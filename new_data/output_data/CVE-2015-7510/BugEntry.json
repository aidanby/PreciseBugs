{"buggy_code": ["/*-*- Mode: C; c-basic-offset: 8; indent-tabs-mode: nil -*-*/\n\n/***\n  This file is part of systemd.\n\n  Copyright 2014 Lennart Poettering\n\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <http://www.gnu.org/licenses/>.\n***/\n\n#include <netdb.h>\n#include <nss.h>\n\n#include \"sd-bus.h\"\n#include \"sd-login.h\"\n\n#include \"alloc-util.h\"\n#include \"bus-common-errors.h\"\n#include \"bus-util.h\"\n#include \"hostname-util.h\"\n#include \"in-addr-util.h\"\n#include \"macro.h\"\n#include \"nss-util.h\"\n#include \"string-util.h\"\n#include \"user-util.h\"\n#include \"util.h\"\n\nNSS_GETHOSTBYNAME_PROTOTYPES(mymachines);\nNSS_GETPW_PROTOTYPES(mymachines);\nNSS_GETGR_PROTOTYPES(mymachines);\n\nstatic int count_addresses(sd_bus_message *m, int af, unsigned *ret) {\n        unsigned c = 0;\n        int r;\n\n        assert(m);\n        assert(ret);\n\n        while ((r = sd_bus_message_enter_container(m, 'r', \"iay\")) > 0) {\n                int family;\n\n                r = sd_bus_message_read(m, \"i\", &family);\n                if (r < 0)\n                        return r;\n\n                r = sd_bus_message_skip(m, \"ay\");\n                if (r < 0)\n                        return r;\n\n                r = sd_bus_message_exit_container(m);\n                if (r < 0)\n                        return r;\n\n                if (af != AF_UNSPEC && family != af)\n                        continue;\n\n                c ++;\n        }\n        if (r < 0)\n                return r;\n\n        r = sd_bus_message_rewind(m, false);\n        if (r < 0)\n                return r;\n\n        *ret = c;\n        return 0;\n}\n\nenum nss_status _nss_mymachines_gethostbyname4_r(\n                const char *name,\n                struct gaih_addrtuple **pat,\n                char *buffer, size_t buflen,\n                int *errnop, int *h_errnop,\n                int32_t *ttlp) {\n\n        struct gaih_addrtuple *r_tuple, *r_tuple_first = NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        _cleanup_free_ int *ifindices = NULL;\n        _cleanup_free_ char *class = NULL;\n        size_t l, ms, idx;\n        unsigned i = 0, c = 0;\n        char *r_name;\n        int n_ifindices, r;\n\n        assert(name);\n        assert(pat);\n        assert(buffer);\n        assert(errnop);\n        assert(h_errnop);\n\n        r = sd_machine_get_class(name, &class);\n        if (r < 0)\n                goto fail;\n        if (!streq(class, \"container\")) {\n                r = -ENOTTY;\n                goto fail;\n        }\n\n        n_ifindices = sd_machine_get_ifindices(name, &ifindices);\n        if (n_ifindices < 0) {\n                r = n_ifindices;\n                goto fail;\n        }\n\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"GetMachineAddresses\",\n                               NULL,\n                               &reply,\n                               \"s\", name);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_message_enter_container(reply, 'a', \"(iay)\");\n        if (r < 0)\n                goto fail;\n\n        r = count_addresses(reply, AF_UNSPEC, &c);\n        if (r < 0)\n                goto fail;\n\n        if (c <= 0) {\n                *errnop = ESRCH;\n                *h_errnop = HOST_NOT_FOUND;\n                return NSS_STATUS_NOTFOUND;\n        }\n\n        l = strlen(name);\n        ms = ALIGN(l+1) + ALIGN(sizeof(struct gaih_addrtuple)) * c;\n        if (buflen < ms) {\n                *errnop = ENOMEM;\n                *h_errnop = TRY_AGAIN;\n                return NSS_STATUS_TRYAGAIN;\n        }\n\n        /* First, append name */\n        r_name = buffer;\n        memcpy(r_name, name, l+1);\n        idx = ALIGN(l+1);\n\n        /* Second, append addresses */\n        r_tuple_first = (struct gaih_addrtuple*) (buffer + idx);\n        while ((r = sd_bus_message_enter_container(reply, 'r', \"iay\")) > 0) {\n                int family;\n                const void *a;\n                size_t sz;\n\n                r = sd_bus_message_read(reply, \"i\", &family);\n                if (r < 0)\n                        goto fail;\n\n                r = sd_bus_message_read_array(reply, 'y', &a, &sz);\n                if (r < 0)\n                        goto fail;\n\n                r = sd_bus_message_exit_container(reply);\n                if (r < 0)\n                        goto fail;\n\n                if (!IN_SET(family, AF_INET, AF_INET6)) {\n                        r = -EAFNOSUPPORT;\n                        goto fail;\n                }\n\n                if (sz != FAMILY_ADDRESS_SIZE(family)) {\n                        r = -EINVAL;\n                        goto fail;\n                }\n\n                r_tuple = (struct gaih_addrtuple*) (buffer + idx);\n                r_tuple->next = i == c-1 ? NULL : (struct gaih_addrtuple*) ((char*) r_tuple + ALIGN(sizeof(struct gaih_addrtuple)));\n                r_tuple->name = r_name;\n                r_tuple->family = family;\n                r_tuple->scopeid = n_ifindices == 1 ? ifindices[0] : 0;\n                memcpy(r_tuple->addr, a, sz);\n\n                idx += ALIGN(sizeof(struct gaih_addrtuple));\n                i++;\n        }\n\n        assert(i == c);\n\n        r = sd_bus_message_exit_container(reply);\n        if (r < 0)\n                goto fail;\n\n        assert(idx == ms);\n\n        if (*pat)\n                **pat = *r_tuple_first;\n        else\n                *pat = r_tuple_first;\n\n        if (ttlp)\n                *ttlp = 0;\n\n        /* Explicitly reset all error variables */\n        *errnop = 0;\n        *h_errnop = NETDB_SUCCESS;\n        h_errno = 0;\n\n        return NSS_STATUS_SUCCESS;\n\nfail:\n        *errnop = -r;\n        *h_errnop = NO_DATA;\n        return NSS_STATUS_UNAVAIL;\n}\n\nenum nss_status _nss_mymachines_gethostbyname3_r(\n                const char *name,\n                int af,\n                struct hostent *result,\n                char *buffer, size_t buflen,\n                int *errnop, int *h_errnop,\n                int32_t *ttlp,\n                char **canonp) {\n\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        _cleanup_free_ char *class = NULL;\n        unsigned c = 0, i = 0;\n        char *r_name, *r_aliases, *r_addr, *r_addr_list;\n        size_t l, idx, ms, alen;\n        int r;\n\n        assert(name);\n        assert(result);\n        assert(buffer);\n        assert(errnop);\n        assert(h_errnop);\n\n        if (af == AF_UNSPEC)\n                af = AF_INET;\n\n        if (af != AF_INET && af != AF_INET6) {\n                r = -EAFNOSUPPORT;\n                goto fail;\n        }\n\n        r = sd_machine_get_class(name, &class);\n        if (r < 0)\n                goto fail;\n        if (!streq(class, \"container\")) {\n                r = -ENOTTY;\n                goto fail;\n        }\n\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"GetMachineAddresses\",\n                               NULL,\n                               &reply,\n                               \"s\", name);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_message_enter_container(reply, 'a', \"(iay)\");\n        if (r < 0)\n                goto fail;\n\n        r = count_addresses(reply, af, &c);\n        if (r < 0)\n                goto fail;\n\n        if (c <= 0) {\n                *errnop = ENOENT;\n                *h_errnop = HOST_NOT_FOUND;\n                return NSS_STATUS_NOTFOUND;\n        }\n\n        alen = FAMILY_ADDRESS_SIZE(af);\n        l = strlen(name);\n\n        ms = ALIGN(l+1) + c * ALIGN(alen) + (c+2) * sizeof(char*);\n\n        if (buflen < ms) {\n                *errnop = ENOMEM;\n                *h_errnop = NO_RECOVERY;\n                return NSS_STATUS_TRYAGAIN;\n        }\n\n        /* First, append name */\n        r_name = buffer;\n        memcpy(r_name, name, l+1);\n        idx = ALIGN(l+1);\n\n        /* Second, create aliases array */\n        r_aliases = buffer + idx;\n        ((char**) r_aliases)[0] = NULL;\n        idx += sizeof(char*);\n\n        /* Third, append addresses */\n        r_addr = buffer + idx;\n        while ((r = sd_bus_message_enter_container(reply, 'r', \"iay\")) > 0) {\n                int family;\n                const void *a;\n                size_t sz;\n\n                r = sd_bus_message_read(reply, \"i\", &family);\n                if (r < 0)\n                        goto fail;\n\n                r = sd_bus_message_read_array(reply, 'y', &a, &sz);\n                if (r < 0)\n                        goto fail;\n\n                r = sd_bus_message_exit_container(reply);\n                if (r < 0)\n                        goto fail;\n\n                if (family != af)\n                        continue;\n\n                if (sz != alen) {\n                        r = -EINVAL;\n                        goto fail;\n                }\n\n                memcpy(r_addr + i*ALIGN(alen), a, alen);\n                i++;\n        }\n\n        assert(i == c);\n        idx += c * ALIGN(alen);\n\n        r = sd_bus_message_exit_container(reply);\n        if (r < 0)\n                goto fail;\n\n        /* Third, append address pointer array */\n        r_addr_list = buffer + idx;\n        for (i = 0; i < c; i++)\n                ((char**) r_addr_list)[i] = r_addr + i*ALIGN(alen);\n\n        ((char**) r_addr_list)[i] = NULL;\n        idx += (c+1) * sizeof(char*);\n\n        assert(idx == ms);\n\n        result->h_name = r_name;\n        result->h_aliases = (char**) r_aliases;\n        result->h_addrtype = af;\n        result->h_length = alen;\n        result->h_addr_list = (char**) r_addr_list;\n\n        if (ttlp)\n                *ttlp = 0;\n\n        if (canonp)\n                *canonp = r_name;\n\n        /* Explicitly reset all error variables */\n        *errnop = 0;\n        *h_errnop = NETDB_SUCCESS;\n        h_errno = 0;\n\n        return NSS_STATUS_SUCCESS;\n\nfail:\n        *errnop = -r;\n        *h_errnop = NO_DATA;\n        return NSS_STATUS_UNAVAIL;\n}\n\nNSS_GETHOSTBYNAME_FALLBACKS(mymachines);\n\nenum nss_status _nss_mymachines_getpwnam_r(\n                const char *name,\n                struct passwd *pwd,\n                char *buffer, size_t buflen,\n                int *errnop) {\n\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *p, *e, *machine;\n        uint32_t mapped;\n        uid_t uid;\n        size_t l;\n        int r;\n\n        assert(name);\n        assert(pwd);\n\n        p = startswith(name, \"vu-\");\n        if (!p)\n                goto not_found;\n\n        e = strrchr(p, '-');\n        if (!e || e == p)\n                goto not_found;\n\n        r = parse_uid(e + 1, &uid);\n        if (r < 0)\n                goto not_found;\n\n        machine = strndupa(p, e - p);\n        if (!machine_name_is_valid(machine))\n                goto not_found;\n\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"MapFromMachineUser\",\n                               &error,\n                               &reply,\n                               \"su\",\n                               machine, (uint32_t) uid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_USER_MAPPING))\n                        goto not_found;\n\n                goto fail;\n        }\n\n        r = sd_bus_message_read(reply, \"u\", &mapped);\n        if (r < 0)\n                goto fail;\n\n        l = strlen(name);\n        if (buflen < l+1) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n\n        memcpy(buffer, name, l+1);\n\n        pwd->pw_name = buffer;\n        pwd->pw_uid = mapped;\n        pwd->pw_gid = 65534; /* nobody */\n        pwd->pw_gecos = buffer;\n        pwd->pw_passwd = (char*) \"*\"; /* locked */\n        pwd->pw_dir = (char*) \"/\";\n        pwd->pw_shell = (char*) \"/sbin/nologin\";\n\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\n\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\n\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}\n\nenum nss_status _nss_mymachines_getpwuid_r(\n                uid_t uid,\n                struct passwd *pwd,\n                char *buffer, size_t buflen,\n                int *errnop) {\n\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *machine, *object;\n        uint32_t mapped;\n        int r;\n\n        if (!uid_is_valid(uid)) {\n                r = -EINVAL;\n                goto fail;\n        }\n\n        /* We consider all uids < 65536 host uids */\n        if (uid < 0x10000)\n                goto not_found;\n\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"MapToMachineUser\",\n                               &error,\n                               &reply,\n                               \"u\",\n                               (uint32_t) uid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_USER_MAPPING))\n                        goto not_found;\n\n                goto fail;\n        }\n\n        r = sd_bus_message_read(reply, \"sou\", &machine, &object, &mapped);\n        if (r < 0)\n                goto fail;\n\n        if (snprintf(buffer, buflen, \"vu-%s-\" UID_FMT, machine, (uid_t) mapped) >= (int) buflen) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n\n        pwd->pw_name = buffer;\n        pwd->pw_uid = uid;\n        pwd->pw_gid = 65534; /* nobody */\n        pwd->pw_gecos = buffer;\n        pwd->pw_passwd = (char*) \"*\"; /* locked */\n        pwd->pw_dir = (char*) \"/\";\n        pwd->pw_shell = (char*) \"/sbin/nologin\";\n\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\n\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\n\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}\n\nenum nss_status _nss_mymachines_getgrnam_r(\n                const char *name,\n                struct group *gr,\n                char *buffer, size_t buflen,\n                int *errnop) {\n\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *p, *e, *machine;\n        uint32_t mapped;\n        uid_t gid;\n        size_t l;\n        int r;\n\n        assert(name);\n        assert(gr);\n\n        p = startswith(name, \"vg-\");\n        if (!p)\n                goto not_found;\n\n        e = strrchr(p, '-');\n        if (!e || e == p)\n                goto not_found;\n\n        r = parse_gid(e + 1, &gid);\n        if (r < 0)\n                goto not_found;\n\n        machine = strndupa(p, e - p);\n        if (!machine_name_is_valid(machine))\n                goto not_found;\n\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"MapFromMachineGroup\",\n                               &error,\n                               &reply,\n                               \"su\",\n                               machine, (uint32_t) gid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_GROUP_MAPPING))\n                        goto not_found;\n\n                goto fail;\n        }\n\n        r = sd_bus_message_read(reply, \"u\", &mapped);\n        if (r < 0)\n                goto fail;\n\n        l = sizeof(char*) + strlen(name) + 1;\n        if (buflen < l) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n\n        memzero(buffer, sizeof(char*));\n        strcpy(buffer + sizeof(char*), name);\n\n        gr->gr_name = buffer + sizeof(char*);\n        gr->gr_gid = gid;\n        gr->gr_passwd = (char*) \"*\"; /* locked */\n        gr->gr_mem = (char**) buffer;\n\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\n\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\n\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}\n\nenum nss_status _nss_mymachines_getgrgid_r(\n                gid_t gid,\n                struct group *gr,\n                char *buffer, size_t buflen,\n                int *errnop) {\n\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *machine, *object;\n        uint32_t mapped;\n        int r;\n\n        if (!gid_is_valid(gid)) {\n                r = -EINVAL;\n                goto fail;\n        }\n\n        /* We consider all gids < 65536 host gids */\n        if (gid < 0x10000)\n                goto not_found;\n\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"MapToMachineGroup\",\n                               &error,\n                               &reply,\n                               \"u\",\n                               (uint32_t) gid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_GROUP_MAPPING))\n                        goto not_found;\n\n                goto fail;\n        }\n\n        r = sd_bus_message_read(reply, \"sou\", &machine, &object, &mapped);\n        if (r < 0)\n                goto fail;\n\n        if (buflen < sizeof(char*) + 1) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n\n        memzero(buffer, sizeof(char*));\n        if (snprintf(buffer + sizeof(char*), buflen - sizeof(char*), \"vg-%s-\" GID_FMT, machine, (gid_t) mapped) >= (int) buflen) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n\n        gr->gr_name = buffer + sizeof(char*);\n        gr->gr_gid = gid;\n        gr->gr_passwd = (char*) \"*\"; /* locked */\n        gr->gr_mem = (char**) buffer;\n\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\n\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\n\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}\n"], "fixing_code": ["/*-*- Mode: C; c-basic-offset: 8; indent-tabs-mode: nil -*-*/\n\n/***\n  This file is part of systemd.\n\n  Copyright 2014 Lennart Poettering\n\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <http://www.gnu.org/licenses/>.\n***/\n\n#include <netdb.h>\n#include <nss.h>\n\n#include \"sd-bus.h\"\n#include \"sd-login.h\"\n\n#include \"alloc-util.h\"\n#include \"bus-common-errors.h\"\n#include \"bus-util.h\"\n#include \"hostname-util.h\"\n#include \"in-addr-util.h\"\n#include \"macro.h\"\n#include \"nss-util.h\"\n#include \"string-util.h\"\n#include \"user-util.h\"\n#include \"util.h\"\n\nNSS_GETHOSTBYNAME_PROTOTYPES(mymachines);\nNSS_GETPW_PROTOTYPES(mymachines);\nNSS_GETGR_PROTOTYPES(mymachines);\n\nstatic int count_addresses(sd_bus_message *m, int af, unsigned *ret) {\n        unsigned c = 0;\n        int r;\n\n        assert(m);\n        assert(ret);\n\n        while ((r = sd_bus_message_enter_container(m, 'r', \"iay\")) > 0) {\n                int family;\n\n                r = sd_bus_message_read(m, \"i\", &family);\n                if (r < 0)\n                        return r;\n\n                r = sd_bus_message_skip(m, \"ay\");\n                if (r < 0)\n                        return r;\n\n                r = sd_bus_message_exit_container(m);\n                if (r < 0)\n                        return r;\n\n                if (af != AF_UNSPEC && family != af)\n                        continue;\n\n                c ++;\n        }\n        if (r < 0)\n                return r;\n\n        r = sd_bus_message_rewind(m, false);\n        if (r < 0)\n                return r;\n\n        *ret = c;\n        return 0;\n}\n\nenum nss_status _nss_mymachines_gethostbyname4_r(\n                const char *name,\n                struct gaih_addrtuple **pat,\n                char *buffer, size_t buflen,\n                int *errnop, int *h_errnop,\n                int32_t *ttlp) {\n\n        struct gaih_addrtuple *r_tuple, *r_tuple_first = NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        _cleanup_free_ int *ifindices = NULL;\n        _cleanup_free_ char *class = NULL;\n        size_t l, ms, idx;\n        unsigned i = 0, c = 0;\n        char *r_name;\n        int n_ifindices, r;\n\n        assert(name);\n        assert(pat);\n        assert(buffer);\n        assert(errnop);\n        assert(h_errnop);\n\n        r = sd_machine_get_class(name, &class);\n        if (r < 0)\n                goto fail;\n        if (!streq(class, \"container\")) {\n                r = -ENOTTY;\n                goto fail;\n        }\n\n        n_ifindices = sd_machine_get_ifindices(name, &ifindices);\n        if (n_ifindices < 0) {\n                r = n_ifindices;\n                goto fail;\n        }\n\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"GetMachineAddresses\",\n                               NULL,\n                               &reply,\n                               \"s\", name);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_message_enter_container(reply, 'a', \"(iay)\");\n        if (r < 0)\n                goto fail;\n\n        r = count_addresses(reply, AF_UNSPEC, &c);\n        if (r < 0)\n                goto fail;\n\n        if (c <= 0) {\n                *errnop = ESRCH;\n                *h_errnop = HOST_NOT_FOUND;\n                return NSS_STATUS_NOTFOUND;\n        }\n\n        l = strlen(name);\n        ms = ALIGN(l+1) + ALIGN(sizeof(struct gaih_addrtuple)) * c;\n        if (buflen < ms) {\n                *errnop = ENOMEM;\n                *h_errnop = TRY_AGAIN;\n                return NSS_STATUS_TRYAGAIN;\n        }\n\n        /* First, append name */\n        r_name = buffer;\n        memcpy(r_name, name, l+1);\n        idx = ALIGN(l+1);\n\n        /* Second, append addresses */\n        r_tuple_first = (struct gaih_addrtuple*) (buffer + idx);\n        while ((r = sd_bus_message_enter_container(reply, 'r', \"iay\")) > 0) {\n                int family;\n                const void *a;\n                size_t sz;\n\n                r = sd_bus_message_read(reply, \"i\", &family);\n                if (r < 0)\n                        goto fail;\n\n                r = sd_bus_message_read_array(reply, 'y', &a, &sz);\n                if (r < 0)\n                        goto fail;\n\n                r = sd_bus_message_exit_container(reply);\n                if (r < 0)\n                        goto fail;\n\n                if (!IN_SET(family, AF_INET, AF_INET6)) {\n                        r = -EAFNOSUPPORT;\n                        goto fail;\n                }\n\n                if (sz != FAMILY_ADDRESS_SIZE(family)) {\n                        r = -EINVAL;\n                        goto fail;\n                }\n\n                r_tuple = (struct gaih_addrtuple*) (buffer + idx);\n                r_tuple->next = i == c-1 ? NULL : (struct gaih_addrtuple*) ((char*) r_tuple + ALIGN(sizeof(struct gaih_addrtuple)));\n                r_tuple->name = r_name;\n                r_tuple->family = family;\n                r_tuple->scopeid = n_ifindices == 1 ? ifindices[0] : 0;\n                memcpy(r_tuple->addr, a, sz);\n\n                idx += ALIGN(sizeof(struct gaih_addrtuple));\n                i++;\n        }\n\n        assert(i == c);\n\n        r = sd_bus_message_exit_container(reply);\n        if (r < 0)\n                goto fail;\n\n        assert(idx == ms);\n\n        if (*pat)\n                **pat = *r_tuple_first;\n        else\n                *pat = r_tuple_first;\n\n        if (ttlp)\n                *ttlp = 0;\n\n        /* Explicitly reset all error variables */\n        *errnop = 0;\n        *h_errnop = NETDB_SUCCESS;\n        h_errno = 0;\n\n        return NSS_STATUS_SUCCESS;\n\nfail:\n        *errnop = -r;\n        *h_errnop = NO_DATA;\n        return NSS_STATUS_UNAVAIL;\n}\n\nenum nss_status _nss_mymachines_gethostbyname3_r(\n                const char *name,\n                int af,\n                struct hostent *result,\n                char *buffer, size_t buflen,\n                int *errnop, int *h_errnop,\n                int32_t *ttlp,\n                char **canonp) {\n\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        _cleanup_free_ char *class = NULL;\n        unsigned c = 0, i = 0;\n        char *r_name, *r_aliases, *r_addr, *r_addr_list;\n        size_t l, idx, ms, alen;\n        int r;\n\n        assert(name);\n        assert(result);\n        assert(buffer);\n        assert(errnop);\n        assert(h_errnop);\n\n        if (af == AF_UNSPEC)\n                af = AF_INET;\n\n        if (af != AF_INET && af != AF_INET6) {\n                r = -EAFNOSUPPORT;\n                goto fail;\n        }\n\n        r = sd_machine_get_class(name, &class);\n        if (r < 0)\n                goto fail;\n        if (!streq(class, \"container\")) {\n                r = -ENOTTY;\n                goto fail;\n        }\n\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"GetMachineAddresses\",\n                               NULL,\n                               &reply,\n                               \"s\", name);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_message_enter_container(reply, 'a', \"(iay)\");\n        if (r < 0)\n                goto fail;\n\n        r = count_addresses(reply, af, &c);\n        if (r < 0)\n                goto fail;\n\n        if (c <= 0) {\n                *errnop = ENOENT;\n                *h_errnop = HOST_NOT_FOUND;\n                return NSS_STATUS_NOTFOUND;\n        }\n\n        alen = FAMILY_ADDRESS_SIZE(af);\n        l = strlen(name);\n\n        ms = ALIGN(l+1) + c * ALIGN(alen) + (c+2) * sizeof(char*);\n\n        if (buflen < ms) {\n                *errnop = ENOMEM;\n                *h_errnop = NO_RECOVERY;\n                return NSS_STATUS_TRYAGAIN;\n        }\n\n        /* First, append name */\n        r_name = buffer;\n        memcpy(r_name, name, l+1);\n        idx = ALIGN(l+1);\n\n        /* Second, create aliases array */\n        r_aliases = buffer + idx;\n        ((char**) r_aliases)[0] = NULL;\n        idx += sizeof(char*);\n\n        /* Third, append addresses */\n        r_addr = buffer + idx;\n        while ((r = sd_bus_message_enter_container(reply, 'r', \"iay\")) > 0) {\n                int family;\n                const void *a;\n                size_t sz;\n\n                r = sd_bus_message_read(reply, \"i\", &family);\n                if (r < 0)\n                        goto fail;\n\n                r = sd_bus_message_read_array(reply, 'y', &a, &sz);\n                if (r < 0)\n                        goto fail;\n\n                r = sd_bus_message_exit_container(reply);\n                if (r < 0)\n                        goto fail;\n\n                if (family != af)\n                        continue;\n\n                if (sz != alen) {\n                        r = -EINVAL;\n                        goto fail;\n                }\n\n                memcpy(r_addr + i*ALIGN(alen), a, alen);\n                i++;\n        }\n\n        assert(i == c);\n        idx += c * ALIGN(alen);\n\n        r = sd_bus_message_exit_container(reply);\n        if (r < 0)\n                goto fail;\n\n        /* Third, append address pointer array */\n        r_addr_list = buffer + idx;\n        for (i = 0; i < c; i++)\n                ((char**) r_addr_list)[i] = r_addr + i*ALIGN(alen);\n\n        ((char**) r_addr_list)[i] = NULL;\n        idx += (c+1) * sizeof(char*);\n\n        assert(idx == ms);\n\n        result->h_name = r_name;\n        result->h_aliases = (char**) r_aliases;\n        result->h_addrtype = af;\n        result->h_length = alen;\n        result->h_addr_list = (char**) r_addr_list;\n\n        if (ttlp)\n                *ttlp = 0;\n\n        if (canonp)\n                *canonp = r_name;\n\n        /* Explicitly reset all error variables */\n        *errnop = 0;\n        *h_errnop = NETDB_SUCCESS;\n        h_errno = 0;\n\n        return NSS_STATUS_SUCCESS;\n\nfail:\n        *errnop = -r;\n        *h_errnop = NO_DATA;\n        return NSS_STATUS_UNAVAIL;\n}\n\nNSS_GETHOSTBYNAME_FALLBACKS(mymachines);\n\nenum nss_status _nss_mymachines_getpwnam_r(\n                const char *name,\n                struct passwd *pwd,\n                char *buffer, size_t buflen,\n                int *errnop) {\n\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *p, *e, *machine;\n        uint32_t mapped;\n        uid_t uid;\n        size_t l;\n        int r;\n\n        assert(name);\n        assert(pwd);\n\n        p = startswith(name, \"vu-\");\n        if (!p)\n                goto not_found;\n\n        e = strrchr(p, '-');\n        if (!e || e == p)\n                goto not_found;\n\n        if (e - p > HOST_NAME_MAX - 1) /* -1 for the last dash */\n                goto not_found;\n\n        r = parse_uid(e + 1, &uid);\n        if (r < 0)\n                goto not_found;\n\n        machine = strndupa(p, e - p);\n        if (!machine_name_is_valid(machine))\n                goto not_found;\n\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"MapFromMachineUser\",\n                               &error,\n                               &reply,\n                               \"su\",\n                               machine, (uint32_t) uid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_USER_MAPPING))\n                        goto not_found;\n\n                goto fail;\n        }\n\n        r = sd_bus_message_read(reply, \"u\", &mapped);\n        if (r < 0)\n                goto fail;\n\n        l = strlen(name);\n        if (buflen < l+1) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n\n        memcpy(buffer, name, l+1);\n\n        pwd->pw_name = buffer;\n        pwd->pw_uid = mapped;\n        pwd->pw_gid = 65534; /* nobody */\n        pwd->pw_gecos = buffer;\n        pwd->pw_passwd = (char*) \"*\"; /* locked */\n        pwd->pw_dir = (char*) \"/\";\n        pwd->pw_shell = (char*) \"/sbin/nologin\";\n\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\n\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\n\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}\n\nenum nss_status _nss_mymachines_getpwuid_r(\n                uid_t uid,\n                struct passwd *pwd,\n                char *buffer, size_t buflen,\n                int *errnop) {\n\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *machine, *object;\n        uint32_t mapped;\n        int r;\n\n        if (!uid_is_valid(uid)) {\n                r = -EINVAL;\n                goto fail;\n        }\n\n        /* We consider all uids < 65536 host uids */\n        if (uid < 0x10000)\n                goto not_found;\n\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"MapToMachineUser\",\n                               &error,\n                               &reply,\n                               \"u\",\n                               (uint32_t) uid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_USER_MAPPING))\n                        goto not_found;\n\n                goto fail;\n        }\n\n        r = sd_bus_message_read(reply, \"sou\", &machine, &object, &mapped);\n        if (r < 0)\n                goto fail;\n\n        if (snprintf(buffer, buflen, \"vu-%s-\" UID_FMT, machine, (uid_t) mapped) >= (int) buflen) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n\n        pwd->pw_name = buffer;\n        pwd->pw_uid = uid;\n        pwd->pw_gid = 65534; /* nobody */\n        pwd->pw_gecos = buffer;\n        pwd->pw_passwd = (char*) \"*\"; /* locked */\n        pwd->pw_dir = (char*) \"/\";\n        pwd->pw_shell = (char*) \"/sbin/nologin\";\n\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\n\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\n\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}\n\nenum nss_status _nss_mymachines_getgrnam_r(\n                const char *name,\n                struct group *gr,\n                char *buffer, size_t buflen,\n                int *errnop) {\n\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *p, *e, *machine;\n        uint32_t mapped;\n        uid_t gid;\n        size_t l;\n        int r;\n\n        assert(name);\n        assert(gr);\n\n        p = startswith(name, \"vg-\");\n        if (!p)\n                goto not_found;\n\n        e = strrchr(p, '-');\n        if (!e || e == p)\n                goto not_found;\n\n        if (e - p > HOST_NAME_MAX - 1)  /* -1 for the last dash */\n                goto not_found;\n\n        r = parse_gid(e + 1, &gid);\n        if (r < 0)\n                goto not_found;\n\n        machine = strndupa(p, e - p);\n        if (!machine_name_is_valid(machine))\n                goto not_found;\n\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"MapFromMachineGroup\",\n                               &error,\n                               &reply,\n                               \"su\",\n                               machine, (uint32_t) gid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_GROUP_MAPPING))\n                        goto not_found;\n\n                goto fail;\n        }\n\n        r = sd_bus_message_read(reply, \"u\", &mapped);\n        if (r < 0)\n                goto fail;\n\n        l = sizeof(char*) + strlen(name) + 1;\n        if (buflen < l) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n\n        memzero(buffer, sizeof(char*));\n        strcpy(buffer + sizeof(char*), name);\n\n        gr->gr_name = buffer + sizeof(char*);\n        gr->gr_gid = gid;\n        gr->gr_passwd = (char*) \"*\"; /* locked */\n        gr->gr_mem = (char**) buffer;\n\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\n\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\n\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}\n\nenum nss_status _nss_mymachines_getgrgid_r(\n                gid_t gid,\n                struct group *gr,\n                char *buffer, size_t buflen,\n                int *errnop) {\n\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *machine, *object;\n        uint32_t mapped;\n        int r;\n\n        if (!gid_is_valid(gid)) {\n                r = -EINVAL;\n                goto fail;\n        }\n\n        /* We consider all gids < 65536 host gids */\n        if (gid < 0x10000)\n                goto not_found;\n\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"MapToMachineGroup\",\n                               &error,\n                               &reply,\n                               \"u\",\n                               (uint32_t) gid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_GROUP_MAPPING))\n                        goto not_found;\n\n                goto fail;\n        }\n\n        r = sd_bus_message_read(reply, \"sou\", &machine, &object, &mapped);\n        if (r < 0)\n                goto fail;\n\n        if (buflen < sizeof(char*) + 1) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n\n        memzero(buffer, sizeof(char*));\n        if (snprintf(buffer + sizeof(char*), buflen - sizeof(char*), \"vg-%s-\" GID_FMT, machine, (gid_t) mapped) >= (int) buflen) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n\n        gr->gr_name = buffer + sizeof(char*);\n        gr->gr_gid = gid;\n        gr->gr_passwd = (char*) \"*\"; /* locked */\n        gr->gr_mem = (char**) buffer;\n\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\n\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\n\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}\n"], "filenames": ["src/nss-mymachines/nss-mymachines.c"], "buggy_code_start_loc": [416], "buggy_code_end_loc": [575], "fixing_code_start_loc": [417], "fixing_code_end_loc": [582], "type": "CWE-119", "message": "Stack-based buffer overflow in the getpwnam and getgrnam functions of the NSS module nss-mymachines in systemd.", "other": {"cve": {"id": "CVE-2015-7510", "sourceIdentifier": "secalert@redhat.com", "published": "2017-09-25T21:29:00.727", "lastModified": "2022-01-28T19:12:14.617", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Stack-based buffer overflow in the getpwnam and getgrnam functions of the NSS module nss-mymachines in systemd."}, {"lang": "es", "value": "Existe un desbordamiento de b\u00fafer basado en pila en las funciones getpwnam y getgrnam del m\u00f3dulo NSS nss-mymachines en systemd."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:systemd_project:systemd:223:*:*:*:*:*:*:*", "matchCriteriaId": "299693FA-4A78-4FBC-8F1B-4057D33048DE"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1284642", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/keszybz/systemd/commit/cb31827d62066a04b02111df3052949fda4b6888", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd/issues/2002", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/keszybz/systemd/commit/cb31827d62066a04b02111df3052949fda4b6888"}}