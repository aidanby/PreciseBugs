{"buggy_code": ["#lang scribble/doc\n@(require \"mz.rkt\" racket/sandbox\n          (for-label racket/sandbox\n                     racket/port\n                     (only-in racket/gui make-gui-namespace)\n                     racket/gui/dynamic))\n\n@(define box-eval (make-base-eval))\n@examples[#:hidden #:eval box-eval (require racket/sandbox)]\n\n@title{Sandboxed Evaluation}\n\n@note-lib-only[racket/sandbox]\n\nThe @racketmodname[racket/sandbox] module provides utilities for\ncreating ``sandboxed'' evaluators, which are configured in a\nparticular way and can have restricted resources (memory and time),\nfilesystem and network access, and much more.  Sandboxed evaluators can be\nconfigured through numerous parameters --- and the defaults are set\nfor the common use case where sandboxes are very limited.\n\n@defproc*[([(make-evaluator [language (or/c module-path?\n                                            (list/c 'special symbol?)\n                                            (cons/c 'begin list?))]\n                            [input-program any/c] ...\n                            [#:requires requires \n                                        (listof (or/c module-path? path-string? \n                                                      (cons/c 'for-syntax (listof module-path?))))\n                                        null]\n                            [#:allow-for-require allow-for-require (listof (or/c module-path? path?)) null]\n                            [#:allow-for-load allow-for-load (listof path-string?) null]\n                            [#:allow-read allow-read (listof (or/c module-path? path-string?)) null])\n            (any/c . -> . any)]\n           [(make-module-evaluator [module-decl (or/c syntax? pair? path? input-port? string? bytes?)]\n                                   [#:language   lang  (or/c #f module-path?) #f]\n                                   [#:allow-for-require allow-for-require (listof (or/c module-path? path?)) null]\n                                   [#:allow-for-load allow-for-load (listof path-string?) null]\n                                   [#:allow-read allow-read (listof (or/c module-path? path-string?)) null])\n            (any/c . -> . any)])]{\n\nThe @racket[make-evaluator] function creates an evaluator with a\n@racket[language] and @racket[requires] specification, and starts\nevaluating the given @racket[input-program]s. The\n@racket[make-module-evaluator] function creates an evaluator that\nworks in the context of a given module. The result in either case is a\nfunction for further evaluation.\n\nThe returned evaluator operates in an isolated and limited\nenvironment. In particular, filesystem access is restricted, which may\ninterfere with using modules from the filesystem that are not\nin a @tech{collection}.  See below for\ninformation on the @racket[allow-for-require],\n@racket[allow-for-load], and @racket[allow-read] arguments.  When\n@racket[language] is a module path or when @racket[requires] is\nprovided, the indicated modules are implicitly included in the\n@racket[allow-for-require] list. (For backward compatibility,\nnon-@racket[module-path?] path strings are allowed in\n@racket[requires]; they are implicitly converted to paths before\naddition to @racket[allow-for-require].)\n\nEach @racket[input-program] or @racket[module-decl] argument provides\na program in one of the following forms:\n\n@itemize[\n\n @item{an input port used to read the program;}\n\n @item{a string or a byte string holding the complete input;}\n\n @item{a path that names a file holding the input; or}\n\n @item{an S-expression or a @tech{syntax object}, which is evaluated\n       as with @racket[eval] (see also\n       @racket[get-uncovered-expressions]).}\n]\n\nIn the first three cases above, the program is read using\n@racket[sandbox-reader], with line-counting enabled for sensible error\nmessages, and with @racket['program] as the source (used for testing\ncoverage).  In the last case, the input is expected to be the complete\nprogram, and is converted to a @tech{syntax object} (using\n@racket['program] as the source), unless it already is a @tech{syntax\nobject}.\n\nThe returned evaluator function accepts additional expressions\n(each time it is called) in essentially the same form: a string or\nbyte string holding a sequence of expressions, a path for a file\nholding expressions, an S-expression, or a @tech{syntax object}.  If\nthe evaluator receives an @racket[eof] value, it is terminated and\nraises errors thereafter.  See also @racket[kill-evaluator], which\nterminates the evaluator without raising an exception.\n\nFor @racket[make-evaluator], multiple @racket[input-program]s are\neffectively concatenated to form a single program. The way that the\n@racket[input-program]s are evaluated depends on the @racket[language]\nargument:\n\n@itemize[\n\n @item{The @racket[language] argument can be a module path (i.e., a\n       datum that matches the grammar for @racket[_module-path] of\n       @racket[require]).\n\n       In this case, the @racket[input-program]s are automatically\n       wrapped in a @racket[module], and the resulting evaluator works\n       within the resulting module's namespace.}\n\n @item{The @racket[language] argument can be a list starting with\n       @racket['special], which indicates a built-in language with\n       special input configuration. The possible values are\n       @racket['(special r5rs)] or a value indicating a teaching\n       language: @racket['(special beginner)], @racket['(special\n       beginner-abbr)], @racket['(special intermediate)],\n       @racket['(special intermediate-lambda)], or @racket['(special\n       advanced)].\n\n       In this case, the @racket[input-program]s are automatically\n       wrapped in a @racket[module], and the resulting evaluator works\n       within the resulting module's namespace. In addition, certain\n       parameters (such as such as @racket[read-accept-infix-dot]) are\n       set to customize reading programs from strings and ports.\n\n       This option is provided mainly for older test systems. Using\n       @racket[make-module-evaluator] with input starting with\n       @racketmodfont{#lang} is generally better.}\n\n @item{Finally, @racket[language] can be a list whose first element is\n       @racket['begin].\n\n       In this case, a new namespace is created using\n       @racket[sandbox-namespace-specs], which by default creates a\n       new namespace using @racket[sandbox-make-namespace] (which, in\n       turn, uses @racket[make-base-namespace] or\n       @racket[make-gui-namespace] depending on\n       @racket[sandbox-gui-available] and @racket[gui-available?]).\n\n       In the new namespace, @racket[language] is evaluated as an\n       expression to further initialize the namespace.}\n\n]\n\nThe @racket[requires] list adds additional imports to the module or\nnamespace for the @racket[input-program]s, even in the case that\n@racket[require] is not made available through the @racket[language].\n\nThe following examples illustrate the difference between an evaluator\nthat puts the program in a module and one that merely initializes a\ntop-level namespace:\n\n@examples[#:label #f\n#:eval box-eval\n(eval:error\n (define base-module-eval \n   (code:comment @#,t{a module cannot have free variables...})\n   (make-evaluator 'racket/base '(define (f) later))))\n(define base-module-eval \n  (make-evaluator 'racket/base '(define (f) later)\n                               '(define later 5)))\n(base-module-eval '(f))\n\n(define base-top-eval \n  (code:comment @#,t{non-module code can have free variables:})\n  (make-evaluator '(begin) '(define (f) later)))\n(base-top-eval '(+ 1 2))\n(base-top-eval '(define later 5))\n(base-top-eval '(f))\n]\n\nThe @racket[make-module-evaluator] function is essentially a\nrestriction of @racket[make-evaluator], where the program must be a\nmodule, and all imports are part of the program.  In some cases it is\nuseful to restrict the program to be a module using a specific module\nin its language position --- use the optional @racket[lang] argument\nto specify such a restriction (the default, @racket[#f], means no\nrestriction is enforced). When the program is specified as a path, then\nthe path is implicitly added to the @racket[allow-for-load] list.\n\n@racketblock[\n(define base-module-eval2\n  (code:comment @#,t{equivalent to @racket[base-module-eval]:})\n  (make-module-evaluator '(module m racket/base\n                            (define (f) later)\n                            (define later 5))))\n]\n\nThe @racket[make-module-evaluator] function can be convenient for testing\nmodule files: pass in a path value for the file\nname, and you get back an evaluator in the module's context which you\ncan use with your favorite test facility.\n\nIn all cases, the evaluator operates in an isolated and limited\nenvironment:\n@itemize[\n\n @item{It uses a new custodian and namespace. When \n       @racket[gui-available?] and @racket[sandbox-gui-available] produce\n       true, it is also runs in its own eventspace.}\n\n @item{The evaluator works under the @racket[sandbox-security-guard],\n       which restricts file system and network access.}\n\n @item{The evaluator is contained in a memory-restricted environment,\n       and each evaluation is wrapped in a @racket[call-with-limits]\n       (when memory accounting is available); see also\n       @racket[sandbox-memory-limit], @racket[sandbox-eval-limits] and\n       @racket[set-eval-limits].}\n]\nNote that these limits apply to the creation of the sandbox\nenvironment too --- so, for example, if the memory that is required to\ncreate the sandbox is higher than the limit, then\n@racket[make-evaluator] will fail with a memory limit exception.\n\nThe @racket[allow-for-require] and @racket[allow-for-load] arguments\nadjust filesystem permissions to extend the set of files that\nare usable by the evaluator. Modules that are in a collection\nare automatically accessible, but the @racket[allow-for-require] argument lists\nadditional modules that can be @racket[require]d along with their imports\n(transitively) through a filesystem path. The @racket[allow-for-load] argument\nsimilarly lists files that can\nbe @racket[load]ed. (The precise permissions needed for\n@racket[require] versus @racket[load] can differ.)  The\n@racket[allow-read] argument is for backward compatibility, only; each\n@racket[module-path?] element of @racket[allow-read] is effectively\nmoved to @racket[allow-for-require], while other elements are moved to\n@racket[allow-for-load].\n\nThe sandboxed environment is well isolated, and the evaluator function\nessentially sends it an expression and waits for a result.  This form\nof communication makes it impossible to have nested (or concurrent)\ncalls to a single evaluator.  Usually this is not a problem, but in\nsome cases you can get the evaluator function available inside the\nsandboxed code, for example:\n@examples[#:label #f #:eval box-eval\n(eval:error\n (let ([e (make-evaluator 'racket/base)])\n   (e `(,e 1))))\n]\nAn error will be signaled in such cases.\n\nIf the value of @racket[sandbox-propagate-exceptions] is true (the\ndefault) when the sandbox is created, then exceptions (both syntax and\nrun-time) are propagated as usual to the caller of the evaluation\nfunction (i.e., catch them with @racket[with-handlers]).  If the value\nof @racket[sandbox-propagate-exceptions] is @racket[#f] when the\nsandbox is created, then uncaught exceptions in a sandbox evaluation\ncause the error to be printed to the sandbox's error port, and the\ncaller of the evaluation receives @|void-const|.\n\nFinally, the fact that a sandboxed evaluator accept syntax objects\nmakes it usable as the value for @racket[current-eval], which means\nthat you can easily start a sandboxed read-eval-print-loop:\n\n@racketblock[\n(define e (make-evaluator 'racket/base))\n(parameterize ([current-eval e])\n  (read-eval-print-loop))\n]\n\nNote that in this code only the REPL interactions will be printed to\nthe current output ports; using I/O operations inside the REPL will\nstill use the usual sandbox parameters (defaulting to no I/O).  In\naddition, the code works only from an existing toplevel REPL ---\nspecifically, @racket[read-eval-print-loop] reads a syntax value and\ngives it the lexical context of the current namespace.  Here is a\nvariation that also allows I/O over the current input and output\nports, and works when used from a module (by using a new namespace):\n\n@racketblock[\n(parameterize ([sandbox-input        current-input-port]\n               [sandbox-output       current-output-port]\n               [sandbox-error-output current-error-port]\n               [current-namespace (make-empty-namespace)])\n  (parameterize ([current-eval (make-evaluator 'racket/base)])\n    (read-eval-print-loop)))\n]\n\n}\n\n\n@defproc*[([(exn:fail:sandbox-terminated? [v any/c]) boolean?]\n           [(exn:fail:sandbox-terminated-reason [exn exn:fail:sandbox-terminated?])\n            symbol?])]{\n\nA predicate and accessor for exceptions that are raised when a sandbox\nis terminated.  Once a sandbox raises such an exception, it will\ncontinue to raise it on further evaluation attempts.\n}\n\n@; ----------------------------------------------------------------------\n\n@section{Security Considerations}\n\nAlthough the sandbox is designed to provide a safe environment for executing\nRacket programs with restricted access to system resources, executing untrusted\nprograms in a sandbox still carries some risk. Because a malicious program can\nexercise arbitrary functionality from the Racket runtime and installed collections,\nan attacker who identifies a vulnerability in Racket or an installed collection\nmay be able to escape the sandbox.\n\nTo mitigate this risk, programs that use the sandbox should employ additional\nprecautions when possible. Suggested measures include:\n@itemlist[\n@item{Supplying a custom module language to @racket[make-evaluator] or\n@racket[make-module-evaluator] that gives untrusted code access to only\nthe language constructs it absolutely requires.}\n@item{If untrusted code needs access to installed collections, installing only\nthe collections required by your program.}\n@item{Using operating-system-level security features to provide defense-in-depth\nin case the process running the sandbox is compromised.}\n@item{Making sure your Racket installation and installed packages are up-to-date\nwith the latest release.}\n]\n\n@; ----------------------------------------------------------------------\n\n@section{Customizing Evaluators}\n\nThe sandboxed evaluators that @racket[make-evaluator] creates can be\ncustomized via many parameters.  Most of the configuration parameters\naffect newly created evaluators; changing them has no effect on\nalready-running evaluators.\n\nThe default configuration options are set for a very restricted\nsandboxed environment --- one that is safe to make publicly available.\nFurther customizations might be needed in case more privileges are\nneeded, or if you want tighter restrictions.  Another useful approach\nfor customizing an evaluator is to begin with a relatively\nunrestricted configuration and add the desired restrictions.  This approach is made\npossible by the @racket[call-with-trusted-sandbox-configuration]\nfunction.\n\nThe sandbox environment uses two notions of restricting the time that\nevaluations takes: @tech{shallow time} and @tech{deep\ntime}. @deftech{Shallow time} refers to the immediate execution of an\nexpression. For example, a @tech{shallow time} limit of five seconds\nwould restrict @racket[(sleep 6)] and other computations that take\nlonger than five seconds. @deftech{Deep time} refers to the total\nexecution of the expression and all threads and sub-processes that the\nexpression creates. For example, a @tech{deep time} limit of five\nseconds would restrict @racket[(thread (\u03bb () (sleep 6)))], which\n@tech{shallow time} would not, @emph{as well as} all expressions that\n@tech{shallow time} would restrict. By default, most sandboxes only\nrestrict @tech{shallow time} to facilitate expressions that use\nthreads.\n\n@defproc[(call-with-trusted-sandbox-configuration [thunk (-> any)])\n         any]{\n\nInvokes the @racket[thunk] in a context where sandbox configuration\nparameters are set for minimal restrictions.  More specifically, there\nare no memory or time limits, and the existing existing @tech{inspectors},\n@tech{security guard}, @tech{exit handler}, @tech{logger}, @tech{plumber}, and\n@tech{environment variable set} are used.  (Note that the I/O\nports settings are not included.)}\n\n\n@defparam[sandbox-init-hook thunk (-> any)]{\n\nA @tech{parameter} that determines a thunk to be called for initializing a\nnew evaluator.  The hook is called just before the program is\nevaluated in a newly-created evaluator context.  It can be used to\nsetup environment parameters related to reading, writing, evaluation,\nand so on.  Certain languages (@racket['(special r5rs)] and the\nteaching languages) have initializations specific to the language; the\nhook is used after that initialization, so it can override settings.}\n\n\n@defparam[sandbox-reader proc (any/c . -> . any)]{\n\nA @tech{parameter} that specifies a function that reads all expressions from\n@racket[(current-input-port)].  The function is used to read program\nsource for an evaluator when a string, byte string, or port is\nsupplied.  The reader function receives a value to be used as input\nsource (i.e., the first argument to @racket[read-syntax]), and it\nshould return a list of @tech{syntax objects}.  The default reader\ncalls @racket[read-syntax], accumulating results in a list until it\nreceives @racket[eof].\n\nNote that the reader function is usually called as is, but when it is\nused to read the program input for @racket[make-module-evaluator],\n@racket[read-accept-lang] and @racket[read-accept-reader] are set to\n@racket[#t].}\n\n\n@defparam[sandbox-input in (or/c #f\n                                 string? bytes?\n                                 input-port?\n                                 'pipe\n                                 (-> input-port?))]{\n\nA @tech{parameter} that determines the initial @racket[current-input-port]\nsetting for a newly created evaluator. It defaults to @racket[#f],\nwhich creates an empty port.  The following other values are allowed:\n\n@itemize[\n\n @item{a string or byte string, which is converted to a port using\n       @racket[open-input-string] or @racket[open-input-bytes];}\n\n @item{an input port;}\n\n @item{the symbol @racket['pipe], which triggers the creation of a\n       pipe, where @racket[put-input] can return the output end of the\n       pipe or write directly to it;}\n\n @item{a thunk, which is called to obtain a port (e.g., using\n       @racket[current-input-port] means that the evaluator input is\n       the same as the calling context's input).}\n\n]}\n\n\n@defparam[sandbox-output in (or/c #f\n                                  output-port? \n                                  'pipe\n                                  'bytes\n                                  'string\n                                  (-> output-port?))]{\n\nA @tech{parameter} that determines the initial @racket[current-output-port]\nsetting for a newly created evaluator. It defaults to @racket[#f],\nwhich creates a port that discards all data.  The following other\nvalues are allowed:\n\n@itemize[\n\n @item{an output port, which is used as-is;}\n\n @item{the symbol @racket['bytes], which causes @racket[get-output] to\n       return the complete output as a byte string as long as the\n       evaluator has not yet terminated (so that the size of the bytes\n       can be charged to the evaluator);}\n\n @item{the symbol @racket['string], which is similar to\n       @racket['bytes], but makes @racket[get-output] produce a\n       string;}\n\n @item{the symbol @racket['pipe], which triggers the creation of a\n       pipe, where @racket[get-output] returns the input end of the\n       pipe;}\n\n @item{a thunk, which is called to obtain a port (e.g., using\n       @racket[current-output-port] means that the evaluator output is\n       not diverted).}\n\n]}\n\n\n@defparam[sandbox-error-output in (or/c #f\n                                        output-port? \n                                        'pipe\n                                        'bytes\n                                        'string\n                                        (-> output-port?))]{\n\nLike @racket[sandbox-output], but for the initial\n@racket[current-error-port] value. An evaluator's error output is set\nafter its output, so using @racket[current-output-port] (the parameter\nitself, not its value) for this parameter value means that the error\nport is the same as the evaluator's initial output port.\n\nThe default is @racket[(lambda () (dup-output-port\n(current-error-port)))], which means that the error output of the\ngenerated evaluator goes to the calling context's error port.}\n\n\n@defboolparam[sandbox-coverage-enabled enabled?]{\n\nA @tech{parameter} that controls whether syntactic coverage information is\ncollected by sandbox evaluators.  Use\n@racket[get-uncovered-expressions] to retrieve coverage information.\n\nThe default value is @racket[#f].\n}\n\n\n@defboolparam[sandbox-propagate-breaks propagate?]{\n\nWhen both this boolean parameter and @racket[(break-enabled)] are true, \nbreaking while an evaluator is\nrunning propagates the break signal to the sandboxed\ncontext.  This makes the sandboxed evaluator break, typically, but\nbeware that sandboxed evaluation can capture and avoid the breaks (so\nif safe execution of code is your goal, make sure you use it with a\ntime limit).  Also, beware that a break may be received after the\nevaluator's result, in which case the evaluation result is lost. Finally,\nbeware that a break may be propagated after an evaluator has produced\na result, so that the break is visible on the next interaction with\nthe evaluator (or the break is lost if the evaluator is not used\nfurther). The default is @racket[#t].}\n\n\n@defboolparam[sandbox-propagate-exceptions propagate?]{\n\nA @tech{parameter} that controls how uncaught exceptions during a sandbox\nevaluation are treated. When the parameter value is @racket[#t], \nthen the exception is propagated to the caller of sandbox.\nWhen the parameter value is @racket[#f], the exception message\nis printed to the sandbox's error port, and the caller of the\nsandbox receives @|void-const| for the evaluation. The default\nis @racket[#t].}\n\n\n@defparam[sandbox-namespace-specs spec (cons/c (-> namespace?) \n                                               (listof module-path?))]{\n\nA @tech{parameter} that holds a list of values that specify how to create a\nnamespace for evaluation in @racket[make-evaluator] or\n@racket[make-module-evaluator].  The first item in the list is a thunk\nthat creates the namespace, and the rest are module paths for modules\nto be attached to the created namespace using\n@racket[namespace-attach-module].\n\nThe default is @racket[(list sandbox-make-namespace)].\n\nThe module paths are needed for sharing module instantiations between\nthe sandbox and the caller.  For example, sandbox code that returns\n@racket[posn] values (from the @racketidfont{lang/posn} module) will\nnot be recognized as such by your own code by default, since the\nsandbox will have its own instance of @racketidfont{lang/posn} and\nthus its own struct type for @racket[posn]s.  To be able to use such\nvalues, include @racket['lang/posn] in the list of module paths.\n\nWhen testing code that uses a teaching language, the following piece\nof code can be helpful:\n\n@racketblock[\n(sandbox-namespace-specs\n (let ([specs (sandbox-namespace-specs)])\n   `(,(car specs)\n     ,@(cdr specs)\n     lang/posn\n     ,@(if (gui-available?) '(mrlib/cache-image-snip) '()))))\n]}\n\n\n@defproc[(sandbox-make-namespace) namespace?]{\n\nCalls @racket[make-gui-namespace] when @racket[(sandbox-gui-available)]\nproduces true, @racket[make-base-namespace] otherwise.}\n\n\n@defboolparam[sandbox-gui-available avail?]{\n\nDetermines whether the @racketmodname[racket/gui] module can be used\nwhen a sandbox evaluator is created. If @racket[gui-available?]\nproduces @racket[#f] during the creation of a sandbox evaluator, this\nparameter is forced to @racket[#f] during initialization of the\nsandbox. The default value of the parameter is @racket[#t].\n\nVarious aspects of the library change when the GUI library is\navailable, such as using a new eventspace for each evaluator.}\n\n\n@defparam[sandbox-override-collection-paths paths (listof path-string?)]{\n\nA @tech{parameter} that determines a list of collection directories to prefix\n@racket[current-library-collection-paths] in an evaluator. This\nparameter is useful for cases when you want to test code using an\nalternate, test-friendly version of a collection, for example, testing\ncode that uses a GUI (like the @racket[htdp/world] teachpack) can be\ndone using a fake library that provides the same interface but no\nactual interaction. The default is @racket[null].}\n\n\n@defparam[sandbox-security-guard guard\n          (or/c security-guard? (-> security-guard?))]{\n\nA @tech{parameter} that determines the initial\n@racket[(current-security-guard)] for sandboxed evaluations.  It can\nbe either a security guard, or a function to construct one.  The\ndefault is a function that restricts the access of the current\nsecurity guard by forbidding all filesystem I/O except for\nspecifications in @racket[sandbox-path-permissions], and it uses\n@racket[sandbox-network-guard] for network connections.}\n\n\n@defparam[sandbox-path-permissions perms\n          (listof (list/c (or/c 'execute 'write 'delete \n                                'read-bytecode 'read 'exists)\n                          (or/c byte-regexp? bytes? string? path?)))]{\n\nA @tech{parameter} that configures the behavior of the default sandbox\nsecurity guard by listing paths and access modes that are allowed for\nthem.  The contents of this parameter is a list of specifications,\neach is an access mode and a byte-regexp for paths that are granted this\naccess.\n\nThe access mode symbol is one of: @racket['execute], @racket['write],\n@racket['delete], @racket['read], or @racket['exists].  These symbols\nare in decreasing order: each implies access for the following modes\ntoo (e.g., @racket['read] allows reading or checking for existence).\n\nThe path regexp is used to identify paths that are granted access.  It\ncan also be given as a path (or a string or a byte string), which is\n(made into a complete path, cleansed, simplified, and then) converted\nto a regexp that allows the path and sub-directories; e.g.,\n@racket[\"/foo/bar\"] applies to @racket[\"/foo/bar/baz\"].\n\nAn additional mode symbol, @racket['read-bytecode], is not part of the\nlinear order of these modes.  Specifying this mode is similar to\nspecifying @racket['read], but it is not implied by any other mode.\n(For example, even if you specify @racket['write] for a certain path,\nyou need to also specify @racket['read-bytecode] to grant this\npermission.)  The sandbox usually works in the context of a lower code\ninspector (see @racket[sandbox-make-code-inspector]) which prevents\nloading of untrusted bytecode files --- the sandbox is set-up to allow\nloading bytecode from files that are specified with\n@racket['read-bytecode].  This specification is given by default to\nthe Racket collection hierarchy (including user-specific libraries) and\nto libraries that are explicitly specified in an @racket[#:allow-read]\nargument.  (Note that this applies for loading bytecode files only,\nunder a lower code inspector it is still impossible to use protected\nmodule bindings (see @secref[\"modprotect\"]).)\n\nThe default value is null, but when an evaluator is created, it is\naugmented by @racket['read-bytecode] permissions that make it possible\nto use collection libraries (including\n@racket[sandbox-override-collection-paths]). See\n@racket[make-evaluator] for more information.}\n\n\n@defparam[sandbox-network-guard proc\n          (symbol?\n           (or/c (and/c string? immutable?) #f)\n           (or/c (integer-in 1 65535) #f)\n           (or/c 'server 'client)\n           . -> . any)]{\n\nA @tech{parameter} that specifies a procedure to be used (as is) by the\ndefault @racket[sandbox-security-guard].  The default forbids all\nnetwork connection.}\n\n\n@defparam[sandbox-exit-handler handler (any/c . -> . any)]{\n\nA @tech{parameter} that determines the initial @racket[(exit-handler)] for\nsandboxed evaluations.  The default kills the evaluator with an\nappropriate error message (see\n@racket[exn:fail:sandbox-terminated-reason]).}\n\n\n@defparam[sandbox-memory-limit limit (or/c (>=/c 0) #f)]{\n\nA @tech{parameter} that determines the total memory limit on the sandbox in\nmegabytes (it can hold a rational or a floating point number).  When\nthis limit is exceeded, the sandbox is terminated.  This value is used\nwhen the sandbox is created and the limit cannot be changed\nafterwards.  It defaults to 30mb.  See @racket[sandbox-eval-limits]\nfor per-evaluation limits and a description of how the two limits work\ntogether.\n\nNote that (when memory accounting is enabled) memory is attributed to\nthe highest custodian that refers to it.  This means that if you\ninspect a value that sandboxed evaluation returns outside of the\nsandbox, your own custodian will be charged for it.  To ensure that it\nis charged back to the sandbox, you should remove references to such\nvalues when the code is done inspecting it.\n\nThis policy has an impact on how the sandbox memory limit interacts\nwith the per-expression limit specified by\n@racket[sandbox-eval-limits]: values that are reachable from the\nsandbox, as well as from the interaction will count against the\nsandbox limit.  For example, in the last interaction of this code,\n@racketblock[\n  (define e (make-evaluator 'racket/base))\n  (e '(define a 1))\n  (e '(for ([i (in-range 20)]) (set! a (cons (make-bytes 500000) a))))\n]\nthe memory blocks are allocated within the interaction limit, but\nsince they're chained to the defined variable, they're also reachable\nfrom the sandbox --- so they will count against the sandbox memory\nlimit but not against the interaction limit (more precisely, no more\nthan one block counts against the interaction limit).}\n\n\n@defparam[sandbox-eval-limits limits\n          (or/c (list/c (or/c (>=/c 0) #f)\n                        (or/c (>=/c 0) #f))\n                #f)]{\n\nA @tech{parameter} that determines the default limits on @italic{each}\nuse of a @racket[make-evaluator] function, including the initial\nevaluation of the input program.  Its value should be a list of two\nnumbers; where the first is a @tech{shallow time} value in seconds,\nand the second is a memory limit in megabytes (note that they don't\nhave to be integers).  Either one can be @racket[#f] for disabling the\ncorresponding limit; alternately, the parameter can be set to\n@racket[#f] to disable all per-evaluation limits (useful in case more\nlimit kinds are available in future versions). The default is\n@racket[(list 30 20)].\n\nNote that these limits apply to the creation of the sandbox\nenvironment too --- even @racket[(make-evaluator 'racket/base)] can\nfail if the limits are strict enough.  For example,\n@racketblock[\n  (parameterize ([sandbox-eval-limits '(0.25 5)])\n    (make-evaluator 'racket/base '(sleep 2)))\n]\nwill throw an error instead of creating an evaluator.  Therefore, to\navoid surprises you need to catch errors that happen when the sandbox\nis created.\n\nWhen limits are set, @racket[call-with-limits] (see below) is wrapped\naround each use of the evaluator, so consuming too much time or memory\nresults in an exception.  Change the limits of a running evaluator\nusing @racket[set-eval-limits].\n\n@margin-note{A custodian's limit is checked only after a garbage\n             collection, except that it may also be checked during\n             certain large allocations that are individually larger\n             than the custodian's limit.}\n\nThe memory limit that is specified by this parameter applies to each\nindividual evaluation, but not to the whole sandbox --- that limit is\nspecified via @racket[sandbox-memory-limit].  When the global limit is\nexceeded, the sandbox is terminated, but when the per-evaluation limit\nis exceeded, an exception recognizable by @racket[exn:fail:resource?] is raised.  For example, say that\nyou evaluate an expression like\n@racketblock[\n  (for ([i (in-range 1000)])\n    (set! a (cons (make-bytes 1000000) a))\n    (collect-garbage))\n]\nthen, assuming sufficiently small limits,\n@itemize[\n\n @item{if a global limit is set but no per-evaluation limit, the\n       sandbox will eventually be terminated and no further\n       evaluations possible;}\n\n @item{if there is a per-evaluation limit, but no global limit, the\n       evaluation will abort with an error and it can be used again\n       --- specifically, @racket[a] will still hold a number of\n       blocks, and you can evaluate the same expression again which\n       will add more blocks to it;}\n\n  @item{if both limits are set, with the global one larger than the\n        per-evaluation limit, then the evaluation will abort and you\n        will be able to repeat it, but doing so several times will\n        eventually terminate the sandbox (this will be indicated by\n        the error message, and by the @racket[evaluator-alive?]\n        predicate).}\n\n]}\n\n\n@defparam[sandbox-eval-handlers handlers\n          (list/c (or/c #f ((-> any) . -> . any))\n                  (or/c #f ((-> any) . -> . any)))]{\n\nA @tech{parameter} that determines two (optional) handlers that wrap\nsandboxed evaluations.  The first one is used when evaluating the\ninitial program when the sandbox is being set-up, and the second is\nused for each interaction.  Each of these handlers should expect a\nthunk as an argument, and they should execute these thunks ---\npossibly imposing further restrictions.  The default values are\n@racket[#f] and @racket[call-with-custodian-shutdown], meaning no\nadditional restrictions on initial sandbox code (e.g., it can start\nbackground threads), and a custodian-shutdown around each interaction\nthat follows.  Another useful function for this is\n@racket[call-with-killing-threads] which kills all threads, but leaves\nother resources intact.}\n\n\n@defparam[sandbox-run-submodules submod-syms (list/c symbol?)]{\n\nA @tech{parameter} that determines submodules to run when a sandbox is\ncreated by @racket[make-module-evaluator]. The parameter's default\nvalue is the empty list.}\n\n\n@defparam[sandbox-make-inspector make (-> inspector?)]{\n\nA @tech{parameter} that determines the (nullary) procedure that is used to\ncreate the inspector for sandboxed evaluation.  The procedure is called\nwhen initializing an evaluator.  The default parameter value is\n@racket[(lambda () (make-inspector (current-inspector)))].}\n\n\n@defparam[sandbox-make-code-inspector make (-> inspector?)]{\n\nA @tech{parameter} that determines the (nullary) procedure that is used to\ncreate the code inspector for sandboxed evaluation.  The procedure is\ncalled when initializing an evaluator.  The default parameter value is\n@racket[(lambda () (make-inspector (current-code-inspector)))].\n\nThe @racket[current-load/use-compiled] handler is setup to allow loading\nof bytecode files under the original code inspector when\n@racket[sandbox-path-permissions] allows it through a\n@racket['read-bytecode] mode symbol, which makes loading libraries\npossible.}\n\n\n@defparam[sandbox-make-logger make (-> logger?)]{\n\nA @tech{parameter} that determines the procedure used to create the logger\nfor sandboxed evaluation.  The procedure is called when initializing\nan evaluator, and the default parameter value is\n@racket[current-logger].  This means that it is not creating a new\nlogger (this might change in the future).}\n\n\n@defparam[sandbox-make-plumber make (or/c (-> plumber?) 'propagate)]{\n\nA @tech{parameter} that determines the procedure used to create the\nplumber for sandboxed evaluation.  The procedure is called when\ninitializing an evaluator.\n\nIf the value is @racket['propagate] (the default), then a new plumber\nis created, and a @tech{flush callback} is added to the current\nplumber to propagate the request to the new plumber within the created\nsandbox (if the sandbox has not already terminated).\n\n@history[#:added \"6.0.1.8\"]}\n\n\n@defparam[sandbox-make-environment-variables make (-> environment-variables?)]{\n\nA @tech{parameter} that determines the procedure used to create the\n@tech{environment variable set} for sandboxed evaluation.  The\nprocedure is called when initializing an evaluator, and the default\nparameter value constructs a new @tech{environment variable set} using\n@racket[(environment-variables-copy\n(current-environment-variables))].}\n\n@; ----------------------------------------------------------------------\n\n@section{Interacting with Evaluators}\n\nThe following functions are used to interact with a sandboxed\nevaluator in addition to using it to evaluate code.\n\n\n@defproc[(evaluator-alive? [evaluator (any/c . -> . any)]) boolean?]{\n\nDetermines whether the evaluator is still alive.}\n\n\n@defproc[(kill-evaluator [evaluator (any/c . -> . any)]) void?]{\n\nReleases the resources that are held by @racket[evaluator] by shutting\ndown the evaluator's custodian.  Attempting to use an evaluator after\nkilling raises an exception, and attempts to kill a dead evaluator are\nignored.\n\nKilling an evaluator is similar to sending an @racket[eof] value to\nthe evaluator, except that an @racket[eof] value will raise an error\nimmediately.}\n\n\n@defproc[(break-evaluator [evaluator (any/c . -> . any)]) void?]{\n\nSends a break to the running evaluator.  The effect of this is as if\nCtrl-C was typed when the evaluator is currently executing, which\npropagates the break to the evaluator's context.}\n\n\n@defproc[(get-user-custodian [evaluator (any/c . -> . any)]) void?]{\n\nRetrieves the @racket[evaluator]'s toplevel custodian.  This returns a\nvalue that is different from @racket[(evaluator '(current-custodian))]\nor @racket[call-in-sandbox-context evaluator current-custodian] --- each\nsandbox interaction is wrapped in its own custodian, which is what these\nwould return.\n\n(One use for this custodian is with @racket[current-memory-use], where\nthe per-interaction sub-custodians will not be charged with the memory\nfor the whole sandbox.)}\n\n\n@defproc[(set-eval-limits [evaluator (any/c . -> . any)]\n                          [secs (or/c exact-nonnegative-integer? #f)]\n                          [mb (or/c exact-nonnegative-integer? #f)])\n         void?]{\n\nChanges the per-expression limits that @racket[evaluator] uses to\n@racket[secs] seconds of @tech{shallow time} and @racket[mb]\nmegabytes (either one can be @racket[#f], indicating no limit).\n\nThis procedure should be used to modify an existing evaluator limits,\nbecause changing the @racket[sandbox-eval-limits] parameter does not\naffect existing evaluators. See also @racket[call-with-limits].}\n\n\n@defproc[(set-eval-handler [evaluator (any/c . -> . any)]\n                           [handler (or/c #f ((-> any) . -> . any))])\n         void?]{\n\nChanges the per-expression handler that the @racket[evaluator] uses\naround each interaction.  A @racket[#f] value means no handler is\nused.\n\nThis procedure should be used to modify an existing evaluator handler,\nbecause changing the @racket[sandbox-eval-handlers] parameter does not\naffect existing evaluators. See also\n@racket[call-with-custodian-shutdown] and\n@racket[call-with-killing-threads] for two useful handlers that are\nprovided.}\n\n\n@defproc*[([(call-with-custodian-shutdown [thunk (-> any)]) any]\n           [(call-with-killing-threads [thunk (-> any)]) any])]{\n\nThese functions are useful for use as an evaluation handler.\n@racket[call-with-custodian-shutdown] will execute the @racket[thunk]\nin a fresh custodian, then shutdown that custodian, making sure that\n@racket[thunk] could not have left behind any resources.\n@racket[call-with-killing-threads] is similar, except that it kills\nthreads that were left, but leaves other resources as is.}\n\n\n@defproc*[([(put-input [evaluator (any/c . -> . any)]) output-port?]\n           [(put-input [evaluator (any/c . -> . any)]\n                       [i/o (or/c bytes? string? eof-object?)]) void?])]{\n\nIf @racket[(sandbox-input)] is @racket['pipe] when an evaluator is\ncreated, then this procedure can be used to retrieve the output port\nend of the pipe (when used with no arguments), or to add a string or a\nbyte string into the pipe.  It can also be used with @racket[eof],\nwhich closes the pipe.}\n\n\n@defproc*[([(get-output [evaluator (any/c . -> . any)]) (or/c #f input-port? bytes? string?)]\n           [(get-error-output [evaluator (any/c . -> . any)]) (or/c #f input-port? bytes? string?)])]{\n\nReturns the output or error-output of the @racket[evaluator],\nin a way that depends on the setting of @racket[(sandbox-output)] or\n@racket[(sandbox-error-output)] when the evaluator was created:\n\n@itemize[\n\n @item{if it was @racket['pipe], then @racket[get-output] returns the\n      input port end of the created pipe;}\n\n @item{if it was @racket['bytes] or @racket['string], then the result\n       is the accumulated output, and the output port is reset so each\n       call returns a different piece of the evaluator's output (note\n       that results are available only until the evaluator has\n       terminated, and any allocations of the output are subject to\n       the sandbox memory limit);}\n\n  @item{otherwise, it returns @racket[#f].}\n]}\n\n\n@defproc[(get-uncovered-expressions [evaluator (any/c . -> . any)]\n                                    [prog? any/c #t]\n                                    [src any/c _default-src])\n         (listof syntax?)]{\n\nRetrieves uncovered expression from an evaluator, as longs as the\n@racket[sandbox-coverage-enabled] parameter had a true value when the\nevaluator was created. Otherwise, an exception is raised to indicate\nthat no coverage information is available.\n\nThe @racket[prog?] argument specifies whether to obtain expressions that\nwere uncovered after only the original input program was evaluated\n(@racket[#t]) or after all later uses of the evaluator (@racket[#f]).\nUsing @racket[#t] retrieves a list that is saved after the input\nprogram is evaluated, and before the evaluator is used, so the result is\nalways the same.\n\nA @racket[#t] value of @racket[prog?] is useful for testing student\nprograms to find out whether a submission has sufficient test coverage\nbuilt in. A @racket[#f] value is useful for writing test suites for a\nprogram to ensure that your tests cover the whole code.\n\nThe second optional argument, @racket[src], specifies that the result\nshould be filtered to hold only @tech{syntax objects} whose source\nmatches @racket[src]. The default is the source that was used in the\nprogram code, if there was one.  Note that @racket['program] is used as\nthe source value if the input program was given as S-expressions or as a\nstring (and in these cases it will be the default for filtering).  If given\n@racket[#f], the result is the unfiltered list of expressions.\n\nThe resulting list of @tech{syntax objects} has at most one expression\nfor each position and span.  Thus, the contents may be unreliable, but\nthe position information is reliable (i.e., it always indicates source\ncode that would be painted red in DrRacket when coverage information\nis used).\n\nNote that if the input program is a sequence of syntax values, either\nmake sure that they have @racket['program] as the source field, or use\nthe @racket[src] argument.  Using a sequence of S-expressions (not\n@tech{syntax objects}) for an input program leads to unreliable\ncoverage results, since each expression may be assigned a single\nsource location.}\n\n@defproc[(call-in-sandbox-context [evaluator (any/c . -> . any)]\n                                  [thunk (-> any)]\n                                  [unrestricted? boolean? #f])\n         any]{\n\nCalls the given @racket[thunk] in the context of a sandboxed\nevaluator.  The call is performed under the resource limits and\nevaluation handler that are used for evaluating expressions, unless\n@racket[unrestricted?] is specified as true.\n\nThis process is usually similar to @racket[(evaluator (list thunk))],\nexcept that it does not rely on the common meaning of a sexpr-based\nsyntax with list expressions as function application (which is not true\nin all languages).  Note that this is more useful for meta-level\noperations such as namespace manipulation, it is not intended to be used\nas a safe-evaluation replacement (i.e., using the sandbox evaluator as\nusual).\n\nIn addition, you can avoid some of the sandboxed restrictions by using\nyour own permissions, for example,\n@racketblock[\n  (let ([guard (current-security-guard)])\n    (call-in-sandbox-context\n      ev\n      (lambda ()\n        (parameterize ([current-security-guard guard])\n          (code:comment @#,t{can access anything you want here})\n          (delete-file \"/some/file\")))))\n]}\n\n@; ----------------------------------------------------------------------\n\n@section{Miscellaneous}\n\n@defthing[gui? boolean?]{\n\nFor backward compatibility, only: the result of @racket[gui-available?]\nat the time that @racketmodname[racket/sandbox] was instantiated.\n\nThe value of @racket[gui?] is no longer used by\n@racketmodname[racket/sandbox] itself. Instead,\n@racket[gui-available?]  and @racket[sandbox-gui-available] are\nchecked at the time that a sandbox evaluator is created.}\n\n\n@defproc[(call-with-limits [secs (or/c exact-nonnegative-integer? #f)]\n                           [mb (or/c exact-nonnegative-integer? #f)]\n                           [thunk (-> any)])\n         any]{\n\nExecutes the given @racket[thunk] with memory and time restrictions:\nif execution consumes more than @racket[mb] megabytes or more than\n@racket[secs] @tech{shallow time} seconds, then the computation is\naborted and an exception recognizable by @racket[exn:fail:resource?] is raised.  Otherwise, the result of\nthe thunk is returned as usual (a value, multiple values, or an\nexception).  Each of the two limits can be @racket[#f] to indicate the\nabsence of a limit. See also @racket[custodian-limit-memory] for\ninformation on memory limits.\n\nTo enforce limits, @racket[thunk] is run in a new thread. As usual,\nthe new thread starts with the same parameter values as the one that\ncalls @racket[call-with-limits]. @emph{Not} as usual, parameter values\nfrom the thread used to run @racket[thunk] are copied back to the\nthread that called @racket[call-with-limits] when @racket[thunk]\ncompletes.\n\nSandboxed evaluators use @racket[call-with-limits], according to the\n@racket[sandbox-eval-limits] setting and uses of\n@racket[set-eval-limits]: each expression evaluation is protected from\ntimeouts and memory problems. Use @racket[call-with-limits] directly\nonly to limit a whole testing session, instead of each expression.}\n\n@defform[(with-limits sec-expr mb-expr body ...)]{\n\nA macro version of @racket[call-with-limits].}\n\n@defproc[(call-with-deep-time-limit [secs exact-nonnegative-integer?]\n                                    [thunk (-> any)])\n         any]{\nExecutes the given @racket[thunk] with @tech{deep time} restrictions,\nand returns the values produced by @racket[thunk].\n\nThe given @racket[thunk] is run in a new thread. If it errors or if\nthe thread terminates returning a value, then @racket[(values)] is\nreturned.\n\n@history[#:changed \"1.1\" @elem{Changed to return @racket[thunk]'s result\n                               if it completes normally.}]}\n\n@defform[(with-deep-time-limit secs-expr body ...)]{\n\nA macro version of @racket[call-with-deep-time-limit].}\n\n@defproc*[([(exn:fail:resource? [v any/c]) boolean?]\n           [(exn:fail:resource-resource [exn exn:fail:resource?])\n            (or/c 'time 'memory 'deep-time)])]{\n\nA predicate and accessor for exceptions that are raised by\n@racket[call-with-limits].  The @racket[resource] field holds a\nsymbol, representing the resource that was expended. @racket['time] is\nused for @tech{shallow time} and @racket['deep-time] is used for\n@tech{deep time}.}\n\n@; ----------------------------------------------------------------------\n\n@close-eval[box-eval]\n", "\n(load-relative \"loadtest.rktl\")\n\n(Section 'sandbox)\n\n(require racket/sandbox)\n\n;; test call-in-nested-thread*\n(let ()\n  (define (kill) (kill-thread (current-thread)))\n  (define (shut) (custodian-shutdown-all (current-custodian)))\n  (define-syntax-rule (nested body ...)\n    (call-in-nested-thread* (lambda () body ...)))\n  (define-syntax-rule (nested* body ...)\n    (call-in-nested-thread* (lambda () body ...)\n                            (lambda () 'kill)\n                            (lambda () 'shut)))\n  (test 1 values (nested 1))\n  ;; propagates parameters\n  (let ([p (make-parameter #f)])\n    (nested (p 1))\n    (test 1 p)\n    (with-handlers ([void void]) (nested (p 2) (error \"foo\") (p 3)))\n    (test 2 p))\n  ;; propagates kill-thread\n  (test (void) thread-wait\n        (thread (lambda ()\n                  (nested (kill))\n                  ;; never reach here\n                  (semaphore-wait (make-semaphore 0)))))\n  ;; propagates custodian-shutdown-all\n  (test (void) values\n        (parameterize ([current-custodian (make-custodian)]) (nested (shut))))\n  ;; test handlers parameters\n  (test 'kill (lambda () (nested* (kill))))\n  (test 'shut (lambda () (nested* (shut)))))\n\n(let ([ev void]\n      [old-port #f]\n      [plumber (make-plumber)]\n      [out-port (open-output-bytes)])\n  (define (make-evaluator! #:requires [reqs null] . args)\n    (set! ev (apply make-evaluator args #:requires reqs)))\n  (define (make-base-evaluator! . args)\n    (set! ev (apply make-evaluator 'racket/base args)))\n  (define (make-base-evaluator/reqs! reqs . args)\n    (set! ev (apply make-evaluator 'racket/base #:requires reqs args)))\n  (define (make-module-evaluator! #:allow-read [allow null] . args)\n    ;; Close port from old evaluation, if any, to avoid later Windows\n    ;; problems deleting an open file:\n    (when old-port (close-input-port old-port) (set! old-port #f))\n    (when (input-port? (car args)) (set! old-port (car args)))\n    ;; Create and install the evaluator:\n    (set! ev (apply make-module-evaluator args #:allow-read allow)))\n  (define (run thunk)\n    (with-handlers ([void (lambda (e) (list 'exn: e))])\n      (call-with-values thunk (lambda vs (cons 'vals: vs)))))\n  (define (run* thunk)\n    (with-handlers ([void (lambda (e) (list 'exn: e))])\n      (call-with-values thunk\n          (case-lambda [(x) (and x #t)] [vs (cons 'vals: vs)]))))\n  (define (e-match? re run thunk)\n    (let ([x (run thunk)])\n      (if (and (list? x) (= 2 (length x)) (eq? 'exn: (car x)) (exn? (cadr x)))\n        (let ([m (exn-message (cadr x))])\n          (or (regexp-match? re m) (list 'bad-exception-message: m)))\n        x)))\n  (define-syntax thunk (lambda (stx)\n                         (syntax-case stx ()\n                           [(_ loc b ...)\n                            (syntax/loc #'loc\n                              (lambda () b ...))])))\n  (define-syntax t\n    (syntax-rules (--eval-- --top-- => <= =err> <err=)\n      [(t -?-) (void)]\n      [(t -?- --eval-- more ...) (t --eval-- more ...)]\n      [(t -?- --top--  more ...) (t --top--  more ...)]\n      [(t --eval-- E)         (test #t            run* (thunk E (ev `E)))]\n      [(t --top--  E)         (test #t            run* (thunk E E))]\n      [(t --eval-- E => R)    (test `(vals: ,R)   run  (thunk E (ev `E)))]\n      [(t --top--  E => R)    (test `(vals: ,R)   run  (thunk E E))]\n      [(t --eval-- E =err> R) (test #t e-match? R run  (thunk E (ev `E)))]\n      [(t --top--  E =err> R) (test #t e-match? R run  (thunk E E))]\n      [(t -?- E => R more ...)    (begin (t -?- E => R) (t -?- more ...))]\n      [(t -?- E =err> R more ...) (begin (t -?- E =err> R) (t -?- more ...))]\n      [(t -?- R <= E more ...)    (t -?- E => R more ...)]\n      [(t -?- R <err= E more ...) (t E =err> R more ...)]\n      ;; last so it doesn't match the above\n      [(t -?- E more ...) (begin (t -?- E) (t -?- more ...))]))\n  (define (make-prog . lines)\n    (apply string-append (map (lambda (l) (string-append l \"\\n\")) lines)))\n\n  (t\n\n   ;; basic stuff, limits\n   --top--\n   (make-base-evaluator!\n    (make-prog \"(define x 1)\"\n               \"(define (id x) x)\"\n               \"(define (plus1 x) x)\"\n               \"(define (loop) (loop))\"\n               \"(define (memory x) (vector-length (make-vector x)))\"))\n   (set-eval-limits ev 0.5 5)\n   --eval--\n   x => 1\n   (id 1) => 1\n   (id (plus1 x)) => 1\n   (define id2 id)\n   (id2 (id x)) => 1\n   blah =err> \"before its definition\"\n   ;; using a string for an input\n   \"1\" => 1\n   \"(+ 1 2) x (define y 9) y (set! y 99) y\" => 99\n   \"bad\\\"string\" =err> \"expected a closing\"\n   \"bad(string\" =err> \"expected a .\\\\).\"\n   \"bad)string\" =err> \"unexpected .\\\\).\"\n   \"(set! y 999) (string\" =err> \"expected a .\\\\).\"\n   y => 99\n   \"(set! y 999) (if)\" =err> \"if: bad syntax\"\n   y => 999\n   ;; test limits\n   (loop) =err> \"out of time\"\n   --top--\n   (when (custodian-memory-accounting-available?)\n     (t --eval-- (memory 3000000) =err> \"out of memory\"))\n   ;; test parameter settings (tricky to get this right since\n   ;; with-limits runs stuff in a different thread)\n   (set-eval-limits ev #f #f)\n   --eval--\n   (define p (make-parameter 0))\n   (p) => 0\n   (p 1)\n   (p) => 1\n   (thread-wait (thread (lambda () (p 100))))\n   (p) => 1\n   --top--\n   (set-eval-limits ev 1 3)\n   --eval--\n   (p) => 1\n   (p 2)\n   (p) => 2\n   (thread-wait (thread (lambda () (p 100))))\n   (p) => 2\n   --top--\n   (set-eval-limits ev #f #f)\n   --eval--\n   (p) => 2\n   ;; breaking\n   --top--\n   (thread (lambda () (sleep 1) (break-evaluator ev)))\n   --eval--\n   (sleep 2) =err> \"user break\"\n   (printf \"x = ~s\\n\" x) => (void)\n   ;; termination\n   --eval--\n   ,eof =err> \"terminated .eof.$\"\n   123  =err> \"terminated .eof.$\"\n   ,eof =err> \"terminated .eof.$\"\n\n   ;; other termination messages\n   --top-- (make-base-evaluator!) (kill-evaluator ev)\n   --eval-- 123 =err> \"terminated .evaluator-killed.$\"\n\n   ;; nested calls are forbidden\n   --top-- (make-base-evaluator!)\n   --eval-- (,ev 1) =err> \"nested evaluator call\"\n\n   ;; eval-limits apply to the sandbox creation too\n   --top--\n   (parameterize ([sandbox-eval-limits '(0.25 5)])\n     (make-base-evaluator! '(sleep 2)))\n   =err> \"out of time\"\n   (when (custodian-memory-accounting-available?)\n     (t --top--\n        (parameterize ([sandbox-eval-limits '(20 2)])\n          (make-base-evaluator! '(define a (for/list ([i (in-range 10)])\n                                             (collect-garbage)\n                                             (make-bytes 500000)))))\n        =err> \"out of memor(?:y)\"))\n\n   ;; check non-propagation of errors\n   --top--\n   (parameterize ([sandbox-propagate-exceptions #f]\n                  [sandbox-error-output 'string])\n     (make-base-evaluator! '(void)))\n   --eval--\n   (/ 0) => (void)\n   --top--\n   (regexp-match #rx\"^.*?\\n\" (get-error-output ev)) => '(\"/: division by zero\\n\")\n   ;; i/o\n   --top--\n   (parameterize ([sandbox-input \"3\\n\"]\n                  [sandbox-output 'string]\n                  [sandbox-error-output current-output-port])\n     (make-base-evaluator! '(define x 123)))\n   --eval-- (printf \"x = ~s\\n\" x) => (void)\n   --top--  (get-output ev) => \"x = 123\\n\"\n   --eval-- (printf \"x = ~s\\n\" x) => (void)\n   --top--  (get-output ev) => \"x = 123\\n\"\n   --eval-- (printf \"x*2 = ~s\\n\" (+ x x)) => (void)\n            (printf \"x*10 = ~s\\n\" (* 10 x)) => (void)\n   --top--  (get-output ev) => \"x*2 = 246\\nx*10 = 1230\\n\"\n   --eval-- (printf \"x*(read) = ~s\\n\" (* x (read))) => (void)\n   --top--  (get-output ev) => \"x*(read) = 369\\n\"\n   --eval-- (begin (printf \"a\\n\") (fprintf (current-error-port) \"b\\n\"))\n   --top--  (get-output ev) => \"a\\nb\\n\"\n            (get-error-output ev) => #f\n   --top--\n   (parameterize ([sandbox-output 'string] [sandbox-error-output 'string])\n     (make-base-evaluator!))\n   --eval-- (begin (printf \"a\\n\") (fprintf (current-error-port) \"b\\n\"))\n   --top--  (get-output ev) => \"a\\n\"\n            (get-error-output ev) => \"b\\n\"\n   --top--\n   (parameterize ([sandbox-input 'pipe]\n                  [sandbox-output 'bytes]\n                  [sandbox-error-output current-output-port]\n                  [sandbox-eval-limits '(0.25 10)])\n     (make-base-evaluator! '(define x 123)))\n   --eval--  (begin (printf \"x = ~s\\n\" x)\n                    (fprintf (current-error-port) \"err\\n\"))\n   --top--   (get-output ev) => #\"x = 123\\nerr\\n\"\n             (put-input ev \"blah\\n\")\n             (put-input ev \"blah\\n\")\n   --eval--  (read-line) => \"blah\"\n             (printf \"line = ~s\\n\" (read-line))\n   --top--   (get-output ev) => #\"line = \\\"blah\\\"\\n\"\n   --eval--  (read-line) =err> \"out of time\"\n   --top--   (put-input ev \"blah\\n\")\n             (put-input ev eof)\n   --eval--  (read-line) => \"blah\"\n             (read-line) => eof\n             (read-line) => eof\n   ;; test kill-evaluator here\n   --top--\n   (kill-evaluator ev) => (void)\n   --eval--\n   x =err> \"terminated .evaluator-killed.$\"\n   y =err> \"terminated .evaluator-killed.$\"\n   ,eof =err> \"terminated .evaluator-killed.$\"\n   --top--\n   (let-values ([(i1 o1) (make-pipe)] [(i2 o2) (make-pipe)])\n     ;; o1 -> i1 -ev-> o2 -> i2\n     (parameterize ([sandbox-input i1] [sandbox-output o2])\n       (make-base-evaluator! '(define x 123)))\n     (t --eval-- (printf \"x = ~s\\n\" x) => (void)\n        --top--  (read-line i2) => \"x = 123\"\n        --eval-- (printf \"x = ~s\\n\" x) => (void)\n        --top--  (read-line i2) => \"x = 123\"\n        --eval-- (printf \"x*2 = ~s\\n\" (+ x x)) => (void)\n                 (printf \"x*10 = ~s\\n\" (* 10 x)) => (void)\n        --top--  (read-line i2) => \"x*2 = 246\"\n                 (read-line i2) => \"x*10 = 1230\"\n                 (fprintf o1 \"3\\n\")\n        --eval-- (printf \"x*(read) = ~s\\n\" (* x (read))) => (void)\n        --top--  (read-line i2) => \"x*(read) = 369\"\n        ))\n\n   ;; sexprs as a program\n   --top--\n   (make-base-evaluator! '(define id (lambda (x) x)))\n   --eval--\n   (id 123) => 123\n   --top--\n   (make-base-evaluator! '(define id (lambda (x) x)) '(define fooo 999))\n   --eval--\n   (id fooo) => 999\n\n   ;; test source locations too\n   --top--\n   (make-base-evaluator! 0 1 2 '(define foo))\n   =err> \"^program:4:0: define:\"\n\n   ;; empty program for clean repls\n   --top--\n   (make-evaluator! '(begin))\n   --eval--\n   (define x (+ 1 2 3)) => (void)\n   x => 6\n   (define x (+ x 10)) => (void)\n   x => 16\n   --top--\n   (make-base-evaluator!)\n   --eval--\n   (define x (+ 1 2 3)) => (void)\n   x => 6\n   (define x (+ x 10)) => (void)\n   x => 16\n   --top--\n   (make-base-evaluator! '(define x (+ 1 2 3)))\n   --eval--\n   (define x (+ x 10)) =err> \"cannot re-define a constant\"\n\n   ;; whole program argument\n   --top--\n   (make-module-evaluator! '(module foo racket/base (define x 1)))\n   --eval--\n   x => 1\n   --top--\n   (make-module-evaluator! '(module foo racket/base (provide x) (define x 1)))\n   --eval--\n   x => 1\n   (define x 2) =err> \"cannot re-define a constant\"\n\n   ;; submodules\n   --top--\n   (parameterize ([sandbox-run-submodules '(go)])\n     (make-module-evaluator! '(module foo racket/base\n                                (define x 1)\n                                (define (set-x! v) (set! x v))\n                                (module+ go (set-x! 2)))))\n   --eval--\n   x => 2\n   --top--\n   (parameterize ([sandbox-run-submodules '(not-there)])\n     (make-module-evaluator! '(module foo racket/base\n                                (define x 1)\n                                (define (set-x! v) (set! x v))\n                                (module+ go (set-x! 2)))))\n   --eval--\n   x => 1\n\n   ;; `for-syntax' is allowed in #:requires:\n   --top--\n   (make-evaluator! 'scheme/base #:requires '((for-syntax racket/base)))\n   --eval--\n   (define-syntax (m stx) #'10)\n   m => 10\n\n   ;; limited FS access, allowed for requires\n   --top--\n   (let* ([tmp       (make-temporary-file \"sandboxtest~a\" 'directory)]\n          [strpath   (lambda xs (path->string (apply build-path xs)))]\n          [racketlib (strpath (path-only (collection-file-path \"main.rkt\" \"racket\")))]\n          [compiled (if (null? (use-compiled-file-paths))\n                        \"compiled\"\n                        (car (use-compiled-file-paths)))]\n          [list-lib  (strpath racketlib \"list.rkt\")]\n          [list-zo   (for/or ([root (in-list (current-compiled-file-roots))])\n                       (define file (cond\n                                      [(eq? root 'same)\n                                       (build-path racketlib compiled \"list_rkt.zo\")]\n                                      [(relative-path? root)\n                                       (build-path racketlib root compiled \"list_rkt.zo\")]\n                                      [else\n                                       (build-path (reroot-path racketlib root) compiled \"list_rkt.zo\")]))\n                       (and (file-exists? file)\n                            (path->string file)))]\n          [test-lib  (strpath tmp \"sandbox-test.rkt\")]\n          [test-zo   (strpath tmp compiled \"sandbox-test_rkt.zo\")]\n          [test2-lib (strpath tmp \"sandbox-test2.rkt\")]\n          [test2-zo  (strpath tmp compiled \"sandbox-test2_rkt.zo\")]\n          [test3-file \"sandbox-test3.rkt\"]\n          [test3-lib  (strpath tmp test3-file)]\n          [make-module-evaluator/rel (lambda (mod\n                                              #:allow-read [allow null] \n                                              #:allow-for-require [allow-for-require null] \n                                              #:allow-for-load [allow-for-load null])\n                                       (parameterize ([current-directory tmp]\n                                                      [current-load-relative-directory tmp])\n                                         (make-module-evaluator mod\n                                                                #:allow-read allow\n                                                                #:allow-for-require allow-for-require\n                                                                #:allow-for-load allow-for-load)))]\n          [make-evaluator/rel (lambda (lang)\n                                (parameterize ([current-directory tmp]\n                                               [current-load-relative-directory tmp])\n                                  (make-evaluator lang)))])\n     (t --top--\n        (make-base-evaluator!)\n        --eval--\n        ;; reading from collects is allowed\n        (list? (directory-list ,racketlib))\n        (file-exists? ,list-lib) => #t\n        (let ([p (open-input-file ,list-lib)]) (begin0 (input-port? p) (close-input-port p))) => #t\n        ;; writing is forbidden\n        (open-output-file ,list-lib) =err> \"`write' access denied\"\n        ;; reading from other places is forbidden\n        (directory-list ,tmp) =err> \"`read' access denied\"\n        ;; no network too\n        (require racket/tcp)\n        (tcp-listen 12345) =err> \"network access denied\"\n        --top--\n        ;; reading from a specified require is fine\n        (with-output-to-file test-lib\n          (lambda ()\n            (printf \"~s\\n\" '(module sandbox-test racket/base\n                              (define x 123) (provide x)))))\n        ;; run it\n        (make-module-evaluator! (string->path test-lib))\n        --eval--\n        x => 123\n        (length (with-input-from-file ,test-lib read)) => 5\n        ;; the directory is still not kosher\n        (directory-list ,tmp) =err> \"`read' access denied\"\n        --top--\n        ;; ports, strings, and bytes are also allowed, but in the case\n        ;; of ports, we have to specificaly enable access to the\n        ;; enclosing directory, since the port name connects it to the\n        ;; directory, and some part of the module infrastructure exploits that:\n        (make-module-evaluator!\n         (open-input-file (string->path test-lib))) =err> \"`exists' access denied\"\n        (make-module-evaluator! (open-input-file (string->path test-lib))\n                                ;; allowing a file read indirectly allows containing-directory\n                                ;; existence check:\n                                #:allow-read (list (string->path test-lib)))\n        (make-module-evaluator! (file->string (string->path test-lib)))\n        (make-module-evaluator! (file->bytes (string->path test-lib)))\n        --top--\n        ;; a relative-path string should work as a module to be `require'd,\n        ;; as opposed to a module to be `load'ed:\n        (with-output-to-file test3-lib\n          (lambda ()\n            (printf \"~s\\n\" '(module sandbox-test racket/base\n                              (provide #%module-begin)))))\n        (make-module-evaluator/rel `(module m ,test3-file)\n                                   #:allow-read (list test3-file))\n        ;; for-require is more clear:\n        (make-module-evaluator/rel `(module m ,test3-file)\n                                   #:allow-for-require (list test3-file))\n        ;; for-load isn't ok:\n        (make-module-evaluator/rel `(module m ,test3-file)\n                                   #:allow-for-load (list test3-file))\n        =err> \"`read' access denied\"\n        ;; an absolute path is treated like `for-load':\n        (make-module-evaluator/rel `(module m ,test3-file)\n                                   #:allow-read (list test3-lib))\n        =err> \"`read' access denied\"\n        (make-module-evaluator/rel `(module m ,test3-file)\n                                   #:allow-read (list (string->path test3-lib)))\n        =err> \"`read' access denied\"\n        ;; an absolute path with `for-require' is ok:\n        (make-module-evaluator/rel `(module m ,test3-file)\n                                   #:allow-for-require (list (string->path test3-lib)))\n        ;; make sure that the language is treated as a require:\n        (make-evaluator/rel test3-file)\n        --top--\n        ;; require it\n        (make-base-evaluator/reqs! `(,test-lib))\n        --eval--\n        x => 123\n        (length (with-input-from-file ,test-lib read)) => 5\n        ;; the directory is still not kosher\n        (directory-list ,tmp) =err> \"`read' access denied\"\n        --top--\n        ;; should work also for module evaluators\n        ;; --> NO!  Shouldn't make user code require whatever it wants\n        ;; (make-module-evaluator!\n        ;;   `(module foo racket/base (require (file ,test-lib))))\n        ;; --eval--\n        ;; x => 123\n        ;; (length (with-input-from-file ,test-lib read)) => 5\n        ;; ;; the directory is still not kosher\n        ;; (directory-list tmp) =err> \"file access denied\"\n        --top--\n        ;; explicitly allow access to tmp, and write access to a single file\n        (make-directory* (build-path tmp compiled))\n        (parameterize ([sandbox-path-permissions\n                        `((read ,tmp) (write ,test-zo)\n                          ,@(sandbox-path-permissions))])\n          (make-base-evaluator!))\n        --eval--\n        (length (with-input-from-file ,test-lib read)) => 5\n        (list? (directory-list ,tmp))\n        (open-output-file ,(build-path tmp \"blah\")) =err> \"access denied\"\n        (delete-directory ,(build-path tmp \"blah\")) =err> \"access denied\"\n        (list? (directory-list ,racketlib))\n        ;; we can read/write/delete list-zo, but we can't run bytecode from\n        ;; it due to the code inspector\n        (copy-file ,list-zo ,test-zo) => (void)\n        (copy-file ,test-zo ,list-zo) =err> \"access denied\"\n        ;; timestamp .zo file (needed under Windows):\n        (file-or-directory-modify-seconds ,test-zo (current-seconds))\n        ;; loading 'test gets 'list module declaration via \".zo\"\n        (load/use-compiled ,test-lib) =err> \"cannot use unsafe linklet loaded with non-original code inspector\"\n        (delete-file ,test-zo) => (void)\n        (delete-file ,test-lib) =err> \"`delete' access denied\"\n        --top--\n        ;; a more explicit test of bytcode loading, allowing rw access to the\n        ;; complete tmp directory, but read-bytecode only for test2-lib\n        (parameterize ([sandbox-path-permissions\n                        `((write ,tmp) (read-bytecode ,test2-lib)\n                          ,@(sandbox-path-permissions))])\n          (make-base-evaluator!))\n        --eval--\n        (define (cp from to)\n          (when (file-exists? to) (delete-file to))\n          (copy-file from to))\n        (cp ,list-lib ,test-lib)  (cp ,list-zo ,test-zo)\n        (cp ,list-lib ,test2-lib) (cp ,list-zo ,test2-zo)\n        ;; bytecode from test-lib is bad, even when we can read/write to it\n        (load ,test-zo) =err> \"cannot use unsafe linklet loaded with non-original code inspector\"\n        ;; bytecode from test2-lib is explicitly allowed\n        (load/use-compiled ,test2-lib)\n        (require 'list) => (void))\n     ((dynamic-require 'racket/file 'delete-directory/files) tmp))\n\n   ;; languages and requires\n   --top--\n   (make-base-evaluator/reqs! '(racket/list))\n   --eval--\n   (last-pair '(1 2 3)) => '(3)\n   (last-pair null) =err> \"contract violation\"\n\n   ;; coverage\n   --top--\n   (parameterize ([sandbox-coverage-enabled #t])\n     (make-base-evaluator!\n      (make-prog \"(define (foo x) (+ x 1))\"\n                 \"(define (bar x) (+ x 2))\"\n                 \"(equal? (foo 3) 4)\")))\n   (pair? (get-uncovered-expressions ev))\n   (pair? (get-uncovered-expressions ev #t))\n   --eval--\n   (foo 3) => 4\n   (bar 10) => 12\n   --top--\n   (null? (get-uncovered-expressions ev #f))\n   (pair? (get-uncovered-expressions ev)) ; no-tests coverage still the same\n\n   ;; misc parameters\n   --top--\n   (parameterize ([sandbox-init-hook\n                   (let ([old (sandbox-init-hook)])\n                     (lambda ()\n                       (old)\n                       (compile-enforce-module-constants #f)\n                       (compile-allow-set!-undefined #t)))])\n     (make-base-evaluator! '(define x 123)))\n   --eval--\n   (set! x 456) ; would be an error without the `enforce' parameter\n   x => 456\n   (set! y 789) ; would be an error without the `set!' parameter\n   y => 789\n\n   ;; test that output is also collected under the limit\n   --top--\n   (parameterize ([sandbox-output 'bytes]\n                  [sandbox-error-output current-output-port]\n                  [sandbox-memory-limit 4]\n                  [sandbox-eval-limits (case (system-type 'vm)\n                                         [(chez-scheme) '(2.5 4)]\n                                         [else '(2.5 1)])])\n     (make-base-evaluator!))\n   ;; GCing is needed to allow these to happen (note: the memory limit is very\n   ;; tight here, this test usually fails if the sandbox library is not\n   ;; compiled)\n   (let ([t (lambda ()\n              (t --eval-- (display (make-bytes 400000 65)) (collect-garbage)\n                 --top--  (bytes-length (get-output ev)) => 400000))])\n     ;; can go arbitrarily high here\n     (for ([i (in-range 20)]) (t)))\n\n   ;; test that killing the thread, shutting the custodian, or calling `exit'\n   ;; works fine first try it without limits (limits imply a nested\n   ;; thread/custodian)\n   --top--\n   (let ()\n     (define (3x2-terminations)\n       (t --top-- (make-base-evaluator!) --eval--\n          (kill-thread (current-thread)) =err> \"terminated .thread-killed.$\"\n          --top-- (make-base-evaluator!) --eval--\n          (custodian-shutdown-all (current-custodian))\n          =err> \"terminated .custodian-shutdown.$\"\n          --top-- (make-base-evaluator!) --eval--\n          (exit) =err> \"terminated .exited.$\"\n          ;; now test that it's fine when called directly\n          --top--\n          (make-base-evaluator!)\n          (call-in-sandbox-context ev\n            (lambda () (kill-thread (current-thread))))\n          =err> \"terminated .thread-killed.$\"\n          (make-base-evaluator!)\n          (call-in-sandbox-context ev\n            (lambda () (custodian-shutdown-all (current-custodian))))\n          =err> \"terminated .custodian-shutdown.$\"\n          (make-base-evaluator!)\n          (call-in-sandbox-context ev exit) =err> \"terminated .exited.$\"))\n     (define (test-terminations)\n       ;; try without, then with per-expression limits\n       (parameterize ([sandbox-eval-limits #f]) (3x2-terminations))\n       (3x2-terminations))\n     (test-terminations))\n\n   ;; when an expression is out of memory, the sandbox should stay alive\n   --top--\n   (when (custodian-memory-accounting-available?)\n     (t --top--\n        (parameterize ([sandbox-eval-limits '(100 5)]\n                       [sandbox-memory-limit 100])\n          (make-base-evaluator!))\n        --eval--\n        (define a '())\n        (define b 1)\n        (length\n         (for/fold ([v null]) ([i (in-range 20)])\n           ;; increases size of sandbox: it's reachable from it (outside of\n           ;; this evaluation) because `a' is defined there\n           (set! a (cons (make-bytes 500000) a))\n           (collect-garbage)\n           ;; increases size of the current evaluation\n           (cons (make-bytes 500000) v)))\n        =err> \"out of mem+o(?:ry)\"\n        b => 1))\n\n   --top--\n   (make-base-evaluator!)\n   --eval--\n   (syntax-original? #'x) => #t\n\n   --eval--\n   (putenv \"PEAR\" \"A Pear\") => #t\n   (getenv \"PEAR\") => \"A Pear\"\n   --top--\n   (getenv \"PEAR\") => #f\n\n   --top--\n   (parameterize ([sandbox-output (lambda () out-port)]\n                  [current-plumber plumber])\n     (make-base-evaluator!))\n   (plumber-add-flush! plumber (lambda (h) (set! plumber #f)))\n   (get-output-string out-port) => \"\"\n   --eval--\n   (plumber-flush-all (current-plumber)) ; should not affect `plumber`\n   (plumber-add-flush! (current-plumber) (lambda (h) (displayln \"flushed\")))\n   --top--\n   (not plumber) => #f\n   (get-output-string out-port) => \"\"\n   (plumber-flush-all plumber)\n   plumber => #f\n   --eval--\n   10 => 10 ; sync, so that flush has been propagated\n   --top--\n   (get-output-string out-port) => \"flushed\\n\"\n   --eval--\n   (exit) =err> \"terminated .exited.$\"\n   --top--\n   (get-output-string out-port) => \"flushed\\nflushed\\n\"\n\n   ;; tests for specials\n   --top--\n   ;; these are conditional so that we can run\n   ;; the tests even when htdp or r5rs is not available\n   (when (collection-file-path \"lang.rkt\" \"r5rs\" #:fail (\u03bb (s) #f))\n     (t --top--\n        (make-evaluator! '(special r5rs) \"(define x (eq? 'x 'X))\")\n        --eval--\n        x => #t\n        --top--\n        (make-base-evaluator! \"(define l null)\")\n        --eval--\n        (cond [null? l 0]) => 0\n        (last-pair l) =err> \"last-pair: undefined\"))\n\n   (when (collection-file-path \"htdp-beginner.rkt\" \"lang\" #:fail (\u03bb (s) #f))\n     (t --top--\n        (make-evaluator! '(special beginner)\n                         (make-prog \"(define l null)\" \"(define x 3.5)\"))\n        --eval--\n        (cond [null? l 0]) =err> \"no open parenthesis\"\n        --top--\n        (eq? (ev \"6\") (ev \"(sub1 (* 2 3.5))\"))\n        (eq? (ev \"6\") (ev \"(sub1 (* 2 x))\"))))))\n\n(parameterize ([current-module-declare-name (make-resolved-module-path 'junk)])\n  (define (avoid-module-declare-name)\n    (with-handlers ([exn? (lambda (_) #f)])\n      (kill-evaluator (make-evaluator 'racket/base))\n      #t))\n  (test #t avoid-module-declare-name))\n\n(let ()\n  (define (try lang)\n    (define e (make-evaluator lang))\n    (e '(require ffi/unsafe))\n    (with-handlers ([exn? exn-message]) (e '(ffi-lib #f)))\n    (e '(require racket/place))\n    (with-handlers ([exn? exn-message]) (e '(place pch 10)))\n    (with-handlers ([exn? exn-message]) (e '(dynamic-place \"x.rkt\" 10))))\n  (define r1 (try 'racket/base))\n  (define r2 (try '(begin)))\n  (test #t regexp-match?\n        #rx\"access disallowed by code inspector to protected\"\n        r1)\n  (test #t equal? r1 r2))\n\n;; ----------------------------------------\n;; Check that sandbox is not flushed if\n;; its custodian has been shut down:\n\n(let ()\n  (define p (make-plumber))\n\n  (define e0\n    (parameterize ([current-plumber p])\n      (call-with-trusted-sandbox-configuration\n       (lambda ()\n         (make-evaluator 'racket/base)))))\n\n  (e0 '(require racket/sandbox))\n  (e0 '(make-evaluator 'racket/base))\n\n  (kill-evaluator e0)\n  ;; e's plumber should not be flushed:\n  (plumber-flush-all p))\n\n;; ----------------------------------------\n\n;; Backup test for one in \"thread.rktl\", since this sandbox test\n;; originally exposed it:\n(let ()\n  (define sandbox (make-evaluator 'racket/base))\n  (sandbox \"(define result (call/cc (lambda (x) (lambda () (x 5)))))\")\n  (sandbox \"(if (procedure? result) (result) result)\"))\n\n;; ----------------------------------------\n\n;; Check that a sandbox can host a sandbox:\n(let ([e (make-module-evaluator (string-append \"#lang racket/base\\n\"))])\n  (e '(require racket/sandbox))\n  (e '(make-module-evaluator (string-append \"#lang racket/base\\n\"))))\n\n;; ----------------------------------------\n\n(report-errs)\n"], "fixing_code": ["#lang scribble/doc\n@(require \"mz.rkt\" racket/sandbox\n          (for-label racket/sandbox\n                     racket/port\n                     (only-in racket/gui make-gui-namespace)\n                     racket/gui/dynamic))\n\n@(define box-eval (make-base-eval))\n@examples[#:hidden #:eval box-eval (require racket/sandbox)]\n\n@title{Sandboxed Evaluation}\n\n@note-lib-only[racket/sandbox]\n\nThe @racketmodname[racket/sandbox] module provides utilities for\ncreating ``sandboxed'' evaluators, which are configured in a\nparticular way and can have restricted resources (memory and time),\nfilesystem and network access, and much more.  Sandboxed evaluators can be\nconfigured through numerous parameters --- and the defaults are set\nfor the common use case where sandboxes are very limited.\n\n@defproc*[([(make-evaluator [language (or/c module-path?\n                                            (list/c 'special symbol?)\n                                            (cons/c 'begin list?))]\n                            [input-program any/c] ...\n                            [#:requires requires \n                                        (listof (or/c module-path? path-string? \n                                                      (cons/c 'for-syntax (listof module-path?))))\n                                        null]\n                            [#:allow-for-require allow-for-require (listof (or/c module-path? path?)) null]\n                            [#:allow-for-load allow-for-load (listof path-string?) null]\n                            [#:allow-read allow-read (listof (or/c module-path? path-string?)) null]\n                            [#:allow-syntactic-requires allow-syntactic-requires (or/c #f (listof module-path?)) #f])\n            (any/c . -> . any)]\n           [(make-module-evaluator [module-decl (or/c syntax? pair? path? input-port? string? bytes?)]\n                                   [#:language  lang  (or/c #f module-path?) #f]\n                                   [#:readers   readers  (or/c #f (listof module-path?)) (and lang (default-language-readers lang))]\n                                   [#:allow-for-require allow-for-require (listof (or/c module-path? path?)) null]\n                                   [#:allow-for-load allow-for-load (listof path-string?) null]\n                                   [#:allow-read allow-read (listof (or/c module-path? path-string?)) null]\n                                   [#:allow-syntactic-requires allow-syntactic-requires (or/c #f (listof module-path?)) #f])\n            (any/c . -> . any)])]{\n\nThe @racket[make-evaluator] function creates an evaluator with a\n@racket[language] and @racket[requires] specification, and starts\nevaluating the given @racket[input-program]s. The\n@racket[make-module-evaluator] function creates an evaluator that\nworks in the context of a given module. The result in either case is a\nfunction for further evaluation.\n\nThe returned evaluator operates in an isolated and limited\nenvironment. In particular, filesystem access is restricted, which may\ninterfere with using modules from the filesystem that are not\nin a @tech{collection}.  See below for\ninformation on the @racket[allow-for-require],\n@racket[allow-for-load], and @racket[allow-read] arguments; collection-based\nmodule files typically do not need to be included in those lists.  When\n@racket[language] is a module path or when @racket[requires] is\nprovided, the indicated modules are implicitly included in the\n@racket[allow-for-require] list. When @racket[allow-syntactic-requires]\nis not @racket[#f], it constraints the set of modules that can be directly\nreferenced in a module; see below for more information.\n(For backward compatibility,\nnon-@racket[module-path?] path strings are allowed in arguments like\n@racket[requires]; they are implicitly converted to paths before\naddition to @racket[allow-for-require].)\n\nEach @racket[input-program] or @racket[module-decl] argument provides\na program in one of the following forms:\n\n@itemize[\n\n @item{an input port used to read the program;}\n\n @item{a string or a byte string holding the complete input;}\n\n @item{a path that names a file holding the input; or}\n\n @item{an S-expression or a @tech{syntax object}, which is evaluated\n       as with @racket[eval] (see also\n       @racket[get-uncovered-expressions]).}\n]\n\nIn the first three cases above, the program is read using\n@racket[sandbox-reader], with line-counting enabled for sensible error\nmessages, and with @racket['program] as the source (used for testing\ncoverage).  In the last case, the input is expected to be the complete\nprogram, and is converted to a @tech{syntax object} (using\n@racket['program] as the source), unless it already is a @tech{syntax\nobject}.\n\nThe returned evaluator function accepts additional expressions\n(each time it is called) in essentially the same form: a string or\nbyte string holding a sequence of expressions, a path for a file\nholding expressions, an S-expression, or a @tech{syntax object}.  If\nthe evaluator receives an @racket[eof] value, it is terminated and\nraises errors thereafter.  See also @racket[kill-evaluator], which\nterminates the evaluator without raising an exception.\n\nFor @racket[make-evaluator], multiple @racket[input-program]s are\neffectively concatenated to form a single program. The way that the\n@racket[input-program]s are evaluated depends on the @racket[language]\nargument:\n\n@itemize[\n\n @item{The @racket[language] argument can be a module path (i.e., a\n       datum that matches the grammar for @racket[_module-path] of\n       @racket[require]).\n\n       In this case, the @racket[input-program]s are automatically\n       wrapped in a @racket[module], and the resulting evaluator works\n       within the resulting module's namespace.}\n\n @item{The @racket[language] argument can be a list starting with\n       @racket['special], which indicates a built-in language with\n       special input configuration. The possible values are\n       @racket['(special r5rs)] or a value indicating a teaching\n       language: @racket['(special beginner)], @racket['(special\n       beginner-abbr)], @racket['(special intermediate)],\n       @racket['(special intermediate-lambda)], or @racket['(special\n       advanced)].\n\n       In this case, the @racket[input-program]s are automatically\n       wrapped in a @racket[module], and the resulting evaluator works\n       within the resulting module's namespace. In addition, certain\n       parameters (such as such as @racket[read-accept-infix-dot]) are\n       set to customize reading programs from strings and ports.\n\n       This option is provided mainly for older test systems. Using\n       @racket[make-module-evaluator] with input starting with\n       @racketmodfont{#lang} is generally better.}\n\n @item{Finally, @racket[language] can be a list whose first element is\n       @racket['begin].\n\n       In this case, a new namespace is created using\n       @racket[sandbox-namespace-specs], which by default creates a\n       new namespace using @racket[sandbox-make-namespace] (which, in\n       turn, uses @racket[make-base-namespace] or\n       @racket[make-gui-namespace] depending on\n       @racket[sandbox-gui-available] and @racket[gui-available?]).\n\n       In the new namespace, @racket[language] is evaluated as an\n       expression to further initialize the namespace.}\n\n]\n\nThe @racket[requires] list adds additional imports to the module or\nnamespace for the @racket[input-program]s, even in the case that\n@racket[require] is not made available through the @racket[language].\nThe @racket[allow-syntactic-requires] argument, if non-@racket[#f],\nconstrains @racket[require] references expanded in the module when the\n@racket[language] argument implies a @racket[module] wrapper; more\nprecisely, it constrains the module paths that can be resolved when a\nsyntax object is provided to the @tech{module name resolver}, which\nwill include @racket[require] forms that are created by macro\nexpansion.\n\nThe following examples illustrate the difference between an evaluator\nthat puts the program in a module and one that merely initializes a\ntop-level namespace:\n\n@examples[#:label #f\n#:eval box-eval\n(eval:error\n (define base-module-eval \n   (code:comment @#,t{a module cannot have free variables...})\n   (make-evaluator 'racket/base '(define (f) later))))\n(define base-module-eval \n  (make-evaluator 'racket/base '(define (f) later)\n                               '(define later 5)))\n(base-module-eval '(f))\n\n(define base-top-eval \n  (code:comment @#,t{non-module code can have free variables:})\n  (make-evaluator '(begin) '(define (f) later)))\n(base-top-eval '(+ 1 2))\n(base-top-eval '(define later 5))\n(base-top-eval '(f))\n]\n\nThe @racket[make-module-evaluator] function is essentially a\nrestriction of @racket[make-evaluator], where the program must be a\nmodule, and all imports are part of the program.  In some cases it is\nuseful to restrict the program to be a module using a specific module\nin its language position; use the optional @racket[lang] argument\nto specify such a restriction, where @racket[#f] means that no\nrestriction is enforced. The @racket[readers] argument similarly\nconstrains the paths that can follow @hash-lang[] or @schememetafont{#reader}\nif it is not @racket[#f], and the default is based on @racket[lang].\nThe @racket[allow-syntactic-requires] argument is treated the same as\nfor @racket[make-evaluator] in the module-wrapper case.\n\nWhen the program is specified as a path, then\nthe path is implicitly added to the @racket[allow-for-load] list.\n\n@racketblock[\n(define base-module-eval2\n  (code:comment @#,t{equivalent to @racket[base-module-eval]:})\n  (make-module-evaluator '(module m racket/base\n                            (define (f) later)\n                            (define later 5))))\n]\n\nThe @racket[make-module-evaluator] function can be convenient for testing\nmodule files: pass in a path value for the file\nname, and you get back an evaluator in the module's context which you\ncan use with your favorite test facility.\n\nIn all cases, the evaluator operates in an isolated and limited\nenvironment:\n@itemize[\n\n @item{It uses a new custodian and namespace. When \n       @racket[gui-available?] and @racket[sandbox-gui-available] produce\n       true, it is also runs in its own eventspace.}\n\n @item{The evaluator works under the @racket[sandbox-security-guard],\n       which restricts file system and network access.}\n\n @item{The evaluator is contained in a memory-restricted environment,\n       and each evaluation is wrapped in a @racket[call-with-limits]\n       (when memory accounting is available); see also\n       @racket[sandbox-memory-limit], @racket[sandbox-eval-limits] and\n       @racket[set-eval-limits].}\n]\nNote that these limits apply to the creation of the sandbox\nenvironment too --- so, for example, if the memory that is required to\ncreate the sandbox is higher than the limit, then\n@racket[make-evaluator] will fail with a memory limit exception.\n\nThe @racket[allow-for-require] and @racket[allow-for-load] arguments\nadjust filesystem permissions to extend the set of files that\nare usable by the evaluator. Modules that are in a collection\nare automatically accessible, but the @racket[allow-for-require] argument lists\nadditional modules that can be @racket[require]d along with their imports\n(transitively) through a filesystem path. The @racket[allow-for-load] argument\nsimilarly lists files that can\nbe @racket[load]ed. (The precise permissions needed for\n@racket[require] versus @racket[load] can differ.)  The\n@racket[allow-read] argument is for backward compatibility, only; each\n@racket[module-path?] element of @racket[allow-read] is effectively\nmoved to @racket[allow-for-require], while other elements are moved to\n@racket[allow-for-load].\n\nThe sandboxed environment is well isolated, and the evaluator function\nessentially sends it an expression and waits for a result.  This form\nof communication makes it impossible to have nested (or concurrent)\ncalls to a single evaluator.  Usually this is not a problem, but in\nsome cases you can get the evaluator function available inside the\nsandboxed code, for example:\n@examples[#:label #f #:eval box-eval\n(eval:error\n (let ([e (make-evaluator 'racket/base)])\n   (e `(,e 1))))\n]\nAn error will be signaled in such cases.\n\nIf the value of @racket[sandbox-propagate-exceptions] is true (the\ndefault) when the sandbox is created, then exceptions (both syntax and\nrun-time) are propagated as usual to the caller of the evaluation\nfunction (i.e., catch them with @racket[with-handlers]).  If the value\nof @racket[sandbox-propagate-exceptions] is @racket[#f] when the\nsandbox is created, then uncaught exceptions in a sandbox evaluation\ncause the error to be printed to the sandbox's error port, and the\ncaller of the evaluation receives @|void-const|.\n\nFinally, the fact that a sandboxed evaluator accept syntax objects\nmakes it usable as the value for @racket[current-eval], which means\nthat you can easily start a sandboxed read-eval-print-loop:\n\n@racketblock[\n(define e (make-evaluator 'racket/base))\n(parameterize ([current-eval e])\n  (read-eval-print-loop))\n]\n\nNote that in this code only the REPL interactions will be printed to\nthe current output ports; using I/O operations inside the REPL will\nstill use the usual sandbox parameters (defaulting to no I/O).  In\naddition, the code works only from an existing toplevel REPL ---\nspecifically, @racket[read-eval-print-loop] reads a syntax value and\ngives it the lexical context of the current namespace.  Here is a\nvariation that also allows I/O over the current input and output\nports, and works when used from a module (by using a new namespace):\n\n@racketblock[\n(parameterize ([sandbox-input        current-input-port]\n               [sandbox-output       current-output-port]\n               [sandbox-error-output current-error-port]\n               [current-namespace (make-empty-namespace)])\n  (parameterize ([current-eval (make-evaluator 'racket/base)])\n    (read-eval-print-loop)))\n]\n\n@history[#:changed \"1.2\" @elem{Added the @racket[#:readers] and\n         @racket[#:allow-syntactic-require] arguments.}]}\n\n\n@defproc*[([(exn:fail:sandbox-terminated? [v any/c]) boolean?]\n           [(exn:fail:sandbox-terminated-reason [exn exn:fail:sandbox-terminated?])\n            symbol?])]{\n\nA predicate and accessor for exceptions that are raised when a sandbox\nis terminated.  Once a sandbox raises such an exception, it will\ncontinue to raise it on further evaluation attempts.\n}\n\n@; ----------------------------------------------------------------------\n\n@section{Security Considerations}\n\nAlthough the sandbox is designed to provide a safe environment for executing\nRacket programs with restricted access to system resources, executing untrusted\nprograms in a sandbox still carries some risk. Because a malicious program can\nexercise arbitrary functionality from the Racket runtime and installed collections,\nan attacker who identifies a vulnerability in Racket or an installed collection\nmay be able to escape the sandbox.\n\nTo mitigate this risk, programs that use the sandbox should employ additional\nprecautions when possible. Suggested measures include:\n@itemlist[\n@item{Supplying a custom module language to @racket[make-evaluator] or\n@racket[make-module-evaluator] that gives untrusted code access to only\nthe language constructs it absolutely requires.}\n@item{If untrusted code needs access to installed collections, installing only\nthe collections required by your program.}\n@item{Using operating-system-level security features to provide defense-in-depth\nin case the process running the sandbox is compromised.}\n@item{Making sure your Racket installation and installed packages are up-to-date\nwith the latest release.}\n]\n\n@; ----------------------------------------------------------------------\n\n@section{Customizing Evaluators}\n\nThe sandboxed evaluators that @racket[make-evaluator] creates can be\ncustomized via many parameters.  Most of the configuration parameters\naffect newly created evaluators; changing them has no effect on\nalready-running evaluators.\n\nThe default configuration options are set for a very restricted\nsandboxed environment --- one that is safe to make publicly available.\nFurther customizations might be needed in case more privileges are\nneeded, or if you want tighter restrictions.  Another useful approach\nfor customizing an evaluator is to begin with a relatively\nunrestricted configuration and add the desired restrictions.  This approach is made\npossible by the @racket[call-with-trusted-sandbox-configuration]\nfunction.\n\nThe sandbox environment uses two notions of restricting the time that\nevaluations takes: @tech{shallow time} and @tech{deep\ntime}. @deftech{Shallow time} refers to the immediate execution of an\nexpression. For example, a @tech{shallow time} limit of five seconds\nwould restrict @racket[(sleep 6)] and other computations that take\nlonger than five seconds. @deftech{Deep time} refers to the total\nexecution of the expression and all threads and sub-processes that the\nexpression creates. For example, a @tech{deep time} limit of five\nseconds would restrict @racket[(thread (\u03bb () (sleep 6)))], which\n@tech{shallow time} would not, @emph{as well as} all expressions that\n@tech{shallow time} would restrict. By default, most sandboxes only\nrestrict @tech{shallow time} to facilitate expressions that use\nthreads.\n\n@defproc[(call-with-trusted-sandbox-configuration [thunk (-> any)])\n         any]{\n\nInvokes the @racket[thunk] in a context where sandbox configuration\nparameters are set for minimal restrictions.  More specifically, there\nare no memory or time limits, and the existing existing @tech{inspectors},\n@tech{security guard}, @tech{exit handler}, @tech{logger}, @tech{plumber}, and\n@tech{environment variable set} are used.  (Note that the I/O\nports settings are not included.)}\n\n\n@defparam[sandbox-init-hook thunk (-> any)]{\n\nA @tech{parameter} that determines a thunk to be called for initializing a\nnew evaluator.  The hook is called just before the program is\nevaluated in a newly-created evaluator context.  It can be used to\nsetup environment parameters related to reading, writing, evaluation,\nand so on.  Certain languages (@racket['(special r5rs)] and the\nteaching languages) have initializations specific to the language; the\nhook is used after that initialization, so it can override settings.}\n\n\n@defparam[sandbox-reader proc (any/c . -> . any)]{\n\nA @tech{parameter} that specifies a function that reads all expressions from\n@racket[(current-input-port)].  The function is used to read program\nsource for an evaluator when a string, byte string, or port is\nsupplied.  The reader function receives a value to be used as input\nsource (i.e., the first argument to @racket[read-syntax]), and it\nshould return a list of @tech{syntax objects}.  The default reader\ncalls @racket[read-syntax], accumulating results in a list until it\nreceives @racket[eof].\n\nNote that the reader function is usually called as is, but when it is\nused to read the program input for @racket[make-module-evaluator],\n@racket[read-accept-lang] and @racket[read-accept-reader] are set to\n@racket[#t].}\n\n\n@defparam[sandbox-input in (or/c #f\n                                 string? bytes?\n                                 input-port?\n                                 'pipe\n                                 (-> input-port?))]{\n\nA @tech{parameter} that determines the initial @racket[current-input-port]\nsetting for a newly created evaluator. It defaults to @racket[#f],\nwhich creates an empty port.  The following other values are allowed:\n\n@itemize[\n\n @item{a string or byte string, which is converted to a port using\n       @racket[open-input-string] or @racket[open-input-bytes];}\n\n @item{an input port;}\n\n @item{the symbol @racket['pipe], which triggers the creation of a\n       pipe, where @racket[put-input] can return the output end of the\n       pipe or write directly to it;}\n\n @item{a thunk, which is called to obtain a port (e.g., using\n       @racket[current-input-port] means that the evaluator input is\n       the same as the calling context's input).}\n\n]}\n\n\n@defparam[sandbox-output in (or/c #f\n                                  output-port? \n                                  'pipe\n                                  'bytes\n                                  'string\n                                  (-> output-port?))]{\n\nA @tech{parameter} that determines the initial @racket[current-output-port]\nsetting for a newly created evaluator. It defaults to @racket[#f],\nwhich creates a port that discards all data.  The following other\nvalues are allowed:\n\n@itemize[\n\n @item{an output port, which is used as-is;}\n\n @item{the symbol @racket['bytes], which causes @racket[get-output] to\n       return the complete output as a byte string as long as the\n       evaluator has not yet terminated (so that the size of the bytes\n       can be charged to the evaluator);}\n\n @item{the symbol @racket['string], which is similar to\n       @racket['bytes], but makes @racket[get-output] produce a\n       string;}\n\n @item{the symbol @racket['pipe], which triggers the creation of a\n       pipe, where @racket[get-output] returns the input end of the\n       pipe;}\n\n @item{a thunk, which is called to obtain a port (e.g., using\n       @racket[current-output-port] means that the evaluator output is\n       not diverted).}\n\n]}\n\n\n@defparam[sandbox-error-output in (or/c #f\n                                        output-port? \n                                        'pipe\n                                        'bytes\n                                        'string\n                                        (-> output-port?))]{\n\nLike @racket[sandbox-output], but for the initial\n@racket[current-error-port] value. An evaluator's error output is set\nafter its output, so using @racket[current-output-port] (the parameter\nitself, not its value) for this parameter value means that the error\nport is the same as the evaluator's initial output port.\n\nThe default is @racket[(lambda () (dup-output-port\n(current-error-port)))], which means that the error output of the\ngenerated evaluator goes to the calling context's error port.}\n\n\n@defboolparam[sandbox-coverage-enabled enabled?]{\n\nA @tech{parameter} that controls whether syntactic coverage information is\ncollected by sandbox evaluators.  Use\n@racket[get-uncovered-expressions] to retrieve coverage information.\n\nThe default value is @racket[#f].\n}\n\n\n@defboolparam[sandbox-propagate-breaks propagate?]{\n\nWhen both this boolean parameter and @racket[(break-enabled)] are true, \nbreaking while an evaluator is\nrunning propagates the break signal to the sandboxed\ncontext.  This makes the sandboxed evaluator break, typically, but\nbeware that sandboxed evaluation can capture and avoid the breaks (so\nif safe execution of code is your goal, make sure you use it with a\ntime limit).  Also, beware that a break may be received after the\nevaluator's result, in which case the evaluation result is lost. Finally,\nbeware that a break may be propagated after an evaluator has produced\na result, so that the break is visible on the next interaction with\nthe evaluator (or the break is lost if the evaluator is not used\nfurther). The default is @racket[#t].}\n\n\n@defboolparam[sandbox-propagate-exceptions propagate?]{\n\nA @tech{parameter} that controls how uncaught exceptions during a sandbox\nevaluation are treated. When the parameter value is @racket[#t], \nthen the exception is propagated to the caller of sandbox.\nWhen the parameter value is @racket[#f], the exception message\nis printed to the sandbox's error port, and the caller of the\nsandbox receives @|void-const| for the evaluation. The default\nis @racket[#t].}\n\n\n@defparam[sandbox-namespace-specs spec (cons/c (-> namespace?) \n                                               (listof module-path?))]{\n\nA @tech{parameter} that holds a list of values that specify how to create a\nnamespace for evaluation in @racket[make-evaluator] or\n@racket[make-module-evaluator].  The first item in the list is a thunk\nthat creates the namespace, and the rest are module paths for modules\nto be attached to the created namespace using\n@racket[namespace-attach-module].\n\nThe default is @racket[(list sandbox-make-namespace)].\n\nThe module paths are needed for sharing module instantiations between\nthe sandbox and the caller.  For example, sandbox code that returns\n@racket[posn] values (from the @racketidfont{lang/posn} module) will\nnot be recognized as such by your own code by default, since the\nsandbox will have its own instance of @racketidfont{lang/posn} and\nthus its own struct type for @racket[posn]s.  To be able to use such\nvalues, include @racket['lang/posn] in the list of module paths.\n\nWhen testing code that uses a teaching language, the following piece\nof code can be helpful:\n\n@racketblock[\n(sandbox-namespace-specs\n (let ([specs (sandbox-namespace-specs)])\n   `(,(car specs)\n     ,@(cdr specs)\n     lang/posn\n     ,@(if (gui-available?) '(mrlib/cache-image-snip) '()))))\n]}\n\n\n@defproc[(sandbox-make-namespace) namespace?]{\n\nCalls @racket[make-gui-namespace] when @racket[(sandbox-gui-available)]\nproduces true, @racket[make-base-namespace] otherwise.}\n\n\n@defboolparam[sandbox-gui-available avail?]{\n\nDetermines whether the @racketmodname[racket/gui] module can be used\nwhen a sandbox evaluator is created. If @racket[gui-available?]\nproduces @racket[#f] during the creation of a sandbox evaluator, this\nparameter is forced to @racket[#f] during initialization of the\nsandbox. The default value of the parameter is @racket[#t].\n\nVarious aspects of the library change when the GUI library is\navailable, such as using a new eventspace for each evaluator.}\n\n\n@defparam[sandbox-override-collection-paths paths (listof path-string?)]{\n\nA @tech{parameter} that determines a list of collection directories to prefix\n@racket[current-library-collection-paths] in an evaluator. This\nparameter is useful for cases when you want to test code using an\nalternate, test-friendly version of a collection, for example, testing\ncode that uses a GUI (like the @racket[htdp/world] teachpack) can be\ndone using a fake library that provides the same interface but no\nactual interaction. The default is @racket[null].}\n\n\n@defparam[sandbox-security-guard guard\n          (or/c security-guard? (-> security-guard?))]{\n\nA @tech{parameter} that determines the initial\n@racket[(current-security-guard)] for sandboxed evaluations.  It can\nbe either a security guard, or a function to construct one.  The\ndefault is a function that restricts the access of the current\nsecurity guard by forbidding all filesystem I/O except for\nspecifications in @racket[sandbox-path-permissions], and it uses\n@racket[sandbox-network-guard] for network connections.}\n\n\n@defparam[sandbox-path-permissions perms\n          (listof (list/c (or/c 'execute 'write 'delete \n                                'read-bytecode 'read 'exists)\n                          (or/c byte-regexp? bytes? string? path?)))]{\n\nA @tech{parameter} that configures the behavior of the default sandbox\nsecurity guard by listing paths and access modes that are allowed for\nthem.  The contents of this parameter is a list of specifications,\neach is an access mode and a byte-regexp for paths that are granted this\naccess.\n\nThe access mode symbol is one of: @racket['execute], @racket['write],\n@racket['delete], @racket['read], or @racket['exists].  These symbols\nare in decreasing order: each implies access for the following modes\ntoo (e.g., @racket['read] allows reading or checking for existence).\n\nThe path regexp is used to identify paths that are granted access.  It\ncan also be given as a path (or a string or a byte string), which is\n(made into a complete path, cleansed, simplified, and then) converted\nto a regexp that allows the path and sub-directories; e.g.,\n@racket[\"/foo/bar\"] applies to @racket[\"/foo/bar/baz\"].\n\nAn additional mode symbol, @racket['read-bytecode], is not part of the\nlinear order of these modes.  Specifying this mode is similar to\nspecifying @racket['read], but it is not implied by any other mode.\n(For example, even if you specify @racket['write] for a certain path,\nyou need to also specify @racket['read-bytecode] to grant this\npermission.)  The sandbox usually works in the context of a lower code\ninspector (see @racket[sandbox-make-code-inspector]) which prevents\nloading of untrusted bytecode files --- the sandbox is set-up to allow\nloading bytecode from files that are specified with\n@racket['read-bytecode].  This specification is given by default to\nthe Racket collection hierarchy (including user-specific libraries) and\nto libraries that are explicitly specified in an @racket[#:allow-read]\nargument.  (Note that this applies for loading bytecode files only,\nunder a lower code inspector it is still impossible to use protected\nmodule bindings (see @secref[\"modprotect\"]).)\n\nThe default value is null, but when an evaluator is created, it is\naugmented by @racket['read-bytecode] permissions that make it possible\nto use collection libraries (including\n@racket[sandbox-override-collection-paths]). See\n@racket[make-evaluator] for more information.}\n\n\n@defparam[sandbox-network-guard proc\n          (symbol?\n           (or/c (and/c string? immutable?) #f)\n           (or/c (integer-in 1 65535) #f)\n           (or/c 'server 'client)\n           . -> . any)]{\n\nA @tech{parameter} that specifies a procedure to be used (as is) by the\ndefault @racket[sandbox-security-guard].  The default forbids all\nnetwork connection.}\n\n\n@defparam[sandbox-exit-handler handler (any/c . -> . any)]{\n\nA @tech{parameter} that determines the initial @racket[(exit-handler)] for\nsandboxed evaluations.  The default kills the evaluator with an\nappropriate error message (see\n@racket[exn:fail:sandbox-terminated-reason]).}\n\n\n@defparam[sandbox-memory-limit limit (or/c (>=/c 0) #f)]{\n\nA @tech{parameter} that determines the total memory limit on the sandbox in\nmegabytes (it can hold a rational or a floating point number).  When\nthis limit is exceeded, the sandbox is terminated.  This value is used\nwhen the sandbox is created and the limit cannot be changed\nafterwards.  It defaults to 30mb.  See @racket[sandbox-eval-limits]\nfor per-evaluation limits and a description of how the two limits work\ntogether.\n\nNote that (when memory accounting is enabled) memory is attributed to\nthe highest custodian that refers to it.  This means that if you\ninspect a value that sandboxed evaluation returns outside of the\nsandbox, your own custodian will be charged for it.  To ensure that it\nis charged back to the sandbox, you should remove references to such\nvalues when the code is done inspecting it.\n\nThis policy has an impact on how the sandbox memory limit interacts\nwith the per-expression limit specified by\n@racket[sandbox-eval-limits]: values that are reachable from the\nsandbox, as well as from the interaction will count against the\nsandbox limit.  For example, in the last interaction of this code,\n@racketblock[\n  (define e (make-evaluator 'racket/base))\n  (e '(define a 1))\n  (e '(for ([i (in-range 20)]) (set! a (cons (make-bytes 500000) a))))\n]\nthe memory blocks are allocated within the interaction limit, but\nsince they're chained to the defined variable, they're also reachable\nfrom the sandbox --- so they will count against the sandbox memory\nlimit but not against the interaction limit (more precisely, no more\nthan one block counts against the interaction limit).}\n\n\n@defparam[sandbox-eval-limits limits\n          (or/c (list/c (or/c (>=/c 0) #f)\n                        (or/c (>=/c 0) #f))\n                #f)]{\n\nA @tech{parameter} that determines the default limits on @italic{each}\nuse of a @racket[make-evaluator] function, including the initial\nevaluation of the input program.  Its value should be a list of two\nnumbers; where the first is a @tech{shallow time} value in seconds,\nand the second is a memory limit in megabytes (note that they don't\nhave to be integers).  Either one can be @racket[#f] for disabling the\ncorresponding limit; alternately, the parameter can be set to\n@racket[#f] to disable all per-evaluation limits (useful in case more\nlimit kinds are available in future versions). The default is\n@racket[(list 30 20)].\n\nNote that these limits apply to the creation of the sandbox\nenvironment too --- even @racket[(make-evaluator 'racket/base)] can\nfail if the limits are strict enough.  For example,\n@racketblock[\n  (parameterize ([sandbox-eval-limits '(0.25 5)])\n    (make-evaluator 'racket/base '(sleep 2)))\n]\nwill throw an error instead of creating an evaluator.  Therefore, to\navoid surprises you need to catch errors that happen when the sandbox\nis created.\n\nWhen limits are set, @racket[call-with-limits] (see below) is wrapped\naround each use of the evaluator, so consuming too much time or memory\nresults in an exception.  Change the limits of a running evaluator\nusing @racket[set-eval-limits].\n\n@margin-note{A custodian's limit is checked only after a garbage\n             collection, except that it may also be checked during\n             certain large allocations that are individually larger\n             than the custodian's limit.}\n\nThe memory limit that is specified by this parameter applies to each\nindividual evaluation, but not to the whole sandbox --- that limit is\nspecified via @racket[sandbox-memory-limit].  When the global limit is\nexceeded, the sandbox is terminated, but when the per-evaluation limit\nis exceeded, an exception recognizable by @racket[exn:fail:resource?] is raised.  For example, say that\nyou evaluate an expression like\n@racketblock[\n  (for ([i (in-range 1000)])\n    (set! a (cons (make-bytes 1000000) a))\n    (collect-garbage))\n]\nthen, assuming sufficiently small limits,\n@itemize[\n\n @item{if a global limit is set but no per-evaluation limit, the\n       sandbox will eventually be terminated and no further\n       evaluations possible;}\n\n @item{if there is a per-evaluation limit, but no global limit, the\n       evaluation will abort with an error and it can be used again\n       --- specifically, @racket[a] will still hold a number of\n       blocks, and you can evaluate the same expression again which\n       will add more blocks to it;}\n\n  @item{if both limits are set, with the global one larger than the\n        per-evaluation limit, then the evaluation will abort and you\n        will be able to repeat it, but doing so several times will\n        eventually terminate the sandbox (this will be indicated by\n        the error message, and by the @racket[evaluator-alive?]\n        predicate).}\n\n]}\n\n\n@defparam[sandbox-eval-handlers handlers\n          (list/c (or/c #f ((-> any) . -> . any))\n                  (or/c #f ((-> any) . -> . any)))]{\n\nA @tech{parameter} that determines two (optional) handlers that wrap\nsandboxed evaluations.  The first one is used when evaluating the\ninitial program when the sandbox is being set-up, and the second is\nused for each interaction.  Each of these handlers should expect a\nthunk as an argument, and they should execute these thunks ---\npossibly imposing further restrictions.  The default values are\n@racket[#f] and @racket[call-with-custodian-shutdown], meaning no\nadditional restrictions on initial sandbox code (e.g., it can start\nbackground threads), and a custodian-shutdown around each interaction\nthat follows.  Another useful function for this is\n@racket[call-with-killing-threads] which kills all threads, but leaves\nother resources intact.}\n\n\n@defparam[sandbox-run-submodules submod-syms (list/c symbol?)]{\n\nA @tech{parameter} that determines submodules to run when a sandbox is\ncreated by @racket[make-module-evaluator]. The parameter's default\nvalue is the empty list.}\n\n\n@defparam[sandbox-make-inspector make (-> inspector?)]{\n\nA @tech{parameter} that determines the (nullary) procedure that is used to\ncreate the inspector for sandboxed evaluation.  The procedure is called\nwhen initializing an evaluator.  The default parameter value is\n@racket[(lambda () (make-inspector (current-inspector)))].}\n\n\n@defparam[sandbox-make-code-inspector make (-> inspector?)]{\n\nA @tech{parameter} that determines the (nullary) procedure that is used to\ncreate the code inspector for sandboxed evaluation.  The procedure is\ncalled when initializing an evaluator.  The default parameter value is\n@racket[(lambda () (make-inspector (current-code-inspector)))].\n\nThe @racket[current-load/use-compiled] handler is setup to allow loading\nof bytecode files under the original code inspector when\n@racket[sandbox-path-permissions] allows it through a\n@racket['read-bytecode] mode symbol, which makes loading libraries\npossible.}\n\n\n@defparam[sandbox-make-logger make (-> logger?)]{\n\nA @tech{parameter} that determines the procedure used to create the logger\nfor sandboxed evaluation.  The procedure is called when initializing\nan evaluator, and the default parameter value is\n@racket[current-logger].  This means that it is not creating a new\nlogger (this might change in the future).}\n\n\n@defparam[sandbox-make-plumber make (or/c (-> plumber?) 'propagate)]{\n\nA @tech{parameter} that determines the procedure used to create the\nplumber for sandboxed evaluation.  The procedure is called when\ninitializing an evaluator.\n\nIf the value is @racket['propagate] (the default), then a new plumber\nis created, and a @tech{flush callback} is added to the current\nplumber to propagate the request to the new plumber within the created\nsandbox (if the sandbox has not already terminated).\n\n@history[#:added \"6.0.1.8\"]}\n\n\n@defparam[sandbox-make-environment-variables make (-> environment-variables?)]{\n\nA @tech{parameter} that determines the procedure used to create the\n@tech{environment variable set} for sandboxed evaluation.  The\nprocedure is called when initializing an evaluator, and the default\nparameter value constructs a new @tech{environment variable set} using\n@racket[(environment-variables-copy\n(current-environment-variables))].}\n\n@defproc[(default-language-readers [lang module-path?]) (listof module-path?)]{\n\nCreates a default list of readers that should be allowed to produce a\nmodule that uses @racket[lang] as the language.\n\nThis default list includes the following (and more paths may be added\nin the future):\n\n@itemlist[\n\n @item{@racket[`(submod ,lang reader)]}\n\n @item{@racketvalfont{'}@racket[lang]@racketvalfont{/lang/reader} if @racket[lang] is a symbol}\n\n @item{the module path producing by adding the relative path @racket[\"lang/reader.rkt\"]\n       to @racket[lang] if @racket[lang] is not a symbol}\n\n @item{@racket['(submod at-exp reader)]}\n\n @item{@racket['at-exp/lang/reader]}\n\n]\n\n@history[#:added \"1.2\"]}\n\n@; ----------------------------------------------------------------------\n\n@section{Interacting with Evaluators}\n\nThe following functions are used to interact with a sandboxed\nevaluator in addition to using it to evaluate code.\n\n\n@defproc[(evaluator-alive? [evaluator (any/c . -> . any)]) boolean?]{\n\nDetermines whether the evaluator is still alive.}\n\n\n@defproc[(kill-evaluator [evaluator (any/c . -> . any)]) void?]{\n\nReleases the resources that are held by @racket[evaluator] by shutting\ndown the evaluator's custodian.  Attempting to use an evaluator after\nkilling raises an exception, and attempts to kill a dead evaluator are\nignored.\n\nKilling an evaluator is similar to sending an @racket[eof] value to\nthe evaluator, except that an @racket[eof] value will raise an error\nimmediately.}\n\n\n@defproc[(break-evaluator [evaluator (any/c . -> . any)]) void?]{\n\nSends a break to the running evaluator.  The effect of this is as if\nCtrl-C was typed when the evaluator is currently executing, which\npropagates the break to the evaluator's context.}\n\n\n@defproc[(get-user-custodian [evaluator (any/c . -> . any)]) void?]{\n\nRetrieves the @racket[evaluator]'s toplevel custodian.  This returns a\nvalue that is different from @racket[(evaluator '(current-custodian))]\nor @racket[call-in-sandbox-context evaluator current-custodian] --- each\nsandbox interaction is wrapped in its own custodian, which is what these\nwould return.\n\n(One use for this custodian is with @racket[current-memory-use], where\nthe per-interaction sub-custodians will not be charged with the memory\nfor the whole sandbox.)}\n\n\n@defproc[(set-eval-limits [evaluator (any/c . -> . any)]\n                          [secs (or/c exact-nonnegative-integer? #f)]\n                          [mb (or/c exact-nonnegative-integer? #f)])\n         void?]{\n\nChanges the per-expression limits that @racket[evaluator] uses to\n@racket[secs] seconds of @tech{shallow time} and @racket[mb]\nmegabytes (either one can be @racket[#f], indicating no limit).\n\nThis procedure should be used to modify an existing evaluator limits,\nbecause changing the @racket[sandbox-eval-limits] parameter does not\naffect existing evaluators. See also @racket[call-with-limits].}\n\n\n@defproc[(set-eval-handler [evaluator (any/c . -> . any)]\n                           [handler (or/c #f ((-> any) . -> . any))])\n         void?]{\n\nChanges the per-expression handler that the @racket[evaluator] uses\naround each interaction.  A @racket[#f] value means no handler is\nused.\n\nThis procedure should be used to modify an existing evaluator handler,\nbecause changing the @racket[sandbox-eval-handlers] parameter does not\naffect existing evaluators. See also\n@racket[call-with-custodian-shutdown] and\n@racket[call-with-killing-threads] for two useful handlers that are\nprovided.}\n\n\n@defproc*[([(call-with-custodian-shutdown [thunk (-> any)]) any]\n           [(call-with-killing-threads [thunk (-> any)]) any])]{\n\nThese functions are useful for use as an evaluation handler.\n@racket[call-with-custodian-shutdown] will execute the @racket[thunk]\nin a fresh custodian, then shutdown that custodian, making sure that\n@racket[thunk] could not have left behind any resources.\n@racket[call-with-killing-threads] is similar, except that it kills\nthreads that were left, but leaves other resources as is.}\n\n\n@defproc*[([(put-input [evaluator (any/c . -> . any)]) output-port?]\n           [(put-input [evaluator (any/c . -> . any)]\n                       [i/o (or/c bytes? string? eof-object?)]) void?])]{\n\nIf @racket[(sandbox-input)] is @racket['pipe] when an evaluator is\ncreated, then this procedure can be used to retrieve the output port\nend of the pipe (when used with no arguments), or to add a string or a\nbyte string into the pipe.  It can also be used with @racket[eof],\nwhich closes the pipe.}\n\n\n@defproc*[([(get-output [evaluator (any/c . -> . any)]) (or/c #f input-port? bytes? string?)]\n           [(get-error-output [evaluator (any/c . -> . any)]) (or/c #f input-port? bytes? string?)])]{\n\nReturns the output or error-output of the @racket[evaluator],\nin a way that depends on the setting of @racket[(sandbox-output)] or\n@racket[(sandbox-error-output)] when the evaluator was created:\n\n@itemize[\n\n @item{if it was @racket['pipe], then @racket[get-output] returns the\n      input port end of the created pipe;}\n\n @item{if it was @racket['bytes] or @racket['string], then the result\n       is the accumulated output, and the output port is reset so each\n       call returns a different piece of the evaluator's output (note\n       that results are available only until the evaluator has\n       terminated, and any allocations of the output are subject to\n       the sandbox memory limit);}\n\n  @item{otherwise, it returns @racket[#f].}\n]}\n\n\n@defproc[(get-uncovered-expressions [evaluator (any/c . -> . any)]\n                                    [prog? any/c #t]\n                                    [src any/c _default-src])\n         (listof syntax?)]{\n\nRetrieves uncovered expression from an evaluator, as longs as the\n@racket[sandbox-coverage-enabled] parameter had a true value when the\nevaluator was created. Otherwise, an exception is raised to indicate\nthat no coverage information is available.\n\nThe @racket[prog?] argument specifies whether to obtain expressions that\nwere uncovered after only the original input program was evaluated\n(@racket[#t]) or after all later uses of the evaluator (@racket[#f]).\nUsing @racket[#t] retrieves a list that is saved after the input\nprogram is evaluated, and before the evaluator is used, so the result is\nalways the same.\n\nA @racket[#t] value of @racket[prog?] is useful for testing student\nprograms to find out whether a submission has sufficient test coverage\nbuilt in. A @racket[#f] value is useful for writing test suites for a\nprogram to ensure that your tests cover the whole code.\n\nThe second optional argument, @racket[src], specifies that the result\nshould be filtered to hold only @tech{syntax objects} whose source\nmatches @racket[src]. The default is the source that was used in the\nprogram code, if there was one.  Note that @racket['program] is used as\nthe source value if the input program was given as S-expressions or as a\nstring (and in these cases it will be the default for filtering).  If given\n@racket[#f], the result is the unfiltered list of expressions.\n\nThe resulting list of @tech{syntax objects} has at most one expression\nfor each position and span.  Thus, the contents may be unreliable, but\nthe position information is reliable (i.e., it always indicates source\ncode that would be painted red in DrRacket when coverage information\nis used).\n\nNote that if the input program is a sequence of syntax values, either\nmake sure that they have @racket['program] as the source field, or use\nthe @racket[src] argument.  Using a sequence of S-expressions (not\n@tech{syntax objects}) for an input program leads to unreliable\ncoverage results, since each expression may be assigned a single\nsource location.}\n\n@defproc[(call-in-sandbox-context [evaluator (any/c . -> . any)]\n                                  [thunk (-> any)]\n                                  [unrestricted? boolean? #f])\n         any]{\n\nCalls the given @racket[thunk] in the context of a sandboxed\nevaluator.  The call is performed under the resource limits and\nevaluation handler that are used for evaluating expressions, unless\n@racket[unrestricted?] is specified as true.\n\nThis process is usually similar to @racket[(evaluator (list thunk))],\nexcept that it does not rely on the common meaning of a sexpr-based\nsyntax with list expressions as function application (which is not true\nin all languages).  Note that this is more useful for meta-level\noperations such as namespace manipulation, it is not intended to be used\nas a safe-evaluation replacement (i.e., using the sandbox evaluator as\nusual).\n\nIn addition, you can avoid some of the sandboxed restrictions by using\nyour own permissions, for example,\n@racketblock[\n  (let ([guard (current-security-guard)])\n    (call-in-sandbox-context\n      ev\n      (lambda ()\n        (parameterize ([current-security-guard guard])\n          (code:comment @#,t{can access anything you want here})\n          (delete-file \"/some/file\")))))\n]}\n\n@; ----------------------------------------------------------------------\n\n@section{Miscellaneous}\n\n@defthing[gui? boolean?]{\n\nFor backward compatibility, only: the result of @racket[gui-available?]\nat the time that @racketmodname[racket/sandbox] was instantiated.\n\nThe value of @racket[gui?] is no longer used by\n@racketmodname[racket/sandbox] itself. Instead,\n@racket[gui-available?]  and @racket[sandbox-gui-available] are\nchecked at the time that a sandbox evaluator is created.}\n\n\n@defproc[(call-with-limits [secs (or/c exact-nonnegative-integer? #f)]\n                           [mb (or/c exact-nonnegative-integer? #f)]\n                           [thunk (-> any)])\n         any]{\n\nExecutes the given @racket[thunk] with memory and time restrictions:\nif execution consumes more than @racket[mb] megabytes or more than\n@racket[secs] @tech{shallow time} seconds, then the computation is\naborted and an exception recognizable by @racket[exn:fail:resource?] is raised.  Otherwise, the result of\nthe thunk is returned as usual (a value, multiple values, or an\nexception).  Each of the two limits can be @racket[#f] to indicate the\nabsence of a limit. See also @racket[custodian-limit-memory] for\ninformation on memory limits.\n\nTo enforce limits, @racket[thunk] is run in a new thread. As usual,\nthe new thread starts with the same parameter values as the one that\ncalls @racket[call-with-limits]. @emph{Not} as usual, parameter values\nfrom the thread used to run @racket[thunk] are copied back to the\nthread that called @racket[call-with-limits] when @racket[thunk]\ncompletes.\n\nSandboxed evaluators use @racket[call-with-limits], according to the\n@racket[sandbox-eval-limits] setting and uses of\n@racket[set-eval-limits]: each expression evaluation is protected from\ntimeouts and memory problems. Use @racket[call-with-limits] directly\nonly to limit a whole testing session, instead of each expression.}\n\n@defform[(with-limits sec-expr mb-expr body ...)]{\n\nA macro version of @racket[call-with-limits].}\n\n@defproc[(call-with-deep-time-limit [secs exact-nonnegative-integer?]\n                                    [thunk (-> any)])\n         any]{\nExecutes the given @racket[thunk] with @tech{deep time} restrictions,\nand returns the values produced by @racket[thunk].\n\nThe given @racket[thunk] is run in a new thread. If it errors or if\nthe thread terminates returning a value, then @racket[(values)] is\nreturned.\n\n@history[#:changed \"1.1\" @elem{Changed to return @racket[thunk]'s result\n                               if it completes normally.}]}\n\n@defform[(with-deep-time-limit secs-expr body ...)]{\n\nA macro version of @racket[call-with-deep-time-limit].}\n\n@defproc*[([(exn:fail:resource? [v any/c]) boolean?]\n           [(exn:fail:resource-resource [exn exn:fail:resource?])\n            (or/c 'time 'memory 'deep-time)])]{\n\nA predicate and accessor for exceptions that are raised by\n@racket[call-with-limits].  The @racket[resource] field holds a\nsymbol, representing the resource that was expended. @racket['time] is\nused for @tech{shallow time} and @racket['deep-time] is used for\n@tech{deep time}.}\n\n@; ----------------------------------------------------------------------\n\n@close-eval[box-eval]\n", "\n(load-relative \"loadtest.rktl\")\n\n(Section 'sandbox)\n\n(require racket/sandbox)\n\n;; test call-in-nested-thread*\n(let ()\n  (define (kill) (kill-thread (current-thread)))\n  (define (shut) (custodian-shutdown-all (current-custodian)))\n  (define-syntax-rule (nested body ...)\n    (call-in-nested-thread* (lambda () body ...)))\n  (define-syntax-rule (nested* body ...)\n    (call-in-nested-thread* (lambda () body ...)\n                            (lambda () 'kill)\n                            (lambda () 'shut)))\n  (test 1 values (nested 1))\n  ;; propagates parameters\n  (let ([p (make-parameter #f)])\n    (nested (p 1))\n    (test 1 p)\n    (with-handlers ([void void]) (nested (p 2) (error \"foo\") (p 3)))\n    (test 2 p))\n  ;; propagates kill-thread\n  (test (void) thread-wait\n        (thread (lambda ()\n                  (nested (kill))\n                  ;; never reach here\n                  (semaphore-wait (make-semaphore 0)))))\n  ;; propagates custodian-shutdown-all\n  (test (void) values\n        (parameterize ([current-custodian (make-custodian)]) (nested (shut))))\n  ;; test handlers parameters\n  (test 'kill (lambda () (nested* (kill))))\n  (test 'shut (lambda () (nested* (shut)))))\n\n(let ([ev void]\n      [old-port #f]\n      [plumber (make-plumber)]\n      [out-port (open-output-bytes)])\n  (define (make-evaluator! #:requires [reqs null] . args)\n    (set! ev (apply make-evaluator args #:requires reqs)))\n  (define (make-base-evaluator! . args)\n    (set! ev (apply make-evaluator 'racket/base args)))\n  (define (make-base-evaluator/reqs! reqs . args)\n    (set! ev (apply make-evaluator 'racket/base #:requires reqs args)))\n  (define (make-module-evaluator! #:allow-read [allow null] . args)\n    ;; Close port from old evaluation, if any, to avoid later Windows\n    ;; problems deleting an open file:\n    (when old-port (close-input-port old-port) (set! old-port #f))\n    (when (input-port? (car args)) (set! old-port (car args)))\n    ;; Create and install the evaluator:\n    (set! ev (apply make-module-evaluator args #:allow-read allow)))\n  (define (run thunk)\n    (with-handlers ([void (lambda (e) (list 'exn: e))])\n      (call-with-values thunk (lambda vs (cons 'vals: vs)))))\n  (define (run* thunk)\n    (with-handlers ([void (lambda (e) (list 'exn: e))])\n      (call-with-values thunk\n          (case-lambda [(x) (and x #t)] [vs (cons 'vals: vs)]))))\n  (define (e-match? re run thunk)\n    (let ([x (run thunk)])\n      (if (and (list? x) (= 2 (length x)) (eq? 'exn: (car x)) (exn? (cadr x)))\n        (let ([m (exn-message (cadr x))])\n          (or (regexp-match? re m) (list 'bad-exception-message: m)))\n        x)))\n  (define-syntax thunk (lambda (stx)\n                         (syntax-case stx ()\n                           [(_ loc b ...)\n                            (syntax/loc #'loc\n                              (lambda () b ...))])))\n  (define-syntax t\n    (syntax-rules (--eval-- --top-- => <= =err> <err=)\n      [(t -?-) (void)]\n      [(t -?- --eval-- more ...) (t --eval-- more ...)]\n      [(t -?- --top--  more ...) (t --top--  more ...)]\n      [(t --eval-- E)         (test #t            run* (thunk E (ev `E)))]\n      [(t --top--  E)         (test #t            run* (thunk E E))]\n      [(t --eval-- E => R)    (test `(vals: ,R)   run  (thunk E (ev `E)))]\n      [(t --top--  E => R)    (test `(vals: ,R)   run  (thunk E E))]\n      [(t --eval-- E =err> R) (test #t e-match? R run  (thunk E (ev `E)))]\n      [(t --top--  E =err> R) (test #t e-match? R run  (thunk E E))]\n      [(t -?- E => R more ...)    (begin (t -?- E => R) (t -?- more ...))]\n      [(t -?- E =err> R more ...) (begin (t -?- E =err> R) (t -?- more ...))]\n      [(t -?- R <= E more ...)    (t -?- E => R more ...)]\n      [(t -?- R <err= E more ...) (t E =err> R more ...)]\n      ;; last so it doesn't match the above\n      [(t -?- E more ...) (begin (t -?- E) (t -?- more ...))]))\n  (define (make-prog . lines)\n    (apply string-append (map (lambda (l) (string-append l \"\\n\")) lines)))\n\n  (t\n\n   ;; basic stuff, limits\n   --top--\n   (make-base-evaluator!\n    (make-prog \"(define x 1)\"\n               \"(define (id x) x)\"\n               \"(define (plus1 x) x)\"\n               \"(define (loop) (loop))\"\n               \"(define (memory x) (vector-length (make-vector x)))\"))\n   (set-eval-limits ev 0.5 5)\n   --eval--\n   x => 1\n   (id 1) => 1\n   (id (plus1 x)) => 1\n   (define id2 id)\n   (id2 (id x)) => 1\n   blah =err> \"before its definition\"\n   ;; using a string for an input\n   \"1\" => 1\n   \"(+ 1 2) x (define y 9) y (set! y 99) y\" => 99\n   \"bad\\\"string\" =err> \"expected a closing\"\n   \"bad(string\" =err> \"expected a .\\\\).\"\n   \"bad)string\" =err> \"unexpected .\\\\).\"\n   \"(set! y 999) (string\" =err> \"expected a .\\\\).\"\n   y => 99\n   \"(set! y 999) (if)\" =err> \"if: bad syntax\"\n   y => 999\n   ;; test limits\n   (loop) =err> \"out of time\"\n   --top--\n   (when (custodian-memory-accounting-available?)\n     (t --eval-- (memory 3000000) =err> \"out of memory\"))\n   ;; test parameter settings (tricky to get this right since\n   ;; with-limits runs stuff in a different thread)\n   (set-eval-limits ev #f #f)\n   --eval--\n   (define p (make-parameter 0))\n   (p) => 0\n   (p 1)\n   (p) => 1\n   (thread-wait (thread (lambda () (p 100))))\n   (p) => 1\n   --top--\n   (set-eval-limits ev 1 3)\n   --eval--\n   (p) => 1\n   (p 2)\n   (p) => 2\n   (thread-wait (thread (lambda () (p 100))))\n   (p) => 2\n   --top--\n   (set-eval-limits ev #f #f)\n   --eval--\n   (p) => 2\n   ;; breaking\n   --top--\n   (thread (lambda () (sleep 1) (break-evaluator ev)))\n   --eval--\n   (sleep 2) =err> \"user break\"\n   (printf \"x = ~s\\n\" x) => (void)\n   ;; termination\n   --eval--\n   ,eof =err> \"terminated .eof.$\"\n   123  =err> \"terminated .eof.$\"\n   ,eof =err> \"terminated .eof.$\"\n\n   ;; other termination messages\n   --top-- (make-base-evaluator!) (kill-evaluator ev)\n   --eval-- 123 =err> \"terminated .evaluator-killed.$\"\n\n   ;; nested calls are forbidden\n   --top-- (make-base-evaluator!)\n   --eval-- (,ev 1) =err> \"nested evaluator call\"\n\n   ;; eval-limits apply to the sandbox creation too\n   --top--\n   (parameterize ([sandbox-eval-limits '(0.25 5)])\n     (make-base-evaluator! '(sleep 2)))\n   =err> \"out of time\"\n   (when (custodian-memory-accounting-available?)\n     (t --top--\n        (parameterize ([sandbox-eval-limits '(20 2)])\n          (make-base-evaluator! '(define a (for/list ([i (in-range 10)])\n                                             (collect-garbage)\n                                             (make-bytes 500000)))))\n        =err> \"out of memor(?:y)\"))\n\n   ;; check non-propagation of errors\n   --top--\n   (parameterize ([sandbox-propagate-exceptions #f]\n                  [sandbox-error-output 'string])\n     (make-base-evaluator! '(void)))\n   --eval--\n   (/ 0) => (void)\n   --top--\n   (regexp-match #rx\"^.*?\\n\" (get-error-output ev)) => '(\"/: division by zero\\n\")\n   ;; i/o\n   --top--\n   (parameterize ([sandbox-input \"3\\n\"]\n                  [sandbox-output 'string]\n                  [sandbox-error-output current-output-port])\n     (make-base-evaluator! '(define x 123)))\n   --eval-- (printf \"x = ~s\\n\" x) => (void)\n   --top--  (get-output ev) => \"x = 123\\n\"\n   --eval-- (printf \"x = ~s\\n\" x) => (void)\n   --top--  (get-output ev) => \"x = 123\\n\"\n   --eval-- (printf \"x*2 = ~s\\n\" (+ x x)) => (void)\n            (printf \"x*10 = ~s\\n\" (* 10 x)) => (void)\n   --top--  (get-output ev) => \"x*2 = 246\\nx*10 = 1230\\n\"\n   --eval-- (printf \"x*(read) = ~s\\n\" (* x (read))) => (void)\n   --top--  (get-output ev) => \"x*(read) = 369\\n\"\n   --eval-- (begin (printf \"a\\n\") (fprintf (current-error-port) \"b\\n\"))\n   --top--  (get-output ev) => \"a\\nb\\n\"\n            (get-error-output ev) => #f\n   --top--\n   (parameterize ([sandbox-output 'string] [sandbox-error-output 'string])\n     (make-base-evaluator!))\n   --eval-- (begin (printf \"a\\n\") (fprintf (current-error-port) \"b\\n\"))\n   --top--  (get-output ev) => \"a\\n\"\n            (get-error-output ev) => \"b\\n\"\n   --top--\n   (parameterize ([sandbox-input 'pipe]\n                  [sandbox-output 'bytes]\n                  [sandbox-error-output current-output-port]\n                  [sandbox-eval-limits '(0.25 10)])\n     (make-base-evaluator! '(define x 123)))\n   --eval--  (begin (printf \"x = ~s\\n\" x)\n                    (fprintf (current-error-port) \"err\\n\"))\n   --top--   (get-output ev) => #\"x = 123\\nerr\\n\"\n             (put-input ev \"blah\\n\")\n             (put-input ev \"blah\\n\")\n   --eval--  (read-line) => \"blah\"\n             (printf \"line = ~s\\n\" (read-line))\n   --top--   (get-output ev) => #\"line = \\\"blah\\\"\\n\"\n   --eval--  (read-line) =err> \"out of time\"\n   --top--   (put-input ev \"blah\\n\")\n             (put-input ev eof)\n   --eval--  (read-line) => \"blah\"\n             (read-line) => eof\n             (read-line) => eof\n   ;; test kill-evaluator here\n   --top--\n   (kill-evaluator ev) => (void)\n   --eval--\n   x =err> \"terminated .evaluator-killed.$\"\n   y =err> \"terminated .evaluator-killed.$\"\n   ,eof =err> \"terminated .evaluator-killed.$\"\n   --top--\n   (let-values ([(i1 o1) (make-pipe)] [(i2 o2) (make-pipe)])\n     ;; o1 -> i1 -ev-> o2 -> i2\n     (parameterize ([sandbox-input i1] [sandbox-output o2])\n       (make-base-evaluator! '(define x 123)))\n     (t --eval-- (printf \"x = ~s\\n\" x) => (void)\n        --top--  (read-line i2) => \"x = 123\"\n        --eval-- (printf \"x = ~s\\n\" x) => (void)\n        --top--  (read-line i2) => \"x = 123\"\n        --eval-- (printf \"x*2 = ~s\\n\" (+ x x)) => (void)\n                 (printf \"x*10 = ~s\\n\" (* 10 x)) => (void)\n        --top--  (read-line i2) => \"x*2 = 246\"\n                 (read-line i2) => \"x*10 = 1230\"\n                 (fprintf o1 \"3\\n\")\n        --eval-- (printf \"x*(read) = ~s\\n\" (* x (read))) => (void)\n        --top--  (read-line i2) => \"x*(read) = 369\"\n        ))\n\n   ;; sexprs as a program\n   --top--\n   (make-base-evaluator! '(define id (lambda (x) x)))\n   --eval--\n   (id 123) => 123\n   --top--\n   (make-base-evaluator! '(define id (lambda (x) x)) '(define fooo 999))\n   --eval--\n   (id fooo) => 999\n\n   ;; test source locations too\n   --top--\n   (make-base-evaluator! 0 1 2 '(define foo))\n   =err> \"^program:4:0: define:\"\n\n   ;; empty program for clean repls\n   --top--\n   (make-evaluator! '(begin))\n   --eval--\n   (define x (+ 1 2 3)) => (void)\n   x => 6\n   (define x (+ x 10)) => (void)\n   x => 16\n   --top--\n   (make-base-evaluator!)\n   --eval--\n   (define x (+ 1 2 3)) => (void)\n   x => 6\n   (define x (+ x 10)) => (void)\n   x => 16\n   --top--\n   (make-base-evaluator! '(define x (+ 1 2 3)))\n   --eval--\n   (define x (+ x 10)) =err> \"cannot re-define a constant\"\n\n   ;; whole program argument\n   --top--\n   (make-module-evaluator! '(module foo racket/base (define x 1)))\n   --eval--\n   x => 1\n   --top--\n   (make-module-evaluator! '(module foo racket/base (provide x) (define x 1)))\n   --eval--\n   x => 1\n   (define x 2) =err> \"cannot re-define a constant\"\n\n   ;; submodules\n   --top--\n   (parameterize ([sandbox-run-submodules '(go)])\n     (make-module-evaluator! '(module foo racket/base\n                                (define x 1)\n                                (define (set-x! v) (set! x v))\n                                (module+ go (set-x! 2)))))\n   --eval--\n   x => 2\n   --top--\n   (parameterize ([sandbox-run-submodules '(not-there)])\n     (make-module-evaluator! '(module foo racket/base\n                                (define x 1)\n                                (define (set-x! v) (set! x v))\n                                (module+ go (set-x! 2)))))\n   --eval--\n   x => 1\n\n   ;; `for-syntax' is allowed in #:requires:\n   --top--\n   (make-evaluator! 'scheme/base #:requires '((for-syntax racket/base)))\n   --eval--\n   (define-syntax (m stx) #'10)\n   m => 10\n\n   ;; limited FS access, allowed for requires\n   --top--\n   (let* ([tmp       (make-temporary-file \"sandboxtest~a\" 'directory)]\n          [strpath   (lambda xs (path->string (apply build-path xs)))]\n          [racketlib (strpath (path-only (collection-file-path \"main.rkt\" \"racket\")))]\n          [compiled (if (null? (use-compiled-file-paths))\n                        \"compiled\"\n                        (car (use-compiled-file-paths)))]\n          [list-lib  (strpath racketlib \"list.rkt\")]\n          [list-zo   (for/or ([root (in-list (current-compiled-file-roots))])\n                       (define file (cond\n                                      [(eq? root 'same)\n                                       (build-path racketlib compiled \"list_rkt.zo\")]\n                                      [(relative-path? root)\n                                       (build-path racketlib root compiled \"list_rkt.zo\")]\n                                      [else\n                                       (build-path (reroot-path racketlib root) compiled \"list_rkt.zo\")]))\n                       (and (file-exists? file)\n                            (path->string file)))]\n          [test-lib  (strpath tmp \"sandbox-test.rkt\")]\n          [test-zo   (strpath tmp compiled \"sandbox-test_rkt.zo\")]\n          [test2-lib (strpath tmp \"sandbox-test2.rkt\")]\n          [test2-zo  (strpath tmp compiled \"sandbox-test2_rkt.zo\")]\n          [test3-file \"sandbox-test3.rkt\"]\n          [test3-lib  (strpath tmp test3-file)]\n          [make-module-evaluator/rel (lambda (mod\n                                              #:allow-read [allow null] \n                                              #:allow-for-require [allow-for-require null] \n                                              #:allow-for-load [allow-for-load null])\n                                       (parameterize ([current-directory tmp]\n                                                      [current-load-relative-directory tmp])\n                                         (make-module-evaluator mod\n                                                                #:allow-read allow\n                                                                #:allow-for-require allow-for-require\n                                                                #:allow-for-load allow-for-load)))]\n          [make-evaluator/rel (lambda (lang)\n                                (parameterize ([current-directory tmp]\n                                               [current-load-relative-directory tmp])\n                                  (make-evaluator lang)))])\n     (t --top--\n        (make-base-evaluator!)\n        --eval--\n        ;; reading from collects is allowed\n        (list? (directory-list ,racketlib))\n        (file-exists? ,list-lib) => #t\n        (let ([p (open-input-file ,list-lib)]) (begin0 (input-port? p) (close-input-port p))) => #t\n        ;; writing is forbidden\n        (open-output-file ,list-lib) =err> \"`write' access denied\"\n        ;; reading from other places is forbidden\n        (directory-list ,tmp) =err> \"`read' access denied\"\n        ;; no network too\n        (require racket/tcp)\n        (tcp-listen 12345) =err> \"network access denied\"\n        --top--\n        ;; reading from a specified require is fine\n        (with-output-to-file test-lib\n          (lambda ()\n            (printf \"~s\\n\" '(module sandbox-test racket/base\n                              (define x 123) (provide x)))))\n        ;; run it\n        (make-module-evaluator! (string->path test-lib))\n        --eval--\n        x => 123\n        (length (with-input-from-file ,test-lib read)) => 5\n        ;; the directory is still not kosher\n        (directory-list ,tmp) =err> \"`read' access denied\"\n        --top--\n        ;; ports, strings, and bytes are also allowed, but in the case\n        ;; of ports, we have to specificaly enable access to the\n        ;; enclosing directory, since the port name connects it to the\n        ;; directory, and some part of the module infrastructure exploits that:\n        (make-module-evaluator!\n         (open-input-file (string->path test-lib))) =err> \"`exists' access denied\"\n        (make-module-evaluator! (open-input-file (string->path test-lib))\n                                ;; allowing a file read indirectly allows containing-directory\n                                ;; existence check:\n                                #:allow-read (list (string->path test-lib)))\n        (make-module-evaluator! (file->string (string->path test-lib)))\n        (make-module-evaluator! (file->bytes (string->path test-lib)))\n        --top--\n        ;; a relative-path string should work as a module to be `require'd,\n        ;; as opposed to a module to be `load'ed:\n        (with-output-to-file test3-lib\n          (lambda ()\n            (printf \"~s\\n\" '(module sandbox-test racket/base\n                              (provide #%module-begin)))))\n        (make-module-evaluator/rel `(module m ,test3-file)\n                                   #:allow-read (list test3-file))\n        ;; for-require is more clear:\n        (make-module-evaluator/rel `(module m ,test3-file)\n                                   #:allow-for-require (list test3-file))\n        ;; for-load isn't ok:\n        (make-module-evaluator/rel `(module m ,test3-file)\n                                   #:allow-for-load (list test3-file))\n        =err> \"`read' access denied\"\n        ;; an absolute path is treated like `for-load':\n        (make-module-evaluator/rel `(module m ,test3-file)\n                                   #:allow-read (list test3-lib))\n        =err> \"`read' access denied\"\n        (make-module-evaluator/rel `(module m ,test3-file)\n                                   #:allow-read (list (string->path test3-lib)))\n        =err> \"`read' access denied\"\n        ;; an absolute path with `for-require' is ok:\n        (make-module-evaluator/rel `(module m ,test3-file)\n                                   #:allow-for-require (list (string->path test3-lib)))\n        ;; make sure that the language is treated as a require:\n        (make-evaluator/rel test3-file)\n        --top--\n        ;; require it\n        (make-base-evaluator/reqs! `(,test-lib))\n        --eval--\n        x => 123\n        (length (with-input-from-file ,test-lib read)) => 5\n        ;; the directory is still not kosher\n        (directory-list ,tmp) =err> \"`read' access denied\"\n        --top--\n        ;; should work also for module evaluators\n        ;; --> NO!  Shouldn't make user code require whatever it wants\n        ;; (make-module-evaluator!\n        ;;   `(module foo racket/base (require (file ,test-lib))))\n        ;; --eval--\n        ;; x => 123\n        ;; (length (with-input-from-file ,test-lib read)) => 5\n        ;; ;; the directory is still not kosher\n        ;; (directory-list tmp) =err> \"file access denied\"\n        --top--\n        ;; explicitly allow access to tmp, and write access to a single file\n        (make-directory* (build-path tmp compiled))\n        (parameterize ([sandbox-path-permissions\n                        `((read ,tmp) (write ,test-zo)\n                          ,@(sandbox-path-permissions))])\n          (make-base-evaluator!))\n        --eval--\n        (length (with-input-from-file ,test-lib read)) => 5\n        (list? (directory-list ,tmp))\n        (open-output-file ,(build-path tmp \"blah\")) =err> \"access denied\"\n        (delete-directory ,(build-path tmp \"blah\")) =err> \"access denied\"\n        (list? (directory-list ,racketlib))\n        ;; we can read/write/delete list-zo, but we can't run bytecode from\n        ;; it due to the code inspector\n        (copy-file ,list-zo ,test-zo) => (void)\n        (copy-file ,test-zo ,list-zo) =err> \"access denied\"\n        ;; timestamp .zo file (needed under Windows):\n        (file-or-directory-modify-seconds ,test-zo (current-seconds))\n        ;; loading 'test gets 'list module declaration via \".zo\"\n        (load/use-compiled ,test-lib) =err> \"cannot use unsafe linklet loaded with non-original code inspector\"\n        (delete-file ,test-zo) => (void)\n        (delete-file ,test-lib) =err> \"`delete' access denied\"\n        --top--\n        ;; a more explicit test of bytcode loading, allowing rw access to the\n        ;; complete tmp directory, but read-bytecode only for test2-lib\n        (parameterize ([sandbox-path-permissions\n                        `((write ,tmp) (read-bytecode ,test2-lib)\n                          ,@(sandbox-path-permissions))])\n          (make-base-evaluator!))\n        --eval--\n        (define (cp from to)\n          (when (file-exists? to) (delete-file to))\n          (copy-file from to))\n        (cp ,list-lib ,test-lib)  (cp ,list-zo ,test-zo)\n        (cp ,list-lib ,test2-lib) (cp ,list-zo ,test2-zo)\n        ;; bytecode from test-lib is bad, even when we can read/write to it\n        (load ,test-zo) =err> \"cannot use unsafe linklet loaded with non-original code inspector\"\n        ;; bytecode from test2-lib is explicitly allowed\n        (load/use-compiled ,test2-lib)\n        (require 'list) => (void))\n     ((dynamic-require 'racket/file 'delete-directory/files) tmp))\n\n   ;; languages and requires\n   --top--\n   (make-base-evaluator/reqs! '(racket/list))\n   --eval--\n   (last-pair '(1 2 3)) => '(3)\n   (last-pair null) =err> \"contract violation\"\n\n   ;; coverage\n   --top--\n   (parameterize ([sandbox-coverage-enabled #t])\n     (make-base-evaluator!\n      (make-prog \"(define (foo x) (+ x 1))\"\n                 \"(define (bar x) (+ x 2))\"\n                 \"(equal? (foo 3) 4)\")))\n   (pair? (get-uncovered-expressions ev))\n   (pair? (get-uncovered-expressions ev #t))\n   --eval--\n   (foo 3) => 4\n   (bar 10) => 12\n   --top--\n   (null? (get-uncovered-expressions ev #f))\n   (pair? (get-uncovered-expressions ev)) ; no-tests coverage still the same\n\n   ;; misc parameters\n   --top--\n   (parameterize ([sandbox-init-hook\n                   (let ([old (sandbox-init-hook)])\n                     (lambda ()\n                       (old)\n                       (compile-enforce-module-constants #f)\n                       (compile-allow-set!-undefined #t)))])\n     (make-base-evaluator! '(define x 123)))\n   --eval--\n   (set! x 456) ; would be an error without the `enforce' parameter\n   x => 456\n   (set! y 789) ; would be an error without the `set!' parameter\n   y => 789\n\n   ;; test that output is also collected under the limit\n   --top--\n   (parameterize ([sandbox-output 'bytes]\n                  [sandbox-error-output current-output-port]\n                  [sandbox-memory-limit 4]\n                  [sandbox-eval-limits (case (system-type 'vm)\n                                         [(chez-scheme) '(2.5 4)]\n                                         [else '(2.5 1)])])\n     (make-base-evaluator!))\n   ;; GCing is needed to allow these to happen (note: the memory limit is very\n   ;; tight here, this test usually fails if the sandbox library is not\n   ;; compiled)\n   (let ([t (lambda ()\n              (t --eval-- (display (make-bytes 400000 65)) (collect-garbage)\n                 --top--  (bytes-length (get-output ev)) => 400000))])\n     ;; can go arbitrarily high here\n     (for ([i (in-range 20)]) (t)))\n\n   ;; test that killing the thread, shutting the custodian, or calling `exit'\n   ;; works fine first try it without limits (limits imply a nested\n   ;; thread/custodian)\n   --top--\n   (let ()\n     (define (3x2-terminations)\n       (t --top-- (make-base-evaluator!) --eval--\n          (kill-thread (current-thread)) =err> \"terminated .thread-killed.$\"\n          --top-- (make-base-evaluator!) --eval--\n          (custodian-shutdown-all (current-custodian))\n          =err> \"terminated .custodian-shutdown.$\"\n          --top-- (make-base-evaluator!) --eval--\n          (exit) =err> \"terminated .exited.$\"\n          ;; now test that it's fine when called directly\n          --top--\n          (make-base-evaluator!)\n          (call-in-sandbox-context ev\n            (lambda () (kill-thread (current-thread))))\n          =err> \"terminated .thread-killed.$\"\n          (make-base-evaluator!)\n          (call-in-sandbox-context ev\n            (lambda () (custodian-shutdown-all (current-custodian))))\n          =err> \"terminated .custodian-shutdown.$\"\n          (make-base-evaluator!)\n          (call-in-sandbox-context ev exit) =err> \"terminated .exited.$\"))\n     (define (test-terminations)\n       ;; try without, then with per-expression limits\n       (parameterize ([sandbox-eval-limits #f]) (3x2-terminations))\n       (3x2-terminations))\n     (test-terminations))\n\n   ;; when an expression is out of memory, the sandbox should stay alive\n   --top--\n   (when (custodian-memory-accounting-available?)\n     (t --top--\n        (parameterize ([sandbox-eval-limits '(100 5)]\n                       [sandbox-memory-limit 100])\n          (make-base-evaluator!))\n        --eval--\n        (define a '())\n        (define b 1)\n        (length\n         (for/fold ([v null]) ([i (in-range 20)])\n           ;; increases size of sandbox: it's reachable from it (outside of\n           ;; this evaluation) because `a' is defined there\n           (set! a (cons (make-bytes 500000) a))\n           (collect-garbage)\n           ;; increases size of the current evaluation\n           (cons (make-bytes 500000) v)))\n        =err> \"out of mem+o(?:ry)\"\n        b => 1))\n\n   --top--\n   (make-base-evaluator!)\n   --eval--\n   (syntax-original? #'x) => #t\n\n   --eval--\n   (putenv \"PEAR\" \"A Pear\") => #t\n   (getenv \"PEAR\") => \"A Pear\"\n   --top--\n   (getenv \"PEAR\") => #f\n\n   --top--\n   (parameterize ([sandbox-output (lambda () out-port)]\n                  [current-plumber plumber])\n     (make-base-evaluator!))\n   (plumber-add-flush! plumber (lambda (h) (set! plumber #f)))\n   (get-output-string out-port) => \"\"\n   --eval--\n   (plumber-flush-all (current-plumber)) ; should not affect `plumber`\n   (plumber-add-flush! (current-plumber) (lambda (h) (displayln \"flushed\")))\n   --top--\n   (not plumber) => #f\n   (get-output-string out-port) => \"\"\n   (plumber-flush-all plumber)\n   plumber => #f\n   --eval--\n   10 => 10 ; sync, so that flush has been propagated\n   --top--\n   (get-output-string out-port) => \"flushed\\n\"\n   --eval--\n   (exit) =err> \"terminated .exited.$\"\n   --top--\n   (get-output-string out-port) => \"flushed\\nflushed\\n\"\n\n   ;; tests for specials\n   --top--\n   ;; these are conditional so that we can run\n   ;; the tests even when htdp or r5rs is not available\n   (when (collection-file-path \"lang.rkt\" \"r5rs\" #:fail (\u03bb (s) #f))\n     (t --top--\n        (make-evaluator! '(special r5rs) \"(define x (eq? 'x 'X))\")\n        --eval--\n        x => #t\n        --top--\n        (make-base-evaluator! \"(define l null)\")\n        --eval--\n        (cond [null? l 0]) => 0\n        (last-pair l) =err> \"last-pair: undefined\"))\n\n   (when (collection-file-path \"htdp-beginner.rkt\" \"lang\" #:fail (\u03bb (s) #f))\n     (t --top--\n        (make-evaluator! '(special beginner)\n                         (make-prog \"(define l null)\" \"(define x 3.5)\"))\n        --eval--\n        (cond [null? l 0]) =err> \"no open parenthesis\"\n        --top--\n        (eq? (ev \"6\") (ev \"(sub1 (* 2 3.5))\"))\n        (eq? (ev \"6\") (ev \"(sub1 (* 2 x))\"))))))\n\n(parameterize ([current-module-declare-name (make-resolved-module-path 'junk)])\n  (define (avoid-module-declare-name)\n    (with-handlers ([exn? (lambda (_) #f)])\n      (kill-evaluator (make-evaluator 'racket/base))\n      #t))\n  (test #t avoid-module-declare-name))\n\n(let ()\n  (define (try lang)\n    (define e (make-evaluator lang))\n    (e '(require ffi/unsafe))\n    (with-handlers ([exn? exn-message]) (e '(ffi-lib #f)))\n    (e '(require racket/place))\n    (with-handlers ([exn? exn-message]) (e '(place pch 10)))\n    (with-handlers ([exn? exn-message]) (e '(dynamic-place \"x.rkt\" 10))))\n  (define r1 (try 'racket/base))\n  (define r2 (try '(begin)))\n  (test #t regexp-match?\n        #rx\"access disallowed by code inspector to protected\"\n        r1)\n  (test #t equal? r1 r2))\n\n;; ----------------------------------------\n;; Check that sandbox is not flushed if\n;; its custodian has been shut down:\n\n(let ()\n  (define p (make-plumber))\n\n  (define e0\n    (parameterize ([current-plumber p])\n      (call-with-trusted-sandbox-configuration\n       (lambda ()\n         (make-evaluator 'racket/base)))))\n\n  (e0 '(require racket/sandbox))\n  (e0 '(make-evaluator 'racket/base))\n\n  (kill-evaluator e0)\n  ;; e's plumber should not be flushed:\n  (plumber-flush-all p))\n\n;; ----------------------------------------\n\n;; Backup test for one in \"thread.rktl\", since this sandbox test\n;; originally exposed it:\n(let ()\n  (define sandbox (make-evaluator 'racket/base))\n  (sandbox \"(define result (call/cc (lambda (x) (lambda () (x 5)))))\")\n  (sandbox \"(if (procedure? result) (result) result)\"))\n\n;; ----------------------------------------\n\n;; Check that a sandbox can host a sandbox:\n(let ([e (make-module-evaluator (string-append \"#lang racket/base\\n\"))])\n  (e '(require racket/sandbox))\n  (e '(make-module-evaluator (string-append \"#lang racket/base\\n\"))))\n\n;; ----------------------------------------\n\n;; Check reader guard on a sandbox:\n(err/rt-test (make-module-evaluator \"#lang s-exp something-bad\" #:language 'racket/base)\n             exn:fail?\n             #rx\"disallowed reader module path: [(]submod s-exp reader[)]\")\n\n(void (make-module-evaluator \"#lang at-exp racket/base\"\n                             #:language 'racket/base))\n(void (make-module-evaluator \"#lang s-exp racket/base\"\n                             #:language 'racket/base\n                             #:readers '((submod s-exp reader)\n                                         s-exp/lang/reader\n                                         racket/base\n                                         (submod racket/base reader))))\n\n;; ----------------------------------------\n\n;; Check require guard on a sandbox:\n\n(err/rt-test (make-module-evaluator \"#lang racket/base (require json)\"\n                                    #:allow-syntactic-requires '(racket/runtime-config))\n             exn:fail?\n             #rx\"disallowed `require` module path: json\")\n(void\n (make-module-evaluator \"#lang racket/base (require json)\"\n                        #:allow-syntactic-requires '(racket/runtime-config json)))\n\n;; ----------------------------------------\n\n(report-errs)\n"], "filenames": ["pkgs/racket-doc/scribblings/reference/sandbox.scrbl", "pkgs/racket-test-core/tests/racket/sandbox.rktl"], "buggy_code_start_loc": [32, 724], "buggy_code_end_loc": [826, 724], "fixing_code_start_loc": [32, 725], "fixing_code_end_loc": [873, 753], "type": "CWE-610", "message": "Racket is a general-purpose programming language and an ecosystem for language-oriented programming. In versions prior to 8.2, code evaluated using the Racket sandbox could cause system modules to incorrectly use attacker-created modules instead of their intended dependencies. This could allow system functions to be controlled by the attacker, giving access to facilities intended to be restricted. This problem is fixed in Racket version 8.2. A workaround is available, depending on system settings. For systems that provide arbitrary Racket evaluation, external sandboxing such as containers limit the impact of the problem. For multi-user evaluation systems, such as the `handin-server` system, it is not possible to work around this problem and upgrading is required.", "other": {"cve": {"id": "CVE-2021-32773", "sourceIdentifier": "security-advisories@github.com", "published": "2021-07-20T00:15:08.883", "lastModified": "2021-07-29T16:22:26.857", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Racket is a general-purpose programming language and an ecosystem for language-oriented programming. In versions prior to 8.2, code evaluated using the Racket sandbox could cause system modules to incorrectly use attacker-created modules instead of their intended dependencies. This could allow system functions to be controlled by the attacker, giving access to facilities intended to be restricted. This problem is fixed in Racket version 8.2. A workaround is available, depending on system settings. For systems that provide arbitrary Racket evaluation, external sandboxing such as containers limit the impact of the problem. For multi-user evaluation systems, such as the `handin-server` system, it is not possible to work around this problem and upgrading is required."}, {"lang": "es", "value": "Racket es un lenguaje de programaci\u00f3n de prop\u00f3sito general y un ecosistema para la programaci\u00f3n orientada al lenguaje. En versiones anteriores a 8.2, el c\u00f3digo evaluado usando el sandbox de Racket pod\u00eda causar que los m\u00f3dulos del sistema usaran incorrectamente m\u00f3dulos creados por el atacante en lugar de sus dependencias previstas. Esto pod\u00eda permitir que las funciones del sistema fueran controladas por el atacante, dando acceso a instalaciones que se pretend\u00eda restringir. Este problema se ha corregido en la versi\u00f3n 8.2 de Racket. Hay una soluci\u00f3n disponible, dependiendo de la configuraci\u00f3n del sistema. Para los sistemas que proporcionan una evaluaci\u00f3n arbitraria de Racket, los sandboxs externos, como los contenedores, limitan el impacto del problema. Para los sistemas de evaluaci\u00f3n multiusuario, como el sistema \"handin-server\", no es posible solucionar este problema y es requerida una actualizaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-610"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-441"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:racket-lang:racket:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2", "matchCriteriaId": "B0BC1E7F-0154-4881-8B4E-D1C426BA55B4"}]}]}], "references": [{"url": "https://github.com/racket/racket/commit/6ca4ffeca1e5877d44f835760ad89f18488d97e1", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/racket/racket/security/advisories/GHSA-cgrw-p7p7-937c", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/racket/racket/commit/6ca4ffeca1e5877d44f835760ad89f18488d97e1"}}