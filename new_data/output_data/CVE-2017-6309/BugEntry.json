{"buggy_code": ["/*\n * file.c -- functions for dealing with file output\n *\n * Copyright (C)1999-2006 Mark Simpson <damned@theworld.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can either send email to this\n * program's maintainer or write to: The Free Software Foundation,\n * Inc.; 59 Temple Place, Suite 330; Boston, MA 02111-1307, USA.\n *\n */\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n#include \"common.h\"\n\n#include \"alloc.h\"\n#include \"date.h\"\n#include \"debug.h\"\n#include \"file.h\"\n#include \"mapi_attr.h\"\n#include \"options.h\"\n#include \"path.h\"\n\n#define TNEF_DEFAULT_FILENAME \"tnef-tmp\"\n\n/* ask user for confirmation of the action */\nstatic int\nconfirm_action (const char *prompt, ...)\n{\n    if (INTERACTIVE)\n    {\n\tint confirmed = 0;\n\tchar buf[BUFSIZ + 1];\n\tva_list args;\n\tva_start (args, prompt);\n\n\tVPRINTF(stdout, prompt, args);\n\tfgets (buf, BUFSIZ, stdin);\n\tif (buf[0] == 'y' || buf[0] == 'Y') confirmed = 1;\n\n\tva_end (args);\n\n\treturn confirmed;\n    }\n    return 1;\n}\n\nvoid\nfile_write (File *file, const char* directory)\n{\n    char *path = NULL;\n\n    assert (file);\n    if (!file) return;\n\n    if (file->name == NULL)\n    {\n\tfile->name = strdup( TNEF_DEFAULT_FILENAME );\n\tdebug_print (\"No file name specified, using default %s.\\n\", TNEF_DEFAULT_FILENAME);\n    }\n\n    if ( file->path == NULL )\n    {\n\tfile->path = munge_fname( file->name );\n\n\tif (file->path == NULL)\n\t{\n\t    file->path = strdup( TNEF_DEFAULT_FILENAME );\n\t    debug_print (\"No path name available, using default %s.\\n\", TNEF_DEFAULT_FILENAME);\n\t}\n    }\n\n    path = concat_fname( directory, file->path );\n\n    if (path == NULL)\n    {\n\tpath = strdup( TNEF_DEFAULT_FILENAME );\n\tdebug_print (\"No path generated, using default %s.\\n\", TNEF_DEFAULT_FILENAME);\n    }\n\n    debug_print (\"%sWRITING\\t|\\t%s\\t|\\t%s\\n\",\n\t\t ((LIST_ONLY==0)?\"\":\"NOT \"), file->name, path);\n\n    if (!LIST_ONLY)\n    {\n\tFILE *fp = NULL;\n\n\tif (!confirm_action (\"extract %s?\", file->name)) return;\n\tif (!OVERWRITE_FILES)\n\t{\n\t    if (file_exists (path))\n\t    {\n\t\tif (!NUMBER_FILES)\n\t\t{\n\t\t    fprintf (stderr,\n\t\t\t     \"tnef: %s: Could not create file: File exists\\n\",\n\t\t\t     path);\n\t\t    return;\n\t\t}\n\t\telse\n\t\t{\n\t\t    char *tmp = find_free_number (path);\n\t\t    debug_print (\"Renaming %s to %s\\n\", path, tmp);\n\t\t    XFREE (path);\n\t\t    path = tmp;\n\t\t}\n\t    }\n\t}\n\n\tfp = fopen (path, \"wb\");\n\tif (fp == NULL)\n\t{\n\t    perror (path);\n\t    exit (1);\n\t}\n\tif (fwrite (file->data, 1, file->len, fp) != file->len)\n\t{\n\t    perror (path);\n\t    exit (1);\n\t}\n\tfclose (fp);\n    }\n\n    if (LIST_ONLY || VERBOSE_ON)\n    {\n\tif (LIST_ONLY && VERBOSE_ON)\n\t{\n\t    /* FIXME: print out date and stuff */\n\t    const char *date_str = date_to_str(&file->dt);\n\t    fprintf (stdout, \"%11lu\\t|\\t%s\\t|\\t%s\\t|\\t%s\", \n\t\t     (unsigned long)file->len,\n\t\t     date_str+4, /* skip the day of week */\n\t\t     file->name,\n\t\t     path);\n\t}\n\telse\n\t{\n            fprintf (stdout, \"%s\\t|\\t%s\", file->name, path);\n\t}\n\tif ( SHOW_MIME )\n\t{\n\t    fprintf (stdout, \"\\t|\\t%s\", file->mime_type ? file->mime_type : \"unknown\");\n            fprintf (stdout, \"\\t|\\t%s\", file->content_id ? file->content_id : \"\");\n\t}\n        fprintf (stdout, \"\\n\");\n    }\n    XFREE(path);\n}\n\nstatic void\nfile_add_mapi_attrs (File* file, MAPI_Attr** attrs)\n{\n    int i;\n    for (i = 0; attrs[i]; i++)\n    {\n\tMAPI_Attr* a = attrs[i];\n\n\tif (a->num_values)\n\t{\n\n\t    switch (a->name)\n\t    {\n\t    case MAPI_ATTACH_LONG_FILENAME:\n\t\tif (file->name) XFREE(file->name);\n\t\tfile->name = strdup( (char*)a->values[0].data.buf );\n\t\tbreak;\n\n\t    case MAPI_ATTACH_DATA_OBJ:\n\t\tfile->len = a->values[0].len;\n\t\tif (file->data) XFREE (file->data);\n\t\tfile->data = CHECKED_XMALLOC (unsigned char, file->len);\n\t\tmemmove (file->data, a->values[0].data.buf, file->len);\n\t\tbreak;\n\n             case MAPI_ATTACH_MIME_TAG:\n\t\tif (file->mime_type) XFREE (file->mime_type);\n\t\tfile->mime_type = CHECKED_XMALLOC (char, a->values[0].len);\n\t\tmemmove (file->mime_type, a->values[0].data.buf, a->values[0].len);\n\t\tbreak;\n\n                case MAPI_ATTACH_CONTENT_ID:\n                    if (file->content_id) XFREE(file->content_id);\n                    file->content_id = CHECKED_XMALLOC (char, a->values[0].len);\n                    memmove (file->content_id, a->values[0].data.buf, a->values[0].len);\n                    break;\n\n\t    default:\n\t\tbreak;\n\t    }\n\t}\n    }\n}\n\nvoid\nfile_add_attr (File* file, Attr* attr)\n{\n    assert (file && attr);\n    if (!(file && attr)) return;\n\n    /* we only care about some things... we will skip most attributes */\n    switch (attr->name)\n    {\n    case attATTACHMODIFYDATE:\n\tcopy_date_from_attr (attr, &file->dt);\n\tbreak;\n\n    case attATTACHMENT:\n    {\n\tMAPI_Attr **mapi_attrs = mapi_attr_read (attr->len, attr->buf);\n\tif (mapi_attrs)\n\t{\n\t    file_add_mapi_attrs (file, mapi_attrs);\n\t    mapi_attr_free_list (mapi_attrs);\n\t    XFREE (mapi_attrs);\n\t}\n    }\n    break;\n\n    case attATTACHTITLE:\n\tfile->name = strdup( (char*)attr->buf );\n\tbreak;\n\n    case attATTACHDATA:\n\tfile->len = attr->len;\n\tfile->data = CHECKED_XMALLOC(unsigned char, attr->len);\n\tmemmove (file->data, attr->buf, attr->len);\n\tbreak;\n\n    default:\n\tbreak;\n    }\n}\n\nvoid\nfile_free (File *file)\n{\n    if (file)\n    {\n\tXFREE (file->name);\n\tXFREE (file->data);\n\tXFREE (file->mime_type);\n        XFREE (file->content_id);\n        XFREE (file->path);\n\tmemset (file, '\\0', sizeof (File));\n    }\n}\n\n", "/*\n * tnef.c -- extract files from microsoft TNEF format\n *\n * Copyright (C)1999-2006 Mark Simpson <damned@theworld.com>\n * Copyright (C)1997 Thomas Boll  <tb@boll.ch>\t[ORIGINAL AUTHOR]\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can either send email to this\n * program's maintainer or write to: The Free Software Foundation,\n * Inc.; 59 Temple Place, Suite 330; Boston, MA 02111-1307, USA.\n *\n * Commentary:\n *       scans tnef file and extracts all attachments\n *       attachments are written to their original file-names if possible\n */\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n#include \"common.h\"\n\n#include \"tnef.h\"\n\n#include \"alloc.h\"\n#include \"attr.h\"\n#include \"debug.h\"\n#include \"file.h\"\n#include \"mapi_attr.h\"\n#include \"options.h\"\n#include \"path.h\"\n#include \"rtf.h\"\n#include \"util.h\"\n\ntypedef struct\n{\n    VarLenData **text_body;\n    VarLenData **html_bodies;\n    VarLenData **rtf_bodies;\n} MessageBody;\n\ntypedef enum\n{\n    TEXT = 't',\n    HTML = 'h',\n    RTF = 'r'\n} MessageBodyTypes;\n\n/* Reads and decodes a object from the stream */\n\f\nstatic Attr*\nread_object (FILE *in)\n{\n    Attr *attr = NULL;\n\n    /* peek to see if there is more to read from this stream */\n    int tmp_char = fgetc(in);\n    if (tmp_char == -1) return NULL;\n    ungetc(tmp_char, in);\n\n    attr = attr_read (in);\n\n    return attr;\n}\n\nstatic void \nfree_bodies(VarLenData **bodies, int len)\n{\n    while (len--)\n    {\n        XFREE(bodies[len]->data);\n        XFREE(bodies[len]);\n    }\n}\n\nstatic File**\nget_body_files (const char* filename,\n\t\tconst char pref,\n\t\tconst MessageBody* body)\n{\n    File **files = NULL;\n    VarLenData **data;\n    char *ext = \"\";\n    char *type = \"unknown\";\n    int i;\n\n    switch (pref)\n    {\n    case 'r':\n\tdata = body->rtf_bodies;\n\text = \".rtf\";\n            type = \"text/rtf\";\n\tbreak;\n    case 'h':\n\tdata = body->html_bodies;\n\text = \".html\";\n            type = \"text/html\";\n\tbreak;\n    case 't':\n\tdata = body->text_body;\n\text = \".txt\";\n            type = \"text/plain\";\n\tbreak;\n    default:\n\tdata = NULL;\n\tbreak;\n    }\n\n    if (data)\n    {\n\tint count = 0;\n\tchar *tmp \n\t    = CHECKED_XCALLOC(char, \n\t\t\t      strlen(filename) + strlen(ext) + 1);\n\tstrcpy (tmp, filename);\n\tstrcat (tmp, ext);\n\n        char *mime = CHECKED_XCALLOC(char, strlen(type) + 1);\n        strcpy (mime, type);\n\n\t/* first get a count */\n\twhile (data[count++]);\n\n\tfiles = (File**)XCALLOC(File*, count + 1);\n\tfor (i = 0; data[i]; i++)\n\t{\n\t    files[i] = (File*)XCALLOC(File, 1);\n\t    files[i]->name = tmp;\n            files[i]->mime_type = mime;\n\t    files[i]->len = data[i]->len;\n\t    files[i]->data \n\t\t= CHECKED_XMALLOC(unsigned char, data[i]->len);\n\t    memmove (files[i]->data, data[i]->data, data[i]->len);\n\t}\n    }\n    return files;\n}\n\nstatic VarLenData**\nget_text_data (Attr *attr)\n{\n    VarLenData **body = XCALLOC(VarLenData*, 2);\n\n    body[0] = XCALLOC(VarLenData, 1);\n    body[0]->len = attr->len;\n    body[0]->data = CHECKED_XCALLOC(unsigned char, attr->len);\n    memmove (body[0]->data, attr->buf, attr->len);\n    return body;\n}\n\nstatic VarLenData**\nget_html_data (MAPI_Attr *a)\n{\n    VarLenData **body = XCALLOC(VarLenData*, a->num_values + 1);\n\n    int j;\n    for (j = 0; j < a->num_values; j++)\n    {\n\tbody[j] = XMALLOC(VarLenData, 1);\n\tbody[j]->len = a->values[j].len;\n\tbody[j]->data = CHECKED_XCALLOC(unsigned char, a->values[j].len);\n\tmemmove (body[j]->data, a->values[j].data.buf, body[j]->len);\n    }\n    return body;\n}\n\nint\ndata_left (FILE* input_file)\n{\n    int retval = 1;\n    \n    if (feof(input_file)) retval = 0;\n    else if (input_file != stdin)\n    {\n\t/* check if there is enough data left */\n\tstruct stat statbuf;\n\tsize_t pos, data_left;\n\tfstat (fileno(input_file), &statbuf);\n\tpos = ftell(input_file);\n\tdata_left = (statbuf.st_size - pos);\n\n\tif (data_left > 0 && data_left < MINIMUM_ATTR_LENGTH) \n\t{\n\t    if ( CRUFT_SKIP )\n\t    {\n\t\t/* look for specific flavor of cruft -- trailing \"\\r\\n\" */\n\n\t\tif ( data_left == 2 )\n\t\t{\n\t\t    int c = fgetc( input_file );\n\n\t\t    if ( c < 0 )\t/* this should never happen */\n\t\t    {\n\t\t\tfprintf( stderr, \"ERROR: confused beyond all redemption.\\n\" );\n\t\t\texit (1);\n\t\t    }\n\n\t\t    ungetc( c, input_file );\n\n\t\t    if ( c == 0x0d )\t\t/* test for \"\\r\" part of \"\\r\\n\" */\n\t\t    {\n\t\t\t/* \"trust\" that next char is 0x0a and ignore this cruft */\n\n\t\t\tif ( VERBOSE_ON )\n\t\t\t    fprintf( stderr, \"WARNING: garbage at end of file (ignored)\\n\" );\n\n\t\t\tif ( DEBUG_ON )\n\t\t\t    debug_print( \"!!garbage at end of file (ignored)\\n\" );\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tfprintf( stderr, \"ERROR: garbage at end of file.\\n\" );\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    fprintf (stderr, \"ERROR: garbage at end of file.\\n\");\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tfprintf (stderr, \"ERROR: garbage at end of file.\\n\");\n\t    }\n\n\t    retval = 0;\n\t}\n    }\n    return retval;\n}\n\n\f\n/* The entry point into this module.  This parses an entire TNEF file. */\nint\nparse_file (FILE* input_file, char* directory, \n\t    char *body_filename, char *body_pref,\n\t    int flags)\n{\n    uint32 d;\n    uint16 key;\n    Attr *attr = NULL;\n    File *file = NULL;\n    int rtf_size = 0, html_size = 0;\n    MessageBody body;\n    memset (&body, '\\0', sizeof (MessageBody));\n\n    /* store the program options in our file global variables */\n    g_flags = flags;\n\n    /* check that this is in fact a TNEF file */\n    d = geti32(input_file);\n    if (d != TNEF_SIGNATURE)\n    {\n\tfprintf (stdout, \"Seems not to be a TNEF file\\n\");\n\treturn 1;\n    }\n\n    /* Get the key */\n    key = geti16(input_file);\n    debug_print (\"TNEF Key: %hx\\n\", key);\n\n    /* The rest of the file is a series of 'messages' and 'attachments' */\n    while ( data_left( input_file ) )\n    {\n\tattr = read_object( input_file );\n\n\tif ( attr == NULL ) break;\n\n\t/* This signals the beginning of a file */\n\tif (attr->name == attATTACHRENDDATA)\n\t{\n\t    if (file)\n\t    {\n\t\tfile_write (file, directory);\n\t\tfile_free (file);\n\t    }\n\t    else\n\t    {\n\t\tfile = CHECKED_XCALLOC (File, 1);\n\t    }\n\t}\n\n\t/* Add the data to our lists. */\n\tswitch (attr->lvl_type)\n\t{\n\tcase LVL_MESSAGE:\n\t    if (attr->name == attBODY)\n\t    {\n\t\tbody.text_body = get_text_data (attr);\n\t    }\n\t    else if (attr->name == attMAPIPROPS) \n\t    { \n\t\tMAPI_Attr **mapi_attrs \n\t\t    = mapi_attr_read (attr->len, attr->buf); \n\t\tif (mapi_attrs)\n\t\t{ \n\t\t    int i;\n\t\t    for (i = 0; mapi_attrs[i]; i++)\n\t\t    {\n\t\t\tMAPI_Attr *a = mapi_attrs[i];\n\t\t\t    \n\t\t\tif (a->name == MAPI_BODY_HTML)\n\t\t\t{\n\t\t\t    body.html_bodies = get_html_data (a);\n                                html_size = a->num_values;\n\t\t\t}\n\t\t\telse if (a->name == MAPI_RTF_COMPRESSED)\n\t\t\t{\n\t\t\t    body.rtf_bodies = get_rtf_data (a);\n                                rtf_size = a->num_values;\n\t\t\t}\n\t\t    }\n\t\t    /* cannot save attributes to file, since they\n\t\t     * are not attachment attributes */ \n\t\t    /* file_add_mapi_attrs (file, mapi_attrs); */\n\t\t    mapi_attr_free_list (mapi_attrs); \n\t\t    XFREE (mapi_attrs); \n\t\t}\n\t    }\n\t    break;\n\tcase LVL_ATTACHMENT:\n\t    file_add_attr (file, attr);\n\t    break;\n\tdefault:\n\t    fprintf (stderr, \"Invalid lvl type on attribute: %d\\n\",\n\t\t     attr->lvl_type);\n\t    return 1;\n\t    break;\n\t}\n\tattr_free (attr);\n\tXFREE (attr);\n    }\n\n    if (file)\n    {\n\tfile_write (file, directory);\n\tfile_free (file);\n\tXFREE (file);\n    }\n    \n    /* Write the message body */\n    if (flags & SAVEBODY)\n    {\n\tint i = 0;\n\tint all_flag = 0;\n\tif (strcmp (body_pref, \"all\") == 0) \n\t{\n\t    all_flag = 1;\n\t    body_pref = \"rht\";\n\t}\n\n\tfor (; i < 3; i++)\n\t{\n\t    File **files\n\t\t= get_body_files (body_filename, body_pref[i], &body);\n\t    if (files)\n\t    {\n\t\tint j = 0; \n\t\tfor (; files[j]; j++)\n\t\t{\n\t\t    file_write(files[j], directory);\n\t\t    file_free (files[j]);\n                    XFREE(files[j]);\n\t\t}\n\t\tXFREE(files);\n\t\tif (!all_flag) break;\n\t    }\n\t}\n    }\n\n    if (body.text_body)\n    {\n        free_bodies(body.text_body, 1);\n        XFREE(body.text_body);\n    }\n    if (rtf_size > 0)\n    {\n        free_bodies(body.rtf_bodies, rtf_size);\n        XFREE(body.rtf_bodies);\n    }\n    if (html_size > 0)\n    {\n        free_bodies(body.html_bodies, html_size);\n        XFREE(body.html_bodies);\n    }\n    return 0;\n}\n\n"], "fixing_code": ["/*\n * file.c -- functions for dealing with file output\n *\n * Copyright (C)1999-2006 Mark Simpson <damned@theworld.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can either send email to this\n * program's maintainer or write to: The Free Software Foundation,\n * Inc.; 59 Temple Place, Suite 330; Boston, MA 02111-1307, USA.\n *\n */\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n#include \"common.h\"\n\n#include \"alloc.h\"\n#include \"date.h\"\n#include \"debug.h\"\n#include \"file.h\"\n#include \"mapi_attr.h\"\n#include \"options.h\"\n#include \"path.h\"\n\n#define TNEF_DEFAULT_FILENAME \"tnef-tmp\"\n\n/* ask user for confirmation of the action */\nstatic int\nconfirm_action (const char *prompt, ...)\n{\n    if (INTERACTIVE)\n    {\n\tint confirmed = 0;\n\tchar buf[BUFSIZ + 1];\n\tva_list args;\n\tva_start (args, prompt);\n\n\tVPRINTF(stdout, prompt, args);\n\tfgets (buf, BUFSIZ, stdin);\n\tif (buf[0] == 'y' || buf[0] == 'Y') confirmed = 1;\n\n\tva_end (args);\n\n\treturn confirmed;\n    }\n    return 1;\n}\n\nvoid\nfile_write (File *file, const char* directory)\n{\n    char *path = NULL;\n\n    assert (file);\n    if (!file) return;\n\n    if (file->name == NULL)\n    {\n\tfile->name = strdup( TNEF_DEFAULT_FILENAME );\n\tdebug_print (\"No file name specified, using default %s.\\n\", TNEF_DEFAULT_FILENAME);\n    }\n\n    if ( file->path == NULL )\n    {\n\tfile->path = munge_fname( file->name );\n\n\tif (file->path == NULL)\n\t{\n\t    file->path = strdup( TNEF_DEFAULT_FILENAME );\n\t    debug_print (\"No path name available, using default %s.\\n\", TNEF_DEFAULT_FILENAME);\n\t}\n    }\n\n    path = concat_fname( directory, file->path );\n\n    if (path == NULL)\n    {\n\tpath = strdup( TNEF_DEFAULT_FILENAME );\n\tdebug_print (\"No path generated, using default %s.\\n\", TNEF_DEFAULT_FILENAME);\n    }\n\n    debug_print (\"%sWRITING\\t|\\t%s\\t|\\t%s\\n\",\n\t\t ((LIST_ONLY==0)?\"\":\"NOT \"), file->name, path);\n\n    if (!LIST_ONLY)\n    {\n\tFILE *fp = NULL;\n\n\tif (!confirm_action (\"extract %s?\", file->name)) return;\n\tif (!OVERWRITE_FILES)\n\t{\n\t    if (file_exists (path))\n\t    {\n\t\tif (!NUMBER_FILES)\n\t\t{\n\t\t    fprintf (stderr,\n\t\t\t     \"tnef: %s: Could not create file: File exists\\n\",\n\t\t\t     path);\n\t\t    return;\n\t\t}\n\t\telse\n\t\t{\n\t\t    char *tmp = find_free_number (path);\n\t\t    debug_print (\"Renaming %s to %s\\n\", path, tmp);\n\t\t    XFREE (path);\n\t\t    path = tmp;\n\t\t}\n\t    }\n\t}\n\n\tfp = fopen (path, \"wb\");\n\tif (fp == NULL)\n\t{\n\t    perror (path);\n\t    exit (1);\n\t}\n\tif (fwrite (file->data, 1, file->len, fp) != file->len)\n\t{\n\t    perror (path);\n\t    exit (1);\n\t}\n\tfclose (fp);\n    }\n\n    if (LIST_ONLY || VERBOSE_ON)\n    {\n\tif (LIST_ONLY && VERBOSE_ON)\n\t{\n\t    /* FIXME: print out date and stuff */\n\t    const char *date_str = date_to_str(&file->dt);\n\t    fprintf (stdout, \"%11lu\\t|\\t%s\\t|\\t%s\\t|\\t%s\", \n\t\t     (unsigned long)file->len,\n\t\t     date_str+4, /* skip the day of week */\n\t\t     file->name,\n\t\t     path);\n\t}\n\telse\n\t{\n            fprintf (stdout, \"%s\\t|\\t%s\", file->name, path);\n\t}\n\tif ( SHOW_MIME )\n\t{\n\t    fprintf (stdout, \"\\t|\\t%s\", file->mime_type ? file->mime_type : \"unknown\");\n            fprintf (stdout, \"\\t|\\t%s\", file->content_id ? file->content_id : \"\");\n\t}\n        fprintf (stdout, \"\\n\");\n    }\n    XFREE(path);\n}\n\nstatic void\nfile_add_mapi_attrs (File* file, MAPI_Attr** attrs)\n{\n    int i;\n    for (i = 0; attrs[i]; i++)\n    {\n\tMAPI_Attr* a = attrs[i];\n\n\tif (a->num_values)\n\t{\n\n\t    switch (a->name)\n\t    {\n\t    case MAPI_ATTACH_LONG_FILENAME:\n\t\tassert(a->type == szMAPI_STRING);\n\t\tif (file->name) XFREE(file->name);\n\t\tfile->name = strdup( (char*)a->values[0].data.buf );\n\t\tbreak;\n\n\t    case MAPI_ATTACH_DATA_OBJ:\n\t\tassert((a->type == szMAPI_BINARY) || (a->type == szMAPI_OBJECT));\n\t\tfile->len = a->values[0].len;\n\t\tif (file->data) XFREE (file->data);\n\t\tfile->data = CHECKED_XMALLOC (unsigned char, file->len);\n\t\tmemmove (file->data, a->values[0].data.buf, file->len);\n\t\tbreak;\n\n             case MAPI_ATTACH_MIME_TAG:\n\t\tassert(a->type == szMAPI_STRING);\n\t\tif (file->mime_type) XFREE (file->mime_type);\n\t\tfile->mime_type = CHECKED_XMALLOC (char, a->values[0].len);\n\t\tmemmove (file->mime_type, a->values[0].data.buf, a->values[0].len);\n\t\tbreak;\n\n                case MAPI_ATTACH_CONTENT_ID:\n                    assert(a->type == szMAPI_STRING);\n                    if (file->content_id) XFREE(file->content_id);\n                    file->content_id = CHECKED_XMALLOC (char, a->values[0].len);\n                    memmove (file->content_id, a->values[0].data.buf, a->values[0].len);\n                    break;\n\n\t    default:\n\t\tbreak;\n\t    }\n\t}\n    }\n}\n\nvoid\nfile_add_attr (File* file, Attr* attr)\n{\n    assert (file && attr);\n    if (!(file && attr)) return;\n\n    /* we only care about some things... we will skip most attributes */\n    switch (attr->name)\n    {\n    case attATTACHMODIFYDATE:\n\tcopy_date_from_attr (attr, &file->dt);\n\tbreak;\n\n    case attATTACHMENT:\n    {\n\tMAPI_Attr **mapi_attrs = mapi_attr_read (attr->len, attr->buf);\n\tif (mapi_attrs)\n\t{\n\t    file_add_mapi_attrs (file, mapi_attrs);\n\t    mapi_attr_free_list (mapi_attrs);\n\t    XFREE (mapi_attrs);\n\t}\n    }\n    break;\n\n    case attATTACHTITLE:\n\tfile->name = strdup( (char*)attr->buf );\n\tbreak;\n\n    case attATTACHDATA:\n\tfile->len = attr->len;\n\tfile->data = CHECKED_XMALLOC(unsigned char, attr->len);\n\tmemmove (file->data, attr->buf, attr->len);\n\tbreak;\n\n    default:\n\tbreak;\n    }\n}\n\nvoid\nfile_free (File *file)\n{\n    if (file)\n    {\n\tXFREE (file->name);\n\tXFREE (file->data);\n\tXFREE (file->mime_type);\n        XFREE (file->content_id);\n        XFREE (file->path);\n\tmemset (file, '\\0', sizeof (File));\n    }\n}\n\n", "/*\n * tnef.c -- extract files from microsoft TNEF format\n *\n * Copyright (C)1999-2006 Mark Simpson <damned@theworld.com>\n * Copyright (C)1997 Thomas Boll  <tb@boll.ch>\t[ORIGINAL AUTHOR]\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can either send email to this\n * program's maintainer or write to: The Free Software Foundation,\n * Inc.; 59 Temple Place, Suite 330; Boston, MA 02111-1307, USA.\n *\n * Commentary:\n *       scans tnef file and extracts all attachments\n *       attachments are written to their original file-names if possible\n */\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n#include \"common.h\"\n\n#include \"tnef.h\"\n\n#include \"alloc.h\"\n#include \"attr.h\"\n#include \"debug.h\"\n#include \"file.h\"\n#include \"mapi_attr.h\"\n#include \"options.h\"\n#include \"path.h\"\n#include \"rtf.h\"\n#include \"util.h\"\n\ntypedef struct\n{\n    VarLenData **text_body;\n    VarLenData **html_bodies;\n    VarLenData **rtf_bodies;\n} MessageBody;\n\ntypedef enum\n{\n    TEXT = 't',\n    HTML = 'h',\n    RTF = 'r'\n} MessageBodyTypes;\n\n/* Reads and decodes a object from the stream */\n\f\nstatic Attr*\nread_object (FILE *in)\n{\n    Attr *attr = NULL;\n\n    /* peek to see if there is more to read from this stream */\n    int tmp_char = fgetc(in);\n    if (tmp_char == -1) return NULL;\n    ungetc(tmp_char, in);\n\n    attr = attr_read (in);\n\n    return attr;\n}\n\nstatic void \nfree_bodies(VarLenData **bodies, int len)\n{\n    while (len--)\n    {\n        XFREE(bodies[len]->data);\n        XFREE(bodies[len]);\n    }\n}\n\nstatic File**\nget_body_files (const char* filename,\n\t\tconst char pref,\n\t\tconst MessageBody* body)\n{\n    File **files = NULL;\n    VarLenData **data;\n    char *ext = \"\";\n    char *type = \"unknown\";\n    int i;\n\n    switch (pref)\n    {\n    case 'r':\n\tdata = body->rtf_bodies;\n\text = \".rtf\";\n            type = \"text/rtf\";\n\tbreak;\n    case 'h':\n\tdata = body->html_bodies;\n\text = \".html\";\n            type = \"text/html\";\n\tbreak;\n    case 't':\n\tdata = body->text_body;\n\text = \".txt\";\n            type = \"text/plain\";\n\tbreak;\n    default:\n\tdata = NULL;\n\tbreak;\n    }\n\n    if (data)\n    {\n\tint count = 0;\n\tchar *tmp \n\t    = CHECKED_XCALLOC(char, \n\t\t\t      strlen(filename) + strlen(ext) + 1);\n\tstrcpy (tmp, filename);\n\tstrcat (tmp, ext);\n\n        char *mime = CHECKED_XCALLOC(char, strlen(type) + 1);\n        strcpy (mime, type);\n\n\t/* first get a count */\n\twhile (data[count++]);\n\n\tfiles = (File**)XCALLOC(File*, count + 1);\n\tfor (i = 0; data[i]; i++)\n\t{\n\t    files[i] = (File*)XCALLOC(File, 1);\n\t    files[i]->name = tmp;\n            files[i]->mime_type = mime;\n\t    files[i]->len = data[i]->len;\n\t    files[i]->data \n\t\t= CHECKED_XMALLOC(unsigned char, data[i]->len);\n\t    memmove (files[i]->data, data[i]->data, data[i]->len);\n\t}\n    }\n    return files;\n}\n\nstatic VarLenData**\nget_text_data (Attr *attr)\n{\n    VarLenData **body = XCALLOC(VarLenData*, 2);\n\n    body[0] = XCALLOC(VarLenData, 1);\n    body[0]->len = attr->len;\n    body[0]->data = CHECKED_XCALLOC(unsigned char, attr->len);\n    memmove (body[0]->data, attr->buf, attr->len);\n    return body;\n}\n\nstatic VarLenData**\nget_html_data (MAPI_Attr *a)\n{\n    VarLenData **body = XCALLOC(VarLenData*, a->num_values + 1);\n\n    int j;\n    for (j = 0; j < a->num_values; j++)\n    {\n        if (a->type == szMAPI_BINARY) {\n \t    body[j] = XMALLOC(VarLenData, 1);\n\t    body[j]->len = a->values[j].len;\n\t    body[j]->data = CHECKED_XCALLOC(unsigned char, a->values[j].len);\n\t    memmove (body[j]->data, a->values[j].data.buf, body[j]->len);\n        }\n    }\n    return body;\n}\n\nint\ndata_left (FILE* input_file)\n{\n    int retval = 1;\n    \n    if (feof(input_file)) retval = 0;\n    else if (input_file != stdin)\n    {\n\t/* check if there is enough data left */\n\tstruct stat statbuf;\n\tsize_t pos, data_left;\n\tfstat (fileno(input_file), &statbuf);\n\tpos = ftell(input_file);\n\tdata_left = (statbuf.st_size - pos);\n\n\tif (data_left > 0 && data_left < MINIMUM_ATTR_LENGTH) \n\t{\n\t    if ( CRUFT_SKIP )\n\t    {\n\t\t/* look for specific flavor of cruft -- trailing \"\\r\\n\" */\n\n\t\tif ( data_left == 2 )\n\t\t{\n\t\t    int c = fgetc( input_file );\n\n\t\t    if ( c < 0 )\t/* this should never happen */\n\t\t    {\n\t\t\tfprintf( stderr, \"ERROR: confused beyond all redemption.\\n\" );\n\t\t\texit (1);\n\t\t    }\n\n\t\t    ungetc( c, input_file );\n\n\t\t    if ( c == 0x0d )\t\t/* test for \"\\r\" part of \"\\r\\n\" */\n\t\t    {\n\t\t\t/* \"trust\" that next char is 0x0a and ignore this cruft */\n\n\t\t\tif ( VERBOSE_ON )\n\t\t\t    fprintf( stderr, \"WARNING: garbage at end of file (ignored)\\n\" );\n\n\t\t\tif ( DEBUG_ON )\n\t\t\t    debug_print( \"!!garbage at end of file (ignored)\\n\" );\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tfprintf( stderr, \"ERROR: garbage at end of file.\\n\" );\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    fprintf (stderr, \"ERROR: garbage at end of file.\\n\");\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tfprintf (stderr, \"ERROR: garbage at end of file.\\n\");\n\t    }\n\n\t    retval = 0;\n\t}\n    }\n    return retval;\n}\n\n\f\n/* The entry point into this module.  This parses an entire TNEF file. */\nint\nparse_file (FILE* input_file, char* directory, \n\t    char *body_filename, char *body_pref,\n\t    int flags)\n{\n    uint32 d;\n    uint16 key;\n    Attr *attr = NULL;\n    File *file = NULL;\n    int rtf_size = 0, html_size = 0;\n    MessageBody body;\n    memset (&body, '\\0', sizeof (MessageBody));\n\n    /* store the program options in our file global variables */\n    g_flags = flags;\n\n    /* check that this is in fact a TNEF file */\n    d = geti32(input_file);\n    if (d != TNEF_SIGNATURE)\n    {\n\tfprintf (stdout, \"Seems not to be a TNEF file\\n\");\n\treturn 1;\n    }\n\n    /* Get the key */\n    key = geti16(input_file);\n    debug_print (\"TNEF Key: %hx\\n\", key);\n\n    /* The rest of the file is a series of 'messages' and 'attachments' */\n    while ( data_left( input_file ) )\n    {\n\tattr = read_object( input_file );\n\n\tif ( attr == NULL ) break;\n\n\t/* This signals the beginning of a file */\n\tif (attr->name == attATTACHRENDDATA)\n\t{\n\t    if (file)\n\t    {\n\t\tfile_write (file, directory);\n\t\tfile_free (file);\n\t    }\n\t    else\n\t    {\n\t\tfile = CHECKED_XCALLOC (File, 1);\n\t    }\n\t}\n\n\t/* Add the data to our lists. */\n\tswitch (attr->lvl_type)\n\t{\n\tcase LVL_MESSAGE:\n\t    if (attr->name == attBODY)\n\t    {\n\t\tbody.text_body = get_text_data (attr);\n\t    }\n\t    else if (attr->name == attMAPIPROPS) \n\t    { \n\t\tMAPI_Attr **mapi_attrs \n\t\t    = mapi_attr_read (attr->len, attr->buf); \n\t\tif (mapi_attrs)\n\t\t{ \n\t\t    int i;\n\t\t    for (i = 0; mapi_attrs[i]; i++)\n\t\t    {\n\t\t\tMAPI_Attr *a = mapi_attrs[i];\n\t\t\n\t\t\tif (a->type == szMAPI_BINARY && a->name == MAPI_BODY_HTML)\n\t\t\t{\n\t\t\t    body.html_bodies = get_html_data (a);\n                                html_size = a->num_values;\n\t\t\t}\n\t\t\telse if (a->type == szMAPI_BINARY && a->name == MAPI_RTF_COMPRESSED)\n\t\t\t{\n\t\t\t    body.rtf_bodies = get_rtf_data (a);\n                                rtf_size = a->num_values;\n\t\t\t}\n\t\t    }\n\t\t    /* cannot save attributes to file, since they\n\t\t     * are not attachment attributes */ \n\t\t    /* file_add_mapi_attrs (file, mapi_attrs); */\n\t\t    mapi_attr_free_list (mapi_attrs); \n\t\t    XFREE (mapi_attrs); \n\t\t}\n\t    }\n\t    break;\n\tcase LVL_ATTACHMENT:\n\t    file_add_attr (file, attr);\n\t    break;\n\tdefault:\n\t    fprintf (stderr, \"Invalid lvl type on attribute: %d\\n\",\n\t\t     attr->lvl_type);\n\t    return 1;\n\t    break;\n\t}\n\tattr_free (attr);\n\tXFREE (attr);\n    }\n\n    if (file)\n    {\n\tfile_write (file, directory);\n\tfile_free (file);\n\tXFREE (file);\n    }\n    \n    /* Write the message body */\n    if (flags & SAVEBODY)\n    {\n\tint i = 0;\n\tint all_flag = 0;\n\tif (strcmp (body_pref, \"all\") == 0) \n\t{\n\t    all_flag = 1;\n\t    body_pref = \"rht\";\n\t}\n\n\tfor (; i < 3; i++)\n\t{\n\t    File **files\n\t\t= get_body_files (body_filename, body_pref[i], &body);\n\t    if (files)\n\t    {\n\t\tint j = 0; \n\t\tfor (; files[j]; j++)\n\t\t{\n\t\t    file_write(files[j], directory);\n\t\t    file_free (files[j]);\n                    XFREE(files[j]);\n\t\t}\n\t\tXFREE(files);\n\t\tif (!all_flag) break;\n\t    }\n\t}\n    }\n\n    if (body.text_body)\n    {\n        free_bodies(body.text_body, 1);\n        XFREE(body.text_body);\n    }\n    if (rtf_size > 0)\n    {\n        free_bodies(body.rtf_bodies, rtf_size);\n        XFREE(body.rtf_bodies);\n    }\n    if (html_size > 0)\n    {\n        free_bodies(body.html_bodies, html_size);\n        XFREE(body.html_bodies);\n    }\n    return 0;\n}\n\n"], "filenames": ["src/file.c", "src/tnef.c"], "buggy_code_start_loc": [175, 169], "buggy_code_end_loc": [193, 318], "fixing_code_start_loc": [176, 169], "fixing_code_end_loc": [198, 320], "type": "CWE-125", "message": "An issue was discovered in tnef before 1.4.13. Two type confusions have been identified in the parse_file() function. These might lead to invalid read and write operations, controlled by an attacker.", "other": {"cve": {"id": "CVE-2017-6309", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-24T04:59:00.637", "lastModified": "2019-03-13T17:58:06.633", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in tnef before 1.4.13. Two type confusions have been identified in the parse_file() function. These might lead to invalid read and write operations, controlled by an attacker."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en tnef en versiones anteriores a 1.4.13. Se han identificado dos confusiones tipo en la funci\u00f3n parse_file(). Esto puede conducir a operaciones de lectura y escritura no v\u00e1lidas, controladas por un atacante."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tnef_project:tnef:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.4.12", "matchCriteriaId": "89F0C6D8-2B85-44C4-A8C0-1BDBCAC4E6DC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3798", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96427", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/verdammelt/tnef/blob/master/ChangeLog", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/verdammelt/tnef/commit/8dccf79857ceeb7a6d3e42c1e762e7b865d5344d", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201708-02", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.x41-dsec.de/lab/advisories/x41-2017-004-tnef/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/verdammelt/tnef/commit/8dccf79857ceeb7a6d3e42c1e762e7b865d5344d"}}