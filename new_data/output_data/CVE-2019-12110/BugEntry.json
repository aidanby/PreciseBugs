{"buggy_code": ["/* $Id: upnpredirect.c,v 1.95 2018/07/06 12:05:48 nanard Exp $ */\n/* vim: tabstop=4 shiftwidth=4 noexpandtab\n * MiniUPnP project\n * http://miniupnp.free.fr/ or https://miniupnp.tuxfamily.org/\n * (c) 2006-2018 Thomas Bernard\n * This software is subject to the conditions detailed\n * in the LICENCE file provided within the distribution */\n\n#include <stdlib.h>\n#include <string.h>\n#include <syslog.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\n#include \"macros.h\"\n#include \"config.h\"\n#include \"upnpredirect.h\"\n#include \"upnpglobalvars.h\"\n#include \"upnpevents.h\"\n#include \"portinuse.h\"\n#include \"upnputils.h\"\n#if defined(USE_NETFILTER)\n#include \"netfilter/iptcrdr.h\"\n#endif\n#if defined(USE_PF)\n#include \"pf/obsdrdr.h\"\n#endif\n#if defined(USE_IPF)\n#include \"ipf/ipfrdr.h\"\n#endif\n#if defined(USE_IPFW)\n#include \"ipfw/ipfwrdr.h\"\n#endif\n#ifdef USE_MINIUPNPDCTL\n#include <stdio.h>\n#include <unistd.h>\n#endif\n#ifdef ENABLE_LEASEFILE\n#include <sys/stat.h>\n#endif\n\n/* from <inttypes.h> */\n#ifndef PRIu64\n#define PRIu64 \"llu\"\n#endif\n\n/* proto_atoi()\n * convert the string \"UDP\" or \"TCP\" to IPPROTO_UDP and IPPROTO_UDP */\nstatic int\nproto_atoi(const char * protocol)\n{\n\tint proto = IPPROTO_TCP;\n\tif(strcasecmp(protocol, \"UDP\") == 0)\n\t\tproto = IPPROTO_UDP;\n#ifdef IPPROTO_UDPLITE\n\telse if(strcasecmp(protocol, \"UDPLITE\") == 0)\n\t\tproto = IPPROTO_UDPLITE;\n#endif /* IPPROTO_UDPLITE */\n\treturn proto;\n}\n\n/* proto_itoa()\n * convert IPPROTO_UDP, IPPROTO_UDP, etc. to \"UDP\", \"TCP\" */\nstatic const char *\nproto_itoa(int proto)\n{\n\tconst char * protocol;\n\tswitch(proto) {\n\tcase IPPROTO_UDP:\n\t\tprotocol = \"UDP\";\n\t\tbreak;\n\tcase IPPROTO_TCP:\n\t\tprotocol = \"TCP\";\n\t\tbreak;\n#ifdef IPPROTO_UDPLITE\n\tcase IPPROTO_UDPLITE:\n\t\tprotocol = \"UDPLITE\";\n\t\tbreak;\n#endif /* IPPROTO_UDPLITE */\n\tdefault:\n\t\tprotocol = \"*UNKNOWN*\";\n\t}\n\treturn protocol;\n}\n\n#ifdef ENABLE_LEASEFILE\nstatic int\nlease_file_add(unsigned short eport,\n               const char * iaddr,\n               unsigned short iport,\n               int proto,\n               const char * desc,\n               unsigned int timestamp)\n{\n\tFILE * fd;\n\n\tif (lease_file == NULL) return 0;\n\n\tfd = fopen( lease_file, \"a\");\n\tif (fd==NULL) {\n\t\tsyslog(LOG_ERR, \"could not open lease file: %s\", lease_file);\n\t\treturn -1;\n\t}\n\n\t/* convert our time to unix time\n     * if LEASEFILE_USE_REMAINING_TIME is defined, only the remaining time is stored */\n\tif (timestamp != 0) {\n\t\ttimestamp -= upnp_time();\n#ifndef LEASEFILE_USE_REMAINING_TIME\n\t\ttimestamp += time(NULL);\n#endif\n\t}\n\n\tfprintf(fd, \"%s:%hu:%s:%hu:%u:%s\\n\",\n\t        proto_itoa(proto), eport, iaddr, iport,\n\t        timestamp, desc);\n\tfclose(fd);\n\n\treturn 0;\n}\n\nstatic int\nlease_file_remove(unsigned short eport, int proto)\n{\n\tFILE* fd, *fdt;\n\tint tmp;\n\tchar buf[512];\n\tchar str[32];\n\tchar tmpfilename[128];\n\tint str_size, buf_size;\n\n\n\tif (lease_file == NULL) return 0;\n\n\tif (strlen( lease_file) + 7 > sizeof(tmpfilename)) {\n\t\tsyslog(LOG_ERR, \"Lease filename is too long\");\n\t\treturn -1;\n\t}\n\n\tsnprintf( tmpfilename, sizeof(tmpfilename), \"%sXXXXXX\", lease_file);\n\n\tfd = fopen( lease_file, \"r\");\n\tif (fd==NULL) {\n\t\treturn 0;\n\t}\n\n\tsnprintf( str, sizeof(str), \"%s:%u\", proto_itoa(proto), eport);\n\tstr_size = strlen(str);\n\n\ttmp = mkstemp(tmpfilename);\n\tif (tmp==-1) {\n\t\tfclose(fd);\n\t\tsyslog(LOG_ERR, \"could not open temporary lease file\");\n\t\treturn -1;\n\t}\n\tfchmod(tmp, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tfdt = fdopen(tmp, \"a\");\n\n\tbuf[sizeof(buf)-1] = 0;\n\twhile( fgets(buf, sizeof(buf)-1, fd) != NULL) {\n\t\tbuf_size = strlen(buf);\n\n\t\tif (buf_size < str_size || strncmp(str, buf, str_size)!=0) {\n\t\t\tfwrite(buf, buf_size, 1, fdt);\n\t\t}\n\t}\n\tfclose(fdt);\n\tfclose(fd);\n\n\tif (rename(tmpfilename, lease_file) < 0) {\n\t\tsyslog(LOG_ERR, \"could not rename temporary lease file to %s\", lease_file);\n\t\tremove(tmpfilename);\n\t}\n\n\treturn 0;\n\n}\n\n/* reload_from_lease_file()\n * read lease_file and add the rules contained\n */\nint reload_from_lease_file()\n{\n\tFILE * fd;\n\tchar * p;\n\tunsigned short eport, iport;\n\tchar * proto;\n\tchar * iaddr;\n\tchar * desc;\n\tchar * rhost;\n\tunsigned int leaseduration;\n\tunsigned int timestamp;\n\ttime_t current_time;\n#ifndef LEASEFILE_USE_REMAINING_TIME\n\ttime_t current_unix_time;\n#endif\n\tchar line[128];\n\tint r;\n\n\tif(!lease_file) return -1;\n\tfd = fopen( lease_file, \"r\");\n\tif (fd==NULL) {\n\t\tsyslog(LOG_ERR, \"could not open lease file: %s\", lease_file);\n\t\treturn -1;\n\t}\n\tif(unlink(lease_file) < 0) {\n\t\tsyslog(LOG_WARNING, \"could not unlink file %s : %m\", lease_file);\n\t}\n\n\tcurrent_time = upnp_time();\n#ifndef LEASEFILE_USE_REMAINING_TIME\n\tcurrent_unix_time = time(NULL);\n#endif\n\twhile(fgets(line, sizeof(line), fd)) {\n\t\tsyslog(LOG_DEBUG, \"parsing lease file line '%s'\", line);\n\t\tproto = line;\n\t\tp = strchr(line, ':');\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"unrecognized data in lease file\");\n\t\t\tcontinue;\n\t\t}\n\t\t*(p++) = '\\0';\n\t\tiaddr = strchr(p, ':');\n\t\tif(!iaddr) {\n\t\t\tsyslog(LOG_ERR, \"unrecognized data in lease file\");\n\t\t\tcontinue;\n\t\t}\n\t\t*(iaddr++) = '\\0';\n\t\teport = (unsigned short)atoi(p);\n\t\tp = strchr(iaddr, ':');\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"unrecognized data in lease file\");\n\t\t\tcontinue;\n\t\t}\n\t\t*(p++) = '\\0';\n\t\tiport = (unsigned short)atoi(p);\n\t\tp = strchr(p, ':');\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"unrecognized data in lease file\");\n\t\t\tcontinue;\n\t\t}\n\t\t*(p++) = '\\0';\n\t\tdesc = strchr(p, ':');\n\t\tif(!desc) {\n\t\t\tsyslog(LOG_ERR, \"unrecognized data in lease file\");\n\t\t\tcontinue;\n\t\t}\n\t\t*(desc++) = '\\0';\n\t\t/*timestamp = (unsigned int)atoi(p);*/\n\t\ttimestamp = (unsigned int)strtoul(p, NULL, 10);\n\t\t/* trim description */\n\t\twhile(isspace(*desc))\n\t\t\tdesc++;\n\t\tp = desc;\n\t\twhile(*(p+1))\n\t\t\tp++;\n\t\twhile(isspace(*p) && (p > desc))\n\t\t\t*(p--) = '\\0';\n\n\t\tif(timestamp > 0) {\n#ifdef LEASEFILE_USE_REMAINING_TIME\n\t\t\tleaseduration = timestamp;\n\t\t\ttimestamp += current_time;\t/* convert to our time */\n#else\n\t\t\tif(timestamp <= (unsigned int)current_unix_time) {\n\t\t\t\tsyslog(LOG_NOTICE, \"already expired lease in lease file\");\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tleaseduration = timestamp - current_unix_time;\n\t\t\t\ttimestamp = leaseduration + current_time; /* convert to our time */\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tleaseduration = 0;\t/* default value */\n\t\t}\n\t\trhost = NULL;\n\t\tr = upnp_redirect(rhost, eport, iaddr, iport, proto, desc, leaseduration);\n\t\tif(r == -1) {\n\t\t\tsyslog(LOG_ERR, \"Failed to redirect %hu -> %s:%hu protocol %s\",\n\t\t\t       eport, iaddr, iport, proto);\n\t\t} else if(r == -2) {\n\t\t\t/* Add the redirection again to the lease file */\n\t\t\tlease_file_add(eport, iaddr, iport, proto_atoi(proto),\n\t\t\t               desc, timestamp);\n\t\t}\n\t}\n\tfclose(fd);\n\n\treturn 0;\n}\n\n#ifdef LEASEFILE_USE_REMAINING_TIME\nvoid lease_file_rewrite(void)\n{\n\tint index;\n\tunsigned short eport, iport;\n\tint proto;\n\tchar iaddr[32];\n\tchar desc[64];\n\tchar rhost[40];\n\tunsigned int timestamp;\n\n\tif (lease_file == NULL) return;\n\tremove(lease_file);\n\tfor(index = 0; ; index++) {\n\t\tif(get_redirect_rule_by_index(index, 0/*ifname*/, &eport, iaddr, sizeof(iaddr),\n\t\t                              &iport, &proto, desc, sizeof(desc),\n\t\t                              rhost, sizeof(rhost), &timestamp,\n\t\t                              0, 0) < 0)\n\t\t\tbreak;\n\t\tif(lease_file_add(eport, iaddr, iport, proto, desc, timestamp) < 0)\n\t\t\tbreak;\n\t}\n}\n#endif\n#endif\n\n/* upnp_redirect()\n * calls OS/fw dependent implementation of the redirection.\n * protocol should be the string \"TCP\" or \"UDP\"\n * returns: 0 on success\n *          -1 failed to redirect\n *          -2 already redirected\n *          -3 permission check failed\n *          -4 already redirected (other mechanism)\n */\nint\nupnp_redirect(const char * rhost, unsigned short eport,\n              const char * iaddr, unsigned short iport,\n              const char * protocol, const char * desc,\n              unsigned int leaseduration)\n{\n\tint proto, r;\n\tchar iaddr_old[32];\n\tchar rhost_old[32];\n\tunsigned short iport_old;\n\tstruct in_addr address;\n\tunsigned int timestamp;\n\n\tproto = proto_atoi(protocol);\n\tif(inet_aton(iaddr, &address) <= 0) {\n\t\tsyslog(LOG_ERR, \"inet_aton(%s) FAILED\", iaddr);\n\t\treturn -1;\n\t}\n\n\tif(!check_upnp_rule_against_permissions(upnppermlist, num_upnpperm,\n\t                                        eport, address, iport)) {\n\t\tsyslog(LOG_INFO, \"redirection permission check failed for \"\n\t\t                 \"%hu->%s:%hu %s\", eport, iaddr, iport, protocol);\n\t\treturn -3;\n\t}\n\t/* IGDv1 (WANIPConnection:1 Service Template Version 1.01 / Nov 12, 2001)\n\t * - 2.2.20.PortMappingDescription :\n\t *  Overwriting Previous / Existing Port Mappings:\n\t * If the RemoteHost, ExternalPort, PortMappingProtocol and InternalClient\n\t * are exactly the same as an existing mapping, the existing mapping values\n\t * for InternalPort, PortMappingDescription, PortMappingEnabled and\n\t * PortMappingLeaseDuration are overwritten.\n\t *  Rejecting a New Port Mapping:\n\t * In cases where the RemoteHost, ExternalPort and PortMappingProtocol\n\t * are the same as an existing mapping, but the InternalClient is\n\t * different, the action is rejected with an appropriate error.\n\t *  Add or Reject New Port Mapping behavior based on vendor implementation:\n\t * In cases where the ExternalPort, PortMappingProtocol and InternalClient\n\t * are the same, but RemoteHost is different, the vendor can choose to\n\t * support both mappings simultaneously, or reject the second mapping\n\t * with an appropriate error.\n\t *\n\t * - 2.4.16.AddPortMapping\n\t * This action creates a new port mapping or overwrites an existing\n\t * mapping with the same internal client. If the ExternalPort and\n\t * PortMappingProtocol pair is already mapped to another internal client,\n\t * an error is returned.\n\t *\n\t * IGDv2 (WANIPConnection:2 Service Standardized DCP (SDCP) Sep 10, 2010)\n\t * Protocol ExternalPort RemoteHost InternalClient Result\n\t *     =         =           \u2260           \u2260         Failure\n\t *     =         =           \u2260           =         Failure or success\n\t *                                                 (vendor specific)\n\t *     =         =           =           \u2260         Failure\n\t *     =         =           =           =         Success (overwrite)\n\t */\n\trhost_old[0] = '\\0';\n\tr = get_redirect_rule(ext_if_name, eport, proto,\n\t                      iaddr_old, sizeof(iaddr_old), &iport_old, 0, 0,\n\t                      rhost_old, sizeof(rhost_old),\n\t                      &timestamp, 0, 0);\n\tif(r == 0) {\n\t\tif(strcmp(iaddr, iaddr_old)==0 &&\n\t\t   ((rhost == NULL && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, \"*\") == 0) && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, rhost_old) == 0)))) {\n\t\t\tsyslog(LOG_INFO, \"updating existing port mapping %hu %s (rhost '%s') => %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\t\tif(iport != iport_old) {\n\t\t\t\tr = update_portmapping(ext_if_name, eport, proto, iport, desc, timestamp);\n\t\t\t} else {\n\t\t\t\tr = update_portmapping_desc_timestamp(ext_if_name, eport, proto, desc, timestamp);\n\t\t\t}\n#ifdef ENABLE_LEASEFILE\n\t\t\tif(r == 0) {\n\t\t\t\tlease_file_remove(eport, proto);\n\t\t\t\tlease_file_add(eport, iaddr, iport, proto, desc, timestamp);\n\t\t\t}\n#endif /* ENABLE_LEASEFILE */\n\t\t\treturn r;\n\t\t} else {\n\t\t\tsyslog(LOG_INFO, \"port %hu %s (rhost '%s') already redirected to %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\treturn -2;\n\t\t}\n#ifdef CHECK_PORTINUSE\n\t} else if (port_in_use(ext_if_name, eport, proto, iaddr, iport) > 0) {\n\t\tsyslog(LOG_INFO, \"port %hu protocol %s already in use\",\n\t\t       eport, protocol);\n\t\treturn -4;\n#endif /* CHECK_PORTINUSE */\n\t} else {\n\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\tsyslog(LOG_INFO, \"redirecting port %hu to %s:%hu protocol %s for: %s\",\n\t\t\teport, iaddr, iport, protocol, desc);\n\t\treturn upnp_redirect_internal(rhost, eport, iaddr, iport, proto,\n\t\t                              desc, timestamp);\n\t}\n}\n\nint\nupnp_redirect_internal(const char * rhost, unsigned short eport,\n                       const char * iaddr, unsigned short iport,\n                       int proto, const char * desc,\n                       unsigned int timestamp)\n{\n\t/*syslog(LOG_INFO, \"redirecting port %hu to %s:%hu protocol %s for: %s\",\n\t\teport, iaddr, iport, protocol, desc);\t\t\t*/\n\tif(disable_port_forwarding)\n\t\treturn -1;\n\tif(add_redirect_rule2(ext_if_name, rhost, eport, iaddr, iport, proto,\n\t                      desc, timestamp) < 0) {\n\t\treturn -1;\n\t}\n\n#ifdef ENABLE_LEASEFILE\n\tlease_file_add( eport, iaddr, iport, proto, desc, timestamp);\n#endif\n/*\tsyslog(LOG_INFO, \"creating pass rule to %s:%hu protocol %s for: %s\",\n\t\tiaddr, iport, protocol, desc);*/\n\tif(add_filter_rule2(ext_if_name, rhost, iaddr, eport, iport, proto, desc) < 0) {\n\t\t/* clean up the redirect rule */\n#if !defined(__linux__)\n\t\tdelete_redirect_rule(ext_if_name, eport, proto);\n#endif\n\t\treturn -1;\n\t}\n\tif(timestamp > 0) {\n\t\tif(!nextruletoclean_timestamp || (timestamp < nextruletoclean_timestamp))\n\t\t\tnextruletoclean_timestamp = timestamp;\n\t}\n#ifdef ENABLE_EVENTS\n\t/* the number of port mappings changed, we must\n\t * inform the subscribers */\n\tupnp_event_var_change_notify(EWanIPC);\n#endif\n\treturn 0;\n}\n\n\n\n/* Firewall independent code which call the FW dependent code. */\nint\nupnp_get_redirection_infos(unsigned short eport, const char * protocol,\n                           unsigned short * iport,\n                           char * iaddr, int iaddrlen,\n                           char * desc, int desclen,\n                           char * rhost, int rhostlen,\n                           unsigned int * leaseduration)\n{\n\tint r;\n\tunsigned int timestamp;\n\ttime_t current_time;\n\n\tif(desc && (desclen > 0))\n\t\tdesc[0] = '\\0';\n\tif(rhost && (rhostlen > 0))\n\t\trhost[0] = '\\0';\n\tr = get_redirect_rule(ext_if_name, eport, proto_atoi(protocol),\n\t                      iaddr, iaddrlen, iport, desc, desclen,\n\t                      rhost, rhostlen, &timestamp,\n\t                      0, 0);\n\tif(r == 0 &&\n\t   timestamp > 0 &&\n\t   timestamp > (unsigned int)(current_time = upnp_time())) {\n\t\t*leaseduration = timestamp - current_time;\n\t} else {\n\t\t*leaseduration = 0;\n\t}\n\treturn r;\n}\n\nint\nupnp_get_redirection_infos_by_index(int index,\n                                    unsigned short * eport, char * protocol,\n                                    unsigned short * iport,\n                                    char * iaddr, int iaddrlen,\n                                    char * desc, int desclen,\n                                    char * rhost, int rhostlen,\n                                    unsigned int * leaseduration)\n{\n\t/*char ifname[IFNAMSIZ];*/\n\tint proto = 0;\n\tunsigned int timestamp;\n\ttime_t current_time;\n\n\tif(desc && (desclen > 0))\n\t\tdesc[0] = '\\0';\n\tif(rhost && (rhostlen > 0))\n\t\trhost[0] = '\\0';\n\tif(get_redirect_rule_by_index(index, 0/*ifname*/, eport, iaddr, iaddrlen,\n\t                              iport, &proto, desc, desclen,\n\t                              rhost, rhostlen, &timestamp,\n\t                              0, 0) < 0)\n\t\treturn -1;\n\telse\n\t{\n\t\tcurrent_time = upnp_time();\n\t\t*leaseduration = (timestamp > (unsigned int)current_time)\n\t\t                 ? (timestamp - current_time)\n\t\t                 : 0;\n\t\tif(proto == IPPROTO_TCP)\n\t\t\tmemcpy(protocol, \"TCP\", 4);\n#ifdef IPPROTO_UDPLITE\n\t\telse if(proto == IPPROTO_UDPLITE)\n\t\t\tmemcpy(protocol, \"UDPLITE\", 8);\n#endif /* IPPROTO_UDPLITE */\n\t\telse\n\t\t\tmemcpy(protocol, \"UDP\", 4);\n\t\treturn 0;\n\t}\n}\n\n/* called from natpmp.c too */\nint\n_upnp_delete_redir(unsigned short eport, int proto)\n{\n\tint r;\n#if defined(__linux__)\n\tr = delete_redirect_and_filter_rules(eport, proto);\n#elif defined(USE_PF)\n\tr = delete_redirect_and_filter_rules(ext_if_name, eport, proto);\n#else\n\tr = delete_redirect_rule(ext_if_name, eport, proto);\n\tdelete_filter_rule(ext_if_name, eport, proto);\n#endif\n#ifdef ENABLE_LEASEFILE\n\tlease_file_remove( eport, proto);\n#endif\n\n#ifdef ENABLE_EVENTS\n\tupnp_event_var_change_notify(EWanIPC);\n#endif\n\treturn r;\n}\n\nint\nupnp_delete_redirection(unsigned short eport, const char * protocol)\n{\n\tsyslog(LOG_INFO, \"removing redirect rule port %hu %s\", eport, protocol);\n\treturn _upnp_delete_redir(eport, proto_atoi(protocol));\n}\n\n/* upnp_get_portmapping_number_of_entries()\n * TODO: improve this code. */\nint\nupnp_get_portmapping_number_of_entries()\n{\n\tint n = 0, r = 0;\n\tunsigned short eport, iport;\n\tchar protocol[4], iaddr[32], desc[64], rhost[32];\n\tunsigned int leaseduration;\n\tdo {\n\t\tprotocol[0] = '\\0'; iaddr[0] = '\\0'; desc[0] = '\\0';\n\t\tr = upnp_get_redirection_infos_by_index(n, &eport, protocol, &iport,\n\t\t                                        iaddr, sizeof(iaddr),\n\t\t                                        desc, sizeof(desc),\n\t\t                                        rhost, sizeof(rhost),\n\t\t                                        &leaseduration);\n\t\tn++;\n\t} while(r==0);\n\treturn (n-1);\n}\n\n/* functions used to remove unused rules\n * As a side effect, delete expired rules (based on LeaseDuration) */\nstruct rule_state *\nget_upnp_rules_state_list(int max_rules_number_target)\n{\n\t/*char ifname[IFNAMSIZ];*/\n\tint proto;\n\tunsigned short iport;\n\tunsigned int timestamp;\n\tstruct rule_state * tmp;\n\tstruct rule_state * list = 0;\n\tstruct rule_state * * p;\n\tint i = 0;\n\ttime_t current_time;\n\n\t/*ifname[0] = '\\0';*/\n\ttmp = malloc(sizeof(struct rule_state));\n\tif(!tmp)\n\t\treturn 0;\n\tcurrent_time = upnp_time();\n\tnextruletoclean_timestamp = 0;\n\twhile(get_redirect_rule_by_index(i, /*ifname*/0, &tmp->eport, 0, 0,\n\t                              &iport, &proto, 0, 0, 0,0, &timestamp,\n\t\t\t\t\t\t\t\t  &tmp->packets, &tmp->bytes) >= 0)\n\t{\n\t\ttmp->to_remove = 0;\n\t\tif(timestamp > 0) {\n\t\t\t/* need to remove this port mapping ? */\n\t\t\tif(timestamp <= (unsigned int)current_time)\n\t\t\t\ttmp->to_remove = 1;\n\t\t\telse if((nextruletoclean_timestamp <= (unsigned int)current_time)\n\t\t\t       || (timestamp < nextruletoclean_timestamp))\n\t\t\t\tnextruletoclean_timestamp = timestamp;\n\t\t}\n\t\ttmp->proto = (short)proto;\n\t\t/* add tmp to list */\n\t\ttmp->next = list;\n\t\tlist = tmp;\n\t\t/* prepare next iteration */\n\t\ti++;\n\t\ttmp = malloc(sizeof(struct rule_state));\n\t\tif(!tmp)\n\t\t\tbreak;\n\t}\n#ifdef PCP_PEER\n\ti=0;\n\twhile(get_peer_rule_by_index(i, /*ifname*/0, &tmp->eport, 0, 0,\n\t\t                              &iport, &proto, 0, 0, 0,0,0, &timestamp,\n\t\t\t\t\t\t\t\t\t  &tmp->packets, &tmp->bytes) >= 0)\n\t{\n\t\ttmp->to_remove = 0;\n\t\tif(timestamp > 0) {\n\t\t\t/* need to remove this port mapping ? */\n\t\t\tif(timestamp <= (unsigned int)current_time)\n\t\t\t\ttmp->to_remove = 1;\n\t\t\telse if((nextruletoclean_timestamp <= (unsigned int)current_time)\n\t\t\t\t   || (timestamp < nextruletoclean_timestamp))\n\t\t\t\tnextruletoclean_timestamp = timestamp;\n\t\t}\n\t\ttmp->proto = (short)proto;\n\t\t/* add tmp to list */\n\t\ttmp->next = list;\n\t\tlist = tmp;\n\t\t/* prepare next iteration */\n\t\ti++;\n\t\ttmp = malloc(sizeof(struct rule_state));\n\t\tif(!tmp)\n\t\t\tbreak;\n\t}\n#endif\n\tfree(tmp);\n\t/* remove the redirections that need to be removed */\n\tfor(p = &list, tmp = list; tmp; tmp = *p)\n\t{\n\t\tif(tmp->to_remove)\n\t\t{\n\t\t\tsyslog(LOG_NOTICE, \"remove port mapping %hu %s because it has expired\",\n\t\t\t       tmp->eport, proto_itoa(tmp->proto));\n\t\t\t_upnp_delete_redir(tmp->eport, tmp->proto);\n\t\t\t*p = tmp->next;\n\t\t\tfree(tmp);\n\t\t\ti--;\n\t\t} else {\n\t\t\tp = &(tmp->next);\n\t\t}\n\t}\n\t/* return empty list if not enough redirections */\n\tif(i<=max_rules_number_target)\n\t\twhile(list)\n\t\t{\n\t\t\ttmp = list;\n\t\t\tlist = tmp->next;\n\t\t\tfree(tmp);\n\t\t}\n\t/* return list */\n\treturn list;\n}\n\nvoid\nremove_unused_rules(struct rule_state * list)\n{\n\tchar ifname[IFNAMSIZ];\n\tunsigned short iport;\n\tstruct rule_state * tmp;\n\tu_int64_t packets;\n\tu_int64_t bytes;\n\tunsigned int timestamp;\n\tint n = 0;\n\n\twhile(list)\n\t{\n\t\t/* remove the rule if no traffic has used it */\n\t\tif(get_redirect_rule(ifname, list->eport, list->proto,\n\t                         0, 0, &iport, 0, 0, 0, 0, &timestamp,\n\t\t                     &packets, &bytes) >= 0)\n\t\t{\n\t\t\tif(packets == list->packets && bytes == list->bytes)\n\t\t\t{\n\t\t\t\tsyslog(LOG_DEBUG, \"removing unused mapping %hu %s : still \"\n\t\t\t\t       \"%\" PRIu64 \"packets %\" PRIu64 \"bytes\",\n\t\t\t\t       list->eport, proto_itoa(list->proto),\n\t\t\t\t       packets, bytes);\n\t\t\t\t_upnp_delete_redir(list->eport, list->proto);\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\ttmp = list;\n\t\tlist = tmp->next;\n\t\tfree(tmp);\n\t}\n\tif(n>0)\n\t\tsyslog(LOG_NOTICE, \"removed %d unused rules\", n);\n}\n\n/* upnp_get_portmappings_in_range()\n * return a list of all \"external\" ports for which a port\n * mapping exists */\nunsigned short *\nupnp_get_portmappings_in_range(unsigned short startport,\n                               unsigned short endport,\n                               const char * protocol,\n                               unsigned int * number)\n{\n\tint proto;\n\tproto = proto_atoi(protocol);\n\tif(!number)\n\t\treturn NULL;\n\treturn get_portmappings_in_range(startport, endport, proto, number);\n}\n\n/* stuff for miniupnpdctl */\n#ifdef USE_MINIUPNPDCTL\nvoid\nwrite_ruleset_details(int s)\n{\n\tint proto = 0;\n\tunsigned short eport, iport;\n\tchar desc[64];\n\tchar iaddr[32];\n\tchar rhost[32];\n\tunsigned int timestamp;\n\tu_int64_t packets;\n\tu_int64_t bytes;\n\tint i = 0;\n\tchar buffer[256];\n\tint n;\n\n\twrite(s, \"Ruleset :\\n\", 10);\n\twhile(get_redirect_rule_by_index(i, 0/*ifname*/, &eport, iaddr, sizeof(iaddr),\n\t                                 &iport, &proto, desc, sizeof(desc),\n\t                                 rhost, sizeof(rhost),\n\t                                 &timestamp,\n\t                                 &packets, &bytes) >= 0)\n\t{\n\t\tn = snprintf(buffer, sizeof(buffer),\n\t\t             \"%2d %s %s:%hu->%s:%hu \"\n\t\t             \"'%s' %u %\" PRIu64 \" %\" PRIu64 \"\\n\",\n\t\t             /*\"'%s' %llu %llu\\n\",*/\n\t\t             i, proto_itoa(proto), rhost,\n\t\t             eport, iaddr, iport, desc, timestamp, packets, bytes);\n\t\twrite(s, buffer, n);\n\t\ti++;\n\t}\n}\n#endif\n"], "fixing_code": ["/* $Id: upnpredirect.c,v 1.95 2018/07/06 12:05:48 nanard Exp $ */\n/* vim: tabstop=4 shiftwidth=4 noexpandtab\n * MiniUPnP project\n * http://miniupnp.free.fr/ or https://miniupnp.tuxfamily.org/\n * (c) 2006-2018 Thomas Bernard\n * This software is subject to the conditions detailed\n * in the LICENCE file provided within the distribution */\n\n#include <stdlib.h>\n#include <string.h>\n#include <syslog.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n\n#include <stdio.h>\n#include <ctype.h>\n#include <unistd.h>\n\n#include \"macros.h\"\n#include \"config.h\"\n#include \"upnpredirect.h\"\n#include \"upnpglobalvars.h\"\n#include \"upnpevents.h\"\n#include \"portinuse.h\"\n#include \"upnputils.h\"\n#if defined(USE_NETFILTER)\n#include \"netfilter/iptcrdr.h\"\n#endif\n#if defined(USE_PF)\n#include \"pf/obsdrdr.h\"\n#endif\n#if defined(USE_IPF)\n#include \"ipf/ipfrdr.h\"\n#endif\n#if defined(USE_IPFW)\n#include \"ipfw/ipfwrdr.h\"\n#endif\n#ifdef USE_MINIUPNPDCTL\n#include <stdio.h>\n#include <unistd.h>\n#endif\n#ifdef ENABLE_LEASEFILE\n#include <sys/stat.h>\n#endif\n\n/* from <inttypes.h> */\n#ifndef PRIu64\n#define PRIu64 \"llu\"\n#endif\n\n/* proto_atoi()\n * convert the string \"UDP\" or \"TCP\" to IPPROTO_UDP and IPPROTO_UDP */\nstatic int\nproto_atoi(const char * protocol)\n{\n\tint proto = IPPROTO_TCP;\n\tif(strcasecmp(protocol, \"UDP\") == 0)\n\t\tproto = IPPROTO_UDP;\n#ifdef IPPROTO_UDPLITE\n\telse if(strcasecmp(protocol, \"UDPLITE\") == 0)\n\t\tproto = IPPROTO_UDPLITE;\n#endif /* IPPROTO_UDPLITE */\n\treturn proto;\n}\n\n/* proto_itoa()\n * convert IPPROTO_UDP, IPPROTO_UDP, etc. to \"UDP\", \"TCP\" */\nstatic const char *\nproto_itoa(int proto)\n{\n\tconst char * protocol;\n\tswitch(proto) {\n\tcase IPPROTO_UDP:\n\t\tprotocol = \"UDP\";\n\t\tbreak;\n\tcase IPPROTO_TCP:\n\t\tprotocol = \"TCP\";\n\t\tbreak;\n#ifdef IPPROTO_UDPLITE\n\tcase IPPROTO_UDPLITE:\n\t\tprotocol = \"UDPLITE\";\n\t\tbreak;\n#endif /* IPPROTO_UDPLITE */\n\tdefault:\n\t\tprotocol = \"*UNKNOWN*\";\n\t}\n\treturn protocol;\n}\n\n#ifdef ENABLE_LEASEFILE\nstatic int\nlease_file_add(unsigned short eport,\n               const char * iaddr,\n               unsigned short iport,\n               int proto,\n               const char * desc,\n               unsigned int timestamp)\n{\n\tFILE * fd;\n\n\tif (lease_file == NULL) return 0;\n\n\tfd = fopen( lease_file, \"a\");\n\tif (fd==NULL) {\n\t\tsyslog(LOG_ERR, \"could not open lease file: %s\", lease_file);\n\t\treturn -1;\n\t}\n\n\t/* convert our time to unix time\n     * if LEASEFILE_USE_REMAINING_TIME is defined, only the remaining time is stored */\n\tif (timestamp != 0) {\n\t\ttimestamp -= upnp_time();\n#ifndef LEASEFILE_USE_REMAINING_TIME\n\t\ttimestamp += time(NULL);\n#endif\n\t}\n\n\tfprintf(fd, \"%s:%hu:%s:%hu:%u:%s\\n\",\n\t        proto_itoa(proto), eport, iaddr, iport,\n\t        timestamp, desc);\n\tfclose(fd);\n\n\treturn 0;\n}\n\nstatic int\nlease_file_remove(unsigned short eport, int proto)\n{\n\tFILE* fd, *fdt;\n\tint tmp;\n\tchar buf[512];\n\tchar str[32];\n\tchar tmpfilename[128];\n\tint str_size, buf_size;\n\n\n\tif (lease_file == NULL) return 0;\n\n\tif (strlen( lease_file) + 7 > sizeof(tmpfilename)) {\n\t\tsyslog(LOG_ERR, \"Lease filename is too long\");\n\t\treturn -1;\n\t}\n\n\tsnprintf( tmpfilename, sizeof(tmpfilename), \"%sXXXXXX\", lease_file);\n\n\tfd = fopen( lease_file, \"r\");\n\tif (fd==NULL) {\n\t\treturn 0;\n\t}\n\n\tsnprintf( str, sizeof(str), \"%s:%u\", proto_itoa(proto), eport);\n\tstr_size = strlen(str);\n\n\ttmp = mkstemp(tmpfilename);\n\tif (tmp==-1) {\n\t\tfclose(fd);\n\t\tsyslog(LOG_ERR, \"could not open temporary lease file\");\n\t\treturn -1;\n\t}\n\tfchmod(tmp, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tfdt = fdopen(tmp, \"a\");\n\n\tbuf[sizeof(buf)-1] = 0;\n\twhile( fgets(buf, sizeof(buf)-1, fd) != NULL) {\n\t\tbuf_size = strlen(buf);\n\n\t\tif (buf_size < str_size || strncmp(str, buf, str_size)!=0) {\n\t\t\tfwrite(buf, buf_size, 1, fdt);\n\t\t}\n\t}\n\tfclose(fdt);\n\tfclose(fd);\n\n\tif (rename(tmpfilename, lease_file) < 0) {\n\t\tsyslog(LOG_ERR, \"could not rename temporary lease file to %s\", lease_file);\n\t\tremove(tmpfilename);\n\t}\n\n\treturn 0;\n\n}\n\n/* reload_from_lease_file()\n * read lease_file and add the rules contained\n */\nint reload_from_lease_file()\n{\n\tFILE * fd;\n\tchar * p;\n\tunsigned short eport, iport;\n\tchar * proto;\n\tchar * iaddr;\n\tchar * desc;\n\tchar * rhost;\n\tunsigned int leaseduration;\n\tunsigned int timestamp;\n\ttime_t current_time;\n#ifndef LEASEFILE_USE_REMAINING_TIME\n\ttime_t current_unix_time;\n#endif\n\tchar line[128];\n\tint r;\n\n\tif(!lease_file) return -1;\n\tfd = fopen( lease_file, \"r\");\n\tif (fd==NULL) {\n\t\tsyslog(LOG_ERR, \"could not open lease file: %s\", lease_file);\n\t\treturn -1;\n\t}\n\tif(unlink(lease_file) < 0) {\n\t\tsyslog(LOG_WARNING, \"could not unlink file %s : %m\", lease_file);\n\t}\n\n\tcurrent_time = upnp_time();\n#ifndef LEASEFILE_USE_REMAINING_TIME\n\tcurrent_unix_time = time(NULL);\n#endif\n\twhile(fgets(line, sizeof(line), fd)) {\n\t\tsyslog(LOG_DEBUG, \"parsing lease file line '%s'\", line);\n\t\tproto = line;\n\t\tp = strchr(line, ':');\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"unrecognized data in lease file\");\n\t\t\tcontinue;\n\t\t}\n\t\t*(p++) = '\\0';\n\t\tiaddr = strchr(p, ':');\n\t\tif(!iaddr) {\n\t\t\tsyslog(LOG_ERR, \"unrecognized data in lease file\");\n\t\t\tcontinue;\n\t\t}\n\t\t*(iaddr++) = '\\0';\n\t\teport = (unsigned short)atoi(p);\n\t\tp = strchr(iaddr, ':');\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"unrecognized data in lease file\");\n\t\t\tcontinue;\n\t\t}\n\t\t*(p++) = '\\0';\n\t\tiport = (unsigned short)atoi(p);\n\t\tp = strchr(p, ':');\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"unrecognized data in lease file\");\n\t\t\tcontinue;\n\t\t}\n\t\t*(p++) = '\\0';\n\t\tdesc = strchr(p, ':');\n\t\tif(!desc) {\n\t\t\tsyslog(LOG_ERR, \"unrecognized data in lease file\");\n\t\t\tcontinue;\n\t\t}\n\t\t*(desc++) = '\\0';\n\t\t/*timestamp = (unsigned int)atoi(p);*/\n\t\ttimestamp = (unsigned int)strtoul(p, NULL, 10);\n\t\t/* trim description */\n\t\twhile(isspace(*desc))\n\t\t\tdesc++;\n\t\tp = desc;\n\t\twhile(*(p+1))\n\t\t\tp++;\n\t\twhile(isspace(*p) && (p > desc))\n\t\t\t*(p--) = '\\0';\n\n\t\tif(timestamp > 0) {\n#ifdef LEASEFILE_USE_REMAINING_TIME\n\t\t\tleaseduration = timestamp;\n\t\t\ttimestamp += current_time;\t/* convert to our time */\n#else\n\t\t\tif(timestamp <= (unsigned int)current_unix_time) {\n\t\t\t\tsyslog(LOG_NOTICE, \"already expired lease in lease file\");\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tleaseduration = timestamp - current_unix_time;\n\t\t\t\ttimestamp = leaseduration + current_time; /* convert to our time */\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tleaseduration = 0;\t/* default value */\n\t\t}\n\t\trhost = NULL;\n\t\tr = upnp_redirect(rhost, eport, iaddr, iport, proto, desc, leaseduration);\n\t\tif(r == -1) {\n\t\t\tsyslog(LOG_ERR, \"Failed to redirect %hu -> %s:%hu protocol %s\",\n\t\t\t       eport, iaddr, iport, proto);\n\t\t} else if(r == -2) {\n\t\t\t/* Add the redirection again to the lease file */\n\t\t\tlease_file_add(eport, iaddr, iport, proto_atoi(proto),\n\t\t\t               desc, timestamp);\n\t\t}\n\t}\n\tfclose(fd);\n\n\treturn 0;\n}\n\n#ifdef LEASEFILE_USE_REMAINING_TIME\nvoid lease_file_rewrite(void)\n{\n\tint index;\n\tunsigned short eport, iport;\n\tint proto;\n\tchar iaddr[32];\n\tchar desc[64];\n\tchar rhost[40];\n\tunsigned int timestamp;\n\n\tif (lease_file == NULL) return;\n\tremove(lease_file);\n\tfor(index = 0; ; index++) {\n\t\tif(get_redirect_rule_by_index(index, 0/*ifname*/, &eport, iaddr, sizeof(iaddr),\n\t\t                              &iport, &proto, desc, sizeof(desc),\n\t\t                              rhost, sizeof(rhost), &timestamp,\n\t\t                              0, 0) < 0)\n\t\t\tbreak;\n\t\tif(lease_file_add(eport, iaddr, iport, proto, desc, timestamp) < 0)\n\t\t\tbreak;\n\t}\n}\n#endif\n#endif\n\n/* upnp_redirect()\n * calls OS/fw dependent implementation of the redirection.\n * protocol should be the string \"TCP\" or \"UDP\"\n * returns: 0 on success\n *          -1 failed to redirect\n *          -2 already redirected\n *          -3 permission check failed\n *          -4 already redirected (other mechanism)\n */\nint\nupnp_redirect(const char * rhost, unsigned short eport,\n              const char * iaddr, unsigned short iport,\n              const char * protocol, const char * desc,\n              unsigned int leaseduration)\n{\n\tint proto, r;\n\tchar iaddr_old[32];\n\tchar rhost_old[32];\n\tunsigned short iport_old;\n\tstruct in_addr address;\n\tunsigned int timestamp;\n\n\tproto = proto_atoi(protocol);\n\tif(inet_aton(iaddr, &address) <= 0) {\n\t\tsyslog(LOG_ERR, \"inet_aton(%s) FAILED\", iaddr);\n\t\treturn -1;\n\t}\n\n\tif(!check_upnp_rule_against_permissions(upnppermlist, num_upnpperm,\n\t                                        eport, address, iport)) {\n\t\tsyslog(LOG_INFO, \"redirection permission check failed for \"\n\t\t                 \"%hu->%s:%hu %s\", eport, iaddr, iport, protocol);\n\t\treturn -3;\n\t}\n\n\tif (desc == NULL)\n\t\tdesc = \"\";\t/* assume empty description */\n\n\t/* IGDv1 (WANIPConnection:1 Service Template Version 1.01 / Nov 12, 2001)\n\t * - 2.2.20.PortMappingDescription :\n\t *  Overwriting Previous / Existing Port Mappings:\n\t * If the RemoteHost, ExternalPort, PortMappingProtocol and InternalClient\n\t * are exactly the same as an existing mapping, the existing mapping values\n\t * for InternalPort, PortMappingDescription, PortMappingEnabled and\n\t * PortMappingLeaseDuration are overwritten.\n\t *  Rejecting a New Port Mapping:\n\t * In cases where the RemoteHost, ExternalPort and PortMappingProtocol\n\t * are the same as an existing mapping, but the InternalClient is\n\t * different, the action is rejected with an appropriate error.\n\t *  Add or Reject New Port Mapping behavior based on vendor implementation:\n\t * In cases where the ExternalPort, PortMappingProtocol and InternalClient\n\t * are the same, but RemoteHost is different, the vendor can choose to\n\t * support both mappings simultaneously, or reject the second mapping\n\t * with an appropriate error.\n\t *\n\t * - 2.4.16.AddPortMapping\n\t * This action creates a new port mapping or overwrites an existing\n\t * mapping with the same internal client. If the ExternalPort and\n\t * PortMappingProtocol pair is already mapped to another internal client,\n\t * an error is returned.\n\t *\n\t * IGDv2 (WANIPConnection:2 Service Standardized DCP (SDCP) Sep 10, 2010)\n\t * Protocol ExternalPort RemoteHost InternalClient Result\n\t *     =         =           \u2260           \u2260         Failure\n\t *     =         =           \u2260           =         Failure or success\n\t *                                                 (vendor specific)\n\t *     =         =           =           \u2260         Failure\n\t *     =         =           =           =         Success (overwrite)\n\t */\n\trhost_old[0] = '\\0';\n\tr = get_redirect_rule(ext_if_name, eport, proto,\n\t                      iaddr_old, sizeof(iaddr_old), &iport_old, 0, 0,\n\t                      rhost_old, sizeof(rhost_old),\n\t                      &timestamp, 0, 0);\n\tif(r == 0) {\n\t\tif(strcmp(iaddr, iaddr_old)==0 &&\n\t\t   ((rhost == NULL && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, \"*\") == 0) && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, rhost_old) == 0)))) {\n\t\t\tsyslog(LOG_INFO, \"updating existing port mapping %hu %s (rhost '%s') => %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\t\tif(iport != iport_old) {\n\t\t\t\tr = update_portmapping(ext_if_name, eport, proto, iport, desc, timestamp);\n\t\t\t} else {\n\t\t\t\tr = update_portmapping_desc_timestamp(ext_if_name, eport, proto, desc, timestamp);\n\t\t\t}\n#ifdef ENABLE_LEASEFILE\n\t\t\tif(r == 0) {\n\t\t\t\tlease_file_remove(eport, proto);\n\t\t\t\tlease_file_add(eport, iaddr, iport, proto, desc, timestamp);\n\t\t\t}\n#endif /* ENABLE_LEASEFILE */\n\t\t\treturn r;\n\t\t} else {\n\t\t\tsyslog(LOG_INFO, \"port %hu %s (rhost '%s') already redirected to %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\treturn -2;\n\t\t}\n#ifdef CHECK_PORTINUSE\n\t} else if (port_in_use(ext_if_name, eport, proto, iaddr, iport) > 0) {\n\t\tsyslog(LOG_INFO, \"port %hu protocol %s already in use\",\n\t\t       eport, protocol);\n\t\treturn -4;\n#endif /* CHECK_PORTINUSE */\n\t} else {\n\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\tsyslog(LOG_INFO, \"redirecting port %hu to %s:%hu protocol %s for: %s\",\n\t\t\teport, iaddr, iport, protocol, desc);\n\t\treturn upnp_redirect_internal(rhost, eport, iaddr, iport, proto,\n\t\t                              desc, timestamp);\n\t}\n}\n\nint\nupnp_redirect_internal(const char * rhost, unsigned short eport,\n                       const char * iaddr, unsigned short iport,\n                       int proto, const char * desc,\n                       unsigned int timestamp)\n{\n\t/*syslog(LOG_INFO, \"redirecting port %hu to %s:%hu protocol %s for: %s\",\n\t\teport, iaddr, iport, protocol, desc);\t\t\t*/\n\tif(disable_port_forwarding)\n\t\treturn -1;\n\tif(add_redirect_rule2(ext_if_name, rhost, eport, iaddr, iport, proto,\n\t                      desc, timestamp) < 0) {\n\t\treturn -1;\n\t}\n\n#ifdef ENABLE_LEASEFILE\n\tlease_file_add( eport, iaddr, iport, proto, desc, timestamp);\n#endif\n/*\tsyslog(LOG_INFO, \"creating pass rule to %s:%hu protocol %s for: %s\",\n\t\tiaddr, iport, protocol, desc);*/\n\tif(add_filter_rule2(ext_if_name, rhost, iaddr, eport, iport, proto, desc) < 0) {\n\t\t/* clean up the redirect rule */\n#if !defined(__linux__)\n\t\tdelete_redirect_rule(ext_if_name, eport, proto);\n#endif\n\t\treturn -1;\n\t}\n\tif(timestamp > 0) {\n\t\tif(!nextruletoclean_timestamp || (timestamp < nextruletoclean_timestamp))\n\t\t\tnextruletoclean_timestamp = timestamp;\n\t}\n#ifdef ENABLE_EVENTS\n\t/* the number of port mappings changed, we must\n\t * inform the subscribers */\n\tupnp_event_var_change_notify(EWanIPC);\n#endif\n\treturn 0;\n}\n\n\n\n/* Firewall independent code which call the FW dependent code. */\nint\nupnp_get_redirection_infos(unsigned short eport, const char * protocol,\n                           unsigned short * iport,\n                           char * iaddr, int iaddrlen,\n                           char * desc, int desclen,\n                           char * rhost, int rhostlen,\n                           unsigned int * leaseduration)\n{\n\tint r;\n\tunsigned int timestamp;\n\ttime_t current_time;\n\n\tif(desc && (desclen > 0))\n\t\tdesc[0] = '\\0';\n\tif(rhost && (rhostlen > 0))\n\t\trhost[0] = '\\0';\n\tr = get_redirect_rule(ext_if_name, eport, proto_atoi(protocol),\n\t                      iaddr, iaddrlen, iport, desc, desclen,\n\t                      rhost, rhostlen, &timestamp,\n\t                      0, 0);\n\tif(r == 0 &&\n\t   timestamp > 0 &&\n\t   timestamp > (unsigned int)(current_time = upnp_time())) {\n\t\t*leaseduration = timestamp - current_time;\n\t} else {\n\t\t*leaseduration = 0;\n\t}\n\treturn r;\n}\n\nint\nupnp_get_redirection_infos_by_index(int index,\n                                    unsigned short * eport, char * protocol,\n                                    unsigned short * iport,\n                                    char * iaddr, int iaddrlen,\n                                    char * desc, int desclen,\n                                    char * rhost, int rhostlen,\n                                    unsigned int * leaseduration)\n{\n\t/*char ifname[IFNAMSIZ];*/\n\tint proto = 0;\n\tunsigned int timestamp;\n\ttime_t current_time;\n\n\tif(desc && (desclen > 0))\n\t\tdesc[0] = '\\0';\n\tif(rhost && (rhostlen > 0))\n\t\trhost[0] = '\\0';\n\tif(get_redirect_rule_by_index(index, 0/*ifname*/, eport, iaddr, iaddrlen,\n\t                              iport, &proto, desc, desclen,\n\t                              rhost, rhostlen, &timestamp,\n\t                              0, 0) < 0)\n\t\treturn -1;\n\telse\n\t{\n\t\tcurrent_time = upnp_time();\n\t\t*leaseduration = (timestamp > (unsigned int)current_time)\n\t\t                 ? (timestamp - current_time)\n\t\t                 : 0;\n\t\tif(proto == IPPROTO_TCP)\n\t\t\tmemcpy(protocol, \"TCP\", 4);\n#ifdef IPPROTO_UDPLITE\n\t\telse if(proto == IPPROTO_UDPLITE)\n\t\t\tmemcpy(protocol, \"UDPLITE\", 8);\n#endif /* IPPROTO_UDPLITE */\n\t\telse\n\t\t\tmemcpy(protocol, \"UDP\", 4);\n\t\treturn 0;\n\t}\n}\n\n/* called from natpmp.c too */\nint\n_upnp_delete_redir(unsigned short eport, int proto)\n{\n\tint r;\n#if defined(__linux__)\n\tr = delete_redirect_and_filter_rules(eport, proto);\n#elif defined(USE_PF)\n\tr = delete_redirect_and_filter_rules(ext_if_name, eport, proto);\n#else\n\tr = delete_redirect_rule(ext_if_name, eport, proto);\n\tdelete_filter_rule(ext_if_name, eport, proto);\n#endif\n#ifdef ENABLE_LEASEFILE\n\tlease_file_remove( eport, proto);\n#endif\n\n#ifdef ENABLE_EVENTS\n\tupnp_event_var_change_notify(EWanIPC);\n#endif\n\treturn r;\n}\n\nint\nupnp_delete_redirection(unsigned short eport, const char * protocol)\n{\n\tsyslog(LOG_INFO, \"removing redirect rule port %hu %s\", eport, protocol);\n\treturn _upnp_delete_redir(eport, proto_atoi(protocol));\n}\n\n/* upnp_get_portmapping_number_of_entries()\n * TODO: improve this code. */\nint\nupnp_get_portmapping_number_of_entries()\n{\n\tint n = 0, r = 0;\n\tunsigned short eport, iport;\n\tchar protocol[4], iaddr[32], desc[64], rhost[32];\n\tunsigned int leaseduration;\n\tdo {\n\t\tprotocol[0] = '\\0'; iaddr[0] = '\\0'; desc[0] = '\\0';\n\t\tr = upnp_get_redirection_infos_by_index(n, &eport, protocol, &iport,\n\t\t                                        iaddr, sizeof(iaddr),\n\t\t                                        desc, sizeof(desc),\n\t\t                                        rhost, sizeof(rhost),\n\t\t                                        &leaseduration);\n\t\tn++;\n\t} while(r==0);\n\treturn (n-1);\n}\n\n/* functions used to remove unused rules\n * As a side effect, delete expired rules (based on LeaseDuration) */\nstruct rule_state *\nget_upnp_rules_state_list(int max_rules_number_target)\n{\n\t/*char ifname[IFNAMSIZ];*/\n\tint proto;\n\tunsigned short iport;\n\tunsigned int timestamp;\n\tstruct rule_state * tmp;\n\tstruct rule_state * list = 0;\n\tstruct rule_state * * p;\n\tint i = 0;\n\ttime_t current_time;\n\n\t/*ifname[0] = '\\0';*/\n\ttmp = malloc(sizeof(struct rule_state));\n\tif(!tmp)\n\t\treturn 0;\n\tcurrent_time = upnp_time();\n\tnextruletoclean_timestamp = 0;\n\twhile(get_redirect_rule_by_index(i, /*ifname*/0, &tmp->eport, 0, 0,\n\t                              &iport, &proto, 0, 0, 0,0, &timestamp,\n\t\t\t\t\t\t\t\t  &tmp->packets, &tmp->bytes) >= 0)\n\t{\n\t\ttmp->to_remove = 0;\n\t\tif(timestamp > 0) {\n\t\t\t/* need to remove this port mapping ? */\n\t\t\tif(timestamp <= (unsigned int)current_time)\n\t\t\t\ttmp->to_remove = 1;\n\t\t\telse if((nextruletoclean_timestamp <= (unsigned int)current_time)\n\t\t\t       || (timestamp < nextruletoclean_timestamp))\n\t\t\t\tnextruletoclean_timestamp = timestamp;\n\t\t}\n\t\ttmp->proto = (short)proto;\n\t\t/* add tmp to list */\n\t\ttmp->next = list;\n\t\tlist = tmp;\n\t\t/* prepare next iteration */\n\t\ti++;\n\t\ttmp = malloc(sizeof(struct rule_state));\n\t\tif(!tmp)\n\t\t\tbreak;\n\t}\n#ifdef PCP_PEER\n\ti=0;\n\twhile(get_peer_rule_by_index(i, /*ifname*/0, &tmp->eport, 0, 0,\n\t\t                              &iport, &proto, 0, 0, 0,0,0, &timestamp,\n\t\t\t\t\t\t\t\t\t  &tmp->packets, &tmp->bytes) >= 0)\n\t{\n\t\ttmp->to_remove = 0;\n\t\tif(timestamp > 0) {\n\t\t\t/* need to remove this port mapping ? */\n\t\t\tif(timestamp <= (unsigned int)current_time)\n\t\t\t\ttmp->to_remove = 1;\n\t\t\telse if((nextruletoclean_timestamp <= (unsigned int)current_time)\n\t\t\t\t   || (timestamp < nextruletoclean_timestamp))\n\t\t\t\tnextruletoclean_timestamp = timestamp;\n\t\t}\n\t\ttmp->proto = (short)proto;\n\t\t/* add tmp to list */\n\t\ttmp->next = list;\n\t\tlist = tmp;\n\t\t/* prepare next iteration */\n\t\ti++;\n\t\ttmp = malloc(sizeof(struct rule_state));\n\t\tif(!tmp)\n\t\t\tbreak;\n\t}\n#endif\n\tfree(tmp);\n\t/* remove the redirections that need to be removed */\n\tfor(p = &list, tmp = list; tmp; tmp = *p)\n\t{\n\t\tif(tmp->to_remove)\n\t\t{\n\t\t\tsyslog(LOG_NOTICE, \"remove port mapping %hu %s because it has expired\",\n\t\t\t       tmp->eport, proto_itoa(tmp->proto));\n\t\t\t_upnp_delete_redir(tmp->eport, tmp->proto);\n\t\t\t*p = tmp->next;\n\t\t\tfree(tmp);\n\t\t\ti--;\n\t\t} else {\n\t\t\tp = &(tmp->next);\n\t\t}\n\t}\n\t/* return empty list if not enough redirections */\n\tif(i<=max_rules_number_target)\n\t\twhile(list)\n\t\t{\n\t\t\ttmp = list;\n\t\t\tlist = tmp->next;\n\t\t\tfree(tmp);\n\t\t}\n\t/* return list */\n\treturn list;\n}\n\nvoid\nremove_unused_rules(struct rule_state * list)\n{\n\tchar ifname[IFNAMSIZ];\n\tunsigned short iport;\n\tstruct rule_state * tmp;\n\tu_int64_t packets;\n\tu_int64_t bytes;\n\tunsigned int timestamp;\n\tint n = 0;\n\n\twhile(list)\n\t{\n\t\t/* remove the rule if no traffic has used it */\n\t\tif(get_redirect_rule(ifname, list->eport, list->proto,\n\t                         0, 0, &iport, 0, 0, 0, 0, &timestamp,\n\t\t                     &packets, &bytes) >= 0)\n\t\t{\n\t\t\tif(packets == list->packets && bytes == list->bytes)\n\t\t\t{\n\t\t\t\tsyslog(LOG_DEBUG, \"removing unused mapping %hu %s : still \"\n\t\t\t\t       \"%\" PRIu64 \"packets %\" PRIu64 \"bytes\",\n\t\t\t\t       list->eport, proto_itoa(list->proto),\n\t\t\t\t       packets, bytes);\n\t\t\t\t_upnp_delete_redir(list->eport, list->proto);\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\ttmp = list;\n\t\tlist = tmp->next;\n\t\tfree(tmp);\n\t}\n\tif(n>0)\n\t\tsyslog(LOG_NOTICE, \"removed %d unused rules\", n);\n}\n\n/* upnp_get_portmappings_in_range()\n * return a list of all \"external\" ports for which a port\n * mapping exists */\nunsigned short *\nupnp_get_portmappings_in_range(unsigned short startport,\n                               unsigned short endport,\n                               const char * protocol,\n                               unsigned int * number)\n{\n\tint proto;\n\tproto = proto_atoi(protocol);\n\tif(!number)\n\t\treturn NULL;\n\treturn get_portmappings_in_range(startport, endport, proto, number);\n}\n\n/* stuff for miniupnpdctl */\n#ifdef USE_MINIUPNPDCTL\nvoid\nwrite_ruleset_details(int s)\n{\n\tint proto = 0;\n\tunsigned short eport, iport;\n\tchar desc[64];\n\tchar iaddr[32];\n\tchar rhost[32];\n\tunsigned int timestamp;\n\tu_int64_t packets;\n\tu_int64_t bytes;\n\tint i = 0;\n\tchar buffer[256];\n\tint n;\n\n\twrite(s, \"Ruleset :\\n\", 10);\n\twhile(get_redirect_rule_by_index(i, 0/*ifname*/, &eport, iaddr, sizeof(iaddr),\n\t                                 &iport, &proto, desc, sizeof(desc),\n\t                                 rhost, sizeof(rhost),\n\t                                 &timestamp,\n\t                                 &packets, &bytes) >= 0)\n\t{\n\t\tn = snprintf(buffer, sizeof(buffer),\n\t\t             \"%2d %s %s:%hu->%s:%hu \"\n\t\t             \"'%s' %u %\" PRIu64 \" %\" PRIu64 \"\\n\",\n\t\t             /*\"'%s' %llu %llu\\n\",*/\n\t\t             i, proto_itoa(proto), rhost,\n\t\t             eport, iaddr, iport, desc, timestamp, packets, bytes);\n\t\twrite(s, buffer, n);\n\t\ti++;\n\t}\n}\n#endif\n"], "filenames": ["miniupnpd/upnpredirect.c"], "buggy_code_start_loc": [358], "buggy_code_end_loc": [358], "fixing_code_start_loc": [359], "fixing_code_end_loc": [363], "type": "CWE-476", "message": "An AddPortMapping Denial Of Service vulnerability in MiniUPnP MiniUPnPd through 2.1 exists due to a NULL pointer dereference in upnpredirect.c.", "other": {"cve": {"id": "CVE-2019-12110", "sourceIdentifier": "cve@mitre.org", "published": "2019-05-15T23:29:00.840", "lastModified": "2020-09-28T20:15:13.000", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An AddPortMapping Denial Of Service vulnerability in MiniUPnP MiniUPnPd through 2.1 exists due to a NULL pointer dereference in upnpredirect.c."}, {"lang": "es", "value": "Se presenta una vulnerabilidad de Denegaci\u00f3n de Servicio (DoS) en AddPortMap en MiniUPnP MiniUPnPd versi\u00f3n hasta 2.1, a causa de una desreferencia del puntero NULL en upnpredirect.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:miniupnp.free:miniupnpd:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.1", "matchCriteriaId": "24BD83A5-9532-4534-9F9C-17C8AF7E94BB"}]}]}], "references": [{"url": "https://github.com/miniupnp/miniupnp/commit/f321c2066b96d18afa5158dfa2d2873a2957ef38", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/05/msg00045.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4542-1/", "source": "cve@mitre.org"}, {"url": "https://www.vdoo.com/blog/security-issues-discovered-in-miniupnp", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/miniupnp/miniupnp/commit/f321c2066b96d18afa5158dfa2d2873a2957ef38"}}