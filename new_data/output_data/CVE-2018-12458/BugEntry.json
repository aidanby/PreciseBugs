{"buggy_code": ["/*\n * MPEG4 encoder.\n * Copyright (c) 2000,2001 Fabrice Bellard\n * Copyright (c) 2002-2010 Michael Niedermayer <michaelni@gmx.at>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/log.h\"\n#include \"libavutil/opt.h\"\n#include \"mpegutils.h\"\n#include \"mpegvideo.h\"\n#include \"h263.h\"\n#include \"mpeg4video.h\"\n\n/* The uni_DCtab_* tables below contain unified bits+length tables to encode DC\n * differences in mpeg4. Unified in the sense that the specification specifies\n * this encoding in several steps. */\nstatic uint8_t  uni_DCtab_lum_len[512];\nstatic uint8_t  uni_DCtab_chrom_len[512];\nstatic uint16_t uni_DCtab_lum_bits[512];\nstatic uint16_t uni_DCtab_chrom_bits[512];\n\n/* Unified encoding tables for run length encoding of coefficients.\n * Unified in the sense that the specification specifies the encoding in several steps. */\nstatic uint32_t uni_mpeg4_intra_rl_bits[64 * 64 * 2 * 2];\nstatic uint8_t  uni_mpeg4_intra_rl_len[64 * 64 * 2 * 2];\nstatic uint32_t uni_mpeg4_inter_rl_bits[64 * 64 * 2 * 2];\nstatic uint8_t  uni_mpeg4_inter_rl_len[64 * 64 * 2 * 2];\n\n//#define UNI_MPEG4_ENC_INDEX(last, run, level) ((last) * 128 + (run) * 256 + (level))\n//#define UNI_MPEG4_ENC_INDEX(last, run, level) ((last) * 128 * 64 + (run) + (level) * 64)\n#define UNI_MPEG4_ENC_INDEX(last, run, level) ((last) * 128 * 64 + (run) * 128 + (level))\n\n/* mpeg4\n * inter\n * max level: 24/6\n * max run: 53/63\n *\n * intra\n * max level: 53/16\n * max run: 29/41\n */\n\n/**\n * Return the number of bits that encoding the 8x8 block in block would need.\n * @param[in]  block_last_index last index in scantable order that refers to a non zero element in block.\n */\nstatic inline int get_block_rate(MpegEncContext *s, int16_t block[64],\n                                 int block_last_index, uint8_t scantable[64])\n{\n    int last = 0;\n    int j;\n    int rate = 0;\n\n    for (j = 1; j <= block_last_index; j++) {\n        const int index = scantable[j];\n        int level = block[index];\n        if (level) {\n            level += 64;\n            if ((level & (~127)) == 0) {\n                if (j < block_last_index)\n                    rate += s->intra_ac_vlc_length[UNI_AC_ENC_INDEX(j - last - 1, level)];\n                else\n                    rate += s->intra_ac_vlc_last_length[UNI_AC_ENC_INDEX(j - last - 1, level)];\n            } else\n                rate += s->ac_esc_length;\n\n            last = j;\n        }\n    }\n\n    return rate;\n}\n\n/**\n * Restore the ac coefficients in block that have been changed by decide_ac_pred().\n * This function also restores s->block_last_index.\n * @param[in,out] block MB coefficients, these will be restored\n * @param[in] dir ac prediction direction for each 8x8 block\n * @param[out] st scantable for each 8x8 block\n * @param[in] zigzag_last_index index referring to the last non zero coefficient in zigzag order\n */\nstatic inline void restore_ac_coeffs(MpegEncContext *s, int16_t block[6][64],\n                                     const int dir[6], uint8_t *st[6],\n                                     const int zigzag_last_index[6])\n{\n    int i, n;\n    memcpy(s->block_last_index, zigzag_last_index, sizeof(int) * 6);\n\n    for (n = 0; n < 6; n++) {\n        int16_t *ac_val = s->ac_val[0][0] + s->block_index[n] * 16;\n\n        st[n] = s->intra_scantable.permutated;\n        if (dir[n]) {\n            /* top prediction */\n            for (i = 1; i < 8; i++)\n                block[n][s->idsp.idct_permutation[i]] = ac_val[i + 8];\n        } else {\n            /* left prediction */\n            for (i = 1; i < 8; i++)\n                block[n][s->idsp.idct_permutation[i << 3]] = ac_val[i];\n        }\n    }\n}\n\n/**\n * Return the optimal value (0 or 1) for the ac_pred element for the given MB in mpeg4.\n * This function will also update s->block_last_index and s->ac_val.\n * @param[in,out] block MB coefficients, these will be updated if 1 is returned\n * @param[in] dir ac prediction direction for each 8x8 block\n * @param[out] st scantable for each 8x8 block\n * @param[out] zigzag_last_index index referring to the last non zero coefficient in zigzag order\n */\nstatic inline int decide_ac_pred(MpegEncContext *s, int16_t block[6][64],\n                                 const int dir[6], uint8_t *st[6],\n                                 int zigzag_last_index[6])\n{\n    int score = 0;\n    int i, n;\n    int8_t *const qscale_table = s->current_picture.qscale_table;\n\n    memcpy(zigzag_last_index, s->block_last_index, sizeof(int) * 6);\n\n    for (n = 0; n < 6; n++) {\n        int16_t *ac_val, *ac_val1;\n\n        score -= get_block_rate(s, block[n], s->block_last_index[n],\n                                s->intra_scantable.permutated);\n\n        ac_val  = s->ac_val[0][0] + s->block_index[n] * 16;\n        ac_val1 = ac_val;\n        if (dir[n]) {\n            const int xy = s->mb_x + s->mb_y * s->mb_stride - s->mb_stride;\n            /* top prediction */\n            ac_val -= s->block_wrap[n] * 16;\n            if (s->mb_y == 0 || s->qscale == qscale_table[xy] || n == 2 || n == 3) {\n                /* same qscale */\n                for (i = 1; i < 8; i++) {\n                    const int level = block[n][s->idsp.idct_permutation[i]];\n                    block[n][s->idsp.idct_permutation[i]] = level - ac_val[i + 8];\n                    ac_val1[i]     = block[n][s->idsp.idct_permutation[i << 3]];\n                    ac_val1[i + 8] = level;\n                }\n            } else {\n                /* different qscale, we must rescale */\n                for (i = 1; i < 8; i++) {\n                    const int level = block[n][s->idsp.idct_permutation[i]];\n                    block[n][s->idsp.idct_permutation[i]] = level - ROUNDED_DIV(ac_val[i + 8] * qscale_table[xy], s->qscale);\n                    ac_val1[i]     = block[n][s->idsp.idct_permutation[i << 3]];\n                    ac_val1[i + 8] = level;\n                }\n            }\n            st[n] = s->intra_h_scantable.permutated;\n        } else {\n            const int xy = s->mb_x - 1 + s->mb_y * s->mb_stride;\n            /* left prediction */\n            ac_val -= 16;\n            if (s->mb_x == 0 || s->qscale == qscale_table[xy] || n == 1 || n == 3) {\n                /* same qscale */\n                for (i = 1; i < 8; i++) {\n                    const int level = block[n][s->idsp.idct_permutation[i << 3]];\n                    block[n][s->idsp.idct_permutation[i << 3]] = level - ac_val[i];\n                    ac_val1[i]     = level;\n                    ac_val1[i + 8] = block[n][s->idsp.idct_permutation[i]];\n                }\n            } else {\n                /* different qscale, we must rescale */\n                for (i = 1; i < 8; i++) {\n                    const int level = block[n][s->idsp.idct_permutation[i << 3]];\n                    block[n][s->idsp.idct_permutation[i << 3]] = level - ROUNDED_DIV(ac_val[i] * qscale_table[xy], s->qscale);\n                    ac_val1[i]     = level;\n                    ac_val1[i + 8] = block[n][s->idsp.idct_permutation[i]];\n                }\n            }\n            st[n] = s->intra_v_scantable.permutated;\n        }\n\n        for (i = 63; i > 0; i--)  // FIXME optimize\n            if (block[n][st[n][i]])\n                break;\n        s->block_last_index[n] = i;\n\n        score += get_block_rate(s, block[n], s->block_last_index[n], st[n]);\n    }\n\n    if (score < 0) {\n        return 1;\n    } else {\n        restore_ac_coeffs(s, block, dir, st, zigzag_last_index);\n        return 0;\n    }\n}\n\n/**\n * modify mb_type & qscale so that encoding is actually possible in mpeg4\n */\nvoid ff_clean_mpeg4_qscales(MpegEncContext *s)\n{\n    int i;\n    int8_t *const qscale_table = s->current_picture.qscale_table;\n\n    ff_clean_h263_qscales(s);\n\n    if (s->pict_type == AV_PICTURE_TYPE_B) {\n        int odd = 0;\n        /* ok, come on, this isn't funny anymore, there's more code for\n         * handling this mpeg4 mess than for the actual adaptive quantization */\n\n        for (i = 0; i < s->mb_num; i++) {\n            int mb_xy = s->mb_index2xy[i];\n            odd += qscale_table[mb_xy] & 1;\n        }\n\n        if (2 * odd > s->mb_num)\n            odd = 1;\n        else\n            odd = 0;\n\n        for (i = 0; i < s->mb_num; i++) {\n            int mb_xy = s->mb_index2xy[i];\n            if ((qscale_table[mb_xy] & 1) != odd)\n                qscale_table[mb_xy]++;\n            if (qscale_table[mb_xy] > 31)\n                qscale_table[mb_xy] = 31;\n        }\n\n        for (i = 1; i < s->mb_num; i++) {\n            int mb_xy = s->mb_index2xy[i];\n            if (qscale_table[mb_xy] != qscale_table[s->mb_index2xy[i - 1]] &&\n                (s->mb_type[mb_xy] & CANDIDATE_MB_TYPE_DIRECT)) {\n                s->mb_type[mb_xy] |= CANDIDATE_MB_TYPE_BIDIR;\n            }\n        }\n    }\n}\n\n/**\n * Encode the dc value.\n * @param n block index (0-3 are luma, 4-5 are chroma)\n */\nstatic inline void mpeg4_encode_dc(PutBitContext *s, int level, int n)\n{\n#if 1\n    /* DC will overflow if level is outside the [-255,255] range. */\n    level += 256;\n    if (n < 4) {\n        /* luminance */\n        put_bits(s, uni_DCtab_lum_len[level], uni_DCtab_lum_bits[level]);\n    } else {\n        /* chrominance */\n        put_bits(s, uni_DCtab_chrom_len[level], uni_DCtab_chrom_bits[level]);\n    }\n#else\n    int size, v;\n    /* find number of bits */\n    size = 0;\n    v    = abs(level);\n    while (v) {\n        v >>= 1;\n        size++;\n    }\n\n    if (n < 4) {\n        /* luminance */\n        put_bits(s, ff_mpeg4_DCtab_lum[size][1], ff_mpeg4_DCtab_lum[size][0]);\n    } else {\n        /* chrominance */\n        put_bits(s, ff_mpeg4_DCtab_chrom[size][1], ff_mpeg4_DCtab_chrom[size][0]);\n    }\n\n    /* encode remaining bits */\n    if (size > 0) {\n        if (level < 0)\n            level = (-level) ^ ((1 << size) - 1);\n        put_bits(s, size, level);\n        if (size > 8)\n            put_bits(s, 1, 1);\n    }\n#endif\n}\n\nstatic inline int mpeg4_get_dc_length(int level, int n)\n{\n    if (n < 4)\n        return uni_DCtab_lum_len[level + 256];\n    else\n        return uni_DCtab_chrom_len[level + 256];\n}\n\n/**\n * Encode an 8x8 block.\n * @param n block index (0-3 are luma, 4-5 are chroma)\n */\nstatic inline void mpeg4_encode_block(MpegEncContext *s,\n                                      int16_t *block, int n, int intra_dc,\n                                      uint8_t *scan_table, PutBitContext *dc_pb,\n                                      PutBitContext *ac_pb)\n{\n    int i, last_non_zero;\n    uint32_t *bits_tab;\n    uint8_t *len_tab;\n    const int last_index = s->block_last_index[n];\n\n    if (s->mb_intra) {  // Note gcc (3.2.1 at least) will optimize this away\n        /* mpeg4 based DC predictor */\n        mpeg4_encode_dc(dc_pb, intra_dc, n);\n        if (last_index < 1)\n            return;\n        i = 1;\n        bits_tab = uni_mpeg4_intra_rl_bits;\n        len_tab  = uni_mpeg4_intra_rl_len;\n    } else {\n        if (last_index < 0)\n            return;\n        i = 0;\n        bits_tab = uni_mpeg4_inter_rl_bits;\n        len_tab  = uni_mpeg4_inter_rl_len;\n    }\n\n    /* AC coefs */\n    last_non_zero = i - 1;\n    for (; i < last_index; i++) {\n        int level = block[scan_table[i]];\n        if (level) {\n            int run = i - last_non_zero - 1;\n            level += 64;\n            if ((level & (~127)) == 0) {\n                const int index = UNI_MPEG4_ENC_INDEX(0, run, level);\n                put_bits(ac_pb, len_tab[index], bits_tab[index]);\n            } else {  // ESC3\n                put_bits(ac_pb,\n                         7 + 2 + 1 + 6 + 1 + 12 + 1,\n                         (3 << 23) + (3 << 21) + (0 << 20) + (run << 14) +\n                         (1 << 13) + (((level - 64) & 0xfff) << 1) + 1);\n            }\n            last_non_zero = i;\n        }\n    }\n    /* if (i <= last_index) */ {\n        int level = block[scan_table[i]];\n        int run   = i - last_non_zero - 1;\n        level += 64;\n        if ((level & (~127)) == 0) {\n            const int index = UNI_MPEG4_ENC_INDEX(1, run, level);\n            put_bits(ac_pb, len_tab[index], bits_tab[index]);\n        } else {  // ESC3\n            put_bits(ac_pb,\n                     7 + 2 + 1 + 6 + 1 + 12 + 1,\n                     (3 << 23) + (3 << 21) + (1 << 20) + (run << 14) +\n                     (1 << 13) + (((level - 64) & 0xfff) << 1) + 1);\n        }\n    }\n}\n\nstatic int mpeg4_get_block_length(MpegEncContext *s,\n                                  int16_t *block, int n,\n                                  int intra_dc, uint8_t *scan_table)\n{\n    int i, last_non_zero;\n    uint8_t *len_tab;\n    const int last_index = s->block_last_index[n];\n    int len = 0;\n\n    if (s->mb_intra) {  // Note gcc (3.2.1 at least) will optimize this away\n        /* mpeg4 based DC predictor */\n        len += mpeg4_get_dc_length(intra_dc, n);\n        if (last_index < 1)\n            return len;\n        i = 1;\n        len_tab = uni_mpeg4_intra_rl_len;\n    } else {\n        if (last_index < 0)\n            return 0;\n        i = 0;\n        len_tab = uni_mpeg4_inter_rl_len;\n    }\n\n    /* AC coefs */\n    last_non_zero = i - 1;\n    for (; i < last_index; i++) {\n        int level = block[scan_table[i]];\n        if (level) {\n            int run = i - last_non_zero - 1;\n            level += 64;\n            if ((level & (~127)) == 0) {\n                const int index = UNI_MPEG4_ENC_INDEX(0, run, level);\n                len += len_tab[index];\n            } else {  // ESC3\n                len += 7 + 2 + 1 + 6 + 1 + 12 + 1;\n            }\n            last_non_zero = i;\n        }\n    }\n    /* if (i <= last_index) */ {\n        int level = block[scan_table[i]];\n        int run   = i - last_non_zero - 1;\n        level += 64;\n        if ((level & (~127)) == 0) {\n            const int index = UNI_MPEG4_ENC_INDEX(1, run, level);\n            len += len_tab[index];\n        } else {  // ESC3\n            len += 7 + 2 + 1 + 6 + 1 + 12 + 1;\n        }\n    }\n\n    return len;\n}\n\nstatic inline void mpeg4_encode_blocks(MpegEncContext *s, int16_t block[6][64],\n                                       int intra_dc[6], uint8_t **scan_table,\n                                       PutBitContext *dc_pb,\n                                       PutBitContext *ac_pb)\n{\n    int i;\n\n    if (scan_table) {\n        if (s->avctx->flags2 & AV_CODEC_FLAG2_NO_OUTPUT) {\n            for (i = 0; i < 6; i++)\n                skip_put_bits(&s->pb,\n                              mpeg4_get_block_length(s, block[i], i,\n                                                     intra_dc[i], scan_table[i]));\n        } else {\n            /* encode each block */\n            for (i = 0; i < 6; i++)\n                mpeg4_encode_block(s, block[i], i,\n                                   intra_dc[i], scan_table[i], dc_pb, ac_pb);\n        }\n    } else {\n        if (s->avctx->flags2 & AV_CODEC_FLAG2_NO_OUTPUT) {\n            for (i = 0; i < 6; i++)\n                skip_put_bits(&s->pb,\n                              mpeg4_get_block_length(s, block[i], i, 0,\n                                                     s->intra_scantable.permutated));\n        } else {\n            /* encode each block */\n            for (i = 0; i < 6; i++)\n                mpeg4_encode_block(s, block[i], i, 0,\n                                   s->intra_scantable.permutated, dc_pb, ac_pb);\n        }\n    }\n}\n\nstatic inline int get_b_cbp(MpegEncContext *s, int16_t block[6][64],\n                            int motion_x, int motion_y, int mb_type)\n{\n    int cbp = 0, i;\n\n    if (s->mpv_flags & FF_MPV_FLAG_CBP_RD) {\n        int score        = 0;\n        const int lambda = s->lambda2 >> (FF_LAMBDA_SHIFT - 6);\n\n        for (i = 0; i < 6; i++) {\n            if (s->coded_score[i] < 0) {\n                score += s->coded_score[i];\n                cbp   |= 1 << (5 - i);\n            }\n        }\n\n        if (cbp) {\n            int zero_score = -6;\n            if ((motion_x | motion_y | s->dquant | mb_type) == 0)\n                zero_score -= 4;  // 2 * MV + mb_type + cbp bit\n\n            zero_score *= lambda;\n            if (zero_score <= score)\n                cbp = 0;\n        }\n\n        for (i = 0; i < 6; i++) {\n            if (s->block_last_index[i] >= 0 && ((cbp >> (5 - i)) & 1) == 0) {\n                s->block_last_index[i] = -1;\n                s->bdsp.clear_block(s->block[i]);\n            }\n        }\n    } else {\n        for (i = 0; i < 6; i++) {\n            if (s->block_last_index[i] >= 0)\n                cbp |= 1 << (5 - i);\n        }\n    }\n    return cbp;\n}\n\n// FIXME this is duplicated to h263.c\nstatic const int dquant_code[5] = { 1, 0, 9, 2, 3 };\n\nvoid ff_mpeg4_encode_mb(MpegEncContext *s, int16_t block[6][64],\n                        int motion_x, int motion_y)\n{\n    int cbpc, cbpy, pred_x, pred_y;\n    PutBitContext *const pb2    = s->data_partitioning ? &s->pb2 : &s->pb;\n    PutBitContext *const tex_pb = s->data_partitioning && s->pict_type != AV_PICTURE_TYPE_B ? &s->tex_pb : &s->pb;\n    PutBitContext *const dc_pb  = s->data_partitioning && s->pict_type != AV_PICTURE_TYPE_I ? &s->pb2 : &s->pb;\n    const int interleaved_stats = (s->avctx->flags & AV_CODEC_FLAG_PASS1) && !s->data_partitioning ? 1 : 0;\n\n    if (!s->mb_intra) {\n        int i, cbp;\n\n        if (s->pict_type == AV_PICTURE_TYPE_B) {\n            /* convert from mv_dir to type */\n            static const int mb_type_table[8] = { -1, 3, 2, 1, -1, -1, -1, 0 };\n            int mb_type = mb_type_table[s->mv_dir];\n\n            if (s->mb_x == 0) {\n                for (i = 0; i < 2; i++)\n                    s->last_mv[i][0][0] =\n                    s->last_mv[i][0][1] =\n                    s->last_mv[i][1][0] =\n                    s->last_mv[i][1][1] = 0;\n            }\n\n            av_assert2(s->dquant >= -2 && s->dquant <= 2);\n            av_assert2((s->dquant & 1) == 0);\n            av_assert2(mb_type >= 0);\n\n            /* nothing to do if this MB was skipped in the next P Frame */\n            if (s->next_picture.mbskip_table[s->mb_y * s->mb_stride + s->mb_x]) {  // FIXME avoid DCT & ...\n                s->skip_count++;\n                s->mv[0][0][0] =\n                s->mv[0][0][1] =\n                s->mv[1][0][0] =\n                s->mv[1][0][1] = 0;\n                s->mv_dir  = MV_DIR_FORWARD;  // doesn't matter\n                s->qscale -= s->dquant;\n//                s->mb_skipped = 1;\n\n                return;\n            }\n\n            cbp = get_b_cbp(s, block, motion_x, motion_y, mb_type);\n\n            if ((cbp | motion_x | motion_y | mb_type) == 0) {\n                /* direct MB with MV={0,0} */\n                av_assert2(s->dquant == 0);\n\n                put_bits(&s->pb, 1, 1); /* mb not coded modb1=1 */\n\n                if (interleaved_stats) {\n                    s->misc_bits++;\n                    s->last_bits++;\n                }\n                s->skip_count++;\n                return;\n            }\n\n            put_bits(&s->pb, 1, 0);            /* mb coded modb1=0 */\n            put_bits(&s->pb, 1, cbp ? 0 : 1);  /* modb2 */ // FIXME merge\n            put_bits(&s->pb, mb_type + 1, 1);  // this table is so simple that we don't need it :)\n            if (cbp)\n                put_bits(&s->pb, 6, cbp);\n\n            if (cbp && mb_type) {\n                if (s->dquant)\n                    put_bits(&s->pb, 2, (s->dquant >> 2) + 3);\n                else\n                    put_bits(&s->pb, 1, 0);\n            } else\n                s->qscale -= s->dquant;\n\n            if (!s->progressive_sequence) {\n                if (cbp)\n                    put_bits(&s->pb, 1, s->interlaced_dct);\n                if (mb_type)                  // not direct mode\n                    put_bits(&s->pb, 1, s->mv_type == MV_TYPE_FIELD);\n            }\n\n            if (interleaved_stats)\n                s->misc_bits += get_bits_diff(s);\n\n            if (!mb_type) {\n                av_assert2(s->mv_dir & MV_DIRECT);\n                ff_h263_encode_motion_vector(s, motion_x, motion_y, 1);\n                s->b_count++;\n                s->f_count++;\n            } else {\n                av_assert2(mb_type > 0 && mb_type < 4);\n                if (s->mv_type != MV_TYPE_FIELD) {\n                    if (s->mv_dir & MV_DIR_FORWARD) {\n                        ff_h263_encode_motion_vector(s,\n                                                     s->mv[0][0][0] - s->last_mv[0][0][0],\n                                                     s->mv[0][0][1] - s->last_mv[0][0][1],\n                                                     s->f_code);\n                        s->last_mv[0][0][0] =\n                        s->last_mv[0][1][0] = s->mv[0][0][0];\n                        s->last_mv[0][0][1] =\n                        s->last_mv[0][1][1] = s->mv[0][0][1];\n                        s->f_count++;\n                    }\n                    if (s->mv_dir & MV_DIR_BACKWARD) {\n                        ff_h263_encode_motion_vector(s,\n                                                     s->mv[1][0][0] - s->last_mv[1][0][0],\n                                                     s->mv[1][0][1] - s->last_mv[1][0][1],\n                                                     s->b_code);\n                        s->last_mv[1][0][0] =\n                        s->last_mv[1][1][0] = s->mv[1][0][0];\n                        s->last_mv[1][0][1] =\n                        s->last_mv[1][1][1] = s->mv[1][0][1];\n                        s->b_count++;\n                    }\n                } else {\n                    if (s->mv_dir & MV_DIR_FORWARD) {\n                        put_bits(&s->pb, 1, s->field_select[0][0]);\n                        put_bits(&s->pb, 1, s->field_select[0][1]);\n                    }\n                    if (s->mv_dir & MV_DIR_BACKWARD) {\n                        put_bits(&s->pb, 1, s->field_select[1][0]);\n                        put_bits(&s->pb, 1, s->field_select[1][1]);\n                    }\n                    if (s->mv_dir & MV_DIR_FORWARD) {\n                        for (i = 0; i < 2; i++) {\n                            ff_h263_encode_motion_vector(s,\n                                                         s->mv[0][i][0] - s->last_mv[0][i][0],\n                                                         s->mv[0][i][1] - s->last_mv[0][i][1] / 2,\n                                                         s->f_code);\n                            s->last_mv[0][i][0] = s->mv[0][i][0];\n                            s->last_mv[0][i][1] = s->mv[0][i][1] * 2;\n                        }\n                        s->f_count++;\n                    }\n                    if (s->mv_dir & MV_DIR_BACKWARD) {\n                        for (i = 0; i < 2; i++) {\n                            ff_h263_encode_motion_vector(s,\n                                                         s->mv[1][i][0] - s->last_mv[1][i][0],\n                                                         s->mv[1][i][1] - s->last_mv[1][i][1] / 2,\n                                                         s->b_code);\n                            s->last_mv[1][i][0] = s->mv[1][i][0];\n                            s->last_mv[1][i][1] = s->mv[1][i][1] * 2;\n                        }\n                        s->b_count++;\n                    }\n                }\n            }\n\n            if (interleaved_stats)\n                s->mv_bits += get_bits_diff(s);\n\n            mpeg4_encode_blocks(s, block, NULL, NULL, NULL, &s->pb);\n\n            if (interleaved_stats)\n                s->p_tex_bits += get_bits_diff(s);\n        } else { /* s->pict_type==AV_PICTURE_TYPE_B */\n            cbp = get_p_cbp(s, block, motion_x, motion_y);\n\n            if ((cbp | motion_x | motion_y | s->dquant) == 0 &&\n                s->mv_type == MV_TYPE_16X16) {\n                /* check if the B frames can skip it too, as we must skip it\n                 * if we skip here why didn't they just compress\n                 * the skip-mb bits instead of reusing them ?! */\n                if (s->max_b_frames > 0) {\n                    int i;\n                    int x, y, offset;\n                    uint8_t *p_pic;\n\n                    x = s->mb_x * 16;\n                    y = s->mb_y * 16;\n\n                    offset = x + y * s->linesize;\n                    p_pic  = s->new_picture.f->data[0] + offset;\n\n                    s->mb_skipped = 1;\n                    for (i = 0; i < s->max_b_frames; i++) {\n                        uint8_t *b_pic;\n                        int diff;\n                        Picture *pic = s->reordered_input_picture[i + 1];\n\n                        if (!pic || pic->f->pict_type != AV_PICTURE_TYPE_B)\n                            break;\n\n                        b_pic = pic->f->data[0] + offset;\n                        if (!pic->shared)\n                            b_pic += INPLACE_OFFSET;\n\n                        if (x + 16 > s->width || y + 16 > s->height) {\n                            int x1, y1;\n                            int xe = FFMIN(16, s->width - x);\n                            int ye = FFMIN(16, s->height - y);\n                            diff = 0;\n                            for (y1 = 0; y1 < ye; y1++) {\n                                for (x1 = 0; x1 < xe; x1++) {\n                                    diff += FFABS(p_pic[x1 + y1 * s->linesize] - b_pic[x1 + y1 * s->linesize]);\n                                }\n                            }\n                            diff = diff * 256 / (xe * ye);\n                        } else {\n                            diff = s->mecc.sad[0](NULL, p_pic, b_pic, s->linesize, 16);\n                        }\n                        if (diff > s->qscale * 70) {  // FIXME check that 70 is optimal\n                            s->mb_skipped = 0;\n                            break;\n                        }\n                    }\n                } else\n                    s->mb_skipped = 1;\n\n                if (s->mb_skipped == 1) {\n                    /* skip macroblock */\n                    put_bits(&s->pb, 1, 1);\n\n                    if (interleaved_stats) {\n                        s->misc_bits++;\n                        s->last_bits++;\n                    }\n                    s->skip_count++;\n\n                    return;\n                }\n            }\n\n            put_bits(&s->pb, 1, 0);     /* mb coded */\n            cbpc  = cbp & 3;\n            cbpy  = cbp >> 2;\n            cbpy ^= 0xf;\n            if (s->mv_type == MV_TYPE_16X16) {\n                if (s->dquant)\n                    cbpc += 8;\n                put_bits(&s->pb,\n                         ff_h263_inter_MCBPC_bits[cbpc],\n                         ff_h263_inter_MCBPC_code[cbpc]);\n\n                put_bits(pb2, ff_h263_cbpy_tab[cbpy][1], ff_h263_cbpy_tab[cbpy][0]);\n                if (s->dquant)\n                    put_bits(pb2, 2, dquant_code[s->dquant + 2]);\n\n                if (!s->progressive_sequence) {\n                    if (cbp)\n                        put_bits(pb2, 1, s->interlaced_dct);\n                    put_bits(pb2, 1, 0);\n                }\n\n                if (interleaved_stats)\n                    s->misc_bits += get_bits_diff(s);\n\n                /* motion vectors: 16x16 mode */\n                ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n\n                ff_h263_encode_motion_vector(s,\n                                             motion_x - pred_x,\n                                             motion_y - pred_y,\n                                             s->f_code);\n            } else if (s->mv_type == MV_TYPE_FIELD) {\n                if (s->dquant)\n                    cbpc += 8;\n                put_bits(&s->pb,\n                         ff_h263_inter_MCBPC_bits[cbpc],\n                         ff_h263_inter_MCBPC_code[cbpc]);\n\n                put_bits(pb2, ff_h263_cbpy_tab[cbpy][1], ff_h263_cbpy_tab[cbpy][0]);\n                if (s->dquant)\n                    put_bits(pb2, 2, dquant_code[s->dquant + 2]);\n\n                av_assert2(!s->progressive_sequence);\n                if (cbp)\n                    put_bits(pb2, 1, s->interlaced_dct);\n                put_bits(pb2, 1, 1);\n\n                if (interleaved_stats)\n                    s->misc_bits += get_bits_diff(s);\n\n                /* motion vectors: 16x8 interlaced mode */\n                ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n                pred_y /= 2;\n\n                put_bits(&s->pb, 1, s->field_select[0][0]);\n                put_bits(&s->pb, 1, s->field_select[0][1]);\n\n                ff_h263_encode_motion_vector(s,\n                                             s->mv[0][0][0] - pred_x,\n                                             s->mv[0][0][1] - pred_y,\n                                             s->f_code);\n                ff_h263_encode_motion_vector(s,\n                                             s->mv[0][1][0] - pred_x,\n                                             s->mv[0][1][1] - pred_y,\n                                             s->f_code);\n            } else {\n                av_assert2(s->mv_type == MV_TYPE_8X8);\n                put_bits(&s->pb,\n                         ff_h263_inter_MCBPC_bits[cbpc + 16],\n                         ff_h263_inter_MCBPC_code[cbpc + 16]);\n                put_bits(pb2, ff_h263_cbpy_tab[cbpy][1], ff_h263_cbpy_tab[cbpy][0]);\n\n                if (!s->progressive_sequence && cbp)\n                    put_bits(pb2, 1, s->interlaced_dct);\n\n                if (interleaved_stats)\n                    s->misc_bits += get_bits_diff(s);\n\n                for (i = 0; i < 4; i++) {\n                    /* motion vectors: 8x8 mode*/\n                    ff_h263_pred_motion(s, i, 0, &pred_x, &pred_y);\n\n                    ff_h263_encode_motion_vector(s,\n                                                 s->current_picture.motion_val[0][s->block_index[i]][0] - pred_x,\n                                                 s->current_picture.motion_val[0][s->block_index[i]][1] - pred_y,\n                                                 s->f_code);\n                }\n            }\n\n            if (interleaved_stats)\n                s->mv_bits += get_bits_diff(s);\n\n            mpeg4_encode_blocks(s, block, NULL, NULL, NULL, tex_pb);\n\n            if (interleaved_stats)\n                s->p_tex_bits += get_bits_diff(s);\n\n            s->f_count++;\n        }\n    } else {\n        int cbp;\n        int dc_diff[6];  // dc values with the dc prediction subtracted\n        int dir[6];      // prediction direction\n        int zigzag_last_index[6];\n        uint8_t *scan_table[6];\n        int i;\n\n        for (i = 0; i < 6; i++)\n            dc_diff[i] = ff_mpeg4_pred_dc(s, i, block[i][0], &dir[i], 1);\n\n        if (s->avctx->flags & AV_CODEC_FLAG_AC_PRED) {\n            s->ac_pred = decide_ac_pred(s, block, dir, scan_table, zigzag_last_index);\n        } else {\n            for (i = 0; i < 6; i++)\n                scan_table[i] = s->intra_scantable.permutated;\n        }\n\n        /* compute cbp */\n        cbp = 0;\n        for (i = 0; i < 6; i++)\n            if (s->block_last_index[i] >= 1)\n                cbp |= 1 << (5 - i);\n\n        cbpc = cbp & 3;\n        if (s->pict_type == AV_PICTURE_TYPE_I) {\n            if (s->dquant)\n                cbpc += 4;\n            put_bits(&s->pb,\n                     ff_h263_intra_MCBPC_bits[cbpc],\n                     ff_h263_intra_MCBPC_code[cbpc]);\n        } else {\n            if (s->dquant)\n                cbpc += 8;\n            put_bits(&s->pb, 1, 0);     /* mb coded */\n            put_bits(&s->pb,\n                     ff_h263_inter_MCBPC_bits[cbpc + 4],\n                     ff_h263_inter_MCBPC_code[cbpc + 4]);\n        }\n        put_bits(pb2, 1, s->ac_pred);\n        cbpy = cbp >> 2;\n        put_bits(pb2, ff_h263_cbpy_tab[cbpy][1], ff_h263_cbpy_tab[cbpy][0]);\n        if (s->dquant)\n            put_bits(dc_pb, 2, dquant_code[s->dquant + 2]);\n\n        if (!s->progressive_sequence)\n            put_bits(dc_pb, 1, s->interlaced_dct);\n\n        if (interleaved_stats)\n            s->misc_bits += get_bits_diff(s);\n\n        mpeg4_encode_blocks(s, block, dc_diff, scan_table, dc_pb, tex_pb);\n\n        if (interleaved_stats)\n            s->i_tex_bits += get_bits_diff(s);\n        s->i_count++;\n\n        /* restore ac coeffs & last_index stuff\n         * if we messed them up with the prediction */\n        if (s->ac_pred)\n            restore_ac_coeffs(s, block, dir, scan_table, zigzag_last_index);\n    }\n}\n\n/**\n * add mpeg4 stuffing bits (01...1)\n */\nvoid ff_mpeg4_stuffing(PutBitContext *pbc)\n{\n    int length;\n    put_bits(pbc, 1, 0);\n    length = (-put_bits_count(pbc)) & 7;\n    if (length)\n        put_bits(pbc, length, (1 << length) - 1);\n}\n\n/* must be called before writing the header */\nvoid ff_set_mpeg4_time(MpegEncContext *s)\n{\n    if (s->pict_type == AV_PICTURE_TYPE_B) {\n        ff_mpeg4_init_direct_mv(s);\n    } else {\n        s->last_time_base = s->time_base;\n        s->time_base      = FFUDIV(s->time, s->avctx->time_base.den);\n    }\n}\n\nstatic void mpeg4_encode_gop_header(MpegEncContext *s)\n{\n    int hours, minutes, seconds;\n    int64_t time;\n\n    put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, GOP_STARTCODE);\n\n    time = s->current_picture_ptr->f->pts;\n    if (s->reordered_input_picture[1])\n        time = FFMIN(time, s->reordered_input_picture[1]->f->pts);\n    time = time * s->avctx->time_base.num;\n    s->last_time_base = FFUDIV(time, s->avctx->time_base.den);\n\n    seconds = FFUDIV(time, s->avctx->time_base.den);\n    minutes = FFUDIV(seconds, 60); seconds = FFUMOD(seconds, 60);\n    hours   = FFUDIV(minutes, 60); minutes = FFUMOD(minutes, 60);\n    hours   = FFUMOD(hours  , 24);\n\n    put_bits(&s->pb, 5, hours);\n    put_bits(&s->pb, 6, minutes);\n    put_bits(&s->pb, 1, 1);\n    put_bits(&s->pb, 6, seconds);\n\n    put_bits(&s->pb, 1, !!(s->avctx->flags & AV_CODEC_FLAG_CLOSED_GOP));\n    put_bits(&s->pb, 1, 0);  // broken link == NO\n\n    ff_mpeg4_stuffing(&s->pb);\n}\n\nstatic void mpeg4_encode_visual_object_header(MpegEncContext *s)\n{\n    int profile_and_level_indication;\n    int vo_ver_id;\n\n    if (s->avctx->profile != FF_PROFILE_UNKNOWN) {\n        profile_and_level_indication = s->avctx->profile << 4;\n    } else if (s->max_b_frames || s->quarter_sample) {\n        profile_and_level_indication = 0xF0;  // adv simple\n    } else {\n        profile_and_level_indication = 0x00;  // simple\n    }\n\n    if (s->avctx->level != FF_LEVEL_UNKNOWN)\n        profile_and_level_indication |= s->avctx->level;\n    else\n        profile_and_level_indication |= 1;   // level 1\n\n    if (profile_and_level_indication >> 4 == 0xF)\n        vo_ver_id = 5;\n    else\n        vo_ver_id = 1;\n\n    // FIXME levels\n\n    put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, VOS_STARTCODE);\n\n    put_bits(&s->pb, 8, profile_and_level_indication);\n\n    put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, VISUAL_OBJ_STARTCODE);\n\n    put_bits(&s->pb, 1, 1);\n    put_bits(&s->pb, 4, vo_ver_id);\n    put_bits(&s->pb, 3, 1);     // priority\n\n    put_bits(&s->pb, 4, 1);     // visual obj type== video obj\n\n    put_bits(&s->pb, 1, 0);     // video signal type == no clue // FIXME\n\n    ff_mpeg4_stuffing(&s->pb);\n}\n\nstatic void mpeg4_encode_vol_header(MpegEncContext *s,\n                                    int vo_number,\n                                    int vol_number)\n{\n    int vo_ver_id;\n\n    if (!CONFIG_MPEG4_ENCODER)\n        return;\n\n    if (s->max_b_frames || s->quarter_sample) {\n        vo_ver_id  = 5;\n        s->vo_type = ADV_SIMPLE_VO_TYPE;\n    } else {\n        vo_ver_id  = 1;\n        s->vo_type = SIMPLE_VO_TYPE;\n    }\n\n    put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, 0x100 + vo_number);        /* video obj */\n    put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, 0x120 + vol_number);       /* video obj layer */\n\n    put_bits(&s->pb, 1, 0);             /* random access vol */\n    put_bits(&s->pb, 8, s->vo_type);    /* video obj type indication */\n    if (s->workaround_bugs & FF_BUG_MS) {\n        put_bits(&s->pb, 1, 0);         /* is obj layer id= no */\n    } else {\n        put_bits(&s->pb, 1, 1);         /* is obj layer id= yes */\n        put_bits(&s->pb, 4, vo_ver_id); /* is obj layer ver id */\n        put_bits(&s->pb, 3, 1);         /* is obj layer priority */\n    }\n\n    s->aspect_ratio_info = ff_h263_aspect_to_info(s->avctx->sample_aspect_ratio);\n\n    put_bits(&s->pb, 4, s->aspect_ratio_info); /* aspect ratio info */\n    if (s->aspect_ratio_info == FF_ASPECT_EXTENDED) {\n        av_reduce(&s->avctx->sample_aspect_ratio.num, &s->avctx->sample_aspect_ratio.den,\n                   s->avctx->sample_aspect_ratio.num,  s->avctx->sample_aspect_ratio.den, 255);\n        put_bits(&s->pb, 8, s->avctx->sample_aspect_ratio.num);\n        put_bits(&s->pb, 8, s->avctx->sample_aspect_ratio.den);\n    }\n\n    if (s->workaround_bugs & FF_BUG_MS) {\n        put_bits(&s->pb, 1, 0);         /* vol control parameters= no @@@ */\n    } else {\n        put_bits(&s->pb, 1, 1);         /* vol control parameters= yes */\n        put_bits(&s->pb, 2, 1);         /* chroma format YUV 420/YV12 */\n        put_bits(&s->pb, 1, s->low_delay);\n        put_bits(&s->pb, 1, 0);         /* vbv parameters= no */\n    }\n\n    put_bits(&s->pb, 2, RECT_SHAPE);    /* vol shape= rectangle */\n    put_bits(&s->pb, 1, 1);             /* marker bit */\n\n    put_bits(&s->pb, 16, s->avctx->time_base.den);\n    if (s->time_increment_bits < 1)\n        s->time_increment_bits = 1;\n    put_bits(&s->pb, 1, 1);             /* marker bit */\n    put_bits(&s->pb, 1, 0);             /* fixed vop rate=no */\n    put_bits(&s->pb, 1, 1);             /* marker bit */\n    put_bits(&s->pb, 13, s->width);     /* vol width */\n    put_bits(&s->pb, 1, 1);             /* marker bit */\n    put_bits(&s->pb, 13, s->height);    /* vol height */\n    put_bits(&s->pb, 1, 1);             /* marker bit */\n    put_bits(&s->pb, 1, s->progressive_sequence ? 0 : 1);\n    put_bits(&s->pb, 1, 1);             /* obmc disable */\n    if (vo_ver_id == 1)\n        put_bits(&s->pb, 1, 0);       /* sprite enable */\n    else\n        put_bits(&s->pb, 2, 0);       /* sprite enable */\n\n    put_bits(&s->pb, 1, 0);             /* not 8 bit == false */\n    put_bits(&s->pb, 1, s->mpeg_quant); /* quant type= (0=h263 style)*/\n\n    if (s->mpeg_quant) {\n        ff_write_quant_matrix(&s->pb, s->avctx->intra_matrix);\n        ff_write_quant_matrix(&s->pb, s->avctx->inter_matrix);\n    }\n\n    if (vo_ver_id != 1)\n        put_bits(&s->pb, 1, s->quarter_sample);\n    put_bits(&s->pb, 1, 1);             /* complexity estimation disable */\n    put_bits(&s->pb, 1, s->rtp_mode ? 0 : 1); /* resync marker disable */\n    put_bits(&s->pb, 1, s->data_partitioning ? 1 : 0);\n    if (s->data_partitioning)\n        put_bits(&s->pb, 1, 0);         /* no rvlc */\n\n    if (vo_ver_id != 1) {\n        put_bits(&s->pb, 1, 0);         /* newpred */\n        put_bits(&s->pb, 1, 0);         /* reduced res vop */\n    }\n    put_bits(&s->pb, 1, 0);             /* scalability */\n\n    ff_mpeg4_stuffing(&s->pb);\n\n    /* user data */\n    if (!(s->avctx->flags & AV_CODEC_FLAG_BITEXACT)) {\n        put_bits(&s->pb, 16, 0);\n        put_bits(&s->pb, 16, 0x1B2);    /* user_data */\n        avpriv_put_string(&s->pb, LIBAVCODEC_IDENT, 0);\n    }\n}\n\n/* write mpeg4 VOP header */\nint ff_mpeg4_encode_picture_header(MpegEncContext *s, int picture_number)\n{\n    int time_incr;\n    int time_div, time_mod;\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n        if (!(s->avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER)) {\n            if (s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT)  // HACK, the reference sw is buggy\n                mpeg4_encode_visual_object_header(s);\n            if (s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT || picture_number == 0)  // HACK, the reference sw is buggy\n                mpeg4_encode_vol_header(s, 0, 0);\n        }\n        if (!(s->workaround_bugs & FF_BUG_MS))\n            mpeg4_encode_gop_header(s);\n    }\n\n    s->partitioned_frame = s->data_partitioning && s->pict_type != AV_PICTURE_TYPE_B;\n\n    put_bits(&s->pb, 16, 0);                /* vop header */\n    put_bits(&s->pb, 16, VOP_STARTCODE);    /* vop header */\n    put_bits(&s->pb, 2, s->pict_type - 1);  /* pict type: I = 0 , P = 1 */\n\n    time_div  = FFUDIV(s->time, s->avctx->time_base.den);\n    time_mod  = FFUMOD(s->time, s->avctx->time_base.den);\n    time_incr = time_div - s->last_time_base;\n    av_assert0(time_incr >= 0);\n\n    // This limits the frame duration to max 1 hour\n    if (time_incr > 3600) {\n        av_log(s->avctx, AV_LOG_ERROR, \"time_incr %d too large\\n\", time_incr);\n        return AVERROR(EINVAL);\n    }\n    while (time_incr--)\n        put_bits(&s->pb, 1, 1);\n\n    put_bits(&s->pb, 1, 0);\n\n    put_bits(&s->pb, 1, 1);                             /* marker */\n    put_bits(&s->pb, s->time_increment_bits, time_mod); /* time increment */\n    put_bits(&s->pb, 1, 1);                             /* marker */\n    put_bits(&s->pb, 1, 1);                             /* vop coded */\n    if (s->pict_type == AV_PICTURE_TYPE_P) {\n        put_bits(&s->pb, 1, s->no_rounding);    /* rounding type */\n    }\n    put_bits(&s->pb, 3, 0);     /* intra dc VLC threshold */\n    if (!s->progressive_sequence) {\n        put_bits(&s->pb, 1, s->current_picture_ptr->f->top_field_first);\n        put_bits(&s->pb, 1, s->alternate_scan);\n    }\n    // FIXME sprite stuff\n\n    put_bits(&s->pb, 5, s->qscale);\n\n    if (s->pict_type != AV_PICTURE_TYPE_I)\n        put_bits(&s->pb, 3, s->f_code);  /* fcode_for */\n    if (s->pict_type == AV_PICTURE_TYPE_B)\n        put_bits(&s->pb, 3, s->b_code);  /* fcode_back */\n\n    return 0;\n}\n\nstatic av_cold void init_uni_dc_tab(void)\n{\n    int level, uni_code, uni_len;\n\n    for (level = -256; level < 256; level++) {\n        int size, v, l;\n        /* find number of bits */\n        size = 0;\n        v    = abs(level);\n        while (v) {\n            v >>= 1;\n            size++;\n        }\n\n        if (level < 0)\n            l = (-level) ^ ((1 << size) - 1);\n        else\n            l = level;\n\n        /* luminance */\n        uni_code = ff_mpeg4_DCtab_lum[size][0];\n        uni_len  = ff_mpeg4_DCtab_lum[size][1];\n\n        if (size > 0) {\n            uni_code <<= size;\n            uni_code  |= l;\n            uni_len   += size;\n            if (size > 8) {\n                uni_code <<= 1;\n                uni_code  |= 1;\n                uni_len++;\n            }\n        }\n        uni_DCtab_lum_bits[level + 256] = uni_code;\n        uni_DCtab_lum_len[level + 256]  = uni_len;\n\n        /* chrominance */\n        uni_code = ff_mpeg4_DCtab_chrom[size][0];\n        uni_len  = ff_mpeg4_DCtab_chrom[size][1];\n\n        if (size > 0) {\n            uni_code <<= size;\n            uni_code  |= l;\n            uni_len   += size;\n            if (size > 8) {\n                uni_code <<= 1;\n                uni_code  |= 1;\n                uni_len++;\n            }\n        }\n        uni_DCtab_chrom_bits[level + 256] = uni_code;\n        uni_DCtab_chrom_len[level + 256]  = uni_len;\n    }\n}\n\nstatic av_cold void init_uni_mpeg4_rl_tab(RLTable *rl, uint32_t *bits_tab,\n                                          uint8_t *len_tab)\n{\n    int slevel, run, last;\n\n    av_assert0(MAX_LEVEL >= 64);\n    av_assert0(MAX_RUN >= 63);\n\n    for (slevel = -64; slevel < 64; slevel++) {\n        if (slevel == 0)\n            continue;\n        for (run = 0; run < 64; run++) {\n            for (last = 0; last <= 1; last++) {\n                const int index = UNI_MPEG4_ENC_INDEX(last, run, slevel + 64);\n                int level       = slevel < 0 ? -slevel : slevel;\n                int sign        = slevel < 0 ? 1 : 0;\n                int bits, len, code;\n                int level1, run1;\n\n                len_tab[index] = 100;\n\n                /* ESC0 */\n                code = get_rl_index(rl, last, run, level);\n                bits = rl->table_vlc[code][0];\n                len  = rl->table_vlc[code][1];\n                bits = bits * 2 + sign;\n                len++;\n\n                if (code != rl->n && len < len_tab[index]) {\n                    bits_tab[index] = bits;\n                    len_tab[index]  = len;\n                }\n                /* ESC1 */\n                bits = rl->table_vlc[rl->n][0];\n                len  = rl->table_vlc[rl->n][1];\n                bits = bits * 2;\n                len++;                 // esc1\n                level1 = level - rl->max_level[last][run];\n                if (level1 > 0) {\n                    code   = get_rl_index(rl, last, run, level1);\n                    bits <<= rl->table_vlc[code][1];\n                    len   += rl->table_vlc[code][1];\n                    bits  += rl->table_vlc[code][0];\n                    bits   = bits * 2 + sign;\n                    len++;\n\n                    if (code != rl->n && len < len_tab[index]) {\n                        bits_tab[index] = bits;\n                        len_tab[index]  = len;\n                    }\n                }\n                /* ESC2 */\n                bits = rl->table_vlc[rl->n][0];\n                len  = rl->table_vlc[rl->n][1];\n                bits = bits * 4 + 2;\n                len += 2;                 // esc2\n                run1 = run - rl->max_run[last][level] - 1;\n                if (run1 >= 0) {\n                    code   = get_rl_index(rl, last, run1, level);\n                    bits <<= rl->table_vlc[code][1];\n                    len   += rl->table_vlc[code][1];\n                    bits  += rl->table_vlc[code][0];\n                    bits   = bits * 2 + sign;\n                    len++;\n\n                    if (code != rl->n && len < len_tab[index]) {\n                        bits_tab[index] = bits;\n                        len_tab[index]  = len;\n                    }\n                }\n                /* ESC3 */\n                bits = rl->table_vlc[rl->n][0];\n                len  = rl->table_vlc[rl->n][1];\n                bits = bits * 4 + 3;\n                len += 2;                 // esc3\n                bits = bits * 2 + last;\n                len++;\n                bits = bits * 64 + run;\n                len += 6;\n                bits = bits * 2 + 1;\n                len++;                    // marker\n                bits = bits * 4096 + (slevel & 0xfff);\n                len += 12;\n                bits = bits * 2 + 1;\n                len++;                    // marker\n\n                if (len < len_tab[index]) {\n                    bits_tab[index] = bits;\n                    len_tab[index]  = len;\n                }\n            }\n        }\n    }\n}\n\nstatic av_cold int encode_init(AVCodecContext *avctx)\n{\n    MpegEncContext *s = avctx->priv_data;\n    int ret;\n    static int done = 0;\n\n    if (avctx->width >= (1<<13) || avctx->height >= (1<<13)) {\n        av_log(avctx, AV_LOG_ERROR, \"dimensions too large for MPEG-4\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    if ((ret = ff_mpv_encode_init(avctx)) < 0)\n        return ret;\n\n    if (!done) {\n        done = 1;\n\n        init_uni_dc_tab();\n\n        ff_rl_init(&ff_mpeg4_rl_intra, ff_mpeg4_static_rl_table_store[0]);\n\n        init_uni_mpeg4_rl_tab(&ff_mpeg4_rl_intra, uni_mpeg4_intra_rl_bits, uni_mpeg4_intra_rl_len);\n        init_uni_mpeg4_rl_tab(&ff_h263_rl_inter, uni_mpeg4_inter_rl_bits, uni_mpeg4_inter_rl_len);\n    }\n\n    s->min_qcoeff               = -2048;\n    s->max_qcoeff               = 2047;\n    s->intra_ac_vlc_length      = uni_mpeg4_intra_rl_len;\n    s->intra_ac_vlc_last_length = uni_mpeg4_intra_rl_len + 128 * 64;\n    s->inter_ac_vlc_length      = uni_mpeg4_inter_rl_len;\n    s->inter_ac_vlc_last_length = uni_mpeg4_inter_rl_len + 128 * 64;\n    s->luma_dc_vlc_length       = uni_DCtab_lum_len;\n    s->ac_esc_length            = 7 + 2 + 1 + 6 + 1 + 12 + 1;\n    s->y_dc_scale_table         = ff_mpeg4_y_dc_scale_table;\n    s->c_dc_scale_table         = ff_mpeg4_c_dc_scale_table;\n\n    if (s->avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {\n        s->avctx->extradata = av_malloc(1024);\n        init_put_bits(&s->pb, s->avctx->extradata, 1024);\n\n        if (!(s->workaround_bugs & FF_BUG_MS))\n            mpeg4_encode_visual_object_header(s);\n        mpeg4_encode_vol_header(s, 0, 0);\n\n//            ff_mpeg4_stuffing(&s->pb); ?\n        flush_put_bits(&s->pb);\n        s->avctx->extradata_size = (put_bits_count(&s->pb) + 7) >> 3;\n    }\n    return 0;\n}\n\nvoid ff_mpeg4_init_partitions(MpegEncContext *s)\n{\n    uint8_t *start = put_bits_ptr(&s->pb);\n    uint8_t *end   = s->pb.buf_end;\n    int size       = end - start;\n    int pb_size    = (((intptr_t)start + size / 3) & (~3)) - (intptr_t)start;\n    int tex_size   = (size - 2 * pb_size) & (~3);\n\n    set_put_bits_buffer_size(&s->pb, pb_size);\n    init_put_bits(&s->tex_pb, start + pb_size, tex_size);\n    init_put_bits(&s->pb2, start + pb_size + tex_size, pb_size);\n}\n\nvoid ff_mpeg4_merge_partitions(MpegEncContext *s)\n{\n    const int pb2_len    = put_bits_count(&s->pb2);\n    const int tex_pb_len = put_bits_count(&s->tex_pb);\n    const int bits       = put_bits_count(&s->pb);\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n        put_bits(&s->pb, 19, DC_MARKER);\n        s->misc_bits  += 19 + pb2_len + bits - s->last_bits;\n        s->i_tex_bits += tex_pb_len;\n    } else {\n        put_bits(&s->pb, 17, MOTION_MARKER);\n        s->misc_bits  += 17 + pb2_len;\n        s->mv_bits    += bits - s->last_bits;\n        s->p_tex_bits += tex_pb_len;\n    }\n\n    flush_put_bits(&s->pb2);\n    flush_put_bits(&s->tex_pb);\n\n    set_put_bits_buffer_size(&s->pb, s->pb2.buf_end - s->pb.buf);\n    avpriv_copy_bits(&s->pb, s->pb2.buf, pb2_len);\n    avpriv_copy_bits(&s->pb, s->tex_pb.buf, tex_pb_len);\n    s->last_bits = put_bits_count(&s->pb);\n}\n\nvoid ff_mpeg4_encode_video_packet_header(MpegEncContext *s)\n{\n    int mb_num_bits = av_log2(s->mb_num - 1) + 1;\n\n    put_bits(&s->pb, ff_mpeg4_get_video_packet_prefix_length(s), 0);\n    put_bits(&s->pb, 1, 1);\n\n    put_bits(&s->pb, mb_num_bits, s->mb_x + s->mb_y * s->mb_width);\n    put_bits(&s->pb, s->quant_precision, s->qscale);\n    put_bits(&s->pb, 1, 0); /* no HEC */\n}\n\n#define OFFSET(x) offsetof(MpegEncContext, x)\n#define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM\nstatic const AVOption options[] = {\n    { \"data_partitioning\", \"Use data partitioning.\",      OFFSET(data_partitioning), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 1, VE },\n    { \"alternate_scan\",    \"Enable alternate scantable.\", OFFSET(alternate_scan),    AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 1, VE },\n    FF_MPV_COMMON_OPTS\n    { NULL },\n};\n\nstatic const AVClass mpeg4enc_class = {\n    .class_name = \"MPEG4 encoder\",\n    .item_name  = av_default_item_name,\n    .option     = options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVCodec ff_mpeg4_encoder = {\n    .name           = \"mpeg4\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"MPEG-4 part 2\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_MPEG4,\n    .priv_data_size = sizeof(MpegEncContext),\n    .init           = encode_init,\n    .encode2        = ff_mpv_encode_picture,\n    .close          = ff_mpv_encode_end,\n    .pix_fmts       = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE },\n    .capabilities   = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_SLICE_THREADS,\n    .priv_class     = &mpeg4enc_class,\n};\n"], "fixing_code": ["/*\n * MPEG4 encoder.\n * Copyright (c) 2000,2001 Fabrice Bellard\n * Copyright (c) 2002-2010 Michael Niedermayer <michaelni@gmx.at>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/log.h\"\n#include \"libavutil/opt.h\"\n#include \"mpegutils.h\"\n#include \"mpegvideo.h\"\n#include \"h263.h\"\n#include \"mpeg4video.h\"\n\n/* The uni_DCtab_* tables below contain unified bits+length tables to encode DC\n * differences in mpeg4. Unified in the sense that the specification specifies\n * this encoding in several steps. */\nstatic uint8_t  uni_DCtab_lum_len[512];\nstatic uint8_t  uni_DCtab_chrom_len[512];\nstatic uint16_t uni_DCtab_lum_bits[512];\nstatic uint16_t uni_DCtab_chrom_bits[512];\n\n/* Unified encoding tables for run length encoding of coefficients.\n * Unified in the sense that the specification specifies the encoding in several steps. */\nstatic uint32_t uni_mpeg4_intra_rl_bits[64 * 64 * 2 * 2];\nstatic uint8_t  uni_mpeg4_intra_rl_len[64 * 64 * 2 * 2];\nstatic uint32_t uni_mpeg4_inter_rl_bits[64 * 64 * 2 * 2];\nstatic uint8_t  uni_mpeg4_inter_rl_len[64 * 64 * 2 * 2];\n\n//#define UNI_MPEG4_ENC_INDEX(last, run, level) ((last) * 128 + (run) * 256 + (level))\n//#define UNI_MPEG4_ENC_INDEX(last, run, level) ((last) * 128 * 64 + (run) + (level) * 64)\n#define UNI_MPEG4_ENC_INDEX(last, run, level) ((last) * 128 * 64 + (run) * 128 + (level))\n\n/* mpeg4\n * inter\n * max level: 24/6\n * max run: 53/63\n *\n * intra\n * max level: 53/16\n * max run: 29/41\n */\n\n/**\n * Return the number of bits that encoding the 8x8 block in block would need.\n * @param[in]  block_last_index last index in scantable order that refers to a non zero element in block.\n */\nstatic inline int get_block_rate(MpegEncContext *s, int16_t block[64],\n                                 int block_last_index, uint8_t scantable[64])\n{\n    int last = 0;\n    int j;\n    int rate = 0;\n\n    for (j = 1; j <= block_last_index; j++) {\n        const int index = scantable[j];\n        int level = block[index];\n        if (level) {\n            level += 64;\n            if ((level & (~127)) == 0) {\n                if (j < block_last_index)\n                    rate += s->intra_ac_vlc_length[UNI_AC_ENC_INDEX(j - last - 1, level)];\n                else\n                    rate += s->intra_ac_vlc_last_length[UNI_AC_ENC_INDEX(j - last - 1, level)];\n            } else\n                rate += s->ac_esc_length;\n\n            last = j;\n        }\n    }\n\n    return rate;\n}\n\n/**\n * Restore the ac coefficients in block that have been changed by decide_ac_pred().\n * This function also restores s->block_last_index.\n * @param[in,out] block MB coefficients, these will be restored\n * @param[in] dir ac prediction direction for each 8x8 block\n * @param[out] st scantable for each 8x8 block\n * @param[in] zigzag_last_index index referring to the last non zero coefficient in zigzag order\n */\nstatic inline void restore_ac_coeffs(MpegEncContext *s, int16_t block[6][64],\n                                     const int dir[6], uint8_t *st[6],\n                                     const int zigzag_last_index[6])\n{\n    int i, n;\n    memcpy(s->block_last_index, zigzag_last_index, sizeof(int) * 6);\n\n    for (n = 0; n < 6; n++) {\n        int16_t *ac_val = s->ac_val[0][0] + s->block_index[n] * 16;\n\n        st[n] = s->intra_scantable.permutated;\n        if (dir[n]) {\n            /* top prediction */\n            for (i = 1; i < 8; i++)\n                block[n][s->idsp.idct_permutation[i]] = ac_val[i + 8];\n        } else {\n            /* left prediction */\n            for (i = 1; i < 8; i++)\n                block[n][s->idsp.idct_permutation[i << 3]] = ac_val[i];\n        }\n    }\n}\n\n/**\n * Return the optimal value (0 or 1) for the ac_pred element for the given MB in mpeg4.\n * This function will also update s->block_last_index and s->ac_val.\n * @param[in,out] block MB coefficients, these will be updated if 1 is returned\n * @param[in] dir ac prediction direction for each 8x8 block\n * @param[out] st scantable for each 8x8 block\n * @param[out] zigzag_last_index index referring to the last non zero coefficient in zigzag order\n */\nstatic inline int decide_ac_pred(MpegEncContext *s, int16_t block[6][64],\n                                 const int dir[6], uint8_t *st[6],\n                                 int zigzag_last_index[6])\n{\n    int score = 0;\n    int i, n;\n    int8_t *const qscale_table = s->current_picture.qscale_table;\n\n    memcpy(zigzag_last_index, s->block_last_index, sizeof(int) * 6);\n\n    for (n = 0; n < 6; n++) {\n        int16_t *ac_val, *ac_val1;\n\n        score -= get_block_rate(s, block[n], s->block_last_index[n],\n                                s->intra_scantable.permutated);\n\n        ac_val  = s->ac_val[0][0] + s->block_index[n] * 16;\n        ac_val1 = ac_val;\n        if (dir[n]) {\n            const int xy = s->mb_x + s->mb_y * s->mb_stride - s->mb_stride;\n            /* top prediction */\n            ac_val -= s->block_wrap[n] * 16;\n            if (s->mb_y == 0 || s->qscale == qscale_table[xy] || n == 2 || n == 3) {\n                /* same qscale */\n                for (i = 1; i < 8; i++) {\n                    const int level = block[n][s->idsp.idct_permutation[i]];\n                    block[n][s->idsp.idct_permutation[i]] = level - ac_val[i + 8];\n                    ac_val1[i]     = block[n][s->idsp.idct_permutation[i << 3]];\n                    ac_val1[i + 8] = level;\n                }\n            } else {\n                /* different qscale, we must rescale */\n                for (i = 1; i < 8; i++) {\n                    const int level = block[n][s->idsp.idct_permutation[i]];\n                    block[n][s->idsp.idct_permutation[i]] = level - ROUNDED_DIV(ac_val[i + 8] * qscale_table[xy], s->qscale);\n                    ac_val1[i]     = block[n][s->idsp.idct_permutation[i << 3]];\n                    ac_val1[i + 8] = level;\n                }\n            }\n            st[n] = s->intra_h_scantable.permutated;\n        } else {\n            const int xy = s->mb_x - 1 + s->mb_y * s->mb_stride;\n            /* left prediction */\n            ac_val -= 16;\n            if (s->mb_x == 0 || s->qscale == qscale_table[xy] || n == 1 || n == 3) {\n                /* same qscale */\n                for (i = 1; i < 8; i++) {\n                    const int level = block[n][s->idsp.idct_permutation[i << 3]];\n                    block[n][s->idsp.idct_permutation[i << 3]] = level - ac_val[i];\n                    ac_val1[i]     = level;\n                    ac_val1[i + 8] = block[n][s->idsp.idct_permutation[i]];\n                }\n            } else {\n                /* different qscale, we must rescale */\n                for (i = 1; i < 8; i++) {\n                    const int level = block[n][s->idsp.idct_permutation[i << 3]];\n                    block[n][s->idsp.idct_permutation[i << 3]] = level - ROUNDED_DIV(ac_val[i] * qscale_table[xy], s->qscale);\n                    ac_val1[i]     = level;\n                    ac_val1[i + 8] = block[n][s->idsp.idct_permutation[i]];\n                }\n            }\n            st[n] = s->intra_v_scantable.permutated;\n        }\n\n        for (i = 63; i > 0; i--)  // FIXME optimize\n            if (block[n][st[n][i]])\n                break;\n        s->block_last_index[n] = i;\n\n        score += get_block_rate(s, block[n], s->block_last_index[n], st[n]);\n    }\n\n    if (score < 0) {\n        return 1;\n    } else {\n        restore_ac_coeffs(s, block, dir, st, zigzag_last_index);\n        return 0;\n    }\n}\n\n/**\n * modify mb_type & qscale so that encoding is actually possible in mpeg4\n */\nvoid ff_clean_mpeg4_qscales(MpegEncContext *s)\n{\n    int i;\n    int8_t *const qscale_table = s->current_picture.qscale_table;\n\n    ff_clean_h263_qscales(s);\n\n    if (s->pict_type == AV_PICTURE_TYPE_B) {\n        int odd = 0;\n        /* ok, come on, this isn't funny anymore, there's more code for\n         * handling this mpeg4 mess than for the actual adaptive quantization */\n\n        for (i = 0; i < s->mb_num; i++) {\n            int mb_xy = s->mb_index2xy[i];\n            odd += qscale_table[mb_xy] & 1;\n        }\n\n        if (2 * odd > s->mb_num)\n            odd = 1;\n        else\n            odd = 0;\n\n        for (i = 0; i < s->mb_num; i++) {\n            int mb_xy = s->mb_index2xy[i];\n            if ((qscale_table[mb_xy] & 1) != odd)\n                qscale_table[mb_xy]++;\n            if (qscale_table[mb_xy] > 31)\n                qscale_table[mb_xy] = 31;\n        }\n\n        for (i = 1; i < s->mb_num; i++) {\n            int mb_xy = s->mb_index2xy[i];\n            if (qscale_table[mb_xy] != qscale_table[s->mb_index2xy[i - 1]] &&\n                (s->mb_type[mb_xy] & CANDIDATE_MB_TYPE_DIRECT)) {\n                s->mb_type[mb_xy] |= CANDIDATE_MB_TYPE_BIDIR;\n            }\n        }\n    }\n}\n\n/**\n * Encode the dc value.\n * @param n block index (0-3 are luma, 4-5 are chroma)\n */\nstatic inline void mpeg4_encode_dc(PutBitContext *s, int level, int n)\n{\n#if 1\n    /* DC will overflow if level is outside the [-255,255] range. */\n    level += 256;\n    if (n < 4) {\n        /* luminance */\n        put_bits(s, uni_DCtab_lum_len[level], uni_DCtab_lum_bits[level]);\n    } else {\n        /* chrominance */\n        put_bits(s, uni_DCtab_chrom_len[level], uni_DCtab_chrom_bits[level]);\n    }\n#else\n    int size, v;\n    /* find number of bits */\n    size = 0;\n    v    = abs(level);\n    while (v) {\n        v >>= 1;\n        size++;\n    }\n\n    if (n < 4) {\n        /* luminance */\n        put_bits(s, ff_mpeg4_DCtab_lum[size][1], ff_mpeg4_DCtab_lum[size][0]);\n    } else {\n        /* chrominance */\n        put_bits(s, ff_mpeg4_DCtab_chrom[size][1], ff_mpeg4_DCtab_chrom[size][0]);\n    }\n\n    /* encode remaining bits */\n    if (size > 0) {\n        if (level < 0)\n            level = (-level) ^ ((1 << size) - 1);\n        put_bits(s, size, level);\n        if (size > 8)\n            put_bits(s, 1, 1);\n    }\n#endif\n}\n\nstatic inline int mpeg4_get_dc_length(int level, int n)\n{\n    if (n < 4)\n        return uni_DCtab_lum_len[level + 256];\n    else\n        return uni_DCtab_chrom_len[level + 256];\n}\n\n/**\n * Encode an 8x8 block.\n * @param n block index (0-3 are luma, 4-5 are chroma)\n */\nstatic inline void mpeg4_encode_block(MpegEncContext *s,\n                                      int16_t *block, int n, int intra_dc,\n                                      uint8_t *scan_table, PutBitContext *dc_pb,\n                                      PutBitContext *ac_pb)\n{\n    int i, last_non_zero;\n    uint32_t *bits_tab;\n    uint8_t *len_tab;\n    const int last_index = s->block_last_index[n];\n\n    if (s->mb_intra) {  // Note gcc (3.2.1 at least) will optimize this away\n        /* mpeg4 based DC predictor */\n        mpeg4_encode_dc(dc_pb, intra_dc, n);\n        if (last_index < 1)\n            return;\n        i = 1;\n        bits_tab = uni_mpeg4_intra_rl_bits;\n        len_tab  = uni_mpeg4_intra_rl_len;\n    } else {\n        if (last_index < 0)\n            return;\n        i = 0;\n        bits_tab = uni_mpeg4_inter_rl_bits;\n        len_tab  = uni_mpeg4_inter_rl_len;\n    }\n\n    /* AC coefs */\n    last_non_zero = i - 1;\n    for (; i < last_index; i++) {\n        int level = block[scan_table[i]];\n        if (level) {\n            int run = i - last_non_zero - 1;\n            level += 64;\n            if ((level & (~127)) == 0) {\n                const int index = UNI_MPEG4_ENC_INDEX(0, run, level);\n                put_bits(ac_pb, len_tab[index], bits_tab[index]);\n            } else {  // ESC3\n                put_bits(ac_pb,\n                         7 + 2 + 1 + 6 + 1 + 12 + 1,\n                         (3 << 23) + (3 << 21) + (0 << 20) + (run << 14) +\n                         (1 << 13) + (((level - 64) & 0xfff) << 1) + 1);\n            }\n            last_non_zero = i;\n        }\n    }\n    /* if (i <= last_index) */ {\n        int level = block[scan_table[i]];\n        int run   = i - last_non_zero - 1;\n        level += 64;\n        if ((level & (~127)) == 0) {\n            const int index = UNI_MPEG4_ENC_INDEX(1, run, level);\n            put_bits(ac_pb, len_tab[index], bits_tab[index]);\n        } else {  // ESC3\n            put_bits(ac_pb,\n                     7 + 2 + 1 + 6 + 1 + 12 + 1,\n                     (3 << 23) + (3 << 21) + (1 << 20) + (run << 14) +\n                     (1 << 13) + (((level - 64) & 0xfff) << 1) + 1);\n        }\n    }\n}\n\nstatic int mpeg4_get_block_length(MpegEncContext *s,\n                                  int16_t *block, int n,\n                                  int intra_dc, uint8_t *scan_table)\n{\n    int i, last_non_zero;\n    uint8_t *len_tab;\n    const int last_index = s->block_last_index[n];\n    int len = 0;\n\n    if (s->mb_intra) {  // Note gcc (3.2.1 at least) will optimize this away\n        /* mpeg4 based DC predictor */\n        len += mpeg4_get_dc_length(intra_dc, n);\n        if (last_index < 1)\n            return len;\n        i = 1;\n        len_tab = uni_mpeg4_intra_rl_len;\n    } else {\n        if (last_index < 0)\n            return 0;\n        i = 0;\n        len_tab = uni_mpeg4_inter_rl_len;\n    }\n\n    /* AC coefs */\n    last_non_zero = i - 1;\n    for (; i < last_index; i++) {\n        int level = block[scan_table[i]];\n        if (level) {\n            int run = i - last_non_zero - 1;\n            level += 64;\n            if ((level & (~127)) == 0) {\n                const int index = UNI_MPEG4_ENC_INDEX(0, run, level);\n                len += len_tab[index];\n            } else {  // ESC3\n                len += 7 + 2 + 1 + 6 + 1 + 12 + 1;\n            }\n            last_non_zero = i;\n        }\n    }\n    /* if (i <= last_index) */ {\n        int level = block[scan_table[i]];\n        int run   = i - last_non_zero - 1;\n        level += 64;\n        if ((level & (~127)) == 0) {\n            const int index = UNI_MPEG4_ENC_INDEX(1, run, level);\n            len += len_tab[index];\n        } else {  // ESC3\n            len += 7 + 2 + 1 + 6 + 1 + 12 + 1;\n        }\n    }\n\n    return len;\n}\n\nstatic inline void mpeg4_encode_blocks(MpegEncContext *s, int16_t block[6][64],\n                                       int intra_dc[6], uint8_t **scan_table,\n                                       PutBitContext *dc_pb,\n                                       PutBitContext *ac_pb)\n{\n    int i;\n\n    if (scan_table) {\n        if (s->avctx->flags2 & AV_CODEC_FLAG2_NO_OUTPUT) {\n            for (i = 0; i < 6; i++)\n                skip_put_bits(&s->pb,\n                              mpeg4_get_block_length(s, block[i], i,\n                                                     intra_dc[i], scan_table[i]));\n        } else {\n            /* encode each block */\n            for (i = 0; i < 6; i++)\n                mpeg4_encode_block(s, block[i], i,\n                                   intra_dc[i], scan_table[i], dc_pb, ac_pb);\n        }\n    } else {\n        if (s->avctx->flags2 & AV_CODEC_FLAG2_NO_OUTPUT) {\n            for (i = 0; i < 6; i++)\n                skip_put_bits(&s->pb,\n                              mpeg4_get_block_length(s, block[i], i, 0,\n                                                     s->intra_scantable.permutated));\n        } else {\n            /* encode each block */\n            for (i = 0; i < 6; i++)\n                mpeg4_encode_block(s, block[i], i, 0,\n                                   s->intra_scantable.permutated, dc_pb, ac_pb);\n        }\n    }\n}\n\nstatic inline int get_b_cbp(MpegEncContext *s, int16_t block[6][64],\n                            int motion_x, int motion_y, int mb_type)\n{\n    int cbp = 0, i;\n\n    if (s->mpv_flags & FF_MPV_FLAG_CBP_RD) {\n        int score        = 0;\n        const int lambda = s->lambda2 >> (FF_LAMBDA_SHIFT - 6);\n\n        for (i = 0; i < 6; i++) {\n            if (s->coded_score[i] < 0) {\n                score += s->coded_score[i];\n                cbp   |= 1 << (5 - i);\n            }\n        }\n\n        if (cbp) {\n            int zero_score = -6;\n            if ((motion_x | motion_y | s->dquant | mb_type) == 0)\n                zero_score -= 4;  // 2 * MV + mb_type + cbp bit\n\n            zero_score *= lambda;\n            if (zero_score <= score)\n                cbp = 0;\n        }\n\n        for (i = 0; i < 6; i++) {\n            if (s->block_last_index[i] >= 0 && ((cbp >> (5 - i)) & 1) == 0) {\n                s->block_last_index[i] = -1;\n                s->bdsp.clear_block(s->block[i]);\n            }\n        }\n    } else {\n        for (i = 0; i < 6; i++) {\n            if (s->block_last_index[i] >= 0)\n                cbp |= 1 << (5 - i);\n        }\n    }\n    return cbp;\n}\n\n// FIXME this is duplicated to h263.c\nstatic const int dquant_code[5] = { 1, 0, 9, 2, 3 };\n\nvoid ff_mpeg4_encode_mb(MpegEncContext *s, int16_t block[6][64],\n                        int motion_x, int motion_y)\n{\n    int cbpc, cbpy, pred_x, pred_y;\n    PutBitContext *const pb2    = s->data_partitioning ? &s->pb2 : &s->pb;\n    PutBitContext *const tex_pb = s->data_partitioning && s->pict_type != AV_PICTURE_TYPE_B ? &s->tex_pb : &s->pb;\n    PutBitContext *const dc_pb  = s->data_partitioning && s->pict_type != AV_PICTURE_TYPE_I ? &s->pb2 : &s->pb;\n    const int interleaved_stats = (s->avctx->flags & AV_CODEC_FLAG_PASS1) && !s->data_partitioning ? 1 : 0;\n\n    if (!s->mb_intra) {\n        int i, cbp;\n\n        if (s->pict_type == AV_PICTURE_TYPE_B) {\n            /* convert from mv_dir to type */\n            static const int mb_type_table[8] = { -1, 3, 2, 1, -1, -1, -1, 0 };\n            int mb_type = mb_type_table[s->mv_dir];\n\n            if (s->mb_x == 0) {\n                for (i = 0; i < 2; i++)\n                    s->last_mv[i][0][0] =\n                    s->last_mv[i][0][1] =\n                    s->last_mv[i][1][0] =\n                    s->last_mv[i][1][1] = 0;\n            }\n\n            av_assert2(s->dquant >= -2 && s->dquant <= 2);\n            av_assert2((s->dquant & 1) == 0);\n            av_assert2(mb_type >= 0);\n\n            /* nothing to do if this MB was skipped in the next P Frame */\n            if (s->next_picture.mbskip_table[s->mb_y * s->mb_stride + s->mb_x]) {  // FIXME avoid DCT & ...\n                s->skip_count++;\n                s->mv[0][0][0] =\n                s->mv[0][0][1] =\n                s->mv[1][0][0] =\n                s->mv[1][0][1] = 0;\n                s->mv_dir  = MV_DIR_FORWARD;  // doesn't matter\n                s->qscale -= s->dquant;\n//                s->mb_skipped = 1;\n\n                return;\n            }\n\n            cbp = get_b_cbp(s, block, motion_x, motion_y, mb_type);\n\n            if ((cbp | motion_x | motion_y | mb_type) == 0) {\n                /* direct MB with MV={0,0} */\n                av_assert2(s->dquant == 0);\n\n                put_bits(&s->pb, 1, 1); /* mb not coded modb1=1 */\n\n                if (interleaved_stats) {\n                    s->misc_bits++;\n                    s->last_bits++;\n                }\n                s->skip_count++;\n                return;\n            }\n\n            put_bits(&s->pb, 1, 0);            /* mb coded modb1=0 */\n            put_bits(&s->pb, 1, cbp ? 0 : 1);  /* modb2 */ // FIXME merge\n            put_bits(&s->pb, mb_type + 1, 1);  // this table is so simple that we don't need it :)\n            if (cbp)\n                put_bits(&s->pb, 6, cbp);\n\n            if (cbp && mb_type) {\n                if (s->dquant)\n                    put_bits(&s->pb, 2, (s->dquant >> 2) + 3);\n                else\n                    put_bits(&s->pb, 1, 0);\n            } else\n                s->qscale -= s->dquant;\n\n            if (!s->progressive_sequence) {\n                if (cbp)\n                    put_bits(&s->pb, 1, s->interlaced_dct);\n                if (mb_type)                  // not direct mode\n                    put_bits(&s->pb, 1, s->mv_type == MV_TYPE_FIELD);\n            }\n\n            if (interleaved_stats)\n                s->misc_bits += get_bits_diff(s);\n\n            if (!mb_type) {\n                av_assert2(s->mv_dir & MV_DIRECT);\n                ff_h263_encode_motion_vector(s, motion_x, motion_y, 1);\n                s->b_count++;\n                s->f_count++;\n            } else {\n                av_assert2(mb_type > 0 && mb_type < 4);\n                if (s->mv_type != MV_TYPE_FIELD) {\n                    if (s->mv_dir & MV_DIR_FORWARD) {\n                        ff_h263_encode_motion_vector(s,\n                                                     s->mv[0][0][0] - s->last_mv[0][0][0],\n                                                     s->mv[0][0][1] - s->last_mv[0][0][1],\n                                                     s->f_code);\n                        s->last_mv[0][0][0] =\n                        s->last_mv[0][1][0] = s->mv[0][0][0];\n                        s->last_mv[0][0][1] =\n                        s->last_mv[0][1][1] = s->mv[0][0][1];\n                        s->f_count++;\n                    }\n                    if (s->mv_dir & MV_DIR_BACKWARD) {\n                        ff_h263_encode_motion_vector(s,\n                                                     s->mv[1][0][0] - s->last_mv[1][0][0],\n                                                     s->mv[1][0][1] - s->last_mv[1][0][1],\n                                                     s->b_code);\n                        s->last_mv[1][0][0] =\n                        s->last_mv[1][1][0] = s->mv[1][0][0];\n                        s->last_mv[1][0][1] =\n                        s->last_mv[1][1][1] = s->mv[1][0][1];\n                        s->b_count++;\n                    }\n                } else {\n                    if (s->mv_dir & MV_DIR_FORWARD) {\n                        put_bits(&s->pb, 1, s->field_select[0][0]);\n                        put_bits(&s->pb, 1, s->field_select[0][1]);\n                    }\n                    if (s->mv_dir & MV_DIR_BACKWARD) {\n                        put_bits(&s->pb, 1, s->field_select[1][0]);\n                        put_bits(&s->pb, 1, s->field_select[1][1]);\n                    }\n                    if (s->mv_dir & MV_DIR_FORWARD) {\n                        for (i = 0; i < 2; i++) {\n                            ff_h263_encode_motion_vector(s,\n                                                         s->mv[0][i][0] - s->last_mv[0][i][0],\n                                                         s->mv[0][i][1] - s->last_mv[0][i][1] / 2,\n                                                         s->f_code);\n                            s->last_mv[0][i][0] = s->mv[0][i][0];\n                            s->last_mv[0][i][1] = s->mv[0][i][1] * 2;\n                        }\n                        s->f_count++;\n                    }\n                    if (s->mv_dir & MV_DIR_BACKWARD) {\n                        for (i = 0; i < 2; i++) {\n                            ff_h263_encode_motion_vector(s,\n                                                         s->mv[1][i][0] - s->last_mv[1][i][0],\n                                                         s->mv[1][i][1] - s->last_mv[1][i][1] / 2,\n                                                         s->b_code);\n                            s->last_mv[1][i][0] = s->mv[1][i][0];\n                            s->last_mv[1][i][1] = s->mv[1][i][1] * 2;\n                        }\n                        s->b_count++;\n                    }\n                }\n            }\n\n            if (interleaved_stats)\n                s->mv_bits += get_bits_diff(s);\n\n            mpeg4_encode_blocks(s, block, NULL, NULL, NULL, &s->pb);\n\n            if (interleaved_stats)\n                s->p_tex_bits += get_bits_diff(s);\n        } else { /* s->pict_type==AV_PICTURE_TYPE_B */\n            cbp = get_p_cbp(s, block, motion_x, motion_y);\n\n            if ((cbp | motion_x | motion_y | s->dquant) == 0 &&\n                s->mv_type == MV_TYPE_16X16) {\n                /* check if the B frames can skip it too, as we must skip it\n                 * if we skip here why didn't they just compress\n                 * the skip-mb bits instead of reusing them ?! */\n                if (s->max_b_frames > 0) {\n                    int i;\n                    int x, y, offset;\n                    uint8_t *p_pic;\n\n                    x = s->mb_x * 16;\n                    y = s->mb_y * 16;\n\n                    offset = x + y * s->linesize;\n                    p_pic  = s->new_picture.f->data[0] + offset;\n\n                    s->mb_skipped = 1;\n                    for (i = 0; i < s->max_b_frames; i++) {\n                        uint8_t *b_pic;\n                        int diff;\n                        Picture *pic = s->reordered_input_picture[i + 1];\n\n                        if (!pic || pic->f->pict_type != AV_PICTURE_TYPE_B)\n                            break;\n\n                        b_pic = pic->f->data[0] + offset;\n                        if (!pic->shared)\n                            b_pic += INPLACE_OFFSET;\n\n                        if (x + 16 > s->width || y + 16 > s->height) {\n                            int x1, y1;\n                            int xe = FFMIN(16, s->width - x);\n                            int ye = FFMIN(16, s->height - y);\n                            diff = 0;\n                            for (y1 = 0; y1 < ye; y1++) {\n                                for (x1 = 0; x1 < xe; x1++) {\n                                    diff += FFABS(p_pic[x1 + y1 * s->linesize] - b_pic[x1 + y1 * s->linesize]);\n                                }\n                            }\n                            diff = diff * 256 / (xe * ye);\n                        } else {\n                            diff = s->mecc.sad[0](NULL, p_pic, b_pic, s->linesize, 16);\n                        }\n                        if (diff > s->qscale * 70) {  // FIXME check that 70 is optimal\n                            s->mb_skipped = 0;\n                            break;\n                        }\n                    }\n                } else\n                    s->mb_skipped = 1;\n\n                if (s->mb_skipped == 1) {\n                    /* skip macroblock */\n                    put_bits(&s->pb, 1, 1);\n\n                    if (interleaved_stats) {\n                        s->misc_bits++;\n                        s->last_bits++;\n                    }\n                    s->skip_count++;\n\n                    return;\n                }\n            }\n\n            put_bits(&s->pb, 1, 0);     /* mb coded */\n            cbpc  = cbp & 3;\n            cbpy  = cbp >> 2;\n            cbpy ^= 0xf;\n            if (s->mv_type == MV_TYPE_16X16) {\n                if (s->dquant)\n                    cbpc += 8;\n                put_bits(&s->pb,\n                         ff_h263_inter_MCBPC_bits[cbpc],\n                         ff_h263_inter_MCBPC_code[cbpc]);\n\n                put_bits(pb2, ff_h263_cbpy_tab[cbpy][1], ff_h263_cbpy_tab[cbpy][0]);\n                if (s->dquant)\n                    put_bits(pb2, 2, dquant_code[s->dquant + 2]);\n\n                if (!s->progressive_sequence) {\n                    if (cbp)\n                        put_bits(pb2, 1, s->interlaced_dct);\n                    put_bits(pb2, 1, 0);\n                }\n\n                if (interleaved_stats)\n                    s->misc_bits += get_bits_diff(s);\n\n                /* motion vectors: 16x16 mode */\n                ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n\n                ff_h263_encode_motion_vector(s,\n                                             motion_x - pred_x,\n                                             motion_y - pred_y,\n                                             s->f_code);\n            } else if (s->mv_type == MV_TYPE_FIELD) {\n                if (s->dquant)\n                    cbpc += 8;\n                put_bits(&s->pb,\n                         ff_h263_inter_MCBPC_bits[cbpc],\n                         ff_h263_inter_MCBPC_code[cbpc]);\n\n                put_bits(pb2, ff_h263_cbpy_tab[cbpy][1], ff_h263_cbpy_tab[cbpy][0]);\n                if (s->dquant)\n                    put_bits(pb2, 2, dquant_code[s->dquant + 2]);\n\n                av_assert2(!s->progressive_sequence);\n                if (cbp)\n                    put_bits(pb2, 1, s->interlaced_dct);\n                put_bits(pb2, 1, 1);\n\n                if (interleaved_stats)\n                    s->misc_bits += get_bits_diff(s);\n\n                /* motion vectors: 16x8 interlaced mode */\n                ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n                pred_y /= 2;\n\n                put_bits(&s->pb, 1, s->field_select[0][0]);\n                put_bits(&s->pb, 1, s->field_select[0][1]);\n\n                ff_h263_encode_motion_vector(s,\n                                             s->mv[0][0][0] - pred_x,\n                                             s->mv[0][0][1] - pred_y,\n                                             s->f_code);\n                ff_h263_encode_motion_vector(s,\n                                             s->mv[0][1][0] - pred_x,\n                                             s->mv[0][1][1] - pred_y,\n                                             s->f_code);\n            } else {\n                av_assert2(s->mv_type == MV_TYPE_8X8);\n                put_bits(&s->pb,\n                         ff_h263_inter_MCBPC_bits[cbpc + 16],\n                         ff_h263_inter_MCBPC_code[cbpc + 16]);\n                put_bits(pb2, ff_h263_cbpy_tab[cbpy][1], ff_h263_cbpy_tab[cbpy][0]);\n\n                if (!s->progressive_sequence && cbp)\n                    put_bits(pb2, 1, s->interlaced_dct);\n\n                if (interleaved_stats)\n                    s->misc_bits += get_bits_diff(s);\n\n                for (i = 0; i < 4; i++) {\n                    /* motion vectors: 8x8 mode*/\n                    ff_h263_pred_motion(s, i, 0, &pred_x, &pred_y);\n\n                    ff_h263_encode_motion_vector(s,\n                                                 s->current_picture.motion_val[0][s->block_index[i]][0] - pred_x,\n                                                 s->current_picture.motion_val[0][s->block_index[i]][1] - pred_y,\n                                                 s->f_code);\n                }\n            }\n\n            if (interleaved_stats)\n                s->mv_bits += get_bits_diff(s);\n\n            mpeg4_encode_blocks(s, block, NULL, NULL, NULL, tex_pb);\n\n            if (interleaved_stats)\n                s->p_tex_bits += get_bits_diff(s);\n\n            s->f_count++;\n        }\n    } else {\n        int cbp;\n        int dc_diff[6];  // dc values with the dc prediction subtracted\n        int dir[6];      // prediction direction\n        int zigzag_last_index[6];\n        uint8_t *scan_table[6];\n        int i;\n\n        for (i = 0; i < 6; i++)\n            dc_diff[i] = ff_mpeg4_pred_dc(s, i, block[i][0], &dir[i], 1);\n\n        if (s->avctx->flags & AV_CODEC_FLAG_AC_PRED) {\n            s->ac_pred = decide_ac_pred(s, block, dir, scan_table, zigzag_last_index);\n        } else {\n            for (i = 0; i < 6; i++)\n                scan_table[i] = s->intra_scantable.permutated;\n        }\n\n        /* compute cbp */\n        cbp = 0;\n        for (i = 0; i < 6; i++)\n            if (s->block_last_index[i] >= 1)\n                cbp |= 1 << (5 - i);\n\n        cbpc = cbp & 3;\n        if (s->pict_type == AV_PICTURE_TYPE_I) {\n            if (s->dquant)\n                cbpc += 4;\n            put_bits(&s->pb,\n                     ff_h263_intra_MCBPC_bits[cbpc],\n                     ff_h263_intra_MCBPC_code[cbpc]);\n        } else {\n            if (s->dquant)\n                cbpc += 8;\n            put_bits(&s->pb, 1, 0);     /* mb coded */\n            put_bits(&s->pb,\n                     ff_h263_inter_MCBPC_bits[cbpc + 4],\n                     ff_h263_inter_MCBPC_code[cbpc + 4]);\n        }\n        put_bits(pb2, 1, s->ac_pred);\n        cbpy = cbp >> 2;\n        put_bits(pb2, ff_h263_cbpy_tab[cbpy][1], ff_h263_cbpy_tab[cbpy][0]);\n        if (s->dquant)\n            put_bits(dc_pb, 2, dquant_code[s->dquant + 2]);\n\n        if (!s->progressive_sequence)\n            put_bits(dc_pb, 1, s->interlaced_dct);\n\n        if (interleaved_stats)\n            s->misc_bits += get_bits_diff(s);\n\n        mpeg4_encode_blocks(s, block, dc_diff, scan_table, dc_pb, tex_pb);\n\n        if (interleaved_stats)\n            s->i_tex_bits += get_bits_diff(s);\n        s->i_count++;\n\n        /* restore ac coeffs & last_index stuff\n         * if we messed them up with the prediction */\n        if (s->ac_pred)\n            restore_ac_coeffs(s, block, dir, scan_table, zigzag_last_index);\n    }\n}\n\n/**\n * add mpeg4 stuffing bits (01...1)\n */\nvoid ff_mpeg4_stuffing(PutBitContext *pbc)\n{\n    int length;\n    put_bits(pbc, 1, 0);\n    length = (-put_bits_count(pbc)) & 7;\n    if (length)\n        put_bits(pbc, length, (1 << length) - 1);\n}\n\n/* must be called before writing the header */\nvoid ff_set_mpeg4_time(MpegEncContext *s)\n{\n    if (s->pict_type == AV_PICTURE_TYPE_B) {\n        ff_mpeg4_init_direct_mv(s);\n    } else {\n        s->last_time_base = s->time_base;\n        s->time_base      = FFUDIV(s->time, s->avctx->time_base.den);\n    }\n}\n\nstatic void mpeg4_encode_gop_header(MpegEncContext *s)\n{\n    int64_t hours, minutes, seconds;\n    int64_t time;\n\n    put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, GOP_STARTCODE);\n\n    time = s->current_picture_ptr->f->pts;\n    if (s->reordered_input_picture[1])\n        time = FFMIN(time, s->reordered_input_picture[1]->f->pts);\n    time = time * s->avctx->time_base.num;\n    s->last_time_base = FFUDIV(time, s->avctx->time_base.den);\n\n    seconds = FFUDIV(time, s->avctx->time_base.den);\n    minutes = FFUDIV(seconds, 60); seconds = FFUMOD(seconds, 60);\n    hours   = FFUDIV(minutes, 60); minutes = FFUMOD(minutes, 60);\n    hours   = FFUMOD(hours  , 24);\n\n    put_bits(&s->pb, 5, hours);\n    put_bits(&s->pb, 6, minutes);\n    put_bits(&s->pb, 1, 1);\n    put_bits(&s->pb, 6, seconds);\n\n    put_bits(&s->pb, 1, !!(s->avctx->flags & AV_CODEC_FLAG_CLOSED_GOP));\n    put_bits(&s->pb, 1, 0);  // broken link == NO\n\n    ff_mpeg4_stuffing(&s->pb);\n}\n\nstatic void mpeg4_encode_visual_object_header(MpegEncContext *s)\n{\n    int profile_and_level_indication;\n    int vo_ver_id;\n\n    if (s->avctx->profile != FF_PROFILE_UNKNOWN) {\n        profile_and_level_indication = s->avctx->profile << 4;\n    } else if (s->max_b_frames || s->quarter_sample) {\n        profile_and_level_indication = 0xF0;  // adv simple\n    } else {\n        profile_and_level_indication = 0x00;  // simple\n    }\n\n    if (s->avctx->level != FF_LEVEL_UNKNOWN)\n        profile_and_level_indication |= s->avctx->level;\n    else\n        profile_and_level_indication |= 1;   // level 1\n\n    if (profile_and_level_indication >> 4 == 0xF)\n        vo_ver_id = 5;\n    else\n        vo_ver_id = 1;\n\n    // FIXME levels\n\n    put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, VOS_STARTCODE);\n\n    put_bits(&s->pb, 8, profile_and_level_indication);\n\n    put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, VISUAL_OBJ_STARTCODE);\n\n    put_bits(&s->pb, 1, 1);\n    put_bits(&s->pb, 4, vo_ver_id);\n    put_bits(&s->pb, 3, 1);     // priority\n\n    put_bits(&s->pb, 4, 1);     // visual obj type== video obj\n\n    put_bits(&s->pb, 1, 0);     // video signal type == no clue // FIXME\n\n    ff_mpeg4_stuffing(&s->pb);\n}\n\nstatic void mpeg4_encode_vol_header(MpegEncContext *s,\n                                    int vo_number,\n                                    int vol_number)\n{\n    int vo_ver_id;\n\n    if (!CONFIG_MPEG4_ENCODER)\n        return;\n\n    if (s->max_b_frames || s->quarter_sample) {\n        vo_ver_id  = 5;\n        s->vo_type = ADV_SIMPLE_VO_TYPE;\n    } else {\n        vo_ver_id  = 1;\n        s->vo_type = SIMPLE_VO_TYPE;\n    }\n\n    put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, 0x100 + vo_number);        /* video obj */\n    put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, 0x120 + vol_number);       /* video obj layer */\n\n    put_bits(&s->pb, 1, 0);             /* random access vol */\n    put_bits(&s->pb, 8, s->vo_type);    /* video obj type indication */\n    if (s->workaround_bugs & FF_BUG_MS) {\n        put_bits(&s->pb, 1, 0);         /* is obj layer id= no */\n    } else {\n        put_bits(&s->pb, 1, 1);         /* is obj layer id= yes */\n        put_bits(&s->pb, 4, vo_ver_id); /* is obj layer ver id */\n        put_bits(&s->pb, 3, 1);         /* is obj layer priority */\n    }\n\n    s->aspect_ratio_info = ff_h263_aspect_to_info(s->avctx->sample_aspect_ratio);\n\n    put_bits(&s->pb, 4, s->aspect_ratio_info); /* aspect ratio info */\n    if (s->aspect_ratio_info == FF_ASPECT_EXTENDED) {\n        av_reduce(&s->avctx->sample_aspect_ratio.num, &s->avctx->sample_aspect_ratio.den,\n                   s->avctx->sample_aspect_ratio.num,  s->avctx->sample_aspect_ratio.den, 255);\n        put_bits(&s->pb, 8, s->avctx->sample_aspect_ratio.num);\n        put_bits(&s->pb, 8, s->avctx->sample_aspect_ratio.den);\n    }\n\n    if (s->workaround_bugs & FF_BUG_MS) {\n        put_bits(&s->pb, 1, 0);         /* vol control parameters= no @@@ */\n    } else {\n        put_bits(&s->pb, 1, 1);         /* vol control parameters= yes */\n        put_bits(&s->pb, 2, 1);         /* chroma format YUV 420/YV12 */\n        put_bits(&s->pb, 1, s->low_delay);\n        put_bits(&s->pb, 1, 0);         /* vbv parameters= no */\n    }\n\n    put_bits(&s->pb, 2, RECT_SHAPE);    /* vol shape= rectangle */\n    put_bits(&s->pb, 1, 1);             /* marker bit */\n\n    put_bits(&s->pb, 16, s->avctx->time_base.den);\n    if (s->time_increment_bits < 1)\n        s->time_increment_bits = 1;\n    put_bits(&s->pb, 1, 1);             /* marker bit */\n    put_bits(&s->pb, 1, 0);             /* fixed vop rate=no */\n    put_bits(&s->pb, 1, 1);             /* marker bit */\n    put_bits(&s->pb, 13, s->width);     /* vol width */\n    put_bits(&s->pb, 1, 1);             /* marker bit */\n    put_bits(&s->pb, 13, s->height);    /* vol height */\n    put_bits(&s->pb, 1, 1);             /* marker bit */\n    put_bits(&s->pb, 1, s->progressive_sequence ? 0 : 1);\n    put_bits(&s->pb, 1, 1);             /* obmc disable */\n    if (vo_ver_id == 1)\n        put_bits(&s->pb, 1, 0);       /* sprite enable */\n    else\n        put_bits(&s->pb, 2, 0);       /* sprite enable */\n\n    put_bits(&s->pb, 1, 0);             /* not 8 bit == false */\n    put_bits(&s->pb, 1, s->mpeg_quant); /* quant type= (0=h263 style)*/\n\n    if (s->mpeg_quant) {\n        ff_write_quant_matrix(&s->pb, s->avctx->intra_matrix);\n        ff_write_quant_matrix(&s->pb, s->avctx->inter_matrix);\n    }\n\n    if (vo_ver_id != 1)\n        put_bits(&s->pb, 1, s->quarter_sample);\n    put_bits(&s->pb, 1, 1);             /* complexity estimation disable */\n    put_bits(&s->pb, 1, s->rtp_mode ? 0 : 1); /* resync marker disable */\n    put_bits(&s->pb, 1, s->data_partitioning ? 1 : 0);\n    if (s->data_partitioning)\n        put_bits(&s->pb, 1, 0);         /* no rvlc */\n\n    if (vo_ver_id != 1) {\n        put_bits(&s->pb, 1, 0);         /* newpred */\n        put_bits(&s->pb, 1, 0);         /* reduced res vop */\n    }\n    put_bits(&s->pb, 1, 0);             /* scalability */\n\n    ff_mpeg4_stuffing(&s->pb);\n\n    /* user data */\n    if (!(s->avctx->flags & AV_CODEC_FLAG_BITEXACT)) {\n        put_bits(&s->pb, 16, 0);\n        put_bits(&s->pb, 16, 0x1B2);    /* user_data */\n        avpriv_put_string(&s->pb, LIBAVCODEC_IDENT, 0);\n    }\n}\n\n/* write mpeg4 VOP header */\nint ff_mpeg4_encode_picture_header(MpegEncContext *s, int picture_number)\n{\n    int time_incr;\n    int time_div, time_mod;\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n        if (!(s->avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER)) {\n            if (s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT)  // HACK, the reference sw is buggy\n                mpeg4_encode_visual_object_header(s);\n            if (s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT || picture_number == 0)  // HACK, the reference sw is buggy\n                mpeg4_encode_vol_header(s, 0, 0);\n        }\n        if (!(s->workaround_bugs & FF_BUG_MS))\n            mpeg4_encode_gop_header(s);\n    }\n\n    s->partitioned_frame = s->data_partitioning && s->pict_type != AV_PICTURE_TYPE_B;\n\n    put_bits(&s->pb, 16, 0);                /* vop header */\n    put_bits(&s->pb, 16, VOP_STARTCODE);    /* vop header */\n    put_bits(&s->pb, 2, s->pict_type - 1);  /* pict type: I = 0 , P = 1 */\n\n    time_div  = FFUDIV(s->time, s->avctx->time_base.den);\n    time_mod  = FFUMOD(s->time, s->avctx->time_base.den);\n    time_incr = time_div - s->last_time_base;\n    av_assert0(time_incr >= 0);\n\n    // This limits the frame duration to max 1 hour\n    if (time_incr > 3600) {\n        av_log(s->avctx, AV_LOG_ERROR, \"time_incr %d too large\\n\", time_incr);\n        return AVERROR(EINVAL);\n    }\n    while (time_incr--)\n        put_bits(&s->pb, 1, 1);\n\n    put_bits(&s->pb, 1, 0);\n\n    put_bits(&s->pb, 1, 1);                             /* marker */\n    put_bits(&s->pb, s->time_increment_bits, time_mod); /* time increment */\n    put_bits(&s->pb, 1, 1);                             /* marker */\n    put_bits(&s->pb, 1, 1);                             /* vop coded */\n    if (s->pict_type == AV_PICTURE_TYPE_P) {\n        put_bits(&s->pb, 1, s->no_rounding);    /* rounding type */\n    }\n    put_bits(&s->pb, 3, 0);     /* intra dc VLC threshold */\n    if (!s->progressive_sequence) {\n        put_bits(&s->pb, 1, s->current_picture_ptr->f->top_field_first);\n        put_bits(&s->pb, 1, s->alternate_scan);\n    }\n    // FIXME sprite stuff\n\n    put_bits(&s->pb, 5, s->qscale);\n\n    if (s->pict_type != AV_PICTURE_TYPE_I)\n        put_bits(&s->pb, 3, s->f_code);  /* fcode_for */\n    if (s->pict_type == AV_PICTURE_TYPE_B)\n        put_bits(&s->pb, 3, s->b_code);  /* fcode_back */\n\n    return 0;\n}\n\nstatic av_cold void init_uni_dc_tab(void)\n{\n    int level, uni_code, uni_len;\n\n    for (level = -256; level < 256; level++) {\n        int size, v, l;\n        /* find number of bits */\n        size = 0;\n        v    = abs(level);\n        while (v) {\n            v >>= 1;\n            size++;\n        }\n\n        if (level < 0)\n            l = (-level) ^ ((1 << size) - 1);\n        else\n            l = level;\n\n        /* luminance */\n        uni_code = ff_mpeg4_DCtab_lum[size][0];\n        uni_len  = ff_mpeg4_DCtab_lum[size][1];\n\n        if (size > 0) {\n            uni_code <<= size;\n            uni_code  |= l;\n            uni_len   += size;\n            if (size > 8) {\n                uni_code <<= 1;\n                uni_code  |= 1;\n                uni_len++;\n            }\n        }\n        uni_DCtab_lum_bits[level + 256] = uni_code;\n        uni_DCtab_lum_len[level + 256]  = uni_len;\n\n        /* chrominance */\n        uni_code = ff_mpeg4_DCtab_chrom[size][0];\n        uni_len  = ff_mpeg4_DCtab_chrom[size][1];\n\n        if (size > 0) {\n            uni_code <<= size;\n            uni_code  |= l;\n            uni_len   += size;\n            if (size > 8) {\n                uni_code <<= 1;\n                uni_code  |= 1;\n                uni_len++;\n            }\n        }\n        uni_DCtab_chrom_bits[level + 256] = uni_code;\n        uni_DCtab_chrom_len[level + 256]  = uni_len;\n    }\n}\n\nstatic av_cold void init_uni_mpeg4_rl_tab(RLTable *rl, uint32_t *bits_tab,\n                                          uint8_t *len_tab)\n{\n    int slevel, run, last;\n\n    av_assert0(MAX_LEVEL >= 64);\n    av_assert0(MAX_RUN >= 63);\n\n    for (slevel = -64; slevel < 64; slevel++) {\n        if (slevel == 0)\n            continue;\n        for (run = 0; run < 64; run++) {\n            for (last = 0; last <= 1; last++) {\n                const int index = UNI_MPEG4_ENC_INDEX(last, run, slevel + 64);\n                int level       = slevel < 0 ? -slevel : slevel;\n                int sign        = slevel < 0 ? 1 : 0;\n                int bits, len, code;\n                int level1, run1;\n\n                len_tab[index] = 100;\n\n                /* ESC0 */\n                code = get_rl_index(rl, last, run, level);\n                bits = rl->table_vlc[code][0];\n                len  = rl->table_vlc[code][1];\n                bits = bits * 2 + sign;\n                len++;\n\n                if (code != rl->n && len < len_tab[index]) {\n                    bits_tab[index] = bits;\n                    len_tab[index]  = len;\n                }\n                /* ESC1 */\n                bits = rl->table_vlc[rl->n][0];\n                len  = rl->table_vlc[rl->n][1];\n                bits = bits * 2;\n                len++;                 // esc1\n                level1 = level - rl->max_level[last][run];\n                if (level1 > 0) {\n                    code   = get_rl_index(rl, last, run, level1);\n                    bits <<= rl->table_vlc[code][1];\n                    len   += rl->table_vlc[code][1];\n                    bits  += rl->table_vlc[code][0];\n                    bits   = bits * 2 + sign;\n                    len++;\n\n                    if (code != rl->n && len < len_tab[index]) {\n                        bits_tab[index] = bits;\n                        len_tab[index]  = len;\n                    }\n                }\n                /* ESC2 */\n                bits = rl->table_vlc[rl->n][0];\n                len  = rl->table_vlc[rl->n][1];\n                bits = bits * 4 + 2;\n                len += 2;                 // esc2\n                run1 = run - rl->max_run[last][level] - 1;\n                if (run1 >= 0) {\n                    code   = get_rl_index(rl, last, run1, level);\n                    bits <<= rl->table_vlc[code][1];\n                    len   += rl->table_vlc[code][1];\n                    bits  += rl->table_vlc[code][0];\n                    bits   = bits * 2 + sign;\n                    len++;\n\n                    if (code != rl->n && len < len_tab[index]) {\n                        bits_tab[index] = bits;\n                        len_tab[index]  = len;\n                    }\n                }\n                /* ESC3 */\n                bits = rl->table_vlc[rl->n][0];\n                len  = rl->table_vlc[rl->n][1];\n                bits = bits * 4 + 3;\n                len += 2;                 // esc3\n                bits = bits * 2 + last;\n                len++;\n                bits = bits * 64 + run;\n                len += 6;\n                bits = bits * 2 + 1;\n                len++;                    // marker\n                bits = bits * 4096 + (slevel & 0xfff);\n                len += 12;\n                bits = bits * 2 + 1;\n                len++;                    // marker\n\n                if (len < len_tab[index]) {\n                    bits_tab[index] = bits;\n                    len_tab[index]  = len;\n                }\n            }\n        }\n    }\n}\n\nstatic av_cold int encode_init(AVCodecContext *avctx)\n{\n    MpegEncContext *s = avctx->priv_data;\n    int ret;\n    static int done = 0;\n\n    if (avctx->width >= (1<<13) || avctx->height >= (1<<13)) {\n        av_log(avctx, AV_LOG_ERROR, \"dimensions too large for MPEG-4\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    if ((ret = ff_mpv_encode_init(avctx)) < 0)\n        return ret;\n\n    if (!done) {\n        done = 1;\n\n        init_uni_dc_tab();\n\n        ff_rl_init(&ff_mpeg4_rl_intra, ff_mpeg4_static_rl_table_store[0]);\n\n        init_uni_mpeg4_rl_tab(&ff_mpeg4_rl_intra, uni_mpeg4_intra_rl_bits, uni_mpeg4_intra_rl_len);\n        init_uni_mpeg4_rl_tab(&ff_h263_rl_inter, uni_mpeg4_inter_rl_bits, uni_mpeg4_inter_rl_len);\n    }\n\n    s->min_qcoeff               = -2048;\n    s->max_qcoeff               = 2047;\n    s->intra_ac_vlc_length      = uni_mpeg4_intra_rl_len;\n    s->intra_ac_vlc_last_length = uni_mpeg4_intra_rl_len + 128 * 64;\n    s->inter_ac_vlc_length      = uni_mpeg4_inter_rl_len;\n    s->inter_ac_vlc_last_length = uni_mpeg4_inter_rl_len + 128 * 64;\n    s->luma_dc_vlc_length       = uni_DCtab_lum_len;\n    s->ac_esc_length            = 7 + 2 + 1 + 6 + 1 + 12 + 1;\n    s->y_dc_scale_table         = ff_mpeg4_y_dc_scale_table;\n    s->c_dc_scale_table         = ff_mpeg4_c_dc_scale_table;\n\n    if (s->avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {\n        s->avctx->extradata = av_malloc(1024);\n        init_put_bits(&s->pb, s->avctx->extradata, 1024);\n\n        if (!(s->workaround_bugs & FF_BUG_MS))\n            mpeg4_encode_visual_object_header(s);\n        mpeg4_encode_vol_header(s, 0, 0);\n\n//            ff_mpeg4_stuffing(&s->pb); ?\n        flush_put_bits(&s->pb);\n        s->avctx->extradata_size = (put_bits_count(&s->pb) + 7) >> 3;\n    }\n    return 0;\n}\n\nvoid ff_mpeg4_init_partitions(MpegEncContext *s)\n{\n    uint8_t *start = put_bits_ptr(&s->pb);\n    uint8_t *end   = s->pb.buf_end;\n    int size       = end - start;\n    int pb_size    = (((intptr_t)start + size / 3) & (~3)) - (intptr_t)start;\n    int tex_size   = (size - 2 * pb_size) & (~3);\n\n    set_put_bits_buffer_size(&s->pb, pb_size);\n    init_put_bits(&s->tex_pb, start + pb_size, tex_size);\n    init_put_bits(&s->pb2, start + pb_size + tex_size, pb_size);\n}\n\nvoid ff_mpeg4_merge_partitions(MpegEncContext *s)\n{\n    const int pb2_len    = put_bits_count(&s->pb2);\n    const int tex_pb_len = put_bits_count(&s->tex_pb);\n    const int bits       = put_bits_count(&s->pb);\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n        put_bits(&s->pb, 19, DC_MARKER);\n        s->misc_bits  += 19 + pb2_len + bits - s->last_bits;\n        s->i_tex_bits += tex_pb_len;\n    } else {\n        put_bits(&s->pb, 17, MOTION_MARKER);\n        s->misc_bits  += 17 + pb2_len;\n        s->mv_bits    += bits - s->last_bits;\n        s->p_tex_bits += tex_pb_len;\n    }\n\n    flush_put_bits(&s->pb2);\n    flush_put_bits(&s->tex_pb);\n\n    set_put_bits_buffer_size(&s->pb, s->pb2.buf_end - s->pb.buf);\n    avpriv_copy_bits(&s->pb, s->pb2.buf, pb2_len);\n    avpriv_copy_bits(&s->pb, s->tex_pb.buf, tex_pb_len);\n    s->last_bits = put_bits_count(&s->pb);\n}\n\nvoid ff_mpeg4_encode_video_packet_header(MpegEncContext *s)\n{\n    int mb_num_bits = av_log2(s->mb_num - 1) + 1;\n\n    put_bits(&s->pb, ff_mpeg4_get_video_packet_prefix_length(s), 0);\n    put_bits(&s->pb, 1, 1);\n\n    put_bits(&s->pb, mb_num_bits, s->mb_x + s->mb_y * s->mb_width);\n    put_bits(&s->pb, s->quant_precision, s->qscale);\n    put_bits(&s->pb, 1, 0); /* no HEC */\n}\n\n#define OFFSET(x) offsetof(MpegEncContext, x)\n#define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM\nstatic const AVOption options[] = {\n    { \"data_partitioning\", \"Use data partitioning.\",      OFFSET(data_partitioning), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 1, VE },\n    { \"alternate_scan\",    \"Enable alternate scantable.\", OFFSET(alternate_scan),    AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 1, VE },\n    FF_MPV_COMMON_OPTS\n    { NULL },\n};\n\nstatic const AVClass mpeg4enc_class = {\n    .class_name = \"MPEG4 encoder\",\n    .item_name  = av_default_item_name,\n    .option     = options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVCodec ff_mpeg4_encoder = {\n    .name           = \"mpeg4\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"MPEG-4 part 2\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_MPEG4,\n    .priv_data_size = sizeof(MpegEncContext),\n    .init           = encode_init,\n    .encode2        = ff_mpv_encode_picture,\n    .close          = ff_mpv_encode_end,\n    .pix_fmts       = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE },\n    .capabilities   = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_SLICE_THREADS,\n    .priv_class     = &mpeg4enc_class,\n};\n"], "filenames": ["libavcodec/mpeg4videoenc.c"], "buggy_code_start_loc": [913], "buggy_code_end_loc": [914], "fixing_code_start_loc": [913], "fixing_code_end_loc": [914], "type": "CWE-20", "message": "An improper integer type in the mpeg4_encode_gop_header function in libavcodec/mpeg4videoenc.c in FFmpeg 2.8 and 4.0 may trigger an assertion violation while converting a crafted AVI file to MPEG4, leading to a denial of service.", "other": {"cve": {"id": "CVE-2018-12458", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-15T15:29:00.217", "lastModified": "2021-02-05T21:57:48.243", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An improper integer type in the mpeg4_encode_gop_header function in libavcodec/mpeg4videoenc.c in FFmpeg 2.8 and 4.0 may trigger an assertion violation while converting a crafted AVI file to MPEG4, leading to a denial of service."}, {"lang": "es", "value": "Un tipo de entero incorrecto en la funci\u00f3n mpeg4_encode_gop_header en libavcodec/mpeg4videoenc.c en FFmpeg 2.8 y 4.0 podr\u00eda desencadenar una violaci\u00f3n de aserci\u00f3n al convertir un archivo AVI manipulado a MPEG4, lo que conduce a una denegaci\u00f3n de servicio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:2.8:*:*:*:*:*:*:*", "matchCriteriaId": "DAA8F265-CE4D-46FE-9871-FDD4D6738DAB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "35169F84-5DDB-468A-9DB4-08CC657ABE8B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/FFmpeg/FFmpeg/commit/6bbef938839adc55e8e048bc9cc2e0fafe2064df", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/e1182fac1afba92a4975917823a5f644bee7e6e8", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4249", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/6bbef938839adc55e8e048bc9cc2e0fafe2064df"}}