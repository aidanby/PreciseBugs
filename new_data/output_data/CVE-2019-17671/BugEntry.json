{"buggy_code": ["<?php\n/**\n * Query API: WP_Query class\n *\n * @package WordPress\n * @subpackage Query\n * @since 4.7.0\n */\n\n/**\n * The WordPress Query class.\n *\n * @link https://codex.wordpress.org/Function_Reference/WP_Query Codex page.\n *\n * @since 1.5.0\n * @since 4.5.0 Removed the `$comments_popup` property.\n */\nclass WP_Query {\n\n\t/**\n\t * Query vars set by the user\n\t *\n\t * @since 1.5.0\n\t * @var array\n\t */\n\tpublic $query;\n\n\t/**\n\t * Query vars, after parsing\n\t *\n\t * @since 1.5.0\n\t * @var array\n\t */\n\tpublic $query_vars = array();\n\n\t/**\n\t * Taxonomy query, as passed to get_tax_sql()\n\t *\n\t * @since 3.1.0\n\t * @var object WP_Tax_Query\n\t */\n\tpublic $tax_query;\n\n\t/**\n\t * Metadata query container\n\t *\n\t * @since 3.2.0\n\t * @var object WP_Meta_Query\n\t */\n\tpublic $meta_query = false;\n\n\t/**\n\t * Date query container\n\t *\n\t * @since 3.7.0\n\t * @var object WP_Date_Query\n\t */\n\tpublic $date_query = false;\n\n\t/**\n\t * Holds the data for a single object that is queried.\n\t *\n\t * Holds the contents of a post, page, category, attachment.\n\t *\n\t * @since 1.5.0\n\t * @var object|array\n\t */\n\tpublic $queried_object;\n\n\t/**\n\t * The ID of the queried object.\n\t *\n\t * @since 1.5.0\n\t * @var int\n\t */\n\tpublic $queried_object_id;\n\n\t/**\n\t * Get post database query.\n\t *\n\t * @since 2.0.1\n\t * @var string\n\t */\n\tpublic $request;\n\n\t/**\n\t * List of posts.\n\t *\n\t * @since 1.5.0\n\t * @var array\n\t */\n\tpublic $posts;\n\n\t/**\n\t * The amount of posts for the current query.\n\t *\n\t * @since 1.5.0\n\t * @var int\n\t */\n\tpublic $post_count = 0;\n\n\t/**\n\t * Index of the current item in the loop.\n\t *\n\t * @since 1.5.0\n\t * @var int\n\t */\n\tpublic $current_post = -1;\n\n\t/**\n\t * Whether the loop has started and the caller is in the loop.\n\t *\n\t * @since 2.0.0\n\t * @var bool\n\t */\n\tpublic $in_the_loop = false;\n\n\t/**\n\t * The current post.\n\t *\n\t * @since 1.5.0\n\t * @var WP_Post\n\t */\n\tpublic $post;\n\n\t/**\n\t * The list of comments for current post.\n\t *\n\t * @since 2.2.0\n\t * @var array\n\t */\n\tpublic $comments;\n\n\t/**\n\t * The amount of comments for the posts.\n\t *\n\t * @since 2.2.0\n\t * @var int\n\t */\n\tpublic $comment_count = 0;\n\n\t/**\n\t * The index of the comment in the comment loop.\n\t *\n\t * @since 2.2.0\n\t * @var int\n\t */\n\tpublic $current_comment = -1;\n\n\t/**\n\t * Current comment ID.\n\t *\n\t * @since 2.2.0\n\t * @var int\n\t */\n\tpublic $comment;\n\n\t/**\n\t * The amount of found posts for the current query.\n\t *\n\t * If limit clause was not used, equals $post_count.\n\t *\n\t * @since 2.1.0\n\t * @var int\n\t */\n\tpublic $found_posts = 0;\n\n\t/**\n\t * The amount of pages.\n\t *\n\t * @since 2.1.0\n\t * @var int\n\t */\n\tpublic $max_num_pages = 0;\n\n\t/**\n\t * The amount of comment pages.\n\t *\n\t * @since 2.7.0\n\t * @var int\n\t */\n\tpublic $max_num_comment_pages = 0;\n\n\t/**\n\t * Signifies whether the current query is for a single post.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_single = false;\n\n\t/**\n\t * Signifies whether the current query is for a preview.\n\t *\n\t * @since 2.0.0\n\t * @var bool\n\t */\n\tpublic $is_preview = false;\n\n\t/**\n\t * Signifies whether the current query is for a page.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_page = false;\n\n\t/**\n\t * Signifies whether the current query is for an archive.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_archive = false;\n\n\t/**\n\t * Signifies whether the current query is for a date archive.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_date = false;\n\n\t/**\n\t * Signifies whether the current query is for a year archive.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_year = false;\n\n\t/**\n\t * Signifies whether the current query is for a month archive.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_month = false;\n\n\t/**\n\t * Signifies whether the current query is for a day archive.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_day = false;\n\n\t/**\n\t * Signifies whether the current query is for a specific time.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_time = false;\n\n\t/**\n\t * Signifies whether the current query is for an author archive.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_author = false;\n\n\t/**\n\t * Signifies whether the current query is for a category archive.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_category = false;\n\n\t/**\n\t * Signifies whether the current query is for a tag archive.\n\t *\n\t * @since 2.3.0\n\t * @var bool\n\t */\n\tpublic $is_tag = false;\n\n\t/**\n\t * Signifies whether the current query is for a taxonomy archive.\n\t *\n\t * @since 2.5.0\n\t * @var bool\n\t */\n\tpublic $is_tax = false;\n\n\t/**\n\t * Signifies whether the current query is for a search.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_search = false;\n\n\t/**\n\t * Signifies whether the current query is for a feed.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_feed = false;\n\n\t/**\n\t * Signifies whether the current query is for a comment feed.\n\t *\n\t * @since 2.2.0\n\t * @var bool\n\t */\n\tpublic $is_comment_feed = false;\n\n\t/**\n\t * Signifies whether the current query is for trackback endpoint call.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_trackback = false;\n\n\t/**\n\t * Signifies whether the current query is for the site homepage.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_home = false;\n\n\t/**\n\t * Signifies whether the current query is for the Privacy Policy page.\n\t *\n\t * @since 5.2.0\n\t * @var bool\n\t */\n\tpublic $is_privacy_policy = false;\n\n\t/**\n\t * Signifies whether the current query couldn't find anything.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_404 = false;\n\n\t/**\n\t * Signifies whether the current query is for an embed.\n\t *\n\t * @since 4.4.0\n\t * @var bool\n\t */\n\tpublic $is_embed = false;\n\n\t/**\n\t * Signifies whether the current query is for a paged result and not for the first page.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_paged = false;\n\n\t/**\n\t * Signifies whether the current query is for an administrative interface page.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_admin = false;\n\n\t/**\n\t * Signifies whether the current query is for an attachment page.\n\t *\n\t * @since 2.0.0\n\t * @var bool\n\t */\n\tpublic $is_attachment = false;\n\n\t/**\n\t * Signifies whether the current query is for an existing single post of any post type\n\t * (post, attachment, page, custom post types).\n\t *\n\t * @since 2.1.0\n\t * @var bool\n\t */\n\tpublic $is_singular = false;\n\n\t/**\n\t * Signifies whether the current query is for the robots.txt file.\n\t *\n\t * @since 2.1.0\n\t * @var bool\n\t */\n\tpublic $is_robots = false;\n\n\t/**\n\t * Signifies whether the current query is for the page_for_posts page.\n\t *\n\t * Basically, the homepage if the option isn't set for the static homepage.\n\t *\n\t * @since 2.1.0\n\t * @var bool\n\t */\n\tpublic $is_posts_page = false;\n\n\t/**\n\t * Signifies whether the current query is for a post type archive.\n\t *\n\t * @since 3.1.0\n\t * @var bool\n\t */\n\tpublic $is_post_type_archive = false;\n\n\t/**\n\t * Stores the ->query_vars state like md5(serialize( $this->query_vars ) ) so we know\n\t * whether we have to re-parse because something has changed\n\t *\n\t * @since 3.1.0\n\t * @var bool|string\n\t */\n\tprivate $query_vars_hash = false;\n\n\t/**\n\t * Whether query vars have changed since the initial parse_query() call. Used to catch modifications to query vars made\n\t * via pre_get_posts hooks.\n\t *\n\t * @since 3.1.1\n\t */\n\tprivate $query_vars_changed = true;\n\n\t/**\n\t * Set if post thumbnails are cached\n\t *\n\t * @since 3.2.0\n\t * @var bool\n\t */\n\tpublic $thumbnails_cached = false;\n\n\t/**\n\t * Cached list of search stopwords.\n\t *\n\t * @since 3.7.0\n\t * @var array\n\t */\n\tprivate $stopwords;\n\n\tprivate $compat_fields = array( 'query_vars_hash', 'query_vars_changed' );\n\n\tprivate $compat_methods = array( 'init_query_flags', 'parse_tax_query' );\n\n\t/**\n\t * Resets query flags to false.\n\t *\n\t * The query flags are what page info WordPress was able to figure out.\n\t *\n\t * @since 2.0.0\n\t */\n\tprivate function init_query_flags() {\n\t\t$this->is_single            = false;\n\t\t$this->is_preview           = false;\n\t\t$this->is_page              = false;\n\t\t$this->is_archive           = false;\n\t\t$this->is_date              = false;\n\t\t$this->is_year              = false;\n\t\t$this->is_month             = false;\n\t\t$this->is_day               = false;\n\t\t$this->is_time              = false;\n\t\t$this->is_author            = false;\n\t\t$this->is_category          = false;\n\t\t$this->is_tag               = false;\n\t\t$this->is_tax               = false;\n\t\t$this->is_search            = false;\n\t\t$this->is_feed              = false;\n\t\t$this->is_comment_feed      = false;\n\t\t$this->is_trackback         = false;\n\t\t$this->is_home              = false;\n\t\t$this->is_privacy_policy    = false;\n\t\t$this->is_404               = false;\n\t\t$this->is_paged             = false;\n\t\t$this->is_admin             = false;\n\t\t$this->is_attachment        = false;\n\t\t$this->is_singular          = false;\n\t\t$this->is_robots            = false;\n\t\t$this->is_posts_page        = false;\n\t\t$this->is_post_type_archive = false;\n\t}\n\n\t/**\n\t * Initiates object properties and sets default values.\n\t *\n\t * @since 1.5.0\n\t */\n\tpublic function init() {\n\t\tunset( $this->posts );\n\t\tunset( $this->query );\n\t\t$this->query_vars = array();\n\t\tunset( $this->queried_object );\n\t\tunset( $this->queried_object_id );\n\t\t$this->post_count   = 0;\n\t\t$this->current_post = -1;\n\t\t$this->in_the_loop  = false;\n\t\tunset( $this->request );\n\t\tunset( $this->post );\n\t\tunset( $this->comments );\n\t\tunset( $this->comment );\n\t\t$this->comment_count         = 0;\n\t\t$this->current_comment       = -1;\n\t\t$this->found_posts           = 0;\n\t\t$this->max_num_pages         = 0;\n\t\t$this->max_num_comment_pages = 0;\n\n\t\t$this->init_query_flags();\n\t}\n\n\t/**\n\t * Reparse the query vars.\n\t *\n\t * @since 1.5.0\n\t */\n\tpublic function parse_query_vars() {\n\t\t$this->parse_query();\n\t}\n\n\t/**\n\t * Fills in the query variables, which do not exist within the parameter.\n\t *\n\t * @since 2.1.0\n\t * @since 4.4.0 Removed the `comments_popup` public query variable.\n\t *\n\t * @param array $array Defined query variables.\n\t * @return array Complete query variables with undefined ones filled in empty.\n\t */\n\tpublic function fill_query_vars( $array ) {\n\t\t$keys = array(\n\t\t\t'error',\n\t\t\t'm',\n\t\t\t'p',\n\t\t\t'post_parent',\n\t\t\t'subpost',\n\t\t\t'subpost_id',\n\t\t\t'attachment',\n\t\t\t'attachment_id',\n\t\t\t'name',\n\t\t\t'static',\n\t\t\t'pagename',\n\t\t\t'page_id',\n\t\t\t'second',\n\t\t\t'minute',\n\t\t\t'hour',\n\t\t\t'day',\n\t\t\t'monthnum',\n\t\t\t'year',\n\t\t\t'w',\n\t\t\t'category_name',\n\t\t\t'tag',\n\t\t\t'cat',\n\t\t\t'tag_id',\n\t\t\t'author',\n\t\t\t'author_name',\n\t\t\t'feed',\n\t\t\t'tb',\n\t\t\t'paged',\n\t\t\t'meta_key',\n\t\t\t'meta_value',\n\t\t\t'preview',\n\t\t\t's',\n\t\t\t'sentence',\n\t\t\t'title',\n\t\t\t'fields',\n\t\t\t'menu_order',\n\t\t\t'embed',\n\t\t);\n\n\t\tforeach ( $keys as $key ) {\n\t\t\tif ( ! isset( $array[ $key ] ) ) {\n\t\t\t\t$array[ $key ] = '';\n\t\t\t}\n\t\t}\n\n\t\t$array_keys = array(\n\t\t\t'category__in',\n\t\t\t'category__not_in',\n\t\t\t'category__and',\n\t\t\t'post__in',\n\t\t\t'post__not_in',\n\t\t\t'post_name__in',\n\t\t\t'tag__in',\n\t\t\t'tag__not_in',\n\t\t\t'tag__and',\n\t\t\t'tag_slug__in',\n\t\t\t'tag_slug__and',\n\t\t\t'post_parent__in',\n\t\t\t'post_parent__not_in',\n\t\t\t'author__in',\n\t\t\t'author__not_in',\n\t\t);\n\n\t\tforeach ( $array_keys as $key ) {\n\t\t\tif ( ! isset( $array[ $key ] ) ) {\n\t\t\t\t$array[ $key ] = array();\n\t\t\t}\n\t\t}\n\t\treturn $array;\n\t}\n\n\t/**\n\t * Parse a query string and set query type booleans.\n\t *\n\t * @since 1.5.0\n\t * @since 4.2.0 Introduced the ability to order by specific clauses of a `$meta_query`, by passing the clause's\n\t *              array key to `$orderby`.\n\t * @since 4.4.0 Introduced `$post_name__in` and `$title` parameters. `$s` was updated to support excluded\n\t *              search terms, by prepending a hyphen.\n\t * @since 4.5.0 Removed the `$comments_popup` parameter.\n\t *              Introduced the `$comment_status` and `$ping_status` parameters.\n\t *              Introduced `RAND(x)` syntax for `$orderby`, which allows an integer seed value to random sorts.\n\t * @since 4.6.0 Added 'post_name__in' support for `$orderby`. Introduced the `$lazy_load_term_meta` argument.\n\t * @since 4.9.0 Introduced the `$comment_count` parameter.\n\t * @since 5.1.0 Introduced the `$meta_compare_key` parameter.\n\t *\n\t * @param string|array $query {\n\t *     Optional. Array or string of Query parameters.\n\t *\n\t *     @type int          $attachment_id           Attachment post ID. Used for 'attachment' post_type.\n\t *     @type int|string   $author                  Author ID, or comma-separated list of IDs.\n\t *     @type string       $author_name             User 'user_nicename'.\n\t *     @type array        $author__in              An array of author IDs to query from.\n\t *     @type array        $author__not_in          An array of author IDs not to query from.\n\t *     @type bool         $cache_results           Whether to cache post information. Default true.\n\t *     @type int|string   $cat                     Category ID or comma-separated list of IDs (this or any children).\n\t *     @type array        $category__and           An array of category IDs (AND in).\n\t *     @type array        $category__in            An array of category IDs (OR in, no children).\n\t *     @type array        $category__not_in        An array of category IDs (NOT in).\n\t *     @type string       $category_name           Use category slug (not name, this or any children).\n\t *     @type array|int    $comment_count           Filter results by comment count. Provide an integer to match\n\t *                                                 comment count exactly. Provide an array with integer 'value'\n\t *                                                 and 'compare' operator ('=', '!=', '>', '>=', '<', '<=' ) to\n\t *                                                 compare against comment_count in a specific way.\n\t *     @type string       $comment_status          Comment status.\n\t *     @type int          $comments_per_page       The number of comments to return per page.\n\t *                                                 Default 'comments_per_page' option.\n\t *     @type array        $date_query              An associative array of WP_Date_Query arguments.\n\t *                                                 See WP_Date_Query::__construct().\n\t *     @type int          $day                     Day of the month. Default empty. Accepts numbers 1-31.\n\t *     @type bool         $exact                   Whether to search by exact keyword. Default false.\n\t *     @type string|array $fields                  Which fields to return. Single field or all fields (string),\n\t *                                                 or array of fields. 'id=>parent' uses 'id' and 'post_parent'.\n\t *                                                 Default all fields. Accepts 'ids', 'id=>parent'.\n\t *     @type int          $hour                    Hour of the day. Default empty. Accepts numbers 0-23.\n\t *     @type int|bool     $ignore_sticky_posts     Whether to ignore sticky posts or not. Setting this to false\n\t *                                                 excludes stickies from 'post__in'. Accepts 1|true, 0|false.\n\t *                                                 Default 0|false.\n\t *     @type int          $m                       Combination YearMonth. Accepts any four-digit year and month\n\t *                                                 numbers 1-12. Default empty.\n\t *     @type string       $meta_compare            Comparison operator to test the 'meta_value'.\n\t *     @type string       $meta_compare_key        Comparison operator to test the 'meta_key'.\n\t *     @type string       $meta_key                Custom field key.\n\t *     @type array        $meta_query              An associative array of WP_Meta_Query arguments. See WP_Meta_Query.\n\t *     @type string       $meta_value              Custom field value.\n\t *     @type int          $meta_value_num          Custom field value number.\n\t *     @type int          $menu_order              The menu order of the posts.\n\t *     @type int          $monthnum                The two-digit month. Default empty. Accepts numbers 1-12.\n\t *     @type string       $name                    Post slug.\n\t *     @type bool         $nopaging                Show all posts (true) or paginate (false). Default false.\n\t *     @type bool         $no_found_rows           Whether to skip counting the total rows found. Enabling can improve\n\t *                                                 performance. Default false.\n\t *     @type int          $offset                  The number of posts to offset before retrieval.\n\t *     @type string       $order                   Designates ascending or descending order of posts. Default 'DESC'.\n\t *                                                 Accepts 'ASC', 'DESC'.\n\t *     @type string|array $orderby                 Sort retrieved posts by parameter. One or more options may be\n\t *                                                 passed. To use 'meta_value', or 'meta_value_num',\n\t *                                                 'meta_key=keyname' must be also be defined. To sort by a\n\t *                                                 specific `$meta_query` clause, use that clause's array key.\n\t *                                                 Accepts 'none', 'name', 'author', 'date', 'title',\n\t *                                                 'modified', 'menu_order', 'parent', 'ID', 'rand',\n\t *                                                 'relevance', 'RAND(x)' (where 'x' is an integer seed value),\n\t *                                                 'comment_count', 'meta_value', 'meta_value_num', 'post__in',\n\t *                                                 'post_name__in', 'post_parent__in', and the array keys\n\t *                                                 of `$meta_query`. Default is 'date', except when a search\n\t *                                                 is being performed, when the default is 'relevance'.\n\t *\n\t *     @type int          $p                       Post ID.\n\t *     @type int          $page                    Show the number of posts that would show up on page X of a\n\t *                                                 static front page.\n\t *     @type int          $paged                   The number of the current page.\n\t *     @type int          $page_id                 Page ID.\n\t *     @type string       $pagename                Page slug.\n\t *     @type string       $perm                    Show posts if user has the appropriate capability.\n\t *     @type string       $ping_status             Ping status.\n\t *     @type array        $post__in                An array of post IDs to retrieve, sticky posts will be included\n\t *     @type string       $post_mime_type          The mime type of the post. Used for 'attachment' post_type.\n\t *     @type array        $post__not_in            An array of post IDs not to retrieve. Note: a string of comma-\n\t *                                                 separated IDs will NOT work.\n\t *     @type int          $post_parent             Page ID to retrieve child pages for. Use 0 to only retrieve\n\t *                                                 top-level pages.\n\t *     @type array        $post_parent__in         An array containing parent page IDs to query child pages from.\n\t *     @type array        $post_parent__not_in     An array containing parent page IDs not to query child pages from.\n\t *     @type string|array $post_type               A post type slug (string) or array of post type slugs.\n\t *                                                 Default 'any' if using 'tax_query'.\n\t *     @type string|array $post_status             A post status (string) or array of post statuses.\n\t *     @type int          $posts_per_page          The number of posts to query for. Use -1 to request all posts.\n\t *     @type int          $posts_per_archive_page  The number of posts to query for by archive page. Overrides\n\t *                                                 'posts_per_page' when is_archive(), or is_search() are true.\n\t *     @type array        $post_name__in           An array of post slugs that results must match.\n\t *     @type string       $s                       Search keyword(s). Prepending a term with a hyphen will\n\t *                                                 exclude posts matching that term. Eg, 'pillow -sofa' will\n\t *                                                 return posts containing 'pillow' but not 'sofa'. The\n\t *                                                 character used for exclusion can be modified using the\n\t *                                                 the 'wp_query_search_exclusion_prefix' filter.\n\t *     @type int          $second                  Second of the minute. Default empty. Accepts numbers 0-60.\n\t *     @type bool         $sentence                Whether to search by phrase. Default false.\n\t *     @type bool         $suppress_filters        Whether to suppress filters. Default false.\n\t *     @type string       $tag                     Tag slug. Comma-separated (either), Plus-separated (all).\n\t *     @type array        $tag__and                An array of tag ids (AND in).\n\t *     @type array        $tag__in                 An array of tag ids (OR in).\n\t *     @type array        $tag__not_in             An array of tag ids (NOT in).\n\t *     @type int          $tag_id                  Tag id or comma-separated list of IDs.\n\t *     @type array        $tag_slug__and           An array of tag slugs (AND in).\n\t *     @type array        $tag_slug__in            An array of tag slugs (OR in). unless 'ignore_sticky_posts' is\n\t *                                                 true. Note: a string of comma-separated IDs will NOT work.\n\t *     @type array        $tax_query               An associative array of WP_Tax_Query arguments.\n\t *                                                 See WP_Tax_Query->queries.\n\t *     @type string       $title                   Post title.\n\t *     @type bool         $update_post_meta_cache  Whether to update the post meta cache. Default true.\n\t *     @type bool         $update_post_term_cache  Whether to update the post term cache. Default true.\n\t *     @type bool         $lazy_load_term_meta     Whether to lazy-load term meta. Setting to false will\n\t *                                                 disable cache priming for term meta, so that each\n\t *                                                 get_term_meta() call will hit the database.\n\t *                                                 Defaults to the value of `$update_post_term_cache`.\n\t *     @type int          $w                       The week number of the year. Default empty. Accepts numbers 0-53.\n\t *     @type int          $year                    The four-digit year. Default empty. Accepts any four-digit year.\n\t * }\n\t */\n\tpublic function parse_query( $query = '' ) {\n\t\tif ( ! empty( $query ) ) {\n\t\t\t$this->init();\n\t\t\t$this->query = $this->query_vars = wp_parse_args( $query );\n\t\t} elseif ( ! isset( $this->query ) ) {\n\t\t\t$this->query = $this->query_vars;\n\t\t}\n\n\t\t$this->query_vars         = $this->fill_query_vars( $this->query_vars );\n\t\t$qv                       = &$this->query_vars;\n\t\t$this->query_vars_changed = true;\n\n\t\tif ( ! empty( $qv['robots'] ) ) {\n\t\t\t$this->is_robots = true;\n\t\t}\n\n\t\tif ( ! is_scalar( $qv['p'] ) || $qv['p'] < 0 ) {\n\t\t\t$qv['p']     = 0;\n\t\t\t$qv['error'] = '404';\n\t\t} else {\n\t\t\t$qv['p'] = intval( $qv['p'] );\n\t\t}\n\n\t\t$qv['page_id']  = absint( $qv['page_id'] );\n\t\t$qv['year']     = absint( $qv['year'] );\n\t\t$qv['monthnum'] = absint( $qv['monthnum'] );\n\t\t$qv['day']      = absint( $qv['day'] );\n\t\t$qv['w']        = absint( $qv['w'] );\n\t\t$qv['m']        = is_scalar( $qv['m'] ) ? preg_replace( '|[^0-9]|', '', $qv['m'] ) : '';\n\t\t$qv['paged']    = absint( $qv['paged'] );\n\t\t$qv['cat']      = preg_replace( '|[^0-9,-]|', '', $qv['cat'] ); // comma separated list of positive or negative integers\n\t\t$qv['author']   = preg_replace( '|[^0-9,-]|', '', $qv['author'] ); // comma separated list of positive or negative integers\n\t\t$qv['pagename'] = trim( $qv['pagename'] );\n\t\t$qv['name']     = trim( $qv['name'] );\n\t\t$qv['title']    = trim( $qv['title'] );\n\t\tif ( '' !== $qv['hour'] ) {\n\t\t\t$qv['hour'] = absint( $qv['hour'] );\n\t\t}\n\t\tif ( '' !== $qv['minute'] ) {\n\t\t\t$qv['minute'] = absint( $qv['minute'] );\n\t\t}\n\t\tif ( '' !== $qv['second'] ) {\n\t\t\t$qv['second'] = absint( $qv['second'] );\n\t\t}\n\t\tif ( '' !== $qv['menu_order'] ) {\n\t\t\t$qv['menu_order'] = absint( $qv['menu_order'] );\n\t\t}\n\n\t\t// Fairly insane upper bound for search string lengths.\n\t\tif ( ! is_scalar( $qv['s'] ) || ( ! empty( $qv['s'] ) && strlen( $qv['s'] ) > 1600 ) ) {\n\t\t\t$qv['s'] = '';\n\t\t}\n\n\t\t// Compat. Map subpost to attachment.\n\t\tif ( '' != $qv['subpost'] ) {\n\t\t\t$qv['attachment'] = $qv['subpost'];\n\t\t}\n\t\tif ( '' != $qv['subpost_id'] ) {\n\t\t\t$qv['attachment_id'] = $qv['subpost_id'];\n\t\t}\n\n\t\t$qv['attachment_id'] = absint( $qv['attachment_id'] );\n\n\t\tif ( ( '' != $qv['attachment'] ) || ! empty( $qv['attachment_id'] ) ) {\n\t\t\t$this->is_single     = true;\n\t\t\t$this->is_attachment = true;\n\t\t} elseif ( '' != $qv['name'] ) {\n\t\t\t$this->is_single = true;\n\t\t} elseif ( $qv['p'] ) {\n\t\t\t$this->is_single = true;\n\t\t} elseif ( ( '' !== $qv['hour'] ) && ( '' !== $qv['minute'] ) && ( '' !== $qv['second'] ) && ( '' != $qv['year'] ) && ( '' != $qv['monthnum'] ) && ( '' != $qv['day'] ) ) {\n\t\t\t// If year, month, day, hour, minute, and second are set, a single\n\t\t\t// post is being queried.\n\t\t\t$this->is_single = true;\n\t\t} elseif ( '' != $qv['static'] || '' != $qv['pagename'] || ! empty( $qv['page_id'] ) ) {\n\t\t\t$this->is_page   = true;\n\t\t\t$this->is_single = false;\n\t\t} else {\n\t\t\t// Look for archive queries. Dates, categories, authors, search, post type archives.\n\n\t\t\tif ( isset( $this->query['s'] ) ) {\n\t\t\t\t$this->is_search = true;\n\t\t\t}\n\n\t\t\tif ( '' !== $qv['second'] ) {\n\t\t\t\t$this->is_time = true;\n\t\t\t\t$this->is_date = true;\n\t\t\t}\n\n\t\t\tif ( '' !== $qv['minute'] ) {\n\t\t\t\t$this->is_time = true;\n\t\t\t\t$this->is_date = true;\n\t\t\t}\n\n\t\t\tif ( '' !== $qv['hour'] ) {\n\t\t\t\t$this->is_time = true;\n\t\t\t\t$this->is_date = true;\n\t\t\t}\n\n\t\t\tif ( $qv['day'] ) {\n\t\t\t\tif ( ! $this->is_date ) {\n\t\t\t\t\t$date = sprintf( '%04d-%02d-%02d', $qv['year'], $qv['monthnum'], $qv['day'] );\n\t\t\t\t\tif ( $qv['monthnum'] && $qv['year'] && ! wp_checkdate( $qv['monthnum'], $qv['day'], $qv['year'], $date ) ) {\n\t\t\t\t\t\t$qv['error'] = '404';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->is_day  = true;\n\t\t\t\t\t\t$this->is_date = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $qv['monthnum'] ) {\n\t\t\t\tif ( ! $this->is_date ) {\n\t\t\t\t\tif ( 12 < $qv['monthnum'] ) {\n\t\t\t\t\t\t$qv['error'] = '404';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->is_month = true;\n\t\t\t\t\t\t$this->is_date  = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $qv['year'] ) {\n\t\t\t\tif ( ! $this->is_date ) {\n\t\t\t\t\t$this->is_year = true;\n\t\t\t\t\t$this->is_date = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $qv['m'] ) {\n\t\t\t\t$this->is_date = true;\n\t\t\t\tif ( strlen( $qv['m'] ) > 9 ) {\n\t\t\t\t\t$this->is_time = true;\n\t\t\t\t} elseif ( strlen( $qv['m'] ) > 7 ) {\n\t\t\t\t\t$this->is_day = true;\n\t\t\t\t} elseif ( strlen( $qv['m'] ) > 5 ) {\n\t\t\t\t\t$this->is_month = true;\n\t\t\t\t} else {\n\t\t\t\t\t$this->is_year = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( '' != $qv['w'] ) {\n\t\t\t\t$this->is_date = true;\n\t\t\t}\n\n\t\t\t$this->query_vars_hash = false;\n\t\t\t$this->parse_tax_query( $qv );\n\n\t\t\tforeach ( $this->tax_query->queries as $tax_query ) {\n\t\t\t\tif ( ! is_array( $tax_query ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( isset( $tax_query['operator'] ) && 'NOT IN' != $tax_query['operator'] ) {\n\t\t\t\t\tswitch ( $tax_query['taxonomy'] ) {\n\t\t\t\t\t\tcase 'category':\n\t\t\t\t\t\t\t$this->is_category = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'post_tag':\n\t\t\t\t\t\t\t$this->is_tag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t$this->is_tax = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tunset( $tax_query );\n\n\t\t\tif ( empty( $qv['author'] ) || ( $qv['author'] == '0' ) ) {\n\t\t\t\t$this->is_author = false;\n\t\t\t} else {\n\t\t\t\t$this->is_author = true;\n\t\t\t}\n\n\t\t\tif ( '' != $qv['author_name'] ) {\n\t\t\t\t$this->is_author = true;\n\t\t\t}\n\n\t\t\tif ( ! empty( $qv['post_type'] ) && ! is_array( $qv['post_type'] ) ) {\n\t\t\t\t$post_type_obj = get_post_type_object( $qv['post_type'] );\n\t\t\t\tif ( ! empty( $post_type_obj->has_archive ) ) {\n\t\t\t\t\t$this->is_post_type_archive = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $this->is_post_type_archive || $this->is_date || $this->is_author || $this->is_category || $this->is_tag || $this->is_tax ) {\n\t\t\t\t$this->is_archive = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( '' != $qv['feed'] ) {\n\t\t\t$this->is_feed = true;\n\t\t}\n\n\t\tif ( '' != $qv['embed'] ) {\n\t\t\t$this->is_embed = true;\n\t\t}\n\n\t\tif ( '' != $qv['tb'] ) {\n\t\t\t$this->is_trackback = true;\n\t\t}\n\n\t\tif ( '' != $qv['paged'] && ( intval( $qv['paged'] ) > 1 ) ) {\n\t\t\t$this->is_paged = true;\n\t\t}\n\n\t\t// if we're previewing inside the write screen\n\t\tif ( '' != $qv['preview'] ) {\n\t\t\t$this->is_preview = true;\n\t\t}\n\n\t\tif ( is_admin() ) {\n\t\t\t$this->is_admin = true;\n\t\t}\n\n\t\tif ( false !== strpos( $qv['feed'], 'comments-' ) ) {\n\t\t\t$qv['feed']         = str_replace( 'comments-', '', $qv['feed'] );\n\t\t\t$qv['withcomments'] = 1;\n\t\t}\n\n\t\t$this->is_singular = $this->is_single || $this->is_page || $this->is_attachment;\n\n\t\tif ( $this->is_feed && ( ! empty( $qv['withcomments'] ) || ( empty( $qv['withoutcomments'] ) && $this->is_singular ) ) ) {\n\t\t\t$this->is_comment_feed = true;\n\t\t}\n\n\t\tif ( ! ( $this->is_singular || $this->is_archive || $this->is_search || $this->is_feed || ( defined( 'REST_REQUEST' ) && REST_REQUEST ) || $this->is_trackback || $this->is_404 || $this->is_admin || $this->is_robots ) ) {\n\t\t\t$this->is_home = true;\n\t\t}\n\n\t\t// Correct is_* for page_on_front and page_for_posts\n\t\tif ( $this->is_home && 'page' == get_option( 'show_on_front' ) && get_option( 'page_on_front' ) ) {\n\t\t\t$_query = wp_parse_args( $this->query );\n\t\t\t// pagename can be set and empty depending on matched rewrite rules. Ignore an empty pagename.\n\t\t\tif ( isset( $_query['pagename'] ) && '' == $_query['pagename'] ) {\n\t\t\t\tunset( $_query['pagename'] );\n\t\t\t}\n\n\t\t\tunset( $_query['embed'] );\n\n\t\t\tif ( empty( $_query ) || ! array_diff( array_keys( $_query ), array( 'preview', 'page', 'paged', 'cpage' ) ) ) {\n\t\t\t\t$this->is_page = true;\n\t\t\t\t$this->is_home = false;\n\t\t\t\t$qv['page_id'] = get_option( 'page_on_front' );\n\t\t\t\t// Correct <!--nextpage--> for page_on_front\n\t\t\t\tif ( ! empty( $qv['paged'] ) ) {\n\t\t\t\t\t$qv['page'] = $qv['paged'];\n\t\t\t\t\tunset( $qv['paged'] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( '' != $qv['pagename'] ) {\n\t\t\t$this->queried_object = get_page_by_path( $qv['pagename'] );\n\n\t\t\tif ( $this->queried_object && 'attachment' == $this->queried_object->post_type ) {\n\t\t\t\tif ( preg_match( '/^[^%]*%(?:postname)%/', get_option( 'permalink_structure' ) ) ) {\n\t\t\t\t\t// See if we also have a post with the same slug\n\t\t\t\t\t$post = get_page_by_path( $qv['pagename'], OBJECT, 'post' );\n\t\t\t\t\tif ( $post ) {\n\t\t\t\t\t\t$this->queried_object = $post;\n\t\t\t\t\t\t$this->is_page        = false;\n\t\t\t\t\t\t$this->is_single      = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ! empty( $this->queried_object ) ) {\n\t\t\t\t$this->queried_object_id = (int) $this->queried_object->ID;\n\t\t\t} else {\n\t\t\t\tunset( $this->queried_object );\n\t\t\t}\n\n\t\t\tif ( 'page' == get_option( 'show_on_front' ) && isset( $this->queried_object_id ) && $this->queried_object_id == get_option( 'page_for_posts' ) ) {\n\t\t\t\t$this->is_page       = false;\n\t\t\t\t$this->is_home       = true;\n\t\t\t\t$this->is_posts_page = true;\n\t\t\t}\n\n\t\t\tif ( isset( $this->queried_object_id ) && $this->queried_object_id == get_option( 'wp_page_for_privacy_policy' ) ) {\n\t\t\t\t$this->is_privacy_policy = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( $qv['page_id'] ) {\n\t\t\tif ( 'page' == get_option( 'show_on_front' ) && $qv['page_id'] == get_option( 'page_for_posts' ) ) {\n\t\t\t\t$this->is_page       = false;\n\t\t\t\t$this->is_home       = true;\n\t\t\t\t$this->is_posts_page = true;\n\t\t\t}\n\n\t\t\tif ( $qv['page_id'] == get_option( 'wp_page_for_privacy_policy' ) ) {\n\t\t\t\t$this->is_privacy_policy = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $qv['post_type'] ) ) {\n\t\t\tif ( is_array( $qv['post_type'] ) ) {\n\t\t\t\t$qv['post_type'] = array_map( 'sanitize_key', $qv['post_type'] );\n\t\t\t} else {\n\t\t\t\t$qv['post_type'] = sanitize_key( $qv['post_type'] );\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $qv['post_status'] ) ) {\n\t\t\tif ( is_array( $qv['post_status'] ) ) {\n\t\t\t\t$qv['post_status'] = array_map( 'sanitize_key', $qv['post_status'] );\n\t\t\t} else {\n\t\t\t\t$qv['post_status'] = preg_replace( '|[^a-z0-9_,-]|', '', $qv['post_status'] );\n\t\t\t}\n\t\t}\n\n\t\tif ( $this->is_posts_page && ( ! isset( $qv['withcomments'] ) || ! $qv['withcomments'] ) ) {\n\t\t\t$this->is_comment_feed = false;\n\t\t}\n\n\t\t$this->is_singular = $this->is_single || $this->is_page || $this->is_attachment;\n\t\t// Done correcting is_* for page_on_front and page_for_posts\n\n\t\tif ( '404' == $qv['error'] ) {\n\t\t\t$this->set_404();\n\t\t}\n\n\t\t$this->is_embed = $this->is_embed && ( $this->is_singular || $this->is_404 );\n\n\t\t$this->query_vars_hash    = md5( serialize( $this->query_vars ) );\n\t\t$this->query_vars_changed = false;\n\n\t\t/**\n\t\t * Fires after the main query vars have been parsed.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t */\n\t\tdo_action_ref_array( 'parse_query', array( &$this ) );\n\t}\n\n\t/**\n\t * Parses various taxonomy related query vars.\n\t *\n\t * For BC, this method is not marked as protected. See [28987].\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param array $q The query variables. Passed by reference.\n\t */\n\tpublic function parse_tax_query( &$q ) {\n\t\tif ( ! empty( $q['tax_query'] ) && is_array( $q['tax_query'] ) ) {\n\t\t\t$tax_query = $q['tax_query'];\n\t\t} else {\n\t\t\t$tax_query = array();\n\t\t}\n\n\t\tif ( ! empty( $q['taxonomy'] ) && ! empty( $q['term'] ) ) {\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => $q['taxonomy'],\n\t\t\t\t'terms'    => array( $q['term'] ),\n\t\t\t\t'field'    => 'slug',\n\t\t\t);\n\t\t}\n\n\t\tforeach ( get_taxonomies( array(), 'objects' ) as $taxonomy => $t ) {\n\t\t\tif ( 'post_tag' == $taxonomy ) {\n\t\t\t\tcontinue;   // Handled further down in the $q['tag'] block\n\t\t\t}\n\n\t\t\tif ( $t->query_var && ! empty( $q[ $t->query_var ] ) ) {\n\t\t\t\t$tax_query_defaults = array(\n\t\t\t\t\t'taxonomy' => $taxonomy,\n\t\t\t\t\t'field'    => 'slug',\n\t\t\t\t);\n\n\t\t\t\tif ( isset( $t->rewrite['hierarchical'] ) && $t->rewrite['hierarchical'] ) {\n\t\t\t\t\t$q[ $t->query_var ] = wp_basename( $q[ $t->query_var ] );\n\t\t\t\t}\n\n\t\t\t\t$term = $q[ $t->query_var ];\n\n\t\t\t\tif ( is_array( $term ) ) {\n\t\t\t\t\t$term = implode( ',', $term );\n\t\t\t\t}\n\n\t\t\t\tif ( strpos( $term, '+' ) !== false ) {\n\t\t\t\t\t$terms = preg_split( '/[+]+/', $term );\n\t\t\t\t\tforeach ( $terms as $term ) {\n\t\t\t\t\t\t$tax_query[] = array_merge(\n\t\t\t\t\t\t\t$tax_query_defaults,\n\t\t\t\t\t\t\tarray(\n\t\t\t\t\t\t\t\t'terms' => array( $term ),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$tax_query[] = array_merge(\n\t\t\t\t\t\t$tax_query_defaults,\n\t\t\t\t\t\tarray(\n\t\t\t\t\t\t\t'terms' => preg_split( '/[,]+/', $term ),\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If querystring 'cat' is an array, implode it.\n\t\tif ( is_array( $q['cat'] ) ) {\n\t\t\t$q['cat'] = implode( ',', $q['cat'] );\n\t\t}\n\n\t\t// Category stuff\n\t\tif ( ! empty( $q['cat'] ) && ! $this->is_singular ) {\n\t\t\t$cat_in = $cat_not_in = array();\n\n\t\t\t$cat_array = preg_split( '/[,\\s]+/', urldecode( $q['cat'] ) );\n\t\t\t$cat_array = array_map( 'intval', $cat_array );\n\t\t\t$q['cat']  = implode( ',', $cat_array );\n\n\t\t\tforeach ( $cat_array as $cat ) {\n\t\t\t\tif ( $cat > 0 ) {\n\t\t\t\t\t$cat_in[] = $cat;\n\t\t\t\t} elseif ( $cat < 0 ) {\n\t\t\t\t\t$cat_not_in[] = abs( $cat );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ! empty( $cat_in ) ) {\n\t\t\t\t$tax_query[] = array(\n\t\t\t\t\t'taxonomy'         => 'category',\n\t\t\t\t\t'terms'            => $cat_in,\n\t\t\t\t\t'field'            => 'term_id',\n\t\t\t\t\t'include_children' => true,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( ! empty( $cat_not_in ) ) {\n\t\t\t\t$tax_query[] = array(\n\t\t\t\t\t'taxonomy'         => 'category',\n\t\t\t\t\t'terms'            => $cat_not_in,\n\t\t\t\t\t'field'            => 'term_id',\n\t\t\t\t\t'operator'         => 'NOT IN',\n\t\t\t\t\t'include_children' => true,\n\t\t\t\t);\n\t\t\t}\n\t\t\tunset( $cat_array, $cat_in, $cat_not_in );\n\t\t}\n\n\t\tif ( ! empty( $q['category__and'] ) && 1 === count( (array) $q['category__and'] ) ) {\n\t\t\t$q['category__and'] = (array) $q['category__and'];\n\t\t\tif ( ! isset( $q['category__in'] ) ) {\n\t\t\t\t$q['category__in'] = array();\n\t\t\t}\n\t\t\t$q['category__in'][] = absint( reset( $q['category__and'] ) );\n\t\t\tunset( $q['category__and'] );\n\t\t}\n\n\t\tif ( ! empty( $q['category__in'] ) ) {\n\t\t\t$q['category__in'] = array_map( 'absint', array_unique( (array) $q['category__in'] ) );\n\t\t\t$tax_query[]       = array(\n\t\t\t\t'taxonomy'         => 'category',\n\t\t\t\t'terms'            => $q['category__in'],\n\t\t\t\t'field'            => 'term_id',\n\t\t\t\t'include_children' => false,\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $q['category__not_in'] ) ) {\n\t\t\t$q['category__not_in'] = array_map( 'absint', array_unique( (array) $q['category__not_in'] ) );\n\t\t\t$tax_query[]           = array(\n\t\t\t\t'taxonomy'         => 'category',\n\t\t\t\t'terms'            => $q['category__not_in'],\n\t\t\t\t'operator'         => 'NOT IN',\n\t\t\t\t'include_children' => false,\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $q['category__and'] ) ) {\n\t\t\t$q['category__and'] = array_map( 'absint', array_unique( (array) $q['category__and'] ) );\n\t\t\t$tax_query[]        = array(\n\t\t\t\t'taxonomy'         => 'category',\n\t\t\t\t'terms'            => $q['category__and'],\n\t\t\t\t'field'            => 'term_id',\n\t\t\t\t'operator'         => 'AND',\n\t\t\t\t'include_children' => false,\n\t\t\t);\n\t\t}\n\n\t\t// If querystring 'tag' is array, implode it.\n\t\tif ( is_array( $q['tag'] ) ) {\n\t\t\t$q['tag'] = implode( ',', $q['tag'] );\n\t\t}\n\n\t\t// Tag stuff\n\t\tif ( '' != $q['tag'] && ! $this->is_singular && $this->query_vars_changed ) {\n\t\t\tif ( strpos( $q['tag'], ',' ) !== false ) {\n\t\t\t\t$tags = preg_split( '/[,\\r\\n\\t ]+/', $q['tag'] );\n\t\t\t\tforeach ( (array) $tags as $tag ) {\n\t\t\t\t\t$tag                 = sanitize_term_field( 'slug', $tag, 0, 'post_tag', 'db' );\n\t\t\t\t\t$q['tag_slug__in'][] = $tag;\n\t\t\t\t}\n\t\t\t} elseif ( preg_match( '/[+\\r\\n\\t ]+/', $q['tag'] ) || ! empty( $q['cat'] ) ) {\n\t\t\t\t$tags = preg_split( '/[+\\r\\n\\t ]+/', $q['tag'] );\n\t\t\t\tforeach ( (array) $tags as $tag ) {\n\t\t\t\t\t$tag                  = sanitize_term_field( 'slug', $tag, 0, 'post_tag', 'db' );\n\t\t\t\t\t$q['tag_slug__and'][] = $tag;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$q['tag']            = sanitize_term_field( 'slug', $q['tag'], 0, 'post_tag', 'db' );\n\t\t\t\t$q['tag_slug__in'][] = $q['tag'];\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $q['tag_id'] ) ) {\n\t\t\t$q['tag_id'] = absint( $q['tag_id'] );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms'    => $q['tag_id'],\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $q['tag__in'] ) ) {\n\t\t\t$q['tag__in'] = array_map( 'absint', array_unique( (array) $q['tag__in'] ) );\n\t\t\t$tax_query[]  = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms'    => $q['tag__in'],\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $q['tag__not_in'] ) ) {\n\t\t\t$q['tag__not_in'] = array_map( 'absint', array_unique( (array) $q['tag__not_in'] ) );\n\t\t\t$tax_query[]      = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms'    => $q['tag__not_in'],\n\t\t\t\t'operator' => 'NOT IN',\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $q['tag__and'] ) ) {\n\t\t\t$q['tag__and'] = array_map( 'absint', array_unique( (array) $q['tag__and'] ) );\n\t\t\t$tax_query[]   = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms'    => $q['tag__and'],\n\t\t\t\t'operator' => 'AND',\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $q['tag_slug__in'] ) ) {\n\t\t\t$q['tag_slug__in'] = array_map( 'sanitize_title_for_query', array_unique( (array) $q['tag_slug__in'] ) );\n\t\t\t$tax_query[]       = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms'    => $q['tag_slug__in'],\n\t\t\t\t'field'    => 'slug',\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $q['tag_slug__and'] ) ) {\n\t\t\t$q['tag_slug__and'] = array_map( 'sanitize_title_for_query', array_unique( (array) $q['tag_slug__and'] ) );\n\t\t\t$tax_query[]        = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms'    => $q['tag_slug__and'],\n\t\t\t\t'field'    => 'slug',\n\t\t\t\t'operator' => 'AND',\n\t\t\t);\n\t\t}\n\n\t\t$this->tax_query = new WP_Tax_Query( $tax_query );\n\n\t\t/**\n\t\t * Fires after taxonomy-related query vars have been parsed.\n\t\t *\n\t\t * @since 3.7.0\n\t\t *\n\t\t * @param WP_Query $this The WP_Query instance.\n\t\t */\n\t\tdo_action( 'parse_tax_query', $this );\n\t}\n\n\t/**\n\t * Generates SQL for the WHERE clause based on passed search terms.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @global wpdb $wpdb WordPress database abstraction object.\n\t *\n\t * @param array $q Query variables.\n\t * @return string WHERE clause.\n\t */\n\tprotected function parse_search( &$q ) {\n\t\tglobal $wpdb;\n\n\t\t$search = '';\n\n\t\t// added slashes screw with quote grouping when done early, so done later\n\t\t$q['s'] = stripslashes( $q['s'] );\n\t\tif ( empty( $_GET['s'] ) && $this->is_main_query() ) {\n\t\t\t$q['s'] = urldecode( $q['s'] );\n\t\t}\n\t\t// there are no line breaks in <input /> fields\n\t\t$q['s']                  = str_replace( array( \"\\r\", \"\\n\" ), '', $q['s'] );\n\t\t$q['search_terms_count'] = 1;\n\t\tif ( ! empty( $q['sentence'] ) ) {\n\t\t\t$q['search_terms'] = array( $q['s'] );\n\t\t} else {\n\t\t\tif ( preg_match_all( '/\".*?(\"|$)|((?<=[\\t \",+])|^)[^\\t \",+]+/', $q['s'], $matches ) ) {\n\t\t\t\t$q['search_terms_count'] = count( $matches[0] );\n\t\t\t\t$q['search_terms']       = $this->parse_search_terms( $matches[0] );\n\t\t\t\t// if the search string has only short terms or stopwords, or is 10+ terms long, match it as sentence\n\t\t\t\tif ( empty( $q['search_terms'] ) || count( $q['search_terms'] ) > 9 ) {\n\t\t\t\t\t$q['search_terms'] = array( $q['s'] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$q['search_terms'] = array( $q['s'] );\n\t\t\t}\n\t\t}\n\n\t\t$n                         = ! empty( $q['exact'] ) ? '' : '%';\n\t\t$searchand                 = '';\n\t\t$q['search_orderby_title'] = array();\n\n\t\t/**\n\t\t * Filters the prefix that indicates that a search term should be excluded from results.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param string $exclusion_prefix The prefix. Default '-'. Returning\n\t\t *                                 an empty value disables exclusions.\n\t\t */\n\t\t$exclusion_prefix = apply_filters( 'wp_query_search_exclusion_prefix', '-' );\n\n\t\tforeach ( $q['search_terms'] as $term ) {\n\t\t\t// If there is an $exclusion_prefix, terms prefixed with it should be excluded.\n\t\t\t$exclude = $exclusion_prefix && ( $exclusion_prefix === substr( $term, 0, 1 ) );\n\t\t\tif ( $exclude ) {\n\t\t\t\t$like_op  = 'NOT LIKE';\n\t\t\t\t$andor_op = 'AND';\n\t\t\t\t$term     = substr( $term, 1 );\n\t\t\t} else {\n\t\t\t\t$like_op  = 'LIKE';\n\t\t\t\t$andor_op = 'OR';\n\t\t\t}\n\n\t\t\tif ( $n && ! $exclude ) {\n\t\t\t\t$like                        = '%' . $wpdb->esc_like( $term ) . '%';\n\t\t\t\t$q['search_orderby_title'][] = $wpdb->prepare( \"{$wpdb->posts}.post_title LIKE %s\", $like );\n\t\t\t}\n\n\t\t\t$like      = $n . $wpdb->esc_like( $term ) . $n;\n\t\t\t$search   .= $wpdb->prepare( \"{$searchand}(({$wpdb->posts}.post_title $like_op %s) $andor_op ({$wpdb->posts}.post_excerpt $like_op %s) $andor_op ({$wpdb->posts}.post_content $like_op %s))\", $like, $like, $like );\n\t\t\t$searchand = ' AND ';\n\t\t}\n\n\t\tif ( ! empty( $search ) ) {\n\t\t\t$search = \" AND ({$search}) \";\n\t\t\tif ( ! is_user_logged_in() ) {\n\t\t\t\t$search .= \" AND ({$wpdb->posts}.post_password = '') \";\n\t\t\t}\n\t\t}\n\n\t\treturn $search;\n\t}\n\n\t/**\n\t * Check if the terms are suitable for searching.\n\t *\n\t * Uses an array of stopwords (terms) that are excluded from the separate\n\t * term matching when searching for posts. The list of English stopwords is\n\t * the approximate search engines list, and is translatable.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @param string[] $terms Array of terms to check.\n\t * @return array Terms that are not stopwords.\n\t */\n\tprotected function parse_search_terms( $terms ) {\n\t\t$strtolower = function_exists( 'mb_strtolower' ) ? 'mb_strtolower' : 'strtolower';\n\t\t$checked    = array();\n\n\t\t$stopwords = $this->get_search_stopwords();\n\n\t\tforeach ( $terms as $term ) {\n\t\t\t// keep before/after spaces when term is for exact match\n\t\t\tif ( preg_match( '/^\".+\"$/', $term ) ) {\n\t\t\t\t$term = trim( $term, \"\\\"'\" );\n\t\t\t} else {\n\t\t\t\t$term = trim( $term, \"\\\"' \" );\n\t\t\t}\n\n\t\t\t// Avoid single A-Z and single dashes.\n\t\t\tif ( ! $term || ( 1 === strlen( $term ) && preg_match( '/^[a-z\\-]$/i', $term ) ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( in_array( call_user_func( $strtolower, $term ), $stopwords, true ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$checked[] = $term;\n\t\t}\n\n\t\treturn $checked;\n\t}\n\n\t/**\n\t * Retrieve stopwords used when parsing search terms.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @return array Stopwords.\n\t */\n\tprotected function get_search_stopwords() {\n\t\tif ( isset( $this->stopwords ) ) {\n\t\t\treturn $this->stopwords;\n\t\t}\n\n\t\t/* translators: This is a comma-separated list of very common words that should be excluded from a search,\n\t\t * like a, an, and the. These are usually called \"stopwords\". You should not simply translate these individual\n\t\t * words into your language. Instead, look for and provide commonly accepted stopwords in your language.\n\t\t */\n\t\t$words = explode(\n\t\t\t',',\n\t\t\t_x(\n\t\t\t\t'about,an,are,as,at,be,by,com,for,from,how,in,is,it,of,on,or,that,the,this,to,was,what,when,where,who,will,with,www',\n\t\t\t\t'Comma-separated list of search stopwords in your language'\n\t\t\t)\n\t\t);\n\n\t\t$stopwords = array();\n\t\tforeach ( $words as $word ) {\n\t\t\t$word = trim( $word, \"\\r\\n\\t \" );\n\t\t\tif ( $word ) {\n\t\t\t\t$stopwords[] = $word;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Filters stopwords used when parsing search terms.\n\t\t *\n\t\t * @since 3.7.0\n\t\t *\n\t\t * @param string[] $stopwords Array of stopwords.\n\t\t */\n\t\t$this->stopwords = apply_filters( 'wp_search_stopwords', $stopwords );\n\t\treturn $this->stopwords;\n\t}\n\n\t/**\n\t * Generates SQL for the ORDER BY condition based on passed search terms.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @global wpdb $wpdb WordPress database abstraction object.\n\t *\n\t * @param array $q Query variables.\n\t * @return string ORDER BY clause.\n\t */\n\tprotected function parse_search_order( &$q ) {\n\t\tglobal $wpdb;\n\n\t\tif ( $q['search_terms_count'] > 1 ) {\n\t\t\t$num_terms = count( $q['search_orderby_title'] );\n\n\t\t\t// If the search terms contain negative queries, don't bother ordering by sentence matches.\n\t\t\t$like = '';\n\t\t\tif ( ! preg_match( '/(?:\\s|^)\\-/', $q['s'] ) ) {\n\t\t\t\t$like = '%' . $wpdb->esc_like( $q['s'] ) . '%';\n\t\t\t}\n\n\t\t\t$search_orderby = '';\n\n\t\t\t// sentence match in 'post_title'\n\t\t\tif ( $like ) {\n\t\t\t\t$search_orderby .= $wpdb->prepare( \"WHEN {$wpdb->posts}.post_title LIKE %s THEN 1 \", $like );\n\t\t\t}\n\n\t\t\t// sanity limit, sort as sentence when more than 6 terms\n\t\t\t// (few searches are longer than 6 terms and most titles are not)\n\t\t\tif ( $num_terms < 7 ) {\n\t\t\t\t// all words in title\n\t\t\t\t$search_orderby .= 'WHEN ' . implode( ' AND ', $q['search_orderby_title'] ) . ' THEN 2 ';\n\t\t\t\t// any word in title, not needed when $num_terms == 1\n\t\t\t\tif ( $num_terms > 1 ) {\n\t\t\t\t\t$search_orderby .= 'WHEN ' . implode( ' OR ', $q['search_orderby_title'] ) . ' THEN 3 ';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Sentence match in 'post_content' and 'post_excerpt'.\n\t\t\tif ( $like ) {\n\t\t\t\t$search_orderby .= $wpdb->prepare( \"WHEN {$wpdb->posts}.post_excerpt LIKE %s THEN 4 \", $like );\n\t\t\t\t$search_orderby .= $wpdb->prepare( \"WHEN {$wpdb->posts}.post_content LIKE %s THEN 5 \", $like );\n\t\t\t}\n\n\t\t\tif ( $search_orderby ) {\n\t\t\t\t$search_orderby = '(CASE ' . $search_orderby . 'ELSE 6 END)';\n\t\t\t}\n\t\t} else {\n\t\t\t// single word or sentence search\n\t\t\t$search_orderby = reset( $q['search_orderby_title'] ) . ' DESC';\n\t\t}\n\n\t\treturn $search_orderby;\n\t}\n\n\t/**\n\t * Converts the given orderby alias (if allowed) to a properly-prefixed value.\n\t *\n\t * @since 4.0.0\n\t *\n\t * @global wpdb $wpdb WordPress database abstraction object.\n\t *\n\t * @param string $orderby Alias for the field to order by.\n\t * @return string|false Table-prefixed value to used in the ORDER clause. False otherwise.\n\t */\n\tprotected function parse_orderby( $orderby ) {\n\t\tglobal $wpdb;\n\n\t\t// Used to filter values.\n\t\t$allowed_keys = array(\n\t\t\t'post_name',\n\t\t\t'post_author',\n\t\t\t'post_date',\n\t\t\t'post_title',\n\t\t\t'post_modified',\n\t\t\t'post_parent',\n\t\t\t'post_type',\n\t\t\t'name',\n\t\t\t'author',\n\t\t\t'date',\n\t\t\t'title',\n\t\t\t'modified',\n\t\t\t'parent',\n\t\t\t'type',\n\t\t\t'ID',\n\t\t\t'menu_order',\n\t\t\t'comment_count',\n\t\t\t'rand',\n\t\t\t'post__in',\n\t\t\t'post_parent__in',\n\t\t\t'post_name__in',\n\t\t);\n\n\t\t$primary_meta_key   = '';\n\t\t$primary_meta_query = false;\n\t\t$meta_clauses       = $this->meta_query->get_clauses();\n\t\tif ( ! empty( $meta_clauses ) ) {\n\t\t\t$primary_meta_query = reset( $meta_clauses );\n\n\t\t\tif ( ! empty( $primary_meta_query['key'] ) ) {\n\t\t\t\t$primary_meta_key = $primary_meta_query['key'];\n\t\t\t\t$allowed_keys[]   = $primary_meta_key;\n\t\t\t}\n\n\t\t\t$allowed_keys[] = 'meta_value';\n\t\t\t$allowed_keys[] = 'meta_value_num';\n\t\t\t$allowed_keys   = array_merge( $allowed_keys, array_keys( $meta_clauses ) );\n\t\t}\n\n\t\t// If RAND() contains a seed value, sanitize and add to allowed keys.\n\t\t$rand_with_seed = false;\n\t\tif ( preg_match( '/RAND\\(([0-9]+)\\)/i', $orderby, $matches ) ) {\n\t\t\t$orderby        = sprintf( 'RAND(%s)', intval( $matches[1] ) );\n\t\t\t$allowed_keys[] = $orderby;\n\t\t\t$rand_with_seed = true;\n\t\t}\n\n\t\tif ( ! in_array( $orderby, $allowed_keys, true ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$orderby_clause = '';\n\n\t\tswitch ( $orderby ) {\n\t\t\tcase 'post_name':\n\t\t\tcase 'post_author':\n\t\t\tcase 'post_date':\n\t\t\tcase 'post_title':\n\t\t\tcase 'post_modified':\n\t\t\tcase 'post_parent':\n\t\t\tcase 'post_type':\n\t\t\tcase 'ID':\n\t\t\tcase 'menu_order':\n\t\t\tcase 'comment_count':\n\t\t\t\t$orderby_clause = \"{$wpdb->posts}.{$orderby}\";\n\t\t\t\tbreak;\n\t\t\tcase 'rand':\n\t\t\t\t$orderby_clause = 'RAND()';\n\t\t\t\tbreak;\n\t\t\tcase $primary_meta_key:\n\t\t\tcase 'meta_value':\n\t\t\t\tif ( ! empty( $primary_meta_query['type'] ) ) {\n\t\t\t\t\t$orderby_clause = \"CAST({$primary_meta_query['alias']}.meta_value AS {$primary_meta_query['cast']})\";\n\t\t\t\t} else {\n\t\t\t\t\t$orderby_clause = \"{$primary_meta_query['alias']}.meta_value\";\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'meta_value_num':\n\t\t\t\t$orderby_clause = \"{$primary_meta_query['alias']}.meta_value+0\";\n\t\t\t\tbreak;\n\t\t\tcase 'post__in':\n\t\t\t\tif ( ! empty( $this->query_vars['post__in'] ) ) {\n\t\t\t\t\t$orderby_clause = \"FIELD({$wpdb->posts}.ID,\" . implode( ',', array_map( 'absint', $this->query_vars['post__in'] ) ) . ')';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'post_parent__in':\n\t\t\t\tif ( ! empty( $this->query_vars['post_parent__in'] ) ) {\n\t\t\t\t\t$orderby_clause = \"FIELD( {$wpdb->posts}.post_parent,\" . implode( ', ', array_map( 'absint', $this->query_vars['post_parent__in'] ) ) . ' )';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'post_name__in':\n\t\t\t\tif ( ! empty( $this->query_vars['post_name__in'] ) ) {\n\t\t\t\t\t$post_name__in        = array_map( 'sanitize_title_for_query', $this->query_vars['post_name__in'] );\n\t\t\t\t\t$post_name__in_string = \"'\" . implode( \"','\", $post_name__in ) . \"'\";\n\t\t\t\t\t$orderby_clause       = \"FIELD( {$wpdb->posts}.post_name,\" . $post_name__in_string . ' )';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ( array_key_exists( $orderby, $meta_clauses ) ) {\n\t\t\t\t\t// $orderby corresponds to a meta_query clause.\n\t\t\t\t\t$meta_clause    = $meta_clauses[ $orderby ];\n\t\t\t\t\t$orderby_clause = \"CAST({$meta_clause['alias']}.meta_value AS {$meta_clause['cast']})\";\n\t\t\t\t} elseif ( $rand_with_seed ) {\n\t\t\t\t\t$orderby_clause = $orderby;\n\t\t\t\t} else {\n\t\t\t\t\t// Default: order by post field.\n\t\t\t\t\t$orderby_clause = \"{$wpdb->posts}.post_\" . sanitize_key( $orderby );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $orderby_clause;\n\t}\n\n\t/**\n\t * Parse an 'order' query variable and cast it to ASC or DESC as necessary.\n\t *\n\t * @since 4.0.0\n\t *\n\t * @param string $order The 'order' query variable.\n\t * @return string The sanitized 'order' query variable.\n\t */\n\tprotected function parse_order( $order ) {\n\t\tif ( ! is_string( $order ) || empty( $order ) ) {\n\t\t\treturn 'DESC';\n\t\t}\n\n\t\tif ( 'ASC' === strtoupper( $order ) ) {\n\t\t\treturn 'ASC';\n\t\t} else {\n\t\t\treturn 'DESC';\n\t\t}\n\t}\n\n\t/**\n\t * Sets the 404 property and saves whether query is feed.\n\t *\n\t * @since 2.0.0\n\t */\n\tpublic function set_404() {\n\t\t$is_feed = $this->is_feed;\n\n\t\t$this->init_query_flags();\n\t\t$this->is_404 = true;\n\n\t\t$this->is_feed = $is_feed;\n\t}\n\n\t/**\n\t * Retrieve query variable.\n\t *\n\t * @since 1.5.0\n\t * @since 3.9.0 The `$default` argument was introduced.\n\t *\n\t * @param string $query_var Query variable key.\n\t * @param mixed  $default   Optional. Value to return if the query variable is not set. Default empty.\n\t * @return mixed Contents of the query variable.\n\t */\n\tpublic function get( $query_var, $default = '' ) {\n\t\tif ( isset( $this->query_vars[ $query_var ] ) ) {\n\t\t\treturn $this->query_vars[ $query_var ];\n\t\t}\n\n\t\treturn $default;\n\t}\n\n\t/**\n\t * Set query variable.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param string $query_var Query variable key.\n\t * @param mixed  $value     Query variable value.\n\t */\n\tpublic function set( $query_var, $value ) {\n\t\t$this->query_vars[ $query_var ] = $value;\n\t}\n\n\t/**\n\t * Retrieves an array of posts based on query variables.\n\t *\n\t * There are a few filters and actions that can be used to modify the post\n\t * database query.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @return WP_Post[]|int[] Array of post objects or post IDs.\n\t */\n\tpublic function get_posts() {\n\t\tglobal $wpdb;\n\n\t\t$this->parse_query();\n\n\t\t/**\n\t\t * Fires after the query variable object is created, but before the actual query is run.\n\t\t *\n\t\t * Note: If using conditional tags, use the method versions within the passed instance\n\t\t * (e.g. $this->is_main_query() instead of is_main_query()). This is because the functions\n\t\t * like is_main_query() test against the global $wp_query instance, not the passed one.\n\t\t *\n\t\t * @since 2.0.0\n\t\t *\n\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t */\n\t\tdo_action_ref_array( 'pre_get_posts', array( &$this ) );\n\n\t\t// Shorthand.\n\t\t$q = &$this->query_vars;\n\n\t\t// Fill again in case pre_get_posts unset some vars.\n\t\t$q = $this->fill_query_vars( $q );\n\n\t\t// Parse meta query\n\t\t$this->meta_query = new WP_Meta_Query();\n\t\t$this->meta_query->parse_query_vars( $q );\n\n\t\t// Set a flag if a pre_get_posts hook changed the query vars.\n\t\t$hash = md5( serialize( $this->query_vars ) );\n\t\tif ( $hash != $this->query_vars_hash ) {\n\t\t\t$this->query_vars_changed = true;\n\t\t\t$this->query_vars_hash    = $hash;\n\t\t}\n\t\tunset( $hash );\n\n\t\t// First let's clear some variables\n\t\t$distinct         = '';\n\t\t$whichauthor      = '';\n\t\t$whichmimetype    = '';\n\t\t$where            = '';\n\t\t$limits           = '';\n\t\t$join             = '';\n\t\t$search           = '';\n\t\t$groupby          = '';\n\t\t$post_status_join = false;\n\t\t$page             = 1;\n\n\t\tif ( isset( $q['caller_get_posts'] ) ) {\n\t\t\t_deprecated_argument(\n\t\t\t\t'WP_Query',\n\t\t\t\t'3.1.0',\n\t\t\t\t/* translators: 1: caller_get_posts, 2: ignore_sticky_posts */\n\t\t\t\tsprintf(\n\t\t\t\t\t__( '%1$s is deprecated. Use %2$s instead.' ),\n\t\t\t\t\t'<code>caller_get_posts</code>',\n\t\t\t\t\t'<code>ignore_sticky_posts</code>'\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tif ( ! isset( $q['ignore_sticky_posts'] ) ) {\n\t\t\t\t$q['ignore_sticky_posts'] = $q['caller_get_posts'];\n\t\t\t}\n\t\t}\n\n\t\tif ( ! isset( $q['ignore_sticky_posts'] ) ) {\n\t\t\t$q['ignore_sticky_posts'] = false;\n\t\t}\n\n\t\tif ( ! isset( $q['suppress_filters'] ) ) {\n\t\t\t$q['suppress_filters'] = false;\n\t\t}\n\n\t\tif ( ! isset( $q['cache_results'] ) ) {\n\t\t\tif ( wp_using_ext_object_cache() ) {\n\t\t\t\t$q['cache_results'] = false;\n\t\t\t} else {\n\t\t\t\t$q['cache_results'] = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( ! isset( $q['update_post_term_cache'] ) ) {\n\t\t\t$q['update_post_term_cache'] = true;\n\t\t}\n\n\t\tif ( ! isset( $q['lazy_load_term_meta'] ) ) {\n\t\t\t$q['lazy_load_term_meta'] = $q['update_post_term_cache'];\n\t\t}\n\n\t\tif ( ! isset( $q['update_post_meta_cache'] ) ) {\n\t\t\t$q['update_post_meta_cache'] = true;\n\t\t}\n\n\t\tif ( ! isset( $q['post_type'] ) ) {\n\t\t\tif ( $this->is_search ) {\n\t\t\t\t$q['post_type'] = 'any';\n\t\t\t} else {\n\t\t\t\t$q['post_type'] = '';\n\t\t\t}\n\t\t}\n\t\t$post_type = $q['post_type'];\n\t\tif ( empty( $q['posts_per_page'] ) ) {\n\t\t\t$q['posts_per_page'] = get_option( 'posts_per_page' );\n\t\t}\n\t\tif ( isset( $q['showposts'] ) && $q['showposts'] ) {\n\t\t\t$q['showposts']      = (int) $q['showposts'];\n\t\t\t$q['posts_per_page'] = $q['showposts'];\n\t\t}\n\t\tif ( ( isset( $q['posts_per_archive_page'] ) && $q['posts_per_archive_page'] != 0 ) && ( $this->is_archive || $this->is_search ) ) {\n\t\t\t$q['posts_per_page'] = $q['posts_per_archive_page'];\n\t\t}\n\t\tif ( ! isset( $q['nopaging'] ) ) {\n\t\t\tif ( $q['posts_per_page'] == -1 ) {\n\t\t\t\t$q['nopaging'] = true;\n\t\t\t} else {\n\t\t\t\t$q['nopaging'] = false;\n\t\t\t}\n\t\t}\n\n\t\tif ( $this->is_feed ) {\n\t\t\t// This overrides posts_per_page.\n\t\t\tif ( ! empty( $q['posts_per_rss'] ) ) {\n\t\t\t\t$q['posts_per_page'] = $q['posts_per_rss'];\n\t\t\t} else {\n\t\t\t\t$q['posts_per_page'] = get_option( 'posts_per_rss' );\n\t\t\t}\n\t\t\t$q['nopaging'] = false;\n\t\t}\n\t\t$q['posts_per_page'] = (int) $q['posts_per_page'];\n\t\tif ( $q['posts_per_page'] < -1 ) {\n\t\t\t$q['posts_per_page'] = abs( $q['posts_per_page'] );\n\t\t} elseif ( $q['posts_per_page'] == 0 ) {\n\t\t\t$q['posts_per_page'] = 1;\n\t\t}\n\n\t\tif ( ! isset( $q['comments_per_page'] ) || $q['comments_per_page'] == 0 ) {\n\t\t\t$q['comments_per_page'] = get_option( 'comments_per_page' );\n\t\t}\n\n\t\tif ( $this->is_home && ( empty( $this->query ) || $q['preview'] == 'true' ) && ( 'page' == get_option( 'show_on_front' ) ) && get_option( 'page_on_front' ) ) {\n\t\t\t$this->is_page = true;\n\t\t\t$this->is_home = false;\n\t\t\t$q['page_id']  = get_option( 'page_on_front' );\n\t\t}\n\n\t\tif ( isset( $q['page'] ) ) {\n\t\t\t$q['page'] = trim( $q['page'], '/' );\n\t\t\t$q['page'] = absint( $q['page'] );\n\t\t}\n\n\t\t// If true, forcibly turns off SQL_CALC_FOUND_ROWS even when limits are present.\n\t\tif ( isset( $q['no_found_rows'] ) ) {\n\t\t\t$q['no_found_rows'] = (bool) $q['no_found_rows'];\n\t\t} else {\n\t\t\t$q['no_found_rows'] = false;\n\t\t}\n\n\t\tswitch ( $q['fields'] ) {\n\t\t\tcase 'ids':\n\t\t\t\t$fields = \"{$wpdb->posts}.ID\";\n\t\t\t\tbreak;\n\t\t\tcase 'id=>parent':\n\t\t\t\t$fields = \"{$wpdb->posts}.ID, {$wpdb->posts}.post_parent\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$fields = \"{$wpdb->posts}.*\";\n\t\t}\n\n\t\tif ( '' !== $q['menu_order'] ) {\n\t\t\t$where .= \" AND {$wpdb->posts}.menu_order = \" . $q['menu_order'];\n\t\t}\n\t\t// The \"m\" parameter is meant for months but accepts datetimes of varying specificity\n\t\tif ( $q['m'] ) {\n\t\t\t$where .= \" AND YEAR({$wpdb->posts}.post_date)=\" . substr( $q['m'], 0, 4 );\n\t\t\tif ( strlen( $q['m'] ) > 5 ) {\n\t\t\t\t$where .= \" AND MONTH({$wpdb->posts}.post_date)=\" . substr( $q['m'], 4, 2 );\n\t\t\t}\n\t\t\tif ( strlen( $q['m'] ) > 7 ) {\n\t\t\t\t$where .= \" AND DAYOFMONTH({$wpdb->posts}.post_date)=\" . substr( $q['m'], 6, 2 );\n\t\t\t}\n\t\t\tif ( strlen( $q['m'] ) > 9 ) {\n\t\t\t\t$where .= \" AND HOUR({$wpdb->posts}.post_date)=\" . substr( $q['m'], 8, 2 );\n\t\t\t}\n\t\t\tif ( strlen( $q['m'] ) > 11 ) {\n\t\t\t\t$where .= \" AND MINUTE({$wpdb->posts}.post_date)=\" . substr( $q['m'], 10, 2 );\n\t\t\t}\n\t\t\tif ( strlen( $q['m'] ) > 13 ) {\n\t\t\t\t$where .= \" AND SECOND({$wpdb->posts}.post_date)=\" . substr( $q['m'], 12, 2 );\n\t\t\t}\n\t\t}\n\n\t\t// Handle the other individual date parameters\n\t\t$date_parameters = array();\n\n\t\tif ( '' !== $q['hour'] ) {\n\t\t\t$date_parameters['hour'] = $q['hour'];\n\t\t}\n\n\t\tif ( '' !== $q['minute'] ) {\n\t\t\t$date_parameters['minute'] = $q['minute'];\n\t\t}\n\n\t\tif ( '' !== $q['second'] ) {\n\t\t\t$date_parameters['second'] = $q['second'];\n\t\t}\n\n\t\tif ( $q['year'] ) {\n\t\t\t$date_parameters['year'] = $q['year'];\n\t\t}\n\n\t\tif ( $q['monthnum'] ) {\n\t\t\t$date_parameters['monthnum'] = $q['monthnum'];\n\t\t}\n\n\t\tif ( $q['w'] ) {\n\t\t\t$date_parameters['week'] = $q['w'];\n\t\t}\n\n\t\tif ( $q['day'] ) {\n\t\t\t$date_parameters['day'] = $q['day'];\n\t\t}\n\n\t\tif ( $date_parameters ) {\n\t\t\t$date_query = new WP_Date_Query( array( $date_parameters ) );\n\t\t\t$where     .= $date_query->get_sql();\n\t\t}\n\t\tunset( $date_parameters, $date_query );\n\n\t\t// Handle complex date queries\n\t\tif ( ! empty( $q['date_query'] ) ) {\n\t\t\t$this->date_query = new WP_Date_Query( $q['date_query'] );\n\t\t\t$where           .= $this->date_query->get_sql();\n\t\t}\n\n\t\t// If we've got a post_type AND it's not \"any\" post_type.\n\t\tif ( ! empty( $q['post_type'] ) && 'any' != $q['post_type'] ) {\n\t\t\tforeach ( (array) $q['post_type'] as $_post_type ) {\n\t\t\t\t$ptype_obj = get_post_type_object( $_post_type );\n\t\t\t\tif ( ! $ptype_obj || ! $ptype_obj->query_var || empty( $q[ $ptype_obj->query_var ] ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( ! $ptype_obj->hierarchical ) {\n\t\t\t\t\t// Non-hierarchical post types can directly use 'name'.\n\t\t\t\t\t$q['name'] = $q[ $ptype_obj->query_var ];\n\t\t\t\t} else {\n\t\t\t\t\t// Hierarchical post types will operate through 'pagename'.\n\t\t\t\t\t$q['pagename'] = $q[ $ptype_obj->query_var ];\n\t\t\t\t\t$q['name']     = '';\n\t\t\t\t}\n\n\t\t\t\t// Only one request for a slug is possible, this is why name & pagename are overwritten above.\n\t\t\t\tbreak;\n\t\t\t} //end foreach\n\t\t\tunset( $ptype_obj );\n\t\t}\n\n\t\tif ( '' !== $q['title'] ) {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.post_title = %s\", stripslashes( $q['title'] ) );\n\t\t}\n\n\t\t// Parameters related to 'post_name'.\n\t\tif ( '' != $q['name'] ) {\n\t\t\t$q['name'] = sanitize_title_for_query( $q['name'] );\n\t\t\t$where    .= \" AND {$wpdb->posts}.post_name = '\" . $q['name'] . \"'\";\n\t\t} elseif ( '' != $q['pagename'] ) {\n\t\t\tif ( isset( $this->queried_object_id ) ) {\n\t\t\t\t$reqpage = $this->queried_object_id;\n\t\t\t} else {\n\t\t\t\tif ( 'page' != $q['post_type'] ) {\n\t\t\t\t\tforeach ( (array) $q['post_type'] as $_post_type ) {\n\t\t\t\t\t\t$ptype_obj = get_post_type_object( $_post_type );\n\t\t\t\t\t\tif ( ! $ptype_obj || ! $ptype_obj->hierarchical ) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$reqpage = get_page_by_path( $q['pagename'], OBJECT, $_post_type );\n\t\t\t\t\t\tif ( $reqpage ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tunset( $ptype_obj );\n\t\t\t\t} else {\n\t\t\t\t\t$reqpage = get_page_by_path( $q['pagename'] );\n\t\t\t\t}\n\t\t\t\tif ( ! empty( $reqpage ) ) {\n\t\t\t\t\t$reqpage = $reqpage->ID;\n\t\t\t\t} else {\n\t\t\t\t\t$reqpage = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$page_for_posts = get_option( 'page_for_posts' );\n\t\t\tif ( ( 'page' != get_option( 'show_on_front' ) ) || empty( $page_for_posts ) || ( $reqpage != $page_for_posts ) ) {\n\t\t\t\t$q['pagename'] = sanitize_title_for_query( wp_basename( $q['pagename'] ) );\n\t\t\t\t$q['name']     = $q['pagename'];\n\t\t\t\t$where        .= \" AND ({$wpdb->posts}.ID = '$reqpage')\";\n\t\t\t\t$reqpage_obj   = get_post( $reqpage );\n\t\t\t\tif ( is_object( $reqpage_obj ) && 'attachment' == $reqpage_obj->post_type ) {\n\t\t\t\t\t$this->is_attachment = true;\n\t\t\t\t\t$post_type           = $q['post_type'] = 'attachment';\n\t\t\t\t\t$this->is_page       = true;\n\t\t\t\t\t$q['attachment_id']  = $reqpage;\n\t\t\t\t}\n\t\t\t}\n\t\t} elseif ( '' != $q['attachment'] ) {\n\t\t\t$q['attachment'] = sanitize_title_for_query( wp_basename( $q['attachment'] ) );\n\t\t\t$q['name']       = $q['attachment'];\n\t\t\t$where          .= \" AND {$wpdb->posts}.post_name = '\" . $q['attachment'] . \"'\";\n\t\t} elseif ( is_array( $q['post_name__in'] ) && ! empty( $q['post_name__in'] ) ) {\n\t\t\t$q['post_name__in'] = array_map( 'sanitize_title_for_query', $q['post_name__in'] );\n\t\t\t$post_name__in      = \"'\" . implode( \"','\", $q['post_name__in'] ) . \"'\";\n\t\t\t$where             .= \" AND {$wpdb->posts}.post_name IN ($post_name__in)\";\n\t\t}\n\n\t\t// If an attachment is requested by number, let it supersede any post number.\n\t\tif ( $q['attachment_id'] ) {\n\t\t\t$q['p'] = absint( $q['attachment_id'] );\n\t\t}\n\n\t\t// If a post number is specified, load that post\n\t\tif ( $q['p'] ) {\n\t\t\t$where .= \" AND {$wpdb->posts}.ID = \" . $q['p'];\n\t\t} elseif ( $q['post__in'] ) {\n\t\t\t$post__in = implode( ',', array_map( 'absint', $q['post__in'] ) );\n\t\t\t$where   .= \" AND {$wpdb->posts}.ID IN ($post__in)\";\n\t\t} elseif ( $q['post__not_in'] ) {\n\t\t\t$post__not_in = implode( ',', array_map( 'absint', $q['post__not_in'] ) );\n\t\t\t$where       .= \" AND {$wpdb->posts}.ID NOT IN ($post__not_in)\";\n\t\t}\n\n\t\tif ( is_numeric( $q['post_parent'] ) ) {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.post_parent = %d \", $q['post_parent'] );\n\t\t} elseif ( $q['post_parent__in'] ) {\n\t\t\t$post_parent__in = implode( ',', array_map( 'absint', $q['post_parent__in'] ) );\n\t\t\t$where          .= \" AND {$wpdb->posts}.post_parent IN ($post_parent__in)\";\n\t\t} elseif ( $q['post_parent__not_in'] ) {\n\t\t\t$post_parent__not_in = implode( ',', array_map( 'absint', $q['post_parent__not_in'] ) );\n\t\t\t$where              .= \" AND {$wpdb->posts}.post_parent NOT IN ($post_parent__not_in)\";\n\t\t}\n\n\t\tif ( $q['page_id'] ) {\n\t\t\tif ( ( 'page' != get_option( 'show_on_front' ) ) || ( $q['page_id'] != get_option( 'page_for_posts' ) ) ) {\n\t\t\t\t$q['p'] = $q['page_id'];\n\t\t\t\t$where  = \" AND {$wpdb->posts}.ID = \" . $q['page_id'];\n\t\t\t}\n\t\t}\n\n\t\t// If a search pattern is specified, load the posts that match.\n\t\tif ( strlen( $q['s'] ) ) {\n\t\t\t$search = $this->parse_search( $q );\n\t\t}\n\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the search SQL that is used in the WHERE clause of WP_Query.\n\t\t\t *\n\t\t\t * @since 3.0.0\n\t\t\t *\n\t\t\t * @param string   $search Search SQL for WHERE clause.\n\t\t\t * @param WP_Query $this   The current WP_Query object.\n\t\t\t */\n\t\t\t$search = apply_filters_ref_array( 'posts_search', array( $search, &$this ) );\n\t\t}\n\n\t\t// Taxonomies\n\t\tif ( ! $this->is_singular ) {\n\t\t\t$this->parse_tax_query( $q );\n\n\t\t\t$clauses = $this->tax_query->get_sql( $wpdb->posts, 'ID' );\n\n\t\t\t$join  .= $clauses['join'];\n\t\t\t$where .= $clauses['where'];\n\t\t}\n\n\t\tif ( $this->is_tax ) {\n\t\t\tif ( empty( $post_type ) ) {\n\t\t\t\t// Do a fully inclusive search for currently registered post types of queried taxonomies\n\t\t\t\t$post_type  = array();\n\t\t\t\t$taxonomies = array_keys( $this->tax_query->queried_terms );\n\t\t\t\tforeach ( get_post_types( array( 'exclude_from_search' => false ) ) as $pt ) {\n\t\t\t\t\t$object_taxonomies = $pt === 'attachment' ? get_taxonomies_for_attachments() : get_object_taxonomies( $pt );\n\t\t\t\t\tif ( array_intersect( $taxonomies, $object_taxonomies ) ) {\n\t\t\t\t\t\t$post_type[] = $pt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( ! $post_type ) {\n\t\t\t\t\t$post_type = 'any';\n\t\t\t\t} elseif ( count( $post_type ) == 1 ) {\n\t\t\t\t\t$post_type = $post_type[0];\n\t\t\t\t}\n\n\t\t\t\t$post_status_join = true;\n\t\t\t} elseif ( in_array( 'attachment', (array) $post_type ) ) {\n\t\t\t\t$post_status_join = true;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Ensure that 'taxonomy', 'term', 'term_id', 'cat', and\n\t\t * 'category_name' vars are set for backward compatibility.\n\t\t */\n\t\tif ( ! empty( $this->tax_query->queried_terms ) ) {\n\n\t\t\t/*\n\t\t\t * Set 'taxonomy', 'term', and 'term_id' to the\n\t\t\t * first taxonomy other than 'post_tag' or 'category'.\n\t\t\t */\n\t\t\tif ( ! isset( $q['taxonomy'] ) ) {\n\t\t\t\tforeach ( $this->tax_query->queried_terms as $queried_taxonomy => $queried_items ) {\n\t\t\t\t\tif ( empty( $queried_items['terms'][0] ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! in_array( $queried_taxonomy, array( 'category', 'post_tag' ) ) ) {\n\t\t\t\t\t\t$q['taxonomy'] = $queried_taxonomy;\n\n\t\t\t\t\t\tif ( 'slug' === $queried_items['field'] ) {\n\t\t\t\t\t\t\t$q['term'] = $queried_items['terms'][0];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$q['term_id'] = $queried_items['terms'][0];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Take the first one we find.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 'cat', 'category_name', 'tag_id'\n\t\t\tforeach ( $this->tax_query->queried_terms as $queried_taxonomy => $queried_items ) {\n\t\t\t\tif ( empty( $queried_items['terms'][0] ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( 'category' === $queried_taxonomy ) {\n\t\t\t\t\t$the_cat = get_term_by( $queried_items['field'], $queried_items['terms'][0], 'category' );\n\t\t\t\t\tif ( $the_cat ) {\n\t\t\t\t\t\t$this->set( 'cat', $the_cat->term_id );\n\t\t\t\t\t\t$this->set( 'category_name', $the_cat->slug );\n\t\t\t\t\t}\n\t\t\t\t\tunset( $the_cat );\n\t\t\t\t}\n\n\t\t\t\tif ( 'post_tag' === $queried_taxonomy ) {\n\t\t\t\t\t$the_tag = get_term_by( $queried_items['field'], $queried_items['terms'][0], 'post_tag' );\n\t\t\t\t\tif ( $the_tag ) {\n\t\t\t\t\t\t$this->set( 'tag_id', $the_tag->term_id );\n\t\t\t\t\t}\n\t\t\t\t\tunset( $the_tag );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $this->tax_query->queries ) || ! empty( $this->meta_query->queries ) ) {\n\t\t\t$groupby = \"{$wpdb->posts}.ID\";\n\t\t}\n\n\t\t// Author/user stuff\n\n\t\tif ( ! empty( $q['author'] ) && $q['author'] != '0' ) {\n\t\t\t$q['author'] = addslashes_gpc( '' . urldecode( $q['author'] ) );\n\t\t\t$authors     = array_unique( array_map( 'intval', preg_split( '/[,\\s]+/', $q['author'] ) ) );\n\t\t\tforeach ( $authors as $author ) {\n\t\t\t\t$key         = $author > 0 ? 'author__in' : 'author__not_in';\n\t\t\t\t$q[ $key ][] = abs( $author );\n\t\t\t}\n\t\t\t$q['author'] = implode( ',', $authors );\n\t\t}\n\n\t\tif ( ! empty( $q['author__not_in'] ) ) {\n\t\t\t$author__not_in = implode( ',', array_map( 'absint', array_unique( (array) $q['author__not_in'] ) ) );\n\t\t\t$where         .= \" AND {$wpdb->posts}.post_author NOT IN ($author__not_in) \";\n\t\t} elseif ( ! empty( $q['author__in'] ) ) {\n\t\t\t$author__in = implode( ',', array_map( 'absint', array_unique( (array) $q['author__in'] ) ) );\n\t\t\t$where     .= \" AND {$wpdb->posts}.post_author IN ($author__in) \";\n\t\t}\n\n\t\t// Author stuff for nice URLs\n\n\t\tif ( '' != $q['author_name'] ) {\n\t\t\tif ( strpos( $q['author_name'], '/' ) !== false ) {\n\t\t\t\t$q['author_name'] = explode( '/', $q['author_name'] );\n\t\t\t\tif ( $q['author_name'][ count( $q['author_name'] ) - 1 ] ) {\n\t\t\t\t\t$q['author_name'] = $q['author_name'][ count( $q['author_name'] ) - 1 ]; // no trailing slash\n\t\t\t\t} else {\n\t\t\t\t\t$q['author_name'] = $q['author_name'][ count( $q['author_name'] ) - 2 ]; // there was a trailing slash\n\t\t\t\t}\n\t\t\t}\n\t\t\t$q['author_name'] = sanitize_title_for_query( $q['author_name'] );\n\t\t\t$q['author']      = get_user_by( 'slug', $q['author_name'] );\n\t\t\tif ( $q['author'] ) {\n\t\t\t\t$q['author'] = $q['author']->ID;\n\t\t\t}\n\t\t\t$whichauthor .= \" AND ({$wpdb->posts}.post_author = \" . absint( $q['author'] ) . ')';\n\t\t}\n\n\t\t// Matching by comment count.\n\t\tif ( isset( $q['comment_count'] ) ) {\n\t\t\t// Numeric comment count is converted to array format.\n\t\t\tif ( is_numeric( $q['comment_count'] ) ) {\n\t\t\t\t$q['comment_count'] = array(\n\t\t\t\t\t'value' => intval( $q['comment_count'] ),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( isset( $q['comment_count']['value'] ) ) {\n\t\t\t\t$q['comment_count'] = array_merge(\n\t\t\t\t\tarray(\n\t\t\t\t\t\t'compare' => '=',\n\t\t\t\t\t),\n\t\t\t\t\t$q['comment_count']\n\t\t\t\t);\n\n\t\t\t\t// Fallback for invalid compare operators is '='.\n\t\t\t\t$compare_operators = array( '=', '!=', '>', '>=', '<', '<=' );\n\t\t\t\tif ( ! in_array( $q['comment_count']['compare'], $compare_operators, true ) ) {\n\t\t\t\t\t$q['comment_count']['compare'] = '=';\n\t\t\t\t}\n\n\t\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.comment_count {$q['comment_count']['compare']} %d\", $q['comment_count']['value'] );\n\t\t\t}\n\t\t}\n\n\t\t// MIME-Type stuff for attachment browsing\n\n\t\tif ( isset( $q['post_mime_type'] ) && '' != $q['post_mime_type'] ) {\n\t\t\t$whichmimetype = wp_post_mime_type_where( $q['post_mime_type'], $wpdb->posts );\n\t\t}\n\t\t$where .= $search . $whichauthor . $whichmimetype;\n\n\t\tif ( ! empty( $this->meta_query->queries ) ) {\n\t\t\t$clauses = $this->meta_query->get_sql( 'post', $wpdb->posts, 'ID', $this );\n\t\t\t$join   .= $clauses['join'];\n\t\t\t$where  .= $clauses['where'];\n\t\t}\n\n\t\t$rand = ( isset( $q['orderby'] ) && 'rand' === $q['orderby'] );\n\t\tif ( ! isset( $q['order'] ) ) {\n\t\t\t$q['order'] = $rand ? '' : 'DESC';\n\t\t} else {\n\t\t\t$q['order'] = $rand ? '' : $this->parse_order( $q['order'] );\n\t\t}\n\n\t\t// These values of orderby should ignore the 'order' parameter.\n\t\t$force_asc = array( 'post__in', 'post_name__in', 'post_parent__in' );\n\t\tif ( isset( $q['orderby'] ) && in_array( $q['orderby'], $force_asc, true ) ) {\n\t\t\t$q['order'] = '';\n\t\t}\n\n\t\t// Order by.\n\t\tif ( empty( $q['orderby'] ) ) {\n\t\t\t/*\n\t\t\t * Boolean false or empty array blanks out ORDER BY,\n\t\t\t * while leaving the value unset or otherwise empty sets the default.\n\t\t\t */\n\t\t\tif ( isset( $q['orderby'] ) && ( is_array( $q['orderby'] ) || false === $q['orderby'] ) ) {\n\t\t\t\t$orderby = '';\n\t\t\t} else {\n\t\t\t\t$orderby = \"{$wpdb->posts}.post_date \" . $q['order'];\n\t\t\t}\n\t\t} elseif ( 'none' == $q['orderby'] ) {\n\t\t\t$orderby = '';\n\t\t} else {\n\t\t\t$orderby_array = array();\n\t\t\tif ( is_array( $q['orderby'] ) ) {\n\t\t\t\tforeach ( $q['orderby'] as $_orderby => $order ) {\n\t\t\t\t\t$orderby = addslashes_gpc( urldecode( $_orderby ) );\n\t\t\t\t\t$parsed  = $this->parse_orderby( $orderby );\n\n\t\t\t\t\tif ( ! $parsed ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t$orderby_array[] = $parsed . ' ' . $this->parse_order( $order );\n\t\t\t\t}\n\t\t\t\t$orderby = implode( ', ', $orderby_array );\n\n\t\t\t} else {\n\t\t\t\t$q['orderby'] = urldecode( $q['orderby'] );\n\t\t\t\t$q['orderby'] = addslashes_gpc( $q['orderby'] );\n\n\t\t\t\tforeach ( explode( ' ', $q['orderby'] ) as $i => $orderby ) {\n\t\t\t\t\t$parsed = $this->parse_orderby( $orderby );\n\t\t\t\t\t// Only allow certain values for safety.\n\t\t\t\t\tif ( ! $parsed ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t$orderby_array[] = $parsed;\n\t\t\t\t}\n\t\t\t\t$orderby = implode( ' ' . $q['order'] . ', ', $orderby_array );\n\n\t\t\t\tif ( empty( $orderby ) ) {\n\t\t\t\t\t$orderby = \"{$wpdb->posts}.post_date \" . $q['order'];\n\t\t\t\t} elseif ( ! empty( $q['order'] ) ) {\n\t\t\t\t\t$orderby .= \" {$q['order']}\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Order search results by relevance only when another \"orderby\" is not specified in the query.\n\t\tif ( ! empty( $q['s'] ) ) {\n\t\t\t$search_orderby = '';\n\t\t\tif ( ! empty( $q['search_orderby_title'] ) && ( empty( $q['orderby'] ) && ! $this->is_feed ) || ( isset( $q['orderby'] ) && 'relevance' === $q['orderby'] ) ) {\n\t\t\t\t$search_orderby = $this->parse_search_order( $q );\n\t\t\t}\n\n\t\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t\t/**\n\t\t\t\t * Filters the ORDER BY used when ordering search results.\n\t\t\t\t *\n\t\t\t\t * @since 3.7.0\n\t\t\t\t *\n\t\t\t\t * @param string   $search_orderby The ORDER BY clause.\n\t\t\t\t * @param WP_Query $this           The current WP_Query instance.\n\t\t\t\t */\n\t\t\t\t$search_orderby = apply_filters( 'posts_search_orderby', $search_orderby, $this );\n\t\t\t}\n\n\t\t\tif ( $search_orderby ) {\n\t\t\t\t$orderby = $orderby ? $search_orderby . ', ' . $orderby : $search_orderby;\n\t\t\t}\n\t\t}\n\n\t\tif ( is_array( $post_type ) && count( $post_type ) > 1 ) {\n\t\t\t$post_type_cap = 'multiple_post_type';\n\t\t} else {\n\t\t\tif ( is_array( $post_type ) ) {\n\t\t\t\t$post_type = reset( $post_type );\n\t\t\t}\n\t\t\t$post_type_object = get_post_type_object( $post_type );\n\t\t\tif ( empty( $post_type_object ) ) {\n\t\t\t\t$post_type_cap = $post_type;\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $q['post_password'] ) ) {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.post_password = %s\", $q['post_password'] );\n\t\t\tif ( empty( $q['perm'] ) ) {\n\t\t\t\t$q['perm'] = 'readable';\n\t\t\t}\n\t\t} elseif ( isset( $q['has_password'] ) ) {\n\t\t\t$where .= sprintf( \" AND {$wpdb->posts}.post_password %s ''\", $q['has_password'] ? '!=' : '=' );\n\t\t}\n\n\t\tif ( ! empty( $q['comment_status'] ) ) {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.comment_status = %s \", $q['comment_status'] );\n\t\t}\n\n\t\tif ( ! empty( $q['ping_status'] ) ) {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.ping_status = %s \", $q['ping_status'] );\n\t\t}\n\n\t\tif ( 'any' == $post_type ) {\n\t\t\t$in_search_post_types = get_post_types( array( 'exclude_from_search' => false ) );\n\t\t\tif ( empty( $in_search_post_types ) ) {\n\t\t\t\t$where .= ' AND 1=0 ';\n\t\t\t} else {\n\t\t\t\t$where .= \" AND {$wpdb->posts}.post_type IN ('\" . join( \"', '\", array_map( 'esc_sql', $in_search_post_types ) ) . \"')\";\n\t\t\t}\n\t\t} elseif ( ! empty( $post_type ) && is_array( $post_type ) ) {\n\t\t\t$where .= \" AND {$wpdb->posts}.post_type IN ('\" . join( \"', '\", esc_sql( $post_type ) ) . \"')\";\n\t\t} elseif ( ! empty( $post_type ) ) {\n\t\t\t$where           .= $wpdb->prepare( \" AND {$wpdb->posts}.post_type = %s\", $post_type );\n\t\t\t$post_type_object = get_post_type_object( $post_type );\n\t\t} elseif ( $this->is_attachment ) {\n\t\t\t$where           .= \" AND {$wpdb->posts}.post_type = 'attachment'\";\n\t\t\t$post_type_object = get_post_type_object( 'attachment' );\n\t\t} elseif ( $this->is_page ) {\n\t\t\t$where           .= \" AND {$wpdb->posts}.post_type = 'page'\";\n\t\t\t$post_type_object = get_post_type_object( 'page' );\n\t\t} else {\n\t\t\t$where           .= \" AND {$wpdb->posts}.post_type = 'post'\";\n\t\t\t$post_type_object = get_post_type_object( 'post' );\n\t\t}\n\n\t\t$edit_cap = 'edit_post';\n\t\t$read_cap = 'read_post';\n\n\t\tif ( ! empty( $post_type_object ) ) {\n\t\t\t$edit_others_cap  = $post_type_object->cap->edit_others_posts;\n\t\t\t$read_private_cap = $post_type_object->cap->read_private_posts;\n\t\t} else {\n\t\t\t$edit_others_cap  = 'edit_others_' . $post_type_cap . 's';\n\t\t\t$read_private_cap = 'read_private_' . $post_type_cap . 's';\n\t\t}\n\n\t\t$user_id = get_current_user_id();\n\n\t\t$q_status = array();\n\t\tif ( ! empty( $q['post_status'] ) ) {\n\t\t\t$statuswheres = array();\n\t\t\t$q_status     = $q['post_status'];\n\t\t\tif ( ! is_array( $q_status ) ) {\n\t\t\t\t$q_status = explode( ',', $q_status );\n\t\t\t}\n\t\t\t$r_status = array();\n\t\t\t$p_status = array();\n\t\t\t$e_status = array();\n\t\t\tif ( in_array( 'any', $q_status ) ) {\n\t\t\t\tforeach ( get_post_stati( array( 'exclude_from_search' => true ) ) as $status ) {\n\t\t\t\t\tif ( ! in_array( $status, $q_status ) ) {\n\t\t\t\t\t\t$e_status[] = \"{$wpdb->posts}.post_status <> '$status'\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tforeach ( get_post_stati() as $status ) {\n\t\t\t\t\tif ( in_array( $status, $q_status ) ) {\n\t\t\t\t\t\tif ( 'private' == $status ) {\n\t\t\t\t\t\t\t$p_status[] = \"{$wpdb->posts}.post_status = '$status'\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$r_status[] = \"{$wpdb->posts}.post_status = '$status'\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( empty( $q['perm'] ) || 'readable' != $q['perm'] ) {\n\t\t\t\t$r_status = array_merge( $r_status, $p_status );\n\t\t\t\tunset( $p_status );\n\t\t\t}\n\n\t\t\tif ( ! empty( $e_status ) ) {\n\t\t\t\t$statuswheres[] = '(' . join( ' AND ', $e_status ) . ')';\n\t\t\t}\n\t\t\tif ( ! empty( $r_status ) ) {\n\t\t\t\tif ( ! empty( $q['perm'] ) && 'editable' == $q['perm'] && ! current_user_can( $edit_others_cap ) ) {\n\t\t\t\t\t$statuswheres[] = \"({$wpdb->posts}.post_author = $user_id \" . 'AND (' . join( ' OR ', $r_status ) . '))';\n\t\t\t\t} else {\n\t\t\t\t\t$statuswheres[] = '(' . join( ' OR ', $r_status ) . ')';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( ! empty( $p_status ) ) {\n\t\t\t\tif ( ! empty( $q['perm'] ) && 'readable' == $q['perm'] && ! current_user_can( $read_private_cap ) ) {\n\t\t\t\t\t$statuswheres[] = \"({$wpdb->posts}.post_author = $user_id \" . 'AND (' . join( ' OR ', $p_status ) . '))';\n\t\t\t\t} else {\n\t\t\t\t\t$statuswheres[] = '(' . join( ' OR ', $p_status ) . ')';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( $post_status_join ) {\n\t\t\t\t$join .= \" LEFT JOIN {$wpdb->posts} AS p2 ON ({$wpdb->posts}.post_parent = p2.ID) \";\n\t\t\t\tforeach ( $statuswheres as $index => $statuswhere ) {\n\t\t\t\t\t$statuswheres[ $index ] = \"($statuswhere OR ({$wpdb->posts}.post_status = 'inherit' AND \" . str_replace( $wpdb->posts, 'p2', $statuswhere ) . '))';\n\t\t\t\t}\n\t\t\t}\n\t\t\t$where_status = implode( ' OR ', $statuswheres );\n\t\t\tif ( ! empty( $where_status ) ) {\n\t\t\t\t$where .= \" AND ($where_status)\";\n\t\t\t}\n\t\t} elseif ( ! $this->is_singular ) {\n\t\t\t$where .= \" AND ({$wpdb->posts}.post_status = 'publish'\";\n\n\t\t\t// Add public states.\n\t\t\t$public_states = get_post_stati( array( 'public' => true ) );\n\t\t\tforeach ( (array) $public_states as $state ) {\n\t\t\t\tif ( 'publish' == $state ) { // Publish is hard-coded above.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t$where .= \" OR {$wpdb->posts}.post_status = '$state'\";\n\t\t\t}\n\n\t\t\tif ( $this->is_admin ) {\n\t\t\t\t// Add protected states that should show in the admin all list.\n\t\t\t\t$admin_all_states = get_post_stati(\n\t\t\t\t\tarray(\n\t\t\t\t\t\t'protected'              => true,\n\t\t\t\t\t\t'show_in_admin_all_list' => true,\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tforeach ( (array) $admin_all_states as $state ) {\n\t\t\t\t\t$where .= \" OR {$wpdb->posts}.post_status = '$state'\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( is_user_logged_in() ) {\n\t\t\t\t// Add private states that are limited to viewing by the author of a post or someone who has caps to read private states.\n\t\t\t\t$private_states = get_post_stati( array( 'private' => true ) );\n\t\t\t\tforeach ( (array) $private_states as $state ) {\n\t\t\t\t\t$where .= current_user_can( $read_private_cap ) ? \" OR {$wpdb->posts}.post_status = '$state'\" : \" OR {$wpdb->posts}.post_author = $user_id AND {$wpdb->posts}.post_status = '$state'\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$where .= ')';\n\t\t}\n\n\t\t/*\n\t\t * Apply filters on where and join prior to paging so that any\n\t\t * manipulations to them are reflected in the paging by day queries.\n\t\t */\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the WHERE clause of the query.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param string   $where The WHERE clause of the query.\n\t\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$where = apply_filters_ref_array( 'posts_where', array( $where, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the JOIN clause of the query.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param string   $join  The JOIN clause of the query.\n\t\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$join = apply_filters_ref_array( 'posts_join', array( $join, &$this ) );\n\t\t}\n\n\t\t// Paging\n\t\tif ( empty( $q['nopaging'] ) && ! $this->is_singular ) {\n\t\t\t$page = absint( $q['paged'] );\n\t\t\tif ( ! $page ) {\n\t\t\t\t$page = 1;\n\t\t\t}\n\n\t\t\t// If 'offset' is provided, it takes precedence over 'paged'.\n\t\t\tif ( isset( $q['offset'] ) && is_numeric( $q['offset'] ) ) {\n\t\t\t\t$q['offset'] = absint( $q['offset'] );\n\t\t\t\t$pgstrt      = $q['offset'] . ', ';\n\t\t\t} else {\n\t\t\t\t$pgstrt = absint( ( $page - 1 ) * $q['posts_per_page'] ) . ', ';\n\t\t\t}\n\t\t\t$limits = 'LIMIT ' . $pgstrt . $q['posts_per_page'];\n\t\t}\n\n\t\t// Comments feeds\n\t\tif ( $this->is_comment_feed && ! $this->is_singular ) {\n\t\t\tif ( $this->is_archive || $this->is_search ) {\n\t\t\t\t$cjoin    = \"JOIN {$wpdb->posts} ON ({$wpdb->comments}.comment_post_ID = {$wpdb->posts}.ID) $join \";\n\t\t\t\t$cwhere   = \"WHERE comment_approved = '1' $where\";\n\t\t\t\t$cgroupby = \"{$wpdb->comments}.comment_id\";\n\t\t\t} else { // Other non singular e.g. front\n\t\t\t\t$cjoin    = \"JOIN {$wpdb->posts} ON ( {$wpdb->comments}.comment_post_ID = {$wpdb->posts}.ID )\";\n\t\t\t\t$cwhere   = \"WHERE ( post_status = 'publish' OR ( post_status = 'inherit' AND post_type = 'attachment' ) ) AND comment_approved = '1'\";\n\t\t\t\t$cgroupby = '';\n\t\t\t}\n\n\t\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t\t/**\n\t\t\t\t * Filters the JOIN clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.2.0\n\t\t\t\t *\n\t\t\t\t * @param string   $cjoin The JOIN clause of the query.\n\t\t\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$cjoin = apply_filters_ref_array( 'comment_feed_join', array( $cjoin, &$this ) );\n\n\t\t\t\t/**\n\t\t\t\t * Filters the WHERE clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.2.0\n\t\t\t\t *\n\t\t\t\t * @param string   $cwhere The WHERE clause of the query.\n\t\t\t\t * @param WP_Query $this   The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$cwhere = apply_filters_ref_array( 'comment_feed_where', array( $cwhere, &$this ) );\n\n\t\t\t\t/**\n\t\t\t\t * Filters the GROUP BY clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.2.0\n\t\t\t\t *\n\t\t\t\t * @param string   $cgroupby The GROUP BY clause of the query.\n\t\t\t\t * @param WP_Query $this     The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$cgroupby = apply_filters_ref_array( 'comment_feed_groupby', array( $cgroupby, &$this ) );\n\n\t\t\t\t/**\n\t\t\t\t * Filters the ORDER BY clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.8.0\n\t\t\t\t *\n\t\t\t\t * @param string   $corderby The ORDER BY clause of the query.\n\t\t\t\t * @param WP_Query $this     The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$corderby = apply_filters_ref_array( 'comment_feed_orderby', array( 'comment_date_gmt DESC', &$this ) );\n\n\t\t\t\t/**\n\t\t\t\t * Filters the LIMIT clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.8.0\n\t\t\t\t *\n\t\t\t\t * @param string   $climits The JOIN clause of the query.\n\t\t\t\t * @param WP_Query $this    The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$climits = apply_filters_ref_array( 'comment_feed_limits', array( 'LIMIT ' . get_option( 'posts_per_rss' ), &$this ) );\n\t\t\t}\n\t\t\t$cgroupby = ( ! empty( $cgroupby ) ) ? 'GROUP BY ' . $cgroupby : '';\n\t\t\t$corderby = ( ! empty( $corderby ) ) ? 'ORDER BY ' . $corderby : '';\n\n\t\t\t$comments = (array) $wpdb->get_results( \"SELECT $distinct {$wpdb->comments}.* FROM {$wpdb->comments} $cjoin $cwhere $cgroupby $corderby $climits\" );\n\t\t\t// Convert to WP_Comment\n\t\t\t$this->comments      = array_map( 'get_comment', $comments );\n\t\t\t$this->comment_count = count( $this->comments );\n\n\t\t\t$post_ids = array();\n\n\t\t\tforeach ( $this->comments as $comment ) {\n\t\t\t\t$post_ids[] = (int) $comment->comment_post_ID;\n\t\t\t}\n\n\t\t\t$post_ids = join( ',', $post_ids );\n\t\t\t$join     = '';\n\t\t\tif ( $post_ids ) {\n\t\t\t\t$where = \"AND {$wpdb->posts}.ID IN ($post_ids) \";\n\t\t\t} else {\n\t\t\t\t$where = 'AND 0';\n\t\t\t}\n\t\t}\n\n\t\t$pieces = array( 'where', 'groupby', 'join', 'orderby', 'distinct', 'fields', 'limits' );\n\n\t\t/*\n\t\t * Apply post-paging filters on where and join. Only plugins that\n\t\t * manipulate paging queries should use these hooks.\n\t\t */\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the WHERE clause of the query.\n\t\t\t *\n\t\t\t * Specifically for manipulating paging queries.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param string   $where The WHERE clause of the query.\n\t\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$where = apply_filters_ref_array( 'posts_where_paged', array( $where, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the GROUP BY clause of the query.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param string   $groupby The GROUP BY clause of the query.\n\t\t\t * @param WP_Query $this    The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$groupby = apply_filters_ref_array( 'posts_groupby', array( $groupby, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the JOIN clause of the query.\n\t\t\t *\n\t\t\t * Specifically for manipulating paging queries.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param string   $join  The JOIN clause of the query.\n\t\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$join = apply_filters_ref_array( 'posts_join_paged', array( $join, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the ORDER BY clause of the query.\n\t\t\t *\n\t\t\t * @since 1.5.1\n\t\t\t *\n\t\t\t * @param string   $orderby The ORDER BY clause of the query.\n\t\t\t * @param WP_Query $this    The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$orderby = apply_filters_ref_array( 'posts_orderby', array( $orderby, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the DISTINCT clause of the query.\n\t\t\t *\n\t\t\t * @since 2.1.0\n\t\t\t *\n\t\t\t * @param string   $distinct The DISTINCT clause of the query.\n\t\t\t * @param WP_Query $this     The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$distinct = apply_filters_ref_array( 'posts_distinct', array( $distinct, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the LIMIT clause of the query.\n\t\t\t *\n\t\t\t * @since 2.1.0\n\t\t\t *\n\t\t\t * @param string   $limits The LIMIT clause of the query.\n\t\t\t * @param WP_Query $this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$limits = apply_filters_ref_array( 'post_limits', array( $limits, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the SELECT clause of the query.\n\t\t\t *\n\t\t\t * @since 2.1.0\n\t\t\t *\n\t\t\t * @param string   $fields The SELECT clause of the query.\n\t\t\t * @param WP_Query $this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$fields = apply_filters_ref_array( 'posts_fields', array( $fields, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters all query clauses at once, for convenience.\n\t\t\t *\n\t\t\t * Covers the WHERE, GROUP BY, JOIN, ORDER BY, DISTINCT,\n\t\t\t * fields (SELECT), and LIMITS clauses.\n\t\t\t *\n\t\t\t * @since 3.1.0\n\t\t\t *\n\t\t\t * @param string[] $clauses Associative array of the clauses for the query.\n\t\t\t * @param WP_Query $this    The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$clauses = (array) apply_filters_ref_array( 'posts_clauses', array( compact( $pieces ), &$this ) );\n\n\t\t\t$where    = isset( $clauses['where'] ) ? $clauses['where'] : '';\n\t\t\t$groupby  = isset( $clauses['groupby'] ) ? $clauses['groupby'] : '';\n\t\t\t$join     = isset( $clauses['join'] ) ? $clauses['join'] : '';\n\t\t\t$orderby  = isset( $clauses['orderby'] ) ? $clauses['orderby'] : '';\n\t\t\t$distinct = isset( $clauses['distinct'] ) ? $clauses['distinct'] : '';\n\t\t\t$fields   = isset( $clauses['fields'] ) ? $clauses['fields'] : '';\n\t\t\t$limits   = isset( $clauses['limits'] ) ? $clauses['limits'] : '';\n\t\t}\n\n\t\t/**\n\t\t * Fires to announce the query's current selection parameters.\n\t\t *\n\t\t * For use by caching plugins.\n\t\t *\n\t\t * @since 2.3.0\n\t\t *\n\t\t * @param string $selection The assembled selection query.\n\t\t */\n\t\tdo_action( 'posts_selection', $where . $groupby . $orderby . $limits . $join );\n\n\t\t/*\n\t\t * Filters again for the benefit of caching plugins.\n\t\t * Regular plugins should use the hooks above.\n\t\t */\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the WHERE clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $where The WHERE clause of the query.\n\t\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$where = apply_filters_ref_array( 'posts_where_request', array( $where, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the GROUP BY clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $groupby The GROUP BY clause of the query.\n\t\t\t * @param WP_Query $this    The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$groupby = apply_filters_ref_array( 'posts_groupby_request', array( $groupby, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the JOIN clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $join  The JOIN clause of the query.\n\t\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$join = apply_filters_ref_array( 'posts_join_request', array( $join, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the ORDER BY clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $orderby The ORDER BY clause of the query.\n\t\t\t * @param WP_Query $this    The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$orderby = apply_filters_ref_array( 'posts_orderby_request', array( $orderby, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the DISTINCT clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $distinct The DISTINCT clause of the query.\n\t\t\t * @param WP_Query $this     The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$distinct = apply_filters_ref_array( 'posts_distinct_request', array( $distinct, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the SELECT clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $fields The SELECT clause of the query.\n\t\t\t * @param WP_Query $this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$fields = apply_filters_ref_array( 'posts_fields_request', array( $fields, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the LIMIT clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $limits The LIMIT clause of the query.\n\t\t\t * @param WP_Query $this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$limits = apply_filters_ref_array( 'post_limits_request', array( $limits, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters all query clauses at once, for convenience.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * Covers the WHERE, GROUP BY, JOIN, ORDER BY, DISTINCT,\n\t\t\t * fields (SELECT), and LIMITS clauses.\n\t\t\t *\n\t\t\t * @since 3.1.0\n\t\t\t *\n\t\t\t * @param string[] $pieces Associative array of the pieces of the query.\n\t\t\t * @param WP_Query $this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$clauses = (array) apply_filters_ref_array( 'posts_clauses_request', array( compact( $pieces ), &$this ) );\n\n\t\t\t$where    = isset( $clauses['where'] ) ? $clauses['where'] : '';\n\t\t\t$groupby  = isset( $clauses['groupby'] ) ? $clauses['groupby'] : '';\n\t\t\t$join     = isset( $clauses['join'] ) ? $clauses['join'] : '';\n\t\t\t$orderby  = isset( $clauses['orderby'] ) ? $clauses['orderby'] : '';\n\t\t\t$distinct = isset( $clauses['distinct'] ) ? $clauses['distinct'] : '';\n\t\t\t$fields   = isset( $clauses['fields'] ) ? $clauses['fields'] : '';\n\t\t\t$limits   = isset( $clauses['limits'] ) ? $clauses['limits'] : '';\n\t\t}\n\n\t\tif ( ! empty( $groupby ) ) {\n\t\t\t$groupby = 'GROUP BY ' . $groupby;\n\t\t}\n\t\tif ( ! empty( $orderby ) ) {\n\t\t\t$orderby = 'ORDER BY ' . $orderby;\n\t\t}\n\n\t\t$found_rows = '';\n\t\tif ( ! $q['no_found_rows'] && ! empty( $limits ) ) {\n\t\t\t$found_rows = 'SQL_CALC_FOUND_ROWS';\n\t\t}\n\n\t\t$this->request = $old_request = \"SELECT $found_rows $distinct $fields FROM {$wpdb->posts} $join WHERE 1=1 $where $groupby $orderby $limits\";\n\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the completed SQL query before sending.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param string   $request The complete SQL query.\n\t\t\t * @param WP_Query $this    The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$this->request = apply_filters_ref_array( 'posts_request', array( $this->request, &$this ) );\n\t\t}\n\n\t\t/**\n\t\t * Filters the posts array before the query takes place.\n\t\t *\n\t\t * Return a non-null value to bypass WordPress's default post queries.\n\t\t *\n\t\t * Filtering functions that require pagination information are encouraged to set\n\t\t * the `found_posts` and `max_num_pages` properties of the WP_Query object,\n\t\t * passed to the filter by reference. If WP_Query does not perform a database\n\t\t * query, it will not have enough information to generate these values itself.\n\t\t *\n\t\t * @since 4.6.0\n\t\t *\n\t\t * @param array|null $posts Return an array of post data to short-circuit WP's query,\n\t\t *                          or null to allow WP to run its normal queries.\n\t\t * @param WP_Query   $this  The WP_Query instance (passed by reference).\n\t\t */\n\t\t$this->posts = apply_filters_ref_array( 'posts_pre_query', array( null, &$this ) );\n\n\t\tif ( 'ids' == $q['fields'] ) {\n\t\t\tif ( null === $this->posts ) {\n\t\t\t\t$this->posts = $wpdb->get_col( $this->request );\n\t\t\t}\n\n\t\t\t$this->posts      = array_map( 'intval', $this->posts );\n\t\t\t$this->post_count = count( $this->posts );\n\t\t\t$this->set_found_posts( $q, $limits );\n\n\t\t\treturn $this->posts;\n\t\t}\n\n\t\tif ( 'id=>parent' == $q['fields'] ) {\n\t\t\tif ( null === $this->posts ) {\n\t\t\t\t$this->posts = $wpdb->get_results( $this->request );\n\t\t\t}\n\n\t\t\t$this->post_count = count( $this->posts );\n\t\t\t$this->set_found_posts( $q, $limits );\n\n\t\t\t$r = array();\n\t\t\tforeach ( $this->posts as $key => $post ) {\n\t\t\t\t$this->posts[ $key ]->ID          = (int) $post->ID;\n\t\t\t\t$this->posts[ $key ]->post_parent = (int) $post->post_parent;\n\n\t\t\t\t$r[ (int) $post->ID ] = (int) $post->post_parent;\n\t\t\t}\n\n\t\t\treturn $r;\n\t\t}\n\n\t\tif ( null === $this->posts ) {\n\t\t\t$split_the_query = ( $old_request == $this->request && \"{$wpdb->posts}.*\" == $fields && ! empty( $limits ) && $q['posts_per_page'] < 500 );\n\n\t\t\t/**\n\t\t\t * Filters whether to split the query.\n\t\t\t *\n\t\t\t * Splitting the query will cause it to fetch just the IDs of the found posts\n\t\t\t * (and then individually fetch each post by ID), rather than fetching every\n\t\t\t * complete row at once. One massive result vs. many small results.\n\t\t\t *\n\t\t\t * @since 3.4.0\n\t\t\t *\n\t\t\t * @param bool     $split_the_query Whether or not to split the query.\n\t\t\t * @param WP_Query $this            The WP_Query instance.\n\t\t\t */\n\t\t\t$split_the_query = apply_filters( 'split_the_query', $split_the_query, $this );\n\n\t\t\tif ( $split_the_query ) {\n\t\t\t\t// First get the IDs and then fill in the objects\n\n\t\t\t\t$this->request = \"SELECT $found_rows $distinct {$wpdb->posts}.ID FROM {$wpdb->posts} $join WHERE 1=1 $where $groupby $orderby $limits\";\n\n\t\t\t\t/**\n\t\t\t\t * Filters the Post IDs SQL request before sending.\n\t\t\t\t *\n\t\t\t\t * @since 3.4.0\n\t\t\t\t *\n\t\t\t\t * @param string   $request The post ID request.\n\t\t\t\t * @param WP_Query $this    The WP_Query instance.\n\t\t\t\t */\n\t\t\t\t$this->request = apply_filters( 'posts_request_ids', $this->request, $this );\n\n\t\t\t\t$ids = $wpdb->get_col( $this->request );\n\n\t\t\t\tif ( $ids ) {\n\t\t\t\t\t$this->posts = $ids;\n\t\t\t\t\t$this->set_found_posts( $q, $limits );\n\t\t\t\t\t_prime_post_caches( $ids, $q['update_post_term_cache'], $q['update_post_meta_cache'] );\n\t\t\t\t} else {\n\t\t\t\t\t$this->posts = array();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$this->posts = $wpdb->get_results( $this->request );\n\t\t\t\t$this->set_found_posts( $q, $limits );\n\t\t\t}\n\t\t}\n\n\t\t// Convert to WP_Post objects.\n\t\tif ( $this->posts ) {\n\t\t\t$this->posts = array_map( 'get_post', $this->posts );\n\t\t}\n\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the raw post results array, prior to status checks.\n\t\t\t *\n\t\t\t * @since 2.3.0\n\t\t\t *\n\t\t\t * @param WP_Post[] $posts Array of post objects.\n\t\t\t * @param WP_Query  $this  The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$this->posts = apply_filters_ref_array( 'posts_results', array( $this->posts, &$this ) );\n\t\t}\n\n\t\tif ( ! empty( $this->posts ) && $this->is_comment_feed && $this->is_singular ) {\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$cjoin = apply_filters_ref_array( 'comment_feed_join', array( '', &$this ) );\n\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$cwhere = apply_filters_ref_array( 'comment_feed_where', array( \"WHERE comment_post_ID = '{$this->posts[0]->ID}' AND comment_approved = '1'\", &$this ) );\n\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$cgroupby = apply_filters_ref_array( 'comment_feed_groupby', array( '', &$this ) );\n\t\t\t$cgroupby = ( ! empty( $cgroupby ) ) ? 'GROUP BY ' . $cgroupby : '';\n\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$corderby = apply_filters_ref_array( 'comment_feed_orderby', array( 'comment_date_gmt DESC', &$this ) );\n\t\t\t$corderby = ( ! empty( $corderby ) ) ? 'ORDER BY ' . $corderby : '';\n\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$climits = apply_filters_ref_array( 'comment_feed_limits', array( 'LIMIT ' . get_option( 'posts_per_rss' ), &$this ) );\n\n\t\t\t$comments_request = \"SELECT {$wpdb->comments}.* FROM {$wpdb->comments} $cjoin $cwhere $cgroupby $corderby $climits\";\n\t\t\t$comments         = $wpdb->get_results( $comments_request );\n\t\t\t// Convert to WP_Comment\n\t\t\t$this->comments      = array_map( 'get_comment', $comments );\n\t\t\t$this->comment_count = count( $this->comments );\n\t\t}\n\n\t\t// Check post status to determine if post should be displayed.\n\t\tif ( ! empty( $this->posts ) && ( $this->is_single || $this->is_page ) ) {\n\t\t\t$status = get_post_status( $this->posts[0] );\n\t\t\tif ( 'attachment' === $this->posts[0]->post_type && 0 === (int) $this->posts[0]->post_parent ) {\n\t\t\t\t$this->is_page       = false;\n\t\t\t\t$this->is_single     = true;\n\t\t\t\t$this->is_attachment = true;\n\t\t\t}\n\t\t\t$post_status_obj = get_post_status_object( $status );\n\n\t\t\t// If the post_status was specifically requested, let it pass through.\n\t\t\tif ( ! $post_status_obj->public && ! in_array( $status, $q_status ) ) {\n\n\t\t\t\tif ( ! is_user_logged_in() ) {\n\t\t\t\t\t// User must be logged in to view unpublished posts.\n\t\t\t\t\t$this->posts = array();\n\t\t\t\t} else {\n\t\t\t\t\tif ( $post_status_obj->protected ) {\n\t\t\t\t\t\t// User must have edit permissions on the draft to preview.\n\t\t\t\t\t\tif ( ! current_user_can( $edit_cap, $this->posts[0]->ID ) ) {\n\t\t\t\t\t\t\t$this->posts = array();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$this->is_preview = true;\n\t\t\t\t\t\t\tif ( 'future' != $status ) {\n\t\t\t\t\t\t\t\t$this->posts[0]->post_date = current_time( 'mysql' );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} elseif ( $post_status_obj->private ) {\n\t\t\t\t\t\tif ( ! current_user_can( $read_cap, $this->posts[0]->ID ) ) {\n\t\t\t\t\t\t\t$this->posts = array();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->posts = array();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $this->is_preview && $this->posts && current_user_can( $edit_cap, $this->posts[0]->ID ) ) {\n\t\t\t\t/**\n\t\t\t\t * Filters the single post for preview mode.\n\t\t\t\t *\n\t\t\t\t * @since 2.7.0\n\t\t\t\t *\n\t\t\t\t * @param WP_Post  $post_preview  The Post object.\n\t\t\t\t * @param WP_Query $this          The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$this->posts[0] = get_post( apply_filters_ref_array( 'the_preview', array( $this->posts[0], &$this ) ) );\n\t\t\t}\n\t\t}\n\n\t\t// Put sticky posts at the top of the posts array\n\t\t$sticky_posts = get_option( 'sticky_posts' );\n\t\tif ( $this->is_home && $page <= 1 && is_array( $sticky_posts ) && ! empty( $sticky_posts ) && ! $q['ignore_sticky_posts'] ) {\n\t\t\t$num_posts     = count( $this->posts );\n\t\t\t$sticky_offset = 0;\n\t\t\t// Loop over posts and relocate stickies to the front.\n\t\t\tfor ( $i = 0; $i < $num_posts; $i++ ) {\n\t\t\t\tif ( in_array( $this->posts[ $i ]->ID, $sticky_posts ) ) {\n\t\t\t\t\t$sticky_post = $this->posts[ $i ];\n\t\t\t\t\t// Remove sticky from current position\n\t\t\t\t\tarray_splice( $this->posts, $i, 1 );\n\t\t\t\t\t// Move to front, after other stickies\n\t\t\t\t\tarray_splice( $this->posts, $sticky_offset, 0, array( $sticky_post ) );\n\t\t\t\t\t// Increment the sticky offset. The next sticky will be placed at this offset.\n\t\t\t\t\t$sticky_offset++;\n\t\t\t\t\t// Remove post from sticky posts array\n\t\t\t\t\t$offset = array_search( $sticky_post->ID, $sticky_posts );\n\t\t\t\t\tunset( $sticky_posts[ $offset ] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If any posts have been excluded specifically, Ignore those that are sticky.\n\t\t\tif ( ! empty( $sticky_posts ) && ! empty( $q['post__not_in'] ) ) {\n\t\t\t\t$sticky_posts = array_diff( $sticky_posts, $q['post__not_in'] );\n\t\t\t}\n\n\t\t\t// Fetch sticky posts that weren't in the query results\n\t\t\tif ( ! empty( $sticky_posts ) ) {\n\t\t\t\t$stickies = get_posts(\n\t\t\t\t\tarray(\n\t\t\t\t\t\t'post__in'    => $sticky_posts,\n\t\t\t\t\t\t'post_type'   => $post_type,\n\t\t\t\t\t\t'post_status' => 'publish',\n\t\t\t\t\t\t'nopaging'    => true,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\tforeach ( $stickies as $sticky_post ) {\n\t\t\t\t\tarray_splice( $this->posts, $sticky_offset, 0, array( $sticky_post ) );\n\t\t\t\t\t$sticky_offset++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If comments have been fetched as part of the query, make sure comment meta lazy-loading is set up.\n\t\tif ( ! empty( $this->comments ) ) {\n\t\t\twp_queue_comments_for_comment_meta_lazyload( $this->comments );\n\t\t}\n\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the array of retrieved posts after they've been fetched and\n\t\t\t * internally processed.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param WP_Post[] $posts Array of post objects.\n\t\t\t * @param WP_Query  $this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$this->posts = apply_filters_ref_array( 'the_posts', array( $this->posts, &$this ) );\n\t\t}\n\n\t\t// Ensure that any posts added/modified via one of the filters above are\n\t\t// of the type WP_Post and are filtered.\n\t\tif ( $this->posts ) {\n\t\t\t$this->post_count = count( $this->posts );\n\n\t\t\t$this->posts = array_map( 'get_post', $this->posts );\n\n\t\t\tif ( $q['cache_results'] ) {\n\t\t\t\tupdate_post_caches( $this->posts, $post_type, $q['update_post_term_cache'], $q['update_post_meta_cache'] );\n\t\t\t}\n\n\t\t\t$this->post = reset( $this->posts );\n\t\t} else {\n\t\t\t$this->post_count = 0;\n\t\t\t$this->posts      = array();\n\t\t}\n\n\t\tif ( $q['lazy_load_term_meta'] ) {\n\t\t\twp_queue_posts_for_term_meta_lazyload( $this->posts );\n\t\t}\n\n\t\treturn $this->posts;\n\t}\n\n\t/**\n\t * Set up the amount of found posts and the number of pages (if limit clause was used)\n\t * for the current query.\n\t *\n\t * @since 3.5.0\n\t *\n\t * @param array  $q      Query variables.\n\t * @param string $limits LIMIT clauses of the query.\n\t */\n\tprivate function set_found_posts( $q, $limits ) {\n\t\tglobal $wpdb;\n\t\t// Bail if posts is an empty array. Continue if posts is an empty string,\n\t\t// null, or false to accommodate caching plugins that fill posts later.\n\t\tif ( $q['no_found_rows'] || ( is_array( $this->posts ) && ! $this->posts ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! empty( $limits ) ) {\n\t\t\t/**\n\t\t\t * Filters the query to run for retrieving the found posts.\n\t\t\t *\n\t\t\t * @since 2.1.0\n\t\t\t *\n\t\t\t * @param string   $found_posts The query to run to find the found posts.\n\t\t\t * @param WP_Query $this        The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$this->found_posts = $wpdb->get_var( apply_filters_ref_array( 'found_posts_query', array( 'SELECT FOUND_ROWS()', &$this ) ) );\n\t\t} else {\n\t\t\tif ( is_array( $this->posts ) ) {\n\t\t\t\t$this->found_posts = count( $this->posts );\n\t\t\t} else {\n\t\t\t\tif ( null === $this->posts ) {\n\t\t\t\t\t$this->found_posts = 0;\n\t\t\t\t} else {\n\t\t\t\t\t$this->found_posts = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Filters the number of found posts for the query.\n\t\t *\n\t\t * @since 2.1.0\n\t\t *\n\t\t * @param int      $found_posts The number of posts found.\n\t\t * @param WP_Query $this        The WP_Query instance (passed by reference).\n\t\t */\n\t\t$this->found_posts = apply_filters_ref_array( 'found_posts', array( $this->found_posts, &$this ) );\n\n\t\tif ( ! empty( $limits ) ) {\n\t\t\t$this->max_num_pages = ceil( $this->found_posts / $q['posts_per_page'] );\n\t\t}\n\t}\n\n\t/**\n\t * Set up the next post and iterate current post index.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @return WP_Post Next post.\n\t */\n\tpublic function next_post() {\n\n\t\t$this->current_post++;\n\n\t\t$this->post = $this->posts[ $this->current_post ];\n\t\treturn $this->post;\n\t}\n\n\t/**\n\t * Sets up the current post.\n\t *\n\t * Retrieves the next post, sets up the post, sets the 'in the loop'\n\t * property to true.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @global WP_Post $post\n\t */\n\tpublic function the_post() {\n\t\tglobal $post;\n\t\t$this->in_the_loop = true;\n\n\t\tif ( $this->current_post == -1 ) { // loop has just started\n\t\t\t/**\n\t\t\t * Fires once the loop is started.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\tdo_action_ref_array( 'loop_start', array( &$this ) );\n\t\t}\n\n\t\t$post = $this->next_post();\n\t\t$this->setup_postdata( $post );\n\t}\n\n\t/**\n\t * Determines whether there are more posts available in the loop.\n\t *\n\t * Calls the {@see 'loop_end'} action when the loop is complete.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @return bool True if posts are available, false if end of loop.\n\t */\n\tpublic function have_posts() {\n\t\tif ( $this->current_post + 1 < $this->post_count ) {\n\t\t\treturn true;\n\t\t} elseif ( $this->current_post + 1 == $this->post_count && $this->post_count > 0 ) {\n\t\t\t/**\n\t\t\t * Fires once the loop has ended.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\tdo_action_ref_array( 'loop_end', array( &$this ) );\n\t\t\t// Do some cleaning up after the loop\n\t\t\t$this->rewind_posts();\n\t\t} elseif ( 0 === $this->post_count ) {\n\t\t\t/**\n\t\t\t * Fires if no results are found in a post query.\n\t\t\t *\n\t\t\t * @since 4.9.0\n\t\t\t *\n\t\t\t * @param WP_Query $this The WP_Query instance.\n\t\t\t */\n\t\t\tdo_action( 'loop_no_results', $this );\n\t\t}\n\n\t\t$this->in_the_loop = false;\n\t\treturn false;\n\t}\n\n\t/**\n\t * Rewind the posts and reset post index.\n\t *\n\t * @since 1.5.0\n\t */\n\tpublic function rewind_posts() {\n\t\t$this->current_post = -1;\n\t\tif ( $this->post_count > 0 ) {\n\t\t\t$this->post = $this->posts[0];\n\t\t}\n\t}\n\n\t/**\n\t * Iterate current comment index and return WP_Comment object.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @return WP_Comment Comment object.\n\t */\n\tpublic function next_comment() {\n\t\t$this->current_comment++;\n\n\t\t$this->comment = $this->comments[ $this->current_comment ];\n\t\treturn $this->comment;\n\t}\n\n\t/**\n\t * Sets up the current comment.\n\t *\n\t * @since 2.2.0\n\t * @global WP_Comment $comment Current comment.\n\t */\n\tpublic function the_comment() {\n\t\tglobal $comment;\n\n\t\t$comment = $this->next_comment();\n\n\t\tif ( $this->current_comment == 0 ) {\n\t\t\t/**\n\t\t\t * Fires once the comment loop is started.\n\t\t\t *\n\t\t\t * @since 2.2.0\n\t\t\t */\n\t\t\tdo_action( 'comment_loop_start' );\n\t\t}\n\t}\n\n\t/**\n\t * Whether there are more comments available.\n\t *\n\t * Automatically rewinds comments when finished.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @return bool True, if more comments. False, if no more posts.\n\t */\n\tpublic function have_comments() {\n\t\tif ( $this->current_comment + 1 < $this->comment_count ) {\n\t\t\treturn true;\n\t\t} elseif ( $this->current_comment + 1 == $this->comment_count ) {\n\t\t\t$this->rewind_comments();\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Rewind the comments, resets the comment index and comment to first.\n\t *\n\t * @since 2.2.0\n\t */\n\tpublic function rewind_comments() {\n\t\t$this->current_comment = -1;\n\t\tif ( $this->comment_count > 0 ) {\n\t\t\t$this->comment = $this->comments[0];\n\t\t}\n\t}\n\n\t/**\n\t * Sets up the WordPress query by parsing query string.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param string|array $query URL query string or array of query arguments.\n\t * @return WP_Post[]|int[] Array of post objects or post IDs.\n\t */\n\tpublic function query( $query ) {\n\t\t$this->init();\n\t\t$this->query = $this->query_vars = wp_parse_args( $query );\n\t\treturn $this->get_posts();\n\t}\n\n\t/**\n\t * Retrieve queried object.\n\t *\n\t * If queried object is not set, then the queried object will be set from\n\t * the category, tag, taxonomy, posts page, single post, page, or author\n\t * query variable. After it is set up, it will be returned.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @return object\n\t */\n\tpublic function get_queried_object() {\n\t\tif ( isset( $this->queried_object ) ) {\n\t\t\treturn $this->queried_object;\n\t\t}\n\n\t\t$this->queried_object    = null;\n\t\t$this->queried_object_id = null;\n\n\t\tif ( $this->is_category || $this->is_tag || $this->is_tax ) {\n\t\t\tif ( $this->is_category ) {\n\t\t\t\tif ( $this->get( 'cat' ) ) {\n\t\t\t\t\t$term = get_term( $this->get( 'cat' ), 'category' );\n\t\t\t\t} elseif ( $this->get( 'category_name' ) ) {\n\t\t\t\t\t$term = get_term_by( 'slug', $this->get( 'category_name' ), 'category' );\n\t\t\t\t}\n\t\t\t} elseif ( $this->is_tag ) {\n\t\t\t\tif ( $this->get( 'tag_id' ) ) {\n\t\t\t\t\t$term = get_term( $this->get( 'tag_id' ), 'post_tag' );\n\t\t\t\t} elseif ( $this->get( 'tag' ) ) {\n\t\t\t\t\t$term = get_term_by( 'slug', $this->get( 'tag' ), 'post_tag' );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// For other tax queries, grab the first term from the first clause.\n\t\t\t\tif ( ! empty( $this->tax_query->queried_terms ) ) {\n\t\t\t\t\t$queried_taxonomies = array_keys( $this->tax_query->queried_terms );\n\t\t\t\t\t$matched_taxonomy   = reset( $queried_taxonomies );\n\t\t\t\t\t$query              = $this->tax_query->queried_terms[ $matched_taxonomy ];\n\n\t\t\t\t\tif ( ! empty( $query['terms'] ) ) {\n\t\t\t\t\t\tif ( 'term_id' == $query['field'] ) {\n\t\t\t\t\t\t\t$term = get_term( reset( $query['terms'] ), $matched_taxonomy );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$term = get_term_by( $query['field'], reset( $query['terms'] ), $matched_taxonomy );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ! empty( $term ) && ! is_wp_error( $term ) ) {\n\t\t\t\t$this->queried_object    = $term;\n\t\t\t\t$this->queried_object_id = (int) $term->term_id;\n\n\t\t\t\tif ( $this->is_category && 'category' === $this->queried_object->taxonomy ) {\n\t\t\t\t\t_make_cat_compat( $this->queried_object );\n\t\t\t\t}\n\t\t\t}\n\t\t} elseif ( $this->is_post_type_archive ) {\n\t\t\t$post_type = $this->get( 'post_type' );\n\t\t\tif ( is_array( $post_type ) ) {\n\t\t\t\t$post_type = reset( $post_type );\n\t\t\t}\n\t\t\t$this->queried_object = get_post_type_object( $post_type );\n\t\t} elseif ( $this->is_posts_page ) {\n\t\t\t$page_for_posts          = get_option( 'page_for_posts' );\n\t\t\t$this->queried_object    = get_post( $page_for_posts );\n\t\t\t$this->queried_object_id = (int) $this->queried_object->ID;\n\t\t} elseif ( $this->is_singular && ! empty( $this->post ) ) {\n\t\t\t$this->queried_object    = $this->post;\n\t\t\t$this->queried_object_id = (int) $this->post->ID;\n\t\t} elseif ( $this->is_author ) {\n\t\t\t$this->queried_object_id = (int) $this->get( 'author' );\n\t\t\t$this->queried_object    = get_userdata( $this->queried_object_id );\n\t\t}\n\n\t\treturn $this->queried_object;\n\t}\n\n\t/**\n\t * Retrieve ID of the current queried object.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @return int\n\t */\n\tpublic function get_queried_object_id() {\n\t\t$this->get_queried_object();\n\n\t\tif ( isset( $this->queried_object_id ) ) {\n\t\t\treturn $this->queried_object_id;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Constructor.\n\t *\n\t * Sets up the WordPress query, if parameter is not empty.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param string|array $query URL query string or array of vars.\n\t */\n\tpublic function __construct( $query = '' ) {\n\t\tif ( ! empty( $query ) ) {\n\t\t\t$this->query( $query );\n\t\t}\n\t}\n\n\t/**\n\t * Make private properties readable for backward compatibility.\n\t *\n\t * @since 4.0.0\n\t *\n\t * @param string $name Property to get.\n\t * @return mixed Property.\n\t */\n\tpublic function __get( $name ) {\n\t\tif ( in_array( $name, $this->compat_fields ) ) {\n\t\t\treturn $this->$name;\n\t\t}\n\t}\n\n\t/**\n\t * Make private properties checkable for backward compatibility.\n\t *\n\t * @since 4.0.0\n\t *\n\t * @param string $name Property to check if set.\n\t * @return bool Whether the property is set.\n\t */\n\tpublic function __isset( $name ) {\n\t\tif ( in_array( $name, $this->compat_fields ) ) {\n\t\t\treturn isset( $this->$name );\n\t\t}\n\t}\n\n\t/**\n\t * Make private/protected methods readable for backward compatibility.\n\t *\n\t * @since 4.0.0\n\t *\n\t * @param string   $name      Method to call.\n\t * @param array    $arguments Arguments to pass when calling.\n\t * @return mixed|false Return value of the callback, false otherwise.\n\t */\n\tpublic function __call( $name, $arguments ) {\n\t\tif ( in_array( $name, $this->compat_methods ) ) {\n\t\t\treturn call_user_func_array( array( $this, $name ), $arguments );\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing archive page?\n\t *\n\t * Month, Year, Category, Author, Post Type archive...\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_archive() {\n\t\treturn (bool) $this->is_archive;\n\t}\n\n\t/**\n\t * Is the query for an existing post type archive page?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $post_types Optional. Post type or array of posts types to check against.\n\t * @return bool\n\t */\n\tpublic function is_post_type_archive( $post_types = '' ) {\n\t\tif ( empty( $post_types ) || ! $this->is_post_type_archive ) {\n\t\t\treturn (bool) $this->is_post_type_archive;\n\t\t}\n\n\t\t$post_type = $this->get( 'post_type' );\n\t\tif ( is_array( $post_type ) ) {\n\t\t\t$post_type = reset( $post_type );\n\t\t}\n\t\t$post_type_object = get_post_type_object( $post_type );\n\n\t\treturn in_array( $post_type_object->name, (array) $post_types );\n\t}\n\n\t/**\n\t * Is the query for an existing attachment page?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $attachment Attachment ID, title, slug, or array of such.\n\t * @return bool\n\t */\n\tpublic function is_attachment( $attachment = '' ) {\n\t\tif ( ! $this->is_attachment ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $attachment ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$attachment = array_map( 'strval', (array) $attachment );\n\n\t\t$post_obj = $this->get_queried_object();\n\n\t\tif ( in_array( (string) $post_obj->ID, $attachment ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $post_obj->post_title, $attachment ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $post_obj->post_name, $attachment ) ) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing author archive page?\n\t *\n\t * If the $author parameter is specified, this function will additionally\n\t * check if the query is for one of the authors specified.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $author Optional. User ID, nickname, nicename, or array of User IDs, nicknames, and nicenames\n\t * @return bool\n\t */\n\tpublic function is_author( $author = '' ) {\n\t\tif ( ! $this->is_author ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $author ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$author_obj = $this->get_queried_object();\n\n\t\t$author = array_map( 'strval', (array) $author );\n\n\t\tif ( in_array( (string) $author_obj->ID, $author ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $author_obj->nickname, $author ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $author_obj->user_nicename, $author ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing category archive page?\n\t *\n\t * If the $category parameter is specified, this function will additionally\n\t * check if the query is for one of the categories specified.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $category Optional. Category ID, name, slug, or array of Category IDs, names, and slugs.\n\t * @return bool\n\t */\n\tpublic function is_category( $category = '' ) {\n\t\tif ( ! $this->is_category ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $category ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$cat_obj = $this->get_queried_object();\n\n\t\t$category = array_map( 'strval', (array) $category );\n\n\t\tif ( in_array( (string) $cat_obj->term_id, $category ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $cat_obj->name, $category ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $cat_obj->slug, $category ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing tag archive page?\n\t *\n\t * If the $tag parameter is specified, this function will additionally\n\t * check if the query is for one of the tags specified.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $tag Optional. Tag ID, name, slug, or array of Tag IDs, names, and slugs.\n\t * @return bool\n\t */\n\tpublic function is_tag( $tag = '' ) {\n\t\tif ( ! $this->is_tag ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $tag ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$tag_obj = $this->get_queried_object();\n\n\t\t$tag = array_map( 'strval', (array) $tag );\n\n\t\tif ( in_array( (string) $tag_obj->term_id, $tag ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $tag_obj->name, $tag ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $tag_obj->slug, $tag ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing custom taxonomy archive page?\n\t *\n\t * If the $taxonomy parameter is specified, this function will additionally\n\t * check if the query is for that specific $taxonomy.\n\t *\n\t * If the $term parameter is specified in addition to the $taxonomy parameter,\n\t * this function will additionally check if the query is for one of the terms\n\t * specified.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @global array $wp_taxonomies\n\t *\n\t * @param mixed $taxonomy Optional. Taxonomy slug or slugs.\n\t * @param mixed $term     Optional. Term ID, name, slug or array of Term IDs, names, and slugs.\n\t * @return bool True for custom taxonomy archive pages, false for built-in taxonomies (category and tag archives).\n\t */\n\tpublic function is_tax( $taxonomy = '', $term = '' ) {\n\t\tglobal $wp_taxonomies;\n\n\t\tif ( ! $this->is_tax ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $taxonomy ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$queried_object = $this->get_queried_object();\n\t\t$tax_array      = array_intersect( array_keys( $wp_taxonomies ), (array) $taxonomy );\n\t\t$term_array     = (array) $term;\n\n\t\t// Check that the taxonomy matches.\n\t\tif ( ! ( isset( $queried_object->taxonomy ) && count( $tax_array ) && in_array( $queried_object->taxonomy, $tax_array ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Only a Taxonomy provided.\n\t\tif ( empty( $term ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn isset( $queried_object->term_id ) &&\n\t\t\tcount(\n\t\t\t\tarray_intersect(\n\t\t\t\t\tarray( $queried_object->term_id, $queried_object->name, $queried_object->slug ),\n\t\t\t\t\t$term_array\n\t\t\t\t)\n\t\t\t);\n\t}\n\n\t/**\n\t * Whether the current URL is within the comments popup window.\n\t *\n\t * @since 3.1.0\n\t * @deprecated 4.5.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_comments_popup() {\n\t\t_deprecated_function( __FUNCTION__, '4.5.0' );\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing date archive?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_date() {\n\t\treturn (bool) $this->is_date;\n\t}\n\n\t/**\n\t * Is the query for an existing day archive?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_day() {\n\t\treturn (bool) $this->is_day;\n\t}\n\n\t/**\n\t * Is the query for a feed?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param string|array $feeds Optional feed types to check.\n\t * @return bool\n\t */\n\tpublic function is_feed( $feeds = '' ) {\n\t\tif ( empty( $feeds ) || ! $this->is_feed ) {\n\t\t\treturn (bool) $this->is_feed;\n\t\t}\n\t\t$qv = $this->get( 'feed' );\n\t\tif ( 'feed' == $qv ) {\n\t\t\t$qv = get_default_feed();\n\t\t}\n\t\treturn in_array( $qv, (array) $feeds );\n\t}\n\n\t/**\n\t * Is the query for a comments feed?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_comment_feed() {\n\t\treturn (bool) $this->is_comment_feed;\n\t}\n\n\t/**\n\t * Is the query for the front page of the site?\n\t *\n\t * This is for what is displayed at your site's main URL.\n\t *\n\t * Depends on the site's \"Front page displays\" Reading Settings 'show_on_front' and 'page_on_front'.\n\t *\n\t * If you set a static page for the front page of your site, this function will return\n\t * true when viewing that page.\n\t *\n\t * Otherwise the same as @see WP_Query::is_home()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool True, if front of site.\n\t */\n\tpublic function is_front_page() {\n\t\t// most likely case\n\t\tif ( 'posts' == get_option( 'show_on_front' ) && $this->is_home() ) {\n\t\t\treturn true;\n\t\t} elseif ( 'page' == get_option( 'show_on_front' ) && get_option( 'page_on_front' ) && $this->is_page( get_option( 'page_on_front' ) ) ) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Is the query for the blog homepage?\n\t *\n\t * This is the page which shows the time based blog content of your site.\n\t *\n\t * Depends on the site's \"Front page displays\" Reading Settings 'show_on_front' and 'page_for_posts'.\n\t *\n\t * If you set a static page for the front page of your site, this function will return\n\t * true only on the page you set as the \"Posts page\".\n\t *\n\t * @see WP_Query::is_front_page()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool True if blog view homepage.\n\t */\n\tpublic function is_home() {\n\t\treturn (bool) $this->is_home;\n\t}\n\n\t/**\n\t * Is the query for the Privacy Policy page?\n\t *\n\t * This is the page which shows the Privacy Policy content of your site.\n\t *\n\t * Depends on the site's \"Change your Privacy Policy page\" Privacy Settings 'wp_page_for_privacy_policy'.\n\t *\n\t * This function will return true only on the page you set as the \"Privacy Policy page\".\n\t *\n\t * @since 5.2.0\n\t *\n\t * @return bool True, if Privacy Policy page.\n\t */\n\tpublic function is_privacy_policy() {\n\t\tif ( get_option( 'wp_page_for_privacy_policy' ) && $this->is_page( get_option( 'wp_page_for_privacy_policy' ) ) ) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Is the query for an existing month archive?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_month() {\n\t\treturn (bool) $this->is_month;\n\t}\n\n\t/**\n\t * Is the query for an existing single page?\n\t *\n\t * If the $page parameter is specified, this function will additionally\n\t * check if the query is for one of the pages specified.\n\t *\n\t * @see WP_Query::is_single()\n\t * @see WP_Query::is_singular()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param int|string|array $page Optional. Page ID, title, slug, path, or array of such. Default empty.\n\t * @return bool Whether the query is for an existing single page.\n\t */\n\tpublic function is_page( $page = '' ) {\n\t\tif ( ! $this->is_page ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $page ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$page_obj = $this->get_queried_object();\n\n\t\t$page = array_map( 'strval', (array) $page );\n\n\t\tif ( in_array( (string) $page_obj->ID, $page ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $page_obj->post_title, $page ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $page_obj->post_name, $page ) ) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tforeach ( $page as $pagepath ) {\n\t\t\t\tif ( ! strpos( $pagepath, '/' ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t$pagepath_obj = get_page_by_path( $pagepath );\n\n\t\t\t\tif ( $pagepath_obj && ( $pagepath_obj->ID == $page_obj->ID ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for paged result and not for the first page?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_paged() {\n\t\treturn (bool) $this->is_paged;\n\t}\n\n\t/**\n\t * Is the query for a post or page preview?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_preview() {\n\t\treturn (bool) $this->is_preview;\n\t}\n\n\t/**\n\t * Is the query for the robots file?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_robots() {\n\t\treturn (bool) $this->is_robots;\n\t}\n\n\t/**\n\t * Is the query for a search?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_search() {\n\t\treturn (bool) $this->is_search;\n\t}\n\n\t/**\n\t * Is the query for an existing single post?\n\t *\n\t * Works for any post type excluding pages.\n\t *\n\t * If the $post parameter is specified, this function will additionally\n\t * check if the query is for one of the Posts specified.\n\t *\n\t * @see WP_Query::is_page()\n\t * @see WP_Query::is_singular()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param int|string|array $post Optional. Post ID, title, slug, path, or array of such. Default empty.\n\t * @return bool Whether the query is for an existing single post.\n\t */\n\tpublic function is_single( $post = '' ) {\n\t\tif ( ! $this->is_single ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $post ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$post_obj = $this->get_queried_object();\n\n\t\t$post = array_map( 'strval', (array) $post );\n\n\t\tif ( in_array( (string) $post_obj->ID, $post ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $post_obj->post_title, $post ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $post_obj->post_name, $post ) ) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tforeach ( $post as $postpath ) {\n\t\t\t\tif ( ! strpos( $postpath, '/' ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t$postpath_obj = get_page_by_path( $postpath, OBJECT, $post_obj->post_type );\n\n\t\t\t\tif ( $postpath_obj && ( $postpath_obj->ID == $post_obj->ID ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing single post of any post type (post, attachment, page,\n\t * custom post types)?\n\t *\n\t * If the $post_types parameter is specified, this function will additionally\n\t * check if the query is for one of the Posts Types specified.\n\t *\n\t * @see WP_Query::is_page()\n\t * @see WP_Query::is_single()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param string|array $post_types Optional. Post type or array of post types. Default empty.\n\t * @return bool Whether the query is for an existing single post of any of the given post types.\n\t */\n\tpublic function is_singular( $post_types = '' ) {\n\t\tif ( empty( $post_types ) || ! $this->is_singular ) {\n\t\t\treturn (bool) $this->is_singular;\n\t\t}\n\n\t\t$post_obj = $this->get_queried_object();\n\n\t\treturn in_array( $post_obj->post_type, (array) $post_types );\n\t}\n\n\t/**\n\t * Is the query for a specific time?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_time() {\n\t\treturn (bool) $this->is_time;\n\t}\n\n\t/**\n\t * Is the query for a trackback endpoint call?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_trackback() {\n\t\treturn (bool) $this->is_trackback;\n\t}\n\n\t/**\n\t * Is the query for an existing year archive?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_year() {\n\t\treturn (bool) $this->is_year;\n\t}\n\n\t/**\n\t * Is the query a 404 (returns no results)?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_404() {\n\t\treturn (bool) $this->is_404;\n\t}\n\n\t/**\n\t * Is the query for an embedded post?\n\t *\n\t * @since 4.4.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_embed() {\n\t\treturn (bool) $this->is_embed;\n\t}\n\n\t/**\n\t * Is the query the main query?\n\t *\n\t * @since 3.3.0\n\t *\n\t * @global WP_Query $wp_query Global WP_Query instance.\n\t *\n\t * @return bool\n\t */\n\tpublic function is_main_query() {\n\t\tglobal $wp_the_query;\n\t\treturn $wp_the_query === $this;\n\t}\n\n\t/**\n\t * Set up global post data.\n\t *\n\t * @since 4.1.0\n\t * @since 4.4.0 Added the ability to pass a post ID to `$post`.\n\t *\n\t * @global int             $id\n\t * @global WP_User         $authordata\n\t * @global string|int|bool $currentday\n\t * @global string|int|bool $currentmonth\n\t * @global int             $page\n\t * @global array           $pages\n\t * @global int             $multipage\n\t * @global int             $more\n\t * @global int             $numpages\n\t *\n\t * @param WP_Post|object|int $post WP_Post instance or Post ID/object.\n\t * @return true True when finished.\n\t */\n\tpublic function setup_postdata( $post ) {\n\t\tglobal $id, $authordata, $currentday, $currentmonth, $page, $pages, $multipage, $more, $numpages;\n\n\t\tif ( ! ( $post instanceof WP_Post ) ) {\n\t\t\t$post = get_post( $post );\n\t\t}\n\n\t\tif ( ! $post ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$elements = $this->generate_postdata( $post );\n\t\tif ( false === $elements ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$id           = $elements['id'];\n\t\t$authordata   = $elements['authordata'];\n\t\t$currentday   = $elements['currentday'];\n\t\t$currentmonth = $elements['currentmonth'];\n\t\t$page         = $elements['page'];\n\t\t$pages        = $elements['pages'];\n\t\t$multipage    = $elements['multipage'];\n\t\t$more         = $elements['more'];\n\t\t$numpages     = $elements['numpages'];\n\n\t\t/**\n\t\t * Fires once the post data has been setup.\n\t\t *\n\t\t * @since 2.8.0\n\t\t * @since 4.1.0 Introduced `$this` parameter.\n\t\t *\n\t\t * @param WP_Post  $post The Post object (passed by reference).\n\t\t * @param WP_Query $this The current Query object (passed by reference).\n\t\t */\n\t\tdo_action_ref_array( 'the_post', array( &$post, &$this ) );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Generate post data.\n\t *\n\t * @since 5.2.0\n\t *\n\t * @param WP_Post|object|int $post WP_Post instance or Post ID/object.\n\t * @return array|bool $elements Elements of post or false on failure.\n\t */\n\tpublic function generate_postdata( $post ) {\n\n\t\tif ( ! ( $post instanceof WP_Post ) ) {\n\t\t\t$post = get_post( $post );\n\t\t}\n\n\t\tif ( ! $post ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$id = (int) $post->ID;\n\n\t\t$authordata = get_userdata( $post->post_author );\n\n\t\t$currentday   = mysql2date( 'd.m.y', $post->post_date, false );\n\t\t$currentmonth = mysql2date( 'm', $post->post_date, false );\n\t\t$numpages     = 1;\n\t\t$multipage    = 0;\n\t\t$page         = $this->get( 'page' );\n\t\tif ( ! $page ) {\n\t\t\t$page = 1;\n\t\t}\n\n\t\t/*\n\t\t * Force full post content when viewing the permalink for the $post,\n\t\t * or when on an RSS feed. Otherwise respect the 'more' tag.\n\t\t */\n\t\tif ( $post->ID === get_queried_object_id() && ( $this->is_page() || $this->is_single() ) ) {\n\t\t\t$more = 1;\n\t\t} elseif ( $this->is_feed() ) {\n\t\t\t$more = 1;\n\t\t} else {\n\t\t\t$more = 0;\n\t\t}\n\n\t\t$content = $post->post_content;\n\t\tif ( false !== strpos( $content, '<!--nextpage-->' ) ) {\n\t\t\t$content = str_replace( \"\\n<!--nextpage-->\\n\", '<!--nextpage-->', $content );\n\t\t\t$content = str_replace( \"\\n<!--nextpage-->\", '<!--nextpage-->', $content );\n\t\t\t$content = str_replace( \"<!--nextpage-->\\n\", '<!--nextpage-->', $content );\n\n\t\t\t// Remove the nextpage block delimiters, to avoid invalid block structures in the split content.\n\t\t\t$content = str_replace( '<!-- wp:nextpage -->', '', $content );\n\t\t\t$content = str_replace( '<!-- /wp:nextpage -->', '', $content );\n\n\t\t\t// Ignore nextpage at the beginning of the content.\n\t\t\tif ( 0 === strpos( $content, '<!--nextpage-->' ) ) {\n\t\t\t\t$content = substr( $content, 15 );\n\t\t\t}\n\n\t\t\t$pages = explode( '<!--nextpage-->', $content );\n\t\t} else {\n\t\t\t$pages = array( $post->post_content );\n\t\t}\n\n\t\t/**\n\t\t * Filters the \"pages\" derived from splitting the post content.\n\t\t *\n\t\t * \"Pages\" are determined by splitting the post content based on the presence\n\t\t * of `<!-- nextpage -->` tags.\n\t\t *\n\t\t * @since 4.4.0\n\t\t *\n\t\t * @param string[] $pages Array of \"pages\" from the post content split by `<!-- nextpage -->` tags.\n\t\t * @param WP_Post  $post  Current post object.\n\t\t */\n\t\t$pages = apply_filters( 'content_pagination', $pages, $post );\n\n\t\t$numpages = count( $pages );\n\n\t\tif ( $numpages > 1 ) {\n\t\t\tif ( $page > 1 ) {\n\t\t\t\t$more = 1;\n\t\t\t}\n\t\t\t$multipage = 1;\n\t\t} else {\n\t\t\t$multipage = 0;\n\t\t}\n\n\t\t$elements = compact( 'id', 'authordata', 'currentday', 'currentmonth', 'page', 'pages', 'multipage', 'more', 'numpages' );\n\n\t\treturn $elements;\n\t}\n\t/**\n\t * After looping through a nested query, this function\n\t * restores the $post global to the current post in this query.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @global WP_Post $post\n\t */\n\tpublic function reset_postdata() {\n\t\tif ( ! empty( $this->post ) ) {\n\t\t\t$GLOBALS['post'] = $this->post;\n\t\t\t$this->setup_postdata( $this->post );\n\t\t}\n\t}\n\n\t/**\n\t * Lazyload term meta for posts in the loop.\n\t *\n\t * @since 4.4.0\n\t * @deprecated 4.5.0 See wp_queue_posts_for_term_meta_lazyload().\n\t *\n\t * @param mixed $check\n\t * @param int   $term_id\n\t * @return mixed\n\t */\n\tpublic function lazyload_term_meta( $check, $term_id ) {\n\t\t_deprecated_function( __METHOD__, '4.5.0' );\n\t\treturn $check;\n\t}\n\n\t/**\n\t * Lazyload comment meta for comments in the loop.\n\t *\n\t * @since 4.4.0\n\t * @deprecated 4.5.0 See wp_queue_comments_for_comment_meta_lazyload().\n\t *\n\t * @param mixed $check\n\t * @param int   $comment_id\n\t * @return mixed\n\t */\n\tpublic function lazyload_comment_meta( $check, $comment_id ) {\n\t\t_deprecated_function( __METHOD__, '4.5.0' );\n\t\treturn $check;\n\t}\n}\n", "<?php\n/**\n * WordPress environment setup class.\n *\n * @package WordPress\n * @since 2.0.0\n */\nclass WP {\n\t/**\n\t * Public query variables.\n\t *\n\t * Long list of public query variables.\n\t *\n\t * @since 2.0.0\n\t * @var string[]\n\t */\n\tpublic $public_query_vars = array( 'm', 'p', 'posts', 'w', 'cat', 'withcomments', 'withoutcomments', 's', 'search', 'exact', 'sentence', 'calendar', 'page', 'paged', 'more', 'tb', 'pb', 'author', 'order', 'orderby', 'year', 'monthnum', 'day', 'hour', 'minute', 'second', 'name', 'category_name', 'tag', 'feed', 'author_name', 'static', 'pagename', 'page_id', 'error', 'attachment', 'attachment_id', 'subpost', 'subpost_id', 'preview', 'robots', 'taxonomy', 'term', 'cpage', 'post_type', 'embed' );\n\n\t/**\n\t * Private query variables.\n\t *\n\t * Long list of private query variables.\n\t *\n\t * @since 2.0.0\n\t * @var string[]\n\t */\n\tpublic $private_query_vars = array( 'offset', 'posts_per_page', 'posts_per_archive_page', 'showposts', 'nopaging', 'post_type', 'post_status', 'category__in', 'category__not_in', 'category__and', 'tag__in', 'tag__not_in', 'tag__and', 'tag_slug__in', 'tag_slug__and', 'tag_id', 'post_mime_type', 'perm', 'comments_per_page', 'post__in', 'post__not_in', 'post_parent', 'post_parent__in', 'post_parent__not_in', 'title', 'fields' );\n\n\t/**\n\t * Extra query variables set by the user.\n\t *\n\t * @since 2.1.0\n\t * @var array\n\t */\n\tpublic $extra_query_vars = array();\n\n\t/**\n\t * Query variables for setting up the WordPress Query Loop.\n\t *\n\t * @since 2.0.0\n\t * @var array\n\t */\n\tpublic $query_vars;\n\n\t/**\n\t * String parsed to set the query variables.\n\t *\n\t * @since 2.0.0\n\t * @var string\n\t */\n\tpublic $query_string;\n\n\t/**\n\t * The request path, e.g. 2015/05/06.\n\t *\n\t * @since 2.0.0\n\t * @var string\n\t */\n\tpublic $request;\n\n\t/**\n\t * Rewrite rule the request matched.\n\t *\n\t * @since 2.0.0\n\t * @var string\n\t */\n\tpublic $matched_rule;\n\n\t/**\n\t * Rewrite query the request matched.\n\t *\n\t * @since 2.0.0\n\t * @var string\n\t */\n\tpublic $matched_query;\n\n\t/**\n\t * Whether already did the permalink.\n\t *\n\t * @since 2.0.0\n\t * @var bool\n\t */\n\tpublic $did_permalink = false;\n\n\t/**\n\t * Add name to list of public query variables.\n\t *\n\t * @since 2.1.0\n\t *\n\t * @param string $qv Query variable name.\n\t */\n\tpublic function add_query_var( $qv ) {\n\t\tif ( ! in_array( $qv, $this->public_query_vars ) ) {\n\t\t\t$this->public_query_vars[] = $qv;\n\t\t}\n\t}\n\n\t/**\n\t * Removes a query variable from a list of public query variables.\n\t *\n\t * @since 4.5.0\n\t *\n\t * @param string $name Query variable name.\n\t */\n\tpublic function remove_query_var( $name ) {\n\t\t$this->public_query_vars = array_diff( $this->public_query_vars, array( $name ) );\n\t}\n\n\t/**\n\t * Set the value of a query variable.\n\t *\n\t * @since 2.3.0\n\t *\n\t * @param string $key Query variable name.\n\t * @param mixed $value Query variable value.\n\t */\n\tpublic function set_query_var( $key, $value ) {\n\t\t$this->query_vars[ $key ] = $value;\n\t}\n\n\t/**\n\t * Parse request to find correct WordPress query.\n\t *\n\t * Sets up the query variables based on the request. There are also many\n\t * filters and actions that can be used to further manipulate the result.\n\t *\n\t * @since 2.0.0\n\t *\n\t * @global WP_Rewrite $wp_rewrite\n\t *\n\t * @param array|string $extra_query_vars Set the extra query variables.\n\t */\n\tpublic function parse_request( $extra_query_vars = '' ) {\n\t\tglobal $wp_rewrite;\n\n\t\t/**\n\t\t * Filters whether to parse the request.\n\t\t *\n\t\t * @since 3.5.0\n\t\t *\n\t\t * @param bool         $bool             Whether or not to parse the request. Default true.\n\t\t * @param WP           $this             Current WordPress environment instance.\n\t\t * @param array|string $extra_query_vars Extra passed query variables.\n\t\t */\n\t\tif ( ! apply_filters( 'do_parse_request', true, $this, $extra_query_vars ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$this->query_vars     = array();\n\t\t$post_type_query_vars = array();\n\n\t\tif ( is_array( $extra_query_vars ) ) {\n\t\t\t$this->extra_query_vars = & $extra_query_vars;\n\t\t} elseif ( ! empty( $extra_query_vars ) ) {\n\t\t\tparse_str( $extra_query_vars, $this->extra_query_vars );\n\t\t}\n\t\t// Process PATH_INFO, REQUEST_URI, and 404 for permalinks.\n\n\t\t// Fetch the rewrite rules.\n\t\t$rewrite = $wp_rewrite->wp_rewrite_rules();\n\n\t\tif ( ! empty( $rewrite ) ) {\n\t\t\t// If we match a rewrite rule, this will be cleared.\n\t\t\t$error               = '404';\n\t\t\t$this->did_permalink = true;\n\n\t\t\t$pathinfo         = isset( $_SERVER['PATH_INFO'] ) ? $_SERVER['PATH_INFO'] : '';\n\t\t\tlist( $pathinfo ) = explode( '?', $pathinfo );\n\t\t\t$pathinfo         = str_replace( '%', '%25', $pathinfo );\n\n\t\t\tlist( $req_uri ) = explode( '?', $_SERVER['REQUEST_URI'] );\n\t\t\t$self            = $_SERVER['PHP_SELF'];\n\t\t\t$home_path       = trim( parse_url( home_url(), PHP_URL_PATH ), '/' );\n\t\t\t$home_path_regex = sprintf( '|^%s|i', preg_quote( $home_path, '|' ) );\n\n\t\t\t// Trim path info from the end and the leading home path from the\n\t\t\t// front. For path info requests, this leaves us with the requesting\n\t\t\t// filename, if any. For 404 requests, this leaves us with the\n\t\t\t// requested permalink.\n\t\t\t$req_uri  = str_replace( $pathinfo, '', $req_uri );\n\t\t\t$req_uri  = trim( $req_uri, '/' );\n\t\t\t$req_uri  = preg_replace( $home_path_regex, '', $req_uri );\n\t\t\t$req_uri  = trim( $req_uri, '/' );\n\t\t\t$pathinfo = trim( $pathinfo, '/' );\n\t\t\t$pathinfo = preg_replace( $home_path_regex, '', $pathinfo );\n\t\t\t$pathinfo = trim( $pathinfo, '/' );\n\t\t\t$self     = trim( $self, '/' );\n\t\t\t$self     = preg_replace( $home_path_regex, '', $self );\n\t\t\t$self     = trim( $self, '/' );\n\n\t\t\t// The requested permalink is in $pathinfo for path info requests and\n\t\t\t//  $req_uri for other requests.\n\t\t\tif ( ! empty( $pathinfo ) && ! preg_match( '|^.*' . $wp_rewrite->index . '$|', $pathinfo ) ) {\n\t\t\t\t$requested_path = $pathinfo;\n\t\t\t} else {\n\t\t\t\t// If the request uri is the index, blank it out so that we don't try to match it against a rule.\n\t\t\t\tif ( $req_uri == $wp_rewrite->index ) {\n\t\t\t\t\t$req_uri = '';\n\t\t\t\t}\n\t\t\t\t$requested_path = $req_uri;\n\t\t\t}\n\t\t\t$requested_file = $req_uri;\n\n\t\t\t$this->request = $requested_path;\n\n\t\t\t// Look for matches.\n\t\t\t$request_match = $requested_path;\n\t\t\tif ( empty( $request_match ) ) {\n\t\t\t\t// An empty request could only match against ^$ regex\n\t\t\t\tif ( isset( $rewrite['$'] ) ) {\n\t\t\t\t\t$this->matched_rule = '$';\n\t\t\t\t\t$query              = $rewrite['$'];\n\t\t\t\t\t$matches            = array( '' );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tforeach ( (array) $rewrite as $match => $query ) {\n\t\t\t\t\t// If the requested file is the anchor of the match, prepend it to the path info.\n\t\t\t\t\tif ( ! empty( $requested_file ) && strpos( $match, $requested_file ) === 0 && $requested_file != $requested_path ) {\n\t\t\t\t\t\t$request_match = $requested_file . '/' . $requested_path;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( preg_match( \"#^$match#\", $request_match, $matches ) ||\n\t\t\t\t\t\tpreg_match( \"#^$match#\", urldecode( $request_match ), $matches ) ) {\n\n\t\t\t\t\t\tif ( $wp_rewrite->use_verbose_page_rules && preg_match( '/pagename=\\$matches\\[([0-9]+)\\]/', $query, $varmatch ) ) {\n\t\t\t\t\t\t\t// This is a verbose page match, let's check to be sure about it.\n\t\t\t\t\t\t\t$page = get_page_by_path( $matches[ $varmatch[1] ] );\n\t\t\t\t\t\t\tif ( ! $page ) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t$post_status_obj = get_post_status_object( $page->post_status );\n\t\t\t\t\t\t\tif ( ! $post_status_obj->public && ! $post_status_obj->protected\n\t\t\t\t\t\t\t\t&& ! $post_status_obj->private && $post_status_obj->exclude_from_search ) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Got a match.\n\t\t\t\t\t\t$this->matched_rule = $match;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( isset( $this->matched_rule ) ) {\n\t\t\t\t// Trim the query of everything up to the '?'.\n\t\t\t\t$query = preg_replace( '!^.+\\?!', '', $query );\n\n\t\t\t\t// Substitute the substring matches into the query.\n\t\t\t\t$query = addslashes( WP_MatchesMapRegex::apply( $query, $matches ) );\n\n\t\t\t\t$this->matched_query = $query;\n\n\t\t\t\t// Parse the query.\n\t\t\t\tparse_str( $query, $perma_query_vars );\n\n\t\t\t\t// If we're processing a 404 request, clear the error var since we found something.\n\t\t\t\tif ( '404' == $error ) {\n\t\t\t\t\tunset( $error, $_GET['error'] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If req_uri is empty or if it is a request for ourself, unset error.\n\t\t\tif ( empty( $requested_path ) || $requested_file == $self || strpos( $_SERVER['PHP_SELF'], 'wp-admin/' ) !== false ) {\n\t\t\t\tunset( $error, $_GET['error'] );\n\n\t\t\t\tif ( isset( $perma_query_vars ) && strpos( $_SERVER['PHP_SELF'], 'wp-admin/' ) !== false ) {\n\t\t\t\t\tunset( $perma_query_vars );\n\t\t\t\t}\n\n\t\t\t\t$this->did_permalink = false;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Filters the query variables whitelist before processing.\n\t\t *\n\t\t * Allows (publicly allowed) query vars to be added, removed, or changed prior\n\t\t * to executing the query. Needed to allow custom rewrite rules using your own arguments\n\t\t * to work, or any other custom query variables you want to be publicly available.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param string[] $public_query_vars The array of whitelisted query variable names.\n\t\t */\n\t\t$this->public_query_vars = apply_filters( 'query_vars', $this->public_query_vars );\n\n\t\tforeach ( get_post_types( array(), 'objects' ) as $post_type => $t ) {\n\t\t\tif ( is_post_type_viewable( $t ) && $t->query_var ) {\n\t\t\t\t$post_type_query_vars[ $t->query_var ] = $post_type;\n\t\t\t}\n\t\t}\n\n\t\tforeach ( $this->public_query_vars as $wpvar ) {\n\t\t\tif ( isset( $this->extra_query_vars[ $wpvar ] ) ) {\n\t\t\t\t$this->query_vars[ $wpvar ] = $this->extra_query_vars[ $wpvar ];\n\t\t\t} elseif ( isset( $_GET[ $wpvar ] ) && isset( $_POST[ $wpvar ] ) && $_GET[ $wpvar ] !== $_POST[ $wpvar ] ) {\n\t\t\t\twp_die( __( 'A variable mismatch has been detected.' ), __( 'Sorry, you are not allowed to view this item.' ), 400 );\n\t\t\t} elseif ( isset( $_POST[ $wpvar ] ) ) {\n\t\t\t\t$this->query_vars[ $wpvar ] = $_POST[ $wpvar ];\n\t\t\t} elseif ( isset( $_GET[ $wpvar ] ) ) {\n\t\t\t\t$this->query_vars[ $wpvar ] = $_GET[ $wpvar ];\n\t\t\t} elseif ( isset( $perma_query_vars[ $wpvar ] ) ) {\n\t\t\t\t$this->query_vars[ $wpvar ] = $perma_query_vars[ $wpvar ];\n\t\t\t}\n\n\t\t\tif ( ! empty( $this->query_vars[ $wpvar ] ) ) {\n\t\t\t\tif ( ! is_array( $this->query_vars[ $wpvar ] ) ) {\n\t\t\t\t\t$this->query_vars[ $wpvar ] = (string) $this->query_vars[ $wpvar ];\n\t\t\t\t} else {\n\t\t\t\t\tforeach ( $this->query_vars[ $wpvar ] as $vkey => $v ) {\n\t\t\t\t\t\tif ( is_scalar( $v ) ) {\n\t\t\t\t\t\t\t$this->query_vars[ $wpvar ][ $vkey ] = (string) $v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( isset( $post_type_query_vars[ $wpvar ] ) ) {\n\t\t\t\t\t$this->query_vars['post_type'] = $post_type_query_vars[ $wpvar ];\n\t\t\t\t\t$this->query_vars['name']      = $this->query_vars[ $wpvar ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Convert urldecoded spaces back into +\n\t\tforeach ( get_taxonomies( array(), 'objects' ) as $taxonomy => $t ) {\n\t\t\tif ( $t->query_var && isset( $this->query_vars[ $t->query_var ] ) ) {\n\t\t\t\t$this->query_vars[ $t->query_var ] = str_replace( ' ', '+', $this->query_vars[ $t->query_var ] );\n\t\t\t}\n\t\t}\n\n\t\t// Don't allow non-publicly queryable taxonomies to be queried from the front end.\n\t\tif ( ! is_admin() ) {\n\t\t\tforeach ( get_taxonomies( array( 'publicly_queryable' => false ), 'objects' ) as $taxonomy => $t ) {\n\t\t\t\t/*\n\t\t\t\t * Disallow when set to the 'taxonomy' query var.\n\t\t\t\t * Non-publicly queryable taxonomies cannot register custom query vars. See register_taxonomy().\n\t\t\t\t */\n\t\t\t\tif ( isset( $this->query_vars['taxonomy'] ) && $taxonomy === $this->query_vars['taxonomy'] ) {\n\t\t\t\t\tunset( $this->query_vars['taxonomy'], $this->query_vars['term'] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Limit publicly queried post_types to those that are publicly_queryable\n\t\tif ( isset( $this->query_vars['post_type'] ) ) {\n\t\t\t$queryable_post_types = get_post_types( array( 'publicly_queryable' => true ) );\n\t\t\tif ( ! is_array( $this->query_vars['post_type'] ) ) {\n\t\t\t\tif ( ! in_array( $this->query_vars['post_type'], $queryable_post_types ) ) {\n\t\t\t\t\tunset( $this->query_vars['post_type'] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$this->query_vars['post_type'] = array_intersect( $this->query_vars['post_type'], $queryable_post_types );\n\t\t\t}\n\t\t}\n\n\t\t// Resolve conflicts between posts with numeric slugs and date archive queries.\n\t\t$this->query_vars = wp_resolve_numeric_slug_conflicts( $this->query_vars );\n\n\t\tforeach ( (array) $this->private_query_vars as $var ) {\n\t\t\tif ( isset( $this->extra_query_vars[ $var ] ) ) {\n\t\t\t\t$this->query_vars[ $var ] = $this->extra_query_vars[ $var ];\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $error ) ) {\n\t\t\t$this->query_vars['error'] = $error;\n\t\t}\n\n\t\t/**\n\t\t * Filters the array of parsed query variables.\n\t\t *\n\t\t * @since 2.1.0\n\t\t *\n\t\t * @param array $query_vars The array of requested query variables.\n\t\t */\n\t\t$this->query_vars = apply_filters( 'request', $this->query_vars );\n\n\t\t/**\n\t\t * Fires once all query variables for the current request have been parsed.\n\t\t *\n\t\t * @since 2.1.0\n\t\t *\n\t\t * @param WP $this Current WordPress environment instance (passed by reference).\n\t\t */\n\t\tdo_action_ref_array( 'parse_request', array( &$this ) );\n\t}\n\n\t/**\n\t * Sends additional HTTP headers for caching, content type, etc.\n\t *\n\t * Sets the Content-Type header. Sets the 'error' status (if passed) and optionally exits.\n\t * If showing a feed, it will also send Last-Modified, ETag, and 304 status if needed.\n\t *\n\t * @since 2.0.0\n\t * @since 4.4.0 `X-Pingback` header is added conditionally after posts have been queried in handle_404().\n\t */\n\tpublic function send_headers() {\n\t\t$headers       = array();\n\t\t$status        = null;\n\t\t$exit_required = false;\n\n\t\tif ( is_user_logged_in() ) {\n\t\t\t$headers = array_merge( $headers, wp_get_nocache_headers() );\n\t\t}\n\t\tif ( ! empty( $this->query_vars['error'] ) ) {\n\t\t\t$status = (int) $this->query_vars['error'];\n\t\t\tif ( 404 === $status ) {\n\t\t\t\tif ( ! is_user_logged_in() ) {\n\t\t\t\t\t$headers = array_merge( $headers, wp_get_nocache_headers() );\n\t\t\t\t}\n\t\t\t\t$headers['Content-Type'] = get_option( 'html_type' ) . '; charset=' . get_option( 'blog_charset' );\n\t\t\t} elseif ( in_array( $status, array( 403, 500, 502, 503 ) ) ) {\n\t\t\t\t$exit_required = true;\n\t\t\t}\n\t\t} elseif ( empty( $this->query_vars['feed'] ) ) {\n\t\t\t$headers['Content-Type'] = get_option( 'html_type' ) . '; charset=' . get_option( 'blog_charset' );\n\t\t} else {\n\t\t\t// Set the correct content type for feeds\n\t\t\t$type = $this->query_vars['feed'];\n\t\t\tif ( 'feed' == $this->query_vars['feed'] ) {\n\t\t\t\t$type = get_default_feed();\n\t\t\t}\n\t\t\t$headers['Content-Type'] = feed_content_type( $type ) . '; charset=' . get_option( 'blog_charset' );\n\n\t\t\t// We're showing a feed, so WP is indeed the only thing that last changed.\n\t\t\tif ( ! empty( $this->query_vars['withcomments'] )\n\t\t\t\t|| false !== strpos( $this->query_vars['feed'], 'comments-' )\n\t\t\t\t|| ( empty( $this->query_vars['withoutcomments'] )\n\t\t\t\t\t&& ( ! empty( $this->query_vars['p'] )\n\t\t\t\t\t\t|| ! empty( $this->query_vars['name'] )\n\t\t\t\t\t\t|| ! empty( $this->query_vars['page_id'] )\n\t\t\t\t\t\t|| ! empty( $this->query_vars['pagename'] )\n\t\t\t\t\t\t|| ! empty( $this->query_vars['attachment'] )\n\t\t\t\t\t\t|| ! empty( $this->query_vars['attachment_id'] )\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t$wp_last_modified = mysql2date( 'D, d M Y H:i:s', get_lastcommentmodified( 'GMT' ), false );\n\t\t\t} else {\n\t\t\t\t$wp_last_modified = mysql2date( 'D, d M Y H:i:s', get_lastpostmodified( 'GMT' ), false );\n\t\t\t}\n\n\t\t\tif ( ! $wp_last_modified ) {\n\t\t\t\t$wp_last_modified = date( 'D, d M Y H:i:s' );\n\t\t\t}\n\n\t\t\t$wp_last_modified .= ' GMT';\n\n\t\t\t$wp_etag                  = '\"' . md5( $wp_last_modified ) . '\"';\n\t\t\t$headers['Last-Modified'] = $wp_last_modified;\n\t\t\t$headers['ETag']          = $wp_etag;\n\n\t\t\t// Support for Conditional GET\n\t\t\tif ( isset( $_SERVER['HTTP_IF_NONE_MATCH'] ) ) {\n\t\t\t\t$client_etag = wp_unslash( $_SERVER['HTTP_IF_NONE_MATCH'] );\n\t\t\t} else {\n\t\t\t\t$client_etag = false;\n\t\t\t}\n\n\t\t\t$client_last_modified = empty( $_SERVER['HTTP_IF_MODIFIED_SINCE'] ) ? '' : trim( $_SERVER['HTTP_IF_MODIFIED_SINCE'] );\n\t\t\t// If string is empty, return 0. If not, attempt to parse into a timestamp\n\t\t\t$client_modified_timestamp = $client_last_modified ? strtotime( $client_last_modified ) : 0;\n\n\t\t\t// Make a timestamp for our most recent modification...\n\t\t\t$wp_modified_timestamp = strtotime( $wp_last_modified );\n\n\t\t\tif ( ( $client_last_modified && $client_etag ) ?\n\t\t\t\t\t( ( $client_modified_timestamp >= $wp_modified_timestamp ) && ( $client_etag == $wp_etag ) ) :\n\t\t\t\t\t( ( $client_modified_timestamp >= $wp_modified_timestamp ) || ( $client_etag == $wp_etag ) ) ) {\n\t\t\t\t$status        = 304;\n\t\t\t\t$exit_required = true;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Filters the HTTP headers before they're sent to the browser.\n\t\t *\n\t\t * @since 2.8.0\n\t\t *\n\t\t * @param string[] $headers Associative array of headers to be sent.\n\t\t * @param WP       $this    Current WordPress environment instance.\n\t\t */\n\t\t$headers = apply_filters( 'wp_headers', $headers, $this );\n\n\t\tif ( ! empty( $status ) ) {\n\t\t\tstatus_header( $status );\n\t\t}\n\n\t\t// If Last-Modified is set to false, it should not be sent (no-cache situation).\n\t\tif ( isset( $headers['Last-Modified'] ) && false === $headers['Last-Modified'] ) {\n\t\t\tunset( $headers['Last-Modified'] );\n\n\t\t\t// In PHP 5.3+, make sure we are not sending a Last-Modified header.\n\t\t\tif ( function_exists( 'header_remove' ) ) {\n\t\t\t\t@header_remove( 'Last-Modified' );\n\t\t\t} else {\n\t\t\t\t// In PHP 5.2, send an empty Last-Modified header, but only as a\n\t\t\t\t// last resort to override a header already sent. #WP23021\n\t\t\t\tforeach ( headers_list() as $header ) {\n\t\t\t\t\tif ( 0 === stripos( $header, 'Last-Modified' ) ) {\n\t\t\t\t\t\t$headers['Last-Modified'] = '';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tforeach ( (array) $headers as $name => $field_value ) {\n\t\t\t@header( \"{$name}: {$field_value}\" );\n\t\t}\n\n\t\tif ( $exit_required ) {\n\t\t\texit();\n\t\t}\n\n\t\t/**\n\t\t * Fires once the requested HTTP headers for caching, content type, etc. have been sent.\n\t\t *\n\t\t * @since 2.1.0\n\t\t *\n\t\t * @param WP $this Current WordPress environment instance (passed by reference).\n\t\t */\n\t\tdo_action_ref_array( 'send_headers', array( &$this ) );\n\t}\n\n\t/**\n\t * Sets the query string property based off of the query variable property.\n\t *\n\t * The {@see 'query_string'} filter is deprecated, but still works. Plugins should\n\t * use the {@see 'request'} filter instead.\n\t *\n\t * @since 2.0.0\n\t */\n\tpublic function build_query_string() {\n\t\t$this->query_string = '';\n\t\tforeach ( (array) array_keys( $this->query_vars ) as $wpvar ) {\n\t\t\tif ( '' != $this->query_vars[ $wpvar ] ) {\n\t\t\t\t$this->query_string .= ( strlen( $this->query_string ) < 1 ) ? '' : '&';\n\t\t\t\tif ( ! is_scalar( $this->query_vars[ $wpvar ] ) ) { // Discard non-scalars.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t$this->query_string .= $wpvar . '=' . rawurlencode( $this->query_vars[ $wpvar ] );\n\t\t\t}\n\t\t}\n\n\t\tif ( has_filter( 'query_string' ) ) {  // Don't bother filtering and parsing if no plugins are hooked in.\n\t\t\t/**\n\t\t\t * Filters the query string before parsing.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t * @deprecated 2.1.0 Use 'query_vars' or 'request' filters instead.\n\t\t\t *\n\t\t\t * @param string $query_string The query string to modify.\n\t\t\t */\n\t\t\t$this->query_string = apply_filters( 'query_string', $this->query_string );\n\t\t\tparse_str( $this->query_string, $this->query_vars );\n\t\t}\n\t}\n\n\t/**\n\t * Set up the WordPress Globals.\n\t *\n\t * The query_vars property will be extracted to the GLOBALS. So care should\n\t * be taken when naming global variables that might interfere with the\n\t * WordPress environment.\n\t *\n\t * @since 2.0.0\n\t *\n\t * @global WP_Query     $wp_query\n\t * @global string       $query_string Query string for the loop.\n\t * @global array        $posts The found posts.\n\t * @global WP_Post|null $post The current post, if available.\n\t * @global string       $request The SQL statement for the request.\n\t * @global int          $more Only set, if single page or post.\n\t * @global int          $single If single page or post. Only set, if single page or post.\n\t * @global WP_User      $authordata Only set, if author archive.\n\t */\n\tpublic function register_globals() {\n\t\tglobal $wp_query;\n\n\t\t// Extract updated query vars back into global namespace.\n\t\tforeach ( (array) $wp_query->query_vars as $key => $value ) {\n\t\t\t$GLOBALS[ $key ] = $value;\n\t\t}\n\n\t\t$GLOBALS['query_string'] = $this->query_string;\n\t\t$GLOBALS['posts']        = & $wp_query->posts;\n\t\t$GLOBALS['post']         = isset( $wp_query->post ) ? $wp_query->post : null;\n\t\t$GLOBALS['request']      = $wp_query->request;\n\n\t\tif ( $wp_query->is_single() || $wp_query->is_page() ) {\n\t\t\t$GLOBALS['more']   = 1;\n\t\t\t$GLOBALS['single'] = 1;\n\t\t}\n\n\t\tif ( $wp_query->is_author() && isset( $wp_query->post ) ) {\n\t\t\t$GLOBALS['authordata'] = get_userdata( $wp_query->post->post_author );\n\t\t}\n\t}\n\n\t/**\n\t * Set up the current user.\n\t *\n\t * @since 2.0.0\n\t */\n\tpublic function init() {\n\t\twp_get_current_user();\n\t}\n\n\t/**\n\t * Set up the Loop based on the query variables.\n\t *\n\t * @since 2.0.0\n\t *\n\t * @global WP_Query $wp_the_query\n\t */\n\tpublic function query_posts() {\n\t\tglobal $wp_the_query;\n\t\t$this->build_query_string();\n\t\t$wp_the_query->query( $this->query_vars );\n\t}\n\n\t/**\n\t * Set the Headers for 404, if nothing is found for requested URL.\n\t *\n\t * Issue a 404 if a request doesn't match any posts and doesn't match\n\t * any object (e.g. an existing-but-empty category, tag, author) and a 404 was not already\n\t * issued, and if the request was not a search or the homepage.\n\t *\n\t * Otherwise, issue a 200.\n\t *\n\t * This sets headers after posts have been queried. handle_404() really means \"handle status.\"\n\t * By inspecting the result of querying posts, seemingly successful requests can be switched to\n\t * a 404 so that canonical redirection logic can kick in.\n\t *\n\t * @since 2.0.0\n\t *\n\t * @global WP_Query $wp_query\n\t */\n\tpublic function handle_404() {\n\t\tglobal $wp_query;\n\n\t\t/**\n\t\t * Filters whether to short-circuit default header status handling.\n\t\t *\n\t\t * Returning a non-false value from the filter will short-circuit the handling\n\t\t * and return early.\n\t\t *\n\t\t * @since 4.5.0\n\t\t *\n\t\t * @param bool     $preempt  Whether to short-circuit default header status handling. Default false.\n\t\t * @param WP_Query $wp_query WordPress Query object.\n\t\t */\n\t\tif ( false !== apply_filters( 'pre_handle_404', false, $wp_query ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If we've already issued a 404, bail.\n\t\tif ( is_404() ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Never 404 for the admin, robots, or if we found posts.\n\t\tif ( is_admin() || is_robots() || $wp_query->posts ) {\n\n\t\t\t$success = true;\n\t\t\tif ( is_singular() ) {\n\t\t\t\t$p = false;\n\n\t\t\t\tif ( $wp_query->post instanceof WP_Post ) {\n\t\t\t\t\t$p = clone $wp_query->post;\n\t\t\t\t}\n\n\t\t\t\t// Only set X-Pingback for single posts that allow pings.\n\t\t\t\tif ( $p && pings_open( $p ) ) {\n\t\t\t\t\t@header( 'X-Pingback: ' . get_bloginfo( 'pingback_url', 'display' ) );\n\t\t\t\t}\n\n\t\t\t\t// check for paged content that exceeds the max number of pages\n\t\t\t\t$next = '<!--nextpage-->';\n\t\t\t\tif ( $p && false !== strpos( $p->post_content, $next ) && ! empty( $this->query_vars['page'] ) ) {\n\t\t\t\t\t$page    = trim( $this->query_vars['page'], '/' );\n\t\t\t\t\t$success = (int) $page <= ( substr_count( $p->post_content, $next ) + 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $success ) {\n\t\t\t\tstatus_header( 200 );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// We will 404 for paged queries, as no posts were found.\n\t\tif ( ! is_paged() ) {\n\n\t\t\t// Don't 404 for authors without posts as long as they matched an author on this site.\n\t\t\t$author = get_query_var( 'author' );\n\t\t\tif ( is_author() && is_numeric( $author ) && $author > 0 && is_user_member_of_blog( $author ) ) {\n\t\t\t\tstatus_header( 200 );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Don't 404 for these queries if they matched an object.\n\t\t\tif ( ( is_tag() || is_category() || is_tax() || is_post_type_archive() ) && get_queried_object() ) {\n\t\t\t\tstatus_header( 200 );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Don't 404 for these queries either.\n\t\t\tif ( is_home() || is_search() || is_feed() ) {\n\t\t\t\tstatus_header( 200 );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Guess it's time to 404.\n\t\t$wp_query->set_404();\n\t\tstatus_header( 404 );\n\t\tnocache_headers();\n\t}\n\n\t/**\n\t * Sets up all of the variables required by the WordPress environment.\n\t *\n\t * The action {@see 'wp'} has one parameter that references the WP object. It\n\t * allows for accessing the properties and methods to further manipulate the\n\t * object.\n\t *\n\t * @since 2.0.0\n\t *\n\t * @param string|array $query_args Passed to parse_request().\n\t */\n\tpublic function main( $query_args = '' ) {\n\t\t$this->init();\n\t\t$this->parse_request( $query_args );\n\t\t$this->send_headers();\n\t\t$this->query_posts();\n\t\t$this->handle_404();\n\t\t$this->register_globals();\n\n\t\t/**\n\t\t * Fires once the WordPress environment has been set up.\n\t\t *\n\t\t * @since 2.1.0\n\t\t *\n\t\t * @param WP $this Current WordPress environment instance (passed by reference).\n\t\t */\n\t\tdo_action_ref_array( 'wp', array( &$this ) );\n\t}\n}\n", "<?php\n/**\n * WordPress Version\n *\n * Contains version information for the current WordPress release.\n *\n * @package WordPress\n * @since 1.1.0\n */\n\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '5.2.4-alpha-46473';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 44719;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4940-20190515';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.6.20';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "fixing_code": ["<?php\n/**\n * Query API: WP_Query class\n *\n * @package WordPress\n * @subpackage Query\n * @since 4.7.0\n */\n\n/**\n * The WordPress Query class.\n *\n * @link https://codex.wordpress.org/Function_Reference/WP_Query Codex page.\n *\n * @since 1.5.0\n * @since 4.5.0 Removed the `$comments_popup` property.\n */\nclass WP_Query {\n\n\t/**\n\t * Query vars set by the user\n\t *\n\t * @since 1.5.0\n\t * @var array\n\t */\n\tpublic $query;\n\n\t/**\n\t * Query vars, after parsing\n\t *\n\t * @since 1.5.0\n\t * @var array\n\t */\n\tpublic $query_vars = array();\n\n\t/**\n\t * Taxonomy query, as passed to get_tax_sql()\n\t *\n\t * @since 3.1.0\n\t * @var object WP_Tax_Query\n\t */\n\tpublic $tax_query;\n\n\t/**\n\t * Metadata query container\n\t *\n\t * @since 3.2.0\n\t * @var object WP_Meta_Query\n\t */\n\tpublic $meta_query = false;\n\n\t/**\n\t * Date query container\n\t *\n\t * @since 3.7.0\n\t * @var object WP_Date_Query\n\t */\n\tpublic $date_query = false;\n\n\t/**\n\t * Holds the data for a single object that is queried.\n\t *\n\t * Holds the contents of a post, page, category, attachment.\n\t *\n\t * @since 1.5.0\n\t * @var object|array\n\t */\n\tpublic $queried_object;\n\n\t/**\n\t * The ID of the queried object.\n\t *\n\t * @since 1.5.0\n\t * @var int\n\t */\n\tpublic $queried_object_id;\n\n\t/**\n\t * Get post database query.\n\t *\n\t * @since 2.0.1\n\t * @var string\n\t */\n\tpublic $request;\n\n\t/**\n\t * List of posts.\n\t *\n\t * @since 1.5.0\n\t * @var array\n\t */\n\tpublic $posts;\n\n\t/**\n\t * The amount of posts for the current query.\n\t *\n\t * @since 1.5.0\n\t * @var int\n\t */\n\tpublic $post_count = 0;\n\n\t/**\n\t * Index of the current item in the loop.\n\t *\n\t * @since 1.5.0\n\t * @var int\n\t */\n\tpublic $current_post = -1;\n\n\t/**\n\t * Whether the loop has started and the caller is in the loop.\n\t *\n\t * @since 2.0.0\n\t * @var bool\n\t */\n\tpublic $in_the_loop = false;\n\n\t/**\n\t * The current post.\n\t *\n\t * @since 1.5.0\n\t * @var WP_Post\n\t */\n\tpublic $post;\n\n\t/**\n\t * The list of comments for current post.\n\t *\n\t * @since 2.2.0\n\t * @var array\n\t */\n\tpublic $comments;\n\n\t/**\n\t * The amount of comments for the posts.\n\t *\n\t * @since 2.2.0\n\t * @var int\n\t */\n\tpublic $comment_count = 0;\n\n\t/**\n\t * The index of the comment in the comment loop.\n\t *\n\t * @since 2.2.0\n\t * @var int\n\t */\n\tpublic $current_comment = -1;\n\n\t/**\n\t * Current comment ID.\n\t *\n\t * @since 2.2.0\n\t * @var int\n\t */\n\tpublic $comment;\n\n\t/**\n\t * The amount of found posts for the current query.\n\t *\n\t * If limit clause was not used, equals $post_count.\n\t *\n\t * @since 2.1.0\n\t * @var int\n\t */\n\tpublic $found_posts = 0;\n\n\t/**\n\t * The amount of pages.\n\t *\n\t * @since 2.1.0\n\t * @var int\n\t */\n\tpublic $max_num_pages = 0;\n\n\t/**\n\t * The amount of comment pages.\n\t *\n\t * @since 2.7.0\n\t * @var int\n\t */\n\tpublic $max_num_comment_pages = 0;\n\n\t/**\n\t * Signifies whether the current query is for a single post.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_single = false;\n\n\t/**\n\t * Signifies whether the current query is for a preview.\n\t *\n\t * @since 2.0.0\n\t * @var bool\n\t */\n\tpublic $is_preview = false;\n\n\t/**\n\t * Signifies whether the current query is for a page.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_page = false;\n\n\t/**\n\t * Signifies whether the current query is for an archive.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_archive = false;\n\n\t/**\n\t * Signifies whether the current query is for a date archive.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_date = false;\n\n\t/**\n\t * Signifies whether the current query is for a year archive.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_year = false;\n\n\t/**\n\t * Signifies whether the current query is for a month archive.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_month = false;\n\n\t/**\n\t * Signifies whether the current query is for a day archive.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_day = false;\n\n\t/**\n\t * Signifies whether the current query is for a specific time.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_time = false;\n\n\t/**\n\t * Signifies whether the current query is for an author archive.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_author = false;\n\n\t/**\n\t * Signifies whether the current query is for a category archive.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_category = false;\n\n\t/**\n\t * Signifies whether the current query is for a tag archive.\n\t *\n\t * @since 2.3.0\n\t * @var bool\n\t */\n\tpublic $is_tag = false;\n\n\t/**\n\t * Signifies whether the current query is for a taxonomy archive.\n\t *\n\t * @since 2.5.0\n\t * @var bool\n\t */\n\tpublic $is_tax = false;\n\n\t/**\n\t * Signifies whether the current query is for a search.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_search = false;\n\n\t/**\n\t * Signifies whether the current query is for a feed.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_feed = false;\n\n\t/**\n\t * Signifies whether the current query is for a comment feed.\n\t *\n\t * @since 2.2.0\n\t * @var bool\n\t */\n\tpublic $is_comment_feed = false;\n\n\t/**\n\t * Signifies whether the current query is for trackback endpoint call.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_trackback = false;\n\n\t/**\n\t * Signifies whether the current query is for the site homepage.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_home = false;\n\n\t/**\n\t * Signifies whether the current query is for the Privacy Policy page.\n\t *\n\t * @since 5.2.0\n\t * @var bool\n\t */\n\tpublic $is_privacy_policy = false;\n\n\t/**\n\t * Signifies whether the current query couldn't find anything.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_404 = false;\n\n\t/**\n\t * Signifies whether the current query is for an embed.\n\t *\n\t * @since 4.4.0\n\t * @var bool\n\t */\n\tpublic $is_embed = false;\n\n\t/**\n\t * Signifies whether the current query is for a paged result and not for the first page.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_paged = false;\n\n\t/**\n\t * Signifies whether the current query is for an administrative interface page.\n\t *\n\t * @since 1.5.0\n\t * @var bool\n\t */\n\tpublic $is_admin = false;\n\n\t/**\n\t * Signifies whether the current query is for an attachment page.\n\t *\n\t * @since 2.0.0\n\t * @var bool\n\t */\n\tpublic $is_attachment = false;\n\n\t/**\n\t * Signifies whether the current query is for an existing single post of any post type\n\t * (post, attachment, page, custom post types).\n\t *\n\t * @since 2.1.0\n\t * @var bool\n\t */\n\tpublic $is_singular = false;\n\n\t/**\n\t * Signifies whether the current query is for the robots.txt file.\n\t *\n\t * @since 2.1.0\n\t * @var bool\n\t */\n\tpublic $is_robots = false;\n\n\t/**\n\t * Signifies whether the current query is for the page_for_posts page.\n\t *\n\t * Basically, the homepage if the option isn't set for the static homepage.\n\t *\n\t * @since 2.1.0\n\t * @var bool\n\t */\n\tpublic $is_posts_page = false;\n\n\t/**\n\t * Signifies whether the current query is for a post type archive.\n\t *\n\t * @since 3.1.0\n\t * @var bool\n\t */\n\tpublic $is_post_type_archive = false;\n\n\t/**\n\t * Stores the ->query_vars state like md5(serialize( $this->query_vars ) ) so we know\n\t * whether we have to re-parse because something has changed\n\t *\n\t * @since 3.1.0\n\t * @var bool|string\n\t */\n\tprivate $query_vars_hash = false;\n\n\t/**\n\t * Whether query vars have changed since the initial parse_query() call. Used to catch modifications to query vars made\n\t * via pre_get_posts hooks.\n\t *\n\t * @since 3.1.1\n\t */\n\tprivate $query_vars_changed = true;\n\n\t/**\n\t * Set if post thumbnails are cached\n\t *\n\t * @since 3.2.0\n\t * @var bool\n\t */\n\tpublic $thumbnails_cached = false;\n\n\t/**\n\t * Cached list of search stopwords.\n\t *\n\t * @since 3.7.0\n\t * @var array\n\t */\n\tprivate $stopwords;\n\n\tprivate $compat_fields = array( 'query_vars_hash', 'query_vars_changed' );\n\n\tprivate $compat_methods = array( 'init_query_flags', 'parse_tax_query' );\n\n\t/**\n\t * Resets query flags to false.\n\t *\n\t * The query flags are what page info WordPress was able to figure out.\n\t *\n\t * @since 2.0.0\n\t */\n\tprivate function init_query_flags() {\n\t\t$this->is_single            = false;\n\t\t$this->is_preview           = false;\n\t\t$this->is_page              = false;\n\t\t$this->is_archive           = false;\n\t\t$this->is_date              = false;\n\t\t$this->is_year              = false;\n\t\t$this->is_month             = false;\n\t\t$this->is_day               = false;\n\t\t$this->is_time              = false;\n\t\t$this->is_author            = false;\n\t\t$this->is_category          = false;\n\t\t$this->is_tag               = false;\n\t\t$this->is_tax               = false;\n\t\t$this->is_search            = false;\n\t\t$this->is_feed              = false;\n\t\t$this->is_comment_feed      = false;\n\t\t$this->is_trackback         = false;\n\t\t$this->is_home              = false;\n\t\t$this->is_privacy_policy    = false;\n\t\t$this->is_404               = false;\n\t\t$this->is_paged             = false;\n\t\t$this->is_admin             = false;\n\t\t$this->is_attachment        = false;\n\t\t$this->is_singular          = false;\n\t\t$this->is_robots            = false;\n\t\t$this->is_posts_page        = false;\n\t\t$this->is_post_type_archive = false;\n\t}\n\n\t/**\n\t * Initiates object properties and sets default values.\n\t *\n\t * @since 1.5.0\n\t */\n\tpublic function init() {\n\t\tunset( $this->posts );\n\t\tunset( $this->query );\n\t\t$this->query_vars = array();\n\t\tunset( $this->queried_object );\n\t\tunset( $this->queried_object_id );\n\t\t$this->post_count   = 0;\n\t\t$this->current_post = -1;\n\t\t$this->in_the_loop  = false;\n\t\tunset( $this->request );\n\t\tunset( $this->post );\n\t\tunset( $this->comments );\n\t\tunset( $this->comment );\n\t\t$this->comment_count         = 0;\n\t\t$this->current_comment       = -1;\n\t\t$this->found_posts           = 0;\n\t\t$this->max_num_pages         = 0;\n\t\t$this->max_num_comment_pages = 0;\n\n\t\t$this->init_query_flags();\n\t}\n\n\t/**\n\t * Reparse the query vars.\n\t *\n\t * @since 1.5.0\n\t */\n\tpublic function parse_query_vars() {\n\t\t$this->parse_query();\n\t}\n\n\t/**\n\t * Fills in the query variables, which do not exist within the parameter.\n\t *\n\t * @since 2.1.0\n\t * @since 4.4.0 Removed the `comments_popup` public query variable.\n\t *\n\t * @param array $array Defined query variables.\n\t * @return array Complete query variables with undefined ones filled in empty.\n\t */\n\tpublic function fill_query_vars( $array ) {\n\t\t$keys = array(\n\t\t\t'error',\n\t\t\t'm',\n\t\t\t'p',\n\t\t\t'post_parent',\n\t\t\t'subpost',\n\t\t\t'subpost_id',\n\t\t\t'attachment',\n\t\t\t'attachment_id',\n\t\t\t'name',\n\t\t\t'pagename',\n\t\t\t'page_id',\n\t\t\t'second',\n\t\t\t'minute',\n\t\t\t'hour',\n\t\t\t'day',\n\t\t\t'monthnum',\n\t\t\t'year',\n\t\t\t'w',\n\t\t\t'category_name',\n\t\t\t'tag',\n\t\t\t'cat',\n\t\t\t'tag_id',\n\t\t\t'author',\n\t\t\t'author_name',\n\t\t\t'feed',\n\t\t\t'tb',\n\t\t\t'paged',\n\t\t\t'meta_key',\n\t\t\t'meta_value',\n\t\t\t'preview',\n\t\t\t's',\n\t\t\t'sentence',\n\t\t\t'title',\n\t\t\t'fields',\n\t\t\t'menu_order',\n\t\t\t'embed',\n\t\t);\n\n\t\tforeach ( $keys as $key ) {\n\t\t\tif ( ! isset( $array[ $key ] ) ) {\n\t\t\t\t$array[ $key ] = '';\n\t\t\t}\n\t\t}\n\n\t\t$array_keys = array(\n\t\t\t'category__in',\n\t\t\t'category__not_in',\n\t\t\t'category__and',\n\t\t\t'post__in',\n\t\t\t'post__not_in',\n\t\t\t'post_name__in',\n\t\t\t'tag__in',\n\t\t\t'tag__not_in',\n\t\t\t'tag__and',\n\t\t\t'tag_slug__in',\n\t\t\t'tag_slug__and',\n\t\t\t'post_parent__in',\n\t\t\t'post_parent__not_in',\n\t\t\t'author__in',\n\t\t\t'author__not_in',\n\t\t);\n\n\t\tforeach ( $array_keys as $key ) {\n\t\t\tif ( ! isset( $array[ $key ] ) ) {\n\t\t\t\t$array[ $key ] = array();\n\t\t\t}\n\t\t}\n\t\treturn $array;\n\t}\n\n\t/**\n\t * Parse a query string and set query type booleans.\n\t *\n\t * @since 1.5.0\n\t * @since 4.2.0 Introduced the ability to order by specific clauses of a `$meta_query`, by passing the clause's\n\t *              array key to `$orderby`.\n\t * @since 4.4.0 Introduced `$post_name__in` and `$title` parameters. `$s` was updated to support excluded\n\t *              search terms, by prepending a hyphen.\n\t * @since 4.5.0 Removed the `$comments_popup` parameter.\n\t *              Introduced the `$comment_status` and `$ping_status` parameters.\n\t *              Introduced `RAND(x)` syntax for `$orderby`, which allows an integer seed value to random sorts.\n\t * @since 4.6.0 Added 'post_name__in' support for `$orderby`. Introduced the `$lazy_load_term_meta` argument.\n\t * @since 4.9.0 Introduced the `$comment_count` parameter.\n\t * @since 5.1.0 Introduced the `$meta_compare_key` parameter.\n\t *\n\t * @param string|array $query {\n\t *     Optional. Array or string of Query parameters.\n\t *\n\t *     @type int          $attachment_id           Attachment post ID. Used for 'attachment' post_type.\n\t *     @type int|string   $author                  Author ID, or comma-separated list of IDs.\n\t *     @type string       $author_name             User 'user_nicename'.\n\t *     @type array        $author__in              An array of author IDs to query from.\n\t *     @type array        $author__not_in          An array of author IDs not to query from.\n\t *     @type bool         $cache_results           Whether to cache post information. Default true.\n\t *     @type int|string   $cat                     Category ID or comma-separated list of IDs (this or any children).\n\t *     @type array        $category__and           An array of category IDs (AND in).\n\t *     @type array        $category__in            An array of category IDs (OR in, no children).\n\t *     @type array        $category__not_in        An array of category IDs (NOT in).\n\t *     @type string       $category_name           Use category slug (not name, this or any children).\n\t *     @type array|int    $comment_count           Filter results by comment count. Provide an integer to match\n\t *                                                 comment count exactly. Provide an array with integer 'value'\n\t *                                                 and 'compare' operator ('=', '!=', '>', '>=', '<', '<=' ) to\n\t *                                                 compare against comment_count in a specific way.\n\t *     @type string       $comment_status          Comment status.\n\t *     @type int          $comments_per_page       The number of comments to return per page.\n\t *                                                 Default 'comments_per_page' option.\n\t *     @type array        $date_query              An associative array of WP_Date_Query arguments.\n\t *                                                 See WP_Date_Query::__construct().\n\t *     @type int          $day                     Day of the month. Default empty. Accepts numbers 1-31.\n\t *     @type bool         $exact                   Whether to search by exact keyword. Default false.\n\t *     @type string|array $fields                  Which fields to return. Single field or all fields (string),\n\t *                                                 or array of fields. 'id=>parent' uses 'id' and 'post_parent'.\n\t *                                                 Default all fields. Accepts 'ids', 'id=>parent'.\n\t *     @type int          $hour                    Hour of the day. Default empty. Accepts numbers 0-23.\n\t *     @type int|bool     $ignore_sticky_posts     Whether to ignore sticky posts or not. Setting this to false\n\t *                                                 excludes stickies from 'post__in'. Accepts 1|true, 0|false.\n\t *                                                 Default 0|false.\n\t *     @type int          $m                       Combination YearMonth. Accepts any four-digit year and month\n\t *                                                 numbers 1-12. Default empty.\n\t *     @type string       $meta_compare            Comparison operator to test the 'meta_value'.\n\t *     @type string       $meta_compare_key        Comparison operator to test the 'meta_key'.\n\t *     @type string       $meta_key                Custom field key.\n\t *     @type array        $meta_query              An associative array of WP_Meta_Query arguments. See WP_Meta_Query.\n\t *     @type string       $meta_value              Custom field value.\n\t *     @type int          $meta_value_num          Custom field value number.\n\t *     @type int          $menu_order              The menu order of the posts.\n\t *     @type int          $monthnum                The two-digit month. Default empty. Accepts numbers 1-12.\n\t *     @type string       $name                    Post slug.\n\t *     @type bool         $nopaging                Show all posts (true) or paginate (false). Default false.\n\t *     @type bool         $no_found_rows           Whether to skip counting the total rows found. Enabling can improve\n\t *                                                 performance. Default false.\n\t *     @type int          $offset                  The number of posts to offset before retrieval.\n\t *     @type string       $order                   Designates ascending or descending order of posts. Default 'DESC'.\n\t *                                                 Accepts 'ASC', 'DESC'.\n\t *     @type string|array $orderby                 Sort retrieved posts by parameter. One or more options may be\n\t *                                                 passed. To use 'meta_value', or 'meta_value_num',\n\t *                                                 'meta_key=keyname' must be also be defined. To sort by a\n\t *                                                 specific `$meta_query` clause, use that clause's array key.\n\t *                                                 Accepts 'none', 'name', 'author', 'date', 'title',\n\t *                                                 'modified', 'menu_order', 'parent', 'ID', 'rand',\n\t *                                                 'relevance', 'RAND(x)' (where 'x' is an integer seed value),\n\t *                                                 'comment_count', 'meta_value', 'meta_value_num', 'post__in',\n\t *                                                 'post_name__in', 'post_parent__in', and the array keys\n\t *                                                 of `$meta_query`. Default is 'date', except when a search\n\t *                                                 is being performed, when the default is 'relevance'.\n\t *\n\t *     @type int          $p                       Post ID.\n\t *     @type int          $page                    Show the number of posts that would show up on page X of a\n\t *                                                 static front page.\n\t *     @type int          $paged                   The number of the current page.\n\t *     @type int          $page_id                 Page ID.\n\t *     @type string       $pagename                Page slug.\n\t *     @type string       $perm                    Show posts if user has the appropriate capability.\n\t *     @type string       $ping_status             Ping status.\n\t *     @type array        $post__in                An array of post IDs to retrieve, sticky posts will be included\n\t *     @type string       $post_mime_type          The mime type of the post. Used for 'attachment' post_type.\n\t *     @type array        $post__not_in            An array of post IDs not to retrieve. Note: a string of comma-\n\t *                                                 separated IDs will NOT work.\n\t *     @type int          $post_parent             Page ID to retrieve child pages for. Use 0 to only retrieve\n\t *                                                 top-level pages.\n\t *     @type array        $post_parent__in         An array containing parent page IDs to query child pages from.\n\t *     @type array        $post_parent__not_in     An array containing parent page IDs not to query child pages from.\n\t *     @type string|array $post_type               A post type slug (string) or array of post type slugs.\n\t *                                                 Default 'any' if using 'tax_query'.\n\t *     @type string|array $post_status             A post status (string) or array of post statuses.\n\t *     @type int          $posts_per_page          The number of posts to query for. Use -1 to request all posts.\n\t *     @type int          $posts_per_archive_page  The number of posts to query for by archive page. Overrides\n\t *                                                 'posts_per_page' when is_archive(), or is_search() are true.\n\t *     @type array        $post_name__in           An array of post slugs that results must match.\n\t *     @type string       $s                       Search keyword(s). Prepending a term with a hyphen will\n\t *                                                 exclude posts matching that term. Eg, 'pillow -sofa' will\n\t *                                                 return posts containing 'pillow' but not 'sofa'. The\n\t *                                                 character used for exclusion can be modified using the\n\t *                                                 the 'wp_query_search_exclusion_prefix' filter.\n\t *     @type int          $second                  Second of the minute. Default empty. Accepts numbers 0-60.\n\t *     @type bool         $sentence                Whether to search by phrase. Default false.\n\t *     @type bool         $suppress_filters        Whether to suppress filters. Default false.\n\t *     @type string       $tag                     Tag slug. Comma-separated (either), Plus-separated (all).\n\t *     @type array        $tag__and                An array of tag ids (AND in).\n\t *     @type array        $tag__in                 An array of tag ids (OR in).\n\t *     @type array        $tag__not_in             An array of tag ids (NOT in).\n\t *     @type int          $tag_id                  Tag id or comma-separated list of IDs.\n\t *     @type array        $tag_slug__and           An array of tag slugs (AND in).\n\t *     @type array        $tag_slug__in            An array of tag slugs (OR in). unless 'ignore_sticky_posts' is\n\t *                                                 true. Note: a string of comma-separated IDs will NOT work.\n\t *     @type array        $tax_query               An associative array of WP_Tax_Query arguments.\n\t *                                                 See WP_Tax_Query->queries.\n\t *     @type string       $title                   Post title.\n\t *     @type bool         $update_post_meta_cache  Whether to update the post meta cache. Default true.\n\t *     @type bool         $update_post_term_cache  Whether to update the post term cache. Default true.\n\t *     @type bool         $lazy_load_term_meta     Whether to lazy-load term meta. Setting to false will\n\t *                                                 disable cache priming for term meta, so that each\n\t *                                                 get_term_meta() call will hit the database.\n\t *                                                 Defaults to the value of `$update_post_term_cache`.\n\t *     @type int          $w                       The week number of the year. Default empty. Accepts numbers 0-53.\n\t *     @type int          $year                    The four-digit year. Default empty. Accepts any four-digit year.\n\t * }\n\t */\n\tpublic function parse_query( $query = '' ) {\n\t\tif ( ! empty( $query ) ) {\n\t\t\t$this->init();\n\t\t\t$this->query = $this->query_vars = wp_parse_args( $query );\n\t\t} elseif ( ! isset( $this->query ) ) {\n\t\t\t$this->query = $this->query_vars;\n\t\t}\n\n\t\t$this->query_vars         = $this->fill_query_vars( $this->query_vars );\n\t\t$qv                       = &$this->query_vars;\n\t\t$this->query_vars_changed = true;\n\n\t\tif ( ! empty( $qv['robots'] ) ) {\n\t\t\t$this->is_robots = true;\n\t\t}\n\n\t\tif ( ! is_scalar( $qv['p'] ) || $qv['p'] < 0 ) {\n\t\t\t$qv['p']     = 0;\n\t\t\t$qv['error'] = '404';\n\t\t} else {\n\t\t\t$qv['p'] = intval( $qv['p'] );\n\t\t}\n\n\t\t$qv['page_id']  = absint( $qv['page_id'] );\n\t\t$qv['year']     = absint( $qv['year'] );\n\t\t$qv['monthnum'] = absint( $qv['monthnum'] );\n\t\t$qv['day']      = absint( $qv['day'] );\n\t\t$qv['w']        = absint( $qv['w'] );\n\t\t$qv['m']        = is_scalar( $qv['m'] ) ? preg_replace( '|[^0-9]|', '', $qv['m'] ) : '';\n\t\t$qv['paged']    = absint( $qv['paged'] );\n\t\t$qv['cat']      = preg_replace( '|[^0-9,-]|', '', $qv['cat'] ); // comma separated list of positive or negative integers\n\t\t$qv['author']   = preg_replace( '|[^0-9,-]|', '', $qv['author'] ); // comma separated list of positive or negative integers\n\t\t$qv['pagename'] = trim( $qv['pagename'] );\n\t\t$qv['name']     = trim( $qv['name'] );\n\t\t$qv['title']    = trim( $qv['title'] );\n\t\tif ( '' !== $qv['hour'] ) {\n\t\t\t$qv['hour'] = absint( $qv['hour'] );\n\t\t}\n\t\tif ( '' !== $qv['minute'] ) {\n\t\t\t$qv['minute'] = absint( $qv['minute'] );\n\t\t}\n\t\tif ( '' !== $qv['second'] ) {\n\t\t\t$qv['second'] = absint( $qv['second'] );\n\t\t}\n\t\tif ( '' !== $qv['menu_order'] ) {\n\t\t\t$qv['menu_order'] = absint( $qv['menu_order'] );\n\t\t}\n\n\t\t// Fairly insane upper bound for search string lengths.\n\t\tif ( ! is_scalar( $qv['s'] ) || ( ! empty( $qv['s'] ) && strlen( $qv['s'] ) > 1600 ) ) {\n\t\t\t$qv['s'] = '';\n\t\t}\n\n\t\t// Compat. Map subpost to attachment.\n\t\tif ( '' != $qv['subpost'] ) {\n\t\t\t$qv['attachment'] = $qv['subpost'];\n\t\t}\n\t\tif ( '' != $qv['subpost_id'] ) {\n\t\t\t$qv['attachment_id'] = $qv['subpost_id'];\n\t\t}\n\n\t\t$qv['attachment_id'] = absint( $qv['attachment_id'] );\n\n\t\tif ( ( '' != $qv['attachment'] ) || ! empty( $qv['attachment_id'] ) ) {\n\t\t\t$this->is_single     = true;\n\t\t\t$this->is_attachment = true;\n\t\t} elseif ( '' != $qv['name'] ) {\n\t\t\t$this->is_single = true;\n\t\t} elseif ( $qv['p'] ) {\n\t\t\t$this->is_single = true;\n\t\t} elseif ( ( '' !== $qv['hour'] ) && ( '' !== $qv['minute'] ) && ( '' !== $qv['second'] ) && ( '' != $qv['year'] ) && ( '' != $qv['monthnum'] ) && ( '' != $qv['day'] ) ) {\n\t\t\t// If year, month, day, hour, minute, and second are set, a single\n\t\t\t// post is being queried.\n\t\t\t$this->is_single = true;\n\t\t} elseif ( '' != $qv['pagename'] || ! empty( $qv['page_id'] ) ) {\n\t\t\t$this->is_page   = true;\n\t\t\t$this->is_single = false;\n\t\t} else {\n\t\t\t// Look for archive queries. Dates, categories, authors, search, post type archives.\n\n\t\t\tif ( isset( $this->query['s'] ) ) {\n\t\t\t\t$this->is_search = true;\n\t\t\t}\n\n\t\t\tif ( '' !== $qv['second'] ) {\n\t\t\t\t$this->is_time = true;\n\t\t\t\t$this->is_date = true;\n\t\t\t}\n\n\t\t\tif ( '' !== $qv['minute'] ) {\n\t\t\t\t$this->is_time = true;\n\t\t\t\t$this->is_date = true;\n\t\t\t}\n\n\t\t\tif ( '' !== $qv['hour'] ) {\n\t\t\t\t$this->is_time = true;\n\t\t\t\t$this->is_date = true;\n\t\t\t}\n\n\t\t\tif ( $qv['day'] ) {\n\t\t\t\tif ( ! $this->is_date ) {\n\t\t\t\t\t$date = sprintf( '%04d-%02d-%02d', $qv['year'], $qv['monthnum'], $qv['day'] );\n\t\t\t\t\tif ( $qv['monthnum'] && $qv['year'] && ! wp_checkdate( $qv['monthnum'], $qv['day'], $qv['year'], $date ) ) {\n\t\t\t\t\t\t$qv['error'] = '404';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->is_day  = true;\n\t\t\t\t\t\t$this->is_date = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $qv['monthnum'] ) {\n\t\t\t\tif ( ! $this->is_date ) {\n\t\t\t\t\tif ( 12 < $qv['monthnum'] ) {\n\t\t\t\t\t\t$qv['error'] = '404';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->is_month = true;\n\t\t\t\t\t\t$this->is_date  = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $qv['year'] ) {\n\t\t\t\tif ( ! $this->is_date ) {\n\t\t\t\t\t$this->is_year = true;\n\t\t\t\t\t$this->is_date = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $qv['m'] ) {\n\t\t\t\t$this->is_date = true;\n\t\t\t\tif ( strlen( $qv['m'] ) > 9 ) {\n\t\t\t\t\t$this->is_time = true;\n\t\t\t\t} elseif ( strlen( $qv['m'] ) > 7 ) {\n\t\t\t\t\t$this->is_day = true;\n\t\t\t\t} elseif ( strlen( $qv['m'] ) > 5 ) {\n\t\t\t\t\t$this->is_month = true;\n\t\t\t\t} else {\n\t\t\t\t\t$this->is_year = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( '' != $qv['w'] ) {\n\t\t\t\t$this->is_date = true;\n\t\t\t}\n\n\t\t\t$this->query_vars_hash = false;\n\t\t\t$this->parse_tax_query( $qv );\n\n\t\t\tforeach ( $this->tax_query->queries as $tax_query ) {\n\t\t\t\tif ( ! is_array( $tax_query ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( isset( $tax_query['operator'] ) && 'NOT IN' != $tax_query['operator'] ) {\n\t\t\t\t\tswitch ( $tax_query['taxonomy'] ) {\n\t\t\t\t\t\tcase 'category':\n\t\t\t\t\t\t\t$this->is_category = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'post_tag':\n\t\t\t\t\t\t\t$this->is_tag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t$this->is_tax = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tunset( $tax_query );\n\n\t\t\tif ( empty( $qv['author'] ) || ( $qv['author'] == '0' ) ) {\n\t\t\t\t$this->is_author = false;\n\t\t\t} else {\n\t\t\t\t$this->is_author = true;\n\t\t\t}\n\n\t\t\tif ( '' != $qv['author_name'] ) {\n\t\t\t\t$this->is_author = true;\n\t\t\t}\n\n\t\t\tif ( ! empty( $qv['post_type'] ) && ! is_array( $qv['post_type'] ) ) {\n\t\t\t\t$post_type_obj = get_post_type_object( $qv['post_type'] );\n\t\t\t\tif ( ! empty( $post_type_obj->has_archive ) ) {\n\t\t\t\t\t$this->is_post_type_archive = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $this->is_post_type_archive || $this->is_date || $this->is_author || $this->is_category || $this->is_tag || $this->is_tax ) {\n\t\t\t\t$this->is_archive = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( '' != $qv['feed'] ) {\n\t\t\t$this->is_feed = true;\n\t\t}\n\n\t\tif ( '' != $qv['embed'] ) {\n\t\t\t$this->is_embed = true;\n\t\t}\n\n\t\tif ( '' != $qv['tb'] ) {\n\t\t\t$this->is_trackback = true;\n\t\t}\n\n\t\tif ( '' != $qv['paged'] && ( intval( $qv['paged'] ) > 1 ) ) {\n\t\t\t$this->is_paged = true;\n\t\t}\n\n\t\t// if we're previewing inside the write screen\n\t\tif ( '' != $qv['preview'] ) {\n\t\t\t$this->is_preview = true;\n\t\t}\n\n\t\tif ( is_admin() ) {\n\t\t\t$this->is_admin = true;\n\t\t}\n\n\t\tif ( false !== strpos( $qv['feed'], 'comments-' ) ) {\n\t\t\t$qv['feed']         = str_replace( 'comments-', '', $qv['feed'] );\n\t\t\t$qv['withcomments'] = 1;\n\t\t}\n\n\t\t$this->is_singular = $this->is_single || $this->is_page || $this->is_attachment;\n\n\t\tif ( $this->is_feed && ( ! empty( $qv['withcomments'] ) || ( empty( $qv['withoutcomments'] ) && $this->is_singular ) ) ) {\n\t\t\t$this->is_comment_feed = true;\n\t\t}\n\n\t\tif ( ! ( $this->is_singular || $this->is_archive || $this->is_search || $this->is_feed || ( defined( 'REST_REQUEST' ) && REST_REQUEST ) || $this->is_trackback || $this->is_404 || $this->is_admin || $this->is_robots ) ) {\n\t\t\t$this->is_home = true;\n\t\t}\n\n\t\t// Correct is_* for page_on_front and page_for_posts\n\t\tif ( $this->is_home && 'page' == get_option( 'show_on_front' ) && get_option( 'page_on_front' ) ) {\n\t\t\t$_query = wp_parse_args( $this->query );\n\t\t\t// pagename can be set and empty depending on matched rewrite rules. Ignore an empty pagename.\n\t\t\tif ( isset( $_query['pagename'] ) && '' == $_query['pagename'] ) {\n\t\t\t\tunset( $_query['pagename'] );\n\t\t\t}\n\n\t\t\tunset( $_query['embed'] );\n\n\t\t\tif ( empty( $_query ) || ! array_diff( array_keys( $_query ), array( 'preview', 'page', 'paged', 'cpage' ) ) ) {\n\t\t\t\t$this->is_page = true;\n\t\t\t\t$this->is_home = false;\n\t\t\t\t$qv['page_id'] = get_option( 'page_on_front' );\n\t\t\t\t// Correct <!--nextpage--> for page_on_front\n\t\t\t\tif ( ! empty( $qv['paged'] ) ) {\n\t\t\t\t\t$qv['page'] = $qv['paged'];\n\t\t\t\t\tunset( $qv['paged'] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( '' != $qv['pagename'] ) {\n\t\t\t$this->queried_object = get_page_by_path( $qv['pagename'] );\n\n\t\t\tif ( $this->queried_object && 'attachment' == $this->queried_object->post_type ) {\n\t\t\t\tif ( preg_match( '/^[^%]*%(?:postname)%/', get_option( 'permalink_structure' ) ) ) {\n\t\t\t\t\t// See if we also have a post with the same slug\n\t\t\t\t\t$post = get_page_by_path( $qv['pagename'], OBJECT, 'post' );\n\t\t\t\t\tif ( $post ) {\n\t\t\t\t\t\t$this->queried_object = $post;\n\t\t\t\t\t\t$this->is_page        = false;\n\t\t\t\t\t\t$this->is_single      = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ! empty( $this->queried_object ) ) {\n\t\t\t\t$this->queried_object_id = (int) $this->queried_object->ID;\n\t\t\t} else {\n\t\t\t\tunset( $this->queried_object );\n\t\t\t}\n\n\t\t\tif ( 'page' == get_option( 'show_on_front' ) && isset( $this->queried_object_id ) && $this->queried_object_id == get_option( 'page_for_posts' ) ) {\n\t\t\t\t$this->is_page       = false;\n\t\t\t\t$this->is_home       = true;\n\t\t\t\t$this->is_posts_page = true;\n\t\t\t}\n\n\t\t\tif ( isset( $this->queried_object_id ) && $this->queried_object_id == get_option( 'wp_page_for_privacy_policy' ) ) {\n\t\t\t\t$this->is_privacy_policy = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( $qv['page_id'] ) {\n\t\t\tif ( 'page' == get_option( 'show_on_front' ) && $qv['page_id'] == get_option( 'page_for_posts' ) ) {\n\t\t\t\t$this->is_page       = false;\n\t\t\t\t$this->is_home       = true;\n\t\t\t\t$this->is_posts_page = true;\n\t\t\t}\n\n\t\t\tif ( $qv['page_id'] == get_option( 'wp_page_for_privacy_policy' ) ) {\n\t\t\t\t$this->is_privacy_policy = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $qv['post_type'] ) ) {\n\t\t\tif ( is_array( $qv['post_type'] ) ) {\n\t\t\t\t$qv['post_type'] = array_map( 'sanitize_key', $qv['post_type'] );\n\t\t\t} else {\n\t\t\t\t$qv['post_type'] = sanitize_key( $qv['post_type'] );\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $qv['post_status'] ) ) {\n\t\t\tif ( is_array( $qv['post_status'] ) ) {\n\t\t\t\t$qv['post_status'] = array_map( 'sanitize_key', $qv['post_status'] );\n\t\t\t} else {\n\t\t\t\t$qv['post_status'] = preg_replace( '|[^a-z0-9_,-]|', '', $qv['post_status'] );\n\t\t\t}\n\t\t}\n\n\t\tif ( $this->is_posts_page && ( ! isset( $qv['withcomments'] ) || ! $qv['withcomments'] ) ) {\n\t\t\t$this->is_comment_feed = false;\n\t\t}\n\n\t\t$this->is_singular = $this->is_single || $this->is_page || $this->is_attachment;\n\t\t// Done correcting is_* for page_on_front and page_for_posts\n\n\t\tif ( '404' == $qv['error'] ) {\n\t\t\t$this->set_404();\n\t\t}\n\n\t\t$this->is_embed = $this->is_embed && ( $this->is_singular || $this->is_404 );\n\n\t\t$this->query_vars_hash    = md5( serialize( $this->query_vars ) );\n\t\t$this->query_vars_changed = false;\n\n\t\t/**\n\t\t * Fires after the main query vars have been parsed.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t */\n\t\tdo_action_ref_array( 'parse_query', array( &$this ) );\n\t}\n\n\t/**\n\t * Parses various taxonomy related query vars.\n\t *\n\t * For BC, this method is not marked as protected. See [28987].\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param array $q The query variables. Passed by reference.\n\t */\n\tpublic function parse_tax_query( &$q ) {\n\t\tif ( ! empty( $q['tax_query'] ) && is_array( $q['tax_query'] ) ) {\n\t\t\t$tax_query = $q['tax_query'];\n\t\t} else {\n\t\t\t$tax_query = array();\n\t\t}\n\n\t\tif ( ! empty( $q['taxonomy'] ) && ! empty( $q['term'] ) ) {\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => $q['taxonomy'],\n\t\t\t\t'terms'    => array( $q['term'] ),\n\t\t\t\t'field'    => 'slug',\n\t\t\t);\n\t\t}\n\n\t\tforeach ( get_taxonomies( array(), 'objects' ) as $taxonomy => $t ) {\n\t\t\tif ( 'post_tag' == $taxonomy ) {\n\t\t\t\tcontinue;   // Handled further down in the $q['tag'] block\n\t\t\t}\n\n\t\t\tif ( $t->query_var && ! empty( $q[ $t->query_var ] ) ) {\n\t\t\t\t$tax_query_defaults = array(\n\t\t\t\t\t'taxonomy' => $taxonomy,\n\t\t\t\t\t'field'    => 'slug',\n\t\t\t\t);\n\n\t\t\t\tif ( isset( $t->rewrite['hierarchical'] ) && $t->rewrite['hierarchical'] ) {\n\t\t\t\t\t$q[ $t->query_var ] = wp_basename( $q[ $t->query_var ] );\n\t\t\t\t}\n\n\t\t\t\t$term = $q[ $t->query_var ];\n\n\t\t\t\tif ( is_array( $term ) ) {\n\t\t\t\t\t$term = implode( ',', $term );\n\t\t\t\t}\n\n\t\t\t\tif ( strpos( $term, '+' ) !== false ) {\n\t\t\t\t\t$terms = preg_split( '/[+]+/', $term );\n\t\t\t\t\tforeach ( $terms as $term ) {\n\t\t\t\t\t\t$tax_query[] = array_merge(\n\t\t\t\t\t\t\t$tax_query_defaults,\n\t\t\t\t\t\t\tarray(\n\t\t\t\t\t\t\t\t'terms' => array( $term ),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$tax_query[] = array_merge(\n\t\t\t\t\t\t$tax_query_defaults,\n\t\t\t\t\t\tarray(\n\t\t\t\t\t\t\t'terms' => preg_split( '/[,]+/', $term ),\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If querystring 'cat' is an array, implode it.\n\t\tif ( is_array( $q['cat'] ) ) {\n\t\t\t$q['cat'] = implode( ',', $q['cat'] );\n\t\t}\n\n\t\t// Category stuff\n\t\tif ( ! empty( $q['cat'] ) && ! $this->is_singular ) {\n\t\t\t$cat_in = $cat_not_in = array();\n\n\t\t\t$cat_array = preg_split( '/[,\\s]+/', urldecode( $q['cat'] ) );\n\t\t\t$cat_array = array_map( 'intval', $cat_array );\n\t\t\t$q['cat']  = implode( ',', $cat_array );\n\n\t\t\tforeach ( $cat_array as $cat ) {\n\t\t\t\tif ( $cat > 0 ) {\n\t\t\t\t\t$cat_in[] = $cat;\n\t\t\t\t} elseif ( $cat < 0 ) {\n\t\t\t\t\t$cat_not_in[] = abs( $cat );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ! empty( $cat_in ) ) {\n\t\t\t\t$tax_query[] = array(\n\t\t\t\t\t'taxonomy'         => 'category',\n\t\t\t\t\t'terms'            => $cat_in,\n\t\t\t\t\t'field'            => 'term_id',\n\t\t\t\t\t'include_children' => true,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( ! empty( $cat_not_in ) ) {\n\t\t\t\t$tax_query[] = array(\n\t\t\t\t\t'taxonomy'         => 'category',\n\t\t\t\t\t'terms'            => $cat_not_in,\n\t\t\t\t\t'field'            => 'term_id',\n\t\t\t\t\t'operator'         => 'NOT IN',\n\t\t\t\t\t'include_children' => true,\n\t\t\t\t);\n\t\t\t}\n\t\t\tunset( $cat_array, $cat_in, $cat_not_in );\n\t\t}\n\n\t\tif ( ! empty( $q['category__and'] ) && 1 === count( (array) $q['category__and'] ) ) {\n\t\t\t$q['category__and'] = (array) $q['category__and'];\n\t\t\tif ( ! isset( $q['category__in'] ) ) {\n\t\t\t\t$q['category__in'] = array();\n\t\t\t}\n\t\t\t$q['category__in'][] = absint( reset( $q['category__and'] ) );\n\t\t\tunset( $q['category__and'] );\n\t\t}\n\n\t\tif ( ! empty( $q['category__in'] ) ) {\n\t\t\t$q['category__in'] = array_map( 'absint', array_unique( (array) $q['category__in'] ) );\n\t\t\t$tax_query[]       = array(\n\t\t\t\t'taxonomy'         => 'category',\n\t\t\t\t'terms'            => $q['category__in'],\n\t\t\t\t'field'            => 'term_id',\n\t\t\t\t'include_children' => false,\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $q['category__not_in'] ) ) {\n\t\t\t$q['category__not_in'] = array_map( 'absint', array_unique( (array) $q['category__not_in'] ) );\n\t\t\t$tax_query[]           = array(\n\t\t\t\t'taxonomy'         => 'category',\n\t\t\t\t'terms'            => $q['category__not_in'],\n\t\t\t\t'operator'         => 'NOT IN',\n\t\t\t\t'include_children' => false,\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $q['category__and'] ) ) {\n\t\t\t$q['category__and'] = array_map( 'absint', array_unique( (array) $q['category__and'] ) );\n\t\t\t$tax_query[]        = array(\n\t\t\t\t'taxonomy'         => 'category',\n\t\t\t\t'terms'            => $q['category__and'],\n\t\t\t\t'field'            => 'term_id',\n\t\t\t\t'operator'         => 'AND',\n\t\t\t\t'include_children' => false,\n\t\t\t);\n\t\t}\n\n\t\t// If querystring 'tag' is array, implode it.\n\t\tif ( is_array( $q['tag'] ) ) {\n\t\t\t$q['tag'] = implode( ',', $q['tag'] );\n\t\t}\n\n\t\t// Tag stuff\n\t\tif ( '' != $q['tag'] && ! $this->is_singular && $this->query_vars_changed ) {\n\t\t\tif ( strpos( $q['tag'], ',' ) !== false ) {\n\t\t\t\t$tags = preg_split( '/[,\\r\\n\\t ]+/', $q['tag'] );\n\t\t\t\tforeach ( (array) $tags as $tag ) {\n\t\t\t\t\t$tag                 = sanitize_term_field( 'slug', $tag, 0, 'post_tag', 'db' );\n\t\t\t\t\t$q['tag_slug__in'][] = $tag;\n\t\t\t\t}\n\t\t\t} elseif ( preg_match( '/[+\\r\\n\\t ]+/', $q['tag'] ) || ! empty( $q['cat'] ) ) {\n\t\t\t\t$tags = preg_split( '/[+\\r\\n\\t ]+/', $q['tag'] );\n\t\t\t\tforeach ( (array) $tags as $tag ) {\n\t\t\t\t\t$tag                  = sanitize_term_field( 'slug', $tag, 0, 'post_tag', 'db' );\n\t\t\t\t\t$q['tag_slug__and'][] = $tag;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$q['tag']            = sanitize_term_field( 'slug', $q['tag'], 0, 'post_tag', 'db' );\n\t\t\t\t$q['tag_slug__in'][] = $q['tag'];\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $q['tag_id'] ) ) {\n\t\t\t$q['tag_id'] = absint( $q['tag_id'] );\n\t\t\t$tax_query[] = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms'    => $q['tag_id'],\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $q['tag__in'] ) ) {\n\t\t\t$q['tag__in'] = array_map( 'absint', array_unique( (array) $q['tag__in'] ) );\n\t\t\t$tax_query[]  = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms'    => $q['tag__in'],\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $q['tag__not_in'] ) ) {\n\t\t\t$q['tag__not_in'] = array_map( 'absint', array_unique( (array) $q['tag__not_in'] ) );\n\t\t\t$tax_query[]      = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms'    => $q['tag__not_in'],\n\t\t\t\t'operator' => 'NOT IN',\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $q['tag__and'] ) ) {\n\t\t\t$q['tag__and'] = array_map( 'absint', array_unique( (array) $q['tag__and'] ) );\n\t\t\t$tax_query[]   = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms'    => $q['tag__and'],\n\t\t\t\t'operator' => 'AND',\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $q['tag_slug__in'] ) ) {\n\t\t\t$q['tag_slug__in'] = array_map( 'sanitize_title_for_query', array_unique( (array) $q['tag_slug__in'] ) );\n\t\t\t$tax_query[]       = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms'    => $q['tag_slug__in'],\n\t\t\t\t'field'    => 'slug',\n\t\t\t);\n\t\t}\n\n\t\tif ( ! empty( $q['tag_slug__and'] ) ) {\n\t\t\t$q['tag_slug__and'] = array_map( 'sanitize_title_for_query', array_unique( (array) $q['tag_slug__and'] ) );\n\t\t\t$tax_query[]        = array(\n\t\t\t\t'taxonomy' => 'post_tag',\n\t\t\t\t'terms'    => $q['tag_slug__and'],\n\t\t\t\t'field'    => 'slug',\n\t\t\t\t'operator' => 'AND',\n\t\t\t);\n\t\t}\n\n\t\t$this->tax_query = new WP_Tax_Query( $tax_query );\n\n\t\t/**\n\t\t * Fires after taxonomy-related query vars have been parsed.\n\t\t *\n\t\t * @since 3.7.0\n\t\t *\n\t\t * @param WP_Query $this The WP_Query instance.\n\t\t */\n\t\tdo_action( 'parse_tax_query', $this );\n\t}\n\n\t/**\n\t * Generates SQL for the WHERE clause based on passed search terms.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @global wpdb $wpdb WordPress database abstraction object.\n\t *\n\t * @param array $q Query variables.\n\t * @return string WHERE clause.\n\t */\n\tprotected function parse_search( &$q ) {\n\t\tglobal $wpdb;\n\n\t\t$search = '';\n\n\t\t// added slashes screw with quote grouping when done early, so done later\n\t\t$q['s'] = stripslashes( $q['s'] );\n\t\tif ( empty( $_GET['s'] ) && $this->is_main_query() ) {\n\t\t\t$q['s'] = urldecode( $q['s'] );\n\t\t}\n\t\t// there are no line breaks in <input /> fields\n\t\t$q['s']                  = str_replace( array( \"\\r\", \"\\n\" ), '', $q['s'] );\n\t\t$q['search_terms_count'] = 1;\n\t\tif ( ! empty( $q['sentence'] ) ) {\n\t\t\t$q['search_terms'] = array( $q['s'] );\n\t\t} else {\n\t\t\tif ( preg_match_all( '/\".*?(\"|$)|((?<=[\\t \",+])|^)[^\\t \",+]+/', $q['s'], $matches ) ) {\n\t\t\t\t$q['search_terms_count'] = count( $matches[0] );\n\t\t\t\t$q['search_terms']       = $this->parse_search_terms( $matches[0] );\n\t\t\t\t// if the search string has only short terms or stopwords, or is 10+ terms long, match it as sentence\n\t\t\t\tif ( empty( $q['search_terms'] ) || count( $q['search_terms'] ) > 9 ) {\n\t\t\t\t\t$q['search_terms'] = array( $q['s'] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$q['search_terms'] = array( $q['s'] );\n\t\t\t}\n\t\t}\n\n\t\t$n                         = ! empty( $q['exact'] ) ? '' : '%';\n\t\t$searchand                 = '';\n\t\t$q['search_orderby_title'] = array();\n\n\t\t/**\n\t\t * Filters the prefix that indicates that a search term should be excluded from results.\n\t\t *\n\t\t * @since 4.7.0\n\t\t *\n\t\t * @param string $exclusion_prefix The prefix. Default '-'. Returning\n\t\t *                                 an empty value disables exclusions.\n\t\t */\n\t\t$exclusion_prefix = apply_filters( 'wp_query_search_exclusion_prefix', '-' );\n\n\t\tforeach ( $q['search_terms'] as $term ) {\n\t\t\t// If there is an $exclusion_prefix, terms prefixed with it should be excluded.\n\t\t\t$exclude = $exclusion_prefix && ( $exclusion_prefix === substr( $term, 0, 1 ) );\n\t\t\tif ( $exclude ) {\n\t\t\t\t$like_op  = 'NOT LIKE';\n\t\t\t\t$andor_op = 'AND';\n\t\t\t\t$term     = substr( $term, 1 );\n\t\t\t} else {\n\t\t\t\t$like_op  = 'LIKE';\n\t\t\t\t$andor_op = 'OR';\n\t\t\t}\n\n\t\t\tif ( $n && ! $exclude ) {\n\t\t\t\t$like                        = '%' . $wpdb->esc_like( $term ) . '%';\n\t\t\t\t$q['search_orderby_title'][] = $wpdb->prepare( \"{$wpdb->posts}.post_title LIKE %s\", $like );\n\t\t\t}\n\n\t\t\t$like      = $n . $wpdb->esc_like( $term ) . $n;\n\t\t\t$search   .= $wpdb->prepare( \"{$searchand}(({$wpdb->posts}.post_title $like_op %s) $andor_op ({$wpdb->posts}.post_excerpt $like_op %s) $andor_op ({$wpdb->posts}.post_content $like_op %s))\", $like, $like, $like );\n\t\t\t$searchand = ' AND ';\n\t\t}\n\n\t\tif ( ! empty( $search ) ) {\n\t\t\t$search = \" AND ({$search}) \";\n\t\t\tif ( ! is_user_logged_in() ) {\n\t\t\t\t$search .= \" AND ({$wpdb->posts}.post_password = '') \";\n\t\t\t}\n\t\t}\n\n\t\treturn $search;\n\t}\n\n\t/**\n\t * Check if the terms are suitable for searching.\n\t *\n\t * Uses an array of stopwords (terms) that are excluded from the separate\n\t * term matching when searching for posts. The list of English stopwords is\n\t * the approximate search engines list, and is translatable.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @param string[] $terms Array of terms to check.\n\t * @return array Terms that are not stopwords.\n\t */\n\tprotected function parse_search_terms( $terms ) {\n\t\t$strtolower = function_exists( 'mb_strtolower' ) ? 'mb_strtolower' : 'strtolower';\n\t\t$checked    = array();\n\n\t\t$stopwords = $this->get_search_stopwords();\n\n\t\tforeach ( $terms as $term ) {\n\t\t\t// keep before/after spaces when term is for exact match\n\t\t\tif ( preg_match( '/^\".+\"$/', $term ) ) {\n\t\t\t\t$term = trim( $term, \"\\\"'\" );\n\t\t\t} else {\n\t\t\t\t$term = trim( $term, \"\\\"' \" );\n\t\t\t}\n\n\t\t\t// Avoid single A-Z and single dashes.\n\t\t\tif ( ! $term || ( 1 === strlen( $term ) && preg_match( '/^[a-z\\-]$/i', $term ) ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( in_array( call_user_func( $strtolower, $term ), $stopwords, true ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$checked[] = $term;\n\t\t}\n\n\t\treturn $checked;\n\t}\n\n\t/**\n\t * Retrieve stopwords used when parsing search terms.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @return array Stopwords.\n\t */\n\tprotected function get_search_stopwords() {\n\t\tif ( isset( $this->stopwords ) ) {\n\t\t\treturn $this->stopwords;\n\t\t}\n\n\t\t/* translators: This is a comma-separated list of very common words that should be excluded from a search,\n\t\t * like a, an, and the. These are usually called \"stopwords\". You should not simply translate these individual\n\t\t * words into your language. Instead, look for and provide commonly accepted stopwords in your language.\n\t\t */\n\t\t$words = explode(\n\t\t\t',',\n\t\t\t_x(\n\t\t\t\t'about,an,are,as,at,be,by,com,for,from,how,in,is,it,of,on,or,that,the,this,to,was,what,when,where,who,will,with,www',\n\t\t\t\t'Comma-separated list of search stopwords in your language'\n\t\t\t)\n\t\t);\n\n\t\t$stopwords = array();\n\t\tforeach ( $words as $word ) {\n\t\t\t$word = trim( $word, \"\\r\\n\\t \" );\n\t\t\tif ( $word ) {\n\t\t\t\t$stopwords[] = $word;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Filters stopwords used when parsing search terms.\n\t\t *\n\t\t * @since 3.7.0\n\t\t *\n\t\t * @param string[] $stopwords Array of stopwords.\n\t\t */\n\t\t$this->stopwords = apply_filters( 'wp_search_stopwords', $stopwords );\n\t\treturn $this->stopwords;\n\t}\n\n\t/**\n\t * Generates SQL for the ORDER BY condition based on passed search terms.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @global wpdb $wpdb WordPress database abstraction object.\n\t *\n\t * @param array $q Query variables.\n\t * @return string ORDER BY clause.\n\t */\n\tprotected function parse_search_order( &$q ) {\n\t\tglobal $wpdb;\n\n\t\tif ( $q['search_terms_count'] > 1 ) {\n\t\t\t$num_terms = count( $q['search_orderby_title'] );\n\n\t\t\t// If the search terms contain negative queries, don't bother ordering by sentence matches.\n\t\t\t$like = '';\n\t\t\tif ( ! preg_match( '/(?:\\s|^)\\-/', $q['s'] ) ) {\n\t\t\t\t$like = '%' . $wpdb->esc_like( $q['s'] ) . '%';\n\t\t\t}\n\n\t\t\t$search_orderby = '';\n\n\t\t\t// sentence match in 'post_title'\n\t\t\tif ( $like ) {\n\t\t\t\t$search_orderby .= $wpdb->prepare( \"WHEN {$wpdb->posts}.post_title LIKE %s THEN 1 \", $like );\n\t\t\t}\n\n\t\t\t// sanity limit, sort as sentence when more than 6 terms\n\t\t\t// (few searches are longer than 6 terms and most titles are not)\n\t\t\tif ( $num_terms < 7 ) {\n\t\t\t\t// all words in title\n\t\t\t\t$search_orderby .= 'WHEN ' . implode( ' AND ', $q['search_orderby_title'] ) . ' THEN 2 ';\n\t\t\t\t// any word in title, not needed when $num_terms == 1\n\t\t\t\tif ( $num_terms > 1 ) {\n\t\t\t\t\t$search_orderby .= 'WHEN ' . implode( ' OR ', $q['search_orderby_title'] ) . ' THEN 3 ';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Sentence match in 'post_content' and 'post_excerpt'.\n\t\t\tif ( $like ) {\n\t\t\t\t$search_orderby .= $wpdb->prepare( \"WHEN {$wpdb->posts}.post_excerpt LIKE %s THEN 4 \", $like );\n\t\t\t\t$search_orderby .= $wpdb->prepare( \"WHEN {$wpdb->posts}.post_content LIKE %s THEN 5 \", $like );\n\t\t\t}\n\n\t\t\tif ( $search_orderby ) {\n\t\t\t\t$search_orderby = '(CASE ' . $search_orderby . 'ELSE 6 END)';\n\t\t\t}\n\t\t} else {\n\t\t\t// single word or sentence search\n\t\t\t$search_orderby = reset( $q['search_orderby_title'] ) . ' DESC';\n\t\t}\n\n\t\treturn $search_orderby;\n\t}\n\n\t/**\n\t * Converts the given orderby alias (if allowed) to a properly-prefixed value.\n\t *\n\t * @since 4.0.0\n\t *\n\t * @global wpdb $wpdb WordPress database abstraction object.\n\t *\n\t * @param string $orderby Alias for the field to order by.\n\t * @return string|false Table-prefixed value to used in the ORDER clause. False otherwise.\n\t */\n\tprotected function parse_orderby( $orderby ) {\n\t\tglobal $wpdb;\n\n\t\t// Used to filter values.\n\t\t$allowed_keys = array(\n\t\t\t'post_name',\n\t\t\t'post_author',\n\t\t\t'post_date',\n\t\t\t'post_title',\n\t\t\t'post_modified',\n\t\t\t'post_parent',\n\t\t\t'post_type',\n\t\t\t'name',\n\t\t\t'author',\n\t\t\t'date',\n\t\t\t'title',\n\t\t\t'modified',\n\t\t\t'parent',\n\t\t\t'type',\n\t\t\t'ID',\n\t\t\t'menu_order',\n\t\t\t'comment_count',\n\t\t\t'rand',\n\t\t\t'post__in',\n\t\t\t'post_parent__in',\n\t\t\t'post_name__in',\n\t\t);\n\n\t\t$primary_meta_key   = '';\n\t\t$primary_meta_query = false;\n\t\t$meta_clauses       = $this->meta_query->get_clauses();\n\t\tif ( ! empty( $meta_clauses ) ) {\n\t\t\t$primary_meta_query = reset( $meta_clauses );\n\n\t\t\tif ( ! empty( $primary_meta_query['key'] ) ) {\n\t\t\t\t$primary_meta_key = $primary_meta_query['key'];\n\t\t\t\t$allowed_keys[]   = $primary_meta_key;\n\t\t\t}\n\n\t\t\t$allowed_keys[] = 'meta_value';\n\t\t\t$allowed_keys[] = 'meta_value_num';\n\t\t\t$allowed_keys   = array_merge( $allowed_keys, array_keys( $meta_clauses ) );\n\t\t}\n\n\t\t// If RAND() contains a seed value, sanitize and add to allowed keys.\n\t\t$rand_with_seed = false;\n\t\tif ( preg_match( '/RAND\\(([0-9]+)\\)/i', $orderby, $matches ) ) {\n\t\t\t$orderby        = sprintf( 'RAND(%s)', intval( $matches[1] ) );\n\t\t\t$allowed_keys[] = $orderby;\n\t\t\t$rand_with_seed = true;\n\t\t}\n\n\t\tif ( ! in_array( $orderby, $allowed_keys, true ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$orderby_clause = '';\n\n\t\tswitch ( $orderby ) {\n\t\t\tcase 'post_name':\n\t\t\tcase 'post_author':\n\t\t\tcase 'post_date':\n\t\t\tcase 'post_title':\n\t\t\tcase 'post_modified':\n\t\t\tcase 'post_parent':\n\t\t\tcase 'post_type':\n\t\t\tcase 'ID':\n\t\t\tcase 'menu_order':\n\t\t\tcase 'comment_count':\n\t\t\t\t$orderby_clause = \"{$wpdb->posts}.{$orderby}\";\n\t\t\t\tbreak;\n\t\t\tcase 'rand':\n\t\t\t\t$orderby_clause = 'RAND()';\n\t\t\t\tbreak;\n\t\t\tcase $primary_meta_key:\n\t\t\tcase 'meta_value':\n\t\t\t\tif ( ! empty( $primary_meta_query['type'] ) ) {\n\t\t\t\t\t$orderby_clause = \"CAST({$primary_meta_query['alias']}.meta_value AS {$primary_meta_query['cast']})\";\n\t\t\t\t} else {\n\t\t\t\t\t$orderby_clause = \"{$primary_meta_query['alias']}.meta_value\";\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'meta_value_num':\n\t\t\t\t$orderby_clause = \"{$primary_meta_query['alias']}.meta_value+0\";\n\t\t\t\tbreak;\n\t\t\tcase 'post__in':\n\t\t\t\tif ( ! empty( $this->query_vars['post__in'] ) ) {\n\t\t\t\t\t$orderby_clause = \"FIELD({$wpdb->posts}.ID,\" . implode( ',', array_map( 'absint', $this->query_vars['post__in'] ) ) . ')';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'post_parent__in':\n\t\t\t\tif ( ! empty( $this->query_vars['post_parent__in'] ) ) {\n\t\t\t\t\t$orderby_clause = \"FIELD( {$wpdb->posts}.post_parent,\" . implode( ', ', array_map( 'absint', $this->query_vars['post_parent__in'] ) ) . ' )';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'post_name__in':\n\t\t\t\tif ( ! empty( $this->query_vars['post_name__in'] ) ) {\n\t\t\t\t\t$post_name__in        = array_map( 'sanitize_title_for_query', $this->query_vars['post_name__in'] );\n\t\t\t\t\t$post_name__in_string = \"'\" . implode( \"','\", $post_name__in ) . \"'\";\n\t\t\t\t\t$orderby_clause       = \"FIELD( {$wpdb->posts}.post_name,\" . $post_name__in_string . ' )';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ( array_key_exists( $orderby, $meta_clauses ) ) {\n\t\t\t\t\t// $orderby corresponds to a meta_query clause.\n\t\t\t\t\t$meta_clause    = $meta_clauses[ $orderby ];\n\t\t\t\t\t$orderby_clause = \"CAST({$meta_clause['alias']}.meta_value AS {$meta_clause['cast']})\";\n\t\t\t\t} elseif ( $rand_with_seed ) {\n\t\t\t\t\t$orderby_clause = $orderby;\n\t\t\t\t} else {\n\t\t\t\t\t// Default: order by post field.\n\t\t\t\t\t$orderby_clause = \"{$wpdb->posts}.post_\" . sanitize_key( $orderby );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $orderby_clause;\n\t}\n\n\t/**\n\t * Parse an 'order' query variable and cast it to ASC or DESC as necessary.\n\t *\n\t * @since 4.0.0\n\t *\n\t * @param string $order The 'order' query variable.\n\t * @return string The sanitized 'order' query variable.\n\t */\n\tprotected function parse_order( $order ) {\n\t\tif ( ! is_string( $order ) || empty( $order ) ) {\n\t\t\treturn 'DESC';\n\t\t}\n\n\t\tif ( 'ASC' === strtoupper( $order ) ) {\n\t\t\treturn 'ASC';\n\t\t} else {\n\t\t\treturn 'DESC';\n\t\t}\n\t}\n\n\t/**\n\t * Sets the 404 property and saves whether query is feed.\n\t *\n\t * @since 2.0.0\n\t */\n\tpublic function set_404() {\n\t\t$is_feed = $this->is_feed;\n\n\t\t$this->init_query_flags();\n\t\t$this->is_404 = true;\n\n\t\t$this->is_feed = $is_feed;\n\t}\n\n\t/**\n\t * Retrieve query variable.\n\t *\n\t * @since 1.5.0\n\t * @since 3.9.0 The `$default` argument was introduced.\n\t *\n\t * @param string $query_var Query variable key.\n\t * @param mixed  $default   Optional. Value to return if the query variable is not set. Default empty.\n\t * @return mixed Contents of the query variable.\n\t */\n\tpublic function get( $query_var, $default = '' ) {\n\t\tif ( isset( $this->query_vars[ $query_var ] ) ) {\n\t\t\treturn $this->query_vars[ $query_var ];\n\t\t}\n\n\t\treturn $default;\n\t}\n\n\t/**\n\t * Set query variable.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param string $query_var Query variable key.\n\t * @param mixed  $value     Query variable value.\n\t */\n\tpublic function set( $query_var, $value ) {\n\t\t$this->query_vars[ $query_var ] = $value;\n\t}\n\n\t/**\n\t * Retrieves an array of posts based on query variables.\n\t *\n\t * There are a few filters and actions that can be used to modify the post\n\t * database query.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @return WP_Post[]|int[] Array of post objects or post IDs.\n\t */\n\tpublic function get_posts() {\n\t\tglobal $wpdb;\n\n\t\t$this->parse_query();\n\n\t\t/**\n\t\t * Fires after the query variable object is created, but before the actual query is run.\n\t\t *\n\t\t * Note: If using conditional tags, use the method versions within the passed instance\n\t\t * (e.g. $this->is_main_query() instead of is_main_query()). This is because the functions\n\t\t * like is_main_query() test against the global $wp_query instance, not the passed one.\n\t\t *\n\t\t * @since 2.0.0\n\t\t *\n\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t */\n\t\tdo_action_ref_array( 'pre_get_posts', array( &$this ) );\n\n\t\t// Shorthand.\n\t\t$q = &$this->query_vars;\n\n\t\t// Fill again in case pre_get_posts unset some vars.\n\t\t$q = $this->fill_query_vars( $q );\n\n\t\t// Parse meta query\n\t\t$this->meta_query = new WP_Meta_Query();\n\t\t$this->meta_query->parse_query_vars( $q );\n\n\t\t// Set a flag if a pre_get_posts hook changed the query vars.\n\t\t$hash = md5( serialize( $this->query_vars ) );\n\t\tif ( $hash != $this->query_vars_hash ) {\n\t\t\t$this->query_vars_changed = true;\n\t\t\t$this->query_vars_hash    = $hash;\n\t\t}\n\t\tunset( $hash );\n\n\t\t// First let's clear some variables\n\t\t$distinct         = '';\n\t\t$whichauthor      = '';\n\t\t$whichmimetype    = '';\n\t\t$where            = '';\n\t\t$limits           = '';\n\t\t$join             = '';\n\t\t$search           = '';\n\t\t$groupby          = '';\n\t\t$post_status_join = false;\n\t\t$page             = 1;\n\n\t\tif ( isset( $q['caller_get_posts'] ) ) {\n\t\t\t_deprecated_argument(\n\t\t\t\t'WP_Query',\n\t\t\t\t'3.1.0',\n\t\t\t\t/* translators: 1: caller_get_posts, 2: ignore_sticky_posts */\n\t\t\t\tsprintf(\n\t\t\t\t\t__( '%1$s is deprecated. Use %2$s instead.' ),\n\t\t\t\t\t'<code>caller_get_posts</code>',\n\t\t\t\t\t'<code>ignore_sticky_posts</code>'\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tif ( ! isset( $q['ignore_sticky_posts'] ) ) {\n\t\t\t\t$q['ignore_sticky_posts'] = $q['caller_get_posts'];\n\t\t\t}\n\t\t}\n\n\t\tif ( ! isset( $q['ignore_sticky_posts'] ) ) {\n\t\t\t$q['ignore_sticky_posts'] = false;\n\t\t}\n\n\t\tif ( ! isset( $q['suppress_filters'] ) ) {\n\t\t\t$q['suppress_filters'] = false;\n\t\t}\n\n\t\tif ( ! isset( $q['cache_results'] ) ) {\n\t\t\tif ( wp_using_ext_object_cache() ) {\n\t\t\t\t$q['cache_results'] = false;\n\t\t\t} else {\n\t\t\t\t$q['cache_results'] = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( ! isset( $q['update_post_term_cache'] ) ) {\n\t\t\t$q['update_post_term_cache'] = true;\n\t\t}\n\n\t\tif ( ! isset( $q['lazy_load_term_meta'] ) ) {\n\t\t\t$q['lazy_load_term_meta'] = $q['update_post_term_cache'];\n\t\t}\n\n\t\tif ( ! isset( $q['update_post_meta_cache'] ) ) {\n\t\t\t$q['update_post_meta_cache'] = true;\n\t\t}\n\n\t\tif ( ! isset( $q['post_type'] ) ) {\n\t\t\tif ( $this->is_search ) {\n\t\t\t\t$q['post_type'] = 'any';\n\t\t\t} else {\n\t\t\t\t$q['post_type'] = '';\n\t\t\t}\n\t\t}\n\t\t$post_type = $q['post_type'];\n\t\tif ( empty( $q['posts_per_page'] ) ) {\n\t\t\t$q['posts_per_page'] = get_option( 'posts_per_page' );\n\t\t}\n\t\tif ( isset( $q['showposts'] ) && $q['showposts'] ) {\n\t\t\t$q['showposts']      = (int) $q['showposts'];\n\t\t\t$q['posts_per_page'] = $q['showposts'];\n\t\t}\n\t\tif ( ( isset( $q['posts_per_archive_page'] ) && $q['posts_per_archive_page'] != 0 ) && ( $this->is_archive || $this->is_search ) ) {\n\t\t\t$q['posts_per_page'] = $q['posts_per_archive_page'];\n\t\t}\n\t\tif ( ! isset( $q['nopaging'] ) ) {\n\t\t\tif ( $q['posts_per_page'] == -1 ) {\n\t\t\t\t$q['nopaging'] = true;\n\t\t\t} else {\n\t\t\t\t$q['nopaging'] = false;\n\t\t\t}\n\t\t}\n\n\t\tif ( $this->is_feed ) {\n\t\t\t// This overrides posts_per_page.\n\t\t\tif ( ! empty( $q['posts_per_rss'] ) ) {\n\t\t\t\t$q['posts_per_page'] = $q['posts_per_rss'];\n\t\t\t} else {\n\t\t\t\t$q['posts_per_page'] = get_option( 'posts_per_rss' );\n\t\t\t}\n\t\t\t$q['nopaging'] = false;\n\t\t}\n\t\t$q['posts_per_page'] = (int) $q['posts_per_page'];\n\t\tif ( $q['posts_per_page'] < -1 ) {\n\t\t\t$q['posts_per_page'] = abs( $q['posts_per_page'] );\n\t\t} elseif ( $q['posts_per_page'] == 0 ) {\n\t\t\t$q['posts_per_page'] = 1;\n\t\t}\n\n\t\tif ( ! isset( $q['comments_per_page'] ) || $q['comments_per_page'] == 0 ) {\n\t\t\t$q['comments_per_page'] = get_option( 'comments_per_page' );\n\t\t}\n\n\t\tif ( $this->is_home && ( empty( $this->query ) || $q['preview'] == 'true' ) && ( 'page' == get_option( 'show_on_front' ) ) && get_option( 'page_on_front' ) ) {\n\t\t\t$this->is_page = true;\n\t\t\t$this->is_home = false;\n\t\t\t$q['page_id']  = get_option( 'page_on_front' );\n\t\t}\n\n\t\tif ( isset( $q['page'] ) ) {\n\t\t\t$q['page'] = trim( $q['page'], '/' );\n\t\t\t$q['page'] = absint( $q['page'] );\n\t\t}\n\n\t\t// If true, forcibly turns off SQL_CALC_FOUND_ROWS even when limits are present.\n\t\tif ( isset( $q['no_found_rows'] ) ) {\n\t\t\t$q['no_found_rows'] = (bool) $q['no_found_rows'];\n\t\t} else {\n\t\t\t$q['no_found_rows'] = false;\n\t\t}\n\n\t\tswitch ( $q['fields'] ) {\n\t\t\tcase 'ids':\n\t\t\t\t$fields = \"{$wpdb->posts}.ID\";\n\t\t\t\tbreak;\n\t\t\tcase 'id=>parent':\n\t\t\t\t$fields = \"{$wpdb->posts}.ID, {$wpdb->posts}.post_parent\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$fields = \"{$wpdb->posts}.*\";\n\t\t}\n\n\t\tif ( '' !== $q['menu_order'] ) {\n\t\t\t$where .= \" AND {$wpdb->posts}.menu_order = \" . $q['menu_order'];\n\t\t}\n\t\t// The \"m\" parameter is meant for months but accepts datetimes of varying specificity\n\t\tif ( $q['m'] ) {\n\t\t\t$where .= \" AND YEAR({$wpdb->posts}.post_date)=\" . substr( $q['m'], 0, 4 );\n\t\t\tif ( strlen( $q['m'] ) > 5 ) {\n\t\t\t\t$where .= \" AND MONTH({$wpdb->posts}.post_date)=\" . substr( $q['m'], 4, 2 );\n\t\t\t}\n\t\t\tif ( strlen( $q['m'] ) > 7 ) {\n\t\t\t\t$where .= \" AND DAYOFMONTH({$wpdb->posts}.post_date)=\" . substr( $q['m'], 6, 2 );\n\t\t\t}\n\t\t\tif ( strlen( $q['m'] ) > 9 ) {\n\t\t\t\t$where .= \" AND HOUR({$wpdb->posts}.post_date)=\" . substr( $q['m'], 8, 2 );\n\t\t\t}\n\t\t\tif ( strlen( $q['m'] ) > 11 ) {\n\t\t\t\t$where .= \" AND MINUTE({$wpdb->posts}.post_date)=\" . substr( $q['m'], 10, 2 );\n\t\t\t}\n\t\t\tif ( strlen( $q['m'] ) > 13 ) {\n\t\t\t\t$where .= \" AND SECOND({$wpdb->posts}.post_date)=\" . substr( $q['m'], 12, 2 );\n\t\t\t}\n\t\t}\n\n\t\t// Handle the other individual date parameters\n\t\t$date_parameters = array();\n\n\t\tif ( '' !== $q['hour'] ) {\n\t\t\t$date_parameters['hour'] = $q['hour'];\n\t\t}\n\n\t\tif ( '' !== $q['minute'] ) {\n\t\t\t$date_parameters['minute'] = $q['minute'];\n\t\t}\n\n\t\tif ( '' !== $q['second'] ) {\n\t\t\t$date_parameters['second'] = $q['second'];\n\t\t}\n\n\t\tif ( $q['year'] ) {\n\t\t\t$date_parameters['year'] = $q['year'];\n\t\t}\n\n\t\tif ( $q['monthnum'] ) {\n\t\t\t$date_parameters['monthnum'] = $q['monthnum'];\n\t\t}\n\n\t\tif ( $q['w'] ) {\n\t\t\t$date_parameters['week'] = $q['w'];\n\t\t}\n\n\t\tif ( $q['day'] ) {\n\t\t\t$date_parameters['day'] = $q['day'];\n\t\t}\n\n\t\tif ( $date_parameters ) {\n\t\t\t$date_query = new WP_Date_Query( array( $date_parameters ) );\n\t\t\t$where     .= $date_query->get_sql();\n\t\t}\n\t\tunset( $date_parameters, $date_query );\n\n\t\t// Handle complex date queries\n\t\tif ( ! empty( $q['date_query'] ) ) {\n\t\t\t$this->date_query = new WP_Date_Query( $q['date_query'] );\n\t\t\t$where           .= $this->date_query->get_sql();\n\t\t}\n\n\t\t// If we've got a post_type AND it's not \"any\" post_type.\n\t\tif ( ! empty( $q['post_type'] ) && 'any' != $q['post_type'] ) {\n\t\t\tforeach ( (array) $q['post_type'] as $_post_type ) {\n\t\t\t\t$ptype_obj = get_post_type_object( $_post_type );\n\t\t\t\tif ( ! $ptype_obj || ! $ptype_obj->query_var || empty( $q[ $ptype_obj->query_var ] ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( ! $ptype_obj->hierarchical ) {\n\t\t\t\t\t// Non-hierarchical post types can directly use 'name'.\n\t\t\t\t\t$q['name'] = $q[ $ptype_obj->query_var ];\n\t\t\t\t} else {\n\t\t\t\t\t// Hierarchical post types will operate through 'pagename'.\n\t\t\t\t\t$q['pagename'] = $q[ $ptype_obj->query_var ];\n\t\t\t\t\t$q['name']     = '';\n\t\t\t\t}\n\n\t\t\t\t// Only one request for a slug is possible, this is why name & pagename are overwritten above.\n\t\t\t\tbreak;\n\t\t\t} //end foreach\n\t\t\tunset( $ptype_obj );\n\t\t}\n\n\t\tif ( '' !== $q['title'] ) {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.post_title = %s\", stripslashes( $q['title'] ) );\n\t\t}\n\n\t\t// Parameters related to 'post_name'.\n\t\tif ( '' != $q['name'] ) {\n\t\t\t$q['name'] = sanitize_title_for_query( $q['name'] );\n\t\t\t$where    .= \" AND {$wpdb->posts}.post_name = '\" . $q['name'] . \"'\";\n\t\t} elseif ( '' != $q['pagename'] ) {\n\t\t\tif ( isset( $this->queried_object_id ) ) {\n\t\t\t\t$reqpage = $this->queried_object_id;\n\t\t\t} else {\n\t\t\t\tif ( 'page' != $q['post_type'] ) {\n\t\t\t\t\tforeach ( (array) $q['post_type'] as $_post_type ) {\n\t\t\t\t\t\t$ptype_obj = get_post_type_object( $_post_type );\n\t\t\t\t\t\tif ( ! $ptype_obj || ! $ptype_obj->hierarchical ) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$reqpage = get_page_by_path( $q['pagename'], OBJECT, $_post_type );\n\t\t\t\t\t\tif ( $reqpage ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tunset( $ptype_obj );\n\t\t\t\t} else {\n\t\t\t\t\t$reqpage = get_page_by_path( $q['pagename'] );\n\t\t\t\t}\n\t\t\t\tif ( ! empty( $reqpage ) ) {\n\t\t\t\t\t$reqpage = $reqpage->ID;\n\t\t\t\t} else {\n\t\t\t\t\t$reqpage = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$page_for_posts = get_option( 'page_for_posts' );\n\t\t\tif ( ( 'page' != get_option( 'show_on_front' ) ) || empty( $page_for_posts ) || ( $reqpage != $page_for_posts ) ) {\n\t\t\t\t$q['pagename'] = sanitize_title_for_query( wp_basename( $q['pagename'] ) );\n\t\t\t\t$q['name']     = $q['pagename'];\n\t\t\t\t$where        .= \" AND ({$wpdb->posts}.ID = '$reqpage')\";\n\t\t\t\t$reqpage_obj   = get_post( $reqpage );\n\t\t\t\tif ( is_object( $reqpage_obj ) && 'attachment' == $reqpage_obj->post_type ) {\n\t\t\t\t\t$this->is_attachment = true;\n\t\t\t\t\t$post_type           = $q['post_type'] = 'attachment';\n\t\t\t\t\t$this->is_page       = true;\n\t\t\t\t\t$q['attachment_id']  = $reqpage;\n\t\t\t\t}\n\t\t\t}\n\t\t} elseif ( '' != $q['attachment'] ) {\n\t\t\t$q['attachment'] = sanitize_title_for_query( wp_basename( $q['attachment'] ) );\n\t\t\t$q['name']       = $q['attachment'];\n\t\t\t$where          .= \" AND {$wpdb->posts}.post_name = '\" . $q['attachment'] . \"'\";\n\t\t} elseif ( is_array( $q['post_name__in'] ) && ! empty( $q['post_name__in'] ) ) {\n\t\t\t$q['post_name__in'] = array_map( 'sanitize_title_for_query', $q['post_name__in'] );\n\t\t\t$post_name__in      = \"'\" . implode( \"','\", $q['post_name__in'] ) . \"'\";\n\t\t\t$where             .= \" AND {$wpdb->posts}.post_name IN ($post_name__in)\";\n\t\t}\n\n\t\t// If an attachment is requested by number, let it supersede any post number.\n\t\tif ( $q['attachment_id'] ) {\n\t\t\t$q['p'] = absint( $q['attachment_id'] );\n\t\t}\n\n\t\t// If a post number is specified, load that post\n\t\tif ( $q['p'] ) {\n\t\t\t$where .= \" AND {$wpdb->posts}.ID = \" . $q['p'];\n\t\t} elseif ( $q['post__in'] ) {\n\t\t\t$post__in = implode( ',', array_map( 'absint', $q['post__in'] ) );\n\t\t\t$where   .= \" AND {$wpdb->posts}.ID IN ($post__in)\";\n\t\t} elseif ( $q['post__not_in'] ) {\n\t\t\t$post__not_in = implode( ',', array_map( 'absint', $q['post__not_in'] ) );\n\t\t\t$where       .= \" AND {$wpdb->posts}.ID NOT IN ($post__not_in)\";\n\t\t}\n\n\t\tif ( is_numeric( $q['post_parent'] ) ) {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.post_parent = %d \", $q['post_parent'] );\n\t\t} elseif ( $q['post_parent__in'] ) {\n\t\t\t$post_parent__in = implode( ',', array_map( 'absint', $q['post_parent__in'] ) );\n\t\t\t$where          .= \" AND {$wpdb->posts}.post_parent IN ($post_parent__in)\";\n\t\t} elseif ( $q['post_parent__not_in'] ) {\n\t\t\t$post_parent__not_in = implode( ',', array_map( 'absint', $q['post_parent__not_in'] ) );\n\t\t\t$where              .= \" AND {$wpdb->posts}.post_parent NOT IN ($post_parent__not_in)\";\n\t\t}\n\n\t\tif ( $q['page_id'] ) {\n\t\t\tif ( ( 'page' != get_option( 'show_on_front' ) ) || ( $q['page_id'] != get_option( 'page_for_posts' ) ) ) {\n\t\t\t\t$q['p'] = $q['page_id'];\n\t\t\t\t$where  = \" AND {$wpdb->posts}.ID = \" . $q['page_id'];\n\t\t\t}\n\t\t}\n\n\t\t// If a search pattern is specified, load the posts that match.\n\t\tif ( strlen( $q['s'] ) ) {\n\t\t\t$search = $this->parse_search( $q );\n\t\t}\n\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the search SQL that is used in the WHERE clause of WP_Query.\n\t\t\t *\n\t\t\t * @since 3.0.0\n\t\t\t *\n\t\t\t * @param string   $search Search SQL for WHERE clause.\n\t\t\t * @param WP_Query $this   The current WP_Query object.\n\t\t\t */\n\t\t\t$search = apply_filters_ref_array( 'posts_search', array( $search, &$this ) );\n\t\t}\n\n\t\t// Taxonomies\n\t\tif ( ! $this->is_singular ) {\n\t\t\t$this->parse_tax_query( $q );\n\n\t\t\t$clauses = $this->tax_query->get_sql( $wpdb->posts, 'ID' );\n\n\t\t\t$join  .= $clauses['join'];\n\t\t\t$where .= $clauses['where'];\n\t\t}\n\n\t\tif ( $this->is_tax ) {\n\t\t\tif ( empty( $post_type ) ) {\n\t\t\t\t// Do a fully inclusive search for currently registered post types of queried taxonomies\n\t\t\t\t$post_type  = array();\n\t\t\t\t$taxonomies = array_keys( $this->tax_query->queried_terms );\n\t\t\t\tforeach ( get_post_types( array( 'exclude_from_search' => false ) ) as $pt ) {\n\t\t\t\t\t$object_taxonomies = $pt === 'attachment' ? get_taxonomies_for_attachments() : get_object_taxonomies( $pt );\n\t\t\t\t\tif ( array_intersect( $taxonomies, $object_taxonomies ) ) {\n\t\t\t\t\t\t$post_type[] = $pt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( ! $post_type ) {\n\t\t\t\t\t$post_type = 'any';\n\t\t\t\t} elseif ( count( $post_type ) == 1 ) {\n\t\t\t\t\t$post_type = $post_type[0];\n\t\t\t\t}\n\n\t\t\t\t$post_status_join = true;\n\t\t\t} elseif ( in_array( 'attachment', (array) $post_type ) ) {\n\t\t\t\t$post_status_join = true;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Ensure that 'taxonomy', 'term', 'term_id', 'cat', and\n\t\t * 'category_name' vars are set for backward compatibility.\n\t\t */\n\t\tif ( ! empty( $this->tax_query->queried_terms ) ) {\n\n\t\t\t/*\n\t\t\t * Set 'taxonomy', 'term', and 'term_id' to the\n\t\t\t * first taxonomy other than 'post_tag' or 'category'.\n\t\t\t */\n\t\t\tif ( ! isset( $q['taxonomy'] ) ) {\n\t\t\t\tforeach ( $this->tax_query->queried_terms as $queried_taxonomy => $queried_items ) {\n\t\t\t\t\tif ( empty( $queried_items['terms'][0] ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! in_array( $queried_taxonomy, array( 'category', 'post_tag' ) ) ) {\n\t\t\t\t\t\t$q['taxonomy'] = $queried_taxonomy;\n\n\t\t\t\t\t\tif ( 'slug' === $queried_items['field'] ) {\n\t\t\t\t\t\t\t$q['term'] = $queried_items['terms'][0];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$q['term_id'] = $queried_items['terms'][0];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Take the first one we find.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 'cat', 'category_name', 'tag_id'\n\t\t\tforeach ( $this->tax_query->queried_terms as $queried_taxonomy => $queried_items ) {\n\t\t\t\tif ( empty( $queried_items['terms'][0] ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( 'category' === $queried_taxonomy ) {\n\t\t\t\t\t$the_cat = get_term_by( $queried_items['field'], $queried_items['terms'][0], 'category' );\n\t\t\t\t\tif ( $the_cat ) {\n\t\t\t\t\t\t$this->set( 'cat', $the_cat->term_id );\n\t\t\t\t\t\t$this->set( 'category_name', $the_cat->slug );\n\t\t\t\t\t}\n\t\t\t\t\tunset( $the_cat );\n\t\t\t\t}\n\n\t\t\t\tif ( 'post_tag' === $queried_taxonomy ) {\n\t\t\t\t\t$the_tag = get_term_by( $queried_items['field'], $queried_items['terms'][0], 'post_tag' );\n\t\t\t\t\tif ( $the_tag ) {\n\t\t\t\t\t\t$this->set( 'tag_id', $the_tag->term_id );\n\t\t\t\t\t}\n\t\t\t\t\tunset( $the_tag );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $this->tax_query->queries ) || ! empty( $this->meta_query->queries ) ) {\n\t\t\t$groupby = \"{$wpdb->posts}.ID\";\n\t\t}\n\n\t\t// Author/user stuff\n\n\t\tif ( ! empty( $q['author'] ) && $q['author'] != '0' ) {\n\t\t\t$q['author'] = addslashes_gpc( '' . urldecode( $q['author'] ) );\n\t\t\t$authors     = array_unique( array_map( 'intval', preg_split( '/[,\\s]+/', $q['author'] ) ) );\n\t\t\tforeach ( $authors as $author ) {\n\t\t\t\t$key         = $author > 0 ? 'author__in' : 'author__not_in';\n\t\t\t\t$q[ $key ][] = abs( $author );\n\t\t\t}\n\t\t\t$q['author'] = implode( ',', $authors );\n\t\t}\n\n\t\tif ( ! empty( $q['author__not_in'] ) ) {\n\t\t\t$author__not_in = implode( ',', array_map( 'absint', array_unique( (array) $q['author__not_in'] ) ) );\n\t\t\t$where         .= \" AND {$wpdb->posts}.post_author NOT IN ($author__not_in) \";\n\t\t} elseif ( ! empty( $q['author__in'] ) ) {\n\t\t\t$author__in = implode( ',', array_map( 'absint', array_unique( (array) $q['author__in'] ) ) );\n\t\t\t$where     .= \" AND {$wpdb->posts}.post_author IN ($author__in) \";\n\t\t}\n\n\t\t// Author stuff for nice URLs\n\n\t\tif ( '' != $q['author_name'] ) {\n\t\t\tif ( strpos( $q['author_name'], '/' ) !== false ) {\n\t\t\t\t$q['author_name'] = explode( '/', $q['author_name'] );\n\t\t\t\tif ( $q['author_name'][ count( $q['author_name'] ) - 1 ] ) {\n\t\t\t\t\t$q['author_name'] = $q['author_name'][ count( $q['author_name'] ) - 1 ]; // no trailing slash\n\t\t\t\t} else {\n\t\t\t\t\t$q['author_name'] = $q['author_name'][ count( $q['author_name'] ) - 2 ]; // there was a trailing slash\n\t\t\t\t}\n\t\t\t}\n\t\t\t$q['author_name'] = sanitize_title_for_query( $q['author_name'] );\n\t\t\t$q['author']      = get_user_by( 'slug', $q['author_name'] );\n\t\t\tif ( $q['author'] ) {\n\t\t\t\t$q['author'] = $q['author']->ID;\n\t\t\t}\n\t\t\t$whichauthor .= \" AND ({$wpdb->posts}.post_author = \" . absint( $q['author'] ) . ')';\n\t\t}\n\n\t\t// Matching by comment count.\n\t\tif ( isset( $q['comment_count'] ) ) {\n\t\t\t// Numeric comment count is converted to array format.\n\t\t\tif ( is_numeric( $q['comment_count'] ) ) {\n\t\t\t\t$q['comment_count'] = array(\n\t\t\t\t\t'value' => intval( $q['comment_count'] ),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( isset( $q['comment_count']['value'] ) ) {\n\t\t\t\t$q['comment_count'] = array_merge(\n\t\t\t\t\tarray(\n\t\t\t\t\t\t'compare' => '=',\n\t\t\t\t\t),\n\t\t\t\t\t$q['comment_count']\n\t\t\t\t);\n\n\t\t\t\t// Fallback for invalid compare operators is '='.\n\t\t\t\t$compare_operators = array( '=', '!=', '>', '>=', '<', '<=' );\n\t\t\t\tif ( ! in_array( $q['comment_count']['compare'], $compare_operators, true ) ) {\n\t\t\t\t\t$q['comment_count']['compare'] = '=';\n\t\t\t\t}\n\n\t\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.comment_count {$q['comment_count']['compare']} %d\", $q['comment_count']['value'] );\n\t\t\t}\n\t\t}\n\n\t\t// MIME-Type stuff for attachment browsing\n\n\t\tif ( isset( $q['post_mime_type'] ) && '' != $q['post_mime_type'] ) {\n\t\t\t$whichmimetype = wp_post_mime_type_where( $q['post_mime_type'], $wpdb->posts );\n\t\t}\n\t\t$where .= $search . $whichauthor . $whichmimetype;\n\n\t\tif ( ! empty( $this->meta_query->queries ) ) {\n\t\t\t$clauses = $this->meta_query->get_sql( 'post', $wpdb->posts, 'ID', $this );\n\t\t\t$join   .= $clauses['join'];\n\t\t\t$where  .= $clauses['where'];\n\t\t}\n\n\t\t$rand = ( isset( $q['orderby'] ) && 'rand' === $q['orderby'] );\n\t\tif ( ! isset( $q['order'] ) ) {\n\t\t\t$q['order'] = $rand ? '' : 'DESC';\n\t\t} else {\n\t\t\t$q['order'] = $rand ? '' : $this->parse_order( $q['order'] );\n\t\t}\n\n\t\t// These values of orderby should ignore the 'order' parameter.\n\t\t$force_asc = array( 'post__in', 'post_name__in', 'post_parent__in' );\n\t\tif ( isset( $q['orderby'] ) && in_array( $q['orderby'], $force_asc, true ) ) {\n\t\t\t$q['order'] = '';\n\t\t}\n\n\t\t// Order by.\n\t\tif ( empty( $q['orderby'] ) ) {\n\t\t\t/*\n\t\t\t * Boolean false or empty array blanks out ORDER BY,\n\t\t\t * while leaving the value unset or otherwise empty sets the default.\n\t\t\t */\n\t\t\tif ( isset( $q['orderby'] ) && ( is_array( $q['orderby'] ) || false === $q['orderby'] ) ) {\n\t\t\t\t$orderby = '';\n\t\t\t} else {\n\t\t\t\t$orderby = \"{$wpdb->posts}.post_date \" . $q['order'];\n\t\t\t}\n\t\t} elseif ( 'none' == $q['orderby'] ) {\n\t\t\t$orderby = '';\n\t\t} else {\n\t\t\t$orderby_array = array();\n\t\t\tif ( is_array( $q['orderby'] ) ) {\n\t\t\t\tforeach ( $q['orderby'] as $_orderby => $order ) {\n\t\t\t\t\t$orderby = addslashes_gpc( urldecode( $_orderby ) );\n\t\t\t\t\t$parsed  = $this->parse_orderby( $orderby );\n\n\t\t\t\t\tif ( ! $parsed ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t$orderby_array[] = $parsed . ' ' . $this->parse_order( $order );\n\t\t\t\t}\n\t\t\t\t$orderby = implode( ', ', $orderby_array );\n\n\t\t\t} else {\n\t\t\t\t$q['orderby'] = urldecode( $q['orderby'] );\n\t\t\t\t$q['orderby'] = addslashes_gpc( $q['orderby'] );\n\n\t\t\t\tforeach ( explode( ' ', $q['orderby'] ) as $i => $orderby ) {\n\t\t\t\t\t$parsed = $this->parse_orderby( $orderby );\n\t\t\t\t\t// Only allow certain values for safety.\n\t\t\t\t\tif ( ! $parsed ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t$orderby_array[] = $parsed;\n\t\t\t\t}\n\t\t\t\t$orderby = implode( ' ' . $q['order'] . ', ', $orderby_array );\n\n\t\t\t\tif ( empty( $orderby ) ) {\n\t\t\t\t\t$orderby = \"{$wpdb->posts}.post_date \" . $q['order'];\n\t\t\t\t} elseif ( ! empty( $q['order'] ) ) {\n\t\t\t\t\t$orderby .= \" {$q['order']}\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Order search results by relevance only when another \"orderby\" is not specified in the query.\n\t\tif ( ! empty( $q['s'] ) ) {\n\t\t\t$search_orderby = '';\n\t\t\tif ( ! empty( $q['search_orderby_title'] ) && ( empty( $q['orderby'] ) && ! $this->is_feed ) || ( isset( $q['orderby'] ) && 'relevance' === $q['orderby'] ) ) {\n\t\t\t\t$search_orderby = $this->parse_search_order( $q );\n\t\t\t}\n\n\t\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t\t/**\n\t\t\t\t * Filters the ORDER BY used when ordering search results.\n\t\t\t\t *\n\t\t\t\t * @since 3.7.0\n\t\t\t\t *\n\t\t\t\t * @param string   $search_orderby The ORDER BY clause.\n\t\t\t\t * @param WP_Query $this           The current WP_Query instance.\n\t\t\t\t */\n\t\t\t\t$search_orderby = apply_filters( 'posts_search_orderby', $search_orderby, $this );\n\t\t\t}\n\n\t\t\tif ( $search_orderby ) {\n\t\t\t\t$orderby = $orderby ? $search_orderby . ', ' . $orderby : $search_orderby;\n\t\t\t}\n\t\t}\n\n\t\tif ( is_array( $post_type ) && count( $post_type ) > 1 ) {\n\t\t\t$post_type_cap = 'multiple_post_type';\n\t\t} else {\n\t\t\tif ( is_array( $post_type ) ) {\n\t\t\t\t$post_type = reset( $post_type );\n\t\t\t}\n\t\t\t$post_type_object = get_post_type_object( $post_type );\n\t\t\tif ( empty( $post_type_object ) ) {\n\t\t\t\t$post_type_cap = $post_type;\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $q['post_password'] ) ) {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.post_password = %s\", $q['post_password'] );\n\t\t\tif ( empty( $q['perm'] ) ) {\n\t\t\t\t$q['perm'] = 'readable';\n\t\t\t}\n\t\t} elseif ( isset( $q['has_password'] ) ) {\n\t\t\t$where .= sprintf( \" AND {$wpdb->posts}.post_password %s ''\", $q['has_password'] ? '!=' : '=' );\n\t\t}\n\n\t\tif ( ! empty( $q['comment_status'] ) ) {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.comment_status = %s \", $q['comment_status'] );\n\t\t}\n\n\t\tif ( ! empty( $q['ping_status'] ) ) {\n\t\t\t$where .= $wpdb->prepare( \" AND {$wpdb->posts}.ping_status = %s \", $q['ping_status'] );\n\t\t}\n\n\t\tif ( 'any' == $post_type ) {\n\t\t\t$in_search_post_types = get_post_types( array( 'exclude_from_search' => false ) );\n\t\t\tif ( empty( $in_search_post_types ) ) {\n\t\t\t\t$where .= ' AND 1=0 ';\n\t\t\t} else {\n\t\t\t\t$where .= \" AND {$wpdb->posts}.post_type IN ('\" . join( \"', '\", array_map( 'esc_sql', $in_search_post_types ) ) . \"')\";\n\t\t\t}\n\t\t} elseif ( ! empty( $post_type ) && is_array( $post_type ) ) {\n\t\t\t$where .= \" AND {$wpdb->posts}.post_type IN ('\" . join( \"', '\", esc_sql( $post_type ) ) . \"')\";\n\t\t} elseif ( ! empty( $post_type ) ) {\n\t\t\t$where           .= $wpdb->prepare( \" AND {$wpdb->posts}.post_type = %s\", $post_type );\n\t\t\t$post_type_object = get_post_type_object( $post_type );\n\t\t} elseif ( $this->is_attachment ) {\n\t\t\t$where           .= \" AND {$wpdb->posts}.post_type = 'attachment'\";\n\t\t\t$post_type_object = get_post_type_object( 'attachment' );\n\t\t} elseif ( $this->is_page ) {\n\t\t\t$where           .= \" AND {$wpdb->posts}.post_type = 'page'\";\n\t\t\t$post_type_object = get_post_type_object( 'page' );\n\t\t} else {\n\t\t\t$where           .= \" AND {$wpdb->posts}.post_type = 'post'\";\n\t\t\t$post_type_object = get_post_type_object( 'post' );\n\t\t}\n\n\t\t$edit_cap = 'edit_post';\n\t\t$read_cap = 'read_post';\n\n\t\tif ( ! empty( $post_type_object ) ) {\n\t\t\t$edit_others_cap  = $post_type_object->cap->edit_others_posts;\n\t\t\t$read_private_cap = $post_type_object->cap->read_private_posts;\n\t\t} else {\n\t\t\t$edit_others_cap  = 'edit_others_' . $post_type_cap . 's';\n\t\t\t$read_private_cap = 'read_private_' . $post_type_cap . 's';\n\t\t}\n\n\t\t$user_id = get_current_user_id();\n\n\t\t$q_status = array();\n\t\tif ( ! empty( $q['post_status'] ) ) {\n\t\t\t$statuswheres = array();\n\t\t\t$q_status     = $q['post_status'];\n\t\t\tif ( ! is_array( $q_status ) ) {\n\t\t\t\t$q_status = explode( ',', $q_status );\n\t\t\t}\n\t\t\t$r_status = array();\n\t\t\t$p_status = array();\n\t\t\t$e_status = array();\n\t\t\tif ( in_array( 'any', $q_status ) ) {\n\t\t\t\tforeach ( get_post_stati( array( 'exclude_from_search' => true ) ) as $status ) {\n\t\t\t\t\tif ( ! in_array( $status, $q_status ) ) {\n\t\t\t\t\t\t$e_status[] = \"{$wpdb->posts}.post_status <> '$status'\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tforeach ( get_post_stati() as $status ) {\n\t\t\t\t\tif ( in_array( $status, $q_status ) ) {\n\t\t\t\t\t\tif ( 'private' == $status ) {\n\t\t\t\t\t\t\t$p_status[] = \"{$wpdb->posts}.post_status = '$status'\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$r_status[] = \"{$wpdb->posts}.post_status = '$status'\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( empty( $q['perm'] ) || 'readable' != $q['perm'] ) {\n\t\t\t\t$r_status = array_merge( $r_status, $p_status );\n\t\t\t\tunset( $p_status );\n\t\t\t}\n\n\t\t\tif ( ! empty( $e_status ) ) {\n\t\t\t\t$statuswheres[] = '(' . join( ' AND ', $e_status ) . ')';\n\t\t\t}\n\t\t\tif ( ! empty( $r_status ) ) {\n\t\t\t\tif ( ! empty( $q['perm'] ) && 'editable' == $q['perm'] && ! current_user_can( $edit_others_cap ) ) {\n\t\t\t\t\t$statuswheres[] = \"({$wpdb->posts}.post_author = $user_id \" . 'AND (' . join( ' OR ', $r_status ) . '))';\n\t\t\t\t} else {\n\t\t\t\t\t$statuswheres[] = '(' . join( ' OR ', $r_status ) . ')';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( ! empty( $p_status ) ) {\n\t\t\t\tif ( ! empty( $q['perm'] ) && 'readable' == $q['perm'] && ! current_user_can( $read_private_cap ) ) {\n\t\t\t\t\t$statuswheres[] = \"({$wpdb->posts}.post_author = $user_id \" . 'AND (' . join( ' OR ', $p_status ) . '))';\n\t\t\t\t} else {\n\t\t\t\t\t$statuswheres[] = '(' . join( ' OR ', $p_status ) . ')';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( $post_status_join ) {\n\t\t\t\t$join .= \" LEFT JOIN {$wpdb->posts} AS p2 ON ({$wpdb->posts}.post_parent = p2.ID) \";\n\t\t\t\tforeach ( $statuswheres as $index => $statuswhere ) {\n\t\t\t\t\t$statuswheres[ $index ] = \"($statuswhere OR ({$wpdb->posts}.post_status = 'inherit' AND \" . str_replace( $wpdb->posts, 'p2', $statuswhere ) . '))';\n\t\t\t\t}\n\t\t\t}\n\t\t\t$where_status = implode( ' OR ', $statuswheres );\n\t\t\tif ( ! empty( $where_status ) ) {\n\t\t\t\t$where .= \" AND ($where_status)\";\n\t\t\t}\n\t\t} elseif ( ! $this->is_singular ) {\n\t\t\t$where .= \" AND ({$wpdb->posts}.post_status = 'publish'\";\n\n\t\t\t// Add public states.\n\t\t\t$public_states = get_post_stati( array( 'public' => true ) );\n\t\t\tforeach ( (array) $public_states as $state ) {\n\t\t\t\tif ( 'publish' == $state ) { // Publish is hard-coded above.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t$where .= \" OR {$wpdb->posts}.post_status = '$state'\";\n\t\t\t}\n\n\t\t\tif ( $this->is_admin ) {\n\t\t\t\t// Add protected states that should show in the admin all list.\n\t\t\t\t$admin_all_states = get_post_stati(\n\t\t\t\t\tarray(\n\t\t\t\t\t\t'protected'              => true,\n\t\t\t\t\t\t'show_in_admin_all_list' => true,\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tforeach ( (array) $admin_all_states as $state ) {\n\t\t\t\t\t$where .= \" OR {$wpdb->posts}.post_status = '$state'\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( is_user_logged_in() ) {\n\t\t\t\t// Add private states that are limited to viewing by the author of a post or someone who has caps to read private states.\n\t\t\t\t$private_states = get_post_stati( array( 'private' => true ) );\n\t\t\t\tforeach ( (array) $private_states as $state ) {\n\t\t\t\t\t$where .= current_user_can( $read_private_cap ) ? \" OR {$wpdb->posts}.post_status = '$state'\" : \" OR {$wpdb->posts}.post_author = $user_id AND {$wpdb->posts}.post_status = '$state'\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$where .= ')';\n\t\t}\n\n\t\t/*\n\t\t * Apply filters on where and join prior to paging so that any\n\t\t * manipulations to them are reflected in the paging by day queries.\n\t\t */\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the WHERE clause of the query.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param string   $where The WHERE clause of the query.\n\t\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$where = apply_filters_ref_array( 'posts_where', array( $where, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the JOIN clause of the query.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param string   $join  The JOIN clause of the query.\n\t\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$join = apply_filters_ref_array( 'posts_join', array( $join, &$this ) );\n\t\t}\n\n\t\t// Paging\n\t\tif ( empty( $q['nopaging'] ) && ! $this->is_singular ) {\n\t\t\t$page = absint( $q['paged'] );\n\t\t\tif ( ! $page ) {\n\t\t\t\t$page = 1;\n\t\t\t}\n\n\t\t\t// If 'offset' is provided, it takes precedence over 'paged'.\n\t\t\tif ( isset( $q['offset'] ) && is_numeric( $q['offset'] ) ) {\n\t\t\t\t$q['offset'] = absint( $q['offset'] );\n\t\t\t\t$pgstrt      = $q['offset'] . ', ';\n\t\t\t} else {\n\t\t\t\t$pgstrt = absint( ( $page - 1 ) * $q['posts_per_page'] ) . ', ';\n\t\t\t}\n\t\t\t$limits = 'LIMIT ' . $pgstrt . $q['posts_per_page'];\n\t\t}\n\n\t\t// Comments feeds\n\t\tif ( $this->is_comment_feed && ! $this->is_singular ) {\n\t\t\tif ( $this->is_archive || $this->is_search ) {\n\t\t\t\t$cjoin    = \"JOIN {$wpdb->posts} ON ({$wpdb->comments}.comment_post_ID = {$wpdb->posts}.ID) $join \";\n\t\t\t\t$cwhere   = \"WHERE comment_approved = '1' $where\";\n\t\t\t\t$cgroupby = \"{$wpdb->comments}.comment_id\";\n\t\t\t} else { // Other non singular e.g. front\n\t\t\t\t$cjoin    = \"JOIN {$wpdb->posts} ON ( {$wpdb->comments}.comment_post_ID = {$wpdb->posts}.ID )\";\n\t\t\t\t$cwhere   = \"WHERE ( post_status = 'publish' OR ( post_status = 'inherit' AND post_type = 'attachment' ) ) AND comment_approved = '1'\";\n\t\t\t\t$cgroupby = '';\n\t\t\t}\n\n\t\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t\t/**\n\t\t\t\t * Filters the JOIN clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.2.0\n\t\t\t\t *\n\t\t\t\t * @param string   $cjoin The JOIN clause of the query.\n\t\t\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$cjoin = apply_filters_ref_array( 'comment_feed_join', array( $cjoin, &$this ) );\n\n\t\t\t\t/**\n\t\t\t\t * Filters the WHERE clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.2.0\n\t\t\t\t *\n\t\t\t\t * @param string   $cwhere The WHERE clause of the query.\n\t\t\t\t * @param WP_Query $this   The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$cwhere = apply_filters_ref_array( 'comment_feed_where', array( $cwhere, &$this ) );\n\n\t\t\t\t/**\n\t\t\t\t * Filters the GROUP BY clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.2.0\n\t\t\t\t *\n\t\t\t\t * @param string   $cgroupby The GROUP BY clause of the query.\n\t\t\t\t * @param WP_Query $this     The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$cgroupby = apply_filters_ref_array( 'comment_feed_groupby', array( $cgroupby, &$this ) );\n\n\t\t\t\t/**\n\t\t\t\t * Filters the ORDER BY clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.8.0\n\t\t\t\t *\n\t\t\t\t * @param string   $corderby The ORDER BY clause of the query.\n\t\t\t\t * @param WP_Query $this     The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$corderby = apply_filters_ref_array( 'comment_feed_orderby', array( 'comment_date_gmt DESC', &$this ) );\n\n\t\t\t\t/**\n\t\t\t\t * Filters the LIMIT clause of the comments feed query before sending.\n\t\t\t\t *\n\t\t\t\t * @since 2.8.0\n\t\t\t\t *\n\t\t\t\t * @param string   $climits The JOIN clause of the query.\n\t\t\t\t * @param WP_Query $this    The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$climits = apply_filters_ref_array( 'comment_feed_limits', array( 'LIMIT ' . get_option( 'posts_per_rss' ), &$this ) );\n\t\t\t}\n\t\t\t$cgroupby = ( ! empty( $cgroupby ) ) ? 'GROUP BY ' . $cgroupby : '';\n\t\t\t$corderby = ( ! empty( $corderby ) ) ? 'ORDER BY ' . $corderby : '';\n\n\t\t\t$comments = (array) $wpdb->get_results( \"SELECT $distinct {$wpdb->comments}.* FROM {$wpdb->comments} $cjoin $cwhere $cgroupby $corderby $climits\" );\n\t\t\t// Convert to WP_Comment\n\t\t\t$this->comments      = array_map( 'get_comment', $comments );\n\t\t\t$this->comment_count = count( $this->comments );\n\n\t\t\t$post_ids = array();\n\n\t\t\tforeach ( $this->comments as $comment ) {\n\t\t\t\t$post_ids[] = (int) $comment->comment_post_ID;\n\t\t\t}\n\n\t\t\t$post_ids = join( ',', $post_ids );\n\t\t\t$join     = '';\n\t\t\tif ( $post_ids ) {\n\t\t\t\t$where = \"AND {$wpdb->posts}.ID IN ($post_ids) \";\n\t\t\t} else {\n\t\t\t\t$where = 'AND 0';\n\t\t\t}\n\t\t}\n\n\t\t$pieces = array( 'where', 'groupby', 'join', 'orderby', 'distinct', 'fields', 'limits' );\n\n\t\t/*\n\t\t * Apply post-paging filters on where and join. Only plugins that\n\t\t * manipulate paging queries should use these hooks.\n\t\t */\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the WHERE clause of the query.\n\t\t\t *\n\t\t\t * Specifically for manipulating paging queries.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param string   $where The WHERE clause of the query.\n\t\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$where = apply_filters_ref_array( 'posts_where_paged', array( $where, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the GROUP BY clause of the query.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param string   $groupby The GROUP BY clause of the query.\n\t\t\t * @param WP_Query $this    The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$groupby = apply_filters_ref_array( 'posts_groupby', array( $groupby, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the JOIN clause of the query.\n\t\t\t *\n\t\t\t * Specifically for manipulating paging queries.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param string   $join  The JOIN clause of the query.\n\t\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$join = apply_filters_ref_array( 'posts_join_paged', array( $join, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the ORDER BY clause of the query.\n\t\t\t *\n\t\t\t * @since 1.5.1\n\t\t\t *\n\t\t\t * @param string   $orderby The ORDER BY clause of the query.\n\t\t\t * @param WP_Query $this    The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$orderby = apply_filters_ref_array( 'posts_orderby', array( $orderby, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the DISTINCT clause of the query.\n\t\t\t *\n\t\t\t * @since 2.1.0\n\t\t\t *\n\t\t\t * @param string   $distinct The DISTINCT clause of the query.\n\t\t\t * @param WP_Query $this     The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$distinct = apply_filters_ref_array( 'posts_distinct', array( $distinct, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the LIMIT clause of the query.\n\t\t\t *\n\t\t\t * @since 2.1.0\n\t\t\t *\n\t\t\t * @param string   $limits The LIMIT clause of the query.\n\t\t\t * @param WP_Query $this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$limits = apply_filters_ref_array( 'post_limits', array( $limits, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the SELECT clause of the query.\n\t\t\t *\n\t\t\t * @since 2.1.0\n\t\t\t *\n\t\t\t * @param string   $fields The SELECT clause of the query.\n\t\t\t * @param WP_Query $this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$fields = apply_filters_ref_array( 'posts_fields', array( $fields, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters all query clauses at once, for convenience.\n\t\t\t *\n\t\t\t * Covers the WHERE, GROUP BY, JOIN, ORDER BY, DISTINCT,\n\t\t\t * fields (SELECT), and LIMITS clauses.\n\t\t\t *\n\t\t\t * @since 3.1.0\n\t\t\t *\n\t\t\t * @param string[] $clauses Associative array of the clauses for the query.\n\t\t\t * @param WP_Query $this    The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$clauses = (array) apply_filters_ref_array( 'posts_clauses', array( compact( $pieces ), &$this ) );\n\n\t\t\t$where    = isset( $clauses['where'] ) ? $clauses['where'] : '';\n\t\t\t$groupby  = isset( $clauses['groupby'] ) ? $clauses['groupby'] : '';\n\t\t\t$join     = isset( $clauses['join'] ) ? $clauses['join'] : '';\n\t\t\t$orderby  = isset( $clauses['orderby'] ) ? $clauses['orderby'] : '';\n\t\t\t$distinct = isset( $clauses['distinct'] ) ? $clauses['distinct'] : '';\n\t\t\t$fields   = isset( $clauses['fields'] ) ? $clauses['fields'] : '';\n\t\t\t$limits   = isset( $clauses['limits'] ) ? $clauses['limits'] : '';\n\t\t}\n\n\t\t/**\n\t\t * Fires to announce the query's current selection parameters.\n\t\t *\n\t\t * For use by caching plugins.\n\t\t *\n\t\t * @since 2.3.0\n\t\t *\n\t\t * @param string $selection The assembled selection query.\n\t\t */\n\t\tdo_action( 'posts_selection', $where . $groupby . $orderby . $limits . $join );\n\n\t\t/*\n\t\t * Filters again for the benefit of caching plugins.\n\t\t * Regular plugins should use the hooks above.\n\t\t */\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the WHERE clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $where The WHERE clause of the query.\n\t\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$where = apply_filters_ref_array( 'posts_where_request', array( $where, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the GROUP BY clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $groupby The GROUP BY clause of the query.\n\t\t\t * @param WP_Query $this    The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$groupby = apply_filters_ref_array( 'posts_groupby_request', array( $groupby, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the JOIN clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $join  The JOIN clause of the query.\n\t\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$join = apply_filters_ref_array( 'posts_join_request', array( $join, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the ORDER BY clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $orderby The ORDER BY clause of the query.\n\t\t\t * @param WP_Query $this    The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$orderby = apply_filters_ref_array( 'posts_orderby_request', array( $orderby, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the DISTINCT clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $distinct The DISTINCT clause of the query.\n\t\t\t * @param WP_Query $this     The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$distinct = apply_filters_ref_array( 'posts_distinct_request', array( $distinct, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the SELECT clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $fields The SELECT clause of the query.\n\t\t\t * @param WP_Query $this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$fields = apply_filters_ref_array( 'posts_fields_request', array( $fields, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters the LIMIT clause of the query.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * @since 2.5.0\n\t\t\t *\n\t\t\t * @param string   $limits The LIMIT clause of the query.\n\t\t\t * @param WP_Query $this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$limits = apply_filters_ref_array( 'post_limits_request', array( $limits, &$this ) );\n\n\t\t\t/**\n\t\t\t * Filters all query clauses at once, for convenience.\n\t\t\t *\n\t\t\t * For use by caching plugins.\n\t\t\t *\n\t\t\t * Covers the WHERE, GROUP BY, JOIN, ORDER BY, DISTINCT,\n\t\t\t * fields (SELECT), and LIMITS clauses.\n\t\t\t *\n\t\t\t * @since 3.1.0\n\t\t\t *\n\t\t\t * @param string[] $pieces Associative array of the pieces of the query.\n\t\t\t * @param WP_Query $this   The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$clauses = (array) apply_filters_ref_array( 'posts_clauses_request', array( compact( $pieces ), &$this ) );\n\n\t\t\t$where    = isset( $clauses['where'] ) ? $clauses['where'] : '';\n\t\t\t$groupby  = isset( $clauses['groupby'] ) ? $clauses['groupby'] : '';\n\t\t\t$join     = isset( $clauses['join'] ) ? $clauses['join'] : '';\n\t\t\t$orderby  = isset( $clauses['orderby'] ) ? $clauses['orderby'] : '';\n\t\t\t$distinct = isset( $clauses['distinct'] ) ? $clauses['distinct'] : '';\n\t\t\t$fields   = isset( $clauses['fields'] ) ? $clauses['fields'] : '';\n\t\t\t$limits   = isset( $clauses['limits'] ) ? $clauses['limits'] : '';\n\t\t}\n\n\t\tif ( ! empty( $groupby ) ) {\n\t\t\t$groupby = 'GROUP BY ' . $groupby;\n\t\t}\n\t\tif ( ! empty( $orderby ) ) {\n\t\t\t$orderby = 'ORDER BY ' . $orderby;\n\t\t}\n\n\t\t$found_rows = '';\n\t\tif ( ! $q['no_found_rows'] && ! empty( $limits ) ) {\n\t\t\t$found_rows = 'SQL_CALC_FOUND_ROWS';\n\t\t}\n\n\t\t$this->request = $old_request = \"SELECT $found_rows $distinct $fields FROM {$wpdb->posts} $join WHERE 1=1 $where $groupby $orderby $limits\";\n\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the completed SQL query before sending.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param string   $request The complete SQL query.\n\t\t\t * @param WP_Query $this    The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$this->request = apply_filters_ref_array( 'posts_request', array( $this->request, &$this ) );\n\t\t}\n\n\t\t/**\n\t\t * Filters the posts array before the query takes place.\n\t\t *\n\t\t * Return a non-null value to bypass WordPress's default post queries.\n\t\t *\n\t\t * Filtering functions that require pagination information are encouraged to set\n\t\t * the `found_posts` and `max_num_pages` properties of the WP_Query object,\n\t\t * passed to the filter by reference. If WP_Query does not perform a database\n\t\t * query, it will not have enough information to generate these values itself.\n\t\t *\n\t\t * @since 4.6.0\n\t\t *\n\t\t * @param array|null $posts Return an array of post data to short-circuit WP's query,\n\t\t *                          or null to allow WP to run its normal queries.\n\t\t * @param WP_Query   $this  The WP_Query instance (passed by reference).\n\t\t */\n\t\t$this->posts = apply_filters_ref_array( 'posts_pre_query', array( null, &$this ) );\n\n\t\tif ( 'ids' == $q['fields'] ) {\n\t\t\tif ( null === $this->posts ) {\n\t\t\t\t$this->posts = $wpdb->get_col( $this->request );\n\t\t\t}\n\n\t\t\t$this->posts      = array_map( 'intval', $this->posts );\n\t\t\t$this->post_count = count( $this->posts );\n\t\t\t$this->set_found_posts( $q, $limits );\n\n\t\t\treturn $this->posts;\n\t\t}\n\n\t\tif ( 'id=>parent' == $q['fields'] ) {\n\t\t\tif ( null === $this->posts ) {\n\t\t\t\t$this->posts = $wpdb->get_results( $this->request );\n\t\t\t}\n\n\t\t\t$this->post_count = count( $this->posts );\n\t\t\t$this->set_found_posts( $q, $limits );\n\n\t\t\t$r = array();\n\t\t\tforeach ( $this->posts as $key => $post ) {\n\t\t\t\t$this->posts[ $key ]->ID          = (int) $post->ID;\n\t\t\t\t$this->posts[ $key ]->post_parent = (int) $post->post_parent;\n\n\t\t\t\t$r[ (int) $post->ID ] = (int) $post->post_parent;\n\t\t\t}\n\n\t\t\treturn $r;\n\t\t}\n\n\t\tif ( null === $this->posts ) {\n\t\t\t$split_the_query = ( $old_request == $this->request && \"{$wpdb->posts}.*\" == $fields && ! empty( $limits ) && $q['posts_per_page'] < 500 );\n\n\t\t\t/**\n\t\t\t * Filters whether to split the query.\n\t\t\t *\n\t\t\t * Splitting the query will cause it to fetch just the IDs of the found posts\n\t\t\t * (and then individually fetch each post by ID), rather than fetching every\n\t\t\t * complete row at once. One massive result vs. many small results.\n\t\t\t *\n\t\t\t * @since 3.4.0\n\t\t\t *\n\t\t\t * @param bool     $split_the_query Whether or not to split the query.\n\t\t\t * @param WP_Query $this            The WP_Query instance.\n\t\t\t */\n\t\t\t$split_the_query = apply_filters( 'split_the_query', $split_the_query, $this );\n\n\t\t\tif ( $split_the_query ) {\n\t\t\t\t// First get the IDs and then fill in the objects\n\n\t\t\t\t$this->request = \"SELECT $found_rows $distinct {$wpdb->posts}.ID FROM {$wpdb->posts} $join WHERE 1=1 $where $groupby $orderby $limits\";\n\n\t\t\t\t/**\n\t\t\t\t * Filters the Post IDs SQL request before sending.\n\t\t\t\t *\n\t\t\t\t * @since 3.4.0\n\t\t\t\t *\n\t\t\t\t * @param string   $request The post ID request.\n\t\t\t\t * @param WP_Query $this    The WP_Query instance.\n\t\t\t\t */\n\t\t\t\t$this->request = apply_filters( 'posts_request_ids', $this->request, $this );\n\n\t\t\t\t$ids = $wpdb->get_col( $this->request );\n\n\t\t\t\tif ( $ids ) {\n\t\t\t\t\t$this->posts = $ids;\n\t\t\t\t\t$this->set_found_posts( $q, $limits );\n\t\t\t\t\t_prime_post_caches( $ids, $q['update_post_term_cache'], $q['update_post_meta_cache'] );\n\t\t\t\t} else {\n\t\t\t\t\t$this->posts = array();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$this->posts = $wpdb->get_results( $this->request );\n\t\t\t\t$this->set_found_posts( $q, $limits );\n\t\t\t}\n\t\t}\n\n\t\t// Convert to WP_Post objects.\n\t\tif ( $this->posts ) {\n\t\t\t$this->posts = array_map( 'get_post', $this->posts );\n\t\t}\n\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the raw post results array, prior to status checks.\n\t\t\t *\n\t\t\t * @since 2.3.0\n\t\t\t *\n\t\t\t * @param WP_Post[] $posts Array of post objects.\n\t\t\t * @param WP_Query  $this  The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$this->posts = apply_filters_ref_array( 'posts_results', array( $this->posts, &$this ) );\n\t\t}\n\n\t\tif ( ! empty( $this->posts ) && $this->is_comment_feed && $this->is_singular ) {\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$cjoin = apply_filters_ref_array( 'comment_feed_join', array( '', &$this ) );\n\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$cwhere = apply_filters_ref_array( 'comment_feed_where', array( \"WHERE comment_post_ID = '{$this->posts[0]->ID}' AND comment_approved = '1'\", &$this ) );\n\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$cgroupby = apply_filters_ref_array( 'comment_feed_groupby', array( '', &$this ) );\n\t\t\t$cgroupby = ( ! empty( $cgroupby ) ) ? 'GROUP BY ' . $cgroupby : '';\n\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$corderby = apply_filters_ref_array( 'comment_feed_orderby', array( 'comment_date_gmt DESC', &$this ) );\n\t\t\t$corderby = ( ! empty( $corderby ) ) ? 'ORDER BY ' . $corderby : '';\n\n\t\t\t/** This filter is documented in wp-includes/query.php */\n\t\t\t$climits = apply_filters_ref_array( 'comment_feed_limits', array( 'LIMIT ' . get_option( 'posts_per_rss' ), &$this ) );\n\n\t\t\t$comments_request = \"SELECT {$wpdb->comments}.* FROM {$wpdb->comments} $cjoin $cwhere $cgroupby $corderby $climits\";\n\t\t\t$comments         = $wpdb->get_results( $comments_request );\n\t\t\t// Convert to WP_Comment\n\t\t\t$this->comments      = array_map( 'get_comment', $comments );\n\t\t\t$this->comment_count = count( $this->comments );\n\t\t}\n\n\t\t// Check post status to determine if post should be displayed.\n\t\tif ( ! empty( $this->posts ) && ( $this->is_single || $this->is_page ) ) {\n\t\t\t$status = get_post_status( $this->posts[0] );\n\t\t\tif ( 'attachment' === $this->posts[0]->post_type && 0 === (int) $this->posts[0]->post_parent ) {\n\t\t\t\t$this->is_page       = false;\n\t\t\t\t$this->is_single     = true;\n\t\t\t\t$this->is_attachment = true;\n\t\t\t}\n\t\t\t$post_status_obj = get_post_status_object( $status );\n\n\t\t\t// If the post_status was specifically requested, let it pass through.\n\t\t\tif ( ! $post_status_obj->public && ! in_array( $status, $q_status ) ) {\n\n\t\t\t\tif ( ! is_user_logged_in() ) {\n\t\t\t\t\t// User must be logged in to view unpublished posts.\n\t\t\t\t\t$this->posts = array();\n\t\t\t\t} else {\n\t\t\t\t\tif ( $post_status_obj->protected ) {\n\t\t\t\t\t\t// User must have edit permissions on the draft to preview.\n\t\t\t\t\t\tif ( ! current_user_can( $edit_cap, $this->posts[0]->ID ) ) {\n\t\t\t\t\t\t\t$this->posts = array();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$this->is_preview = true;\n\t\t\t\t\t\t\tif ( 'future' != $status ) {\n\t\t\t\t\t\t\t\t$this->posts[0]->post_date = current_time( 'mysql' );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} elseif ( $post_status_obj->private ) {\n\t\t\t\t\t\tif ( ! current_user_can( $read_cap, $this->posts[0]->ID ) ) {\n\t\t\t\t\t\t\t$this->posts = array();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->posts = array();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $this->is_preview && $this->posts && current_user_can( $edit_cap, $this->posts[0]->ID ) ) {\n\t\t\t\t/**\n\t\t\t\t * Filters the single post for preview mode.\n\t\t\t\t *\n\t\t\t\t * @since 2.7.0\n\t\t\t\t *\n\t\t\t\t * @param WP_Post  $post_preview  The Post object.\n\t\t\t\t * @param WP_Query $this          The WP_Query instance (passed by reference).\n\t\t\t\t */\n\t\t\t\t$this->posts[0] = get_post( apply_filters_ref_array( 'the_preview', array( $this->posts[0], &$this ) ) );\n\t\t\t}\n\t\t}\n\n\t\t// Put sticky posts at the top of the posts array\n\t\t$sticky_posts = get_option( 'sticky_posts' );\n\t\tif ( $this->is_home && $page <= 1 && is_array( $sticky_posts ) && ! empty( $sticky_posts ) && ! $q['ignore_sticky_posts'] ) {\n\t\t\t$num_posts     = count( $this->posts );\n\t\t\t$sticky_offset = 0;\n\t\t\t// Loop over posts and relocate stickies to the front.\n\t\t\tfor ( $i = 0; $i < $num_posts; $i++ ) {\n\t\t\t\tif ( in_array( $this->posts[ $i ]->ID, $sticky_posts ) ) {\n\t\t\t\t\t$sticky_post = $this->posts[ $i ];\n\t\t\t\t\t// Remove sticky from current position\n\t\t\t\t\tarray_splice( $this->posts, $i, 1 );\n\t\t\t\t\t// Move to front, after other stickies\n\t\t\t\t\tarray_splice( $this->posts, $sticky_offset, 0, array( $sticky_post ) );\n\t\t\t\t\t// Increment the sticky offset. The next sticky will be placed at this offset.\n\t\t\t\t\t$sticky_offset++;\n\t\t\t\t\t// Remove post from sticky posts array\n\t\t\t\t\t$offset = array_search( $sticky_post->ID, $sticky_posts );\n\t\t\t\t\tunset( $sticky_posts[ $offset ] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If any posts have been excluded specifically, Ignore those that are sticky.\n\t\t\tif ( ! empty( $sticky_posts ) && ! empty( $q['post__not_in'] ) ) {\n\t\t\t\t$sticky_posts = array_diff( $sticky_posts, $q['post__not_in'] );\n\t\t\t}\n\n\t\t\t// Fetch sticky posts that weren't in the query results\n\t\t\tif ( ! empty( $sticky_posts ) ) {\n\t\t\t\t$stickies = get_posts(\n\t\t\t\t\tarray(\n\t\t\t\t\t\t'post__in'    => $sticky_posts,\n\t\t\t\t\t\t'post_type'   => $post_type,\n\t\t\t\t\t\t'post_status' => 'publish',\n\t\t\t\t\t\t'nopaging'    => true,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\tforeach ( $stickies as $sticky_post ) {\n\t\t\t\t\tarray_splice( $this->posts, $sticky_offset, 0, array( $sticky_post ) );\n\t\t\t\t\t$sticky_offset++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If comments have been fetched as part of the query, make sure comment meta lazy-loading is set up.\n\t\tif ( ! empty( $this->comments ) ) {\n\t\t\twp_queue_comments_for_comment_meta_lazyload( $this->comments );\n\t\t}\n\n\t\tif ( ! $q['suppress_filters'] ) {\n\t\t\t/**\n\t\t\t * Filters the array of retrieved posts after they've been fetched and\n\t\t\t * internally processed.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param WP_Post[] $posts Array of post objects.\n\t\t\t * @param WP_Query  $this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$this->posts = apply_filters_ref_array( 'the_posts', array( $this->posts, &$this ) );\n\t\t}\n\n\t\t// Ensure that any posts added/modified via one of the filters above are\n\t\t// of the type WP_Post and are filtered.\n\t\tif ( $this->posts ) {\n\t\t\t$this->post_count = count( $this->posts );\n\n\t\t\t$this->posts = array_map( 'get_post', $this->posts );\n\n\t\t\tif ( $q['cache_results'] ) {\n\t\t\t\tupdate_post_caches( $this->posts, $post_type, $q['update_post_term_cache'], $q['update_post_meta_cache'] );\n\t\t\t}\n\n\t\t\t$this->post = reset( $this->posts );\n\t\t} else {\n\t\t\t$this->post_count = 0;\n\t\t\t$this->posts      = array();\n\t\t}\n\n\t\tif ( $q['lazy_load_term_meta'] ) {\n\t\t\twp_queue_posts_for_term_meta_lazyload( $this->posts );\n\t\t}\n\n\t\treturn $this->posts;\n\t}\n\n\t/**\n\t * Set up the amount of found posts and the number of pages (if limit clause was used)\n\t * for the current query.\n\t *\n\t * @since 3.5.0\n\t *\n\t * @param array  $q      Query variables.\n\t * @param string $limits LIMIT clauses of the query.\n\t */\n\tprivate function set_found_posts( $q, $limits ) {\n\t\tglobal $wpdb;\n\t\t// Bail if posts is an empty array. Continue if posts is an empty string,\n\t\t// null, or false to accommodate caching plugins that fill posts later.\n\t\tif ( $q['no_found_rows'] || ( is_array( $this->posts ) && ! $this->posts ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! empty( $limits ) ) {\n\t\t\t/**\n\t\t\t * Filters the query to run for retrieving the found posts.\n\t\t\t *\n\t\t\t * @since 2.1.0\n\t\t\t *\n\t\t\t * @param string   $found_posts The query to run to find the found posts.\n\t\t\t * @param WP_Query $this        The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\t$this->found_posts = $wpdb->get_var( apply_filters_ref_array( 'found_posts_query', array( 'SELECT FOUND_ROWS()', &$this ) ) );\n\t\t} else {\n\t\t\tif ( is_array( $this->posts ) ) {\n\t\t\t\t$this->found_posts = count( $this->posts );\n\t\t\t} else {\n\t\t\t\tif ( null === $this->posts ) {\n\t\t\t\t\t$this->found_posts = 0;\n\t\t\t\t} else {\n\t\t\t\t\t$this->found_posts = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Filters the number of found posts for the query.\n\t\t *\n\t\t * @since 2.1.0\n\t\t *\n\t\t * @param int      $found_posts The number of posts found.\n\t\t * @param WP_Query $this        The WP_Query instance (passed by reference).\n\t\t */\n\t\t$this->found_posts = apply_filters_ref_array( 'found_posts', array( $this->found_posts, &$this ) );\n\n\t\tif ( ! empty( $limits ) ) {\n\t\t\t$this->max_num_pages = ceil( $this->found_posts / $q['posts_per_page'] );\n\t\t}\n\t}\n\n\t/**\n\t * Set up the next post and iterate current post index.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @return WP_Post Next post.\n\t */\n\tpublic function next_post() {\n\n\t\t$this->current_post++;\n\n\t\t$this->post = $this->posts[ $this->current_post ];\n\t\treturn $this->post;\n\t}\n\n\t/**\n\t * Sets up the current post.\n\t *\n\t * Retrieves the next post, sets up the post, sets the 'in the loop'\n\t * property to true.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @global WP_Post $post\n\t */\n\tpublic function the_post() {\n\t\tglobal $post;\n\t\t$this->in_the_loop = true;\n\n\t\tif ( $this->current_post == -1 ) { // loop has just started\n\t\t\t/**\n\t\t\t * Fires once the loop is started.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\tdo_action_ref_array( 'loop_start', array( &$this ) );\n\t\t}\n\n\t\t$post = $this->next_post();\n\t\t$this->setup_postdata( $post );\n\t}\n\n\t/**\n\t * Determines whether there are more posts available in the loop.\n\t *\n\t * Calls the {@see 'loop_end'} action when the loop is complete.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @return bool True if posts are available, false if end of loop.\n\t */\n\tpublic function have_posts() {\n\t\tif ( $this->current_post + 1 < $this->post_count ) {\n\t\t\treturn true;\n\t\t} elseif ( $this->current_post + 1 == $this->post_count && $this->post_count > 0 ) {\n\t\t\t/**\n\t\t\t * Fires once the loop has ended.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param WP_Query $this The WP_Query instance (passed by reference).\n\t\t\t */\n\t\t\tdo_action_ref_array( 'loop_end', array( &$this ) );\n\t\t\t// Do some cleaning up after the loop\n\t\t\t$this->rewind_posts();\n\t\t} elseif ( 0 === $this->post_count ) {\n\t\t\t/**\n\t\t\t * Fires if no results are found in a post query.\n\t\t\t *\n\t\t\t * @since 4.9.0\n\t\t\t *\n\t\t\t * @param WP_Query $this The WP_Query instance.\n\t\t\t */\n\t\t\tdo_action( 'loop_no_results', $this );\n\t\t}\n\n\t\t$this->in_the_loop = false;\n\t\treturn false;\n\t}\n\n\t/**\n\t * Rewind the posts and reset post index.\n\t *\n\t * @since 1.5.0\n\t */\n\tpublic function rewind_posts() {\n\t\t$this->current_post = -1;\n\t\tif ( $this->post_count > 0 ) {\n\t\t\t$this->post = $this->posts[0];\n\t\t}\n\t}\n\n\t/**\n\t * Iterate current comment index and return WP_Comment object.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @return WP_Comment Comment object.\n\t */\n\tpublic function next_comment() {\n\t\t$this->current_comment++;\n\n\t\t$this->comment = $this->comments[ $this->current_comment ];\n\t\treturn $this->comment;\n\t}\n\n\t/**\n\t * Sets up the current comment.\n\t *\n\t * @since 2.2.0\n\t * @global WP_Comment $comment Current comment.\n\t */\n\tpublic function the_comment() {\n\t\tglobal $comment;\n\n\t\t$comment = $this->next_comment();\n\n\t\tif ( $this->current_comment == 0 ) {\n\t\t\t/**\n\t\t\t * Fires once the comment loop is started.\n\t\t\t *\n\t\t\t * @since 2.2.0\n\t\t\t */\n\t\t\tdo_action( 'comment_loop_start' );\n\t\t}\n\t}\n\n\t/**\n\t * Whether there are more comments available.\n\t *\n\t * Automatically rewinds comments when finished.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @return bool True, if more comments. False, if no more posts.\n\t */\n\tpublic function have_comments() {\n\t\tif ( $this->current_comment + 1 < $this->comment_count ) {\n\t\t\treturn true;\n\t\t} elseif ( $this->current_comment + 1 == $this->comment_count ) {\n\t\t\t$this->rewind_comments();\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Rewind the comments, resets the comment index and comment to first.\n\t *\n\t * @since 2.2.0\n\t */\n\tpublic function rewind_comments() {\n\t\t$this->current_comment = -1;\n\t\tif ( $this->comment_count > 0 ) {\n\t\t\t$this->comment = $this->comments[0];\n\t\t}\n\t}\n\n\t/**\n\t * Sets up the WordPress query by parsing query string.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param string|array $query URL query string or array of query arguments.\n\t * @return WP_Post[]|int[] Array of post objects or post IDs.\n\t */\n\tpublic function query( $query ) {\n\t\t$this->init();\n\t\t$this->query = $this->query_vars = wp_parse_args( $query );\n\t\treturn $this->get_posts();\n\t}\n\n\t/**\n\t * Retrieve queried object.\n\t *\n\t * If queried object is not set, then the queried object will be set from\n\t * the category, tag, taxonomy, posts page, single post, page, or author\n\t * query variable. After it is set up, it will be returned.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @return object\n\t */\n\tpublic function get_queried_object() {\n\t\tif ( isset( $this->queried_object ) ) {\n\t\t\treturn $this->queried_object;\n\t\t}\n\n\t\t$this->queried_object    = null;\n\t\t$this->queried_object_id = null;\n\n\t\tif ( $this->is_category || $this->is_tag || $this->is_tax ) {\n\t\t\tif ( $this->is_category ) {\n\t\t\t\tif ( $this->get( 'cat' ) ) {\n\t\t\t\t\t$term = get_term( $this->get( 'cat' ), 'category' );\n\t\t\t\t} elseif ( $this->get( 'category_name' ) ) {\n\t\t\t\t\t$term = get_term_by( 'slug', $this->get( 'category_name' ), 'category' );\n\t\t\t\t}\n\t\t\t} elseif ( $this->is_tag ) {\n\t\t\t\tif ( $this->get( 'tag_id' ) ) {\n\t\t\t\t\t$term = get_term( $this->get( 'tag_id' ), 'post_tag' );\n\t\t\t\t} elseif ( $this->get( 'tag' ) ) {\n\t\t\t\t\t$term = get_term_by( 'slug', $this->get( 'tag' ), 'post_tag' );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// For other tax queries, grab the first term from the first clause.\n\t\t\t\tif ( ! empty( $this->tax_query->queried_terms ) ) {\n\t\t\t\t\t$queried_taxonomies = array_keys( $this->tax_query->queried_terms );\n\t\t\t\t\t$matched_taxonomy   = reset( $queried_taxonomies );\n\t\t\t\t\t$query              = $this->tax_query->queried_terms[ $matched_taxonomy ];\n\n\t\t\t\t\tif ( ! empty( $query['terms'] ) ) {\n\t\t\t\t\t\tif ( 'term_id' == $query['field'] ) {\n\t\t\t\t\t\t\t$term = get_term( reset( $query['terms'] ), $matched_taxonomy );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$term = get_term_by( $query['field'], reset( $query['terms'] ), $matched_taxonomy );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ! empty( $term ) && ! is_wp_error( $term ) ) {\n\t\t\t\t$this->queried_object    = $term;\n\t\t\t\t$this->queried_object_id = (int) $term->term_id;\n\n\t\t\t\tif ( $this->is_category && 'category' === $this->queried_object->taxonomy ) {\n\t\t\t\t\t_make_cat_compat( $this->queried_object );\n\t\t\t\t}\n\t\t\t}\n\t\t} elseif ( $this->is_post_type_archive ) {\n\t\t\t$post_type = $this->get( 'post_type' );\n\t\t\tif ( is_array( $post_type ) ) {\n\t\t\t\t$post_type = reset( $post_type );\n\t\t\t}\n\t\t\t$this->queried_object = get_post_type_object( $post_type );\n\t\t} elseif ( $this->is_posts_page ) {\n\t\t\t$page_for_posts          = get_option( 'page_for_posts' );\n\t\t\t$this->queried_object    = get_post( $page_for_posts );\n\t\t\t$this->queried_object_id = (int) $this->queried_object->ID;\n\t\t} elseif ( $this->is_singular && ! empty( $this->post ) ) {\n\t\t\t$this->queried_object    = $this->post;\n\t\t\t$this->queried_object_id = (int) $this->post->ID;\n\t\t} elseif ( $this->is_author ) {\n\t\t\t$this->queried_object_id = (int) $this->get( 'author' );\n\t\t\t$this->queried_object    = get_userdata( $this->queried_object_id );\n\t\t}\n\n\t\treturn $this->queried_object;\n\t}\n\n\t/**\n\t * Retrieve ID of the current queried object.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @return int\n\t */\n\tpublic function get_queried_object_id() {\n\t\t$this->get_queried_object();\n\n\t\tif ( isset( $this->queried_object_id ) ) {\n\t\t\treturn $this->queried_object_id;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Constructor.\n\t *\n\t * Sets up the WordPress query, if parameter is not empty.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param string|array $query URL query string or array of vars.\n\t */\n\tpublic function __construct( $query = '' ) {\n\t\tif ( ! empty( $query ) ) {\n\t\t\t$this->query( $query );\n\t\t}\n\t}\n\n\t/**\n\t * Make private properties readable for backward compatibility.\n\t *\n\t * @since 4.0.0\n\t *\n\t * @param string $name Property to get.\n\t * @return mixed Property.\n\t */\n\tpublic function __get( $name ) {\n\t\tif ( in_array( $name, $this->compat_fields ) ) {\n\t\t\treturn $this->$name;\n\t\t}\n\t}\n\n\t/**\n\t * Make private properties checkable for backward compatibility.\n\t *\n\t * @since 4.0.0\n\t *\n\t * @param string $name Property to check if set.\n\t * @return bool Whether the property is set.\n\t */\n\tpublic function __isset( $name ) {\n\t\tif ( in_array( $name, $this->compat_fields ) ) {\n\t\t\treturn isset( $this->$name );\n\t\t}\n\t}\n\n\t/**\n\t * Make private/protected methods readable for backward compatibility.\n\t *\n\t * @since 4.0.0\n\t *\n\t * @param string   $name      Method to call.\n\t * @param array    $arguments Arguments to pass when calling.\n\t * @return mixed|false Return value of the callback, false otherwise.\n\t */\n\tpublic function __call( $name, $arguments ) {\n\t\tif ( in_array( $name, $this->compat_methods ) ) {\n\t\t\treturn call_user_func_array( array( $this, $name ), $arguments );\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing archive page?\n\t *\n\t * Month, Year, Category, Author, Post Type archive...\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_archive() {\n\t\treturn (bool) $this->is_archive;\n\t}\n\n\t/**\n\t * Is the query for an existing post type archive page?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $post_types Optional. Post type or array of posts types to check against.\n\t * @return bool\n\t */\n\tpublic function is_post_type_archive( $post_types = '' ) {\n\t\tif ( empty( $post_types ) || ! $this->is_post_type_archive ) {\n\t\t\treturn (bool) $this->is_post_type_archive;\n\t\t}\n\n\t\t$post_type = $this->get( 'post_type' );\n\t\tif ( is_array( $post_type ) ) {\n\t\t\t$post_type = reset( $post_type );\n\t\t}\n\t\t$post_type_object = get_post_type_object( $post_type );\n\n\t\treturn in_array( $post_type_object->name, (array) $post_types );\n\t}\n\n\t/**\n\t * Is the query for an existing attachment page?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $attachment Attachment ID, title, slug, or array of such.\n\t * @return bool\n\t */\n\tpublic function is_attachment( $attachment = '' ) {\n\t\tif ( ! $this->is_attachment ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $attachment ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$attachment = array_map( 'strval', (array) $attachment );\n\n\t\t$post_obj = $this->get_queried_object();\n\n\t\tif ( in_array( (string) $post_obj->ID, $attachment ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $post_obj->post_title, $attachment ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $post_obj->post_name, $attachment ) ) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing author archive page?\n\t *\n\t * If the $author parameter is specified, this function will additionally\n\t * check if the query is for one of the authors specified.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $author Optional. User ID, nickname, nicename, or array of User IDs, nicknames, and nicenames\n\t * @return bool\n\t */\n\tpublic function is_author( $author = '' ) {\n\t\tif ( ! $this->is_author ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $author ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$author_obj = $this->get_queried_object();\n\n\t\t$author = array_map( 'strval', (array) $author );\n\n\t\tif ( in_array( (string) $author_obj->ID, $author ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $author_obj->nickname, $author ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $author_obj->user_nicename, $author ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing category archive page?\n\t *\n\t * If the $category parameter is specified, this function will additionally\n\t * check if the query is for one of the categories specified.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $category Optional. Category ID, name, slug, or array of Category IDs, names, and slugs.\n\t * @return bool\n\t */\n\tpublic function is_category( $category = '' ) {\n\t\tif ( ! $this->is_category ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $category ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$cat_obj = $this->get_queried_object();\n\n\t\t$category = array_map( 'strval', (array) $category );\n\n\t\tif ( in_array( (string) $cat_obj->term_id, $category ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $cat_obj->name, $category ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $cat_obj->slug, $category ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing tag archive page?\n\t *\n\t * If the $tag parameter is specified, this function will additionally\n\t * check if the query is for one of the tags specified.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param mixed $tag Optional. Tag ID, name, slug, or array of Tag IDs, names, and slugs.\n\t * @return bool\n\t */\n\tpublic function is_tag( $tag = '' ) {\n\t\tif ( ! $this->is_tag ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $tag ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$tag_obj = $this->get_queried_object();\n\n\t\t$tag = array_map( 'strval', (array) $tag );\n\n\t\tif ( in_array( (string) $tag_obj->term_id, $tag ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $tag_obj->name, $tag ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $tag_obj->slug, $tag ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing custom taxonomy archive page?\n\t *\n\t * If the $taxonomy parameter is specified, this function will additionally\n\t * check if the query is for that specific $taxonomy.\n\t *\n\t * If the $term parameter is specified in addition to the $taxonomy parameter,\n\t * this function will additionally check if the query is for one of the terms\n\t * specified.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @global array $wp_taxonomies\n\t *\n\t * @param mixed $taxonomy Optional. Taxonomy slug or slugs.\n\t * @param mixed $term     Optional. Term ID, name, slug or array of Term IDs, names, and slugs.\n\t * @return bool True for custom taxonomy archive pages, false for built-in taxonomies (category and tag archives).\n\t */\n\tpublic function is_tax( $taxonomy = '', $term = '' ) {\n\t\tglobal $wp_taxonomies;\n\n\t\tif ( ! $this->is_tax ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $taxonomy ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$queried_object = $this->get_queried_object();\n\t\t$tax_array      = array_intersect( array_keys( $wp_taxonomies ), (array) $taxonomy );\n\t\t$term_array     = (array) $term;\n\n\t\t// Check that the taxonomy matches.\n\t\tif ( ! ( isset( $queried_object->taxonomy ) && count( $tax_array ) && in_array( $queried_object->taxonomy, $tax_array ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Only a Taxonomy provided.\n\t\tif ( empty( $term ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn isset( $queried_object->term_id ) &&\n\t\t\tcount(\n\t\t\t\tarray_intersect(\n\t\t\t\t\tarray( $queried_object->term_id, $queried_object->name, $queried_object->slug ),\n\t\t\t\t\t$term_array\n\t\t\t\t)\n\t\t\t);\n\t}\n\n\t/**\n\t * Whether the current URL is within the comments popup window.\n\t *\n\t * @since 3.1.0\n\t * @deprecated 4.5.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_comments_popup() {\n\t\t_deprecated_function( __FUNCTION__, '4.5.0' );\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing date archive?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_date() {\n\t\treturn (bool) $this->is_date;\n\t}\n\n\t/**\n\t * Is the query for an existing day archive?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_day() {\n\t\treturn (bool) $this->is_day;\n\t}\n\n\t/**\n\t * Is the query for a feed?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param string|array $feeds Optional feed types to check.\n\t * @return bool\n\t */\n\tpublic function is_feed( $feeds = '' ) {\n\t\tif ( empty( $feeds ) || ! $this->is_feed ) {\n\t\t\treturn (bool) $this->is_feed;\n\t\t}\n\t\t$qv = $this->get( 'feed' );\n\t\tif ( 'feed' == $qv ) {\n\t\t\t$qv = get_default_feed();\n\t\t}\n\t\treturn in_array( $qv, (array) $feeds );\n\t}\n\n\t/**\n\t * Is the query for a comments feed?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_comment_feed() {\n\t\treturn (bool) $this->is_comment_feed;\n\t}\n\n\t/**\n\t * Is the query for the front page of the site?\n\t *\n\t * This is for what is displayed at your site's main URL.\n\t *\n\t * Depends on the site's \"Front page displays\" Reading Settings 'show_on_front' and 'page_on_front'.\n\t *\n\t * If you set a static page for the front page of your site, this function will return\n\t * true when viewing that page.\n\t *\n\t * Otherwise the same as @see WP_Query::is_home()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool True, if front of site.\n\t */\n\tpublic function is_front_page() {\n\t\t// most likely case\n\t\tif ( 'posts' == get_option( 'show_on_front' ) && $this->is_home() ) {\n\t\t\treturn true;\n\t\t} elseif ( 'page' == get_option( 'show_on_front' ) && get_option( 'page_on_front' ) && $this->is_page( get_option( 'page_on_front' ) ) ) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Is the query for the blog homepage?\n\t *\n\t * This is the page which shows the time based blog content of your site.\n\t *\n\t * Depends on the site's \"Front page displays\" Reading Settings 'show_on_front' and 'page_for_posts'.\n\t *\n\t * If you set a static page for the front page of your site, this function will return\n\t * true only on the page you set as the \"Posts page\".\n\t *\n\t * @see WP_Query::is_front_page()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool True if blog view homepage.\n\t */\n\tpublic function is_home() {\n\t\treturn (bool) $this->is_home;\n\t}\n\n\t/**\n\t * Is the query for the Privacy Policy page?\n\t *\n\t * This is the page which shows the Privacy Policy content of your site.\n\t *\n\t * Depends on the site's \"Change your Privacy Policy page\" Privacy Settings 'wp_page_for_privacy_policy'.\n\t *\n\t * This function will return true only on the page you set as the \"Privacy Policy page\".\n\t *\n\t * @since 5.2.0\n\t *\n\t * @return bool True, if Privacy Policy page.\n\t */\n\tpublic function is_privacy_policy() {\n\t\tif ( get_option( 'wp_page_for_privacy_policy' ) && $this->is_page( get_option( 'wp_page_for_privacy_policy' ) ) ) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Is the query for an existing month archive?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_month() {\n\t\treturn (bool) $this->is_month;\n\t}\n\n\t/**\n\t * Is the query for an existing single page?\n\t *\n\t * If the $page parameter is specified, this function will additionally\n\t * check if the query is for one of the pages specified.\n\t *\n\t * @see WP_Query::is_single()\n\t * @see WP_Query::is_singular()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param int|string|array $page Optional. Page ID, title, slug, path, or array of such. Default empty.\n\t * @return bool Whether the query is for an existing single page.\n\t */\n\tpublic function is_page( $page = '' ) {\n\t\tif ( ! $this->is_page ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $page ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$page_obj = $this->get_queried_object();\n\n\t\t$page = array_map( 'strval', (array) $page );\n\n\t\tif ( in_array( (string) $page_obj->ID, $page ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $page_obj->post_title, $page ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $page_obj->post_name, $page ) ) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tforeach ( $page as $pagepath ) {\n\t\t\t\tif ( ! strpos( $pagepath, '/' ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t$pagepath_obj = get_page_by_path( $pagepath );\n\n\t\t\t\tif ( $pagepath_obj && ( $pagepath_obj->ID == $page_obj->ID ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for paged result and not for the first page?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_paged() {\n\t\treturn (bool) $this->is_paged;\n\t}\n\n\t/**\n\t * Is the query for a post or page preview?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_preview() {\n\t\treturn (bool) $this->is_preview;\n\t}\n\n\t/**\n\t * Is the query for the robots file?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_robots() {\n\t\treturn (bool) $this->is_robots;\n\t}\n\n\t/**\n\t * Is the query for a search?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_search() {\n\t\treturn (bool) $this->is_search;\n\t}\n\n\t/**\n\t * Is the query for an existing single post?\n\t *\n\t * Works for any post type excluding pages.\n\t *\n\t * If the $post parameter is specified, this function will additionally\n\t * check if the query is for one of the Posts specified.\n\t *\n\t * @see WP_Query::is_page()\n\t * @see WP_Query::is_singular()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param int|string|array $post Optional. Post ID, title, slug, path, or array of such. Default empty.\n\t * @return bool Whether the query is for an existing single post.\n\t */\n\tpublic function is_single( $post = '' ) {\n\t\tif ( ! $this->is_single ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $post ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$post_obj = $this->get_queried_object();\n\n\t\t$post = array_map( 'strval', (array) $post );\n\n\t\tif ( in_array( (string) $post_obj->ID, $post ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $post_obj->post_title, $post ) ) {\n\t\t\treturn true;\n\t\t} elseif ( in_array( $post_obj->post_name, $post ) ) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tforeach ( $post as $postpath ) {\n\t\t\t\tif ( ! strpos( $postpath, '/' ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t$postpath_obj = get_page_by_path( $postpath, OBJECT, $post_obj->post_type );\n\n\t\t\t\tif ( $postpath_obj && ( $postpath_obj->ID == $post_obj->ID ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Is the query for an existing single post of any post type (post, attachment, page,\n\t * custom post types)?\n\t *\n\t * If the $post_types parameter is specified, this function will additionally\n\t * check if the query is for one of the Posts Types specified.\n\t *\n\t * @see WP_Query::is_page()\n\t * @see WP_Query::is_single()\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param string|array $post_types Optional. Post type or array of post types. Default empty.\n\t * @return bool Whether the query is for an existing single post of any of the given post types.\n\t */\n\tpublic function is_singular( $post_types = '' ) {\n\t\tif ( empty( $post_types ) || ! $this->is_singular ) {\n\t\t\treturn (bool) $this->is_singular;\n\t\t}\n\n\t\t$post_obj = $this->get_queried_object();\n\n\t\treturn in_array( $post_obj->post_type, (array) $post_types );\n\t}\n\n\t/**\n\t * Is the query for a specific time?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_time() {\n\t\treturn (bool) $this->is_time;\n\t}\n\n\t/**\n\t * Is the query for a trackback endpoint call?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_trackback() {\n\t\treturn (bool) $this->is_trackback;\n\t}\n\n\t/**\n\t * Is the query for an existing year archive?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_year() {\n\t\treturn (bool) $this->is_year;\n\t}\n\n\t/**\n\t * Is the query a 404 (returns no results)?\n\t *\n\t * @since 3.1.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_404() {\n\t\treturn (bool) $this->is_404;\n\t}\n\n\t/**\n\t * Is the query for an embedded post?\n\t *\n\t * @since 4.4.0\n\t *\n\t * @return bool\n\t */\n\tpublic function is_embed() {\n\t\treturn (bool) $this->is_embed;\n\t}\n\n\t/**\n\t * Is the query the main query?\n\t *\n\t * @since 3.3.0\n\t *\n\t * @global WP_Query $wp_query Global WP_Query instance.\n\t *\n\t * @return bool\n\t */\n\tpublic function is_main_query() {\n\t\tglobal $wp_the_query;\n\t\treturn $wp_the_query === $this;\n\t}\n\n\t/**\n\t * Set up global post data.\n\t *\n\t * @since 4.1.0\n\t * @since 4.4.0 Added the ability to pass a post ID to `$post`.\n\t *\n\t * @global int             $id\n\t * @global WP_User         $authordata\n\t * @global string|int|bool $currentday\n\t * @global string|int|bool $currentmonth\n\t * @global int             $page\n\t * @global array           $pages\n\t * @global int             $multipage\n\t * @global int             $more\n\t * @global int             $numpages\n\t *\n\t * @param WP_Post|object|int $post WP_Post instance or Post ID/object.\n\t * @return true True when finished.\n\t */\n\tpublic function setup_postdata( $post ) {\n\t\tglobal $id, $authordata, $currentday, $currentmonth, $page, $pages, $multipage, $more, $numpages;\n\n\t\tif ( ! ( $post instanceof WP_Post ) ) {\n\t\t\t$post = get_post( $post );\n\t\t}\n\n\t\tif ( ! $post ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$elements = $this->generate_postdata( $post );\n\t\tif ( false === $elements ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$id           = $elements['id'];\n\t\t$authordata   = $elements['authordata'];\n\t\t$currentday   = $elements['currentday'];\n\t\t$currentmonth = $elements['currentmonth'];\n\t\t$page         = $elements['page'];\n\t\t$pages        = $elements['pages'];\n\t\t$multipage    = $elements['multipage'];\n\t\t$more         = $elements['more'];\n\t\t$numpages     = $elements['numpages'];\n\n\t\t/**\n\t\t * Fires once the post data has been setup.\n\t\t *\n\t\t * @since 2.8.0\n\t\t * @since 4.1.0 Introduced `$this` parameter.\n\t\t *\n\t\t * @param WP_Post  $post The Post object (passed by reference).\n\t\t * @param WP_Query $this The current Query object (passed by reference).\n\t\t */\n\t\tdo_action_ref_array( 'the_post', array( &$post, &$this ) );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Generate post data.\n\t *\n\t * @since 5.2.0\n\t *\n\t * @param WP_Post|object|int $post WP_Post instance or Post ID/object.\n\t * @return array|bool $elements Elements of post or false on failure.\n\t */\n\tpublic function generate_postdata( $post ) {\n\n\t\tif ( ! ( $post instanceof WP_Post ) ) {\n\t\t\t$post = get_post( $post );\n\t\t}\n\n\t\tif ( ! $post ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$id = (int) $post->ID;\n\n\t\t$authordata = get_userdata( $post->post_author );\n\n\t\t$currentday   = mysql2date( 'd.m.y', $post->post_date, false );\n\t\t$currentmonth = mysql2date( 'm', $post->post_date, false );\n\t\t$numpages     = 1;\n\t\t$multipage    = 0;\n\t\t$page         = $this->get( 'page' );\n\t\tif ( ! $page ) {\n\t\t\t$page = 1;\n\t\t}\n\n\t\t/*\n\t\t * Force full post content when viewing the permalink for the $post,\n\t\t * or when on an RSS feed. Otherwise respect the 'more' tag.\n\t\t */\n\t\tif ( $post->ID === get_queried_object_id() && ( $this->is_page() || $this->is_single() ) ) {\n\t\t\t$more = 1;\n\t\t} elseif ( $this->is_feed() ) {\n\t\t\t$more = 1;\n\t\t} else {\n\t\t\t$more = 0;\n\t\t}\n\n\t\t$content = $post->post_content;\n\t\tif ( false !== strpos( $content, '<!--nextpage-->' ) ) {\n\t\t\t$content = str_replace( \"\\n<!--nextpage-->\\n\", '<!--nextpage-->', $content );\n\t\t\t$content = str_replace( \"\\n<!--nextpage-->\", '<!--nextpage-->', $content );\n\t\t\t$content = str_replace( \"<!--nextpage-->\\n\", '<!--nextpage-->', $content );\n\n\t\t\t// Remove the nextpage block delimiters, to avoid invalid block structures in the split content.\n\t\t\t$content = str_replace( '<!-- wp:nextpage -->', '', $content );\n\t\t\t$content = str_replace( '<!-- /wp:nextpage -->', '', $content );\n\n\t\t\t// Ignore nextpage at the beginning of the content.\n\t\t\tif ( 0 === strpos( $content, '<!--nextpage-->' ) ) {\n\t\t\t\t$content = substr( $content, 15 );\n\t\t\t}\n\n\t\t\t$pages = explode( '<!--nextpage-->', $content );\n\t\t} else {\n\t\t\t$pages = array( $post->post_content );\n\t\t}\n\n\t\t/**\n\t\t * Filters the \"pages\" derived from splitting the post content.\n\t\t *\n\t\t * \"Pages\" are determined by splitting the post content based on the presence\n\t\t * of `<!-- nextpage -->` tags.\n\t\t *\n\t\t * @since 4.4.0\n\t\t *\n\t\t * @param string[] $pages Array of \"pages\" from the post content split by `<!-- nextpage -->` tags.\n\t\t * @param WP_Post  $post  Current post object.\n\t\t */\n\t\t$pages = apply_filters( 'content_pagination', $pages, $post );\n\n\t\t$numpages = count( $pages );\n\n\t\tif ( $numpages > 1 ) {\n\t\t\tif ( $page > 1 ) {\n\t\t\t\t$more = 1;\n\t\t\t}\n\t\t\t$multipage = 1;\n\t\t} else {\n\t\t\t$multipage = 0;\n\t\t}\n\n\t\t$elements = compact( 'id', 'authordata', 'currentday', 'currentmonth', 'page', 'pages', 'multipage', 'more', 'numpages' );\n\n\t\treturn $elements;\n\t}\n\t/**\n\t * After looping through a nested query, this function\n\t * restores the $post global to the current post in this query.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @global WP_Post $post\n\t */\n\tpublic function reset_postdata() {\n\t\tif ( ! empty( $this->post ) ) {\n\t\t\t$GLOBALS['post'] = $this->post;\n\t\t\t$this->setup_postdata( $this->post );\n\t\t}\n\t}\n\n\t/**\n\t * Lazyload term meta for posts in the loop.\n\t *\n\t * @since 4.4.0\n\t * @deprecated 4.5.0 See wp_queue_posts_for_term_meta_lazyload().\n\t *\n\t * @param mixed $check\n\t * @param int   $term_id\n\t * @return mixed\n\t */\n\tpublic function lazyload_term_meta( $check, $term_id ) {\n\t\t_deprecated_function( __METHOD__, '4.5.0' );\n\t\treturn $check;\n\t}\n\n\t/**\n\t * Lazyload comment meta for comments in the loop.\n\t *\n\t * @since 4.4.0\n\t * @deprecated 4.5.0 See wp_queue_comments_for_comment_meta_lazyload().\n\t *\n\t * @param mixed $check\n\t * @param int   $comment_id\n\t * @return mixed\n\t */\n\tpublic function lazyload_comment_meta( $check, $comment_id ) {\n\t\t_deprecated_function( __METHOD__, '4.5.0' );\n\t\treturn $check;\n\t}\n}\n", "<?php\n/**\n * WordPress environment setup class.\n *\n * @package WordPress\n * @since 2.0.0\n */\nclass WP {\n\t/**\n\t * Public query variables.\n\t *\n\t * Long list of public query variables.\n\t *\n\t * @since 2.0.0\n\t * @var string[]\n\t */\n\tpublic $public_query_vars = array( 'm', 'p', 'posts', 'w', 'cat', 'withcomments', 'withoutcomments', 's', 'search', 'exact', 'sentence', 'calendar', 'page', 'paged', 'more', 'tb', 'pb', 'author', 'order', 'orderby', 'year', 'monthnum', 'day', 'hour', 'minute', 'second', 'name', 'category_name', 'tag', 'feed', 'author_name', 'pagename', 'page_id', 'error', 'attachment', 'attachment_id', 'subpost', 'subpost_id', 'preview', 'robots', 'taxonomy', 'term', 'cpage', 'post_type', 'embed' );\n\n\t/**\n\t * Private query variables.\n\t *\n\t * Long list of private query variables.\n\t *\n\t * @since 2.0.0\n\t * @var string[]\n\t */\n\tpublic $private_query_vars = array( 'offset', 'posts_per_page', 'posts_per_archive_page', 'showposts', 'nopaging', 'post_type', 'post_status', 'category__in', 'category__not_in', 'category__and', 'tag__in', 'tag__not_in', 'tag__and', 'tag_slug__in', 'tag_slug__and', 'tag_id', 'post_mime_type', 'perm', 'comments_per_page', 'post__in', 'post__not_in', 'post_parent', 'post_parent__in', 'post_parent__not_in', 'title', 'fields' );\n\n\t/**\n\t * Extra query variables set by the user.\n\t *\n\t * @since 2.1.0\n\t * @var array\n\t */\n\tpublic $extra_query_vars = array();\n\n\t/**\n\t * Query variables for setting up the WordPress Query Loop.\n\t *\n\t * @since 2.0.0\n\t * @var array\n\t */\n\tpublic $query_vars;\n\n\t/**\n\t * String parsed to set the query variables.\n\t *\n\t * @since 2.0.0\n\t * @var string\n\t */\n\tpublic $query_string;\n\n\t/**\n\t * The request path, e.g. 2015/05/06.\n\t *\n\t * @since 2.0.0\n\t * @var string\n\t */\n\tpublic $request;\n\n\t/**\n\t * Rewrite rule the request matched.\n\t *\n\t * @since 2.0.0\n\t * @var string\n\t */\n\tpublic $matched_rule;\n\n\t/**\n\t * Rewrite query the request matched.\n\t *\n\t * @since 2.0.0\n\t * @var string\n\t */\n\tpublic $matched_query;\n\n\t/**\n\t * Whether already did the permalink.\n\t *\n\t * @since 2.0.0\n\t * @var bool\n\t */\n\tpublic $did_permalink = false;\n\n\t/**\n\t * Add name to list of public query variables.\n\t *\n\t * @since 2.1.0\n\t *\n\t * @param string $qv Query variable name.\n\t */\n\tpublic function add_query_var( $qv ) {\n\t\tif ( ! in_array( $qv, $this->public_query_vars ) ) {\n\t\t\t$this->public_query_vars[] = $qv;\n\t\t}\n\t}\n\n\t/**\n\t * Removes a query variable from a list of public query variables.\n\t *\n\t * @since 4.5.0\n\t *\n\t * @param string $name Query variable name.\n\t */\n\tpublic function remove_query_var( $name ) {\n\t\t$this->public_query_vars = array_diff( $this->public_query_vars, array( $name ) );\n\t}\n\n\t/**\n\t * Set the value of a query variable.\n\t *\n\t * @since 2.3.0\n\t *\n\t * @param string $key Query variable name.\n\t * @param mixed $value Query variable value.\n\t */\n\tpublic function set_query_var( $key, $value ) {\n\t\t$this->query_vars[ $key ] = $value;\n\t}\n\n\t/**\n\t * Parse request to find correct WordPress query.\n\t *\n\t * Sets up the query variables based on the request. There are also many\n\t * filters and actions that can be used to further manipulate the result.\n\t *\n\t * @since 2.0.0\n\t *\n\t * @global WP_Rewrite $wp_rewrite\n\t *\n\t * @param array|string $extra_query_vars Set the extra query variables.\n\t */\n\tpublic function parse_request( $extra_query_vars = '' ) {\n\t\tglobal $wp_rewrite;\n\n\t\t/**\n\t\t * Filters whether to parse the request.\n\t\t *\n\t\t * @since 3.5.0\n\t\t *\n\t\t * @param bool         $bool             Whether or not to parse the request. Default true.\n\t\t * @param WP           $this             Current WordPress environment instance.\n\t\t * @param array|string $extra_query_vars Extra passed query variables.\n\t\t */\n\t\tif ( ! apply_filters( 'do_parse_request', true, $this, $extra_query_vars ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$this->query_vars     = array();\n\t\t$post_type_query_vars = array();\n\n\t\tif ( is_array( $extra_query_vars ) ) {\n\t\t\t$this->extra_query_vars = & $extra_query_vars;\n\t\t} elseif ( ! empty( $extra_query_vars ) ) {\n\t\t\tparse_str( $extra_query_vars, $this->extra_query_vars );\n\t\t}\n\t\t// Process PATH_INFO, REQUEST_URI, and 404 for permalinks.\n\n\t\t// Fetch the rewrite rules.\n\t\t$rewrite = $wp_rewrite->wp_rewrite_rules();\n\n\t\tif ( ! empty( $rewrite ) ) {\n\t\t\t// If we match a rewrite rule, this will be cleared.\n\t\t\t$error               = '404';\n\t\t\t$this->did_permalink = true;\n\n\t\t\t$pathinfo         = isset( $_SERVER['PATH_INFO'] ) ? $_SERVER['PATH_INFO'] : '';\n\t\t\tlist( $pathinfo ) = explode( '?', $pathinfo );\n\t\t\t$pathinfo         = str_replace( '%', '%25', $pathinfo );\n\n\t\t\tlist( $req_uri ) = explode( '?', $_SERVER['REQUEST_URI'] );\n\t\t\t$self            = $_SERVER['PHP_SELF'];\n\t\t\t$home_path       = trim( parse_url( home_url(), PHP_URL_PATH ), '/' );\n\t\t\t$home_path_regex = sprintf( '|^%s|i', preg_quote( $home_path, '|' ) );\n\n\t\t\t// Trim path info from the end and the leading home path from the\n\t\t\t// front. For path info requests, this leaves us with the requesting\n\t\t\t// filename, if any. For 404 requests, this leaves us with the\n\t\t\t// requested permalink.\n\t\t\t$req_uri  = str_replace( $pathinfo, '', $req_uri );\n\t\t\t$req_uri  = trim( $req_uri, '/' );\n\t\t\t$req_uri  = preg_replace( $home_path_regex, '', $req_uri );\n\t\t\t$req_uri  = trim( $req_uri, '/' );\n\t\t\t$pathinfo = trim( $pathinfo, '/' );\n\t\t\t$pathinfo = preg_replace( $home_path_regex, '', $pathinfo );\n\t\t\t$pathinfo = trim( $pathinfo, '/' );\n\t\t\t$self     = trim( $self, '/' );\n\t\t\t$self     = preg_replace( $home_path_regex, '', $self );\n\t\t\t$self     = trim( $self, '/' );\n\n\t\t\t// The requested permalink is in $pathinfo for path info requests and\n\t\t\t//  $req_uri for other requests.\n\t\t\tif ( ! empty( $pathinfo ) && ! preg_match( '|^.*' . $wp_rewrite->index . '$|', $pathinfo ) ) {\n\t\t\t\t$requested_path = $pathinfo;\n\t\t\t} else {\n\t\t\t\t// If the request uri is the index, blank it out so that we don't try to match it against a rule.\n\t\t\t\tif ( $req_uri == $wp_rewrite->index ) {\n\t\t\t\t\t$req_uri = '';\n\t\t\t\t}\n\t\t\t\t$requested_path = $req_uri;\n\t\t\t}\n\t\t\t$requested_file = $req_uri;\n\n\t\t\t$this->request = $requested_path;\n\n\t\t\t// Look for matches.\n\t\t\t$request_match = $requested_path;\n\t\t\tif ( empty( $request_match ) ) {\n\t\t\t\t// An empty request could only match against ^$ regex\n\t\t\t\tif ( isset( $rewrite['$'] ) ) {\n\t\t\t\t\t$this->matched_rule = '$';\n\t\t\t\t\t$query              = $rewrite['$'];\n\t\t\t\t\t$matches            = array( '' );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tforeach ( (array) $rewrite as $match => $query ) {\n\t\t\t\t\t// If the requested file is the anchor of the match, prepend it to the path info.\n\t\t\t\t\tif ( ! empty( $requested_file ) && strpos( $match, $requested_file ) === 0 && $requested_file != $requested_path ) {\n\t\t\t\t\t\t$request_match = $requested_file . '/' . $requested_path;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( preg_match( \"#^$match#\", $request_match, $matches ) ||\n\t\t\t\t\t\tpreg_match( \"#^$match#\", urldecode( $request_match ), $matches ) ) {\n\n\t\t\t\t\t\tif ( $wp_rewrite->use_verbose_page_rules && preg_match( '/pagename=\\$matches\\[([0-9]+)\\]/', $query, $varmatch ) ) {\n\t\t\t\t\t\t\t// This is a verbose page match, let's check to be sure about it.\n\t\t\t\t\t\t\t$page = get_page_by_path( $matches[ $varmatch[1] ] );\n\t\t\t\t\t\t\tif ( ! $page ) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t$post_status_obj = get_post_status_object( $page->post_status );\n\t\t\t\t\t\t\tif ( ! $post_status_obj->public && ! $post_status_obj->protected\n\t\t\t\t\t\t\t\t&& ! $post_status_obj->private && $post_status_obj->exclude_from_search ) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Got a match.\n\t\t\t\t\t\t$this->matched_rule = $match;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( isset( $this->matched_rule ) ) {\n\t\t\t\t// Trim the query of everything up to the '?'.\n\t\t\t\t$query = preg_replace( '!^.+\\?!', '', $query );\n\n\t\t\t\t// Substitute the substring matches into the query.\n\t\t\t\t$query = addslashes( WP_MatchesMapRegex::apply( $query, $matches ) );\n\n\t\t\t\t$this->matched_query = $query;\n\n\t\t\t\t// Parse the query.\n\t\t\t\tparse_str( $query, $perma_query_vars );\n\n\t\t\t\t// If we're processing a 404 request, clear the error var since we found something.\n\t\t\t\tif ( '404' == $error ) {\n\t\t\t\t\tunset( $error, $_GET['error'] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If req_uri is empty or if it is a request for ourself, unset error.\n\t\t\tif ( empty( $requested_path ) || $requested_file == $self || strpos( $_SERVER['PHP_SELF'], 'wp-admin/' ) !== false ) {\n\t\t\t\tunset( $error, $_GET['error'] );\n\n\t\t\t\tif ( isset( $perma_query_vars ) && strpos( $_SERVER['PHP_SELF'], 'wp-admin/' ) !== false ) {\n\t\t\t\t\tunset( $perma_query_vars );\n\t\t\t\t}\n\n\t\t\t\t$this->did_permalink = false;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Filters the query variables whitelist before processing.\n\t\t *\n\t\t * Allows (publicly allowed) query vars to be added, removed, or changed prior\n\t\t * to executing the query. Needed to allow custom rewrite rules using your own arguments\n\t\t * to work, or any other custom query variables you want to be publicly available.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param string[] $public_query_vars The array of whitelisted query variable names.\n\t\t */\n\t\t$this->public_query_vars = apply_filters( 'query_vars', $this->public_query_vars );\n\n\t\tforeach ( get_post_types( array(), 'objects' ) as $post_type => $t ) {\n\t\t\tif ( is_post_type_viewable( $t ) && $t->query_var ) {\n\t\t\t\t$post_type_query_vars[ $t->query_var ] = $post_type;\n\t\t\t}\n\t\t}\n\n\t\tforeach ( $this->public_query_vars as $wpvar ) {\n\t\t\tif ( isset( $this->extra_query_vars[ $wpvar ] ) ) {\n\t\t\t\t$this->query_vars[ $wpvar ] = $this->extra_query_vars[ $wpvar ];\n\t\t\t} elseif ( isset( $_GET[ $wpvar ] ) && isset( $_POST[ $wpvar ] ) && $_GET[ $wpvar ] !== $_POST[ $wpvar ] ) {\n\t\t\t\twp_die( __( 'A variable mismatch has been detected.' ), __( 'Sorry, you are not allowed to view this item.' ), 400 );\n\t\t\t} elseif ( isset( $_POST[ $wpvar ] ) ) {\n\t\t\t\t$this->query_vars[ $wpvar ] = $_POST[ $wpvar ];\n\t\t\t} elseif ( isset( $_GET[ $wpvar ] ) ) {\n\t\t\t\t$this->query_vars[ $wpvar ] = $_GET[ $wpvar ];\n\t\t\t} elseif ( isset( $perma_query_vars[ $wpvar ] ) ) {\n\t\t\t\t$this->query_vars[ $wpvar ] = $perma_query_vars[ $wpvar ];\n\t\t\t}\n\n\t\t\tif ( ! empty( $this->query_vars[ $wpvar ] ) ) {\n\t\t\t\tif ( ! is_array( $this->query_vars[ $wpvar ] ) ) {\n\t\t\t\t\t$this->query_vars[ $wpvar ] = (string) $this->query_vars[ $wpvar ];\n\t\t\t\t} else {\n\t\t\t\t\tforeach ( $this->query_vars[ $wpvar ] as $vkey => $v ) {\n\t\t\t\t\t\tif ( is_scalar( $v ) ) {\n\t\t\t\t\t\t\t$this->query_vars[ $wpvar ][ $vkey ] = (string) $v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( isset( $post_type_query_vars[ $wpvar ] ) ) {\n\t\t\t\t\t$this->query_vars['post_type'] = $post_type_query_vars[ $wpvar ];\n\t\t\t\t\t$this->query_vars['name']      = $this->query_vars[ $wpvar ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Convert urldecoded spaces back into +\n\t\tforeach ( get_taxonomies( array(), 'objects' ) as $taxonomy => $t ) {\n\t\t\tif ( $t->query_var && isset( $this->query_vars[ $t->query_var ] ) ) {\n\t\t\t\t$this->query_vars[ $t->query_var ] = str_replace( ' ', '+', $this->query_vars[ $t->query_var ] );\n\t\t\t}\n\t\t}\n\n\t\t// Don't allow non-publicly queryable taxonomies to be queried from the front end.\n\t\tif ( ! is_admin() ) {\n\t\t\tforeach ( get_taxonomies( array( 'publicly_queryable' => false ), 'objects' ) as $taxonomy => $t ) {\n\t\t\t\t/*\n\t\t\t\t * Disallow when set to the 'taxonomy' query var.\n\t\t\t\t * Non-publicly queryable taxonomies cannot register custom query vars. See register_taxonomy().\n\t\t\t\t */\n\t\t\t\tif ( isset( $this->query_vars['taxonomy'] ) && $taxonomy === $this->query_vars['taxonomy'] ) {\n\t\t\t\t\tunset( $this->query_vars['taxonomy'], $this->query_vars['term'] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Limit publicly queried post_types to those that are publicly_queryable\n\t\tif ( isset( $this->query_vars['post_type'] ) ) {\n\t\t\t$queryable_post_types = get_post_types( array( 'publicly_queryable' => true ) );\n\t\t\tif ( ! is_array( $this->query_vars['post_type'] ) ) {\n\t\t\t\tif ( ! in_array( $this->query_vars['post_type'], $queryable_post_types ) ) {\n\t\t\t\t\tunset( $this->query_vars['post_type'] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$this->query_vars['post_type'] = array_intersect( $this->query_vars['post_type'], $queryable_post_types );\n\t\t\t}\n\t\t}\n\n\t\t// Resolve conflicts between posts with numeric slugs and date archive queries.\n\t\t$this->query_vars = wp_resolve_numeric_slug_conflicts( $this->query_vars );\n\n\t\tforeach ( (array) $this->private_query_vars as $var ) {\n\t\t\tif ( isset( $this->extra_query_vars[ $var ] ) ) {\n\t\t\t\t$this->query_vars[ $var ] = $this->extra_query_vars[ $var ];\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $error ) ) {\n\t\t\t$this->query_vars['error'] = $error;\n\t\t}\n\n\t\t/**\n\t\t * Filters the array of parsed query variables.\n\t\t *\n\t\t * @since 2.1.0\n\t\t *\n\t\t * @param array $query_vars The array of requested query variables.\n\t\t */\n\t\t$this->query_vars = apply_filters( 'request', $this->query_vars );\n\n\t\t/**\n\t\t * Fires once all query variables for the current request have been parsed.\n\t\t *\n\t\t * @since 2.1.0\n\t\t *\n\t\t * @param WP $this Current WordPress environment instance (passed by reference).\n\t\t */\n\t\tdo_action_ref_array( 'parse_request', array( &$this ) );\n\t}\n\n\t/**\n\t * Sends additional HTTP headers for caching, content type, etc.\n\t *\n\t * Sets the Content-Type header. Sets the 'error' status (if passed) and optionally exits.\n\t * If showing a feed, it will also send Last-Modified, ETag, and 304 status if needed.\n\t *\n\t * @since 2.0.0\n\t * @since 4.4.0 `X-Pingback` header is added conditionally after posts have been queried in handle_404().\n\t */\n\tpublic function send_headers() {\n\t\t$headers       = array();\n\t\t$status        = null;\n\t\t$exit_required = false;\n\n\t\tif ( is_user_logged_in() ) {\n\t\t\t$headers = array_merge( $headers, wp_get_nocache_headers() );\n\t\t}\n\t\tif ( ! empty( $this->query_vars['error'] ) ) {\n\t\t\t$status = (int) $this->query_vars['error'];\n\t\t\tif ( 404 === $status ) {\n\t\t\t\tif ( ! is_user_logged_in() ) {\n\t\t\t\t\t$headers = array_merge( $headers, wp_get_nocache_headers() );\n\t\t\t\t}\n\t\t\t\t$headers['Content-Type'] = get_option( 'html_type' ) . '; charset=' . get_option( 'blog_charset' );\n\t\t\t} elseif ( in_array( $status, array( 403, 500, 502, 503 ) ) ) {\n\t\t\t\t$exit_required = true;\n\t\t\t}\n\t\t} elseif ( empty( $this->query_vars['feed'] ) ) {\n\t\t\t$headers['Content-Type'] = get_option( 'html_type' ) . '; charset=' . get_option( 'blog_charset' );\n\t\t} else {\n\t\t\t// Set the correct content type for feeds\n\t\t\t$type = $this->query_vars['feed'];\n\t\t\tif ( 'feed' == $this->query_vars['feed'] ) {\n\t\t\t\t$type = get_default_feed();\n\t\t\t}\n\t\t\t$headers['Content-Type'] = feed_content_type( $type ) . '; charset=' . get_option( 'blog_charset' );\n\n\t\t\t// We're showing a feed, so WP is indeed the only thing that last changed.\n\t\t\tif ( ! empty( $this->query_vars['withcomments'] )\n\t\t\t\t|| false !== strpos( $this->query_vars['feed'], 'comments-' )\n\t\t\t\t|| ( empty( $this->query_vars['withoutcomments'] )\n\t\t\t\t\t&& ( ! empty( $this->query_vars['p'] )\n\t\t\t\t\t\t|| ! empty( $this->query_vars['name'] )\n\t\t\t\t\t\t|| ! empty( $this->query_vars['page_id'] )\n\t\t\t\t\t\t|| ! empty( $this->query_vars['pagename'] )\n\t\t\t\t\t\t|| ! empty( $this->query_vars['attachment'] )\n\t\t\t\t\t\t|| ! empty( $this->query_vars['attachment_id'] )\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t$wp_last_modified = mysql2date( 'D, d M Y H:i:s', get_lastcommentmodified( 'GMT' ), false );\n\t\t\t} else {\n\t\t\t\t$wp_last_modified = mysql2date( 'D, d M Y H:i:s', get_lastpostmodified( 'GMT' ), false );\n\t\t\t}\n\n\t\t\tif ( ! $wp_last_modified ) {\n\t\t\t\t$wp_last_modified = date( 'D, d M Y H:i:s' );\n\t\t\t}\n\n\t\t\t$wp_last_modified .= ' GMT';\n\n\t\t\t$wp_etag                  = '\"' . md5( $wp_last_modified ) . '\"';\n\t\t\t$headers['Last-Modified'] = $wp_last_modified;\n\t\t\t$headers['ETag']          = $wp_etag;\n\n\t\t\t// Support for Conditional GET\n\t\t\tif ( isset( $_SERVER['HTTP_IF_NONE_MATCH'] ) ) {\n\t\t\t\t$client_etag = wp_unslash( $_SERVER['HTTP_IF_NONE_MATCH'] );\n\t\t\t} else {\n\t\t\t\t$client_etag = false;\n\t\t\t}\n\n\t\t\t$client_last_modified = empty( $_SERVER['HTTP_IF_MODIFIED_SINCE'] ) ? '' : trim( $_SERVER['HTTP_IF_MODIFIED_SINCE'] );\n\t\t\t// If string is empty, return 0. If not, attempt to parse into a timestamp\n\t\t\t$client_modified_timestamp = $client_last_modified ? strtotime( $client_last_modified ) : 0;\n\n\t\t\t// Make a timestamp for our most recent modification...\n\t\t\t$wp_modified_timestamp = strtotime( $wp_last_modified );\n\n\t\t\tif ( ( $client_last_modified && $client_etag ) ?\n\t\t\t\t\t( ( $client_modified_timestamp >= $wp_modified_timestamp ) && ( $client_etag == $wp_etag ) ) :\n\t\t\t\t\t( ( $client_modified_timestamp >= $wp_modified_timestamp ) || ( $client_etag == $wp_etag ) ) ) {\n\t\t\t\t$status        = 304;\n\t\t\t\t$exit_required = true;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Filters the HTTP headers before they're sent to the browser.\n\t\t *\n\t\t * @since 2.8.0\n\t\t *\n\t\t * @param string[] $headers Associative array of headers to be sent.\n\t\t * @param WP       $this    Current WordPress environment instance.\n\t\t */\n\t\t$headers = apply_filters( 'wp_headers', $headers, $this );\n\n\t\tif ( ! empty( $status ) ) {\n\t\t\tstatus_header( $status );\n\t\t}\n\n\t\t// If Last-Modified is set to false, it should not be sent (no-cache situation).\n\t\tif ( isset( $headers['Last-Modified'] ) && false === $headers['Last-Modified'] ) {\n\t\t\tunset( $headers['Last-Modified'] );\n\n\t\t\t// In PHP 5.3+, make sure we are not sending a Last-Modified header.\n\t\t\tif ( function_exists( 'header_remove' ) ) {\n\t\t\t\t@header_remove( 'Last-Modified' );\n\t\t\t} else {\n\t\t\t\t// In PHP 5.2, send an empty Last-Modified header, but only as a\n\t\t\t\t// last resort to override a header already sent. #WP23021\n\t\t\t\tforeach ( headers_list() as $header ) {\n\t\t\t\t\tif ( 0 === stripos( $header, 'Last-Modified' ) ) {\n\t\t\t\t\t\t$headers['Last-Modified'] = '';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tforeach ( (array) $headers as $name => $field_value ) {\n\t\t\t@header( \"{$name}: {$field_value}\" );\n\t\t}\n\n\t\tif ( $exit_required ) {\n\t\t\texit();\n\t\t}\n\n\t\t/**\n\t\t * Fires once the requested HTTP headers for caching, content type, etc. have been sent.\n\t\t *\n\t\t * @since 2.1.0\n\t\t *\n\t\t * @param WP $this Current WordPress environment instance (passed by reference).\n\t\t */\n\t\tdo_action_ref_array( 'send_headers', array( &$this ) );\n\t}\n\n\t/**\n\t * Sets the query string property based off of the query variable property.\n\t *\n\t * The {@see 'query_string'} filter is deprecated, but still works. Plugins should\n\t * use the {@see 'request'} filter instead.\n\t *\n\t * @since 2.0.0\n\t */\n\tpublic function build_query_string() {\n\t\t$this->query_string = '';\n\t\tforeach ( (array) array_keys( $this->query_vars ) as $wpvar ) {\n\t\t\tif ( '' != $this->query_vars[ $wpvar ] ) {\n\t\t\t\t$this->query_string .= ( strlen( $this->query_string ) < 1 ) ? '' : '&';\n\t\t\t\tif ( ! is_scalar( $this->query_vars[ $wpvar ] ) ) { // Discard non-scalars.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t$this->query_string .= $wpvar . '=' . rawurlencode( $this->query_vars[ $wpvar ] );\n\t\t\t}\n\t\t}\n\n\t\tif ( has_filter( 'query_string' ) ) {  // Don't bother filtering and parsing if no plugins are hooked in.\n\t\t\t/**\n\t\t\t * Filters the query string before parsing.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t * @deprecated 2.1.0 Use 'query_vars' or 'request' filters instead.\n\t\t\t *\n\t\t\t * @param string $query_string The query string to modify.\n\t\t\t */\n\t\t\t$this->query_string = apply_filters( 'query_string', $this->query_string );\n\t\t\tparse_str( $this->query_string, $this->query_vars );\n\t\t}\n\t}\n\n\t/**\n\t * Set up the WordPress Globals.\n\t *\n\t * The query_vars property will be extracted to the GLOBALS. So care should\n\t * be taken when naming global variables that might interfere with the\n\t * WordPress environment.\n\t *\n\t * @since 2.0.0\n\t *\n\t * @global WP_Query     $wp_query\n\t * @global string       $query_string Query string for the loop.\n\t * @global array        $posts The found posts.\n\t * @global WP_Post|null $post The current post, if available.\n\t * @global string       $request The SQL statement for the request.\n\t * @global int          $more Only set, if single page or post.\n\t * @global int          $single If single page or post. Only set, if single page or post.\n\t * @global WP_User      $authordata Only set, if author archive.\n\t */\n\tpublic function register_globals() {\n\t\tglobal $wp_query;\n\n\t\t// Extract updated query vars back into global namespace.\n\t\tforeach ( (array) $wp_query->query_vars as $key => $value ) {\n\t\t\t$GLOBALS[ $key ] = $value;\n\t\t}\n\n\t\t$GLOBALS['query_string'] = $this->query_string;\n\t\t$GLOBALS['posts']        = & $wp_query->posts;\n\t\t$GLOBALS['post']         = isset( $wp_query->post ) ? $wp_query->post : null;\n\t\t$GLOBALS['request']      = $wp_query->request;\n\n\t\tif ( $wp_query->is_single() || $wp_query->is_page() ) {\n\t\t\t$GLOBALS['more']   = 1;\n\t\t\t$GLOBALS['single'] = 1;\n\t\t}\n\n\t\tif ( $wp_query->is_author() && isset( $wp_query->post ) ) {\n\t\t\t$GLOBALS['authordata'] = get_userdata( $wp_query->post->post_author );\n\t\t}\n\t}\n\n\t/**\n\t * Set up the current user.\n\t *\n\t * @since 2.0.0\n\t */\n\tpublic function init() {\n\t\twp_get_current_user();\n\t}\n\n\t/**\n\t * Set up the Loop based on the query variables.\n\t *\n\t * @since 2.0.0\n\t *\n\t * @global WP_Query $wp_the_query\n\t */\n\tpublic function query_posts() {\n\t\tglobal $wp_the_query;\n\t\t$this->build_query_string();\n\t\t$wp_the_query->query( $this->query_vars );\n\t}\n\n\t/**\n\t * Set the Headers for 404, if nothing is found for requested URL.\n\t *\n\t * Issue a 404 if a request doesn't match any posts and doesn't match\n\t * any object (e.g. an existing-but-empty category, tag, author) and a 404 was not already\n\t * issued, and if the request was not a search or the homepage.\n\t *\n\t * Otherwise, issue a 200.\n\t *\n\t * This sets headers after posts have been queried. handle_404() really means \"handle status.\"\n\t * By inspecting the result of querying posts, seemingly successful requests can be switched to\n\t * a 404 so that canonical redirection logic can kick in.\n\t *\n\t * @since 2.0.0\n\t *\n\t * @global WP_Query $wp_query\n\t */\n\tpublic function handle_404() {\n\t\tglobal $wp_query;\n\n\t\t/**\n\t\t * Filters whether to short-circuit default header status handling.\n\t\t *\n\t\t * Returning a non-false value from the filter will short-circuit the handling\n\t\t * and return early.\n\t\t *\n\t\t * @since 4.5.0\n\t\t *\n\t\t * @param bool     $preempt  Whether to short-circuit default header status handling. Default false.\n\t\t * @param WP_Query $wp_query WordPress Query object.\n\t\t */\n\t\tif ( false !== apply_filters( 'pre_handle_404', false, $wp_query ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If we've already issued a 404, bail.\n\t\tif ( is_404() ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Never 404 for the admin, robots, or if we found posts.\n\t\tif ( is_admin() || is_robots() || $wp_query->posts ) {\n\n\t\t\t$success = true;\n\t\t\tif ( is_singular() ) {\n\t\t\t\t$p = false;\n\n\t\t\t\tif ( $wp_query->post instanceof WP_Post ) {\n\t\t\t\t\t$p = clone $wp_query->post;\n\t\t\t\t}\n\n\t\t\t\t// Only set X-Pingback for single posts that allow pings.\n\t\t\t\tif ( $p && pings_open( $p ) ) {\n\t\t\t\t\t@header( 'X-Pingback: ' . get_bloginfo( 'pingback_url', 'display' ) );\n\t\t\t\t}\n\n\t\t\t\t// check for paged content that exceeds the max number of pages\n\t\t\t\t$next = '<!--nextpage-->';\n\t\t\t\tif ( $p && false !== strpos( $p->post_content, $next ) && ! empty( $this->query_vars['page'] ) ) {\n\t\t\t\t\t$page    = trim( $this->query_vars['page'], '/' );\n\t\t\t\t\t$success = (int) $page <= ( substr_count( $p->post_content, $next ) + 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $success ) {\n\t\t\t\tstatus_header( 200 );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// We will 404 for paged queries, as no posts were found.\n\t\tif ( ! is_paged() ) {\n\n\t\t\t// Don't 404 for authors without posts as long as they matched an author on this site.\n\t\t\t$author = get_query_var( 'author' );\n\t\t\tif ( is_author() && is_numeric( $author ) && $author > 0 && is_user_member_of_blog( $author ) ) {\n\t\t\t\tstatus_header( 200 );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Don't 404 for these queries if they matched an object.\n\t\t\tif ( ( is_tag() || is_category() || is_tax() || is_post_type_archive() ) && get_queried_object() ) {\n\t\t\t\tstatus_header( 200 );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Don't 404 for these queries either.\n\t\t\tif ( is_home() || is_search() || is_feed() ) {\n\t\t\t\tstatus_header( 200 );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Guess it's time to 404.\n\t\t$wp_query->set_404();\n\t\tstatus_header( 404 );\n\t\tnocache_headers();\n\t}\n\n\t/**\n\t * Sets up all of the variables required by the WordPress environment.\n\t *\n\t * The action {@see 'wp'} has one parameter that references the WP object. It\n\t * allows for accessing the properties and methods to further manipulate the\n\t * object.\n\t *\n\t * @since 2.0.0\n\t *\n\t * @param string|array $query_args Passed to parse_request().\n\t */\n\tpublic function main( $query_args = '' ) {\n\t\t$this->init();\n\t\t$this->parse_request( $query_args );\n\t\t$this->send_headers();\n\t\t$this->query_posts();\n\t\t$this->handle_404();\n\t\t$this->register_globals();\n\n\t\t/**\n\t\t * Fires once the WordPress environment has been set up.\n\t\t *\n\t\t * @since 2.1.0\n\t\t *\n\t\t * @param WP $this Current WordPress environment instance (passed by reference).\n\t\t */\n\t\tdo_action_ref_array( 'wp', array( &$this ) );\n\t}\n}\n", "<?php\n/**\n * WordPress Version\n *\n * Contains version information for the current WordPress release.\n *\n * @package WordPress\n * @since 1.1.0\n */\n\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '5.2.4-alpha-46479';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 44719;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4940-20190515';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.6.20';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "filenames": ["wp-includes/class-wp-query.php", "wp-includes/class-wp.php", "wp-includes/version.php"], "buggy_code_start_loc": [541, 17, 16], "buggy_code_end_loc": [806, 18, 17], "fixing_code_start_loc": [540, 17, 16], "fixing_code_end_loc": [805, 18, 17], "type": "CWE-200", "message": "In WordPress before 5.2.4, unauthenticated viewing of certain content is possible because the static query property is mishandled.", "other": {"cve": {"id": "CVE-2019-17671", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-17T13:15:10.937", "lastModified": "2023-02-03T21:54:45.063", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In WordPress before 5.2.4, unauthenticated viewing of certain content is possible because the static query property is mishandled."}, {"lang": "es", "value": "En WordPress anterior a 5.2.4, es posible la visualizaci\u00f3n no autenticada de cierto contenido porque la propiedad de consulta est\u00e1tica es manejada inapropiadamente."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wordpress:wordpress:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.2.4", "matchCriteriaId": "954E75B0-6B64-4856-B36D-4EBD80FBDC1B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://blog.wpscan.org/wordpress/security/release/2019/10/15/wordpress-524-security-release-breakdown.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://core.trac.wordpress.org/changeset/46474", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/WordPress/WordPress/commit/f82ed753cf00329a5e41f2cb6dc521085136f308", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/11/msg00000.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2020/Jan/8", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://wordpress.org/news/2019/10/wordpress-5-2-4-security-release/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://wpvulndb.com/vulnerabilities/9909", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4599", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4677", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/WordPress/WordPress/commit/f82ed753cf00329a5e41f2cb6dc521085136f308"}}