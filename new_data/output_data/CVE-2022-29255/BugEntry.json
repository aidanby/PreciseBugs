{"buggy_code": ["from decimal import Decimal\n\nimport pytest\n\nfrom vyper.exceptions import (\n    ArgumentException,\n    InvalidType,\n    StateAccessViolation,\n    StructureException,\n    UndeclaredDefinition,\n    UnknownType,\n)\n\n\ndef test_external_contract_calls(get_contract, get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\n@external\ndef foo(arg1: int128) -> int128:\n    return arg1\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n        def foo(arg1: int128) -> int128: view\n\n@external\ndef bar(arg1: address, arg2: int128) -> int128:\n    return Foo(arg1).foo(arg2)\n    \"\"\"\n    c2 = get_contract(contract_2)\n\n    assert c2.bar(c.address, 1) == 1\n    print(\"Successfully executed an external contract call\")\n\n\ndef test_complicated_external_contract_calls(get_contract, get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nlucky: public(int128)\n\n@external\ndef __init__(_lucky: int128):\n    self.lucky = _lucky\n\n@external\ndef foo() -> int128:\n    return self.lucky\n\n@external\ndef array() -> Bytes[3]:\n    return b'dog'\n    \"\"\"\n\n    lucky_number = 7\n    c = get_contract_with_gas_estimation(contract_1, *[lucky_number])\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> int128: nonpayable\n    def array() -> Bytes[3]: view\n\n@external\ndef bar(arg1: address) -> int128:\n    return Foo(arg1).foo()\n    \"\"\"\n    c2 = get_contract(contract_2)\n\n    assert c2.bar(c.address) == lucky_number\n    print(\"Successfully executed a complicated external contract call\")\n\n\n@pytest.mark.parametrize(\"length\", [3, 32, 33, 64])\ndef test_external_contract_calls_with_bytes(get_contract, length):\n    contract_1 = f\"\"\"\n@external\ndef array() -> Bytes[{length}]:\n    return b'dog'\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def array() -> Bytes[3]: view\n\n@external\ndef get_array(arg1: address) -> Bytes[3]:\n    return Foo(arg1).array()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c2.get_array(c.address) == b\"dog\"\n\n\ndef test_bytes_too_long(get_contract, assert_tx_failed):\n    contract_1 = \"\"\"\n@external\ndef array() -> Bytes[4]:\n    return b'doge'\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def array() -> Bytes[3]: view\n\n@external\ndef get_array(arg1: address) -> Bytes[3]:\n    return Foo(arg1).array()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert_tx_failed(lambda: c2.get_array(c.address))\n\n\n@pytest.mark.parametrize(\n    \"revert_string\", [\"Mayday, mayday!\", \"A very long revert string\" + \".\" * 512]\n)\ndef test_revert_propagation(get_contract, assert_tx_failed, revert_string):\n    raiser = f\"\"\"\n@external\ndef run():\n    raise \"{revert_string}\"\n    \"\"\"\n    caller = \"\"\"\ninterface Raises:\n    def run(): pure\n\n@external\ndef run(raiser: address):\n    Raises(raiser).run()\n    \"\"\"\n    c1 = get_contract(raiser)\n    c2 = get_contract(caller)\n    assert_tx_failed(lambda: c2.run(c1.address), exc_text=revert_string)\n\n\n@pytest.mark.parametrize(\"a,b\", [(3, 3), (4, 3), (3, 4), (32, 32), (33, 33), (64, 64)])\n@pytest.mark.parametrize(\"actual\", [3, 32, 64])\ndef test_tuple_with_bytes(get_contract, a, b, actual):\n    contract_1 = f\"\"\"\n@external\ndef array() -> (Bytes[{actual}], int128, Bytes[{actual}]):\n    return b'dog', 255, b'cat'\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = f\"\"\"\ninterface Foo:\n    def array() -> (Bytes[{a}], int128, Bytes[{b}]): view\n\n@external\ndef get_array(arg1: address) -> (Bytes[{a}], int128, Bytes[{b}]):\n    a: Bytes[{a}] = b\"\"\n    b: int128 = 0\n    c: Bytes[{b}] = b\"\"\n    a, b, c = Foo(arg1).array()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.array() == [b\"dog\", 255, b\"cat\"]\n    assert c2.get_array(c.address) == [b\"dog\", 255, b\"cat\"]\n\n\n@pytest.mark.parametrize(\"a,b\", [(18, 7), (18, 18), (19, 6), (64, 6), (7, 19)])\n@pytest.mark.parametrize(\"c,d\", [(19, 7), (64, 64)])\ndef test_tuple_with_bytes_too_long(get_contract, assert_tx_failed, a, c, b, d):\n    contract_1 = f\"\"\"\n@external\ndef array() -> (Bytes[{c}], int128, Bytes[{d}]):\n    return b'nineteen characters', 255, b'seven!!'\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = f\"\"\"\ninterface Foo:\n    def array() -> (Bytes[{a}], int128, Bytes[{b}]): view\n\n@external\ndef get_array(arg1: address) -> (Bytes[{a}], int128, Bytes[{b}]):\n    a: Bytes[{a}] = b\"\"\n    b: int128 = 0\n    c: Bytes[{b}] = b\"\"\n    a, b, c = Foo(arg1).array()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.array() == [b\"nineteen characters\", 255, b\"seven!!\"]\n    assert_tx_failed(lambda: c2.get_array(c.address))\n\n\ndef test_tuple_with_bytes_too_long_two(get_contract, assert_tx_failed):\n    contract_1 = \"\"\"\n@external\ndef array() -> (Bytes[30], int128, Bytes[30]):\n    return b'nineteen characters', 255, b'seven!!'\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def array() -> (Bytes[30], int128, Bytes[3]): view\n\n@external\ndef get_array(arg1: address) -> (Bytes[30], int128, Bytes[3]):\n    a: Bytes[30] = b\"\"\n    b: int128 = 0\n    c: Bytes[3] = b\"\"\n    a, b, c = Foo(arg1).array()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.array() == [b\"nineteen characters\", 255, b\"seven!!\"]\n    assert_tx_failed(lambda: c2.get_array(c.address))\n\n\n@pytest.mark.parametrize(\"length\", [8, 256])\ndef test_external_contract_calls_with_uint8(get_contract, length):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> uint{length}:\n    return 255\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> uint8: view\n\n@external\ndef bar(arg1: address) -> uint8:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c2.bar(c.address) == 255\n\n\ndef test_uint8_too_long(get_contract, assert_tx_failed):\n    contract_1 = \"\"\"\n@external\ndef foo() -> uint256:\n    return 2**255\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> uint8: view\n\n@external\ndef bar(arg1: address) -> uint8:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"a,b\", [(8, 8), (8, 256), (256, 8), (256, 256)])\n@pytest.mark.parametrize(\"actual\", [8, 256])\ndef test_tuple_with_uint8(get_contract, a, b, actual):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> (uint{actual}, Bytes[3], uint{actual}):\n    return 255, b'dog', 255\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = f\"\"\"\ninterface Foo:\n    def foo() -> (uint{a}, Bytes[3], uint{b}): view\n\n@external\ndef bar(arg1: address) -> (uint{a}, Bytes[3], uint{b}):\n    a: uint{a} = 0\n    b: Bytes[3] = b\"\"\n    c: uint{b} = 0\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [255, b\"dog\", 255]\n    assert c2.bar(c.address) == [255, b\"dog\", 255]\n\n\n@pytest.mark.parametrize(\"a,b\", [(8, 256), (256, 8), (256, 256)])\ndef test_tuple_with_uint8_too_long(get_contract, assert_tx_failed, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> (uint{a}, Bytes[3], uint{b}):\n    return {(2**a)-1}, b'dog', {(2**b)-1}\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> (uint8, Bytes[3], uint8): view\n\n@external\ndef bar(arg1: address) -> (uint8, Bytes[3], uint8):\n    a: uint8 = 0\n    b: Bytes[3] = b\"\"\n    c: uint8 = 0\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [int(f\"{(2**a)-1}\"), b\"dog\", int(f\"{(2**b)-1}\")]\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"a,b\", [(8, 256), (256, 8)])\ndef test_tuple_with_uint8_too_long_two(get_contract, assert_tx_failed, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> (uint{b}, Bytes[3], uint{a}):\n    return {(2**b)-1}, b'dog', {(2**a)-1}\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = f\"\"\"\ninterface Foo:\n    def foo() -> (uint{a}, Bytes[3], uint{b}): view\n\n@external\ndef bar(arg1: address) -> (uint{a}, Bytes[3], uint{b}):\n    a: uint{a} = 0\n    b: Bytes[3] = b\"\"\n    c: uint{b} = 0\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [int(f\"{(2**b)-1}\"), b\"dog\", int(f\"{(2**a)-1}\")]\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"length\", [128, 256])\ndef test_external_contract_calls_with_int128(get_contract, length):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> int{length}:\n    return 1\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> int128: view\n\n@external\ndef bar(arg1: address) -> int128:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c2.bar(c.address) == 1\n\n\ndef test_int128_too_long(get_contract, assert_tx_failed):\n    contract_1 = \"\"\"\n@external\ndef foo() -> int256:\n    return (2**255)-1\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> int128: view\n\n@external\ndef bar(arg1: address) -> int128:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"a,b\", [(128, 128), (128, 256), (256, 128), (256, 256)])\n@pytest.mark.parametrize(\"actual\", [128, 256])\ndef test_tuple_with_int128(get_contract, a, b, actual):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> (int{actual}, Bytes[3], int{actual}):\n    return 255, b'dog', 255\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = f\"\"\"\ninterface Foo:\n    def foo() -> (int{a}, Bytes[3], int{b}): view\n\n@external\ndef bar(arg1: address) -> (int{a}, Bytes[3], int{b}):\n    a: int{a} = 0\n    b: Bytes[3] = b\"\"\n    c: int{b} = 0\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [255, b\"dog\", 255]\n    assert c2.bar(c.address) == [255, b\"dog\", 255]\n\n\n@pytest.mark.parametrize(\"a,b\", [(128, 256), (256, 128), (256, 256)])\ndef test_tuple_with_int128_too_long(get_contract, assert_tx_failed, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> (int{a}, Bytes[3], int{b}):\n    return {(2**(a-1))-1}, b'dog', {(2**(b-1))-1}\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> (int128, Bytes[3], int128): view\n\n@external\ndef bar(arg1: address) -> (int128, Bytes[3], int128):\n    a: int128 = 0\n    b: Bytes[3] = b\"\"\n    c: int128 = 0\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [int(f\"{(2**(a-1))-1}\"), b\"dog\", int(f\"{(2**(b-1))-1}\")]\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"a,b\", [(128, 256), (256, 128)])\ndef test_tuple_with_int128_too_long_two(get_contract, assert_tx_failed, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> (int{b}, Bytes[3], int{a}):\n    return {(2**(b-1))-1}, b'dog', {(2**(a-1))-1}\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = f\"\"\"\ninterface Foo:\n    def foo() -> (int{a}, Bytes[3], int{b}): view\n\n@external\ndef bar(arg1: address) -> (int{a}, Bytes[3], int{b}):\n    a: int{a} = 0\n    b: Bytes[3] = b\"\"\n    c: int{b} = 0\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [int(f\"{(2**(b-1))-1}\"), b\"dog\", int(f\"{(2**(a-1))-1}\")]\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"type\", [\"uint8\", \"uint256\", \"int128\", \"int256\"])\ndef test_external_contract_calls_with_decimal(get_contract, type):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> {type}:\n    return 1\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> decimal: view\n\n@external\ndef bar(arg1: address) -> decimal:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c2.bar(c.address) == Decimal(\"1e-10\")\n\n\ndef test_decimal_too_long(get_contract, assert_tx_failed):\n    contract_1 = \"\"\"\n@external\ndef foo() -> uint256:\n    return 2**255\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> decimal: view\n\n@external\ndef bar(arg1: address) -> decimal:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"a\", [\"uint8\", \"uint256\", \"int128\", \"int256\"])\n@pytest.mark.parametrize(\"b\", [\"uint8\", \"uint256\", \"int128\", \"int256\"])\ndef test_tuple_with_decimal(get_contract, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> ({a}, Bytes[3], {b}):\n    return 0, b'dog', 1\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> (decimal, Bytes[3], decimal): view\n\n@external\ndef bar(arg1: address) -> (decimal, Bytes[3], decimal):\n    a: decimal = 0.0\n    b: Bytes[3] = b\"\"\n    c: decimal = 0.0\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [0, b\"dog\", 1]\n    result = c2.bar(c.address)\n    assert result == [Decimal(\"0.0\"), b\"dog\", Decimal(\"1e-10\")]\n\n\n@pytest.mark.parametrize(\"a,b\", [(8, 256), (256, 8), (256, 256)])\ndef test_tuple_with_decimal_too_long(get_contract, assert_tx_failed, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> (uint{a}, Bytes[3], uint{b}):\n    return {2**(a-1)}, b'dog', {2**(b-1)}\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> (decimal, Bytes[3], decimal): view\n\n@external\ndef bar(arg1: address) -> (decimal, Bytes[3], decimal):\n    a: decimal = 0.0\n    b: Bytes[3] = b\"\"\n    c: decimal = 0.0\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [2 ** (a - 1), b\"dog\", 2 ** (b - 1)]\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"type\", [\"uint8\", \"uint256\", \"int128\", \"int256\"])\ndef test_external_contract_calls_with_bool(get_contract, type):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> {type}:\n    return 1\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> bool: view\n\n@external\ndef bar(arg1: address) -> bool:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c2.bar(c.address) is True\n\n\ndef test_bool_too_long(get_contract, assert_tx_failed):\n    contract_1 = \"\"\"\n@external\ndef foo() -> uint256:\n    return 2\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> bool: view\n\n@external\ndef bar(arg1: address) -> bool:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"a\", [\"uint8\", \"uint256\", \"int128\", \"int256\"])\n@pytest.mark.parametrize(\"b\", [\"uint8\", \"uint256\", \"int128\", \"int256\"])\ndef test_tuple_with_bool(get_contract, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> ({a}, Bytes[3], {b}):\n    return 1, b'dog', 0\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> (bool, Bytes[3], bool): view\n\n@external\ndef bar(arg1: address) -> (bool, Bytes[3], bool):\n    a: bool = False\n    b: Bytes[3] = b\"\"\n    c: bool = False\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [1, b\"dog\", 0]\n    assert c2.bar(c.address) == [True, b\"dog\", False]\n\n\n@pytest.mark.parametrize(\"a\", [\"uint8\", \"uint256\", \"int128\", \"int256\"])\n@pytest.mark.parametrize(\"b\", [\"uint8\", \"uint256\", \"int128\", \"int256\"])\ndef test_tuple_with_bool_too_long(get_contract, assert_tx_failed, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> ({a}, Bytes[3], {b}):\n    return 1, b'dog', 2\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> (bool, Bytes[3], bool): view\n\n@external\ndef bar(arg1: address) -> (bool, Bytes[3], bool):\n    a: bool = False\n    b: Bytes[3] = b\"\"\n    c: bool = False\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [1, b\"dog\", 2]\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"type\", [\"uint8\", \"int128\", \"uint256\", \"int256\"])\ndef test_external_contract_calls_with_address(get_contract, type):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> {type}:\n    return 1\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> address: view\n\n@external\ndef bar(arg1: address) -> address:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c2.bar(c.address) == \"0x0000000000000000000000000000000000000001\"\n\n\n@pytest.mark.parametrize(\"type\", [\"uint256\", \"int256\"])\ndef test_external_contract_calls_with_address_two(get_contract, type):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> {type}:\n    return (2**160)-1\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> address: view\n\n@external\ndef bar(arg1: address) -> address:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c2.bar(c.address).lower() == \"0xffffffffffffffffffffffffffffffffffffffff\"\n\n\n@pytest.mark.parametrize(\"type\", [\"uint256\", \"int256\"])\ndef test_address_too_long(get_contract, assert_tx_failed, type):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> {type}:\n    return 2**160\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> address: view\n\n@external\ndef bar(arg1: address) -> address:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"a\", [\"uint8\", \"int128\", \"uint256\", \"int256\"])\n@pytest.mark.parametrize(\"b\", [\"uint8\", \"int128\", \"uint256\", \"int256\"])\ndef test_tuple_with_address(get_contract, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> ({a}, Bytes[3], {b}):\n    return 16, b'dog', 1\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> (address, Bytes[3], address): view\n\n@external\ndef bar(arg1: address) -> (address, Bytes[3], address):\n    a: address = ZERO_ADDRESS\n    b: Bytes[3] = b\"\"\n    c: address = ZERO_ADDRESS\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [16, b\"dog\", 1]\n    assert c2.bar(c.address) == [\n        \"0x0000000000000000000000000000000000000010\",\n        b\"dog\",\n        \"0x0000000000000000000000000000000000000001\",\n    ]\n\n\n@pytest.mark.parametrize(\"a\", [\"uint256\", \"int256\"])\n@pytest.mark.parametrize(\"b\", [\"uint256\", \"int256\"])\ndef test_tuple_with_address_two(get_contract, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> ({a}, Bytes[3], {b}):\n    return (2**160)-1, b'dog', (2**160)-2\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> (address, Bytes[3], address): view\n\n@external\ndef bar(arg1: address) -> (address, Bytes[3], address):\n    a: address = ZERO_ADDRESS\n    b: Bytes[3] = b\"\"\n    c: address = ZERO_ADDRESS\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [(2 ** 160) - 1, b\"dog\", (2 ** 160) - 2]\n    result = c2.bar(c.address)\n    assert len(result) == 3\n    assert result[0].lower() == \"0xffffffffffffffffffffffffffffffffffffffff\"\n    assert result[1] == b\"dog\"\n    assert result[2].lower() == \"0xfffffffffffffffffffffffffffffffffffffffe\"\n\n\n@pytest.mark.parametrize(\"a\", [\"uint256\", \"int256\"])\n@pytest.mark.parametrize(\"b\", [\"uint256\", \"int256\"])\ndef test_tuple_with_address_too_long(get_contract, assert_tx_failed, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> ({a}, Bytes[3], {b}):\n    return (2**160)-1, b'dog', 2**160\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> (address, Bytes[3], address): view\n\n@external\ndef bar(arg1: address) -> (address, Bytes[3], address):\n    a: address = ZERO_ADDRESS\n    b: Bytes[3] = b\"\"\n    c: address = ZERO_ADDRESS\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [(2 ** 160) - 1, b\"dog\", 2 ** 160]\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\ndef test_external_contract_call_state_change(get_contract):\n    contract_1 = \"\"\"\nlucky: public(int128)\n\n@external\ndef set_lucky(_lucky: int128):\n    self.lucky = _lucky\n    \"\"\"\n\n    lucky_number = 7\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def set_lucky(_lucky: int128): nonpayable\n\n@external\ndef set_lucky(arg1: address, arg2: int128):\n    Foo(arg1).set_lucky(arg2)\n    \"\"\"\n    c2 = get_contract(contract_2)\n\n    assert c.lucky() == 0\n    c2.set_lucky(c.address, lucky_number, transact={})\n    assert c.lucky() == lucky_number\n    print(\"Successfully executed an external contract call state change\")\n\n\ndef test_constant_external_contract_call_cannot_change_state(\n    assert_compile_failed, get_contract_with_gas_estimation\n):\n    c = \"\"\"\ninterface Foo:\n    def set_lucky(_lucky: int128) -> int128: nonpayable\n\n@external\n@view\ndef set_lucky_expr(arg1: address, arg2: int128):\n    Foo(arg1).set_lucky(arg2)\n\n@external\n@view\ndef set_lucky_stmt(arg1: address, arg2: int128) -> int128:\n    return Foo(arg1).set_lucky(arg2)\n    \"\"\"\n    assert_compile_failed(lambda: get_contract_with_gas_estimation(c), StateAccessViolation)\n\n    print(\"Successfully blocked an external contract call from a constant function\")\n\n\ndef test_external_contract_can_be_changed_based_on_address(get_contract):\n    contract_1 = \"\"\"\nlucky: public(int128)\n\n@external\ndef set_lucky(_lucky: int128):\n    self.lucky = _lucky\n    \"\"\"\n\n    lucky_number_1 = 7\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\nlucky: public(int128)\n\n@external\ndef set_lucky(_lucky: int128) -> int128:\n    self.lucky = _lucky\n    return self.lucky\n    \"\"\"\n\n    lucky_number_2 = 3\n    c2 = get_contract(contract_2)\n\n    contract_3 = \"\"\"\ninterface Foo:\n    def set_lucky(_lucky: int128): nonpayable\n\n@external\ndef set_lucky(arg1: address, arg2: int128):\n    Foo(arg1).set_lucky(arg2)\n    \"\"\"\n    c3 = get_contract(contract_3)\n\n    c3.set_lucky(c.address, lucky_number_1, transact={})\n    c3.set_lucky(c2.address, lucky_number_2, transact={})\n    assert c.lucky() == lucky_number_1\n    assert c2.lucky() == lucky_number_2\n    print(\n        \"Successfully executed multiple external contract calls to different \"\n        \"contracts based on address\"\n    )\n\n\ndef test_external_contract_calls_with_public_globals(get_contract):\n    contract_1 = \"\"\"\nlucky: public(int128)\n\n@external\ndef __init__(_lucky: int128):\n    self.lucky = _lucky\n    \"\"\"\n\n    lucky_number = 7\n    c = get_contract(contract_1, *[lucky_number])\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def lucky() -> int128: view\n\n@external\ndef bar(arg1: address) -> int128:\n    return Foo(arg1).lucky()\n    \"\"\"\n    c2 = get_contract(contract_2)\n\n    assert c2.bar(c.address) == lucky_number\n    print(\"Successfully executed an external contract call with public globals\")\n\n\ndef test_external_contract_calls_with_multiple_contracts(get_contract):\n    contract_1 = \"\"\"\nlucky: public(int128)\n\n@external\ndef __init__(_lucky: int128):\n    self.lucky = _lucky\n    \"\"\"\n\n    lucky_number = 7\n    c = get_contract(contract_1, *[lucky_number])\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def lucky() -> int128: view\n\nmagic_number: public(int128)\n\n@external\ndef __init__(arg1: address):\n    self.magic_number = Foo(arg1).lucky()\n    \"\"\"\n\n    c2 = get_contract(contract_2, *[c.address])\n    contract_3 = \"\"\"\ninterface Bar:\n    def magic_number() -> int128: view\n\nbest_number: public(int128)\n\n@external\ndef __init__(arg1: address):\n    self.best_number = Bar(arg1).magic_number()\n    \"\"\"\n\n    c3 = get_contract(contract_3, *[c2.address])\n    assert c3.best_number() == lucky_number\n    print(\"Successfully executed a multiple external contract calls\")\n\n\ndef test_external_contract_calls_with_default_value(get_contract):\n    contract_1 = \"\"\"\n@external\ndef foo(arg1: uint256=1) -> uint256:\n    return arg1\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo(arg1: uint256=1) -> uint256: nonpayable\n\n@external\ndef bar(addr: address) -> uint256:\n    return Foo(addr).foo()\n    \"\"\"\n\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n\n    assert c1.foo() == 1\n    assert c1.foo(2) == 2\n    assert c2.bar(c1.address) == 1\n\n\ndef test_external_contract_calls_with_default_value_two(get_contract):\n    contract_1 = \"\"\"\n@external\ndef foo(arg1: uint256, arg2: uint256=1) -> uint256:\n    return arg1 + arg2\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo(arg1: uint256, arg2: uint256=1) -> uint256: nonpayable\n\n@external\ndef bar(addr: address, arg1: uint256) -> uint256:\n    return Foo(addr).foo(arg1)\n    \"\"\"\n\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n\n    assert c1.foo(2) == 3\n    assert c1.foo(2, 3) == 5\n    assert c2.bar(c1.address, 2) == 3\n\n\ndef test_invalid_external_contract_call_to_the_same_contract(get_contract):\n    contract_1 = \"\"\"\n@external\ndef bar() -> int128:\n    return 1\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Bar:\n    def bar() -> int128: view\n\n@external\ndef bar() -> int128:\n    return 1\n\n@external\ndef _stmt(x: address):\n    Bar(x).bar()\n\n@external\ndef _expr(x: address) -> int128:\n    return Bar(x).bar()\n    \"\"\"\n\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n\n    c2._stmt(c1.address)\n    c2._stmt(c2.address)\n\n    assert c2._expr(c1.address) == 1\n    assert c2._expr(c2.address) == 1\n\n\ndef test_invalid_nonexistent_contract_call(w3, assert_tx_failed, get_contract):\n    contract_1 = \"\"\"\n@external\ndef bar() -> int128:\n    return 1\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Bar:\n    def bar() -> int128: view\n\n@external\ndef foo(x: address) -> int128:\n    return Bar(x).bar()\n    \"\"\"\n\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n\n    assert c2.foo(c1.address) == 1\n    assert_tx_failed(lambda: c2.foo(w3.eth.accounts[0]))\n    assert_tx_failed(lambda: c2.foo(w3.eth.accounts[3]))\n\n\ndef test_invalid_contract_reference_declaration(assert_tx_failed, get_contract):\n    contract = \"\"\"\ninterface Bar:\n    get_magic_number: 1\n\nbest_number: public(int128)\n\n@external\ndef __init__():\n    pass\n\"\"\"\n    assert_tx_failed(lambda: get_contract(contract), exception=StructureException)\n\n\ndef test_invalid_contract_reference_call(assert_tx_failed, get_contract):\n    contract = \"\"\"\n@external\ndef bar(arg1: address, arg2: int128) -> int128:\n    return Foo(arg1).foo(arg2)\n\"\"\"\n    assert_tx_failed(lambda: get_contract(contract), exception=UndeclaredDefinition)\n\n\ndef test_invalid_contract_reference_return_type(assert_tx_failed, get_contract):\n    contract = \"\"\"\ninterface Foo:\n    def foo(arg2: int128) -> invalid: view\n\n@external\ndef bar(arg1: address, arg2: int128) -> int128:\n    return Foo(arg1).foo(arg2)\n\"\"\"\n    assert_tx_failed(lambda: get_contract(contract), exception=UnknownType)\n\n\ndef test_external_contract_call_declaration_expr(get_contract):\n    contract_1 = \"\"\"\n@external\ndef bar() -> int128:\n    return 1\n\"\"\"\n\n    contract_2 = \"\"\"\ninterface Bar:\n    def bar() -> int128: view\n\nbar_contract: Bar\n\n@external\ndef foo(contract_address: address) -> int128:\n    self.bar_contract = Bar(contract_address)\n    return self.bar_contract.bar()\n    \"\"\"\n\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n    assert c2.foo(c1.address) == 1\n\n\ndef test_external_contract_call_declaration_stmt(get_contract):\n    contract_1 = \"\"\"\nlucky: int128\n\n@external\ndef set_lucky(_lucky: int128):\n    self.lucky = _lucky\n\n@external\ndef get_lucky() -> int128:\n    return self.lucky\n\"\"\"\n\n    contract_2 = \"\"\"\ninterface Bar:\n    def set_lucky(arg1: int128): nonpayable\n    def get_lucky() -> int128: view\n\nbar_contract: Bar\n\n@external\ndef set_lucky(contract_address: address):\n    self.bar_contract = Bar(contract_address)\n    self.bar_contract.set_lucky(1)\n\n@external\ndef get_lucky(contract_address: address) -> int128:\n    self.bar_contract = Bar(contract_address)\n    return self.bar_contract.get_lucky()\n    \"\"\"\n\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n    assert c1.get_lucky() == 0\n    assert c2.get_lucky(c1.address) == 0\n    c1.set_lucky(6, transact={})\n    assert c1.get_lucky() == 6\n    assert c2.get_lucky(c1.address) == 6\n    c2.set_lucky(c1.address, transact={})\n    assert c1.get_lucky() == 1\n    assert c2.get_lucky(c1.address) == 1\n\n\ndef test_complex_external_contract_call_declaration(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\n@external\ndef get_lucky() -> int128:\n    return 1\n\"\"\"\n\n    contract_2 = \"\"\"\n@external\ndef get_lucky() -> int128:\n    return 2\n\"\"\"\n\n    contract_3 = \"\"\"\ninterface Bar:\n    def set_lucky(arg1: int128): nonpayable\n    def get_lucky() -> int128: view\n\nbar_contract: Bar\n\n@external\ndef set_contract(contract_address: address):\n    self.bar_contract = Bar(contract_address)\n\n@external\ndef get_lucky() -> int128:\n    return self.bar_contract.get_lucky()\n\"\"\"\n\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n    c3 = get_contract_with_gas_estimation(contract_3)\n    assert c1.get_lucky() == 1\n    assert c2.get_lucky() == 2\n    c3.set_contract(c1.address, transact={})\n    assert c3.get_lucky() == 1\n    c3.set_contract(c2.address, transact={})\n    assert c3.get_lucky() == 2\n\n\ndef test_address_can_returned_from_contract_type(get_contract):\n    contract_1 = \"\"\"\n@external\ndef bar() -> int128:\n    return 1\n\"\"\"\n    contract_2 = \"\"\"\ninterface Bar:\n    def bar() -> int128: view\n\nbar_contract: public(Bar)\n\n@external\ndef foo(contract_address: address):\n    self.bar_contract = Bar(contract_address)\n\n@external\ndef get_bar() -> int128:\n    return self.bar_contract.bar()\n\"\"\"\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n    c2.foo(c1.address, transact={})\n    assert c2.bar_contract() == c1.address\n    assert c2.get_bar() == 1\n\n\ndef test_invalid_external_contract_call_declaration_1(assert_compile_failed, get_contract):\n    contract_1 = \"\"\"\ninterface Bar:\n    def bar() -> int128: view\n\nbar_contract: Bar\n\n@external\ndef foo(contract_address: contract(Boo)) -> int128:\n    self.bar_contract = Bar(contract_address)\n    return self.bar_contract.bar()\n    \"\"\"\n\n    assert_compile_failed(lambda: get_contract(contract_1), UnknownType)\n\n\ndef test_invalid_external_contract_call_declaration_2(assert_compile_failed, get_contract):\n    contract_1 = \"\"\"\ninterface Bar:\n    def bar() -> int128: view\n\nbar_contract: Boo\n\n@external\ndef foo(contract_address: address) -> int128:\n    self.bar_contract = Bar(contract_address)\n    return self.bar_contract.bar()\n    \"\"\"\n\n    assert_compile_failed(lambda: get_contract(contract_1), UnknownType)\n\n\ndef test_external_with_payable_value(w3, get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\n@payable\n@external\ndef get_lucky() -> int128:\n    return 1\n\n@external\ndef get_balance() -> uint256:\n    return self.balance\n\"\"\"\n\n    contract_2 = \"\"\"\ninterface Bar:\n    def get_lucky() -> int128: payable\n\nbar_contract: Bar\n\n@external\ndef set_contract(contract_address: address):\n    self.bar_contract = Bar(contract_address)\n\n@payable\n@external\ndef get_lucky(amount_to_send: uint256) -> int128:\n    if amount_to_send != 0:\n        return self.bar_contract.get_lucky(value=amount_to_send)\n    else: # send it all\n        return self.bar_contract.get_lucky(value=msg.value)\n\"\"\"\n\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    # Set address.\n    assert c1.get_lucky() == 1\n    assert c1.get_balance() == 0\n\n    c2.set_contract(c1.address, transact={})\n\n    # Send some eth\n    assert c2.get_lucky(0, call={\"value\": 500}) == 1\n    c2.get_lucky(0, transact={\"value\": 500})\n    # Contract 1 received money.\n    assert c1.get_balance() == 500\n    assert w3.eth.get_balance(c1.address) == 500\n    assert w3.eth.get_balance(c2.address) == 0\n\n    # Send subset of amount\n    assert c2.get_lucky(250, call={\"value\": 500}) == 1\n    c2.get_lucky(250, transact={\"value\": 500})\n\n    # Contract 1 received more money.\n    assert c1.get_balance() == 750\n    assert w3.eth.get_balance(c1.address) == 750\n    assert w3.eth.get_balance(c2.address) == 250\n\n\ndef test_external_call_with_gas(assert_tx_failed, get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\n@external\ndef get_lucky() -> int128:\n    return 656598\n\"\"\"\n\n    contract_2 = \"\"\"\ninterface Bar:\n    def set_lucky(arg1: int128): nonpayable\n    def get_lucky() -> int128: view\n\nbar_contract: Bar\n\n@external\ndef set_contract(contract_address: address):\n    self.bar_contract = Bar(contract_address)\n\n@external\ndef get_lucky(gas_amount: uint256) -> int128:\n    return self.bar_contract.get_lucky(gas=gas_amount)\n\"\"\"\n\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n    c2.set_contract(c1.address, transact={})\n\n    assert c2.get_lucky(1000) == 656598\n    assert_tx_failed(lambda: c2.get_lucky(50))  # too little gas.\n\n\ndef test_skip_contract_check(get_contract_with_gas_estimation):\n    contract_2 = \"\"\"\n@external\n@view\ndef bar():\n    pass\n    \"\"\"\n    contract_1 = \"\"\"\ninterface Bar:\n    def bar() -> uint256: view\n    def baz(): view\n\n@external\ndef call_bar(addr: address):\n    # would fail if returndatasize check were on\n    x: uint256 = Bar(addr).bar(skip_contract_check=True)\n@external\ndef call_baz():\n    # some address with no code\n    addr: address = 0x1234567890AbcdEF1234567890aBcdef12345678\n    # would fail if extcodesize check were on\n    Bar(addr).baz(skip_contract_check=True)\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n    c1.call_bar(c2.address)\n    c1.call_baz()\n\n\ndef test_invalid_keyword_on_call(assert_compile_failed, get_contract_with_gas_estimation):\n\n    contract_1 = \"\"\"\ninterface Bar:\n    def set_lucky(arg1: int128): nonpayable\n    def get_lucky() -> int128: view\n\nbar_contract: Bar\n\n@external\ndef get_lucky(amount_to_send: int128) -> int128:\n    return self.bar_contract.get_lucky(gass=1)\n    \"\"\"\n\n    assert_compile_failed(lambda: get_contract_with_gas_estimation(contract_1), ArgumentException)\n\n\ndef test_invalid_contract_declaration(assert_compile_failed, get_contract_with_gas_estimation):\n\n    contract_1 = \"\"\"\ninterface Bar:\n    def set_lucky(arg1: int128): nonpayable\n\nbar_contract: Barr\n\n    \"\"\"\n\n    assert_compile_failed(lambda: get_contract_with_gas_estimation(contract_1), UnknownType)\n\n\nFAILING_CONTRACTS_STRUCTURE_EXCEPTION = [\n    \"\"\"\n# wrong arg count\ninterface Bar:\n    def bar(arg1: int128) -> bool: view\n\n@external\ndef foo(a: address):\n    Bar(a).bar(1, 2)\n    \"\"\",\n    \"\"\"\n# expected args, none given\ninterface Bar:\n    def bar(arg1: int128) -> bool: view\n\n@external\ndef foo(a: address):\n    Bar(a).bar()\n    \"\"\",\n    \"\"\"\n# expected no args, args given\ninterface Bar:\n    def bar() -> bool: view\n\n@external\ndef foo(a: address):\n    Bar(a).bar(1)\n    \"\"\",\n    \"\"\"\ninterface Bar:\n    def bar(x: uint256, y: uint256) -> uint256: view\n\n@external\ndef foo(a: address, x: uint256, y: uint256):\n    Bar(a).bar(x, y=y)\n    \"\"\",\n]\n\n\n@pytest.mark.parametrize(\"bad_code\", FAILING_CONTRACTS_STRUCTURE_EXCEPTION)\ndef test_bad_code_struct_exc(assert_compile_failed, get_contract_with_gas_estimation, bad_code):\n\n    assert_compile_failed(lambda: get_contract_with_gas_estimation(bad_code), ArgumentException)\n\n\ndef test_bad_skip_contract_check(assert_compile_failed, get_contract_with_gas_estimation):\n    code = \"\"\"\n# variable value for skip_contract_check\ninterface Bar:\n    def bar(): payable\n\n@external\ndef foo():\n    x: bool = True\n    Bar(msg.sender).bar(skip_contract_check=x)\n    \"\"\"\n    assert_compile_failed(lambda: get_contract_with_gas_estimation(code), InvalidType)\n\n\ndef test_tuple_return_external_contract_call(get_contract):\n    contract_1 = \"\"\"\n@external\ndef out_literals() -> (int128, address, Bytes[10]):\n    return 1, 0x0000000000000000000000000000000000000123, b\"random\"\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Test:\n    def out_literals() -> (int128, address, Bytes[10]) : view\n\n@external\ndef test(addr: address) -> (int128, address, Bytes[10]):\n    a: int128 = 0\n    b: address = ZERO_ADDRESS\n    c: Bytes[10] = b\"\"\n    (a, b, c) = Test(addr).out_literals()\n    return a, b,c\n\n    \"\"\"\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n\n    assert c1.out_literals() == [1, \"0x0000000000000000000000000000000000000123\", b\"random\"]\n    assert c2.test(c1.address) == [1, \"0x0000000000000000000000000000000000000123\", b\"random\"]\n\n\ndef test_struct_return_external_contract_call_1(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n    y: address\n@external\ndef out_literals() -> X:\n    return X({x: 1, y: 0x0000000000000000000000000000000000012345})\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: int128\n    y: address\ninterface Test:\n    def out_literals() -> X : view\n\n@external\ndef test(addr: address) -> (int128, address):\n    ret: X = Test(addr).out_literals()\n    return ret.x, ret.y\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.out_literals() == (1, \"0x0000000000000000000000000000000000012345\")\n    assert c2.test(c1.address) == list(c1.out_literals())\n\n\n@pytest.mark.parametrize(\"i,ln,s,\", [(100, 6, \"abcde\"), (41, 40, \"a\" * 34), (57, 70, \"z\" * 68)])\ndef test_struct_return_external_contract_call_2(get_contract_with_gas_estimation, i, ln, s):\n    contract_1 = f\"\"\"\nstruct X:\n    x: int128\n    y: String[{ln}]\n    z: Bytes[{ln}]\n@external\ndef get_struct_x() -> X:\n    return X({{x: {i}, y: \"{s}\", z: b\"{s}\"}})\n    \"\"\"\n\n    contract_2 = f\"\"\"\nstruct X:\n    x: int128\n    y: String[{ln}]\n    z: Bytes[{ln}]\ninterface Test:\n    def get_struct_x() -> X : view\n\n@external\ndef test(addr: address) -> (int128, String[{ln}], Bytes[{ln}]):\n    ret: X = Test(addr).get_struct_x()\n    return ret.x, ret.y, ret.z\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.get_struct_x() == (i, s, bytes(s, \"utf-8\"))\n    assert c2.test(c1.address) == list(c1.get_struct_x())\n\n\ndef test_struct_return_external_contract_call_3(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n@external\ndef out_literals() -> X:\n    return X({x: 1})\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: int128\ninterface Test:\n    def out_literals() -> X : view\n\n@external\ndef test(addr: address) -> int128:\n    ret: X = Test(addr).out_literals()\n    return ret.x\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.out_literals() == (1,)\n    assert [c2.test(c1.address)] == list(c1.out_literals())\n\n\ndef test_constant_struct_return_external_contract_call_1(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n    y: address\n\nBAR: constant(X) = X({x: 1, y: 0x0000000000000000000000000000000000012345})\n\n@external\ndef out_literals() -> X:\n    return BAR\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: int128\n    y: address\ninterface Test:\n    def out_literals() -> X : view\n\n@external\ndef test(addr: address) -> (int128, address):\n    ret: X = Test(addr).out_literals()\n    return ret.x, ret.y\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.out_literals() == (1, \"0x0000000000000000000000000000000000012345\")\n    assert c2.test(c1.address) == list(c1.out_literals())\n\n\n@pytest.mark.parametrize(\"i,ln,s,\", [(100, 6, \"abcde\"), (41, 40, \"a\" * 34), (57, 70, \"z\" * 68)])\ndef test_constant_struct_return_external_contract_call_2(\n    get_contract_with_gas_estimation, i, ln, s\n):\n    contract_1 = f\"\"\"\nstruct X:\n    x: int128\n    y: String[{ln}]\n    z: Bytes[{ln}]\n\nBAR: constant(X) = X({{x: {i}, y: \"{s}\", z: b\"{s}\"}})\n\n@external\ndef get_struct_x() -> X:\n    return BAR\n    \"\"\"\n\n    contract_2 = f\"\"\"\nstruct X:\n    x: int128\n    y: String[{ln}]\n    z: Bytes[{ln}]\ninterface Test:\n    def get_struct_x() -> X : view\n\n@external\ndef test(addr: address) -> (int128, String[{ln}], Bytes[{ln}]):\n    ret: X = Test(addr).get_struct_x()\n    return ret.x, ret.y, ret.z\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.get_struct_x() == (i, s, bytes(s, \"utf-8\"))\n    assert c2.test(c1.address) == list(c1.get_struct_x())\n\n\ndef test_constant_struct_return_external_contract_call_3(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n\nBAR: constant(X) = X({x: 1})\n\n@external\ndef out_literals() -> X:\n    return BAR\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: int128\ninterface Test:\n    def out_literals() -> X : view\n\n@external\ndef test(addr: address) -> int128:\n    ret: X = Test(addr).out_literals()\n    return ret.x\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.out_literals() == (1,)\n    assert [c2.test(c1.address)] == list(c1.out_literals())\n\n\ndef test_constant_struct_member_return_external_contract_call_1(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n    y: address\n\nBAR: constant(X) = X({x: 1, y: 0x0000000000000000000000000000000000012345})\n\n@external\ndef get_y() -> address:\n    return BAR.y\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Test:\n    def get_y() -> address : view\n\n@external\ndef test(addr: address) -> address:\n    ret: address = Test(addr).get_y()\n    return ret\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.get_y() == \"0x0000000000000000000000000000000000012345\"\n    assert c2.test(c1.address) == \"0x0000000000000000000000000000000000012345\"\n\n\n@pytest.mark.parametrize(\"i,ln,s,\", [(100, 6, \"abcde\"), (41, 40, \"a\" * 34), (57, 70, \"z\" * 68)])\ndef test_constant_struct_member_return_external_contract_call_2(\n    get_contract_with_gas_estimation, i, ln, s\n):\n    contract_1 = f\"\"\"\nstruct X:\n    x: int128\n    y: String[{ln}]\n    z: Bytes[{ln}]\n\nBAR: constant(X) = X({{x: {i}, y: \"{s}\", z: b\"{s}\"}})\n\n@external\ndef get_y() -> String[{ln}]:\n    return BAR.y\n    \"\"\"\n\n    contract_2 = f\"\"\"\ninterface Test:\n    def get_y() -> String[{ln}] : view\n\n@external\ndef test(addr: address) -> String[{ln}]:\n    ret: String[{ln}] = Test(addr).get_y()\n    return ret\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.get_y() == s\n    assert c2.test(c1.address) == s\n\n\ndef test_constant_struct_member_return_external_contract_call_3(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n\nBAR: constant(X) = X({x: 1})\n\n@external\ndef get_x() -> int128:\n    return BAR.x\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Test:\n    def get_x() -> int128 : view\n\n@external\ndef test(addr: address) -> int128:\n    ret: int128 = Test(addr).get_x()\n    return ret\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.get_x() == 1\n    assert c2.test(c1.address) == 1\n\n\ndef test_constant_nested_struct_return_external_contract_call_1(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n    y: address\n\nstruct A:\n    a: X\n    b: uint256\n\nBAR: constant(A) = A({a: X({x: 1, y: 0x0000000000000000000000000000000000012345}), b: 777})\n\n@external\ndef out_literals() -> A:\n    return BAR\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: int128\n    y: address\n\nstruct A:\n    a: X\n    b: uint256\n\ninterface Test:\n    def out_literals() -> A : view\n\n@external\ndef test(addr: address) -> (X, uint256):\n    ret: A = Test(addr).out_literals()\n    return ret.a, ret.b\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.out_literals() == ((1, \"0x0000000000000000000000000000000000012345\"), 777)\n    assert c2.test(c1.address) == list(c1.out_literals())\n\n\n@pytest.mark.parametrize(\"i,ln,s,\", [(100, 6, \"abcde\"), (41, 40, \"a\" * 34), (57, 70, \"z\" * 68)])\ndef test_constant_nested_struct_return_external_contract_call_2(\n    get_contract_with_gas_estimation, i, ln, s\n):\n    contract_1 = f\"\"\"\nstruct X:\n    x: int128\n    y: String[{ln}]\n    z: Bytes[{ln}]\n\nstruct A:\n    a: X\n    b: uint256\n\nBAR: constant(A) = A({{a: X({{x: {i}, y: \"{s}\", z: b\"{s}\"}}), b: 777}})\n\n@external\ndef get_struct_a() -> A:\n    return BAR\n    \"\"\"\n\n    contract_2 = f\"\"\"\nstruct X:\n    x: int128\n    y: String[{ln}]\n    z: Bytes[{ln}]\n\nstruct A:\n    a: X\n    b: uint256\n\ninterface Test:\n    def get_struct_a() -> A : view\n\n@external\ndef test(addr: address) -> (X, uint256):\n    ret: A = Test(addr).get_struct_a()\n    return ret.a, ret.b\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.get_struct_a() == ((i, s, bytes(s, \"utf-8\")), 777)\n    assert c2.test(c1.address) == list(c1.get_struct_a())\n\n\ndef test_constant_nested_struct_return_external_contract_call_3(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n    y: int128\n\nstruct A:\n    a: X\n    b: uint256\n\nstruct C:\n    c: A\n    d: bool\n\nBAR: constant(C) = C({c: A({a: X({x: 1, y: -1}), b: 777}), d: True})\n\n@external\ndef out_literals() -> C:\n    return BAR\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: int128\n    y: int128\n\nstruct A:\n    a: X\n    b: uint256\n\nstruct C:\n    c: A\n    d: bool\n\ninterface Test:\n    def out_literals() -> C : view\n\n@external\ndef test(addr: address) -> (A, bool):\n    ret: C = Test(addr).out_literals()\n    return ret.c, ret.d\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.out_literals() == (((1, -1), 777), True)\n    assert c2.test(c1.address) == list(c1.out_literals())\n\n\ndef test_constant_nested_struct_member_return_external_contract_call_1(\n    get_contract_with_gas_estimation,\n):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n    y: address\n\nstruct A:\n    a: X\n    b: uint256\n\nBAR: constant(A) = A({a: X({x: 1, y: 0x0000000000000000000000000000000000012345}), b: 777})\n\n@external\ndef get_y() -> address:\n    return BAR.a.y\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Test:\n    def get_y() -> address : view\n\n@external\ndef test(addr: address) -> address:\n    ret: address = Test(addr).get_y()\n    return ret\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.get_y() == \"0x0000000000000000000000000000000000012345\"\n    assert c2.test(c1.address) == \"0x0000000000000000000000000000000000012345\"\n\n\n@pytest.mark.parametrize(\"i,ln,s,\", [(100, 6, \"abcde\"), (41, 40, \"a\" * 34), (57, 70, \"z\" * 68)])\ndef test_constant_nested_struct_member_return_external_contract_call_2(\n    get_contract_with_gas_estimation, i, ln, s\n):\n    contract_1 = f\"\"\"\nstruct X:\n    x: int128\n    y: String[{ln}]\n    z: Bytes[{ln}]\n\nstruct A:\n    a: X\n    b: uint256\n    c: bool\n\nBAR: constant(A) = A({{a: X({{x: {i}, y: \"{s}\", z: b\"{s}\"}}), b: 777, c: True}})\n\n@external\ndef get_y() -> String[{ln}]:\n    return BAR.a.y\n    \"\"\"\n\n    contract_2 = f\"\"\"\ninterface Test:\n    def get_y() -> String[{ln}] : view\n\n@external\ndef test(addr: address) -> String[{ln}]:\n    ret: String[{ln}] = Test(addr).get_y()\n    return ret\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.get_y() == s\n    assert c2.test(c1.address) == s\n\n\ndef test_constant_nested_struct_member_return_external_contract_call_3(\n    get_contract_with_gas_estimation,\n):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n    y: int128\n\nstruct A:\n    a: X\n    b: uint256\n\nstruct C:\n    c: A\n    d: bool\n\nBAR: constant(C) = C({c: A({a: X({x: 1, y: -1}), b: 777}), d: True})\n\n@external\ndef get_y() -> int128:\n    return BAR.c.a.y\n\n@external\ndef get_b() -> uint256:\n    return BAR.c.b\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Test:\n    def get_y() -> int128 : view\n    def get_b() -> uint256 : view\n\n@external\ndef test(addr: address) -> int128:\n    ret: int128 = Test(addr).get_y()\n    return ret\n\n@external\ndef test2(addr: address) -> uint256:\n    ret: uint256 = Test(addr).get_b()\n    return ret\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.get_y() == -1\n    assert c2.test(c1.address) == -1\n\n    assert c1.get_b() == 777\n    assert c2.test2(c1.address) == 777\n\n\ndef test_dynamically_sized_struct_external_contract_call(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: uint256\n    y: Bytes[6]\n\n@external\ndef foo(x: X) -> Bytes[6]:\n    return x.y\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: uint256\n    y: Bytes[6]\n\ninterface Foo:\n    def foo(x: X) -> Bytes[6]: nonpayable\n\n@external\ndef bar(addr: address) -> Bytes[6]:\n    _X: X = X({x: 1, y: b\"hello\"})\n    return Foo(addr).foo(_X)\n    \"\"\"\n\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.foo((1, b\"hello\")) == b\"hello\"\n    assert c2.bar(c1.address) == b\"hello\"\n\n\ndef test_dynamically_sized_struct_external_contract_call_2(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: uint256\n    y: String[6]\n\n@external\ndef foo(x: X) -> String[6]:\n    return x.y\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: uint256\n    y: String[6]\n\ninterface Foo:\n    def foo(x: X) -> String[6]: nonpayable\n\n@external\ndef bar(addr: address) -> String[6]:\n    _X: X = X({x: 1, y: \"hello\"})\n    return Foo(addr).foo(_X)\n    \"\"\"\n\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.foo((1, \"hello\")) == \"hello\"\n    assert c2.bar(c1.address) == \"hello\"\n\n\ndef test_dynamically_sized_struct_member_external_contract_call(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\n@external\ndef foo(b: Bytes[6]) -> Bytes[6]:\n    return b\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: uint256\n    y: Bytes[6]\n\ninterface Foo:\n    def foo(b: Bytes[6]) -> Bytes[6]: nonpayable\n\n@external\ndef bar(addr: address) -> Bytes[6]:\n    _X: X = X({x: 1, y: b\"hello\"})\n    return Foo(addr).foo(_X.y)\n    \"\"\"\n\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.foo(b\"hello\") == b\"hello\"\n    assert c2.bar(c1.address) == b\"hello\"\n\n\ndef test_dynamically_sized_struct_member_external_contract_call_2(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\n@external\ndef foo(s: String[6]) -> String[6]:\n    return s\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: uint256\n    y: String[6]\n\ninterface Foo:\n    def foo(b: String[6]) -> String[6]: nonpayable\n\n@external\ndef bar(addr: address) -> String[6]:\n    _X: X = X({x: 1, y: \"hello\"})\n    return Foo(addr).foo(_X.y)\n    \"\"\"\n\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.foo(\"hello\") == \"hello\"\n    assert c2.bar(c1.address) == \"hello\"\n\n\ndef test_list_external_contract_call(get_contract, get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\n@external\ndef array() -> int128[3]:\n    return [0, 0, 0]\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def array() -> int128[3]: view\n@external\ndef get_array(arg1: address) -> int128[3]:\n    return Foo(arg1).array()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c2.get_array(c.address) == [0, 0, 0]\n\n\ndef test_returndatasize_too_short(get_contract, assert_tx_failed):\n    contract_1 = \"\"\"\n@external\ndef bar(a: int128) -> int128:\n    return a\n\"\"\"\n    contract_2 = \"\"\"\ninterface Bar:\n    def bar(a: int128) -> (int128, int128): view\n\n@external\ndef foo(_addr: address):\n    Bar(_addr).bar(456)\n\"\"\"\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n    assert_tx_failed(lambda: c2.foo(c1.address))\n\n\ndef test_returndatasize_empty(get_contract, assert_tx_failed):\n    contract_1 = \"\"\"\n@external\ndef bar(a: int128):\n    pass\n\"\"\"\n    contract_2 = \"\"\"\ninterface Bar:\n    def bar(a: int128) -> int128: view\n\n@external\ndef foo(_addr: address) -> int128:\n    return Bar(_addr).bar(456)\n\"\"\"\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n    assert_tx_failed(lambda: c2.foo(c1.address))\n\n\ndef test_returndatasize_too_long(get_contract):\n    contract_1 = \"\"\"\n@external\ndef bar(a: int128) -> (int128, int128):\n    return a, 789\n\"\"\"\n    contract_2 = \"\"\"\ninterface Bar:\n    def bar(a: int128) -> int128: view\n\n@external\ndef foo(_addr: address) -> int128:\n    return Bar(_addr).bar(456)\n\"\"\"\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n\n    # excess return data does not raise\n    assert c2.foo(c1.address) == 456\n\n\ndef test_no_returndata(get_contract, assert_tx_failed):\n    contract_1 = \"\"\"\n@external\ndef bar(a: int128) -> int128:\n    return a\n\"\"\"\n    contract_2 = \"\"\"\ninterface Bar:\n    def bar(a: int128) -> int128: view\n\n@external\ndef foo(_addr: address, _addr2: address) -> int128:\n    x: int128 = Bar(_addr).bar(456)\n    # make two calls to confirm EVM behavior: RETURNDATA is always based on the last call\n    y: int128 = Bar(_addr2).bar(123)\n    return y\n\n\"\"\"\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n\n    assert c2.foo(c1.address, c1.address) == 123\n    assert_tx_failed(lambda: c2.foo(c1.address, \"0x1234567890123456789012345678901234567890\"))\n\n\ndef test_default_override(get_contract, assert_tx_failed):\n    bad_erc20_code = \"\"\"\n@external\ndef transfer(receiver: address, amount: uint256):\n    pass\n    \"\"\"\n\n    negative_transfer_code = \"\"\"\n@external\ndef transfer(receiver: address, amount: uint256) -> bool:\n    return False\n    \"\"\"\n\n    self_destructing_code = \"\"\"\n@external\ndef transfer(receiver: address, amount: uint256):\n    selfdestruct(msg.sender)\n    \"\"\"\n\n    code = \"\"\"\nfrom vyper.interfaces import ERC20\n@external\ndef safeTransfer(erc20: ERC20, receiver: address, amount: uint256) -> uint256:\n    assert erc20.transfer(receiver, amount, default_return_value=True)\n    return 7\n\n@external\ndef transferBorked(erc20: ERC20, receiver: address, amount: uint256):\n    assert erc20.transfer(receiver, amount)\n    \"\"\"\n    bad_erc20 = get_contract(bad_erc20_code)\n    c = get_contract(code)\n\n    # demonstrate transfer failing\n    assert_tx_failed(lambda: c.transferBorked(bad_erc20.address, c.address, 0))\n    # would fail without default_return_value\n    assert c.safeTransfer(bad_erc20.address, c.address, 0) == 7\n\n    # check that `default_return_value` does not stomp valid returndata.\n    negative_contract = get_contract(negative_transfer_code)\n    assert_tx_failed(lambda: c.safeTransfer(negative_contract.address, c.address, 0))\n\n    # default_return_value should fail on EOAs (addresses with no code)\n    random_address = \"0x0000000000000000000000000000000000001234\"\n    assert_tx_failed(lambda: c.safeTransfer(random_address, c.address, 1))\n\n    # in this case, the extcodesize check runs after the token contract\n    # selfdestructs. however, extcodesize still returns nonzero until\n    # later (i.e., after this transaction), so we still pass\n    # the extcodesize check.\n    self_destructing_contract = get_contract(self_destructing_code)\n    assert c.safeTransfer(self_destructing_contract.address, c.address, 0) == 7\n\n\ndef test_default_override2(get_contract, assert_tx_failed):\n    bad_code_1 = \"\"\"\n@external\ndef return_64_bytes() -> bool:\n    return True\n    \"\"\"\n\n    bad_code_2 = \"\"\"\n@external\ndef return_64_bytes():\n    pass\n    \"\"\"\n\n    code = \"\"\"\nstruct BoolPair:\n    x: bool\n    y: bool\ninterface Foo:\n    def return_64_bytes() -> BoolPair: nonpayable\n@external\ndef bar(foo: Foo):\n    t: BoolPair = foo.return_64_bytes(default_return_value=BoolPair({x: True, y:True}))\n    assert t.x and t.y\n    \"\"\"\n    bad_1 = get_contract(bad_code_1)\n    bad_2 = get_contract(bad_code_2)\n    c = get_contract(code)\n\n    # fails due to returndatasize being nonzero but also lt 64\n    assert_tx_failed(lambda: c.bar(bad_1.address))\n    c.bar(bad_2.address)\n", "from dataclasses import dataclass\n\nimport vyper.utils as util\nfrom vyper.address_space import MEMORY\nfrom vyper.codegen.abi_encoder import abi_encode\nfrom vyper.codegen.core import (\n    calculate_type_for_external_return,\n    check_assign,\n    check_external_call,\n    dummy_node_for_type,\n    make_setter,\n    needs_clamp,\n    unwrap_location,\n    wrap_value_for_external_return,\n)\nfrom vyper.codegen.ir_node import Encoding, IRnode\nfrom vyper.codegen.types import InterfaceType, TupleType, get_type_for_exact_size\nfrom vyper.codegen.types.convert import new_type_to_old_type\nfrom vyper.exceptions import TypeCheckFailure\nfrom vyper.semantics.types.function import StateMutability\n\n\n@dataclass\nclass _CallKwargs:\n    value: IRnode\n    gas: IRnode\n    skip_contract_check: bool\n    default_return_value: IRnode\n\n\ndef _pack_arguments(fn_type, args, context):\n    # abi encoding just treats all args as a big tuple\n    args_tuple_t = TupleType([x.typ for x in args])\n    args_as_tuple = IRnode.from_list([\"multi\"] + [x for x in args], typ=args_tuple_t)\n    args_abi_t = args_tuple_t.abi_type\n\n    # sanity typecheck - make sure the arguments can be assigned\n    dst_tuple_t = TupleType(\n        [new_type_to_old_type(typ) for typ in fn_type.arguments.values()][: len(args)]\n    )\n    check_assign(dummy_node_for_type(dst_tuple_t), args_as_tuple)\n\n    if fn_type.return_type is not None:\n        return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n        # we use the same buffer for args and returndata,\n        # so allocate enough space here for the returndata too.\n        buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\n    else:\n        buflen = args_abi_t.size_bound()\n\n    buflen += 32  # padding for the method id\n\n    buf_t = get_type_for_exact_size(buflen)\n    buf = context.new_internal_variable(buf_t)\n\n    args_ofst = buf + 28\n    args_len = args_abi_t.size_bound() + 4\n\n    abi_signature = fn_type.name + dst_tuple_t.abi_type.selector_name()\n\n    # layout:\n    # 32 bytes                 | args\n    # 0x..00<method_id_4bytes> | args\n    # the reason for the left padding is just so the alignment is easier.\n    # if we were only targeting constantinople, we could align\n    # to buf (and also keep code size small) by using\n    # (mstore buf (shl signature.method_id 224))\n    pack_args = [\"seq\"]\n    pack_args.append([\"mstore\", buf, util.abi_method_id(abi_signature)])\n\n    if len(args) != 0:\n        pack_args.append(abi_encode(buf + 32, args_as_tuple, context, bufsz=buflen))\n\n    return buf, pack_args, args_ofst, args_len\n\n\ndef _unpack_returndata(buf, fn_type, call_kwargs, contract_address, context, expr):\n    ast_return_t = fn_type.return_type\n\n    if ast_return_t is None:\n        return [\"pass\"], 0, 0\n\n    return_t = new_type_to_old_type(ast_return_t)\n\n    wrapped_return_t = calculate_type_for_external_return(return_t)\n\n    abi_return_t = wrapped_return_t.abi_type\n\n    min_return_size = abi_return_t.min_size()\n    max_return_size = abi_return_t.size_bound()\n    assert 0 < min_return_size <= max_return_size\n\n    ret_ofst = buf\n    ret_len = max_return_size\n\n    encoding = Encoding.ABI\n\n    buf = IRnode.from_list(\n        buf,\n        typ=wrapped_return_t,\n        location=MEMORY,\n        encoding=encoding,\n        annotation=f\"{expr.node_source_code} returndata buffer\",\n    )\n\n    unpacker = [\"seq\"]\n\n    # revert when returndatasize is not in bounds\n    # (except when return_override is provided.)\n    if not call_kwargs.skip_contract_check:\n        unpacker.append([\"assert\", [\"ge\", \"returndatasize\", min_return_size]])\n\n    assert isinstance(wrapped_return_t, TupleType)\n\n    # unpack strictly\n    if needs_clamp(wrapped_return_t, encoding):\n        return_buf = context.new_internal_variable(wrapped_return_t)\n        return_buf = IRnode.from_list(return_buf, typ=wrapped_return_t, location=MEMORY)\n\n        # note: make_setter does ABI decoding and clamps\n        unpacker.append(make_setter(return_buf, buf))\n    else:\n        return_buf = buf\n\n    if call_kwargs.default_return_value is not None:\n        # if returndatasize == 0:\n        #    copy return override to buf\n        # else:\n        #    do the other stuff\n\n        override_value = wrap_value_for_external_return(call_kwargs.default_return_value)\n        stomp_return_buffer = [\"seq\"]\n        if not call_kwargs.skip_contract_check:\n            stomp_return_buffer.append(_extcodesize_check(contract_address))\n        stomp_return_buffer.append(make_setter(return_buf, override_value))\n        unpacker = [\"if\", [\"eq\", \"returndatasize\", 0], stomp_return_buffer, unpacker]\n\n    unpacker = [\"seq\", unpacker, return_buf]\n\n    return unpacker, ret_ofst, ret_len\n\n\ndef _parse_kwargs(call_expr, context):\n    from vyper.codegen.expr import Expr  # TODO rethink this circular import\n\n    def _bool(x):\n        assert x.value in (0, 1), \"type checker missed this\"\n        return bool(x.value)\n\n    # note: codegen for kwarg values in AST order\n    call_kwargs = {kw.arg: Expr(kw.value, context).ir_node for kw in call_expr.keywords}\n\n    ret = _CallKwargs(\n        value=unwrap_location(call_kwargs.pop(\"value\", IRnode(0))),\n        gas=unwrap_location(call_kwargs.pop(\"gas\", IRnode(\"gas\"))),\n        skip_contract_check=_bool(call_kwargs.pop(\"skip_contract_check\", IRnode(0))),\n        default_return_value=call_kwargs.pop(\"default_return_value\", None),\n    )\n\n    if len(call_kwargs) != 0:\n        raise TypeCheckFailure(f\"Unexpected keyword arguments: {call_kwargs}\")\n\n    return ret\n\n\ndef _extcodesize_check(address):\n    return [\"assert\", [\"extcodesize\", address]]\n\n\ndef ir_for_external_call(call_expr, context):\n    from vyper.codegen.expr import Expr  # TODO rethink this circular import\n\n    contract_address = Expr.parse_value_expr(call_expr.func.value, context)\n    call_kwargs = _parse_kwargs(call_expr, context)\n    args_ir = [Expr(x, context).ir_node for x in call_expr.args]\n\n    assert isinstance(contract_address.typ, InterfaceType)\n\n    # expr.func._metadata[\"type\"].return_type is more accurate\n    # than fn_sig.return_type in the case of JSON interfaces.\n    fn_type = call_expr.func._metadata[\"type\"]\n\n    # sanity check\n    assert fn_type.min_arg_count <= len(args_ir) <= fn_type.max_arg_count\n\n    ret = [\"seq\"]\n\n    buf, arg_packer, args_ofst, args_len = _pack_arguments(fn_type, args_ir, context)\n\n    ret_unpacker, ret_ofst, ret_len = _unpack_returndata(\n        buf, fn_type, call_kwargs, contract_address, context, call_expr\n    )\n\n    ret += arg_packer\n\n    if fn_type.return_type is None and not call_kwargs.skip_contract_check:\n        # if we do not expect return data, check that a contract exists at the\n        # target address. we must perform this check BEFORE the call because\n        # the contract might selfdestruct. on the other hand we can omit this\n        # when we _do_ expect return data because we later check\n        # `returndatasize` (that check works even if the contract\n        # selfdestructs).\n        ret.append(_extcodesize_check(contract_address))\n\n    gas = call_kwargs.gas\n    value = call_kwargs.value\n\n    use_staticcall = fn_type.mutability in (StateMutability.VIEW, StateMutability.PURE)\n    if context.is_constant():\n        assert use_staticcall, \"typechecker missed this\"\n\n    if use_staticcall:\n        call_op = [\"staticcall\", gas, contract_address, args_ofst, args_len, buf, ret_len]\n    else:\n        call_op = [\"call\", gas, contract_address, value, args_ofst, args_len, buf, ret_len]\n\n    ret.append(check_external_call(call_op))\n\n    return_t = None\n    if fn_type.return_type is not None:\n        return_t = new_type_to_old_type(fn_type.return_type)\n        ret.append(ret_unpacker)\n\n    return IRnode.from_list(ret, typ=return_t, location=MEMORY)\n"], "fixing_code": ["from decimal import Decimal\n\nimport pytest\n\nfrom vyper.exceptions import (\n    ArgumentException,\n    InvalidType,\n    StateAccessViolation,\n    StructureException,\n    UndeclaredDefinition,\n    UnknownType,\n)\n\n\ndef test_external_contract_calls(get_contract, get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\n@external\ndef foo(arg1: int128) -> int128:\n    return arg1\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n        def foo(arg1: int128) -> int128: view\n\n@external\ndef bar(arg1: address, arg2: int128) -> int128:\n    return Foo(arg1).foo(arg2)\n    \"\"\"\n    c2 = get_contract(contract_2)\n\n    assert c2.bar(c.address, 1) == 1\n    print(\"Successfully executed an external contract call\")\n\n\ndef test_complicated_external_contract_calls(get_contract, get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nlucky: public(int128)\n\n@external\ndef __init__(_lucky: int128):\n    self.lucky = _lucky\n\n@external\ndef foo() -> int128:\n    return self.lucky\n\n@external\ndef array() -> Bytes[3]:\n    return b'dog'\n    \"\"\"\n\n    lucky_number = 7\n    c = get_contract_with_gas_estimation(contract_1, *[lucky_number])\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> int128: nonpayable\n    def array() -> Bytes[3]: view\n\n@external\ndef bar(arg1: address) -> int128:\n    return Foo(arg1).foo()\n    \"\"\"\n    c2 = get_contract(contract_2)\n\n    assert c2.bar(c.address) == lucky_number\n    print(\"Successfully executed a complicated external contract call\")\n\n\n@pytest.mark.parametrize(\"length\", [3, 32, 33, 64])\ndef test_external_contract_calls_with_bytes(get_contract, length):\n    contract_1 = f\"\"\"\n@external\ndef array() -> Bytes[{length}]:\n    return b'dog'\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def array() -> Bytes[3]: view\n\n@external\ndef get_array(arg1: address) -> Bytes[3]:\n    return Foo(arg1).array()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c2.get_array(c.address) == b\"dog\"\n\n\ndef test_bytes_too_long(get_contract, assert_tx_failed):\n    contract_1 = \"\"\"\n@external\ndef array() -> Bytes[4]:\n    return b'doge'\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def array() -> Bytes[3]: view\n\n@external\ndef get_array(arg1: address) -> Bytes[3]:\n    return Foo(arg1).array()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert_tx_failed(lambda: c2.get_array(c.address))\n\n\n@pytest.mark.parametrize(\n    \"revert_string\", [\"Mayday, mayday!\", \"A very long revert string\" + \".\" * 512]\n)\ndef test_revert_propagation(get_contract, assert_tx_failed, revert_string):\n    raiser = f\"\"\"\n@external\ndef run():\n    raise \"{revert_string}\"\n    \"\"\"\n    caller = \"\"\"\ninterface Raises:\n    def run(): pure\n\n@external\ndef run(raiser: address):\n    Raises(raiser).run()\n    \"\"\"\n    c1 = get_contract(raiser)\n    c2 = get_contract(caller)\n    assert_tx_failed(lambda: c2.run(c1.address), exc_text=revert_string)\n\n\n@pytest.mark.parametrize(\"a,b\", [(3, 3), (4, 3), (3, 4), (32, 32), (33, 33), (64, 64)])\n@pytest.mark.parametrize(\"actual\", [3, 32, 64])\ndef test_tuple_with_bytes(get_contract, a, b, actual):\n    contract_1 = f\"\"\"\n@external\ndef array() -> (Bytes[{actual}], int128, Bytes[{actual}]):\n    return b'dog', 255, b'cat'\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = f\"\"\"\ninterface Foo:\n    def array() -> (Bytes[{a}], int128, Bytes[{b}]): view\n\n@external\ndef get_array(arg1: address) -> (Bytes[{a}], int128, Bytes[{b}]):\n    a: Bytes[{a}] = b\"\"\n    b: int128 = 0\n    c: Bytes[{b}] = b\"\"\n    a, b, c = Foo(arg1).array()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.array() == [b\"dog\", 255, b\"cat\"]\n    assert c2.get_array(c.address) == [b\"dog\", 255, b\"cat\"]\n\n\n@pytest.mark.parametrize(\"a,b\", [(18, 7), (18, 18), (19, 6), (64, 6), (7, 19)])\n@pytest.mark.parametrize(\"c,d\", [(19, 7), (64, 64)])\ndef test_tuple_with_bytes_too_long(get_contract, assert_tx_failed, a, c, b, d):\n    contract_1 = f\"\"\"\n@external\ndef array() -> (Bytes[{c}], int128, Bytes[{d}]):\n    return b'nineteen characters', 255, b'seven!!'\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = f\"\"\"\ninterface Foo:\n    def array() -> (Bytes[{a}], int128, Bytes[{b}]): view\n\n@external\ndef get_array(arg1: address) -> (Bytes[{a}], int128, Bytes[{b}]):\n    a: Bytes[{a}] = b\"\"\n    b: int128 = 0\n    c: Bytes[{b}] = b\"\"\n    a, b, c = Foo(arg1).array()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.array() == [b\"nineteen characters\", 255, b\"seven!!\"]\n    assert_tx_failed(lambda: c2.get_array(c.address))\n\n\ndef test_tuple_with_bytes_too_long_two(get_contract, assert_tx_failed):\n    contract_1 = \"\"\"\n@external\ndef array() -> (Bytes[30], int128, Bytes[30]):\n    return b'nineteen characters', 255, b'seven!!'\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def array() -> (Bytes[30], int128, Bytes[3]): view\n\n@external\ndef get_array(arg1: address) -> (Bytes[30], int128, Bytes[3]):\n    a: Bytes[30] = b\"\"\n    b: int128 = 0\n    c: Bytes[3] = b\"\"\n    a, b, c = Foo(arg1).array()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.array() == [b\"nineteen characters\", 255, b\"seven!!\"]\n    assert_tx_failed(lambda: c2.get_array(c.address))\n\n\n@pytest.mark.parametrize(\"length\", [8, 256])\ndef test_external_contract_calls_with_uint8(get_contract, length):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> uint{length}:\n    return 255\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> uint8: view\n\n@external\ndef bar(arg1: address) -> uint8:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c2.bar(c.address) == 255\n\n\ndef test_uint8_too_long(get_contract, assert_tx_failed):\n    contract_1 = \"\"\"\n@external\ndef foo() -> uint256:\n    return 2**255\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> uint8: view\n\n@external\ndef bar(arg1: address) -> uint8:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"a,b\", [(8, 8), (8, 256), (256, 8), (256, 256)])\n@pytest.mark.parametrize(\"actual\", [8, 256])\ndef test_tuple_with_uint8(get_contract, a, b, actual):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> (uint{actual}, Bytes[3], uint{actual}):\n    return 255, b'dog', 255\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = f\"\"\"\ninterface Foo:\n    def foo() -> (uint{a}, Bytes[3], uint{b}): view\n\n@external\ndef bar(arg1: address) -> (uint{a}, Bytes[3], uint{b}):\n    a: uint{a} = 0\n    b: Bytes[3] = b\"\"\n    c: uint{b} = 0\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [255, b\"dog\", 255]\n    assert c2.bar(c.address) == [255, b\"dog\", 255]\n\n\n@pytest.mark.parametrize(\"a,b\", [(8, 256), (256, 8), (256, 256)])\ndef test_tuple_with_uint8_too_long(get_contract, assert_tx_failed, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> (uint{a}, Bytes[3], uint{b}):\n    return {(2**a)-1}, b'dog', {(2**b)-1}\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> (uint8, Bytes[3], uint8): view\n\n@external\ndef bar(arg1: address) -> (uint8, Bytes[3], uint8):\n    a: uint8 = 0\n    b: Bytes[3] = b\"\"\n    c: uint8 = 0\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [int(f\"{(2**a)-1}\"), b\"dog\", int(f\"{(2**b)-1}\")]\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"a,b\", [(8, 256), (256, 8)])\ndef test_tuple_with_uint8_too_long_two(get_contract, assert_tx_failed, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> (uint{b}, Bytes[3], uint{a}):\n    return {(2**b)-1}, b'dog', {(2**a)-1}\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = f\"\"\"\ninterface Foo:\n    def foo() -> (uint{a}, Bytes[3], uint{b}): view\n\n@external\ndef bar(arg1: address) -> (uint{a}, Bytes[3], uint{b}):\n    a: uint{a} = 0\n    b: Bytes[3] = b\"\"\n    c: uint{b} = 0\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [int(f\"{(2**b)-1}\"), b\"dog\", int(f\"{(2**a)-1}\")]\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"length\", [128, 256])\ndef test_external_contract_calls_with_int128(get_contract, length):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> int{length}:\n    return 1\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> int128: view\n\n@external\ndef bar(arg1: address) -> int128:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c2.bar(c.address) == 1\n\n\ndef test_int128_too_long(get_contract, assert_tx_failed):\n    contract_1 = \"\"\"\n@external\ndef foo() -> int256:\n    return (2**255)-1\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> int128: view\n\n@external\ndef bar(arg1: address) -> int128:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"a,b\", [(128, 128), (128, 256), (256, 128), (256, 256)])\n@pytest.mark.parametrize(\"actual\", [128, 256])\ndef test_tuple_with_int128(get_contract, a, b, actual):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> (int{actual}, Bytes[3], int{actual}):\n    return 255, b'dog', 255\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = f\"\"\"\ninterface Foo:\n    def foo() -> (int{a}, Bytes[3], int{b}): view\n\n@external\ndef bar(arg1: address) -> (int{a}, Bytes[3], int{b}):\n    a: int{a} = 0\n    b: Bytes[3] = b\"\"\n    c: int{b} = 0\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [255, b\"dog\", 255]\n    assert c2.bar(c.address) == [255, b\"dog\", 255]\n\n\n@pytest.mark.parametrize(\"a,b\", [(128, 256), (256, 128), (256, 256)])\ndef test_tuple_with_int128_too_long(get_contract, assert_tx_failed, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> (int{a}, Bytes[3], int{b}):\n    return {(2**(a-1))-1}, b'dog', {(2**(b-1))-1}\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> (int128, Bytes[3], int128): view\n\n@external\ndef bar(arg1: address) -> (int128, Bytes[3], int128):\n    a: int128 = 0\n    b: Bytes[3] = b\"\"\n    c: int128 = 0\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [int(f\"{(2**(a-1))-1}\"), b\"dog\", int(f\"{(2**(b-1))-1}\")]\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"a,b\", [(128, 256), (256, 128)])\ndef test_tuple_with_int128_too_long_two(get_contract, assert_tx_failed, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> (int{b}, Bytes[3], int{a}):\n    return {(2**(b-1))-1}, b'dog', {(2**(a-1))-1}\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = f\"\"\"\ninterface Foo:\n    def foo() -> (int{a}, Bytes[3], int{b}): view\n\n@external\ndef bar(arg1: address) -> (int{a}, Bytes[3], int{b}):\n    a: int{a} = 0\n    b: Bytes[3] = b\"\"\n    c: int{b} = 0\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [int(f\"{(2**(b-1))-1}\"), b\"dog\", int(f\"{(2**(a-1))-1}\")]\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"type\", [\"uint8\", \"uint256\", \"int128\", \"int256\"])\ndef test_external_contract_calls_with_decimal(get_contract, type):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> {type}:\n    return 1\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> decimal: view\n\n@external\ndef bar(arg1: address) -> decimal:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c2.bar(c.address) == Decimal(\"1e-10\")\n\n\ndef test_decimal_too_long(get_contract, assert_tx_failed):\n    contract_1 = \"\"\"\n@external\ndef foo() -> uint256:\n    return 2**255\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> decimal: view\n\n@external\ndef bar(arg1: address) -> decimal:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"a\", [\"uint8\", \"uint256\", \"int128\", \"int256\"])\n@pytest.mark.parametrize(\"b\", [\"uint8\", \"uint256\", \"int128\", \"int256\"])\ndef test_tuple_with_decimal(get_contract, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> ({a}, Bytes[3], {b}):\n    return 0, b'dog', 1\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> (decimal, Bytes[3], decimal): view\n\n@external\ndef bar(arg1: address) -> (decimal, Bytes[3], decimal):\n    a: decimal = 0.0\n    b: Bytes[3] = b\"\"\n    c: decimal = 0.0\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [0, b\"dog\", 1]\n    result = c2.bar(c.address)\n    assert result == [Decimal(\"0.0\"), b\"dog\", Decimal(\"1e-10\")]\n\n\n@pytest.mark.parametrize(\"a,b\", [(8, 256), (256, 8), (256, 256)])\ndef test_tuple_with_decimal_too_long(get_contract, assert_tx_failed, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> (uint{a}, Bytes[3], uint{b}):\n    return {2**(a-1)}, b'dog', {2**(b-1)}\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> (decimal, Bytes[3], decimal): view\n\n@external\ndef bar(arg1: address) -> (decimal, Bytes[3], decimal):\n    a: decimal = 0.0\n    b: Bytes[3] = b\"\"\n    c: decimal = 0.0\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [2 ** (a - 1), b\"dog\", 2 ** (b - 1)]\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"type\", [\"uint8\", \"uint256\", \"int128\", \"int256\"])\ndef test_external_contract_calls_with_bool(get_contract, type):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> {type}:\n    return 1\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> bool: view\n\n@external\ndef bar(arg1: address) -> bool:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c2.bar(c.address) is True\n\n\ndef test_bool_too_long(get_contract, assert_tx_failed):\n    contract_1 = \"\"\"\n@external\ndef foo() -> uint256:\n    return 2\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> bool: view\n\n@external\ndef bar(arg1: address) -> bool:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"a\", [\"uint8\", \"uint256\", \"int128\", \"int256\"])\n@pytest.mark.parametrize(\"b\", [\"uint8\", \"uint256\", \"int128\", \"int256\"])\ndef test_tuple_with_bool(get_contract, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> ({a}, Bytes[3], {b}):\n    return 1, b'dog', 0\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> (bool, Bytes[3], bool): view\n\n@external\ndef bar(arg1: address) -> (bool, Bytes[3], bool):\n    a: bool = False\n    b: Bytes[3] = b\"\"\n    c: bool = False\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [1, b\"dog\", 0]\n    assert c2.bar(c.address) == [True, b\"dog\", False]\n\n\n@pytest.mark.parametrize(\"a\", [\"uint8\", \"uint256\", \"int128\", \"int256\"])\n@pytest.mark.parametrize(\"b\", [\"uint8\", \"uint256\", \"int128\", \"int256\"])\ndef test_tuple_with_bool_too_long(get_contract, assert_tx_failed, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> ({a}, Bytes[3], {b}):\n    return 1, b'dog', 2\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> (bool, Bytes[3], bool): view\n\n@external\ndef bar(arg1: address) -> (bool, Bytes[3], bool):\n    a: bool = False\n    b: Bytes[3] = b\"\"\n    c: bool = False\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [1, b\"dog\", 2]\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"type\", [\"uint8\", \"int128\", \"uint256\", \"int256\"])\ndef test_external_contract_calls_with_address(get_contract, type):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> {type}:\n    return 1\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> address: view\n\n@external\ndef bar(arg1: address) -> address:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c2.bar(c.address) == \"0x0000000000000000000000000000000000000001\"\n\n\n@pytest.mark.parametrize(\"type\", [\"uint256\", \"int256\"])\ndef test_external_contract_calls_with_address_two(get_contract, type):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> {type}:\n    return (2**160)-1\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> address: view\n\n@external\ndef bar(arg1: address) -> address:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c2.bar(c.address).lower() == \"0xffffffffffffffffffffffffffffffffffffffff\"\n\n\n@pytest.mark.parametrize(\"type\", [\"uint256\", \"int256\"])\ndef test_address_too_long(get_contract, assert_tx_failed, type):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> {type}:\n    return 2**160\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> address: view\n\n@external\ndef bar(arg1: address) -> address:\n    return Foo(arg1).foo()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\n@pytest.mark.parametrize(\"a\", [\"uint8\", \"int128\", \"uint256\", \"int256\"])\n@pytest.mark.parametrize(\"b\", [\"uint8\", \"int128\", \"uint256\", \"int256\"])\ndef test_tuple_with_address(get_contract, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> ({a}, Bytes[3], {b}):\n    return 16, b'dog', 1\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> (address, Bytes[3], address): view\n\n@external\ndef bar(arg1: address) -> (address, Bytes[3], address):\n    a: address = ZERO_ADDRESS\n    b: Bytes[3] = b\"\"\n    c: address = ZERO_ADDRESS\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [16, b\"dog\", 1]\n    assert c2.bar(c.address) == [\n        \"0x0000000000000000000000000000000000000010\",\n        b\"dog\",\n        \"0x0000000000000000000000000000000000000001\",\n    ]\n\n\n@pytest.mark.parametrize(\"a\", [\"uint256\", \"int256\"])\n@pytest.mark.parametrize(\"b\", [\"uint256\", \"int256\"])\ndef test_tuple_with_address_two(get_contract, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> ({a}, Bytes[3], {b}):\n    return (2**160)-1, b'dog', (2**160)-2\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> (address, Bytes[3], address): view\n\n@external\ndef bar(arg1: address) -> (address, Bytes[3], address):\n    a: address = ZERO_ADDRESS\n    b: Bytes[3] = b\"\"\n    c: address = ZERO_ADDRESS\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [(2 ** 160) - 1, b\"dog\", (2 ** 160) - 2]\n    result = c2.bar(c.address)\n    assert len(result) == 3\n    assert result[0].lower() == \"0xffffffffffffffffffffffffffffffffffffffff\"\n    assert result[1] == b\"dog\"\n    assert result[2].lower() == \"0xfffffffffffffffffffffffffffffffffffffffe\"\n\n\n@pytest.mark.parametrize(\"a\", [\"uint256\", \"int256\"])\n@pytest.mark.parametrize(\"b\", [\"uint256\", \"int256\"])\ndef test_tuple_with_address_too_long(get_contract, assert_tx_failed, a, b):\n    contract_1 = f\"\"\"\n@external\ndef foo() -> ({a}, Bytes[3], {b}):\n    return (2**160)-1, b'dog', 2**160\n    \"\"\"\n\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo() -> (address, Bytes[3], address): view\n\n@external\ndef bar(arg1: address) -> (address, Bytes[3], address):\n    a: address = ZERO_ADDRESS\n    b: Bytes[3] = b\"\"\n    c: address = ZERO_ADDRESS\n    a, b, c = Foo(arg1).foo()\n    return a, b, c\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c.foo() == [(2 ** 160) - 1, b\"dog\", 2 ** 160]\n    assert_tx_failed(lambda: c2.bar(c.address))\n\n\ndef test_external_contract_call_state_change(get_contract):\n    contract_1 = \"\"\"\nlucky: public(int128)\n\n@external\ndef set_lucky(_lucky: int128):\n    self.lucky = _lucky\n    \"\"\"\n\n    lucky_number = 7\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def set_lucky(_lucky: int128): nonpayable\n\n@external\ndef set_lucky(arg1: address, arg2: int128):\n    Foo(arg1).set_lucky(arg2)\n    \"\"\"\n    c2 = get_contract(contract_2)\n\n    assert c.lucky() == 0\n    c2.set_lucky(c.address, lucky_number, transact={})\n    assert c.lucky() == lucky_number\n    print(\"Successfully executed an external contract call state change\")\n\n\ndef test_constant_external_contract_call_cannot_change_state(\n    assert_compile_failed, get_contract_with_gas_estimation\n):\n    c = \"\"\"\ninterface Foo:\n    def set_lucky(_lucky: int128) -> int128: nonpayable\n\n@external\n@view\ndef set_lucky_expr(arg1: address, arg2: int128):\n    Foo(arg1).set_lucky(arg2)\n\n@external\n@view\ndef set_lucky_stmt(arg1: address, arg2: int128) -> int128:\n    return Foo(arg1).set_lucky(arg2)\n    \"\"\"\n    assert_compile_failed(lambda: get_contract_with_gas_estimation(c), StateAccessViolation)\n\n    print(\"Successfully blocked an external contract call from a constant function\")\n\n\ndef test_external_contract_can_be_changed_based_on_address(get_contract):\n    contract_1 = \"\"\"\nlucky: public(int128)\n\n@external\ndef set_lucky(_lucky: int128):\n    self.lucky = _lucky\n    \"\"\"\n\n    lucky_number_1 = 7\n    c = get_contract(contract_1)\n\n    contract_2 = \"\"\"\nlucky: public(int128)\n\n@external\ndef set_lucky(_lucky: int128) -> int128:\n    self.lucky = _lucky\n    return self.lucky\n    \"\"\"\n\n    lucky_number_2 = 3\n    c2 = get_contract(contract_2)\n\n    contract_3 = \"\"\"\ninterface Foo:\n    def set_lucky(_lucky: int128): nonpayable\n\n@external\ndef set_lucky(arg1: address, arg2: int128):\n    Foo(arg1).set_lucky(arg2)\n    \"\"\"\n    c3 = get_contract(contract_3)\n\n    c3.set_lucky(c.address, lucky_number_1, transact={})\n    c3.set_lucky(c2.address, lucky_number_2, transact={})\n    assert c.lucky() == lucky_number_1\n    assert c2.lucky() == lucky_number_2\n    print(\n        \"Successfully executed multiple external contract calls to different \"\n        \"contracts based on address\"\n    )\n\n\ndef test_external_contract_calls_with_public_globals(get_contract):\n    contract_1 = \"\"\"\nlucky: public(int128)\n\n@external\ndef __init__(_lucky: int128):\n    self.lucky = _lucky\n    \"\"\"\n\n    lucky_number = 7\n    c = get_contract(contract_1, *[lucky_number])\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def lucky() -> int128: view\n\n@external\ndef bar(arg1: address) -> int128:\n    return Foo(arg1).lucky()\n    \"\"\"\n    c2 = get_contract(contract_2)\n\n    assert c2.bar(c.address) == lucky_number\n    print(\"Successfully executed an external contract call with public globals\")\n\n\ndef test_external_contract_calls_with_multiple_contracts(get_contract):\n    contract_1 = \"\"\"\nlucky: public(int128)\n\n@external\ndef __init__(_lucky: int128):\n    self.lucky = _lucky\n    \"\"\"\n\n    lucky_number = 7\n    c = get_contract(contract_1, *[lucky_number])\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def lucky() -> int128: view\n\nmagic_number: public(int128)\n\n@external\ndef __init__(arg1: address):\n    self.magic_number = Foo(arg1).lucky()\n    \"\"\"\n\n    c2 = get_contract(contract_2, *[c.address])\n    contract_3 = \"\"\"\ninterface Bar:\n    def magic_number() -> int128: view\n\nbest_number: public(int128)\n\n@external\ndef __init__(arg1: address):\n    self.best_number = Bar(arg1).magic_number()\n    \"\"\"\n\n    c3 = get_contract(contract_3, *[c2.address])\n    assert c3.best_number() == lucky_number\n    print(\"Successfully executed a multiple external contract calls\")\n\n\ndef test_external_contract_calls_with_default_value(get_contract):\n    contract_1 = \"\"\"\n@external\ndef foo(arg1: uint256=1) -> uint256:\n    return arg1\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo(arg1: uint256=1) -> uint256: nonpayable\n\n@external\ndef bar(addr: address) -> uint256:\n    return Foo(addr).foo()\n    \"\"\"\n\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n\n    assert c1.foo() == 1\n    assert c1.foo(2) == 2\n    assert c2.bar(c1.address) == 1\n\n\ndef test_external_contract_calls_with_default_value_two(get_contract):\n    contract_1 = \"\"\"\n@external\ndef foo(arg1: uint256, arg2: uint256=1) -> uint256:\n    return arg1 + arg2\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def foo(arg1: uint256, arg2: uint256=1) -> uint256: nonpayable\n\n@external\ndef bar(addr: address, arg1: uint256) -> uint256:\n    return Foo(addr).foo(arg1)\n    \"\"\"\n\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n\n    assert c1.foo(2) == 3\n    assert c1.foo(2, 3) == 5\n    assert c2.bar(c1.address, 2) == 3\n\n\ndef test_invalid_external_contract_call_to_the_same_contract(get_contract):\n    contract_1 = \"\"\"\n@external\ndef bar() -> int128:\n    return 1\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Bar:\n    def bar() -> int128: view\n\n@external\ndef bar() -> int128:\n    return 1\n\n@external\ndef _stmt(x: address):\n    Bar(x).bar()\n\n@external\ndef _expr(x: address) -> int128:\n    return Bar(x).bar()\n    \"\"\"\n\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n\n    c2._stmt(c1.address)\n    c2._stmt(c2.address)\n\n    assert c2._expr(c1.address) == 1\n    assert c2._expr(c2.address) == 1\n\n\ndef test_invalid_nonexistent_contract_call(w3, assert_tx_failed, get_contract):\n    contract_1 = \"\"\"\n@external\ndef bar() -> int128:\n    return 1\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Bar:\n    def bar() -> int128: view\n\n@external\ndef foo(x: address) -> int128:\n    return Bar(x).bar()\n    \"\"\"\n\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n\n    assert c2.foo(c1.address) == 1\n    assert_tx_failed(lambda: c2.foo(w3.eth.accounts[0]))\n    assert_tx_failed(lambda: c2.foo(w3.eth.accounts[3]))\n\n\ndef test_invalid_contract_reference_declaration(assert_tx_failed, get_contract):\n    contract = \"\"\"\ninterface Bar:\n    get_magic_number: 1\n\nbest_number: public(int128)\n\n@external\ndef __init__():\n    pass\n\"\"\"\n    assert_tx_failed(lambda: get_contract(contract), exception=StructureException)\n\n\ndef test_invalid_contract_reference_call(assert_tx_failed, get_contract):\n    contract = \"\"\"\n@external\ndef bar(arg1: address, arg2: int128) -> int128:\n    return Foo(arg1).foo(arg2)\n\"\"\"\n    assert_tx_failed(lambda: get_contract(contract), exception=UndeclaredDefinition)\n\n\ndef test_invalid_contract_reference_return_type(assert_tx_failed, get_contract):\n    contract = \"\"\"\ninterface Foo:\n    def foo(arg2: int128) -> invalid: view\n\n@external\ndef bar(arg1: address, arg2: int128) -> int128:\n    return Foo(arg1).foo(arg2)\n\"\"\"\n    assert_tx_failed(lambda: get_contract(contract), exception=UnknownType)\n\n\ndef test_external_contract_call_declaration_expr(get_contract):\n    contract_1 = \"\"\"\n@external\ndef bar() -> int128:\n    return 1\n\"\"\"\n\n    contract_2 = \"\"\"\ninterface Bar:\n    def bar() -> int128: view\n\nbar_contract: Bar\n\n@external\ndef foo(contract_address: address) -> int128:\n    self.bar_contract = Bar(contract_address)\n    return self.bar_contract.bar()\n    \"\"\"\n\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n    assert c2.foo(c1.address) == 1\n\n\ndef test_external_contract_call_declaration_stmt(get_contract):\n    contract_1 = \"\"\"\nlucky: int128\n\n@external\ndef set_lucky(_lucky: int128):\n    self.lucky = _lucky\n\n@external\ndef get_lucky() -> int128:\n    return self.lucky\n\"\"\"\n\n    contract_2 = \"\"\"\ninterface Bar:\n    def set_lucky(arg1: int128): nonpayable\n    def get_lucky() -> int128: view\n\nbar_contract: Bar\n\n@external\ndef set_lucky(contract_address: address):\n    self.bar_contract = Bar(contract_address)\n    self.bar_contract.set_lucky(1)\n\n@external\ndef get_lucky(contract_address: address) -> int128:\n    self.bar_contract = Bar(contract_address)\n    return self.bar_contract.get_lucky()\n    \"\"\"\n\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n    assert c1.get_lucky() == 0\n    assert c2.get_lucky(c1.address) == 0\n    c1.set_lucky(6, transact={})\n    assert c1.get_lucky() == 6\n    assert c2.get_lucky(c1.address) == 6\n    c2.set_lucky(c1.address, transact={})\n    assert c1.get_lucky() == 1\n    assert c2.get_lucky(c1.address) == 1\n\n\ndef test_complex_external_contract_call_declaration(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\n@external\ndef get_lucky() -> int128:\n    return 1\n\"\"\"\n\n    contract_2 = \"\"\"\n@external\ndef get_lucky() -> int128:\n    return 2\n\"\"\"\n\n    contract_3 = \"\"\"\ninterface Bar:\n    def set_lucky(arg1: int128): nonpayable\n    def get_lucky() -> int128: view\n\nbar_contract: Bar\n\n@external\ndef set_contract(contract_address: address):\n    self.bar_contract = Bar(contract_address)\n\n@external\ndef get_lucky() -> int128:\n    return self.bar_contract.get_lucky()\n\"\"\"\n\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n    c3 = get_contract_with_gas_estimation(contract_3)\n    assert c1.get_lucky() == 1\n    assert c2.get_lucky() == 2\n    c3.set_contract(c1.address, transact={})\n    assert c3.get_lucky() == 1\n    c3.set_contract(c2.address, transact={})\n    assert c3.get_lucky() == 2\n\n\ndef test_address_can_returned_from_contract_type(get_contract):\n    contract_1 = \"\"\"\n@external\ndef bar() -> int128:\n    return 1\n\"\"\"\n    contract_2 = \"\"\"\ninterface Bar:\n    def bar() -> int128: view\n\nbar_contract: public(Bar)\n\n@external\ndef foo(contract_address: address):\n    self.bar_contract = Bar(contract_address)\n\n@external\ndef get_bar() -> int128:\n    return self.bar_contract.bar()\n\"\"\"\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n    c2.foo(c1.address, transact={})\n    assert c2.bar_contract() == c1.address\n    assert c2.get_bar() == 1\n\n\ndef test_invalid_external_contract_call_declaration_1(assert_compile_failed, get_contract):\n    contract_1 = \"\"\"\ninterface Bar:\n    def bar() -> int128: view\n\nbar_contract: Bar\n\n@external\ndef foo(contract_address: contract(Boo)) -> int128:\n    self.bar_contract = Bar(contract_address)\n    return self.bar_contract.bar()\n    \"\"\"\n\n    assert_compile_failed(lambda: get_contract(contract_1), UnknownType)\n\n\ndef test_invalid_external_contract_call_declaration_2(assert_compile_failed, get_contract):\n    contract_1 = \"\"\"\ninterface Bar:\n    def bar() -> int128: view\n\nbar_contract: Boo\n\n@external\ndef foo(contract_address: address) -> int128:\n    self.bar_contract = Bar(contract_address)\n    return self.bar_contract.bar()\n    \"\"\"\n\n    assert_compile_failed(lambda: get_contract(contract_1), UnknownType)\n\n\ndef test_external_with_payable_value(w3, get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\n@payable\n@external\ndef get_lucky() -> int128:\n    return 1\n\n@external\ndef get_balance() -> uint256:\n    return self.balance\n\"\"\"\n\n    contract_2 = \"\"\"\ninterface Bar:\n    def get_lucky() -> int128: payable\n\nbar_contract: Bar\n\n@external\ndef set_contract(contract_address: address):\n    self.bar_contract = Bar(contract_address)\n\n@payable\n@external\ndef get_lucky(amount_to_send: uint256) -> int128:\n    if amount_to_send != 0:\n        return self.bar_contract.get_lucky(value=amount_to_send)\n    else: # send it all\n        return self.bar_contract.get_lucky(value=msg.value)\n\"\"\"\n\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    # Set address.\n    assert c1.get_lucky() == 1\n    assert c1.get_balance() == 0\n\n    c2.set_contract(c1.address, transact={})\n\n    # Send some eth\n    assert c2.get_lucky(0, call={\"value\": 500}) == 1\n    c2.get_lucky(0, transact={\"value\": 500})\n    # Contract 1 received money.\n    assert c1.get_balance() == 500\n    assert w3.eth.get_balance(c1.address) == 500\n    assert w3.eth.get_balance(c2.address) == 0\n\n    # Send subset of amount\n    assert c2.get_lucky(250, call={\"value\": 500}) == 1\n    c2.get_lucky(250, transact={\"value\": 500})\n\n    # Contract 1 received more money.\n    assert c1.get_balance() == 750\n    assert w3.eth.get_balance(c1.address) == 750\n    assert w3.eth.get_balance(c2.address) == 250\n\n\ndef test_external_call_with_gas(assert_tx_failed, get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\n@external\ndef get_lucky() -> int128:\n    return 656598\n\"\"\"\n\n    contract_2 = \"\"\"\ninterface Bar:\n    def set_lucky(arg1: int128): nonpayable\n    def get_lucky() -> int128: view\n\nbar_contract: Bar\n\n@external\ndef set_contract(contract_address: address):\n    self.bar_contract = Bar(contract_address)\n\n@external\ndef get_lucky(gas_amount: uint256) -> int128:\n    return self.bar_contract.get_lucky(gas=gas_amount)\n\"\"\"\n\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n    c2.set_contract(c1.address, transact={})\n\n    assert c2.get_lucky(1000) == 656598\n    assert_tx_failed(lambda: c2.get_lucky(50))  # too little gas.\n\n\ndef test_skip_contract_check(get_contract_with_gas_estimation):\n    contract_2 = \"\"\"\n@external\n@view\ndef bar():\n    pass\n    \"\"\"\n    contract_1 = \"\"\"\ninterface Bar:\n    def bar() -> uint256: view\n    def baz(): view\n\n@external\ndef call_bar(addr: address):\n    # would fail if returndatasize check were on\n    x: uint256 = Bar(addr).bar(skip_contract_check=True)\n@external\ndef call_baz():\n    # some address with no code\n    addr: address = 0x1234567890AbcdEF1234567890aBcdef12345678\n    # would fail if extcodesize check were on\n    Bar(addr).baz(skip_contract_check=True)\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n    c1.call_bar(c2.address)\n    c1.call_baz()\n\n\ndef test_invalid_keyword_on_call(assert_compile_failed, get_contract_with_gas_estimation):\n\n    contract_1 = \"\"\"\ninterface Bar:\n    def set_lucky(arg1: int128): nonpayable\n    def get_lucky() -> int128: view\n\nbar_contract: Bar\n\n@external\ndef get_lucky(amount_to_send: int128) -> int128:\n    return self.bar_contract.get_lucky(gass=1)\n    \"\"\"\n\n    assert_compile_failed(lambda: get_contract_with_gas_estimation(contract_1), ArgumentException)\n\n\ndef test_invalid_contract_declaration(assert_compile_failed, get_contract_with_gas_estimation):\n\n    contract_1 = \"\"\"\ninterface Bar:\n    def set_lucky(arg1: int128): nonpayable\n\nbar_contract: Barr\n\n    \"\"\"\n\n    assert_compile_failed(lambda: get_contract_with_gas_estimation(contract_1), UnknownType)\n\n\nFAILING_CONTRACTS_STRUCTURE_EXCEPTION = [\n    \"\"\"\n# wrong arg count\ninterface Bar:\n    def bar(arg1: int128) -> bool: view\n\n@external\ndef foo(a: address):\n    Bar(a).bar(1, 2)\n    \"\"\",\n    \"\"\"\n# expected args, none given\ninterface Bar:\n    def bar(arg1: int128) -> bool: view\n\n@external\ndef foo(a: address):\n    Bar(a).bar()\n    \"\"\",\n    \"\"\"\n# expected no args, args given\ninterface Bar:\n    def bar() -> bool: view\n\n@external\ndef foo(a: address):\n    Bar(a).bar(1)\n    \"\"\",\n    \"\"\"\ninterface Bar:\n    def bar(x: uint256, y: uint256) -> uint256: view\n\n@external\ndef foo(a: address, x: uint256, y: uint256):\n    Bar(a).bar(x, y=y)\n    \"\"\",\n]\n\n\n@pytest.mark.parametrize(\"bad_code\", FAILING_CONTRACTS_STRUCTURE_EXCEPTION)\ndef test_bad_code_struct_exc(assert_compile_failed, get_contract_with_gas_estimation, bad_code):\n\n    assert_compile_failed(lambda: get_contract_with_gas_estimation(bad_code), ArgumentException)\n\n\ndef test_bad_skip_contract_check(assert_compile_failed, get_contract_with_gas_estimation):\n    code = \"\"\"\n# variable value for skip_contract_check\ninterface Bar:\n    def bar(): payable\n\n@external\ndef foo():\n    x: bool = True\n    Bar(msg.sender).bar(skip_contract_check=x)\n    \"\"\"\n    assert_compile_failed(lambda: get_contract_with_gas_estimation(code), InvalidType)\n\n\ndef test_tuple_return_external_contract_call(get_contract):\n    contract_1 = \"\"\"\n@external\ndef out_literals() -> (int128, address, Bytes[10]):\n    return 1, 0x0000000000000000000000000000000000000123, b\"random\"\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Test:\n    def out_literals() -> (int128, address, Bytes[10]) : view\n\n@external\ndef test(addr: address) -> (int128, address, Bytes[10]):\n    a: int128 = 0\n    b: address = ZERO_ADDRESS\n    c: Bytes[10] = b\"\"\n    (a, b, c) = Test(addr).out_literals()\n    return a, b,c\n\n    \"\"\"\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n\n    assert c1.out_literals() == [1, \"0x0000000000000000000000000000000000000123\", b\"random\"]\n    assert c2.test(c1.address) == [1, \"0x0000000000000000000000000000000000000123\", b\"random\"]\n\n\ndef test_struct_return_external_contract_call_1(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n    y: address\n@external\ndef out_literals() -> X:\n    return X({x: 1, y: 0x0000000000000000000000000000000000012345})\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: int128\n    y: address\ninterface Test:\n    def out_literals() -> X : view\n\n@external\ndef test(addr: address) -> (int128, address):\n    ret: X = Test(addr).out_literals()\n    return ret.x, ret.y\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.out_literals() == (1, \"0x0000000000000000000000000000000000012345\")\n    assert c2.test(c1.address) == list(c1.out_literals())\n\n\n@pytest.mark.parametrize(\"i,ln,s,\", [(100, 6, \"abcde\"), (41, 40, \"a\" * 34), (57, 70, \"z\" * 68)])\ndef test_struct_return_external_contract_call_2(get_contract_with_gas_estimation, i, ln, s):\n    contract_1 = f\"\"\"\nstruct X:\n    x: int128\n    y: String[{ln}]\n    z: Bytes[{ln}]\n@external\ndef get_struct_x() -> X:\n    return X({{x: {i}, y: \"{s}\", z: b\"{s}\"}})\n    \"\"\"\n\n    contract_2 = f\"\"\"\nstruct X:\n    x: int128\n    y: String[{ln}]\n    z: Bytes[{ln}]\ninterface Test:\n    def get_struct_x() -> X : view\n\n@external\ndef test(addr: address) -> (int128, String[{ln}], Bytes[{ln}]):\n    ret: X = Test(addr).get_struct_x()\n    return ret.x, ret.y, ret.z\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.get_struct_x() == (i, s, bytes(s, \"utf-8\"))\n    assert c2.test(c1.address) == list(c1.get_struct_x())\n\n\ndef test_struct_return_external_contract_call_3(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n@external\ndef out_literals() -> X:\n    return X({x: 1})\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: int128\ninterface Test:\n    def out_literals() -> X : view\n\n@external\ndef test(addr: address) -> int128:\n    ret: X = Test(addr).out_literals()\n    return ret.x\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.out_literals() == (1,)\n    assert [c2.test(c1.address)] == list(c1.out_literals())\n\n\ndef test_constant_struct_return_external_contract_call_1(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n    y: address\n\nBAR: constant(X) = X({x: 1, y: 0x0000000000000000000000000000000000012345})\n\n@external\ndef out_literals() -> X:\n    return BAR\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: int128\n    y: address\ninterface Test:\n    def out_literals() -> X : view\n\n@external\ndef test(addr: address) -> (int128, address):\n    ret: X = Test(addr).out_literals()\n    return ret.x, ret.y\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.out_literals() == (1, \"0x0000000000000000000000000000000000012345\")\n    assert c2.test(c1.address) == list(c1.out_literals())\n\n\n@pytest.mark.parametrize(\"i,ln,s,\", [(100, 6, \"abcde\"), (41, 40, \"a\" * 34), (57, 70, \"z\" * 68)])\ndef test_constant_struct_return_external_contract_call_2(\n    get_contract_with_gas_estimation, i, ln, s\n):\n    contract_1 = f\"\"\"\nstruct X:\n    x: int128\n    y: String[{ln}]\n    z: Bytes[{ln}]\n\nBAR: constant(X) = X({{x: {i}, y: \"{s}\", z: b\"{s}\"}})\n\n@external\ndef get_struct_x() -> X:\n    return BAR\n    \"\"\"\n\n    contract_2 = f\"\"\"\nstruct X:\n    x: int128\n    y: String[{ln}]\n    z: Bytes[{ln}]\ninterface Test:\n    def get_struct_x() -> X : view\n\n@external\ndef test(addr: address) -> (int128, String[{ln}], Bytes[{ln}]):\n    ret: X = Test(addr).get_struct_x()\n    return ret.x, ret.y, ret.z\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.get_struct_x() == (i, s, bytes(s, \"utf-8\"))\n    assert c2.test(c1.address) == list(c1.get_struct_x())\n\n\ndef test_constant_struct_return_external_contract_call_3(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n\nBAR: constant(X) = X({x: 1})\n\n@external\ndef out_literals() -> X:\n    return BAR\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: int128\ninterface Test:\n    def out_literals() -> X : view\n\n@external\ndef test(addr: address) -> int128:\n    ret: X = Test(addr).out_literals()\n    return ret.x\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.out_literals() == (1,)\n    assert [c2.test(c1.address)] == list(c1.out_literals())\n\n\ndef test_constant_struct_member_return_external_contract_call_1(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n    y: address\n\nBAR: constant(X) = X({x: 1, y: 0x0000000000000000000000000000000000012345})\n\n@external\ndef get_y() -> address:\n    return BAR.y\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Test:\n    def get_y() -> address : view\n\n@external\ndef test(addr: address) -> address:\n    ret: address = Test(addr).get_y()\n    return ret\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.get_y() == \"0x0000000000000000000000000000000000012345\"\n    assert c2.test(c1.address) == \"0x0000000000000000000000000000000000012345\"\n\n\n@pytest.mark.parametrize(\"i,ln,s,\", [(100, 6, \"abcde\"), (41, 40, \"a\" * 34), (57, 70, \"z\" * 68)])\ndef test_constant_struct_member_return_external_contract_call_2(\n    get_contract_with_gas_estimation, i, ln, s\n):\n    contract_1 = f\"\"\"\nstruct X:\n    x: int128\n    y: String[{ln}]\n    z: Bytes[{ln}]\n\nBAR: constant(X) = X({{x: {i}, y: \"{s}\", z: b\"{s}\"}})\n\n@external\ndef get_y() -> String[{ln}]:\n    return BAR.y\n    \"\"\"\n\n    contract_2 = f\"\"\"\ninterface Test:\n    def get_y() -> String[{ln}] : view\n\n@external\ndef test(addr: address) -> String[{ln}]:\n    ret: String[{ln}] = Test(addr).get_y()\n    return ret\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.get_y() == s\n    assert c2.test(c1.address) == s\n\n\ndef test_constant_struct_member_return_external_contract_call_3(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n\nBAR: constant(X) = X({x: 1})\n\n@external\ndef get_x() -> int128:\n    return BAR.x\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Test:\n    def get_x() -> int128 : view\n\n@external\ndef test(addr: address) -> int128:\n    ret: int128 = Test(addr).get_x()\n    return ret\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.get_x() == 1\n    assert c2.test(c1.address) == 1\n\n\ndef test_constant_nested_struct_return_external_contract_call_1(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n    y: address\n\nstruct A:\n    a: X\n    b: uint256\n\nBAR: constant(A) = A({a: X({x: 1, y: 0x0000000000000000000000000000000000012345}), b: 777})\n\n@external\ndef out_literals() -> A:\n    return BAR\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: int128\n    y: address\n\nstruct A:\n    a: X\n    b: uint256\n\ninterface Test:\n    def out_literals() -> A : view\n\n@external\ndef test(addr: address) -> (X, uint256):\n    ret: A = Test(addr).out_literals()\n    return ret.a, ret.b\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.out_literals() == ((1, \"0x0000000000000000000000000000000000012345\"), 777)\n    assert c2.test(c1.address) == list(c1.out_literals())\n\n\n@pytest.mark.parametrize(\"i,ln,s,\", [(100, 6, \"abcde\"), (41, 40, \"a\" * 34), (57, 70, \"z\" * 68)])\ndef test_constant_nested_struct_return_external_contract_call_2(\n    get_contract_with_gas_estimation, i, ln, s\n):\n    contract_1 = f\"\"\"\nstruct X:\n    x: int128\n    y: String[{ln}]\n    z: Bytes[{ln}]\n\nstruct A:\n    a: X\n    b: uint256\n\nBAR: constant(A) = A({{a: X({{x: {i}, y: \"{s}\", z: b\"{s}\"}}), b: 777}})\n\n@external\ndef get_struct_a() -> A:\n    return BAR\n    \"\"\"\n\n    contract_2 = f\"\"\"\nstruct X:\n    x: int128\n    y: String[{ln}]\n    z: Bytes[{ln}]\n\nstruct A:\n    a: X\n    b: uint256\n\ninterface Test:\n    def get_struct_a() -> A : view\n\n@external\ndef test(addr: address) -> (X, uint256):\n    ret: A = Test(addr).get_struct_a()\n    return ret.a, ret.b\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.get_struct_a() == ((i, s, bytes(s, \"utf-8\")), 777)\n    assert c2.test(c1.address) == list(c1.get_struct_a())\n\n\ndef test_constant_nested_struct_return_external_contract_call_3(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n    y: int128\n\nstruct A:\n    a: X\n    b: uint256\n\nstruct C:\n    c: A\n    d: bool\n\nBAR: constant(C) = C({c: A({a: X({x: 1, y: -1}), b: 777}), d: True})\n\n@external\ndef out_literals() -> C:\n    return BAR\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: int128\n    y: int128\n\nstruct A:\n    a: X\n    b: uint256\n\nstruct C:\n    c: A\n    d: bool\n\ninterface Test:\n    def out_literals() -> C : view\n\n@external\ndef test(addr: address) -> (A, bool):\n    ret: C = Test(addr).out_literals()\n    return ret.c, ret.d\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.out_literals() == (((1, -1), 777), True)\n    assert c2.test(c1.address) == list(c1.out_literals())\n\n\ndef test_constant_nested_struct_member_return_external_contract_call_1(\n    get_contract_with_gas_estimation,\n):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n    y: address\n\nstruct A:\n    a: X\n    b: uint256\n\nBAR: constant(A) = A({a: X({x: 1, y: 0x0000000000000000000000000000000000012345}), b: 777})\n\n@external\ndef get_y() -> address:\n    return BAR.a.y\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Test:\n    def get_y() -> address : view\n\n@external\ndef test(addr: address) -> address:\n    ret: address = Test(addr).get_y()\n    return ret\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.get_y() == \"0x0000000000000000000000000000000000012345\"\n    assert c2.test(c1.address) == \"0x0000000000000000000000000000000000012345\"\n\n\n@pytest.mark.parametrize(\"i,ln,s,\", [(100, 6, \"abcde\"), (41, 40, \"a\" * 34), (57, 70, \"z\" * 68)])\ndef test_constant_nested_struct_member_return_external_contract_call_2(\n    get_contract_with_gas_estimation, i, ln, s\n):\n    contract_1 = f\"\"\"\nstruct X:\n    x: int128\n    y: String[{ln}]\n    z: Bytes[{ln}]\n\nstruct A:\n    a: X\n    b: uint256\n    c: bool\n\nBAR: constant(A) = A({{a: X({{x: {i}, y: \"{s}\", z: b\"{s}\"}}), b: 777, c: True}})\n\n@external\ndef get_y() -> String[{ln}]:\n    return BAR.a.y\n    \"\"\"\n\n    contract_2 = f\"\"\"\ninterface Test:\n    def get_y() -> String[{ln}] : view\n\n@external\ndef test(addr: address) -> String[{ln}]:\n    ret: String[{ln}] = Test(addr).get_y()\n    return ret\n\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.get_y() == s\n    assert c2.test(c1.address) == s\n\n\ndef test_constant_nested_struct_member_return_external_contract_call_3(\n    get_contract_with_gas_estimation,\n):\n    contract_1 = \"\"\"\nstruct X:\n    x: int128\n    y: int128\n\nstruct A:\n    a: X\n    b: uint256\n\nstruct C:\n    c: A\n    d: bool\n\nBAR: constant(C) = C({c: A({a: X({x: 1, y: -1}), b: 777}), d: True})\n\n@external\ndef get_y() -> int128:\n    return BAR.c.a.y\n\n@external\ndef get_b() -> uint256:\n    return BAR.c.b\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Test:\n    def get_y() -> int128 : view\n    def get_b() -> uint256 : view\n\n@external\ndef test(addr: address) -> int128:\n    ret: int128 = Test(addr).get_y()\n    return ret\n\n@external\ndef test2(addr: address) -> uint256:\n    ret: uint256 = Test(addr).get_b()\n    return ret\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.get_y() == -1\n    assert c2.test(c1.address) == -1\n\n    assert c1.get_b() == 777\n    assert c2.test2(c1.address) == 777\n\n\ndef test_dynamically_sized_struct_external_contract_call(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: uint256\n    y: Bytes[6]\n\n@external\ndef foo(x: X) -> Bytes[6]:\n    return x.y\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: uint256\n    y: Bytes[6]\n\ninterface Foo:\n    def foo(x: X) -> Bytes[6]: nonpayable\n\n@external\ndef bar(addr: address) -> Bytes[6]:\n    _X: X = X({x: 1, y: b\"hello\"})\n    return Foo(addr).foo(_X)\n    \"\"\"\n\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.foo((1, b\"hello\")) == b\"hello\"\n    assert c2.bar(c1.address) == b\"hello\"\n\n\ndef test_dynamically_sized_struct_external_contract_call_2(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\nstruct X:\n    x: uint256\n    y: String[6]\n\n@external\ndef foo(x: X) -> String[6]:\n    return x.y\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: uint256\n    y: String[6]\n\ninterface Foo:\n    def foo(x: X) -> String[6]: nonpayable\n\n@external\ndef bar(addr: address) -> String[6]:\n    _X: X = X({x: 1, y: \"hello\"})\n    return Foo(addr).foo(_X)\n    \"\"\"\n\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.foo((1, \"hello\")) == \"hello\"\n    assert c2.bar(c1.address) == \"hello\"\n\n\ndef test_dynamically_sized_struct_member_external_contract_call(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\n@external\ndef foo(b: Bytes[6]) -> Bytes[6]:\n    return b\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: uint256\n    y: Bytes[6]\n\ninterface Foo:\n    def foo(b: Bytes[6]) -> Bytes[6]: nonpayable\n\n@external\ndef bar(addr: address) -> Bytes[6]:\n    _X: X = X({x: 1, y: b\"hello\"})\n    return Foo(addr).foo(_X.y)\n    \"\"\"\n\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.foo(b\"hello\") == b\"hello\"\n    assert c2.bar(c1.address) == b\"hello\"\n\n\ndef test_dynamically_sized_struct_member_external_contract_call_2(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\n@external\ndef foo(s: String[6]) -> String[6]:\n    return s\n    \"\"\"\n\n    contract_2 = \"\"\"\nstruct X:\n    x: uint256\n    y: String[6]\n\ninterface Foo:\n    def foo(b: String[6]) -> String[6]: nonpayable\n\n@external\ndef bar(addr: address) -> String[6]:\n    _X: X = X({x: 1, y: \"hello\"})\n    return Foo(addr).foo(_X.y)\n    \"\"\"\n\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.foo(\"hello\") == \"hello\"\n    assert c2.bar(c1.address) == \"hello\"\n\n\ndef test_list_external_contract_call(get_contract, get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\n@external\ndef array() -> int128[3]:\n    return [0, 0, 0]\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(contract_1)\n\n    contract_2 = \"\"\"\ninterface Foo:\n    def array() -> int128[3]: view\n@external\ndef get_array(arg1: address) -> int128[3]:\n    return Foo(arg1).array()\n\"\"\"\n\n    c2 = get_contract(contract_2)\n    assert c2.get_array(c.address) == [0, 0, 0]\n\n\ndef test_returndatasize_too_short(get_contract, assert_tx_failed):\n    contract_1 = \"\"\"\n@external\ndef bar(a: int128) -> int128:\n    return a\n\"\"\"\n    contract_2 = \"\"\"\ninterface Bar:\n    def bar(a: int128) -> (int128, int128): view\n\n@external\ndef foo(_addr: address):\n    Bar(_addr).bar(456)\n\"\"\"\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n    assert_tx_failed(lambda: c2.foo(c1.address))\n\n\ndef test_returndatasize_empty(get_contract, assert_tx_failed):\n    contract_1 = \"\"\"\n@external\ndef bar(a: int128):\n    pass\n\"\"\"\n    contract_2 = \"\"\"\ninterface Bar:\n    def bar(a: int128) -> int128: view\n\n@external\ndef foo(_addr: address) -> int128:\n    return Bar(_addr).bar(456)\n\"\"\"\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n    assert_tx_failed(lambda: c2.foo(c1.address))\n\n\ndef test_returndatasize_too_long(get_contract):\n    contract_1 = \"\"\"\n@external\ndef bar(a: int128) -> (int128, int128):\n    return a, 789\n\"\"\"\n    contract_2 = \"\"\"\ninterface Bar:\n    def bar(a: int128) -> int128: view\n\n@external\ndef foo(_addr: address) -> int128:\n    return Bar(_addr).bar(456)\n\"\"\"\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n\n    # excess return data does not raise\n    assert c2.foo(c1.address) == 456\n\n\ndef test_no_returndata(get_contract, assert_tx_failed):\n    contract_1 = \"\"\"\n@external\ndef bar(a: int128) -> int128:\n    return a\n\"\"\"\n    contract_2 = \"\"\"\ninterface Bar:\n    def bar(a: int128) -> int128: view\n\n@external\ndef foo(_addr: address, _addr2: address) -> int128:\n    x: int128 = Bar(_addr).bar(456)\n    # make two calls to confirm EVM behavior: RETURNDATA is always based on the last call\n    y: int128 = Bar(_addr2).bar(123)\n    return y\n\n\"\"\"\n    c1 = get_contract(contract_1)\n    c2 = get_contract(contract_2)\n\n    assert c2.foo(c1.address, c1.address) == 123\n    assert_tx_failed(lambda: c2.foo(c1.address, \"0x1234567890123456789012345678901234567890\"))\n\n\ndef test_default_override(get_contract, assert_tx_failed):\n    bad_erc20_code = \"\"\"\n@external\ndef transfer(receiver: address, amount: uint256):\n    pass\n    \"\"\"\n\n    negative_transfer_code = \"\"\"\n@external\ndef transfer(receiver: address, amount: uint256) -> bool:\n    return False\n    \"\"\"\n\n    self_destructing_code = \"\"\"\n@external\ndef transfer(receiver: address, amount: uint256):\n    selfdestruct(msg.sender)\n    \"\"\"\n\n    code = \"\"\"\nfrom vyper.interfaces import ERC20\n@external\ndef safeTransfer(erc20: ERC20, receiver: address, amount: uint256) -> uint256:\n    assert erc20.transfer(receiver, amount, default_return_value=True)\n    return 7\n\n@external\ndef transferBorked(erc20: ERC20, receiver: address, amount: uint256):\n    assert erc20.transfer(receiver, amount)\n    \"\"\"\n    bad_erc20 = get_contract(bad_erc20_code)\n    c = get_contract(code)\n\n    # demonstrate transfer failing\n    assert_tx_failed(lambda: c.transferBorked(bad_erc20.address, c.address, 0))\n    # would fail without default_return_value\n    assert c.safeTransfer(bad_erc20.address, c.address, 0) == 7\n\n    # check that `default_return_value` does not stomp valid returndata.\n    negative_contract = get_contract(negative_transfer_code)\n    assert_tx_failed(lambda: c.safeTransfer(negative_contract.address, c.address, 0))\n\n    # default_return_value should fail on EOAs (addresses with no code)\n    random_address = \"0x0000000000000000000000000000000000001234\"\n    assert_tx_failed(lambda: c.safeTransfer(random_address, c.address, 1))\n\n    # in this case, the extcodesize check runs after the token contract\n    # selfdestructs. however, extcodesize still returns nonzero until\n    # later (i.e., after this transaction), so we still pass\n    # the extcodesize check.\n    self_destructing_contract = get_contract(self_destructing_code)\n    assert c.safeTransfer(self_destructing_contract.address, c.address, 0) == 7\n\n\ndef test_default_override2(get_contract, assert_tx_failed):\n    bad_code_1 = \"\"\"\n@external\ndef return_64_bytes() -> bool:\n    return True\n    \"\"\"\n\n    bad_code_2 = \"\"\"\n@external\ndef return_64_bytes():\n    pass\n    \"\"\"\n\n    code = \"\"\"\nstruct BoolPair:\n    x: bool\n    y: bool\ninterface Foo:\n    def return_64_bytes() -> BoolPair: nonpayable\n@external\ndef bar(foo: Foo):\n    t: BoolPair = foo.return_64_bytes(default_return_value=BoolPair({x: True, y:True}))\n    assert t.x and t.y\n    \"\"\"\n    bad_1 = get_contract(bad_code_1)\n    bad_2 = get_contract(bad_code_2)\n    c = get_contract(code)\n\n    # fails due to returndatasize being nonzero but also lt 64\n    assert_tx_failed(lambda: c.bar(bad_1.address))\n    c.bar(bad_2.address)\n\n\ndef test_contract_address_evaluation(get_contract):\n    callee_code = \"\"\"\n# implements: Foo\n\ninterface Counter:\n    def increment_counter(): nonpayable\n\n@external\ndef foo():\n    pass\n\n@external\ndef bar() -> address:\n    Counter(msg.sender).increment_counter()\n    return self\n    \"\"\"\n    code = \"\"\"\n# implements: Counter\n\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\ncounter: uint256\n\n@external\ndef increment_counter():\n    self.counter += 1\n\n@external\ndef do_stuff(f: Foo) -> uint256:\n    Foo(f.bar()).foo()\n    return self.counter\n    \"\"\"\n\n    c1 = get_contract(code)\n    c2 = get_contract(callee_code)\n\n    assert c1.do_stuff(c2.address) == 1\n", "from dataclasses import dataclass\n\nimport vyper.utils as util\nfrom vyper.address_space import MEMORY\nfrom vyper.codegen.abi_encoder import abi_encode\nfrom vyper.codegen.core import (\n    calculate_type_for_external_return,\n    check_assign,\n    check_external_call,\n    dummy_node_for_type,\n    make_setter,\n    needs_clamp,\n    unwrap_location,\n    wrap_value_for_external_return,\n)\nfrom vyper.codegen.ir_node import Encoding, IRnode\nfrom vyper.codegen.types import InterfaceType, TupleType, get_type_for_exact_size\nfrom vyper.codegen.types.convert import new_type_to_old_type\nfrom vyper.exceptions import TypeCheckFailure\nfrom vyper.semantics.types.function import StateMutability\n\n\n@dataclass\nclass _CallKwargs:\n    value: IRnode\n    gas: IRnode\n    skip_contract_check: bool\n    default_return_value: IRnode\n\n\ndef _pack_arguments(fn_type, args, context):\n    # abi encoding just treats all args as a big tuple\n    args_tuple_t = TupleType([x.typ for x in args])\n    args_as_tuple = IRnode.from_list([\"multi\"] + [x for x in args], typ=args_tuple_t)\n    args_abi_t = args_tuple_t.abi_type\n\n    # sanity typecheck - make sure the arguments can be assigned\n    dst_tuple_t = TupleType(\n        [new_type_to_old_type(typ) for typ in fn_type.arguments.values()][: len(args)]\n    )\n    check_assign(dummy_node_for_type(dst_tuple_t), args_as_tuple)\n\n    if fn_type.return_type is not None:\n        return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n        # we use the same buffer for args and returndata,\n        # so allocate enough space here for the returndata too.\n        buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\n    else:\n        buflen = args_abi_t.size_bound()\n\n    buflen += 32  # padding for the method id\n\n    buf_t = get_type_for_exact_size(buflen)\n    buf = context.new_internal_variable(buf_t)\n\n    args_ofst = buf + 28\n    args_len = args_abi_t.size_bound() + 4\n\n    abi_signature = fn_type.name + dst_tuple_t.abi_type.selector_name()\n\n    # layout:\n    # 32 bytes                 | args\n    # 0x..00<method_id_4bytes> | args\n    # the reason for the left padding is just so the alignment is easier.\n    # if we were only targeting constantinople, we could align\n    # to buf (and also keep code size small) by using\n    # (mstore buf (shl signature.method_id 224))\n    pack_args = [\"seq\"]\n    pack_args.append([\"mstore\", buf, util.abi_method_id(abi_signature)])\n\n    if len(args) != 0:\n        pack_args.append(abi_encode(buf + 32, args_as_tuple, context, bufsz=buflen))\n\n    return buf, pack_args, args_ofst, args_len\n\n\ndef _unpack_returndata(buf, fn_type, call_kwargs, contract_address, context, expr):\n    ast_return_t = fn_type.return_type\n\n    if ast_return_t is None:\n        return [\"pass\"], 0, 0\n\n    return_t = new_type_to_old_type(ast_return_t)\n\n    wrapped_return_t = calculate_type_for_external_return(return_t)\n\n    abi_return_t = wrapped_return_t.abi_type\n\n    min_return_size = abi_return_t.min_size()\n    max_return_size = abi_return_t.size_bound()\n    assert 0 < min_return_size <= max_return_size\n\n    ret_ofst = buf\n    ret_len = max_return_size\n\n    encoding = Encoding.ABI\n\n    buf = IRnode.from_list(\n        buf,\n        typ=wrapped_return_t,\n        location=MEMORY,\n        encoding=encoding,\n        annotation=f\"{expr.node_source_code} returndata buffer\",\n    )\n\n    unpacker = [\"seq\"]\n\n    # revert when returndatasize is not in bounds\n    # (except when return_override is provided.)\n    if not call_kwargs.skip_contract_check:\n        unpacker.append([\"assert\", [\"ge\", \"returndatasize\", min_return_size]])\n\n    assert isinstance(wrapped_return_t, TupleType)\n\n    # unpack strictly\n    if needs_clamp(wrapped_return_t, encoding):\n        return_buf = context.new_internal_variable(wrapped_return_t)\n        return_buf = IRnode.from_list(return_buf, typ=wrapped_return_t, location=MEMORY)\n\n        # note: make_setter does ABI decoding and clamps\n        unpacker.append(make_setter(return_buf, buf))\n    else:\n        return_buf = buf\n\n    if call_kwargs.default_return_value is not None:\n        # if returndatasize == 0:\n        #    copy return override to buf\n        # else:\n        #    do the other stuff\n\n        override_value = wrap_value_for_external_return(call_kwargs.default_return_value)\n        stomp_return_buffer = [\"seq\"]\n        if not call_kwargs.skip_contract_check:\n            stomp_return_buffer.append(_extcodesize_check(contract_address))\n        stomp_return_buffer.append(make_setter(return_buf, override_value))\n        unpacker = [\"if\", [\"eq\", \"returndatasize\", 0], stomp_return_buffer, unpacker]\n\n    unpacker = [\"seq\", unpacker, return_buf]\n\n    return unpacker, ret_ofst, ret_len\n\n\ndef _parse_kwargs(call_expr, context):\n    from vyper.codegen.expr import Expr  # TODO rethink this circular import\n\n    def _bool(x):\n        assert x.value in (0, 1), \"type checker missed this\"\n        return bool(x.value)\n\n    # note: codegen for kwarg values in AST order\n    call_kwargs = {kw.arg: Expr(kw.value, context).ir_node for kw in call_expr.keywords}\n\n    ret = _CallKwargs(\n        value=unwrap_location(call_kwargs.pop(\"value\", IRnode(0))),\n        gas=unwrap_location(call_kwargs.pop(\"gas\", IRnode(\"gas\"))),\n        skip_contract_check=_bool(call_kwargs.pop(\"skip_contract_check\", IRnode(0))),\n        default_return_value=call_kwargs.pop(\"default_return_value\", None),\n    )\n\n    if len(call_kwargs) != 0:\n        raise TypeCheckFailure(f\"Unexpected keyword arguments: {call_kwargs}\")\n\n    return ret\n\n\ndef _extcodesize_check(address):\n    return [\"assert\", [\"extcodesize\", address]]\n\n\ndef _external_call_helper(contract_address, args_ir, call_kwargs, call_expr, context):\n    # expr.func._metadata[\"type\"].return_type is more accurate\n    # than fn_sig.return_type in the case of JSON interfaces.\n    fn_type = call_expr.func._metadata[\"type\"]\n\n    # sanity check\n    assert fn_type.min_arg_count <= len(args_ir) <= fn_type.max_arg_count\n\n    ret = [\"seq\"]\n\n    buf, arg_packer, args_ofst, args_len = _pack_arguments(fn_type, args_ir, context)\n\n    ret_unpacker, ret_ofst, ret_len = _unpack_returndata(\n        buf, fn_type, call_kwargs, contract_address, context, call_expr\n    )\n\n    ret += arg_packer\n\n    if fn_type.return_type is None and not call_kwargs.skip_contract_check:\n        # if we do not expect return data, check that a contract exists at the\n        # target address. we must perform this check BEFORE the call because\n        # the contract might selfdestruct. on the other hand we can omit this\n        # when we _do_ expect return data because we later check\n        # `returndatasize` (that check works even if the contract\n        # selfdestructs).\n        ret.append(_extcodesize_check(contract_address))\n\n    gas = call_kwargs.gas\n    value = call_kwargs.value\n\n    use_staticcall = fn_type.mutability in (StateMutability.VIEW, StateMutability.PURE)\n    if context.is_constant():\n        assert use_staticcall, \"typechecker missed this\"\n\n    if use_staticcall:\n        call_op = [\"staticcall\", gas, contract_address, args_ofst, args_len, buf, ret_len]\n    else:\n        call_op = [\"call\", gas, contract_address, value, args_ofst, args_len, buf, ret_len]\n\n    ret.append(check_external_call(call_op))\n\n    return_t = None\n    if fn_type.return_type is not None:\n        return_t = new_type_to_old_type(fn_type.return_type)\n        ret.append(ret_unpacker)\n\n    return IRnode.from_list(ret, typ=return_t, location=MEMORY)\n\n\ndef ir_for_external_call(call_expr, context):\n    from vyper.codegen.expr import Expr  # TODO rethink this circular import\n\n    contract_address = Expr.parse_value_expr(call_expr.func.value, context)\n    assert isinstance(contract_address.typ, InterfaceType)\n    args_ir = [Expr(x, context).ir_node for x in call_expr.args]\n    call_kwargs = _parse_kwargs(call_expr, context)\n\n    with contract_address.cache_when_complex(\"external_contract\") as (b1, contract_address):\n        return b1.resolve(\n            _external_call_helper(contract_address, args_ir, call_kwargs, call_expr, context)\n        )\n"], "filenames": ["tests/parser/features/external_contracts/test_external_contract_calls.py", "vyper/codegen/external_call.py"], "buggy_code_start_loc": [2413, 171], "buggy_code_end_loc": [2413, 225], "fixing_code_start_loc": [2414, 171], "fixing_code_end_loc": [2455, 232], "type": "CWE-670", "message": "Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.", "other": {"cve": {"id": "CVE-2022-29255", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-09T09:15:08.377", "lastModified": "2022-06-15T17:06:24.963", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4."}, {"lang": "es", "value": "Vyper es un Lenguaje de Contratos Inteligentes de Python para la m\u00e1quina virtual de Ethereum. En versiones anteriores a 0.3.4, cuando es llamado a un contrato externo sin valor de retorno, la direcci\u00f3n del contrato (incluyendo los efectos secundarios) pod\u00eda ser evaluada dos veces. Esto pod\u00eda resultar en  respuestas incorrectas para los contratos. Este problema ha sido abordado en versi\u00f3n 0.3.4"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-670"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-670"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vyper_project:vyper:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.3.4", "matchCriteriaId": "A7CFF078-2A1A-4125-984D-524650FF82AC"}]}]}], "references": [{"url": "https://github.com/vyperlang/vyper/commit/6b4d8ff185de071252feaa1c319712b2d6577f8d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vyperlang/vyper/security/advisories/GHSA-4v9q-cgpw-cf38", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vyperlang/vyper/commit/6b4d8ff185de071252feaa1c319712b2d6577f8d"}}