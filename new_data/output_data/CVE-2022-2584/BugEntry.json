{"buggy_code": ["package dagpb\n\n// mirrored in JavaScript @ https://github.com/ipld/js-dag-pb/blob/master/test/test-compat.js\n\nimport (\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"strings\"\n\t\"testing\"\n\n\tcid \"github.com/ipfs/go-cid\"\n\t\"github.com/ipld/go-ipld-prime\"\n\t\"github.com/ipld/go-ipld-prime/fluent\"\n\tcidlink \"github.com/ipld/go-ipld-prime/linking/cid\"\n\tbasicnode \"github.com/ipld/go-ipld-prime/node/basic\"\n)\n\nvar dataZero []byte = make([]byte, 0)\nvar dataSome []byte = []byte{0, 1, 2, 3, 4}\nvar acid cid.Cid = _mkcid()\nvar zeroName string = \"\"\nvar someName string = \"some name\"\nvar zeroTsize uint64 = 0\nvar someTsize uint64 = 1010\nvar largeTsize uint64 = 9007199254740991 // JavaScript Number.MAX_SAFE_INTEGER\n\ntype testCase struct {\n\tname          string\n\tnode          *pbNode\n\texpectedBytes string\n\texpectedForm  string\n\tencodeError   string\n\tdecodeError   string\n}\n\nvar testCases = []testCase{\n\t{\n\t\tname:          \"empty\",\n\t\tnode:          &pbNode{},\n\t\texpectedBytes: \"\",\n\t\texpectedForm: `{\n\t\"Links\": []\n}`,\n\t\tencodeError: \"missing required fields: Links\",\n\t},\n\t{\n\t\tname:          \"Data zero\",\n\t\tnode:          &pbNode{data: dataZero},\n\t\texpectedBytes: \"0a00\",\n\t\texpectedForm: `{\n\t\"Data\": \"\",\n\t\"Links\": []\n}`,\n\t\tencodeError: \"missing required fields: Links\",\n\t},\n\t{\n\t\tname:          \"Data some\",\n\t\tnode:          &pbNode{data: dataSome},\n\t\texpectedBytes: \"0a050001020304\",\n\t\texpectedForm: `{\n\t\"Data\": \"0001020304\",\n\t\"Links\": []\n}`,\n\t\tencodeError: \"missing required fields: Links\",\n\t},\n\t{\n\t\tname:          \"Links zero\",\n\t\tnode:          &pbNode{links: []pbLink{}},\n\t\texpectedBytes: \"\",\n\t\texpectedForm: `{\n\t\"Links\": []\n}`,\n\t},\n\t{\n\t\tname:          \"Data some Links zero\",\n\t\tnode:          &pbNode{data: dataSome, links: []pbLink{}},\n\t\texpectedBytes: \"0a050001020304\",\n\t\texpectedForm: `{\n\t\"Data\": \"0001020304\",\n\t\"Links\": []\n}`,\n\t},\n\t{\n\t\tname:          \"Links empty\",\n\t\tnode:          &pbNode{links: []pbLink{{}}},\n\t\texpectedBytes: \"1200\",\n\t\tencodeError:   \"missing required fields: Hash\",\n\t\tdecodeError:   \"expected CID\",\n\t},\n\t{\n\t\tname:          \"Data some Links empty\",\n\t\tnode:          &pbNode{data: dataSome, links: []pbLink{{}}},\n\t\texpectedBytes: \"12000a050001020304\",\n\t\tencodeError:   \"missing required fields: Hash\",\n\t\tdecodeError:   \"expected CID\",\n\t},\n\t{\n\t\tname:          \"Links Hash zero\",\n\t\texpectedBytes: \"12020a00\",\n\t\tdecodeError:   \"expected CID\", // error should come up from go-cid too\n\t},\n\t{\n\t\tname:          \"Links Hash some\",\n\t\tnode:          &pbNode{links: []pbLink{{hash: acid}}},\n\t\texpectedBytes: \"120b0a09015500050001020304\",\n\t\texpectedForm: `{\n\t\"Links\": [\n\t\t{\n\t\t\t\"Hash\": \"015500050001020304\"\n\t\t}\n\t]\n}`,\n\t},\n\t{\n\t\tname:          \"Links Name zero\",\n\t\tnode:          &pbNode{links: []pbLink{{name: zeroName, hasName: true}}},\n\t\texpectedBytes: \"12021200\",\n\t\tencodeError:   \"missing required fields: Hash\",\n\t\tdecodeError:   \"expected CID\",\n\t},\n\t{\n\t\tname:          \"Links Hash some Name zero\",\n\t\tnode:          &pbNode{links: []pbLink{{hash: acid, name: zeroName, hasName: true}}},\n\t\texpectedBytes: \"120d0a090155000500010203041200\",\n\t\texpectedForm: `{\n\t\"Links\": [\n\t\t{\n\t\t\t\"Hash\": \"015500050001020304\",\n\t\t\t\"Name\": \"\"\n\t\t}\n\t]\n}`,\n\t},\n\t{\n\t\tname:          \"Links Name some\",\n\t\tnode:          &pbNode{links: []pbLink{{name: someName, hasName: true}}},\n\t\texpectedBytes: \"120b1209736f6d65206e616d65\",\n\t\tencodeError:   \"missing required fields: Hash\",\n\t\tdecodeError:   \"expected CID\",\n\t},\n\t{\n\t\tname:          \"Links Hash some Name some\",\n\t\tnode:          &pbNode{links: []pbLink{{hash: acid, name: someName, hasName: true}}},\n\t\texpectedBytes: \"12160a090155000500010203041209736f6d65206e616d65\",\n\t\texpectedForm: `{\n\t\"Links\": [\n\t\t{\n\t\t\t\"Hash\": \"015500050001020304\",\n\t\t\t\"Name\": \"some name\"\n\t\t}\n\t]\n}`,\n\t},\n\t{\n\t\tname:          \"Links Tsize zero\",\n\t\tnode:          &pbNode{links: []pbLink{{tsize: zeroTsize, hasTsize: true}}},\n\t\texpectedBytes: \"12021800\",\n\t\tencodeError:   \"missing required fields: Hash\",\n\t\tdecodeError:   \"expected CID\",\n\t},\n\t{\n\t\tname:          \"Links Hash some Tsize zero\",\n\t\tnode:          &pbNode{links: []pbLink{{hash: acid, tsize: zeroTsize, hasTsize: true}}},\n\t\texpectedBytes: \"120d0a090155000500010203041800\",\n\t\texpectedForm: `{\n\t\"Links\": [\n\t\t{\n\t\t\t\"Hash\": \"015500050001020304\",\n\t\t\t\"Tsize\": 0\n\t\t}\n\t]\n}`,\n\t},\n\t{\n\t\tname:          \"Links Tsize some\",\n\t\tnode:          &pbNode{links: []pbLink{{tsize: someTsize, hasTsize: true}}},\n\t\texpectedBytes: \"120318f207\",\n\t\tencodeError:   \"missing required fields: Hash\",\n\t\tdecodeError:   \"expected CID\",\n\t},\n\t{\n\t\tname:          \"Links Hash some Tsize some\",\n\t\tnode:          &pbNode{links: []pbLink{{hash: acid, tsize: largeTsize, hasTsize: true}}},\n\t\texpectedBytes: \"12140a0901550005000102030418ffffffffffffff0f\",\n\t\texpectedForm: `{\n\t\"Links\": [\n\t\t{\n\t\t\t\"Hash\": \"015500050001020304\",\n\t\t\t\"Tsize\": 9007199254740991\n\t\t}\n\t]\n}`,\n\t},\n}\n\nfunc TestCompat(t *testing.T) {\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tverifyRoundTrip(t, tc)\n\t\t})\n\t}\n}\n\nfunc verifyRoundTrip(t *testing.T, tc testCase) {\n\tvar err error\n\tvar actualBytes string\n\tvar actualForm string\n\n\tif tc.node != nil {\n\t\tnode := buildNode(*tc.node)\n\t\tactualBytes, err = nodeToString(t, node)\n\n\t\tif tc.encodeError != \"\" {\n\t\t\tif err != nil {\n\t\t\t\tif !strings.Contains(err.Error(), tc.encodeError) {\n\t\t\t\t\tt.Fatalf(\"got unexpeced encode error: [%v] (expected [%v])\", err.Error(), tc.encodeError)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt.Fatalf(\"did not get expected encode error: %v\", tc.encodeError)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t} else {\n\t\t\t\tif actualBytes != tc.expectedBytes {\n\t\t\t\t\tt.Logf(\n\t\t\t\t\t\t\"Expected bytes: [%v]\\nGot: [%v]\\n\",\n\t\t\t\t\t\ttc.expectedBytes,\n\t\t\t\t\t\tactualBytes)\n\t\t\t\t\tt.Error(\"Did not match\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tactualForm, err = bytesToFormString(t, tc.expectedBytes, basicnode.Prototype__Map{}.NewBuilder())\n\tif tc.decodeError != \"\" {\n\t\tif err != nil {\n\t\t\tif !strings.Contains(err.Error(), tc.decodeError) {\n\t\t\t\tt.Fatalf(\"got unexpeced decode error: [%v] (expected [%v])\", err.Error(), tc.decodeError)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatalf(\"did not get expected decode error: %v\", tc.decodeError)\n\t\t}\n\t} else {\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif actualForm != tc.expectedForm {\n\t\t\tt.Logf(\n\t\t\t\t\"Expected form: [%v]\\nGot: [%v]\\n\",\n\t\t\t\ttc.expectedForm,\n\t\t\t\tactualForm)\n\t\t\tt.Error(\"Did not match\")\n\t\t}\n\t}\n}\n\nfunc buildNode(n pbNode) ipld.Node {\n\treturn fluent.MustBuildMap(basicnode.Prototype__Map{}, 2, func(fma fluent.MapAssembler) {\n\t\tif n.data != nil {\n\t\t\tfma.AssembleEntry(\"Data\").AssignBytes(n.data)\n\t\t}\n\t\tif n.links != nil {\n\t\t\tfma.AssembleEntry(\"Links\").CreateList(int64(len(n.links)), func(fla fluent.ListAssembler) {\n\t\t\t\tfor _, link := range n.links {\n\t\t\t\t\tfla.AssembleValue().CreateMap(3, func(fma fluent.MapAssembler) {\n\t\t\t\t\t\tif link.hasName {\n\t\t\t\t\t\t\tfma.AssembleEntry(\"Name\").AssignString(link.name)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif link.hasTsize {\n\t\t\t\t\t\t\tfma.AssembleEntry(\"Tsize\").AssignInt(int64(link.tsize))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif link.hash.ByteLen() != 0 {\n\t\t\t\t\t\t\tfma.AssembleEntry(\"Hash\").AssignLink(cidlink.Link{Cid: link.hash})\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc nodeToString(t *testing.T, node ipld.Node) (string, error) {\n\tvar buf bytes.Buffer\n\terr := Marshal(node, &buf)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\th := hex.EncodeToString(buf.Bytes())\n\tt.Logf(\"[%v]\\n\", h)\n\treturn h, nil\n}\n\nfunc bytesToFormString(t *testing.T, bytesHex string, nb ipld.NodeBuilder) (string, error) {\n\tbyts, err := hex.DecodeString(bytesHex)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif err = Unmarshal(nb, bytes.NewReader(byts)); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnode := nb.Build()\n\tstr, err := json.MarshalIndent(cleanPBNode(t, node), \"\", \"\\t\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(str), nil\n}\n\n// convert a ipld.Node (PBLink) into a map for clean JSON marshalling\nfunc cleanPBLink(t *testing.T, link ipld.Node) map[string]interface{} {\n\tif link == nil {\n\t\treturn nil\n\t}\n\tnl := make(map[string]interface{})\n\thash, _ := link.LookupByString(\"Hash\")\n\tif hash != nil {\n\t\tl, _ := hash.AsLink()\n\t\tcl, _ := l.(cidlink.Link)\n\t\tnl[\"Hash\"] = hex.EncodeToString(cl.Bytes())\n\t}\n\tname, _ := link.LookupByString(\"Name\")\n\tif name != nil {\n\t\tname, _ := name.AsString()\n\t\tnl[\"Name\"] = name\n\t}\n\ttsize, _ := link.LookupByString(\"Tsize\")\n\tif tsize != nil {\n\t\ttsize, _ := tsize.AsInt()\n\t\tnl[\"Tsize\"] = tsize\n\t}\n\treturn nl\n}\n\n// convert an ipld.Node (PBNode) into a map for clean JSON marshalling\nfunc cleanPBNode(t *testing.T, node ipld.Node) map[string]interface{} {\n\tnn := make(map[string]interface{})\n\tdata, _ := node.LookupByString(\"Data\")\n\tif data != nil {\n\t\tbyts, _ := data.AsBytes()\n\t\tnn[\"Data\"] = hex.EncodeToString(byts)\n\t}\n\tlinks, _ := node.LookupByString(\"Links\")\n\tif links != nil {\n\t\tlinksList := make([]map[string]interface{}, links.Length())\n\t\tlinksIter := links.ListIterator()\n\t\tfor !linksIter.Done() {\n\t\t\tii, link, _ := linksIter.Next()\n\t\t\tlinksList[ii] = cleanPBLink(t, link)\n\t\t}\n\t\tnn[\"Links\"] = linksList\n\t}\n\treturn nn\n}\n\nfunc _mkcid() cid.Cid {\n\t_, c, _ := cid.CidFromBytes([]byte{1, 85, 0, 5, 0, 1, 2, 3, 4})\n\treturn c\n}\n", "package dagpb\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\n\t\"github.com/ipfs/go-cid\"\n\tipld \"github.com/ipld/go-ipld-prime\"\n\tcidlink \"github.com/ipld/go-ipld-prime/linking/cid\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n)\n\n// ErrIntOverflow is returned a varint overflows during decode, it indicates\n// malformed data\nvar ErrIntOverflow = fmt.Errorf(\"protobuf: varint overflow\")\n\n// Decode provides an IPLD codec decode interface for DAG-PB data. Provide a\n// compatible NodeAssembler and a byte source to unmarshal a DAG-PB IPLD Node.\n// Use the NodeAssembler from the PBNode type for safest construction\n// (Type.PBNode.NewBuilder()). A Map assembler will also work.\n// This function is registered via the go-ipld-prime link loader for multicodec\n// code 0x70 when this package is invoked via init.\nfunc Decode(na ipld.NodeAssembler, in io.Reader) error {\n\tvar src []byte\n\tif buf, ok := in.(interface{ Bytes() []byte }); ok {\n\t\tsrc = buf.Bytes()\n\t} else {\n\t\tvar err error\n\t\tsrc, err = ioutil.ReadAll(in)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn DecodeBytes(na, src)\n}\n\n// DecodeBytes is like Decode, but it uses an input buffer directly.\n// Decode will grab or read all the bytes from an io.Reader anyway, so this can\n// save having to copy the bytes or create a bytes.Buffer.\nfunc DecodeBytes(na ipld.NodeAssembler, src []byte) error {\n\tremaining := src\n\n\tma, err := na.BeginMap(2)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar links ipld.ListAssembler\n\n\thaveData := false\n\thaveLinks := false\n\tfor {\n\t\tif len(remaining) == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tfieldNum, wireType, n := protowire.ConsumeTag(remaining)\n\t\tif n < 0 {\n\t\t\treturn protowire.ParseError(n)\n\t\t}\n\t\tremaining = remaining[n:]\n\n\t\tif wireType != 2 {\n\t\t\treturn fmt.Errorf(\"protobuf: (PBNode) invalid wireType, expected 2, got %d\", wireType)\n\t\t}\n\n\t\t// Note that we allow Data and Links to come in either order,\n\t\t// since the spec defines that decoding \"should\" accept either form.\n\t\t// This is for backwards compatibility with older IPFS data.\n\n\t\tswitch fieldNum {\n\t\tcase 1:\n\t\t\tif haveData {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBNode) duplicate Data section\")\n\t\t\t}\n\n\t\t\tchunk, n := protowire.ConsumeBytes(remaining)\n\t\t\tif n < 0 {\n\t\t\t\treturn protowire.ParseError(n)\n\t\t\t}\n\t\t\tremaining = remaining[n:]\n\n\t\t\tif links != nil {\n\t\t\t\t// Links came before Data.\n\t\t\t\t// Finish them before we start Data.\n\t\t\t\tif err := links.Finish(); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tlinks = nil\n\t\t\t}\n\n\t\t\tif err := ma.AssembleKey().AssignString(\"Data\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := ma.AssembleValue().AssignBytes(chunk); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\thaveData = true\n\n\t\tcase 2:\n\t\t\tbytesLen, n := protowire.ConsumeVarint(remaining)\n\t\t\tif n < 0 {\n\t\t\t\treturn protowire.ParseError(n)\n\t\t\t}\n\t\t\tremaining = remaining[n:]\n\n\t\t\tif links == nil {\n\t\t\t\tif haveLinks {\n\t\t\t\t\treturn fmt.Errorf(\"protobuf: (PBNode) duplicate Links section\")\n\t\t\t\t}\n\n\t\t\t\t// The repeated \"Links\" part begins.\n\t\t\t\tif err := ma.AssembleKey().AssignString(\"Links\"); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tlinks, err = ma.AssembleValue().BeginList(0)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurLink, err := links.AssembleValue().BeginMap(3)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := unmarshalLink(remaining[:bytesLen], curLink); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tremaining = remaining[bytesLen:]\n\t\t\tif err := curLink.Finish(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\thaveLinks = true\n\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got %d\", fieldNum)\n\t\t}\n\t}\n\n\tif links != nil {\n\t\t// We had some links at the end, so finish them.\n\t\tif err := links.Finish(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t} else if !haveLinks {\n\t\t// We didn't have any links.\n\t\t// Since we always want a Links field, add one here.\n\t\tif err := ma.AssembleKey().AssignString(\"Links\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlinks, err := ma.AssembleValue().BeginList(0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := links.Finish(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn ma.Finish()\n}\n\nfunc unmarshalLink(remaining []byte, ma ipld.MapAssembler) error {\n\thaveHash := false\n\thaveName := false\n\thaveTsize := false\n\tfor {\n\t\tif len(remaining) == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tfieldNum, wireType, n := protowire.ConsumeTag(remaining)\n\t\tif n < 0 {\n\t\t\treturn protowire.ParseError(n)\n\t\t}\n\t\tremaining = remaining[n:]\n\n\t\tswitch fieldNum {\n\t\tcase 1:\n\t\t\tif haveHash {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) duplicate Hash section\")\n\t\t\t}\n\t\t\tif haveName {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) invalid order, found Name before Hash\")\n\t\t\t}\n\t\t\tif haveTsize {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) invalid order, found Tsize before Hash\")\n\t\t\t}\n\t\t\tif wireType != 2 {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) wrong wireType (%d) for Hash\", wireType)\n\t\t\t}\n\n\t\t\tchunk, n := protowire.ConsumeBytes(remaining)\n\t\t\tif n < 0 {\n\t\t\t\treturn protowire.ParseError(n)\n\t\t\t}\n\t\t\tremaining = remaining[n:]\n\n\t\t\t_, c, err := cid.CidFromBytes(chunk)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid Hash field found in link, expected CID (%v)\", err)\n\t\t\t}\n\t\t\tif err := ma.AssembleKey().AssignString(\"Hash\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := ma.AssembleValue().AssignLink(cidlink.Link{Cid: c}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\thaveHash = true\n\n\t\tcase 2:\n\t\t\tif haveName {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) duplicate Name section\")\n\t\t\t}\n\t\t\tif haveTsize {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) invalid order, found Tsize before Name\")\n\t\t\t}\n\t\t\tif wireType != 2 {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) wrong wireType (%d) for Name\", wireType)\n\t\t\t}\n\n\t\t\tchunk, n := protowire.ConsumeBytes(remaining)\n\t\t\tif n < 0 {\n\t\t\t\treturn protowire.ParseError(n)\n\t\t\t}\n\t\t\tremaining = remaining[n:]\n\n\t\t\tif err := ma.AssembleKey().AssignString(\"Name\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := ma.AssembleValue().AssignString(string(chunk)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\thaveName = true\n\n\t\tcase 3:\n\t\t\tif haveTsize {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) duplicate Tsize section\")\n\t\t\t}\n\t\t\tif wireType != 0 {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) wrong wireType (%d) for Tsize\", wireType)\n\t\t\t}\n\n\t\t\tv, n := protowire.ConsumeVarint(remaining)\n\t\t\tif n < 0 {\n\t\t\t\treturn protowire.ParseError(n)\n\t\t\t}\n\t\t\tremaining = remaining[n:]\n\n\t\t\tif err := ma.AssembleKey().AssignString(\"Tsize\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := ma.AssembleValue().AssignInt(int64(v)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\thaveTsize = true\n\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got %d\", fieldNum)\n\t\t}\n\t}\n\n\tif !haveHash {\n\t\treturn fmt.Errorf(\"invalid Hash field found in link, expected CID\")\n\t}\n\n\treturn nil\n}\n"], "fixing_code": ["package dagpb\n\n// mirrored in JavaScript @ https://github.com/ipld/js-dag-pb/blob/master/test/test-compat.js\n\nimport (\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"strings\"\n\t\"testing\"\n\n\tcid \"github.com/ipfs/go-cid\"\n\t\"github.com/ipld/go-ipld-prime\"\n\t\"github.com/ipld/go-ipld-prime/fluent\"\n\tcidlink \"github.com/ipld/go-ipld-prime/linking/cid\"\n\tbasicnode \"github.com/ipld/go-ipld-prime/node/basic\"\n)\n\nvar dataZero []byte = make([]byte, 0)\nvar dataSome []byte = []byte{0, 1, 2, 3, 4}\nvar acid cid.Cid = _mkcid()\nvar zeroName string = \"\"\nvar someName string = \"some name\"\nvar zeroTsize uint64 = 0\nvar someTsize uint64 = 1010\nvar largeTsize uint64 = 9007199254740991 // JavaScript Number.MAX_SAFE_INTEGER\n\ntype testCase struct {\n\tname          string\n\tnode          *pbNode\n\texpectedBytes string\n\texpectedForm  string\n\tencodeError   string\n\tdecodeError   string\n\ttestEncode    bool\n}\n\nvar testCases = []testCase{\n\t{\n\t\tname:          \"empty\",\n\t\tnode:          &pbNode{},\n\t\texpectedBytes: \"\",\n\t\texpectedForm: `{\n\t\"Links\": []\n}`,\n\t\tencodeError: \"missing required fields: Links\",\n\t},\n\t{\n\t\tname:          \"Data zero\",\n\t\tnode:          &pbNode{data: dataZero},\n\t\texpectedBytes: \"0a00\",\n\t\texpectedForm: `{\n\t\"Data\": \"\",\n\t\"Links\": []\n}`,\n\t\tencodeError: \"missing required fields: Links\",\n\t},\n\t{\n\t\tname:          \"Data some\",\n\t\tnode:          &pbNode{data: dataSome},\n\t\texpectedBytes: \"0a050001020304\",\n\t\texpectedForm: `{\n\t\"Data\": \"0001020304\",\n\t\"Links\": []\n}`,\n\t\tencodeError: \"missing required fields: Links\",\n\t},\n\t{\n\t\tname:          \"Data some, short\",\n\t\tnode:          &pbNode{data: dataSome},\n\t\texpectedBytes: \"0a0500010203\",\n\t\tdecodeError:   \"unexpected EOF\",\n\t\tencodeError:   \"missing required fields: Links\",\n\t},\n\t{\n\t\tname:          \"Links zero\",\n\t\tnode:          &pbNode{links: []pbLink{}},\n\t\texpectedBytes: \"\",\n\t\texpectedForm: `{\n\t\"Links\": []\n}`,\n\t},\n\t{\n\t\tname:          \"Data some Links zero\",\n\t\tnode:          &pbNode{data: dataSome, links: []pbLink{}},\n\t\texpectedBytes: \"0a050001020304\",\n\t\texpectedForm: `{\n\t\"Data\": \"0001020304\",\n\t\"Links\": []\n}`,\n\t},\n\t{\n\t\tname:          \"Links empty\",\n\t\tnode:          &pbNode{links: []pbLink{{}}},\n\t\texpectedBytes: \"1200\",\n\t\tencodeError:   \"missing required fields: Hash\",\n\t\tdecodeError:   \"expected CID\",\n\t},\n\t{\n\t\tname:          \"Data some Links empty\",\n\t\tnode:          &pbNode{data: dataSome, links: []pbLink{{}}},\n\t\texpectedBytes: \"12000a050001020304\",\n\t\tencodeError:   \"missing required fields: Hash\",\n\t\tdecodeError:   \"expected CID\",\n\t},\n\t{\n\t\tname:          \"Links Hash zero\",\n\t\texpectedBytes: \"12020a00\",\n\t\tdecodeError:   \"expected CID\", // error should come up from go-cid too\n\t},\n\t{\n\t\tname:          \"Links Hash some\",\n\t\tnode:          &pbNode{links: []pbLink{{hash: acid}}},\n\t\texpectedBytes: \"120b0a09015500050001020304\",\n\t\texpectedForm: `{\n\t\"Links\": [\n\t\t{\n\t\t\t\"Hash\": \"015500050001020304\"\n\t\t}\n\t]\n}`,\n\t},\n\t{\n\t\tname:          \"Links Hash some, short\",\n\t\tnode:          &pbNode{links: []pbLink{{hash: acid}}},\n\t\texpectedBytes: \"120b0a090155000500010203\",\n\t\tdecodeError:   \"unexpected EOF\",\n\t\ttestEncode:    false,\n\t}, {\n\t\tname:          \"Links Name zero\",\n\t\tnode:          &pbNode{links: []pbLink{{name: zeroName, hasName: true}}},\n\t\texpectedBytes: \"12021200\",\n\t\tencodeError:   \"missing required fields: Hash\",\n\t\tdecodeError:   \"expected CID\",\n\t},\n\t{\n\t\tname:          \"Links Hash some Name zero\",\n\t\tnode:          &pbNode{links: []pbLink{{hash: acid, name: zeroName, hasName: true}}},\n\t\texpectedBytes: \"120d0a090155000500010203041200\",\n\t\texpectedForm: `{\n\t\"Links\": [\n\t\t{\n\t\t\t\"Hash\": \"015500050001020304\",\n\t\t\t\"Name\": \"\"\n\t\t}\n\t]\n}`,\n\t},\n\t{\n\t\tname:          \"Links Name some\",\n\t\tnode:          &pbNode{links: []pbLink{{name: someName, hasName: true}}},\n\t\texpectedBytes: \"120b1209736f6d65206e616d65\",\n\t\tencodeError:   \"missing required fields: Hash\",\n\t\tdecodeError:   \"expected CID\",\n\t},\n\t{\n\t\tname:          \"Links Hash some Name some\",\n\t\tnode:          &pbNode{links: []pbLink{{hash: acid, name: someName, hasName: true}}},\n\t\texpectedBytes: \"12160a090155000500010203041209736f6d65206e616d65\",\n\t\texpectedForm: `{\n\t\"Links\": [\n\t\t{\n\t\t\t\"Hash\": \"015500050001020304\",\n\t\t\t\"Name\": \"some name\"\n\t\t}\n\t]\n}`,\n\t},\n\t{\n\t\tname:          \"Links Tsize zero\",\n\t\tnode:          &pbNode{links: []pbLink{{tsize: zeroTsize, hasTsize: true}}},\n\t\texpectedBytes: \"12021800\",\n\t\tencodeError:   \"missing required fields: Hash\",\n\t\tdecodeError:   \"expected CID\",\n\t},\n\t{\n\t\tname:          \"Links Hash some Tsize zero\",\n\t\tnode:          &pbNode{links: []pbLink{{hash: acid, tsize: zeroTsize, hasTsize: true}}},\n\t\texpectedBytes: \"120d0a090155000500010203041800\",\n\t\texpectedForm: `{\n\t\"Links\": [\n\t\t{\n\t\t\t\"Hash\": \"015500050001020304\",\n\t\t\t\"Tsize\": 0\n\t\t}\n\t]\n}`,\n\t},\n\t{\n\t\tname:          \"Links Tsize some\",\n\t\tnode:          &pbNode{links: []pbLink{{tsize: someTsize, hasTsize: true}}},\n\t\texpectedBytes: \"120318f207\",\n\t\tencodeError:   \"missing required fields: Hash\",\n\t\tdecodeError:   \"expected CID\",\n\t},\n\t{\n\t\tname:          \"Links Hash some Tsize some\",\n\t\tnode:          &pbNode{links: []pbLink{{hash: acid, tsize: largeTsize, hasTsize: true}}},\n\t\texpectedBytes: \"12140a0901550005000102030418ffffffffffffff0f\",\n\t\texpectedForm: `{\n\t\"Links\": [\n\t\t{\n\t\t\t\"Hash\": \"015500050001020304\",\n\t\t\t\"Tsize\": 9007199254740991\n\t\t}\n\t]\n}`,\n\t},\n}\n\nfunc TestCompat(t *testing.T) {\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tverifyRoundTrip(t, tc)\n\t\t})\n\t}\n}\n\nfunc verifyRoundTrip(t *testing.T, tc testCase) {\n\tvar err error\n\tvar actualBytes string\n\tvar actualForm string\n\n\tif tc.node != nil {\n\t\tnode := buildNode(*tc.node)\n\t\tactualBytes, err = nodeToString(t, node)\n\n\t\tif tc.testEncode {\n\t\t\tif tc.encodeError != \"\" {\n\t\t\t\tif err != nil {\n\t\t\t\t\tif !strings.Contains(err.Error(), tc.encodeError) {\n\t\t\t\t\t\tt.Fatalf(\"got unexpeced encode error: [%v] (expected [%v])\", err.Error(), tc.encodeError)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tt.Fatalf(\"did not get expected encode error: %v\", tc.encodeError)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t} else {\n\t\t\t\t\tif actualBytes != tc.expectedBytes {\n\t\t\t\t\t\tt.Logf(\n\t\t\t\t\t\t\t\"Expected bytes: [%v]\\nGot: [%v]\\n\",\n\t\t\t\t\t\t\ttc.expectedBytes,\n\t\t\t\t\t\t\tactualBytes)\n\t\t\t\t\t\tt.Error(\"Did not match\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tactualForm, err = bytesToFormString(t, tc.expectedBytes, basicnode.Prototype__Map{}.NewBuilder())\n\tif tc.decodeError != \"\" {\n\t\tif err != nil {\n\t\t\tif !strings.Contains(err.Error(), tc.decodeError) {\n\t\t\t\tt.Fatalf(\"got unexpeced decode error: [%v] (expected [%v])\", err.Error(), tc.decodeError)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatalf(\"did not get expected decode error: %v\", tc.decodeError)\n\t\t}\n\t} else {\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif actualForm != tc.expectedForm {\n\t\t\tt.Logf(\n\t\t\t\t\"Expected form: [%v]\\nGot: [%v]\\n\",\n\t\t\t\ttc.expectedForm,\n\t\t\t\tactualForm)\n\t\t\tt.Error(\"Did not match\")\n\t\t}\n\t}\n}\n\nfunc buildNode(n pbNode) ipld.Node {\n\treturn fluent.MustBuildMap(basicnode.Prototype__Map{}, 2, func(fma fluent.MapAssembler) {\n\t\tif n.data != nil {\n\t\t\tfma.AssembleEntry(\"Data\").AssignBytes(n.data)\n\t\t}\n\t\tif n.links != nil {\n\t\t\tfma.AssembleEntry(\"Links\").CreateList(int64(len(n.links)), func(fla fluent.ListAssembler) {\n\t\t\t\tfor _, link := range n.links {\n\t\t\t\t\tfla.AssembleValue().CreateMap(3, func(fma fluent.MapAssembler) {\n\t\t\t\t\t\tif link.hasName {\n\t\t\t\t\t\t\tfma.AssembleEntry(\"Name\").AssignString(link.name)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif link.hasTsize {\n\t\t\t\t\t\t\tfma.AssembleEntry(\"Tsize\").AssignInt(int64(link.tsize))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif link.hash.ByteLen() != 0 {\n\t\t\t\t\t\t\tfma.AssembleEntry(\"Hash\").AssignLink(cidlink.Link{Cid: link.hash})\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc nodeToString(t *testing.T, node ipld.Node) (string, error) {\n\tvar buf bytes.Buffer\n\terr := Marshal(node, &buf)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\th := hex.EncodeToString(buf.Bytes())\n\tt.Logf(\"[%v]\\n\", h)\n\treturn h, nil\n}\n\nfunc bytesToFormString(t *testing.T, bytesHex string, nb ipld.NodeBuilder) (string, error) {\n\tbyts, err := hex.DecodeString(bytesHex)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif err = Unmarshal(nb, bytes.NewReader(byts)); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnode := nb.Build()\n\tstr, err := json.MarshalIndent(cleanPBNode(t, node), \"\", \"\\t\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(str), nil\n}\n\n// convert a ipld.Node (PBLink) into a map for clean JSON marshalling\nfunc cleanPBLink(t *testing.T, link ipld.Node) map[string]interface{} {\n\tif link == nil {\n\t\treturn nil\n\t}\n\tnl := make(map[string]interface{})\n\thash, _ := link.LookupByString(\"Hash\")\n\tif hash != nil {\n\t\tl, _ := hash.AsLink()\n\t\tcl, _ := l.(cidlink.Link)\n\t\tnl[\"Hash\"] = hex.EncodeToString(cl.Bytes())\n\t}\n\tname, _ := link.LookupByString(\"Name\")\n\tif name != nil {\n\t\tname, _ := name.AsString()\n\t\tnl[\"Name\"] = name\n\t}\n\ttsize, _ := link.LookupByString(\"Tsize\")\n\tif tsize != nil {\n\t\ttsize, _ := tsize.AsInt()\n\t\tnl[\"Tsize\"] = tsize\n\t}\n\treturn nl\n}\n\n// convert an ipld.Node (PBNode) into a map for clean JSON marshalling\nfunc cleanPBNode(t *testing.T, node ipld.Node) map[string]interface{} {\n\tnn := make(map[string]interface{})\n\tdata, _ := node.LookupByString(\"Data\")\n\tif data != nil {\n\t\tbyts, _ := data.AsBytes()\n\t\tnn[\"Data\"] = hex.EncodeToString(byts)\n\t}\n\tlinks, _ := node.LookupByString(\"Links\")\n\tif links != nil {\n\t\tlinksList := make([]map[string]interface{}, links.Length())\n\t\tlinksIter := links.ListIterator()\n\t\tfor !linksIter.Done() {\n\t\t\tii, link, _ := linksIter.Next()\n\t\t\tlinksList[ii] = cleanPBLink(t, link)\n\t\t}\n\t\tnn[\"Links\"] = linksList\n\t}\n\treturn nn\n}\n\nfunc _mkcid() cid.Cid {\n\t_, c, _ := cid.CidFromBytes([]byte{1, 85, 0, 5, 0, 1, 2, 3, 4})\n\treturn c\n}\n", "package dagpb\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\n\t\"github.com/ipfs/go-cid\"\n\tipld \"github.com/ipld/go-ipld-prime\"\n\tcidlink \"github.com/ipld/go-ipld-prime/linking/cid\"\n\t\"google.golang.org/protobuf/encoding/protowire\"\n)\n\n// ErrIntOverflow is returned a varint overflows during decode, it indicates\n// malformed data\nvar ErrIntOverflow = fmt.Errorf(\"protobuf: varint overflow\")\n\n// Decode provides an IPLD codec decode interface for DAG-PB data. Provide a\n// compatible NodeAssembler and a byte source to unmarshal a DAG-PB IPLD Node.\n// Use the NodeAssembler from the PBNode type for safest construction\n// (Type.PBNode.NewBuilder()). A Map assembler will also work.\n// This function is registered via the go-ipld-prime link loader for multicodec\n// code 0x70 when this package is invoked via init.\nfunc Decode(na ipld.NodeAssembler, in io.Reader) error {\n\tvar src []byte\n\tif buf, ok := in.(interface{ Bytes() []byte }); ok {\n\t\tsrc = buf.Bytes()\n\t} else {\n\t\tvar err error\n\t\tsrc, err = ioutil.ReadAll(in)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn DecodeBytes(na, src)\n}\n\n// DecodeBytes is like Decode, but it uses an input buffer directly.\n// Decode will grab or read all the bytes from an io.Reader anyway, so this can\n// save having to copy the bytes or create a bytes.Buffer.\nfunc DecodeBytes(na ipld.NodeAssembler, src []byte) error {\n\tremaining := src\n\n\tma, err := na.BeginMap(2)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar links ipld.ListAssembler\n\n\thaveData := false\n\thaveLinks := false\n\tfor {\n\t\tif len(remaining) == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tfieldNum, wireType, n := protowire.ConsumeTag(remaining)\n\t\tif n < 0 {\n\t\t\treturn protowire.ParseError(n)\n\t\t}\n\t\tremaining = remaining[n:]\n\n\t\tif wireType != 2 {\n\t\t\treturn fmt.Errorf(\"protobuf: (PBNode) invalid wireType, expected 2, got %d\", wireType)\n\t\t}\n\n\t\t// Note that we allow Data and Links to come in either order,\n\t\t// since the spec defines that decoding \"should\" accept either form.\n\t\t// This is for backwards compatibility with older IPFS data.\n\n\t\tswitch fieldNum {\n\t\tcase 1:\n\t\t\tif haveData {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBNode) duplicate Data section\")\n\t\t\t}\n\n\t\t\tchunk, n := protowire.ConsumeBytes(remaining)\n\t\t\tif n < 0 {\n\t\t\t\treturn protowire.ParseError(n)\n\t\t\t}\n\t\t\tremaining = remaining[n:]\n\n\t\t\tif links != nil {\n\t\t\t\t// Links came before Data.\n\t\t\t\t// Finish them before we start Data.\n\t\t\t\tif err := links.Finish(); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tlinks = nil\n\t\t\t}\n\n\t\t\tif err := ma.AssembleKey().AssignString(\"Data\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := ma.AssembleValue().AssignBytes(chunk); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\thaveData = true\n\n\t\tcase 2:\n\t\t\tchunk, n := protowire.ConsumeBytes(remaining)\n\t\t\tif n < 0 {\n\t\t\t\treturn protowire.ParseError(n)\n\t\t\t}\n\t\t\tremaining = remaining[n:]\n\n\t\t\tif links == nil {\n\t\t\t\tif haveLinks {\n\t\t\t\t\treturn fmt.Errorf(\"protobuf: (PBNode) duplicate Links section\")\n\t\t\t\t}\n\n\t\t\t\t// The repeated \"Links\" part begins.\n\t\t\t\tif err := ma.AssembleKey().AssignString(\"Links\"); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tlinks, err = ma.AssembleValue().BeginList(0)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurLink, err := links.AssembleValue().BeginMap(3)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := unmarshalLink(chunk, curLink); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := curLink.Finish(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\thaveLinks = true\n\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got %d\", fieldNum)\n\t\t}\n\t}\n\n\tif links != nil {\n\t\t// We had some links at the end, so finish them.\n\t\tif err := links.Finish(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t} else if !haveLinks {\n\t\t// We didn't have any links.\n\t\t// Since we always want a Links field, add one here.\n\t\tif err := ma.AssembleKey().AssignString(\"Links\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlinks, err := ma.AssembleValue().BeginList(0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := links.Finish(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn ma.Finish()\n}\n\nfunc unmarshalLink(remaining []byte, ma ipld.MapAssembler) error {\n\thaveHash := false\n\thaveName := false\n\thaveTsize := false\n\tfor {\n\t\tif len(remaining) == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tfieldNum, wireType, n := protowire.ConsumeTag(remaining)\n\t\tif n < 0 {\n\t\t\treturn protowire.ParseError(n)\n\t\t}\n\t\tremaining = remaining[n:]\n\n\t\tswitch fieldNum {\n\t\tcase 1:\n\t\t\tif haveHash {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) duplicate Hash section\")\n\t\t\t}\n\t\t\tif haveName {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) invalid order, found Name before Hash\")\n\t\t\t}\n\t\t\tif haveTsize {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) invalid order, found Tsize before Hash\")\n\t\t\t}\n\t\t\tif wireType != 2 {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) wrong wireType (%d) for Hash\", wireType)\n\t\t\t}\n\n\t\t\tchunk, n := protowire.ConsumeBytes(remaining)\n\t\t\tif n < 0 {\n\t\t\t\treturn protowire.ParseError(n)\n\t\t\t}\n\t\t\tremaining = remaining[n:]\n\n\t\t\t_, c, err := cid.CidFromBytes(chunk)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid Hash field found in link, expected CID (%v)\", err)\n\t\t\t}\n\t\t\tif err := ma.AssembleKey().AssignString(\"Hash\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := ma.AssembleValue().AssignLink(cidlink.Link{Cid: c}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\thaveHash = true\n\n\t\tcase 2:\n\t\t\tif haveName {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) duplicate Name section\")\n\t\t\t}\n\t\t\tif haveTsize {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) invalid order, found Tsize before Name\")\n\t\t\t}\n\t\t\tif wireType != 2 {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) wrong wireType (%d) for Name\", wireType)\n\t\t\t}\n\n\t\t\tchunk, n := protowire.ConsumeBytes(remaining)\n\t\t\tif n < 0 {\n\t\t\t\treturn protowire.ParseError(n)\n\t\t\t}\n\t\t\tremaining = remaining[n:]\n\n\t\t\tif err := ma.AssembleKey().AssignString(\"Name\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := ma.AssembleValue().AssignString(string(chunk)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\thaveName = true\n\n\t\tcase 3:\n\t\t\tif haveTsize {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) duplicate Tsize section\")\n\t\t\t}\n\t\t\tif wireType != 0 {\n\t\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) wrong wireType (%d) for Tsize\", wireType)\n\t\t\t}\n\n\t\t\tv, n := protowire.ConsumeVarint(remaining)\n\t\t\tif n < 0 {\n\t\t\t\treturn protowire.ParseError(n)\n\t\t\t}\n\t\t\tremaining = remaining[n:]\n\n\t\t\tif err := ma.AssembleKey().AssignString(\"Tsize\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := ma.AssembleValue().AssignInt(int64(v)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\thaveTsize = true\n\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got %d\", fieldNum)\n\t\t}\n\t}\n\n\tif !haveHash {\n\t\treturn fmt.Errorf(\"invalid Hash field found in link, expected CID\")\n\t}\n\n\treturn nil\n}\n"], "filenames": ["compat_test.go", "unmarshal.go"], "buggy_code_start_loc": [34, 101], "buggy_code_end_loc": [232, 130], "fixing_code_start_loc": [35, 101], "fixing_code_end_loc": [248, 129], "type": "CWE-119", "message": "The dag-pb codec can panic when decoding invalid blocks.", "other": {"cve": {"id": "CVE-2022-2584", "sourceIdentifier": "security@golang.org", "published": "2022-12-27T22:15:12.653", "lastModified": "2023-01-06T15:06:15.000", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The dag-pb codec can panic when decoding invalid blocks."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}, {"source": "security@golang.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:protocol:go-codec-dagpb:*:*:*:*:*:go:*:*", "versionEndExcluding": "1.3.1", "matchCriteriaId": "8B80475C-B409-4404-AB91-9EFDD09149A3"}]}]}], "references": [{"url": "https://github.com/ipld/go-codec-dagpb/commit/a17ace35cc760a2698645c09868f9050fa219f57", "source": "security@golang.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://pkg.go.dev/vuln/GO-2022-0422", "source": "security@golang.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ipld/go-codec-dagpb/commit/a17ace35cc760a2698645c09868f9050fa219f57"}}