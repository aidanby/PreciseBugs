{"buggy_code": ["//! A `Source` for registry-based packages.\n//!\n//! # What's a Registry?\n//!\n//! [Registries] are central locations where packages can be uploaded to,\n//! discovered, and searched for. The purpose of a registry is to have a\n//! location that serves as permanent storage for versions of a crate over time.\n//!\n//! Compared to git sources (see [`GitSource`]), a registry provides many\n//! packages as well as many versions simultaneously. Git sources can also\n//! have commits deleted through rebasings where registries cannot have their\n//! versions deleted.\n//!\n//! In Cargo, [`RegistryData`] is an abstraction over each kind of actual\n//! registry, and [`RegistrySource`] connects those implementations to\n//! [`Source`] trait. Two prominent features these abstractions provide are\n//!\n//! * A way to query the metadata of a package from a registry. The metadata\n//!   comes from the index.\n//! * A way to download package contents (a.k.a source files) that are required\n//!   when building the package itself.\n//!\n//! We'll cover each functionality later.\n//!\n//! [Registries]: https://doc.rust-lang.org/nightly/cargo/reference/registries.html\n//! [`GitSource`]: super::GitSource\n//!\n//! # Different Kinds of Registries\n//!\n//! Cargo provides multiple kinds of registries. Each of them serves the index\n//! and package contents in a slightly different way. Namely,\n//!\n//! * [`LocalRegistry`] --- Serves the index and package contents entirely on\n//!   a local filesystem.\n//! * [`RemoteRegistry`] --- Serves the index ahead of time from a Git\n//!   repository, and package contents are downloaded as needed.\n//! * [`HttpRegistry`] --- Serves both the index and package contents on demand\n//!   over a HTTP-based registry API. This is the default starting from 1.70.0.\n//!\n//! Each registry has its own [`RegistryData`] implementation, and can be\n//! created from either [`RegistrySource::local`] or [`RegistrySource::remote`].\n//!\n//! [`LocalRegistry`]: local::LocalRegistry\n//! [`RemoteRegistry`]: remote::RemoteRegistry\n//! [`HttpRegistry`]: http_remote::HttpRegistry\n//!\n//! # The Index of a Registry\n//!\n//! One of the major difficulties with a registry is that hosting so many\n//! packages may quickly run into performance problems when dealing with\n//! dependency graphs. It's infeasible for cargo to download the entire contents\n//! of the registry just to resolve one package's dependencies, for example. As\n//! a result, cargo needs some efficient method of querying what packages are\n//! available on a registry, what versions are available, and what the\n//! dependencies for each version is.\n//!\n//! To solve the problem, a registry must provide an index of package metadata.\n//! The index of a registry is essentially an easily query-able version of the\n//! registry's database for a list of versions of a package as well as a list\n//! of dependencies for each version. The exact format of the index is\n//! described later.\n//!\n//! See the [`index`] module for topics about the management, parsing, caching,\n//! and versioning for the on-disk index.\n//!\n//! ## The Format of The Index\n//!\n//! The index is a store for the list of versions for all packages known, so its\n//! format on disk is optimized slightly to ensure that `ls registry` doesn't\n//! produce a list of all packages ever known. The index also wants to ensure\n//! that there's not a million files which may actually end up hitting\n//! filesystem limits at some point. To this end, a few decisions were made\n//! about the format of the registry:\n//!\n//! 1. Each crate will have one file corresponding to it. Each version for a\n//!    crate will just be a line in this file (see [`IndexPackage`] for its\n//!    representation).\n//! 2. There will be two tiers of directories for crate names, under which\n//!    crates corresponding to those tiers will be located.\n//!    (See [`cargo_util::registry::make_dep_path`] for the implementation of\n//!    this layout hierarchy.)\n//!\n//! As an example, this is an example hierarchy of an index:\n//!\n//! ```notrust\n//! .\n//! \u251c\u2500\u2500 3\n//! \u2502\u00a0\u00a0 \u2514\u2500\u2500 u\n//! \u2502\u00a0\u00a0     \u2514\u2500\u2500 url\n//! \u251c\u2500\u2500 bz\n//! \u2502\u00a0\u00a0 \u2514\u2500\u2500 ip\n//! \u2502\u00a0\u00a0     \u2514\u2500\u2500 bzip2\n//! \u251c\u2500\u2500 config.json\n//! \u251c\u2500\u2500 en\n//! \u2502\u00a0\u00a0 \u2514\u2500\u2500 co\n//! \u2502\u00a0\u00a0     \u2514\u2500\u2500 encoding\n//! \u2514\u2500\u2500 li\n//!  \u00a0\u00a0 \u251c\u2500\u2500 bg\n//!  \u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 libgit2\n//!  \u00a0\u00a0 \u2514\u2500\u2500 nk\n//!  \u00a0\u00a0     \u2514\u2500\u2500 link-config\n//! ```\n//!\n//! The root of the index contains a `config.json` file with a few entries\n//! corresponding to the registry (see [`RegistryConfig`] below).\n//!\n//! Otherwise, there are three numbered directories (1, 2, 3) for crates with\n//! names 1, 2, and 3 characters in length. The 1/2 directories simply have the\n//! crate files underneath them, while the 3 directory is sharded by the first\n//! letter of the crate name.\n//!\n//! Otherwise the top-level directory contains many two-letter directory names,\n//! each of which has many sub-folders with two letters. At the end of all these\n//! are the actual crate files themselves.\n//!\n//! The purpose of this layout is to hopefully cut down on `ls` sizes as well as\n//! efficient lookup based on the crate name itself.\n//!\n//! See [The Cargo Book: Registry Index][registry-index] for the public\n//! interface on the index format.\n//!\n//! [registry-index]: https://doc.rust-lang.org/nightly/cargo/reference/registry-index.html\n//!\n//! ## The Index Files\n//!\n//! Each file in the index is the history of one crate over time. Each line in\n//! the file corresponds to one version of a crate, stored in JSON format (see\n//! the [`IndexPackage`] structure).\n//!\n//! As new versions are published, new lines are appended to this file. **The\n//! only modifications to this file that should happen over time are yanks of a\n//! particular version.**\n//!\n//! # Downloading Packages\n//!\n//! The purpose of the index was to provide an efficient method to resolve the\n//! dependency graph for a package. After resolution has been performed, we need\n//! to download the contents of packages so we can read the full manifest and\n//! build the source code.\n//!\n//! To accomplish this, [`RegistryData::download`] will \"make\" an HTTP request\n//! per-package requested to download tarballs into a local cache. These\n//! tarballs will then be unpacked into a destination folder.\n//!\n//! Note that because versions uploaded to the registry are frozen forever that\n//! the HTTP download and unpacking can all be skipped if the version has\n//! already been downloaded and unpacked. This caching allows us to only\n//! download a package when absolutely necessary.\n//!\n//! # Filesystem Hierarchy\n//!\n//! Overall, the `$HOME/.cargo` looks like this when talking about the registry\n//! (remote registries, specifically):\n//!\n//! ```notrust\n//! # A folder under which all registry metadata is hosted (similar to\n//! # $HOME/.cargo/git)\n//! $HOME/.cargo/registry/\n//!\n//!     # For each registry that cargo knows about (keyed by hostname + hash)\n//!     # there is a folder which is the checked out version of the index for\n//!     # the registry in this location. Note that this is done so cargo can\n//!     # support multiple registries simultaneously\n//!     index/\n//!         registry1-<hash>/\n//!         registry2-<hash>/\n//!         ...\n//!\n//!     # This folder is a cache for all downloaded tarballs (`.crate` file)\n//!     # from a registry. Once downloaded and verified, a tarball never changes.\n//!     cache/\n//!         registry1-<hash>/<pkg>-<version>.crate\n//!         ...\n//!\n//!     # Location in which all tarballs are unpacked. Each tarball is known to\n//!     # be frozen after downloading, so transitively this folder is also\n//!     # frozen once its unpacked (it's never unpacked again)\n//!     # CAVEAT: They are not read-only. See rust-lang/cargo#9455.\n//!     src/\n//!         registry1-<hash>/<pkg>-<version>/...\n//!         ...\n//! ```\n//!\n//! [`IndexPackage`]: index::IndexPackage\n\nuse std::collections::HashSet;\nuse std::fs::{File, OpenOptions};\nuse std::io::{self, Write};\nuse std::path::{Path, PathBuf};\nuse std::task::{ready, Poll};\n\nuse anyhow::Context as _;\nuse cargo_util::paths::{self, exclude_from_backups_and_indexing};\nuse flate2::read::GzDecoder;\nuse log::debug;\nuse serde::Deserialize;\nuse tar::Archive;\n\nuse crate::core::dependency::Dependency;\nuse crate::core::source::MaybePackage;\nuse crate::core::{Package, PackageId, QueryKind, Source, SourceId, Summary};\nuse crate::sources::PathSource;\nuse crate::util::hex;\nuse crate::util::network::PollExt;\nuse crate::util::{\n    restricted_names, CargoResult, Config, Filesystem, LimitErrorReader, OptVersionReq,\n};\n\n/// The `.cargo-ok` file is used to track if the source is already unpacked.\n/// See [`RegistrySource::unpack_package`] for more.\n///\n/// Not to be confused with `.cargo-ok` file in git sources.\nconst PACKAGE_SOURCE_LOCK: &str = \".cargo-ok\";\n\npub const CRATES_IO_INDEX: &str = \"https://github.com/rust-lang/crates.io-index\";\npub const CRATES_IO_HTTP_INDEX: &str = \"sparse+https://index.crates.io/\";\npub const CRATES_IO_REGISTRY: &str = \"crates-io\";\npub const CRATES_IO_DOMAIN: &str = \"crates.io\";\n\n/// A [`Source`] implementation for a local or a remote registry.\n///\n/// This contains common functionality that is shared between each registry\n/// kind, with the registry-specific logic implemented as part of the\n/// [`RegistryData`] trait referenced via the `ops` field.\n///\n/// For general concepts of registries, see the [module-level documentation](crate::sources::registry).\npub struct RegistrySource<'cfg> {\n    /// The unique identifier of this source.\n    source_id: SourceId,\n    /// The path where crate files are extracted (`$CARGO_HOME/registry/src/$REG-HASH`).\n    src_path: Filesystem,\n    /// Local reference to [`Config`] for convenience.\n    config: &'cfg Config,\n    /// Abstraction for interfacing to the different registry kinds.\n    ops: Box<dyn RegistryData + 'cfg>,\n    /// Interface for managing the on-disk index.\n    index: index::RegistryIndex<'cfg>,\n    /// A set of packages that should be allowed to be used, even if they are\n    /// yanked.\n    ///\n    /// This is populated from the entries in `Cargo.lock` to ensure that\n    /// `cargo update -p somepkg` won't unlock yanked entries in `Cargo.lock`.\n    /// Otherwise, the resolver would think that those entries no longer\n    /// exist, and it would trigger updates to unrelated packages.\n    yanked_whitelist: HashSet<PackageId>,\n}\n\n/// The [`config.json`] file stored in the index.\n///\n/// The config file may look like:\n///\n/// ```json\n/// {\n///     \"dl\": \"https://example.com/api/{crate}/{version}/download\",\n///     \"api\": \"https://example.com/api\",\n///     \"auth-required\": false             # unstable feature (RFC 3139)\n/// }\n/// ```\n///\n/// [`config.json`]: https://doc.rust-lang.org/nightly/cargo/reference/registry-index.html#index-configuration\n#[derive(Deserialize, Debug, Clone)]\n#[serde(rename_all = \"kebab-case\")]\npub struct RegistryConfig {\n    /// Download endpoint for all crates.\n    ///\n    /// The string is a template which will generate the download URL for the\n    /// tarball of a specific version of a crate. The substrings `{crate}` and\n    /// `{version}` will be replaced with the crate's name and version\n    /// respectively.  The substring `{prefix}` will be replaced with the\n    /// crate's prefix directory name, and the substring `{lowerprefix}` will\n    /// be replaced with the crate's prefix directory name converted to\n    /// lowercase. The substring `{sha256-checksum}` will be replaced with the\n    /// crate's sha256 checksum.\n    ///\n    /// For backwards compatibility, if the string does not contain any\n    /// markers (`{crate}`, `{version}`, `{prefix}`, or `{lowerprefix}`), it\n    /// will be extended with `/{crate}/{version}/download` to\n    /// support registries like crates.io which were created before the\n    /// templating setup was created.\n    ///\n    /// For more on the template of the download URL, see [Index Configuration](\n    /// https://doc.rust-lang.org/nightly/cargo/reference/registry-index.html#index-configuration).\n    pub dl: String,\n\n    /// API endpoint for the registry. This is what's actually hit to perform\n    /// operations like yanks, owner modifications, publish new crates, etc.\n    /// If this is None, the registry does not support API commands.\n    pub api: Option<String>,\n\n    /// Whether all operations require authentication. See [RFC 3139].\n    ///\n    /// [RFC 3139]: https://rust-lang.github.io/rfcs/3139-cargo-alternative-registry-auth.html\n    #[serde(default)]\n    pub auth_required: bool,\n}\n\n/// Result from loading data from a registry.\npub enum LoadResponse {\n    /// The cache is valid. The cached data should be used.\n    CacheValid,\n\n    /// The cache is out of date. Returned data should be used.\n    Data {\n        raw_data: Vec<u8>,\n        /// Version of this data to determine whether it is out of date.\n        index_version: Option<String>,\n    },\n\n    /// The requested crate was found.\n    NotFound,\n}\n\n/// An abstract interface to handle both a local and and remote registry.\n///\n/// This allows [`RegistrySource`] to abstractly handle each registry kind.\n///\n/// For general concepts of registries, see the [module-level documentation](crate::sources::registry).\npub trait RegistryData {\n    /// Performs initialization for the registry.\n    ///\n    /// This should be safe to call multiple times, the implementation is\n    /// expected to not do any work if it is already prepared.\n    fn prepare(&self) -> CargoResult<()>;\n\n    /// Returns the path to the index.\n    ///\n    /// Note that different registries store the index in different formats\n    /// (remote = git, http & local = files).\n    fn index_path(&self) -> &Filesystem;\n\n    /// Loads the JSON for a specific named package from the index.\n    ///\n    /// * `root` is the root path to the index.\n    /// * `path` is the relative path to the package to load (like `ca/rg/cargo`).\n    /// * `index_version` is the version of the requested crate data currently\n    ///    in cache. This is useful for checking if a local cache is outdated.\n    fn load(\n        &mut self,\n        root: &Path,\n        path: &Path,\n        index_version: Option<&str>,\n    ) -> Poll<CargoResult<LoadResponse>>;\n\n    /// Loads the `config.json` file and returns it.\n    ///\n    /// Local registries don't have a config, and return `None`.\n    fn config(&mut self) -> Poll<CargoResult<Option<RegistryConfig>>>;\n\n    /// Invalidates locally cached data.\n    fn invalidate_cache(&mut self);\n\n    /// If quiet, the source should not display any progress or status messages.\n    fn set_quiet(&mut self, quiet: bool);\n\n    /// Is the local cached data up-to-date?\n    fn is_updated(&self) -> bool;\n\n    /// Prepare to start downloading a `.crate` file.\n    ///\n    /// Despite the name, this doesn't actually download anything. If the\n    /// `.crate` is already downloaded, then it returns [`MaybeLock::Ready`].\n    /// If it hasn't been downloaded, then it returns [`MaybeLock::Download`]\n    /// which contains the URL to download. The [`crate::core::package::Downloads`]\n    /// system handles the actual download process. After downloading, it\n    /// calls [`Self::finish_download`] to save the downloaded file.\n    ///\n    /// `checksum` is currently only used by local registries to verify the\n    /// file contents (because local registries never actually download\n    /// anything). Remote registries will validate the checksum in\n    /// `finish_download`. For already downloaded `.crate` files, it does not\n    /// validate the checksum, assuming the filesystem does not suffer from\n    /// corruption or manipulation.\n    fn download(&mut self, pkg: PackageId, checksum: &str) -> CargoResult<MaybeLock>;\n\n    /// Finish a download by saving a `.crate` file to disk.\n    ///\n    /// After [`crate::core::package::Downloads`] has finished a download,\n    /// it will call this to save the `.crate` file. This is only relevant\n    /// for remote registries. This should validate the checksum and save\n    /// the given data to the on-disk cache.\n    ///\n    /// Returns a [`File`] handle to the `.crate` file, positioned at the start.\n    fn finish_download(&mut self, pkg: PackageId, checksum: &str, data: &[u8])\n        -> CargoResult<File>;\n\n    /// Returns whether or not the `.crate` file is already downloaded.\n    fn is_crate_downloaded(&self, _pkg: PackageId) -> bool {\n        true\n    }\n\n    /// Validates that the global package cache lock is held.\n    ///\n    /// Given the [`Filesystem`], this will make sure that the package cache\n    /// lock is held. If not, it will panic. See\n    /// [`Config::acquire_package_cache_lock`] for acquiring the global lock.\n    ///\n    /// Returns the [`Path`] to the [`Filesystem`].\n    fn assert_index_locked<'a>(&self, path: &'a Filesystem) -> &'a Path;\n\n    /// Block until all outstanding Poll::Pending requests are Poll::Ready.\n    fn block_until_ready(&mut self) -> CargoResult<()>;\n}\n\n/// The status of [`RegistryData::download`] which indicates if a `.crate`\n/// file has already been downloaded, or if not then the URL to download.\npub enum MaybeLock {\n    /// The `.crate` file is already downloaded. [`File`] is a handle to the\n    /// opened `.crate` file on the filesystem.\n    Ready(File),\n    /// The `.crate` file is not downloaded, here's the URL to download it from.\n    ///\n    /// `descriptor` is just a text string to display to the user of what is\n    /// being downloaded.\n    Download {\n        url: String,\n        descriptor: String,\n        authorization: Option<String>,\n    },\n}\n\nmod download;\nmod http_remote;\nmod index;\nmod local;\nmod remote;\n\n/// Generates a unique name for [`SourceId`] to have a unique path to put their\n/// index files.\nfn short_name(id: SourceId, is_shallow: bool) -> String {\n    let hash = hex::short_hash(&id);\n    let ident = id.url().host_str().unwrap_or(\"\").to_string();\n    let mut name = format!(\"{}-{}\", ident, hash);\n    if is_shallow {\n        name.push_str(\"-shallow\");\n    }\n    name\n}\n\nimpl<'cfg> RegistrySource<'cfg> {\n    /// Creates a [`Source`] of a \"remote\" registry.\n    /// It could be either an HTTP-based [`http_remote::HttpRegistry`] or\n    /// a Git-based [`remote::RemoteRegistry`].\n    ///\n    /// * `yanked_whitelist` --- Packages allowed to be used, even if they are yanked.\n    pub fn remote(\n        source_id: SourceId,\n        yanked_whitelist: &HashSet<PackageId>,\n        config: &'cfg Config,\n    ) -> CargoResult<RegistrySource<'cfg>> {\n        assert!(source_id.is_remote_registry());\n        let name = short_name(\n            source_id,\n            config\n                .cli_unstable()\n                .gitoxide\n                .map_or(false, |gix| gix.fetch && gix.shallow_index)\n                && !source_id.is_sparse(),\n        );\n        let ops = if source_id.is_sparse() {\n            Box::new(http_remote::HttpRegistry::new(source_id, config, &name)?) as Box<_>\n        } else {\n            Box::new(remote::RemoteRegistry::new(source_id, config, &name)) as Box<_>\n        };\n\n        Ok(RegistrySource::new(\n            source_id,\n            config,\n            &name,\n            ops,\n            yanked_whitelist,\n        ))\n    }\n\n    /// Creates a [`Source`] of a local registry, with [`local::LocalRegistry`] under the hood.\n    ///\n    /// * `path` --- The root path of a local registry on the file system.\n    /// * `yanked_whitelist` --- Packages allowed to be used, even if they are yanked.\n    pub fn local(\n        source_id: SourceId,\n        path: &Path,\n        yanked_whitelist: &HashSet<PackageId>,\n        config: &'cfg Config,\n    ) -> RegistrySource<'cfg> {\n        let name = short_name(source_id, false);\n        let ops = local::LocalRegistry::new(path, config, &name);\n        RegistrySource::new(source_id, config, &name, Box::new(ops), yanked_whitelist)\n    }\n\n    /// Creates a source of a registry. This is a inner helper function.\n    ///\n    /// * `name` --- Name of a path segment which may affect where `.crate`\n    ///   tarballs, the registry index and cache are stored. Expect to be unique.\n    /// * `ops` --- The underlying [`RegistryData`] type.\n    /// * `yanked_whitelist` --- Packages allowed to be used, even if they are yanked.\n    fn new(\n        source_id: SourceId,\n        config: &'cfg Config,\n        name: &str,\n        ops: Box<dyn RegistryData + 'cfg>,\n        yanked_whitelist: &HashSet<PackageId>,\n    ) -> RegistrySource<'cfg> {\n        RegistrySource {\n            src_path: config.registry_source_path().join(name),\n            config,\n            source_id,\n            index: index::RegistryIndex::new(source_id, ops.index_path(), config),\n            yanked_whitelist: yanked_whitelist.clone(),\n            ops,\n        }\n    }\n\n    /// Decode the [configuration](RegistryConfig) stored within the registry.\n    ///\n    /// This requires that the index has been at least checked out.\n    pub fn config(&mut self) -> Poll<CargoResult<Option<RegistryConfig>>> {\n        self.ops.config()\n    }\n\n    /// Unpacks a downloaded package into a location where it's ready to be\n    /// compiled.\n    ///\n    /// No action is taken if the source looks like it's already unpacked.\n    ///\n    /// # History of interruption detection with `.cargo-ok` file\n    ///\n    /// Cargo has always included a `.cargo-ok` file ([`PACKAGE_SOURCE_LOCK`])\n    /// to detect if extraction was interrupted, but it was originally empty.\n    ///\n    /// In 1.34, Cargo was changed to create the `.cargo-ok` file before it\n    /// started extraction to implement fine-grained locking. After it was\n    /// finished extracting, it wrote two bytes to indicate it was complete.\n    /// It would use the length check to detect if it was possibly interrupted.\n    ///\n    /// In 1.36, Cargo changed to not use fine-grained locking, and instead used\n    /// a global lock. The use of `.cargo-ok` was no longer needed for locking\n    /// purposes, but was kept to detect when extraction was interrupted.\n    ///\n    /// In 1.49, Cargo changed to not create the `.cargo-ok` file before it\n    /// started extraction to deal with `.crate` files that inexplicably had\n    /// a `.cargo-ok` file in them.\n    ///\n    /// In 1.64, Cargo changed to detect `.crate` files with `.cargo-ok` files\n    /// in them in response to [CVE-2022-36113], which dealt with malicious\n    /// `.crate` files making `.cargo-ok` a symlink causing cargo to write \"ok\"\n    /// to any arbitrary file on the filesystem it has permission to.\n    ///\n    /// This is all a long-winded way of explaining the circumstances that might\n    /// cause a directory to contain a `.cargo-ok` file that is empty or\n    /// otherwise corrupted. Either this was extracted by a version of Rust\n    /// before 1.34, in which case everything should be fine. However, an empty\n    /// file created by versions 1.36 to 1.49 indicates that the extraction was\n    /// interrupted and that we need to start again.\n    ///\n    /// Another possibility is that the filesystem is simply corrupted, in\n    /// which case deleting the directory might be the safe thing to do. That\n    /// is probably unlikely, though.\n    ///\n    /// To be safe, we deletes the directory and starts over again if an empty\n    /// `.cargo-ok` file is found.\n    ///\n    /// [CVE-2022-36113]: https://blog.rust-lang.org/2022/09/14/cargo-cves.html#arbitrary-file-corruption-cve-2022-36113\n    fn unpack_package(&self, pkg: PackageId, tarball: &File) -> CargoResult<PathBuf> {\n        let package_dir = format!(\"{}-{}\", pkg.name(), pkg.version());\n        let dst = self.src_path.join(&package_dir);\n        let path = dst.join(PACKAGE_SOURCE_LOCK);\n        let path = self.config.assert_package_cache_locked(&path);\n        let unpack_dir = path.parent().unwrap();\n        match path.metadata() {\n            Ok(meta) if meta.len() > 0 => return Ok(unpack_dir.to_path_buf()),\n            Ok(_meta) => {\n                // See comment of `unpack_package` about why removing all stuff.\n                log::warn!(\"unexpected length of {path:?}, clearing cache\");\n                paths::remove_dir_all(dst.as_path_unlocked())?;\n            }\n            Err(e) if e.kind() == io::ErrorKind::NotFound => {}\n            Err(e) => anyhow::bail!(\"failed to access package completion {path:?}: {e}\"),\n        }\n        dst.create_dir()?;\n        let mut tar = {\n            let size_limit = max_unpack_size(self.config, tarball.metadata()?.len());\n            let gz = GzDecoder::new(tarball);\n            let gz = LimitErrorReader::new(gz, size_limit);\n            Archive::new(gz)\n        };\n        let prefix = unpack_dir.file_name().unwrap();\n        let parent = unpack_dir.parent().unwrap();\n        for entry in tar.entries()? {\n            let mut entry = entry.with_context(|| \"failed to iterate over archive\")?;\n            let entry_path = entry\n                .path()\n                .with_context(|| \"failed to read entry path\")?\n                .into_owned();\n\n            // We're going to unpack this tarball into the global source\n            // directory, but we want to make sure that it doesn't accidentally\n            // (or maliciously) overwrite source code from other crates. Cargo\n            // itself should never generate a tarball that hits this error, and\n            // crates.io should also block uploads with these sorts of tarballs,\n            // but be extra sure by adding a check here as well.\n            if !entry_path.starts_with(prefix) {\n                anyhow::bail!(\n                    \"invalid tarball downloaded, contains \\\n                     a file at {:?} which isn't under {:?}\",\n                    entry_path,\n                    prefix\n                )\n            }\n            // Prevent unpacking the lockfile from the crate itself.\n            if entry_path\n                .file_name()\n                .map_or(false, |p| p == PACKAGE_SOURCE_LOCK)\n            {\n                continue;\n            }\n            // Unpacking failed\n            let mut result = entry.unpack_in(parent).map_err(anyhow::Error::from);\n            if cfg!(windows) && restricted_names::is_windows_reserved_path(&entry_path) {\n                result = result.with_context(|| {\n                    format!(\n                        \"`{}` appears to contain a reserved Windows path, \\\n                        it cannot be extracted on Windows\",\n                        entry_path.display()\n                    )\n                });\n            }\n            result\n                .with_context(|| format!(\"failed to unpack entry at `{}`\", entry_path.display()))?;\n        }\n\n        // Now that we've finished unpacking, create and write to the lock file to indicate that\n        // unpacking was successful.\n        let mut ok = OpenOptions::new()\n            .create_new(true)\n            .read(true)\n            .write(true)\n            .open(&path)\n            .with_context(|| format!(\"failed to open `{}`\", path.display()))?;\n        write!(ok, \"ok\")?;\n\n        Ok(unpack_dir.to_path_buf())\n    }\n\n    /// Turns the downloaded `.crate` tarball file into a [`Package`].\n    ///\n    /// This unconditionally sets checksum for the returned package, so it\n    /// should only be called after doing integrity check. That is to say,\n    /// you need to call either [`RegistryData::download`] or\n    /// [`RegistryData::finish_download`] before calling this method.\n    fn get_pkg(&mut self, package: PackageId, path: &File) -> CargoResult<Package> {\n        let path = self\n            .unpack_package(package, path)\n            .with_context(|| format!(\"failed to unpack package `{}`\", package))?;\n        let mut src = PathSource::new(&path, self.source_id, self.config);\n        src.update()?;\n        let mut pkg = match src.download(package)? {\n            MaybePackage::Ready(pkg) => pkg,\n            MaybePackage::Download { .. } => unreachable!(),\n        };\n\n        // After we've loaded the package configure its summary's `checksum`\n        // field with the checksum we know for this `PackageId`.\n        let req = OptVersionReq::exact(package.version());\n        let summary_with_cksum = self\n            .index\n            .summaries(&package.name(), &req, &mut *self.ops)?\n            .expect(\"a downloaded dep now pending!?\")\n            .map(|s| s.summary.clone())\n            .next()\n            .expect(\"summary not found\");\n        if let Some(cksum) = summary_with_cksum.checksum() {\n            pkg.manifest_mut()\n                .summary_mut()\n                .set_checksum(cksum.to_string());\n        }\n\n        Ok(pkg)\n    }\n}\n\nimpl<'cfg> Source for RegistrySource<'cfg> {\n    fn query(\n        &mut self,\n        dep: &Dependency,\n        kind: QueryKind,\n        f: &mut dyn FnMut(Summary),\n    ) -> Poll<CargoResult<()>> {\n        // If this is a precise dependency, then it came from a lock file and in\n        // theory the registry is known to contain this version. If, however, we\n        // come back with no summaries, then our registry may need to be\n        // updated, so we fall back to performing a lazy update.\n        if kind == QueryKind::Exact && dep.source_id().precise().is_some() && !self.ops.is_updated()\n        {\n            debug!(\"attempting query without update\");\n            let mut called = false;\n            ready!(self.index.query_inner(\n                &dep.package_name(),\n                dep.version_req(),\n                &mut *self.ops,\n                &self.yanked_whitelist,\n                &mut |s| {\n                    if dep.matches(&s) {\n                        called = true;\n                        f(s);\n                    }\n                },\n            ))?;\n            if called {\n                Poll::Ready(Ok(()))\n            } else {\n                debug!(\"falling back to an update\");\n                self.invalidate_cache();\n                Poll::Pending\n            }\n        } else {\n            let mut called = false;\n            ready!(self.index.query_inner(\n                &dep.package_name(),\n                dep.version_req(),\n                &mut *self.ops,\n                &self.yanked_whitelist,\n                &mut |s| {\n                    let matched = match kind {\n                        QueryKind::Exact => dep.matches(&s),\n                        QueryKind::Fuzzy => true,\n                    };\n                    if matched {\n                        f(s);\n                        called = true;\n                    }\n                }\n            ))?;\n            if called {\n                return Poll::Ready(Ok(()));\n            }\n            let mut any_pending = false;\n            if kind == QueryKind::Fuzzy {\n                // Attempt to handle misspellings by searching for a chain of related\n                // names to the original name. The resolver will later\n                // reject any candidates that have the wrong name, and with this it'll\n                // along the way produce helpful \"did you mean?\" suggestions.\n                // For now we only try the canonical lysing `-` to `_` and vice versa.\n                // More advanced fuzzy searching become in the future.\n                for name_permutation in [\n                    dep.package_name().replace('-', \"_\"),\n                    dep.package_name().replace('_', \"-\"),\n                ] {\n                    if name_permutation.as_str() == dep.package_name().as_str() {\n                        continue;\n                    }\n                    any_pending |= self\n                        .index\n                        .query_inner(\n                            &name_permutation,\n                            dep.version_req(),\n                            &mut *self.ops,\n                            &self.yanked_whitelist,\n                            f,\n                        )?\n                        .is_pending();\n                }\n            }\n            if any_pending {\n                Poll::Pending\n            } else {\n                Poll::Ready(Ok(()))\n            }\n        }\n    }\n\n    fn supports_checksums(&self) -> bool {\n        true\n    }\n\n    fn requires_precise(&self) -> bool {\n        false\n    }\n\n    fn source_id(&self) -> SourceId {\n        self.source_id\n    }\n\n    fn invalidate_cache(&mut self) {\n        self.index.clear_summaries_cache();\n        self.ops.invalidate_cache();\n    }\n\n    fn set_quiet(&mut self, quiet: bool) {\n        self.ops.set_quiet(quiet);\n    }\n\n    fn download(&mut self, package: PackageId) -> CargoResult<MaybePackage> {\n        let hash = loop {\n            match self.index.hash(package, &mut *self.ops)? {\n                Poll::Pending => self.block_until_ready()?,\n                Poll::Ready(hash) => break hash,\n            }\n        };\n        match self.ops.download(package, hash)? {\n            MaybeLock::Ready(file) => self.get_pkg(package, &file).map(MaybePackage::Ready),\n            MaybeLock::Download {\n                url,\n                descriptor,\n                authorization,\n            } => Ok(MaybePackage::Download {\n                url,\n                descriptor,\n                authorization,\n            }),\n        }\n    }\n\n    fn finish_download(&mut self, package: PackageId, data: Vec<u8>) -> CargoResult<Package> {\n        let hash = loop {\n            match self.index.hash(package, &mut *self.ops)? {\n                Poll::Pending => self.block_until_ready()?,\n                Poll::Ready(hash) => break hash,\n            }\n        };\n        let file = self.ops.finish_download(package, hash, &data)?;\n        self.get_pkg(package, &file)\n    }\n\n    fn fingerprint(&self, pkg: &Package) -> CargoResult<String> {\n        Ok(pkg.package_id().version().to_string())\n    }\n\n    fn describe(&self) -> String {\n        self.source_id.display_index()\n    }\n\n    fn add_to_yanked_whitelist(&mut self, pkgs: &[PackageId]) {\n        self.yanked_whitelist.extend(pkgs);\n    }\n\n    fn is_yanked(&mut self, pkg: PackageId) -> Poll<CargoResult<bool>> {\n        self.index.is_yanked(pkg, &mut *self.ops)\n    }\n\n    fn block_until_ready(&mut self) -> CargoResult<()> {\n        // Before starting to work on the registry, make sure that\n        // `<cargo_home>/registry` is marked as excluded from indexing and\n        // backups. Older versions of Cargo didn't do this, so we do it here\n        // regardless of whether `<cargo_home>` exists.\n        //\n        // This does not use `create_dir_all_excluded_from_backups_atomic` for\n        // the same reason: we want to exclude it even if the directory already\n        // exists.\n        //\n        // IO errors in creating and marking it are ignored, e.g. in case we're on a\n        // read-only filesystem.\n        let registry_base = self.config.registry_base_path();\n        let _ = registry_base.create_dir();\n        exclude_from_backups_and_indexing(&registry_base.into_path_unlocked());\n\n        self.ops.block_until_ready()\n    }\n}\n\nimpl RegistryConfig {\n    /// File name of [`RegistryConfig`].\n    const NAME: &str = \"config.json\";\n}\n\n/// Get the maximum upack size that Cargo permits\n/// based on a given `size` of your compressed file.\n///\n/// Returns the larger one between `size * max compression ratio`\n/// and a fixed max unpacked size.\n///\n/// In reality, the compression ratio usually falls in the range of 2:1 to 10:1.\n/// We choose 20:1 to cover almost all possible cases hopefully.\n/// Any ratio higher than this is considered as a zip bomb.\n///\n/// In the future we might want to introduce a configurable size.\n///\n/// Some of the real world data from common compression algorithms:\n///\n/// * <https://www.zlib.net/zlib_tech.html>\n/// * <https://cran.r-project.org/web/packages/brotli/vignettes/brotli-2015-09-22.pdf>\n/// * <https://blog.cloudflare.com/results-experimenting-brotli/>\n/// * <https://tukaani.org/lzma/benchmarks.html>\nfn max_unpack_size(config: &Config, size: u64) -> u64 {\n    const SIZE_VAR: &str = \"__CARGO_TEST_MAX_UNPACK_SIZE\";\n    const RATIO_VAR: &str = \"__CARGO_TEST_MAX_UNPACK_RATIO\";\n    const MAX_UNPACK_SIZE: u64 = 512 * 1024 * 1024; // 512 MiB\n    const MAX_COMPRESSION_RATIO: usize = 20; // 20:1\n\n    let max_unpack_size = if cfg!(debug_assertions) && config.get_env(SIZE_VAR).is_ok() {\n        // For integration test only.\n        config\n            .get_env(SIZE_VAR)\n            .unwrap()\n            .parse()\n            .expect(\"a max unpack size in bytes\")\n    } else {\n        MAX_UNPACK_SIZE\n    };\n    let max_compression_ratio = if cfg!(debug_assertions) && config.get_env(RATIO_VAR).is_ok() {\n        // For integration test only.\n        config\n            .get_env(RATIO_VAR)\n            .unwrap()\n            .parse()\n            .expect(\"a max compression ratio in bytes\")\n    } else {\n        MAX_COMPRESSION_RATIO\n    };\n\n    u64::max(max_unpack_size, size * max_compression_ratio as u64)\n}\n", "use std::fmt;\nuse std::path::{Path, PathBuf};\nuse std::time::Duration;\n\npub use self::canonical_url::CanonicalUrl;\npub use self::config::{homedir, Config, ConfigValue};\npub(crate) use self::counter::MetricsCounter;\npub use self::dependency_queue::DependencyQueue;\npub use self::diagnostic_server::RustfixDiagnosticServer;\npub use self::edit_distance::{closest, closest_msg, edit_distance};\npub use self::errors::CliError;\npub use self::errors::{internal, CargoResult, CliResult};\npub use self::flock::{FileLock, Filesystem};\npub use self::graph::Graph;\npub use self::hasher::StableHasher;\npub use self::hex::{hash_u64, short_hash, to_hex};\npub use self::into_url::IntoUrl;\npub use self::into_url_with_base::IntoUrlWithBase;\npub(crate) use self::io::LimitErrorReader;\npub use self::lockserver::{LockServer, LockServerClient, LockServerStarted};\npub use self::progress::{Progress, ProgressStyle};\npub use self::queue::Queue;\npub use self::restricted_names::validate_package_name;\npub use self::rustc::Rustc;\npub use self::semver_ext::{OptVersionReq, VersionExt, VersionReqExt};\npub use self::to_semver::ToSemver;\npub use self::vcs::{existing_vcs_repo, FossilRepo, GitRepo, HgRepo, PijulRepo};\npub use self::workspace::{\n    add_path_args, path_args, print_available_benches, print_available_binaries,\n    print_available_examples, print_available_packages, print_available_tests,\n};\n\npub mod auth;\nmod canonical_url;\npub mod command_prelude;\npub mod config;\nmod counter;\npub mod cpu;\npub mod credential;\nmod dependency_queue;\npub mod diagnostic_server;\npub mod edit_distance;\npub mod errors;\nmod flock;\npub mod graph;\nmod hasher;\npub mod hex;\npub mod important_paths;\npub mod interning;\npub mod into_url;\nmod into_url_with_base;\nmod io;\npub mod job;\nmod lockserver;\npub mod machine_message;\npub mod network;\npub mod profile;\nmod progress;\nmod queue;\npub mod restricted_names;\npub mod rustc;\nmod semver_ext;\npub mod to_semver;\npub mod toml;\npub mod toml_mut;\nmod vcs;\nmod workspace;\n\npub fn elapsed(duration: Duration) -> String {\n    let secs = duration.as_secs();\n\n    if secs >= 60 {\n        format!(\"{}m {:02}s\", secs / 60, secs % 60)\n    } else {\n        format!(\"{}.{:02}s\", secs, duration.subsec_nanos() / 10_000_000)\n    }\n}\n\n/// Formats a number of bytes into a human readable SI-prefixed size.\n/// Returns a tuple of `(quantity, units)`.\npub fn human_readable_bytes(bytes: u64) -> (f32, &'static str) {\n    static UNITS: [&str; 7] = [\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\"];\n    let bytes = bytes as f32;\n    let i = ((bytes.log2() / 10.0) as usize).min(UNITS.len() - 1);\n    (bytes / 1024_f32.powi(i as i32), UNITS[i])\n}\n\npub fn iter_join_onto<W, I, T>(mut w: W, iter: I, delim: &str) -> fmt::Result\nwhere\n    W: fmt::Write,\n    I: IntoIterator<Item = T>,\n    T: std::fmt::Display,\n{\n    let mut it = iter.into_iter().peekable();\n    while let Some(n) = it.next() {\n        write!(w, \"{}\", n)?;\n        if it.peek().is_some() {\n            write!(w, \"{}\", delim)?;\n        }\n    }\n    Ok(())\n}\n\npub fn iter_join<I, T>(iter: I, delim: &str) -> String\nwhere\n    I: IntoIterator<Item = T>,\n    T: std::fmt::Display,\n{\n    let mut s = String::new();\n    let _ = iter_join_onto(&mut s, iter, delim);\n    s\n}\n\npub fn indented_lines(text: &str) -> String {\n    text.lines()\n        .map(|line| {\n            if line.is_empty() {\n                String::from(\"\\n\")\n            } else {\n                format!(\"  {}\\n\", line)\n            }\n        })\n        .collect()\n}\n\npub fn truncate_with_ellipsis(s: &str, max_width: usize) -> String {\n    // We should truncate at grapheme-boundary and compute character-widths,\n    // yet the dependencies on unicode-segmentation and unicode-width are\n    // not worth it.\n    let mut chars = s.chars();\n    let mut prefix = (&mut chars).take(max_width - 1).collect::<String>();\n    if chars.next().is_some() {\n        prefix.push('\u2026');\n    }\n    prefix\n}\n\n#[cfg(not(windows))]\n#[inline]\npub fn try_canonicalize<P: AsRef<Path>>(path: P) -> std::io::Result<PathBuf> {\n    std::fs::canonicalize(&path)\n}\n\n#[cfg(windows)]\n#[inline]\npub fn try_canonicalize<P: AsRef<Path>>(path: P) -> std::io::Result<PathBuf> {\n    use std::ffi::OsString;\n    use std::io::Error;\n    use std::os::windows::ffi::{OsStrExt, OsStringExt};\n    use std::{io::ErrorKind, ptr};\n    use windows_sys::Win32::Foundation::{GetLastError, SetLastError};\n    use windows_sys::Win32::Storage::FileSystem::GetFullPathNameW;\n\n    // On Windows `canonicalize` may fail, so we fall back to getting an absolute path.\n    std::fs::canonicalize(&path).or_else(|_| {\n        // Return an error if a file does not exist for better compatiblity with `canonicalize`\n        if !path.as_ref().try_exists()? {\n            return Err(Error::new(ErrorKind::NotFound, \"the path was not found\"));\n        }\n\n        // This code is based on the unstable `std::path::absolute` and could be replaced with it\n        // if it's stabilized.\n\n        let path = path.as_ref().as_os_str();\n        let mut path_u16 = Vec::with_capacity(path.len() + 1);\n        path_u16.extend(path.encode_wide());\n        if path_u16.iter().find(|c| **c == 0).is_some() {\n            return Err(Error::new(\n                ErrorKind::InvalidInput,\n                \"strings passed to WinAPI cannot contain NULs\",\n            ));\n        }\n        path_u16.push(0);\n\n        loop {\n            unsafe {\n                SetLastError(0);\n                let len =\n                    GetFullPathNameW(path_u16.as_ptr(), 0, &mut [] as *mut u16, ptr::null_mut());\n                if len == 0 {\n                    let error = GetLastError();\n                    if error != 0 {\n                        return Err(Error::from_raw_os_error(error as i32));\n                    }\n                }\n                let mut result = vec![0u16; len as usize];\n\n                let write_len = GetFullPathNameW(\n                    path_u16.as_ptr(),\n                    result.len().try_into().unwrap(),\n                    result.as_mut_ptr().cast::<u16>(),\n                    ptr::null_mut(),\n                );\n                if write_len == 0 {\n                    let error = GetLastError();\n                    if error != 0 {\n                        return Err(Error::from_raw_os_error(error as i32));\n                    }\n                }\n\n                if write_len <= len {\n                    return Ok(PathBuf::from(OsString::from_wide(\n                        &result[0..(write_len as usize)],\n                    )));\n                }\n            }\n        }\n    })\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_human_readable_bytes() {\n        assert_eq!(human_readable_bytes(0), (0., \"B\"));\n        assert_eq!(human_readable_bytes(8), (8., \"B\"));\n        assert_eq!(human_readable_bytes(1000), (1000., \"B\"));\n        assert_eq!(human_readable_bytes(1024), (1., \"KiB\"));\n        assert_eq!(human_readable_bytes(1024 * 420 + 512), (420.5, \"KiB\"));\n        assert_eq!(human_readable_bytes(1024 * 1024), (1., \"MiB\"));\n        assert_eq!(\n            human_readable_bytes(1024 * 1024 + 1024 * 256),\n            (1.25, \"MiB\")\n        );\n        assert_eq!(human_readable_bytes(1024 * 1024 * 1024), (1., \"GiB\"));\n        assert_eq!(\n            human_readable_bytes((1024. * 1024. * 1024. * 3.1415) as u64),\n            (3.1415, \"GiB\")\n        );\n        assert_eq!(human_readable_bytes(1024 * 1024 * 1024 * 1024), (1., \"TiB\"));\n        assert_eq!(\n            human_readable_bytes(1024 * 1024 * 1024 * 1024 * 1024),\n            (1., \"PiB\")\n        );\n        assert_eq!(\n            human_readable_bytes(1024 * 1024 * 1024 * 1024 * 1024 * 1024),\n            (1., \"EiB\")\n        );\n        assert_eq!(human_readable_bytes(u64::MAX), (16., \"EiB\"));\n    }\n}\n", "//! Tests for normal registry dependencies.\n\nuse cargo::core::SourceId;\nuse cargo_test_support::cargo_process;\nuse cargo_test_support::paths::{self, CargoPathExt};\nuse cargo_test_support::registry::{\n    self, registry_path, Dependency, Package, RegistryBuilder, Response, TestRegistry,\n};\nuse cargo_test_support::{basic_manifest, project};\nuse cargo_test_support::{git, install::cargo_home, t};\nuse cargo_util::paths::remove_dir_all;\nuse std::fmt::Write;\nuse std::fs::{self, File};\nuse std::path::Path;\nuse std::sync::Arc;\nuse std::sync::Mutex;\n\nfn setup_http() -> TestRegistry {\n    RegistryBuilder::new().http_index().build()\n}\n\n#[cargo_test]\nfn test_server_stops() {\n    let server = setup_http();\n    server.join(); // ensure the server fully shuts down\n}\n\n#[cargo_test]\nfn simple_http() {\n    let _server = setup_http();\n    simple();\n}\n\n#[cargo_test]\nfn simple_git() {\n    simple();\n}\n\nfn simple() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\").publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v0.0.1 (registry `dummy-registry`)\n[CHECKING] bar v0.0.1\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n\n    p.cargo(\"clean\").run();\n\n    assert!(paths::home().join(\".cargo/registry/CACHEDIR.TAG\").is_file());\n\n    // Don't download a second time\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[CHECKING] bar v0.0.1\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn deps_http() {\n    let _server = setup_http();\n    deps();\n}\n\n#[cargo_test]\nfn deps_git() {\n    deps();\n}\n\nfn deps() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"baz\", \"0.0.1\").publish();\n    Package::new(\"bar\", \"0.0.1\").dep(\"baz\", \"*\").publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] [..] v0.0.1 (registry `dummy-registry`)\n[DOWNLOADED] [..] v0.0.1 (registry `dummy-registry`)\n[CHECKING] baz v0.0.1\n[CHECKING] bar v0.0.1\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n\n    assert!(paths::home().join(\".cargo/registry/CACHEDIR.TAG\").is_file());\n}\n\n#[cargo_test]\nfn nonexistent_http() {\n    let _server = setup_http();\n    nonexistent();\n}\n\n#[cargo_test]\nfn nonexistent_git() {\n    nonexistent();\n}\n\nfn nonexistent() {\n    Package::new(\"init\", \"0.0.1\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                nonexistent = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[UPDATING] [..] index\nerror: no matching package named `nonexistent` found\nlocation searched: registry [..]\nrequired by package `foo v0.0.1 ([..])`\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn wrong_case_http() {\n    let _server = setup_http();\n    wrong_case();\n}\n\n#[cargo_test]\nfn wrong_case_git() {\n    wrong_case();\n}\n\nfn wrong_case() {\n    Package::new(\"init\", \"0.0.1\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                Init = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    // #5678 to make this work\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[UPDATING] [..] index\nerror: no matching package found\nsearched package name: `Init`\nperhaps you meant:      init\nlocation searched: registry [..]\nrequired by package `foo v0.0.1 ([..])`\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn mis_hyphenated_http() {\n    let _server = setup_http();\n    mis_hyphenated();\n}\n\n#[cargo_test]\nfn mis_hyphenated_git() {\n    mis_hyphenated();\n}\n\nfn mis_hyphenated() {\n    Package::new(\"mis-hyphenated\", \"0.0.1\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                mis_hyphenated = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    // #2775 to make this work\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[UPDATING] [..] index\nerror: no matching package found\nsearched package name: `mis_hyphenated`\nperhaps you meant:      mis-hyphenated\nlocation searched: registry [..]\nrequired by package `foo v0.0.1 ([..])`\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn wrong_version_http() {\n    let _server = setup_http();\n    wrong_version();\n}\n\n#[cargo_test]\nfn wrong_version_git() {\n    wrong_version();\n}\n\nfn wrong_version() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                foo = \">= 1.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"foo\", \"0.0.1\").publish();\n    Package::new(\"foo\", \"0.0.2\").publish();\n\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr_contains(\n            \"\\\nerror: failed to select a version for the requirement `foo = \\\">=1.0.0\\\"`\ncandidate versions found which didn't match: 0.0.2, 0.0.1\nlocation searched: `[..]` index (which is replacing registry `[..]`)\nrequired by package `foo v0.0.1 ([..])`\n\",\n        )\n        .run();\n\n    Package::new(\"foo\", \"0.0.3\").publish();\n    Package::new(\"foo\", \"0.0.4\").publish();\n\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr_contains(\n            \"\\\nerror: failed to select a version for the requirement `foo = \\\">=1.0.0\\\"`\ncandidate versions found which didn't match: 0.0.4, 0.0.3, 0.0.2, ...\nlocation searched: `[..]` index (which is replacing registry `[..]`)\nrequired by package `foo v0.0.1 ([..])`\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn bad_cksum_http() {\n    let _server = setup_http();\n    bad_cksum();\n}\n\n#[cargo_test]\nfn bad_cksum_git() {\n    bad_cksum();\n}\n\nfn bad_cksum() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bad-cksum = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    let pkg = Package::new(\"bad-cksum\", \"0.0.1\");\n    pkg.publish();\n    t!(File::create(&pkg.archive_dst()));\n\n    p.cargo(\"check -v\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[UPDATING] [..] index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bad-cksum [..]\n[ERROR] failed to download replaced source registry `crates-io`\n\nCaused by:\n  failed to verify the checksum of `bad-cksum v0.0.1 (registry `dummy-registry`)`\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn update_registry_http() {\n    let _server = setup_http();\n    update_registry();\n}\n\n#[cargo_test]\nfn update_registry_git() {\n    update_registry();\n}\n\nfn update_registry() {\n    Package::new(\"init\", \"0.0.1\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                notyet = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr_contains(\n            \"\\\nerror: no matching package named `notyet` found\nlocation searched: registry `[..]`\nrequired by package `foo v0.0.1 ([..])`\n\",\n        )\n        .run();\n\n    Package::new(\"notyet\", \"0.0.1\").publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] notyet v0.0.1 (registry `dummy-registry`)\n[CHECKING] notyet v0.0.1\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn package_with_path_deps_http() {\n    let _server = setup_http();\n    package_with_path_deps();\n}\n\n#[cargo_test]\nfn package_with_path_deps_git() {\n    package_with_path_deps();\n}\n\nfn package_with_path_deps() {\n    Package::new(\"init\", \"0.0.1\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n                license = \"MIT\"\n                description = \"foo\"\n                repository = \"bar\"\n\n                [dependencies.notyet]\n                version = \"0.0.1\"\n                path = \"notyet\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .file(\"notyet/Cargo.toml\", &basic_manifest(\"notyet\", \"0.0.1\"))\n        .file(\"notyet/src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"package\")\n        .with_status(101)\n        .with_stderr_contains(\n            \"\\\n[PACKAGING] foo [..]\n[UPDATING] [..]\n[ERROR] failed to prepare local package for uploading\n\nCaused by:\n  no matching package named `notyet` found\n  location searched: registry `crates-io`\n  required by package `foo v0.0.1 [..]`\n\",\n        )\n        .run();\n\n    Package::new(\"notyet\", \"0.0.1\").publish();\n\n    p.cargo(\"package\")\n        .with_stderr(\n            \"\\\n[PACKAGING] foo v0.0.1 ([CWD])\n[UPDATING] `[..]` index\n[VERIFYING] foo v0.0.1 ([CWD])\n[DOWNLOADING] crates ...\n[DOWNLOADED] notyet v0.0.1 (registry `dummy-registry`)\n[COMPILING] notyet v0.0.1\n[COMPILING] foo v0.0.1 ([CWD][..])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n[PACKAGED] [..]\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn lockfile_locks_http() {\n    let _server = setup_http();\n    lockfile_locks();\n}\n\n#[cargo_test]\nfn lockfile_locks_git() {\n    lockfile_locks();\n}\n\nfn lockfile_locks() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\").publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v0.0.1 (registry `dummy-registry`)\n[CHECKING] bar v0.0.1\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n\n    p.root().move_into_the_past();\n    Package::new(\"bar\", \"0.0.2\").publish();\n\n    p.cargo(\"check\").with_stdout(\"\").run();\n}\n\n#[cargo_test]\nfn lockfile_locks_transitively_http() {\n    let _server = setup_http();\n    lockfile_locks_transitively();\n}\n\n#[cargo_test]\nfn lockfile_locks_transitively_git() {\n    lockfile_locks_transitively();\n}\n\nfn lockfile_locks_transitively() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"baz\", \"0.0.1\").publish();\n    Package::new(\"bar\", \"0.0.1\").dep(\"baz\", \"*\").publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] [..] v0.0.1 (registry `dummy-registry`)\n[DOWNLOADED] [..] v0.0.1 (registry `dummy-registry`)\n[CHECKING] baz v0.0.1\n[CHECKING] bar v0.0.1\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n\n    p.root().move_into_the_past();\n    Package::new(\"baz\", \"0.0.2\").publish();\n    Package::new(\"bar\", \"0.0.2\").dep(\"baz\", \"*\").publish();\n\n    p.cargo(\"check\").with_stdout(\"\").run();\n}\n\n#[cargo_test]\nfn yanks_are_not_used_http() {\n    let _server = setup_http();\n    yanks_are_not_used();\n}\n\n#[cargo_test]\nfn yanks_are_not_used_git() {\n    yanks_are_not_used();\n}\n\nfn yanks_are_not_used() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"baz\", \"0.0.1\").publish();\n    Package::new(\"baz\", \"0.0.2\").yanked(true).publish();\n    Package::new(\"bar\", \"0.0.1\").dep(\"baz\", \"*\").publish();\n    Package::new(\"bar\", \"0.0.2\")\n        .dep(\"baz\", \"*\")\n        .yanked(true)\n        .publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] [..] v0.0.1 (registry `dummy-registry`)\n[DOWNLOADED] [..] v0.0.1 (registry `dummy-registry`)\n[CHECKING] baz v0.0.1\n[CHECKING] bar v0.0.1\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn relying_on_a_yank_is_bad_http() {\n    let _server = setup_http();\n    relying_on_a_yank_is_bad();\n}\n\n#[cargo_test]\nfn relying_on_a_yank_is_bad_git() {\n    relying_on_a_yank_is_bad();\n}\n\nfn relying_on_a_yank_is_bad() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"baz\", \"0.0.1\").publish();\n    Package::new(\"baz\", \"0.0.2\").yanked(true).publish();\n    Package::new(\"bar\", \"0.0.1\").dep(\"baz\", \"=0.0.2\").publish();\n\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr_contains(\n            \"\\\nerror: failed to select a version for the requirement `baz = \\\"=0.0.2\\\"`\ncandidate versions found which didn't match: 0.0.1\nlocation searched: `[..]` index (which is replacing registry `[..]`)\nrequired by package `bar v0.0.1`\n    ... which satisfies dependency `bar = \\\"*\\\"` of package `foo [..]`\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn yanks_in_lockfiles_are_ok_http() {\n    let _server = setup_http();\n    yanks_in_lockfiles_are_ok();\n}\n\n#[cargo_test]\nfn yanks_in_lockfiles_are_ok_git() {\n    yanks_in_lockfiles_are_ok();\n}\n\nfn yanks_in_lockfiles_are_ok() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\").publish();\n\n    p.cargo(\"check\").run();\n\n    registry_path().join(\"3\").rm_rf();\n\n    Package::new(\"bar\", \"0.0.1\").yanked(true).publish();\n\n    p.cargo(\"check\").with_stdout(\"\").run();\n\n    p.cargo(\"update\")\n        .with_status(101)\n        .with_stderr_contains(\n            \"\\\nerror: no matching package named `bar` found\nlocation searched: registry [..]\nrequired by package `foo v0.0.1 ([..])`\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn yanks_in_lockfiles_are_ok_for_other_update_http() {\n    let _server = setup_http();\n    yanks_in_lockfiles_are_ok_for_other_update();\n}\n\n#[cargo_test]\nfn yanks_in_lockfiles_are_ok_for_other_update_git() {\n    yanks_in_lockfiles_are_ok_for_other_update();\n}\n\nfn yanks_in_lockfiles_are_ok_for_other_update() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n                baz = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\").publish();\n    Package::new(\"baz\", \"0.0.1\").publish();\n\n    p.cargo(\"check\").run();\n\n    registry_path().join(\"3\").rm_rf();\n\n    Package::new(\"bar\", \"0.0.1\").yanked(true).publish();\n    Package::new(\"baz\", \"0.0.1\").publish();\n\n    p.cargo(\"check\").with_stdout(\"\").run();\n\n    Package::new(\"baz\", \"0.0.2\").publish();\n\n    p.cargo(\"update\")\n        .with_status(101)\n        .with_stderr_contains(\n            \"\\\nerror: no matching package named `bar` found\nlocation searched: registry [..]\nrequired by package `foo v0.0.1 ([..])`\n\",\n        )\n        .run();\n\n    p.cargo(\"update -p baz\")\n        .with_stderr_contains(\n            \"\\\n[UPDATING] `[..]` index\n[UPDATING] baz v0.0.1 -> v0.0.2\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn yanks_in_lockfiles_are_ok_with_new_dep_http() {\n    let _server = setup_http();\n    yanks_in_lockfiles_are_ok_with_new_dep();\n}\n\n#[cargo_test]\nfn yanks_in_lockfiles_are_ok_with_new_dep_git() {\n    yanks_in_lockfiles_are_ok_with_new_dep();\n}\n\nfn yanks_in_lockfiles_are_ok_with_new_dep() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\").publish();\n\n    p.cargo(\"check\").run();\n\n    registry_path().join(\"3\").rm_rf();\n\n    Package::new(\"bar\", \"0.0.1\").yanked(true).publish();\n    Package::new(\"baz\", \"0.0.1\").publish();\n\n    p.change_file(\n        \"Cargo.toml\",\n        r#\"\n            [package]\n            name = \"foo\"\n            version = \"0.0.1\"\n            authors = []\n\n            [dependencies]\n            bar = \"*\"\n            baz = \"*\"\n        \"#,\n    );\n\n    p.cargo(\"check\").with_stdout(\"\").run();\n}\n\n#[cargo_test]\nfn update_with_lockfile_if_packages_missing_http() {\n    let _server = setup_http();\n    update_with_lockfile_if_packages_missing();\n}\n\n#[cargo_test]\nfn update_with_lockfile_if_packages_missing_git() {\n    update_with_lockfile_if_packages_missing();\n}\n\nfn update_with_lockfile_if_packages_missing() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\").publish();\n    p.cargo(\"check\").run();\n    p.root().move_into_the_past();\n\n    paths::home().join(\".cargo/registry\").rm_rf();\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v0.0.1 (registry `dummy-registry`)\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn update_lockfile_http() {\n    let _server = setup_http();\n    update_lockfile();\n}\n\n#[cargo_test]\nfn update_lockfile_git() {\n    update_lockfile();\n}\n\nfn update_lockfile() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    println!(\"0.0.1\");\n    Package::new(\"bar\", \"0.0.1\").publish();\n    p.cargo(\"check\").run();\n\n    Package::new(\"bar\", \"0.0.2\").publish();\n    Package::new(\"bar\", \"0.0.3\").publish();\n    paths::home().join(\".cargo/registry\").rm_rf();\n    println!(\"0.0.2 update\");\n    p.cargo(\"update -p bar --precise 0.0.2\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[UPDATING] bar v0.0.1 -> v0.0.2\n\",\n        )\n        .run();\n\n    println!(\"0.0.2 build\");\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[DOWNLOADING] crates ...\n[DOWNLOADED] [..] v0.0.2 (registry `dummy-registry`)\n[CHECKING] bar v0.0.2\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n\n    println!(\"0.0.3 update\");\n    p.cargo(\"update -p bar\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[UPDATING] bar v0.0.2 -> v0.0.3\n\",\n        )\n        .run();\n\n    println!(\"0.0.3 build\");\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[DOWNLOADING] crates ...\n[DOWNLOADED] [..] v0.0.3 (registry `dummy-registry`)\n[CHECKING] bar v0.0.3\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n\n    println!(\"new dependencies update\");\n    Package::new(\"bar\", \"0.0.4\").dep(\"spam\", \"0.2.5\").publish();\n    Package::new(\"spam\", \"0.2.5\").publish();\n    p.cargo(\"update -p bar\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[UPDATING] bar v0.0.3 -> v0.0.4\n[ADDING] spam v0.2.5\n\",\n        )\n        .run();\n\n    println!(\"new dependencies update\");\n    Package::new(\"bar\", \"0.0.5\").publish();\n    p.cargo(\"update -p bar\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[UPDATING] bar v0.0.4 -> v0.0.5\n[REMOVING] spam v0.2.5\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn dev_dependency_not_used_http() {\n    let _server = setup_http();\n    dev_dependency_not_used();\n}\n\n#[cargo_test]\nfn dev_dependency_not_used_git() {\n    dev_dependency_not_used();\n}\n\nfn dev_dependency_not_used() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"baz\", \"0.0.1\").publish();\n    Package::new(\"bar\", \"0.0.1\").dev_dep(\"baz\", \"*\").publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] [..] v0.0.1 (registry `dummy-registry`)\n[CHECKING] bar v0.0.1\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn bad_license_file_http() {\n    let registry = setup_http();\n    bad_license_file(&registry);\n}\n\n#[cargo_test]\nfn bad_license_file_git() {\n    let registry = registry::init();\n    bad_license_file(&registry);\n}\n\nfn bad_license_file(registry: &TestRegistry) {\n    Package::new(\"foo\", \"1.0.0\").publish();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n                license-file = \"foo\"\n                description = \"bar\"\n                repository = \"baz\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n    p.cargo(\"publish -v\")\n        .replace_crates_io(registry.index_url())\n        .with_status(101)\n        .with_stderr_contains(\"[ERROR] the license file `foo` does not exist\")\n        .run();\n}\n\n#[cargo_test]\nfn updating_a_dep_http() {\n    let _server = setup_http();\n    updating_a_dep();\n}\n\n#[cargo_test]\nfn updating_a_dep_git() {\n    updating_a_dep();\n}\n\nfn updating_a_dep() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies.a]\n                path = \"a\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .file(\n            \"a/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"a\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"a/src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\").publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v0.0.1 (registry `dummy-registry`)\n[CHECKING] bar v0.0.1\n[CHECKING] a v0.0.1 ([CWD]/a)\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n    assert!(paths::home().join(\".cargo/registry/CACHEDIR.TAG\").is_file());\n\n    // Now delete the CACHEDIR.TAG file: this is the situation we'll be in after\n    // upgrading from a version of Cargo that doesn't mark this directory, to one that\n    // does. It should be recreated.\n    fs::remove_file(paths::home().join(\".cargo/registry/CACHEDIR.TAG\"))\n        .expect(\"remove CACHEDIR.TAG\");\n\n    p.change_file(\n        \"a/Cargo.toml\",\n        r#\"\n        [package]\n        name = \"a\"\n        version = \"0.0.1\"\n        authors = []\n\n        [dependencies]\n        bar = \"0.1.0\"\n        \"#,\n    );\n    Package::new(\"bar\", \"0.1.0\").publish();\n\n    println!(\"second\");\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v0.1.0 (registry `dummy-registry`)\n[CHECKING] bar v0.1.0\n[CHECKING] a v0.0.1 ([CWD]/a)\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n\n    assert!(\n        paths::home().join(\".cargo/registry/CACHEDIR.TAG\").is_file(),\n        \"CACHEDIR.TAG recreated in existing registry\"\n    );\n}\n\n#[cargo_test]\nfn git_and_registry_dep_http() {\n    let _server = setup_http();\n    git_and_registry_dep();\n}\n\n#[cargo_test]\nfn git_and_registry_dep_git() {\n    git_and_registry_dep();\n}\n\nfn git_and_registry_dep() {\n    let b = git::repo(&paths::root().join(\"b\"))\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"b\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                a = \"0.0.1\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.0.1\"\n                    authors = []\n\n                    [dependencies]\n                    a = \"0.0.1\"\n\n                    [dependencies.b]\n                    git = '{}'\n                \"#,\n                b.url()\n            ),\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"a\", \"0.0.1\").publish();\n\n    p.root().move_into_the_past();\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] [..]\n[UPDATING] [..]\n[DOWNLOADING] crates ...\n[DOWNLOADED] a v0.0.1 (registry `dummy-registry`)\n[CHECKING] a v0.0.1\n[CHECKING] b v0.0.1 ([..])\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n    p.root().move_into_the_past();\n\n    println!(\"second\");\n    p.cargo(\"check\").with_stdout(\"\").run();\n}\n\n#[cargo_test]\nfn update_publish_then_update_http() {\n    let _server = setup_http();\n    update_publish_then_update();\n}\n\n#[cargo_test]\nfn update_publish_then_update_git() {\n    update_publish_then_update();\n}\n\nfn update_publish_then_update() {\n    // First generate a Cargo.lock and a clone of the registry index at the\n    // \"head\" of the current registry.\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                a = \"0.1.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n    Package::new(\"a\", \"0.1.0\").publish();\n    p.cargo(\"build\").run();\n\n    // Next, publish a new package and back up the copy of the registry we just\n    // created.\n    Package::new(\"a\", \"0.1.1\").publish();\n    let registry = paths::home().join(\".cargo/registry\");\n    let backup = paths::root().join(\"registry-backup\");\n    t!(fs::rename(&registry, &backup));\n\n    // Generate a Cargo.lock with the newer version, and then move the old copy\n    // of the registry back into place.\n    let p2 = project()\n        .at(\"foo2\")\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                a = \"0.1.1\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n    p2.cargo(\"build\").run();\n    registry.rm_rf();\n    t!(fs::rename(&backup, &registry));\n    t!(fs::rename(\n        p2.root().join(\"Cargo.lock\"),\n        p.root().join(\"Cargo.lock\")\n    ));\n\n    // Finally, build the first project again (with our newer Cargo.lock) which\n    // should force an update of the old registry, download the new crate, and\n    // then build everything again.\n    p.cargo(\"build\")\n        .with_stderr(\n            \"\\\n[UPDATING] [..]\n[DOWNLOADING] crates ...\n[DOWNLOADED] a v0.1.1 (registry `dummy-registry`)\n[COMPILING] a v0.1.1\n[COMPILING] foo v0.5.0 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn fetch_downloads_http() {\n    let _server = setup_http();\n    fetch_downloads();\n}\n\n#[cargo_test]\nfn fetch_downloads_git() {\n    fetch_downloads();\n}\n\nfn fetch_downloads() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                a = \"0.1.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"a\", \"0.1.0\").publish();\n\n    p.cargo(\"fetch\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] a v0.1.0 (registry [..])\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn update_transitive_dependency_http() {\n    let _server = setup_http();\n    update_transitive_dependency();\n}\n\n#[cargo_test]\nfn update_transitive_dependency_git() {\n    update_transitive_dependency();\n}\n\nfn update_transitive_dependency() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                a = \"0.1.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"a\", \"0.1.0\").dep(\"b\", \"*\").publish();\n    Package::new(\"b\", \"0.1.0\").publish();\n\n    p.cargo(\"fetch\").run();\n\n    Package::new(\"b\", \"0.1.1\").publish();\n\n    p.cargo(\"update -pb\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[UPDATING] b v0.1.0 -> v0.1.1\n\",\n        )\n        .run();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[DOWNLOADING] crates ...\n[DOWNLOADED] b v0.1.1 (registry `dummy-registry`)\n[CHECKING] b v0.1.1\n[CHECKING] a v0.1.0\n[CHECKING] foo v0.5.0 ([..])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn update_backtracking_ok_http() {\n    let _server = setup_http();\n    update_backtracking_ok();\n}\n\n#[cargo_test]\nfn update_backtracking_ok_git() {\n    update_backtracking_ok();\n}\n\nfn update_backtracking_ok() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                webdriver = \"0.1\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"webdriver\", \"0.1.0\")\n        .dep(\"hyper\", \"0.6\")\n        .publish();\n    Package::new(\"hyper\", \"0.6.5\")\n        .dep(\"openssl\", \"0.1\")\n        .dep(\"cookie\", \"0.1\")\n        .publish();\n    Package::new(\"cookie\", \"0.1.0\")\n        .dep(\"openssl\", \"0.1\")\n        .publish();\n    Package::new(\"openssl\", \"0.1.0\").publish();\n\n    p.cargo(\"generate-lockfile\").run();\n\n    Package::new(\"openssl\", \"0.1.1\").publish();\n    Package::new(\"hyper\", \"0.6.6\")\n        .dep(\"openssl\", \"0.1.1\")\n        .dep(\"cookie\", \"0.1.0\")\n        .publish();\n\n    p.cargo(\"update -p hyper\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[UPDATING] hyper v0.6.5 -> v0.6.6\n[UPDATING] openssl v0.1.0 -> v0.1.1\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn update_multiple_packages_http() {\n    let _server = setup_http();\n    update_multiple_packages();\n}\n\n#[cargo_test]\nfn update_multiple_packages_git() {\n    update_multiple_packages();\n}\n\nfn update_multiple_packages() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                a = \"*\"\n                b = \"*\"\n                c = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"a\", \"0.1.0\").publish();\n    Package::new(\"b\", \"0.1.0\").publish();\n    Package::new(\"c\", \"0.1.0\").publish();\n\n    p.cargo(\"fetch\").run();\n\n    Package::new(\"a\", \"0.1.1\").publish();\n    Package::new(\"b\", \"0.1.1\").publish();\n    Package::new(\"c\", \"0.1.1\").publish();\n\n    p.cargo(\"update -pa -pb\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[UPDATING] a v0.1.0 -> v0.1.1\n[UPDATING] b v0.1.0 -> v0.1.1\n\",\n        )\n        .run();\n\n    p.cargo(\"update -pb -pc\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[UPDATING] c v0.1.0 -> v0.1.1\n\",\n        )\n        .run();\n\n    p.cargo(\"check\")\n        .with_stderr_contains(\"[DOWNLOADED] a v0.1.1 (registry `dummy-registry`)\")\n        .with_stderr_contains(\"[DOWNLOADED] b v0.1.1 (registry `dummy-registry`)\")\n        .with_stderr_contains(\"[DOWNLOADED] c v0.1.1 (registry `dummy-registry`)\")\n        .with_stderr_contains(\"[CHECKING] a v0.1.1\")\n        .with_stderr_contains(\"[CHECKING] b v0.1.1\")\n        .with_stderr_contains(\"[CHECKING] c v0.1.1\")\n        .with_stderr_contains(\"[CHECKING] foo v0.5.0 ([..])\")\n        .run();\n}\n\n#[cargo_test]\nfn bundled_crate_in_registry_http() {\n    let _server = setup_http();\n    bundled_crate_in_registry();\n}\n\n#[cargo_test]\nfn bundled_crate_in_registry_git() {\n    bundled_crate_in_registry();\n}\n\nfn bundled_crate_in_registry() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                bar = \"0.1\"\n                baz = \"0.1\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.1.0\").publish();\n    Package::new(\"baz\", \"0.1.0\")\n        .dep(\"bar\", \"0.1.0\")\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"baz\"\n                version = \"0.1.0\"\n                authors = []\n\n                [dependencies]\n                bar = { path = \"bar\", version = \"0.1.0\" }\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .file(\"bar/Cargo.toml\", &basic_manifest(\"bar\", \"0.1.0\"))\n        .file(\"bar/src/lib.rs\", \"\")\n        .publish();\n\n    p.cargo(\"run\").run();\n}\n\n#[cargo_test]\nfn update_same_prefix_oh_my_how_was_this_a_bug_http() {\n    let _server = setup_http();\n    update_same_prefix_oh_my_how_was_this_a_bug();\n}\n\n#[cargo_test]\nfn update_same_prefix_oh_my_how_was_this_a_bug_git() {\n    update_same_prefix_oh_my_how_was_this_a_bug();\n}\n\nfn update_same_prefix_oh_my_how_was_this_a_bug() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"ugh\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"0.1\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"foobar\", \"0.2.0\").publish();\n    Package::new(\"foo\", \"0.1.0\")\n        .dep(\"foobar\", \"0.2.0\")\n        .publish();\n\n    p.cargo(\"generate-lockfile\").run();\n    p.cargo(\"update -pfoobar --precise=0.2.0\").run();\n}\n\n#[cargo_test]\nfn use_semver_http() {\n    let _server = setup_http();\n    use_semver();\n}\n\n#[cargo_test]\nfn use_semver_git() {\n    use_semver();\n}\n\nfn use_semver() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"1.2.3-alpha.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"foo\", \"1.2.3-alpha.0\").publish();\n\n    p.cargo(\"check\").run();\n}\n\n#[cargo_test]\nfn use_semver_package_incorrectly_http() {\n    let _server = setup_http();\n    use_semver_package_incorrectly();\n}\n\n#[cargo_test]\nfn use_semver_package_incorrectly_git() {\n    use_semver_package_incorrectly();\n}\n\nfn use_semver_package_incorrectly() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n            [workspace]\n            members = [\"a\", \"b\"]\n            \"#,\n        )\n        .file(\n            \"a/Cargo.toml\",\n            r#\"\n            [package]\n            name = \"a\"\n            version = \"0.1.1-alpha.0\"\n            authors = []\n            \"#,\n        )\n        .file(\n            \"b/Cargo.toml\",\n            r#\"\n            [package]\n            name = \"b\"\n            version = \"0.1.0\"\n            authors = []\n\n            [dependencies]\n            a = { version = \"^0.1\", path = \"../a\" }\n            \"#,\n        )\n        .file(\"a/src/main.rs\", \"fn main() {}\")\n        .file(\"b/src/main.rs\", \"fn main() {}\")\n        .build();\n\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\nerror: no matching package found\nsearched package name: `a`\nprerelease package needs to be specified explicitly\na = { version = \\\"0.1.1-alpha.0\\\" }\nlocation searched: [..]\nrequired by package `b v0.1.0 ([..])`\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn only_download_relevant_http() {\n    let _server = setup_http();\n    only_download_relevant();\n}\n\n#[cargo_test]\nfn only_download_relevant_git() {\n    only_download_relevant();\n}\n\nfn only_download_relevant() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.5.0\"\n                authors = []\n\n                [target.foo.dependencies]\n                foo = \"*\"\n                [dev-dependencies]\n                bar = \"*\"\n                [dependencies]\n                baz = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"foo\", \"0.1.0\").publish();\n    Package::new(\"bar\", \"0.1.0\").publish();\n    Package::new(\"baz\", \"0.1.0\").publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] baz v0.1.0 ([..])\n[CHECKING] baz v0.1.0\n[CHECKING] bar v0.5.0 ([..])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn resolve_and_backtracking_http() {\n    let _server = setup_http();\n    resolve_and_backtracking();\n}\n\n#[cargo_test]\nfn resolve_and_backtracking_git() {\n    resolve_and_backtracking();\n}\n\nfn resolve_and_backtracking() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"foo\", \"0.1.1\")\n        .feature_dep(\"bar\", \"0.1\", &[\"a\", \"b\"])\n        .publish();\n    Package::new(\"foo\", \"0.1.0\").publish();\n\n    p.cargo(\"check\").run();\n}\n\n#[cargo_test]\nfn upstream_warnings_on_extra_verbose_http() {\n    let _server = setup_http();\n    upstream_warnings_on_extra_verbose();\n}\n\n#[cargo_test]\nfn upstream_warnings_on_extra_verbose_git() {\n    upstream_warnings_on_extra_verbose();\n}\n\nfn upstream_warnings_on_extra_verbose() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"foo\", \"0.1.0\")\n        .file(\"src/lib.rs\", \"fn unused() {}\")\n        .publish();\n\n    p.cargo(\"check -vv\")\n        .with_stderr_contains(\"[WARNING] [..]unused[..]\")\n        .run();\n}\n\n#[cargo_test]\nfn disallow_network_http() {\n    let _server = setup_http();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    p.cargo(\"check --frozen\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[UPDATING] [..]\n[ERROR] failed to get `foo` as a dependency of package `bar v0.5.0 ([..])`\n\nCaused by:\n  failed to query replaced source registry `crates-io`\n\nCaused by:\n  attempting to make an HTTP request, but --frozen was specified\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn disallow_network_git() {\n    let _server = RegistryBuilder::new().build();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    p.cargo(\"check --frozen\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[ERROR] failed to get `foo` as a dependency of package `bar v0.5.0 [..]`\n\nCaused by:\n  failed to load source for dependency `foo`\n\nCaused by:\n  Unable to update registry `crates-io`\n\nCaused by:\n  failed to update replaced source registry `crates-io`\n\nCaused by:\n  attempting to make an HTTP request, but --frozen was specified\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn add_dep_dont_update_registry_http() {\n    let _server = setup_http();\n    add_dep_dont_update_registry();\n}\n\n#[cargo_test]\nfn add_dep_dont_update_registry_git() {\n    add_dep_dont_update_registry();\n}\n\nfn add_dep_dont_update_registry() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                baz = { path = \"baz\" }\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .file(\n            \"baz/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"baz\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                remote = \"0.3\"\n            \"#,\n        )\n        .file(\"baz/src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"remote\", \"0.3.4\").publish();\n\n    p.cargo(\"check\").run();\n\n    p.change_file(\n        \"Cargo.toml\",\n        r#\"\n        [package]\n        name = \"bar\"\n        version = \"0.5.0\"\n        authors = []\n\n        [dependencies]\n        baz = { path = \"baz\" }\n        remote = \"0.3\"\n        \"#,\n    );\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[CHECKING] bar v0.5.0 ([..])\n[FINISHED] [..]\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn bump_version_dont_update_registry_http() {\n    let _server = setup_http();\n    bump_version_dont_update_registry();\n}\n\n#[cargo_test]\nfn bump_version_dont_update_registry_git() {\n    bump_version_dont_update_registry();\n}\n\nfn bump_version_dont_update_registry() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                baz = { path = \"baz\" }\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .file(\n            \"baz/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"baz\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                remote = \"0.3\"\n            \"#,\n        )\n        .file(\"baz/src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"remote\", \"0.3.4\").publish();\n\n    p.cargo(\"check\").run();\n\n    p.change_file(\n        \"Cargo.toml\",\n        r#\"\n        [package]\n        name = \"bar\"\n        version = \"0.6.0\"\n        authors = []\n\n        [dependencies]\n        baz = { path = \"baz\" }\n        \"#,\n    );\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[CHECKING] bar v0.6.0 ([..])\n[FINISHED] [..]\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn toml_lies_but_index_is_truth_http() {\n    let _server = setup_http();\n    toml_lies_but_index_is_truth();\n}\n\n#[cargo_test]\nfn toml_lies_but_index_is_truth_git() {\n    toml_lies_but_index_is_truth();\n}\n\nfn toml_lies_but_index_is_truth() {\n    Package::new(\"foo\", \"0.2.0\").publish();\n    Package::new(\"bar\", \"0.3.0\")\n        .dep(\"foo\", \"0.2.0\")\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.3.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"0.1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"extern crate foo;\")\n        .publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                bar = \"0.3\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    p.cargo(\"check -v\").run();\n}\n\n#[cargo_test]\nfn vv_prints_warnings_http() {\n    let _server = setup_http();\n    vv_prints_warnings();\n}\n\n#[cargo_test]\nfn vv_prints_warnings_git() {\n    vv_prints_warnings();\n}\n\nfn vv_prints_warnings() {\n    Package::new(\"foo\", \"0.2.0\")\n        .file(\n            \"src/lib.rs\",\n            \"#![deny(warnings)] fn foo() {} // unused function\",\n        )\n        .publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"fo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"0.2\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    p.cargo(\"check -vv\").run();\n}\n\n#[cargo_test]\nfn bad_and_or_malicious_packages_rejected_http() {\n    let _server = setup_http();\n    bad_and_or_malicious_packages_rejected();\n}\n\n#[cargo_test]\nfn bad_and_or_malicious_packages_rejected_git() {\n    bad_and_or_malicious_packages_rejected();\n}\n\nfn bad_and_or_malicious_packages_rejected() {\n    Package::new(\"foo\", \"0.2.0\")\n        .extra_file(\"foo-0.1.0/src/lib.rs\", \"\")\n        .publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"fo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"0.2\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    p.cargo(\"check -vv\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[UPDATING] [..]\n[DOWNLOADING] crates ...\n[DOWNLOADED] [..]\nerror: failed to download [..]\n\nCaused by:\n  failed to unpack [..]\n\nCaused by:\n  [..] contains a file at \\\"foo-0.1.0/src/lib.rs\\\" which isn't under \\\"foo-0.2.0\\\"\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn git_init_templatedir_missing_http() {\n    let _server = setup_http();\n    git_init_templatedir_missing();\n}\n\n#[cargo_test]\nfn git_init_templatedir_missing_git() {\n    git_init_templatedir_missing();\n}\n\nfn git_init_templatedir_missing() {\n    Package::new(\"foo\", \"0.2.0\").dep(\"bar\", \"*\").publish();\n    Package::new(\"bar\", \"0.2.0\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"fo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"0.2\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    p.cargo(\"check\").run();\n\n    remove_dir_all(paths::home().join(\".cargo/registry\")).unwrap();\n    fs::write(\n        paths::home().join(\".gitconfig\"),\n        r#\"\n            [init]\n            templatedir = nowhere\n        \"#,\n    )\n    .unwrap();\n\n    p.cargo(\"check\").run();\n    p.cargo(\"check\").run();\n}\n\n#[cargo_test]\nfn rename_deps_and_features_http() {\n    let _server = setup_http();\n    rename_deps_and_features();\n}\n\n#[cargo_test]\nfn rename_deps_and_features_git() {\n    rename_deps_and_features();\n}\n\nfn rename_deps_and_features() {\n    Package::new(\"foo\", \"0.1.0\")\n        .file(\"src/lib.rs\", \"pub fn f1() {}\")\n        .publish();\n    Package::new(\"foo\", \"0.2.0\")\n        .file(\"src/lib.rs\", \"pub fn f2() {}\")\n        .publish();\n    Package::new(\"bar\", \"0.2.0\")\n        .add_dep(\n            Dependency::new(\"foo01\", \"0.1.0\")\n                .package(\"foo\")\n                .optional(true),\n        )\n        .add_dep(Dependency::new(\"foo02\", \"0.2.0\").package(\"foo\"))\n        .feature(\"another\", &[\"foo01\"])\n        .file(\n            \"src/lib.rs\",\n            r#\"\n                extern crate foo02;\n                #[cfg(feature = \"foo01\")]\n                extern crate foo01;\n\n                pub fn foo() {\n                    foo02::f2();\n                    #[cfg(feature = \"foo01\")]\n                    foo01::f1();\n                }\n            \"#,\n        )\n        .publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"a\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                bar = \"0.2\"\n            \"#,\n        )\n        .file(\n            \"src/main.rs\",\n            \"\n                extern crate bar;\n                fn main() { bar::foo(); }\n            \",\n        )\n        .build();\n\n    p.cargo(\"check\").run();\n    p.cargo(\"check --features bar/foo01\").run();\n    p.cargo(\"check --features bar/another\").run();\n}\n\n#[cargo_test]\nfn ignore_invalid_json_lines_http() {\n    let _server = setup_http();\n    ignore_invalid_json_lines();\n}\n\n#[cargo_test]\nfn ignore_invalid_json_lines_git() {\n    ignore_invalid_json_lines();\n}\n\nfn ignore_invalid_json_lines() {\n    Package::new(\"foo\", \"0.1.0\").publish();\n    Package::new(\"foo\", \"0.1.1\").invalid_json(true).publish();\n    Package::new(\"foo\", \"0.2.0\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"a\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = '0.1.0'\n                foo02 = { version = '0.2.0', package = 'foo' }\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"check\").run();\n}\n\n#[cargo_test]\nfn readonly_registry_still_works_http() {\n    let _server = setup_http();\n    readonly_registry_still_works();\n}\n\n#[cargo_test]\nfn readonly_registry_still_works_git() {\n    readonly_registry_still_works();\n}\n\nfn readonly_registry_still_works() {\n    Package::new(\"foo\", \"0.1.0\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"a\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = '0.1.0'\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"generate-lockfile\").run();\n    p.cargo(\"fetch --locked\").run();\n    chmod_readonly(&paths::home(), true);\n    p.cargo(\"check\").run();\n    // make sure we un-readonly the files afterwards so \"cargo clean\" can remove them (#6934)\n    chmod_readonly(&paths::home(), false);\n\n    fn chmod_readonly(path: &Path, readonly: bool) {\n        for entry in t!(path.read_dir()) {\n            let entry = t!(entry);\n            let path = entry.path();\n            if t!(entry.file_type()).is_dir() {\n                chmod_readonly(&path, readonly);\n            } else {\n                set_readonly(&path, readonly);\n            }\n        }\n        set_readonly(path, readonly);\n    }\n\n    fn set_readonly(path: &Path, readonly: bool) {\n        let mut perms = t!(path.metadata()).permissions();\n        perms.set_readonly(readonly);\n        t!(fs::set_permissions(path, perms));\n    }\n}\n\n#[cargo_test]\nfn registry_index_rejected_http() {\n    let _server = setup_http();\n    registry_index_rejected();\n}\n\n#[cargo_test]\nfn registry_index_rejected_git() {\n    registry_index_rejected();\n}\n\nfn registry_index_rejected() {\n    Package::new(\"dep\", \"0.1.0\").publish();\n\n    let p = project()\n        .file(\n            \".cargo/config\",\n            r#\"\n            [registry]\n            index = \"https://example.com/\"\n            \"#,\n        )\n        .file(\n            \"Cargo.toml\",\n            r#\"\n            [package]\n            name = \"foo\"\n            version = \"0.1.0\"\n\n            [dependencies]\n            dep = \"0.1\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[ERROR] failed to parse manifest at `[..]/foo/Cargo.toml`\n\nCaused by:\n  the `registry.index` config value is no longer supported\n  Use `[source]` replacement to alter the default index for crates.io.\n\",\n        )\n        .run();\n\n    p.cargo(\"login\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[ERROR] the `registry.index` config value is no longer supported\nUse `[source]` replacement to alter the default index for crates.io.\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn package_lock_inside_package_is_overwritten() {\n    let registry = registry::init();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\")\n        .file(\"src/lib.rs\", \"\")\n        .file(\".cargo-ok\", \"\")\n        .publish();\n\n    p.cargo(\"check\").run();\n\n    let id = SourceId::for_registry(registry.index_url()).unwrap();\n    let hash = cargo::util::hex::short_hash(&id);\n    let ok = cargo_home()\n        .join(\"registry\")\n        .join(\"src\")\n        .join(format!(\"-{}\", hash))\n        .join(\"bar-0.0.1\")\n        .join(\".cargo-ok\");\n\n    assert_eq!(ok.metadata().unwrap().len(), 2);\n}\n\n#[cargo_test]\nfn package_lock_as_a_symlink_inside_package_is_overwritten() {\n    let registry = registry::init();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\")\n        .file(\"src/lib.rs\", \"pub fn f() {}\")\n        .symlink(\".cargo-ok\", \"src/lib.rs\")\n        .publish();\n\n    p.cargo(\"check\").run();\n\n    let id = SourceId::for_registry(registry.index_url()).unwrap();\n    let hash = cargo::util::hex::short_hash(&id);\n    let pkg_root = cargo_home()\n        .join(\"registry\")\n        .join(\"src\")\n        .join(format!(\"-{}\", hash))\n        .join(\"bar-0.0.1\");\n    let ok = pkg_root.join(\".cargo-ok\");\n    let librs = pkg_root.join(\"src/lib.rs\");\n\n    // Is correctly overwritten and doesn't affect the file linked to\n    assert_eq!(ok.metadata().unwrap().len(), 2);\n    assert_eq!(fs::read_to_string(librs).unwrap(), \"pub fn f() {}\");\n}\n\n#[cargo_test]\nfn ignores_unknown_index_version_http() {\n    let _server = setup_http();\n    ignores_unknown_index_version();\n}\n\n#[cargo_test]\nfn ignores_unknown_index_version_git() {\n    ignores_unknown_index_version();\n}\n\nfn ignores_unknown_index_version() {\n    // If the version field is not understood, it is ignored.\n    Package::new(\"bar\", \"1.0.0\").publish();\n    Package::new(\"bar\", \"1.0.1\").schema_version(9999).publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bar = \"1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"tree\")\n        .with_stdout(\n            \"foo v0.1.0 [..]\\n\\\n             \u2514\u2500\u2500 bar v1.0.0\\n\\\n            \",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn protocol() {\n    cargo_process(\"install bar\")\n        .with_status(101)\n        .env(\"CARGO_REGISTRIES_CRATES_IO_PROTOCOL\", \"invalid\")\n        .with_stderr(\"[ERROR] unsupported registry protocol `invalid` (defined in environment variable `CARGO_REGISTRIES_CRATES_IO_PROTOCOL`)\")\n        .run()\n}\n\n#[cargo_test]\nfn http_requires_trailing_slash() {\n    cargo_process(\"install bar --index sparse+https://invalid.crates.io/test\")\n        .with_status(101)\n        .with_stderr(\"[ERROR] sparse registry url must end in a slash `/`: sparse+https://invalid.crates.io/test\")\n        .run()\n}\n\n// Limit the test to debug builds so that `__CARGO_TEST_MAX_UNPACK_SIZE` will take affect.\n#[cfg(debug_assertions)]\n#[cargo_test]\nfn reach_max_unpack_size() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n\n                [dependencies]\n                bar = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    // Size of bar.crate is around 180 bytes.\n    Package::new(\"bar\", \"0.0.1\").publish();\n\n    p.cargo(\"check\")\n        .env(\"__CARGO_TEST_MAX_UNPACK_SIZE\", \"8\") // hit 8 bytes limit and boom!\n        .env(\"__CARGO_TEST_MAX_UNPACK_RATIO\", \"0\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v0.0.1 (registry `dummy-registry`)\n[ERROR] failed to download replaced source registry `crates-io`\n\nCaused by:\n  failed to unpack package `bar v0.0.1 (registry `dummy-registry`)`\n\nCaused by:\n  failed to iterate over archive\n\nCaused by:\n  maximum limit reached when reading\n\",\n        )\n        .run();\n\n    // Restore to the default ratio and it should compile.\n    p.cargo(\"check\")\n        .env(\"__CARGO_TEST_MAX_UNPACK_SIZE\", \"8\")\n        .with_stderr(\n            \"\\\n[CHECKING] bar v0.0.1\n[CHECKING] foo v0.0.1 ([..])\n[FINISHED] dev [..]\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn sparse_retry_single() {\n    let fail_count = Mutex::new(0);\n    let _registry = RegistryBuilder::new()\n        .http_index()\n        .add_responder(\"/index/3/b/bar\", move |req, server| {\n            let mut fail_count = fail_count.lock().unwrap();\n            if *fail_count < 2 {\n                *fail_count += 1;\n                server.internal_server_error(req)\n            } else {\n                server.index(req)\n            }\n        })\n        .build();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\").publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\nwarning: spurious network error (3 tries remaining): failed to get successful HTTP response from `[..]` (127.0.0.1), got 500\nbody:\ninternal server error\nwarning: spurious network error (2 tries remaining): failed to get successful HTTP response from `[..]` (127.0.0.1), got 500\nbody:\ninternal server error\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v0.0.1 (registry `dummy-registry`)\n[CHECKING] bar v0.0.1\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn sparse_retry_multiple() {\n    // Tests retry behavior of downloading lots of packages with various\n    // failure rates accessing the sparse index.\n\n    // The index is the number of retries, the value is the number of packages\n    // that retry that number of times. Thus 50 packages succeed on first try,\n    // 25 on second, etc.\n    const RETRIES: &[u32] = &[50, 25, 12, 6];\n\n    let pkgs: Vec<_> = RETRIES\n        .iter()\n        .enumerate()\n        .flat_map(|(retries, num)| {\n            (0..*num)\n                .into_iter()\n                .map(move |n| (retries as u32, format!(\"{}-{n}-{retries}\", rand_prefix())))\n        })\n        .collect();\n\n    let mut builder = RegistryBuilder::new().http_index();\n    let fail_counts: Arc<Mutex<Vec<u32>>> = Arc::new(Mutex::new(vec![0; pkgs.len()]));\n    let mut cargo_toml = r#\"\n        [package]\n        name = \"foo\"\n        version = \"0.1.0\"\n\n        [dependencies]\n        \"#\n    .to_string();\n    // The expected stderr output.\n    let mut expected = \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n\"\n    .to_string();\n    for (n, (retries, name)) in pkgs.iter().enumerate() {\n        let count_clone = fail_counts.clone();\n        let retries = *retries;\n        let ab = &name[..2];\n        let cd = &name[2..4];\n        builder = builder.add_responder(format!(\"/index/{ab}/{cd}/{name}\"), move |req, server| {\n            let mut fail_counts = count_clone.lock().unwrap();\n            if fail_counts[n] < retries {\n                fail_counts[n] += 1;\n                server.internal_server_error(req)\n            } else {\n                server.index(req)\n            }\n        });\n        write!(&mut cargo_toml, \"{name} = \\\"1.0.0\\\"\\n\").unwrap();\n        for retry in 0..retries {\n            let remain = 3 - retry;\n            write!(\n                &mut expected,\n                \"warning: spurious network error ({remain} tries remaining): \\\n                failed to get successful HTTP response from \\\n                `http://127.0.0.1:[..]/{ab}/{cd}/{name}` (127.0.0.1), got 500\\n\\\n                body:\\n\\\n                internal server error\\n\"\n            )\n            .unwrap();\n        }\n        write!(\n            &mut expected,\n            \"[DOWNLOADED] {name} v1.0.0 (registry `dummy-registry`)\\n\"\n        )\n        .unwrap();\n    }\n    let _server = builder.build();\n    for (_, name) in &pkgs {\n        Package::new(name, \"1.0.0\").publish();\n    }\n    let p = project()\n        .file(\"Cargo.toml\", &cargo_toml)\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    p.cargo(\"fetch\").with_stderr_unordered(expected).run();\n}\n\n#[cargo_test]\nfn dl_retry_single() {\n    // Tests retry behavior of downloading a package.\n    // This tests a single package which exercises the code path that causes\n    // it to block.\n    let fail_count = Mutex::new(0);\n    let _server = RegistryBuilder::new()\n        .http_index()\n        .add_responder(\"/dl/bar/1.0.0/download\", move |req, server| {\n            let mut fail_count = fail_count.lock().unwrap();\n            if *fail_count < 2 {\n                *fail_count += 1;\n                server.internal_server_error(req)\n            } else {\n                server.dl(req)\n            }\n        })\n        .build();\n    Package::new(\"bar\", \"1.0.0\").publish();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bar = \"1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    p.cargo(\"fetch\")\n        .with_stderr(\"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\nwarning: spurious network error (3 tries remaining): \\\n    failed to get successful HTTP response from `http://127.0.0.1:[..]/dl/bar/1.0.0/download` (127.0.0.1), got 500\nbody:\ninternal server error\nwarning: spurious network error (2 tries remaining): \\\n    failed to get successful HTTP response from `http://127.0.0.1:[..]/dl/bar/1.0.0/download` (127.0.0.1), got 500\nbody:\ninternal server error\n[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)\n\").run();\n}\n\n/// Creates a random prefix to randomly spread out the package names\n/// to somewhat evenly distribute the different failures at different\n/// points.\nfn rand_prefix() -> String {\n    use rand::Rng;\n    const CHARS: &[u8] = b\"abcdefghijklmnopqrstuvwxyz\";\n    let mut rng = rand::thread_rng();\n    (0..5)\n        .map(|_| CHARS[rng.gen_range(0..CHARS.len())] as char)\n        .collect()\n}\n\n#[cargo_test]\nfn dl_retry_multiple() {\n    // Tests retry behavior of downloading lots of packages with various\n    // failure rates.\n\n    // The index is the number of retries, the value is the number of packages\n    // that retry that number of times. Thus 50 packages succeed on first try,\n    // 25 on second, etc.\n    const RETRIES: &[u32] = &[50, 25, 12, 6];\n\n    let pkgs: Vec<_> = RETRIES\n        .iter()\n        .enumerate()\n        .flat_map(|(retries, num)| {\n            (0..*num)\n                .into_iter()\n                .map(move |n| (retries as u32, format!(\"{}-{n}-{retries}\", rand_prefix())))\n        })\n        .collect();\n\n    let mut builder = RegistryBuilder::new().http_index();\n    let fail_counts: Arc<Mutex<Vec<u32>>> = Arc::new(Mutex::new(vec![0; pkgs.len()]));\n    let mut cargo_toml = r#\"\n        [package]\n        name = \"foo\"\n        version = \"0.1.0\"\n\n        [dependencies]\n        \"#\n    .to_string();\n    // The expected stderr output.\n    let mut expected = \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n\"\n    .to_string();\n    for (n, (retries, name)) in pkgs.iter().enumerate() {\n        let count_clone = fail_counts.clone();\n        let retries = *retries;\n        builder =\n            builder.add_responder(format!(\"/dl/{name}/1.0.0/download\"), move |req, server| {\n                let mut fail_counts = count_clone.lock().unwrap();\n                if fail_counts[n] < retries {\n                    fail_counts[n] += 1;\n                    server.internal_server_error(req)\n                } else {\n                    server.dl(req)\n                }\n            });\n        write!(&mut cargo_toml, \"{name} = \\\"1.0.0\\\"\\n\").unwrap();\n        for retry in 0..retries {\n            let remain = 3 - retry;\n            write!(\n                &mut expected,\n                \"warning: spurious network error ({remain} tries remaining): \\\n                failed to get successful HTTP response from \\\n                `http://127.0.0.1:[..]/dl/{name}/1.0.0/download` (127.0.0.1), got 500\\n\\\n                body:\\n\\\n                internal server error\\n\"\n            )\n            .unwrap();\n        }\n        write!(\n            &mut expected,\n            \"[DOWNLOADED] {name} v1.0.0 (registry `dummy-registry`)\\n\"\n        )\n        .unwrap();\n    }\n    let _server = builder.build();\n    for (_, name) in &pkgs {\n        Package::new(name, \"1.0.0\").publish();\n    }\n    let p = project()\n        .file(\"Cargo.toml\", &cargo_toml)\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    p.cargo(\"fetch\").with_stderr_unordered(expected).run();\n}\n\n#[cargo_test]\nfn deleted_entry() {\n    // Checks the behavior when a package is removed from the index.\n    // This is done occasionally on crates.io to handle things like\n    // copyright takedowns.\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bar = \"0.1\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    // First, test removing a single version, but leaving an older version.\n    Package::new(\"bar\", \"0.1.0\").publish();\n    let bar_path = Path::new(\"3/b/bar\");\n    let bar_reg_path = registry_path().join(&bar_path);\n    let old_index = fs::read_to_string(&bar_reg_path).unwrap();\n    Package::new(\"bar\", \"0.1.1\").publish();\n    p.cargo(\"tree\")\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v0.1.1 (registry `dummy-registry`)\n\",\n        )\n        .with_stdout(\n            \"\\\nfoo v0.1.0 ([ROOT]/foo)\n\u2514\u2500\u2500 bar v0.1.1\n\",\n        )\n        .run();\n\n    // Remove 0.1.1\n    fs::remove_file(paths::root().join(\"dl/bar/0.1.1/download\")).unwrap();\n    let repo = git2::Repository::open(registry_path()).unwrap();\n    let mut index = repo.index().unwrap();\n    fs::write(&bar_reg_path, &old_index).unwrap();\n    index.add_path(&bar_path).unwrap();\n    index.write().unwrap();\n    git::commit(&repo);\n\n    // With `Cargo.lock` unchanged, it shouldn't have an impact.\n    p.cargo(\"tree\")\n        .with_stderr(\"\")\n        .with_stdout(\n            \"\\\nfoo v0.1.0 ([ROOT]/foo)\n\u2514\u2500\u2500 bar v0.1.1\n\",\n        )\n        .run();\n\n    // Regenerating Cargo.lock should switch to old version.\n    fs::remove_file(p.root().join(\"Cargo.lock\")).unwrap();\n    p.cargo(\"tree\")\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v0.1.0 (registry `dummy-registry`)\n\",\n        )\n        .with_stdout(\n            \"\\\nfoo v0.1.0 ([ROOT]/foo)\n\u2514\u2500\u2500 bar v0.1.0\n\",\n        )\n        .run();\n\n    // Remove the package entirely.\n    fs::remove_file(paths::root().join(\"dl/bar/0.1.0/download\")).unwrap();\n    let mut index = repo.index().unwrap();\n    index.remove(&bar_path, 0).unwrap();\n    index.write().unwrap();\n    git::commit(&repo);\n    fs::remove_file(&bar_reg_path).unwrap();\n\n    // With `Cargo.lock` unchanged, it shouldn't have an impact.\n    p.cargo(\"tree\")\n        .with_stderr(\"\")\n        .with_stdout(\n            \"\\\nfoo v0.1.0 ([ROOT]/foo)\n\u2514\u2500\u2500 bar v0.1.0\n\",\n        )\n        .run();\n\n    // Regenerating Cargo.lock should fail.\n    fs::remove_file(p.root().join(\"Cargo.lock\")).unwrap();\n    p.cargo(\"tree\")\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\nerror: no matching package named `bar` found\nlocation searched: registry `crates-io`\nrequired by package `foo v0.1.0 ([ROOT]/foo)`\n\",\n        )\n        .with_status(101)\n        .run();\n}\n\n#[cargo_test]\nfn corrupted_ok_overwritten() {\n    // Checks what happens if .cargo-ok gets truncated, such as if the file is\n    // created, but the flush/close is interrupted.\n    Package::new(\"bar\", \"1.0.0\").publish();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bar = \"1\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    p.cargo(\"fetch\")\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)\n\",\n        )\n        .run();\n    let ok = glob::glob(\n        paths::home()\n            .join(\".cargo/registry/src/*/bar-1.0.0/.cargo-ok\")\n            .to_str()\n            .unwrap(),\n    )\n    .unwrap()\n    .next()\n    .unwrap()\n    .unwrap();\n    // Simulate cargo being interrupted, or filesystem corruption.\n    fs::write(&ok, \"\").unwrap();\n    assert_eq!(fs::read_to_string(&ok).unwrap(), \"\");\n    p.cargo(\"fetch\").with_stderr(\"\").run();\n    assert_eq!(fs::read_to_string(&ok).unwrap(), \"ok\");\n}\n\n#[cargo_test]\nfn not_found_permutations() {\n    // Test for querying permutations for a missing dependency.\n    let misses = Arc::new(Mutex::new(Vec::new()));\n    let misses2 = misses.clone();\n    let _registry = RegistryBuilder::new()\n        .http_index()\n        .not_found_handler(move |req, _server| {\n            let mut misses = misses2.lock().unwrap();\n            misses.push(req.url.path().to_string());\n            Response {\n                code: 404,\n                headers: vec![],\n                body: b\"not found\".to_vec(),\n            }\n        })\n        .build();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                a-b_c = \"1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\nerror: no matching package named `a-b_c` found\nlocation searched: registry `crates-io`\nrequired by package `foo v0.0.1 ([ROOT]/foo)`\n\",\n        )\n        .run();\n    let mut misses = misses.lock().unwrap();\n    misses.sort();\n    assert_eq!(\n        &*misses,\n        &[\n            \"/index/a-/b-/a-b-c\",\n            \"/index/a-/b_/a-b_c\",\n            \"/index/a_/b_/a_b_c\"\n        ]\n    );\n}\n\n#[cargo_test]\nfn default_auth_error() {\n    // Check for the error message for an authentication error when default is set.\n    let crates_io = RegistryBuilder::new().http_api().build();\n    let _alternative = RegistryBuilder::new().http_api().alternative().build();\n\n    paths::home().join(\".cargo/credentials.toml\").rm_rf();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n                license = \"MIT\"\n                description = \"foo\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    // Test output before setting the default.\n    p.cargo(\"publish --no-verify\")\n        .replace_crates_io(crates_io.index_url())\n        .with_stderr(\n            \"\\\n[UPDATING] crates.io index\nerror: no token found, please run `cargo login`\nor use environment variable CARGO_REGISTRY_TOKEN\n\",\n        )\n        .with_status(101)\n        .run();\n\n    p.cargo(\"publish --no-verify --registry alternative\")\n        .replace_crates_io(crates_io.index_url())\n        .with_stderr(\n            \"\\\n[UPDATING] `alternative` index\nerror: no token found for `alternative`, please run `cargo login --registry alternative`\nor use environment variable CARGO_REGISTRIES_ALTERNATIVE_TOKEN\n\",\n        )\n        .with_status(101)\n        .run();\n\n    // Test the output with the default.\n    cargo_util::paths::append(\n        &cargo_home().join(\"config\"),\n        br#\"\n            [registry]\n            default = \"alternative\"\n        \"#,\n    )\n    .unwrap();\n\n    p.cargo(\"publish --no-verify\")\n        .replace_crates_io(crates_io.index_url())\n        .with_stderr(\n            \"\\\n[UPDATING] `alternative` index\nerror: no token found for `alternative`, please run `cargo login --registry alternative`\nor use environment variable CARGO_REGISTRIES_ALTERNATIVE_TOKEN\n\",\n        )\n        .with_status(101)\n        .run();\n\n    p.cargo(\"publish --no-verify --registry crates-io\")\n        .replace_crates_io(crates_io.index_url())\n        .with_stderr(\n            \"\\\n[UPDATING] crates.io index\nerror: no token found, please run `cargo login --registry crates-io`\nor use environment variable CARGO_REGISTRY_TOKEN\n\",\n        )\n        .with_status(101)\n        .run();\n}\n\nconst SAMPLE_HEADERS: &[&str] = &[\n    \"x-amz-cf-pop: SFO53-P2\",\n    \"x-amz-cf-id: vEc3osJrCAXVaciNnF4Vev-hZFgnYwmNZtxMKRJ5bF6h9FTOtbTMnA==\",\n    \"x-cache: Hit from cloudfront\",\n    \"server: AmazonS3\",\n    \"x-amz-version-id: pvsJYY_JGsWiSETZvLJKb7DeEW5wWq1W\",\n    \"x-amz-server-side-encryption: AES256\",\n    \"content-type: text/plain\",\n    \"via: 1.1 bcbc5b46216015493e082cfbcf77ef10.cloudfront.net (CloudFront)\",\n];\n\n#[cargo_test]\nfn debug_header_message_index() {\n    // The error message should include some headers for debugging purposes.\n    let _server = RegistryBuilder::new()\n        .http_index()\n        .add_responder(\"/index/3/b/bar\", |_, _| Response {\n            code: 503,\n            headers: SAMPLE_HEADERS.iter().map(|s| s.to_string()).collect(),\n            body: b\"Please slow down\".to_vec(),\n        })\n        .build();\n    Package::new(\"bar\", \"1.0.0\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bar = \"1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    p.cargo(\"fetch\").with_status(101).with_stderr(\"\\\n[UPDATING] `dummy-registry` index\nwarning: spurious network error (3 tries remaining): \\\n    failed to get successful HTTP response from `http://127.0.0.1:[..]/index/3/b/bar` (127.0.0.1), got 503\nbody:\nPlease slow down\nwarning: spurious network error (2 tries remaining): \\\n    failed to get successful HTTP response from `http://127.0.0.1:[..]/index/3/b/bar` (127.0.0.1), got 503\nbody:\nPlease slow down\nwarning: spurious network error (1 tries remaining): \\\n    failed to get successful HTTP response from `http://127.0.0.1:[..]/index/3/b/bar` (127.0.0.1), got 503\nbody:\nPlease slow down\nerror: failed to get `bar` as a dependency of package `foo v0.1.0 ([ROOT]/foo)`\n\nCaused by:\n  failed to query replaced source registry `crates-io`\n\nCaused by:\n  download of 3/b/bar failed\n\nCaused by:\n  failed to get successful HTTP response from `http://127.0.0.1:[..]/index/3/b/bar` (127.0.0.1), got 503\n  debug headers:\n  x-amz-cf-pop: SFO53-P2\n  x-amz-cf-id: vEc3osJrCAXVaciNnF4Vev-hZFgnYwmNZtxMKRJ5bF6h9FTOtbTMnA==\n  x-cache: Hit from cloudfront\n  body:\n  Please slow down\n\").run();\n}\n\n#[cargo_test]\nfn debug_header_message_dl() {\n    // Same as debug_header_message_index, but for the dl endpoint which goes\n    // through a completely different code path.\n    let _server = RegistryBuilder::new()\n        .http_index()\n        .add_responder(\"/dl/bar/1.0.0/download\", |_, _| Response {\n            code: 503,\n            headers: SAMPLE_HEADERS.iter().map(|s| s.to_string()).collect(),\n            body: b\"Please slow down\".to_vec(),\n        })\n        .build();\n    Package::new(\"bar\", \"1.0.0\").publish();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bar = \"1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"fetch\").with_status(101).with_stderr(\"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\nwarning: spurious network error (3 tries remaining): \\\n    failed to get successful HTTP response from `http://127.0.0.1:[..]/dl/bar/1.0.0/download` (127.0.0.1), got 503\nbody:\nPlease slow down\nwarning: spurious network error (2 tries remaining): \\\n    failed to get successful HTTP response from `http://127.0.0.1:[..]/dl/bar/1.0.0/download` (127.0.0.1), got 503\nbody:\nPlease slow down\nwarning: spurious network error (1 tries remaining): \\\n    failed to get successful HTTP response from `http://127.0.0.1:[..]/dl/bar/1.0.0/download` (127.0.0.1), got 503\nbody:\nPlease slow down\nerror: failed to download from `http://127.0.0.1:[..]/dl/bar/1.0.0/download`\n\nCaused by:\n  failed to get successful HTTP response from `http://127.0.0.1:[..]/dl/bar/1.0.0/download` (127.0.0.1), got 503\n  debug headers:\n  x-amz-cf-pop: SFO53-P2\n  x-amz-cf-id: vEc3osJrCAXVaciNnF4Vev-hZFgnYwmNZtxMKRJ5bF6h9FTOtbTMnA==\n  x-cache: Hit from cloudfront\n  body:\n  Please slow down\n\").run();\n}\n", "//! Tests for the `cargo vendor` command.\n//!\n//! Note that every test here uses `--respect-source-config` so that the\n//! \"fake\" crates.io is used. Otherwise `vendor` would download the crates.io\n//! index from the network.\n\nuse std::fs;\n\nuse cargo_test_support::git;\nuse cargo_test_support::registry::{self, Package, RegistryBuilder};\nuse cargo_test_support::{basic_lib_manifest, basic_manifest, paths, project, Project};\n\n#[cargo_test]\nfn vendor_simple() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                log = \"0.3.5\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"log\", \"0.3.5\").publish();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    let lock = p.read_file(\"vendor/log/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.3.5\\\"\"));\n\n    add_vendor_config(&p);\n    p.cargo(\"check\").run();\n}\n\n#[cargo_test]\nfn vendor_sample_config() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                log = \"0.3.5\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"log\", \"0.3.5\").publish();\n\n    p.cargo(\"vendor --respect-source-config\")\n        .with_stdout(\n            r#\"[source.crates-io]\nreplace-with = \"vendored-sources\"\n\n[source.vendored-sources]\ndirectory = \"vendor\"\n\"#,\n        )\n        .run();\n}\n\n#[cargo_test]\nfn vendor_sample_config_alt_registry() {\n    let registry = RegistryBuilder::new().alternative().http_index().build();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                log = { version = \"0.3.5\", registry = \"alternative\" }\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"log\", \"0.3.5\").alternative(true).publish();\n\n    p.cargo(\"vendor --respect-source-config\")\n        .with_stdout(format!(\n            r#\"[source.\"{0}\"]\nregistry = \"{0}\"\nreplace-with = \"vendored-sources\"\n\n[source.vendored-sources]\ndirectory = \"vendor\"\n\"#,\n            registry.index_url()\n        ))\n        .run();\n}\n\n#[cargo_test]\nfn vendor_path_specified() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                log = \"0.3.5\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"log\", \"0.3.5\").publish();\n\n    let path = if cfg!(windows) {\n        r#\"deps\\.vendor\"#\n    } else {\n        \"deps/.vendor\"\n    };\n\n    let output = p\n        .cargo(\"vendor --respect-source-config\")\n        .arg(path)\n        .exec_with_output()\n        .unwrap();\n    // Assert against original output to ensure that\n    // path is normalized by `ops::vendor` on Windows.\n    assert_eq!(\n        &String::from_utf8(output.stdout).unwrap(),\n        r#\"[source.crates-io]\nreplace-with = \"vendored-sources\"\n\n[source.vendored-sources]\ndirectory = \"deps/.vendor\"\n\"#\n    );\n\n    let lock = p.read_file(\"deps/.vendor/log/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.3.5\\\"\"));\n}\n\nfn add_vendor_config(p: &Project) {\n    p.change_file(\n        \".cargo/config\",\n        r#\"\n            [source.crates-io]\n            replace-with = 'vendor'\n\n            [source.vendor]\n            directory = 'vendor'\n        \"#,\n    );\n}\n\n#[cargo_test]\nfn package_exclude() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bar = \"0.1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"bar\", \"0.1.0\")\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.1.0\"\n                exclude = [\".*\", \"!.include\", \"!.dotdir/include\"]\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .file(\".exclude\", \"\")\n        .file(\".include\", \"\")\n        .file(\".dotdir/exclude\", \"\")\n        .file(\".dotdir/include\", \"\")\n        .publish();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    let csum = p.read_file(\"vendor/bar/.cargo-checksum.json\");\n    assert!(csum.contains(\".include\"));\n    assert!(!csum.contains(\".exclude\"));\n    assert!(!csum.contains(\".dotdir/exclude\"));\n    // Gitignore doesn't re-include a file in an excluded parent directory,\n    // even if negating it explicitly.\n    assert!(!csum.contains(\".dotdir/include\"));\n}\n\n#[cargo_test]\nfn two_versions() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"0.8.0\"\n                bar = { path = \"bar\" }\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .file(\n            \"bar/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"0.7.0\"\n            \"#,\n        )\n        .file(\"bar/src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"bitflags\", \"0.7.0\").publish();\n    Package::new(\"bitflags\", \"0.8.0\").publish();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n\n    let lock = p.read_file(\"vendor/bitflags/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.8.0\\\"\"));\n    let lock = p.read_file(\"vendor/bitflags-0.7.0/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.7.0\\\"\"));\n\n    add_vendor_config(&p);\n    p.cargo(\"check\").run();\n}\n\n#[cargo_test]\nfn two_explicit_versions() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"0.8.0\"\n                bar = { path = \"bar\" }\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .file(\n            \"bar/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"0.7.0\"\n            \"#,\n        )\n        .file(\"bar/src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"bitflags\", \"0.7.0\").publish();\n    Package::new(\"bitflags\", \"0.8.0\").publish();\n\n    p.cargo(\"vendor --respect-source-config --versioned-dirs\")\n        .run();\n\n    let lock = p.read_file(\"vendor/bitflags-0.8.0/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.8.0\\\"\"));\n    let lock = p.read_file(\"vendor/bitflags-0.7.0/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.7.0\\\"\"));\n\n    add_vendor_config(&p);\n    p.cargo(\"check\").run();\n}\n\n#[cargo_test]\nfn help() {\n    let p = project().build();\n    p.cargo(\"vendor -h\").run();\n}\n\n#[cargo_test]\nfn update_versions() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"0.7.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"bitflags\", \"0.7.0\").publish();\n    Package::new(\"bitflags\", \"0.8.0\").publish();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n\n    let lock = p.read_file(\"vendor/bitflags/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.7.0\\\"\"));\n\n    p.change_file(\n        \"Cargo.toml\",\n        r#\"\n            [package]\n            name = \"foo\"\n            version = \"0.1.0\"\n\n            [dependencies]\n            bitflags = \"0.8.0\"\n        \"#,\n    );\n    p.cargo(\"vendor --respect-source-config\").run();\n\n    let lock = p.read_file(\"vendor/bitflags/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.8.0\\\"\"));\n}\n\n#[cargo_test]\nfn two_lockfiles() {\n    let p = project()\n        .no_manifest()\n        .file(\n            \"foo/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"=0.7.0\"\n            \"#,\n        )\n        .file(\"foo/src/lib.rs\", \"\")\n        .file(\n            \"bar/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"=0.8.0\"\n            \"#,\n        )\n        .file(\"bar/src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"bitflags\", \"0.7.0\").publish();\n    Package::new(\"bitflags\", \"0.8.0\").publish();\n\n    p.cargo(\"vendor --respect-source-config -s bar/Cargo.toml --manifest-path foo/Cargo.toml\")\n        .run();\n\n    let lock = p.read_file(\"vendor/bitflags/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.8.0\\\"\"));\n    let lock = p.read_file(\"vendor/bitflags-0.7.0/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.7.0\\\"\"));\n\n    add_vendor_config(&p);\n    p.cargo(\"check\").cwd(\"foo\").run();\n    p.cargo(\"check\").cwd(\"bar\").run();\n}\n\n#[cargo_test]\nfn test_sync_argument() {\n    let p = project()\n        .no_manifest()\n        .file(\n            \"foo/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"=0.7.0\"\n            \"#,\n        )\n        .file(\"foo/src/lib.rs\", \"\")\n        .file(\n            \"bar/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"=0.8.0\"\n            \"#,\n        )\n        .file(\"bar/src/lib.rs\", \"\")\n        .file(\n            \"baz/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"baz\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"=0.8.0\"\n            \"#,\n        )\n        .file(\"baz/src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"bitflags\", \"0.7.0\").publish();\n    Package::new(\"bitflags\", \"0.8.0\").publish();\n\n    p.cargo(\"vendor --respect-source-config --manifest-path foo/Cargo.toml -s bar/Cargo.toml baz/Cargo.toml test_vendor\")\n        .with_stderr(\"\\\nerror: unexpected argument 'test_vendor' found\n\nUsage: cargo[EXE] vendor [OPTIONS] [path]\n\nFor more information, try '--help'.\",\n        )\n        .with_status(1)\n        .run();\n\n    p.cargo(\"vendor --respect-source-config --manifest-path foo/Cargo.toml -s bar/Cargo.toml -s baz/Cargo.toml test_vendor\")\n        .run();\n\n    let lock = p.read_file(\"test_vendor/bitflags/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.8.0\\\"\"));\n    let lock = p.read_file(\"test_vendor/bitflags-0.7.0/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.7.0\\\"\"));\n}\n\n#[cargo_test]\nfn delete_old_crates() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"=0.7.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"bitflags\", \"0.7.0\").publish();\n    Package::new(\"log\", \"0.3.5\").publish();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    p.read_file(\"vendor/bitflags/Cargo.toml\");\n\n    p.change_file(\n        \"Cargo.toml\",\n        r#\"\n            [package]\n            name = \"foo\"\n            version = \"0.1.0\"\n\n            [dependencies]\n            log = \"=0.3.5\"\n        \"#,\n    );\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    let lock = p.read_file(\"vendor/log/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.3.5\\\"\"));\n    assert!(!p.root().join(\"vendor/bitflags/Cargo.toml\").exists());\n}\n\n#[cargo_test]\nfn ignore_files() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                url = \"1.4.1\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"url\", \"1.4.1\")\n        .file(\"src/lib.rs\", \"\")\n        .file(\"foo.orig\", \"\")\n        .file(\".gitignore\", \"\")\n        .file(\".gitattributes\", \"\")\n        .file(\"foo.rej\", \"\")\n        .publish();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    let csum = p.read_file(\"vendor/url/.cargo-checksum.json\");\n    assert!(!csum.contains(\"foo.orig\"));\n    assert!(!csum.contains(\".gitignore\"));\n    assert!(!csum.contains(\".gitattributes\"));\n    assert!(!csum.contains(\".cargo-ok\"));\n    assert!(!csum.contains(\"foo.rej\"));\n}\n\n#[cargo_test]\nfn included_files_only() {\n    let git = git::new(\"a\", |p| {\n        p.file(\"Cargo.toml\", &basic_lib_manifest(\"a\"))\n            .file(\"src/lib.rs\", \"\")\n            .file(\".gitignore\", \"a\")\n            .file(\"a/b.md\", \"\")\n    });\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.1.0\"\n\n                    [dependencies]\n                    a = {{ git = '{}' }}\n                \"#,\n                git.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    let csum = p.read_file(\"vendor/a/.cargo-checksum.json\");\n    assert!(!csum.contains(\"a/b.md\"));\n}\n\n#[cargo_test]\nfn dependent_crates_in_crates() {\n    let git = git::new(\"a\", |p| {\n        p.file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"a\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                b = { path = 'b' }\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .file(\"b/Cargo.toml\", &basic_lib_manifest(\"b\"))\n        .file(\"b/src/lib.rs\", \"\")\n    });\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.1.0\"\n\n                    [dependencies]\n                    a = {{ git = '{}' }}\n                \"#,\n                git.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    p.read_file(\"vendor/a/.cargo-checksum.json\");\n    p.read_file(\"vendor/b/.cargo-checksum.json\");\n}\n\n#[cargo_test]\nfn vendoring_git_crates() {\n    let git = git::new(\"git\", |p| {\n        p.file(\"Cargo.toml\", &basic_lib_manifest(\"serde_derive\"))\n            .file(\"src/lib.rs\", \"\")\n            .file(\"src/wut.rs\", \"\")\n    });\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.1.0\"\n\n                    [dependencies.serde]\n                    version = \"0.5.0\"\n\n                    [dependencies.serde_derive]\n                    version = \"0.5.0\"\n\n                    [patch.crates-io]\n                    serde_derive = {{ git = '{}' }}\n                \"#,\n                git.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    Package::new(\"serde\", \"0.5.0\")\n        .dep(\"serde_derive\", \"0.5\")\n        .publish();\n    Package::new(\"serde_derive\", \"0.5.0\").publish();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    p.read_file(\"vendor/serde_derive/src/wut.rs\");\n\n    add_vendor_config(&p);\n    p.cargo(\"check\").run();\n}\n\n#[cargo_test]\nfn git_simple() {\n    let git = git::new(\"git\", |p| {\n        p.file(\"Cargo.toml\", &basic_lib_manifest(\"a\"))\n            .file(\"src/lib.rs\", \"\")\n    });\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.1.0\"\n\n                    [dependencies]\n                    a = {{ git = '{}' }}\n                \"#,\n                git.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    let csum = p.read_file(\"vendor/a/.cargo-checksum.json\");\n    assert!(csum.contains(\"\\\"package\\\":null\"));\n}\n\n#[cargo_test]\nfn git_diff_rev() {\n    let (git_project, git_repo) = git::new_repo(\"git\", |p| {\n        p.file(\"Cargo.toml\", &basic_manifest(\"a\", \"0.1.0\"))\n            .file(\"src/lib.rs\", \"\")\n    });\n    let url = git_project.url();\n    let ref_1 = \"v0.1.0\";\n    let ref_2 = \"v0.2.0\";\n\n    git::tag(&git_repo, ref_1);\n\n    git_project.change_file(\"Cargo.toml\", &basic_manifest(\"a\", \"0.2.0\"));\n    git::add(&git_repo);\n    git::commit(&git_repo);\n    git::tag(&git_repo, ref_2);\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.1.0\"\n\n                    [dependencies]\n                    a_1 = {{ package = \"a\", git = '{url}', rev = '{ref_1}' }}\n                    a_2 = {{ package = \"a\", git = '{url}', rev = '{ref_2}' }}\n                \"#\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"vendor --respect-source-config\")\n        .with_stdout(\n            r#\"[source.\"git+file://[..]/git?rev=v0.1.0\"]\ngit = [..]\nrev = \"v0.1.0\"\nreplace-with = \"vendored-sources\"\n\n[source.\"git+file://[..]/git?rev=v0.2.0\"]\ngit = [..]\nrev = \"v0.2.0\"\nreplace-with = \"vendored-sources\"\n\n[source.vendored-sources]\ndirectory = \"vendor\"\n\"#,\n        )\n        .run();\n}\n\n#[cargo_test]\nfn git_duplicate() {\n    let git = git::new(\"a\", |p| {\n        p.file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"a\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                b = { path = 'b' }\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .file(\"b/Cargo.toml\", &basic_lib_manifest(\"b\"))\n        .file(\"b/src/lib.rs\", \"\")\n    });\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.1.0\"\n\n                    [dependencies]\n                    a = {{ git = '{}' }}\n                    b = '0.5.0'\n\n                \"#,\n                git.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    Package::new(\"b\", \"0.5.0\").publish();\n\n    p.cargo(\"vendor --respect-source-config\")\n        .with_stderr(\n            \"\\\n[UPDATING] [..]\n[UPDATING] [..]\n[DOWNLOADING] [..]\n[DOWNLOADED] [..]\nerror: failed to sync\n\nCaused by:\n  found duplicate version of package `b v0.5.0` vendored from two sources:\n\n  <tab>source 1: [..]\n  <tab>source 2: [..]\n\",\n        )\n        .with_status(101)\n        .run();\n}\n\n#[cargo_test]\nfn git_complex() {\n    let git_b = git::new(\"git_b\", |p| {\n        p.file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"b\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                dep_b = { path = 'dep_b' }\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .file(\"dep_b/Cargo.toml\", &basic_lib_manifest(\"dep_b\"))\n        .file(\"dep_b/src/lib.rs\", \"\")\n    });\n\n    let git_a = git::new(\"git_a\", |p| {\n        p.file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"a\"\n                    version = \"0.1.0\"\n\n                    [dependencies]\n                    b = {{ git = '{}' }}\n                    dep_a = {{ path = 'dep_a' }}\n                \"#,\n                git_b.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .file(\"dep_a/Cargo.toml\", &basic_lib_manifest(\"dep_a\"))\n        .file(\"dep_a/src/lib.rs\", \"\")\n    });\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.1.0\"\n\n                    [dependencies]\n                    a = {{ git = '{}' }}\n                \"#,\n                git_a.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    let output = p\n        .cargo(\"vendor --respect-source-config\")\n        .exec_with_output()\n        .unwrap();\n    let output = String::from_utf8(output.stdout).unwrap();\n    p.change_file(\".cargo/config\", &output);\n\n    p.cargo(\"check -v\")\n        .with_stderr_contains(\"[..]foo/vendor/a/src/lib.rs[..]\")\n        .with_stderr_contains(\"[..]foo/vendor/dep_a/src/lib.rs[..]\")\n        .with_stderr_contains(\"[..]foo/vendor/b/src/lib.rs[..]\")\n        .with_stderr_contains(\"[..]foo/vendor/dep_b/src/lib.rs[..]\")\n        .run();\n}\n\n#[cargo_test]\nfn depend_on_vendor_dir_not_deleted() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                libc = \"0.2.30\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"libc\", \"0.2.30\").publish();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    assert!(p.root().join(\"vendor/libc\").is_dir());\n\n    p.change_file(\n        \"Cargo.toml\",\n        r#\"\n            [package]\n            name = \"foo\"\n            version = \"0.1.0\"\n\n            [dependencies]\n            libc = \"0.2.30\"\n\n            [patch.crates-io]\n            libc = { path = 'vendor/libc' }\n        \"#,\n    );\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    assert!(p.root().join(\"vendor/libc\").is_dir());\n}\n\n#[cargo_test]\nfn ignore_hidden() {\n    // Don't delete files starting with `.`\n    Package::new(\"bar\", \"0.1.0\").publish();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n            [package]\n            name = \"foo\"\n            version = \"1.0.0\"\n            [dependencies]\n            bar = \"0.1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    p.cargo(\"vendor --respect-source-config\").run();\n    // Add a `.git` directory.\n    let repo = git::init(&p.root().join(\"vendor\"));\n    git::add(&repo);\n    git::commit(&repo);\n    assert!(p.root().join(\"vendor/.git\").exists());\n    // Vendor again, shouldn't change anything.\n    p.cargo(\"vendor --respect-source-config\").run();\n    // .git should not be removed.\n    assert!(p.root().join(\"vendor/.git\").exists());\n    // And just for good measure, make sure no files changed.\n    let mut opts = git2::StatusOptions::new();\n    assert!(repo\n        .statuses(Some(&mut opts))\n        .unwrap()\n        .iter()\n        .all(|status| status.status() == git2::Status::CURRENT));\n}\n\n#[cargo_test]\nfn config_instructions_works() {\n    // Check that the config instructions work for all dependency kinds.\n    registry::alt_init();\n    Package::new(\"dep\", \"0.1.0\").publish();\n    Package::new(\"altdep\", \"0.1.0\").alternative(true).publish();\n    let git_project = git::new(\"gitdep\", |project| {\n        project\n            .file(\"Cargo.toml\", &basic_lib_manifest(\"gitdep\"))\n            .file(\"src/lib.rs\", \"\")\n    });\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                dep = \"0.1\"\n                altdep = {{version=\"0.1\", registry=\"alternative\"}}\n                gitdep = {{git='{}'}}\n                \"#,\n                git_project.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    let output = p\n        .cargo(\"vendor --respect-source-config\")\n        .exec_with_output()\n        .unwrap();\n    let output = String::from_utf8(output.stdout).unwrap();\n    p.change_file(\".cargo/config\", &output);\n\n    p.cargo(\"check -v\")\n        .with_stderr_contains(\"[..]foo/vendor/dep/src/lib.rs[..]\")\n        .with_stderr_contains(\"[..]foo/vendor/altdep/src/lib.rs[..]\")\n        .with_stderr_contains(\"[..]foo/vendor/gitdep/src/lib.rs[..]\")\n        .run();\n}\n\n#[cargo_test]\nfn git_crlf_preservation() {\n    // Check that newlines don't get changed when you vendor\n    // (will only fail if your system is setup with core.autocrlf=true on windows)\n    let input = \"hello \\nthere\\nmy newline\\nfriends\";\n    let git_project = git::new(\"git\", |p| {\n        p.file(\"Cargo.toml\", &basic_lib_manifest(\"a\"))\n            .file(\"src/lib.rs\", input)\n    });\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.1.0\"\n\n                    [dependencies]\n                    a = {{ git = '{}' }}\n                \"#,\n                git_project.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    fs::write(\n        paths::home().join(\".gitconfig\"),\n        r#\"\n            [core]\n            autocrlf = true\n        \"#,\n    )\n    .unwrap();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    let output = p.read_file(\"vendor/a/src/lib.rs\");\n    assert_eq!(input, output);\n}\n\n#[cargo_test]\n#[cfg(unix)]\nfn vendor_preserves_permissions() {\n    use std::os::unix::fs::MetadataExt;\n\n    Package::new(\"bar\", \"1.0.0\")\n        .file_with_mode(\"example.sh\", 0o755, \"#!/bin/sh\")\n        .file(\"src/lib.rs\", \"\")\n        .publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bar = \"1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n\n    let metadata = fs::metadata(p.root().join(\"vendor/bar/src/lib.rs\")).unwrap();\n    assert_eq!(metadata.mode() & 0o777, 0o644);\n    let metadata = fs::metadata(p.root().join(\"vendor/bar/example.sh\")).unwrap();\n    assert_eq!(metadata.mode() & 0o777, 0o755);\n}\n\n#[cargo_test]\nfn no_remote_dependency_no_vendor() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n                [dependencies]\n                bar = { path = \"bar\" }\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .file(\n            \"bar/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.1.0\"\n            \"#,\n        )\n        .file(\"bar/src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"vendor\")\n        .with_stderr(\"There is no dependency to vendor in this project.\")\n        .run();\n    assert!(!p.root().join(\"vendor\").exists());\n}\n\n#[cargo_test]\nfn vendor_crate_with_ws_inherit() {\n    let git = git::new(\"ws\", |p| {\n        p.file(\n            \"Cargo.toml\",\n            r#\"\n                [workspace]\n                members = [\"bar\"]\n                [workspace.package]\n                version = \"0.1.0\"\n            \"#,\n        )\n        .file(\n            \"bar/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version.workspace = true\n            \"#,\n        )\n        .file(\"bar/src/lib.rs\", \"\")\n    });\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.1.0\"\n\n                    [dependencies]\n                    bar = {{ git = '{}' }}\n                \"#,\n                git.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    p.change_file(\n        \".cargo/config\",\n        &format!(\n            r#\"\n                [source.\"{}\"]\n                git = \"{}\"\n                replace-with = \"vendor\"\n\n                [source.vendor]\n                directory = \"vendor\"\n            \"#,\n            git.url(),\n            git.url()\n        ),\n    );\n\n    p.cargo(\"check -v\")\n        .with_stderr_contains(\"[..]foo/vendor/bar/src/lib.rs[..]\")\n        .run();\n}\n"], "fixing_code": ["//! A `Source` for registry-based packages.\n//!\n//! # What's a Registry?\n//!\n//! [Registries] are central locations where packages can be uploaded to,\n//! discovered, and searched for. The purpose of a registry is to have a\n//! location that serves as permanent storage for versions of a crate over time.\n//!\n//! Compared to git sources (see [`GitSource`]), a registry provides many\n//! packages as well as many versions simultaneously. Git sources can also\n//! have commits deleted through rebasings where registries cannot have their\n//! versions deleted.\n//!\n//! In Cargo, [`RegistryData`] is an abstraction over each kind of actual\n//! registry, and [`RegistrySource`] connects those implementations to\n//! [`Source`] trait. Two prominent features these abstractions provide are\n//!\n//! * A way to query the metadata of a package from a registry. The metadata\n//!   comes from the index.\n//! * A way to download package contents (a.k.a source files) that are required\n//!   when building the package itself.\n//!\n//! We'll cover each functionality later.\n//!\n//! [Registries]: https://doc.rust-lang.org/nightly/cargo/reference/registries.html\n//! [`GitSource`]: super::GitSource\n//!\n//! # Different Kinds of Registries\n//!\n//! Cargo provides multiple kinds of registries. Each of them serves the index\n//! and package contents in a slightly different way. Namely,\n//!\n//! * [`LocalRegistry`] --- Serves the index and package contents entirely on\n//!   a local filesystem.\n//! * [`RemoteRegistry`] --- Serves the index ahead of time from a Git\n//!   repository, and package contents are downloaded as needed.\n//! * [`HttpRegistry`] --- Serves both the index and package contents on demand\n//!   over a HTTP-based registry API. This is the default starting from 1.70.0.\n//!\n//! Each registry has its own [`RegistryData`] implementation, and can be\n//! created from either [`RegistrySource::local`] or [`RegistrySource::remote`].\n//!\n//! [`LocalRegistry`]: local::LocalRegistry\n//! [`RemoteRegistry`]: remote::RemoteRegistry\n//! [`HttpRegistry`]: http_remote::HttpRegistry\n//!\n//! # The Index of a Registry\n//!\n//! One of the major difficulties with a registry is that hosting so many\n//! packages may quickly run into performance problems when dealing with\n//! dependency graphs. It's infeasible for cargo to download the entire contents\n//! of the registry just to resolve one package's dependencies, for example. As\n//! a result, cargo needs some efficient method of querying what packages are\n//! available on a registry, what versions are available, and what the\n//! dependencies for each version is.\n//!\n//! To solve the problem, a registry must provide an index of package metadata.\n//! The index of a registry is essentially an easily query-able version of the\n//! registry's database for a list of versions of a package as well as a list\n//! of dependencies for each version. The exact format of the index is\n//! described later.\n//!\n//! See the [`index`] module for topics about the management, parsing, caching,\n//! and versioning for the on-disk index.\n//!\n//! ## The Format of The Index\n//!\n//! The index is a store for the list of versions for all packages known, so its\n//! format on disk is optimized slightly to ensure that `ls registry` doesn't\n//! produce a list of all packages ever known. The index also wants to ensure\n//! that there's not a million files which may actually end up hitting\n//! filesystem limits at some point. To this end, a few decisions were made\n//! about the format of the registry:\n//!\n//! 1. Each crate will have one file corresponding to it. Each version for a\n//!    crate will just be a line in this file (see [`IndexPackage`] for its\n//!    representation).\n//! 2. There will be two tiers of directories for crate names, under which\n//!    crates corresponding to those tiers will be located.\n//!    (See [`cargo_util::registry::make_dep_path`] for the implementation of\n//!    this layout hierarchy.)\n//!\n//! As an example, this is an example hierarchy of an index:\n//!\n//! ```notrust\n//! .\n//! \u251c\u2500\u2500 3\n//! \u2502\u00a0\u00a0 \u2514\u2500\u2500 u\n//! \u2502\u00a0\u00a0     \u2514\u2500\u2500 url\n//! \u251c\u2500\u2500 bz\n//! \u2502\u00a0\u00a0 \u2514\u2500\u2500 ip\n//! \u2502\u00a0\u00a0     \u2514\u2500\u2500 bzip2\n//! \u251c\u2500\u2500 config.json\n//! \u251c\u2500\u2500 en\n//! \u2502\u00a0\u00a0 \u2514\u2500\u2500 co\n//! \u2502\u00a0\u00a0     \u2514\u2500\u2500 encoding\n//! \u2514\u2500\u2500 li\n//!  \u00a0\u00a0 \u251c\u2500\u2500 bg\n//!  \u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 libgit2\n//!  \u00a0\u00a0 \u2514\u2500\u2500 nk\n//!  \u00a0\u00a0     \u2514\u2500\u2500 link-config\n//! ```\n//!\n//! The root of the index contains a `config.json` file with a few entries\n//! corresponding to the registry (see [`RegistryConfig`] below).\n//!\n//! Otherwise, there are three numbered directories (1, 2, 3) for crates with\n//! names 1, 2, and 3 characters in length. The 1/2 directories simply have the\n//! crate files underneath them, while the 3 directory is sharded by the first\n//! letter of the crate name.\n//!\n//! Otherwise the top-level directory contains many two-letter directory names,\n//! each of which has many sub-folders with two letters. At the end of all these\n//! are the actual crate files themselves.\n//!\n//! The purpose of this layout is to hopefully cut down on `ls` sizes as well as\n//! efficient lookup based on the crate name itself.\n//!\n//! See [The Cargo Book: Registry Index][registry-index] for the public\n//! interface on the index format.\n//!\n//! [registry-index]: https://doc.rust-lang.org/nightly/cargo/reference/registry-index.html\n//!\n//! ## The Index Files\n//!\n//! Each file in the index is the history of one crate over time. Each line in\n//! the file corresponds to one version of a crate, stored in JSON format (see\n//! the [`IndexPackage`] structure).\n//!\n//! As new versions are published, new lines are appended to this file. **The\n//! only modifications to this file that should happen over time are yanks of a\n//! particular version.**\n//!\n//! # Downloading Packages\n//!\n//! The purpose of the index was to provide an efficient method to resolve the\n//! dependency graph for a package. After resolution has been performed, we need\n//! to download the contents of packages so we can read the full manifest and\n//! build the source code.\n//!\n//! To accomplish this, [`RegistryData::download`] will \"make\" an HTTP request\n//! per-package requested to download tarballs into a local cache. These\n//! tarballs will then be unpacked into a destination folder.\n//!\n//! Note that because versions uploaded to the registry are frozen forever that\n//! the HTTP download and unpacking can all be skipped if the version has\n//! already been downloaded and unpacked. This caching allows us to only\n//! download a package when absolutely necessary.\n//!\n//! # Filesystem Hierarchy\n//!\n//! Overall, the `$HOME/.cargo` looks like this when talking about the registry\n//! (remote registries, specifically):\n//!\n//! ```notrust\n//! # A folder under which all registry metadata is hosted (similar to\n//! # $HOME/.cargo/git)\n//! $HOME/.cargo/registry/\n//!\n//!     # For each registry that cargo knows about (keyed by hostname + hash)\n//!     # there is a folder which is the checked out version of the index for\n//!     # the registry in this location. Note that this is done so cargo can\n//!     # support multiple registries simultaneously\n//!     index/\n//!         registry1-<hash>/\n//!         registry2-<hash>/\n//!         ...\n//!\n//!     # This folder is a cache for all downloaded tarballs (`.crate` file)\n//!     # from a registry. Once downloaded and verified, a tarball never changes.\n//!     cache/\n//!         registry1-<hash>/<pkg>-<version>.crate\n//!         ...\n//!\n//!     # Location in which all tarballs are unpacked. Each tarball is known to\n//!     # be frozen after downloading, so transitively this folder is also\n//!     # frozen once its unpacked (it's never unpacked again)\n//!     # CAVEAT: They are not read-only. See rust-lang/cargo#9455.\n//!     src/\n//!         registry1-<hash>/<pkg>-<version>/...\n//!         ...\n//! ```\n//!\n//! [`IndexPackage`]: index::IndexPackage\n\nuse std::collections::HashSet;\nuse std::fs;\nuse std::fs::{File, OpenOptions};\nuse std::io;\nuse std::io::Read;\nuse std::io::Write;\nuse std::path::{Path, PathBuf};\nuse std::task::{ready, Poll};\n\nuse anyhow::Context as _;\nuse cargo_util::paths::{self, exclude_from_backups_and_indexing};\nuse flate2::read::GzDecoder;\nuse log::debug;\nuse serde::Deserialize;\nuse serde::Serialize;\nuse tar::Archive;\n\nuse crate::core::dependency::Dependency;\nuse crate::core::source::MaybePackage;\nuse crate::core::{Package, PackageId, QueryKind, Source, SourceId, Summary};\nuse crate::sources::PathSource;\nuse crate::util::hex;\nuse crate::util::network::PollExt;\nuse crate::util::{\n    restricted_names, CargoResult, Config, Filesystem, LimitErrorReader, OptVersionReq,\n};\n\n/// The `.cargo-ok` file is used to track if the source is already unpacked.\n/// See [`RegistrySource::unpack_package`] for more.\n///\n/// Not to be confused with `.cargo-ok` file in git sources.\nconst PACKAGE_SOURCE_LOCK: &str = \".cargo-ok\";\n\npub const CRATES_IO_INDEX: &str = \"https://github.com/rust-lang/crates.io-index\";\npub const CRATES_IO_HTTP_INDEX: &str = \"sparse+https://index.crates.io/\";\npub const CRATES_IO_REGISTRY: &str = \"crates-io\";\npub const CRATES_IO_DOMAIN: &str = \"crates.io\";\n\n/// The content inside `.cargo-ok`.\n/// See [`RegistrySource::unpack_package`] for more.\n#[derive(Deserialize, Serialize)]\nstruct LockMetadata {\n    /// The version of `.cargo-ok` file\n    v: u32,\n}\n\n/// A [`Source`] implementation for a local or a remote registry.\n///\n/// This contains common functionality that is shared between each registry\n/// kind, with the registry-specific logic implemented as part of the\n/// [`RegistryData`] trait referenced via the `ops` field.\n///\n/// For general concepts of registries, see the [module-level documentation](crate::sources::registry).\npub struct RegistrySource<'cfg> {\n    /// The unique identifier of this source.\n    source_id: SourceId,\n    /// The path where crate files are extracted (`$CARGO_HOME/registry/src/$REG-HASH`).\n    src_path: Filesystem,\n    /// Local reference to [`Config`] for convenience.\n    config: &'cfg Config,\n    /// Abstraction for interfacing to the different registry kinds.\n    ops: Box<dyn RegistryData + 'cfg>,\n    /// Interface for managing the on-disk index.\n    index: index::RegistryIndex<'cfg>,\n    /// A set of packages that should be allowed to be used, even if they are\n    /// yanked.\n    ///\n    /// This is populated from the entries in `Cargo.lock` to ensure that\n    /// `cargo update -p somepkg` won't unlock yanked entries in `Cargo.lock`.\n    /// Otherwise, the resolver would think that those entries no longer\n    /// exist, and it would trigger updates to unrelated packages.\n    yanked_whitelist: HashSet<PackageId>,\n}\n\n/// The [`config.json`] file stored in the index.\n///\n/// The config file may look like:\n///\n/// ```json\n/// {\n///     \"dl\": \"https://example.com/api/{crate}/{version}/download\",\n///     \"api\": \"https://example.com/api\",\n///     \"auth-required\": false             # unstable feature (RFC 3139)\n/// }\n/// ```\n///\n/// [`config.json`]: https://doc.rust-lang.org/nightly/cargo/reference/registry-index.html#index-configuration\n#[derive(Deserialize, Debug, Clone)]\n#[serde(rename_all = \"kebab-case\")]\npub struct RegistryConfig {\n    /// Download endpoint for all crates.\n    ///\n    /// The string is a template which will generate the download URL for the\n    /// tarball of a specific version of a crate. The substrings `{crate}` and\n    /// `{version}` will be replaced with the crate's name and version\n    /// respectively.  The substring `{prefix}` will be replaced with the\n    /// crate's prefix directory name, and the substring `{lowerprefix}` will\n    /// be replaced with the crate's prefix directory name converted to\n    /// lowercase. The substring `{sha256-checksum}` will be replaced with the\n    /// crate's sha256 checksum.\n    ///\n    /// For backwards compatibility, if the string does not contain any\n    /// markers (`{crate}`, `{version}`, `{prefix}`, or `{lowerprefix}`), it\n    /// will be extended with `/{crate}/{version}/download` to\n    /// support registries like crates.io which were created before the\n    /// templating setup was created.\n    ///\n    /// For more on the template of the download URL, see [Index Configuration](\n    /// https://doc.rust-lang.org/nightly/cargo/reference/registry-index.html#index-configuration).\n    pub dl: String,\n\n    /// API endpoint for the registry. This is what's actually hit to perform\n    /// operations like yanks, owner modifications, publish new crates, etc.\n    /// If this is None, the registry does not support API commands.\n    pub api: Option<String>,\n\n    /// Whether all operations require authentication. See [RFC 3139].\n    ///\n    /// [RFC 3139]: https://rust-lang.github.io/rfcs/3139-cargo-alternative-registry-auth.html\n    #[serde(default)]\n    pub auth_required: bool,\n}\n\n/// Result from loading data from a registry.\npub enum LoadResponse {\n    /// The cache is valid. The cached data should be used.\n    CacheValid,\n\n    /// The cache is out of date. Returned data should be used.\n    Data {\n        raw_data: Vec<u8>,\n        /// Version of this data to determine whether it is out of date.\n        index_version: Option<String>,\n    },\n\n    /// The requested crate was found.\n    NotFound,\n}\n\n/// An abstract interface to handle both a local and and remote registry.\n///\n/// This allows [`RegistrySource`] to abstractly handle each registry kind.\n///\n/// For general concepts of registries, see the [module-level documentation](crate::sources::registry).\npub trait RegistryData {\n    /// Performs initialization for the registry.\n    ///\n    /// This should be safe to call multiple times, the implementation is\n    /// expected to not do any work if it is already prepared.\n    fn prepare(&self) -> CargoResult<()>;\n\n    /// Returns the path to the index.\n    ///\n    /// Note that different registries store the index in different formats\n    /// (remote = git, http & local = files).\n    fn index_path(&self) -> &Filesystem;\n\n    /// Loads the JSON for a specific named package from the index.\n    ///\n    /// * `root` is the root path to the index.\n    /// * `path` is the relative path to the package to load (like `ca/rg/cargo`).\n    /// * `index_version` is the version of the requested crate data currently\n    ///    in cache. This is useful for checking if a local cache is outdated.\n    fn load(\n        &mut self,\n        root: &Path,\n        path: &Path,\n        index_version: Option<&str>,\n    ) -> Poll<CargoResult<LoadResponse>>;\n\n    /// Loads the `config.json` file and returns it.\n    ///\n    /// Local registries don't have a config, and return `None`.\n    fn config(&mut self) -> Poll<CargoResult<Option<RegistryConfig>>>;\n\n    /// Invalidates locally cached data.\n    fn invalidate_cache(&mut self);\n\n    /// If quiet, the source should not display any progress or status messages.\n    fn set_quiet(&mut self, quiet: bool);\n\n    /// Is the local cached data up-to-date?\n    fn is_updated(&self) -> bool;\n\n    /// Prepare to start downloading a `.crate` file.\n    ///\n    /// Despite the name, this doesn't actually download anything. If the\n    /// `.crate` is already downloaded, then it returns [`MaybeLock::Ready`].\n    /// If it hasn't been downloaded, then it returns [`MaybeLock::Download`]\n    /// which contains the URL to download. The [`crate::core::package::Downloads`]\n    /// system handles the actual download process. After downloading, it\n    /// calls [`Self::finish_download`] to save the downloaded file.\n    ///\n    /// `checksum` is currently only used by local registries to verify the\n    /// file contents (because local registries never actually download\n    /// anything). Remote registries will validate the checksum in\n    /// `finish_download`. For already downloaded `.crate` files, it does not\n    /// validate the checksum, assuming the filesystem does not suffer from\n    /// corruption or manipulation.\n    fn download(&mut self, pkg: PackageId, checksum: &str) -> CargoResult<MaybeLock>;\n\n    /// Finish a download by saving a `.crate` file to disk.\n    ///\n    /// After [`crate::core::package::Downloads`] has finished a download,\n    /// it will call this to save the `.crate` file. This is only relevant\n    /// for remote registries. This should validate the checksum and save\n    /// the given data to the on-disk cache.\n    ///\n    /// Returns a [`File`] handle to the `.crate` file, positioned at the start.\n    fn finish_download(&mut self, pkg: PackageId, checksum: &str, data: &[u8])\n        -> CargoResult<File>;\n\n    /// Returns whether or not the `.crate` file is already downloaded.\n    fn is_crate_downloaded(&self, _pkg: PackageId) -> bool {\n        true\n    }\n\n    /// Validates that the global package cache lock is held.\n    ///\n    /// Given the [`Filesystem`], this will make sure that the package cache\n    /// lock is held. If not, it will panic. See\n    /// [`Config::acquire_package_cache_lock`] for acquiring the global lock.\n    ///\n    /// Returns the [`Path`] to the [`Filesystem`].\n    fn assert_index_locked<'a>(&self, path: &'a Filesystem) -> &'a Path;\n\n    /// Block until all outstanding Poll::Pending requests are Poll::Ready.\n    fn block_until_ready(&mut self) -> CargoResult<()>;\n}\n\n/// The status of [`RegistryData::download`] which indicates if a `.crate`\n/// file has already been downloaded, or if not then the URL to download.\npub enum MaybeLock {\n    /// The `.crate` file is already downloaded. [`File`] is a handle to the\n    /// opened `.crate` file on the filesystem.\n    Ready(File),\n    /// The `.crate` file is not downloaded, here's the URL to download it from.\n    ///\n    /// `descriptor` is just a text string to display to the user of what is\n    /// being downloaded.\n    Download {\n        url: String,\n        descriptor: String,\n        authorization: Option<String>,\n    },\n}\n\nmod download;\nmod http_remote;\nmod index;\nmod local;\nmod remote;\n\n/// Generates a unique name for [`SourceId`] to have a unique path to put their\n/// index files.\nfn short_name(id: SourceId, is_shallow: bool) -> String {\n    let hash = hex::short_hash(&id);\n    let ident = id.url().host_str().unwrap_or(\"\").to_string();\n    let mut name = format!(\"{}-{}\", ident, hash);\n    if is_shallow {\n        name.push_str(\"-shallow\");\n    }\n    name\n}\n\nimpl<'cfg> RegistrySource<'cfg> {\n    /// Creates a [`Source`] of a \"remote\" registry.\n    /// It could be either an HTTP-based [`http_remote::HttpRegistry`] or\n    /// a Git-based [`remote::RemoteRegistry`].\n    ///\n    /// * `yanked_whitelist` --- Packages allowed to be used, even if they are yanked.\n    pub fn remote(\n        source_id: SourceId,\n        yanked_whitelist: &HashSet<PackageId>,\n        config: &'cfg Config,\n    ) -> CargoResult<RegistrySource<'cfg>> {\n        assert!(source_id.is_remote_registry());\n        let name = short_name(\n            source_id,\n            config\n                .cli_unstable()\n                .gitoxide\n                .map_or(false, |gix| gix.fetch && gix.shallow_index)\n                && !source_id.is_sparse(),\n        );\n        let ops = if source_id.is_sparse() {\n            Box::new(http_remote::HttpRegistry::new(source_id, config, &name)?) as Box<_>\n        } else {\n            Box::new(remote::RemoteRegistry::new(source_id, config, &name)) as Box<_>\n        };\n\n        Ok(RegistrySource::new(\n            source_id,\n            config,\n            &name,\n            ops,\n            yanked_whitelist,\n        ))\n    }\n\n    /// Creates a [`Source`] of a local registry, with [`local::LocalRegistry`] under the hood.\n    ///\n    /// * `path` --- The root path of a local registry on the file system.\n    /// * `yanked_whitelist` --- Packages allowed to be used, even if they are yanked.\n    pub fn local(\n        source_id: SourceId,\n        path: &Path,\n        yanked_whitelist: &HashSet<PackageId>,\n        config: &'cfg Config,\n    ) -> RegistrySource<'cfg> {\n        let name = short_name(source_id, false);\n        let ops = local::LocalRegistry::new(path, config, &name);\n        RegistrySource::new(source_id, config, &name, Box::new(ops), yanked_whitelist)\n    }\n\n    /// Creates a source of a registry. This is a inner helper function.\n    ///\n    /// * `name` --- Name of a path segment which may affect where `.crate`\n    ///   tarballs, the registry index and cache are stored. Expect to be unique.\n    /// * `ops` --- The underlying [`RegistryData`] type.\n    /// * `yanked_whitelist` --- Packages allowed to be used, even if they are yanked.\n    fn new(\n        source_id: SourceId,\n        config: &'cfg Config,\n        name: &str,\n        ops: Box<dyn RegistryData + 'cfg>,\n        yanked_whitelist: &HashSet<PackageId>,\n    ) -> RegistrySource<'cfg> {\n        RegistrySource {\n            src_path: config.registry_source_path().join(name),\n            config,\n            source_id,\n            index: index::RegistryIndex::new(source_id, ops.index_path(), config),\n            yanked_whitelist: yanked_whitelist.clone(),\n            ops,\n        }\n    }\n\n    /// Decode the [configuration](RegistryConfig) stored within the registry.\n    ///\n    /// This requires that the index has been at least checked out.\n    pub fn config(&mut self) -> Poll<CargoResult<Option<RegistryConfig>>> {\n        self.ops.config()\n    }\n\n    /// Unpacks a downloaded package into a location where it's ready to be\n    /// compiled.\n    ///\n    /// No action is taken if the source looks like it's already unpacked.\n    ///\n    /// # History of interruption detection with `.cargo-ok` file\n    ///\n    /// Cargo has always included a `.cargo-ok` file ([`PACKAGE_SOURCE_LOCK`])\n    /// to detect if extraction was interrupted, but it was originally empty.\n    ///\n    /// In 1.34, Cargo was changed to create the `.cargo-ok` file before it\n    /// started extraction to implement fine-grained locking. After it was\n    /// finished extracting, it wrote two bytes to indicate it was complete.\n    /// It would use the length check to detect if it was possibly interrupted.\n    ///\n    /// In 1.36, Cargo changed to not use fine-grained locking, and instead used\n    /// a global lock. The use of `.cargo-ok` was no longer needed for locking\n    /// purposes, but was kept to detect when extraction was interrupted.\n    ///\n    /// In 1.49, Cargo changed to not create the `.cargo-ok` file before it\n    /// started extraction to deal with `.crate` files that inexplicably had\n    /// a `.cargo-ok` file in them.\n    ///\n    /// In 1.64, Cargo changed to detect `.crate` files with `.cargo-ok` files\n    /// in them in response to [CVE-2022-36113], which dealt with malicious\n    /// `.crate` files making `.cargo-ok` a symlink causing cargo to write \"ok\"\n    /// to any arbitrary file on the filesystem it has permission to.\n    ///\n    /// In 1.71, `.cargo-ok` changed to contain a JSON `{ v: 1 }` to indicate\n    /// the version of it. A failure of parsing will result in a heavy-hammer\n    /// approach that unpacks the `.crate` file again. This is in response to a\n    /// security issue that the unpacking didn't respect umask on Unix systems.\n    ///\n    /// This is all a long-winded way of explaining the circumstances that might\n    /// cause a directory to contain a `.cargo-ok` file that is empty or\n    /// otherwise corrupted. Either this was extracted by a version of Rust\n    /// before 1.34, in which case everything should be fine. However, an empty\n    /// file created by versions 1.36 to 1.49 indicates that the extraction was\n    /// interrupted and that we need to start again.\n    ///\n    /// Another possibility is that the filesystem is simply corrupted, in\n    /// which case deleting the directory might be the safe thing to do. That\n    /// is probably unlikely, though.\n    ///\n    /// To be safe, we deletes the directory and starts over again if an empty\n    /// `.cargo-ok` file is found.\n    ///\n    /// [CVE-2022-36113]: https://blog.rust-lang.org/2022/09/14/cargo-cves.html#arbitrary-file-corruption-cve-2022-36113\n    fn unpack_package(&self, pkg: PackageId, tarball: &File) -> CargoResult<PathBuf> {\n        let package_dir = format!(\"{}-{}\", pkg.name(), pkg.version());\n        let dst = self.src_path.join(&package_dir);\n        let path = dst.join(PACKAGE_SOURCE_LOCK);\n        let path = self.config.assert_package_cache_locked(&path);\n        let unpack_dir = path.parent().unwrap();\n        match fs::read_to_string(path) {\n            Ok(ok) => match serde_json::from_str::<LockMetadata>(&ok) {\n                Ok(lock_meta) if lock_meta.v == 1 => {\n                    return Ok(unpack_dir.to_path_buf());\n                }\n                _ => {\n                    if ok == \"ok\" {\n                        log::debug!(\"old `ok` content found, clearing cache\");\n                    } else {\n                        log::warn!(\"unrecognized .cargo-ok content, clearing cache: {ok}\");\n                    }\n                    // See comment of `unpack_package` about why removing all stuff.\n                    paths::remove_dir_all(dst.as_path_unlocked())?;\n                }\n            },\n            Err(e) if e.kind() == io::ErrorKind::NotFound => {}\n            Err(e) => anyhow::bail!(\"unable to read .cargo-ok file at {path:?}: {e}\"),\n        }\n        dst.create_dir()?;\n        let mut tar = {\n            let size_limit = max_unpack_size(self.config, tarball.metadata()?.len());\n            let gz = GzDecoder::new(tarball);\n            let gz = LimitErrorReader::new(gz, size_limit);\n            let mut tar = Archive::new(gz);\n            set_mask(&mut tar);\n            tar\n        };\n        let prefix = unpack_dir.file_name().unwrap();\n        let parent = unpack_dir.parent().unwrap();\n        for entry in tar.entries()? {\n            let mut entry = entry.with_context(|| \"failed to iterate over archive\")?;\n            let entry_path = entry\n                .path()\n                .with_context(|| \"failed to read entry path\")?\n                .into_owned();\n\n            // We're going to unpack this tarball into the global source\n            // directory, but we want to make sure that it doesn't accidentally\n            // (or maliciously) overwrite source code from other crates. Cargo\n            // itself should never generate a tarball that hits this error, and\n            // crates.io should also block uploads with these sorts of tarballs,\n            // but be extra sure by adding a check here as well.\n            if !entry_path.starts_with(prefix) {\n                anyhow::bail!(\n                    \"invalid tarball downloaded, contains \\\n                     a file at {:?} which isn't under {:?}\",\n                    entry_path,\n                    prefix\n                )\n            }\n            // Prevent unpacking the lockfile from the crate itself.\n            if entry_path\n                .file_name()\n                .map_or(false, |p| p == PACKAGE_SOURCE_LOCK)\n            {\n                continue;\n            }\n            // Unpacking failed\n            let mut result = entry.unpack_in(parent).map_err(anyhow::Error::from);\n            if cfg!(windows) && restricted_names::is_windows_reserved_path(&entry_path) {\n                result = result.with_context(|| {\n                    format!(\n                        \"`{}` appears to contain a reserved Windows path, \\\n                        it cannot be extracted on Windows\",\n                        entry_path.display()\n                    )\n                });\n            }\n            result\n                .with_context(|| format!(\"failed to unpack entry at `{}`\", entry_path.display()))?;\n        }\n\n        // Now that we've finished unpacking, create and write to the lock file to indicate that\n        // unpacking was successful.\n        let mut ok = OpenOptions::new()\n            .create_new(true)\n            .read(true)\n            .write(true)\n            .open(&path)\n            .with_context(|| format!(\"failed to open `{}`\", path.display()))?;\n\n        let lock_meta = LockMetadata { v: 1 };\n        write!(ok, \"{}\", serde_json::to_string(&lock_meta).unwrap())?;\n\n        Ok(unpack_dir.to_path_buf())\n    }\n\n    /// Turns the downloaded `.crate` tarball file into a [`Package`].\n    ///\n    /// This unconditionally sets checksum for the returned package, so it\n    /// should only be called after doing integrity check. That is to say,\n    /// you need to call either [`RegistryData::download`] or\n    /// [`RegistryData::finish_download`] before calling this method.\n    fn get_pkg(&mut self, package: PackageId, path: &File) -> CargoResult<Package> {\n        let path = self\n            .unpack_package(package, path)\n            .with_context(|| format!(\"failed to unpack package `{}`\", package))?;\n        let mut src = PathSource::new(&path, self.source_id, self.config);\n        src.update()?;\n        let mut pkg = match src.download(package)? {\n            MaybePackage::Ready(pkg) => pkg,\n            MaybePackage::Download { .. } => unreachable!(),\n        };\n\n        // After we've loaded the package configure its summary's `checksum`\n        // field with the checksum we know for this `PackageId`.\n        let req = OptVersionReq::exact(package.version());\n        let summary_with_cksum = self\n            .index\n            .summaries(&package.name(), &req, &mut *self.ops)?\n            .expect(\"a downloaded dep now pending!?\")\n            .map(|s| s.summary.clone())\n            .next()\n            .expect(\"summary not found\");\n        if let Some(cksum) = summary_with_cksum.checksum() {\n            pkg.manifest_mut()\n                .summary_mut()\n                .set_checksum(cksum.to_string());\n        }\n\n        Ok(pkg)\n    }\n}\n\nimpl<'cfg> Source for RegistrySource<'cfg> {\n    fn query(\n        &mut self,\n        dep: &Dependency,\n        kind: QueryKind,\n        f: &mut dyn FnMut(Summary),\n    ) -> Poll<CargoResult<()>> {\n        // If this is a precise dependency, then it came from a lock file and in\n        // theory the registry is known to contain this version. If, however, we\n        // come back with no summaries, then our registry may need to be\n        // updated, so we fall back to performing a lazy update.\n        if kind == QueryKind::Exact && dep.source_id().precise().is_some() && !self.ops.is_updated()\n        {\n            debug!(\"attempting query without update\");\n            let mut called = false;\n            ready!(self.index.query_inner(\n                &dep.package_name(),\n                dep.version_req(),\n                &mut *self.ops,\n                &self.yanked_whitelist,\n                &mut |s| {\n                    if dep.matches(&s) {\n                        called = true;\n                        f(s);\n                    }\n                },\n            ))?;\n            if called {\n                Poll::Ready(Ok(()))\n            } else {\n                debug!(\"falling back to an update\");\n                self.invalidate_cache();\n                Poll::Pending\n            }\n        } else {\n            let mut called = false;\n            ready!(self.index.query_inner(\n                &dep.package_name(),\n                dep.version_req(),\n                &mut *self.ops,\n                &self.yanked_whitelist,\n                &mut |s| {\n                    let matched = match kind {\n                        QueryKind::Exact => dep.matches(&s),\n                        QueryKind::Fuzzy => true,\n                    };\n                    if matched {\n                        f(s);\n                        called = true;\n                    }\n                }\n            ))?;\n            if called {\n                return Poll::Ready(Ok(()));\n            }\n            let mut any_pending = false;\n            if kind == QueryKind::Fuzzy {\n                // Attempt to handle misspellings by searching for a chain of related\n                // names to the original name. The resolver will later\n                // reject any candidates that have the wrong name, and with this it'll\n                // along the way produce helpful \"did you mean?\" suggestions.\n                // For now we only try the canonical lysing `-` to `_` and vice versa.\n                // More advanced fuzzy searching become in the future.\n                for name_permutation in [\n                    dep.package_name().replace('-', \"_\"),\n                    dep.package_name().replace('_', \"-\"),\n                ] {\n                    if name_permutation.as_str() == dep.package_name().as_str() {\n                        continue;\n                    }\n                    any_pending |= self\n                        .index\n                        .query_inner(\n                            &name_permutation,\n                            dep.version_req(),\n                            &mut *self.ops,\n                            &self.yanked_whitelist,\n                            f,\n                        )?\n                        .is_pending();\n                }\n            }\n            if any_pending {\n                Poll::Pending\n            } else {\n                Poll::Ready(Ok(()))\n            }\n        }\n    }\n\n    fn supports_checksums(&self) -> bool {\n        true\n    }\n\n    fn requires_precise(&self) -> bool {\n        false\n    }\n\n    fn source_id(&self) -> SourceId {\n        self.source_id\n    }\n\n    fn invalidate_cache(&mut self) {\n        self.index.clear_summaries_cache();\n        self.ops.invalidate_cache();\n    }\n\n    fn set_quiet(&mut self, quiet: bool) {\n        self.ops.set_quiet(quiet);\n    }\n\n    fn download(&mut self, package: PackageId) -> CargoResult<MaybePackage> {\n        let hash = loop {\n            match self.index.hash(package, &mut *self.ops)? {\n                Poll::Pending => self.block_until_ready()?,\n                Poll::Ready(hash) => break hash,\n            }\n        };\n        match self.ops.download(package, hash)? {\n            MaybeLock::Ready(file) => self.get_pkg(package, &file).map(MaybePackage::Ready),\n            MaybeLock::Download {\n                url,\n                descriptor,\n                authorization,\n            } => Ok(MaybePackage::Download {\n                url,\n                descriptor,\n                authorization,\n            }),\n        }\n    }\n\n    fn finish_download(&mut self, package: PackageId, data: Vec<u8>) -> CargoResult<Package> {\n        let hash = loop {\n            match self.index.hash(package, &mut *self.ops)? {\n                Poll::Pending => self.block_until_ready()?,\n                Poll::Ready(hash) => break hash,\n            }\n        };\n        let file = self.ops.finish_download(package, hash, &data)?;\n        self.get_pkg(package, &file)\n    }\n\n    fn fingerprint(&self, pkg: &Package) -> CargoResult<String> {\n        Ok(pkg.package_id().version().to_string())\n    }\n\n    fn describe(&self) -> String {\n        self.source_id.display_index()\n    }\n\n    fn add_to_yanked_whitelist(&mut self, pkgs: &[PackageId]) {\n        self.yanked_whitelist.extend(pkgs);\n    }\n\n    fn is_yanked(&mut self, pkg: PackageId) -> Poll<CargoResult<bool>> {\n        self.index.is_yanked(pkg, &mut *self.ops)\n    }\n\n    fn block_until_ready(&mut self) -> CargoResult<()> {\n        // Before starting to work on the registry, make sure that\n        // `<cargo_home>/registry` is marked as excluded from indexing and\n        // backups. Older versions of Cargo didn't do this, so we do it here\n        // regardless of whether `<cargo_home>` exists.\n        //\n        // This does not use `create_dir_all_excluded_from_backups_atomic` for\n        // the same reason: we want to exclude it even if the directory already\n        // exists.\n        //\n        // IO errors in creating and marking it are ignored, e.g. in case we're on a\n        // read-only filesystem.\n        let registry_base = self.config.registry_base_path();\n        let _ = registry_base.create_dir();\n        exclude_from_backups_and_indexing(&registry_base.into_path_unlocked());\n\n        self.ops.block_until_ready()\n    }\n}\n\nimpl RegistryConfig {\n    /// File name of [`RegistryConfig`].\n    const NAME: &str = \"config.json\";\n}\n\n/// Get the maximum upack size that Cargo permits\n/// based on a given `size` of your compressed file.\n///\n/// Returns the larger one between `size * max compression ratio`\n/// and a fixed max unpacked size.\n///\n/// In reality, the compression ratio usually falls in the range of 2:1 to 10:1.\n/// We choose 20:1 to cover almost all possible cases hopefully.\n/// Any ratio higher than this is considered as a zip bomb.\n///\n/// In the future we might want to introduce a configurable size.\n///\n/// Some of the real world data from common compression algorithms:\n///\n/// * <https://www.zlib.net/zlib_tech.html>\n/// * <https://cran.r-project.org/web/packages/brotli/vignettes/brotli-2015-09-22.pdf>\n/// * <https://blog.cloudflare.com/results-experimenting-brotli/>\n/// * <https://tukaani.org/lzma/benchmarks.html>\nfn max_unpack_size(config: &Config, size: u64) -> u64 {\n    const SIZE_VAR: &str = \"__CARGO_TEST_MAX_UNPACK_SIZE\";\n    const RATIO_VAR: &str = \"__CARGO_TEST_MAX_UNPACK_RATIO\";\n    const MAX_UNPACK_SIZE: u64 = 512 * 1024 * 1024; // 512 MiB\n    const MAX_COMPRESSION_RATIO: usize = 20; // 20:1\n\n    let max_unpack_size = if cfg!(debug_assertions) && config.get_env(SIZE_VAR).is_ok() {\n        // For integration test only.\n        config\n            .get_env(SIZE_VAR)\n            .unwrap()\n            .parse()\n            .expect(\"a max unpack size in bytes\")\n    } else {\n        MAX_UNPACK_SIZE\n    };\n    let max_compression_ratio = if cfg!(debug_assertions) && config.get_env(RATIO_VAR).is_ok() {\n        // For integration test only.\n        config\n            .get_env(RATIO_VAR)\n            .unwrap()\n            .parse()\n            .expect(\"a max compression ratio in bytes\")\n    } else {\n        MAX_COMPRESSION_RATIO\n    };\n\n    u64::max(max_unpack_size, size * max_compression_ratio as u64)\n}\n\n/// Set the current [`umask`] value for the given tarball. No-op on non-Unix\n/// platforms.\n///\n/// On Windows, tar only looks at user permissions and tries to set the \"read\n/// only\" attribute, so no-op as well.\n///\n/// [`umask`]: https://man7.org/linux/man-pages/man2/umask.2.html\n#[allow(unused_variables)]\nfn set_mask<R: Read>(tar: &mut Archive<R>) {\n    #[cfg(unix)]\n    tar.set_mask(crate::util::get_umask());\n}\n", "use std::fmt;\nuse std::path::{Path, PathBuf};\nuse std::time::Duration;\n\npub use self::canonical_url::CanonicalUrl;\npub use self::config::{homedir, Config, ConfigValue};\npub(crate) use self::counter::MetricsCounter;\npub use self::dependency_queue::DependencyQueue;\npub use self::diagnostic_server::RustfixDiagnosticServer;\npub use self::edit_distance::{closest, closest_msg, edit_distance};\npub use self::errors::CliError;\npub use self::errors::{internal, CargoResult, CliResult};\npub use self::flock::{FileLock, Filesystem};\npub use self::graph::Graph;\npub use self::hasher::StableHasher;\npub use self::hex::{hash_u64, short_hash, to_hex};\npub use self::into_url::IntoUrl;\npub use self::into_url_with_base::IntoUrlWithBase;\npub(crate) use self::io::LimitErrorReader;\npub use self::lockserver::{LockServer, LockServerClient, LockServerStarted};\npub use self::progress::{Progress, ProgressStyle};\npub use self::queue::Queue;\npub use self::restricted_names::validate_package_name;\npub use self::rustc::Rustc;\npub use self::semver_ext::{OptVersionReq, VersionExt, VersionReqExt};\npub use self::to_semver::ToSemver;\npub use self::vcs::{existing_vcs_repo, FossilRepo, GitRepo, HgRepo, PijulRepo};\npub use self::workspace::{\n    add_path_args, path_args, print_available_benches, print_available_binaries,\n    print_available_examples, print_available_packages, print_available_tests,\n};\n\npub mod auth;\nmod canonical_url;\npub mod command_prelude;\npub mod config;\nmod counter;\npub mod cpu;\npub mod credential;\nmod dependency_queue;\npub mod diagnostic_server;\npub mod edit_distance;\npub mod errors;\nmod flock;\npub mod graph;\nmod hasher;\npub mod hex;\npub mod important_paths;\npub mod interning;\npub mod into_url;\nmod into_url_with_base;\nmod io;\npub mod job;\nmod lockserver;\npub mod machine_message;\npub mod network;\npub mod profile;\nmod progress;\nmod queue;\npub mod restricted_names;\npub mod rustc;\nmod semver_ext;\npub mod to_semver;\npub mod toml;\npub mod toml_mut;\nmod vcs;\nmod workspace;\n\npub fn elapsed(duration: Duration) -> String {\n    let secs = duration.as_secs();\n\n    if secs >= 60 {\n        format!(\"{}m {:02}s\", secs / 60, secs % 60)\n    } else {\n        format!(\"{}.{:02}s\", secs, duration.subsec_nanos() / 10_000_000)\n    }\n}\n\n/// Formats a number of bytes into a human readable SI-prefixed size.\n/// Returns a tuple of `(quantity, units)`.\npub fn human_readable_bytes(bytes: u64) -> (f32, &'static str) {\n    static UNITS: [&str; 7] = [\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\"];\n    let bytes = bytes as f32;\n    let i = ((bytes.log2() / 10.0) as usize).min(UNITS.len() - 1);\n    (bytes / 1024_f32.powi(i as i32), UNITS[i])\n}\n\npub fn iter_join_onto<W, I, T>(mut w: W, iter: I, delim: &str) -> fmt::Result\nwhere\n    W: fmt::Write,\n    I: IntoIterator<Item = T>,\n    T: std::fmt::Display,\n{\n    let mut it = iter.into_iter().peekable();\n    while let Some(n) = it.next() {\n        write!(w, \"{}\", n)?;\n        if it.peek().is_some() {\n            write!(w, \"{}\", delim)?;\n        }\n    }\n    Ok(())\n}\n\npub fn iter_join<I, T>(iter: I, delim: &str) -> String\nwhere\n    I: IntoIterator<Item = T>,\n    T: std::fmt::Display,\n{\n    let mut s = String::new();\n    let _ = iter_join_onto(&mut s, iter, delim);\n    s\n}\n\npub fn indented_lines(text: &str) -> String {\n    text.lines()\n        .map(|line| {\n            if line.is_empty() {\n                String::from(\"\\n\")\n            } else {\n                format!(\"  {}\\n\", line)\n            }\n        })\n        .collect()\n}\n\npub fn truncate_with_ellipsis(s: &str, max_width: usize) -> String {\n    // We should truncate at grapheme-boundary and compute character-widths,\n    // yet the dependencies on unicode-segmentation and unicode-width are\n    // not worth it.\n    let mut chars = s.chars();\n    let mut prefix = (&mut chars).take(max_width - 1).collect::<String>();\n    if chars.next().is_some() {\n        prefix.push('\u2026');\n    }\n    prefix\n}\n\n#[cfg(not(windows))]\n#[inline]\npub fn try_canonicalize<P: AsRef<Path>>(path: P) -> std::io::Result<PathBuf> {\n    std::fs::canonicalize(&path)\n}\n\n#[cfg(windows)]\n#[inline]\npub fn try_canonicalize<P: AsRef<Path>>(path: P) -> std::io::Result<PathBuf> {\n    use std::ffi::OsString;\n    use std::io::Error;\n    use std::os::windows::ffi::{OsStrExt, OsStringExt};\n    use std::{io::ErrorKind, ptr};\n    use windows_sys::Win32::Foundation::{GetLastError, SetLastError};\n    use windows_sys::Win32::Storage::FileSystem::GetFullPathNameW;\n\n    // On Windows `canonicalize` may fail, so we fall back to getting an absolute path.\n    std::fs::canonicalize(&path).or_else(|_| {\n        // Return an error if a file does not exist for better compatiblity with `canonicalize`\n        if !path.as_ref().try_exists()? {\n            return Err(Error::new(ErrorKind::NotFound, \"the path was not found\"));\n        }\n\n        // This code is based on the unstable `std::path::absolute` and could be replaced with it\n        // if it's stabilized.\n\n        let path = path.as_ref().as_os_str();\n        let mut path_u16 = Vec::with_capacity(path.len() + 1);\n        path_u16.extend(path.encode_wide());\n        if path_u16.iter().find(|c| **c == 0).is_some() {\n            return Err(Error::new(\n                ErrorKind::InvalidInput,\n                \"strings passed to WinAPI cannot contain NULs\",\n            ));\n        }\n        path_u16.push(0);\n\n        loop {\n            unsafe {\n                SetLastError(0);\n                let len =\n                    GetFullPathNameW(path_u16.as_ptr(), 0, &mut [] as *mut u16, ptr::null_mut());\n                if len == 0 {\n                    let error = GetLastError();\n                    if error != 0 {\n                        return Err(Error::from_raw_os_error(error as i32));\n                    }\n                }\n                let mut result = vec![0u16; len as usize];\n\n                let write_len = GetFullPathNameW(\n                    path_u16.as_ptr(),\n                    result.len().try_into().unwrap(),\n                    result.as_mut_ptr().cast::<u16>(),\n                    ptr::null_mut(),\n                );\n                if write_len == 0 {\n                    let error = GetLastError();\n                    if error != 0 {\n                        return Err(Error::from_raw_os_error(error as i32));\n                    }\n                }\n\n                if write_len <= len {\n                    return Ok(PathBuf::from(OsString::from_wide(\n                        &result[0..(write_len as usize)],\n                    )));\n                }\n            }\n        }\n    })\n}\n\n/// Get the current [`umask`] value.\n///\n/// [`umask`]: https://man7.org/linux/man-pages/man2/umask.2.html\n#[cfg(unix)]\npub fn get_umask() -> u32 {\n    use std::sync::OnceLock;\n    static UMASK: OnceLock<libc::mode_t> = OnceLock::new();\n    // SAFETY: Syscalls are unsafe. Calling `umask` twice is even unsafer for\n    // multithreading program, since it doesn't provide a way to retrive the\n    // value without modifications. We use a static `OnceLock` here to ensure\n    // it only gets call once during the entire program lifetime.\n    *UMASK.get_or_init(|| unsafe {\n        let umask = libc::umask(0o022);\n        libc::umask(umask);\n        umask\n    }) as u32 // it is u16 on macos\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_human_readable_bytes() {\n        assert_eq!(human_readable_bytes(0), (0., \"B\"));\n        assert_eq!(human_readable_bytes(8), (8., \"B\"));\n        assert_eq!(human_readable_bytes(1000), (1000., \"B\"));\n        assert_eq!(human_readable_bytes(1024), (1., \"KiB\"));\n        assert_eq!(human_readable_bytes(1024 * 420 + 512), (420.5, \"KiB\"));\n        assert_eq!(human_readable_bytes(1024 * 1024), (1., \"MiB\"));\n        assert_eq!(\n            human_readable_bytes(1024 * 1024 + 1024 * 256),\n            (1.25, \"MiB\")\n        );\n        assert_eq!(human_readable_bytes(1024 * 1024 * 1024), (1., \"GiB\"));\n        assert_eq!(\n            human_readable_bytes((1024. * 1024. * 1024. * 3.1415) as u64),\n            (3.1415, \"GiB\")\n        );\n        assert_eq!(human_readable_bytes(1024 * 1024 * 1024 * 1024), (1., \"TiB\"));\n        assert_eq!(\n            human_readable_bytes(1024 * 1024 * 1024 * 1024 * 1024),\n            (1., \"PiB\")\n        );\n        assert_eq!(\n            human_readable_bytes(1024 * 1024 * 1024 * 1024 * 1024 * 1024),\n            (1., \"EiB\")\n        );\n        assert_eq!(human_readable_bytes(u64::MAX), (16., \"EiB\"));\n    }\n}\n", "//! Tests for normal registry dependencies.\n\nuse cargo::core::SourceId;\nuse cargo_test_support::cargo_process;\nuse cargo_test_support::paths::{self, CargoPathExt};\nuse cargo_test_support::registry::{\n    self, registry_path, Dependency, Package, RegistryBuilder, Response, TestRegistry,\n};\nuse cargo_test_support::{basic_manifest, project};\nuse cargo_test_support::{git, install::cargo_home, t};\nuse cargo_util::paths::remove_dir_all;\nuse std::fmt::Write;\nuse std::fs::{self, File};\nuse std::path::Path;\nuse std::sync::Arc;\nuse std::sync::Mutex;\n\nfn setup_http() -> TestRegistry {\n    RegistryBuilder::new().http_index().build()\n}\n\n#[cargo_test]\nfn test_server_stops() {\n    let server = setup_http();\n    server.join(); // ensure the server fully shuts down\n}\n\n#[cargo_test]\nfn simple_http() {\n    let _server = setup_http();\n    simple();\n}\n\n#[cargo_test]\nfn simple_git() {\n    simple();\n}\n\nfn simple() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\").publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v0.0.1 (registry `dummy-registry`)\n[CHECKING] bar v0.0.1\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n\n    p.cargo(\"clean\").run();\n\n    assert!(paths::home().join(\".cargo/registry/CACHEDIR.TAG\").is_file());\n\n    // Don't download a second time\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[CHECKING] bar v0.0.1\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn deps_http() {\n    let _server = setup_http();\n    deps();\n}\n\n#[cargo_test]\nfn deps_git() {\n    deps();\n}\n\nfn deps() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"baz\", \"0.0.1\").publish();\n    Package::new(\"bar\", \"0.0.1\").dep(\"baz\", \"*\").publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] [..] v0.0.1 (registry `dummy-registry`)\n[DOWNLOADED] [..] v0.0.1 (registry `dummy-registry`)\n[CHECKING] baz v0.0.1\n[CHECKING] bar v0.0.1\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n\n    assert!(paths::home().join(\".cargo/registry/CACHEDIR.TAG\").is_file());\n}\n\n#[cargo_test]\nfn nonexistent_http() {\n    let _server = setup_http();\n    nonexistent();\n}\n\n#[cargo_test]\nfn nonexistent_git() {\n    nonexistent();\n}\n\nfn nonexistent() {\n    Package::new(\"init\", \"0.0.1\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                nonexistent = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[UPDATING] [..] index\nerror: no matching package named `nonexistent` found\nlocation searched: registry [..]\nrequired by package `foo v0.0.1 ([..])`\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn wrong_case_http() {\n    let _server = setup_http();\n    wrong_case();\n}\n\n#[cargo_test]\nfn wrong_case_git() {\n    wrong_case();\n}\n\nfn wrong_case() {\n    Package::new(\"init\", \"0.0.1\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                Init = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    // #5678 to make this work\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[UPDATING] [..] index\nerror: no matching package found\nsearched package name: `Init`\nperhaps you meant:      init\nlocation searched: registry [..]\nrequired by package `foo v0.0.1 ([..])`\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn mis_hyphenated_http() {\n    let _server = setup_http();\n    mis_hyphenated();\n}\n\n#[cargo_test]\nfn mis_hyphenated_git() {\n    mis_hyphenated();\n}\n\nfn mis_hyphenated() {\n    Package::new(\"mis-hyphenated\", \"0.0.1\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                mis_hyphenated = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    // #2775 to make this work\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[UPDATING] [..] index\nerror: no matching package found\nsearched package name: `mis_hyphenated`\nperhaps you meant:      mis-hyphenated\nlocation searched: registry [..]\nrequired by package `foo v0.0.1 ([..])`\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn wrong_version_http() {\n    let _server = setup_http();\n    wrong_version();\n}\n\n#[cargo_test]\nfn wrong_version_git() {\n    wrong_version();\n}\n\nfn wrong_version() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                foo = \">= 1.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"foo\", \"0.0.1\").publish();\n    Package::new(\"foo\", \"0.0.2\").publish();\n\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr_contains(\n            \"\\\nerror: failed to select a version for the requirement `foo = \\\">=1.0.0\\\"`\ncandidate versions found which didn't match: 0.0.2, 0.0.1\nlocation searched: `[..]` index (which is replacing registry `[..]`)\nrequired by package `foo v0.0.1 ([..])`\n\",\n        )\n        .run();\n\n    Package::new(\"foo\", \"0.0.3\").publish();\n    Package::new(\"foo\", \"0.0.4\").publish();\n\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr_contains(\n            \"\\\nerror: failed to select a version for the requirement `foo = \\\">=1.0.0\\\"`\ncandidate versions found which didn't match: 0.0.4, 0.0.3, 0.0.2, ...\nlocation searched: `[..]` index (which is replacing registry `[..]`)\nrequired by package `foo v0.0.1 ([..])`\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn bad_cksum_http() {\n    let _server = setup_http();\n    bad_cksum();\n}\n\n#[cargo_test]\nfn bad_cksum_git() {\n    bad_cksum();\n}\n\nfn bad_cksum() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bad-cksum = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    let pkg = Package::new(\"bad-cksum\", \"0.0.1\");\n    pkg.publish();\n    t!(File::create(&pkg.archive_dst()));\n\n    p.cargo(\"check -v\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[UPDATING] [..] index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bad-cksum [..]\n[ERROR] failed to download replaced source registry `crates-io`\n\nCaused by:\n  failed to verify the checksum of `bad-cksum v0.0.1 (registry `dummy-registry`)`\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn update_registry_http() {\n    let _server = setup_http();\n    update_registry();\n}\n\n#[cargo_test]\nfn update_registry_git() {\n    update_registry();\n}\n\nfn update_registry() {\n    Package::new(\"init\", \"0.0.1\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                notyet = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr_contains(\n            \"\\\nerror: no matching package named `notyet` found\nlocation searched: registry `[..]`\nrequired by package `foo v0.0.1 ([..])`\n\",\n        )\n        .run();\n\n    Package::new(\"notyet\", \"0.0.1\").publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] notyet v0.0.1 (registry `dummy-registry`)\n[CHECKING] notyet v0.0.1\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn package_with_path_deps_http() {\n    let _server = setup_http();\n    package_with_path_deps();\n}\n\n#[cargo_test]\nfn package_with_path_deps_git() {\n    package_with_path_deps();\n}\n\nfn package_with_path_deps() {\n    Package::new(\"init\", \"0.0.1\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n                license = \"MIT\"\n                description = \"foo\"\n                repository = \"bar\"\n\n                [dependencies.notyet]\n                version = \"0.0.1\"\n                path = \"notyet\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .file(\"notyet/Cargo.toml\", &basic_manifest(\"notyet\", \"0.0.1\"))\n        .file(\"notyet/src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"package\")\n        .with_status(101)\n        .with_stderr_contains(\n            \"\\\n[PACKAGING] foo [..]\n[UPDATING] [..]\n[ERROR] failed to prepare local package for uploading\n\nCaused by:\n  no matching package named `notyet` found\n  location searched: registry `crates-io`\n  required by package `foo v0.0.1 [..]`\n\",\n        )\n        .run();\n\n    Package::new(\"notyet\", \"0.0.1\").publish();\n\n    p.cargo(\"package\")\n        .with_stderr(\n            \"\\\n[PACKAGING] foo v0.0.1 ([CWD])\n[UPDATING] `[..]` index\n[VERIFYING] foo v0.0.1 ([CWD])\n[DOWNLOADING] crates ...\n[DOWNLOADED] notyet v0.0.1 (registry `dummy-registry`)\n[COMPILING] notyet v0.0.1\n[COMPILING] foo v0.0.1 ([CWD][..])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n[PACKAGED] [..]\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn lockfile_locks_http() {\n    let _server = setup_http();\n    lockfile_locks();\n}\n\n#[cargo_test]\nfn lockfile_locks_git() {\n    lockfile_locks();\n}\n\nfn lockfile_locks() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\").publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v0.0.1 (registry `dummy-registry`)\n[CHECKING] bar v0.0.1\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n\n    p.root().move_into_the_past();\n    Package::new(\"bar\", \"0.0.2\").publish();\n\n    p.cargo(\"check\").with_stdout(\"\").run();\n}\n\n#[cargo_test]\nfn lockfile_locks_transitively_http() {\n    let _server = setup_http();\n    lockfile_locks_transitively();\n}\n\n#[cargo_test]\nfn lockfile_locks_transitively_git() {\n    lockfile_locks_transitively();\n}\n\nfn lockfile_locks_transitively() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"baz\", \"0.0.1\").publish();\n    Package::new(\"bar\", \"0.0.1\").dep(\"baz\", \"*\").publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] [..] v0.0.1 (registry `dummy-registry`)\n[DOWNLOADED] [..] v0.0.1 (registry `dummy-registry`)\n[CHECKING] baz v0.0.1\n[CHECKING] bar v0.0.1\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n\n    p.root().move_into_the_past();\n    Package::new(\"baz\", \"0.0.2\").publish();\n    Package::new(\"bar\", \"0.0.2\").dep(\"baz\", \"*\").publish();\n\n    p.cargo(\"check\").with_stdout(\"\").run();\n}\n\n#[cargo_test]\nfn yanks_are_not_used_http() {\n    let _server = setup_http();\n    yanks_are_not_used();\n}\n\n#[cargo_test]\nfn yanks_are_not_used_git() {\n    yanks_are_not_used();\n}\n\nfn yanks_are_not_used() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"baz\", \"0.0.1\").publish();\n    Package::new(\"baz\", \"0.0.2\").yanked(true).publish();\n    Package::new(\"bar\", \"0.0.1\").dep(\"baz\", \"*\").publish();\n    Package::new(\"bar\", \"0.0.2\")\n        .dep(\"baz\", \"*\")\n        .yanked(true)\n        .publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] [..] v0.0.1 (registry `dummy-registry`)\n[DOWNLOADED] [..] v0.0.1 (registry `dummy-registry`)\n[CHECKING] baz v0.0.1\n[CHECKING] bar v0.0.1\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn relying_on_a_yank_is_bad_http() {\n    let _server = setup_http();\n    relying_on_a_yank_is_bad();\n}\n\n#[cargo_test]\nfn relying_on_a_yank_is_bad_git() {\n    relying_on_a_yank_is_bad();\n}\n\nfn relying_on_a_yank_is_bad() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"baz\", \"0.0.1\").publish();\n    Package::new(\"baz\", \"0.0.2\").yanked(true).publish();\n    Package::new(\"bar\", \"0.0.1\").dep(\"baz\", \"=0.0.2\").publish();\n\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr_contains(\n            \"\\\nerror: failed to select a version for the requirement `baz = \\\"=0.0.2\\\"`\ncandidate versions found which didn't match: 0.0.1\nlocation searched: `[..]` index (which is replacing registry `[..]`)\nrequired by package `bar v0.0.1`\n    ... which satisfies dependency `bar = \\\"*\\\"` of package `foo [..]`\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn yanks_in_lockfiles_are_ok_http() {\n    let _server = setup_http();\n    yanks_in_lockfiles_are_ok();\n}\n\n#[cargo_test]\nfn yanks_in_lockfiles_are_ok_git() {\n    yanks_in_lockfiles_are_ok();\n}\n\nfn yanks_in_lockfiles_are_ok() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\").publish();\n\n    p.cargo(\"check\").run();\n\n    registry_path().join(\"3\").rm_rf();\n\n    Package::new(\"bar\", \"0.0.1\").yanked(true).publish();\n\n    p.cargo(\"check\").with_stdout(\"\").run();\n\n    p.cargo(\"update\")\n        .with_status(101)\n        .with_stderr_contains(\n            \"\\\nerror: no matching package named `bar` found\nlocation searched: registry [..]\nrequired by package `foo v0.0.1 ([..])`\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn yanks_in_lockfiles_are_ok_for_other_update_http() {\n    let _server = setup_http();\n    yanks_in_lockfiles_are_ok_for_other_update();\n}\n\n#[cargo_test]\nfn yanks_in_lockfiles_are_ok_for_other_update_git() {\n    yanks_in_lockfiles_are_ok_for_other_update();\n}\n\nfn yanks_in_lockfiles_are_ok_for_other_update() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n                baz = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\").publish();\n    Package::new(\"baz\", \"0.0.1\").publish();\n\n    p.cargo(\"check\").run();\n\n    registry_path().join(\"3\").rm_rf();\n\n    Package::new(\"bar\", \"0.0.1\").yanked(true).publish();\n    Package::new(\"baz\", \"0.0.1\").publish();\n\n    p.cargo(\"check\").with_stdout(\"\").run();\n\n    Package::new(\"baz\", \"0.0.2\").publish();\n\n    p.cargo(\"update\")\n        .with_status(101)\n        .with_stderr_contains(\n            \"\\\nerror: no matching package named `bar` found\nlocation searched: registry [..]\nrequired by package `foo v0.0.1 ([..])`\n\",\n        )\n        .run();\n\n    p.cargo(\"update -p baz\")\n        .with_stderr_contains(\n            \"\\\n[UPDATING] `[..]` index\n[UPDATING] baz v0.0.1 -> v0.0.2\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn yanks_in_lockfiles_are_ok_with_new_dep_http() {\n    let _server = setup_http();\n    yanks_in_lockfiles_are_ok_with_new_dep();\n}\n\n#[cargo_test]\nfn yanks_in_lockfiles_are_ok_with_new_dep_git() {\n    yanks_in_lockfiles_are_ok_with_new_dep();\n}\n\nfn yanks_in_lockfiles_are_ok_with_new_dep() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\").publish();\n\n    p.cargo(\"check\").run();\n\n    registry_path().join(\"3\").rm_rf();\n\n    Package::new(\"bar\", \"0.0.1\").yanked(true).publish();\n    Package::new(\"baz\", \"0.0.1\").publish();\n\n    p.change_file(\n        \"Cargo.toml\",\n        r#\"\n            [package]\n            name = \"foo\"\n            version = \"0.0.1\"\n            authors = []\n\n            [dependencies]\n            bar = \"*\"\n            baz = \"*\"\n        \"#,\n    );\n\n    p.cargo(\"check\").with_stdout(\"\").run();\n}\n\n#[cargo_test]\nfn update_with_lockfile_if_packages_missing_http() {\n    let _server = setup_http();\n    update_with_lockfile_if_packages_missing();\n}\n\n#[cargo_test]\nfn update_with_lockfile_if_packages_missing_git() {\n    update_with_lockfile_if_packages_missing();\n}\n\nfn update_with_lockfile_if_packages_missing() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\").publish();\n    p.cargo(\"check\").run();\n    p.root().move_into_the_past();\n\n    paths::home().join(\".cargo/registry\").rm_rf();\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v0.0.1 (registry `dummy-registry`)\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn update_lockfile_http() {\n    let _server = setup_http();\n    update_lockfile();\n}\n\n#[cargo_test]\nfn update_lockfile_git() {\n    update_lockfile();\n}\n\nfn update_lockfile() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    println!(\"0.0.1\");\n    Package::new(\"bar\", \"0.0.1\").publish();\n    p.cargo(\"check\").run();\n\n    Package::new(\"bar\", \"0.0.2\").publish();\n    Package::new(\"bar\", \"0.0.3\").publish();\n    paths::home().join(\".cargo/registry\").rm_rf();\n    println!(\"0.0.2 update\");\n    p.cargo(\"update -p bar --precise 0.0.2\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[UPDATING] bar v0.0.1 -> v0.0.2\n\",\n        )\n        .run();\n\n    println!(\"0.0.2 build\");\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[DOWNLOADING] crates ...\n[DOWNLOADED] [..] v0.0.2 (registry `dummy-registry`)\n[CHECKING] bar v0.0.2\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n\n    println!(\"0.0.3 update\");\n    p.cargo(\"update -p bar\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[UPDATING] bar v0.0.2 -> v0.0.3\n\",\n        )\n        .run();\n\n    println!(\"0.0.3 build\");\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[DOWNLOADING] crates ...\n[DOWNLOADED] [..] v0.0.3 (registry `dummy-registry`)\n[CHECKING] bar v0.0.3\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n\n    println!(\"new dependencies update\");\n    Package::new(\"bar\", \"0.0.4\").dep(\"spam\", \"0.2.5\").publish();\n    Package::new(\"spam\", \"0.2.5\").publish();\n    p.cargo(\"update -p bar\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[UPDATING] bar v0.0.3 -> v0.0.4\n[ADDING] spam v0.2.5\n\",\n        )\n        .run();\n\n    println!(\"new dependencies update\");\n    Package::new(\"bar\", \"0.0.5\").publish();\n    p.cargo(\"update -p bar\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[UPDATING] bar v0.0.4 -> v0.0.5\n[REMOVING] spam v0.2.5\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn dev_dependency_not_used_http() {\n    let _server = setup_http();\n    dev_dependency_not_used();\n}\n\n#[cargo_test]\nfn dev_dependency_not_used_git() {\n    dev_dependency_not_used();\n}\n\nfn dev_dependency_not_used() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"baz\", \"0.0.1\").publish();\n    Package::new(\"bar\", \"0.0.1\").dev_dep(\"baz\", \"*\").publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] [..] v0.0.1 (registry `dummy-registry`)\n[CHECKING] bar v0.0.1\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn bad_license_file_http() {\n    let registry = setup_http();\n    bad_license_file(&registry);\n}\n\n#[cargo_test]\nfn bad_license_file_git() {\n    let registry = registry::init();\n    bad_license_file(&registry);\n}\n\nfn bad_license_file(registry: &TestRegistry) {\n    Package::new(\"foo\", \"1.0.0\").publish();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n                license-file = \"foo\"\n                description = \"bar\"\n                repository = \"baz\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n    p.cargo(\"publish -v\")\n        .replace_crates_io(registry.index_url())\n        .with_status(101)\n        .with_stderr_contains(\"[ERROR] the license file `foo` does not exist\")\n        .run();\n}\n\n#[cargo_test]\nfn updating_a_dep_http() {\n    let _server = setup_http();\n    updating_a_dep();\n}\n\n#[cargo_test]\nfn updating_a_dep_git() {\n    updating_a_dep();\n}\n\nfn updating_a_dep() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies.a]\n                path = \"a\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .file(\n            \"a/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"a\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \"*\"\n            \"#,\n        )\n        .file(\"a/src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\").publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v0.0.1 (registry `dummy-registry`)\n[CHECKING] bar v0.0.1\n[CHECKING] a v0.0.1 ([CWD]/a)\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n    assert!(paths::home().join(\".cargo/registry/CACHEDIR.TAG\").is_file());\n\n    // Now delete the CACHEDIR.TAG file: this is the situation we'll be in after\n    // upgrading from a version of Cargo that doesn't mark this directory, to one that\n    // does. It should be recreated.\n    fs::remove_file(paths::home().join(\".cargo/registry/CACHEDIR.TAG\"))\n        .expect(\"remove CACHEDIR.TAG\");\n\n    p.change_file(\n        \"a/Cargo.toml\",\n        r#\"\n        [package]\n        name = \"a\"\n        version = \"0.0.1\"\n        authors = []\n\n        [dependencies]\n        bar = \"0.1.0\"\n        \"#,\n    );\n    Package::new(\"bar\", \"0.1.0\").publish();\n\n    println!(\"second\");\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v0.1.0 (registry `dummy-registry`)\n[CHECKING] bar v0.1.0\n[CHECKING] a v0.0.1 ([CWD]/a)\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n\n    assert!(\n        paths::home().join(\".cargo/registry/CACHEDIR.TAG\").is_file(),\n        \"CACHEDIR.TAG recreated in existing registry\"\n    );\n}\n\n#[cargo_test]\nfn git_and_registry_dep_http() {\n    let _server = setup_http();\n    git_and_registry_dep();\n}\n\n#[cargo_test]\nfn git_and_registry_dep_git() {\n    git_and_registry_dep();\n}\n\nfn git_and_registry_dep() {\n    let b = git::repo(&paths::root().join(\"b\"))\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"b\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                a = \"0.0.1\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.0.1\"\n                    authors = []\n\n                    [dependencies]\n                    a = \"0.0.1\"\n\n                    [dependencies.b]\n                    git = '{}'\n                \"#,\n                b.url()\n            ),\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"a\", \"0.0.1\").publish();\n\n    p.root().move_into_the_past();\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] [..]\n[UPDATING] [..]\n[DOWNLOADING] crates ...\n[DOWNLOADED] a v0.0.1 (registry `dummy-registry`)\n[CHECKING] a v0.0.1\n[CHECKING] b v0.0.1 ([..])\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n    p.root().move_into_the_past();\n\n    println!(\"second\");\n    p.cargo(\"check\").with_stdout(\"\").run();\n}\n\n#[cargo_test]\nfn update_publish_then_update_http() {\n    let _server = setup_http();\n    update_publish_then_update();\n}\n\n#[cargo_test]\nfn update_publish_then_update_git() {\n    update_publish_then_update();\n}\n\nfn update_publish_then_update() {\n    // First generate a Cargo.lock and a clone of the registry index at the\n    // \"head\" of the current registry.\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                a = \"0.1.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n    Package::new(\"a\", \"0.1.0\").publish();\n    p.cargo(\"build\").run();\n\n    // Next, publish a new package and back up the copy of the registry we just\n    // created.\n    Package::new(\"a\", \"0.1.1\").publish();\n    let registry = paths::home().join(\".cargo/registry\");\n    let backup = paths::root().join(\"registry-backup\");\n    t!(fs::rename(&registry, &backup));\n\n    // Generate a Cargo.lock with the newer version, and then move the old copy\n    // of the registry back into place.\n    let p2 = project()\n        .at(\"foo2\")\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                a = \"0.1.1\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n    p2.cargo(\"build\").run();\n    registry.rm_rf();\n    t!(fs::rename(&backup, &registry));\n    t!(fs::rename(\n        p2.root().join(\"Cargo.lock\"),\n        p.root().join(\"Cargo.lock\")\n    ));\n\n    // Finally, build the first project again (with our newer Cargo.lock) which\n    // should force an update of the old registry, download the new crate, and\n    // then build everything again.\n    p.cargo(\"build\")\n        .with_stderr(\n            \"\\\n[UPDATING] [..]\n[DOWNLOADING] crates ...\n[DOWNLOADED] a v0.1.1 (registry `dummy-registry`)\n[COMPILING] a v0.1.1\n[COMPILING] foo v0.5.0 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn fetch_downloads_http() {\n    let _server = setup_http();\n    fetch_downloads();\n}\n\n#[cargo_test]\nfn fetch_downloads_git() {\n    fetch_downloads();\n}\n\nfn fetch_downloads() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                a = \"0.1.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"a\", \"0.1.0\").publish();\n\n    p.cargo(\"fetch\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] a v0.1.0 (registry [..])\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn update_transitive_dependency_http() {\n    let _server = setup_http();\n    update_transitive_dependency();\n}\n\n#[cargo_test]\nfn update_transitive_dependency_git() {\n    update_transitive_dependency();\n}\n\nfn update_transitive_dependency() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                a = \"0.1.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"a\", \"0.1.0\").dep(\"b\", \"*\").publish();\n    Package::new(\"b\", \"0.1.0\").publish();\n\n    p.cargo(\"fetch\").run();\n\n    Package::new(\"b\", \"0.1.1\").publish();\n\n    p.cargo(\"update -pb\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[UPDATING] b v0.1.0 -> v0.1.1\n\",\n        )\n        .run();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[DOWNLOADING] crates ...\n[DOWNLOADED] b v0.1.1 (registry `dummy-registry`)\n[CHECKING] b v0.1.1\n[CHECKING] a v0.1.0\n[CHECKING] foo v0.5.0 ([..])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn update_backtracking_ok_http() {\n    let _server = setup_http();\n    update_backtracking_ok();\n}\n\n#[cargo_test]\nfn update_backtracking_ok_git() {\n    update_backtracking_ok();\n}\n\nfn update_backtracking_ok() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                webdriver = \"0.1\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"webdriver\", \"0.1.0\")\n        .dep(\"hyper\", \"0.6\")\n        .publish();\n    Package::new(\"hyper\", \"0.6.5\")\n        .dep(\"openssl\", \"0.1\")\n        .dep(\"cookie\", \"0.1\")\n        .publish();\n    Package::new(\"cookie\", \"0.1.0\")\n        .dep(\"openssl\", \"0.1\")\n        .publish();\n    Package::new(\"openssl\", \"0.1.0\").publish();\n\n    p.cargo(\"generate-lockfile\").run();\n\n    Package::new(\"openssl\", \"0.1.1\").publish();\n    Package::new(\"hyper\", \"0.6.6\")\n        .dep(\"openssl\", \"0.1.1\")\n        .dep(\"cookie\", \"0.1.0\")\n        .publish();\n\n    p.cargo(\"update -p hyper\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[UPDATING] hyper v0.6.5 -> v0.6.6\n[UPDATING] openssl v0.1.0 -> v0.1.1\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn update_multiple_packages_http() {\n    let _server = setup_http();\n    update_multiple_packages();\n}\n\n#[cargo_test]\nfn update_multiple_packages_git() {\n    update_multiple_packages();\n}\n\nfn update_multiple_packages() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                a = \"*\"\n                b = \"*\"\n                c = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"a\", \"0.1.0\").publish();\n    Package::new(\"b\", \"0.1.0\").publish();\n    Package::new(\"c\", \"0.1.0\").publish();\n\n    p.cargo(\"fetch\").run();\n\n    Package::new(\"a\", \"0.1.1\").publish();\n    Package::new(\"b\", \"0.1.1\").publish();\n    Package::new(\"c\", \"0.1.1\").publish();\n\n    p.cargo(\"update -pa -pb\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[UPDATING] a v0.1.0 -> v0.1.1\n[UPDATING] b v0.1.0 -> v0.1.1\n\",\n        )\n        .run();\n\n    p.cargo(\"update -pb -pc\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[UPDATING] c v0.1.0 -> v0.1.1\n\",\n        )\n        .run();\n\n    p.cargo(\"check\")\n        .with_stderr_contains(\"[DOWNLOADED] a v0.1.1 (registry `dummy-registry`)\")\n        .with_stderr_contains(\"[DOWNLOADED] b v0.1.1 (registry `dummy-registry`)\")\n        .with_stderr_contains(\"[DOWNLOADED] c v0.1.1 (registry `dummy-registry`)\")\n        .with_stderr_contains(\"[CHECKING] a v0.1.1\")\n        .with_stderr_contains(\"[CHECKING] b v0.1.1\")\n        .with_stderr_contains(\"[CHECKING] c v0.1.1\")\n        .with_stderr_contains(\"[CHECKING] foo v0.5.0 ([..])\")\n        .run();\n}\n\n#[cargo_test]\nfn bundled_crate_in_registry_http() {\n    let _server = setup_http();\n    bundled_crate_in_registry();\n}\n\n#[cargo_test]\nfn bundled_crate_in_registry_git() {\n    bundled_crate_in_registry();\n}\n\nfn bundled_crate_in_registry() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                bar = \"0.1\"\n                baz = \"0.1\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.1.0\").publish();\n    Package::new(\"baz\", \"0.1.0\")\n        .dep(\"bar\", \"0.1.0\")\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"baz\"\n                version = \"0.1.0\"\n                authors = []\n\n                [dependencies]\n                bar = { path = \"bar\", version = \"0.1.0\" }\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .file(\"bar/Cargo.toml\", &basic_manifest(\"bar\", \"0.1.0\"))\n        .file(\"bar/src/lib.rs\", \"\")\n        .publish();\n\n    p.cargo(\"run\").run();\n}\n\n#[cargo_test]\nfn update_same_prefix_oh_my_how_was_this_a_bug_http() {\n    let _server = setup_http();\n    update_same_prefix_oh_my_how_was_this_a_bug();\n}\n\n#[cargo_test]\nfn update_same_prefix_oh_my_how_was_this_a_bug_git() {\n    update_same_prefix_oh_my_how_was_this_a_bug();\n}\n\nfn update_same_prefix_oh_my_how_was_this_a_bug() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"ugh\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"0.1\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"foobar\", \"0.2.0\").publish();\n    Package::new(\"foo\", \"0.1.0\")\n        .dep(\"foobar\", \"0.2.0\")\n        .publish();\n\n    p.cargo(\"generate-lockfile\").run();\n    p.cargo(\"update -pfoobar --precise=0.2.0\").run();\n}\n\n#[cargo_test]\nfn use_semver_http() {\n    let _server = setup_http();\n    use_semver();\n}\n\n#[cargo_test]\nfn use_semver_git() {\n    use_semver();\n}\n\nfn use_semver() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"1.2.3-alpha.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"foo\", \"1.2.3-alpha.0\").publish();\n\n    p.cargo(\"check\").run();\n}\n\n#[cargo_test]\nfn use_semver_package_incorrectly_http() {\n    let _server = setup_http();\n    use_semver_package_incorrectly();\n}\n\n#[cargo_test]\nfn use_semver_package_incorrectly_git() {\n    use_semver_package_incorrectly();\n}\n\nfn use_semver_package_incorrectly() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n            [workspace]\n            members = [\"a\", \"b\"]\n            \"#,\n        )\n        .file(\n            \"a/Cargo.toml\",\n            r#\"\n            [package]\n            name = \"a\"\n            version = \"0.1.1-alpha.0\"\n            authors = []\n            \"#,\n        )\n        .file(\n            \"b/Cargo.toml\",\n            r#\"\n            [package]\n            name = \"b\"\n            version = \"0.1.0\"\n            authors = []\n\n            [dependencies]\n            a = { version = \"^0.1\", path = \"../a\" }\n            \"#,\n        )\n        .file(\"a/src/main.rs\", \"fn main() {}\")\n        .file(\"b/src/main.rs\", \"fn main() {}\")\n        .build();\n\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\nerror: no matching package found\nsearched package name: `a`\nprerelease package needs to be specified explicitly\na = { version = \\\"0.1.1-alpha.0\\\" }\nlocation searched: [..]\nrequired by package `b v0.1.0 ([..])`\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn only_download_relevant_http() {\n    let _server = setup_http();\n    only_download_relevant();\n}\n\n#[cargo_test]\nfn only_download_relevant_git() {\n    only_download_relevant();\n}\n\nfn only_download_relevant() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.5.0\"\n                authors = []\n\n                [target.foo.dependencies]\n                foo = \"*\"\n                [dev-dependencies]\n                bar = \"*\"\n                [dependencies]\n                baz = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"foo\", \"0.1.0\").publish();\n    Package::new(\"bar\", \"0.1.0\").publish();\n    Package::new(\"baz\", \"0.1.0\").publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `[..]` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] baz v0.1.0 ([..])\n[CHECKING] baz v0.1.0\n[CHECKING] bar v0.5.0 ([..])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn resolve_and_backtracking_http() {\n    let _server = setup_http();\n    resolve_and_backtracking();\n}\n\n#[cargo_test]\nfn resolve_and_backtracking_git() {\n    resolve_and_backtracking();\n}\n\nfn resolve_and_backtracking() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"foo\", \"0.1.1\")\n        .feature_dep(\"bar\", \"0.1\", &[\"a\", \"b\"])\n        .publish();\n    Package::new(\"foo\", \"0.1.0\").publish();\n\n    p.cargo(\"check\").run();\n}\n\n#[cargo_test]\nfn upstream_warnings_on_extra_verbose_http() {\n    let _server = setup_http();\n    upstream_warnings_on_extra_verbose();\n}\n\n#[cargo_test]\nfn upstream_warnings_on_extra_verbose_git() {\n    upstream_warnings_on_extra_verbose();\n}\n\nfn upstream_warnings_on_extra_verbose() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"foo\", \"0.1.0\")\n        .file(\"src/lib.rs\", \"fn unused() {}\")\n        .publish();\n\n    p.cargo(\"check -vv\")\n        .with_stderr_contains(\"[WARNING] [..]unused[..]\")\n        .run();\n}\n\n#[cargo_test]\nfn disallow_network_http() {\n    let _server = setup_http();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    p.cargo(\"check --frozen\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[UPDATING] [..]\n[ERROR] failed to get `foo` as a dependency of package `bar v0.5.0 ([..])`\n\nCaused by:\n  failed to query replaced source registry `crates-io`\n\nCaused by:\n  attempting to make an HTTP request, but --frozen was specified\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn disallow_network_git() {\n    let _server = RegistryBuilder::new().build();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"*\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    p.cargo(\"check --frozen\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[ERROR] failed to get `foo` as a dependency of package `bar v0.5.0 [..]`\n\nCaused by:\n  failed to load source for dependency `foo`\n\nCaused by:\n  Unable to update registry `crates-io`\n\nCaused by:\n  failed to update replaced source registry `crates-io`\n\nCaused by:\n  attempting to make an HTTP request, but --frozen was specified\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn add_dep_dont_update_registry_http() {\n    let _server = setup_http();\n    add_dep_dont_update_registry();\n}\n\n#[cargo_test]\nfn add_dep_dont_update_registry_git() {\n    add_dep_dont_update_registry();\n}\n\nfn add_dep_dont_update_registry() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                baz = { path = \"baz\" }\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .file(\n            \"baz/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"baz\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                remote = \"0.3\"\n            \"#,\n        )\n        .file(\"baz/src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"remote\", \"0.3.4\").publish();\n\n    p.cargo(\"check\").run();\n\n    p.change_file(\n        \"Cargo.toml\",\n        r#\"\n        [package]\n        name = \"bar\"\n        version = \"0.5.0\"\n        authors = []\n\n        [dependencies]\n        baz = { path = \"baz\" }\n        remote = \"0.3\"\n        \"#,\n    );\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[CHECKING] bar v0.5.0 ([..])\n[FINISHED] [..]\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn bump_version_dont_update_registry_http() {\n    let _server = setup_http();\n    bump_version_dont_update_registry();\n}\n\n#[cargo_test]\nfn bump_version_dont_update_registry_git() {\n    bump_version_dont_update_registry();\n}\n\nfn bump_version_dont_update_registry() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                baz = { path = \"baz\" }\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .file(\n            \"baz/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"baz\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                remote = \"0.3\"\n            \"#,\n        )\n        .file(\"baz/src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"remote\", \"0.3.4\").publish();\n\n    p.cargo(\"check\").run();\n\n    p.change_file(\n        \"Cargo.toml\",\n        r#\"\n        [package]\n        name = \"bar\"\n        version = \"0.6.0\"\n        authors = []\n\n        [dependencies]\n        baz = { path = \"baz\" }\n        \"#,\n    );\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[CHECKING] bar v0.6.0 ([..])\n[FINISHED] [..]\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn toml_lies_but_index_is_truth_http() {\n    let _server = setup_http();\n    toml_lies_but_index_is_truth();\n}\n\n#[cargo_test]\nfn toml_lies_but_index_is_truth_git() {\n    toml_lies_but_index_is_truth();\n}\n\nfn toml_lies_but_index_is_truth() {\n    Package::new(\"foo\", \"0.2.0\").publish();\n    Package::new(\"bar\", \"0.3.0\")\n        .dep(\"foo\", \"0.2.0\")\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.3.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"0.1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"extern crate foo;\")\n        .publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                bar = \"0.3\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    p.cargo(\"check -v\").run();\n}\n\n#[cargo_test]\nfn vv_prints_warnings_http() {\n    let _server = setup_http();\n    vv_prints_warnings();\n}\n\n#[cargo_test]\nfn vv_prints_warnings_git() {\n    vv_prints_warnings();\n}\n\nfn vv_prints_warnings() {\n    Package::new(\"foo\", \"0.2.0\")\n        .file(\n            \"src/lib.rs\",\n            \"#![deny(warnings)] fn foo() {} // unused function\",\n        )\n        .publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"fo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"0.2\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    p.cargo(\"check -vv\").run();\n}\n\n#[cargo_test]\nfn bad_and_or_malicious_packages_rejected_http() {\n    let _server = setup_http();\n    bad_and_or_malicious_packages_rejected();\n}\n\n#[cargo_test]\nfn bad_and_or_malicious_packages_rejected_git() {\n    bad_and_or_malicious_packages_rejected();\n}\n\nfn bad_and_or_malicious_packages_rejected() {\n    Package::new(\"foo\", \"0.2.0\")\n        .extra_file(\"foo-0.1.0/src/lib.rs\", \"\")\n        .publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"fo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"0.2\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    p.cargo(\"check -vv\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[UPDATING] [..]\n[DOWNLOADING] crates ...\n[DOWNLOADED] [..]\nerror: failed to download [..]\n\nCaused by:\n  failed to unpack [..]\n\nCaused by:\n  [..] contains a file at \\\"foo-0.1.0/src/lib.rs\\\" which isn't under \\\"foo-0.2.0\\\"\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn git_init_templatedir_missing_http() {\n    let _server = setup_http();\n    git_init_templatedir_missing();\n}\n\n#[cargo_test]\nfn git_init_templatedir_missing_git() {\n    git_init_templatedir_missing();\n}\n\nfn git_init_templatedir_missing() {\n    Package::new(\"foo\", \"0.2.0\").dep(\"bar\", \"*\").publish();\n    Package::new(\"bar\", \"0.2.0\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"fo\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = \"0.2\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    p.cargo(\"check\").run();\n\n    remove_dir_all(paths::home().join(\".cargo/registry\")).unwrap();\n    fs::write(\n        paths::home().join(\".gitconfig\"),\n        r#\"\n            [init]\n            templatedir = nowhere\n        \"#,\n    )\n    .unwrap();\n\n    p.cargo(\"check\").run();\n    p.cargo(\"check\").run();\n}\n\n#[cargo_test]\nfn rename_deps_and_features_http() {\n    let _server = setup_http();\n    rename_deps_and_features();\n}\n\n#[cargo_test]\nfn rename_deps_and_features_git() {\n    rename_deps_and_features();\n}\n\nfn rename_deps_and_features() {\n    Package::new(\"foo\", \"0.1.0\")\n        .file(\"src/lib.rs\", \"pub fn f1() {}\")\n        .publish();\n    Package::new(\"foo\", \"0.2.0\")\n        .file(\"src/lib.rs\", \"pub fn f2() {}\")\n        .publish();\n    Package::new(\"bar\", \"0.2.0\")\n        .add_dep(\n            Dependency::new(\"foo01\", \"0.1.0\")\n                .package(\"foo\")\n                .optional(true),\n        )\n        .add_dep(Dependency::new(\"foo02\", \"0.2.0\").package(\"foo\"))\n        .feature(\"another\", &[\"foo01\"])\n        .file(\n            \"src/lib.rs\",\n            r#\"\n                extern crate foo02;\n                #[cfg(feature = \"foo01\")]\n                extern crate foo01;\n\n                pub fn foo() {\n                    foo02::f2();\n                    #[cfg(feature = \"foo01\")]\n                    foo01::f1();\n                }\n            \"#,\n        )\n        .publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"a\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                bar = \"0.2\"\n            \"#,\n        )\n        .file(\n            \"src/main.rs\",\n            \"\n                extern crate bar;\n                fn main() { bar::foo(); }\n            \",\n        )\n        .build();\n\n    p.cargo(\"check\").run();\n    p.cargo(\"check --features bar/foo01\").run();\n    p.cargo(\"check --features bar/another\").run();\n}\n\n#[cargo_test]\nfn ignore_invalid_json_lines_http() {\n    let _server = setup_http();\n    ignore_invalid_json_lines();\n}\n\n#[cargo_test]\nfn ignore_invalid_json_lines_git() {\n    ignore_invalid_json_lines();\n}\n\nfn ignore_invalid_json_lines() {\n    Package::new(\"foo\", \"0.1.0\").publish();\n    Package::new(\"foo\", \"0.1.1\").invalid_json(true).publish();\n    Package::new(\"foo\", \"0.2.0\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"a\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = '0.1.0'\n                foo02 = { version = '0.2.0', package = 'foo' }\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"check\").run();\n}\n\n#[cargo_test]\nfn readonly_registry_still_works_http() {\n    let _server = setup_http();\n    readonly_registry_still_works();\n}\n\n#[cargo_test]\nfn readonly_registry_still_works_git() {\n    readonly_registry_still_works();\n}\n\nfn readonly_registry_still_works() {\n    Package::new(\"foo\", \"0.1.0\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"a\"\n                version = \"0.5.0\"\n                authors = []\n\n                [dependencies]\n                foo = '0.1.0'\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"generate-lockfile\").run();\n    p.cargo(\"fetch --locked\").run();\n    chmod_readonly(&paths::home(), true);\n    p.cargo(\"check\").run();\n    // make sure we un-readonly the files afterwards so \"cargo clean\" can remove them (#6934)\n    chmod_readonly(&paths::home(), false);\n\n    fn chmod_readonly(path: &Path, readonly: bool) {\n        for entry in t!(path.read_dir()) {\n            let entry = t!(entry);\n            let path = entry.path();\n            if t!(entry.file_type()).is_dir() {\n                chmod_readonly(&path, readonly);\n            } else {\n                set_readonly(&path, readonly);\n            }\n        }\n        set_readonly(path, readonly);\n    }\n\n    fn set_readonly(path: &Path, readonly: bool) {\n        let mut perms = t!(path.metadata()).permissions();\n        perms.set_readonly(readonly);\n        t!(fs::set_permissions(path, perms));\n    }\n}\n\n#[cargo_test]\nfn registry_index_rejected_http() {\n    let _server = setup_http();\n    registry_index_rejected();\n}\n\n#[cargo_test]\nfn registry_index_rejected_git() {\n    registry_index_rejected();\n}\n\nfn registry_index_rejected() {\n    Package::new(\"dep\", \"0.1.0\").publish();\n\n    let p = project()\n        .file(\n            \".cargo/config\",\n            r#\"\n            [registry]\n            index = \"https://example.com/\"\n            \"#,\n        )\n        .file(\n            \"Cargo.toml\",\n            r#\"\n            [package]\n            name = \"foo\"\n            version = \"0.1.0\"\n\n            [dependencies]\n            dep = \"0.1\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[ERROR] failed to parse manifest at `[..]/foo/Cargo.toml`\n\nCaused by:\n  the `registry.index` config value is no longer supported\n  Use `[source]` replacement to alter the default index for crates.io.\n\",\n        )\n        .run();\n\n    p.cargo(\"login\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[ERROR] the `registry.index` config value is no longer supported\nUse `[source]` replacement to alter the default index for crates.io.\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn package_lock_inside_package_is_overwritten() {\n    let registry = registry::init();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\")\n        .file(\"src/lib.rs\", \"\")\n        .file(\".cargo-ok\", \"\")\n        .publish();\n\n    p.cargo(\"check\").run();\n\n    let id = SourceId::for_registry(registry.index_url()).unwrap();\n    let hash = cargo::util::hex::short_hash(&id);\n    let ok = cargo_home()\n        .join(\"registry\")\n        .join(\"src\")\n        .join(format!(\"-{}\", hash))\n        .join(\"bar-0.0.1\")\n        .join(\".cargo-ok\");\n\n    assert_eq!(ok.metadata().unwrap().len(), 7);\n}\n\n#[cargo_test]\nfn package_lock_as_a_symlink_inside_package_is_overwritten() {\n    let registry = registry::init();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\")\n        .file(\"src/lib.rs\", \"pub fn f() {}\")\n        .symlink(\".cargo-ok\", \"src/lib.rs\")\n        .publish();\n\n    p.cargo(\"check\").run();\n\n    let id = SourceId::for_registry(registry.index_url()).unwrap();\n    let hash = cargo::util::hex::short_hash(&id);\n    let pkg_root = cargo_home()\n        .join(\"registry\")\n        .join(\"src\")\n        .join(format!(\"-{}\", hash))\n        .join(\"bar-0.0.1\");\n    let ok = pkg_root.join(\".cargo-ok\");\n    let librs = pkg_root.join(\"src/lib.rs\");\n\n    // Is correctly overwritten and doesn't affect the file linked to\n    assert_eq!(ok.metadata().unwrap().len(), 7);\n    assert_eq!(fs::read_to_string(librs).unwrap(), \"pub fn f() {}\");\n}\n\n#[cargo_test]\nfn ignores_unknown_index_version_http() {\n    let _server = setup_http();\n    ignores_unknown_index_version();\n}\n\n#[cargo_test]\nfn ignores_unknown_index_version_git() {\n    ignores_unknown_index_version();\n}\n\nfn ignores_unknown_index_version() {\n    // If the version field is not understood, it is ignored.\n    Package::new(\"bar\", \"1.0.0\").publish();\n    Package::new(\"bar\", \"1.0.1\").schema_version(9999).publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bar = \"1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"tree\")\n        .with_stdout(\n            \"foo v0.1.0 [..]\\n\\\n             \u2514\u2500\u2500 bar v1.0.0\\n\\\n            \",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn protocol() {\n    cargo_process(\"install bar\")\n        .with_status(101)\n        .env(\"CARGO_REGISTRIES_CRATES_IO_PROTOCOL\", \"invalid\")\n        .with_stderr(\"[ERROR] unsupported registry protocol `invalid` (defined in environment variable `CARGO_REGISTRIES_CRATES_IO_PROTOCOL`)\")\n        .run()\n}\n\n#[cargo_test]\nfn http_requires_trailing_slash() {\n    cargo_process(\"install bar --index sparse+https://invalid.crates.io/test\")\n        .with_status(101)\n        .with_stderr(\"[ERROR] sparse registry url must end in a slash `/`: sparse+https://invalid.crates.io/test\")\n        .run()\n}\n\n// Limit the test to debug builds so that `__CARGO_TEST_MAX_UNPACK_SIZE` will take affect.\n#[cfg(debug_assertions)]\n#[cargo_test]\nfn reach_max_unpack_size() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n\n                [dependencies]\n                bar = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    // Size of bar.crate is around 180 bytes.\n    Package::new(\"bar\", \"0.0.1\").publish();\n\n    p.cargo(\"check\")\n        .env(\"__CARGO_TEST_MAX_UNPACK_SIZE\", \"8\") // hit 8 bytes limit and boom!\n        .env(\"__CARGO_TEST_MAX_UNPACK_RATIO\", \"0\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v0.0.1 (registry `dummy-registry`)\n[ERROR] failed to download replaced source registry `crates-io`\n\nCaused by:\n  failed to unpack package `bar v0.0.1 (registry `dummy-registry`)`\n\nCaused by:\n  failed to iterate over archive\n\nCaused by:\n  maximum limit reached when reading\n\",\n        )\n        .run();\n\n    // Restore to the default ratio and it should compile.\n    p.cargo(\"check\")\n        .env(\"__CARGO_TEST_MAX_UNPACK_SIZE\", \"8\")\n        .with_stderr(\n            \"\\\n[CHECKING] bar v0.0.1\n[CHECKING] foo v0.0.1 ([..])\n[FINISHED] dev [..]\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn sparse_retry_single() {\n    let fail_count = Mutex::new(0);\n    let _registry = RegistryBuilder::new()\n        .http_index()\n        .add_responder(\"/index/3/b/bar\", move |req, server| {\n            let mut fail_count = fail_count.lock().unwrap();\n            if *fail_count < 2 {\n                *fail_count += 1;\n                server.internal_server_error(req)\n            } else {\n                server.index(req)\n            }\n        })\n        .build();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                bar = \">= 0.0.0\"\n            \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"bar\", \"0.0.1\").publish();\n\n    p.cargo(\"check\")\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\nwarning: spurious network error (3 tries remaining): failed to get successful HTTP response from `[..]` (127.0.0.1), got 500\nbody:\ninternal server error\nwarning: spurious network error (2 tries remaining): failed to get successful HTTP response from `[..]` (127.0.0.1), got 500\nbody:\ninternal server error\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v0.0.1 (registry `dummy-registry`)\n[CHECKING] bar v0.0.1\n[CHECKING] foo v0.0.1 ([CWD])\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..]s\n\",\n        )\n        .run();\n}\n\n#[cargo_test]\nfn sparse_retry_multiple() {\n    // Tests retry behavior of downloading lots of packages with various\n    // failure rates accessing the sparse index.\n\n    // The index is the number of retries, the value is the number of packages\n    // that retry that number of times. Thus 50 packages succeed on first try,\n    // 25 on second, etc.\n    const RETRIES: &[u32] = &[50, 25, 12, 6];\n\n    let pkgs: Vec<_> = RETRIES\n        .iter()\n        .enumerate()\n        .flat_map(|(retries, num)| {\n            (0..*num)\n                .into_iter()\n                .map(move |n| (retries as u32, format!(\"{}-{n}-{retries}\", rand_prefix())))\n        })\n        .collect();\n\n    let mut builder = RegistryBuilder::new().http_index();\n    let fail_counts: Arc<Mutex<Vec<u32>>> = Arc::new(Mutex::new(vec![0; pkgs.len()]));\n    let mut cargo_toml = r#\"\n        [package]\n        name = \"foo\"\n        version = \"0.1.0\"\n\n        [dependencies]\n        \"#\n    .to_string();\n    // The expected stderr output.\n    let mut expected = \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n\"\n    .to_string();\n    for (n, (retries, name)) in pkgs.iter().enumerate() {\n        let count_clone = fail_counts.clone();\n        let retries = *retries;\n        let ab = &name[..2];\n        let cd = &name[2..4];\n        builder = builder.add_responder(format!(\"/index/{ab}/{cd}/{name}\"), move |req, server| {\n            let mut fail_counts = count_clone.lock().unwrap();\n            if fail_counts[n] < retries {\n                fail_counts[n] += 1;\n                server.internal_server_error(req)\n            } else {\n                server.index(req)\n            }\n        });\n        write!(&mut cargo_toml, \"{name} = \\\"1.0.0\\\"\\n\").unwrap();\n        for retry in 0..retries {\n            let remain = 3 - retry;\n            write!(\n                &mut expected,\n                \"warning: spurious network error ({remain} tries remaining): \\\n                failed to get successful HTTP response from \\\n                `http://127.0.0.1:[..]/{ab}/{cd}/{name}` (127.0.0.1), got 500\\n\\\n                body:\\n\\\n                internal server error\\n\"\n            )\n            .unwrap();\n        }\n        write!(\n            &mut expected,\n            \"[DOWNLOADED] {name} v1.0.0 (registry `dummy-registry`)\\n\"\n        )\n        .unwrap();\n    }\n    let _server = builder.build();\n    for (_, name) in &pkgs {\n        Package::new(name, \"1.0.0\").publish();\n    }\n    let p = project()\n        .file(\"Cargo.toml\", &cargo_toml)\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    p.cargo(\"fetch\").with_stderr_unordered(expected).run();\n}\n\n#[cargo_test]\nfn dl_retry_single() {\n    // Tests retry behavior of downloading a package.\n    // This tests a single package which exercises the code path that causes\n    // it to block.\n    let fail_count = Mutex::new(0);\n    let _server = RegistryBuilder::new()\n        .http_index()\n        .add_responder(\"/dl/bar/1.0.0/download\", move |req, server| {\n            let mut fail_count = fail_count.lock().unwrap();\n            if *fail_count < 2 {\n                *fail_count += 1;\n                server.internal_server_error(req)\n            } else {\n                server.dl(req)\n            }\n        })\n        .build();\n    Package::new(\"bar\", \"1.0.0\").publish();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bar = \"1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    p.cargo(\"fetch\")\n        .with_stderr(\"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\nwarning: spurious network error (3 tries remaining): \\\n    failed to get successful HTTP response from `http://127.0.0.1:[..]/dl/bar/1.0.0/download` (127.0.0.1), got 500\nbody:\ninternal server error\nwarning: spurious network error (2 tries remaining): \\\n    failed to get successful HTTP response from `http://127.0.0.1:[..]/dl/bar/1.0.0/download` (127.0.0.1), got 500\nbody:\ninternal server error\n[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)\n\").run();\n}\n\n/// Creates a random prefix to randomly spread out the package names\n/// to somewhat evenly distribute the different failures at different\n/// points.\nfn rand_prefix() -> String {\n    use rand::Rng;\n    const CHARS: &[u8] = b\"abcdefghijklmnopqrstuvwxyz\";\n    let mut rng = rand::thread_rng();\n    (0..5)\n        .map(|_| CHARS[rng.gen_range(0..CHARS.len())] as char)\n        .collect()\n}\n\n#[cargo_test]\nfn dl_retry_multiple() {\n    // Tests retry behavior of downloading lots of packages with various\n    // failure rates.\n\n    // The index is the number of retries, the value is the number of packages\n    // that retry that number of times. Thus 50 packages succeed on first try,\n    // 25 on second, etc.\n    const RETRIES: &[u32] = &[50, 25, 12, 6];\n\n    let pkgs: Vec<_> = RETRIES\n        .iter()\n        .enumerate()\n        .flat_map(|(retries, num)| {\n            (0..*num)\n                .into_iter()\n                .map(move |n| (retries as u32, format!(\"{}-{n}-{retries}\", rand_prefix())))\n        })\n        .collect();\n\n    let mut builder = RegistryBuilder::new().http_index();\n    let fail_counts: Arc<Mutex<Vec<u32>>> = Arc::new(Mutex::new(vec![0; pkgs.len()]));\n    let mut cargo_toml = r#\"\n        [package]\n        name = \"foo\"\n        version = \"0.1.0\"\n\n        [dependencies]\n        \"#\n    .to_string();\n    // The expected stderr output.\n    let mut expected = \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n\"\n    .to_string();\n    for (n, (retries, name)) in pkgs.iter().enumerate() {\n        let count_clone = fail_counts.clone();\n        let retries = *retries;\n        builder =\n            builder.add_responder(format!(\"/dl/{name}/1.0.0/download\"), move |req, server| {\n                let mut fail_counts = count_clone.lock().unwrap();\n                if fail_counts[n] < retries {\n                    fail_counts[n] += 1;\n                    server.internal_server_error(req)\n                } else {\n                    server.dl(req)\n                }\n            });\n        write!(&mut cargo_toml, \"{name} = \\\"1.0.0\\\"\\n\").unwrap();\n        for retry in 0..retries {\n            let remain = 3 - retry;\n            write!(\n                &mut expected,\n                \"warning: spurious network error ({remain} tries remaining): \\\n                failed to get successful HTTP response from \\\n                `http://127.0.0.1:[..]/dl/{name}/1.0.0/download` (127.0.0.1), got 500\\n\\\n                body:\\n\\\n                internal server error\\n\"\n            )\n            .unwrap();\n        }\n        write!(\n            &mut expected,\n            \"[DOWNLOADED] {name} v1.0.0 (registry `dummy-registry`)\\n\"\n        )\n        .unwrap();\n    }\n    let _server = builder.build();\n    for (_, name) in &pkgs {\n        Package::new(name, \"1.0.0\").publish();\n    }\n    let p = project()\n        .file(\"Cargo.toml\", &cargo_toml)\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    p.cargo(\"fetch\").with_stderr_unordered(expected).run();\n}\n\n#[cargo_test]\nfn deleted_entry() {\n    // Checks the behavior when a package is removed from the index.\n    // This is done occasionally on crates.io to handle things like\n    // copyright takedowns.\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bar = \"0.1\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    // First, test removing a single version, but leaving an older version.\n    Package::new(\"bar\", \"0.1.0\").publish();\n    let bar_path = Path::new(\"3/b/bar\");\n    let bar_reg_path = registry_path().join(&bar_path);\n    let old_index = fs::read_to_string(&bar_reg_path).unwrap();\n    Package::new(\"bar\", \"0.1.1\").publish();\n    p.cargo(\"tree\")\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v0.1.1 (registry `dummy-registry`)\n\",\n        )\n        .with_stdout(\n            \"\\\nfoo v0.1.0 ([ROOT]/foo)\n\u2514\u2500\u2500 bar v0.1.1\n\",\n        )\n        .run();\n\n    // Remove 0.1.1\n    fs::remove_file(paths::root().join(\"dl/bar/0.1.1/download\")).unwrap();\n    let repo = git2::Repository::open(registry_path()).unwrap();\n    let mut index = repo.index().unwrap();\n    fs::write(&bar_reg_path, &old_index).unwrap();\n    index.add_path(&bar_path).unwrap();\n    index.write().unwrap();\n    git::commit(&repo);\n\n    // With `Cargo.lock` unchanged, it shouldn't have an impact.\n    p.cargo(\"tree\")\n        .with_stderr(\"\")\n        .with_stdout(\n            \"\\\nfoo v0.1.0 ([ROOT]/foo)\n\u2514\u2500\u2500 bar v0.1.1\n\",\n        )\n        .run();\n\n    // Regenerating Cargo.lock should switch to old version.\n    fs::remove_file(p.root().join(\"Cargo.lock\")).unwrap();\n    p.cargo(\"tree\")\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v0.1.0 (registry `dummy-registry`)\n\",\n        )\n        .with_stdout(\n            \"\\\nfoo v0.1.0 ([ROOT]/foo)\n\u2514\u2500\u2500 bar v0.1.0\n\",\n        )\n        .run();\n\n    // Remove the package entirely.\n    fs::remove_file(paths::root().join(\"dl/bar/0.1.0/download\")).unwrap();\n    let mut index = repo.index().unwrap();\n    index.remove(&bar_path, 0).unwrap();\n    index.write().unwrap();\n    git::commit(&repo);\n    fs::remove_file(&bar_reg_path).unwrap();\n\n    // With `Cargo.lock` unchanged, it shouldn't have an impact.\n    p.cargo(\"tree\")\n        .with_stderr(\"\")\n        .with_stdout(\n            \"\\\nfoo v0.1.0 ([ROOT]/foo)\n\u2514\u2500\u2500 bar v0.1.0\n\",\n        )\n        .run();\n\n    // Regenerating Cargo.lock should fail.\n    fs::remove_file(p.root().join(\"Cargo.lock\")).unwrap();\n    p.cargo(\"tree\")\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\nerror: no matching package named `bar` found\nlocation searched: registry `crates-io`\nrequired by package `foo v0.1.0 ([ROOT]/foo)`\n\",\n        )\n        .with_status(101)\n        .run();\n}\n\n#[cargo_test]\nfn corrupted_ok_overwritten() {\n    // Checks what happens if .cargo-ok gets truncated, such as if the file is\n    // created, but the flush/close is interrupted.\n    Package::new(\"bar\", \"1.0.0\").publish();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bar = \"1\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    p.cargo(\"fetch\")\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)\n\",\n        )\n        .run();\n    let ok = glob::glob(\n        paths::home()\n            .join(\".cargo/registry/src/*/bar-1.0.0/.cargo-ok\")\n            .to_str()\n            .unwrap(),\n    )\n    .unwrap()\n    .next()\n    .unwrap()\n    .unwrap();\n    // Simulate cargo being interrupted, or filesystem corruption.\n    fs::write(&ok, \"\").unwrap();\n    assert_eq!(fs::read_to_string(&ok).unwrap(), \"\");\n    p.cargo(\"fetch\").with_stderr(\"\").run();\n    assert_eq!(fs::read_to_string(&ok).unwrap(), r#\"{\"v\":1}\"#);\n}\n\n#[cargo_test]\nfn not_found_permutations() {\n    // Test for querying permutations for a missing dependency.\n    let misses = Arc::new(Mutex::new(Vec::new()));\n    let misses2 = misses.clone();\n    let _registry = RegistryBuilder::new()\n        .http_index()\n        .not_found_handler(move |req, _server| {\n            let mut misses = misses2.lock().unwrap();\n            misses.push(req.url.path().to_string());\n            Response {\n                code: 404,\n                headers: vec![],\n                body: b\"not found\".to_vec(),\n            }\n        })\n        .build();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.0.1\"\n                authors = []\n\n                [dependencies]\n                a-b_c = \"1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"check\")\n        .with_status(101)\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\nerror: no matching package named `a-b_c` found\nlocation searched: registry `crates-io`\nrequired by package `foo v0.0.1 ([ROOT]/foo)`\n\",\n        )\n        .run();\n    let mut misses = misses.lock().unwrap();\n    misses.sort();\n    assert_eq!(\n        &*misses,\n        &[\n            \"/index/a-/b-/a-b-c\",\n            \"/index/a-/b_/a-b_c\",\n            \"/index/a_/b_/a_b_c\"\n        ]\n    );\n}\n\n#[cargo_test]\nfn default_auth_error() {\n    // Check for the error message for an authentication error when default is set.\n    let crates_io = RegistryBuilder::new().http_api().build();\n    let _alternative = RegistryBuilder::new().http_api().alternative().build();\n\n    paths::home().join(\".cargo/credentials.toml\").rm_rf();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n                license = \"MIT\"\n                description = \"foo\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    // Test output before setting the default.\n    p.cargo(\"publish --no-verify\")\n        .replace_crates_io(crates_io.index_url())\n        .with_stderr(\n            \"\\\n[UPDATING] crates.io index\nerror: no token found, please run `cargo login`\nor use environment variable CARGO_REGISTRY_TOKEN\n\",\n        )\n        .with_status(101)\n        .run();\n\n    p.cargo(\"publish --no-verify --registry alternative\")\n        .replace_crates_io(crates_io.index_url())\n        .with_stderr(\n            \"\\\n[UPDATING] `alternative` index\nerror: no token found for `alternative`, please run `cargo login --registry alternative`\nor use environment variable CARGO_REGISTRIES_ALTERNATIVE_TOKEN\n\",\n        )\n        .with_status(101)\n        .run();\n\n    // Test the output with the default.\n    cargo_util::paths::append(\n        &cargo_home().join(\"config\"),\n        br#\"\n            [registry]\n            default = \"alternative\"\n        \"#,\n    )\n    .unwrap();\n\n    p.cargo(\"publish --no-verify\")\n        .replace_crates_io(crates_io.index_url())\n        .with_stderr(\n            \"\\\n[UPDATING] `alternative` index\nerror: no token found for `alternative`, please run `cargo login --registry alternative`\nor use environment variable CARGO_REGISTRIES_ALTERNATIVE_TOKEN\n\",\n        )\n        .with_status(101)\n        .run();\n\n    p.cargo(\"publish --no-verify --registry crates-io\")\n        .replace_crates_io(crates_io.index_url())\n        .with_stderr(\n            \"\\\n[UPDATING] crates.io index\nerror: no token found, please run `cargo login --registry crates-io`\nor use environment variable CARGO_REGISTRY_TOKEN\n\",\n        )\n        .with_status(101)\n        .run();\n}\n\nconst SAMPLE_HEADERS: &[&str] = &[\n    \"x-amz-cf-pop: SFO53-P2\",\n    \"x-amz-cf-id: vEc3osJrCAXVaciNnF4Vev-hZFgnYwmNZtxMKRJ5bF6h9FTOtbTMnA==\",\n    \"x-cache: Hit from cloudfront\",\n    \"server: AmazonS3\",\n    \"x-amz-version-id: pvsJYY_JGsWiSETZvLJKb7DeEW5wWq1W\",\n    \"x-amz-server-side-encryption: AES256\",\n    \"content-type: text/plain\",\n    \"via: 1.1 bcbc5b46216015493e082cfbcf77ef10.cloudfront.net (CloudFront)\",\n];\n\n#[cargo_test]\nfn debug_header_message_index() {\n    // The error message should include some headers for debugging purposes.\n    let _server = RegistryBuilder::new()\n        .http_index()\n        .add_responder(\"/index/3/b/bar\", |_, _| Response {\n            code: 503,\n            headers: SAMPLE_HEADERS.iter().map(|s| s.to_string()).collect(),\n            body: b\"Please slow down\".to_vec(),\n        })\n        .build();\n    Package::new(\"bar\", \"1.0.0\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bar = \"1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    p.cargo(\"fetch\").with_status(101).with_stderr(\"\\\n[UPDATING] `dummy-registry` index\nwarning: spurious network error (3 tries remaining): \\\n    failed to get successful HTTP response from `http://127.0.0.1:[..]/index/3/b/bar` (127.0.0.1), got 503\nbody:\nPlease slow down\nwarning: spurious network error (2 tries remaining): \\\n    failed to get successful HTTP response from `http://127.0.0.1:[..]/index/3/b/bar` (127.0.0.1), got 503\nbody:\nPlease slow down\nwarning: spurious network error (1 tries remaining): \\\n    failed to get successful HTTP response from `http://127.0.0.1:[..]/index/3/b/bar` (127.0.0.1), got 503\nbody:\nPlease slow down\nerror: failed to get `bar` as a dependency of package `foo v0.1.0 ([ROOT]/foo)`\n\nCaused by:\n  failed to query replaced source registry `crates-io`\n\nCaused by:\n  download of 3/b/bar failed\n\nCaused by:\n  failed to get successful HTTP response from `http://127.0.0.1:[..]/index/3/b/bar` (127.0.0.1), got 503\n  debug headers:\n  x-amz-cf-pop: SFO53-P2\n  x-amz-cf-id: vEc3osJrCAXVaciNnF4Vev-hZFgnYwmNZtxMKRJ5bF6h9FTOtbTMnA==\n  x-cache: Hit from cloudfront\n  body:\n  Please slow down\n\").run();\n}\n\n#[cargo_test]\nfn debug_header_message_dl() {\n    // Same as debug_header_message_index, but for the dl endpoint which goes\n    // through a completely different code path.\n    let _server = RegistryBuilder::new()\n        .http_index()\n        .add_responder(\"/dl/bar/1.0.0/download\", |_, _| Response {\n            code: 503,\n            headers: SAMPLE_HEADERS.iter().map(|s| s.to_string()).collect(),\n            body: b\"Please slow down\".to_vec(),\n        })\n        .build();\n    Package::new(\"bar\", \"1.0.0\").publish();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bar = \"1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"fetch\").with_status(101).with_stderr(\"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\nwarning: spurious network error (3 tries remaining): \\\n    failed to get successful HTTP response from `http://127.0.0.1:[..]/dl/bar/1.0.0/download` (127.0.0.1), got 503\nbody:\nPlease slow down\nwarning: spurious network error (2 tries remaining): \\\n    failed to get successful HTTP response from `http://127.0.0.1:[..]/dl/bar/1.0.0/download` (127.0.0.1), got 503\nbody:\nPlease slow down\nwarning: spurious network error (1 tries remaining): \\\n    failed to get successful HTTP response from `http://127.0.0.1:[..]/dl/bar/1.0.0/download` (127.0.0.1), got 503\nbody:\nPlease slow down\nerror: failed to download from `http://127.0.0.1:[..]/dl/bar/1.0.0/download`\n\nCaused by:\n  failed to get successful HTTP response from `http://127.0.0.1:[..]/dl/bar/1.0.0/download` (127.0.0.1), got 503\n  debug headers:\n  x-amz-cf-pop: SFO53-P2\n  x-amz-cf-id: vEc3osJrCAXVaciNnF4Vev-hZFgnYwmNZtxMKRJ5bF6h9FTOtbTMnA==\n  x-cache: Hit from cloudfront\n  body:\n  Please slow down\n\").run();\n}\n\n#[cfg(unix)]\n#[cargo_test]\nfn set_mask_during_unpacking() {\n    use std::os::unix::fs::MetadataExt;\n\n    Package::new(\"bar\", \"1.0.0\")\n        .file_with_mode(\"example.sh\", 0o777, \"#!/bin/sh\")\n        .file_with_mode(\"src/lib.rs\", 0o666, \"\")\n        .publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bar = \"1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"fetch\")\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)\n\",\n        )\n        .run();\n    let src_file_path = |path: &str| {\n        glob::glob(\n            paths::home()\n                .join(\".cargo/registry/src/*/bar-1.0.0/\")\n                .join(path)\n                .to_str()\n                .unwrap(),\n        )\n        .unwrap()\n        .next()\n        .unwrap()\n        .unwrap()\n    };\n\n    let umask = cargo::util::get_umask();\n    let metadata = fs::metadata(src_file_path(\"src/lib.rs\")).unwrap();\n    assert_eq!(metadata.mode() & 0o777, 0o666 & !umask);\n    let metadata = fs::metadata(src_file_path(\"example.sh\")).unwrap();\n    assert_eq!(metadata.mode() & 0o777, 0o777 & !umask);\n}\n\n#[cargo_test]\nfn unpack_again_when_cargo_ok_is_unrecognized() {\n    Package::new(\"bar\", \"1.0.0\").publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bar = \"1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"fetch\")\n        .with_stderr(\n            \"\\\n[UPDATING] `dummy-registry` index\n[DOWNLOADING] crates ...\n[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)\n\",\n        )\n        .run();\n\n    let src_file_path = |path: &str| {\n        glob::glob(\n            paths::home()\n                .join(\".cargo/registry/src/*/bar-1.0.0/\")\n                .join(path)\n                .to_str()\n                .unwrap(),\n        )\n        .unwrap()\n        .next()\n        .unwrap()\n        .unwrap()\n    };\n\n    // Change permissions to simulate the old behavior not respecting umask.\n    let lib_rs = src_file_path(\"src/lib.rs\");\n    let cargo_ok = src_file_path(\".cargo-ok\");\n    let mut perms = fs::metadata(&lib_rs).unwrap().permissions();\n    assert!(!perms.readonly());\n    perms.set_readonly(true);\n    fs::set_permissions(&lib_rs, perms).unwrap();\n    let ok = fs::read_to_string(&cargo_ok).unwrap();\n    assert_eq!(&ok, r#\"{\"v\":1}\"#);\n\n    p.cargo(\"fetch\").with_stderr(\"\").run();\n\n    // Without changing `.cargo-ok`, a unpack won't be triggered.\n    let perms = fs::metadata(&lib_rs).unwrap().permissions();\n    assert!(perms.readonly());\n\n    // Write \"ok\" to simulate the old behavior and trigger the unpack again.\n    fs::write(&cargo_ok, \"ok\").unwrap();\n\n    p.cargo(\"fetch\").with_stderr(\"\").run();\n\n    // Permission has been restored and `.cargo-ok` is in the new format.\n    let perms = fs::metadata(lib_rs).unwrap().permissions();\n    assert!(!perms.readonly());\n    let ok = fs::read_to_string(&cargo_ok).unwrap();\n    assert_eq!(&ok, r#\"{\"v\":1}\"#);\n}\n", "//! Tests for the `cargo vendor` command.\n//!\n//! Note that every test here uses `--respect-source-config` so that the\n//! \"fake\" crates.io is used. Otherwise `vendor` would download the crates.io\n//! index from the network.\n\nuse std::fs;\n\nuse cargo_test_support::git;\nuse cargo_test_support::registry::{self, Package, RegistryBuilder};\nuse cargo_test_support::{basic_lib_manifest, basic_manifest, paths, project, Project};\n\n#[cargo_test]\nfn vendor_simple() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                log = \"0.3.5\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"log\", \"0.3.5\").publish();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    let lock = p.read_file(\"vendor/log/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.3.5\\\"\"));\n\n    add_vendor_config(&p);\n    p.cargo(\"check\").run();\n}\n\n#[cargo_test]\nfn vendor_sample_config() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                log = \"0.3.5\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"log\", \"0.3.5\").publish();\n\n    p.cargo(\"vendor --respect-source-config\")\n        .with_stdout(\n            r#\"[source.crates-io]\nreplace-with = \"vendored-sources\"\n\n[source.vendored-sources]\ndirectory = \"vendor\"\n\"#,\n        )\n        .run();\n}\n\n#[cargo_test]\nfn vendor_sample_config_alt_registry() {\n    let registry = RegistryBuilder::new().alternative().http_index().build();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                log = { version = \"0.3.5\", registry = \"alternative\" }\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"log\", \"0.3.5\").alternative(true).publish();\n\n    p.cargo(\"vendor --respect-source-config\")\n        .with_stdout(format!(\n            r#\"[source.\"{0}\"]\nregistry = \"{0}\"\nreplace-with = \"vendored-sources\"\n\n[source.vendored-sources]\ndirectory = \"vendor\"\n\"#,\n            registry.index_url()\n        ))\n        .run();\n}\n\n#[cargo_test]\nfn vendor_path_specified() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                log = \"0.3.5\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"log\", \"0.3.5\").publish();\n\n    let path = if cfg!(windows) {\n        r#\"deps\\.vendor\"#\n    } else {\n        \"deps/.vendor\"\n    };\n\n    let output = p\n        .cargo(\"vendor --respect-source-config\")\n        .arg(path)\n        .exec_with_output()\n        .unwrap();\n    // Assert against original output to ensure that\n    // path is normalized by `ops::vendor` on Windows.\n    assert_eq!(\n        &String::from_utf8(output.stdout).unwrap(),\n        r#\"[source.crates-io]\nreplace-with = \"vendored-sources\"\n\n[source.vendored-sources]\ndirectory = \"deps/.vendor\"\n\"#\n    );\n\n    let lock = p.read_file(\"deps/.vendor/log/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.3.5\\\"\"));\n}\n\nfn add_vendor_config(p: &Project) {\n    p.change_file(\n        \".cargo/config\",\n        r#\"\n            [source.crates-io]\n            replace-with = 'vendor'\n\n            [source.vendor]\n            directory = 'vendor'\n        \"#,\n    );\n}\n\n#[cargo_test]\nfn package_exclude() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bar = \"0.1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"bar\", \"0.1.0\")\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.1.0\"\n                exclude = [\".*\", \"!.include\", \"!.dotdir/include\"]\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .file(\".exclude\", \"\")\n        .file(\".include\", \"\")\n        .file(\".dotdir/exclude\", \"\")\n        .file(\".dotdir/include\", \"\")\n        .publish();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    let csum = p.read_file(\"vendor/bar/.cargo-checksum.json\");\n    assert!(csum.contains(\".include\"));\n    assert!(!csum.contains(\".exclude\"));\n    assert!(!csum.contains(\".dotdir/exclude\"));\n    // Gitignore doesn't re-include a file in an excluded parent directory,\n    // even if negating it explicitly.\n    assert!(!csum.contains(\".dotdir/include\"));\n}\n\n#[cargo_test]\nfn two_versions() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"0.8.0\"\n                bar = { path = \"bar\" }\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .file(\n            \"bar/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"0.7.0\"\n            \"#,\n        )\n        .file(\"bar/src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"bitflags\", \"0.7.0\").publish();\n    Package::new(\"bitflags\", \"0.8.0\").publish();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n\n    let lock = p.read_file(\"vendor/bitflags/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.8.0\\\"\"));\n    let lock = p.read_file(\"vendor/bitflags-0.7.0/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.7.0\\\"\"));\n\n    add_vendor_config(&p);\n    p.cargo(\"check\").run();\n}\n\n#[cargo_test]\nfn two_explicit_versions() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"0.8.0\"\n                bar = { path = \"bar\" }\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .file(\n            \"bar/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"0.7.0\"\n            \"#,\n        )\n        .file(\"bar/src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"bitflags\", \"0.7.0\").publish();\n    Package::new(\"bitflags\", \"0.8.0\").publish();\n\n    p.cargo(\"vendor --respect-source-config --versioned-dirs\")\n        .run();\n\n    let lock = p.read_file(\"vendor/bitflags-0.8.0/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.8.0\\\"\"));\n    let lock = p.read_file(\"vendor/bitflags-0.7.0/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.7.0\\\"\"));\n\n    add_vendor_config(&p);\n    p.cargo(\"check\").run();\n}\n\n#[cargo_test]\nfn help() {\n    let p = project().build();\n    p.cargo(\"vendor -h\").run();\n}\n\n#[cargo_test]\nfn update_versions() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"0.7.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"bitflags\", \"0.7.0\").publish();\n    Package::new(\"bitflags\", \"0.8.0\").publish();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n\n    let lock = p.read_file(\"vendor/bitflags/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.7.0\\\"\"));\n\n    p.change_file(\n        \"Cargo.toml\",\n        r#\"\n            [package]\n            name = \"foo\"\n            version = \"0.1.0\"\n\n            [dependencies]\n            bitflags = \"0.8.0\"\n        \"#,\n    );\n    p.cargo(\"vendor --respect-source-config\").run();\n\n    let lock = p.read_file(\"vendor/bitflags/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.8.0\\\"\"));\n}\n\n#[cargo_test]\nfn two_lockfiles() {\n    let p = project()\n        .no_manifest()\n        .file(\n            \"foo/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"=0.7.0\"\n            \"#,\n        )\n        .file(\"foo/src/lib.rs\", \"\")\n        .file(\n            \"bar/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"=0.8.0\"\n            \"#,\n        )\n        .file(\"bar/src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"bitflags\", \"0.7.0\").publish();\n    Package::new(\"bitflags\", \"0.8.0\").publish();\n\n    p.cargo(\"vendor --respect-source-config -s bar/Cargo.toml --manifest-path foo/Cargo.toml\")\n        .run();\n\n    let lock = p.read_file(\"vendor/bitflags/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.8.0\\\"\"));\n    let lock = p.read_file(\"vendor/bitflags-0.7.0/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.7.0\\\"\"));\n\n    add_vendor_config(&p);\n    p.cargo(\"check\").cwd(\"foo\").run();\n    p.cargo(\"check\").cwd(\"bar\").run();\n}\n\n#[cargo_test]\nfn test_sync_argument() {\n    let p = project()\n        .no_manifest()\n        .file(\n            \"foo/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"=0.7.0\"\n            \"#,\n        )\n        .file(\"foo/src/lib.rs\", \"\")\n        .file(\n            \"bar/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"=0.8.0\"\n            \"#,\n        )\n        .file(\"bar/src/lib.rs\", \"\")\n        .file(\n            \"baz/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"baz\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"=0.8.0\"\n            \"#,\n        )\n        .file(\"baz/src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"bitflags\", \"0.7.0\").publish();\n    Package::new(\"bitflags\", \"0.8.0\").publish();\n\n    p.cargo(\"vendor --respect-source-config --manifest-path foo/Cargo.toml -s bar/Cargo.toml baz/Cargo.toml test_vendor\")\n        .with_stderr(\"\\\nerror: unexpected argument 'test_vendor' found\n\nUsage: cargo[EXE] vendor [OPTIONS] [path]\n\nFor more information, try '--help'.\",\n        )\n        .with_status(1)\n        .run();\n\n    p.cargo(\"vendor --respect-source-config --manifest-path foo/Cargo.toml -s bar/Cargo.toml -s baz/Cargo.toml test_vendor\")\n        .run();\n\n    let lock = p.read_file(\"test_vendor/bitflags/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.8.0\\\"\"));\n    let lock = p.read_file(\"test_vendor/bitflags-0.7.0/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.7.0\\\"\"));\n}\n\n#[cargo_test]\nfn delete_old_crates() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bitflags = \"=0.7.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"bitflags\", \"0.7.0\").publish();\n    Package::new(\"log\", \"0.3.5\").publish();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    p.read_file(\"vendor/bitflags/Cargo.toml\");\n\n    p.change_file(\n        \"Cargo.toml\",\n        r#\"\n            [package]\n            name = \"foo\"\n            version = \"0.1.0\"\n\n            [dependencies]\n            log = \"=0.3.5\"\n        \"#,\n    );\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    let lock = p.read_file(\"vendor/log/Cargo.toml\");\n    assert!(lock.contains(\"version = \\\"0.3.5\\\"\"));\n    assert!(!p.root().join(\"vendor/bitflags/Cargo.toml\").exists());\n}\n\n#[cargo_test]\nfn ignore_files() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                url = \"1.4.1\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"url\", \"1.4.1\")\n        .file(\"src/lib.rs\", \"\")\n        .file(\"foo.orig\", \"\")\n        .file(\".gitignore\", \"\")\n        .file(\".gitattributes\", \"\")\n        .file(\"foo.rej\", \"\")\n        .publish();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    let csum = p.read_file(\"vendor/url/.cargo-checksum.json\");\n    assert!(!csum.contains(\"foo.orig\"));\n    assert!(!csum.contains(\".gitignore\"));\n    assert!(!csum.contains(\".gitattributes\"));\n    assert!(!csum.contains(\".cargo-ok\"));\n    assert!(!csum.contains(\"foo.rej\"));\n}\n\n#[cargo_test]\nfn included_files_only() {\n    let git = git::new(\"a\", |p| {\n        p.file(\"Cargo.toml\", &basic_lib_manifest(\"a\"))\n            .file(\"src/lib.rs\", \"\")\n            .file(\".gitignore\", \"a\")\n            .file(\"a/b.md\", \"\")\n    });\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.1.0\"\n\n                    [dependencies]\n                    a = {{ git = '{}' }}\n                \"#,\n                git.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    let csum = p.read_file(\"vendor/a/.cargo-checksum.json\");\n    assert!(!csum.contains(\"a/b.md\"));\n}\n\n#[cargo_test]\nfn dependent_crates_in_crates() {\n    let git = git::new(\"a\", |p| {\n        p.file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"a\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                b = { path = 'b' }\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .file(\"b/Cargo.toml\", &basic_lib_manifest(\"b\"))\n        .file(\"b/src/lib.rs\", \"\")\n    });\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.1.0\"\n\n                    [dependencies]\n                    a = {{ git = '{}' }}\n                \"#,\n                git.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    p.read_file(\"vendor/a/.cargo-checksum.json\");\n    p.read_file(\"vendor/b/.cargo-checksum.json\");\n}\n\n#[cargo_test]\nfn vendoring_git_crates() {\n    let git = git::new(\"git\", |p| {\n        p.file(\"Cargo.toml\", &basic_lib_manifest(\"serde_derive\"))\n            .file(\"src/lib.rs\", \"\")\n            .file(\"src/wut.rs\", \"\")\n    });\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.1.0\"\n\n                    [dependencies.serde]\n                    version = \"0.5.0\"\n\n                    [dependencies.serde_derive]\n                    version = \"0.5.0\"\n\n                    [patch.crates-io]\n                    serde_derive = {{ git = '{}' }}\n                \"#,\n                git.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    Package::new(\"serde\", \"0.5.0\")\n        .dep(\"serde_derive\", \"0.5\")\n        .publish();\n    Package::new(\"serde_derive\", \"0.5.0\").publish();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    p.read_file(\"vendor/serde_derive/src/wut.rs\");\n\n    add_vendor_config(&p);\n    p.cargo(\"check\").run();\n}\n\n#[cargo_test]\nfn git_simple() {\n    let git = git::new(\"git\", |p| {\n        p.file(\"Cargo.toml\", &basic_lib_manifest(\"a\"))\n            .file(\"src/lib.rs\", \"\")\n    });\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.1.0\"\n\n                    [dependencies]\n                    a = {{ git = '{}' }}\n                \"#,\n                git.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    let csum = p.read_file(\"vendor/a/.cargo-checksum.json\");\n    assert!(csum.contains(\"\\\"package\\\":null\"));\n}\n\n#[cargo_test]\nfn git_diff_rev() {\n    let (git_project, git_repo) = git::new_repo(\"git\", |p| {\n        p.file(\"Cargo.toml\", &basic_manifest(\"a\", \"0.1.0\"))\n            .file(\"src/lib.rs\", \"\")\n    });\n    let url = git_project.url();\n    let ref_1 = \"v0.1.0\";\n    let ref_2 = \"v0.2.0\";\n\n    git::tag(&git_repo, ref_1);\n\n    git_project.change_file(\"Cargo.toml\", &basic_manifest(\"a\", \"0.2.0\"));\n    git::add(&git_repo);\n    git::commit(&git_repo);\n    git::tag(&git_repo, ref_2);\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.1.0\"\n\n                    [dependencies]\n                    a_1 = {{ package = \"a\", git = '{url}', rev = '{ref_1}' }}\n                    a_2 = {{ package = \"a\", git = '{url}', rev = '{ref_2}' }}\n                \"#\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"vendor --respect-source-config\")\n        .with_stdout(\n            r#\"[source.\"git+file://[..]/git?rev=v0.1.0\"]\ngit = [..]\nrev = \"v0.1.0\"\nreplace-with = \"vendored-sources\"\n\n[source.\"git+file://[..]/git?rev=v0.2.0\"]\ngit = [..]\nrev = \"v0.2.0\"\nreplace-with = \"vendored-sources\"\n\n[source.vendored-sources]\ndirectory = \"vendor\"\n\"#,\n        )\n        .run();\n}\n\n#[cargo_test]\nfn git_duplicate() {\n    let git = git::new(\"a\", |p| {\n        p.file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"a\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                b = { path = 'b' }\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .file(\"b/Cargo.toml\", &basic_lib_manifest(\"b\"))\n        .file(\"b/src/lib.rs\", \"\")\n    });\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.1.0\"\n\n                    [dependencies]\n                    a = {{ git = '{}' }}\n                    b = '0.5.0'\n\n                \"#,\n                git.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    Package::new(\"b\", \"0.5.0\").publish();\n\n    p.cargo(\"vendor --respect-source-config\")\n        .with_stderr(\n            \"\\\n[UPDATING] [..]\n[UPDATING] [..]\n[DOWNLOADING] [..]\n[DOWNLOADED] [..]\nerror: failed to sync\n\nCaused by:\n  found duplicate version of package `b v0.5.0` vendored from two sources:\n\n  <tab>source 1: [..]\n  <tab>source 2: [..]\n\",\n        )\n        .with_status(101)\n        .run();\n}\n\n#[cargo_test]\nfn git_complex() {\n    let git_b = git::new(\"git_b\", |p| {\n        p.file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"b\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                dep_b = { path = 'dep_b' }\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .file(\"dep_b/Cargo.toml\", &basic_lib_manifest(\"dep_b\"))\n        .file(\"dep_b/src/lib.rs\", \"\")\n    });\n\n    let git_a = git::new(\"git_a\", |p| {\n        p.file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"a\"\n                    version = \"0.1.0\"\n\n                    [dependencies]\n                    b = {{ git = '{}' }}\n                    dep_a = {{ path = 'dep_a' }}\n                \"#,\n                git_b.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .file(\"dep_a/Cargo.toml\", &basic_lib_manifest(\"dep_a\"))\n        .file(\"dep_a/src/lib.rs\", \"\")\n    });\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.1.0\"\n\n                    [dependencies]\n                    a = {{ git = '{}' }}\n                \"#,\n                git_a.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    let output = p\n        .cargo(\"vendor --respect-source-config\")\n        .exec_with_output()\n        .unwrap();\n    let output = String::from_utf8(output.stdout).unwrap();\n    p.change_file(\".cargo/config\", &output);\n\n    p.cargo(\"check -v\")\n        .with_stderr_contains(\"[..]foo/vendor/a/src/lib.rs[..]\")\n        .with_stderr_contains(\"[..]foo/vendor/dep_a/src/lib.rs[..]\")\n        .with_stderr_contains(\"[..]foo/vendor/b/src/lib.rs[..]\")\n        .with_stderr_contains(\"[..]foo/vendor/dep_b/src/lib.rs[..]\")\n        .run();\n}\n\n#[cargo_test]\nfn depend_on_vendor_dir_not_deleted() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                libc = \"0.2.30\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    Package::new(\"libc\", \"0.2.30\").publish();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    assert!(p.root().join(\"vendor/libc\").is_dir());\n\n    p.change_file(\n        \"Cargo.toml\",\n        r#\"\n            [package]\n            name = \"foo\"\n            version = \"0.1.0\"\n\n            [dependencies]\n            libc = \"0.2.30\"\n\n            [patch.crates-io]\n            libc = { path = 'vendor/libc' }\n        \"#,\n    );\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    assert!(p.root().join(\"vendor/libc\").is_dir());\n}\n\n#[cargo_test]\nfn ignore_hidden() {\n    // Don't delete files starting with `.`\n    Package::new(\"bar\", \"0.1.0\").publish();\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n            [package]\n            name = \"foo\"\n            version = \"1.0.0\"\n            [dependencies]\n            bar = \"0.1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    p.cargo(\"vendor --respect-source-config\").run();\n    // Add a `.git` directory.\n    let repo = git::init(&p.root().join(\"vendor\"));\n    git::add(&repo);\n    git::commit(&repo);\n    assert!(p.root().join(\"vendor/.git\").exists());\n    // Vendor again, shouldn't change anything.\n    p.cargo(\"vendor --respect-source-config\").run();\n    // .git should not be removed.\n    assert!(p.root().join(\"vendor/.git\").exists());\n    // And just for good measure, make sure no files changed.\n    let mut opts = git2::StatusOptions::new();\n    assert!(repo\n        .statuses(Some(&mut opts))\n        .unwrap()\n        .iter()\n        .all(|status| status.status() == git2::Status::CURRENT));\n}\n\n#[cargo_test]\nfn config_instructions_works() {\n    // Check that the config instructions work for all dependency kinds.\n    registry::alt_init();\n    Package::new(\"dep\", \"0.1.0\").publish();\n    Package::new(\"altdep\", \"0.1.0\").alternative(true).publish();\n    let git_project = git::new(\"gitdep\", |project| {\n        project\n            .file(\"Cargo.toml\", &basic_lib_manifest(\"gitdep\"))\n            .file(\"src/lib.rs\", \"\")\n    });\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                dep = \"0.1\"\n                altdep = {{version=\"0.1\", registry=\"alternative\"}}\n                gitdep = {{git='{}'}}\n                \"#,\n                git_project.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n    let output = p\n        .cargo(\"vendor --respect-source-config\")\n        .exec_with_output()\n        .unwrap();\n    let output = String::from_utf8(output.stdout).unwrap();\n    p.change_file(\".cargo/config\", &output);\n\n    p.cargo(\"check -v\")\n        .with_stderr_contains(\"[..]foo/vendor/dep/src/lib.rs[..]\")\n        .with_stderr_contains(\"[..]foo/vendor/altdep/src/lib.rs[..]\")\n        .with_stderr_contains(\"[..]foo/vendor/gitdep/src/lib.rs[..]\")\n        .run();\n}\n\n#[cargo_test]\nfn git_crlf_preservation() {\n    // Check that newlines don't get changed when you vendor\n    // (will only fail if your system is setup with core.autocrlf=true on windows)\n    let input = \"hello \\nthere\\nmy newline\\nfriends\";\n    let git_project = git::new(\"git\", |p| {\n        p.file(\"Cargo.toml\", &basic_lib_manifest(\"a\"))\n            .file(\"src/lib.rs\", input)\n    });\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.1.0\"\n\n                    [dependencies]\n                    a = {{ git = '{}' }}\n                \"#,\n                git_project.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    fs::write(\n        paths::home().join(\".gitconfig\"),\n        r#\"\n            [core]\n            autocrlf = true\n        \"#,\n    )\n    .unwrap();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    let output = p.read_file(\"vendor/a/src/lib.rs\");\n    assert_eq!(input, output);\n}\n\n#[cargo_test]\n#[cfg(unix)]\nfn vendor_preserves_permissions() {\n    use std::os::unix::fs::MetadataExt;\n\n    Package::new(\"bar\", \"1.0.0\")\n        .file_with_mode(\"example.sh\", 0o755, \"#!/bin/sh\")\n        .file(\"src/lib.rs\", \"\")\n        .publish();\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n\n                [dependencies]\n                bar = \"1.0\"\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n\n    let umask = cargo::util::get_umask();\n    let metadata = fs::metadata(p.root().join(\"vendor/bar/src/lib.rs\")).unwrap();\n    assert_eq!(metadata.mode() & 0o777, 0o644 & !umask);\n    let metadata = fs::metadata(p.root().join(\"vendor/bar/example.sh\")).unwrap();\n    assert_eq!(metadata.mode() & 0o777, 0o755 & !umask);\n}\n\n#[cargo_test]\nfn no_remote_dependency_no_vendor() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n                [package]\n                name = \"foo\"\n                version = \"0.1.0\"\n                [dependencies]\n                bar = { path = \"bar\" }\n            \"#,\n        )\n        .file(\"src/lib.rs\", \"\")\n        .file(\n            \"bar/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version = \"0.1.0\"\n            \"#,\n        )\n        .file(\"bar/src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"vendor\")\n        .with_stderr(\"There is no dependency to vendor in this project.\")\n        .run();\n    assert!(!p.root().join(\"vendor\").exists());\n}\n\n#[cargo_test]\nfn vendor_crate_with_ws_inherit() {\n    let git = git::new(\"ws\", |p| {\n        p.file(\n            \"Cargo.toml\",\n            r#\"\n                [workspace]\n                members = [\"bar\"]\n                [workspace.package]\n                version = \"0.1.0\"\n            \"#,\n        )\n        .file(\n            \"bar/Cargo.toml\",\n            r#\"\n                [package]\n                name = \"bar\"\n                version.workspace = true\n            \"#,\n        )\n        .file(\"bar/src/lib.rs\", \"\")\n    });\n\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            &format!(\n                r#\"\n                    [package]\n                    name = \"foo\"\n                    version = \"0.1.0\"\n\n                    [dependencies]\n                    bar = {{ git = '{}' }}\n                \"#,\n                git.url()\n            ),\n        )\n        .file(\"src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"vendor --respect-source-config\").run();\n    p.change_file(\n        \".cargo/config\",\n        &format!(\n            r#\"\n                [source.\"{}\"]\n                git = \"{}\"\n                replace-with = \"vendor\"\n\n                [source.vendor]\n                directory = \"vendor\"\n            \"#,\n            git.url(),\n            git.url()\n        ),\n    );\n\n    p.cargo(\"check -v\")\n        .with_stderr_contains(\"[..]foo/vendor/bar/src/lib.rs[..]\")\n        .run();\n}\n"], "filenames": ["src/cargo/sources/registry/mod.rs", "src/cargo/util/mod.rs", "tests/testsuite/registry.rs", "tests/testsuite/vendor.rs"], "buggy_code_start_loc": [186, 210, 2549, 1053], "buggy_code_end_loc": [910, 210, 3405, 1058], "fixing_code_start_loc": [187, 211, 2549, 1054], "fixing_code_end_loc": [953, 229, 3532, 1059], "type": "CWE-278", "message": "Cargo downloads the Rust project\u2019s dependencies and compiles the project. Cargo prior to version 0.72.2, bundled with Rust prior to version 1.71.1, did not respect the umask when extracting crate archives on UNIX-like systems. If the user downloaded a crate containing files writeable by any local user, another local user could exploit this to change the source code compiled and executed by the current user. To prevent existing cached extractions from being exploitable, the Cargo binary version 0.72.2 included in Rust 1.71.1 or later will purge caches generated by older Cargo versions automatically. As a workaround, configure one's system to prevent other local users from accessing the Cargo directory, usually located in `~/.cargo`.", "other": {"cve": {"id": "CVE-2023-38497", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-04T16:15:10.370", "lastModified": "2023-08-17T19:15:12.613", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Cargo downloads the Rust project\u2019s dependencies and compiles the project. Cargo prior to version 0.72.2, bundled with Rust prior to version 1.71.1, did not respect the umask when extracting crate archives on UNIX-like systems. If the user downloaded a crate containing files writeable by any local user, another local user could exploit this to change the source code compiled and executed by the current user. To prevent existing cached extractions from being exploitable, the Cargo binary version 0.72.2 included in Rust 1.71.1 or later will purge caches generated by older Cargo versions automatically. As a workaround, configure one's system to prevent other local users from accessing the Cargo directory, usually located in `~/.cargo`."}, {"lang": "es", "value": "Cargo descarga las dependencias del proyecto Rust y compila el proyecto. Cargo antes de la versi\u00f3n 0.72.2, incluido con Rust antes de la versi\u00f3n 1.71.1, no respetaba la umask al extraer archivos crate en sistemas tipo UNIX. Si el usuario descargaba un crate que conten\u00eda archivos escribibles por cualquier usuario local, otro usuario local pod\u00eda aprovecharse de esto para cambiar el c\u00f3digo fuente compilado y ejecutado por el usuario actual. Para evitar que las extracciones en cach\u00e9 existentes puedan ser explotadas, el binario Cargo versi\u00f3n 0.72.2 incluido en Rust 1.71.1 o posterior purgar\u00e1 autom\u00e1ticamente las cach\u00e9s generadas por versiones anteriores de Cargo. Como soluci\u00f3n, configure su sistema para evitar que otros usuarios locales accedan al directorio Cargo, normalmente ubicado en `~/.cargo`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.9, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.5, "impactScore": 5.8}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-278"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-732"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rust-lang:cargo:*:*:*:*:*:rust:*:*", "versionEndExcluding": "0.72.2", "matchCriteriaId": "6B2B9FDF-667F-4909-BBC8-3C6210BF03EC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}]}]}], "references": [{"url": "https://en.wikipedia.org/wiki/Umask", "source": "security-advisories@github.com", "tags": ["Not Applicable"]}, {"url": "https://github.com/rust-lang/cargo/commit/d78bbf4bde3c6b95caca7512f537c6f9721426ff", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/rust-lang/cargo/pull/12443", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch"]}, {"url": "https://github.com/rust-lang/cargo/security/advisories/GHSA-j3xp-wfr4-hx87", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/rust-lang/wg-security-response/tree/main/patches/CVE-2023-38497", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/QGKE6PGM4HIQUHPJRBQAHMELINSGN4H4/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/QMEXGUGPW5OBSQA6URTBNDSU3RAEFOZ4/", "source": "security-advisories@github.com"}, {"url": "https://www.rust-lang.org/policies/security", "source": "security-advisories@github.com", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/rust-lang/cargo/commit/d78bbf4bde3c6b95caca7512f537c6f9721426ff"}}