{"buggy_code": ["# Copyright (C) 2003-2007  Robey Pointer <robeypointer@gmail.com>\n#\n# This file is part of paramiko.\n#\n# Paramiko is free software; you can redistribute it and/or modify it under the\n# terms of the GNU Lesser General Public License as published by the Free\n# Software Foundation; either version 2.1 of the License, or (at your option)\n# any later version.\n#\n# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY\n# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with Paramiko; if not, write to the Free Software Foundation, Inc.,\n# 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n\n\"\"\"\nCommon constants and global variables.\n\"\"\"\nimport logging\nfrom paramiko.py3compat import byte_chr, PY2, bytes_types, text_type, long\n\nMSG_DISCONNECT, MSG_IGNORE, MSG_UNIMPLEMENTED, MSG_DEBUG, \\\n    MSG_SERVICE_REQUEST, MSG_SERVICE_ACCEPT = range(1, 7)\nMSG_KEXINIT, MSG_NEWKEYS = range(20, 22)\nMSG_USERAUTH_REQUEST, MSG_USERAUTH_FAILURE, MSG_USERAUTH_SUCCESS, \\\n    MSG_USERAUTH_BANNER = range(50, 54)\nMSG_USERAUTH_PK_OK = 60\nMSG_USERAUTH_INFO_REQUEST, MSG_USERAUTH_INFO_RESPONSE = range(60, 62)\nMSG_USERAUTH_GSSAPI_RESPONSE, MSG_USERAUTH_GSSAPI_TOKEN = range(60, 62)\nMSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, MSG_USERAUTH_GSSAPI_ERROR,\\\n    MSG_USERAUTH_GSSAPI_ERRTOK, MSG_USERAUTH_GSSAPI_MIC = range(63, 67)\nMSG_GLOBAL_REQUEST, MSG_REQUEST_SUCCESS, MSG_REQUEST_FAILURE = range(80, 83)\nMSG_CHANNEL_OPEN, MSG_CHANNEL_OPEN_SUCCESS, MSG_CHANNEL_OPEN_FAILURE, \\\n    MSG_CHANNEL_WINDOW_ADJUST, MSG_CHANNEL_DATA, MSG_CHANNEL_EXTENDED_DATA, \\\n    MSG_CHANNEL_EOF, MSG_CHANNEL_CLOSE, MSG_CHANNEL_REQUEST, \\\n    MSG_CHANNEL_SUCCESS, MSG_CHANNEL_FAILURE = range(90, 101)\n\ncMSG_DISCONNECT = byte_chr(MSG_DISCONNECT)\ncMSG_IGNORE = byte_chr(MSG_IGNORE)\ncMSG_UNIMPLEMENTED = byte_chr(MSG_UNIMPLEMENTED)\ncMSG_DEBUG = byte_chr(MSG_DEBUG)\ncMSG_SERVICE_REQUEST = byte_chr(MSG_SERVICE_REQUEST)\ncMSG_SERVICE_ACCEPT = byte_chr(MSG_SERVICE_ACCEPT)\ncMSG_KEXINIT = byte_chr(MSG_KEXINIT)\ncMSG_NEWKEYS = byte_chr(MSG_NEWKEYS)\ncMSG_USERAUTH_REQUEST = byte_chr(MSG_USERAUTH_REQUEST)\ncMSG_USERAUTH_FAILURE = byte_chr(MSG_USERAUTH_FAILURE)\ncMSG_USERAUTH_SUCCESS = byte_chr(MSG_USERAUTH_SUCCESS)\ncMSG_USERAUTH_BANNER = byte_chr(MSG_USERAUTH_BANNER)\ncMSG_USERAUTH_PK_OK = byte_chr(MSG_USERAUTH_PK_OK)\ncMSG_USERAUTH_INFO_REQUEST = byte_chr(MSG_USERAUTH_INFO_REQUEST)\ncMSG_USERAUTH_INFO_RESPONSE = byte_chr(MSG_USERAUTH_INFO_RESPONSE)\ncMSG_USERAUTH_GSSAPI_RESPONSE = byte_chr(MSG_USERAUTH_GSSAPI_RESPONSE)\ncMSG_USERAUTH_GSSAPI_TOKEN = byte_chr(MSG_USERAUTH_GSSAPI_TOKEN)\ncMSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE = \\\n    byte_chr(MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE)\ncMSG_USERAUTH_GSSAPI_ERROR = byte_chr(MSG_USERAUTH_GSSAPI_ERROR)\ncMSG_USERAUTH_GSSAPI_ERRTOK = byte_chr(MSG_USERAUTH_GSSAPI_ERRTOK)\ncMSG_USERAUTH_GSSAPI_MIC = byte_chr(MSG_USERAUTH_GSSAPI_MIC)\ncMSG_GLOBAL_REQUEST = byte_chr(MSG_GLOBAL_REQUEST)\ncMSG_REQUEST_SUCCESS = byte_chr(MSG_REQUEST_SUCCESS)\ncMSG_REQUEST_FAILURE = byte_chr(MSG_REQUEST_FAILURE)\ncMSG_CHANNEL_OPEN = byte_chr(MSG_CHANNEL_OPEN)\ncMSG_CHANNEL_OPEN_SUCCESS = byte_chr(MSG_CHANNEL_OPEN_SUCCESS)\ncMSG_CHANNEL_OPEN_FAILURE = byte_chr(MSG_CHANNEL_OPEN_FAILURE)\ncMSG_CHANNEL_WINDOW_ADJUST = byte_chr(MSG_CHANNEL_WINDOW_ADJUST)\ncMSG_CHANNEL_DATA = byte_chr(MSG_CHANNEL_DATA)\ncMSG_CHANNEL_EXTENDED_DATA = byte_chr(MSG_CHANNEL_EXTENDED_DATA)\ncMSG_CHANNEL_EOF = byte_chr(MSG_CHANNEL_EOF)\ncMSG_CHANNEL_CLOSE = byte_chr(MSG_CHANNEL_CLOSE)\ncMSG_CHANNEL_REQUEST = byte_chr(MSG_CHANNEL_REQUEST)\ncMSG_CHANNEL_SUCCESS = byte_chr(MSG_CHANNEL_SUCCESS)\ncMSG_CHANNEL_FAILURE = byte_chr(MSG_CHANNEL_FAILURE)\n\n# for debugging:\nMSG_NAMES = {\n    MSG_DISCONNECT: 'disconnect',\n    MSG_IGNORE: 'ignore',\n    MSG_UNIMPLEMENTED: 'unimplemented',\n    MSG_DEBUG: 'debug',\n    MSG_SERVICE_REQUEST: 'service-request',\n    MSG_SERVICE_ACCEPT: 'service-accept',\n    MSG_KEXINIT: 'kexinit',\n    MSG_NEWKEYS: 'newkeys',\n    30: 'kex30',\n    31: 'kex31',\n    32: 'kex32',\n    33: 'kex33',\n    34: 'kex34',\n    40: 'kex40',\n    41: 'kex41',\n    MSG_USERAUTH_REQUEST: 'userauth-request',\n    MSG_USERAUTH_FAILURE: 'userauth-failure',\n    MSG_USERAUTH_SUCCESS: 'userauth-success',\n    MSG_USERAUTH_BANNER: 'userauth--banner',\n    MSG_USERAUTH_PK_OK: 'userauth-60(pk-ok/info-request)',\n    MSG_USERAUTH_INFO_RESPONSE: 'userauth-info-response',\n    MSG_GLOBAL_REQUEST: 'global-request',\n    MSG_REQUEST_SUCCESS: 'request-success',\n    MSG_REQUEST_FAILURE: 'request-failure',\n    MSG_CHANNEL_OPEN: 'channel-open',\n    MSG_CHANNEL_OPEN_SUCCESS: 'channel-open-success',\n    MSG_CHANNEL_OPEN_FAILURE: 'channel-open-failure',\n    MSG_CHANNEL_WINDOW_ADJUST: 'channel-window-adjust',\n    MSG_CHANNEL_DATA: 'channel-data',\n    MSG_CHANNEL_EXTENDED_DATA: 'channel-extended-data',\n    MSG_CHANNEL_EOF: 'channel-eof',\n    MSG_CHANNEL_CLOSE: 'channel-close',\n    MSG_CHANNEL_REQUEST: 'channel-request',\n    MSG_CHANNEL_SUCCESS: 'channel-success',\n    MSG_CHANNEL_FAILURE: 'channel-failure',\n    MSG_USERAUTH_GSSAPI_RESPONSE: 'userauth-gssapi-response',\n    MSG_USERAUTH_GSSAPI_TOKEN: 'userauth-gssapi-token',\n    MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE: 'userauth-gssapi-exchange-complete',\n    MSG_USERAUTH_GSSAPI_ERROR: 'userauth-gssapi-error',\n    MSG_USERAUTH_GSSAPI_ERRTOK: 'userauth-gssapi-error-token',\n    MSG_USERAUTH_GSSAPI_MIC: 'userauth-gssapi-mic'\n}\n\n\n# authentication request return codes:\nAUTH_SUCCESSFUL, AUTH_PARTIALLY_SUCCESSFUL, AUTH_FAILED = range(3)\n\n\n# channel request failed reasons:\n(OPEN_SUCCEEDED,\n OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED,\n OPEN_FAILED_CONNECT_FAILED,\n OPEN_FAILED_UNKNOWN_CHANNEL_TYPE,\n OPEN_FAILED_RESOURCE_SHORTAGE) = range(0, 5)\n\n\nCONNECTION_FAILED_CODE = {\n    1: 'Administratively prohibited',\n    2: 'Connect failed',\n    3: 'Unknown channel type',\n    4: 'Resource shortage'\n}\n\n\nDISCONNECT_SERVICE_NOT_AVAILABLE, DISCONNECT_AUTH_CANCELLED_BY_USER, \\\n    DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE = 7, 13, 14\n\nzero_byte = byte_chr(0)\none_byte = byte_chr(1)\nfour_byte = byte_chr(4)\nmax_byte = byte_chr(0xff)\ncr_byte = byte_chr(13)\nlinefeed_byte = byte_chr(10)\ncrlf = cr_byte + linefeed_byte\n\nif PY2:\n    cr_byte_value = cr_byte\n    linefeed_byte_value = linefeed_byte\nelse:\n    cr_byte_value = 13\n    linefeed_byte_value = 10\n\n\ndef asbytes(s):\n    \"\"\"Coerce to bytes if possible or return unchanged.\"\"\"\n    if isinstance(s, bytes_types):\n        return s\n    if isinstance(s, text_type):\n        # Accept text and encode as utf-8 for compatibility only.\n        return s.encode(\"utf-8\")\n    asbytes = getattr(s, \"asbytes\", None)\n    if asbytes is not None:\n        return asbytes()\n    # May be an object that implements the buffer api, let callers handle.\n    return s\n\n\nxffffffff = long(0xffffffff)\nx80000000 = long(0x80000000)\no666 = 438\no660 = 432\no644 = 420\no600 = 384\no777 = 511\no700 = 448\no70 = 56\n\nDEBUG = logging.DEBUG\nINFO = logging.INFO\nWARNING = logging.WARNING\nERROR = logging.ERROR\nCRITICAL = logging.CRITICAL\n\n# Common IO/select/etc sleep period, in seconds\nio_sleep = 0.01\n\nDEFAULT_WINDOW_SIZE = 64 * 2 ** 15\nDEFAULT_MAX_PACKET_SIZE = 2 ** 15\n\n# lower bound on the max packet size we'll accept from the remote host\n# Minimum packet size is 32768 bytes according to\n# http://www.ietf.org/rfc/rfc4254.txt\nMIN_WINDOW_SIZE = 2 ** 15\n\n# However, according to http://www.ietf.org/rfc/rfc4253.txt it is perfectly\n# legal to accept a size much smaller, as OpenSSH client does as size 16384.\nMIN_PACKET_SIZE = 2 ** 12\n\n# Max windows size according to http://www.ietf.org/rfc/rfc4254.txt\nMAX_WINDOW_SIZE = 2 ** 32 - 1\n", "# Copyright (C) 2003-2007  Robey Pointer <robeypointer@gmail.com>\n#\n# This file is part of paramiko.\n#\n# Paramiko is free software; you can redistribute it and/or modify it under the\n# terms of the GNU Lesser General Public License as published by the Free\n# Software Foundation; either version 2.1 of the License, or (at your option)\n# any later version.\n#\n# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY\n# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with Paramiko; if not, write to the Free Software Foundation, Inc.,\n# 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n\n\"\"\"\nCore protocol implementation\n\"\"\"\n\nfrom __future__ import print_function\nimport os\nimport socket\nimport sys\nimport threading\nimport time\nimport weakref\nfrom hashlib import md5, sha1, sha256, sha512\n\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.ciphers import algorithms, Cipher, modes\n\nimport paramiko\nfrom paramiko import util\nfrom paramiko.auth_handler import AuthHandler\nfrom paramiko.ssh_gss import GSSAuth\nfrom paramiko.channel import Channel\nfrom paramiko.common import (\n    xffffffff, cMSG_CHANNEL_OPEN, cMSG_IGNORE, cMSG_GLOBAL_REQUEST, DEBUG,\n    MSG_KEXINIT, MSG_IGNORE, MSG_DISCONNECT, MSG_DEBUG, ERROR, WARNING,\n    cMSG_UNIMPLEMENTED, INFO, cMSG_KEXINIT, cMSG_NEWKEYS, MSG_NEWKEYS,\n    cMSG_REQUEST_SUCCESS, cMSG_REQUEST_FAILURE, CONNECTION_FAILED_CODE,\n    OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED, OPEN_SUCCEEDED,\n    cMSG_CHANNEL_OPEN_FAILURE, cMSG_CHANNEL_OPEN_SUCCESS, MSG_GLOBAL_REQUEST,\n    MSG_REQUEST_SUCCESS, MSG_REQUEST_FAILURE, MSG_CHANNEL_OPEN_SUCCESS,\n    MSG_CHANNEL_OPEN_FAILURE, MSG_CHANNEL_OPEN, MSG_CHANNEL_SUCCESS,\n    MSG_CHANNEL_FAILURE, MSG_CHANNEL_DATA, MSG_CHANNEL_EXTENDED_DATA,\n    MSG_CHANNEL_WINDOW_ADJUST, MSG_CHANNEL_REQUEST, MSG_CHANNEL_EOF,\n    MSG_CHANNEL_CLOSE, MIN_WINDOW_SIZE, MIN_PACKET_SIZE, MAX_WINDOW_SIZE,\n    DEFAULT_WINDOW_SIZE, DEFAULT_MAX_PACKET_SIZE,\n)\nfrom paramiko.compress import ZlibCompressor, ZlibDecompressor\nfrom paramiko.dsskey import DSSKey\nfrom paramiko.kex_gex import KexGex, KexGexSHA256\nfrom paramiko.kex_group1 import KexGroup1\nfrom paramiko.kex_group14 import KexGroup14\nfrom paramiko.kex_gss import KexGSSGex, KexGSSGroup1, KexGSSGroup14\nfrom paramiko.message import Message\nfrom paramiko.packet import Packetizer, NeedRekeyException\nfrom paramiko.primes import ModulusPack\nfrom paramiko.py3compat import string_types, long, byte_ord, b, input, PY2\nfrom paramiko.rsakey import RSAKey\nfrom paramiko.ecdsakey import ECDSAKey\nfrom paramiko.server import ServerInterface\nfrom paramiko.sftp_client import SFTPClient\nfrom paramiko.ssh_exception import (\n    SSHException, BadAuthenticationType, ChannelException, ProxyCommandFailure,\n)\nfrom paramiko.util import retry_on_signal, ClosingContextManager, clamp_value\n\n\n# for thread cleanup\n_active_threads = []\n\ndef _join_lingering_threads():\n    for thr in _active_threads:\n        thr.stop_thread()\n\n\nimport atexit\natexit.register(_join_lingering_threads)\n\n\nclass Transport(threading.Thread, ClosingContextManager):\n    \"\"\"\n    An SSH Transport attaches to a stream (usually a socket), negotiates an\n    encrypted session, authenticates, and then creates stream tunnels, called\n    `channels <.Channel>`, across the session.  Multiple channels can be\n    multiplexed across a single session (and often are, in the case of port\n    forwardings).\n\n    Instances of this class may be used as context managers.\n    \"\"\"\n    _ENCRYPT = object()\n    _DECRYPT = object()\n\n    _PROTO_ID = '2.0'\n    _CLIENT_ID = 'paramiko_%s' % paramiko.__version__\n\n    # These tuples of algorithm identifiers are in preference order; do not\n    # reorder without reason!\n    _preferred_ciphers = (\n        'aes128-ctr',\n        'aes192-ctr',\n        'aes256-ctr',\n        'aes128-cbc',\n        'aes192-cbc',\n        'aes256-cbc',\n        'blowfish-cbc',\n        '3des-cbc',\n    )\n    _preferred_macs = (\n        'hmac-sha2-256',\n        'hmac-sha2-512',\n        'hmac-sha1',\n        'hmac-md5',\n        'hmac-sha1-96',\n        'hmac-md5-96',\n    )\n    _preferred_keys = (\n        'ecdsa-sha2-nistp256',\n        'ecdsa-sha2-nistp384',\n        'ecdsa-sha2-nistp521',\n        'ssh-rsa',\n        'ssh-dss',\n    )\n    _preferred_kex = (\n        'diffie-hellman-group1-sha1',\n        'diffie-hellman-group14-sha1',\n        'diffie-hellman-group-exchange-sha1',\n        'diffie-hellman-group-exchange-sha256',\n    )\n    _preferred_gsskex = (\n        'gss-gex-sha1-toWM5Slw5Ew8Mqkay+al2g==',\n        'gss-group14-sha1-toWM5Slw5Ew8Mqkay+al2g==',\n        'gss-group1-sha1-toWM5Slw5Ew8Mqkay+al2g==',\n    )\n    _preferred_compression = ('none',)\n\n    _cipher_info = {\n        'aes128-ctr': {\n            'class': algorithms.AES,\n            'mode': modes.CTR,\n            'block-size': 16,\n            'key-size': 16\n        },\n        'aes192-ctr': {\n            'class': algorithms.AES,\n            'mode': modes.CTR,\n            'block-size': 16,\n            'key-size': 24\n        },\n        'aes256-ctr': {\n            'class': algorithms.AES,\n            'mode': modes.CTR,\n            'block-size': 16,\n            'key-size': 32\n        },\n        'blowfish-cbc': {\n            'class': algorithms.Blowfish,\n            'mode': modes.CBC,\n            'block-size': 8,\n            'key-size': 16\n        },\n        'aes128-cbc': {\n            'class': algorithms.AES,\n            'mode': modes.CBC,\n            'block-size': 16,\n            'key-size': 16\n        },\n        'aes192-cbc': {\n            'class': algorithms.AES,\n            'mode': modes.CBC,\n            'block-size': 16,\n            'key-size': 24\n        },\n        'aes256-cbc': {\n            'class': algorithms.AES,\n            'mode': modes.CBC,\n            'block-size': 16,\n            'key-size': 32\n        },\n        '3des-cbc': {\n            'class': algorithms.TripleDES,\n            'mode': modes.CBC,\n            'block-size': 8,\n            'key-size': 24\n        },\n    }\n\n\n    _mac_info = {\n        'hmac-sha1': {'class': sha1, 'size': 20},\n        'hmac-sha1-96': {'class': sha1, 'size': 12},\n        'hmac-sha2-256': {'class': sha256, 'size': 32},\n        'hmac-sha2-512': {'class': sha512, 'size': 64},\n        'hmac-md5': {'class': md5, 'size': 16},\n        'hmac-md5-96': {'class': md5, 'size': 12},\n    }\n\n    _key_info = {\n        'ssh-rsa': RSAKey,\n        'ssh-dss': DSSKey,\n        'ecdsa-sha2-nistp256': ECDSAKey,\n        'ecdsa-sha2-nistp384': ECDSAKey,\n        'ecdsa-sha2-nistp521': ECDSAKey,\n    }\n\n    _kex_info = {\n        'diffie-hellman-group1-sha1': KexGroup1,\n        'diffie-hellman-group14-sha1': KexGroup14,\n        'diffie-hellman-group-exchange-sha1': KexGex,\n        'diffie-hellman-group-exchange-sha256': KexGexSHA256,\n        'gss-group1-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup1,\n        'gss-group14-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup14,\n        'gss-gex-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGex\n    }\n\n    _compression_info = {\n        # zlib@openssh.com is just zlib, but only turned on after a successful\n        # authentication.  openssh servers may only offer this type because\n        # they've had troubles with security holes in zlib in the past.\n        'zlib@openssh.com': (ZlibCompressor, ZlibDecompressor),\n        'zlib': (ZlibCompressor, ZlibDecompressor),\n        'none': (None, None),\n    }\n\n    _modulus_pack = None\n    _active_check_timeout = 0.1\n\n    def __init__(self,\n                 sock,\n                 default_window_size=DEFAULT_WINDOW_SIZE,\n                 default_max_packet_size=DEFAULT_MAX_PACKET_SIZE,\n                 gss_kex=False,\n                 gss_deleg_creds=True):\n        \"\"\"\n        Create a new SSH session over an existing socket, or socket-like\n        object.  This only creates the `.Transport` object; it doesn't begin\n        the SSH session yet.  Use `connect` or `start_client` to begin a client\n        session, or `start_server` to begin a server session.\n\n        If the object is not actually a socket, it must have the following\n        methods:\n\n        - ``send(str)``: Writes from 1 to ``len(str)`` bytes, and returns an\n          int representing the number of bytes written.  Returns\n          0 or raises ``EOFError`` if the stream has been closed.\n        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a\n          string.  Returns 0 or raises ``EOFError`` if the stream has been\n          closed.\n        - ``close()``: Closes the socket.\n        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.\n\n        For ease of use, you may also pass in an address (as a tuple) or a host\n        string as the ``sock`` argument.  (A host string is a hostname with an\n        optional port (separated by ``\":\"``) which will be converted into a\n        tuple of ``(hostname, port)``.)  A socket will be connected to this\n        address and used for communication.  Exceptions from the ``socket``\n        call may be thrown in this case.\n\n        .. note::\n            Modifying the the window and packet sizes might have adverse\n            effects on your channels created from this transport. The default\n            values are the same as in the OpenSSH code base and have been\n            battle tested.\n\n        :param socket sock:\n            a socket or socket-like object to create the session over.\n        :param int default_window_size:\n            sets the default window size on the transport. (defaults to\n            2097152)\n        :param int default_max_packet_size:\n            sets the default max packet size on the transport. (defaults to\n            32768)\n\n        .. versionchanged:: 1.15\n            Added the ``default_window_size`` and ``default_max_packet_size``\n            arguments.\n        \"\"\"\n        self.active = False\n\n        if isinstance(sock, string_types):\n            # convert \"host:port\" into (host, port)\n            hl = sock.split(':', 1)\n            if len(hl) == 1:\n                sock = (hl[0], 22)\n            else:\n                sock = (hl[0], int(hl[1]))\n        if type(sock) is tuple:\n            # connect to the given (host, port)\n            hostname, port = sock\n            reason = 'No suitable address family'\n            addrinfos = socket.getaddrinfo(\n                hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM\n            )\n            for family, socktype, proto, canonname, sockaddr in addrinfos:\n                if socktype == socket.SOCK_STREAM:\n                    af = family\n                    # addr = sockaddr\n                    sock = socket.socket(af, socket.SOCK_STREAM)\n                    try:\n                        retry_on_signal(lambda: sock.connect((hostname, port)))\n                    except socket.error as e:\n                        reason = str(e)\n                    else:\n                        break\n            else:\n                raise SSHException(\n                    'Unable to connect to %s: %s' % (hostname, reason))\n        # okay, normal socket-ish flow here...\n        threading.Thread.__init__(self)\n        self.setDaemon(True)\n        self.sock = sock\n        # we set the timeout so we can check self.active periodically to\n        # see if we should bail. socket.timeout exception is never propagated.\n        self.sock.settimeout(self._active_check_timeout)\n\n        # negotiated crypto parameters\n        self.packetizer = Packetizer(sock)\n        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID\n        self.remote_version = ''\n        self.local_cipher = self.remote_cipher = ''\n        self.local_kex_init = self.remote_kex_init = None\n        self.local_mac = self.remote_mac = None\n        self.local_compression = self.remote_compression = None\n        self.session_id = None\n        self.host_key_type = None\n        self.host_key = None\n\n        # GSS-API / SSPI Key Exchange\n        self.use_gss_kex = gss_kex\n        # This will be set to True if GSS-API Key Exchange was performed\n        self.gss_kex_used = False\n        self.kexgss_ctxt = None\n        self.gss_host = None\n        if self.use_gss_kex:\n            self.kexgss_ctxt = GSSAuth(\"gssapi-keyex\", gss_deleg_creds)\n            self._preferred_kex = self._preferred_gsskex + self._preferred_kex\n\n        # state used during negotiation\n        self.kex_engine = None\n        self.H = None\n        self.K = None\n\n        self.initial_kex_done = False\n        self.in_kex = False\n        self.authenticated = False\n        self._expected_packet = tuple()\n        # synchronization (always higher level than write_lock)\n        self.lock = threading.Lock()\n\n        # tracking open channels\n        self._channels = ChannelMap()\n        self.channel_events = {}       # (id -> Event)\n        self.channels_seen = {}        # (id -> True)\n        self._channel_counter = 0\n        self.default_max_packet_size = default_max_packet_size\n        self.default_window_size = default_window_size\n        self._forward_agent_handler = None\n        self._x11_handler = None\n        self._tcp_handler = None\n\n        self.saved_exception = None\n        self.clear_to_send = threading.Event()\n        self.clear_to_send_lock = threading.Lock()\n        self.clear_to_send_timeout = 30.0\n        self.log_name = 'paramiko.transport'\n        self.logger = util.get_logger(self.log_name)\n        self.packetizer.set_log(self.logger)\n        self.auth_handler = None\n        # response Message from an arbitrary global request\n        self.global_response = None\n        # user-defined event callbacks\n        self.completion_event = None\n        # how long (seconds) to wait for the SSH banner\n        self.banner_timeout = 15\n        # how long (seconds) to wait for the handshake to finish after SSH\n        # banner sent.\n        self.handshake_timeout = 15\n\n        # server mode:\n        self.server_mode = False\n        self.server_object = None\n        self.server_key_dict = {}\n        self.server_accepts = []\n        self.server_accept_cv = threading.Condition(self.lock)\n        self.subsystem_table = {}\n\n    def __repr__(self):\n        \"\"\"\n        Returns a string representation of this object, for debugging.\n        \"\"\"\n        out = '<paramiko.Transport at %s' % hex(long(id(self)) & xffffffff)\n        if not self.active:\n            out += ' (unconnected)'\n        else:\n            if self.local_cipher != '':\n                out += ' (cipher %s, %d bits)' % (\n                    self.local_cipher,\n                    self._cipher_info[self.local_cipher]['key-size'] * 8\n                )\n            if self.is_authenticated():\n                out += ' (active; %d open channel(s))' % len(self._channels)\n            elif self.initial_kex_done:\n                out += ' (connected; awaiting auth)'\n            else:\n                out += ' (connecting)'\n        out += '>'\n        return out\n\n    def atfork(self):\n        \"\"\"\n        Terminate this Transport without closing the session.  On posix\n        systems, if a Transport is open during process forking, both parent\n        and child will share the underlying socket, but only one process can\n        use the connection (without corrupting the session).  Use this method\n        to clean up a Transport object without disrupting the other process.\n\n        .. versionadded:: 1.5.3\n        \"\"\"\n        self.sock.close()\n        self.close()\n\n    def get_security_options(self):\n        \"\"\"\n        Return a `.SecurityOptions` object which can be used to tweak the\n        encryption algorithms this transport will permit (for encryption,\n        digest/hash operations, public keys, and key exchanges) and the order\n        of preference for them.\n        \"\"\"\n        return SecurityOptions(self)\n\n    def set_gss_host(self, gss_host):\n        \"\"\"\n        Setter for C{gss_host} if GSS-API Key Exchange is performed.\n\n        :param str gss_host: The targets name in the kerberos database\n                             Default: The name of the host to connect to\n        \"\"\"\n        # We need the FQDN to get this working with SSPI\n        self.gss_host = socket.getfqdn(gss_host)\n\n    def start_client(self, event=None):\n        \"\"\"\n        Negotiate a new SSH2 session as a client.  This is the first step after\n        creating a new `.Transport`.  A separate thread is created for protocol\n        negotiation.\n\n        If an event is passed in, this method returns immediately.  When\n        negotiation is done (successful or not), the given ``Event`` will\n        be triggered.  On failure, `is_active` will return ``False``.\n\n        (Since 1.4) If ``event`` is ``None``, this method will not return until\n        negotation is done.  On success, the method returns normally.\n        Otherwise an SSHException is raised.\n\n        After a successful negotiation, you will usually want to authenticate,\n        calling `auth_password <Transport.auth_password>` or\n        `auth_publickey <Transport.auth_publickey>`.\n\n        .. note:: `connect` is a simpler method for connecting as a client.\n\n        .. note::\n            After calling this method (or `start_server` or `connect`), you\n            should no longer directly read from or write to the original socket\n            object.\n\n        :param .threading.Event event:\n            an event to trigger when negotiation is complete (optional)\n\n        :raises:\n            `.SSHException` -- if negotiation fails (and no ``event`` was\n            passed in)\n        \"\"\"\n        self.active = True\n        if event is not None:\n            # async, return immediately and let the app poll for completion\n            self.completion_event = event\n            self.start()\n            return\n\n        # synchronous, wait for a result\n        self.completion_event = event = threading.Event()\n        self.start()\n        while True:\n            event.wait(0.1)\n            if not self.active:\n                e = self.get_exception()\n                if e is not None:\n                    raise e\n                raise SSHException('Negotiation failed.')\n            if event.is_set():\n                break\n\n    def start_server(self, event=None, server=None):\n        \"\"\"\n        Negotiate a new SSH2 session as a server.  This is the first step after\n        creating a new `.Transport` and setting up your server host key(s).  A\n        separate thread is created for protocol negotiation.\n\n        If an event is passed in, this method returns immediately.  When\n        negotiation is done (successful or not), the given ``Event`` will\n        be triggered.  On failure, `is_active` will return ``False``.\n\n        (Since 1.4) If ``event`` is ``None``, this method will not return until\n        negotiation is done.  On success, the method returns normally.\n        Otherwise an SSHException is raised.\n\n        After a successful negotiation, the client will need to authenticate.\n        Override the methods `get_allowed_auths\n        <.ServerInterface.get_allowed_auths>`, `check_auth_none\n        <.ServerInterface.check_auth_none>`, `check_auth_password\n        <.ServerInterface.check_auth_password>`, and `check_auth_publickey\n        <.ServerInterface.check_auth_publickey>` in the given ``server`` object\n        to control the authentication process.\n\n        After a successful authentication, the client should request to open a\n        channel.  Override `check_channel_request\n        <.ServerInterface.check_channel_request>` in the given ``server``\n        object to allow channels to be opened.\n\n        .. note::\n            After calling this method (or `start_client` or `connect`), you\n            should no longer directly read from or write to the original socket\n            object.\n\n        :param .threading.Event event:\n            an event to trigger when negotiation is complete.\n        :param .ServerInterface server:\n            an object used to perform authentication and create `channels\n            <.Channel>`\n\n        :raises:\n            `.SSHException` -- if negotiation fails (and no ``event`` was\n            passed in)\n        \"\"\"\n        if server is None:\n            server = ServerInterface()\n        self.server_mode = True\n        self.server_object = server\n        self.active = True\n        if event is not None:\n            # async, return immediately and let the app poll for completion\n            self.completion_event = event\n            self.start()\n            return\n\n        # synchronous, wait for a result\n        self.completion_event = event = threading.Event()\n        self.start()\n        while True:\n            event.wait(0.1)\n            if not self.active:\n                e = self.get_exception()\n                if e is not None:\n                    raise e\n                raise SSHException('Negotiation failed.')\n            if event.is_set():\n                break\n\n    def add_server_key(self, key):\n        \"\"\"\n        Add a host key to the list of keys used for server mode.  When behaving\n        as a server, the host key is used to sign certain packets during the\n        SSH2 negotiation, so that the client can trust that we are who we say\n        we are.  Because this is used for signing, the key must contain private\n        key info, not just the public half.  Only one key of each type (RSA or\n        DSS) is kept.\n\n        :param .PKey key:\n            the host key to add, usually an `.RSAKey` or `.DSSKey`.\n        \"\"\"\n        self.server_key_dict[key.get_name()] = key\n\n    def get_server_key(self):\n        \"\"\"\n        Return the active host key, in server mode.  After negotiating with the\n        client, this method will return the negotiated host key.  If only one\n        type of host key was set with `add_server_key`, that's the only key\n        that will ever be returned.  But in cases where you have set more than\n        one type of host key (for example, an RSA key and a DSS key), the key\n        type will be negotiated by the client, and this method will return the\n        key of the type agreed on.  If the host key has not been negotiated\n        yet, ``None`` is returned.  In client mode, the behavior is undefined.\n\n        :return:\n            host key (`.PKey`) of the type negotiated by the client, or\n            ``None``.\n        \"\"\"\n        try:\n            return self.server_key_dict[self.host_key_type]\n        except KeyError:\n            pass\n        return None\n\n    @staticmethod\n    def load_server_moduli(filename=None):\n        \"\"\"\n        (optional)\n        Load a file of prime moduli for use in doing group-exchange key\n        negotiation in server mode.  It's a rather obscure option and can be\n        safely ignored.\n\n        In server mode, the remote client may request \"group-exchange\" key\n        negotiation, which asks the server to send a random prime number that\n        fits certain criteria.  These primes are pretty difficult to compute,\n        so they can't be generated on demand.  But many systems contain a file\n        of suitable primes (usually named something like ``/etc/ssh/moduli``).\n        If you call `load_server_moduli` and it returns ``True``, then this\n        file of primes has been loaded and we will support \"group-exchange\" in\n        server mode.  Otherwise server mode will just claim that it doesn't\n        support that method of key negotiation.\n\n        :param str filename:\n            optional path to the moduli file, if you happen to know that it's\n            not in a standard location.\n        :return:\n            True if a moduli file was successfully loaded; False otherwise.\n\n        .. note:: This has no effect when used in client mode.\n        \"\"\"\n        Transport._modulus_pack = ModulusPack()\n        # places to look for the openssh \"moduli\" file\n        file_list = ['/etc/ssh/moduli', '/usr/local/etc/moduli']\n        if filename is not None:\n            file_list.insert(0, filename)\n        for fn in file_list:\n            try:\n                Transport._modulus_pack.read_file(fn)\n                return True\n            except IOError:\n                pass\n        # none succeeded\n        Transport._modulus_pack = None\n        return False\n\n    def close(self):\n        \"\"\"\n        Close this session, and any open channels that are tied to it.\n        \"\"\"\n        if not self.active:\n            return\n        self.stop_thread()\n        for chan in list(self._channels.values()):\n            chan._unlink()\n        self.sock.close()\n\n    def get_remote_server_key(self):\n        \"\"\"\n        Return the host key of the server (in client mode).\n\n        .. note::\n            Previously this call returned a tuple of ``(key type, key\n            string)``. You can get the same effect by calling `.PKey.get_name`\n            for the key type, and ``str(key)`` for the key string.\n\n        :raises: `.SSHException` -- if no session is currently active.\n\n        :return: public key (`.PKey`) of the remote server\n        \"\"\"\n        if (not self.active) or (not self.initial_kex_done):\n            raise SSHException('No existing session')\n        return self.host_key\n\n    def is_active(self):\n        \"\"\"\n        Return true if this session is active (open).\n\n        :return:\n            True if the session is still active (open); False if the session is\n            closed\n        \"\"\"\n        return self.active\n\n    def open_session(\n        self,\n        window_size=None,\n        max_packet_size=None,\n        timeout=None,\n    ):\n        \"\"\"\n        Request a new channel to the server, of type ``\"session\"``.  This is\n        just an alias for calling `open_channel` with an argument of\n        ``\"session\"``.\n\n        .. note:: Modifying the the window and packet sizes might have adverse\n            effects on the session created. The default values are the same\n            as in the OpenSSH code base and have been battle tested.\n\n        :param int window_size:\n            optional window size for this session.\n        :param int max_packet_size:\n            optional max packet size for this session.\n\n        :return: a new `.Channel`\n\n        :raises:\n            `.SSHException` -- if the request is rejected or the session ends\n            prematurely\n\n        .. versionchanged:: 1.13.4/1.14.3/1.15.3\n            Added the ``timeout`` argument.\n        .. versionchanged:: 1.15\n            Added the ``window_size`` and ``max_packet_size`` arguments.\n        \"\"\"\n        return self.open_channel('session',\n                                 window_size=window_size,\n                                 max_packet_size=max_packet_size,\n                                 timeout=timeout)\n\n    def open_x11_channel(self, src_addr=None):\n        \"\"\"\n        Request a new channel to the client, of type ``\"x11\"``.  This\n        is just an alias for ``open_channel('x11', src_addr=src_addr)``.\n\n        :param tuple src_addr:\n            the source address (``(str, int)``) of the x11 server (port is the\n            x11 port, ie. 6010)\n        :return: a new `.Channel`\n\n        :raises:\n            `.SSHException` -- if the request is rejected or the session ends\n            prematurely\n        \"\"\"\n        return self.open_channel('x11', src_addr=src_addr)\n\n    def open_forward_agent_channel(self):\n        \"\"\"\n        Request a new channel to the client, of type\n        ``\"auth-agent@openssh.com\"``.\n\n        This is just an alias for ``open_channel('auth-agent@openssh.com')``.\n\n        :return: a new `.Channel`\n\n        :raises: `.SSHException` --\n            if the request is rejected or the session ends prematurely\n        \"\"\"\n        return self.open_channel('auth-agent@openssh.com')\n\n    def open_forwarded_tcpip_channel(self, src_addr, dest_addr):\n        \"\"\"\n        Request a new channel back to the client, of type ``forwarded-tcpip``.\n\n        This is used after a client has requested port forwarding, for sending\n        incoming connections back to the client.\n\n        :param src_addr: originator's address\n        :param dest_addr: local (server) connected address\n        \"\"\"\n        return self.open_channel('forwarded-tcpip', dest_addr, src_addr)\n\n    def open_channel(self,\n                     kind,\n                     dest_addr=None,\n                     src_addr=None,\n                     window_size=None,\n                     max_packet_size=None,\n                     timeout=None):\n        \"\"\"\n        Request a new channel to the server. `Channels <.Channel>` are\n        socket-like objects used for the actual transfer of data across the\n        session. You may only request a channel after negotiating encryption\n        (using `connect` or `start_client`) and authenticating.\n\n        .. note:: Modifying the the window and packet sizes might have adverse\n            effects on the channel created. The default values are the same\n            as in the OpenSSH code base and have been battle tested.\n\n        :param str kind:\n            the kind of channel requested (usually ``\"session\"``,\n            ``\"forwarded-tcpip\"``, ``\"direct-tcpip\"``, or ``\"x11\"``)\n        :param tuple dest_addr:\n            the destination address (address + port tuple) of this port\n            forwarding, if ``kind`` is ``\"forwarded-tcpip\"`` or\n            ``\"direct-tcpip\"`` (ignored for other channel types)\n        :param src_addr: the source address of this port forwarding, if\n            ``kind`` is ``\"forwarded-tcpip\"``, ``\"direct-tcpip\"``, or ``\"x11\"``\n        :param int window_size:\n            optional window size for this session.\n        :param int max_packet_size:\n            optional max packet size for this session.\n        :param float timeout:\n            optional timeout opening a channel, default 3600s (1h)\n\n        :return: a new `.Channel` on success\n\n        :raises:\n            `.SSHException` -- if the request is rejected, the session ends\n            prematurely or there is a timeout openning a channel\n\n        .. versionchanged:: 1.15\n            Added the ``window_size`` and ``max_packet_size`` arguments.\n        \"\"\"\n        if not self.active:\n            raise SSHException('SSH session not active')\n        timeout = 3600 if timeout is None else timeout\n        self.lock.acquire()\n        try:\n            window_size = self._sanitize_window_size(window_size)\n            max_packet_size = self._sanitize_packet_size(max_packet_size)\n            chanid = self._next_channel()\n            m = Message()\n            m.add_byte(cMSG_CHANNEL_OPEN)\n            m.add_string(kind)\n            m.add_int(chanid)\n            m.add_int(window_size)\n            m.add_int(max_packet_size)\n            if (kind == 'forwarded-tcpip') or (kind == 'direct-tcpip'):\n                m.add_string(dest_addr[0])\n                m.add_int(dest_addr[1])\n                m.add_string(src_addr[0])\n                m.add_int(src_addr[1])\n            elif kind == 'x11':\n                m.add_string(src_addr[0])\n                m.add_int(src_addr[1])\n            chan = Channel(chanid)\n            self._channels.put(chanid, chan)\n            self.channel_events[chanid] = event = threading.Event()\n            self.channels_seen[chanid] = True\n            chan._set_transport(self)\n            chan._set_window(window_size, max_packet_size)\n        finally:\n            self.lock.release()\n        self._send_user_message(m)\n        start_ts = time.time()\n        while True:\n            event.wait(0.1)\n            if not self.active:\n                e = self.get_exception()\n                if e is None:\n                    e = SSHException('Unable to open channel.')\n                raise e\n            if event.is_set():\n                break\n            elif start_ts + timeout < time.time():\n                raise SSHException('Timeout opening channel.')\n        chan = self._channels.get(chanid)\n        if chan is not None:\n            return chan\n        e = self.get_exception()\n        if e is None:\n            e = SSHException('Unable to open channel.')\n        raise e\n\n    def request_port_forward(self, address, port, handler=None):\n        \"\"\"\n        Ask the server to forward TCP connections from a listening port on\n        the server, across this SSH session.\n\n        If a handler is given, that handler is called from a different thread\n        whenever a forwarded connection arrives.  The handler parameters are::\n\n            handler(\n                channel,\n                (origin_addr, origin_port),\n                (server_addr, server_port),\n            )\n\n        where ``server_addr`` and ``server_port`` are the address and port that\n        the server was listening on.\n\n        If no handler is set, the default behavior is to send new incoming\n        forwarded connections into the accept queue, to be picked up via\n        `accept`.\n\n        :param str address: the address to bind when forwarding\n        :param int port:\n            the port to forward, or 0 to ask the server to allocate any port\n        :param callable handler:\n            optional handler for incoming forwarded connections, of the form\n            ``func(Channel, (str, int), (str, int))``.\n\n        :return: the port number (`int`) allocated by the server\n\n        :raises:\n            `.SSHException` -- if the server refused the TCP forward request\n        \"\"\"\n        if not self.active:\n            raise SSHException('SSH session not active')\n        port = int(port)\n        response = self.global_request(\n            'tcpip-forward', (address, port), wait=True\n        )\n        if response is None:\n            raise SSHException('TCP forwarding request denied')\n        if port == 0:\n            port = response.get_int()\n        if handler is None:\n            def default_handler(channel, src_addr, dest_addr_port):\n                # src_addr, src_port = src_addr_port\n                # dest_addr, dest_port = dest_addr_port\n                self._queue_incoming_channel(channel)\n            handler = default_handler\n        self._tcp_handler = handler\n        return port\n\n    def cancel_port_forward(self, address, port):\n        \"\"\"\n        Ask the server to cancel a previous port-forwarding request.  No more\n        connections to the given address & port will be forwarded across this\n        ssh connection.\n\n        :param str address: the address to stop forwarding\n        :param int port: the port to stop forwarding\n        \"\"\"\n        if not self.active:\n            return\n        self._tcp_handler = None\n        self.global_request('cancel-tcpip-forward', (address, port), wait=True)\n\n    def open_sftp_client(self):\n        \"\"\"\n        Create an SFTP client channel from an open transport.  On success, an\n        SFTP session will be opened with the remote host, and a new\n        `.SFTPClient` object will be returned.\n\n        :return:\n            a new `.SFTPClient` referring to an sftp session (channel) across\n            this transport\n        \"\"\"\n        return SFTPClient.from_transport(self)\n\n    def send_ignore(self, byte_count=None):\n        \"\"\"\n        Send a junk packet across the encrypted link.  This is sometimes used\n        to add \"noise\" to a connection to confuse would-be attackers.  It can\n        also be used as a keep-alive for long lived connections traversing\n        firewalls.\n\n        :param int byte_count:\n            the number of random bytes to send in the payload of the ignored\n            packet -- defaults to a random number from 10 to 41.\n        \"\"\"\n        m = Message()\n        m.add_byte(cMSG_IGNORE)\n        if byte_count is None:\n            byte_count = (byte_ord(os.urandom(1)) % 32) + 10\n        m.add_bytes(os.urandom(byte_count))\n        self._send_user_message(m)\n\n    def renegotiate_keys(self):\n        \"\"\"\n        Force this session to switch to new keys.  Normally this is done\n        automatically after the session hits a certain number of packets or\n        bytes sent or received, but this method gives you the option of forcing\n        new keys whenever you want.  Negotiating new keys causes a pause in\n        traffic both ways as the two sides swap keys and do computations.  This\n        method returns when the session has switched to new keys.\n\n        :raises:\n            `.SSHException` -- if the key renegotiation failed (which causes\n            the session to end)\n        \"\"\"\n        self.completion_event = threading.Event()\n        self._send_kex_init()\n        while True:\n            self.completion_event.wait(0.1)\n            if not self.active:\n                e = self.get_exception()\n                if e is not None:\n                    raise e\n                raise SSHException('Negotiation failed.')\n            if self.completion_event.is_set():\n                break\n        return\n\n    def set_keepalive(self, interval):\n        \"\"\"\n        Turn on/off keepalive packets (default is off).  If this is set, after\n        ``interval`` seconds without sending any data over the connection, a\n        \"keepalive\" packet will be sent (and ignored by the remote host).  This\n        can be useful to keep connections alive over a NAT, for example.\n\n        :param int interval:\n            seconds to wait before sending a keepalive packet (or\n            0 to disable keepalives).\n        \"\"\"\n        def _request(x=weakref.proxy(self)):\n            return x.global_request('keepalive@lag.net', wait=False)\n        self.packetizer.set_keepalive(interval, _request)\n\n    def global_request(self, kind, data=None, wait=True):\n        \"\"\"\n        Make a global request to the remote host.  These are normally\n        extensions to the SSH2 protocol.\n\n        :param str kind: name of the request.\n        :param tuple data:\n            an optional tuple containing additional data to attach to the\n            request.\n        :param bool wait:\n            ``True`` if this method should not return until a response is\n            received; ``False`` otherwise.\n        :return:\n            a `.Message` containing possible additional data if the request was\n            successful (or an empty `.Message` if ``wait`` was ``False``);\n            ``None`` if the request was denied.\n        \"\"\"\n        if wait:\n            self.completion_event = threading.Event()\n        m = Message()\n        m.add_byte(cMSG_GLOBAL_REQUEST)\n        m.add_string(kind)\n        m.add_boolean(wait)\n        if data is not None:\n            m.add(*data)\n        self._log(DEBUG, 'Sending global request \"%s\"' % kind)\n        self._send_user_message(m)\n        if not wait:\n            return None\n        while True:\n            self.completion_event.wait(0.1)\n            if not self.active:\n                return None\n            if self.completion_event.is_set():\n                break\n        return self.global_response\n\n    def accept(self, timeout=None):\n        \"\"\"\n        Return the next channel opened by the client over this transport, in\n        server mode.  If no channel is opened before the given timeout,\n        ``None`` is returned.\n\n        :param int timeout:\n            seconds to wait for a channel, or ``None`` to wait forever\n        :return: a new `.Channel` opened by the client\n        \"\"\"\n        self.lock.acquire()\n        try:\n            if len(self.server_accepts) > 0:\n                chan = self.server_accepts.pop(0)\n            else:\n                self.server_accept_cv.wait(timeout)\n                if len(self.server_accepts) > 0:\n                    chan = self.server_accepts.pop(0)\n                else:\n                    # timeout\n                    chan = None\n        finally:\n            self.lock.release()\n        return chan\n\n    def connect(\n        self,\n        hostkey=None,\n        username='',\n        password=None,\n        pkey=None,\n        gss_host=None,\n        gss_auth=False,\n        gss_kex=False,\n        gss_deleg_creds=True,\n    ):\n        \"\"\"\n        Negotiate an SSH2 session, and optionally verify the server's host key\n        and authenticate using a password or private key.  This is a shortcut\n        for `start_client`, `get_remote_server_key`, and\n        `Transport.auth_password` or `Transport.auth_publickey`.  Use those\n        methods if you want more control.\n\n        You can use this method immediately after creating a Transport to\n        negotiate encryption with a server.  If it fails, an exception will be\n        thrown.  On success, the method will return cleanly, and an encrypted\n        session exists.  You may immediately call `open_channel` or\n        `open_session` to get a `.Channel` object, which is used for data\n        transfer.\n\n        .. note::\n            If you fail to supply a password or private key, this method may\n            succeed, but a subsequent `open_channel` or `open_session` call may\n            fail because you haven't authenticated yet.\n\n        :param .PKey hostkey:\n            the host key expected from the server, or ``None`` if you don't\n            want to do host key verification.\n        :param str username: the username to authenticate as.\n        :param str password:\n            a password to use for authentication, if you want to use password\n            authentication; otherwise ``None``.\n        :param .PKey pkey:\n            a private key to use for authentication, if you want to use private\n            key authentication; otherwise ``None``.\n        :param str gss_host:\n            The target's name in the kerberos database. Default: hostname\n        :param bool gss_auth:\n            ``True`` if you want to use GSS-API authentication.\n        :param bool gss_kex:\n            Perform GSS-API Key Exchange and user authentication.\n        :param bool gss_deleg_creds:\n            Whether to delegate GSS-API client credentials.\n\n        :raises: `.SSHException` -- if the SSH2 negotiation fails, the host key\n            supplied by the server is incorrect, or authentication fails.\n        \"\"\"\n        if hostkey is not None:\n            self._preferred_keys = [hostkey.get_name()]\n\n        self.start_client()\n\n        # check host key if we were given one\n        # If GSS-API Key Exchange was performed, we are not required to check\n        # the host key.\n        if (hostkey is not None) and not gss_kex:\n            key = self.get_remote_server_key()\n            if (\n                key.get_name() != hostkey.get_name() or\n                key.asbytes() != hostkey.asbytes()\n            ):\n                self._log(DEBUG, 'Bad host key from server')\n                self._log(DEBUG, 'Expected: %s: %s' % (\n                    hostkey.get_name(), repr(hostkey.asbytes()))\n                )\n                self._log(DEBUG, 'Got     : %s: %s' % (\n                    key.get_name(), repr(key.asbytes()))\n                )\n                raise SSHException('Bad host key from server')\n            self._log(DEBUG, 'Host key verified (%s)' % hostkey.get_name())\n\n        if (pkey is not None) or (password is not None) or gss_auth or gss_kex:\n            if gss_auth:\n                self._log(DEBUG, 'Attempting GSS-API auth... (gssapi-with-mic)') # noqa\n                self.auth_gssapi_with_mic(username, gss_host, gss_deleg_creds)\n            elif gss_kex:\n                self._log(DEBUG, 'Attempting GSS-API auth... (gssapi-keyex)')\n                self.auth_gssapi_keyex(username)\n            elif pkey is not None:\n                self._log(DEBUG, 'Attempting public-key auth...')\n                self.auth_publickey(username, pkey)\n            else:\n                self._log(DEBUG, 'Attempting password auth...')\n                self.auth_password(username, password)\n\n        return\n\n    def get_exception(self):\n        \"\"\"\n        Return any exception that happened during the last server request.\n        This can be used to fetch more specific error information after using\n        calls like `start_client`.  The exception (if any) is cleared after\n        this call.\n\n        :return:\n            an exception, or ``None`` if there is no stored exception.\n\n        .. versionadded:: 1.1\n        \"\"\"\n        self.lock.acquire()\n        try:\n            e = self.saved_exception\n            self.saved_exception = None\n            return e\n        finally:\n            self.lock.release()\n\n    def set_subsystem_handler(self, name, handler, *larg, **kwarg):\n        \"\"\"\n        Set the handler class for a subsystem in server mode.  If a request\n        for this subsystem is made on an open ssh channel later, this handler\n        will be constructed and called -- see `.SubsystemHandler` for more\n        detailed documentation.\n\n        Any extra parameters (including keyword arguments) are saved and\n        passed to the `.SubsystemHandler` constructor later.\n\n        :param str name: name of the subsystem.\n        :param handler:\n            subclass of `.SubsystemHandler` that handles this subsystem.\n        \"\"\"\n        try:\n            self.lock.acquire()\n            self.subsystem_table[name] = (handler, larg, kwarg)\n        finally:\n            self.lock.release()\n\n    def is_authenticated(self):\n        \"\"\"\n        Return true if this session is active and authenticated.\n\n        :return:\n            True if the session is still open and has been authenticated\n            successfully; False if authentication failed and/or the session is\n            closed.\n        \"\"\"\n        return (\n            self.active and\n            self.auth_handler is not None and\n            self.auth_handler.is_authenticated()\n        )\n\n    def get_username(self):\n        \"\"\"\n        Return the username this connection is authenticated for.  If the\n        session is not authenticated (or authentication failed), this method\n        returns ``None``.\n\n        :return: username that was authenticated (a `str`), or ``None``.\n        \"\"\"\n        if not self.active or (self.auth_handler is None):\n            return None\n        return self.auth_handler.get_username()\n\n    def get_banner(self):\n        \"\"\"\n        Return the banner supplied by the server upon connect. If no banner is\n        supplied, this method returns ``None``.\n\n        :returns: server supplied banner (`str`), or ``None``.\n\n        .. versionadded:: 1.13\n        \"\"\"\n        if not self.active or (self.auth_handler is None):\n            return None\n        return self.auth_handler.banner\n\n    def auth_none(self, username):\n        \"\"\"\n        Try to authenticate to the server using no authentication at all.\n        This will almost always fail.  It may be useful for determining the\n        list of authentication types supported by the server, by catching the\n        `.BadAuthenticationType` exception raised.\n\n        :param str username: the username to authenticate as\n        :return:\n            `list` of auth types permissible for the next stage of\n            authentication (normally empty)\n\n        :raises:\n            `.BadAuthenticationType` -- if \"none\" authentication isn't allowed\n            by the server for this user\n        :raises:\n            `.SSHException` -- if the authentication failed due to a network\n            error\n\n        .. versionadded:: 1.5\n        \"\"\"\n        if (not self.active) or (not self.initial_kex_done):\n            raise SSHException('No existing session')\n        my_event = threading.Event()\n        self.auth_handler = AuthHandler(self)\n        self.auth_handler.auth_none(username, my_event)\n        return self.auth_handler.wait_for_response(my_event)\n\n    def auth_password(self, username, password, event=None, fallback=True):\n        \"\"\"\n        Authenticate to the server using a password.  The username and password\n        are sent over an encrypted link.\n\n        If an ``event`` is passed in, this method will return immediately, and\n        the event will be triggered once authentication succeeds or fails.  On\n        success, `is_authenticated` will return ``True``.  On failure, you may\n        use `get_exception` to get more detailed error information.\n\n        Since 1.1, if no event is passed, this method will block until the\n        authentication succeeds or fails.  On failure, an exception is raised.\n        Otherwise, the method simply returns.\n\n        Since 1.5, if no event is passed and ``fallback`` is ``True`` (the\n        default), if the server doesn't support plain password authentication\n        but does support so-called \"keyboard-interactive\" mode, an attempt\n        will be made to authenticate using this interactive mode.  If it fails,\n        the normal exception will be thrown as if the attempt had never been\n        made.  This is useful for some recent Gentoo and Debian distributions,\n        which turn off plain password authentication in a misguided belief\n        that interactive authentication is \"more secure\".  (It's not.)\n\n        If the server requires multi-step authentication (which is very rare),\n        this method will return a list of auth types permissible for the next\n        step.  Otherwise, in the normal case, an empty list is returned.\n\n        :param str username: the username to authenticate as\n        :param basestring password: the password to authenticate with\n        :param .threading.Event event:\n            an event to trigger when the authentication attempt is complete\n            (whether it was successful or not)\n        :param bool fallback:\n            ``True`` if an attempt at an automated \"interactive\" password auth\n            should be made if the server doesn't support normal password auth\n        :return:\n            `list` of auth types permissible for the next stage of\n            authentication (normally empty)\n\n        :raises:\n            `.BadAuthenticationType` -- if password authentication isn't\n            allowed by the server for this user (and no event was passed in)\n        :raises:\n            `.AuthenticationException` -- if the authentication failed (and no\n            event was passed in)\n        :raises: `.SSHException` -- if there was a network error\n        \"\"\"\n        if (not self.active) or (not self.initial_kex_done):\n            # we should never try to send the password unless we're on a secure\n            # link\n            raise SSHException('No existing session')\n        if event is None:\n            my_event = threading.Event()\n        else:\n            my_event = event\n        self.auth_handler = AuthHandler(self)\n        self.auth_handler.auth_password(username, password, my_event)\n        if event is not None:\n            # caller wants to wait for event themselves\n            return []\n        try:\n            return self.auth_handler.wait_for_response(my_event)\n        except BadAuthenticationType as e:\n            # if password auth isn't allowed, but keyboard-interactive *is*,\n            # try to fudge it\n            if not fallback or ('keyboard-interactive' not in e.allowed_types):\n                raise\n            try:\n                def handler(title, instructions, fields):\n                    if len(fields) > 1:\n                        raise SSHException('Fallback authentication failed.')\n                    if len(fields) == 0:\n                        # for some reason, at least on os x, a 2nd request will\n                        # be made with zero fields requested.  maybe it's just\n                        # to try to fake out automated scripting of the exact\n                        # type we're doing here.  *shrug* :)\n                        return []\n                    return [password]\n                return self.auth_interactive(username, handler)\n            except SSHException:\n                # attempt failed; just raise the original exception\n                raise e\n\n    def auth_publickey(self, username, key, event=None):\n        \"\"\"\n        Authenticate to the server using a private key.  The key is used to\n        sign data from the server, so it must include the private part.\n\n        If an ``event`` is passed in, this method will return immediately, and\n        the event will be triggered once authentication succeeds or fails.  On\n        success, `is_authenticated` will return ``True``.  On failure, you may\n        use `get_exception` to get more detailed error information.\n\n        Since 1.1, if no event is passed, this method will block until the\n        authentication succeeds or fails.  On failure, an exception is raised.\n        Otherwise, the method simply returns.\n\n        If the server requires multi-step authentication (which is very rare),\n        this method will return a list of auth types permissible for the next\n        step.  Otherwise, in the normal case, an empty list is returned.\n\n        :param str username: the username to authenticate as\n        :param .PKey key: the private key to authenticate with\n        :param .threading.Event event:\n            an event to trigger when the authentication attempt is complete\n            (whether it was successful or not)\n        :return:\n            `list` of auth types permissible for the next stage of\n            authentication (normally empty)\n\n        :raises:\n            `.BadAuthenticationType` -- if public-key authentication isn't\n            allowed by the server for this user (and no event was passed in)\n        :raises:\n            `.AuthenticationException` -- if the authentication failed (and no\n            event was passed in)\n        :raises: `.SSHException` -- if there was a network error\n        \"\"\"\n        if (not self.active) or (not self.initial_kex_done):\n            # we should never try to authenticate unless we're on a secure link\n            raise SSHException('No existing session')\n        if event is None:\n            my_event = threading.Event()\n        else:\n            my_event = event\n        self.auth_handler = AuthHandler(self)\n        self.auth_handler.auth_publickey(username, key, my_event)\n        if event is not None:\n            # caller wants to wait for event themselves\n            return []\n        return self.auth_handler.wait_for_response(my_event)\n\n    def auth_interactive(self, username, handler, submethods=''):\n        \"\"\"\n        Authenticate to the server interactively.  A handler is used to answer\n        arbitrary questions from the server.  On many servers, this is just a\n        dumb wrapper around PAM.\n\n        This method will block until the authentication succeeds or fails,\n        peroidically calling the handler asynchronously to get answers to\n        authentication questions.  The handler may be called more than once\n        if the server continues to ask questions.\n\n        The handler is expected to be a callable that will handle calls of the\n        form: ``handler(title, instructions, prompt_list)``.  The ``title`` is\n        meant to be a dialog-window title, and the ``instructions`` are user\n        instructions (both are strings).  ``prompt_list`` will be a list of\n        prompts, each prompt being a tuple of ``(str, bool)``.  The string is\n        the prompt and the boolean indicates whether the user text should be\n        echoed.\n\n        A sample call would thus be:\n        ``handler('title', 'instructions', [('Password:', False)])``.\n\n        The handler should return a list or tuple of answers to the server's\n        questions.\n\n        If the server requires multi-step authentication (which is very rare),\n        this method will return a list of auth types permissible for the next\n        step.  Otherwise, in the normal case, an empty list is returned.\n\n        :param str username: the username to authenticate as\n        :param callable handler: a handler for responding to server questions\n        :param str submethods: a string list of desired submethods (optional)\n        :return:\n            `list` of auth types permissible for the next stage of\n            authentication (normally empty).\n\n        :raises: `.BadAuthenticationType` -- if public-key authentication isn't\n            allowed by the server for this user\n        :raises: `.AuthenticationException` -- if the authentication failed\n        :raises: `.SSHException` -- if there was a network error\n\n        .. versionadded:: 1.5\n        \"\"\"\n        if (not self.active) or (not self.initial_kex_done):\n            # we should never try to authenticate unless we're on a secure link\n            raise SSHException('No existing session')\n        my_event = threading.Event()\n        self.auth_handler = AuthHandler(self)\n        self.auth_handler.auth_interactive(\n            username, handler, my_event, submethods\n        )\n        return self.auth_handler.wait_for_response(my_event)\n\n    def auth_interactive_dumb(self, username, handler=None, submethods=''):\n        \"\"\"\n        Autenticate to the server interactively but dumber.\n        Just print the prompt and / or instructions to stdout and send back\n        the response. This is good for situations where partial auth is\n        achieved by key and then the user has to enter a 2fac token.\n        \"\"\"\n\n        if not handler:\n            def handler(title, instructions, prompt_list):\n                answers = []\n                if title:\n                    print(title.strip())\n                if instructions:\n                    print(instructions.strip())\n                for prompt, show_input in prompt_list:\n                    print(prompt.strip(), end=' ')\n                    answers.append(input())\n                return answers\n        return self.auth_interactive(username, handler, submethods)\n\n    def auth_gssapi_with_mic(self, username, gss_host, gss_deleg_creds):\n        \"\"\"\n        Authenticate to the Server using GSS-API / SSPI.\n\n        :param str username: The username to authenticate as\n        :param str gss_host: The target host\n        :param bool gss_deleg_creds: Delegate credentials or not\n        :return: list of auth types permissible for the next stage of\n                 authentication (normally empty)\n        :rtype: list\n        :raises: `.BadAuthenticationType` -- if gssapi-with-mic isn't\n            allowed by the server (and no event was passed in)\n        :raises:\n            `.AuthenticationException` -- if the authentication failed (and no\n            event was passed in)\n        :raises: `.SSHException` -- if there was a network error\n        \"\"\"\n        if (not self.active) or (not self.initial_kex_done):\n            # we should never try to authenticate unless we're on a secure link\n            raise SSHException('No existing session')\n        my_event = threading.Event()\n        self.auth_handler = AuthHandler(self)\n        self.auth_handler.auth_gssapi_with_mic(\n            username, gss_host, gss_deleg_creds, my_event\n        )\n        return self.auth_handler.wait_for_response(my_event)\n\n    def auth_gssapi_keyex(self, username):\n        \"\"\"\n        Authenticate to the server with GSS-API/SSPI if GSS-API kex is in use.\n\n        :param str username: The username to authenticate as.\n        :returns:\n            a `list` of auth types permissible for the next stage of\n            authentication (normally empty)\n        :raises: `.BadAuthenticationType` --\n            if GSS-API Key Exchange was not performed (and no event was passed\n            in)\n        :raises: `.AuthenticationException` --\n            if the authentication failed (and no event was passed in)\n        :raises: `.SSHException` -- if there was a network error\n        \"\"\"\n        if (not self.active) or (not self.initial_kex_done):\n            # we should never try to authenticate unless we're on a secure link\n            raise SSHException('No existing session')\n        my_event = threading.Event()\n        self.auth_handler = AuthHandler(self)\n        self.auth_handler.auth_gssapi_keyex(username, my_event)\n        return self.auth_handler.wait_for_response(my_event)\n\n    def set_log_channel(self, name):\n        \"\"\"\n        Set the channel for this transport's logging.  The default is\n        ``\"paramiko.transport\"`` but it can be set to anything you want. (See\n        the `.logging` module for more info.)  SSH Channels will log to a\n        sub-channel of the one specified.\n\n        :param str name: new channel name for logging\n\n        .. versionadded:: 1.1\n        \"\"\"\n        self.log_name = name\n        self.logger = util.get_logger(name)\n        self.packetizer.set_log(self.logger)\n\n    def get_log_channel(self):\n        \"\"\"\n        Return the channel name used for this transport's logging.\n\n        :return: channel name as a `str`\n\n        .. versionadded:: 1.2\n        \"\"\"\n        return self.log_name\n\n    def set_hexdump(self, hexdump):\n        \"\"\"\n        Turn on/off logging a hex dump of protocol traffic at DEBUG level in\n        the logs.  Normally you would want this off (which is the default),\n        but if you are debugging something, it may be useful.\n\n        :param bool hexdump:\n            ``True`` to log protocol traffix (in hex) to the log; ``False``\n            otherwise.\n        \"\"\"\n        self.packetizer.set_hexdump(hexdump)\n\n    def get_hexdump(self):\n        \"\"\"\n        Return ``True`` if the transport is currently logging hex dumps of\n        protocol traffic.\n\n        :return: ``True`` if hex dumps are being logged, else ``False``.\n\n        .. versionadded:: 1.4\n        \"\"\"\n        return self.packetizer.get_hexdump()\n\n    def use_compression(self, compress=True):\n        \"\"\"\n        Turn on/off compression.  This will only have an affect before starting\n        the transport (ie before calling `connect`, etc).  By default,\n        compression is off since it negatively affects interactive sessions.\n\n        :param bool compress:\n            ``True`` to ask the remote client/server to compress traffic;\n            ``False`` to refuse compression\n\n        .. versionadded:: 1.5.2\n        \"\"\"\n        if compress:\n            self._preferred_compression = ('zlib@openssh.com', 'zlib', 'none')\n        else:\n            self._preferred_compression = ('none',)\n\n    def getpeername(self):\n        \"\"\"\n        Return the address of the remote side of this Transport, if possible.\n\n        This is effectively a wrapper around ``getpeername`` on the underlying\n        socket.  If the socket-like object has no ``getpeername`` method, then\n        ``(\"unknown\", 0)`` is returned.\n\n        :return:\n            the address of the remote host, if known, as a ``(str, int)``\n            tuple.\n        \"\"\"\n        gp = getattr(self.sock, 'getpeername', None)\n        if gp is None:\n            return 'unknown', 0\n        return gp()\n\n    def stop_thread(self):\n        self.active = False\n        self.packetizer.close()\n        if PY2:\n            # Original join logic; #520 doesn't appear commonly present under\n            # Python 2.\n            while self.is_alive() and self is not threading.current_thread():\n                self.join(10)\n        else:\n            # Keep trying to join() our main thread, quickly, until:\n            # * We join()ed successfully (self.is_alive() == False)\n            # * Or it looks like we've hit issue #520 (socket.recv hitting some\n            # race condition preventing it from timing out correctly), wherein\n            # our socket and packetizer are both closed (but where we'd\n            # otherwise be sitting forever on that recv()).\n            while (\n                self.is_alive() and\n                self is not threading.current_thread() and\n                not self.sock._closed and\n                not self.packetizer.closed\n            ):\n                self.join(0.1)\n\n    # internals...\n\n    def _log(self, level, msg, *args):\n        if issubclass(type(msg), list):\n            for m in msg:\n                self.logger.log(level, m)\n        else:\n            self.logger.log(level, msg, *args)\n\n    def _get_modulus_pack(self):\n        \"\"\"used by KexGex to find primes for group exchange\"\"\"\n        return self._modulus_pack\n\n    def _next_channel(self):\n        \"\"\"you are holding the lock\"\"\"\n        chanid = self._channel_counter\n        while self._channels.get(chanid) is not None:\n            self._channel_counter = (self._channel_counter + 1) & 0xffffff\n            chanid = self._channel_counter\n        self._channel_counter = (self._channel_counter + 1) & 0xffffff\n        return chanid\n\n    def _unlink_channel(self, chanid):\n        \"\"\"used by a Channel to remove itself from the active channel list\"\"\"\n        self._channels.delete(chanid)\n\n    def _send_message(self, data):\n        self.packetizer.send_message(data)\n\n    def _send_user_message(self, data):\n        \"\"\"\n        send a message, but block if we're in key negotiation.  this is used\n        for user-initiated requests.\n        \"\"\"\n        start = time.time()\n        while True:\n            self.clear_to_send.wait(0.1)\n            if not self.active:\n                self._log(DEBUG, 'Dropping user packet because connection is dead.') # noqa\n                return\n            self.clear_to_send_lock.acquire()\n            if self.clear_to_send.is_set():\n                break\n            self.clear_to_send_lock.release()\n            if time.time() > start + self.clear_to_send_timeout:\n                raise SSHException('Key-exchange timed out waiting for key negotiation') # noqa\n        try:\n            self._send_message(data)\n        finally:\n            self.clear_to_send_lock.release()\n\n    def _set_K_H(self, k, h):\n        \"\"\"\n        Used by a kex obj to set the K (root key) and H (exchange hash).\n        \"\"\"\n        self.K = k\n        self.H = h\n        if self.session_id is None:\n            self.session_id = h\n\n    def _expect_packet(self, *ptypes):\n        \"\"\"\n        Used by a kex obj to register the next packet type it expects to see.\n        \"\"\"\n        self._expected_packet = tuple(ptypes)\n\n    def _verify_key(self, host_key, sig):\n        key = self._key_info[self.host_key_type](Message(host_key))\n        if key is None:\n            raise SSHException('Unknown host key type')\n        if not key.verify_ssh_sig(self.H, Message(sig)):\n            raise SSHException('Signature verification (%s) failed.' % self.host_key_type) # noqa\n        self.host_key = key\n\n    def _compute_key(self, id, nbytes):\n        \"\"\"id is 'A' - 'F' for the various keys used by ssh\"\"\"\n        m = Message()\n        m.add_mpint(self.K)\n        m.add_bytes(self.H)\n        m.add_byte(b(id))\n        m.add_bytes(self.session_id)\n        # Fallback to SHA1 for kex engines that fail to specify a hex\n        # algorithm, or for e.g. transport tests that don't run kexinit.\n        hash_algo = getattr(self.kex_engine, 'hash_algo', None)\n        hash_select_msg = \"kex engine %s specified hash_algo %r\" % (\n            self.kex_engine.__class__.__name__, hash_algo\n        )\n        if hash_algo is None:\n            hash_algo = sha1\n            hash_select_msg += \", falling back to sha1\"\n        if not hasattr(self, '_logged_hash_selection'):\n            self._log(DEBUG, hash_select_msg)\n            setattr(self, '_logged_hash_selection', True)\n        out = sofar = hash_algo(m.asbytes()).digest()\n        while len(out) < nbytes:\n            m = Message()\n            m.add_mpint(self.K)\n            m.add_bytes(self.H)\n            m.add_bytes(sofar)\n            digest = hash_algo(m.asbytes()).digest()\n            out += digest\n            sofar += digest\n        return out[:nbytes]\n\n    def _get_cipher(self, name, key, iv, operation):\n        if name not in self._cipher_info:\n            raise SSHException('Unknown client cipher ' + name)\n        else:\n            cipher = Cipher(\n                self._cipher_info[name]['class'](key),\n                self._cipher_info[name]['mode'](iv),\n                backend=default_backend(),\n            )\n            if operation is self._ENCRYPT:\n                return cipher.encryptor()\n            else:\n                return cipher.decryptor()\n\n    def _set_forward_agent_handler(self, handler):\n        if handler is None:\n            def default_handler(channel):\n                self._queue_incoming_channel(channel)\n            self._forward_agent_handler = default_handler\n        else:\n            self._forward_agent_handler = handler\n\n    def _set_x11_handler(self, handler):\n        # only called if a channel has turned on x11 forwarding\n        if handler is None:\n            # by default, use the same mechanism as accept()\n            def default_handler(channel, src_addr_port):\n                self._queue_incoming_channel(channel)\n            self._x11_handler = default_handler\n        else:\n            self._x11_handler = handler\n\n    def _queue_incoming_channel(self, channel):\n        self.lock.acquire()\n        try:\n            self.server_accepts.append(channel)\n            self.server_accept_cv.notify()\n        finally:\n            self.lock.release()\n\n    def _sanitize_window_size(self, window_size):\n        if window_size is None:\n            window_size = self.default_window_size\n        return clamp_value(MIN_WINDOW_SIZE, window_size, MAX_WINDOW_SIZE)\n\n    def _sanitize_packet_size(self, max_packet_size):\n        if max_packet_size is None:\n            max_packet_size = self.default_max_packet_size\n        return clamp_value(MIN_PACKET_SIZE, max_packet_size, MAX_WINDOW_SIZE)\n\n\n    def run(self):\n        # (use the exposed \"run\" method, because if we specify a thread target\n        # of a private method, threading.Thread will keep a reference to it\n        # indefinitely, creating a GC cycle and not letting Transport ever be\n        # GC'd. it's a bug in Thread.)\n\n        # Hold reference to 'sys' so we can test sys.modules to detect\n        # interpreter shutdown.\n        self.sys = sys\n\n        # active=True occurs before the thread is launched, to avoid a race\n        _active_threads.append(self)\n        tid = hex(long(id(self)) & xffffffff)\n        if self.server_mode:\n            self._log(DEBUG, 'starting thread (server mode): %s' % tid)\n        else:\n            self._log(DEBUG, 'starting thread (client mode): %s' % tid)\n        try:\n            try:\n                self.packetizer.write_all(b(self.local_version + '\\r\\n'))\n                self._log(DEBUG, 'Local version/idstring: %s' % self.local_version) # noqa\n                self._check_banner()\n                # The above is actually very much part of the handshake, but\n                # sometimes the banner can be read but the machine is not\n                # responding, for example when the remote ssh daemon is loaded\n                # in to memory but we can not read from the disk/spawn a new\n                # shell.\n                # Make sure we can specify a timeout for the initial handshake.\n                # Re-use the banner timeout for now.\n                self.packetizer.start_handshake(self.handshake_timeout)\n                self._send_kex_init()\n                self._expect_packet(MSG_KEXINIT)\n\n                while self.active:\n                    if self.packetizer.need_rekey() and not self.in_kex:\n                        self._send_kex_init()\n                    try:\n                        ptype, m = self.packetizer.read_message()\n                    except NeedRekeyException:\n                        continue\n                    if ptype == MSG_IGNORE:\n                        continue\n                    elif ptype == MSG_DISCONNECT:\n                        self._parse_disconnect(m)\n                        self.active = False\n                        self.packetizer.close()\n                        break\n                    elif ptype == MSG_DEBUG:\n                        self._parse_debug(m)\n                        continue\n                    if len(self._expected_packet) > 0:\n                        if ptype not in self._expected_packet:\n                            raise SSHException('Expecting packet from %r, got %d' % (self._expected_packet, ptype)) # noqa\n                        self._expected_packet = tuple()\n                        if (ptype >= 30) and (ptype <= 41):\n                            self.kex_engine.parse_next(ptype, m)\n                            continue\n\n                    if ptype in self._handler_table:\n                        self._handler_table[ptype](self, m)\n                    elif ptype in self._channel_handler_table:\n                        chanid = m.get_int()\n                        chan = self._channels.get(chanid)\n                        if chan is not None:\n                            self._channel_handler_table[ptype](chan, m)\n                        elif chanid in self.channels_seen:\n                            self._log(DEBUG, 'Ignoring message for dead channel %d' % chanid) # noqa\n                        else:\n                            self._log(ERROR, 'Channel request for unknown channel %d' % chanid) # noqa\n                            self.active = False\n                            self.packetizer.close()\n                    elif (\n                        self.auth_handler is not None and\n                        ptype in self.auth_handler._handler_table\n                    ):\n                        handler = self.auth_handler._handler_table[ptype]\n                        handler(self.auth_handler, m)\n                        if len(self._expected_packet) > 0:\n                            continue\n                    else:\n                        self._log(WARNING, 'Oops, unhandled type %d' % ptype)\n                        msg = Message()\n                        msg.add_byte(cMSG_UNIMPLEMENTED)\n                        msg.add_int(m.seqno)\n                        self._send_message(msg)\n                    self.packetizer.complete_handshake()\n            except SSHException as e:\n                self._log(ERROR, 'Exception: ' + str(e))\n                self._log(ERROR, util.tb_strings())\n                self.saved_exception = e\n            except EOFError as e:\n                self._log(DEBUG, 'EOF in transport thread')\n                self.saved_exception = e\n            except socket.error as e:\n                if type(e.args) is tuple:\n                    if e.args:\n                        emsg = '%s (%d)' % (e.args[1], e.args[0])\n                    else:  # empty tuple, e.g. socket.timeout\n                        emsg = str(e) or repr(e)\n                else:\n                    emsg = e.args\n                self._log(ERROR, 'Socket exception: ' + emsg)\n                self.saved_exception = e\n            except Exception as e:\n                self._log(ERROR, 'Unknown exception: ' + str(e))\n                self._log(ERROR, util.tb_strings())\n                self.saved_exception = e\n            _active_threads.remove(self)\n            for chan in list(self._channels.values()):\n                chan._unlink()\n            if self.active:\n                self.active = False\n                self.packetizer.close()\n                if self.completion_event is not None:\n                    self.completion_event.set()\n                if self.auth_handler is not None:\n                    self.auth_handler.abort()\n                for event in self.channel_events.values():\n                    event.set()\n                try:\n                    self.lock.acquire()\n                    self.server_accept_cv.notify()\n                finally:\n                    self.lock.release()\n            self.sock.close()\n        except:\n            # Don't raise spurious 'NoneType has no attribute X' errors when we\n            # wake up during interpreter shutdown. Or rather -- raise\n            # everything *if* sys.modules (used as a convenient sentinel)\n            # appears to still exist.\n            if self.sys.modules is not None:\n                raise\n\n\n    def _log_agreement(self, which, local, remote):\n        # Log useful, non-duplicative line re: an agreed-upon algorithm.\n        # Old code implied algorithms could be asymmetrical (different for\n        # inbound vs outbound) so we preserve that possibility.\n        msg = \"{0} agreed: \".format(which)\n        if local == remote:\n            msg += local\n        else:\n            msg += \"local={0}, remote={1}\".format(local, remote)\n        self._log(DEBUG, msg)\n\n    # protocol stages\n\n    def _negotiate_keys(self, m):\n        # throws SSHException on anything unusual\n        self.clear_to_send_lock.acquire()\n        try:\n            self.clear_to_send.clear()\n        finally:\n            self.clear_to_send_lock.release()\n        if self.local_kex_init is None:\n            # remote side wants to renegotiate\n            self._send_kex_init()\n        self._parse_kex_init(m)\n        self.kex_engine.start_kex()\n\n    def _check_banner(self):\n        # this is slow, but we only have to do it once\n        for i in range(100):\n            # give them 15 seconds for the first line, then just 2 seconds\n            # each additional line.  (some sites have very high latency.)\n            if i == 0:\n                timeout = self.banner_timeout\n            else:\n                timeout = 2\n            try:\n                buf = self.packetizer.readline(timeout)\n            except ProxyCommandFailure:\n                raise\n            except Exception as e:\n                raise SSHException(\n                    'Error reading SSH protocol banner' + str(e)\n                )\n            if buf[:4] == 'SSH-':\n                break\n            self._log(DEBUG, 'Banner: ' + buf)\n        if buf[:4] != 'SSH-':\n            raise SSHException('Indecipherable protocol version \"' + buf + '\"')\n        # save this server version string for later\n        self.remote_version = buf\n        self._log(DEBUG, 'Remote version/idstring: %s' % buf)\n        # pull off any attached comment\n        # NOTE: comment used to be stored in a variable and then...never used.\n        # since 2003. ca 877cd974b8182d26fa76d566072917ea67b64e67\n        i = buf.find(' ')\n        if i >= 0:\n            buf = buf[:i]\n        # parse out version string and make sure it matches\n        segs = buf.split('-', 2)\n        if len(segs) < 3:\n            raise SSHException('Invalid SSH banner')\n        version = segs[1]\n        client = segs[2]\n        if version != '1.99' and version != '2.0':\n            msg = 'Incompatible version ({0} instead of 2.0)'\n            raise SSHException(msg.format(version))\n        msg = 'Connected (version {0}, client {1})'.format(version, client)\n        self._log(INFO, msg)\n\n    def _send_kex_init(self):\n        \"\"\"\n        announce to the other side that we'd like to negotiate keys, and what\n        kind of key negotiation we support.\n        \"\"\"\n        self.clear_to_send_lock.acquire()\n        try:\n            self.clear_to_send.clear()\n        finally:\n            self.clear_to_send_lock.release()\n        self.in_kex = True\n        if self.server_mode:\n            mp_required_prefix = 'diffie-hellman-group-exchange-sha'\n            kex_mp = [\n                k for k\n                in self._preferred_kex\n                if k.startswith(mp_required_prefix)\n            ]\n            if (self._modulus_pack is None) and (len(kex_mp) > 0):\n                # can't do group-exchange if we don't have a pack of potential\n                # primes\n                pkex = [\n                    k for k\n                    in self.get_security_options().kex\n                    if not k.startswith(mp_required_prefix)\n                ]\n                self.get_security_options().kex = pkex\n            available_server_keys = list(filter(\n                list(self.server_key_dict.keys()).__contains__,\n                self._preferred_keys\n            ))\n        else:\n            available_server_keys = self._preferred_keys\n\n        m = Message()\n        m.add_byte(cMSG_KEXINIT)\n        m.add_bytes(os.urandom(16))\n        m.add_list(self._preferred_kex)\n        m.add_list(available_server_keys)\n        m.add_list(self._preferred_ciphers)\n        m.add_list(self._preferred_ciphers)\n        m.add_list(self._preferred_macs)\n        m.add_list(self._preferred_macs)\n        m.add_list(self._preferred_compression)\n        m.add_list(self._preferred_compression)\n        m.add_string(bytes())\n        m.add_string(bytes())\n        m.add_boolean(False)\n        m.add_int(0)\n        # save a copy for later (needed to compute a hash)\n        self.local_kex_init = m.asbytes()\n        self._send_message(m)\n\n    def _parse_kex_init(self, m):\n        m.get_bytes(16) # cookie, discarded\n        kex_algo_list = m.get_list()\n        server_key_algo_list = m.get_list()\n        client_encrypt_algo_list = m.get_list()\n        server_encrypt_algo_list = m.get_list()\n        client_mac_algo_list = m.get_list()\n        server_mac_algo_list = m.get_list()\n        client_compress_algo_list = m.get_list()\n        server_compress_algo_list = m.get_list()\n        client_lang_list = m.get_list()\n        server_lang_list = m.get_list()\n        kex_follows = m.get_boolean()\n        m.get_int() # unused\n\n        self._log(DEBUG,\n            'kex algos:' + str(kex_algo_list) +\n            ' server key:' + str(server_key_algo_list) +\n            ' client encrypt:' + str(client_encrypt_algo_list) +\n            ' server encrypt:' + str(server_encrypt_algo_list) +\n            ' client mac:' + str(client_mac_algo_list) +\n            ' server mac:' + str(server_mac_algo_list) +\n            ' client compress:' + str(client_compress_algo_list) +\n            ' server compress:' + str(server_compress_algo_list) +\n            ' client lang:' + str(client_lang_list) +\n            ' server lang:' + str(server_lang_list) +\n            ' kex follows?' + str(kex_follows)\n        )\n\n        # as a server, we pick the first item in the client's list that we\n        # support.\n        # as a client, we pick the first item in our list that the server\n        # supports.\n        if self.server_mode:\n            agreed_kex = list(filter(\n                self._preferred_kex.__contains__,\n                kex_algo_list\n            ))\n        else:\n            agreed_kex = list(filter(\n                kex_algo_list.__contains__,\n                self._preferred_kex\n            ))\n        if len(agreed_kex) == 0:\n            raise SSHException('Incompatible ssh peer (no acceptable kex algorithm)') # noqa\n        self.kex_engine = self._kex_info[agreed_kex[0]](self)\n        self._log(DEBUG, \"Kex agreed: %s\" % agreed_kex[0])\n\n        if self.server_mode:\n            available_server_keys = list(filter(\n                list(self.server_key_dict.keys()).__contains__,\n                self._preferred_keys\n            ))\n            agreed_keys = list(filter(\n                available_server_keys.__contains__, server_key_algo_list\n            ))\n        else:\n            agreed_keys = list(filter(\n                server_key_algo_list.__contains__, self._preferred_keys\n            ))\n        if len(agreed_keys) == 0:\n            raise SSHException('Incompatible ssh peer (no acceptable host key)') # noqa\n        self.host_key_type = agreed_keys[0]\n        if self.server_mode and (self.get_server_key() is None):\n            raise SSHException('Incompatible ssh peer (can\\'t match requested host key type)') # noqa\n\n        if self.server_mode:\n            agreed_local_ciphers = list(filter(\n                self._preferred_ciphers.__contains__,\n                server_encrypt_algo_list\n            ))\n            agreed_remote_ciphers = list(filter(\n                self._preferred_ciphers.__contains__,\n                client_encrypt_algo_list\n            ))\n        else:\n            agreed_local_ciphers = list(filter(\n                client_encrypt_algo_list.__contains__,\n                self._preferred_ciphers\n            ))\n            agreed_remote_ciphers = list(filter(\n                server_encrypt_algo_list.__contains__,\n                self._preferred_ciphers\n            ))\n        if len(agreed_local_ciphers) == 0 or len(agreed_remote_ciphers) == 0:\n            raise SSHException('Incompatible ssh server (no acceptable ciphers)') # noqa\n        self.local_cipher = agreed_local_ciphers[0]\n        self.remote_cipher = agreed_remote_ciphers[0]\n        self._log_agreement(\n            'Cipher', local=self.local_cipher, remote=self.remote_cipher\n        )\n\n        if self.server_mode:\n            agreed_remote_macs = list(filter(\n                self._preferred_macs.__contains__, client_mac_algo_list\n            ))\n            agreed_local_macs = list(filter(\n                self._preferred_macs.__contains__, server_mac_algo_list\n            ))\n        else:\n            agreed_local_macs = list(filter(\n                client_mac_algo_list.__contains__, self._preferred_macs\n            ))\n            agreed_remote_macs = list(filter(\n                server_mac_algo_list.__contains__, self._preferred_macs\n            ))\n        if (len(agreed_local_macs) == 0) or (len(agreed_remote_macs) == 0):\n            raise SSHException('Incompatible ssh server (no acceptable macs)')\n        self.local_mac = agreed_local_macs[0]\n        self.remote_mac = agreed_remote_macs[0]\n        self._log_agreement(\n            'MAC', local=self.local_mac, remote=self.remote_mac\n        )\n\n        if self.server_mode:\n            agreed_remote_compression = list(filter(\n                self._preferred_compression.__contains__,\n                client_compress_algo_list\n            ))\n            agreed_local_compression = list(filter(\n                self._preferred_compression.__contains__,\n                server_compress_algo_list\n            ))\n        else:\n            agreed_local_compression = list(filter(\n                client_compress_algo_list.__contains__,\n                self._preferred_compression\n            ))\n            agreed_remote_compression = list(filter(\n                server_compress_algo_list.__contains__,\n                self._preferred_compression\n            ))\n        if (\n            len(agreed_local_compression) == 0 or\n            len(agreed_remote_compression) == 0\n        ):\n            msg = 'Incompatible ssh server (no acceptable compression) {0!r} {1!r} {2!r}' # noqa\n            raise SSHException(msg.format(\n                agreed_local_compression, agreed_remote_compression,\n                self._preferred_compression,\n            ))\n        self.local_compression = agreed_local_compression[0]\n        self.remote_compression = agreed_remote_compression[0]\n        self._log_agreement(\n            'Compression',\n            local=self.local_compression,\n            remote=self.remote_compression\n        )\n\n        # save for computing hash later...\n        # now wait!  openssh has a bug (and others might too) where there are\n        # actually some extra bytes (one NUL byte in openssh's case) added to\n        # the end of the packet but not parsed.  turns out we need to throw\n        # away those bytes because they aren't part of the hash.\n        self.remote_kex_init = cMSG_KEXINIT + m.get_so_far()\n\n    def _activate_inbound(self):\n        \"\"\"switch on newly negotiated encryption parameters for\n         inbound traffic\"\"\"\n        block_size = self._cipher_info[self.remote_cipher]['block-size']\n        if self.server_mode:\n            IV_in = self._compute_key('A', block_size)\n            key_in = self._compute_key(\n                'C', self._cipher_info[self.remote_cipher]['key-size']\n            )\n        else:\n            IV_in = self._compute_key('B', block_size)\n            key_in = self._compute_key(\n                'D', self._cipher_info[self.remote_cipher]['key-size']\n            )\n        engine = self._get_cipher(\n            self.remote_cipher, key_in, IV_in, self._DECRYPT\n        )\n        mac_size = self._mac_info[self.remote_mac]['size']\n        mac_engine = self._mac_info[self.remote_mac]['class']\n        # initial mac keys are done in the hash's natural size (not the\n        # potentially truncated transmission size)\n        if self.server_mode:\n            mac_key = self._compute_key('E', mac_engine().digest_size)\n        else:\n            mac_key = self._compute_key('F', mac_engine().digest_size)\n        self.packetizer.set_inbound_cipher(\n            engine, block_size, mac_engine, mac_size, mac_key\n        )\n        compress_in = self._compression_info[self.remote_compression][1]\n        if (\n            compress_in is not None and\n            (\n                self.remote_compression != 'zlib@openssh.com' or\n                self.authenticated\n            )\n        ):\n            self._log(DEBUG, 'Switching on inbound compression ...')\n            self.packetizer.set_inbound_compressor(compress_in())\n\n    def _activate_outbound(self):\n        \"\"\"switch on newly negotiated encryption parameters for\n         outbound traffic\"\"\"\n        m = Message()\n        m.add_byte(cMSG_NEWKEYS)\n        self._send_message(m)\n        block_size = self._cipher_info[self.local_cipher]['block-size']\n        if self.server_mode:\n            IV_out = self._compute_key('B', block_size)\n            key_out = self._compute_key(\n                'D', self._cipher_info[self.local_cipher]['key-size'])\n        else:\n            IV_out = self._compute_key('A', block_size)\n            key_out = self._compute_key(\n                'C', self._cipher_info[self.local_cipher]['key-size'])\n        engine = self._get_cipher(\n            self.local_cipher, key_out, IV_out, self._ENCRYPT)\n        mac_size = self._mac_info[self.local_mac]['size']\n        mac_engine = self._mac_info[self.local_mac]['class']\n        # initial mac keys are done in the hash's natural size (not the\n        # potentially truncated transmission size)\n        if self.server_mode:\n            mac_key = self._compute_key('F', mac_engine().digest_size)\n        else:\n            mac_key = self._compute_key('E', mac_engine().digest_size)\n        sdctr = self.local_cipher.endswith('-ctr')\n        self.packetizer.set_outbound_cipher(\n            engine, block_size, mac_engine, mac_size, mac_key, sdctr)\n        compress_out = self._compression_info[self.local_compression][0]\n        if (\n            compress_out is not None and\n            (\n                self.local_compression != 'zlib@openssh.com' or\n                self.authenticated\n            )\n        ):\n            self._log(DEBUG, 'Switching on outbound compression ...')\n            self.packetizer.set_outbound_compressor(compress_out())\n        if not self.packetizer.need_rekey():\n            self.in_kex = False\n        # we always expect to receive NEWKEYS now\n        self._expect_packet(MSG_NEWKEYS)\n\n    def _auth_trigger(self):\n        self.authenticated = True\n        # delayed initiation of compression\n        if self.local_compression == 'zlib@openssh.com':\n            compress_out = self._compression_info[self.local_compression][0]\n            self._log(DEBUG, 'Switching on outbound compression ...')\n            self.packetizer.set_outbound_compressor(compress_out())\n        if self.remote_compression == 'zlib@openssh.com':\n            compress_in = self._compression_info[self.remote_compression][1]\n            self._log(DEBUG, 'Switching on inbound compression ...')\n            self.packetizer.set_inbound_compressor(compress_in())\n\n    def _parse_newkeys(self, m):\n        self._log(DEBUG, 'Switch to new keys ...')\n        self._activate_inbound()\n        # can also free a bunch of stuff here\n        self.local_kex_init = self.remote_kex_init = None\n        self.K = None\n        self.kex_engine = None\n        if self.server_mode and (self.auth_handler is None):\n            # create auth handler for server mode\n            self.auth_handler = AuthHandler(self)\n        if not self.initial_kex_done:\n            # this was the first key exchange\n            self.initial_kex_done = True\n        # send an event?\n        if self.completion_event is not None:\n            self.completion_event.set()\n        # it's now okay to send data again (if this was a re-key)\n        if not self.packetizer.need_rekey():\n            self.in_kex = False\n        self.clear_to_send_lock.acquire()\n        try:\n            self.clear_to_send.set()\n        finally:\n            self.clear_to_send_lock.release()\n        return\n\n    def _parse_disconnect(self, m):\n        code = m.get_int()\n        desc = m.get_text()\n        self._log(INFO, 'Disconnect (code %d): %s' % (code, desc))\n\n    def _parse_global_request(self, m):\n        kind = m.get_text()\n        self._log(DEBUG, 'Received global request \"%s\"' % kind)\n        want_reply = m.get_boolean()\n        if not self.server_mode:\n            self._log(\n                DEBUG,\n                'Rejecting \"%s\" global request from server.' % kind\n            )\n            ok = False\n        elif kind == 'tcpip-forward':\n            address = m.get_text()\n            port = m.get_int()\n            ok = self.server_object.check_port_forward_request(address, port)\n            if ok:\n                ok = (ok,)\n        elif kind == 'cancel-tcpip-forward':\n            address = m.get_text()\n            port = m.get_int()\n            self.server_object.cancel_port_forward_request(address, port)\n            ok = True\n        else:\n            ok = self.server_object.check_global_request(kind, m)\n        extra = ()\n        if type(ok) is tuple:\n            extra = ok\n            ok = True\n        if want_reply:\n            msg = Message()\n            if ok:\n                msg.add_byte(cMSG_REQUEST_SUCCESS)\n                msg.add(*extra)\n            else:\n                msg.add_byte(cMSG_REQUEST_FAILURE)\n            self._send_message(msg)\n\n    def _parse_request_success(self, m):\n        self._log(DEBUG, 'Global request successful.')\n        self.global_response = m\n        if self.completion_event is not None:\n            self.completion_event.set()\n\n    def _parse_request_failure(self, m):\n        self._log(DEBUG, 'Global request denied.')\n        self.global_response = None\n        if self.completion_event is not None:\n            self.completion_event.set()\n\n    def _parse_channel_open_success(self, m):\n        chanid = m.get_int()\n        server_chanid = m.get_int()\n        server_window_size = m.get_int()\n        server_max_packet_size = m.get_int()\n        chan = self._channels.get(chanid)\n        if chan is None:\n            self._log(WARNING, 'Success for unrequested channel! [??]')\n            return\n        self.lock.acquire()\n        try:\n            chan._set_remote_channel(\n                server_chanid, server_window_size, server_max_packet_size)\n            self._log(DEBUG, 'Secsh channel %d opened.' % chanid)\n            if chanid in self.channel_events:\n                self.channel_events[chanid].set()\n                del self.channel_events[chanid]\n        finally:\n            self.lock.release()\n        return\n\n    def _parse_channel_open_failure(self, m):\n        chanid = m.get_int()\n        reason = m.get_int()\n        reason_str = m.get_text()\n        m.get_text()  # ignored language\n        reason_text = CONNECTION_FAILED_CODE.get(reason, '(unknown code)')\n        self._log(\n            ERROR,\n            'Secsh channel %d open FAILED: %s: %s' % (\n                chanid, reason_str, reason_text)\n        )\n        self.lock.acquire()\n        try:\n            self.saved_exception = ChannelException(reason, reason_text)\n            if chanid in self.channel_events:\n                self._channels.delete(chanid)\n                if chanid in self.channel_events:\n                    self.channel_events[chanid].set()\n                    del self.channel_events[chanid]\n        finally:\n            self.lock.release()\n        return\n\n    def _parse_channel_open(self, m):\n        kind = m.get_text()\n        chanid = m.get_int()\n        initial_window_size = m.get_int()\n        max_packet_size = m.get_int()\n        reject = False\n        if (\n            kind == 'auth-agent@openssh.com' and\n            self._forward_agent_handler is not None\n        ):\n            self._log(DEBUG, 'Incoming forward agent connection')\n            self.lock.acquire()\n            try:\n                my_chanid = self._next_channel()\n            finally:\n                self.lock.release()\n        elif (kind == 'x11') and (self._x11_handler is not None):\n            origin_addr = m.get_text()\n            origin_port = m.get_int()\n            self._log(\n                DEBUG,\n                'Incoming x11 connection from %s:%d' % (\n                    origin_addr, origin_port)\n            )\n            self.lock.acquire()\n            try:\n                my_chanid = self._next_channel()\n            finally:\n                self.lock.release()\n        elif (kind == 'forwarded-tcpip') and (self._tcp_handler is not None):\n            server_addr = m.get_text()\n            server_port = m.get_int()\n            origin_addr = m.get_text()\n            origin_port = m.get_int()\n            self._log(\n                DEBUG,\n                'Incoming tcp forwarded connection from %s:%d' % (\n                    origin_addr, origin_port)\n            )\n            self.lock.acquire()\n            try:\n                my_chanid = self._next_channel()\n            finally:\n                self.lock.release()\n        elif not self.server_mode:\n            self._log(\n                DEBUG,\n                'Rejecting \"%s\" channel request from server.' % kind)\n            reject = True\n            reason = OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED\n        else:\n            self.lock.acquire()\n            try:\n                my_chanid = self._next_channel()\n            finally:\n                self.lock.release()\n            if kind == 'direct-tcpip':\n                # handle direct-tcpip requests coming from the client\n                dest_addr = m.get_text()\n                dest_port = m.get_int()\n                origin_addr = m.get_text()\n                origin_port = m.get_int()\n                reason = self.server_object.check_channel_direct_tcpip_request(\n                    my_chanid,\n                    (origin_addr, origin_port),\n                    (dest_addr, dest_port)\n                )\n            else:\n                reason = self.server_object.check_channel_request(\n                    kind, my_chanid)\n            if reason != OPEN_SUCCEEDED:\n                self._log(\n                    DEBUG,\n                    'Rejecting \"%s\" channel request from client.' % kind)\n                reject = True\n        if reject:\n            msg = Message()\n            msg.add_byte(cMSG_CHANNEL_OPEN_FAILURE)\n            msg.add_int(chanid)\n            msg.add_int(reason)\n            msg.add_string('')\n            msg.add_string('en')\n            self._send_message(msg)\n            return\n\n        chan = Channel(my_chanid)\n        self.lock.acquire()\n        try:\n            self._channels.put(my_chanid, chan)\n            self.channels_seen[my_chanid] = True\n            chan._set_transport(self)\n            chan._set_window(\n                self.default_window_size, self.default_max_packet_size)\n            chan._set_remote_channel(\n                chanid, initial_window_size, max_packet_size)\n        finally:\n            self.lock.release()\n        m = Message()\n        m.add_byte(cMSG_CHANNEL_OPEN_SUCCESS)\n        m.add_int(chanid)\n        m.add_int(my_chanid)\n        m.add_int(self.default_window_size)\n        m.add_int(self.default_max_packet_size)\n        self._send_message(m)\n        self._log(DEBUG, 'Secsh channel %d (%s) opened.', my_chanid, kind)\n        if kind == 'auth-agent@openssh.com':\n            self._forward_agent_handler(chan)\n        elif kind == 'x11':\n            self._x11_handler(chan, (origin_addr, origin_port))\n        elif kind == 'forwarded-tcpip':\n            chan.origin_addr = (origin_addr, origin_port)\n            self._tcp_handler(\n                chan,\n                (origin_addr, origin_port),\n                (server_addr, server_port)\n            )\n        else:\n            self._queue_incoming_channel(chan)\n\n    def _parse_debug(self, m):\n        m.get_boolean()  # always_display\n        msg = m.get_string()\n        m.get_string()  # language\n        self._log(DEBUG, 'Debug msg: {0}'.format(util.safe_string(msg)))\n\n    def _get_subsystem_handler(self, name):\n        try:\n            self.lock.acquire()\n            if name not in self.subsystem_table:\n                return None, [], {}\n            return self.subsystem_table[name]\n        finally:\n            self.lock.release()\n\n    _handler_table = {\n        MSG_NEWKEYS: _parse_newkeys,\n        MSG_GLOBAL_REQUEST: _parse_global_request,\n        MSG_REQUEST_SUCCESS: _parse_request_success,\n        MSG_REQUEST_FAILURE: _parse_request_failure,\n        MSG_CHANNEL_OPEN_SUCCESS: _parse_channel_open_success,\n        MSG_CHANNEL_OPEN_FAILURE: _parse_channel_open_failure,\n        MSG_CHANNEL_OPEN: _parse_channel_open,\n        MSG_KEXINIT: _negotiate_keys,\n    }\n\n    _channel_handler_table = {\n        MSG_CHANNEL_SUCCESS: Channel._request_success,\n        MSG_CHANNEL_FAILURE: Channel._request_failed,\n        MSG_CHANNEL_DATA: Channel._feed,\n        MSG_CHANNEL_EXTENDED_DATA: Channel._feed_extended,\n        MSG_CHANNEL_WINDOW_ADJUST: Channel._window_adjust,\n        MSG_CHANNEL_REQUEST: Channel._handle_request,\n        MSG_CHANNEL_EOF: Channel._handle_eof,\n        MSG_CHANNEL_CLOSE: Channel._handle_close,\n    }\n\n\nclass SecurityOptions (object):\n    \"\"\"\n    Simple object containing the security preferences of an ssh transport.\n    These are tuples of acceptable ciphers, digests, key types, and key\n    exchange algorithms, listed in order of preference.\n\n    Changing the contents and/or order of these fields affects the underlying\n    `.Transport` (but only if you change them before starting the session).\n    If you try to add an algorithm that paramiko doesn't recognize,\n    ``ValueError`` will be raised.  If you try to assign something besides a\n    tuple to one of the fields, ``TypeError`` will be raised.\n    \"\"\"\n    __slots__ = '_transport'\n\n    def __init__(self, transport):\n        self._transport = transport\n\n    def __repr__(self):\n        \"\"\"\n        Returns a string representation of this object, for debugging.\n        \"\"\"\n        return '<paramiko.SecurityOptions for %s>' % repr(self._transport)\n\n    def _set(self, name, orig, x):\n        if type(x) is list:\n            x = tuple(x)\n        if type(x) is not tuple:\n            raise TypeError('expected tuple or list')\n        possible = list(getattr(self._transport, orig).keys())\n        forbidden = [n for n in x if n not in possible]\n        if len(forbidden) > 0:\n            raise ValueError('unknown cipher')\n        setattr(self._transport, name, x)\n\n    @property\n    def ciphers(self):\n        \"\"\"Symmetric encryption ciphers\"\"\"\n        return self._transport._preferred_ciphers\n\n    @ciphers.setter\n    def ciphers(self, x):\n        self._set('_preferred_ciphers', '_cipher_info', x)\n\n    @property\n    def digests(self):\n        \"\"\"Digest (one-way hash) algorithms\"\"\"\n        return self._transport._preferred_macs\n\n    @digests.setter\n    def digests(self, x):\n        self._set('_preferred_macs', '_mac_info', x)\n\n    @property\n    def key_types(self):\n        \"\"\"Public-key algorithms\"\"\"\n        return self._transport._preferred_keys\n\n    @key_types.setter\n    def key_types(self, x):\n        self._set('_preferred_keys', '_key_info', x)\n\n\n    @property\n    def kex(self):\n        \"\"\"Key exchange algorithms\"\"\"\n        return self._transport._preferred_kex\n\n    @kex.setter\n    def kex(self, x):\n        self._set('_preferred_kex', '_kex_info', x)\n\n    @property\n    def compression(self):\n        \"\"\"Compression algorithms\"\"\"\n        return self._transport._preferred_compression\n\n    @compression.setter\n    def compression(self, x):\n        self._set('_preferred_compression', '_compression_info', x)\n\n\nclass ChannelMap (object):\n    def __init__(self):\n        # (id -> Channel)\n        self._map = weakref.WeakValueDictionary()\n        self._lock = threading.Lock()\n\n    def put(self, chanid, chan):\n        self._lock.acquire()\n        try:\n            self._map[chanid] = chan\n        finally:\n            self._lock.release()\n\n    def get(self, chanid):\n        self._lock.acquire()\n        try:\n            return self._map.get(chanid, None)\n        finally:\n            self._lock.release()\n\n    def delete(self, chanid):\n        self._lock.acquire()\n        try:\n            try:\n                del self._map[chanid]\n            except KeyError:\n                pass\n        finally:\n            self._lock.release()\n\n    def values(self):\n        self._lock.acquire()\n        try:\n            return list(self._map.values())\n        finally:\n            self._lock.release()\n\n    def __len__(self):\n        self._lock.acquire()\n        try:\n            return len(self._map)\n        finally:\n            self._lock.release()\n"], "fixing_code": ["# Copyright (C) 2003-2007  Robey Pointer <robeypointer@gmail.com>\n#\n# This file is part of paramiko.\n#\n# Paramiko is free software; you can redistribute it and/or modify it under the\n# terms of the GNU Lesser General Public License as published by the Free\n# Software Foundation; either version 2.1 of the License, or (at your option)\n# any later version.\n#\n# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY\n# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with Paramiko; if not, write to the Free Software Foundation, Inc.,\n# 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n\n\"\"\"\nCommon constants and global variables.\n\"\"\"\nimport logging\nfrom paramiko.py3compat import byte_chr, PY2, bytes_types, text_type, long\n\nMSG_DISCONNECT, MSG_IGNORE, MSG_UNIMPLEMENTED, MSG_DEBUG, \\\n    MSG_SERVICE_REQUEST, MSG_SERVICE_ACCEPT = range(1, 7)\nMSG_KEXINIT, MSG_NEWKEYS = range(20, 22)\nMSG_USERAUTH_REQUEST, MSG_USERAUTH_FAILURE, MSG_USERAUTH_SUCCESS, \\\n    MSG_USERAUTH_BANNER = range(50, 54)\nMSG_USERAUTH_PK_OK = 60\nMSG_USERAUTH_INFO_REQUEST, MSG_USERAUTH_INFO_RESPONSE = range(60, 62)\nMSG_USERAUTH_GSSAPI_RESPONSE, MSG_USERAUTH_GSSAPI_TOKEN = range(60, 62)\nMSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, MSG_USERAUTH_GSSAPI_ERROR,\\\n    MSG_USERAUTH_GSSAPI_ERRTOK, MSG_USERAUTH_GSSAPI_MIC = range(63, 67)\nHIGHEST_USERAUTH_MESSAGE_ID = 79\nMSG_GLOBAL_REQUEST, MSG_REQUEST_SUCCESS, MSG_REQUEST_FAILURE = range(80, 83)\nMSG_CHANNEL_OPEN, MSG_CHANNEL_OPEN_SUCCESS, MSG_CHANNEL_OPEN_FAILURE, \\\n    MSG_CHANNEL_WINDOW_ADJUST, MSG_CHANNEL_DATA, MSG_CHANNEL_EXTENDED_DATA, \\\n    MSG_CHANNEL_EOF, MSG_CHANNEL_CLOSE, MSG_CHANNEL_REQUEST, \\\n    MSG_CHANNEL_SUCCESS, MSG_CHANNEL_FAILURE = range(90, 101)\n\ncMSG_DISCONNECT = byte_chr(MSG_DISCONNECT)\ncMSG_IGNORE = byte_chr(MSG_IGNORE)\ncMSG_UNIMPLEMENTED = byte_chr(MSG_UNIMPLEMENTED)\ncMSG_DEBUG = byte_chr(MSG_DEBUG)\ncMSG_SERVICE_REQUEST = byte_chr(MSG_SERVICE_REQUEST)\ncMSG_SERVICE_ACCEPT = byte_chr(MSG_SERVICE_ACCEPT)\ncMSG_KEXINIT = byte_chr(MSG_KEXINIT)\ncMSG_NEWKEYS = byte_chr(MSG_NEWKEYS)\ncMSG_USERAUTH_REQUEST = byte_chr(MSG_USERAUTH_REQUEST)\ncMSG_USERAUTH_FAILURE = byte_chr(MSG_USERAUTH_FAILURE)\ncMSG_USERAUTH_SUCCESS = byte_chr(MSG_USERAUTH_SUCCESS)\ncMSG_USERAUTH_BANNER = byte_chr(MSG_USERAUTH_BANNER)\ncMSG_USERAUTH_PK_OK = byte_chr(MSG_USERAUTH_PK_OK)\ncMSG_USERAUTH_INFO_REQUEST = byte_chr(MSG_USERAUTH_INFO_REQUEST)\ncMSG_USERAUTH_INFO_RESPONSE = byte_chr(MSG_USERAUTH_INFO_RESPONSE)\ncMSG_USERAUTH_GSSAPI_RESPONSE = byte_chr(MSG_USERAUTH_GSSAPI_RESPONSE)\ncMSG_USERAUTH_GSSAPI_TOKEN = byte_chr(MSG_USERAUTH_GSSAPI_TOKEN)\ncMSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE = \\\n    byte_chr(MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE)\ncMSG_USERAUTH_GSSAPI_ERROR = byte_chr(MSG_USERAUTH_GSSAPI_ERROR)\ncMSG_USERAUTH_GSSAPI_ERRTOK = byte_chr(MSG_USERAUTH_GSSAPI_ERRTOK)\ncMSG_USERAUTH_GSSAPI_MIC = byte_chr(MSG_USERAUTH_GSSAPI_MIC)\ncMSG_GLOBAL_REQUEST = byte_chr(MSG_GLOBAL_REQUEST)\ncMSG_REQUEST_SUCCESS = byte_chr(MSG_REQUEST_SUCCESS)\ncMSG_REQUEST_FAILURE = byte_chr(MSG_REQUEST_FAILURE)\ncMSG_CHANNEL_OPEN = byte_chr(MSG_CHANNEL_OPEN)\ncMSG_CHANNEL_OPEN_SUCCESS = byte_chr(MSG_CHANNEL_OPEN_SUCCESS)\ncMSG_CHANNEL_OPEN_FAILURE = byte_chr(MSG_CHANNEL_OPEN_FAILURE)\ncMSG_CHANNEL_WINDOW_ADJUST = byte_chr(MSG_CHANNEL_WINDOW_ADJUST)\ncMSG_CHANNEL_DATA = byte_chr(MSG_CHANNEL_DATA)\ncMSG_CHANNEL_EXTENDED_DATA = byte_chr(MSG_CHANNEL_EXTENDED_DATA)\ncMSG_CHANNEL_EOF = byte_chr(MSG_CHANNEL_EOF)\ncMSG_CHANNEL_CLOSE = byte_chr(MSG_CHANNEL_CLOSE)\ncMSG_CHANNEL_REQUEST = byte_chr(MSG_CHANNEL_REQUEST)\ncMSG_CHANNEL_SUCCESS = byte_chr(MSG_CHANNEL_SUCCESS)\ncMSG_CHANNEL_FAILURE = byte_chr(MSG_CHANNEL_FAILURE)\n\n# for debugging:\nMSG_NAMES = {\n    MSG_DISCONNECT: 'disconnect',\n    MSG_IGNORE: 'ignore',\n    MSG_UNIMPLEMENTED: 'unimplemented',\n    MSG_DEBUG: 'debug',\n    MSG_SERVICE_REQUEST: 'service-request',\n    MSG_SERVICE_ACCEPT: 'service-accept',\n    MSG_KEXINIT: 'kexinit',\n    MSG_NEWKEYS: 'newkeys',\n    30: 'kex30',\n    31: 'kex31',\n    32: 'kex32',\n    33: 'kex33',\n    34: 'kex34',\n    40: 'kex40',\n    41: 'kex41',\n    MSG_USERAUTH_REQUEST: 'userauth-request',\n    MSG_USERAUTH_FAILURE: 'userauth-failure',\n    MSG_USERAUTH_SUCCESS: 'userauth-success',\n    MSG_USERAUTH_BANNER: 'userauth--banner',\n    MSG_USERAUTH_PK_OK: 'userauth-60(pk-ok/info-request)',\n    MSG_USERAUTH_INFO_RESPONSE: 'userauth-info-response',\n    MSG_GLOBAL_REQUEST: 'global-request',\n    MSG_REQUEST_SUCCESS: 'request-success',\n    MSG_REQUEST_FAILURE: 'request-failure',\n    MSG_CHANNEL_OPEN: 'channel-open',\n    MSG_CHANNEL_OPEN_SUCCESS: 'channel-open-success',\n    MSG_CHANNEL_OPEN_FAILURE: 'channel-open-failure',\n    MSG_CHANNEL_WINDOW_ADJUST: 'channel-window-adjust',\n    MSG_CHANNEL_DATA: 'channel-data',\n    MSG_CHANNEL_EXTENDED_DATA: 'channel-extended-data',\n    MSG_CHANNEL_EOF: 'channel-eof',\n    MSG_CHANNEL_CLOSE: 'channel-close',\n    MSG_CHANNEL_REQUEST: 'channel-request',\n    MSG_CHANNEL_SUCCESS: 'channel-success',\n    MSG_CHANNEL_FAILURE: 'channel-failure',\n    MSG_USERAUTH_GSSAPI_RESPONSE: 'userauth-gssapi-response',\n    MSG_USERAUTH_GSSAPI_TOKEN: 'userauth-gssapi-token',\n    MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE: 'userauth-gssapi-exchange-complete',\n    MSG_USERAUTH_GSSAPI_ERROR: 'userauth-gssapi-error',\n    MSG_USERAUTH_GSSAPI_ERRTOK: 'userauth-gssapi-error-token',\n    MSG_USERAUTH_GSSAPI_MIC: 'userauth-gssapi-mic'\n}\n\n\n# authentication request return codes:\nAUTH_SUCCESSFUL, AUTH_PARTIALLY_SUCCESSFUL, AUTH_FAILED = range(3)\n\n\n# channel request failed reasons:\n(OPEN_SUCCEEDED,\n OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED,\n OPEN_FAILED_CONNECT_FAILED,\n OPEN_FAILED_UNKNOWN_CHANNEL_TYPE,\n OPEN_FAILED_RESOURCE_SHORTAGE) = range(0, 5)\n\n\nCONNECTION_FAILED_CODE = {\n    1: 'Administratively prohibited',\n    2: 'Connect failed',\n    3: 'Unknown channel type',\n    4: 'Resource shortage'\n}\n\n\nDISCONNECT_SERVICE_NOT_AVAILABLE, DISCONNECT_AUTH_CANCELLED_BY_USER, \\\n    DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE = 7, 13, 14\n\nzero_byte = byte_chr(0)\none_byte = byte_chr(1)\nfour_byte = byte_chr(4)\nmax_byte = byte_chr(0xff)\ncr_byte = byte_chr(13)\nlinefeed_byte = byte_chr(10)\ncrlf = cr_byte + linefeed_byte\n\nif PY2:\n    cr_byte_value = cr_byte\n    linefeed_byte_value = linefeed_byte\nelse:\n    cr_byte_value = 13\n    linefeed_byte_value = 10\n\n\ndef asbytes(s):\n    \"\"\"Coerce to bytes if possible or return unchanged.\"\"\"\n    if isinstance(s, bytes_types):\n        return s\n    if isinstance(s, text_type):\n        # Accept text and encode as utf-8 for compatibility only.\n        return s.encode(\"utf-8\")\n    asbytes = getattr(s, \"asbytes\", None)\n    if asbytes is not None:\n        return asbytes()\n    # May be an object that implements the buffer api, let callers handle.\n    return s\n\n\nxffffffff = long(0xffffffff)\nx80000000 = long(0x80000000)\no666 = 438\no660 = 432\no644 = 420\no600 = 384\no777 = 511\no700 = 448\no70 = 56\n\nDEBUG = logging.DEBUG\nINFO = logging.INFO\nWARNING = logging.WARNING\nERROR = logging.ERROR\nCRITICAL = logging.CRITICAL\n\n# Common IO/select/etc sleep period, in seconds\nio_sleep = 0.01\n\nDEFAULT_WINDOW_SIZE = 64 * 2 ** 15\nDEFAULT_MAX_PACKET_SIZE = 2 ** 15\n\n# lower bound on the max packet size we'll accept from the remote host\n# Minimum packet size is 32768 bytes according to\n# http://www.ietf.org/rfc/rfc4254.txt\nMIN_WINDOW_SIZE = 2 ** 15\n\n# However, according to http://www.ietf.org/rfc/rfc4253.txt it is perfectly\n# legal to accept a size much smaller, as OpenSSH client does as size 16384.\nMIN_PACKET_SIZE = 2 ** 12\n\n# Max windows size according to http://www.ietf.org/rfc/rfc4254.txt\nMAX_WINDOW_SIZE = 2 ** 32 - 1\n", "# Copyright (C) 2003-2007  Robey Pointer <robeypointer@gmail.com>\n#\n# This file is part of paramiko.\n#\n# Paramiko is free software; you can redistribute it and/or modify it under the\n# terms of the GNU Lesser General Public License as published by the Free\n# Software Foundation; either version 2.1 of the License, or (at your option)\n# any later version.\n#\n# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY\n# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with Paramiko; if not, write to the Free Software Foundation, Inc.,\n# 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n\n\"\"\"\nCore protocol implementation\n\"\"\"\n\nfrom __future__ import print_function\nimport os\nimport socket\nimport sys\nimport threading\nimport time\nimport weakref\nfrom hashlib import md5, sha1, sha256, sha512\n\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.ciphers import algorithms, Cipher, modes\n\nimport paramiko\nfrom paramiko import util\nfrom paramiko.auth_handler import AuthHandler\nfrom paramiko.ssh_gss import GSSAuth\nfrom paramiko.channel import Channel\nfrom paramiko.common import (\n    xffffffff, cMSG_CHANNEL_OPEN, cMSG_IGNORE, cMSG_GLOBAL_REQUEST, DEBUG,\n    MSG_KEXINIT, MSG_IGNORE, MSG_DISCONNECT, MSG_DEBUG, ERROR, WARNING,\n    cMSG_UNIMPLEMENTED, INFO, cMSG_KEXINIT, cMSG_NEWKEYS, MSG_NEWKEYS,\n    cMSG_REQUEST_SUCCESS, cMSG_REQUEST_FAILURE, CONNECTION_FAILED_CODE,\n    OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED, OPEN_SUCCEEDED,\n    cMSG_CHANNEL_OPEN_FAILURE, cMSG_CHANNEL_OPEN_SUCCESS, MSG_GLOBAL_REQUEST,\n    MSG_REQUEST_SUCCESS, MSG_REQUEST_FAILURE, MSG_CHANNEL_OPEN_SUCCESS,\n    MSG_CHANNEL_OPEN_FAILURE, MSG_CHANNEL_OPEN, MSG_CHANNEL_SUCCESS,\n    MSG_CHANNEL_FAILURE, MSG_CHANNEL_DATA, MSG_CHANNEL_EXTENDED_DATA,\n    MSG_CHANNEL_WINDOW_ADJUST, MSG_CHANNEL_REQUEST, MSG_CHANNEL_EOF,\n    MSG_CHANNEL_CLOSE, MIN_WINDOW_SIZE, MIN_PACKET_SIZE, MAX_WINDOW_SIZE,\n    DEFAULT_WINDOW_SIZE, DEFAULT_MAX_PACKET_SIZE, HIGHEST_USERAUTH_MESSAGE_ID,\n)\nfrom paramiko.compress import ZlibCompressor, ZlibDecompressor\nfrom paramiko.dsskey import DSSKey\nfrom paramiko.kex_gex import KexGex, KexGexSHA256\nfrom paramiko.kex_group1 import KexGroup1\nfrom paramiko.kex_group14 import KexGroup14\nfrom paramiko.kex_gss import KexGSSGex, KexGSSGroup1, KexGSSGroup14\nfrom paramiko.message import Message\nfrom paramiko.packet import Packetizer, NeedRekeyException\nfrom paramiko.primes import ModulusPack\nfrom paramiko.py3compat import string_types, long, byte_ord, b, input, PY2\nfrom paramiko.rsakey import RSAKey\nfrom paramiko.ecdsakey import ECDSAKey\nfrom paramiko.server import ServerInterface\nfrom paramiko.sftp_client import SFTPClient\nfrom paramiko.ssh_exception import (\n    SSHException, BadAuthenticationType, ChannelException, ProxyCommandFailure,\n)\nfrom paramiko.util import retry_on_signal, ClosingContextManager, clamp_value\n\n\n# for thread cleanup\n_active_threads = []\n\ndef _join_lingering_threads():\n    for thr in _active_threads:\n        thr.stop_thread()\n\n\nimport atexit\natexit.register(_join_lingering_threads)\n\n\nclass Transport(threading.Thread, ClosingContextManager):\n    \"\"\"\n    An SSH Transport attaches to a stream (usually a socket), negotiates an\n    encrypted session, authenticates, and then creates stream tunnels, called\n    `channels <.Channel>`, across the session.  Multiple channels can be\n    multiplexed across a single session (and often are, in the case of port\n    forwardings).\n\n    Instances of this class may be used as context managers.\n    \"\"\"\n    _ENCRYPT = object()\n    _DECRYPT = object()\n\n    _PROTO_ID = '2.0'\n    _CLIENT_ID = 'paramiko_%s' % paramiko.__version__\n\n    # These tuples of algorithm identifiers are in preference order; do not\n    # reorder without reason!\n    _preferred_ciphers = (\n        'aes128-ctr',\n        'aes192-ctr',\n        'aes256-ctr',\n        'aes128-cbc',\n        'aes192-cbc',\n        'aes256-cbc',\n        'blowfish-cbc',\n        '3des-cbc',\n    )\n    _preferred_macs = (\n        'hmac-sha2-256',\n        'hmac-sha2-512',\n        'hmac-sha1',\n        'hmac-md5',\n        'hmac-sha1-96',\n        'hmac-md5-96',\n    )\n    _preferred_keys = (\n        'ecdsa-sha2-nistp256',\n        'ecdsa-sha2-nistp384',\n        'ecdsa-sha2-nistp521',\n        'ssh-rsa',\n        'ssh-dss',\n    )\n    _preferred_kex = (\n        'diffie-hellman-group1-sha1',\n        'diffie-hellman-group14-sha1',\n        'diffie-hellman-group-exchange-sha1',\n        'diffie-hellman-group-exchange-sha256',\n    )\n    _preferred_gsskex = (\n        'gss-gex-sha1-toWM5Slw5Ew8Mqkay+al2g==',\n        'gss-group14-sha1-toWM5Slw5Ew8Mqkay+al2g==',\n        'gss-group1-sha1-toWM5Slw5Ew8Mqkay+al2g==',\n    )\n    _preferred_compression = ('none',)\n\n    _cipher_info = {\n        'aes128-ctr': {\n            'class': algorithms.AES,\n            'mode': modes.CTR,\n            'block-size': 16,\n            'key-size': 16\n        },\n        'aes192-ctr': {\n            'class': algorithms.AES,\n            'mode': modes.CTR,\n            'block-size': 16,\n            'key-size': 24\n        },\n        'aes256-ctr': {\n            'class': algorithms.AES,\n            'mode': modes.CTR,\n            'block-size': 16,\n            'key-size': 32\n        },\n        'blowfish-cbc': {\n            'class': algorithms.Blowfish,\n            'mode': modes.CBC,\n            'block-size': 8,\n            'key-size': 16\n        },\n        'aes128-cbc': {\n            'class': algorithms.AES,\n            'mode': modes.CBC,\n            'block-size': 16,\n            'key-size': 16\n        },\n        'aes192-cbc': {\n            'class': algorithms.AES,\n            'mode': modes.CBC,\n            'block-size': 16,\n            'key-size': 24\n        },\n        'aes256-cbc': {\n            'class': algorithms.AES,\n            'mode': modes.CBC,\n            'block-size': 16,\n            'key-size': 32\n        },\n        '3des-cbc': {\n            'class': algorithms.TripleDES,\n            'mode': modes.CBC,\n            'block-size': 8,\n            'key-size': 24\n        },\n    }\n\n\n    _mac_info = {\n        'hmac-sha1': {'class': sha1, 'size': 20},\n        'hmac-sha1-96': {'class': sha1, 'size': 12},\n        'hmac-sha2-256': {'class': sha256, 'size': 32},\n        'hmac-sha2-512': {'class': sha512, 'size': 64},\n        'hmac-md5': {'class': md5, 'size': 16},\n        'hmac-md5-96': {'class': md5, 'size': 12},\n    }\n\n    _key_info = {\n        'ssh-rsa': RSAKey,\n        'ssh-dss': DSSKey,\n        'ecdsa-sha2-nistp256': ECDSAKey,\n        'ecdsa-sha2-nistp384': ECDSAKey,\n        'ecdsa-sha2-nistp521': ECDSAKey,\n    }\n\n    _kex_info = {\n        'diffie-hellman-group1-sha1': KexGroup1,\n        'diffie-hellman-group14-sha1': KexGroup14,\n        'diffie-hellman-group-exchange-sha1': KexGex,\n        'diffie-hellman-group-exchange-sha256': KexGexSHA256,\n        'gss-group1-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup1,\n        'gss-group14-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup14,\n        'gss-gex-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGex\n    }\n\n    _compression_info = {\n        # zlib@openssh.com is just zlib, but only turned on after a successful\n        # authentication.  openssh servers may only offer this type because\n        # they've had troubles with security holes in zlib in the past.\n        'zlib@openssh.com': (ZlibCompressor, ZlibDecompressor),\n        'zlib': (ZlibCompressor, ZlibDecompressor),\n        'none': (None, None),\n    }\n\n    _modulus_pack = None\n    _active_check_timeout = 0.1\n\n    def __init__(self,\n                 sock,\n                 default_window_size=DEFAULT_WINDOW_SIZE,\n                 default_max_packet_size=DEFAULT_MAX_PACKET_SIZE,\n                 gss_kex=False,\n                 gss_deleg_creds=True):\n        \"\"\"\n        Create a new SSH session over an existing socket, or socket-like\n        object.  This only creates the `.Transport` object; it doesn't begin\n        the SSH session yet.  Use `connect` or `start_client` to begin a client\n        session, or `start_server` to begin a server session.\n\n        If the object is not actually a socket, it must have the following\n        methods:\n\n        - ``send(str)``: Writes from 1 to ``len(str)`` bytes, and returns an\n          int representing the number of bytes written.  Returns\n          0 or raises ``EOFError`` if the stream has been closed.\n        - ``recv(int)``: Reads from 1 to ``int`` bytes and returns them as a\n          string.  Returns 0 or raises ``EOFError`` if the stream has been\n          closed.\n        - ``close()``: Closes the socket.\n        - ``settimeout(n)``: Sets a (float) timeout on I/O operations.\n\n        For ease of use, you may also pass in an address (as a tuple) or a host\n        string as the ``sock`` argument.  (A host string is a hostname with an\n        optional port (separated by ``\":\"``) which will be converted into a\n        tuple of ``(hostname, port)``.)  A socket will be connected to this\n        address and used for communication.  Exceptions from the ``socket``\n        call may be thrown in this case.\n\n        .. note::\n            Modifying the the window and packet sizes might have adverse\n            effects on your channels created from this transport. The default\n            values are the same as in the OpenSSH code base and have been\n            battle tested.\n\n        :param socket sock:\n            a socket or socket-like object to create the session over.\n        :param int default_window_size:\n            sets the default window size on the transport. (defaults to\n            2097152)\n        :param int default_max_packet_size:\n            sets the default max packet size on the transport. (defaults to\n            32768)\n\n        .. versionchanged:: 1.15\n            Added the ``default_window_size`` and ``default_max_packet_size``\n            arguments.\n        \"\"\"\n        self.active = False\n\n        if isinstance(sock, string_types):\n            # convert \"host:port\" into (host, port)\n            hl = sock.split(':', 1)\n            if len(hl) == 1:\n                sock = (hl[0], 22)\n            else:\n                sock = (hl[0], int(hl[1]))\n        if type(sock) is tuple:\n            # connect to the given (host, port)\n            hostname, port = sock\n            reason = 'No suitable address family'\n            addrinfos = socket.getaddrinfo(\n                hostname, port, socket.AF_UNSPEC, socket.SOCK_STREAM\n            )\n            for family, socktype, proto, canonname, sockaddr in addrinfos:\n                if socktype == socket.SOCK_STREAM:\n                    af = family\n                    # addr = sockaddr\n                    sock = socket.socket(af, socket.SOCK_STREAM)\n                    try:\n                        retry_on_signal(lambda: sock.connect((hostname, port)))\n                    except socket.error as e:\n                        reason = str(e)\n                    else:\n                        break\n            else:\n                raise SSHException(\n                    'Unable to connect to %s: %s' % (hostname, reason))\n        # okay, normal socket-ish flow here...\n        threading.Thread.__init__(self)\n        self.setDaemon(True)\n        self.sock = sock\n        # we set the timeout so we can check self.active periodically to\n        # see if we should bail. socket.timeout exception is never propagated.\n        self.sock.settimeout(self._active_check_timeout)\n\n        # negotiated crypto parameters\n        self.packetizer = Packetizer(sock)\n        self.local_version = 'SSH-' + self._PROTO_ID + '-' + self._CLIENT_ID\n        self.remote_version = ''\n        self.local_cipher = self.remote_cipher = ''\n        self.local_kex_init = self.remote_kex_init = None\n        self.local_mac = self.remote_mac = None\n        self.local_compression = self.remote_compression = None\n        self.session_id = None\n        self.host_key_type = None\n        self.host_key = None\n\n        # GSS-API / SSPI Key Exchange\n        self.use_gss_kex = gss_kex\n        # This will be set to True if GSS-API Key Exchange was performed\n        self.gss_kex_used = False\n        self.kexgss_ctxt = None\n        self.gss_host = None\n        if self.use_gss_kex:\n            self.kexgss_ctxt = GSSAuth(\"gssapi-keyex\", gss_deleg_creds)\n            self._preferred_kex = self._preferred_gsskex + self._preferred_kex\n\n        # state used during negotiation\n        self.kex_engine = None\n        self.H = None\n        self.K = None\n\n        self.initial_kex_done = False\n        self.in_kex = False\n        self.authenticated = False\n        self._expected_packet = tuple()\n        # synchronization (always higher level than write_lock)\n        self.lock = threading.Lock()\n\n        # tracking open channels\n        self._channels = ChannelMap()\n        self.channel_events = {}       # (id -> Event)\n        self.channels_seen = {}        # (id -> True)\n        self._channel_counter = 0\n        self.default_max_packet_size = default_max_packet_size\n        self.default_window_size = default_window_size\n        self._forward_agent_handler = None\n        self._x11_handler = None\n        self._tcp_handler = None\n\n        self.saved_exception = None\n        self.clear_to_send = threading.Event()\n        self.clear_to_send_lock = threading.Lock()\n        self.clear_to_send_timeout = 30.0\n        self.log_name = 'paramiko.transport'\n        self.logger = util.get_logger(self.log_name)\n        self.packetizer.set_log(self.logger)\n        self.auth_handler = None\n        # response Message from an arbitrary global request\n        self.global_response = None\n        # user-defined event callbacks\n        self.completion_event = None\n        # how long (seconds) to wait for the SSH banner\n        self.banner_timeout = 15\n        # how long (seconds) to wait for the handshake to finish after SSH\n        # banner sent.\n        self.handshake_timeout = 15\n\n        # server mode:\n        self.server_mode = False\n        self.server_object = None\n        self.server_key_dict = {}\n        self.server_accepts = []\n        self.server_accept_cv = threading.Condition(self.lock)\n        self.subsystem_table = {}\n\n    def __repr__(self):\n        \"\"\"\n        Returns a string representation of this object, for debugging.\n        \"\"\"\n        out = '<paramiko.Transport at %s' % hex(long(id(self)) & xffffffff)\n        if not self.active:\n            out += ' (unconnected)'\n        else:\n            if self.local_cipher != '':\n                out += ' (cipher %s, %d bits)' % (\n                    self.local_cipher,\n                    self._cipher_info[self.local_cipher]['key-size'] * 8\n                )\n            if self.is_authenticated():\n                out += ' (active; %d open channel(s))' % len(self._channels)\n            elif self.initial_kex_done:\n                out += ' (connected; awaiting auth)'\n            else:\n                out += ' (connecting)'\n        out += '>'\n        return out\n\n    def atfork(self):\n        \"\"\"\n        Terminate this Transport without closing the session.  On posix\n        systems, if a Transport is open during process forking, both parent\n        and child will share the underlying socket, but only one process can\n        use the connection (without corrupting the session).  Use this method\n        to clean up a Transport object without disrupting the other process.\n\n        .. versionadded:: 1.5.3\n        \"\"\"\n        self.sock.close()\n        self.close()\n\n    def get_security_options(self):\n        \"\"\"\n        Return a `.SecurityOptions` object which can be used to tweak the\n        encryption algorithms this transport will permit (for encryption,\n        digest/hash operations, public keys, and key exchanges) and the order\n        of preference for them.\n        \"\"\"\n        return SecurityOptions(self)\n\n    def set_gss_host(self, gss_host):\n        \"\"\"\n        Setter for C{gss_host} if GSS-API Key Exchange is performed.\n\n        :param str gss_host: The targets name in the kerberos database\n                             Default: The name of the host to connect to\n        \"\"\"\n        # We need the FQDN to get this working with SSPI\n        self.gss_host = socket.getfqdn(gss_host)\n\n    def start_client(self, event=None):\n        \"\"\"\n        Negotiate a new SSH2 session as a client.  This is the first step after\n        creating a new `.Transport`.  A separate thread is created for protocol\n        negotiation.\n\n        If an event is passed in, this method returns immediately.  When\n        negotiation is done (successful or not), the given ``Event`` will\n        be triggered.  On failure, `is_active` will return ``False``.\n\n        (Since 1.4) If ``event`` is ``None``, this method will not return until\n        negotation is done.  On success, the method returns normally.\n        Otherwise an SSHException is raised.\n\n        After a successful negotiation, you will usually want to authenticate,\n        calling `auth_password <Transport.auth_password>` or\n        `auth_publickey <Transport.auth_publickey>`.\n\n        .. note:: `connect` is a simpler method for connecting as a client.\n\n        .. note::\n            After calling this method (or `start_server` or `connect`), you\n            should no longer directly read from or write to the original socket\n            object.\n\n        :param .threading.Event event:\n            an event to trigger when negotiation is complete (optional)\n\n        :raises:\n            `.SSHException` -- if negotiation fails (and no ``event`` was\n            passed in)\n        \"\"\"\n        self.active = True\n        if event is not None:\n            # async, return immediately and let the app poll for completion\n            self.completion_event = event\n            self.start()\n            return\n\n        # synchronous, wait for a result\n        self.completion_event = event = threading.Event()\n        self.start()\n        while True:\n            event.wait(0.1)\n            if not self.active:\n                e = self.get_exception()\n                if e is not None:\n                    raise e\n                raise SSHException('Negotiation failed.')\n            if event.is_set():\n                break\n\n    def start_server(self, event=None, server=None):\n        \"\"\"\n        Negotiate a new SSH2 session as a server.  This is the first step after\n        creating a new `.Transport` and setting up your server host key(s).  A\n        separate thread is created for protocol negotiation.\n\n        If an event is passed in, this method returns immediately.  When\n        negotiation is done (successful or not), the given ``Event`` will\n        be triggered.  On failure, `is_active` will return ``False``.\n\n        (Since 1.4) If ``event`` is ``None``, this method will not return until\n        negotiation is done.  On success, the method returns normally.\n        Otherwise an SSHException is raised.\n\n        After a successful negotiation, the client will need to authenticate.\n        Override the methods `get_allowed_auths\n        <.ServerInterface.get_allowed_auths>`, `check_auth_none\n        <.ServerInterface.check_auth_none>`, `check_auth_password\n        <.ServerInterface.check_auth_password>`, and `check_auth_publickey\n        <.ServerInterface.check_auth_publickey>` in the given ``server`` object\n        to control the authentication process.\n\n        After a successful authentication, the client should request to open a\n        channel.  Override `check_channel_request\n        <.ServerInterface.check_channel_request>` in the given ``server``\n        object to allow channels to be opened.\n\n        .. note::\n            After calling this method (or `start_client` or `connect`), you\n            should no longer directly read from or write to the original socket\n            object.\n\n        :param .threading.Event event:\n            an event to trigger when negotiation is complete.\n        :param .ServerInterface server:\n            an object used to perform authentication and create `channels\n            <.Channel>`\n\n        :raises:\n            `.SSHException` -- if negotiation fails (and no ``event`` was\n            passed in)\n        \"\"\"\n        if server is None:\n            server = ServerInterface()\n        self.server_mode = True\n        self.server_object = server\n        self.active = True\n        if event is not None:\n            # async, return immediately and let the app poll for completion\n            self.completion_event = event\n            self.start()\n            return\n\n        # synchronous, wait for a result\n        self.completion_event = event = threading.Event()\n        self.start()\n        while True:\n            event.wait(0.1)\n            if not self.active:\n                e = self.get_exception()\n                if e is not None:\n                    raise e\n                raise SSHException('Negotiation failed.')\n            if event.is_set():\n                break\n\n    def add_server_key(self, key):\n        \"\"\"\n        Add a host key to the list of keys used for server mode.  When behaving\n        as a server, the host key is used to sign certain packets during the\n        SSH2 negotiation, so that the client can trust that we are who we say\n        we are.  Because this is used for signing, the key must contain private\n        key info, not just the public half.  Only one key of each type (RSA or\n        DSS) is kept.\n\n        :param .PKey key:\n            the host key to add, usually an `.RSAKey` or `.DSSKey`.\n        \"\"\"\n        self.server_key_dict[key.get_name()] = key\n\n    def get_server_key(self):\n        \"\"\"\n        Return the active host key, in server mode.  After negotiating with the\n        client, this method will return the negotiated host key.  If only one\n        type of host key was set with `add_server_key`, that's the only key\n        that will ever be returned.  But in cases where you have set more than\n        one type of host key (for example, an RSA key and a DSS key), the key\n        type will be negotiated by the client, and this method will return the\n        key of the type agreed on.  If the host key has not been negotiated\n        yet, ``None`` is returned.  In client mode, the behavior is undefined.\n\n        :return:\n            host key (`.PKey`) of the type negotiated by the client, or\n            ``None``.\n        \"\"\"\n        try:\n            return self.server_key_dict[self.host_key_type]\n        except KeyError:\n            pass\n        return None\n\n    @staticmethod\n    def load_server_moduli(filename=None):\n        \"\"\"\n        (optional)\n        Load a file of prime moduli for use in doing group-exchange key\n        negotiation in server mode.  It's a rather obscure option and can be\n        safely ignored.\n\n        In server mode, the remote client may request \"group-exchange\" key\n        negotiation, which asks the server to send a random prime number that\n        fits certain criteria.  These primes are pretty difficult to compute,\n        so they can't be generated on demand.  But many systems contain a file\n        of suitable primes (usually named something like ``/etc/ssh/moduli``).\n        If you call `load_server_moduli` and it returns ``True``, then this\n        file of primes has been loaded and we will support \"group-exchange\" in\n        server mode.  Otherwise server mode will just claim that it doesn't\n        support that method of key negotiation.\n\n        :param str filename:\n            optional path to the moduli file, if you happen to know that it's\n            not in a standard location.\n        :return:\n            True if a moduli file was successfully loaded; False otherwise.\n\n        .. note:: This has no effect when used in client mode.\n        \"\"\"\n        Transport._modulus_pack = ModulusPack()\n        # places to look for the openssh \"moduli\" file\n        file_list = ['/etc/ssh/moduli', '/usr/local/etc/moduli']\n        if filename is not None:\n            file_list.insert(0, filename)\n        for fn in file_list:\n            try:\n                Transport._modulus_pack.read_file(fn)\n                return True\n            except IOError:\n                pass\n        # none succeeded\n        Transport._modulus_pack = None\n        return False\n\n    def close(self):\n        \"\"\"\n        Close this session, and any open channels that are tied to it.\n        \"\"\"\n        if not self.active:\n            return\n        self.stop_thread()\n        for chan in list(self._channels.values()):\n            chan._unlink()\n        self.sock.close()\n\n    def get_remote_server_key(self):\n        \"\"\"\n        Return the host key of the server (in client mode).\n\n        .. note::\n            Previously this call returned a tuple of ``(key type, key\n            string)``. You can get the same effect by calling `.PKey.get_name`\n            for the key type, and ``str(key)`` for the key string.\n\n        :raises: `.SSHException` -- if no session is currently active.\n\n        :return: public key (`.PKey`) of the remote server\n        \"\"\"\n        if (not self.active) or (not self.initial_kex_done):\n            raise SSHException('No existing session')\n        return self.host_key\n\n    def is_active(self):\n        \"\"\"\n        Return true if this session is active (open).\n\n        :return:\n            True if the session is still active (open); False if the session is\n            closed\n        \"\"\"\n        return self.active\n\n    def open_session(\n        self,\n        window_size=None,\n        max_packet_size=None,\n        timeout=None,\n    ):\n        \"\"\"\n        Request a new channel to the server, of type ``\"session\"``.  This is\n        just an alias for calling `open_channel` with an argument of\n        ``\"session\"``.\n\n        .. note:: Modifying the the window and packet sizes might have adverse\n            effects on the session created. The default values are the same\n            as in the OpenSSH code base and have been battle tested.\n\n        :param int window_size:\n            optional window size for this session.\n        :param int max_packet_size:\n            optional max packet size for this session.\n\n        :return: a new `.Channel`\n\n        :raises:\n            `.SSHException` -- if the request is rejected or the session ends\n            prematurely\n\n        .. versionchanged:: 1.13.4/1.14.3/1.15.3\n            Added the ``timeout`` argument.\n        .. versionchanged:: 1.15\n            Added the ``window_size`` and ``max_packet_size`` arguments.\n        \"\"\"\n        return self.open_channel('session',\n                                 window_size=window_size,\n                                 max_packet_size=max_packet_size,\n                                 timeout=timeout)\n\n    def open_x11_channel(self, src_addr=None):\n        \"\"\"\n        Request a new channel to the client, of type ``\"x11\"``.  This\n        is just an alias for ``open_channel('x11', src_addr=src_addr)``.\n\n        :param tuple src_addr:\n            the source address (``(str, int)``) of the x11 server (port is the\n            x11 port, ie. 6010)\n        :return: a new `.Channel`\n\n        :raises:\n            `.SSHException` -- if the request is rejected or the session ends\n            prematurely\n        \"\"\"\n        return self.open_channel('x11', src_addr=src_addr)\n\n    def open_forward_agent_channel(self):\n        \"\"\"\n        Request a new channel to the client, of type\n        ``\"auth-agent@openssh.com\"``.\n\n        This is just an alias for ``open_channel('auth-agent@openssh.com')``.\n\n        :return: a new `.Channel`\n\n        :raises: `.SSHException` --\n            if the request is rejected or the session ends prematurely\n        \"\"\"\n        return self.open_channel('auth-agent@openssh.com')\n\n    def open_forwarded_tcpip_channel(self, src_addr, dest_addr):\n        \"\"\"\n        Request a new channel back to the client, of type ``forwarded-tcpip``.\n\n        This is used after a client has requested port forwarding, for sending\n        incoming connections back to the client.\n\n        :param src_addr: originator's address\n        :param dest_addr: local (server) connected address\n        \"\"\"\n        return self.open_channel('forwarded-tcpip', dest_addr, src_addr)\n\n    def open_channel(self,\n                     kind,\n                     dest_addr=None,\n                     src_addr=None,\n                     window_size=None,\n                     max_packet_size=None,\n                     timeout=None):\n        \"\"\"\n        Request a new channel to the server. `Channels <.Channel>` are\n        socket-like objects used for the actual transfer of data across the\n        session. You may only request a channel after negotiating encryption\n        (using `connect` or `start_client`) and authenticating.\n\n        .. note:: Modifying the the window and packet sizes might have adverse\n            effects on the channel created. The default values are the same\n            as in the OpenSSH code base and have been battle tested.\n\n        :param str kind:\n            the kind of channel requested (usually ``\"session\"``,\n            ``\"forwarded-tcpip\"``, ``\"direct-tcpip\"``, or ``\"x11\"``)\n        :param tuple dest_addr:\n            the destination address (address + port tuple) of this port\n            forwarding, if ``kind`` is ``\"forwarded-tcpip\"`` or\n            ``\"direct-tcpip\"`` (ignored for other channel types)\n        :param src_addr: the source address of this port forwarding, if\n            ``kind`` is ``\"forwarded-tcpip\"``, ``\"direct-tcpip\"``, or ``\"x11\"``\n        :param int window_size:\n            optional window size for this session.\n        :param int max_packet_size:\n            optional max packet size for this session.\n        :param float timeout:\n            optional timeout opening a channel, default 3600s (1h)\n\n        :return: a new `.Channel` on success\n\n        :raises:\n            `.SSHException` -- if the request is rejected, the session ends\n            prematurely or there is a timeout openning a channel\n\n        .. versionchanged:: 1.15\n            Added the ``window_size`` and ``max_packet_size`` arguments.\n        \"\"\"\n        if not self.active:\n            raise SSHException('SSH session not active')\n        timeout = 3600 if timeout is None else timeout\n        self.lock.acquire()\n        try:\n            window_size = self._sanitize_window_size(window_size)\n            max_packet_size = self._sanitize_packet_size(max_packet_size)\n            chanid = self._next_channel()\n            m = Message()\n            m.add_byte(cMSG_CHANNEL_OPEN)\n            m.add_string(kind)\n            m.add_int(chanid)\n            m.add_int(window_size)\n            m.add_int(max_packet_size)\n            if (kind == 'forwarded-tcpip') or (kind == 'direct-tcpip'):\n                m.add_string(dest_addr[0])\n                m.add_int(dest_addr[1])\n                m.add_string(src_addr[0])\n                m.add_int(src_addr[1])\n            elif kind == 'x11':\n                m.add_string(src_addr[0])\n                m.add_int(src_addr[1])\n            chan = Channel(chanid)\n            self._channels.put(chanid, chan)\n            self.channel_events[chanid] = event = threading.Event()\n            self.channels_seen[chanid] = True\n            chan._set_transport(self)\n            chan._set_window(window_size, max_packet_size)\n        finally:\n            self.lock.release()\n        self._send_user_message(m)\n        start_ts = time.time()\n        while True:\n            event.wait(0.1)\n            if not self.active:\n                e = self.get_exception()\n                if e is None:\n                    e = SSHException('Unable to open channel.')\n                raise e\n            if event.is_set():\n                break\n            elif start_ts + timeout < time.time():\n                raise SSHException('Timeout opening channel.')\n        chan = self._channels.get(chanid)\n        if chan is not None:\n            return chan\n        e = self.get_exception()\n        if e is None:\n            e = SSHException('Unable to open channel.')\n        raise e\n\n    def request_port_forward(self, address, port, handler=None):\n        \"\"\"\n        Ask the server to forward TCP connections from a listening port on\n        the server, across this SSH session.\n\n        If a handler is given, that handler is called from a different thread\n        whenever a forwarded connection arrives.  The handler parameters are::\n\n            handler(\n                channel,\n                (origin_addr, origin_port),\n                (server_addr, server_port),\n            )\n\n        where ``server_addr`` and ``server_port`` are the address and port that\n        the server was listening on.\n\n        If no handler is set, the default behavior is to send new incoming\n        forwarded connections into the accept queue, to be picked up via\n        `accept`.\n\n        :param str address: the address to bind when forwarding\n        :param int port:\n            the port to forward, or 0 to ask the server to allocate any port\n        :param callable handler:\n            optional handler for incoming forwarded connections, of the form\n            ``func(Channel, (str, int), (str, int))``.\n\n        :return: the port number (`int`) allocated by the server\n\n        :raises:\n            `.SSHException` -- if the server refused the TCP forward request\n        \"\"\"\n        if not self.active:\n            raise SSHException('SSH session not active')\n        port = int(port)\n        response = self.global_request(\n            'tcpip-forward', (address, port), wait=True\n        )\n        if response is None:\n            raise SSHException('TCP forwarding request denied')\n        if port == 0:\n            port = response.get_int()\n        if handler is None:\n            def default_handler(channel, src_addr, dest_addr_port):\n                # src_addr, src_port = src_addr_port\n                # dest_addr, dest_port = dest_addr_port\n                self._queue_incoming_channel(channel)\n            handler = default_handler\n        self._tcp_handler = handler\n        return port\n\n    def cancel_port_forward(self, address, port):\n        \"\"\"\n        Ask the server to cancel a previous port-forwarding request.  No more\n        connections to the given address & port will be forwarded across this\n        ssh connection.\n\n        :param str address: the address to stop forwarding\n        :param int port: the port to stop forwarding\n        \"\"\"\n        if not self.active:\n            return\n        self._tcp_handler = None\n        self.global_request('cancel-tcpip-forward', (address, port), wait=True)\n\n    def open_sftp_client(self):\n        \"\"\"\n        Create an SFTP client channel from an open transport.  On success, an\n        SFTP session will be opened with the remote host, and a new\n        `.SFTPClient` object will be returned.\n\n        :return:\n            a new `.SFTPClient` referring to an sftp session (channel) across\n            this transport\n        \"\"\"\n        return SFTPClient.from_transport(self)\n\n    def send_ignore(self, byte_count=None):\n        \"\"\"\n        Send a junk packet across the encrypted link.  This is sometimes used\n        to add \"noise\" to a connection to confuse would-be attackers.  It can\n        also be used as a keep-alive for long lived connections traversing\n        firewalls.\n\n        :param int byte_count:\n            the number of random bytes to send in the payload of the ignored\n            packet -- defaults to a random number from 10 to 41.\n        \"\"\"\n        m = Message()\n        m.add_byte(cMSG_IGNORE)\n        if byte_count is None:\n            byte_count = (byte_ord(os.urandom(1)) % 32) + 10\n        m.add_bytes(os.urandom(byte_count))\n        self._send_user_message(m)\n\n    def renegotiate_keys(self):\n        \"\"\"\n        Force this session to switch to new keys.  Normally this is done\n        automatically after the session hits a certain number of packets or\n        bytes sent or received, but this method gives you the option of forcing\n        new keys whenever you want.  Negotiating new keys causes a pause in\n        traffic both ways as the two sides swap keys and do computations.  This\n        method returns when the session has switched to new keys.\n\n        :raises:\n            `.SSHException` -- if the key renegotiation failed (which causes\n            the session to end)\n        \"\"\"\n        self.completion_event = threading.Event()\n        self._send_kex_init()\n        while True:\n            self.completion_event.wait(0.1)\n            if not self.active:\n                e = self.get_exception()\n                if e is not None:\n                    raise e\n                raise SSHException('Negotiation failed.')\n            if self.completion_event.is_set():\n                break\n        return\n\n    def set_keepalive(self, interval):\n        \"\"\"\n        Turn on/off keepalive packets (default is off).  If this is set, after\n        ``interval`` seconds without sending any data over the connection, a\n        \"keepalive\" packet will be sent (and ignored by the remote host).  This\n        can be useful to keep connections alive over a NAT, for example.\n\n        :param int interval:\n            seconds to wait before sending a keepalive packet (or\n            0 to disable keepalives).\n        \"\"\"\n        def _request(x=weakref.proxy(self)):\n            return x.global_request('keepalive@lag.net', wait=False)\n        self.packetizer.set_keepalive(interval, _request)\n\n    def global_request(self, kind, data=None, wait=True):\n        \"\"\"\n        Make a global request to the remote host.  These are normally\n        extensions to the SSH2 protocol.\n\n        :param str kind: name of the request.\n        :param tuple data:\n            an optional tuple containing additional data to attach to the\n            request.\n        :param bool wait:\n            ``True`` if this method should not return until a response is\n            received; ``False`` otherwise.\n        :return:\n            a `.Message` containing possible additional data if the request was\n            successful (or an empty `.Message` if ``wait`` was ``False``);\n            ``None`` if the request was denied.\n        \"\"\"\n        if wait:\n            self.completion_event = threading.Event()\n        m = Message()\n        m.add_byte(cMSG_GLOBAL_REQUEST)\n        m.add_string(kind)\n        m.add_boolean(wait)\n        if data is not None:\n            m.add(*data)\n        self._log(DEBUG, 'Sending global request \"%s\"' % kind)\n        self._send_user_message(m)\n        if not wait:\n            return None\n        while True:\n            self.completion_event.wait(0.1)\n            if not self.active:\n                return None\n            if self.completion_event.is_set():\n                break\n        return self.global_response\n\n    def accept(self, timeout=None):\n        \"\"\"\n        Return the next channel opened by the client over this transport, in\n        server mode.  If no channel is opened before the given timeout,\n        ``None`` is returned.\n\n        :param int timeout:\n            seconds to wait for a channel, or ``None`` to wait forever\n        :return: a new `.Channel` opened by the client\n        \"\"\"\n        self.lock.acquire()\n        try:\n            if len(self.server_accepts) > 0:\n                chan = self.server_accepts.pop(0)\n            else:\n                self.server_accept_cv.wait(timeout)\n                if len(self.server_accepts) > 0:\n                    chan = self.server_accepts.pop(0)\n                else:\n                    # timeout\n                    chan = None\n        finally:\n            self.lock.release()\n        return chan\n\n    def connect(\n        self,\n        hostkey=None,\n        username='',\n        password=None,\n        pkey=None,\n        gss_host=None,\n        gss_auth=False,\n        gss_kex=False,\n        gss_deleg_creds=True,\n    ):\n        \"\"\"\n        Negotiate an SSH2 session, and optionally verify the server's host key\n        and authenticate using a password or private key.  This is a shortcut\n        for `start_client`, `get_remote_server_key`, and\n        `Transport.auth_password` or `Transport.auth_publickey`.  Use those\n        methods if you want more control.\n\n        You can use this method immediately after creating a Transport to\n        negotiate encryption with a server.  If it fails, an exception will be\n        thrown.  On success, the method will return cleanly, and an encrypted\n        session exists.  You may immediately call `open_channel` or\n        `open_session` to get a `.Channel` object, which is used for data\n        transfer.\n\n        .. note::\n            If you fail to supply a password or private key, this method may\n            succeed, but a subsequent `open_channel` or `open_session` call may\n            fail because you haven't authenticated yet.\n\n        :param .PKey hostkey:\n            the host key expected from the server, or ``None`` if you don't\n            want to do host key verification.\n        :param str username: the username to authenticate as.\n        :param str password:\n            a password to use for authentication, if you want to use password\n            authentication; otherwise ``None``.\n        :param .PKey pkey:\n            a private key to use for authentication, if you want to use private\n            key authentication; otherwise ``None``.\n        :param str gss_host:\n            The target's name in the kerberos database. Default: hostname\n        :param bool gss_auth:\n            ``True`` if you want to use GSS-API authentication.\n        :param bool gss_kex:\n            Perform GSS-API Key Exchange and user authentication.\n        :param bool gss_deleg_creds:\n            Whether to delegate GSS-API client credentials.\n\n        :raises: `.SSHException` -- if the SSH2 negotiation fails, the host key\n            supplied by the server is incorrect, or authentication fails.\n        \"\"\"\n        if hostkey is not None:\n            self._preferred_keys = [hostkey.get_name()]\n\n        self.start_client()\n\n        # check host key if we were given one\n        # If GSS-API Key Exchange was performed, we are not required to check\n        # the host key.\n        if (hostkey is not None) and not gss_kex:\n            key = self.get_remote_server_key()\n            if (\n                key.get_name() != hostkey.get_name() or\n                key.asbytes() != hostkey.asbytes()\n            ):\n                self._log(DEBUG, 'Bad host key from server')\n                self._log(DEBUG, 'Expected: %s: %s' % (\n                    hostkey.get_name(), repr(hostkey.asbytes()))\n                )\n                self._log(DEBUG, 'Got     : %s: %s' % (\n                    key.get_name(), repr(key.asbytes()))\n                )\n                raise SSHException('Bad host key from server')\n            self._log(DEBUG, 'Host key verified (%s)' % hostkey.get_name())\n\n        if (pkey is not None) or (password is not None) or gss_auth or gss_kex:\n            if gss_auth:\n                self._log(DEBUG, 'Attempting GSS-API auth... (gssapi-with-mic)') # noqa\n                self.auth_gssapi_with_mic(username, gss_host, gss_deleg_creds)\n            elif gss_kex:\n                self._log(DEBUG, 'Attempting GSS-API auth... (gssapi-keyex)')\n                self.auth_gssapi_keyex(username)\n            elif pkey is not None:\n                self._log(DEBUG, 'Attempting public-key auth...')\n                self.auth_publickey(username, pkey)\n            else:\n                self._log(DEBUG, 'Attempting password auth...')\n                self.auth_password(username, password)\n\n        return\n\n    def get_exception(self):\n        \"\"\"\n        Return any exception that happened during the last server request.\n        This can be used to fetch more specific error information after using\n        calls like `start_client`.  The exception (if any) is cleared after\n        this call.\n\n        :return:\n            an exception, or ``None`` if there is no stored exception.\n\n        .. versionadded:: 1.1\n        \"\"\"\n        self.lock.acquire()\n        try:\n            e = self.saved_exception\n            self.saved_exception = None\n            return e\n        finally:\n            self.lock.release()\n\n    def set_subsystem_handler(self, name, handler, *larg, **kwarg):\n        \"\"\"\n        Set the handler class for a subsystem in server mode.  If a request\n        for this subsystem is made on an open ssh channel later, this handler\n        will be constructed and called -- see `.SubsystemHandler` for more\n        detailed documentation.\n\n        Any extra parameters (including keyword arguments) are saved and\n        passed to the `.SubsystemHandler` constructor later.\n\n        :param str name: name of the subsystem.\n        :param handler:\n            subclass of `.SubsystemHandler` that handles this subsystem.\n        \"\"\"\n        try:\n            self.lock.acquire()\n            self.subsystem_table[name] = (handler, larg, kwarg)\n        finally:\n            self.lock.release()\n\n    def is_authenticated(self):\n        \"\"\"\n        Return true if this session is active and authenticated.\n\n        :return:\n            True if the session is still open and has been authenticated\n            successfully; False if authentication failed and/or the session is\n            closed.\n        \"\"\"\n        return (\n            self.active and\n            self.auth_handler is not None and\n            self.auth_handler.is_authenticated()\n        )\n\n    def get_username(self):\n        \"\"\"\n        Return the username this connection is authenticated for.  If the\n        session is not authenticated (or authentication failed), this method\n        returns ``None``.\n\n        :return: username that was authenticated (a `str`), or ``None``.\n        \"\"\"\n        if not self.active or (self.auth_handler is None):\n            return None\n        return self.auth_handler.get_username()\n\n    def get_banner(self):\n        \"\"\"\n        Return the banner supplied by the server upon connect. If no banner is\n        supplied, this method returns ``None``.\n\n        :returns: server supplied banner (`str`), or ``None``.\n\n        .. versionadded:: 1.13\n        \"\"\"\n        if not self.active or (self.auth_handler is None):\n            return None\n        return self.auth_handler.banner\n\n    def auth_none(self, username):\n        \"\"\"\n        Try to authenticate to the server using no authentication at all.\n        This will almost always fail.  It may be useful for determining the\n        list of authentication types supported by the server, by catching the\n        `.BadAuthenticationType` exception raised.\n\n        :param str username: the username to authenticate as\n        :return:\n            `list` of auth types permissible for the next stage of\n            authentication (normally empty)\n\n        :raises:\n            `.BadAuthenticationType` -- if \"none\" authentication isn't allowed\n            by the server for this user\n        :raises:\n            `.SSHException` -- if the authentication failed due to a network\n            error\n\n        .. versionadded:: 1.5\n        \"\"\"\n        if (not self.active) or (not self.initial_kex_done):\n            raise SSHException('No existing session')\n        my_event = threading.Event()\n        self.auth_handler = AuthHandler(self)\n        self.auth_handler.auth_none(username, my_event)\n        return self.auth_handler.wait_for_response(my_event)\n\n    def auth_password(self, username, password, event=None, fallback=True):\n        \"\"\"\n        Authenticate to the server using a password.  The username and password\n        are sent over an encrypted link.\n\n        If an ``event`` is passed in, this method will return immediately, and\n        the event will be triggered once authentication succeeds or fails.  On\n        success, `is_authenticated` will return ``True``.  On failure, you may\n        use `get_exception` to get more detailed error information.\n\n        Since 1.1, if no event is passed, this method will block until the\n        authentication succeeds or fails.  On failure, an exception is raised.\n        Otherwise, the method simply returns.\n\n        Since 1.5, if no event is passed and ``fallback`` is ``True`` (the\n        default), if the server doesn't support plain password authentication\n        but does support so-called \"keyboard-interactive\" mode, an attempt\n        will be made to authenticate using this interactive mode.  If it fails,\n        the normal exception will be thrown as if the attempt had never been\n        made.  This is useful for some recent Gentoo and Debian distributions,\n        which turn off plain password authentication in a misguided belief\n        that interactive authentication is \"more secure\".  (It's not.)\n\n        If the server requires multi-step authentication (which is very rare),\n        this method will return a list of auth types permissible for the next\n        step.  Otherwise, in the normal case, an empty list is returned.\n\n        :param str username: the username to authenticate as\n        :param basestring password: the password to authenticate with\n        :param .threading.Event event:\n            an event to trigger when the authentication attempt is complete\n            (whether it was successful or not)\n        :param bool fallback:\n            ``True`` if an attempt at an automated \"interactive\" password auth\n            should be made if the server doesn't support normal password auth\n        :return:\n            `list` of auth types permissible for the next stage of\n            authentication (normally empty)\n\n        :raises:\n            `.BadAuthenticationType` -- if password authentication isn't\n            allowed by the server for this user (and no event was passed in)\n        :raises:\n            `.AuthenticationException` -- if the authentication failed (and no\n            event was passed in)\n        :raises: `.SSHException` -- if there was a network error\n        \"\"\"\n        if (not self.active) or (not self.initial_kex_done):\n            # we should never try to send the password unless we're on a secure\n            # link\n            raise SSHException('No existing session')\n        if event is None:\n            my_event = threading.Event()\n        else:\n            my_event = event\n        self.auth_handler = AuthHandler(self)\n        self.auth_handler.auth_password(username, password, my_event)\n        if event is not None:\n            # caller wants to wait for event themselves\n            return []\n        try:\n            return self.auth_handler.wait_for_response(my_event)\n        except BadAuthenticationType as e:\n            # if password auth isn't allowed, but keyboard-interactive *is*,\n            # try to fudge it\n            if not fallback or ('keyboard-interactive' not in e.allowed_types):\n                raise\n            try:\n                def handler(title, instructions, fields):\n                    if len(fields) > 1:\n                        raise SSHException('Fallback authentication failed.')\n                    if len(fields) == 0:\n                        # for some reason, at least on os x, a 2nd request will\n                        # be made with zero fields requested.  maybe it's just\n                        # to try to fake out automated scripting of the exact\n                        # type we're doing here.  *shrug* :)\n                        return []\n                    return [password]\n                return self.auth_interactive(username, handler)\n            except SSHException:\n                # attempt failed; just raise the original exception\n                raise e\n\n    def auth_publickey(self, username, key, event=None):\n        \"\"\"\n        Authenticate to the server using a private key.  The key is used to\n        sign data from the server, so it must include the private part.\n\n        If an ``event`` is passed in, this method will return immediately, and\n        the event will be triggered once authentication succeeds or fails.  On\n        success, `is_authenticated` will return ``True``.  On failure, you may\n        use `get_exception` to get more detailed error information.\n\n        Since 1.1, if no event is passed, this method will block until the\n        authentication succeeds or fails.  On failure, an exception is raised.\n        Otherwise, the method simply returns.\n\n        If the server requires multi-step authentication (which is very rare),\n        this method will return a list of auth types permissible for the next\n        step.  Otherwise, in the normal case, an empty list is returned.\n\n        :param str username: the username to authenticate as\n        :param .PKey key: the private key to authenticate with\n        :param .threading.Event event:\n            an event to trigger when the authentication attempt is complete\n            (whether it was successful or not)\n        :return:\n            `list` of auth types permissible for the next stage of\n            authentication (normally empty)\n\n        :raises:\n            `.BadAuthenticationType` -- if public-key authentication isn't\n            allowed by the server for this user (and no event was passed in)\n        :raises:\n            `.AuthenticationException` -- if the authentication failed (and no\n            event was passed in)\n        :raises: `.SSHException` -- if there was a network error\n        \"\"\"\n        if (not self.active) or (not self.initial_kex_done):\n            # we should never try to authenticate unless we're on a secure link\n            raise SSHException('No existing session')\n        if event is None:\n            my_event = threading.Event()\n        else:\n            my_event = event\n        self.auth_handler = AuthHandler(self)\n        self.auth_handler.auth_publickey(username, key, my_event)\n        if event is not None:\n            # caller wants to wait for event themselves\n            return []\n        return self.auth_handler.wait_for_response(my_event)\n\n    def auth_interactive(self, username, handler, submethods=''):\n        \"\"\"\n        Authenticate to the server interactively.  A handler is used to answer\n        arbitrary questions from the server.  On many servers, this is just a\n        dumb wrapper around PAM.\n\n        This method will block until the authentication succeeds or fails,\n        peroidically calling the handler asynchronously to get answers to\n        authentication questions.  The handler may be called more than once\n        if the server continues to ask questions.\n\n        The handler is expected to be a callable that will handle calls of the\n        form: ``handler(title, instructions, prompt_list)``.  The ``title`` is\n        meant to be a dialog-window title, and the ``instructions`` are user\n        instructions (both are strings).  ``prompt_list`` will be a list of\n        prompts, each prompt being a tuple of ``(str, bool)``.  The string is\n        the prompt and the boolean indicates whether the user text should be\n        echoed.\n\n        A sample call would thus be:\n        ``handler('title', 'instructions', [('Password:', False)])``.\n\n        The handler should return a list or tuple of answers to the server's\n        questions.\n\n        If the server requires multi-step authentication (which is very rare),\n        this method will return a list of auth types permissible for the next\n        step.  Otherwise, in the normal case, an empty list is returned.\n\n        :param str username: the username to authenticate as\n        :param callable handler: a handler for responding to server questions\n        :param str submethods: a string list of desired submethods (optional)\n        :return:\n            `list` of auth types permissible for the next stage of\n            authentication (normally empty).\n\n        :raises: `.BadAuthenticationType` -- if public-key authentication isn't\n            allowed by the server for this user\n        :raises: `.AuthenticationException` -- if the authentication failed\n        :raises: `.SSHException` -- if there was a network error\n\n        .. versionadded:: 1.5\n        \"\"\"\n        if (not self.active) or (not self.initial_kex_done):\n            # we should never try to authenticate unless we're on a secure link\n            raise SSHException('No existing session')\n        my_event = threading.Event()\n        self.auth_handler = AuthHandler(self)\n        self.auth_handler.auth_interactive(\n            username, handler, my_event, submethods\n        )\n        return self.auth_handler.wait_for_response(my_event)\n\n    def auth_interactive_dumb(self, username, handler=None, submethods=''):\n        \"\"\"\n        Autenticate to the server interactively but dumber.\n        Just print the prompt and / or instructions to stdout and send back\n        the response. This is good for situations where partial auth is\n        achieved by key and then the user has to enter a 2fac token.\n        \"\"\"\n\n        if not handler:\n            def handler(title, instructions, prompt_list):\n                answers = []\n                if title:\n                    print(title.strip())\n                if instructions:\n                    print(instructions.strip())\n                for prompt, show_input in prompt_list:\n                    print(prompt.strip(), end=' ')\n                    answers.append(input())\n                return answers\n        return self.auth_interactive(username, handler, submethods)\n\n    def auth_gssapi_with_mic(self, username, gss_host, gss_deleg_creds):\n        \"\"\"\n        Authenticate to the Server using GSS-API / SSPI.\n\n        :param str username: The username to authenticate as\n        :param str gss_host: The target host\n        :param bool gss_deleg_creds: Delegate credentials or not\n        :return: list of auth types permissible for the next stage of\n                 authentication (normally empty)\n        :rtype: list\n        :raises: `.BadAuthenticationType` -- if gssapi-with-mic isn't\n            allowed by the server (and no event was passed in)\n        :raises:\n            `.AuthenticationException` -- if the authentication failed (and no\n            event was passed in)\n        :raises: `.SSHException` -- if there was a network error\n        \"\"\"\n        if (not self.active) or (not self.initial_kex_done):\n            # we should never try to authenticate unless we're on a secure link\n            raise SSHException('No existing session')\n        my_event = threading.Event()\n        self.auth_handler = AuthHandler(self)\n        self.auth_handler.auth_gssapi_with_mic(\n            username, gss_host, gss_deleg_creds, my_event\n        )\n        return self.auth_handler.wait_for_response(my_event)\n\n    def auth_gssapi_keyex(self, username):\n        \"\"\"\n        Authenticate to the server with GSS-API/SSPI if GSS-API kex is in use.\n\n        :param str username: The username to authenticate as.\n        :returns:\n            a `list` of auth types permissible for the next stage of\n            authentication (normally empty)\n        :raises: `.BadAuthenticationType` --\n            if GSS-API Key Exchange was not performed (and no event was passed\n            in)\n        :raises: `.AuthenticationException` --\n            if the authentication failed (and no event was passed in)\n        :raises: `.SSHException` -- if there was a network error\n        \"\"\"\n        if (not self.active) or (not self.initial_kex_done):\n            # we should never try to authenticate unless we're on a secure link\n            raise SSHException('No existing session')\n        my_event = threading.Event()\n        self.auth_handler = AuthHandler(self)\n        self.auth_handler.auth_gssapi_keyex(username, my_event)\n        return self.auth_handler.wait_for_response(my_event)\n\n    def set_log_channel(self, name):\n        \"\"\"\n        Set the channel for this transport's logging.  The default is\n        ``\"paramiko.transport\"`` but it can be set to anything you want. (See\n        the `.logging` module for more info.)  SSH Channels will log to a\n        sub-channel of the one specified.\n\n        :param str name: new channel name for logging\n\n        .. versionadded:: 1.1\n        \"\"\"\n        self.log_name = name\n        self.logger = util.get_logger(name)\n        self.packetizer.set_log(self.logger)\n\n    def get_log_channel(self):\n        \"\"\"\n        Return the channel name used for this transport's logging.\n\n        :return: channel name as a `str`\n\n        .. versionadded:: 1.2\n        \"\"\"\n        return self.log_name\n\n    def set_hexdump(self, hexdump):\n        \"\"\"\n        Turn on/off logging a hex dump of protocol traffic at DEBUG level in\n        the logs.  Normally you would want this off (which is the default),\n        but if you are debugging something, it may be useful.\n\n        :param bool hexdump:\n            ``True`` to log protocol traffix (in hex) to the log; ``False``\n            otherwise.\n        \"\"\"\n        self.packetizer.set_hexdump(hexdump)\n\n    def get_hexdump(self):\n        \"\"\"\n        Return ``True`` if the transport is currently logging hex dumps of\n        protocol traffic.\n\n        :return: ``True`` if hex dumps are being logged, else ``False``.\n\n        .. versionadded:: 1.4\n        \"\"\"\n        return self.packetizer.get_hexdump()\n\n    def use_compression(self, compress=True):\n        \"\"\"\n        Turn on/off compression.  This will only have an affect before starting\n        the transport (ie before calling `connect`, etc).  By default,\n        compression is off since it negatively affects interactive sessions.\n\n        :param bool compress:\n            ``True`` to ask the remote client/server to compress traffic;\n            ``False`` to refuse compression\n\n        .. versionadded:: 1.5.2\n        \"\"\"\n        if compress:\n            self._preferred_compression = ('zlib@openssh.com', 'zlib', 'none')\n        else:\n            self._preferred_compression = ('none',)\n\n    def getpeername(self):\n        \"\"\"\n        Return the address of the remote side of this Transport, if possible.\n\n        This is effectively a wrapper around ``getpeername`` on the underlying\n        socket.  If the socket-like object has no ``getpeername`` method, then\n        ``(\"unknown\", 0)`` is returned.\n\n        :return:\n            the address of the remote host, if known, as a ``(str, int)``\n            tuple.\n        \"\"\"\n        gp = getattr(self.sock, 'getpeername', None)\n        if gp is None:\n            return 'unknown', 0\n        return gp()\n\n    def stop_thread(self):\n        self.active = False\n        self.packetizer.close()\n        if PY2:\n            # Original join logic; #520 doesn't appear commonly present under\n            # Python 2.\n            while self.is_alive() and self is not threading.current_thread():\n                self.join(10)\n        else:\n            # Keep trying to join() our main thread, quickly, until:\n            # * We join()ed successfully (self.is_alive() == False)\n            # * Or it looks like we've hit issue #520 (socket.recv hitting some\n            # race condition preventing it from timing out correctly), wherein\n            # our socket and packetizer are both closed (but where we'd\n            # otherwise be sitting forever on that recv()).\n            while (\n                self.is_alive() and\n                self is not threading.current_thread() and\n                not self.sock._closed and\n                not self.packetizer.closed\n            ):\n                self.join(0.1)\n\n    # internals...\n\n    def _log(self, level, msg, *args):\n        if issubclass(type(msg), list):\n            for m in msg:\n                self.logger.log(level, m)\n        else:\n            self.logger.log(level, msg, *args)\n\n    def _get_modulus_pack(self):\n        \"\"\"used by KexGex to find primes for group exchange\"\"\"\n        return self._modulus_pack\n\n    def _next_channel(self):\n        \"\"\"you are holding the lock\"\"\"\n        chanid = self._channel_counter\n        while self._channels.get(chanid) is not None:\n            self._channel_counter = (self._channel_counter + 1) & 0xffffff\n            chanid = self._channel_counter\n        self._channel_counter = (self._channel_counter + 1) & 0xffffff\n        return chanid\n\n    def _unlink_channel(self, chanid):\n        \"\"\"used by a Channel to remove itself from the active channel list\"\"\"\n        self._channels.delete(chanid)\n\n    def _send_message(self, data):\n        self.packetizer.send_message(data)\n\n    def _send_user_message(self, data):\n        \"\"\"\n        send a message, but block if we're in key negotiation.  this is used\n        for user-initiated requests.\n        \"\"\"\n        start = time.time()\n        while True:\n            self.clear_to_send.wait(0.1)\n            if not self.active:\n                self._log(DEBUG, 'Dropping user packet because connection is dead.') # noqa\n                return\n            self.clear_to_send_lock.acquire()\n            if self.clear_to_send.is_set():\n                break\n            self.clear_to_send_lock.release()\n            if time.time() > start + self.clear_to_send_timeout:\n                raise SSHException('Key-exchange timed out waiting for key negotiation') # noqa\n        try:\n            self._send_message(data)\n        finally:\n            self.clear_to_send_lock.release()\n\n    def _set_K_H(self, k, h):\n        \"\"\"\n        Used by a kex obj to set the K (root key) and H (exchange hash).\n        \"\"\"\n        self.K = k\n        self.H = h\n        if self.session_id is None:\n            self.session_id = h\n\n    def _expect_packet(self, *ptypes):\n        \"\"\"\n        Used by a kex obj to register the next packet type it expects to see.\n        \"\"\"\n        self._expected_packet = tuple(ptypes)\n\n    def _verify_key(self, host_key, sig):\n        key = self._key_info[self.host_key_type](Message(host_key))\n        if key is None:\n            raise SSHException('Unknown host key type')\n        if not key.verify_ssh_sig(self.H, Message(sig)):\n            raise SSHException('Signature verification (%s) failed.' % self.host_key_type) # noqa\n        self.host_key = key\n\n    def _compute_key(self, id, nbytes):\n        \"\"\"id is 'A' - 'F' for the various keys used by ssh\"\"\"\n        m = Message()\n        m.add_mpint(self.K)\n        m.add_bytes(self.H)\n        m.add_byte(b(id))\n        m.add_bytes(self.session_id)\n        # Fallback to SHA1 for kex engines that fail to specify a hex\n        # algorithm, or for e.g. transport tests that don't run kexinit.\n        hash_algo = getattr(self.kex_engine, 'hash_algo', None)\n        hash_select_msg = \"kex engine %s specified hash_algo %r\" % (\n            self.kex_engine.__class__.__name__, hash_algo\n        )\n        if hash_algo is None:\n            hash_algo = sha1\n            hash_select_msg += \", falling back to sha1\"\n        if not hasattr(self, '_logged_hash_selection'):\n            self._log(DEBUG, hash_select_msg)\n            setattr(self, '_logged_hash_selection', True)\n        out = sofar = hash_algo(m.asbytes()).digest()\n        while len(out) < nbytes:\n            m = Message()\n            m.add_mpint(self.K)\n            m.add_bytes(self.H)\n            m.add_bytes(sofar)\n            digest = hash_algo(m.asbytes()).digest()\n            out += digest\n            sofar += digest\n        return out[:nbytes]\n\n    def _get_cipher(self, name, key, iv, operation):\n        if name not in self._cipher_info:\n            raise SSHException('Unknown client cipher ' + name)\n        else:\n            cipher = Cipher(\n                self._cipher_info[name]['class'](key),\n                self._cipher_info[name]['mode'](iv),\n                backend=default_backend(),\n            )\n            if operation is self._ENCRYPT:\n                return cipher.encryptor()\n            else:\n                return cipher.decryptor()\n\n    def _set_forward_agent_handler(self, handler):\n        if handler is None:\n            def default_handler(channel):\n                self._queue_incoming_channel(channel)\n            self._forward_agent_handler = default_handler\n        else:\n            self._forward_agent_handler = handler\n\n    def _set_x11_handler(self, handler):\n        # only called if a channel has turned on x11 forwarding\n        if handler is None:\n            # by default, use the same mechanism as accept()\n            def default_handler(channel, src_addr_port):\n                self._queue_incoming_channel(channel)\n            self._x11_handler = default_handler\n        else:\n            self._x11_handler = handler\n\n    def _queue_incoming_channel(self, channel):\n        self.lock.acquire()\n        try:\n            self.server_accepts.append(channel)\n            self.server_accept_cv.notify()\n        finally:\n            self.lock.release()\n\n    def _sanitize_window_size(self, window_size):\n        if window_size is None:\n            window_size = self.default_window_size\n        return clamp_value(MIN_WINDOW_SIZE, window_size, MAX_WINDOW_SIZE)\n\n    def _sanitize_packet_size(self, max_packet_size):\n        if max_packet_size is None:\n            max_packet_size = self.default_max_packet_size\n        return clamp_value(MIN_PACKET_SIZE, max_packet_size, MAX_WINDOW_SIZE)\n\n    def _ensure_authed(self, ptype, message):\n        \"\"\"\n        Checks message type against current auth state.\n\n        If server mode, and auth has not succeeded, and the message is of a\n        post-auth type (channel open or global request) an appropriate error\n        response Message is crafted and returned to caller for sending.\n\n        Otherwise (client mode, authed, or pre-auth message) returns None.\n        \"\"\"\n        if (\n            not self.server_mode\n            or ptype <= HIGHEST_USERAUTH_MESSAGE_ID\n            or self.is_authenticated()\n        ):\n            return None\n        # WELP. We must be dealing with someone trying to do non-auth things\n        # without being authed. Tell them off, based on message class.\n        reply = Message()\n        # Global requests have no details, just failure.\n        if ptype == MSG_GLOBAL_REQUEST:\n            reply.add_byte(cMSG_REQUEST_FAILURE)\n        # Channel opens let us reject w/ a specific type + message.\n        elif ptype == MSG_CHANNEL_OPEN:\n            kind = message.get_text()\n            chanid = message.get_int()\n            reply.add_byte(cMSG_CHANNEL_OPEN_FAILURE)\n            reply.add_int(chanid)\n            reply.add_int(OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED)\n            reply.add_string('')\n            reply.add_string('en')\n        # NOTE: Post-open channel messages do not need checking; the above will\n        # reject attemps to open channels, meaning that even if a malicious\n        # user tries to send a MSG_CHANNEL_REQUEST, it will simply fall under\n        # the logic that handles unknown channel IDs (as the channel list will\n        # be empty.)\n        return reply\n\n    def run(self):\n        # (use the exposed \"run\" method, because if we specify a thread target\n        # of a private method, threading.Thread will keep a reference to it\n        # indefinitely, creating a GC cycle and not letting Transport ever be\n        # GC'd. it's a bug in Thread.)\n\n        # Hold reference to 'sys' so we can test sys.modules to detect\n        # interpreter shutdown.\n        self.sys = sys\n\n        # active=True occurs before the thread is launched, to avoid a race\n        _active_threads.append(self)\n        tid = hex(long(id(self)) & xffffffff)\n        if self.server_mode:\n            self._log(DEBUG, 'starting thread (server mode): %s' % tid)\n        else:\n            self._log(DEBUG, 'starting thread (client mode): %s' % tid)\n        try:\n            try:\n                self.packetizer.write_all(b(self.local_version + '\\r\\n'))\n                self._log(DEBUG, 'Local version/idstring: %s' % self.local_version) # noqa\n                self._check_banner()\n                # The above is actually very much part of the handshake, but\n                # sometimes the banner can be read but the machine is not\n                # responding, for example when the remote ssh daemon is loaded\n                # in to memory but we can not read from the disk/spawn a new\n                # shell.\n                # Make sure we can specify a timeout for the initial handshake.\n                # Re-use the banner timeout for now.\n                self.packetizer.start_handshake(self.handshake_timeout)\n                self._send_kex_init()\n                self._expect_packet(MSG_KEXINIT)\n\n                while self.active:\n                    if self.packetizer.need_rekey() and not self.in_kex:\n                        self._send_kex_init()\n                    try:\n                        ptype, m = self.packetizer.read_message()\n                    except NeedRekeyException:\n                        continue\n                    if ptype == MSG_IGNORE:\n                        continue\n                    elif ptype == MSG_DISCONNECT:\n                        self._parse_disconnect(m)\n                        self.active = False\n                        self.packetizer.close()\n                        break\n                    elif ptype == MSG_DEBUG:\n                        self._parse_debug(m)\n                        continue\n                    if len(self._expected_packet) > 0:\n                        if ptype not in self._expected_packet:\n                            raise SSHException('Expecting packet from %r, got %d' % (self._expected_packet, ptype)) # noqa\n                        self._expected_packet = tuple()\n                        if (ptype >= 30) and (ptype <= 41):\n                            self.kex_engine.parse_next(ptype, m)\n                            continue\n\n                    if ptype in self._handler_table:\n                        error_msg = self._ensure_authed(ptype, m)\n                        if error_msg:\n                            self._send_message(error_msg)\n                        else:\n                            self._handler_table[ptype](self, m)\n                    elif ptype in self._channel_handler_table:\n                        chanid = m.get_int()\n                        chan = self._channels.get(chanid)\n                        if chan is not None:\n                            self._channel_handler_table[ptype](chan, m)\n                        elif chanid in self.channels_seen:\n                            self._log(DEBUG, 'Ignoring message for dead channel %d' % chanid) # noqa\n                        else:\n                            self._log(ERROR, 'Channel request for unknown channel %d' % chanid) # noqa\n                            self.active = False\n                            self.packetizer.close()\n                    elif (\n                        self.auth_handler is not None and\n                        ptype in self.auth_handler._handler_table\n                    ):\n                        handler = self.auth_handler._handler_table[ptype]\n                        handler(self.auth_handler, m)\n                        if len(self._expected_packet) > 0:\n                            continue\n                    else:\n                        self._log(WARNING, 'Oops, unhandled type %d' % ptype)\n                        msg = Message()\n                        msg.add_byte(cMSG_UNIMPLEMENTED)\n                        msg.add_int(m.seqno)\n                        self._send_message(msg)\n                    self.packetizer.complete_handshake()\n            except SSHException as e:\n                self._log(ERROR, 'Exception: ' + str(e))\n                self._log(ERROR, util.tb_strings())\n                self.saved_exception = e\n            except EOFError as e:\n                self._log(DEBUG, 'EOF in transport thread')\n                self.saved_exception = e\n            except socket.error as e:\n                if type(e.args) is tuple:\n                    if e.args:\n                        emsg = '%s (%d)' % (e.args[1], e.args[0])\n                    else:  # empty tuple, e.g. socket.timeout\n                        emsg = str(e) or repr(e)\n                else:\n                    emsg = e.args\n                self._log(ERROR, 'Socket exception: ' + emsg)\n                self.saved_exception = e\n            except Exception as e:\n                self._log(ERROR, 'Unknown exception: ' + str(e))\n                self._log(ERROR, util.tb_strings())\n                self.saved_exception = e\n            _active_threads.remove(self)\n            for chan in list(self._channels.values()):\n                chan._unlink()\n            if self.active:\n                self.active = False\n                self.packetizer.close()\n                if self.completion_event is not None:\n                    self.completion_event.set()\n                if self.auth_handler is not None:\n                    self.auth_handler.abort()\n                for event in self.channel_events.values():\n                    event.set()\n                try:\n                    self.lock.acquire()\n                    self.server_accept_cv.notify()\n                finally:\n                    self.lock.release()\n            self.sock.close()\n        except:\n            # Don't raise spurious 'NoneType has no attribute X' errors when we\n            # wake up during interpreter shutdown. Or rather -- raise\n            # everything *if* sys.modules (used as a convenient sentinel)\n            # appears to still exist.\n            if self.sys.modules is not None:\n                raise\n\n\n    def _log_agreement(self, which, local, remote):\n        # Log useful, non-duplicative line re: an agreed-upon algorithm.\n        # Old code implied algorithms could be asymmetrical (different for\n        # inbound vs outbound) so we preserve that possibility.\n        msg = \"{0} agreed: \".format(which)\n        if local == remote:\n            msg += local\n        else:\n            msg += \"local={0}, remote={1}\".format(local, remote)\n        self._log(DEBUG, msg)\n\n    # protocol stages\n\n    def _negotiate_keys(self, m):\n        # throws SSHException on anything unusual\n        self.clear_to_send_lock.acquire()\n        try:\n            self.clear_to_send.clear()\n        finally:\n            self.clear_to_send_lock.release()\n        if self.local_kex_init is None:\n            # remote side wants to renegotiate\n            self._send_kex_init()\n        self._parse_kex_init(m)\n        self.kex_engine.start_kex()\n\n    def _check_banner(self):\n        # this is slow, but we only have to do it once\n        for i in range(100):\n            # give them 15 seconds for the first line, then just 2 seconds\n            # each additional line.  (some sites have very high latency.)\n            if i == 0:\n                timeout = self.banner_timeout\n            else:\n                timeout = 2\n            try:\n                buf = self.packetizer.readline(timeout)\n            except ProxyCommandFailure:\n                raise\n            except Exception as e:\n                raise SSHException(\n                    'Error reading SSH protocol banner' + str(e)\n                )\n            if buf[:4] == 'SSH-':\n                break\n            self._log(DEBUG, 'Banner: ' + buf)\n        if buf[:4] != 'SSH-':\n            raise SSHException('Indecipherable protocol version \"' + buf + '\"')\n        # save this server version string for later\n        self.remote_version = buf\n        self._log(DEBUG, 'Remote version/idstring: %s' % buf)\n        # pull off any attached comment\n        # NOTE: comment used to be stored in a variable and then...never used.\n        # since 2003. ca 877cd974b8182d26fa76d566072917ea67b64e67\n        i = buf.find(' ')\n        if i >= 0:\n            buf = buf[:i]\n        # parse out version string and make sure it matches\n        segs = buf.split('-', 2)\n        if len(segs) < 3:\n            raise SSHException('Invalid SSH banner')\n        version = segs[1]\n        client = segs[2]\n        if version != '1.99' and version != '2.0':\n            msg = 'Incompatible version ({0} instead of 2.0)'\n            raise SSHException(msg.format(version))\n        msg = 'Connected (version {0}, client {1})'.format(version, client)\n        self._log(INFO, msg)\n\n    def _send_kex_init(self):\n        \"\"\"\n        announce to the other side that we'd like to negotiate keys, and what\n        kind of key negotiation we support.\n        \"\"\"\n        self.clear_to_send_lock.acquire()\n        try:\n            self.clear_to_send.clear()\n        finally:\n            self.clear_to_send_lock.release()\n        self.in_kex = True\n        if self.server_mode:\n            mp_required_prefix = 'diffie-hellman-group-exchange-sha'\n            kex_mp = [\n                k for k\n                in self._preferred_kex\n                if k.startswith(mp_required_prefix)\n            ]\n            if (self._modulus_pack is None) and (len(kex_mp) > 0):\n                # can't do group-exchange if we don't have a pack of potential\n                # primes\n                pkex = [\n                    k for k\n                    in self.get_security_options().kex\n                    if not k.startswith(mp_required_prefix)\n                ]\n                self.get_security_options().kex = pkex\n            available_server_keys = list(filter(\n                list(self.server_key_dict.keys()).__contains__,\n                self._preferred_keys\n            ))\n        else:\n            available_server_keys = self._preferred_keys\n\n        m = Message()\n        m.add_byte(cMSG_KEXINIT)\n        m.add_bytes(os.urandom(16))\n        m.add_list(self._preferred_kex)\n        m.add_list(available_server_keys)\n        m.add_list(self._preferred_ciphers)\n        m.add_list(self._preferred_ciphers)\n        m.add_list(self._preferred_macs)\n        m.add_list(self._preferred_macs)\n        m.add_list(self._preferred_compression)\n        m.add_list(self._preferred_compression)\n        m.add_string(bytes())\n        m.add_string(bytes())\n        m.add_boolean(False)\n        m.add_int(0)\n        # save a copy for later (needed to compute a hash)\n        self.local_kex_init = m.asbytes()\n        self._send_message(m)\n\n    def _parse_kex_init(self, m):\n        m.get_bytes(16) # cookie, discarded\n        kex_algo_list = m.get_list()\n        server_key_algo_list = m.get_list()\n        client_encrypt_algo_list = m.get_list()\n        server_encrypt_algo_list = m.get_list()\n        client_mac_algo_list = m.get_list()\n        server_mac_algo_list = m.get_list()\n        client_compress_algo_list = m.get_list()\n        server_compress_algo_list = m.get_list()\n        client_lang_list = m.get_list()\n        server_lang_list = m.get_list()\n        kex_follows = m.get_boolean()\n        m.get_int() # unused\n\n        self._log(DEBUG,\n            'kex algos:' + str(kex_algo_list) +\n            ' server key:' + str(server_key_algo_list) +\n            ' client encrypt:' + str(client_encrypt_algo_list) +\n            ' server encrypt:' + str(server_encrypt_algo_list) +\n            ' client mac:' + str(client_mac_algo_list) +\n            ' server mac:' + str(server_mac_algo_list) +\n            ' client compress:' + str(client_compress_algo_list) +\n            ' server compress:' + str(server_compress_algo_list) +\n            ' client lang:' + str(client_lang_list) +\n            ' server lang:' + str(server_lang_list) +\n            ' kex follows?' + str(kex_follows)\n        )\n\n        # as a server, we pick the first item in the client's list that we\n        # support.\n        # as a client, we pick the first item in our list that the server\n        # supports.\n        if self.server_mode:\n            agreed_kex = list(filter(\n                self._preferred_kex.__contains__,\n                kex_algo_list\n            ))\n        else:\n            agreed_kex = list(filter(\n                kex_algo_list.__contains__,\n                self._preferred_kex\n            ))\n        if len(agreed_kex) == 0:\n            raise SSHException('Incompatible ssh peer (no acceptable kex algorithm)') # noqa\n        self.kex_engine = self._kex_info[agreed_kex[0]](self)\n        self._log(DEBUG, \"Kex agreed: %s\" % agreed_kex[0])\n\n        if self.server_mode:\n            available_server_keys = list(filter(\n                list(self.server_key_dict.keys()).__contains__,\n                self._preferred_keys\n            ))\n            agreed_keys = list(filter(\n                available_server_keys.__contains__, server_key_algo_list\n            ))\n        else:\n            agreed_keys = list(filter(\n                server_key_algo_list.__contains__, self._preferred_keys\n            ))\n        if len(agreed_keys) == 0:\n            raise SSHException('Incompatible ssh peer (no acceptable host key)') # noqa\n        self.host_key_type = agreed_keys[0]\n        if self.server_mode and (self.get_server_key() is None):\n            raise SSHException('Incompatible ssh peer (can\\'t match requested host key type)') # noqa\n\n        if self.server_mode:\n            agreed_local_ciphers = list(filter(\n                self._preferred_ciphers.__contains__,\n                server_encrypt_algo_list\n            ))\n            agreed_remote_ciphers = list(filter(\n                self._preferred_ciphers.__contains__,\n                client_encrypt_algo_list\n            ))\n        else:\n            agreed_local_ciphers = list(filter(\n                client_encrypt_algo_list.__contains__,\n                self._preferred_ciphers\n            ))\n            agreed_remote_ciphers = list(filter(\n                server_encrypt_algo_list.__contains__,\n                self._preferred_ciphers\n            ))\n        if len(agreed_local_ciphers) == 0 or len(agreed_remote_ciphers) == 0:\n            raise SSHException('Incompatible ssh server (no acceptable ciphers)') # noqa\n        self.local_cipher = agreed_local_ciphers[0]\n        self.remote_cipher = agreed_remote_ciphers[0]\n        self._log_agreement(\n            'Cipher', local=self.local_cipher, remote=self.remote_cipher\n        )\n\n        if self.server_mode:\n            agreed_remote_macs = list(filter(\n                self._preferred_macs.__contains__, client_mac_algo_list\n            ))\n            agreed_local_macs = list(filter(\n                self._preferred_macs.__contains__, server_mac_algo_list\n            ))\n        else:\n            agreed_local_macs = list(filter(\n                client_mac_algo_list.__contains__, self._preferred_macs\n            ))\n            agreed_remote_macs = list(filter(\n                server_mac_algo_list.__contains__, self._preferred_macs\n            ))\n        if (len(agreed_local_macs) == 0) or (len(agreed_remote_macs) == 0):\n            raise SSHException('Incompatible ssh server (no acceptable macs)')\n        self.local_mac = agreed_local_macs[0]\n        self.remote_mac = agreed_remote_macs[0]\n        self._log_agreement(\n            'MAC', local=self.local_mac, remote=self.remote_mac\n        )\n\n        if self.server_mode:\n            agreed_remote_compression = list(filter(\n                self._preferred_compression.__contains__,\n                client_compress_algo_list\n            ))\n            agreed_local_compression = list(filter(\n                self._preferred_compression.__contains__,\n                server_compress_algo_list\n            ))\n        else:\n            agreed_local_compression = list(filter(\n                client_compress_algo_list.__contains__,\n                self._preferred_compression\n            ))\n            agreed_remote_compression = list(filter(\n                server_compress_algo_list.__contains__,\n                self._preferred_compression\n            ))\n        if (\n            len(agreed_local_compression) == 0 or\n            len(agreed_remote_compression) == 0\n        ):\n            msg = 'Incompatible ssh server (no acceptable compression) {0!r} {1!r} {2!r}' # noqa\n            raise SSHException(msg.format(\n                agreed_local_compression, agreed_remote_compression,\n                self._preferred_compression,\n            ))\n        self.local_compression = agreed_local_compression[0]\n        self.remote_compression = agreed_remote_compression[0]\n        self._log_agreement(\n            'Compression',\n            local=self.local_compression,\n            remote=self.remote_compression\n        )\n\n        # save for computing hash later...\n        # now wait!  openssh has a bug (and others might too) where there are\n        # actually some extra bytes (one NUL byte in openssh's case) added to\n        # the end of the packet but not parsed.  turns out we need to throw\n        # away those bytes because they aren't part of the hash.\n        self.remote_kex_init = cMSG_KEXINIT + m.get_so_far()\n\n    def _activate_inbound(self):\n        \"\"\"switch on newly negotiated encryption parameters for\n         inbound traffic\"\"\"\n        block_size = self._cipher_info[self.remote_cipher]['block-size']\n        if self.server_mode:\n            IV_in = self._compute_key('A', block_size)\n            key_in = self._compute_key(\n                'C', self._cipher_info[self.remote_cipher]['key-size']\n            )\n        else:\n            IV_in = self._compute_key('B', block_size)\n            key_in = self._compute_key(\n                'D', self._cipher_info[self.remote_cipher]['key-size']\n            )\n        engine = self._get_cipher(\n            self.remote_cipher, key_in, IV_in, self._DECRYPT\n        )\n        mac_size = self._mac_info[self.remote_mac]['size']\n        mac_engine = self._mac_info[self.remote_mac]['class']\n        # initial mac keys are done in the hash's natural size (not the\n        # potentially truncated transmission size)\n        if self.server_mode:\n            mac_key = self._compute_key('E', mac_engine().digest_size)\n        else:\n            mac_key = self._compute_key('F', mac_engine().digest_size)\n        self.packetizer.set_inbound_cipher(\n            engine, block_size, mac_engine, mac_size, mac_key\n        )\n        compress_in = self._compression_info[self.remote_compression][1]\n        if (\n            compress_in is not None and\n            (\n                self.remote_compression != 'zlib@openssh.com' or\n                self.authenticated\n            )\n        ):\n            self._log(DEBUG, 'Switching on inbound compression ...')\n            self.packetizer.set_inbound_compressor(compress_in())\n\n    def _activate_outbound(self):\n        \"\"\"switch on newly negotiated encryption parameters for\n         outbound traffic\"\"\"\n        m = Message()\n        m.add_byte(cMSG_NEWKEYS)\n        self._send_message(m)\n        block_size = self._cipher_info[self.local_cipher]['block-size']\n        if self.server_mode:\n            IV_out = self._compute_key('B', block_size)\n            key_out = self._compute_key(\n                'D', self._cipher_info[self.local_cipher]['key-size'])\n        else:\n            IV_out = self._compute_key('A', block_size)\n            key_out = self._compute_key(\n                'C', self._cipher_info[self.local_cipher]['key-size'])\n        engine = self._get_cipher(\n            self.local_cipher, key_out, IV_out, self._ENCRYPT)\n        mac_size = self._mac_info[self.local_mac]['size']\n        mac_engine = self._mac_info[self.local_mac]['class']\n        # initial mac keys are done in the hash's natural size (not the\n        # potentially truncated transmission size)\n        if self.server_mode:\n            mac_key = self._compute_key('F', mac_engine().digest_size)\n        else:\n            mac_key = self._compute_key('E', mac_engine().digest_size)\n        sdctr = self.local_cipher.endswith('-ctr')\n        self.packetizer.set_outbound_cipher(\n            engine, block_size, mac_engine, mac_size, mac_key, sdctr)\n        compress_out = self._compression_info[self.local_compression][0]\n        if (\n            compress_out is not None and\n            (\n                self.local_compression != 'zlib@openssh.com' or\n                self.authenticated\n            )\n        ):\n            self._log(DEBUG, 'Switching on outbound compression ...')\n            self.packetizer.set_outbound_compressor(compress_out())\n        if not self.packetizer.need_rekey():\n            self.in_kex = False\n        # we always expect to receive NEWKEYS now\n        self._expect_packet(MSG_NEWKEYS)\n\n    def _auth_trigger(self):\n        self.authenticated = True\n        # delayed initiation of compression\n        if self.local_compression == 'zlib@openssh.com':\n            compress_out = self._compression_info[self.local_compression][0]\n            self._log(DEBUG, 'Switching on outbound compression ...')\n            self.packetizer.set_outbound_compressor(compress_out())\n        if self.remote_compression == 'zlib@openssh.com':\n            compress_in = self._compression_info[self.remote_compression][1]\n            self._log(DEBUG, 'Switching on inbound compression ...')\n            self.packetizer.set_inbound_compressor(compress_in())\n\n    def _parse_newkeys(self, m):\n        self._log(DEBUG, 'Switch to new keys ...')\n        self._activate_inbound()\n        # can also free a bunch of stuff here\n        self.local_kex_init = self.remote_kex_init = None\n        self.K = None\n        self.kex_engine = None\n        if self.server_mode and (self.auth_handler is None):\n            # create auth handler for server mode\n            self.auth_handler = AuthHandler(self)\n        if not self.initial_kex_done:\n            # this was the first key exchange\n            self.initial_kex_done = True\n        # send an event?\n        if self.completion_event is not None:\n            self.completion_event.set()\n        # it's now okay to send data again (if this was a re-key)\n        if not self.packetizer.need_rekey():\n            self.in_kex = False\n        self.clear_to_send_lock.acquire()\n        try:\n            self.clear_to_send.set()\n        finally:\n            self.clear_to_send_lock.release()\n        return\n\n    def _parse_disconnect(self, m):\n        code = m.get_int()\n        desc = m.get_text()\n        self._log(INFO, 'Disconnect (code %d): %s' % (code, desc))\n\n    def _parse_global_request(self, m):\n        kind = m.get_text()\n        self._log(DEBUG, 'Received global request \"%s\"' % kind)\n        want_reply = m.get_boolean()\n        if not self.server_mode:\n            self._log(\n                DEBUG,\n                'Rejecting \"%s\" global request from server.' % kind\n            )\n            ok = False\n        elif kind == 'tcpip-forward':\n            address = m.get_text()\n            port = m.get_int()\n            ok = self.server_object.check_port_forward_request(address, port)\n            if ok:\n                ok = (ok,)\n        elif kind == 'cancel-tcpip-forward':\n            address = m.get_text()\n            port = m.get_int()\n            self.server_object.cancel_port_forward_request(address, port)\n            ok = True\n        else:\n            ok = self.server_object.check_global_request(kind, m)\n        extra = ()\n        if type(ok) is tuple:\n            extra = ok\n            ok = True\n        if want_reply:\n            msg = Message()\n            if ok:\n                msg.add_byte(cMSG_REQUEST_SUCCESS)\n                msg.add(*extra)\n            else:\n                msg.add_byte(cMSG_REQUEST_FAILURE)\n            self._send_message(msg)\n\n    def _parse_request_success(self, m):\n        self._log(DEBUG, 'Global request successful.')\n        self.global_response = m\n        if self.completion_event is not None:\n            self.completion_event.set()\n\n    def _parse_request_failure(self, m):\n        self._log(DEBUG, 'Global request denied.')\n        self.global_response = None\n        if self.completion_event is not None:\n            self.completion_event.set()\n\n    def _parse_channel_open_success(self, m):\n        chanid = m.get_int()\n        server_chanid = m.get_int()\n        server_window_size = m.get_int()\n        server_max_packet_size = m.get_int()\n        chan = self._channels.get(chanid)\n        if chan is None:\n            self._log(WARNING, 'Success for unrequested channel! [??]')\n            return\n        self.lock.acquire()\n        try:\n            chan._set_remote_channel(\n                server_chanid, server_window_size, server_max_packet_size)\n            self._log(DEBUG, 'Secsh channel %d opened.' % chanid)\n            if chanid in self.channel_events:\n                self.channel_events[chanid].set()\n                del self.channel_events[chanid]\n        finally:\n            self.lock.release()\n        return\n\n    def _parse_channel_open_failure(self, m):\n        chanid = m.get_int()\n        reason = m.get_int()\n        reason_str = m.get_text()\n        m.get_text()  # ignored language\n        reason_text = CONNECTION_FAILED_CODE.get(reason, '(unknown code)')\n        self._log(\n            ERROR,\n            'Secsh channel %d open FAILED: %s: %s' % (\n                chanid, reason_str, reason_text)\n        )\n        self.lock.acquire()\n        try:\n            self.saved_exception = ChannelException(reason, reason_text)\n            if chanid in self.channel_events:\n                self._channels.delete(chanid)\n                if chanid in self.channel_events:\n                    self.channel_events[chanid].set()\n                    del self.channel_events[chanid]\n        finally:\n            self.lock.release()\n        return\n\n    def _parse_channel_open(self, m):\n        kind = m.get_text()\n        chanid = m.get_int()\n        initial_window_size = m.get_int()\n        max_packet_size = m.get_int()\n        reject = False\n        if (\n            kind == 'auth-agent@openssh.com' and\n            self._forward_agent_handler is not None\n        ):\n            self._log(DEBUG, 'Incoming forward agent connection')\n            self.lock.acquire()\n            try:\n                my_chanid = self._next_channel()\n            finally:\n                self.lock.release()\n        elif (kind == 'x11') and (self._x11_handler is not None):\n            origin_addr = m.get_text()\n            origin_port = m.get_int()\n            self._log(\n                DEBUG,\n                'Incoming x11 connection from %s:%d' % (\n                    origin_addr, origin_port)\n            )\n            self.lock.acquire()\n            try:\n                my_chanid = self._next_channel()\n            finally:\n                self.lock.release()\n        elif (kind == 'forwarded-tcpip') and (self._tcp_handler is not None):\n            server_addr = m.get_text()\n            server_port = m.get_int()\n            origin_addr = m.get_text()\n            origin_port = m.get_int()\n            self._log(\n                DEBUG,\n                'Incoming tcp forwarded connection from %s:%d' % (\n                    origin_addr, origin_port)\n            )\n            self.lock.acquire()\n            try:\n                my_chanid = self._next_channel()\n            finally:\n                self.lock.release()\n        elif not self.server_mode:\n            self._log(\n                DEBUG,\n                'Rejecting \"%s\" channel request from server.' % kind)\n            reject = True\n            reason = OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED\n        else:\n            self.lock.acquire()\n            try:\n                my_chanid = self._next_channel()\n            finally:\n                self.lock.release()\n            if kind == 'direct-tcpip':\n                # handle direct-tcpip requests coming from the client\n                dest_addr = m.get_text()\n                dest_port = m.get_int()\n                origin_addr = m.get_text()\n                origin_port = m.get_int()\n                reason = self.server_object.check_channel_direct_tcpip_request(\n                    my_chanid,\n                    (origin_addr, origin_port),\n                    (dest_addr, dest_port)\n                )\n            else:\n                reason = self.server_object.check_channel_request(\n                    kind, my_chanid)\n            if reason != OPEN_SUCCEEDED:\n                self._log(\n                    DEBUG,\n                    'Rejecting \"%s\" channel request from client.' % kind)\n                reject = True\n        if reject:\n            msg = Message()\n            msg.add_byte(cMSG_CHANNEL_OPEN_FAILURE)\n            msg.add_int(chanid)\n            msg.add_int(reason)\n            msg.add_string('')\n            msg.add_string('en')\n            self._send_message(msg)\n            return\n\n        chan = Channel(my_chanid)\n        self.lock.acquire()\n        try:\n            self._channels.put(my_chanid, chan)\n            self.channels_seen[my_chanid] = True\n            chan._set_transport(self)\n            chan._set_window(\n                self.default_window_size, self.default_max_packet_size)\n            chan._set_remote_channel(\n                chanid, initial_window_size, max_packet_size)\n        finally:\n            self.lock.release()\n        m = Message()\n        m.add_byte(cMSG_CHANNEL_OPEN_SUCCESS)\n        m.add_int(chanid)\n        m.add_int(my_chanid)\n        m.add_int(self.default_window_size)\n        m.add_int(self.default_max_packet_size)\n        self._send_message(m)\n        self._log(DEBUG, 'Secsh channel %d (%s) opened.', my_chanid, kind)\n        if kind == 'auth-agent@openssh.com':\n            self._forward_agent_handler(chan)\n        elif kind == 'x11':\n            self._x11_handler(chan, (origin_addr, origin_port))\n        elif kind == 'forwarded-tcpip':\n            chan.origin_addr = (origin_addr, origin_port)\n            self._tcp_handler(\n                chan,\n                (origin_addr, origin_port),\n                (server_addr, server_port)\n            )\n        else:\n            self._queue_incoming_channel(chan)\n\n    def _parse_debug(self, m):\n        m.get_boolean()  # always_display\n        msg = m.get_string()\n        m.get_string()  # language\n        self._log(DEBUG, 'Debug msg: {0}'.format(util.safe_string(msg)))\n\n    def _get_subsystem_handler(self, name):\n        try:\n            self.lock.acquire()\n            if name not in self.subsystem_table:\n                return None, [], {}\n            return self.subsystem_table[name]\n        finally:\n            self.lock.release()\n\n    _handler_table = {\n        MSG_NEWKEYS: _parse_newkeys,\n        MSG_GLOBAL_REQUEST: _parse_global_request,\n        MSG_REQUEST_SUCCESS: _parse_request_success,\n        MSG_REQUEST_FAILURE: _parse_request_failure,\n        MSG_CHANNEL_OPEN_SUCCESS: _parse_channel_open_success,\n        MSG_CHANNEL_OPEN_FAILURE: _parse_channel_open_failure,\n        MSG_CHANNEL_OPEN: _parse_channel_open,\n        MSG_KEXINIT: _negotiate_keys,\n    }\n\n    _channel_handler_table = {\n        MSG_CHANNEL_SUCCESS: Channel._request_success,\n        MSG_CHANNEL_FAILURE: Channel._request_failed,\n        MSG_CHANNEL_DATA: Channel._feed,\n        MSG_CHANNEL_EXTENDED_DATA: Channel._feed_extended,\n        MSG_CHANNEL_WINDOW_ADJUST: Channel._window_adjust,\n        MSG_CHANNEL_REQUEST: Channel._handle_request,\n        MSG_CHANNEL_EOF: Channel._handle_eof,\n        MSG_CHANNEL_CLOSE: Channel._handle_close,\n    }\n\n\nclass SecurityOptions (object):\n    \"\"\"\n    Simple object containing the security preferences of an ssh transport.\n    These are tuples of acceptable ciphers, digests, key types, and key\n    exchange algorithms, listed in order of preference.\n\n    Changing the contents and/or order of these fields affects the underlying\n    `.Transport` (but only if you change them before starting the session).\n    If you try to add an algorithm that paramiko doesn't recognize,\n    ``ValueError`` will be raised.  If you try to assign something besides a\n    tuple to one of the fields, ``TypeError`` will be raised.\n    \"\"\"\n    __slots__ = '_transport'\n\n    def __init__(self, transport):\n        self._transport = transport\n\n    def __repr__(self):\n        \"\"\"\n        Returns a string representation of this object, for debugging.\n        \"\"\"\n        return '<paramiko.SecurityOptions for %s>' % repr(self._transport)\n\n    def _set(self, name, orig, x):\n        if type(x) is list:\n            x = tuple(x)\n        if type(x) is not tuple:\n            raise TypeError('expected tuple or list')\n        possible = list(getattr(self._transport, orig).keys())\n        forbidden = [n for n in x if n not in possible]\n        if len(forbidden) > 0:\n            raise ValueError('unknown cipher')\n        setattr(self._transport, name, x)\n\n    @property\n    def ciphers(self):\n        \"\"\"Symmetric encryption ciphers\"\"\"\n        return self._transport._preferred_ciphers\n\n    @ciphers.setter\n    def ciphers(self, x):\n        self._set('_preferred_ciphers', '_cipher_info', x)\n\n    @property\n    def digests(self):\n        \"\"\"Digest (one-way hash) algorithms\"\"\"\n        return self._transport._preferred_macs\n\n    @digests.setter\n    def digests(self, x):\n        self._set('_preferred_macs', '_mac_info', x)\n\n    @property\n    def key_types(self):\n        \"\"\"Public-key algorithms\"\"\"\n        return self._transport._preferred_keys\n\n    @key_types.setter\n    def key_types(self, x):\n        self._set('_preferred_keys', '_key_info', x)\n\n\n    @property\n    def kex(self):\n        \"\"\"Key exchange algorithms\"\"\"\n        return self._transport._preferred_kex\n\n    @kex.setter\n    def kex(self, x):\n        self._set('_preferred_kex', '_kex_info', x)\n\n    @property\n    def compression(self):\n        \"\"\"Compression algorithms\"\"\"\n        return self._transport._preferred_compression\n\n    @compression.setter\n    def compression(self, x):\n        self._set('_preferred_compression', '_compression_info', x)\n\n\nclass ChannelMap (object):\n    def __init__(self):\n        # (id -> Channel)\n        self._map = weakref.WeakValueDictionary()\n        self._lock = threading.Lock()\n\n    def put(self, chanid, chan):\n        self._lock.acquire()\n        try:\n            self._map[chanid] = chan\n        finally:\n            self._lock.release()\n\n    def get(self, chanid):\n        self._lock.acquire()\n        try:\n            return self._map.get(chanid, None)\n        finally:\n            self._lock.release()\n\n    def delete(self, chanid):\n        self._lock.acquire()\n        try:\n            try:\n                del self._map[chanid]\n            except KeyError:\n                pass\n        finally:\n            self._lock.release()\n\n    def values(self):\n        self._lock.acquire()\n        try:\n            return list(self._map.values())\n        finally:\n            self._lock.release()\n\n    def __len__(self):\n        self._lock.acquire()\n        try:\n            return len(self._map)\n        finally:\n            self._lock.release()\n"], "filenames": ["paramiko/common.py", "paramiko/transport.py"], "buggy_code_start_loc": [34, 52], "buggy_code_end_loc": [34, 1824], "fixing_code_start_loc": [35, 52], "fixing_code_end_loc": [36, 1865], "type": "CWE-287", "message": "transport.py in the SSH server implementation of Paramiko before 1.17.6, 1.18.x before 1.18.5, 2.0.x before 2.0.8, 2.1.x before 2.1.5, 2.2.x before 2.2.3, 2.3.x before 2.3.2, and 2.4.x before 2.4.1 does not properly check whether authentication is completed before processing other requests, as demonstrated by channel-open. A customized SSH client can simply skip the authentication step.", "other": {"cve": {"id": "CVE-2018-7750", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-13T18:29:00.303", "lastModified": "2022-04-18T17:30:23.640", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "transport.py in the SSH server implementation of Paramiko before 1.17.6, 1.18.x before 1.18.5, 2.0.x before 2.0.8, 2.1.x before 2.1.5, 2.2.x before 2.2.3, 2.3.x before 2.3.2, and 2.4.x before 2.4.1 does not properly check whether authentication is completed before processing other requests, as demonstrated by channel-open. A customized SSH client can simply skip the authentication step."}, {"lang": "es", "value": "transport.py en la implementaci\u00f3n del servidor SSH de Paramiko, en versiones anteriores a la 1.17.6; versiones 1.18.x anteriores a la 1.18.5; versiones 2.0.x anteriores a la 2.0.8; versiones 2.1.x anteriores a la 2.1.5; versiones 2.2.x anteriores a la 2.2.3; versiones 2.3.x anteriores a la 2.3.2 y versiones 2.4.x anteriores a la 2.4.1, no comprueba adecuadamente si la autenticaci\u00f3n se ha completado antes de procesar otras peticiones, tal y como demuestra channel-open. Un cliente SSH personalizado puede simplemente omitir el paso de autenticaci\u00f3n."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:paramiko:paramiko:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.17.6", "matchCriteriaId": "5D1D3BB9-1426-4498-9BB4-A7F7696C7D18"}, {"vulnerable": true, "criteria": "cpe:2.3:a:paramiko:paramiko:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.18.0", "versionEndExcluding": "1.18.5", "matchCriteriaId": "8F645AC2-3A4F-47C7-9DFC-DEB25C467D21"}, {"vulnerable": true, "criteria": "cpe:2.3:a:paramiko:paramiko:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.0.8", "matchCriteriaId": "1B500C82-6C71-4ED6-B334-E13DBFFA6F51"}, {"vulnerable": true, "criteria": "cpe:2.3:a:paramiko:paramiko:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.1.0", "versionEndExcluding": "2.1.5", "matchCriteriaId": "E90FB648-ABD2-4BDC-AD67-DD904595D967"}, {"vulnerable": true, "criteria": "cpe:2.3:a:paramiko:paramiko:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.2.3", "matchCriteriaId": "B2C6E9E8-AF99-4E7B-8EE4-646835D7AFE1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:paramiko:paramiko:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.2", "matchCriteriaId": "4E16324F-880D-44DF-8F01-EFAAA5358E81"}, {"vulnerable": true, "criteria": "cpe:2.3:a:paramiko:paramiko:2.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "CFD08D44-023B-4126-8D7F-E9ECFDA59A6E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ansible_engine:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "8989CD03-49A1-4831-BF98-9F21592788BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ansible_engine:2.4:*:*:*:*:*:*:*", "matchCriteriaId": "5864D753-2A37-4800-A73E-6ACA0662B605"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:cloudforms:4.5:*:*:*:*:*:*:*", "matchCriteriaId": "32E1BA91-4695-4E64-A9D7-4A6CB6904D41"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:cloudforms:4.6:*:*:*:*:*:*:*", "matchCriteriaId": "67F7263F-113D-4BAE-B8CB-86A61531A2AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:virtualization:4.1:*:*:*:*:*:*:*", "matchCriteriaId": "03EB0F63-DB24-4240-BC44-C92BAE7EAF42"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:6.4:*:*:*:*:*:*:*", "matchCriteriaId": "AF83BB87-B203-48F9-9D06-48A5FE399050"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:6.5:*:*:*:*:*:*:*", "matchCriteriaId": "1F3BEFDB-5156-4E1C-80BB-8BE9FEAA7623"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:6.6:*:*:*:*:*:*:*", "matchCriteriaId": "16E6D998-B41D-4B49-9E00-8336D2E40A4A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:6.7:*:*:*:*:*:*:*", "matchCriteriaId": "6C81647C-9A53-481D-A54C-36770A093F90"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:6.6:*:*:*:*:*:*:*", "matchCriteriaId": "13E02156-E748-4820-B76F-7074793837E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/103713", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0591", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0646", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1124", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1125", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1213", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1274", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1328", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1525", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1972", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/paramiko/paramiko/blob/master/sites/www/changelog.rst", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/paramiko/paramiko/commit/fa29bd8446c8eab237f5187d28787727b4610516", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/paramiko/paramiko/issues/1175", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/10/msg00018.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/12/msg00025.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3603-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3603-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/45712/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/paramiko/paramiko/commit/fa29bd8446c8eab237f5187d28787727b4610516"}}