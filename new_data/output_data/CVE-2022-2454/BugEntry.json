{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2005-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / LASeR codec sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/laser_dev.h>\n#include <gpac/internal/scenegraph_dev.h>\n#include <gpac/bitstream.h>\n#include <gpac/events.h>\n\n#ifndef GPAC_DISABLE_LASER\n\n\n#define GF_LSR_READ_INT(_codec, _val, _nbBits, _str) {\\\n\tif (_nbBits/8 > gf_bs_available(lsr->bs)) {\\\n\t\tlsr->last_error = GF_NON_COMPLIANT_BITSTREAM;\\\n\t\t(_val) = 0;\\\n\t} else {\\\n\t\t(_val) = gf_bs_read_int(_codec->bs, _nbBits);\t\\\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[LASeR] %s\\t\\t%d\\t\\t%d\\n\", _str, _nbBits, _val)); \\\n\t}\\\n}\n\n\nstatic void lsr_read_group_content(GF_LASeRCodec *lsr, GF_Node *elt, Bool skip_object_content);\nstatic void lsr_read_group_content_post_init(GF_LASeRCodec *lsr, SVG_Element *elt, Bool skip_init);\nstatic GF_Err lsr_read_command_list(GF_LASeRCodec *lsr, GF_List *comList, SVG_Element *cond, Bool first_imp);\nstatic GF_Err lsr_decode_laser_unit(GF_LASeRCodec *lsr, GF_List *com_list);\nstatic void lsr_read_path_type(GF_LASeRCodec *lsr, GF_Node *n, u32 tag, SVG_PathData *path, const char *name);\nstatic void lsr_read_point_sequence(GF_LASeRCodec *lsr, GF_List *pts, const char *name);\nstatic Bool lsr_setup_smil_anim(GF_LASeRCodec *lsr, SVG_Element *anim, SVG_Element *anim_parent);\n\nGF_EXPORT\nGF_LASeRCodec *gf_laser_decoder_new(GF_SceneGraph *graph)\n{\n\tGF_LASeRCodec *tmp;\n\tGF_SAFEALLOC(tmp, GF_LASeRCodec);\n\tif (!tmp) return NULL;\n\ttmp->streamInfo = gf_list_new();\n\ttmp->font_table = gf_list_new();\n\ttmp->deferred_hrefs = gf_list_new();\n\ttmp->deferred_listeners = gf_list_new();\n\ttmp->deferred_anims = gf_list_new();\n\ttmp->unresolved_commands = gf_list_new();\n\ttmp->sg = graph;\n\treturn tmp;\n}\n\nGF_EXPORT\nvoid gf_laser_decoder_del(GF_LASeRCodec *codec)\n{\n\t/*destroy all config*/\n\twhile (gf_list_count(codec->streamInfo)) {\n\t\tLASeRStreamInfo *p = (LASeRStreamInfo *)gf_list_last(codec->streamInfo);\n\t\tgf_free(p);\n\t\tgf_list_rem_last(codec->streamInfo);\n\t}\n\tgf_list_del(codec->streamInfo);\n\tif (codec->col_table) gf_free(codec->col_table);\n\twhile (gf_list_count(codec->font_table)) {\n\t\tchar *ft = (char *)gf_list_last(codec->font_table);\n\t\tgf_free(ft);\n\t\tgf_list_rem_last(codec->font_table);\n\t}\n\tgf_list_del(codec->font_table);\n#if 0\n\twhile (gf_list_count(codec->deferred_hrefs)) {\n\t\tXMLRI *iri = (XMLRI *)gf_list_last(codec->deferred_hrefs);\n\t\tgf_list_rem_last(codec->deferred_hrefs);\n\t\tif (iri->string) gf_free(iri->string);\n\t\tiri->string = NULL;\n\t}\n#endif\n\tgf_list_del(codec->deferred_hrefs);\n\tgf_list_del(codec->deferred_anims);\n\tgf_list_del(codec->deferred_listeners);\n\tgf_list_del(codec->unresolved_commands);\n\tgf_free(codec);\n}\n\nstatic LASeRStreamInfo *lsr_get_stream(GF_LASeRCodec *codec, u16 ESID)\n{\n\tu32 i=0;\n\tLASeRStreamInfo *ptr;\n\twhile ((ptr = (LASeRStreamInfo *)gf_list_enum(codec->streamInfo, &i))) {\n\t\tif (!ESID || (ptr->ESID==ESID)) return ptr;\n\t}\n\treturn NULL;\n}\n\n\nGF_EXPORT\nGF_Err gf_laser_decoder_configure_stream(GF_LASeRCodec *codec, u16 ESID, u8 *dsi, u32 dsi_len)\n{\n\tLASeRStreamInfo *info;\n\tGF_BitStream *bs;\n\tif (lsr_get_stream(codec, ESID) != NULL) return GF_BAD_PARAM;\n\tGF_SAFEALLOC(info, LASeRStreamInfo);\n\tif (!info) return GF_OUT_OF_MEM;\n\tinfo->ESID = ESID;\n\tbs = gf_bs_new(dsi, dsi_len, GF_BITSTREAM_READ);\n\n\tinfo->cfg.profile = gf_bs_read_int(bs, 8);\n\tinfo->cfg.level = gf_bs_read_int(bs, 8);\n\t/*info->cfg.reserved = */ gf_bs_read_int(bs, 3);\n\tinfo->cfg.pointsCodec = gf_bs_read_int(bs, 2);\n\tinfo->cfg.pathComponents = gf_bs_read_int(bs, 4);\n\tinfo->cfg.fullRequestHost = gf_bs_read_int(bs, 1);\n\tif (gf_bs_read_int(bs, 1)) {\n\t\tinfo->cfg.time_resolution = gf_bs_read_int(bs, 16);\n\t} else {\n\t\tinfo->cfg.time_resolution = 1000;\n\t}\n\tinfo->cfg.colorComponentBits = gf_bs_read_int(bs, 4);\n\tinfo->cfg.colorComponentBits += 1;\n\tinfo->cfg.resolution = gf_bs_read_int(bs, 4);\n\tif (info->cfg.resolution>7) info->cfg.resolution -= 16;\n\tinfo->cfg.coord_bits = gf_bs_read_int(bs, 5);\n\tinfo->cfg.scale_bits_minus_coord_bits = gf_bs_read_int(bs, 4);\n\tinfo->cfg.newSceneIndicator = gf_bs_read_int(bs, 1);\n\t/*reserved*/ gf_bs_read_int(bs, 3);\n\tinfo->cfg.extensionIDBits = gf_bs_read_int(bs, 4);\n\t/*we ignore the rest*/\n\tgf_list_add(codec->streamInfo, info);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_laser_decoder_remove_stream(GF_LASeRCodec *codec, u16 ESID)\n{\n\tu32 i, count;\n\tcount = gf_list_count(codec->streamInfo);\n\tfor (i=0; i<count; i++) {\n\t\tLASeRStreamInfo *ptr = (LASeRStreamInfo *) gf_list_get(codec->streamInfo, i);\n\t\tif (ptr->ESID==ESID) {\n\t\t\tgf_free(ptr);\n\t\t\tgf_list_rem(codec->streamInfo, i);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_BAD_PARAM;\n}\n\n\nvoid gf_bs_set_eos_callback(GF_BitStream *bs, void (*EndOfStream)(void *par), void *par);\n\nvoid lsr_end_of_stream(void *co)\n{\n\tGF_LASeRCodec *codec = (GF_LASeRCodec *)co;\n\tif (codec->last_error != GF_NON_COMPLIANT_BITSTREAM) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[LASeR] memory overread - corrupted decoding\\n\"));\n\t\t((GF_LASeRCodec *) co)->last_error = GF_NON_COMPLIANT_BITSTREAM;\n\t}\n}\n\nGF_EXPORT\nBool gf_laser_decode_has_conditionnals(GF_LASeRCodec *codec)\n{\n\treturn codec && codec->has_conditionnals ? GF_TRUE : GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_laser_decode_au(GF_LASeRCodec *codec, u16 ESID, const u8 *data, u32 data_len)\n{\n\tGF_Err e;\n\tif (!codec || !data || !data_len) return GF_BAD_PARAM;\n\n\tcodec->info = lsr_get_stream(codec, ESID);\n\tif (!codec->info) return GF_BAD_PARAM;\n\tcodec->coord_bits = codec->info->cfg.coord_bits;\n\tcodec->scale_bits = codec->info->cfg.scale_bits_minus_coord_bits;\n\tcodec->time_resolution = codec->info->cfg.time_resolution;\n\tcodec->color_scale = (1<<codec->info->cfg.colorComponentBits) - 1;\n\tif (codec->info->cfg.resolution >= 0)\n\t\tcodec->res_factor = INT2FIX(1<<codec->info->cfg.resolution);\n\telse\n\t\tcodec->res_factor = gf_divfix(FIX_ONE, INT2FIX(1 << (-codec->info->cfg.resolution)) );\n\n\tcodec->bs = gf_bs_new(data, data_len, GF_BITSTREAM_READ);\n\tgf_bs_set_eos_callback(codec->bs, lsr_end_of_stream, codec);\n\tcodec->memory_dec = GF_FALSE;\n\te = lsr_decode_laser_unit(codec, NULL);\n\tgf_bs_del(codec->bs);\n\tcodec->bs = NULL;\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_laser_decode_command_list(GF_LASeRCodec *codec, u16 ESID, u8 *data, u32 data_len, GF_List *com_list)\n{\n\tGF_Err e;\n\tu32 i;\n\tif (!codec || !data || !data_len) return GF_BAD_PARAM;\n\n\tcodec->info = lsr_get_stream(codec, ESID);\n\tif (!codec->info) return GF_BAD_PARAM;\n\tcodec->coord_bits = codec->info->cfg.coord_bits;\n\tcodec->scale_bits = codec->info->cfg.scale_bits_minus_coord_bits;\n\tcodec->time_resolution = codec->info->cfg.time_resolution;\n\tcodec->color_scale = (1<<codec->info->cfg.colorComponentBits) - 1;\n\tif (codec->info->cfg.resolution >= 0)\n\t\tcodec->res_factor = INT2FIX(1<<codec->info->cfg.resolution);\n\telse\n\t\tcodec->res_factor = gf_divfix(FIX_ONE, INT2FIX(1 << (-codec->info->cfg.resolution)) );\n\n\tcodec->bs = gf_bs_new(data, data_len, GF_BITSTREAM_READ);\n\tgf_bs_set_eos_callback(codec->bs, lsr_end_of_stream, codec);\n\tcodec->memory_dec = GF_TRUE;\n\te = lsr_decode_laser_unit(codec, com_list);\n\tgf_bs_del(codec->bs);\n\tcodec->bs = NULL;\n\tif (e) return e;\n\n\tfor (i=0; i<gf_list_count(codec->unresolved_commands); i++) {\n\t\tGF_Command *com = (GF_Command *)gf_list_get(codec->unresolved_commands, i);\n\t\tassert(!com->node);\n\t\tcom->node = gf_sg_find_node(codec->sg, com->RouteID);\n\t\tif (com->node) {\n\t\t\tgf_node_register(com->node, NULL);\n\t\t\tcom->RouteID = 0;\n\t\t\tgf_list_rem(codec->unresolved_commands, i);\n\t\t\ti--;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_laser_decoder_set_clock(GF_LASeRCodec *codec, Double (*GetSceneTime)(void *st_cbk), void *st_cbk )\n{\n\tcodec->GetSceneTime = GetSceneTime;\n\tcodec->cbk = st_cbk;\n}\n\nstatic u32 lsr_read_vluimsbf5(GF_LASeRCodec *lsr, const char *name)\n{\n\tu32 nb_words = 0;\n\tu32 nb_tot, nb_bits, val;\n\n\twhile (gf_bs_read_int(lsr->bs, 1)) nb_words++;\n\tnb_words++;\n\tnb_tot = nb_words;\n\tnb_bits = nb_words*4;\n\tnb_tot += nb_bits;\n\tval = gf_bs_read_int(lsr->bs, nb_bits);\n\tif (name) GF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[LASeR] %s\\t\\t%d\\t\\t%d\\n\", name, nb_tot, val));\n\treturn val;\n}\nstatic u32 lsr_read_vluimsbf8(GF_LASeRCodec *lsr, const char *name)\n{\n\tu32 nb_words = 0;\n\tu32 nb_tot, nb_bits, val;\n\n\twhile (gf_bs_read_int(lsr->bs, 1)) nb_words++;\n\tnb_words++;\n\tnb_tot = nb_words;\n\tnb_bits = nb_words*7;\n\tnb_tot += nb_bits;\n\tval = gf_bs_read_int(lsr->bs, nb_bits);\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[LASeR] %s\\t\\t%d\\t\\t%d\\n\", name, nb_tot, val));\n\treturn val;\n}\n\nstatic void lsr_read_extension(GF_LASeRCodec *lsr, const char *name)\n{\n\tu32 len = lsr_read_vluimsbf5(lsr, name);\n#if 0\n\t*out_data = gf_malloc(sizeof(char)*len);\n\tgf_bs_read_data(lsr->bs, *out_data, len);\n\t*out_len = len;\n#else\n\twhile (len && gf_bs_available(lsr->bs) ) {\n\t\tgf_bs_read_int(lsr->bs, 8);\n\t\tlen--;\n\t}\n\tif (len) lsr->last_error = GF_NON_COMPLIANT_BITSTREAM;\n#endif\n}\n\nstatic void lsr_read_extend_class(GF_LASeRCodec *lsr, char **out_data, u32 *out_len, const char *name)\n{\n\tu32 len;\n\tGF_LSR_READ_INT(lsr, len, lsr->info->cfg.extensionIDBits, \"reserved\");\n\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n//\twhile (len) gf_bs_read_int(lsr->bs, 1);\n\tgf_bs_read_long_int(lsr->bs, len);\n\tif (out_data) *out_data = NULL;\n\tif (out_len) *out_len = 0;\n}\n\nstatic void lsr_read_private_element_container(GF_LASeRCodec *lsr)\n{\n\tu32 val, len;\n\tGF_LSR_READ_INT(lsr, val, 4, \"ch4\");\n\tswitch (val) {\n\t/*privateAnyXMLElement*/\n\tcase 0:\n\t\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\t\tgf_bs_skip_bytes(lsr->bs, len);\n\t\tbreak;\n\t/*privateOpaqueElement*/\n\tcase 1:\n\t\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\t\tgf_bs_skip_bytes(lsr->bs, len);\n\t\tbreak;\n\t/*element_any*/\n\tcase 2:\n\t\tlsr_read_extend_class(lsr, NULL, 0, \"reserved\");\n\t\tbreak;\n\t/*attr_custom_extension*/\n\tdefault:\n\t\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\t\tgf_bs_skip_bytes(lsr->bs, len);\n\t\tbreak;\n\t}\n}\n\nstatic void lsr_read_private_attribute_container(GF_LASeRCodec *lsr)\n{\n\tu32 val;\n\tdo {\n\t\tu32 skip_len;\n\t\tGF_LSR_READ_INT(lsr, val, 2, \"privateDataType\");\n\t\tskip_len = lsr_read_vluimsbf5(lsr, \"skipLen\");\n\t\tgf_bs_align(lsr->bs);\n\t\t/*just skip data*/\n#if 1\n\t\tif (skip_len>gf_bs_available(lsr->bs)) {\n\t\t\tlsr->last_error = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\treturn;\n\t\t}\n\t\tgf_bs_skip_bytes(lsr->bs, skip_len);\n#else\n\t\tswitch (val) {\n\t\t/*private data of type \"anyXML\"*/\n\t\tcase 0:\n\t\t\tcount = lsr_read_vluimsbf5(lsr, \"count\");\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tprivateAttribute(0) attr[i];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/*TODO FIXME - nameSpaceIndexBits is not defined in the spec*/\n\t\t\tuint(nameSpaceIndexBits) nameSpaceIndex;\n\t\t\tgf_bs_align(lsr->bs);\n\t\t\tbyte[skipLen - ((nameSpaceIndexBits+7)%8)] data;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*TODO - spec is wrong here (typo, \"len\" instead of \"skipLen\" )*/\n\t\t\tgf_bs_skip_bytes(skipLen);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tgf_bs_align(lsr->bs);\n\t\tGF_LSR_READ_INT(lsr, val, 1, \"hasMorePrivateData\");\n\t} while (val);\n}\n\nstatic void lsr_read_any_attribute(GF_LASeRCodec *lsr, GF_Node *node, Bool skippable)\n{\n\tu32 val = 1;\n\tif (skippable) GF_LSR_READ_INT(lsr, val, 1, \"has_attrs\");\n\tif (val) {\n\t\tdo {\n\t\t\tGF_LSR_READ_INT(lsr, val, lsr->info->cfg.extensionIDBits, \"reserved\");\n\t\t\tval = lsr_read_vluimsbf5(lsr, \"len\");//len in BITS\n\t\t\tGF_LSR_READ_INT(lsr, val, val, \"reserved_val\");\n\t\t\tGF_LSR_READ_INT(lsr, val, 1, \"hasNextExtension\");\n\t\t\tif (lsr->last_error) return;\n\t\t} while (val);\n\t}\n}\n\nstatic void lsr_read_object_content(GF_LASeRCodec *lsr, SVG_Element *elt)\n{\n\tu32 val;\n\tGF_LSR_READ_INT(lsr, val, 1, \"has_private_attr\");\n\tif (val) lsr_read_private_attribute_container(lsr);\n}\n\nstatic void lsr_read_codec_IDREF(GF_LASeRCodec *lsr, XMLRI *href, const char *name)\n{\n\tGF_Node *n;\n\tu32 flag;\n\tu32 nID = 1+lsr_read_vluimsbf5(lsr, name);\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"reserved\");\n\tif (flag) {\n\t\tu32 len = lsr_read_vluimsbf5(lsr, \"len\");\n\t\tGF_LSR_READ_INT(lsr, flag, len, \"reserved\");\n\t}\n\n\tn = gf_sg_find_node(lsr->sg, nID);\n\tif (!n) {\n\t\tchar NodeID[1024];\n\t\tsprintf(NodeID, \"N%d\", nID-1);\n\t\thref->string = gf_strdup(NodeID);\n\t\tif (href->type!=0xFF)\n\t\t\tgf_list_add(lsr->deferred_hrefs, href);\n\t\thref->type = XMLRI_ELEMENTID;\n\t\treturn;\n\t}\n\thref->target = (SVG_Element *)n;\n\thref->type = XMLRI_ELEMENTID;\n\tgf_node_register_iri(lsr->sg, href);\n}\n\nstatic u32 lsr_read_codec_IDREF_command(GF_LASeRCodec *lsr, const char *name)\n{\n\tu32 flag;\n\tu32 nID = 1+lsr_read_vluimsbf5(lsr, name);\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"reserved\");\n\tif (flag) {\n\t\tu32 len = lsr_read_vluimsbf5(lsr, \"len\");\n\t\tGF_LSR_READ_INT(lsr, flag, len, \"reserved\");\n\t}\n\treturn nID;\n}\n\nstatic Fixed lsr_read_fixed_16_8(GF_LASeRCodec *lsr, const char *name)\n{\n\tu32 val;\n\tGF_LSR_READ_INT(lsr, val, 24, name);\n\tif (val & (1<<23)) {\n\t\ts32 res = val - (1<<24);\n#ifdef GPAC_FIXED_POINT\n\t\treturn res*256;\n#else\n\t\treturn INT2FIX(res) / 256;\n#endif\n\t} else {\n#ifdef GPAC_FIXED_POINT\n\t\treturn val*256;\n#else\n\t\treturn INT2FIX(val) / 256;\n#endif\n\t}\n}\n\nstatic void lsr_read_fixed_16_8i(GF_LASeRCodec *lsr, SVG_Number *n, const char *name)\n{\n\ts32 val;\n\tGF_LSR_READ_INT(lsr, val, 1, name);\n\tif (val) {\n\t\tn->type=SVG_NUMBER_INHERIT;\n\t} else {\n\t\tn->type=SVG_NUMBER_VALUE;\n\t\tn->value = lsr_read_fixed_16_8(lsr, name);\n\t}\n}\n\n\nstatic void lsr_get_color(GF_LASeRCodec *lsr, u32 idx, SVG_Color *color)\n{\n\tLSRCol *c;\n\tif (idx>=lsr->nb_cols) return;\n\n\tc = &lsr->col_table[idx];\n\tcolor->red = INT2FIX(c->r) / lsr->color_scale;\n\tcolor->green = INT2FIX(c->g) / lsr->color_scale;\n\tcolor->blue = INT2FIX(c->b) / lsr->color_scale;\n\tcolor->type = SVG_COLOR_RGBCOLOR;\n}\n\n\nstatic void lsr_read_line_increment_type(GF_LASeRCodec *lsr, SVG_Number *li, const char *name)\n{\n\tu32 val;\n\tGF_LSR_READ_INT(lsr, val, 1, \"choice\");\n\tif (val==1) {\n\t\tGF_LSR_READ_INT(lsr, val, 1, \"type\");\n\t\tif (val==1) li->type=SVG_NUMBER_INHERIT;\n\t\telse li->type=SVG_NUMBER_AUTO;\n\t} else {\n\t\tli->value = lsr_read_fixed_16_8(lsr, \"line-increment-value\");\n\t}\n}\n\nstatic void lsr_read_byte_align_string(GF_LASeRCodec *lsr, char **str, const char *name)\n{\n\tu32 len;\n\tgf_bs_align(lsr->bs);\n\tlen = lsr_read_vluimsbf8(lsr, \"len\");\n\tif (str) {\n\t\tif (*str) gf_free(*str);\n\t\t*str = NULL;\n\t\tif (len) {\n\t\t\tif (len > gf_bs_available(lsr->bs) ) {\n\t\t\t\tlsr->last_error = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*str = (char*)gf_malloc(sizeof(char)*(len+1));\n\t\t\tif (!*str) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgf_bs_read_data(lsr->bs, *str, len);\n\t\t\t(*str) [len] = 0;\n\t\t}\n\t} else {\n\t\tif (len > gf_bs_available(lsr->bs) ) {\n\t\t\tlsr->last_error = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\treturn;\n\t\t}\n\t\twhile (len) {\n\t\t\tgf_bs_read_int(lsr->bs, 8);\n\t\t\tlen--;\n\t\t}\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[LASeR] %s\\t\\t%d\\t\\t%s\\n\", name, 8*len, str ? *str : \"\"));\n}\n\nstatic void lsr_read_text_content(GF_LASeRCodec *lsr, GF_Node *elt)\n{\n\tchar *str = NULL;\n\tlsr_read_byte_align_string(lsr, &str, \"textContent\");\n\tif (!str) return;\n\tgf_dom_add_text_node(elt, str);\n}\n\nstatic void lsr_read_byte_align_string_list(GF_LASeRCodec *lsr, GF_List *l, const char *name, Bool is_iri, Bool is_font)\n{\n\tXMLRI *iri;\n\tchar *text, *sep, *sep2, *cur;\n\twhile (gf_list_count(l)) {\n\t\tchar *str = (char *)gf_list_last(l);\n\t\tgf_list_rem_last(l);\n\t\tgf_free(str);\n\t}\n\ttext = NULL;\n\tlsr_read_byte_align_string(lsr, &text, name);\n\tcur = text;\n\twhile (cur) {\n\t\tsep = strchr(cur, '\\'');\n\t\tif (!sep && is_font) {\n\t\t\tsep = strchr(cur, ',');\n\t\t\tif (!sep) sep = strchr(cur, ';');\n\t\t}\n\t\tif (!sep) {\n\t\t\tif (is_iri) {\n\t\t\t\tGF_SAFEALLOC(iri, XMLRI);\n\t\t\t\tif (iri) {\n\t\t\t\t\tiri->string = gf_strdup(cur);\n\t\t\t\t\tiri->type = XMLRI_STRING;\n\t\t\t\t\tgf_list_add(l, iri);\n\t\t\t\t} else {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_list_add(l, gf_strdup(cur));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tsep2 = strchr(sep + 1, '\\'');\n\t\tif (!sep2 && !is_font) {\n\t\t\tif (is_iri) {\n\t\t\t\tGF_SAFEALLOC(iri, XMLRI);\n\t\t\t\tif (iri) {\n\t\t\t\t\tiri->string = gf_strdup(cur);\n\t\t\t\t\tiri->type = XMLRI_STRING;\n\t\t\t\t\tgf_list_add(l, iri);\n\t\t\t\t} else {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_list_add(l, gf_strdup(cur));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (sep2)\n\t\t\tsep2[0] = 0;\n\t\telse\n\t\t\tsep[0] = 0;\n\t\tif (is_iri) {\n\t\t\tGF_SAFEALLOC(iri, XMLRI);\n\t\t\tif (iri) {\n\t\t\t\tiri->string = gf_strdup(sep+1);\n\t\t\t\tiri->type = XMLRI_STRING;\n\t\t\t\tgf_list_add(l, iri);\n\t\t\t} else {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t}\n\t\t} else {\n\t\t\tgf_list_add(l, gf_strdup(sep+1));\n\t\t}\n\t\tif (sep2) {\n\t\t\tsep2[0] = '\\'';\n\t\t\tcur = sep2 + 1;\n\t\t} else {\n\t\t\tsep[0] = ';';\n\t\t\tcur = sep + 1;\n\t\t}\n\t}\n\tgf_free(text);\n}\n\nstatic void lsr_read_any_uri(GF_LASeRCodec *lsr, XMLRI *iri, const char *name)\n{\n\tu32 val;\n\tGF_LSR_READ_INT(lsr, val, 1, \"hasUri\");\n\tif (val) {\n\t\tchar *s = NULL;\n\t\tiri->type=XMLRI_STRING;\n\t\tif (iri->string) {\n\t\t\tgf_free(iri->string);\n\t\t\tiri->string = NULL;\n\t\t}\n\t\tlsr_read_byte_align_string(lsr, &s, \"uri\");\n\t\tGF_LSR_READ_INT(lsr, val, 1, \"hasData\");\n\t\tif (!val) {\n\t\t\tiri->string = s;\n\t\t} else {\n\t\t\tu32 len_rad, len;\n\t\t\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\t\t\tif (len > gf_bs_available(lsr->bs)) {\n\t\t\t\tlsr->last_error = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlen_rad = s ? (u32) strlen(s) : 0;\n\t\t\tiri->string = (char*)gf_malloc(sizeof(char)*(len_rad+1+len+1));\n\t\t\tif (!iri->string) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tiri->string[0] = 0;\n\t\t\tif (s) {\n\t\t\t\tstrcpy(iri->string, s);\n\t\t\t\tgf_free(s);\n\t\t\t}\n\t\t\tstrcat(iri->string, \",\");\n\t\t\tgf_bs_read_data(lsr->bs, iri->string + len_rad + 1, len);\n\t\t\tiri->string[len_rad + 1 + len] = 0;\n\t\t}\n\t}\n\tGF_LSR_READ_INT(lsr, val, 1, \"hasID\");\n\tif (val) lsr_read_codec_IDREF(lsr, iri, \"idref\");\n\n\tGF_LSR_READ_INT(lsr, val, 1, \"hasStreamID\");\n\tif (val) {\n\t\tiri->type = XMLRI_STREAMID;\n\t\tiri->lsr_stream_id = lsr_read_vluimsbf5(lsr, name);\n\t\tGF_LSR_READ_INT(lsr, val, 1, \"reserved\");\n\t\tif (val) {\n\t\t\tu32 len = lsr_read_vluimsbf5(lsr, \"len\");\n\t\t\tGF_LSR_READ_INT(lsr, val, len, \"reserved\");\n\t\t}\n\t}\n}\n\nstatic void lsr_read_paint(GF_LASeRCodec *lsr, SVG_Paint *paint, const char *name)\n{\n\tu32 val;\n\tGF_LSR_READ_INT(lsr, val, 1, \"hasIndex\");\n\tif (val) {\n\t\tGF_LSR_READ_INT(lsr, val, lsr->colorIndexBits, name);\n\t\tlsr_get_color(lsr, val, &paint->color);\n\t\tpaint->type = SVG_PAINT_COLOR;\n\t\tpaint->color.type = 0;\n\t} else {\n\t\tGF_LSR_READ_INT(lsr, val, 2, \"enum\");\n\t\tswitch (val) {\n\t\tcase 0:\n\t\t\tGF_LSR_READ_INT(lsr, val, 2, \"choice\");\n\t\t\tswitch (val) {\n\t\t\tcase 0:\n\t\t\t\tpaint->type = SVG_PAINT_INHERIT;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tpaint->type = SVG_PAINT_COLOR;\n\t\t\t\tpaint->color.type = SVG_COLOR_CURRENTCOLOR;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpaint->type = SVG_PAINT_NONE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t{\n\t\t\tXMLRI iri;\n\t\t\tmemset(&iri, 0, sizeof(XMLRI));\n\t\t\tiri.type = 0xFF;\n\t\t\tlsr_read_any_uri(lsr, &iri, name);\n\t\t\tgf_node_unregister_iri(lsr->sg, &iri);\n\t\t\tgf_list_del_item(lsr->deferred_hrefs, &iri);\n\n\t\t\tpaint->type = SVG_PAINT_URI;\n\t\t\tif (iri.string) {\n\t\t\t\tpaint->type = SVG_PAINT_URI;\n\t\t\t\tpaint->iri.type = XMLRI_STRING;\n\t\t\t\tpaint->iri.string = iri.string;\n\t\t\t} else if (iri.target) {\n\t\t\t\tpaint->iri.type = XMLRI_ELEMENTID;\n\t\t\t\tpaint->iri.target = iri.target;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 2:\n\t\t{\n\t\t\tchar *sysPaint=NULL;\n\t\t\tlsr_read_byte_align_string(lsr, &sysPaint, \"systemsPaint\");\n\t\t\tif (sysPaint) {\n\t\t\t\tpaint->type = SVG_PAINT_COLOR;\n\t\t\t\tpaint->color.type = gf_svg_get_system_paint_server_type(sysPaint);\n\t\t\t\tgf_free(sysPaint);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 3:\n\t\t\tlsr_read_extension(lsr, name);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void lsr_read_string_attribute(GF_LASeRCodec *lsr, GF_Node *elt, u32 tag, char *name)\n{\n\tu32 val;\n\tGF_LSR_READ_INT(lsr, val, 1, name);\n\tif (val) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, tag, GF_TRUE, GF_FALSE, &info);\n\t\tlsr_read_byte_align_string(lsr, info.far_ptr, name);\n\t}\n}\nstatic void lsr_read_id(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tGF_FieldInfo info;\n\tu32 val, id, i, count;\n\tchar *name;\n\tGF_LSR_READ_INT(lsr, val, 1, \"has_id\");\n\tif (!val) return;\n\n\tname = NULL;\n\tid = 1+lsr_read_vluimsbf5(lsr, \"ID\");\n\tgf_node_set_id(n, id, name);\n\n\tGF_LSR_READ_INT(lsr, val, 1, \"reserved\");\n\t/*currently not used*/\n\tif (val) {\n\t\tu32 len = lsr_read_vluimsbf5(lsr, \"len\");\n\t\tGF_LSR_READ_INT(lsr, val, len, \"reserved\");\n\t}\n\n\t/*update all pending HREFs*/\n\tcount = gf_list_count(lsr->deferred_hrefs);\n\tfor (i=0; i<count; i++) {\n\t\tXMLRI *href = (XMLRI *)gf_list_get(lsr->deferred_hrefs, i);\n\t\tchar *str_id = href ? href->string : NULL;\n\t\tif (!str_id) return;\n\t\t\n\t\tif (str_id[0] == '#') str_id++;\n\t\t/*skip 'N'*/\n\t\tstr_id++;\n\t\tif (id == (1 + (u32) atoi(str_id))) {\n\t\t\thref->target = (SVG_Element*) n;\n\t\t\tgf_free(href->string);\n\t\t\thref->string = NULL;\n\t\t\tgf_list_rem(lsr->deferred_hrefs, i);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t}\n\t}\n\n\t/*update unresolved listeners*/\n\tcount = gf_list_count(lsr->deferred_listeners);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Node *par;\n\t\tXMLRI *observer = NULL;\n\t\tGF_Node *listener = (GF_Node *)gf_list_get(lsr->deferred_listeners, i);\n\n\t\tpar = NULL;\n\t\tif (gf_node_get_attribute_by_tag(listener, TAG_XMLEV_ATT_observer, GF_FALSE, GF_FALSE, &info) == GF_OK) {\n\t\t\tobserver = (XMLRI*)info.far_ptr;\n\t\t\tif (observer->type == XMLRI_ELEMENTID) {\n\t\t\t\tif (!observer->target) continue;\n\t\t\t\telse par = (GF_Node*)observer->target;\n\t\t\t}\n\t\t}\n\t\tif (gf_node_get_attribute_by_tag(listener, TAG_XMLEV_ATT_target, GF_FALSE, GF_FALSE, &info) == GF_OK) {\n\t\t\tif (((XMLRI*)info.far_ptr)->type == XMLRI_ELEMENTID) {\n\t\t\t\tif (!((XMLRI*)info.far_ptr)->target) continue;\n\t\t\t\telse if (!par) par = (GF_Node*)((XMLRI*)info.far_ptr)->target;\n\t\t\t}\n\t\t}\n\t\t/*FIXME - double check with XML events*/\n\t\tif (!par && !observer) {\n\t\t\tif (gf_node_get_attribute_by_tag(listener, TAG_XMLEV_ATT_event, GF_FALSE, GF_FALSE, &info) == GF_OK) {\n\t\t\t\tXMLEV_Event *ev = (XMLEV_Event *)info.far_ptr;\n\t\t\t\t/*all non-UI get attched to root*/\n\t\t\t\tif (ev && (ev->type>GF_EVENT_MOUSEWHEEL)) {\n\t\t\t\t\tpar = (GF_Node*) lsr->current_root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tassert(par);\n\t\tgf_node_dom_listener_add(par, listener);\n\t\tgf_list_rem(lsr->deferred_listeners, i);\n\t\ti--;\n\t\tcount--;\n\t}\n\n\t/*update all pending animations*/\n\tcount = gf_list_count(lsr->deferred_anims);\n\tfor (i=0; i<count; i++) {\n\t\tSVG_Element *elt = (SVG_Element *)gf_list_get(lsr->deferred_anims, i);\n\t\tif (lsr_setup_smil_anim(lsr, elt, NULL)) {\n\t\t\tgf_list_rem(lsr->deferred_anims, i);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t\tgf_node_init((GF_Node*)elt);\n\t\t}\n\t}\n}\n\nstatic Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n{\n#ifdef GPAC_FIXED_POINT\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\tif (neg < -FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\tif (val > FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#else\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#endif\n}\n\nstatic Fixed lsr_translate_scale(GF_LASeRCodec *lsr, u32 val)\n{\n\tif (val >> (lsr->coord_bits-1) ) {\n\t\ts32 v = val - (1<<lsr->coord_bits);\n\t\treturn INT2FIX(v) / 256 ;\n\t} else {\n\t\treturn INT2FIX(val) / 256;\n\t}\n}\nstatic void lsr_read_matrix(GF_LASeRCodec *lsr, SVG_Transform *mx)\n{\n\tu32 flag;\n\tgf_mx2d_init(mx->mat);\n\tmx->is_ref = 0;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"isNotMatrix\");\n\tif (flag) {\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"isRef\");\n\t\tif (flag) {\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"hasXY\");\n\t\t\tif (flag) {\n\t\t\t\tmx->mat.m[2] = lsr_read_fixed_16_8(lsr, \"valueX\");\n\t\t\t\tmx->mat.m[5] = lsr_read_fixed_16_8(lsr, \"valueY\");\n\t\t\t}\n\t\t} else {\n\t\t\tlsr_read_extension(lsr, \"ext\");\n\t\t}\n\t} else {\n\t\tlsr->coord_bits += lsr->scale_bits;\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"xx_yy_present\");\n\t\tif (flag) {\n\t\t\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, \"xx\");\n\t\t\tmx->mat.m[0] = lsr_translate_scale(lsr, flag);\n\t\t\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, \"yy\");\n\t\t\tmx->mat.m[4] = lsr_translate_scale(lsr, flag);\n\t\t} else {\n\t\t\tmx->mat.m[0] = mx->mat.m[4] = FIX_ONE;\n\t\t}\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"xy_yx_present\");\n\t\tif (flag) {\n\t\t\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, \"xy\");\n\t\t\tmx->mat.m[1] = lsr_translate_scale(lsr, flag);\n\t\t\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, \"yx\");\n\t\t\tmx->mat.m[3] = lsr_translate_scale(lsr, flag);\n\t\t}\n\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"xz_yz_present\");\n\t\tif (flag) {\n\t\t\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, \"xz\");\n\t\t\tmx->mat.m[2] = lsr_translate_coords(lsr, flag, lsr->coord_bits);\n\t\t\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, \"yz\");\n\t\t\tmx->mat.m[5] = lsr_translate_coords(lsr, flag, lsr->coord_bits);\n\t\t}\n\t\tlsr->coord_bits -= lsr->scale_bits;\n\t}\n}\n\nstatic Fixed lsr_read_fixed_clamp(GF_LASeRCodec *lsr, const char *name)\n{\n\ts32 val;\n\tGF_LSR_READ_INT(lsr, val, 8, name);\n\treturn INT2FIX(val) / 255;\n}\n\nstatic void lsr_read_focus(GF_LASeRCodec *lsr, SVG_Focus *foc, const char *name)\n{\n\tu32 flag;\n\n\tif (foc->target.string) {\n\t\tgf_free(foc->target.string);\n\t\tfoc->target.string = NULL;\n\t}\n\tif (foc->target.target) foc->target.target = NULL;\n\tgf_node_unregister_iri(lsr->sg, &foc->target);\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"isEnum\");\n\tif (flag) {\n\t\tGF_LSR_READ_INT(lsr, foc->type, 1, \"enum\");\n\t} else {\n\t\tfoc->type = SVG_FOCUS_IRI;\n\t\tlsr_read_codec_IDREF(lsr, &foc->target, \"id\");\n\t}\n}\n\nstatic void lsr_restore_base(GF_LASeRCodec *lsr, SVG_Element *elt, SVG_Element *base, Bool reset_fill, Bool reset_stroke)\n{\n\tGF_Err e;\n\tGF_FieldInfo f_base, f_clone;\n\tSVGAttribute *att;\n\n\t/*clone all propertie from base*/\n\tatt = base->attributes;\n\twhile (att) {\n\t\tBool is_fill, is_stroke;\n\t\tis_fill = is_stroke = GF_FALSE;\n\t\tswitch (att->tag) {\n\t\t/*for all properties*/\n\t\tcase TAG_SVG_ATT_fill:\n\t\t\tis_fill = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke:\n\t\t\tis_stroke = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_audio_level:\n\t\tcase TAG_SVG_ATT_color:\n\t\tcase TAG_SVG_ATT_color_rendering:\n\t\tcase TAG_SVG_ATT_display:\n\t\tcase TAG_SVG_ATT_display_align:\n\t\tcase TAG_SVG_ATT_fill_opacity:\n\t\tcase TAG_SVG_ATT_fill_rule:\n\t\tcase TAG_SVG_ATT_font_family:\n\t\tcase TAG_SVG_ATT_font_size:\n\t\tcase TAG_SVG_ATT_font_style:\n\t\tcase TAG_SVG_ATT_font_variant:\n\t\tcase TAG_SVG_ATT_font_weight:\n\t\tcase TAG_SVG_ATT_image_rendering:\n\t\tcase TAG_SVG_ATT_line_increment:\n\t\tcase TAG_SVG_ATT_opacity:\n\t\tcase TAG_SVG_ATT_pointer_events:\n\t\tcase TAG_SVG_ATT_shape_rendering:\n\t\tcase TAG_SVG_ATT_solid_color:\n\t\tcase TAG_SVG_ATT_solid_opacity:\n\t\tcase TAG_SVG_ATT_stop_color:\n\t\tcase TAG_SVG_ATT_stop_opacity:\n\t\tcase TAG_SVG_ATT_stroke_dasharray:\n\t\tcase TAG_SVG_ATT_stroke_dashoffset:\n\t\tcase TAG_SVG_ATT_stroke_linecap:\n\t\tcase TAG_SVG_ATT_stroke_linejoin:\n\t\tcase TAG_SVG_ATT_stroke_miterlimit:\n\t\tcase TAG_SVG_ATT_stroke_opacity:\n\t\tcase TAG_SVG_ATT_stroke_width:\n\t\tcase TAG_SVG_ATT_text_align:\n\t\tcase TAG_SVG_ATT_text_anchor:\n\t\tcase TAG_SVG_ATT_text_rendering:\n\t\tcase TAG_SVG_ATT_vector_effect:\n\t\tcase TAG_SVG_ATT_viewport_fill:\n\t\tcase TAG_SVG_ATT_viewport_fill_opacity:\n\t\tcase TAG_SVG_ATT_visibility:\n\t\t/*and xml:_class*/\n\t\tcase TAG_SVG_ATT__class:\n\t\tcase TAG_SVG_ATT_externalResourcesRequired:\n\t\t\tbreak;\n\n\t\t/*pathLength for path*/\n\t\tcase TAG_SVG_ATT_pathLength:\n\t\t\tbreak;\n\t\t/*rx & ry for rect*/\n\t\tcase TAG_SVG_ATT_rx:\n\t\tcase TAG_SVG_ATT_ry:\n\t\t\tif (base->sgprivate->tag!=TAG_SVG_rect) {\n\t\t\t\tatt = att->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t/*x & y for use*/\n\t\tcase TAG_SVG_ATT_x:\n\t\tcase TAG_SVG_ATT_y:\n\t\t\tif (base->sgprivate->tag!=TAG_SVG_use) {\n\t\t\t\tatt = att->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t/*editable & rotate for text*/\n\t\tcase TAG_SVG_ATT_editable:\n\t\tcase TAG_SVG_ATT_rotate:\n\t\t\tif (base->sgprivate->tag!=TAG_SVG_text) {\n\t\t\t\tatt = att->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_transform:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tatt = att->next;\n\t\t\tcontinue;\n\t\t}\n\t\t/*clone field*/\n\t\te = gf_node_get_attribute_by_tag((GF_Node*)elt, att->tag, GF_TRUE, GF_FALSE, &f_clone);\n\t\tif (e) goto err_exit;\n\t\tf_base.fieldIndex = att->tag;\n\t\tf_base.fieldType = att->data_type;\n\t\tf_base.far_ptr = att->data;\n\t\te = gf_svg_attributes_copy(&f_clone, &f_base, GF_FALSE);\n\t\tif (e) goto err_exit;\n\n\t\tif (is_fill && reset_fill) {\n\t\t\tSVG_Paint*p = (SVG_Paint*)f_clone.far_ptr;\n\t\t\tif (p->iri.string) gf_free(p->iri.string);\n\t\t\tmemset(p, 0, sizeof(SVG_Paint));\n\t\t}\n\t\tif (is_stroke && reset_stroke) {\n\t\t\tSVG_Paint*p = (SVG_Paint*)f_clone.far_ptr;\n\t\t\tif (p->iri.string) gf_free(p->iri.string);\n\t\t\tmemset(p, 0, sizeof(SVG_Paint));\n\t\t}\n\t\tatt = att->next;\n\t}\n\treturn;\n\nerr_exit:\n\tlsr->last_error = e;\n}\n\n\nstatic u32 lsr_to_dom_key(u32 lsr_k)\n{\n\tswitch (lsr_k) {\n\tcase 0:\n\t\treturn GF_KEY_STAR;\n\tcase 1:\n\t\treturn GF_KEY_0;\n\tcase 2:\n\t\treturn GF_KEY_1;\n\tcase 3:\n\t\treturn GF_KEY_2;\n\tcase 4:\n\t\treturn GF_KEY_3;\n\tcase 5:\n\t\treturn GF_KEY_4;\n\tcase 6:\n\t\treturn GF_KEY_5;\n\tcase 7:\n\t\treturn GF_KEY_6;\n\tcase 8:\n\t\treturn GF_KEY_7;\n\tcase 9:\n\t\treturn GF_KEY_8;\n\tcase 10:\n\t\treturn GF_KEY_9;\n\tcase 12:\n\t\treturn GF_KEY_DOWN;\n\tcase 14:\n\t\treturn GF_KEY_LEFT;\n\tcase 16:\n\t\treturn GF_KEY_RIGHT;\n\tcase 20:\n\t\treturn GF_KEY_UP;\n\t/*WHAT IS ANY_KEY (11) ??*/\n\tcase 13:\n\t\treturn GF_KEY_ENTER;\n\tcase 15:\n\t\treturn GF_KEY_ESCAPE;\n\tcase 17:\n\t\treturn GF_KEY_NUMBER;\n\tcase 18:\n\t\treturn GF_KEY_CELL_SOFT1;\n\tcase 19:\n\t\treturn GF_KEY_CELL_SOFT2;\n\tdefault:\n\t\t/*use '*' by default ... */\n\t\treturn 0;\n\t}\n}\n\nstatic void lsr_read_event_type(GF_LASeRCodec *lsr, XMLEV_Event *evtType)\n{\n\tu32 flag;\n\tmemset(evtType, 0, sizeof(XMLEV_Event));\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"choice\");\n\tif (!flag) {\n\t\tchar *evtName, *sep;\n\t\tevtName = NULL;\n\t\tlsr_read_byte_align_string(lsr, &evtName, \"evtString\");\n\t\tevtType->type = evtType->parameter = 0;\n\t\tif (evtName) {\n\t\t\tsep = strchr(evtName, '(');\n\t\t\tif (sep) {\n\t\t\t\tchar *param;\n\t\t\t\tsep[0] = 0;\n\t\t\t\tevtType->type = gf_dom_event_type_by_name(evtName);\n\t\t\t\tsep[0] = '(';\n\t\t\t\tparam = sep+1;\n\t\t\t\tsep = strchr(evtName, ')');\n\t\t\t\tif (sep) sep[0]=0;\n\t\t\t\tif (evtType->type==GF_EVENT_REPEAT) {\n\t\t\t\t\tevtType->parameter = atoi(param);\n\t\t\t\t} else {\n\t\t\t\t\tevtType->parameter = gf_dom_get_key_type(param);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tevtType->type = gf_dom_event_type_by_name(evtName);\n\t\t\t}\n\t\t\tgf_free(evtName);\n\t\t}\n\t} else {\n\t\tevtType->parameter = 0;\n\t\tGF_LSR_READ_INT(lsr, flag, 6, \"event\");\n\t\tswitch (flag) {\n\t\tcase LSR_EVT_abort:\n\t\t\tevtType->type = GF_EVENT_ABORT;\n\t\t\tbreak;\n\t\tcase LSR_EVT_accessKey:\n\t\t\tevtType->type = GF_EVENT_KEYDOWN;\n\t\t\tbreak;\n\t\tcase LSR_EVT_activate:\n\t\t\tevtType->type = GF_EVENT_ACTIVATE;\n\t\t\tbreak;\n\t\tcase LSR_EVT_activatedEvent:\n\t\t\tevtType->type = GF_EVENT_ACTIVATED;\n\t\t\tbreak;\n\t\tcase LSR_EVT_beginEvent:\n\t\t\tevtType->type = GF_EVENT_BEGIN_EVENT;\n\t\t\tbreak;\n\t\tcase LSR_EVT_click:\n\t\t\tevtType->type = GF_EVENT_CLICK;\n\t\t\tbreak;\n\t\tcase LSR_EVT_deactivatedEvent:\n\t\t\tevtType->type = GF_EVENT_DEACTIVATED;\n\t\t\tbreak;\n\t\tcase LSR_EVT_endEvent:\n\t\t\tevtType->type = GF_EVENT_END_EVENT;\n\t\t\tbreak;\n\t\tcase LSR_EVT_error:\n\t\t\tevtType->type = GF_EVENT_ERROR;\n\t\t\tbreak;\n\t\tcase LSR_EVT_executionTime:\n\t\t\tevtType->type = GF_EVENT_EXECUTION_TIME;\n\t\t\tbreak;\n\t\tcase LSR_EVT_focusin:\n\t\t\tevtType->type = GF_EVENT_FOCUSIN;\n\t\t\tbreak;\n\t\tcase LSR_EVT_focusout:\n\t\t\tevtType->type = GF_EVENT_FOCUSOUT;\n\t\t\tbreak;\n\t\tcase LSR_EVT_keydown:\n\t\t\tevtType->type = GF_EVENT_KEYDOWN;\n\t\t\tbreak;\n\t\tcase LSR_EVT_keyup:\n\t\t\tevtType->type = GF_EVENT_KEYUP;\n\t\t\tbreak;\n\t\tcase LSR_EVT_load:\n\t\t\tevtType->type = GF_EVENT_LOAD;\n\t\t\tbreak;\n\t\tcase LSR_EVT_longAccessKey:\n\t\t\tevtType->type = GF_EVENT_LONGKEYPRESS;\n\t\t\tbreak;\n\t\tcase LSR_EVT_mousedown:\n\t\t\tevtType->type = GF_EVENT_MOUSEDOWN;\n\t\t\tbreak;\n\t\tcase LSR_EVT_mousemove:\n\t\t\tevtType->type = GF_EVENT_MOUSEMOVE;\n\t\t\tbreak;\n\t\tcase LSR_EVT_mouseout:\n\t\t\tevtType->type = GF_EVENT_MOUSEOUT;\n\t\t\tbreak;\n\t\tcase LSR_EVT_mouseover:\n\t\t\tevtType->type = GF_EVENT_MOUSEOVER;\n\t\t\tbreak;\n\t\tcase LSR_EVT_mouseup:\n\t\t\tevtType->type = GF_EVENT_MOUSEUP;\n\t\t\tbreak;\n\t\tcase LSR_EVT_pause:\n\t\t\tevtType->type = GF_EVENT_PAUSE;\n\t\t\tbreak;\n\t\tcase LSR_EVT_pausedEvent:\n\t\t\tevtType->type = GF_EVENT_PAUSED_EVENT;\n\t\t\tbreak;\n\t\tcase LSR_EVT_play:\n\t\t\tevtType->type = GF_EVENT_PLAY;\n\t\t\tbreak;\n\t\tcase LSR_EVT_repeatEvent:\n\t\t\tevtType->type = GF_EVENT_REPEAT_EVENT;\n\t\t\tbreak;\n\t\tcase LSR_EVT_repeatKey:\n\t\t\tevtType->type = GF_EVENT_REPEAT_KEY;\n\t\t\tbreak;\n\t\tcase LSR_EVT_resize:\n\t\t\tevtType->type = GF_EVENT_RESIZE;\n\t\t\tbreak;\n\t\tcase LSR_EVT_resumedEvent:\n\t\t\tevtType->type = GF_EVENT_RESUME_EVENT;\n\t\t\tbreak;\n\t\tcase LSR_EVT_scroll:\n\t\t\tevtType->type = GF_EVENT_SCROLL;\n\t\t\tbreak;\n\t\tcase LSR_EVT_shortAccessKey:\n\t\t\tevtType->type = GF_EVENT_SHORT_ACCESSKEY;\n\t\t\tbreak;\n\t\tcase LSR_EVT_textinput:\n\t\t\tevtType->type = GF_EVENT_TEXTINPUT;\n\t\t\tbreak;\n\t\tcase LSR_EVT_unload:\n\t\t\tevtType->type = GF_EVENT_UNLOAD;\n\t\t\tbreak;\n\t\tcase LSR_EVT_zoom:\n\t\t\tevtType->type = GF_EVENT_ZOOM;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[LASeR] Undefined LASeR event %d\\n\", flag));\n\t\t\tbreak;\n\t\t}\n\t\tswitch (flag) {\n\t\tcase LSR_EVT_accessKey:\n\t\tcase LSR_EVT_longAccessKey:\n\t\tcase LSR_EVT_repeatKey:\n\t\tcase LSR_EVT_shortAccessKey:\n\t\t\tevtType->parameter = lsr_read_vluimsbf5(lsr, \"keyCode\");\n\t\t\tevtType->parameter  = lsr_to_dom_key(evtType->parameter);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic SMIL_Time *lsr_read_smil_time(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tSMIL_Time *t;\n\tu32 val;\n\n\tGF_SAFEALLOC(t, SMIL_Time);\n\tif (!t) {\n\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\treturn NULL;\n\t}\n\tt->type = GF_SMIL_TIME_CLOCK;\n\n\tGF_LSR_READ_INT(lsr, val, 1, \"hasEvent\");\n\tif (val) {\n\t\tt->type = GF_SMIL_TIME_EVENT;\n\t\tGF_LSR_READ_INT(lsr, val, 1, \"hasIdentifier\");\n\t\tif (val) {\n\t\t\tXMLRI iri;\n\t\t\tiri.type = 0xFF;\n\t\t\tiri.string = NULL;\n\t\t\tlsr_read_codec_IDREF(lsr, &iri, \"idref\");\n\t\t\tgf_node_unregister_iri(lsr->sg, &iri);\n\t\t\tif (iri.string) {\n\t\t\t\tt->element_id = iri.string;\n\t\t\t} else {\n\t\t\t\tt->element = (GF_Node *)iri.target;\n\t\t\t}\n\t\t}\n\t\tlsr_read_event_type(lsr, &t->event);\n\t\tif (t->event.type==GF_EVENT_EXECUTION_TIME) {\n\t\t\tt->type = GF_SMIL_TIME_CLOCK;\n\t\t\tt->clock = gf_node_get_scene_time(n);\n\t\t}\n\t}\n\tGF_LSR_READ_INT(lsr, val, 1, \"hasClock\");\n\tif (val) {\n\t\tu32 now;\n\t\tGF_LSR_READ_INT(lsr, val, 1, \"sign\");\n\t\tnow = lsr_read_vluimsbf5(lsr, \"value\");\n\t\tt->clock = now;\n\t\tt->clock /= lsr->time_resolution;\n\t\tif (val) t->clock *= -1;\n\t}\n\treturn t;\n}\n\nstatic void lsr_read_smil_times(GF_LASeRCodec *lsr, GF_Node *n, u32 tag, SMIL_Times *times, const char *name, Bool skipable)\n{\n\tGF_FieldInfo info;\n\tSMIL_Time *v;\n\tu32 val, i, count;\n\n\tif (skipable) {\n\t\tGF_LSR_READ_INT(lsr, val, 1, name);\n\t\tif (!val) return;\n\t}\n\tif (!times) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, tag, GF_TRUE, GF_FALSE, &info);\n\t\ttimes = (SMIL_Times*)info.far_ptr;\n\t}\n\n\twhile (gf_list_count(*times)) {\n\t\tv = (SMIL_Time *)gf_list_last(*times);\n\t\tgf_list_rem_last(*times);\n\t\tif (v->element_id) gf_free(v->element_id);\n\t\tgf_free(v);\n\t}\n\n\tGF_LSR_READ_INT(lsr, val, 1, \"choice\");\n\tif (val) {\n\t\tGF_SAFEALLOC(v, SMIL_Time);\n\t\tif (v) {\n\t\t\tv->type = GF_SMIL_TIME_INDEFINITE;\n\t\t\tgf_list_add(*times, v);\n\t\t} else {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t}\n\t\treturn;\n\t}\n\tcount = lsr_read_vluimsbf5(lsr, \"count\");\n\tfor (i=0; i<count; i++) {\n\t\tv = lsr_read_smil_time(lsr, n);\n\t\tgf_list_add(*times, v);\n\t\tif (lsr->last_error) return;\n\t}\n}\n\nstatic void lsr_read_duration_ex(GF_LASeRCodec *lsr, GF_Node *n, u32 tag, SMIL_Duration *smil, const char *name, Bool skipable)\n{\n\tGF_FieldInfo info;\n\tu32 val = 1;\n\n\tif (skipable) {\n\t\tGF_LSR_READ_INT(lsr, val, 1, name);\n\t\tif (!val) return;\n\t}\n\tif (!smil) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, tag, GF_TRUE, GF_FALSE, &info);\n\t\tif (lsr->last_error) return;\n\t\tsmil = (SMIL_Duration *)info.far_ptr;\n\t}\n\tsmil->type = 0;\n\tsmil->clock_value=0;\n\n\tGF_LSR_READ_INT(lsr, val, 1, \"choice\");\n\tif (val) {\n\t\tGF_LSR_READ_INT(lsr, smil->type, 2, \"time\");\n\t} else {\n\t\tBool sign;\n\t\tu32 now;\n\t\tGF_LSR_READ_INT(lsr, sign, 1, \"sign\");\n\t\tnow = lsr_read_vluimsbf5(lsr, \"value\");\n\t\tsmil->clock_value = now;\n\t\tsmil->clock_value /= lsr->time_resolution;\n\t\tif (sign) smil->clock_value *= -1;\n\t\tsmil->type = SMIL_DURATION_DEFINED;\n\t}\n}\nstatic void lsr_read_duration(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tlsr_read_duration_ex(lsr, n, TAG_SVG_ATT_dur, NULL, \"dur\", GF_TRUE);\n}\n/*TODO Add decent error checking...*/\nstatic void lsr_read_rare_full(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tGF_FieldInfo info;\n\tu32 i, nb_rare, field_rare;\n\ts32 field_tag;\n\n\tGF_LSR_READ_INT(lsr, nb_rare, 1, \"has_rare\");\n\tif (!nb_rare) return;\n\tGF_LSR_READ_INT(lsr, nb_rare, 6, \"nbOfAttributes\");\n\n\tfor (i=0; i<nb_rare; i++) {\n\t\tGF_LSR_READ_INT(lsr, field_rare, 6, \"attributeRARE\");\n\n\t\t/*lsr extend*/\n\t\tif (field_rare==49) {\n\t\t\tu32 extID, len, j;\n\t\t\twhile (1) {\n\t\t\t\tGF_LSR_READ_INT(lsr, extID, lsr->info->cfg.extensionIDBits, \"extensionID\");\n\t\t\t\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\t\t\t\tif (extID==2) {\n\t\t\t\t\tGF_LSR_READ_INT(lsr, len, 2, \"nbOfAttributes\");\n\t\t\t\t\tfor (j=0; j<len; j++) {\n\t\t\t\t\t\tGF_LSR_READ_INT(lsr, extID, 3, \"attributeRARE\");\n\t\t\t\t\t\tswitch (extID) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_syncMaster, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, \"syncMaster\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_focusHighlight, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FocusHighlight *)info.far_ptr, 2, \"focusHighlight\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_initialVisibility, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_InitialVisibility *)info.far_ptr, 2, \"initialVisibility\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_fullscreen, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, \"fullscreen\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_requiredFonts, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List **)info.far_ptr, \"requiredFonts\", GF_FALSE, GF_TRUE);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_read_int(lsr->bs, len);\n\t\t\t\t}\n\t\t\t\tGF_LSR_READ_INT(lsr, extID, 1, \"hasNextExtension\");\n\t\t\t\tif (!extID) break;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfield_tag = gf_lsr_rare_type_to_attribute(field_rare);\n\t\tif (field_tag==-1) {\n\t\t\treturn;\n\t\t}\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, field_tag, GF_TRUE, GF_FALSE, &info);\n\t\tif (!info.far_ptr) lsr->last_error = GF_NOT_SUPPORTED;\n\t\tif (lsr->last_error) return;\n\n\t\tswitch (field_tag) {\n\t\tcase TAG_SVG_ATT__class:\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"class\");\n\t\t\tbreak;\n\t\t/*properties*/\n\t\tcase TAG_SVG_ATT_audio_level:\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"audio-level\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_color:\n\t\t\tlsr_read_paint(lsr, (SVG_Paint *)info.far_ptr, \"color\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_color_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, \"color-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_display:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Display*)info.far_ptr, 5, \"display\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_display_align:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_DisplayAlign*)info.far_ptr, 3, \"display-align\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_fill_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"fill-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_fill_rule:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FillRule*)info.far_ptr, 2, \"fill-rule\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_image_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, \"image-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_line_increment:\n\t\t\tlsr_read_line_increment_type(lsr, info.far_ptr, \"line-increment\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_pointer_events:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_PointerEvents*)info.far_ptr, 4, \"pointer-events\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_shape_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, \"shape-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_solid_color:\n\t\t\tlsr_read_paint(lsr, info.far_ptr, \"solid-color\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_solid_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"solid-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stop_color:\n\t\t\tlsr_read_paint(lsr, info.far_ptr, \"stop-color\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stop_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"stop-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_dasharray:\n\t\t{\n\t\t\tu32 j, flag;\n\t\t\tSVG_StrokeDashArray *da = (SVG_StrokeDashArray *)info.far_ptr;\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"dashArray\");\n\t\t\tif (flag) {\n\t\t\t\tda->type=SVG_STROKEDASHARRAY_INHERIT;\n\t\t\t} else {\n\t\t\t\tda->type=SVG_STROKEDASHARRAY_ARRAY;\n\t\t\t\tda->array.count = lsr_read_vluimsbf5(lsr, \"len\");\n\t\t\t\tda->array.vals = (Fixed*)gf_malloc(sizeof(Fixed)*da->array.count);\n\t\t\t\tda->array.units = (u8*)gf_malloc(sizeof(u8)*da->array.count);\n\t\t\t\tif (!da->array.vals || !da->array.units) {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor (j=0; j<da->array.count; j++) {\n\t\t\t\t\tda->array.vals[j] = lsr_read_fixed_16_8(lsr, \"dash\");\n\t\t\t\t\tda->array.units[j] = 0;\n\t\t\t\t\tif (lsr->last_error) return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_dashoffset:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"dashOffset\");\n\t\t\tbreak;\n\n\t\tcase TAG_SVG_ATT_stroke_linecap:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_StrokeLineCap*)info.far_ptr, 2, \"stroke-linecap\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_linejoin:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_StrokeLineJoin*)info.far_ptr, 2, \"stroke-linejoin\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_miterlimit:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"miterLimit\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"stroke-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_width:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"strokeWidth\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_text_anchor:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_TextAnchor*)info.far_ptr, 2, \"text-achor\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_text_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, \"text-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_viewport_fill:\n\t\t\tlsr_read_paint(lsr, info.far_ptr, \"viewport-fill\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_viewport_fill_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"viewport-fill-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_vector_effect:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_VectorEffect*)info.far_ptr, 4, \"vector-effect\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_visibility:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Visibility*)info.far_ptr, 2, \"visibility\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_requiredExtensions:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"requiredExtensions\", GF_TRUE, GF_FALSE);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_requiredFormats:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"requiredFormats\", GF_FALSE, GF_FALSE);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_requiredFeatures:\n\t\t{\n\t\t\tu32 j, fcount = lsr_read_vluimsbf5(lsr, \"count\");\n\t\t\tfor (j=0; j<fcount; j++) {\n\t\t\t\tu32 fval;\n\t\t\t\tGF_LSR_READ_INT(lsr, fval, 6, \"feature\");\n\t\t\t\tif (lsr->last_error) return;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TAG_SVG_ATT_systemLanguage:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"systemLanguage\", GF_FALSE, GF_FALSE);\n\t\t\tbreak;\n\t\tcase TAG_XML_ATT_base:\n\t\t\tlsr_read_byte_align_string(lsr, &((XMLRI*)info.far_ptr)->string, \"xml:base\");\n\t\t\t((XMLRI*)info.far_ptr)->type = XMLRI_STRING;\n\t\t\tbreak;\n\t\tcase TAG_XML_ATT_lang:\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"xml:lang\");\n\t\t\tbreak;\n\t\tcase TAG_XML_ATT_space:\n\t\t\tGF_LSR_READ_INT(lsr, *(XML_Space*)info.far_ptr, 1, \"xml:space\");\n\t\t\tbreak;\n\t\t/*focusable*/\n\t\tcase TAG_SVG_ATT_nav_next:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNext\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_up:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNorth\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_up_left:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNorthEast\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_up_right:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNorthWest\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_prev:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusPrev\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_down:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusSouth\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_down_left:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusSouthEast\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_down_right:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusSouthWest\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_left:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusEast\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_focusable:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Focusable*)info.far_ptr, 2, \"focusable\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_right:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusWest\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_transform:\n\t\t\tlsr_read_matrix(lsr, info.far_ptr);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_text_decoration:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"textDecoration\", GF_FALSE, GF_FALSE);\n\t\t\tbreak;\n\n\t\tcase TAG_SVG_ATT_font_variant:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FontVariant*)info.far_ptr, 2, \"font-variant\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_family:\n\t\t{\n\t\t\tu32 flag;\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"isInherit\");\n\t\t\tif (flag) {\n\t\t\t\t((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_INHERIT;\n\t\t\t} else {\n\t\t\t\tchar *ft;\n\t\t\t\t((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_VALUE;\n\t\t\t\tGF_LSR_READ_INT(lsr, flag, lsr->fontIndexBits, \"fontIndex\");\n\t\t\t\tft = (char*)gf_list_get(lsr->font_table, flag);\n\t\t\t\tif (ft) ((SVG_FontFamily*)info.far_ptr)->value = gf_strdup(ft);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_size:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"fontSize\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_style:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FontStyle*)info.far_ptr, 3, \"fontStyle\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_weight:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FontWeight*)info.far_ptr, 4, \"fontWeight\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_title:\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"xlink:title\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_type:\n\t\t\t/*TODO FIXME*/\n\t\t\tGF_LSR_READ_INT(lsr, field_rare, 3, \"xlink:type\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_role:\n\t\t\tlsr_read_any_uri(lsr, info.far_ptr, \"xlink:role\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_arcrole:\n\t\t\tlsr_read_any_uri(lsr, info.far_ptr, \"xlink:arcrole\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_actuate:\n\t\t\t/*TODO FIXME*/\n\t\t\tGF_LSR_READ_INT(lsr, field_rare, 2, \"xlink:actuate\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_show:\n\t\t\t/*TODO FIXME*/\n\t\t\tGF_LSR_READ_INT(lsr, field_rare, 3, \"xlink:show\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_end:\n\t\t\tlsr_read_smil_times(lsr, NULL, 0, info.far_ptr, \"end\", 0);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_max:\n\t\t\tlsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, \"min\", 0);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_min:\n\t\t\tlsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, \"min\", 0);\n\t\t\tbreak;\n\t\t}\n\t\tif (lsr->last_error) return;\n\t}\n}\n\n#define lsr_read_rare(_a, _b) lsr_read_rare_full(_a, _b)\n\nstatic void lsr_read_fill(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tBool has_fill;\n\tGF_LSR_READ_INT(lsr, has_fill, 1, \"fill\");\n\tif (has_fill) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_fill, GF_TRUE, GF_FALSE, &info);\n\t\tlsr_read_paint(lsr, info.far_ptr, \"fill\");\n\t}\n}\n\nstatic void lsr_read_stroke(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tBool has_stroke;\n\tGF_LSR_READ_INT(lsr, has_stroke, 1, \"has_stroke\");\n\tif (has_stroke) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_stroke, GF_TRUE, GF_FALSE, &info);\n\t\tlsr_read_paint(lsr, info.far_ptr, \"stroke\");\n\t}\n}\nstatic void lsr_read_href(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tBool has_href;\n\tGF_LSR_READ_INT(lsr, has_href, 1, \"has_href\");\n\tif (has_href) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_XLINK_ATT_href, GF_TRUE, GF_FALSE, &info);\n\t\tlsr_read_any_uri(lsr, info.far_ptr, \"href\");\n\t}\n}\n\nstatic void lsr_read_accumulate(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tBool v;\n\tGF_LSR_READ_INT(lsr, v, 1, \"has_accumulate\");\n\tif (v) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_accumulate, GF_TRUE, GF_FALSE, &info);\n\t\tGF_LSR_READ_INT(lsr, *(SMIL_Accumulate*)info.far_ptr, 1, \"accumulate\");\n\t}\n}\nstatic void lsr_read_additive(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tBool v;\n\tGF_LSR_READ_INT(lsr, v, 1, \"has_additive\");\n\tif (v) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_additive, GF_TRUE, GF_FALSE, &info);\n\t\tGF_LSR_READ_INT(lsr, *(SMIL_Additive*)info.far_ptr, 1, \"additive\");\n\t}\n}\nstatic void lsr_read_calc_mode(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 v;\n\t/*SMIL_CALCMODE_LINEAR is default and 0 in our code*/\n\tGF_LSR_READ_INT(lsr, v, 1, \"has_calcMode\");\n\tif (v) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_calcMode, GF_TRUE, GF_FALSE, &info);\n\t\tGF_LSR_READ_INT(lsr, *(SMIL_CalcMode*)info.far_ptr, 2, \"calcMode\");\n\t}\n}\n\nstatic void lsr_read_attribute_name_ex(GF_LASeRCodec *lsr, GF_Node *n, Bool skippable)\n{\n\tu32 val = 1;\n\tif (skippable) {\n\t\tGF_LSR_READ_INT(lsr, val, 1, \"hasAttributeName\");\n\t\tif (!val) return;\n\t}\n\n\tGF_LSR_READ_INT(lsr, val, 1, \"choice\");\n\tif (val) {\n\t\tlsr_read_vluimsbf5(lsr, \"item[i]\");\n\t\tlsr_read_vluimsbf5(lsr, \"item[i]\");\n\t\treturn;\n\t} else {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_attributeName, GF_TRUE, GF_FALSE, &info);\n\t\tGF_LSR_READ_INT(lsr, val, 8, \"attributeType\");\n\n\t\t/*translate type to attribute tag*/\n\t\t((SMIL_AttributeName*)info.far_ptr)->type = gf_lsr_anim_type_to_attribute(val);\n\t}\n}\nstatic void lsr_read_attribute_name(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tlsr_read_attribute_name_ex(lsr, n, GF_TRUE);\n}\n\nstatic void lsr_delete_anim_value(GF_LASeRCodec *lsr, SMIL_AnimateValue *val, u32 coded_type)\n{\n\t//unable to transform, free mem and reset\n\tswitch (coded_type) {\n\tcase 0://SVG_string *\n\t\tgf_free(* (SVG_String *)val->value);\n\t\tgf_free(val->value);\n\t\tbreak;\n\tcase 1://SVG_Number *\n\t\tgf_free(val->value);\n\t\tbreak;\n\tcase 2: //SVG_PathData *\n\t\tgf_svg_delete_attribute_value(SVG_PathData_datatype, val->value, NULL);\n\t\tbreak;\n\tcase 3: //SVG_Points *pts\n\t\tgf_svg_delete_attribute_value(SVG_Points_datatype, val->value, NULL);\n\t\tbreak;\n\tcase 4: //SVG_Number*\n\t\tgf_free(val->value);\n\t\tbreak;\n\tcase 5://SVG_Paint\n\t\tgf_free(val->value);\n\t\tbreak;\n\tcase 6://u8*\n\t\tgf_free(val->value);\n\t\tbreak;\n\tcase 7: //list of u8 *\n\tcase 8: //list of floats\n\t\t{\n\t\t\tGF_List *l = (GF_List *) val->value;\n\t\t\twhile (gf_list_count(l)) {\n\t\t\t\tvoid *v = gf_list_pop_back(l);\n\t\t\t\tgf_free(v);\n\t\t\t}\n\t\t\tgf_list_del(l);\n\t\t}\n\t\tbreak;\n\t/*point */\n\tcase 9: //SVG_Point *\n\t\tgf_free(val->value);\n\t\tbreak;\n\tcase 10: //u32 *\n\t\tgf_free(val->value);\n\t\tbreak;\n\tcase 11: //SVG_FontFamily *\n\t{\n\t\tSVG_FontFamily *ft = (SVG_FontFamily *) val->value;\n\t\tif (ft->value) gf_free(ft->value);\n\t\tgf_free(ft);\n\t}\n\t\tbreak;\n\tcase 12:\n\t{\n\t\tXMLRI *iri = (XMLRI *)val->value;\n\t\tgf_list_del_item(lsr->deferred_hrefs, iri);\n\t\tgf_node_unregister_iri(lsr->sg, iri);\n\t\tif (iri->string) gf_free(iri->string);\n\t\tgf_free(iri);\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tval->value = NULL;\n}\n\nstatic void lsr_translate_anim_value(GF_LASeRCodec *lsr, SMIL_AnimateValue *val, u32 coded_type)\n{\n\tswitch (val->type) {\n\tcase SVG_StrokeDashArray_datatype:\n\t\t//if list of fixed only\n\t\tif (coded_type == 8) {\n\t\t\tSVG_StrokeDashArray *da;\n\t\t\tGF_List *l = (GF_List *)val->value;\n\t\t\tu32 i;\n\t\t\tGF_SAFEALLOC(da, SVG_StrokeDashArray);\n\t\t\tif (!da) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tda->array.count = gf_list_count(l);\n\t\t\tif (!da->array.count) {\n\t\t\t\tda->type = SVG_STROKEDASHARRAY_INHERIT;\n\t\t\t} else {\n\t\t\t\tda->type = SVG_STROKEDASHARRAY_ARRAY;\n\t\t\t\tda->array.vals = (Fixed *) gf_malloc(sizeof(Fixed)*da->array.count);\n\t\t\t\tda->array.units = (u8 *) gf_malloc(sizeof(u8)*da->array.count);\n\t\t\t\tif (!da->array.vals || !da->array.units) {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor (i=0; i<da->array.count; i++) {\n\t\t\t\t\tFixed *v = (Fixed *)gf_list_get(l, i);\n\t\t\t\t\tda->array.vals[i] = *v;\n\t\t\t\t\tda->array.units[i] = 0;\n\t\t\t\t\tgf_free(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_del(l);\n\t\t\tval->value = da;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase SVG_ViewBox_datatype:\n\t\t//if list of fixed only\n\t\tif (coded_type == 8) {\n\t\t\tSVG_ViewBox *vb;\n\t\t\tGF_List *l = (GF_List *)val->value;\n\t\t\tGF_SAFEALLOC(vb, SVG_ViewBox);\n\t\t\tif (!vb) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (gf_list_count(l)==4) {\n\t\t\t\tvb->x = * ((Fixed *)gf_list_get(l, 0));\n\t\t\t\tvb->y = * ((Fixed *)gf_list_get(l, 1));\n\t\t\t\tvb->width = * ((Fixed *)gf_list_get(l, 2));\n\t\t\t\tvb->height = * ((Fixed *)gf_list_get(l, 3));\n\t\t\t}\n\t\t\twhile (gf_list_count(l)) {\n\t\t\t\tFixed *v = (Fixed *)gf_list_last(l);\n\t\t\t\tgf_free(v);\n\t\t\t\tgf_list_rem_last(l);\n\t\t\t}\n\t\t\tgf_list_del(l);\n\t\t\tval->value = vb;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase SVG_Coordinates_datatype:\n\t{\n\t\tSVG_Coordinates *coords;\n\t\tif (coded_type==1) {\n\t\t\tGF_List *l = gf_list_new();\n\t\t\t/*allocated value is already an SVG number*/\n\t\t\tgf_list_add(l, val->value);\n\t\t\tcoords = (SVG_Coordinates*)gf_malloc(sizeof(SVG_Coordinates));\n\t\t\tif (!coords) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\t*coords = l;\n\t\t\t\tval->value = coords;\n\t\t\t}\n\t\t\treturn;\n\t\t} else if (coded_type==8) {\n\t\t\tGF_List *l = (GF_List *)val->value;\n\t\t\tu32 i, count = gf_list_count(l);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tSVG_Coordinate *c;\n\t\t\t\tFixed *v = (Fixed *)gf_list_get(l, i);\n\t\t\t\tc = (SVG_Coordinate*)gf_malloc(sizeof(SVG_Coordinate));\n\t\t\t\tif (!c) {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t} else {\n\t\t\t\t\tc->type = SVG_NUMBER_VALUE;\n\t\t\t\t\tc->value = *v;\n\t\t\t\t}\n\t\t\t\tgf_free(v);\n\t\t\t\tgf_list_rem(l, i);\n\t\t\t\tif (c)\n\t\t\t\t\tgf_list_insert(l, c, i);\n\t\t\t}\n\t\t\tcoords = (SVG_Coordinates*)gf_malloc(sizeof(SVG_Coordinates));\n\t\t\tif (!coords) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\t*coords = (GF_List *) val->value;\n\t\t\t\tval->value = coords;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\t\tbreak;\n\tcase SVG_Motion_datatype:\n\t\tif (coded_type==9) {\n\t\t\tGF_Matrix2D *mat;\n\t\t\tSVG_Point *pt = (SVG_Point *)val->value;\n\t\t\tGF_SAFEALLOC(mat, GF_Matrix2D);\n\t\t\tif (mat) {\n\t\t\t\tgf_mx2d_init(*mat);\n\t\t\t\tmat->m[2] = pt->x;\n\t\t\t\tmat->m[5] = pt->y;\n\t\t\t\tval->value = mat;\n\t\t\t} else {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tgf_free(pt);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tlsr_delete_anim_value(lsr, val, coded_type);\n}\n\n\nstatic void lsr_translate_anim_values(GF_LASeRCodec *lsr, SMIL_AnimateValues *val, u32 coded_type)\n{\n\tu32 i, count;\n\tBool handled = GF_FALSE;\n\tGF_List *list, *new_list;\n\n\tlist = val->values;\n\tswitch (val->type) {\n\tcase SVG_StrokeDashArray_datatype:\n\t\tif (coded_type == 8) handled = GF_TRUE;\n\t\tbreak;\n\tcase SVG_ViewBox_datatype:\n\t\tif (coded_type == 8) handled = GF_TRUE;\n\t\tbreak;\n\tcase SVG_Coordinates_datatype:\n\t\tif (coded_type == 8) handled = GF_TRUE;\n\t\tbreak;\n\tcase SVG_Motion_datatype:\n\t\tif (coded_type==9) handled = GF_TRUE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!handled) {\n\t\twhile (gf_list_count(list)) {\n\t\t\tSMIL_AnimateValue a_val;\n\t\t\ta_val.type = 0;\n\t\t\ta_val.value = gf_list_pop_back(list);\n\t\t\tlsr_delete_anim_value(lsr, &a_val, coded_type);\n\t\t}\n\t\tgf_list_del(list);\n\t\tval->values = gf_list_new();\n\t\treturn;\n\t}\n\n\tval->values = new_list = gf_list_new();\n\tcount = gf_list_count(list);\n\tfor (i=0; i<count; i++) {\n\t\tswitch (val->type) {\n\t\tcase SVG_StrokeDashArray_datatype:\n\t\t{\n\t\t\tSVG_StrokeDashArray *da;\n\t\t\tGF_List *l = (GF_List *)gf_list_get(list, i);\n\t\t\tu32 j;\n\t\t\tGF_SAFEALLOC(da, SVG_StrokeDashArray);\n\t\t\tif (!da) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tda->array.count = gf_list_count(l);\n\t\t\tif (!da->array.count) {\n\t\t\t\tda->type = SVG_STROKEDASHARRAY_INHERIT;\n\t\t\t} else {\n\t\t\t\tda->type = SVG_STROKEDASHARRAY_ARRAY;\n\t\t\t\tda->array.vals = (Fixed *)gf_malloc(sizeof(Fixed)*da->array.count);\n\t\t\t\tda->array.units = (u8 *) gf_malloc(sizeof(u8)*da->array.count);\n\t\t\t\tif (!da->array.vals || !da->array.units) {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor (j=0; j<da->array.count; j++) {\n\t\t\t\t\tFixed *v = (Fixed *)gf_list_get(l, j);\n\t\t\t\t\tda->array.vals[j] = *v;\n\t\t\t\t\tda->array.units[j] = 0;\n\t\t\t\t\tgf_free(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_del(l);\n\t\t\tgf_list_add(new_list, da);\n\t\t}\n\t\tbreak;\n\t\tcase SVG_ViewBox_datatype:\n\t\t{\n\t\t\tSVG_ViewBox *vb;\n\t\t\tGF_List *l = (GF_List *)gf_list_get(list, i);\n\t\t\tGF_SAFEALLOC(vb, SVG_ViewBox);\n\t\t\tif (!vb) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (gf_list_count(l)==4) {\n\t\t\t\tvb->x = * ((Fixed *)gf_list_get(l, 0));\n\t\t\t\tvb->y = * ((Fixed *)gf_list_get(l, 1));\n\t\t\t\tvb->width = * ((Fixed *)gf_list_get(l, 2));\n\t\t\t\tvb->height = * ((Fixed *)gf_list_get(l, 3));\n\t\t\t}\n\t\t\twhile (gf_list_count(l)) {\n\t\t\t\tFixed *v=(Fixed *)gf_list_last(l);\n\t\t\t\tgf_free(v);\n\t\t\t\tgf_list_rem_last(l);\n\t\t\t}\n\t\t\tgf_list_del(l);\n\t\t\tgf_list_add(new_list, vb);\n\t\t}\n\t\tbreak;\n\t\tcase SVG_Coordinates_datatype:\n\t\t{\n\t\t\tSVG_Coordinates *coords;\n\t\t\tGF_List *l = (GF_List *)gf_list_get(list, i);\n\t\t\tu32 j, count2;\n\t\t\tcount2 = gf_list_count(l);\n\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\tFixed *v = (Fixed *)gf_list_get(l, j);\n\t\t\t\tSVG_Coordinate *c = (SVG_Coordinate *)gf_malloc(sizeof(SVG_Coordinate));\n\t\t\t\tif (!c) {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t} else {\n\t\t\t\t\tc->type = SVG_NUMBER_VALUE;\n\t\t\t\t\tc->value = *v;\n\t\t\t\t}\n\t\t\t\tgf_list_rem(l, j);\n\t\t\t\tgf_free(v);\n\t\t\t\tif (c)\n\t\t\t\t\tgf_list_insert(l, c, j);\n\t\t\t}\n\n\t\t\tcoords = (SVG_Coordinates*)gf_malloc(sizeof(SVG_Coordinates));\n\t\t\tif (!coords) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\t*coords = l;\n\t\t\t\tgf_list_add(new_list, coords);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase SVG_Motion_datatype:\n \t\t{\n\t\t\tGF_Point2D *pt = (GF_Point2D *)gf_list_get(list, i);\n\t\t\tGF_Matrix2D *m = (GF_Matrix2D *)gf_malloc(sizeof(GF_Matrix2D ));\n\t\t\tif (!m) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\tgf_mx2d_init(*m);\n\t\t\t\tm->m[2] = pt->x;\n\t\t\t\tm->m[5] = pt->y;\n\t\t\t\tgf_list_add(new_list, m);\n\t\t\t}\n\t\t\tgf_free(pt);\n\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_list_del(list);\n}\n\nstatic Bool lsr_init_smil_times(GF_LASeRCodec *lsr, SVG_Element *anim, GF_List *times, SVG_Element *parent)\n{\n\tu32 i, count;\n\tcount = gf_list_count(times);\n\tfor (i=0; i<count; i++) {\n\t\tSMIL_Time *t = (SMIL_Time *)gf_list_get(times, i);\n\t\tif (t->type==GF_SMIL_TIME_EVENT) {\n\t\t\tif (t->element_id) {\n\t\t\t\tif (t->element_id[0]=='N') {\n\t\t\t\t\tt->element = gf_sg_find_node(lsr->sg, atoi(t->element_id+1) + 1);\n\t\t\t\t} else {\n\t\t\t\t\tt->element = gf_sg_find_node_by_name(lsr->sg, t->element_id);\n\t\t\t\t}\n\t\t\t\tif (!t->element) return GF_FALSE;\n\t\t\t\tgf_free(t->element_id);\n\t\t\t\tt->element_id = NULL;\n\t\t\t}\n\t\t\telse if (!t->element) {\n\t\t\t\tif (t->event.parameter && (t->event.type==GF_EVENT_KEYDOWN) ) {\n\t\t\t\t\tt->element = lsr->sg->RootNode ? lsr->sg->RootNode : lsr->current_root;\n\t\t\t\t} else {\n\t\t\t\t\tt->element = (GF_Node*)parent;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\nstatic Bool lsr_setup_smil_anim(GF_LASeRCodec *lsr, SVG_Element *anim, SVG_Element *anim_parent)\n{\n\tGF_FieldInfo info;\n\tu32 coded_type, not_res;\n\tGF_Node *target;\n\tBool is_animateMotion, is_animateTransform;\n\tXMLRI *xlink;\n\tSMIL_AttributeName *name = NULL;\n\tSMIL_AnimateValue *value;\n\n\t/*setup smil events*/\n\tnot_res = 0;\n\tif (gf_node_get_attribute_by_tag((GF_Node *)anim, TAG_SVG_ATT_begin, GF_FALSE, GF_FALSE, &info)==GF_OK) {\n\t\tif (!lsr_init_smil_times(lsr, anim, *(GF_List**)info.far_ptr, anim_parent)) not_res++;\n\t}\n\n\tif (gf_node_get_attribute_by_tag((GF_Node *)anim, TAG_SVG_ATT_end, GF_FALSE, GF_FALSE, &info)==GF_OK) {\n\t\tif (!lsr_init_smil_times(lsr, anim, *(GF_List**)info.far_ptr, anim_parent)) not_res++;\n\t}\n\n\n\t/*get xlink*/\n\txlink = NULL;\n\tif (gf_node_get_attribute_by_tag((GF_Node *)anim, TAG_XLINK_ATT_href, GF_FALSE, GF_FALSE, &info)==GF_OK) {\n\t\txlink = info.far_ptr;\n\t}\n\n\t/*setup target node*/\n\tif (!xlink || !xlink->target) {\n\t\t/*target not received*/\n\t\tif (xlink && (xlink->type == XMLRI_ELEMENTID)) return GF_FALSE;\n\n\t\tif (!xlink) {\n\t\t\t/*target is parent, initialize xlink (needed by anim module)*/\n\t\t\tif (gf_node_get_attribute_by_tag((GF_Node *)anim, TAG_XLINK_ATT_href, GF_TRUE, GF_FALSE, &info)==GF_OK) {\n\t\t\t\txlink = info.far_ptr;\n\t\t\t} else {\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\txlink->type = XMLRI_ELEMENTID;\n\t\txlink->target = anim_parent;\n\t\tgf_node_register_iri(lsr->sg, xlink);\n\t\ttarget = (GF_Node *)anim_parent;\n\t} else {\n\t\ttarget = (GF_Node *)xlink->target;\n\t}\n\tif (!target || not_res) return GF_FALSE;\n\n\tis_animateTransform = is_animateMotion = GF_FALSE;\n\tif (anim->sgprivate->tag==TAG_SVG_animateMotion) is_animateMotion = GF_TRUE;\n\telse if (anim->sgprivate->tag==TAG_SVG_animateTransform) {\n\t\tis_animateTransform = GF_TRUE;\n\t}\n\tif (is_animateMotion) goto translate_vals;\n\n\t/*for all except animateMotion, get attributeName*/\n\tif (gf_node_get_attribute_by_tag((GF_Node *)anim, TAG_SVG_ATT_attributeName, GF_FALSE, GF_FALSE, &info)==GF_OK) {\n\t\tname = info.far_ptr;\n\t}\n\tif (!name) {\n\t\treturn GF_FALSE;\n\t}\n\n\tif (!name->field_ptr) {\n\t\tif (gf_node_get_attribute_by_tag((GF_Node *)target, name->type, GF_TRUE, GF_FALSE, &info)!=GF_OK) return GF_FALSE;\n\t\tname->field_ptr = info.far_ptr;\n\t\tname->type = info.fieldType;\n\t\tname->tag = info.fieldIndex;\n\t}\n\n\n\t/*browse all anim types and retranslate anim values. This must be done in 2 steps since we may not have received\n\tthe target node when parsing the animation node*/\ntranslate_vals:\n\n\t/*and setup anim values*/\n\tif (gf_node_get_attribute_by_tag((GF_Node *)anim, TAG_SVG_ATT_from, GF_FALSE, GF_FALSE, &info)==GF_OK) {\n\t\tif (is_animateTransform) {\n\t\t\tname->type = ((SMIL_AnimateValue*)info.far_ptr)->type;\n\t\t} else {\n\t\t\tvalue = info.far_ptr;\n\t\t\tcoded_type = value->type;\n\t\t\tvalue->type = is_animateMotion ? SVG_Motion_datatype : name->type;\n\t\t\tlsr_translate_anim_value(lsr, value, coded_type);\n\t\t}\n\t}\n\tif (gf_node_get_attribute_by_tag((GF_Node *)anim, TAG_SVG_ATT_by, GF_FALSE, GF_FALSE, &info)==GF_OK) {\n\t\tif (is_animateTransform) {\n\t\t\tname->type = ((SMIL_AnimateValue*)info.far_ptr)->type;\n\t\t} else {\n\t\t\tvalue = info.far_ptr;\n\t\t\tcoded_type = value->type;\n\t\t\tvalue->type = is_animateMotion ? SVG_Motion_datatype : name->type;\n\t\t\tlsr_translate_anim_value(lsr, value, coded_type);\n\t\t}\n\t}\n\tif (gf_node_get_attribute_by_tag((GF_Node *)anim, TAG_SVG_ATT_to, GF_FALSE, GF_FALSE, &info)==GF_OK) {\n\t\tif (is_animateTransform) {\n\t\t\tname->type = ((SMIL_AnimateValue*)info.far_ptr)->type;\n\t\t} else {\n\t\t\tvalue = info.far_ptr;\n\t\t\tcoded_type = value->type;\n\t\t\tvalue->type = is_animateMotion ? SVG_Motion_datatype : name->type;\n\t\t\tlsr_translate_anim_value(lsr, value, coded_type);\n\t\t}\n\t}\n\tif (gf_node_get_attribute_by_tag((GF_Node *)anim, TAG_SVG_ATT_values, GF_FALSE, GF_FALSE, &info)==GF_OK) {\n\t\tif (is_animateTransform) {\n\t\t\tname->type = ((SMIL_AnimateValues*)info.far_ptr)->type;\n\t\t} else {\n\t\t\tSMIL_AnimateValues *values = info.far_ptr;\n\t\t\tcoded_type = values->type;\n\t\t\tvalues->type = is_animateMotion ? SVG_Motion_datatype : name->type;\n\t\t\tvalues->laser_strings = 0;\n\t\t\tlsr_translate_anim_values(lsr, values, coded_type);\n\t\t}\n\t}\n\n\treturn GF_TRUE;\n}\n\nstatic void lsr_read_anim_fill(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 val;\n\n\tGF_LSR_READ_INT(lsr, val, 1, \"has_smil_fill\");\n\tif (val) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_smil_fill, GF_TRUE, 0, &info);\n\t\t/*enumeration freeze{0} remove{1}*/\n\t\tGF_LSR_READ_INT(lsr, val, 1, \"smil_fill\");\n\t\t*(SMIL_Fill*)info.far_ptr = val ? SMIL_FILL_REMOVE : SMIL_FILL_FREEZE;\n\t}\n}\nstatic void lsr_read_anim_repeatCount(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 val;\n\tGF_LSR_READ_INT(lsr, val, 1, \"has_repeatCount\");\n\tif (val) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_repeatCount, GF_TRUE, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, val, 1, \"repeatCount\");\n\t\tif (val) ((SMIL_RepeatCount*)info.far_ptr)->type = SMIL_REPEATCOUNT_INDEFINITE;\n\t\telse {\n\t\t\t((SMIL_RepeatCount*)info.far_ptr)->type = SMIL_REPEATCOUNT_DEFINED;\n\t\t\t((SMIL_RepeatCount*)info.far_ptr)->count = lsr_read_fixed_16_8(lsr, \"repeatCount\");\n\t\t}\n\t}\n}\nstatic void lsr_read_repeat_duration(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"has_repeatDur\");\n\tif (flag) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_repeatDur, GF_TRUE, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"choice\");\n\n\t\tif (flag) {\n\t\t\t((SMIL_Duration *)info.far_ptr)->type = SMIL_DURATION_INDEFINITE;\n\t\t} else {\n\t\t\t((SMIL_Duration *)info.far_ptr)->clock_value = (Double) lsr_read_vluimsbf5(lsr, \"value\");\n\t\t\t((SMIL_Duration *)info.far_ptr)->clock_value /= lsr->time_resolution;\n\t\t\t((SMIL_Duration *)info.far_ptr)->type = SMIL_DURATION_DEFINED;\n\t\t}\n\t}\n}\nstatic void lsr_read_anim_restart(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 val;\n\tGF_LSR_READ_INT(lsr, val, 1, \"has_restart\");\n\tif (val) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_restart, GF_TRUE, 0, &info);\n\t\t/*enumeration always{0} never{1} whenNotActive{2}*/\n\t\tGF_LSR_READ_INT(lsr, *(SMIL_Restart*)info.far_ptr, 2, \"restart\");\n\t}\n}\n\nstatic void *lsr_read_an_anim_value(GF_LASeRCodec *lsr, u32 coded_type, const char *name)\n{\n\tu32 flag;\n\tu32 escapeFlag, escape_val = 0;\n\tu8 *enum_val;\n\tu32 *id_val;\n\tchar *string;\n\tSVG_String *svg_string;\n\tSVG_Number *num;\n\tXMLRI *iri;\n\tSVG_Point *pt;\n\tSVG_Paint *paint;\n\n\tGF_LSR_READ_INT(lsr, escapeFlag, 1, \"escapeFlag\");\n\tif (escapeFlag) GF_LSR_READ_INT(lsr, escape_val, 2, \"escapeEnum\");\n\n\tswitch (coded_type) {\n\tcase 0:\n\t\tstring = NULL;\n\t\tlsr_read_byte_align_string(lsr, &string, name);\n\t\tGF_SAFEALLOC(svg_string, SVG_String);\n\t\tif (!svg_string) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\t*svg_string = string;\n\t\treturn svg_string;\n\tcase 1:\n\t\tnum = (SVG_Number*)gf_malloc(sizeof(SVG_Number));\n\t\tif (!num) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tif (escapeFlag) {\n\t\t\tnum->type = (escape_val==1) ? SVG_NUMBER_INHERIT : SVG_NUMBER_VALUE;\n\t\t} else {\n\t\t\tnum->type = SVG_NUMBER_VALUE;\n\t\t\tnum->value = lsr_read_fixed_16_8(lsr, name);\n\t\t}\n\t\treturn num;\n\tcase 2:\n\t{\n\t\tSVG_PathData *pd = (SVG_PathData *)gf_svg_create_attribute_value(SVG_PathData_datatype);\n\t\tif (!pd) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\tlsr_read_path_type(lsr, NULL, 0, pd, name);\n\t\t}\n\t\treturn pd;\n\t}\n\tcase 3:\n\t{\n\t\tSVG_Points *pts = (SVG_Points *)gf_svg_create_attribute_value(SVG_Points_datatype);\n\t\tif (!pts) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\tlsr_read_point_sequence(lsr, *pts, name);\n\t\t}\n\t\treturn pts;\n\t}\n\tcase 4:\n\t\tnum = (SVG_Number*)gf_malloc(sizeof(SVG_Number));\n\t\tif (!num) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tif (escapeFlag) {\n\t\t\tnum->type = (escape_val==1) ? SVG_NUMBER_INHERIT : SVG_NUMBER_VALUE;\n\t\t} else {\n\t\t\tnum->type = SVG_NUMBER_VALUE;\n\t\t\tnum->value = lsr_read_fixed_clamp(lsr, name);\n\t\t}\n\t\treturn num;\n\tcase 5:\n\t\tGF_SAFEALLOC(paint, SVG_Paint);\n\t\tif (!paint) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tif (escapeFlag) {\n\t\t\tpaint->type = SVG_PAINT_INHERIT;\n\t\t} else {\n\t\t\tlsr_read_paint(lsr, paint, name);\n\t\t}\n\t\treturn paint;\n\tcase 6:\n\t\tenum_val = (u8*)gf_malloc(sizeof(u8));\n\t\tif (!enum_val) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\t*enum_val = lsr_read_vluimsbf5(lsr, name);\n\t\t}\n\t\treturn enum_val;\n\t/*TODO check this is correct*/\n\tcase 7:\n\t{\n\t\tGF_List *l = gf_list_new();\n\t\tif (!l) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tu32 i, count;\n\t\tcount = lsr_read_vluimsbf5(lsr, \"count\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu8 *v = (u8 *)gf_malloc(sizeof(u8));\n\t\t\tif (!v) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\t*v = lsr_read_vluimsbf5(lsr, \"val\");\n\t\t\t\tgf_list_add(l, v);\n\t\t\t}\n\t\t\tif (lsr->last_error) break;\n\t\t}\n\t\treturn l;\n\t}\n\t/*TODO check this is correct*/\n\tcase 8: // floats\n\t{\n\t\tGF_List *l = gf_list_new();\n\t\tif (!l) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tu32 i, count;\n\t\tcount = lsr_read_vluimsbf5(lsr, \"count\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\tFixed *v = (Fixed *)gf_malloc(sizeof(Fixed));\n\t\t\tif (!v) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\t*v = lsr_read_fixed_16_8(lsr, \"val\");\n\t\t\t\tgf_list_add(l, v);\n\t\t\t}\n\t\t\tif (lsr->last_error) break;\n\t\t}\n\t\treturn l;\n\t}\n\n\t/*point */\n\tcase 9:\n\t\tpt = (SVG_Point*)gf_malloc(sizeof(SVG_Point));\n\t\tif (!pt) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, \"valX\");\n\t\tpt->x = lsr_translate_coords(lsr, flag, lsr->coord_bits);\n\t\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, \"valY\");\n\t\tpt->y = lsr_translate_coords(lsr, flag, lsr->coord_bits);\n\t\treturn pt;\n\tcase 10:\n\t\tid_val = (u32*)gf_malloc(sizeof(u32));\n\t\tif (!id_val) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\t*id_val = lsr_read_vluimsbf5(lsr, name);\n\t\t}\n\t\treturn id_val;\n\tcase 11:\n\t{\n\t\tSVG_FontFamily *ft;\n\t\tu32 idx;\n\t\tGF_SAFEALLOC(ft, SVG_FontFamily);\n\t\tif (!ft) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tif (escapeFlag) {\n\t\t\tft->type = SVG_FONTFAMILY_INHERIT;\n\t\t} else {\n\t\t\tidx = lsr_read_vluimsbf5(lsr, name);\n\t\t\tft->type = SVG_FONTFAMILY_VALUE;\n\t\t\tft->value = (char*)gf_list_get(lsr->font_table, idx);\n\t\t\tif (ft->value) ft->value = gf_strdup(ft->value);\n\t\t}\n\t\treturn ft;\n\t}\n\tcase 12:\n\t\tGF_SAFEALLOC(iri, XMLRI);\n\t\tif (!iri) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\tlsr_read_any_uri(lsr, iri, name);\n\t\t}\n\t\treturn iri;\n\tdefault:\n\t\tlsr_read_extension(lsr, name);\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic void lsr_translate_anim_trans_value(GF_LASeRCodec *lsr, SMIL_AnimateValue *val, u32 transform_type)\n{\n\tSVG_Point_Angle *p;\n\tFixed *f;\n\tu32 coded_type = val->type;\n\n\tswitch(transform_type) {\n\tcase SVG_TRANSFORM_TRANSLATE:\n\t\tval->type = SVG_Transform_Translate_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_SCALE:\n\t\tval->type = SVG_Transform_Scale_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_ROTATE:\n\t\tval->type = SVG_Transform_Rotate_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_SKEWX:\n\t\tval->type = SVG_Transform_SkewX_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_SKEWY:\n\t\tval->type = SVG_Transform_SkewY_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_MATRIX:\n\t\tval->type = SVG_Transform_datatype;\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[LSR Parsing] unknown datatype for animate transform.\\n\"));\n\t\treturn;\n\t}\n\tif (!val->value) return;\n\tswitch (transform_type) {\n\tcase SVG_TRANSFORM_ROTATE:\n\t\tif (coded_type==8) {\n\t\t\tp = (SVG_Point_Angle*)gf_malloc(sizeof(SVG_Point_Angle));\n\t\t\tif (!p) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp->x = p->y = 0;\n\t\t\tGF_List *l = (GF_List *)val->value;\n\t\t\tf = (Fixed*)gf_list_get(l, 0);\n\t\t\tif (f) p->angle = *f;\n\n\t\t\tf = (Fixed*)gf_list_get(l, 1);\n\t\t\tif (f) p->x = *f;\n\n\t\t\tf = (Fixed*)gf_list_get(l, 2);\n\t\t\tif (f) p->y = *f;\n\n\t\t\twhile (gf_list_count(l)) {\n\t\t\t\tf = gf_list_pop_back(l);\n\t\t\t\tgf_free(f);\n\t\t\t}\n\t\t\tgf_list_del(l);\n\t\t\tp->angle = gf_muldiv(p->angle, GF_PI, INT2FIX(180) );\n\t\t\tval->value = p;\n\t\t\treturn;\n\t\t} else if ((coded_type==1) || (coded_type==4)) {\n\t\t\tp = (SVG_Point_Angle*)gf_malloc(sizeof(SVG_Point_Angle));\n\t\t\tif (!p) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp->x = p->y = 0;\n\t\t\tp->angle = ((SVG_Number *)val->value)->value;\n\t\t\tgf_free(val->value);\n\t\t\tp->angle = gf_muldiv(p->angle, GF_PI, INT2FIX(180) );\n\t\t\tval->value = p;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase SVG_TRANSFORM_SCALE:\n\t\tif (coded_type==8) {\n\t\t\tSVG_Point *pt;\n\t\t\tGF_List *l = (GF_List *)val->value;\n\t\t\tGF_SAFEALLOC(pt , SVG_Point);\n\t\t\tif (!pt) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf = (Fixed*)gf_list_get(l, 0);\n\t\t\tif (f) pt->x = *f;\n\t\t\tf = (Fixed*)gf_list_get(l, 1);\n\t\t\tif (f) pt->y = *f;\n\t\t\telse pt->y = pt->x;\n\n\t\t\twhile (gf_list_count(l)) {\n\t\t\t\tf = gf_list_pop_back(l);\n\t\t\t\tgf_free(f);\n\t\t\t}\n\t\t\tgf_list_del(l);\n\t\t\tval->value = pt;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase SVG_TRANSFORM_SKEWX:\n\tcase SVG_TRANSFORM_SKEWY:\n\t\tif ((coded_type==1) || (coded_type==4)) {\n\t\t\tf = (Fixed*)gf_malloc(sizeof(Fixed));\n\t\t\tif (!f) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*f = ((SVG_Number *)val->value)->value;\n\t\t\tgf_free(val->value);\n\t\t\tval->value = f;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\t//not handled\n\tlsr_delete_anim_value(lsr, val, coded_type);\n}\n\nstatic void lsr_translate_anim_trans_values(GF_LASeRCodec *lsr, SMIL_AnimateValues *val, u32 transform_type)\n{\n\tu32 count, i, coded_type;\n\tSVG_Point_Angle *p;\n\tSVG_Point *pt;\n\tFixed *f;\n\tGF_List *l;\n\tBool handled = GF_FALSE;\n\n\tcoded_type = val->type;\n\tswitch(transform_type) {\n\tcase SVG_TRANSFORM_TRANSLATE:\n\t\tval->type = SVG_Transform_Translate_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_SCALE:\n\t\tif (coded_type==8) handled = GF_TRUE;\n\t\tval->type = SVG_Transform_Scale_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_ROTATE:\n\t\tif ((coded_type==8) || (coded_type==1)) handled = GF_TRUE;\n\t\tval->type = SVG_Transform_Rotate_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_SKEWX:\n\t\tif ((coded_type==1) || (coded_type==4)) handled = GF_TRUE;\n\t\tval->type = SVG_Transform_SkewX_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_SKEWY:\n\t\tif ((coded_type==1) || (coded_type==4)) handled = GF_TRUE;\n\t\tval->type = SVG_Transform_SkewY_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_MATRIX:\n\t\tval->type = SVG_Transform_datatype;\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[SVG Parsing] unknown datatype for animate transform.\\n\"));\n\t\tbreak;\n\t}\n\n\tif (!handled) {\n\t\twhile (gf_list_count(val->values)) {\n\t\t\tSMIL_AnimateValue a_val;\n\t\t\ta_val.type = 0;\n\t\t\ta_val.value = gf_list_pop_back(val->values);\n\t\t\tlsr_delete_anim_value(lsr, &a_val, coded_type);\n\t\t}\n\t\treturn;\n\t}\n\n\tcount = gf_list_count(val->values);\n\tif (!count) return;\n\n\tif (transform_type==SVG_TRANSFORM_TRANSLATE)\n\t\treturn;\n\n\tfor (i=0; i<count; i++) {\n\t\tvoid *a_val = gf_list_get(val->values, i);\n\t\tswitch (transform_type) {\n\t\tcase SVG_TRANSFORM_ROTATE:\n\t\t\tGF_SAFEALLOC(p, SVG_Point_Angle);\n\t\t\tif (!p) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (coded_type==8) {\n\t\t\t\tl = (GF_List*)a_val;\n\t\t\t\tf = (Fixed*)gf_list_get(l, 0);\n\t\t\t\tif (f) p->angle = *f;\n\t\t\t\tf = (Fixed*)gf_list_get(l, 1);\n\t\t\t\tif (f) p->x = *f;\n\t\t\t\tf = (Fixed*)gf_list_get(l, 2);\n\t\t\t\tif (f) p->y = *f;\n\t\t\t\twhile (gf_list_count(l)) {\n\t\t\t\t\tf = (Fixed*)gf_list_last(l);\n\t\t\t\t\tgf_list_rem_last(l);\n\t\t\t\t\tgf_free(f);\n\t\t\t\t}\n\t\t\t\tgf_list_del(l);\n\t\t\t} else if (coded_type==1) {\n\t\t\t\tp->angle = ((SVG_Number *)a_val)->value;\n\t\t\t\tgf_free(a_val);\n\t\t\t}\n\t\t\tp->angle = gf_muldiv(p->angle, GF_PI, INT2FIX(180) );\n\t\t\tgf_list_rem(val->values, i);\n\t\t\tgf_list_insert(val->values, p, i);\n\t\t\tbreak;\n\t\tcase SVG_TRANSFORM_SKEWX:\n\t\tcase SVG_TRANSFORM_SKEWY:\n\t\t\tf = (Fixed*)gf_malloc(sizeof(Fixed));\n\t\t\tif (!f) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\t*f = ((SVG_Number *)a_val)->value;\n\t\t\t}\n\t\t\tgf_free(a_val);\n\t\t\tgf_list_rem(val->values, i);\n\t\t\tif (f)\n\t\t\t\tgf_list_insert(val->values, f, i);\n\t\t\tbreak;\n\t\tcase SVG_TRANSFORM_SCALE:\n\t\t\tGF_SAFEALLOC(pt, SVG_Point);\n\t\t\tif (!pt)\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\n\t\t\tl = (GF_List*)a_val;\n\t\t\tif (pt) {\n\t\t\t\tf = (Fixed*)gf_list_get(l, 0);\n\t\t\t\tif (f) pt->x = *f;\n\t\t\t\tf = (Fixed*)gf_list_get(l, 1);\n\t\t\t\tif (f) pt->y = *f;\n\t\t\t\telse pt->y = pt->x;\n\t\t\t}\n\n\t\t\twhile (gf_list_count(l)) {\n\t\t\t\tf = (Fixed*)gf_list_last(l);\n\t\t\t\tgf_list_rem_last(l);\n\t\t\t\tgf_free(f);\n\t\t\t}\n\t\t\tgf_list_del(l);\n\t\t\tgf_list_rem(val->values, i);\n\t\t\tif (pt)\n\t\t\t\tgf_list_insert(val->values, pt, i);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[LASeR] unknown transform type %d\\n\", transform_type));\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void lsr_read_anim_value_ex(GF_LASeRCodec *lsr, GF_Node *n, u32 tag, const char *name, u32 *tr_type)\n{\n\tu32 val, coded_type;\n\tGF_LSR_READ_INT(lsr, val, 1, name);\n\tif (val) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, tag, GF_TRUE, 0, &info);\n\n\t\tGF_LSR_READ_INT(lsr, coded_type, 4, \"type\");\n\t\t((SMIL_AnimateValue*)info.far_ptr)->value = lsr_read_an_anim_value(lsr, coded_type, name);\n\t\t((SMIL_AnimateValue*)info.far_ptr)->type = coded_type;\n\n\t\tif (tr_type) {\n\t\t\tlsr_translate_anim_trans_value(lsr, info.far_ptr, *tr_type);\n\t\t}\n\t}\n}\n\nstatic void lsr_read_anim_values_ex(GF_LASeRCodec *lsr, GF_Node *n, u32 *tr_type)\n{\n\tu32 flag, i, count = 0;\n\tu32 coded_type;\n\tGF_FieldInfo info;\n\tSMIL_AnimateValues *values;\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"values\");\n\tif (!flag) return;\n\n\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_values, GF_TRUE, 0, &info);\n\tvalues = (SMIL_AnimateValues *)info.far_ptr;\n\n\tGF_LSR_READ_INT(lsr, coded_type, 4, \"type\");\n\tvalues->type = coded_type;\n\tvalues->laser_strings = 0;\n\n\tcount = lsr_read_vluimsbf5(lsr, \"count\");\n\tfor (i=0; i<count; i++) {\n\t\tvoid *att = lsr_read_an_anim_value(lsr, coded_type, \"a_value\");\n\t\tif (att) gf_list_add(values->values, att);\n\t\tif (lsr->last_error) return;\n\t}\n\tif (tr_type) {\n\t\tlsr_translate_anim_trans_values(lsr, info.far_ptr, *tr_type);\n\t}\n}\n#define lsr_read_anim_value(_a, _b, _c, _d) lsr_read_anim_value_ex(_a, _b, _c, _d, NULL)\n#define lsr_read_anim_values(_a, _b) lsr_read_anim_values_ex(_a, _b, NULL)\n\nstatic Fixed *lsr_read_fraction_12_item(GF_LASeRCodec *lsr)\n{\n\tu32 flag;\n\tFixed *f;\n\tGF_SAFEALLOC(f, Fixed);\n\tif (!f) {\n\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\treturn NULL;\n\t}\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasShort\");\n\tif (flag) {\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"isZero\");\n\t\tif (flag) *f = 0;\n\t\telse *f = FIX_ONE;\n\t} else {\n\t\tu32 v;\n\t\tGF_LSR_READ_INT(lsr, v, 12, \"val\");\n\t\t*f = INT2FIX(v) / 4096/*(1<<12)*/;\n\t}\n\treturn f;\n}\n\nstatic void lsr_read_fraction_12(GF_LASeRCodec *lsr, GF_Node *elt, u32 tag, const char *name)\n{\n\tGF_FieldInfo info;\n\tu32 i, count;\n\tGF_LSR_READ_INT(lsr, count, 1, name);\n\tif (!count) return;\n\n\tlsr->last_error = gf_node_get_attribute_by_tag(elt, tag, GF_TRUE, 0, &info);\n\n\tcount = lsr_read_vluimsbf5(lsr, \"name\");\n\tfor (i=0; i<count; i++) {\n\t\tFixed *f = lsr_read_fraction_12_item(lsr);\n\t\tgf_list_add( *((SMIL_KeyTimes*)info.far_ptr), f);\n\t\tif (lsr->last_error) return;\n\t}\n}\nstatic void lsr_read_float_list(GF_LASeRCodec *lsr, GF_Node *n, u32 tag, SVG_Coordinates*coords, const char *name)\n{\n\tu32 i, count;\n\tGF_LSR_READ_INT(lsr, count, 1, name);\n\tif (!count) return;\n\n\tif (!coords) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, tag, GF_TRUE, 0, &info);\n\t\tcoords = (SVG_Coordinates*)info.far_ptr;\n\t} else {\n\t\twhile (gf_list_count(*coords)) {\n\t\t\tFixed *v = (Fixed *)gf_list_last(*coords);\n\t\t\tgf_list_rem_last(*coords);\n\t\t\tgf_free(v);\n\t\t}\n\t}\n\tcount = lsr_read_vluimsbf5(lsr, \"count\");\n\tif (tag == TAG_SVG_ATT_text_rotate) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tSVG_Number *num = (SVG_Number *)gf_malloc(sizeof(SVG_Number));\n\t\t\tif (!num) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\tnum->type = SVG_NUMBER_VALUE;\n\t\t\t\tnum->value = lsr_read_fixed_16_8(lsr, \"val\");\n\t\t\t\tgf_list_add(*coords, num);\n\t\t\t}\n\t\t\tif (lsr->last_error) return;\n\t\t}\n\t}\n\telse {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tFixed *num = (Fixed *)gf_malloc(sizeof(Fixed));\n\t\t\tif (!num) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\t*num = lsr_read_fixed_16_8(lsr, \"val\");\n\t\t\t}\n\t\t\tgf_list_add(*coords, num);\n\t\t\tif (lsr->last_error) return;\n\t\t}\n\t}\n}\n\nstatic void lsr_read_point_sequence(GF_LASeRCodec *lsr, GF_List *pts, const char *name)\n{\n\tu32 flag, i, count;\n\n\twhile (gf_list_count(pts)) {\n\t\tSVG_Point *v = (SVG_Point *)gf_list_last(pts);\n\t\tgf_list_rem_last(pts);\n\t\tgf_free(v);\n\t}\n\tcount = lsr_read_vluimsbf5(lsr, \"nbPoints\");\n\tif (!count) return;\n\t/*TODO golomb coding*/\n\tGF_LSR_READ_INT(lsr, flag, 1, \"flag\");\n\tif (!flag) {\n\t\tif (count < 3) {\n\t\t\tu32 nb_bits, v;\n\t\t\tGF_LSR_READ_INT(lsr, nb_bits, 5, \"bits\");\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tSVG_Point *pt = (SVG_Point *)gf_malloc(sizeof(SVG_Point));\n\t\t\t\tif (!pt) {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t} else {\n\t\t\t\t\tgf_list_add(pts, pt);\n\t\t\t\t\tGF_LSR_READ_INT(lsr, v, nb_bits, \"x\");\n\t\t\t\t\tpt->x = lsr_translate_coords(lsr, v, nb_bits);\n\t\t\t\t\tGF_LSR_READ_INT(lsr, v, nb_bits, \"y\");\n\t\t\t\t\tpt->y = lsr_translate_coords(lsr, v, nb_bits);\n\t\t\t\t}\n\t\t\t\tif (lsr->last_error) return;\n\t\t\t}\n\t\t} else {\n\t\t\tu32 nb_dx, nb_dy, k;\n\t\t\tFixed x, y;\n\t\t\tSVG_Point *pt = (SVG_Point *)gf_malloc(sizeof(SVG_Point));\n\t\t\tif (!pt) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgf_list_add(pts, pt);\n\n\t\t\tGF_LSR_READ_INT(lsr, nb_dx, 5, \"bits\");\n\t\t\tGF_LSR_READ_INT(lsr, k, nb_dx, \"x\");\n\t\t\tx = pt->x = lsr_translate_coords(lsr, k, nb_dx);\n\t\t\tGF_LSR_READ_INT(lsr, k, nb_dx, \"y\");\n\t\t\ty = pt->y = lsr_translate_coords(lsr, k, nb_dx);\n\n\t\t\tGF_LSR_READ_INT(lsr, nb_dx, 5, \"bitsx\");\n\t\t\tGF_LSR_READ_INT(lsr, nb_dy, 5, \"bitsy\");\n\t\t\tfor (i=1; i<count; i++) {\n\t\t\t\tpt = (SVG_Point *)gf_malloc(sizeof(SVG_Point));\n\t\t\t\tif (!pt) {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t} else {\n\t\t\t\t\tgf_list_add(pts, pt);\n\t\t\t\t\tGF_LSR_READ_INT(lsr, k, nb_dx, \"dx\");\n\t\t\t\t\tpt->x = x + lsr_translate_coords(lsr, k, nb_dx);\n\t\t\t\t\tx = pt->x;\n\t\t\t\t\tGF_LSR_READ_INT(lsr, k, nb_dy, \"dy\");\n\t\t\t\t\tpt->y = y + lsr_translate_coords(lsr, k, nb_dy);\n\t\t\t\t\ty = pt->y;\n\t\t\t\t}\n\t\t\t\tif (lsr->last_error) return;\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void lsr_read_path_type(GF_LASeRCodec *lsr, GF_Node *n, u32 tag, SVG_PathData *path, const char *name)\n{\n#if USE_GF_PATH\n\tGF_Point2D *pt, *ct1, *ct2, *end;\n\tGF_Point2D orig, ct_orig;\n\tu32 i, count, cur_pt, type;\n\tGF_List *pts = gf_list_new();\n\tlsr_read_point_sequence(lsr, pts, \"seq\");\n\n\tif (!path) {\n\t\tGF_FieldInfo info;\n\t\tgf_node_get_attribute_by_tag(n, tag, GF_TRUE, 0, &info);\n\t\tpath = (SVG_PathData*)info.far_ptr;\n\t} else {\n\t\tgf_path_reset(path);\n\t}\n\t/*first MoveTo is skipped in LASeR*/\n\tpt = (GF_Point2D*)gf_list_get(pts, 0);\n\tif (pt) {\n\t\tct_orig = orig = *pt;\n\t\tgf_path_add_move_to_vec(path, pt);\n\t} else {\n\t\torig.x = orig.y = 0;\n\t\tct_orig = orig;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[LASeR] Empty path found.\\n\"));\n\t}\n\tcur_pt = 1;\n\tcount = lsr_read_vluimsbf5(lsr, \"nbOfTypes\");\n\tfor (i=0; i<count; i++) {\n\t\tGF_LSR_READ_INT(lsr, type, 5, name);\n\t\tswitch (type) {\n\t\tcase LSR_PATH_COM_h:\n\t\tcase LSR_PATH_COM_l:\n\t\tcase LSR_PATH_COM_v:\n\t\tcase LSR_PATH_COM_H:\n\t\tcase LSR_PATH_COM_V:\n\t\tcase LSR_PATH_COM_L:\n\t\t\tpt = (GF_Point2D*)gf_list_get(pts, cur_pt);\n\t\t\tif (!pt) goto err_exit;\n\t\t\tgf_path_add_line_to_vec(path, pt);\n\t\t\tcur_pt++;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_m:\n\t\tcase LSR_PATH_COM_M:\n\t\t\tpt = (GF_Point2D*)gf_list_get(pts, cur_pt);\n\t\t\tif (!pt) goto err_exit;\n\t\t\tgf_path_add_move_to_vec(path, pt);\n\t\t\tcur_pt++;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_q:\n\t\tcase LSR_PATH_COM_Q:\n\t\t\tct1 = (GF_Point2D*)gf_list_get(pts, cur_pt);\n\t\t\tend = (GF_Point2D*)gf_list_get(pts, cur_pt+1);\n\t\t\tif (!ct1 || !end) goto err_exit;\n\t\t\tgf_path_add_quadratic_to_vec(path, ct1, end);\n\t\t\torig = *end;\n\t\t\tcur_pt+=2;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_c:\n\t\tcase LSR_PATH_COM_C:\n\t\t\tct1 = (GF_Point2D*)gf_list_get(pts, cur_pt);\n\t\t\tct2 = (GF_Point2D*)gf_list_get(pts, cur_pt+1);\n\t\t\tend = (GF_Point2D*)gf_list_get(pts, cur_pt+2);\n\t\t\tif (!ct1 || !ct2 || !end) goto err_exit;\n\t\t\tgf_path_add_cubic_to_vec(path, ct1, ct2, end);\n\t\t\tcur_pt+=3;\n\t\t\tct_orig = *ct2;\n\t\t\torig = *end;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_s:\n\t\tcase LSR_PATH_COM_S:\n\t\t\tct_orig.x = 2*orig.x - ct_orig.x;\n\t\t\tct_orig.y = 2*orig.y - ct_orig.y;\n\t\t\tct2 = (GF_Point2D*)gf_list_get(pts, cur_pt);\n\t\t\tend = (GF_Point2D*)gf_list_get(pts, cur_pt+1);\n\t\t\tif (!ct2 || !end) goto err_exit;\n\t\t\tgf_path_add_cubic_to_vec(path, &ct_orig, ct2, end);\n\t\t\tct_orig = *ct2;\n\t\t\torig = *end;\n\t\t\tcur_pt+=2;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_t:\n\t\tcase LSR_PATH_COM_T:\n\t\t\tct_orig.x = 2*orig.x - ct_orig.x;\n\t\t\tct_orig.y = 2*orig.y - ct_orig.y;\n\t\t\tend = gf_list_get(pts, cur_pt);\n\t\t\tif (!end) goto err_exit;\n\t\t\tgf_path_add_quadratic_to_vec(path, &ct_orig, end);\n\t\t\torig = *end;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_z:\n\t\tcase LSR_PATH_COM_Z:\n\t\t\tgf_path_close(path);\n\t\t\tbreak;\n\t\t}\n\t\tif (lsr->last_error) break;\n\t}\n\tgoto exit;\n\nerr_exit:\n\tlsr->last_error = GF_NON_COMPLIANT_BITSTREAM;\n\nexit:\n\twhile (gf_list_count(pts)) {\n\t\tend = (GF_Point2D*)gf_list_get(pts, 0);\n\t\tgf_list_rem(pts, 0);\n\t\tgf_free(end);\n\t}\n\tgf_list_del(pts);\n\n#else\n\tu32 i, count, c;\n\tif (!path) {\n\t\tlsr->last_error = GF_BAD_PARAM;\n\t\treturn;\n\t}\n\tlsr_read_point_sequence(lsr, path->points, \"seq\");\n\twhile (gf_list_count(path->commands)) {\n\t\tu8 *v = (u8 *)gf_list_last(path->commands);\n\t\tgf_list_rem_last(path->commands);\n\t\tgf_free(v);\n\t}\n\n\tcount = lsr_read_vluimsbf5(lsr, \"nbOfTypes\");\n\tfor (i=0; i<count; i++) {\n\t\tu8 *type = (u8 *)gf_malloc(sizeof(u8));\n\t\tif (!type) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn;\n\t\t}\n\t\tGF_LSR_READ_INT(lsr, c, 5, name);\n\n\t\tswitch (c) {\n\t\tcase LSR_PATH_COM_h:\n\t\tcase LSR_PATH_COM_l:\n\t\tcase LSR_PATH_COM_v:\n\t\tcase LSR_PATH_COM_H:\n\t\tcase LSR_PATH_COM_V:\n\t\tcase LSR_PATH_COM_L:\n\t\t\t*type=SVG_PATHCOMMAND_L;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_m:\n\t\tcase LSR_PATH_COM_M:\n\t\t\t*type=SVG_PATHCOMMAND_M;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_q:\n\t\tcase LSR_PATH_COM_Q:\n\t\t\t*type=SVG_PATHCOMMAND_Q;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_c:\n\t\tcase LSR_PATH_COM_C:\n\t\t\t*type=SVG_PATHCOMMAND_C;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_s:\n\t\tcase LSR_PATH_COM_S:\n\t\t\t*type=SVG_PATHCOMMAND_S;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_t:\n\t\tcase LSR_PATH_COM_T:\n\t\t\t*type=SVG_PATHCOMMAND_T;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_z:\n\t\tcase LSR_PATH_COM_Z:\n\t\t\t*type=SVG_PATHCOMMAND_Z;\n\t\t\tbreak;\n\t\t}\n\t\tgf_list_add(path->commands, type);\n\t}\n#endif\n}\n\nstatic void lsr_read_rotate_type(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"rotate\");\n\tif (flag) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_rotate, GF_TRUE, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"choice\");\n\n\t\tif (flag) {\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"rotate\");\n\t\t\t((SVG_Number *)info.far_ptr)->type = flag ? SVG_NUMBER_AUTO_REVERSE : SVG_NUMBER_AUTO;\n\t\t} else {\n\t\t\t((SVG_Number *)info.far_ptr)->value = lsr_read_fixed_16_8(lsr, \"rotate\");\n\t\t\t((SVG_Number *)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t}\n\t}\n}\nstatic void lsr_read_sync_behavior(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"syncBehavior\");\n\tif (flag) {\n\t\tGF_FieldInfo info;\n\t\tGF_LSR_READ_INT(lsr, flag, 2, \"syncBehavior\");\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_syncBehavior, GF_TRUE, 0, &info);\n\t\t*(SMIL_SyncBehavior*)info.far_ptr = flag + 1;\n\t}\n}\nstatic void lsr_read_sync_tolerance(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"syncTolerance\");\n\tif (flag) {\n\t\tGF_FieldInfo info;\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"syncTolerance\");\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_syncTolerance, GF_TRUE, 0, &info);\n\t\tif (flag) ((SMIL_SyncTolerance *)info.far_ptr)->type = SMIL_SYNCTOLERANCE_DEFAULT;\n\t\telse {\n\t\t\tu32 v = lsr_read_vluimsbf5(lsr, \"value\");\n\t\t\t((SMIL_SyncTolerance *)info.far_ptr)->value = INT2FIX(v);\n\t\t\t((SMIL_SyncTolerance *)info.far_ptr)->value /= lsr->time_resolution;\n\t\t}\n\t}\n}\nstatic void lsr_read_sync_reference(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasSyncReference\");\n\tif (flag) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_syncReference, GF_TRUE, 0, &info);\n\t\tlsr_read_any_uri(lsr, info.far_ptr, \"syncReference\");\n\t}\n}\n\nstatic void lsr_read_coordinate(GF_LASeRCodec *lsr, SVG_Number *coord, Bool skipable, const char *name)\n{\n\tu32 flag;\n\tif (skipable) {\n\t\tGF_LSR_READ_INT(lsr, flag, 1, name);\n\t\tif (!flag) {\n\t\t\t//coord->type = SVG_NUMBER_UNKNOWN;\n\t\t\t//coord->value = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\tcoord->type = SVG_NUMBER_VALUE;\n\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, name);\n\tcoord->value = lsr_translate_coords(lsr, flag, lsr->coord_bits);\n}\nstatic void lsr_read_coordinate_ptr(GF_LASeRCodec *lsr, GF_Node *n, u32 tag, Bool skipable, const char *name)\n{\n\tu32 flag;\n\tGF_FieldInfo info;\n\tif (skipable) {\n\t\tGF_LSR_READ_INT(lsr, flag, 1, name);\n\t\tif (!flag) return;\n\t}\n\tlsr->last_error = gf_node_get_attribute_by_tag(n, tag, GF_TRUE, 0, &info);\n\n\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, name);\n\t((SVG_Number*)info.far_ptr)->value = lsr_translate_coords(lsr, flag, lsr->coord_bits);\n}\n\nstatic void lsr_read_coord_list(GF_LASeRCodec *lsr, GF_Node *elt, u32 tag, const char *name)\n{\n\tGF_FieldInfo info;\n\tu32 i, count;\n\tGF_LSR_READ_INT(lsr, count, 1, name);\n\tif (!count) return;\n\tcount = lsr_read_vluimsbf5(lsr, \"nb_coords\");\n\tif (!count) return;\n\n\tlsr->last_error = gf_node_get_attribute_by_tag(elt, tag, GF_TRUE, 0, &info);\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 res;\n\t\tSVG_Coordinate *f;\n\t\tGF_SAFEALLOC(f, SVG_Coordinate );\n\t\tif (!f) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn;\n\t\t}\n\t\tGF_LSR_READ_INT(lsr, res, lsr->coord_bits, name);\n\t\tf->value = lsr_translate_coords(lsr, res, lsr->coord_bits);\n\t\tgf_list_add(*(SVG_Coordinates*)info.far_ptr, f);\n\t\tif (lsr->last_error) return;\n\t}\n}\n\nstatic void lsr_read_transform_behavior(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tGF_FieldInfo info;\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasTransformBehavior\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_transformBehavior, GF_TRUE, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, *(SVG_TransformBehavior*)info.far_ptr, 4, \"transformBehavior\");\n\t}\n}\n\nstatic void lsr_read_content_type(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasType\");\n\tif (flag) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_type, GF_TRUE, 0, &info);\n\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"type\");\n\t}\n}\nstatic void lsr_read_script_type(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasType\");\n\tif (flag) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_XLINK_ATT_type, GF_TRUE, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"choice\");\n\t\tif (flag) {\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"script\");\n\t\t\tswitch (flag) {\n\t\t\tcase 0:\n\t\t\t\t*(SVG_String*)info.far_ptr = gf_strdup(\"application/ecmascript\");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t*(SVG_String*)info.far_ptr = gf_strdup(\"application/jar-archive\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"type\");\n\t\t}\n\t}\n}\nstatic void lsr_read_value_with_units(GF_LASeRCodec *lsr, SVG_Number *n, const char *name)\n{\n\ts32 val;\n\tGF_LSR_READ_INT(lsr, val, 32, name);\n#ifdef GPAC_FIXED_POINT\n\tn->value = val << 8;\n#else\n\tn->value = INT2FIX(val) / (1<<8);\n#endif\n\tGF_LSR_READ_INT(lsr, val, 3, \"units\");\n\tswitch (val) {\n\tcase 1:\n\t\tn->type = SVG_NUMBER_IN;\n\t\tbreak;\n\tcase 2:\n\t\tn->type = SVG_NUMBER_CM;\n\t\tbreak;\n\tcase 3:\n\t\tn->type = SVG_NUMBER_MM;\n\t\tbreak;\n\tcase 4:\n\t\tn->type = SVG_NUMBER_PT;\n\t\tbreak;\n\tcase 5:\n\t\tn->type = SVG_NUMBER_PC;\n\t\tbreak;\n\tcase 6:\n\t\tn->type = SVG_NUMBER_PERCENTAGE;\n\t\tbreak;\n\tdefault:\n\t\tn->type = SVG_NUMBER_VALUE;\n\t\tbreak;\n\t}\n}\n\n\nstatic void lsr_read_clip_time(GF_LASeRCodec *lsr, GF_Node *elt, u32 tag, const char *name)\n{\n\tGF_FieldInfo info;\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, name);\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, tag, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"isEnum\");\n\t\tif (!flag) {\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"sign\");\n\t\t\tflag = lsr_read_vluimsbf5(lsr, \"val\");\n\t\t\t*((SVG_Clock *)info.far_ptr) = flag;\n\t\t\t*((SVG_Clock *)info.far_ptr) /= lsr->time_resolution;\n\t\t}\n\t}\n}\n\nstatic void lsr_read_attribute_type(GF_LASeRCodec *lsr, GF_Node *elt)\n{\n\tGF_FieldInfo info;\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasAttributeType\");\n\tif (!flag) return;\n\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_attributeType, 1, 0, &info);\n\tGF_LSR_READ_INT(lsr, *(SMIL_AttributeType*)info.far_ptr, 2, \"attributeType\");\n}\n\nstatic void lsr_read_preserve_aspect_ratio(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tGF_FieldInfo info;\n\tu32 flag;\n\tSVG_PreserveAspectRatio *par;\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasPreserveAspectRatio\");\n\tif (!flag) return;\n\n\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_preserveAspectRatio, 1, 0, &info);\n\tpar = (SVG_PreserveAspectRatio *)info.far_ptr;\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"choice (meetOrSlice)\");\n\tGF_LSR_READ_INT(lsr, par->defer, 1, \"choice (defer)\");\n\tGF_LSR_READ_INT(lsr, flag, 4, \"alignXandY\");\n\tswitch (flag) {\n\tcase 1:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMAX;\n\t\tbreak;\n\tcase 2:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMID;\n\t\tbreak;\n\tcase 3:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMIN;\n\t\tbreak;\n\tcase 4:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMAX;\n\t\tbreak;\n\tcase 5:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMID;\n\t\tbreak;\n\tcase 6:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMIN;\n\t\tbreak;\n\tcase 7:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMAX;\n\t\tbreak;\n\tcase 8:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMID;\n\t\tbreak;\n\tcase 9:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMIN;\n\t\tbreak;\n\tdefault:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_NONE;\n\t\tbreak;\n\t}\n}\n\nstatic void lsr_read_eRR(GF_LASeRCodec *lsr, GF_Node *elt)\n{\n\tu32 err;\n\tGF_LSR_READ_INT(lsr, err, 1, \"externalResourcesRequired\");\n\tif (err) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_externalResourcesRequired, 1, 0, &info);\n\t\t*(SVG_Boolean*)info.far_ptr = 1;\n\t}\n}\n\nstatic void lsr_read_lsr_enabled(GF_LASeRCodec *lsr, GF_Node *elt)\n{\n\tu32 err;\n\tGF_LSR_READ_INT(lsr, err, 1, \"enabled\");\n\tif (err) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_LSR_ATT_enabled, 1, 0, &info);\n\t\t*(SVG_Boolean*)info.far_ptr = 1;\n\t}\n}\n\nstatic GF_Node *lsr_read_a(GF_LASeRCodec *lsr)\n{\n\tBool flag;\n\tGF_Node *elt = (GF_Node*) gf_node_new(lsr->sg, TAG_SVG_a);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_eRR(lsr, elt);\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasTarget\");\n\tif (flag) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_target, 1, 0, &info);\n\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"target\");\n\t}\n\tlsr_read_href(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\n\n\nstatic GF_Node *lsr_read_animate(GF_LASeRCodec *lsr, SVG_Element *parent, Bool is_animateColor)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, is_animateColor ? TAG_SVG_animateColor : TAG_SVG_animate);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_attribute_name(lsr, elt);\n\n\tlsr_read_accumulate(lsr, elt);\n\tlsr_read_additive(lsr, elt);\n\tlsr_read_anim_value(lsr, elt, TAG_SVG_ATT_by, \"by\");\n\tlsr_read_calc_mode(lsr, elt);\n\tlsr_read_anim_value(lsr, elt, TAG_SVG_ATT_from, \"from\");\n\tlsr_read_fraction_12(lsr, elt, TAG_SVG_ATT_keySplines, \"keySplines\");\n\tlsr_read_fraction_12(lsr, elt, TAG_SVG_ATT_keyTimes, \"keyTimes\");\n\tlsr_read_anim_values(lsr, elt);\n\tlsr_read_attribute_type(lsr, elt);\n\tlsr_read_smil_times(lsr, elt, TAG_SVG_ATT_begin, NULL, \"begin\", 1);\n\tlsr_read_duration(lsr, elt);\n\tlsr_read_anim_fill(lsr, elt);\n\tlsr_read_anim_repeatCount(lsr, elt);\n\tlsr_read_repeat_duration(lsr, elt);\n\tlsr_read_anim_restart(lsr, elt);\n\tlsr_read_anim_value(lsr, elt, TAG_SVG_ATT_to, \"to\");\n\tlsr_read_href(lsr, elt);\n\tlsr_read_lsr_enabled(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\n\tif (!lsr_setup_smil_anim(lsr, (SVG_Element*)elt, parent)) {\n\t\tgf_list_add(lsr->deferred_anims, elt);\n\t\tlsr_read_group_content_post_init(lsr, (SVG_Element*)elt, 1);\n\t} else {\n\t\tlsr_read_group_content(lsr, elt, 0);\n\t}\n\treturn elt;\n}\n\n\nstatic GF_Node *lsr_read_animateMotion(GF_LASeRCodec *lsr, SVG_Element *parent)\n{\n\tBool flag;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_animateMotion);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_accumulate(lsr, elt);\n\tlsr_read_additive(lsr, elt);\n\tlsr_read_anim_value(lsr, elt, TAG_SVG_ATT_by, \"by\");\n\tlsr_read_calc_mode(lsr, elt);\n\tlsr_read_anim_value(lsr, elt, TAG_SVG_ATT_from, \"from\");\n\tlsr_read_fraction_12(lsr, elt, TAG_SVG_ATT_keySplines, \"keySplines\");\n\tlsr_read_fraction_12(lsr, elt, TAG_SVG_ATT_keyTimes, \"keyTimes\");\n\tlsr_read_anim_values(lsr, elt);\n\tlsr_read_attribute_type(lsr, elt);\n\tlsr_read_smil_times(lsr, elt, TAG_SVG_ATT_begin, NULL, \"begin\", 1);\n\tlsr_read_duration(lsr, elt);\n\tlsr_read_anim_fill(lsr, elt);\n\tlsr_read_anim_repeatCount(lsr, elt);\n\tlsr_read_repeat_duration(lsr, elt);\n\tlsr_read_anim_restart(lsr, elt);\n\tlsr_read_anim_value(lsr, elt, TAG_SVG_ATT_to, \"to\");\n\tlsr_read_float_list(lsr, elt, TAG_SVG_ATT_keyPoints, NULL, \"keyPoints\");\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasPath\");\n\tif (flag) lsr_read_path_type(lsr, elt, TAG_SVG_ATT_path, NULL, \"path\");\n\n\tlsr_read_rotate_type(lsr, elt);\n\tlsr_read_href(lsr, elt);\n\tlsr_read_lsr_enabled(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\n\tif (!lsr_setup_smil_anim(lsr, (SVG_Element*)elt, parent)) {\n\t\tgf_list_add(lsr->deferred_anims, elt);\n\t\tlsr_read_group_content_post_init(lsr, (SVG_Element*)elt, 1);\n\t} else {\n\t\tlsr_read_group_content_post_init(lsr, (SVG_Element*)elt, 0);\n\t}\n\treturn elt;\n}\n\n\nstatic GF_Node *lsr_read_animateTransform(GF_LASeRCodec *lsr, SVG_Element *parent)\n{\n\tu32 type;\n\tu32 flag;\n\tGF_FieldInfo info;\n\tGF_Node *elt= gf_node_new(lsr->sg, TAG_SVG_animateTransform);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_attribute_name(lsr, elt);\n\n\t/*enumeration rotate{0} scale{1} skewX{2} skewY{3} translate{4}*/\n\tGF_LSR_READ_INT(lsr, flag, 3, \"rotscatra\");\n\tswitch (flag) {\n\tcase 0:\n\t\ttype = SVG_TRANSFORM_ROTATE;\n\t\tbreak;\n\tcase 1:\n\t\ttype = SVG_TRANSFORM_SCALE;\n\t\tbreak;\n\tcase 2:\n\t\ttype = SVG_TRANSFORM_SKEWX;\n\t\tbreak;\n\tcase 3:\n\t\ttype = SVG_TRANSFORM_SKEWY;\n\t\tbreak;\n\tcase 4:\n\t\ttype = SVG_TRANSFORM_TRANSLATE;\n\t\tbreak;\n\tdefault:\n\t\ttype = SVG_TRANSFORM_ROTATE;\n\t\tbreak;\n\t}\n\tif (gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_transform_type, 1, 0, &info)==GF_OK) {\n\t\t*(SVG_TransformType *)info.far_ptr = type;\n\t}\n\n\tlsr_read_accumulate(lsr, elt);\n\tlsr_read_additive(lsr, elt);\n\tlsr_read_anim_value_ex(lsr, elt, TAG_SVG_ATT_by, \"by\", &type);\n\tlsr_read_calc_mode(lsr, elt);\n\tlsr_read_anim_value_ex(lsr, elt, TAG_SVG_ATT_from, \"from\", &type);\n\tlsr_read_fraction_12(lsr, elt, TAG_SVG_ATT_keySplines, \"keySplines\");\n\tlsr_read_fraction_12(lsr, elt, TAG_SVG_ATT_keyTimes, \"keyTimes\");\n\tlsr_read_anim_values_ex(lsr, elt, &type);\n\tlsr_read_attribute_type(lsr, elt);\n\n\tlsr_read_smil_times(lsr, elt, TAG_SVG_ATT_begin, NULL, \"begin\", 1);\n\tlsr_read_duration(lsr, elt);\n\tlsr_read_anim_fill(lsr, elt);\n\tlsr_read_anim_repeatCount(lsr, elt);\n\tlsr_read_repeat_duration(lsr, elt);\n\tlsr_read_anim_restart(lsr, elt);\n\tlsr_read_anim_value_ex(lsr, elt, TAG_SVG_ATT_to, \"to\", &type);\n\n\tlsr_read_href(lsr, elt);\n\tlsr_read_lsr_enabled(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\n\tif (!lsr_setup_smil_anim(lsr, (SVG_Element*)elt, parent)) {\n\t\tgf_list_add(lsr->deferred_anims, elt);\n\t\tlsr_read_group_content_post_init(lsr, (SVG_Element*)elt, 1);\n\t} else {\n\t\tlsr_read_group_content(lsr, elt, 0);\n\t}\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_audio(GF_LASeRCodec *lsr, SVG_Element *parent)\n{\n\tGF_Node *elt= gf_node_new(lsr->sg, TAG_SVG_audio);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_smil_times(lsr, elt, TAG_SVG_ATT_begin, NULL, \"begin\", 1);\n\tlsr_read_duration(lsr, elt);\n\tlsr_read_eRR(lsr, elt);\n\tlsr_read_anim_repeatCount(lsr, elt);\n\tlsr_read_repeat_duration(lsr, elt);\n\tlsr_read_anim_restart(lsr, elt);\n\tlsr_read_sync_behavior(lsr, elt);\n\tlsr_read_sync_tolerance(lsr, elt);\n\tlsr_read_content_type(lsr, elt);\n\tlsr_read_href(lsr, elt);\n\n\tlsr_read_clip_time(lsr, elt, TAG_SVG_ATT_clipBegin, \"clipBegin\");\n\tlsr_read_clip_time(lsr, elt, TAG_SVG_ATT_clipEnd, \"clipEnd\");\n\tlsr_read_sync_reference(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_circle(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt= gf_node_new(lsr->sg, TAG_SVG_circle);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_cx, 1, \"cx\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_cy, 1, \"cy\");\n\tlsr_read_coordinate_ptr(lsr, elt,TAG_SVG_ATT_r, 0, \"r\");\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_conditional(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_LSR_conditional);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_smil_times(lsr, elt, TAG_SVG_ATT_begin, NULL, \"begin\", 1);\n\tlsr_read_eRR(lsr, elt);\n\tlsr_read_lsr_enabled(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_command_list(lsr, NULL, (SVG_Element*)elt, 0);\n\n\tlsr->has_conditionnals = GF_TRUE;\n\tgf_node_init(elt);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_cursorManager(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_LSR_cursorManager);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt,TAG_SVG_ATT_x, 1, \"x\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y, 1, \"y\");\n\tlsr_read_href(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_data(GF_LASeRCodec *lsr, u32 node_tag)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, node_tag);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_defs(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_defs);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_ellipse(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_ellipse);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_cx, 1, \"cx\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_cy, 1, \"cy\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_rx, 0, \"rx\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_ry, 0, \"ry\");\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_foreignObject(GF_LASeRCodec *lsr)\n{\n\tu32 flag;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_foreignObject);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_eRR(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_height, 0, \"height\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_width, 0, \"width\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x, 1, \"x\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y, 1, \"y\");\n\n\tlsr_read_any_attribute(lsr, elt, 1);\n\t/*\tTODO\n\t\tbit(1) opt_group;\n\t\tif(opt_group) {\n\t\t\tvluimsbf5 occ1;\n\t\t\tfor(int t=0;t<occ1;t++) {\n\t\t\t\tprivateElementContainer child0[[t]];\n\t\t\t}\n\t\t}\n\t*/\n\tGF_LSR_READ_INT(lsr, flag, 1, \"opt_group\");\n\treturn elt;\n}\n\n\nstatic GF_Node *lsr_read_g(GF_LASeRCodec *lsr, Bool is_same)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_g);\n\tif (is_same) {\n\t\tif (lsr->prev_g) {\n\t\t\tlsr_restore_base(lsr, (SVG_Element*) elt, lsr->prev_g, 0, 0);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[LASeR] sameg coded in bitstream but no g defined !\\n\"));\n\t\t}\n\t\tlsr_read_id(lsr, elt);\n\t} else {\n\t\tlsr_read_id(lsr, elt);\n\t\tlsr_read_rare_full(lsr, elt);\n\t\tlsr_read_fill(lsr, elt);\n\t\tlsr_read_stroke(lsr, elt);\n\t\tlsr_read_eRR(lsr, elt);\n\t\tlsr_read_any_attribute(lsr, elt, 1);\n\t\tlsr->prev_g = (SVG_Element*)elt;\n\t}\n\tlsr_read_group_content(lsr, elt, is_same);\n\treturn elt;\n}\n\nstatic void lsr_read_opacity(GF_LASeRCodec *lsr, GF_Node *elt)\n{\n\tu32 flag;\n\tGF_FieldInfo info;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"opacity\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_opacity, 1, 0, &info);\n\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"opacity\");\n\t}\n\n}\nstatic GF_Node *lsr_read_image(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_image);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_eRR(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_height, 1, \"height\");\n\tlsr_read_opacity(lsr, elt);\n\n\tlsr_read_preserve_aspect_ratio(lsr, elt);\n\tlsr_read_content_type(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_width, 1, \"width\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x, 1, \"x\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y, 1, \"y\");\n\tlsr_read_href(lsr, elt);\n\tlsr_read_transform_behavior(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_line(GF_LASeRCodec *lsr, Bool is_same)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_line);\n\n\tif (is_same) {\n\t\tif (lsr->prev_line) {\n\t\t\tlsr_restore_base(lsr, (SVG_Element*) elt, (SVG_Element *)lsr->prev_line, 0, 0);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[LASeR] sameline coded in bitstream but no line defined !\\n\"));\n\t\t}\n\t\tlsr_read_id(lsr, elt);\n\t} else {\n\t\tlsr_read_id(lsr, elt);\n\t\tlsr_read_rare_full(lsr, elt);\n\t\tlsr_read_fill(lsr, elt);\n\t\tlsr_read_stroke(lsr, elt);\n\t}\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x1, 1, \"x1\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x2, 0, \"x2\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y1, 1, \"y1\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y2, 0, \"y2\");\n\tif (!is_same) {\n\t\tlsr_read_any_attribute(lsr, elt, 1);\n\t\tlsr->prev_line = (SVG_Element*)elt;\n\t}\n\tlsr_read_group_content(lsr, elt, is_same);\n\treturn elt;\n}\n\nstatic void lsr_read_gradient_units(GF_LASeRCodec *lsr, GF_Node *elt)\n{\n\tu32 flag;\n\tGF_FieldInfo info;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasGradientUnits\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_gradientUnits, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, *(SVG_GradientUnit*)info.far_ptr, 1, \"gradientUnits\");\n\t}\n}\nstatic GF_Node *lsr_read_linearGradient(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_linearGradient);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_gradient_units(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x1, 1, \"x1\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x2, 1, \"x2\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y1, 1, \"y1\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y2, 1, \"y2\");\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_mpath(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_mpath);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_href(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_path(GF_LASeRCodec *lsr, u32 same_type)\n{\n\tu32 flag;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_path);\n\n\tif (same_type) {\n\t\tif (lsr->prev_path) {\n\t\t\tlsr_restore_base(lsr, (SVG_Element*)elt, (SVG_Element *)lsr->prev_path, (same_type==2) ? 1 : 0, 0);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[LASeR] samepath coded in bitstream but no path defined !\\n\"));\n\t\t}\n\t\tlsr_read_id(lsr, elt);\n\t\tif (same_type==2) lsr_read_fill(lsr, elt);\n\t\tlsr_read_path_type(lsr, elt, TAG_SVG_ATT_d, NULL, \"d\");\n\t} else {\n\t\tlsr_read_id(lsr, elt);\n\t\tlsr_read_rare_full(lsr, elt);\n\t\tlsr_read_fill(lsr, elt);\n\t\tlsr_read_stroke(lsr, elt);\n\t\tlsr_read_path_type(lsr, elt, TAG_SVG_ATT_d, NULL, \"d\");\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"hasPathLength\");\n\t\tif (flag) {\n\t\t\tGF_FieldInfo info;\n\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_pathLength, 1, 0, &info);\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_16_8(lsr, \"pathLength\");\n\t\t}\n\t\tlsr_read_any_attribute(lsr, elt, 1);\n\t\tlsr->prev_path = (SVG_Element*)elt;\n\t}\n\tlsr_read_group_content(lsr, elt, same_type);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_polygon(GF_LASeRCodec *lsr, Bool is_polyline, u32 same_type)\n{\n\tGF_FieldInfo info;\n\tGF_Node *elt = gf_node_new(lsr->sg, is_polyline ? TAG_SVG_polyline : TAG_SVG_polygon);\n\n\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_points, 1, 0, &info);\n\n\tif (same_type) {\n\t\tif (lsr->prev_polygon) {\n\t\t\tlsr_restore_base(lsr, (SVG_Element*)elt, (SVG_Element *)lsr->prev_polygon, /*(same_type==2) ? 1 : */ 0, /*(same_type==3) ? 1 : */ 0);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[LASeR] samepolyXXX coded in bitstream but no polyXXX defined !\\n\"));\n\t\t}\n\t\tlsr_read_id(lsr, elt);\n\t\tif (same_type==2) lsr_read_fill(lsr, elt);\n\t\telse if (same_type==3) lsr_read_stroke(lsr, elt);\n\t\tlsr_read_point_sequence(lsr, *(GF_List**)info.far_ptr, \"points\");\n\t} else {\n\t\tlsr_read_id(lsr, elt);\n\t\tlsr_read_rare_full(lsr, elt);\n\t\tlsr_read_fill(lsr, elt);\n\t\tlsr_read_stroke(lsr, elt);\n\t\tlsr_read_point_sequence(lsr, *(GF_List**)info.far_ptr, \"points\");\n\t\tlsr_read_any_attribute(lsr, elt, 1);\n\t\tlsr->prev_polygon = (SVG_Element*)elt;\n\t}\n\tlsr_read_group_content(lsr, elt, same_type);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_radialGradient(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_radialGradient);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_cx, 1, \"cx\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_cy, 1, \"cy\");\n\tlsr_read_gradient_units(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_r, 1, \"r\");\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_rect(GF_LASeRCodec *lsr, u32 same_type)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_rect);\n\n\tif (same_type) {\n\t\tif (lsr->prev_rect) {\n\t\t\tlsr_restore_base(lsr, (SVG_Element*)elt, (SVG_Element *)lsr->prev_rect, (same_type==2) ? 1 : 0, 0);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[LASeR] samerect coded in bitstream but no rect defined !\\n\"));\n\t\t}\n\t\tlsr_read_id(lsr, elt);\n\t\tif (same_type==2) lsr_read_fill(lsr, elt);\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_height, 0, \"height\");\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_width, 0, \"width\");\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x, 1, \"x\");\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y, 1, \"y\");\n\t} else {\n\t\tlsr_read_id(lsr, elt);\n\t\tlsr_read_rare_full(lsr, elt);\n\t\tlsr_read_fill(lsr, elt);\n\t\tlsr_read_stroke(lsr, elt);\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_height, 0, \"height\");\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_rx, 1, \"rx\");\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_ry, 1, \"ry\");\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_width, 0, \"width\");\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x, 1, \"x\");\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y, 1, \"y\");\n\t\tlsr_read_any_attribute(lsr, elt, 1);\n\t\tlsr->prev_rect = (SVG_Element*)elt;\n\t}\n\tlsr_read_group_content(lsr, elt, same_type);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_rectClip(GF_LASeRCodec *lsr)\n{\n\tu32 flag;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_LSR_rectClip);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_eRR(lsr, elt);\n\tGF_LSR_READ_INT(lsr, flag, 1, \"has_size\");\n\tif (flag) {\n\t\tSVG_Number num;\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_size, 1, 0, &info);\n\t\tlsr_read_coordinate(lsr, & num, 0, \"width\");\n\t\t((LASeR_Size*)info.far_ptr)->width = num.value;\n\t\tlsr_read_coordinate(lsr, & num, 0, \"height\");\n\t\t((LASeR_Size*)info.far_ptr)->height = num.value;\n\t}\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_script(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_script);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_eRR(lsr, elt);\n\tlsr_read_script_type(lsr, elt);\n\tlsr_read_href(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_selector(GF_LASeRCodec *lsr)\n{\n\tu32 flag;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_LSR_selector);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_eRR(lsr, elt);\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasChoice\");\n\tif (flag) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_choice, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"choice\");\n\t\tif (flag) {\n\t\t\tGF_LSR_READ_INT(lsr, ((LASeR_Choice*)info.far_ptr)->type, 1, \"type\");\n\t\t} else {\n\t\t\tGF_LSR_READ_INT(lsr, ((LASeR_Choice*)info.far_ptr)->choice_index, 8, \"value\");\n\t\t\t((LASeR_Choice*)info.far_ptr)->type = LASeR_CHOICE_N;\n\t\t}\n\t}\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_set(GF_LASeRCodec *lsr, SVG_Element *parent)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_set);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_attribute_name(lsr, elt);\n\tlsr_read_attribute_type(lsr, elt);\n\n\tlsr_read_smil_times(lsr, elt, TAG_SVG_ATT_begin, NULL, \"begin\", 1);\n\tlsr_read_duration(lsr, elt);\n\tlsr_read_anim_fill(lsr, elt);\n\tlsr_read_anim_repeatCount(lsr, elt);\n\tlsr_read_repeat_duration(lsr, elt);\n\tlsr_read_anim_restart(lsr, elt);\n\tlsr_read_anim_value(lsr, elt, TAG_SVG_ATT_to, \"to\");\n\tlsr_read_href(lsr, elt);\n\tlsr_read_lsr_enabled(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\n\tif (!lsr_setup_smil_anim(lsr, (SVG_Element*)elt, parent)) {\n\t\tgf_list_add(lsr->deferred_anims, elt);\n\t\tlsr_read_group_content_post_init(lsr, (SVG_Element*)elt, 1);\n\t} else {\n\t\tlsr_read_group_content(lsr, elt, 0);\n\t}\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_simpleLayout(GF_LASeRCodec *lsr)\n{\n\tu32 flag;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_LSR_simpleLayout);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tGF_LSR_READ_INT(lsr, flag, 1, \"has_delta\");\n\tif (flag) {\n\t\tSVG_Number num;\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_delta, 1, 0, &info);\n\t\tlsr_read_coordinate(lsr, & num, 0, \"width\");\n\t\t((LASeR_Size*)info.far_ptr)->width = num.value;\n\t\tlsr_read_coordinate(lsr, & num, 0, \"height\");\n\t\t((LASeR_Size*)info.far_ptr)->height = num.value;\n\t}\n\tlsr_read_eRR(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_stop(GF_LASeRCodec *lsr)\n{\n\tGF_FieldInfo info;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_stop);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\n\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_offset, 1, 0, &info);\n\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_16_8(lsr, \"offset\");\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_svg(GF_LASeRCodec *lsr, Bool init_node)\n{\n\tGF_FieldInfo info;\n\tSMIL_Duration snap;\n\tu32 flag;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_svg);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_string_attribute(lsr, elt, TAG_SVG_ATT_baseProfile, \"baseProfile\");\n\tlsr_read_string_attribute(lsr, elt, TAG_SVG_ATT_contentScriptType, \"contentScriptType\");\n\tlsr_read_eRR(lsr, elt);\n\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_height, 1, 0, &info);\n\tlsr_read_value_with_units(lsr, info.far_ptr, \"height\");\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasPlaybackOrder\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_playbackOrder, 1, 1, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"playbackOrder\");\n\t\tif (flag) *(SVG_PlaybackOrder*)info.far_ptr = SVG_PLAYBACKORDER_FORWARDONLY;\n\t}\n\n\tlsr_read_preserve_aspect_ratio(lsr, elt);\n\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"has_snapshotTime\");\n\tif (flag) {\n\t\tlsr_read_duration_ex(lsr, NULL, 0, &snap, \"snapshotTime\", 0);\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_snapshotTime, 1, 1, &info);\n\t\tif (snap.type==SMIL_DURATION_DEFINED) *((SVG_Clock *)info.far_ptr) = snap.clock_value;\n\t}\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasSyncBehavior\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_syncBehaviorDefault, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 2, \"syncBehaviorDefault\");\n\t\tswitch (flag) {\n\t\tcase 0:\n\t\t\t*((SMIL_SyncBehavior*)info.far_ptr) = SMIL_SYNCBEHAVIOR_CANSLIP;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*((SMIL_SyncBehavior*)info.far_ptr) = SMIL_SYNCBEHAVIOR_INDEPENDENT;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t*((SMIL_SyncBehavior*)info.far_ptr) = SMIL_SYNCBEHAVIOR_LOCKED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*((SMIL_SyncBehavior*)info.far_ptr) = SMIL_SYNCBEHAVIOR_INHERIT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasSyncToleranceDefault\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_syncToleranceDefault, 1, 0, &info);\n\t\t((SMIL_SyncTolerance*)info.far_ptr)->type = SMIL_SYNCTOLERANCE_VALUE;\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"choice\");\n\t\t((SMIL_SyncTolerance*)info.far_ptr)->value = lsr_read_vluimsbf5(lsr, \"value\");\n\t\t((SMIL_SyncTolerance*)info.far_ptr)->value /= lsr->time_resolution;\n\t}\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasTimelineBegin\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_timelineBegin, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"timelineBegin\");\n\t\tif (flag) *(SVG_TimelineBegin*)info.far_ptr = SVG_TIMELINEBEGIN_ONLOAD;\n\t}\n\tlsr_read_string_attribute(lsr, elt, TAG_SVG_ATT_version, \"version\");\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasViewBox\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_viewBox, 1, 0, &info);\n\t\t((SVG_ViewBox*)info.far_ptr)->x = lsr_read_fixed_16_8(lsr, \"viewbox.x\");\n\t\t((SVG_ViewBox*)info.far_ptr)->y = lsr_read_fixed_16_8(lsr, \"viewbox.y\");\n\t\t((SVG_ViewBox*)info.far_ptr)->width = lsr_read_fixed_16_8(lsr, \"viewbox.width\");\n\t\t((SVG_ViewBox*)info.far_ptr)->height = lsr_read_fixed_16_8(lsr, \"viewbox.height\");\n\t\t((SVG_ViewBox*)info.far_ptr)->is_set = 1;\n\t}\n\n\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_width, 1, 0, &info);\n\tlsr_read_value_with_units(lsr, info.far_ptr, \"width\");\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasZoomAndPan\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_zoomAndPan, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"zoomAndPan\");\n\t\t*((SVG_ZoomAndPan*)info.far_ptr) = flag ? SVG_ZOOMANDPAN_MAGNIFY : SVG_ZOOMANDPAN_DISABLE;\n\t}\n\tlsr_read_any_attribute(lsr, elt, 1);\n\t/*store current root for listeners with no focus target*/\n\tlsr->current_root = elt;\n\n\tif (init_node) {\n\t\tgf_node_register(elt, NULL);\n\t\tgf_sg_set_root_node(lsr->sg, elt);\n\t}\n\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_switch(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_switch);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_eRR(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\n\nstatic GF_Node *lsr_read_text(GF_LASeRCodec *lsr, u32 same_type)\n{\n\tu32 flag;\n\tGF_FieldInfo info;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_text);\n\tif (same_type) {\n\t\tif (lsr->prev_text) {\n\t\t\tlsr_restore_base(lsr, (SVG_Element *)elt, (SVG_Element *)lsr->prev_text, (same_type==2) ? 1 : 0, 0);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[LASeR] sametext coded in bitstream but no text defined !\\n\"));\n\t\t}\n\t\tlsr_read_id(lsr, elt);\n\t\tif (same_type==2) lsr_read_fill(lsr, elt);\n\t\tlsr_read_coord_list(lsr, elt, TAG_SVG_ATT_text_x, \"x\");\n\t\tlsr_read_coord_list(lsr, elt, TAG_SVG_ATT_text_y, \"y\");\n\t} else {\n\t\tlsr_read_id(lsr, elt);\n\t\tlsr_read_rare_full(lsr, elt);\n\t\tlsr_read_fill(lsr, elt);\n\t\tlsr_read_stroke(lsr, elt);\n\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"editable\");\n\t\tif (flag) {\n\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_editable, 1, 0, &info);\n\t\t\t*(SVG_Boolean*)info.far_ptr = flag;\n\t\t}\n\t\tlsr_read_float_list(lsr, elt, TAG_SVG_ATT_text_rotate, NULL, \"rotate\");\n\t\tlsr_read_coord_list(lsr, elt, TAG_SVG_ATT_text_x, \"x\");\n\t\tlsr_read_coord_list(lsr, elt, TAG_SVG_ATT_text_y, \"y\");\n\t\tlsr_read_any_attribute(lsr, elt, 1);\n\t\tlsr->prev_text = (SVG_Element*)elt;\n\t}\n\tlsr_read_group_content(lsr, elt, same_type);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_tspan(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_tspan);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_use(GF_LASeRCodec *lsr, Bool is_same)\n{\n\tGF_FieldInfo info;\n\tu32 flag;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_use);\n\tif (is_same) {\n\t\tif (lsr->prev_use) {\n\t\t\tlsr_restore_base(lsr, (SVG_Element *)elt, lsr->prev_use, 0, 0);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[LASeR] sameuse coded in bitstream but no use defined !\\n\"));\n\t\t}\n\t\tlsr_read_id(lsr, elt);\n\t\tlsr_read_href(lsr, elt);\n\t} else {\n\t\tlsr_read_id(lsr, elt);\n\t\tlsr_read_rare_full(lsr, elt);\n\t\tlsr_read_fill(lsr, elt);\n\t\tlsr_read_stroke(lsr, elt);\n\t\tlsr_read_eRR(lsr, elt);\n\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"hasOverflow\");\n\t\tif (flag) {\n\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_overflow, 1, 0, &info);\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Overflow*)info.far_ptr, 2, \"overflow\");\n\t\t}\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x, 1, \"x\");\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y, 1, \"y\");\n\t\tlsr_read_href(lsr, elt);\n\t\tlsr_read_any_attribute(lsr, elt, 1);\n\t\tlsr->prev_use = (SVG_Element*)elt;\n\t}\n\tlsr_read_group_content(lsr, elt, is_same);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_video(GF_LASeRCodec *lsr, SVG_Element *parent)\n{\n\tGF_FieldInfo info;\n\tu32 flag;\n\tGF_Node*elt = gf_node_new(lsr->sg, TAG_SVG_video);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_smil_times(lsr, elt, TAG_SVG_ATT_begin, NULL, \"begin\", 1);\n\tlsr_read_duration(lsr, elt);\n\tlsr_read_eRR(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_height, 1, \"height\");\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasOverlay\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_overlay, 1, 1, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"choice\");\n\t\tif (flag) {\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Overlay*)info.far_ptr, 1, \"choice\");\n\t\t} else {\n\t\t\tchar *str = NULL;\n\t\t\tlsr_read_byte_align_string(lsr, & str, \"overlayExt\");\n\t\t\tif (str) gf_free(str);\n\t\t}\n\t}\n\tlsr_read_preserve_aspect_ratio(lsr, elt);\n\tlsr_read_anim_repeatCount(lsr, elt);\n\tlsr_read_repeat_duration(lsr, elt);\n\tlsr_read_anim_restart(lsr, elt);\n\tlsr_read_sync_behavior(lsr, elt);\n\tlsr_read_sync_tolerance(lsr, elt);\n\tlsr_read_transform_behavior(lsr, elt);\n\tlsr_read_content_type(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_width, 1, \"width\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x, 1, \"x\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y, 1, \"y\");\n\tlsr_read_href(lsr, elt);\n\n\tlsr_read_clip_time(lsr, elt, TAG_SVG_ATT_clipBegin, \"clipBegin\");\n\tlsr_read_clip_time(lsr, elt, TAG_SVG_ATT_clipEnd, \"clipEnd\");\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasFullscreen\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_fullscreen, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, \"fullscreen\");\n\t}\n\n\tlsr_read_sync_reference(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_listener(GF_LASeRCodec *lsr, SVG_Element *parent)\n{\n\tu32 flag;\n\tGF_FieldInfo info;\n\tXMLEV_Event *ev = NULL;\n\tXMLRI *observer, *target, *handler;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_listener);\n\n\tobserver = target = handler = NULL;\n\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasDefaultAction\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_XMLEV_ATT_defaultAction, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, *(XMLEV_DefaultAction*)info.far_ptr, 1, \"defaultAction\");\n\t}\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasEvent\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_XMLEV_ATT_event, 1, 0, &info);\n\t\tlsr_read_event_type(lsr, info.far_ptr);\n\t\tev = info.far_ptr;\n\t}\n\t/*create default handler but UNINITIALIZED*/\n\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_XMLEV_ATT_handler, 1, 0, &info);\n\thandler = info.far_ptr;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasHandler\");\n\tif (flag) {\n\t\tlsr_read_any_uri(lsr, info.far_ptr, \"handler\");\n\t}\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasObserver\");\n\t/*TODO double check spec here*/\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_XMLEV_ATT_observer, 1, 0, &info);\n\t\tlsr_read_codec_IDREF(lsr, info.far_ptr, \"observer\");\n\t\tobserver = info.far_ptr;\n\t}\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasPhase\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_XMLEV_ATT_phase, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, *(XMLEV_Phase*)info.far_ptr, 1, \"phase\");\n\t}\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasPropagate\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_XMLEV_ATT_propagate, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, *(XMLEV_Propagate*)info.far_ptr, 1, \"propagate\");\n\t}\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasTarget\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_XMLEV_ATT_target, 1, 0, &info);\n\t\tlsr_read_codec_IDREF(lsr, info.far_ptr, \"target\");\n\t\ttarget = info.far_ptr;\n\t}\n\n\tlsr_read_lsr_enabled(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\n\t/*register listener element*/\n\t{\n\t\tBool post_pone = 0;\n\t\tSVG_Element *par = NULL;\n\t\tif (observer && observer->type == XMLRI_ELEMENTID) {\n\t\t\tif (observer->target) par = observer->target;\n\t\t}\n\t\tif (!par && target && (target->type == XMLRI_ELEMENTID)) {\n\t\t\tif (!target->target) post_pone = 1;\n\t\t\telse par = target->target;\n\t\t}\n\t\tif (!handler->target && !handler->string) {\n\t\t\thandler->type = XMLRI_ELEMENTID;\n\t\t\thandler->target = parent;\n\t\t}\n\t\t/*FIXME - double check with XML events*/\n\t\tif (!par && !observer) {\n\t\t\t/*all non-UI get attched to root*/\n\t\t\tif (ev && (ev->type>GF_EVENT_MOUSEWHEEL)) {\n\t\t\t\tpar = (SVG_Element*) lsr->current_root;\n\t\t\t}\n\t\t\telse if (parent) par = parent;\n\t\t\telse par = (SVG_Element*) lsr->current_root;\n\t\t}\n\t\tif (!par) post_pone = 1;\n\n\t\tif (post_pone) {\n\t\t\tgf_list_add(lsr->deferred_listeners, elt);\n\t\t} else {\n\t\t\tif (!par) par = parent;\n\t\t\tgf_node_dom_listener_add((GF_Node *)par, elt);\n\t\t}\n\t}\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_scene_content_model(GF_LASeRCodec *lsr, SVG_Element *parent)\n{\n\tGF_Node *n;\n\tu32 ntype;\n\tGF_LSR_READ_INT(lsr, ntype, 6, \"ch4\");\n\tn = NULL;\n\tswitch (ntype) {\n\tcase LSR_SCENE_CONTENT_MODEL_a:\n\t\tn = lsr_read_a(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_animate:\n\t\tn = lsr_read_animate(lsr, parent, 0);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_animateColor:\n\t\tn = lsr_read_animate(lsr, parent, 1);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_animateMotion:\n\t\tn = lsr_read_animateMotion(lsr, parent);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_animateTransform:\n\t\tn = lsr_read_animateTransform(lsr, parent);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_audio:\n\t\tn = lsr_read_audio(lsr, parent);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_circle:\n\t\tn = lsr_read_circle(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_conditional:\n\t\tn = lsr_read_conditional(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_cursorManager:\n\t\tn = lsr_read_cursorManager(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_defs:\n\t\tn = lsr_read_defs(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_desc:\n\t\tn = lsr_read_data(lsr, TAG_SVG_desc);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_ellipse:\n\t\tn = lsr_read_ellipse(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_foreignObject:\n\t\tn = lsr_read_foreignObject(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_g:\n\t\tn = lsr_read_g(lsr, 0);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_image:\n\t\tn = lsr_read_image(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_line:\n\t\tn = lsr_read_line(lsr, 0);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_linearGradient:\n\t\tn = lsr_read_linearGradient(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_metadata:\n\t\tn = lsr_read_data(lsr, TAG_SVG_metadata);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_mpath:\n\t\tn = lsr_read_mpath(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_path:\n\t\tn = lsr_read_path(lsr, 0);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_polygon:\n\t\tn = lsr_read_polygon(lsr, 0, 0);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_polyline:\n\t\tn = lsr_read_polygon(lsr, 1, 0);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_radialGradient:\n\t\tn = lsr_read_radialGradient(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_rect:\n\t\tn = lsr_read_rect(lsr, 0);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_rectClip:\n\t\tn = lsr_read_rectClip(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_sameg:\n\t\tn = lsr_read_g(lsr, 1);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_sameline:\n\t\tn = lsr_read_line(lsr, 1);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samepath:\n\t\tn = lsr_read_path(lsr, 1);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samepathfill:\n\t\tn = lsr_read_path(lsr, 2);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samepolygon:\n\t\tn = lsr_read_polygon(lsr, 0, 1);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samepolygonfill:\n\t\tn = lsr_read_polygon(lsr, 0, 2);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samepolygonstroke:\n\t\tn = lsr_read_polygon(lsr, 0, 3);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samepolyline:\n\t\tn = lsr_read_polygon(lsr, 1, 1);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samepolylinefill:\n\t\tn = lsr_read_polygon(lsr, 1, 2);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samepolylinestroke:\n\t\tn = lsr_read_polygon(lsr, 1, 3);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samerect:\n\t\tn = lsr_read_rect(lsr, 1);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samerectfill:\n\t\tn = lsr_read_rect(lsr, 2);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_sametext:\n\t\tn = lsr_read_text(lsr, 1);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_sametextfill:\n\t\tn = lsr_read_text(lsr, 2);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_sameuse:\n\t\tn = lsr_read_use(lsr, 1);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_script:\n\t\tn = lsr_read_script(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_selector:\n\t\tn = lsr_read_selector(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_set:\n\t\tn = lsr_read_set(lsr, parent);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_simpleLayout:\n\t\tn = lsr_read_simpleLayout(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_stop:\n\t\tn = lsr_read_stop(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_switch:\n\t\tn = lsr_read_switch(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_text:\n\t\tn = lsr_read_text(lsr, 0);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_title:\n\t\tn = lsr_read_data(lsr, TAG_SVG_title);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_tspan:\n\t\tn = lsr_read_tspan(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_use:\n\t\tn = lsr_read_use(lsr, 0);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_video:\n\t\tn = lsr_read_video(lsr, parent);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_listener:\n\t\tn = lsr_read_listener(lsr, parent);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_element_any:\n\t\tlsr_read_extend_class(lsr, NULL, 0, \"node\");\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_privateContainer:\n\t\tlsr_read_private_element_container(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_textContent:\n\t\tlsr_read_text_content(lsr, (GF_Node*)parent);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (n && n->sgprivate->interact && n->sgprivate->interact->dom_evt) {\n\t\tGF_DOM_Event evt;\n\t\tmemset(&evt, 0, sizeof(GF_DOM_Event));\n\t\tevt.type = GF_EVENT_LOAD;\n\t\tgf_dom_event_fire(n, &evt);\n\t}\n\treturn n;\n}\n\nstatic GF_Node *lsr_read_update_content_model(GF_LASeRCodec *lsr, SVG_Element *parent)\n{\n\tu32 flag;\n\tGF_Node *n=NULL;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"ch4\");\n\tif (flag) {\n\t\tGF_LSR_READ_INT(lsr, flag, 3, \"ch61\");\n\t\tswitch (flag) {\n\t\tcase LSR_UPDATE_CONTENT_MODEL2_conditional:\n\t\t\tn = lsr_read_conditional(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL2_cursorManager:\n\t\t\tn = lsr_read_cursorManager(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL2_extend:\n\t\t\tlsr_read_extend_class(lsr, NULL, 0, \"extend\");\n\t\t\treturn NULL;\n\t\tcase LSR_UPDATE_CONTENT_MODEL2_private:\n\t\t\tlsr_read_private_element_container(lsr);\n\t\t\treturn NULL;\n\t\tcase LSR_UPDATE_CONTENT_MODEL2_rectClip:\n\t\t\tn = lsr_read_rectClip(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL2_simpleLayout:\n\t\t\tn = lsr_read_simpleLayout(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL2_selector:\n\t\t\tn = lsr_read_selector(lsr);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tGF_LSR_READ_INT(lsr, flag, 6, \"ch6\");\n\t\tswitch(flag) {\n\t\tcase LSR_UPDATE_CONTENT_MODEL_a:\n\t\t\tn = lsr_read_a(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_animate:\n\t\t\tn = lsr_read_animate(lsr, parent, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_animateColor:\n\t\t\tn = lsr_read_animate(lsr, parent, 1);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_animateMotion:\n\t\t\tn = lsr_read_animateMotion(lsr, parent);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_animateTransform:\n\t\t\tn = lsr_read_animateTransform(lsr, parent);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_audio:\n\t\t\tn = lsr_read_audio(lsr, parent);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_circle:\n\t\t\tn = lsr_read_circle(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_defs:\n\t\t\tn = lsr_read_defs(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_desc:\n\t\t\tn = lsr_read_data(lsr, TAG_SVG_desc);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_ellipse:\n\t\t\tn = lsr_read_ellipse(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_foreignObject:\n\t\t\tn = lsr_read_foreignObject(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_g:\n\t\t\tn = lsr_read_g(lsr, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_image:\n\t\t\tn = lsr_read_image(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_line:\n\t\t\tn = lsr_read_line(lsr, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_linearGradient:\n\t\t\tn = lsr_read_linearGradient(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_metadata:\n\t\t\tn = lsr_read_data(lsr, TAG_SVG_metadata);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_mpath:\n\t\t\tn = lsr_read_mpath(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_path:\n\t\t\tn = lsr_read_path(lsr, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_polygon:\n\t\t\tn = lsr_read_polygon(lsr, 0, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_polyline:\n\t\t\tn = lsr_read_polygon(lsr, 1, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_radialGradient:\n\t\t\tn = lsr_read_radialGradient(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_rect:\n\t\t\tn = lsr_read_rect(lsr, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_script:\n\t\t\tn = lsr_read_script(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_set:\n\t\t\tn = lsr_read_set(lsr, parent);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_stop:\n\t\t\tn = lsr_read_stop(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_svg:\n\t\t\tn = lsr_read_svg(lsr, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_switch:\n\t\t\tn = lsr_read_switch(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_text:\n\t\t\tn = lsr_read_text(lsr, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_title:\n\t\t\tn = lsr_read_data(lsr, TAG_SVG_title);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_tspan:\n\t\t\tn = lsr_read_tspan(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_use:\n\t\t\tn = lsr_read_use(lsr, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_video:\n\t\t\tn = lsr_read_video(lsr, parent);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_listener:\n\t\t\tn = lsr_read_listener(lsr, parent);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (n && n->sgprivate->interact && n->sgprivate->interact->dom_evt) {\n\t\tGF_DOM_Event evt;\n\t\tmemset(&evt, 0, sizeof(GF_DOM_Event));\n\t\tevt.type = GF_EVENT_LOAD;\n\t\tgf_dom_event_fire(n, &evt);\n\t}\n\treturn n;\n}\n\nstatic void lsr_read_group_content(GF_LASeRCodec *lsr, GF_Node *elt, Bool skip_object_content)\n{\n\tu32 i, count;\n\tif (lsr->last_error) return;\n\n\tif (!skip_object_content) lsr_read_object_content(lsr, (SVG_Element*)elt);\n\n\n\t/*node attributes are all parsed*/\n\tif (elt->sgprivate->tag!=TAG_SVG_script)\n\t\tgf_node_init(elt);\n\n\tGF_LSR_READ_INT(lsr, count, 1, \"opt_group\");\n\tif (count) {\n\t\tGF_ChildNodeItem *last = NULL;\n\t\tcount = lsr_read_vluimsbf5(lsr, \"occ0\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Node *n;\n\t\t\tif (lsr->last_error) return;\n\t\t\tn = lsr_read_scene_content_model(lsr, (SVG_Element*)elt);\n\t\t\tif (n) {\n\t\t\t\tgf_node_register(n, elt);\n\t\t\t\tgf_node_list_add_child_last(& ((SVG_Element*)elt)->children, n, &last);\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[LASeR] ############## end %s ###########\\n\", gf_node_get_class_name(n)));\n\t\t\t} else {\n\t\t\t\t/*either error or text content*/\n\t\t\t}\n\t\t}\n\t}\n\n\tif (elt->sgprivate->tag==TAG_SVG_script)\n\t\tgf_node_init(elt);\n}\n\nstatic void lsr_read_group_content_post_init(GF_LASeRCodec *lsr, SVG_Element *elt, Bool skip_init)\n{\n\tu32 i, count;\n\tif (lsr->last_error) return;\n\tlsr_read_object_content(lsr, elt);\n\n\tGF_LSR_READ_INT(lsr, count, 1, \"opt_group\");\n\tif (count) {\n\t\tGF_ChildNodeItem *last = NULL;\n\t\tcount = lsr_read_vluimsbf5(lsr, \"occ0\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Node *n;\n\t\t\tif (lsr->last_error) return;\n\t\t\tn = lsr_read_scene_content_model(lsr, elt);\n\t\t\tif (n) {\n\t\t\t\tgf_node_register(n, (GF_Node*)elt);\n\t\t\t\tgf_node_list_add_child_last(&elt->children, n, &last);\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[LASeR] ############## end %s ###########\\n\", gf_node_get_class_name(n)));\n\t\t\t} else {\n\t\t\t\t/*either error or text content*/\n\t\t\t}\n\t\t}\n\t}\n\tif (!skip_init) gf_node_init((GF_Node*)elt);\n}\n\nstatic void *lsr_read_update_value_indexed(GF_LASeRCodec *lsr, GF_Node*node, u32 fieldType, void *rep_val, u32 idx, Bool is_insert, Bool is_com, u32 *single_field_type)\n{\n\tFixed *f_val;\n\tSVG_Number num;\n\n\tswitch (fieldType) {\n\tcase SVG_Points_datatype/*ITYPE_point*/:\n\t{\n\t\tSVG_Point *pt;\n\t\tListOfXXX *res;\n\t\tGF_SAFEALLOC(res, ListOfXXX);\n\t\tif (!res) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\t*res = gf_list_new();\n\t\tpt = (SVG_Point*)gf_malloc(sizeof(SVG_Point));\n\t\tif (!pt) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\tlsr_read_coordinate(lsr, &num, 0, \"coordX\");\n\t\t\tpt->x = num.value;\n\t\t\tlsr_read_coordinate(lsr, &num, 0, \"coordY\");\n\t\t\tpt->y = num.value;\n\t\t\tgf_list_add(*res, pt);\n\t\t}\n\t\treturn res;\n\t}\n\tcase SMIL_KeySplines_datatype/*ITYPE_float*/:\n\t{\n\t\tListOfXXX *res;\n\t\tGF_SAFEALLOC(res, ListOfXXX);\n\t\tif (!res) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\t*res = gf_list_new();\n\t\tf_val = (Fixed*)gf_malloc(sizeof(Fixed));\n\t\tif (!f_val) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\t*f_val = lsr_read_fixed_16_8(lsr, \"floatValue\");\n\t\t\tgf_list_add(*res, f_val);\n\t\t}\n\t\treturn res;\n\t}\n\tcase SVG_StrokeDashArray_datatype:\n\tcase SVG_ViewBox_datatype:\n\t\tf_val = (Fixed*)gf_malloc(sizeof(Fixed));\n\t\tif (!f_val) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\t*f_val = lsr_read_fixed_16_8(lsr, \"floatValue\");\n\t\t}\n\t\treturn f_val;\n\tcase SMIL_KeyTimes_datatype/*ITYPE_keyTime*/:\n\t{\n\t\tListOfXXX *res;\n\t\tGF_SAFEALLOC(res, ListOfXXX);\n\t\tif (!res) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\t*res = gf_list_new();\n\t\tf_val = lsr_read_fraction_12_item(lsr);\n\t\tif (f_val) gf_list_add(*res, f_val);\n\t\treturn res;\n\t}\n\tcase SMIL_KeyPoints_datatype/*ITYPE_0to1 - keyPoints*/:\n\t{\n\t\tListOfXXX *res;\n\t\tGF_SAFEALLOC(res, ListOfXXX);\n\t\tif (!res) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\t*res = gf_list_new();\n\t\tf_val = (Fixed*)gf_malloc(sizeof(Fixed));\n\t\tif (!f_val) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\t*f_val = lsr_read_fixed_clamp(lsr, \"value\");\n\t\t\tgf_list_add(*res, f_val);\n\t\t}\n\t\treturn res;\n\t}\n\tcase SMIL_Times_datatype/*ITYPE_smil_time*/:\n\t{\n\t\tListOfXXX *res;\n\t\tGF_SAFEALLOC(res, ListOfXXX);\n\t\tif (!res) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\t*res = gf_list_new();\n\t\tif (! *res) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\tgf_list_add(*res, lsr_read_smil_time(lsr, node) );\n\t\t}\n\t\treturn res;\n\t}\n\tdefault:\n\t\tlsr_read_extension(lsr, \"privateData\");\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic void lsr_read_update_value(GF_LASeRCodec *lsr, GF_Node *node, u32 att_tag, u32 fieldType, void *val, u32 node_tag)\n{\n\tu32 is_default, has_escape, escape_val = 0;\n\tSVG_Number num, *n;\n\n\tswitch (fieldType) {\n\tcase SVG_Boolean_datatype:\n\t\tGF_LSR_READ_INT(lsr, *(SVG_Boolean*)val, 1, \"val\");\n\t\tbreak;\n\tcase SVG_Paint_datatype:\n\t\tlsr_read_paint(lsr, (SVG_Paint*)val, \"val\");\n\t\tbreak;\n\t/*\n\t\tcase SVG_AudioLevel_datatype:\n\t\t\tn = val;\n\t\t\tGF_LSR_READ_INT(lsr, is_default, 1, \"isDefaultValue\");\n\t\t\tif (is_default) n->type=SVG_NUMBER_INHERIT;\n\t\t\telse {\n\t\t\t\tn->type = SVG_NUMBER_VALUE;\n\t\t\t\tn->value = lsr_read_fixed_clamp(lsr, \"val\");\n\t\t\t}\n\t\t\tbreak;\n\t*/\n\tcase SVG_Transform_Scale_datatype:\n\t\t((SVG_Point *)val)->x = lsr_read_fixed_16_8(lsr, \"scale_x\");\n\t\t((SVG_Point *)val)->y = lsr_read_fixed_16_8(lsr, \"scale_y\");\n\t\tbreak;\n\tcase LASeR_Size_datatype:\n\tcase SVG_Transform_Translate_datatype:\n\t\tlsr_read_coordinate(lsr, &num, 0, \"translation_x\");\n\t\t((SVG_Point *)val)->x = num.value;\n\t\tlsr_read_coordinate(lsr, &num, 0, \"translation_y\");\n\t\t((SVG_Point *)val)->y = num.value;\n\t\tbreak;\n\tcase SVG_Transform_Rotate_datatype:\n\t\tGF_LSR_READ_INT(lsr, is_default, 1, \"isDefaultValue\");\n\t\tif (is_default) ((SVG_Point_Angle*)val)->angle = 0;\n\t\telse {\n\t\t\tGF_LSR_READ_INT(lsr, has_escape, 1, \"escapeFlag\");\n\t\t\tif (has_escape) {\n\t\t\t\tGF_LSR_READ_INT(lsr, escape_val, 2, \"escapeEnum\");\n\t\t\t\t((SVG_Point_Angle*)val)->angle = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t((SVG_Point_Angle*)val)->angle = lsr_read_fixed_16_8(lsr, \"rotate\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SVG_Transform_datatype:\n\t\tlsr_read_matrix(lsr, val);\n\t\tbreak;\n\tcase SVG_Number_datatype:\n\tcase SVG_FontSize_datatype:\n\tcase SVG_Length_datatype:\n\t\tn = (SVG_Number*)val;\n\t\tswitch (att_tag) {\n\t\t/*fractions*/\n\t\tcase TAG_SVG_ATT_audio_level:\n\t\tcase TAG_SVG_ATT_fill_opacity:\n\t\tcase TAG_SVG_ATT_offset:\n\t\tcase TAG_SVG_ATT_opacity:\n\t\tcase TAG_SVG_ATT_solid_opacity:\n\t\tcase TAG_SVG_ATT_stop_opacity:\n\t\tcase TAG_SVG_ATT_stroke_opacity:\n\t\tcase TAG_SVG_ATT_viewport_fill_opacity:\n\t\t\tGF_LSR_READ_INT(lsr, is_default, 1, \"isDefaultValue\");\n\t\t\tif (is_default) n->type=SVG_NUMBER_INHERIT;\n\t\t\telse {\n\t\t\t\tn->type = SVG_NUMBER_VALUE;\n\t\t\t\tn->value = lsr_read_fixed_clamp(lsr, \"val\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_width:\n\t\tcase TAG_SVG_ATT_height:\n\t\t\tif (node_tag==TAG_SVG_svg) {\n\t\t\t\tlsr_read_value_with_units(lsr, n, \"val\");\n\t\t\t} else {\n\t\t\t\tlsr_read_coordinate(lsr, n, 0, \"val\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LSR_READ_INT(lsr, is_default, 1, \"isDefaultValue\");\n\t\t\tif (is_default) n->type=SVG_NUMBER_INHERIT;\n\t\t\telse {\n\t\t\t\tGF_LSR_READ_INT(lsr, has_escape, 1, \"escapeFlag\");\n\t\t\t\tif (has_escape) {\n\t\t\t\t\tGF_LSR_READ_INT(lsr, escape_val, 2, \"escapeEnum\");\n\t\t\t\t\tn->type = SVG_NUMBER_AUTO;//only lineIncrement\n\t\t\t\t} else {\n\t\t\t\t\tn->type = SVG_NUMBER_VALUE;\n\t\t\t\t\tn->value = lsr_read_fixed_16_8(lsr, \"val\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SVG_Coordinate_datatype:\n\t\tn = (SVG_Number*)val;\n\t\tn->type = SVG_NUMBER_VALUE;\n\t\tlsr_read_coordinate(lsr, n, 0, \"val\");\n\t\tbreak;\n\n\tcase SVG_Rotate_datatype:\n\t\tn = (SVG_Number*)val;\n\t\tGF_LSR_READ_INT(lsr, is_default, 1, \"isDefaultValue\");\n\t\tif (is_default) n->type=SVG_NUMBER_INHERIT;\n\t\telse {\n\t\t\tGF_LSR_READ_INT(lsr, has_escape, 1, \"escapeFlag\");\n\t\t\tif (has_escape) {\n\t\t\t\tGF_LSR_READ_INT(lsr, escape_val, 2, \"escapeEnum\");\n\t\t\t\tn->type = escape_val ? SVG_NUMBER_AUTO_REVERSE : SVG_NUMBER_AUTO;\n\t\t\t} else {\n\t\t\t\tn->type = SVG_NUMBER_VALUE;\n\t\t\t\tn->value = lsr_read_fixed_16_8(lsr, \"rotate\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SVG_Coordinates_datatype:\n\t\tlsr_read_float_list(lsr, NULL, 0, val, \"val\");\n\t\tbreak;\n\tcase SVG_ViewBox_datatype:\n\t{\n\t\tu32 count;\n\t\tSVG_ViewBox *vb = (SVG_ViewBox *)val;\n\t\tGF_LSR_READ_INT(lsr, count, 1, \"isDefault\");\n\t\tif (count) {\n\t\t\tvb->is_set = 0;\n\t\t} else {\n\t\t\tvb->is_set = 1;\n\t\t\tGF_LSR_READ_INT(lsr, count, 1, \"escapeFlag\");\n\t\t\tcount = lsr_read_vluimsbf5(lsr, \"count\");\n\t\t\tif (count) {\n\t\t\t\tvb->x = lsr_read_fixed_16_8(lsr, \"val\");\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\tif (count) {\n\t\t\t\tvb->y = lsr_read_fixed_16_8(lsr, \"val\");\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\tif (count) {\n\t\t\t\tvb->width = lsr_read_fixed_16_8(lsr, \"val\");\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\tif (count) {\n\t\t\t\tvb->height = lsr_read_fixed_16_8(lsr, \"val\");\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\tcase XMLRI_datatype:\n\tcase SVG_Focus_datatype:\n\t\tif ((att_tag==TAG_XLINK_ATT_href) || (att_tag==TAG_SVG_ATT_syncReference)) {\n\t\t\tlsr_read_any_uri(lsr, (XMLRI*)val, \"val\");\n\t\t} else {\n\t\t\tBool is_escape;\n\t\t\tu32 ID;\n\t\t\tescape_val = ID = 0;\n\t\t\tis_escape = 0;\n\t\t\tGF_LSR_READ_INT(lsr, is_default, 1, \"isDefault\");\n\t\t\tif (!is_default) {\n\t\t\t\tGF_LSR_READ_INT(lsr, is_escape, 1, \"isEscape\");\n\t\t\t\tif (is_escape) {\n\t\t\t\t\tGF_LSR_READ_INT(lsr, escape_val, 2, \"escapeEnumVal\");\n\t\t\t\t} else {\n\t\t\t\t\tID = lsr_read_vluimsbf5(lsr, \"ID\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (att_tag==SVG_Focus_datatype) {\n\t\t\t\tif (is_default) ((SVG_Focus*)val)->type = SVG_FOCUS_AUTO;\n\t\t\t\telse if (is_escape) ((SVG_Focus*)val)->type = escape_val;\n\t\t\t\telse {\n\t\t\t\t\t((SVG_Focus*)val)->type = SVG_FOCUS_IRI;\n\t\t\t\t\t((SVG_Focus*)val)->target.type = XMLRI_ELEMENTID;\n\t\t\t\t\t((SVG_Focus*)val)->target.node_id = ID;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (is_default) ((XMLRI*)val)->type = XMLRI_STRING;\n\t\t\t\telse {\n\t\t\t\t\t((XMLRI *)val)->type = XMLRI_ELEMENTID;\n\t\t\t\t\t((XMLRI *)val)->node_id = ID;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase DOM_String_datatype:\n\tcase SVG_ContentType_datatype:\n\tcase SVG_LanguageID_datatype:\n\t\tlsr_read_byte_align_string(lsr, (char**)val, \"val\");\n\t\tbreak;\n\tcase SVG_Motion_datatype:\n\t\tlsr_read_coordinate(lsr, &num, 0, \"pointValueX\");\n\t\t((GF_Matrix2D*)val)->m[2] = num.value;\n\t\tlsr_read_coordinate(lsr, &num, 0, \"pointValueY\");\n\t\t((GF_Matrix2D*)val)->m[5] = num.value;\n\t\tbreak;\n\tcase SVG_Points_datatype:\n\t\tlsr_read_point_sequence(lsr, *(GF_List **)val, \"val\");\n\t\tbreak;\n\tcase SVG_PathData_datatype:\n\t\tlsr_read_path_type(lsr, NULL, 0, (SVG_PathData*)val, \"val\");\n\t\tbreak;\n\tcase SVG_FontFamily_datatype:\n\t{\n\t\tu32 idx;\n\t\tSVG_FontFamily *ff = (SVG_FontFamily *)val;\n\t\tGF_LSR_READ_INT(lsr, idx, 1, \"isDefault\");\n\t\tff->type = SVG_FONTFAMILY_INHERIT;\n\t\tif (!idx) {\n\t\t\tchar *ft;\n\t\t\tGF_LSR_READ_INT(lsr, idx, 1, \"escapeFlag\");\n\t\t\tidx = lsr_read_vluimsbf5(lsr, \"index\");\n\t\t\tif (ff->value) gf_free(ff->value);\n\t\t\tff->value = NULL;\n\t\t\tft = (char*)gf_list_get(lsr->font_table, idx);\n\t\t\tif (ft) {\n\t\t\t\tff->value = gf_strdup(ft);\n\t\t\t\tff->type = SVG_FONTFAMILY_VALUE;\n\t\t\t}\n\t\t}\n\t}\n\t\tbreak;\n\tcase LASeR_Choice_datatype:\n\t\tGF_LSR_READ_INT(lsr, is_default, 1, \"isDefaultValue\");\n\t\tif (is_default) ((LASeR_Choice *)val)->type = LASeR_CHOICE_ALL;\n\t\telse {\n\t\t\tGF_LSR_READ_INT(lsr, has_escape, 1, \"escapeFlag\");\n\t\t\tif (has_escape) {\n\t\t\t\tGF_LSR_READ_INT(lsr, escape_val, 2, \"escapeEnum\");\n\t\t\t\t((LASeR_Choice *)val)->type = escape_val ? LASeR_CHOICE_NONE : LASeR_CHOICE_ALL;\n\t\t\t} else {\n\t\t\t\t((LASeR_Choice *)val)->type = LASeR_CHOICE_N;\n\t\t\t\t((LASeR_Choice *)val)->choice_index = lsr_read_vluimsbf5(lsr, \"value\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif ((fieldType>=SVG_FillRule_datatype) && (fieldType<=SVG_LAST_U8_PROPERTY)) {\n\t\t\t/*TODO fixme, check inherit values*/\n\t\t\tGF_LSR_READ_INT(lsr, is_default, 1, \"isDefaultValue\");\n\t\t\tif (is_default) *(u8 *)val = 0;\n\t\t\telse *(u8 *)val = lsr_read_vluimsbf5(lsr, \"val\");\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[LASeR] Warning: update value not supported: fieldType %d - attribute tag %d\\n\", fieldType, att_tag));\n\t\t}\n\t}\n\tif (node) {\n\t\t//gf_node_dirty_set(node, 0, 0);\n\t\tgf_node_changed(node, NULL);\n\t}\n}\n\nstatic u32 lsr_get_attribute_name(GF_LASeRCodec *lsr)\n{\n\tu32 val = 1;\n\tGF_LSR_READ_INT(lsr, val, 1, \"has_attributeName\");\n\tif (!val) return -1;\n\n\tGF_LSR_READ_INT(lsr, val, 1, \"choice\");\n\tif (val) {\n\t\tlsr_read_vluimsbf5(lsr, \"item[i]\");\n\t\tlsr_read_vluimsbf5(lsr, \"item[i]\");\n\t\treturn -1;\n\t} else {\n\t\tGF_LSR_READ_INT(lsr, val, 8, \"attributeName\");\n\t\treturn val;\n\t}\n}\n\nstatic GF_Err lsr_read_add_replace_insert(GF_LASeRCodec *lsr, GF_List *com_list, u32 com_type)\n{\n\tGF_FieldInfo info;\n\tGF_Node *n, *operandNode;\n\tGF_Command *com;\n\tGF_CommandField *field;\n\ts32 idx, att_type, op_att_type;\n\tu32 type, idref, op_idref = 0;\n\n\toperandNode = NULL;\n\top_att_type = -1;\n\n\tatt_type = lsr_get_attribute_name(lsr);\n\n\tidx = -1;\n\tif (com_type) {\n\t\tGF_LSR_READ_INT(lsr, type, 1, \"has_index\");\n\t\tif (type) idx = lsr_read_vluimsbf5(lsr, \"index\");\n\t}\n\tif (com_type!=3) {\n\t\tGF_LSR_READ_INT(lsr, type, 1, \"has_operandAttribute\");\n\t\tif (type) GF_LSR_READ_INT(lsr, op_att_type, 8, \"attributeName\");\n\t\tGF_LSR_READ_INT(lsr, type, 1, \"has_operandElementId\");\n\t\tif (type) {\n\t\t\top_idref = lsr_read_codec_IDREF_command(lsr, \"operandElementId\");\n\t\t\toperandNode = gf_sg_find_node(lsr->sg, op_idref);\n\t\t\tif (!operandNode)\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t}\n\tidref = lsr_read_codec_IDREF_command(lsr, \"ref\");\n\n\tn = gf_sg_find_node(lsr->sg, idref);\n\tif (!n) {\n\t\tif (!com_list) {\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t}\n\n\tGF_LSR_READ_INT(lsr, type, 1, \"has_value\");\n\tif (type) {\n\t\t/*node or node-list replacement*/\n\t\tif (att_type==-2) {\n\t\t\tlsr_read_byte_align_string(lsr, NULL, \"anyXML\");\n\t\t}\n\t\telse if (att_type<0) {\n\t\t\tGF_Node *new_node;\n\t\t\tif (!com_type)\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tGF_LSR_READ_INT(lsr, type, 1, \"isInherit\");\n\t\t\tif (type)\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tif (idx==-1) {\n\t\t\t\tGF_LSR_READ_INT(lsr, type, 1, \"escapeFlag\");\n\t\t\t\tif (type)\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\n\t\t\tnew_node = lsr_read_update_content_model(lsr, (idx==-1) ? NULL : (SVG_Element *)n);\n\t\t\tif (com_list) {\n\t\t\t\tcom = gf_sg_command_new(lsr->sg, (com_type==3) ? GF_SG_LSR_INSERT : GF_SG_LSR_REPLACE);\n\t\t\t\tgf_list_add(com_list, com);\n\t\t\t\tif (n) {\n\t\t\t\t\tcom->node = n;\n\t\t\t\t\tgf_node_register(com->node, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tcom->RouteID = idref;\n\t\t\t\t\tgf_list_add(lsr->unresolved_commands, com);\n\t\t\t\t}\n\t\t\t\tfield = gf_sg_command_field_new(com);\n\t\t\t\tfield->pos = idx;\n\t\t\t\tfield->new_node = new_node;\n\t\t\t\tif (new_node) gf_node_register(new_node, NULL);\n\t\t\t} else if (com_type==3) {\n\t\t\t\tgf_node_list_insert_child(& ((SVG_Element *)n)->children, new_node, idx);\n\t\t\t\tif (new_node) gf_node_register(new_node, n);\n\t\t\t} else {\n\t\t\t\t/*child replacement*/\n\t\t\t\tif (idx!=-1) {\n\t\t\t\t\tGF_Node *old = gf_node_list_get_child( ((SVG_Element *)n)->children, idx);\n\t\t\t\t\tif (old)\n\t\t\t\t\t\tgf_node_replace(old, new_node, 0);\n\t\t\t\t\telse {\n\t\t\t\t\t\tgf_node_list_add_child( & ((SVG_Element *)n)->children, new_node);\n\t\t\t\t\t\tif (new_node) gf_node_register(new_node, n);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/*node replacement*/\n\t\t\t\t\tgf_node_replace(n, new_node, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*value replace/add*/\n\t\telse if (com_list) {\n\t\t\tu32 field_type;\n\t\t\tBool text_content = 0;\n\t\t\tcom = gf_sg_command_new(lsr->sg, (com_type==0) ? GF_SG_LSR_ADD : (com_type==3) ? GF_SG_LSR_INSERT : GF_SG_LSR_REPLACE);\n\t\t\tfield = gf_sg_command_field_new(com);\n\t\t\tfield->pos = idx;\n\t\t\tfield_type = 0;\n\t\t\tswitch (att_type) {\n\t\t\t/*text*/\n\t\t\tcase LSR_UPDATE_TYPE_TEXT_CONTENT:\n\t\t\t\ttext_content = 1;\n\t\t\t\tbreak;\n\t\t\t/*matrix.translation, scale or rotate*/\n\t\t\tcase LSR_UPDATE_TYPE_SCALE:\n\t\t\t\tfield->fieldType = field_type = SVG_Transform_Scale_datatype;\n\t\t\t\tfield->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);\n\t\t\t\tbreak;\n\t\t\tcase LSR_UPDATE_TYPE_ROTATE:\n\t\t\t\tfield->fieldType = field_type = SVG_Transform_Rotate_datatype;\n\t\t\t\tfield->fieldIndex = TAG_SVG_ATT_transform;\n\t\t\t\tbreak;\n\t\t\tcase LSR_UPDATE_TYPE_TRANSLATION:\n\t\t\t\tfield->fieldType = field_type = SVG_Transform_Translate_datatype;\n\t\t\t\tfield->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);\n\t\t\t\tbreak;\n\t\t\tcase LSR_UPDATE_TYPE_SVG_HEIGHT:\n\t\t\t\tfield->fieldIndex = TAG_SVG_ATT_height;\n\t\t\t\tfield_type = field->fieldType = SVG_Length_datatype;\n\t\t\t\tbreak;\n\t\t\tcase LSR_UPDATE_TYPE_SVG_WIDTH:\n\t\t\t\tfield->fieldIndex = TAG_SVG_ATT_width;\n\t\t\t\tfield_type = field->fieldType = SVG_Length_datatype;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfield->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);\n\t\t\t\tif (field->fieldIndex == (u32)-1) {\n\t\t\t\t\tlsr->last_error = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\tgf_sg_command_del(com);\n\t\t\t\t\treturn lsr->last_error;\n\t\t\t\t}\n\t\t\t\tfield_type = field->fieldType = gf_xml_get_attribute_type(field->fieldIndex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_list_add(com_list, com);\n\t\t\tif (n) {\n\t\t\t\tcom->node = n;\n\t\t\t\tgf_node_register(com->node, NULL);\n\t\t\t} else {\n\t\t\t\tcom->RouteID = idref;\n\t\t\t\tgf_list_add(lsr->unresolved_commands, com);\n\t\t\t}\n\t\t\tif (idx==-1) {\n\t\t\t\tif (text_content) {\n\t\t\t\t\tGF_DOMText *text = gf_dom_new_text_node(lsr->sg);\n\t\t\t\t\tgf_node_register((GF_Node *)text, NULL);\n\t\t\t\t\tlsr_read_byte_align_string(lsr, &text->textContent, \"val\");\n\t\t\t\t\tfield->new_node = (GF_Node*)text;\n\t\t\t\t} else {\n\t\t\t\t\tfield->field_ptr = gf_svg_create_attribute_value(field_type);\n\t\t\t\t\tlsr_read_update_value(lsr, NULL, field->fieldIndex, field->fieldType, field->field_ptr, n ? n->sgprivate->tag : 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfield->field_ptr = lsr_read_update_value_indexed(lsr, (GF_Node*)n, field_type, NULL, idx, com_type==LSR_UPDATE_INSERT, 1, &field->fieldType);\n\t\t\t}\n\t\t} else {\n\t\t\tGF_Point2D matrix_tmp;\n\t\t\tSVG_Point_Angle matrix_tmp_rot;\n\t\t\tu32 fieldIndex = 0;\n\t\t\tu32 field_type = 0;\n\t\t\tBool text_content = 0;\n\t\t\tBool is_lsr_transform = 0;\n\t\t\tswitch (att_type) {\n\t\t\t/*text*/\n\t\t\tcase LSR_UPDATE_TYPE_TEXT_CONTENT:\n\t\t\t\ttext_content = 1;\n\t\t\t\tbreak;\n\t\t\t/*matrix.translation, scale or rotate*/\n\t\t\tcase LSR_UPDATE_TYPE_SCALE:\n\t\t\t\tinfo.far_ptr = (void *)&matrix_tmp;\n\t\t\t\tfield_type = SVG_Transform_Scale_datatype;\n\t\t\t\tis_lsr_transform = 1;\n\t\t\t\tbreak;\n\t\t\tcase LSR_UPDATE_TYPE_ROTATE:\n\t\t\t\tinfo.far_ptr = (void *)&matrix_tmp_rot;\n\t\t\t\tfield_type = SVG_Transform_Rotate_datatype;\n\t\t\t\tis_lsr_transform = 1;\n\t\t\t\tbreak;\n\t\t\tcase LSR_UPDATE_TYPE_TRANSLATION:\n\t\t\t\tinfo.far_ptr = (void *)&matrix_tmp;\n\t\t\t\tfield_type = SVG_Transform_Translate_datatype;\n\t\t\t\tis_lsr_transform = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfieldIndex = gf_lsr_anim_type_to_attribute(att_type);\n\t\t\t\tgf_node_get_attribute_by_tag(n, fieldIndex, 1, 0, &info);\n\t\t\t\tfield_type = info.fieldType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo.fieldType = field_type;\n\t\t\tif (is_lsr_transform) {\n\t\t\t\tSVG_Transform *dest;\n\t\t\t\tif (idx==-1) {\n\t\t\t\t\tlsr_read_update_value(lsr, NULL, fieldIndex, field_type, info.far_ptr, 0);\n\t\t\t\t} else {\n\t\t\t\t\tassert(0);\n\t\t\t\t}\n\n\n//\t\t\t\tfieldIndex = gf_node_get_attribute_by_tag((GF_Node*)n, TAG_SVG_ATT_transform, 1, 1, &info);\n\t\t\t\tdest = (SVG_Transform *)info.far_ptr;\n\t\t\t\tif (com_type) {\n\t\t\t\t\tGF_Point2D scale, translate;\n\t\t\t\t\tSVG_Point_Angle rotate;\n\t\t\t\t\tif (gf_mx2d_decompose(&dest->mat, &scale, &rotate.angle, &translate)) {\n\t\t\t\t\t\tgf_mx2d_init(dest->mat);\n\t\t\t\t\t\tif (att_type==LSR_UPDATE_TYPE_SCALE) scale = matrix_tmp;\n\t\t\t\t\t\telse if (att_type==LSR_UPDATE_TYPE_TRANSLATION) translate = matrix_tmp;\n\t\t\t\t\t\telse if (att_type==LSR_UPDATE_TYPE_ROTATE) rotate = matrix_tmp_rot;\n\n\t\t\t\t\t\tgf_mx2d_add_scale(&dest->mat, scale.x, scale.y);\n\t\t\t\t\t\tgf_mx2d_add_rotation(&dest->mat, 0, 0, rotate.angle);\n\t\t\t\t\t\tgf_mx2d_add_translation(&dest->mat, translate.x, translate.y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (att_type==LSR_UPDATE_TYPE_SCALE) gf_mx2d_add_scale(&dest->mat, matrix_tmp.x, matrix_tmp.y);\n\t\t\t\telse if (att_type==LSR_UPDATE_TYPE_TRANSLATION) gf_mx2d_add_translation(&dest->mat, matrix_tmp.x, matrix_tmp.y);\n\t\t\t\telse if (att_type==LSR_UPDATE_TYPE_ROTATE) gf_mx2d_add_rotation(&dest->mat, 0, 0, matrix_tmp_rot.angle);\n\n\t\t\t\tgf_node_changed((GF_Node*)n, &info);\n\t\t\t}\n\t\t\telse if (com_type) {\n\t\t\t\tif (text_content) {\n\t\t\t\t\tGF_DOMText *t = NULL;\n\t\t\t\t\tif (idx>=0) {\n\t\t\t\t\t\tif (com_type==LSR_UPDATE_INSERT) {\n\t\t\t\t\t\t\tt = gf_dom_new_text_node(n->sgprivate->scenegraph);\n\t\t\t\t\t\t\tgf_node_register((GF_Node *)t, n);\n\t\t\t\t\t\t\tgf_node_list_insert_child(&((GF_ParentNode *)n)->children, (GF_Node*)t, idx);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tt = (GF_DOMText *) gf_node_list_get_child(((SVG_Element*)n)->children, idx);\n\t\t\t\t\t\t\tif (t->sgprivate->tag!=TAG_DOMText) t = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*this is a replace, reset ALL node content*/\n\t\t\t\t\t\tgf_sg_parent_reset(n);\n\t\t\t\t\t\tt = gf_dom_add_text_node(n, NULL);\n\t\t\t\t\t}\n\t\t\t\t\tlsr_read_byte_align_string(lsr, t ? &t->textContent : NULL, \"textContent\");\n\t\t\t\t\tgf_node_changed(n, NULL);\n\t\t\t\t} else if (idx==-1) {\n\t\t\t\t\tlsr_read_update_value(lsr, (GF_Node*)n, fieldIndex, field_type, info.far_ptr, n->sgprivate->tag);\n\t\t\t\t} else {\n\t\t\t\t\tFixed *v1, *v2;\n\t\t\t\t\t//SMIL_Time *t;\n\t\t\t\t\tvoid *prev, *new_item;\n\t\t\t\t\tvoid *tmp = lsr_read_update_value_indexed(lsr, (GF_Node*)n, field_type, info.far_ptr, idx, com_type==LSR_UPDATE_INSERT, 0, NULL);\n\t\t\t\t\tswitch (field_type) {\n\t\t\t\t\t/*generic GF_List containers, no type translation needed*/\n\t\t\t\t\tcase SMIL_KeyTimes_datatype/*ITYPE_keyTime*/:\n\t\t\t\t\tcase SMIL_KeySplines_datatype/*ITYPE_float*/:\n\t\t\t\t\tcase SVG_Points_datatype/*ITYPE_point*/:\n\t\t\t\t\tcase SMIL_Times_datatype/*ITYPE_smil_time*/:\n\t\t\t\t\t\tnew_item = gf_list_pop_front(*(GF_List **)tmp);\n\t\t\t\t\t\tif (com_type==LSR_UPDATE_INSERT) {\n\t\t\t\t\t\t\tgf_list_insert(*(SVG_Coordinates*)info.far_ptr, new_item, idx);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprev = gf_list_get(*(SVG_Coordinates*)info.far_ptr, idx);\n\t\t\t\t\t\t\tgf_free(prev);\n\t\t\t\t\t\t\tgf_list_rem(*(SVG_Coordinates*)info.far_ptr, idx);\n\t\t\t\t\t\t\tgf_list_insert(*(SVG_Coordinates*)info.far_ptr, new_item, idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_node_changed((GF_Node*)n, NULL);\n\t\t\t\t\t\tgf_list_del(*(GF_List **)tmp);\n\t\t\t\t\t\tgf_free(tmp);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/*list of floats - to check when implementing it...*/\n\t\t\t\t\tcase SMIL_KeyPoints_datatype/*ITYPE_0to1 - keyPoints*/:\n\t\t\t\t\t\tv1 = (Fixed *) gf_list_pop_front(*(GF_List **)tmp);\n\t\t\t\t\t\tv2 = (Fixed *) gf_list_pop_front(*(GF_List **)tmp);\n\t\t\t\t\t\tgf_list_del(*(GF_List **)tmp);\n\t\t\t\t\t\tgf_free(tmp);\n\n\t\t\t\t\t\tif (com_type==LSR_UPDATE_INSERT) {\n\t\t\t\t\t\t\tgf_list_insert(*(SVG_Coordinates*)info.far_ptr, v1, idx);\n\t\t\t\t\t\t\tgf_list_insert(*(SVG_Coordinates*)info.far_ptr, v2, idx+1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprev = gf_list_get(*(SVG_Coordinates*)info.far_ptr, idx);\n\t\t\t\t\t\t\tgf_free(prev);\n\t\t\t\t\t\t\tgf_list_rem(*(SVG_Coordinates*)info.far_ptr, idx);\n\t\t\t\t\t\t\tprev = gf_list_get(*(SVG_Coordinates*)info.far_ptr, idx);\n\t\t\t\t\t\t\tgf_free(prev);\n\t\t\t\t\t\t\tgf_list_rem(*(SVG_Coordinates*)info.far_ptr, idx);\n\t\t\t\t\t\t\tgf_list_insert(*(SVG_Coordinates*)info.far_ptr, v1, idx);\n\t\t\t\t\t\t\tgf_list_insert(*(SVG_Coordinates*)info.far_ptr, v2, idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_node_changed((GF_Node*)n, NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SVG_ViewBox_datatype:\n\t\t\t\t\t\tv1 = (Fixed*)tmp;\n\t\t\t\t\t\tswitch (idx) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t((SVG_ViewBox*)info.far_ptr)->x = *v1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t((SVG_ViewBox*)info.far_ptr)->y = *v1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t((SVG_ViewBox*)info.far_ptr)->width = *v1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t((SVG_ViewBox*)info.far_ptr)->height = *v1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_free(tmp);\n\t\t\t\t\t\tgf_node_changed((GF_Node*)n, NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SVG_StrokeDashArray_datatype:\n\t\t\t\t\t\tv1 = (Fixed*)tmp;\n\t\t\t\t\t\tif (com_type==LSR_UPDATE_INSERT) {\n\t\t\t\t\t\t\tSVG_StrokeDashArray*da = (SVG_StrokeDashArray*)info.far_ptr;\n\t\t\t\t\t\t\t/*use MFFloat for insert*/\n\t\t\t\t\t\t\tif (gf_sg_vrml_mf_insert(&da->array, GF_SG_VRML_MFFLOAT, (void*) &v2, idx)==GF_OK)\n\t\t\t\t\t\t\t\t*v2 = *v1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSVG_StrokeDashArray*da = (SVG_StrokeDashArray*)info.far_ptr;\n\t\t\t\t\t\t\tif (idx<(s32)da->array.count) da->array.vals[idx] = *v1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_free(tmp);\n\t\t\t\t\t\tgf_node_changed((GF_Node*)n, NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgf_free(tmp);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_FieldInfo tmp;\n\t\t\t\ttmp = info;\n\t\t\t\tif (idx==-1) {\n\t\t\t\t\ttmp.far_ptr = gf_svg_create_attribute_value(info.fieldType);\n\t\t\t\t\tlsr_read_update_value(lsr, n, fieldIndex, field_type, tmp.far_ptr, n->sgprivate->tag);\n\t\t\t\t} else {\n\t\t\t\t\ttmp.far_ptr = lsr_read_update_value_indexed(lsr, n, field_type, NULL, idx, 0, 1, NULL);\n\t\t\t\t}\n\t\t\t\tgf_svg_attributes_add(&info, &tmp, &info, 0);\n\t\t\t\tgf_svg_delete_attribute_value(info.fieldType, tmp.far_ptr, gf_node_get_graph(n));\n\t\t\t}\n\t\t}\n\t}\n\t/*copy from node*/\n\telse if (operandNode && (op_att_type>=0)) {\n\t\tu32 opFieldIndex = gf_lsr_anim_type_to_attribute(op_att_type);\n\t\tif (com_list) {\n\t\t\tcom = gf_sg_command_new(lsr->sg, com_type ? GF_SG_LSR_REPLACE : GF_SG_LSR_ADD);\n\t\t\tgf_list_add(com_list, com);\n\t\t\tcom->node = n;\n\t\t\tgf_node_register(com->node, NULL);\n\t\t\tcom->fromNodeID = op_idref;\n\t\t\tcom->fromFieldIndex = opFieldIndex;\n\t\t\tfield = gf_sg_command_field_new(com);\n\t\t\tfield->pos = idx;\n\t\t\tfield->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);\n\t\t} else {\n\t\t\tu32 fieldIndex;\n\t\t\tGF_FieldInfo op_info;\n\t\t\tfieldIndex = gf_lsr_anim_type_to_attribute(att_type);\n\t\t\tgf_node_get_field(n, fieldIndex, &info);\n\t\t\tgf_node_get_field(operandNode, opFieldIndex, &op_info);\n\t\t\tif (com_type) {\n\t\t\t\tgf_svg_attributes_copy(&info, &op_info, 0);\n\t\t\t} else {\n\t\t\t\tgf_svg_attributes_add(&info, &op_info, &info, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tlsr_read_any_attribute(lsr, NULL, 1);\n\n\t/*if not add*/\n\tif (!com_type) return GF_OK;\n\n\t/*list replacement*/\n\tGF_LSR_READ_INT(lsr, type, 1, \"opt_group\");\n\tif (type) {\n\n\t\tif (com_list) {\n\t\t\tu32 count;\n\t\t\tGF_ChildNodeItem *last = NULL;\n\n\t\t\tif (com_type==LSR_UPDATE_INSERT) count = 1;\n\t\t\telse count = lsr_read_vluimsbf5(lsr, \"count\");\n\n\t\t\tcom = gf_sg_command_new(lsr->sg, (com_type==LSR_UPDATE_REPLACE) ? GF_SG_LSR_REPLACE : GF_SG_LSR_INSERT);\n\t\t\tgf_list_add(com_list, com);\n\t\t\tcom->node = n;\n\t\t\tgf_node_register(com->node, NULL);\n\t\t\tfield = gf_sg_command_field_new(com);\n\t\t\tfield->pos = idx;\n\n\t\t\tif (!count && (att_type==LSR_UPDATE_TYPE_TEXT_CONTENT)) {\n\t\t\t\tfield->fieldIndex = -1;\n\t\t\t} else if (count==1) {\n\t\t\t\tfield->new_node = lsr_read_update_content_model(lsr, (SVG_Element *) n);\n\t\t\t\tgf_node_register(field->new_node, NULL);\n\t\t\t\tif (att_type>=0) field->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);\n\t\t\t} else {\n\t\t\t\tfield->fieldType = SVG_NodeList_datatype;\n\t\t\t\tfield->field_ptr = &field->node_list;\n\t\t\t\twhile (count) {\n\t\t\t\t\tGF_Node *new_node = lsr_read_update_content_model(lsr, (SVG_Element *) n);\n\t\t\t\t\tgf_node_register(new_node, NULL);\n\t\t\t\t\tgf_node_list_add_child_last(& field->node_list, new_node, &last);\n\t\t\t\t\tcount--;\n\t\t\t\t\tif (lsr->last_error) return lsr->last_error;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tSVG_Element*elt = (SVG_Element*)n;\n\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\tu32 count;\n\t\t\tif (com_type==LSR_UPDATE_INSERT) count = 1;\n\t\t\telse count = lsr_read_vluimsbf5(lsr, \"count\");\n\n\t\t\tif (com_type==LSR_UPDATE_REPLACE) {\n\t\t\t\tif (idx>=0) {\n\t\t\t\t\tGF_Node *new_node = gf_node_list_del_child_idx(&elt->children, idx);\n\t\t\t\t\tif (new_node) gf_node_unregister(new_node, n);\n\t\t\t\t} else {\n\t\t\t\t\tgf_node_unregister_children(n, elt->children);\n\t\t\t\t\telt->children = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((com_type==LSR_UPDATE_INSERT) || (gf_lsr_anim_type_to_attribute(att_type) == TAG_LSR_ATT_children)) {\n\t\t\t\twhile (count) {\n\t\t\t\t\tGF_Node *new_node = lsr_read_update_content_model(lsr, elt);\n\t\t\t\t\tif (new_node) {\n\t\t\t\t\t\tif (idx>=0) {\n\t\t\t\t\t\t\tgf_node_list_insert_child(&elt->children, new_node, idx);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_node_list_add_child_last(&elt->children, new_node, &last);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_node_register(new_node, n);\n\t\t\t\t\t}\n\t\t\t\t\tcount--;\n\t\t\t\t\tif (lsr->last_error) return lsr->last_error;\n\t\t\t\t}\n\t\t\t\tgf_node_changed(n, NULL);\n\t\t\t}\n\t\t\t/*node replacement*/\n\t\t\telse if ((att_type==-1) && (count==1)) {\n\t\t\t\tGF_Node *new_node = lsr_read_update_content_model(lsr, elt);\n\t\t\t\tgf_node_replace((GF_Node*)elt, new_node, 0);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err lsr_read_delete(GF_LASeRCodec *lsr, GF_List *com_list)\n{\n\tGF_FieldInfo info;\n\ts32 idx, att_type;\n\tu32 type, idref;\n\n\tatt_type = lsr_get_attribute_name(lsr);\n\n\tidx = -2;\n\tGF_LSR_READ_INT(lsr, type, 1, \"has_index\");\n\tif (type) idx = (s32) lsr_read_vluimsbf5(lsr, \"index\");\n\tidref = lsr_read_codec_IDREF_command(lsr, \"ref\");\n\n\tlsr_read_any_attribute(lsr, NULL, 1);\n\tif (com_list) {\n\t\tGF_Command *com;\n\t\tcom = gf_sg_command_new(lsr->sg, GF_SG_LSR_DELETE);\n\t\tgf_list_add(com_list, com);\n\t\tcom->node = gf_sg_find_node(lsr->sg, idref);\n\t\tif (!com->node) {\n\t\t\tcom->RouteID = idref;\n\t\t\tgf_list_add(lsr->unresolved_commands, com);\n\t\t} else {\n\t\t\tgf_node_register(com->node, NULL);\n\t\t}\n\n\t\tif ((idx>=0) || (att_type>=0)) {\n\t\t\tGF_CommandField *field = gf_sg_command_field_new(com);\n\t\t\tfield->pos = idx;\n\t\t\tif (att_type>=0) {\n\t\t\t\tfield->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);\n\t\t\t\tif (!com->node) return GF_SG_UNKNOWN_NODE;\n\t\t\t\tgf_node_get_field(com->node, field->fieldIndex, &info);\n\t\t\t\tfield->fieldType = info.fieldType;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tSVG_Element *elt = (SVG_Element *) gf_sg_find_node(lsr->sg, idref);\n\t\tif (!elt)\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tif (att_type>=0) {\n\t\t\ts32 fieldIndex = gf_lsr_anim_type_to_attribute(att_type);\n\t\t\tgf_node_get_field((GF_Node*)elt, fieldIndex, &info);\n\t\t\t/*TODO implement*/\n\t\t}\n\t\t/*node deletion*/\n\t\telse if (idx>=0) {\n\t\t\tGF_Node *c = (GF_Node *)gf_node_list_get_child(elt->children, idx);\n\t\t\tif (c) {\n\t\t\t\tif (!gf_node_list_del_child( & elt->children, c))\n\t\t\t\t\treturn GF_IO_ERR;\n\t\t\t\tgf_node_unregister(c, (GF_Node*)elt);\n\t\t\t}\n\t\t} else {\n\t\t\tgf_node_replace((GF_Node*)elt, NULL, 0);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err lsr_read_send_event(GF_LASeRCodec *lsr, GF_List *com_list)\n{\n\tu32 flag, idref;\n\ts32 detail;\n\tSVG_Number x, y;\n\tXMLEV_Event event;\n\tlsr_read_event_type(lsr, &event);\n\n\tdetail = 0;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"has_intvalue\");\n\tif (flag) {\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"sign\");\n\t\tdetail = lsr_read_vluimsbf5(lsr, \"value\");\n\t\tif (flag) detail = -detail;\n\n\t\tswitch (event.type) {\n\t\tcase GF_EVENT_KEYDOWN:\n\t\tcase GF_EVENT_LONGKEYPRESS:\n\t\tcase GF_EVENT_REPEAT_KEY:\n\t\tcase GF_EVENT_SHORT_ACCESSKEY:\n\t\t\tdetail = lsr_to_dom_key(detail);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tx.value = y.value = 0;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"has_pointvalue\");\n\tif (flag) {\n\t\tlsr_read_coordinate(lsr, &x, 0, \"x\");\n\t\tlsr_read_coordinate(lsr, &y, 0, \"y\");\n\t}\n\tidref = lsr_read_codec_IDREF_command(lsr, \"idref\");\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"has_pointvalue\");\n\tif (flag) {\n\t\tlsr_read_byte_align_string(lsr, NULL, \"string\");\n\t}\n\tlsr_read_any_attribute(lsr, NULL, 1);\n\n\tif (!com_list) {\n\t\tGF_DOM_Event evt;\n\t\tGF_Node *target = gf_sg_find_node(lsr->sg, idref);\n\t\tif (!target) return GF_OK;\n\n\t\tmemset(&evt, 0, sizeof(GF_DOM_Event));\n\t\tevt.type = event.type;\n\t\tevt.detail = detail ? detail : (s32) event.parameter;\n\t\tevt.clientX = FIX2INT(x.value);\n\t\tevt.clientY = FIX2INT(y.value);\n\t\tgf_dom_event_fire(target, &evt);\n\n\t} else {\n\t\tGF_Command *com = gf_sg_command_new(lsr->sg, GF_SG_LSR_SEND_EVENT);\n\t\tgf_list_add(com_list, com);\n\t\tcom->node = gf_sg_find_node(lsr->sg, idref);\n\t\tif (!com->node) {\n\t\t\tcom->RouteID = idref;\n\t\t\tgf_list_add(lsr->unresolved_commands, com);\n\t\t} else {\n\t\t\tgf_node_register(com->node, NULL);\n\t\t}\n\t\tcom->send_event_integer = detail ? detail : (s32) event.parameter;\n\t\tcom->send_event_name = event.type;\n\t\tcom->send_event_x = FIX2INT(x.value);\n\t\tcom->send_event_y = FIX2INT(y.value);\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err lsr_read_save(GF_LASeRCodec *lsr, GF_List *com_list)\n{\n\tu32 i, count;\n\tcount = lsr_read_vluimsbf5(lsr, \"nbIds\");\n\tfor (i=0; i<count; i++) {\n\t\tu32 flag;\n\t\tlsr_read_vluimsbf5(lsr, \"ref[[i]]\");\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"reserved\");\n\n\t\tlsr_get_attribute_name(lsr);\n\t\tif (lsr->last_error) return lsr->last_error;\n\t}\n\tlsr_read_byte_align_string(lsr, NULL, \"groupID\");\n\tlsr_read_any_attribute(lsr, NULL, 1);\n\treturn GF_OK;\n}\n\nstatic GF_Err lsr_read_restore(GF_LASeRCodec *lsr, GF_List *com_list)\n{\n\tlsr_read_byte_align_string(lsr, NULL, \"groupID\");\n\tlsr_read_any_attribute(lsr, NULL, 1);\n\treturn GF_OK;\n}\n\nvoid lsr_exec_command_list(GF_Node *node, void *par, Bool is_destroy)\n{\n\tGF_DOMUpdates *up = (GF_DOMUpdates *)node;\n\tGF_LASeRCodec *codec = (GF_LASeRCodec *)gf_node_get_private((GF_Node*)node);\n\n\tif (is_destroy || !up || (up->sgprivate->tag!=TAG_DOMUpdates)) return;\n\tassert(!codec->bs);\n\n\tcodec->info = lsr_get_stream(codec, 0);\n\tif (!codec->info) return;\n\tcodec->coord_bits = codec->info->cfg.coord_bits;\n\tcodec->scale_bits = codec->info->cfg.scale_bits_minus_coord_bits;\n\tcodec->time_resolution = codec->info->cfg.time_resolution;\n\tcodec->color_scale = (1<<codec->info->cfg.colorComponentBits) - 1;\n\tif (codec->info->cfg.resolution >= 0)\n\t\tcodec->res_factor = INT2FIX(1<<codec->info->cfg.resolution);\n\telse\n\t\tcodec->res_factor = gf_divfix(FIX_ONE, INT2FIX(1 << (-codec->info->cfg.resolution)) );\n\n\tcodec->bs = gf_bs_new(up->data, up->data_size, GF_BITSTREAM_READ);\n\tcodec->memory_dec = 0;\n\tlsr_read_command_list(codec, NULL, NULL, 0);\n\tgf_bs_del(codec->bs);\n\tcodec->bs = NULL;\n}\n\nstatic GF_Err lsr_read_command_list(GF_LASeRCodec *lsr, GF_List *com_list, SVG_Element *cond, Bool first_imp)\n{\n\tGF_Node *n;\n\tGF_Command *com;\n\tu32 i, type, count;\n\n\tif (cond) {\n\t\tu32 s_len;\n\t\tGF_DOMUpdates *up = gf_dom_add_updates_node((GF_Node*)cond);\n\t\tgf_node_set_callback_function((GF_Node*)up, lsr_exec_command_list);\n\t\tgf_node_set_private((GF_Node *) up, lsr);\n\n\t\ts_len = lsr_read_vluimsbf5(lsr, NULL/*\"encoding-length\" - don't log to avoid corrupting the log order!!*/);\n\t\tgf_bs_align(lsr->bs);\n\t\t/*not in memory mode, direct decode*/\n\t\tif (!lsr->memory_dec) {\n\t\t\tcom_list = NULL;\n\t\t\tup->data_size = s_len;\n\t\t\tup->data = (char*)gf_malloc(sizeof(char)*s_len);\n\t\t\tif (!up->data) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\tgf_bs_read_data(lsr->bs, up->data, s_len);\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\t\t/*memory mode, decode commands*/\n\t\telse {\n\t\t\tcom_list = up->updates;\n\t\t}\n\t}\n\tcount = lsr_read_vluimsbf5(lsr, \"occ0\");\n\tif (first_imp) count++;\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_LSR_READ_INT(lsr, type, 4, \"ch4\");\n\t\tswitch (type) {\n\t\tcase LSR_UPDATE_ADD:\n\t\tcase LSR_UPDATE_INSERT:\n\t\tcase LSR_UPDATE_REPLACE:\n\t\t\tlsr_read_add_replace_insert(lsr, com_list, type);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_DELETE:\n\t\t\tlsr_read_delete(lsr, com_list);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_NEW_SCENE:\n\t\tcase LSR_UPDATE_REFRESH_SCENE: /*TODO FIXME, depends on decoder state*/\n\t\t\tif (type==5) lsr_read_vluimsbf5(lsr, \"time\");\n\t\t\tlsr_read_any_attribute(lsr, NULL, 1);\n\t\t\tif (com_list) {\n\t\t\t\tn = lsr_read_svg(lsr, 0);\n\t\t\t\tif (!n)\n\t\t\t\t\treturn (lsr->last_error = GF_NON_COMPLIANT_BITSTREAM);\n\t\t\t\tgf_node_register(n, NULL);\n\t\t\t\tcom = gf_sg_command_new(lsr->sg, (type==5) ? GF_SG_LSR_REFRESH_SCENE : GF_SG_LSR_NEW_SCENE);\n\t\t\t\tcom->node = n;\n\t\t\t\tgf_list_add(com_list, com);\n\t\t\t} else {\n\t\t\t\tgf_sg_reset(lsr->sg);\n\t\t\t\tgf_sg_set_scene_size_info(lsr->sg, 0, 0, 1);\n\t\t\t\tn = lsr_read_svg(lsr, 1);\n\t\t\t\tif (!n)\n\t\t\t\t\treturn (lsr->last_error = GF_NON_COMPLIANT_BITSTREAM);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_TEXT_CONTENT:\n\t\t\tlsr_read_byte_align_string(lsr, NULL, \"textContent\");\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_SEND_EVENT:\n\t\t\tlsr_read_send_event(lsr, com_list);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_RESTORE:\n\t\t\tlsr_read_restore(lsr, com_list);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_SAVE:\n\t\t\tlsr_read_save(lsr, com_list);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_EXTEND:\n\t\t{\n\t\t\tu32 extID;\n\t\t\tGF_LSR_READ_INT(lsr, extID, lsr->info->cfg.extensionIDBits, \"extensionID\");\n\t\t\t/*len = */lsr_read_vluimsbf5(lsr, \"len\");\n\t\t\tif (extID==2) {\n\t\t\t\tu32 j, sub_count;\n\t\t\t\tlsr_read_vluimsbf5(lsr, \"reserved\");\n\t\t\t\tsub_count = lsr_read_vluimsbf5(lsr, \"occ2\");\n\t\t\t\tfor (j=0; j<sub_count; j++) {\n\t\t\t\t\tu32 k, occ3;\n\t\t\t\t\tGF_LSR_READ_INT(lsr, k, 2, \"reserved\");\n\t\t\t\t\tocc3 = lsr_read_vluimsbf5(lsr, \"occ3\");\n\t\t\t\t\tfor (k=0; k<occ3; k++) {\n\t\t\t\t\t\tu32 sub_type, idref;\n\t\t\t\t\t\tGF_LSR_READ_INT(lsr, sub_type, 2, \"ch5\");\n\t\t\t\t\t\tswitch (sub_type) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tidref = lsr_read_codec_IDREF_command(lsr, \"ref\");\n\n\t\t\t\t\t\t\tn = gf_sg_find_node(lsr->sg, idref);\n\t\t\t\t\t\t\tif (com_list) {\n\t\t\t\t\t\t\t\tcom = gf_sg_command_new(lsr->sg, (sub_type==1) ? GF_SG_LSR_ACTIVATE : GF_SG_LSR_DEACTIVATE);\n\t\t\t\t\t\t\t\tif (n) {\n\t\t\t\t\t\t\t\t\tcom->node = n;\n\t\t\t\t\t\t\t\t\tgf_node_register(n, NULL);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcom->RouteID = idref;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgf_list_add(com_list, com);\n\t\t\t\t\t\t\t} else if (sub_type==1) {\n\t\t\t\t\t\t\t\tif (!n) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\t\t\tgf_node_activate(n);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (!n) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\t\t\tgf_node_deactivate(n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tlsr_read_private_element_container(lsr);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (lsr->last_error) return lsr->last_error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\treturn (lsr->last_error = GF_NON_COMPLIANT_BITSTREAM);\n\t\t}\n\t\t/*same-coding scope is command-based (to check in the spec)*/\n\t\tif (cond) {\n\t\t\tlsr->prev_g = NULL;\n\t\t\tlsr->prev_line = NULL;\n\t\t\tlsr->prev_path = NULL;\n\t\t\tlsr->prev_polygon = NULL;\n\t\t\tlsr->prev_rect = NULL;\n\t\t\tlsr->prev_text = NULL;\n\t\t\tlsr->prev_use = NULL;\n\t\t}\n\n\t\tif (lsr->last_error)\n\t\t\treturn lsr->last_error;\n\t}\nexit:\n\t/*script is align*/\n\tif (cond) {\n\t\tgf_bs_align(lsr->bs);\n\t\tlsr_read_object_content(lsr, (SVG_Element*)cond);\n\t\tlsr->prev_g = NULL;\n\t\tlsr->prev_line = NULL;\n\t\tlsr->prev_path = NULL;\n\t\tlsr->prev_polygon = NULL;\n\t\tlsr->prev_rect = NULL;\n\t\tlsr->prev_text = NULL;\n\t\tlsr->prev_use = NULL;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err lsr_decode_laser_unit(GF_LASeRCodec *lsr, GF_List *com_list)\n{\n\tGF_Err e;\n\tBool reset_encoding_context;\n\tu32 flag, i, count = 0, privateDataIdentifierIndexBits;\n\n\tlsr->last_error = GF_OK;\n\n\t/*\n\t *\t1 - laser unit header\n\t */\n\tGF_LSR_READ_INT(lsr, reset_encoding_context, 1, \"resetEncodingContext\");\n\tGF_LSR_READ_INT(lsr, flag, 1, \"opt_group\");\n\tif (flag) lsr_read_extension(lsr, \"ext\");\n\n\t/*clean all tables*/\n\tif (reset_encoding_context) {\n\t\tlsr->nb_cols = 0;\n\t\tif (lsr->col_table) gf_free(lsr->col_table);\n\t\tlsr->col_table = NULL;\n\t\twhile (gf_list_count(lsr->font_table)) {\n\t\t\tchar *ft = (char *)gf_list_last(lsr->font_table);\n\t\t\tgf_free(ft);\n\t\t\tgf_list_rem_last(lsr->font_table);\n\t\t}\n\t\tlsr->privateData_id_index = lsr->privateTag_index = 0;\n\t}\n\n\t/*\n\t *\t2 - codecInitialisations\n\t */\n\n\t/*\n\t * 2.a - condecInitialization.color\n\t */\n\tGF_LSR_READ_INT(lsr, flag, 1, \"colorInitialisation\");\n\n\tif (flag) {\n\t\tcount = lsr_read_vluimsbf5(lsr, \"count\");\n\t\tif (count>gf_bs_available(lsr->bs)) return lsr->last_error = GF_NON_COMPLIANT_BITSTREAM;\n\t\tlsr->col_table = (LSRCol*)gf_realloc(lsr->col_table, sizeof(LSRCol)*(lsr->nb_cols+count));\n\t\tif (!lsr->col_table)\n\t\t\treturn lsr->last_error = GF_OUT_OF_MEM;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tLSRCol c;\n\t\t\tGF_LSR_READ_INT(lsr, c.r, lsr->info->cfg.colorComponentBits, \"red\");\n\t\t\tGF_LSR_READ_INT(lsr, c.g, lsr->info->cfg.colorComponentBits, \"green\");\n\t\t\tGF_LSR_READ_INT(lsr, c.b, lsr->info->cfg.colorComponentBits, \"blue\");\n\t\t\tlsr->col_table[lsr->nb_cols+i] = c;\n\t\t\tif (lsr->last_error) return lsr->last_error;\n\t\t}\n\t\tlsr->nb_cols += count;\n\t}\n\tlsr->colorIndexBits = gf_get_bit_size(lsr->nb_cols);\n\t/*\n\t * 2.b - condecInitialization.fonts\n\t */\n\tGF_LSR_READ_INT(lsr, flag, 1, \"fontInitialisation\");\n\tcount = 0;\n\tif (flag) {\n\t\tcount = lsr_read_vluimsbf5(lsr, \"count\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\tchar *ft = NULL;\n\t\t\tlsr_read_byte_align_string(lsr, &ft, \"font\");\n\t\t\tgf_list_add(lsr->font_table, ft);\n\t\t\tif (lsr->last_error) return lsr->last_error;\n\t\t}\n\t}\n\tlsr->fontIndexBits = gf_get_bit_size(count);\n\t/*\n\t * 2.c - condecInitialization.private\n\t */\n\tGF_LSR_READ_INT(lsr, flag, 1, \"privateDataIdentifierInitialisation\");\n\n\tif (flag) {\n\t\tcount = lsr_read_vluimsbf5(lsr, \"nbPrivateDataIdentifiers\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\tlsr->privateData_id_index++;\n\t\t\tlsr_read_byte_align_string(lsr, NULL, \"privateDataIdentifier\");\n\t\t\tif (lsr->last_error) return lsr->last_error;\n\t\t}\n\t}\n\t/*\n\t * 2.d - condecInitialization.anyXML\n\t */\n\tGF_LSR_READ_INT(lsr, flag, 1, \"anyXMLInitialisation\");\n\n\tif (flag) {\n\t\tprivateDataIdentifierIndexBits = gf_get_bit_size(lsr->privateData_id_index);\n\t\tcount = lsr_read_vluimsbf5(lsr, \"nbTags\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\tlsr->privateTag_index++;\n\t\t\tif (i) {\n\t\t\t\t/* uint(privateDataIdentifierIndexBits) = */\n\t\t\t\tGF_LSR_READ_INT(lsr, flag, privateDataIdentifierIndexBits, \"privateDataIdentifierIndex\");\n\t\t\t\tlsr_read_byte_align_string(lsr, NULL, \"tag\");\n\t\t\t}\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"hasAttrs\");\n\t\t\tif (flag) {\n\t\t\t\tu32 k, c2 = lsr_read_vluimsbf5(lsr, \"nbAttrNames\");\n\t\t\t\tfor (k=0; k<c2; k++) {\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\t/* uint(privateDataIdentifierIndexBits) = */\n\t\t\t\t\t\tGF_LSR_READ_INT(lsr, flag, privateDataIdentifierIndexBits, \"privateDataIdentifierIndex\");\n\t\t\t\t\t}\n\t\t\t\t\tlsr_read_byte_align_string(lsr, NULL, \"tag\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lsr->last_error) return lsr->last_error;\n\t\t}\n\t}\n\t/*\n\t * 2.e - condecInitialization.extension\n\t */\n\tcount = lsr_read_vluimsbf5(lsr, \"countG\");\n\tfor (i=0; i<count; i++) {\n\t\t/*u32 locID = */lsr_read_vluimsbf5(lsr, \"binaryIdForThisStringID\");\n\t\tlsr_read_byte_align_string(lsr, NULL, \"stringID\");\n\t\tif (lsr->last_error) return lsr->last_error;\n\t}\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasExtension\");\n\tif (flag) {\n\t\tu32 len = lsr_read_vluimsbf5(lsr, \"len\");\n\t\tu32 pos = gf_bs_get_bit_offset(lsr->bs);\n\n\t\tcount = lsr_read_vluimsbf5(lsr, \"len\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\t/*u32 locID = */lsr_read_vluimsbf5(lsr, \"localStreamIdForThisGlobal\");\n\t\t\tlsr_read_byte_align_string(lsr, NULL, \"globalName\");\n\t\t\tif (lsr->last_error) return lsr->last_error;\n\t\t}\n\t\tpos = gf_bs_get_bit_offset(lsr->bs) - pos;\n\t\tif (len<pos)\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tGF_LSR_READ_INT(lsr, flag, pos, \"remainingData\");\n\t}\n\n\te = lsr_read_command_list(lsr, com_list, NULL, 1);\n\tGF_LSR_READ_INT(lsr, flag, 1, \"opt_group\");\n\tif (flag) lsr_read_extension(lsr, \"ext\");\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_LASER*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2005-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / LASeR codec sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/laser_dev.h>\n#include <gpac/internal/scenegraph_dev.h>\n#include <gpac/bitstream.h>\n#include <gpac/events.h>\n\n#ifndef GPAC_DISABLE_LASER\n\n\n#define GF_LSR_READ_INT(_codec, _val, _nbBits, _str) {\\\n\tif (_nbBits/8 > gf_bs_available(lsr->bs)) {\\\n\t\tlsr->last_error = GF_NON_COMPLIANT_BITSTREAM;\\\n\t\t(_val) = 0;\\\n\t} else {\\\n\t\t(_val) = gf_bs_read_int(_codec->bs, _nbBits);\t\\\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[LASeR] %s\\t\\t%d\\t\\t%d\\n\", _str, _nbBits, _val)); \\\n\t}\\\n}\n\n\nstatic void lsr_read_group_content(GF_LASeRCodec *lsr, GF_Node *elt, Bool skip_object_content);\nstatic void lsr_read_group_content_post_init(GF_LASeRCodec *lsr, SVG_Element *elt, Bool skip_init);\nstatic GF_Err lsr_read_command_list(GF_LASeRCodec *lsr, GF_List *comList, SVG_Element *cond, Bool first_imp);\nstatic GF_Err lsr_decode_laser_unit(GF_LASeRCodec *lsr, GF_List *com_list);\nstatic void lsr_read_path_type(GF_LASeRCodec *lsr, GF_Node *n, u32 tag, SVG_PathData *path, const char *name);\nstatic void lsr_read_point_sequence(GF_LASeRCodec *lsr, GF_List *pts, const char *name);\nstatic Bool lsr_setup_smil_anim(GF_LASeRCodec *lsr, SVG_Element *anim, SVG_Element *anim_parent);\n\nGF_EXPORT\nGF_LASeRCodec *gf_laser_decoder_new(GF_SceneGraph *graph)\n{\n\tGF_LASeRCodec *tmp;\n\tGF_SAFEALLOC(tmp, GF_LASeRCodec);\n\tif (!tmp) return NULL;\n\ttmp->streamInfo = gf_list_new();\n\ttmp->font_table = gf_list_new();\n\ttmp->deferred_hrefs = gf_list_new();\n\ttmp->deferred_listeners = gf_list_new();\n\ttmp->deferred_anims = gf_list_new();\n\ttmp->unresolved_commands = gf_list_new();\n\ttmp->sg = graph;\n\treturn tmp;\n}\n\nGF_EXPORT\nvoid gf_laser_decoder_del(GF_LASeRCodec *codec)\n{\n\t/*destroy all config*/\n\twhile (gf_list_count(codec->streamInfo)) {\n\t\tLASeRStreamInfo *p = (LASeRStreamInfo *)gf_list_last(codec->streamInfo);\n\t\tgf_free(p);\n\t\tgf_list_rem_last(codec->streamInfo);\n\t}\n\tgf_list_del(codec->streamInfo);\n\tif (codec->col_table) gf_free(codec->col_table);\n\twhile (gf_list_count(codec->font_table)) {\n\t\tchar *ft = (char *)gf_list_last(codec->font_table);\n\t\tgf_free(ft);\n\t\tgf_list_rem_last(codec->font_table);\n\t}\n\tgf_list_del(codec->font_table);\n#if 0\n\twhile (gf_list_count(codec->deferred_hrefs)) {\n\t\tXMLRI *iri = (XMLRI *)gf_list_last(codec->deferred_hrefs);\n\t\tgf_list_rem_last(codec->deferred_hrefs);\n\t\tif (iri->string) gf_free(iri->string);\n\t\tiri->string = NULL;\n\t}\n#endif\n\tgf_list_del(codec->deferred_hrefs);\n\tgf_list_del(codec->deferred_anims);\n\tgf_list_del(codec->deferred_listeners);\n\tgf_list_del(codec->unresolved_commands);\n\tgf_free(codec);\n}\n\nstatic LASeRStreamInfo *lsr_get_stream(GF_LASeRCodec *codec, u16 ESID)\n{\n\tu32 i=0;\n\tLASeRStreamInfo *ptr;\n\twhile ((ptr = (LASeRStreamInfo *)gf_list_enum(codec->streamInfo, &i))) {\n\t\tif (!ESID || (ptr->ESID==ESID)) return ptr;\n\t}\n\treturn NULL;\n}\n\n\nGF_EXPORT\nGF_Err gf_laser_decoder_configure_stream(GF_LASeRCodec *codec, u16 ESID, u8 *dsi, u32 dsi_len)\n{\n\tLASeRStreamInfo *info;\n\tGF_BitStream *bs;\n\tif (lsr_get_stream(codec, ESID) != NULL) return GF_BAD_PARAM;\n\tGF_SAFEALLOC(info, LASeRStreamInfo);\n\tif (!info) return GF_OUT_OF_MEM;\n\tinfo->ESID = ESID;\n\tbs = gf_bs_new(dsi, dsi_len, GF_BITSTREAM_READ);\n\n\tinfo->cfg.profile = gf_bs_read_int(bs, 8);\n\tinfo->cfg.level = gf_bs_read_int(bs, 8);\n\t/*info->cfg.reserved = */ gf_bs_read_int(bs, 3);\n\tinfo->cfg.pointsCodec = gf_bs_read_int(bs, 2);\n\tinfo->cfg.pathComponents = gf_bs_read_int(bs, 4);\n\tinfo->cfg.fullRequestHost = gf_bs_read_int(bs, 1);\n\tif (gf_bs_read_int(bs, 1)) {\n\t\tinfo->cfg.time_resolution = gf_bs_read_int(bs, 16);\n\t} else {\n\t\tinfo->cfg.time_resolution = 1000;\n\t}\n\tinfo->cfg.colorComponentBits = gf_bs_read_int(bs, 4);\n\tinfo->cfg.colorComponentBits += 1;\n\tinfo->cfg.resolution = gf_bs_read_int(bs, 4);\n\tif (info->cfg.resolution>7) info->cfg.resolution -= 16;\n\tinfo->cfg.coord_bits = gf_bs_read_int(bs, 5);\n\tinfo->cfg.scale_bits_minus_coord_bits = gf_bs_read_int(bs, 4);\n\tinfo->cfg.newSceneIndicator = gf_bs_read_int(bs, 1);\n\t/*reserved*/ gf_bs_read_int(bs, 3);\n\tinfo->cfg.extensionIDBits = gf_bs_read_int(bs, 4);\n\t/*we ignore the rest*/\n\tgf_list_add(codec->streamInfo, info);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_laser_decoder_remove_stream(GF_LASeRCodec *codec, u16 ESID)\n{\n\tu32 i, count;\n\tcount = gf_list_count(codec->streamInfo);\n\tfor (i=0; i<count; i++) {\n\t\tLASeRStreamInfo *ptr = (LASeRStreamInfo *) gf_list_get(codec->streamInfo, i);\n\t\tif (ptr->ESID==ESID) {\n\t\t\tgf_free(ptr);\n\t\t\tgf_list_rem(codec->streamInfo, i);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_BAD_PARAM;\n}\n\n\nvoid gf_bs_set_eos_callback(GF_BitStream *bs, void (*EndOfStream)(void *par), void *par);\n\nvoid lsr_end_of_stream(void *co)\n{\n\tGF_LASeRCodec *codec = (GF_LASeRCodec *)co;\n\tif (codec->last_error != GF_NON_COMPLIANT_BITSTREAM) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[LASeR] memory overread - corrupted decoding\\n\"));\n\t\t((GF_LASeRCodec *) co)->last_error = GF_NON_COMPLIANT_BITSTREAM;\n\t}\n}\n\nGF_EXPORT\nBool gf_laser_decode_has_conditionnals(GF_LASeRCodec *codec)\n{\n\treturn codec && codec->has_conditionnals ? GF_TRUE : GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_laser_decode_au(GF_LASeRCodec *codec, u16 ESID, const u8 *data, u32 data_len)\n{\n\tGF_Err e;\n\tif (!codec || !data || !data_len) return GF_BAD_PARAM;\n\n\tcodec->info = lsr_get_stream(codec, ESID);\n\tif (!codec->info) return GF_BAD_PARAM;\n\tcodec->coord_bits = codec->info->cfg.coord_bits;\n\tcodec->scale_bits = codec->info->cfg.scale_bits_minus_coord_bits;\n\tcodec->time_resolution = codec->info->cfg.time_resolution;\n\tcodec->color_scale = (1<<codec->info->cfg.colorComponentBits) - 1;\n\tif (codec->info->cfg.resolution >= 0)\n\t\tcodec->res_factor = INT2FIX(1<<codec->info->cfg.resolution);\n\telse\n\t\tcodec->res_factor = gf_divfix(FIX_ONE, INT2FIX(1 << (-codec->info->cfg.resolution)) );\n\n\tcodec->bs = gf_bs_new(data, data_len, GF_BITSTREAM_READ);\n\tgf_bs_set_eos_callback(codec->bs, lsr_end_of_stream, codec);\n\tcodec->memory_dec = GF_FALSE;\n\te = lsr_decode_laser_unit(codec, NULL);\n\tgf_bs_del(codec->bs);\n\tcodec->bs = NULL;\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_laser_decode_command_list(GF_LASeRCodec *codec, u16 ESID, u8 *data, u32 data_len, GF_List *com_list)\n{\n\tGF_Err e;\n\tu32 i;\n\tif (!codec || !data || !data_len) return GF_BAD_PARAM;\n\n\tcodec->info = lsr_get_stream(codec, ESID);\n\tif (!codec->info) return GF_BAD_PARAM;\n\tcodec->coord_bits = codec->info->cfg.coord_bits;\n\tcodec->scale_bits = codec->info->cfg.scale_bits_minus_coord_bits;\n\tcodec->time_resolution = codec->info->cfg.time_resolution;\n\tcodec->color_scale = (1<<codec->info->cfg.colorComponentBits) - 1;\n\tif (codec->info->cfg.resolution >= 0)\n\t\tcodec->res_factor = INT2FIX(1<<codec->info->cfg.resolution);\n\telse\n\t\tcodec->res_factor = gf_divfix(FIX_ONE, INT2FIX(1 << (-codec->info->cfg.resolution)) );\n\n\tcodec->bs = gf_bs_new(data, data_len, GF_BITSTREAM_READ);\n\tgf_bs_set_eos_callback(codec->bs, lsr_end_of_stream, codec);\n\tcodec->memory_dec = GF_TRUE;\n\te = lsr_decode_laser_unit(codec, com_list);\n\tgf_bs_del(codec->bs);\n\tcodec->bs = NULL;\n\tif (e) return e;\n\n\tfor (i=0; i<gf_list_count(codec->unresolved_commands); i++) {\n\t\tGF_Command *com = (GF_Command *)gf_list_get(codec->unresolved_commands, i);\n\t\tassert(!com->node);\n\t\tcom->node = gf_sg_find_node(codec->sg, com->RouteID);\n\t\tif (com->node) {\n\t\t\tgf_node_register(com->node, NULL);\n\t\t\tcom->RouteID = 0;\n\t\t\tgf_list_rem(codec->unresolved_commands, i);\n\t\t\ti--;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_laser_decoder_set_clock(GF_LASeRCodec *codec, Double (*GetSceneTime)(void *st_cbk), void *st_cbk )\n{\n\tcodec->GetSceneTime = GetSceneTime;\n\tcodec->cbk = st_cbk;\n}\n\nstatic u32 lsr_read_vluimsbf5(GF_LASeRCodec *lsr, const char *name)\n{\n\tu32 nb_words = 0;\n\tu32 nb_tot, nb_bits, val;\n\n\twhile (gf_bs_read_int(lsr->bs, 1)) nb_words++;\n\tnb_words++;\n\tnb_tot = nb_words;\n\tnb_bits = nb_words*4;\n\tnb_tot += nb_bits;\n\tval = gf_bs_read_int(lsr->bs, nb_bits);\n\tif (name) GF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[LASeR] %s\\t\\t%d\\t\\t%d\\n\", name, nb_tot, val));\n\treturn val;\n}\nstatic u32 lsr_read_vluimsbf8(GF_LASeRCodec *lsr, const char *name)\n{\n\tu32 nb_words = 0;\n\tu32 nb_tot, nb_bits, val;\n\n\twhile (gf_bs_read_int(lsr->bs, 1)) nb_words++;\n\tnb_words++;\n\tnb_tot = nb_words;\n\tnb_bits = nb_words*7;\n\tnb_tot += nb_bits;\n\tval = gf_bs_read_int(lsr->bs, nb_bits);\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[LASeR] %s\\t\\t%d\\t\\t%d\\n\", name, nb_tot, val));\n\treturn val;\n}\n\nstatic void lsr_read_extension(GF_LASeRCodec *lsr, const char *name)\n{\n\tu32 len = lsr_read_vluimsbf5(lsr, name);\n#if 0\n\t*out_data = gf_malloc(sizeof(char)*len);\n\tgf_bs_read_data(lsr->bs, *out_data, len);\n\t*out_len = len;\n#else\n\twhile (len && gf_bs_available(lsr->bs) ) {\n\t\tgf_bs_read_int(lsr->bs, 8);\n\t\tlen--;\n\t}\n\tif (len) lsr->last_error = GF_NON_COMPLIANT_BITSTREAM;\n#endif\n}\n\nstatic void lsr_read_extend_class(GF_LASeRCodec *lsr, char **out_data, u32 *out_len, const char *name)\n{\n\tu32 len;\n\tGF_LSR_READ_INT(lsr, len, lsr->info->cfg.extensionIDBits, \"reserved\");\n\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n//\twhile (len) gf_bs_read_int(lsr->bs, 1);\n\tgf_bs_read_long_int(lsr->bs, len);\n\tif (out_data) *out_data = NULL;\n\tif (out_len) *out_len = 0;\n}\n\nstatic void lsr_read_private_element_container(GF_LASeRCodec *lsr)\n{\n\tu32 val, len;\n\tGF_LSR_READ_INT(lsr, val, 4, \"ch4\");\n\tswitch (val) {\n\t/*privateAnyXMLElement*/\n\tcase 0:\n\t\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\t\tgf_bs_skip_bytes(lsr->bs, len);\n\t\tbreak;\n\t/*privateOpaqueElement*/\n\tcase 1:\n\t\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\t\tgf_bs_skip_bytes(lsr->bs, len);\n\t\tbreak;\n\t/*element_any*/\n\tcase 2:\n\t\tlsr_read_extend_class(lsr, NULL, 0, \"reserved\");\n\t\tbreak;\n\t/*attr_custom_extension*/\n\tdefault:\n\t\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\t\tgf_bs_skip_bytes(lsr->bs, len);\n\t\tbreak;\n\t}\n}\n\nstatic void lsr_read_private_attribute_container(GF_LASeRCodec *lsr)\n{\n\tu32 val;\n\tdo {\n\t\tu32 skip_len;\n\t\tGF_LSR_READ_INT(lsr, val, 2, \"privateDataType\");\n\t\tskip_len = lsr_read_vluimsbf5(lsr, \"skipLen\");\n\t\tgf_bs_align(lsr->bs);\n\t\t/*just skip data*/\n#if 1\n\t\tif (skip_len>gf_bs_available(lsr->bs)) {\n\t\t\tlsr->last_error = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\treturn;\n\t\t}\n\t\tgf_bs_skip_bytes(lsr->bs, skip_len);\n#else\n\t\tswitch (val) {\n\t\t/*private data of type \"anyXML\"*/\n\t\tcase 0:\n\t\t\tcount = lsr_read_vluimsbf5(lsr, \"count\");\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tprivateAttribute(0) attr[i];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/*TODO FIXME - nameSpaceIndexBits is not defined in the spec*/\n\t\t\tuint(nameSpaceIndexBits) nameSpaceIndex;\n\t\t\tgf_bs_align(lsr->bs);\n\t\t\tbyte[skipLen - ((nameSpaceIndexBits+7)%8)] data;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*TODO - spec is wrong here (typo, \"len\" instead of \"skipLen\" )*/\n\t\t\tgf_bs_skip_bytes(skipLen);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tgf_bs_align(lsr->bs);\n\t\tGF_LSR_READ_INT(lsr, val, 1, \"hasMorePrivateData\");\n\t} while (val);\n}\n\nstatic void lsr_read_any_attribute(GF_LASeRCodec *lsr, GF_Node *node, Bool skippable)\n{\n\tu32 val = 1;\n\tif (skippable) GF_LSR_READ_INT(lsr, val, 1, \"has_attrs\");\n\tif (val) {\n\t\tdo {\n\t\t\tGF_LSR_READ_INT(lsr, val, lsr->info->cfg.extensionIDBits, \"reserved\");\n\t\t\tval = lsr_read_vluimsbf5(lsr, \"len\");//len in BITS\n\t\t\tGF_LSR_READ_INT(lsr, val, val, \"reserved_val\");\n\t\t\tGF_LSR_READ_INT(lsr, val, 1, \"hasNextExtension\");\n\t\t\tif (lsr->last_error) return;\n\t\t} while (val);\n\t}\n}\n\nstatic void lsr_read_object_content(GF_LASeRCodec *lsr, SVG_Element *elt)\n{\n\tu32 val;\n\tGF_LSR_READ_INT(lsr, val, 1, \"has_private_attr\");\n\tif (val) lsr_read_private_attribute_container(lsr);\n}\n\nstatic void lsr_read_codec_IDREF(GF_LASeRCodec *lsr, XMLRI *href, const char *name)\n{\n\tGF_Node *n;\n\tu32 flag;\n\tu32 nID = 1+lsr_read_vluimsbf5(lsr, name);\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"reserved\");\n\tif (flag) {\n\t\tu32 len = lsr_read_vluimsbf5(lsr, \"len\");\n\t\tGF_LSR_READ_INT(lsr, flag, len, \"reserved\");\n\t}\n\n\tn = gf_sg_find_node(lsr->sg, nID);\n\tif (!n) {\n\t\tchar NodeID[1024];\n\t\tsprintf(NodeID, \"N%d\", nID-1);\n\t\thref->string = gf_strdup(NodeID);\n\t\tif (href->type!=0xFF)\n\t\t\tgf_list_add(lsr->deferred_hrefs, href);\n\t\thref->type = XMLRI_ELEMENTID;\n\t\treturn;\n\t}\n\thref->target = (SVG_Element *)n;\n\thref->type = XMLRI_ELEMENTID;\n\tgf_node_register_iri(lsr->sg, href);\n}\n\nstatic u32 lsr_read_codec_IDREF_command(GF_LASeRCodec *lsr, const char *name)\n{\n\tu32 flag;\n\tu32 nID = 1+lsr_read_vluimsbf5(lsr, name);\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"reserved\");\n\tif (flag) {\n\t\tu32 len = lsr_read_vluimsbf5(lsr, \"len\");\n\t\tGF_LSR_READ_INT(lsr, flag, len, \"reserved\");\n\t}\n\treturn nID;\n}\n\nstatic Fixed lsr_read_fixed_16_8(GF_LASeRCodec *lsr, const char *name)\n{\n\tu32 val;\n\tGF_LSR_READ_INT(lsr, val, 24, name);\n\tif (val & (1<<23)) {\n\t\ts32 res = val - (1<<24);\n#ifdef GPAC_FIXED_POINT\n\t\treturn res*256;\n#else\n\t\treturn INT2FIX(res) / 256;\n#endif\n\t} else {\n#ifdef GPAC_FIXED_POINT\n\t\treturn val*256;\n#else\n\t\treturn INT2FIX(val) / 256;\n#endif\n\t}\n}\n\nstatic void lsr_read_fixed_16_8i(GF_LASeRCodec *lsr, SVG_Number *n, const char *name)\n{\n\ts32 val;\n\tGF_LSR_READ_INT(lsr, val, 1, name);\n\tif (val) {\n\t\tn->type=SVG_NUMBER_INHERIT;\n\t} else {\n\t\tn->type=SVG_NUMBER_VALUE;\n\t\tn->value = lsr_read_fixed_16_8(lsr, name);\n\t}\n}\n\n\nstatic void lsr_get_color(GF_LASeRCodec *lsr, u32 idx, SVG_Color *color)\n{\n\tLSRCol *c;\n\tif (idx>=lsr->nb_cols) return;\n\n\tc = &lsr->col_table[idx];\n\tcolor->red = INT2FIX(c->r) / lsr->color_scale;\n\tcolor->green = INT2FIX(c->g) / lsr->color_scale;\n\tcolor->blue = INT2FIX(c->b) / lsr->color_scale;\n\tcolor->type = SVG_COLOR_RGBCOLOR;\n}\n\n\nstatic void lsr_read_line_increment_type(GF_LASeRCodec *lsr, SVG_Number *li, const char *name)\n{\n\tu32 val;\n\tGF_LSR_READ_INT(lsr, val, 1, \"choice\");\n\tif (val==1) {\n\t\tGF_LSR_READ_INT(lsr, val, 1, \"type\");\n\t\tif (val==1) li->type=SVG_NUMBER_INHERIT;\n\t\telse li->type=SVG_NUMBER_AUTO;\n\t} else {\n\t\tli->value = lsr_read_fixed_16_8(lsr, \"line-increment-value\");\n\t}\n}\n\nstatic void lsr_read_byte_align_string(GF_LASeRCodec *lsr, char **str, const char *name)\n{\n\tu32 len;\n\tgf_bs_align(lsr->bs);\n\tlen = lsr_read_vluimsbf8(lsr, \"len\");\n\tif (str) {\n\t\tif (*str) gf_free(*str);\n\t\t*str = NULL;\n\t\tif (len) {\n\t\t\tif (len > gf_bs_available(lsr->bs) ) {\n\t\t\t\tlsr->last_error = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*str = (char*)gf_malloc(sizeof(char)*(len+1));\n\t\t\tif (!*str) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgf_bs_read_data(lsr->bs, *str, len);\n\t\t\t(*str) [len] = 0;\n\t\t}\n\t} else {\n\t\tif (len > gf_bs_available(lsr->bs) ) {\n\t\t\tlsr->last_error = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\treturn;\n\t\t}\n\t\twhile (len) {\n\t\t\tgf_bs_read_int(lsr->bs, 8);\n\t\t\tlen--;\n\t\t}\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[LASeR] %s\\t\\t%d\\t\\t%s\\n\", name, 8*len, str ? *str : \"\"));\n}\n\nstatic void lsr_read_text_content(GF_LASeRCodec *lsr, GF_Node *elt)\n{\n\tchar *str = NULL;\n\tlsr_read_byte_align_string(lsr, &str, \"textContent\");\n\tif (!str) return;\n\tgf_dom_add_text_node(elt, str);\n}\n\nstatic void lsr_read_byte_align_string_list(GF_LASeRCodec *lsr, GF_List *l, const char *name, Bool is_iri, Bool is_font)\n{\n\tXMLRI *iri;\n\tchar *text, *sep, *sep2, *cur;\n\twhile (gf_list_count(l)) {\n\t\tchar *str = (char *)gf_list_last(l);\n\t\tgf_list_rem_last(l);\n\t\tgf_free(str);\n\t}\n\ttext = NULL;\n\tlsr_read_byte_align_string(lsr, &text, name);\n\tcur = text;\n\twhile (cur) {\n\t\tsep = strchr(cur, '\\'');\n\t\tif (!sep && is_font) {\n\t\t\tsep = strchr(cur, ',');\n\t\t\tif (!sep) sep = strchr(cur, ';');\n\t\t}\n\t\tif (!sep) {\n\t\t\tif (is_iri) {\n\t\t\t\tGF_SAFEALLOC(iri, XMLRI);\n\t\t\t\tif (iri) {\n\t\t\t\t\tiri->string = gf_strdup(cur);\n\t\t\t\t\tiri->type = XMLRI_STRING;\n\t\t\t\t\tgf_list_add(l, iri);\n\t\t\t\t} else {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_list_add(l, gf_strdup(cur));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tsep2 = strchr(sep + 1, '\\'');\n\t\tif (!sep2 && !is_font) {\n\t\t\tif (is_iri) {\n\t\t\t\tGF_SAFEALLOC(iri, XMLRI);\n\t\t\t\tif (iri) {\n\t\t\t\t\tiri->string = gf_strdup(cur);\n\t\t\t\t\tiri->type = XMLRI_STRING;\n\t\t\t\t\tgf_list_add(l, iri);\n\t\t\t\t} else {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_list_add(l, gf_strdup(cur));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (sep2)\n\t\t\tsep2[0] = 0;\n\t\telse\n\t\t\tsep[0] = 0;\n\t\tif (is_iri) {\n\t\t\tGF_SAFEALLOC(iri, XMLRI);\n\t\t\tif (iri) {\n\t\t\t\tiri->string = gf_strdup(sep+1);\n\t\t\t\tiri->type = XMLRI_STRING;\n\t\t\t\tgf_list_add(l, iri);\n\t\t\t} else {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t}\n\t\t} else {\n\t\t\tgf_list_add(l, gf_strdup(sep+1));\n\t\t}\n\t\tif (sep2) {\n\t\t\tsep2[0] = '\\'';\n\t\t\tcur = sep2 + 1;\n\t\t} else {\n\t\t\tsep[0] = ';';\n\t\t\tcur = sep + 1;\n\t\t}\n\t}\n\tgf_free(text);\n}\n\nstatic void lsr_read_any_uri(GF_LASeRCodec *lsr, XMLRI *iri, const char *name)\n{\n\tu32 val;\n\tGF_LSR_READ_INT(lsr, val, 1, \"hasUri\");\n\tif (val) {\n\t\tchar *s = NULL;\n\t\tiri->type=XMLRI_STRING;\n\t\tif (iri->string) {\n\t\t\tgf_free(iri->string);\n\t\t\tiri->string = NULL;\n\t\t}\n\t\tlsr_read_byte_align_string(lsr, &s, \"uri\");\n\t\tGF_LSR_READ_INT(lsr, val, 1, \"hasData\");\n\t\tif (!val) {\n\t\t\tiri->string = s;\n\t\t} else {\n\t\t\tu32 len_rad, len;\n\t\t\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\t\t\tif (len > gf_bs_available(lsr->bs)) {\n\t\t\t\tlsr->last_error = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlen_rad = s ? (u32) strlen(s) : 0;\n\t\t\tiri->string = (char*)gf_malloc(sizeof(char)*(len_rad+1+len+1));\n\t\t\tif (!iri->string) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tiri->string[0] = 0;\n\t\t\tif (s) {\n\t\t\t\tstrcpy(iri->string, s);\n\t\t\t\tgf_free(s);\n\t\t\t}\n\t\t\tstrcat(iri->string, \",\");\n\t\t\tgf_bs_read_data(lsr->bs, iri->string + len_rad + 1, len);\n\t\t\tiri->string[len_rad + 1 + len] = 0;\n\t\t}\n\t}\n\tGF_LSR_READ_INT(lsr, val, 1, \"hasID\");\n\tif (val) lsr_read_codec_IDREF(lsr, iri, \"idref\");\n\n\tGF_LSR_READ_INT(lsr, val, 1, \"hasStreamID\");\n\tif (val) {\n\t\tiri->type = XMLRI_STREAMID;\n\t\tiri->lsr_stream_id = lsr_read_vluimsbf5(lsr, name);\n\t\tGF_LSR_READ_INT(lsr, val, 1, \"reserved\");\n\t\tif (val) {\n\t\t\tu32 len = lsr_read_vluimsbf5(lsr, \"len\");\n\t\t\tGF_LSR_READ_INT(lsr, val, len, \"reserved\");\n\t\t}\n\t}\n}\n\nstatic void lsr_read_paint(GF_LASeRCodec *lsr, SVG_Paint *paint, const char *name)\n{\n\tu32 val;\n\tGF_LSR_READ_INT(lsr, val, 1, \"hasIndex\");\n\tif (val) {\n\t\tGF_LSR_READ_INT(lsr, val, lsr->colorIndexBits, name);\n\t\tlsr_get_color(lsr, val, &paint->color);\n\t\tpaint->type = SVG_PAINT_COLOR;\n\t\tpaint->color.type = 0;\n\t} else {\n\t\tGF_LSR_READ_INT(lsr, val, 2, \"enum\");\n\t\tswitch (val) {\n\t\tcase 0:\n\t\t\tGF_LSR_READ_INT(lsr, val, 2, \"choice\");\n\t\t\tswitch (val) {\n\t\t\tcase 0:\n\t\t\t\tpaint->type = SVG_PAINT_INHERIT;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tpaint->type = SVG_PAINT_COLOR;\n\t\t\t\tpaint->color.type = SVG_COLOR_CURRENTCOLOR;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpaint->type = SVG_PAINT_NONE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t{\n\t\t\tXMLRI iri;\n\t\t\tmemset(&iri, 0, sizeof(XMLRI));\n\t\t\tiri.type = 0xFF;\n\t\t\tlsr_read_any_uri(lsr, &iri, name);\n\t\t\tgf_node_unregister_iri(lsr->sg, &iri);\n\t\t\tgf_list_del_item(lsr->deferred_hrefs, &iri);\n\n\t\t\tpaint->type = SVG_PAINT_URI;\n\t\t\tif (iri.string) {\n\t\t\t\tpaint->type = SVG_PAINT_URI;\n\t\t\t\tpaint->iri.type = XMLRI_STRING;\n\t\t\t\tpaint->iri.string = iri.string;\n\t\t\t} else if (iri.target) {\n\t\t\t\tpaint->iri.type = XMLRI_ELEMENTID;\n\t\t\t\tpaint->iri.target = iri.target;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 2:\n\t\t{\n\t\t\tchar *sysPaint=NULL;\n\t\t\tlsr_read_byte_align_string(lsr, &sysPaint, \"systemsPaint\");\n\t\t\tif (sysPaint) {\n\t\t\t\tpaint->type = SVG_PAINT_COLOR;\n\t\t\t\tpaint->color.type = gf_svg_get_system_paint_server_type(sysPaint);\n\t\t\t\tgf_free(sysPaint);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 3:\n\t\t\tlsr_read_extension(lsr, name);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void lsr_read_string_attribute(GF_LASeRCodec *lsr, GF_Node *elt, u32 tag, char *name)\n{\n\tu32 val;\n\tGF_LSR_READ_INT(lsr, val, 1, name);\n\tif (val) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, tag, GF_TRUE, GF_FALSE, &info);\n\t\tlsr_read_byte_align_string(lsr, info.far_ptr, name);\n\t}\n}\nstatic void lsr_read_id(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tGF_FieldInfo info;\n\tu32 val, id, i, count;\n\tchar *name;\n\tGF_LSR_READ_INT(lsr, val, 1, \"has_id\");\n\tif (!val) return;\n\n\tname = NULL;\n\tid = 1+lsr_read_vluimsbf5(lsr, \"ID\");\n\tgf_node_set_id(n, id, name);\n\n\tGF_LSR_READ_INT(lsr, val, 1, \"reserved\");\n\t/*currently not used*/\n\tif (val) {\n\t\tu32 len = lsr_read_vluimsbf5(lsr, \"len\");\n\t\tGF_LSR_READ_INT(lsr, val, len, \"reserved\");\n\t}\n\n\t/*update all pending HREFs*/\n\tcount = gf_list_count(lsr->deferred_hrefs);\n\tfor (i=0; i<count; i++) {\n\t\tXMLRI *href = (XMLRI *)gf_list_get(lsr->deferred_hrefs, i);\n\t\tchar *str_id = href ? href->string : NULL;\n\t\tif (!str_id) return;\n\t\t\n\t\tif (str_id[0] == '#') str_id++;\n\t\t/*skip 'N'*/\n\t\tstr_id++;\n\t\tif (id == (1 + (u32) atoi(str_id))) {\n\t\t\thref->target = (SVG_Element*) n;\n\t\t\tgf_free(href->string);\n\t\t\thref->string = NULL;\n\t\t\tgf_list_rem(lsr->deferred_hrefs, i);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t}\n\t}\n\n\t/*update unresolved listeners*/\n\tcount = gf_list_count(lsr->deferred_listeners);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Node *par;\n\t\tXMLRI *observer = NULL;\n\t\tGF_Node *listener = (GF_Node *)gf_list_get(lsr->deferred_listeners, i);\n\n\t\tpar = NULL;\n\t\tif (gf_node_get_attribute_by_tag(listener, TAG_XMLEV_ATT_observer, GF_FALSE, GF_FALSE, &info) == GF_OK) {\n\t\t\tobserver = (XMLRI*)info.far_ptr;\n\t\t\tif (observer->type == XMLRI_ELEMENTID) {\n\t\t\t\tif (!observer->target) continue;\n\t\t\t\telse par = (GF_Node*)observer->target;\n\t\t\t}\n\t\t}\n\t\tif (gf_node_get_attribute_by_tag(listener, TAG_XMLEV_ATT_target, GF_FALSE, GF_FALSE, &info) == GF_OK) {\n\t\t\tif (((XMLRI*)info.far_ptr)->type == XMLRI_ELEMENTID) {\n\t\t\t\tif (!((XMLRI*)info.far_ptr)->target) continue;\n\t\t\t\telse if (!par) par = (GF_Node*)((XMLRI*)info.far_ptr)->target;\n\t\t\t}\n\t\t}\n\t\t/*FIXME - double check with XML events*/\n\t\tif (!par && !observer) {\n\t\t\tif (gf_node_get_attribute_by_tag(listener, TAG_XMLEV_ATT_event, GF_FALSE, GF_FALSE, &info) == GF_OK) {\n\t\t\t\tXMLEV_Event *ev = (XMLEV_Event *)info.far_ptr;\n\t\t\t\t/*all non-UI get attched to root*/\n\t\t\t\tif (ev && (ev->type>GF_EVENT_MOUSEWHEEL)) {\n\t\t\t\t\tpar = (GF_Node*) lsr->current_root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tassert(par);\n\t\tgf_node_dom_listener_add(par, listener);\n\t\tgf_list_rem(lsr->deferred_listeners, i);\n\t\ti--;\n\t\tcount--;\n\t}\n\n\t/*update all pending animations*/\n\tcount = gf_list_count(lsr->deferred_anims);\n\tfor (i=0; i<count; i++) {\n\t\tSVG_Element *elt = (SVG_Element *)gf_list_get(lsr->deferred_anims, i);\n\t\tif (lsr_setup_smil_anim(lsr, elt, NULL)) {\n\t\t\tgf_list_rem(lsr->deferred_anims, i);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t\tgf_node_init((GF_Node*)elt);\n\t\t}\n\t}\n}\n\nstatic Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n{\n\tif (!nb_bits) return 0;\n\t\n#ifdef GPAC_FIXED_POINT\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\tif (neg < -FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\tif (val > FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#else\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#endif\n}\n\nstatic Fixed lsr_translate_scale(GF_LASeRCodec *lsr, u32 val)\n{\n\tif (val >> (lsr->coord_bits-1) ) {\n\t\ts32 v = val - (1<<lsr->coord_bits);\n\t\treturn INT2FIX(v) / 256 ;\n\t} else {\n\t\treturn INT2FIX(val) / 256;\n\t}\n}\nstatic void lsr_read_matrix(GF_LASeRCodec *lsr, SVG_Transform *mx)\n{\n\tu32 flag;\n\tgf_mx2d_init(mx->mat);\n\tmx->is_ref = 0;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"isNotMatrix\");\n\tif (flag) {\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"isRef\");\n\t\tif (flag) {\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"hasXY\");\n\t\t\tif (flag) {\n\t\t\t\tmx->mat.m[2] = lsr_read_fixed_16_8(lsr, \"valueX\");\n\t\t\t\tmx->mat.m[5] = lsr_read_fixed_16_8(lsr, \"valueY\");\n\t\t\t}\n\t\t} else {\n\t\t\tlsr_read_extension(lsr, \"ext\");\n\t\t}\n\t} else {\n\t\tlsr->coord_bits += lsr->scale_bits;\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"xx_yy_present\");\n\t\tif (flag) {\n\t\t\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, \"xx\");\n\t\t\tmx->mat.m[0] = lsr_translate_scale(lsr, flag);\n\t\t\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, \"yy\");\n\t\t\tmx->mat.m[4] = lsr_translate_scale(lsr, flag);\n\t\t} else {\n\t\t\tmx->mat.m[0] = mx->mat.m[4] = FIX_ONE;\n\t\t}\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"xy_yx_present\");\n\t\tif (flag) {\n\t\t\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, \"xy\");\n\t\t\tmx->mat.m[1] = lsr_translate_scale(lsr, flag);\n\t\t\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, \"yx\");\n\t\t\tmx->mat.m[3] = lsr_translate_scale(lsr, flag);\n\t\t}\n\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"xz_yz_present\");\n\t\tif (flag) {\n\t\t\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, \"xz\");\n\t\t\tmx->mat.m[2] = lsr_translate_coords(lsr, flag, lsr->coord_bits);\n\t\t\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, \"yz\");\n\t\t\tmx->mat.m[5] = lsr_translate_coords(lsr, flag, lsr->coord_bits);\n\t\t}\n\t\tlsr->coord_bits -= lsr->scale_bits;\n\t}\n}\n\nstatic Fixed lsr_read_fixed_clamp(GF_LASeRCodec *lsr, const char *name)\n{\n\ts32 val;\n\tGF_LSR_READ_INT(lsr, val, 8, name);\n\treturn INT2FIX(val) / 255;\n}\n\nstatic void lsr_read_focus(GF_LASeRCodec *lsr, SVG_Focus *foc, const char *name)\n{\n\tu32 flag;\n\n\tif (foc->target.string) {\n\t\tgf_free(foc->target.string);\n\t\tfoc->target.string = NULL;\n\t}\n\tif (foc->target.target) foc->target.target = NULL;\n\tgf_node_unregister_iri(lsr->sg, &foc->target);\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"isEnum\");\n\tif (flag) {\n\t\tGF_LSR_READ_INT(lsr, foc->type, 1, \"enum\");\n\t} else {\n\t\tfoc->type = SVG_FOCUS_IRI;\n\t\tlsr_read_codec_IDREF(lsr, &foc->target, \"id\");\n\t}\n}\n\nstatic void lsr_restore_base(GF_LASeRCodec *lsr, SVG_Element *elt, SVG_Element *base, Bool reset_fill, Bool reset_stroke)\n{\n\tGF_Err e;\n\tGF_FieldInfo f_base, f_clone;\n\tSVGAttribute *att;\n\n\t/*clone all propertie from base*/\n\tatt = base->attributes;\n\twhile (att) {\n\t\tBool is_fill, is_stroke;\n\t\tis_fill = is_stroke = GF_FALSE;\n\t\tswitch (att->tag) {\n\t\t/*for all properties*/\n\t\tcase TAG_SVG_ATT_fill:\n\t\t\tis_fill = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke:\n\t\t\tis_stroke = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_audio_level:\n\t\tcase TAG_SVG_ATT_color:\n\t\tcase TAG_SVG_ATT_color_rendering:\n\t\tcase TAG_SVG_ATT_display:\n\t\tcase TAG_SVG_ATT_display_align:\n\t\tcase TAG_SVG_ATT_fill_opacity:\n\t\tcase TAG_SVG_ATT_fill_rule:\n\t\tcase TAG_SVG_ATT_font_family:\n\t\tcase TAG_SVG_ATT_font_size:\n\t\tcase TAG_SVG_ATT_font_style:\n\t\tcase TAG_SVG_ATT_font_variant:\n\t\tcase TAG_SVG_ATT_font_weight:\n\t\tcase TAG_SVG_ATT_image_rendering:\n\t\tcase TAG_SVG_ATT_line_increment:\n\t\tcase TAG_SVG_ATT_opacity:\n\t\tcase TAG_SVG_ATT_pointer_events:\n\t\tcase TAG_SVG_ATT_shape_rendering:\n\t\tcase TAG_SVG_ATT_solid_color:\n\t\tcase TAG_SVG_ATT_solid_opacity:\n\t\tcase TAG_SVG_ATT_stop_color:\n\t\tcase TAG_SVG_ATT_stop_opacity:\n\t\tcase TAG_SVG_ATT_stroke_dasharray:\n\t\tcase TAG_SVG_ATT_stroke_dashoffset:\n\t\tcase TAG_SVG_ATT_stroke_linecap:\n\t\tcase TAG_SVG_ATT_stroke_linejoin:\n\t\tcase TAG_SVG_ATT_stroke_miterlimit:\n\t\tcase TAG_SVG_ATT_stroke_opacity:\n\t\tcase TAG_SVG_ATT_stroke_width:\n\t\tcase TAG_SVG_ATT_text_align:\n\t\tcase TAG_SVG_ATT_text_anchor:\n\t\tcase TAG_SVG_ATT_text_rendering:\n\t\tcase TAG_SVG_ATT_vector_effect:\n\t\tcase TAG_SVG_ATT_viewport_fill:\n\t\tcase TAG_SVG_ATT_viewport_fill_opacity:\n\t\tcase TAG_SVG_ATT_visibility:\n\t\t/*and xml:_class*/\n\t\tcase TAG_SVG_ATT__class:\n\t\tcase TAG_SVG_ATT_externalResourcesRequired:\n\t\t\tbreak;\n\n\t\t/*pathLength for path*/\n\t\tcase TAG_SVG_ATT_pathLength:\n\t\t\tbreak;\n\t\t/*rx & ry for rect*/\n\t\tcase TAG_SVG_ATT_rx:\n\t\tcase TAG_SVG_ATT_ry:\n\t\t\tif (base->sgprivate->tag!=TAG_SVG_rect) {\n\t\t\t\tatt = att->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t/*x & y for use*/\n\t\tcase TAG_SVG_ATT_x:\n\t\tcase TAG_SVG_ATT_y:\n\t\t\tif (base->sgprivate->tag!=TAG_SVG_use) {\n\t\t\t\tatt = att->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t/*editable & rotate for text*/\n\t\tcase TAG_SVG_ATT_editable:\n\t\tcase TAG_SVG_ATT_rotate:\n\t\t\tif (base->sgprivate->tag!=TAG_SVG_text) {\n\t\t\t\tatt = att->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_transform:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tatt = att->next;\n\t\t\tcontinue;\n\t\t}\n\t\t/*clone field*/\n\t\te = gf_node_get_attribute_by_tag((GF_Node*)elt, att->tag, GF_TRUE, GF_FALSE, &f_clone);\n\t\tif (e) goto err_exit;\n\t\tf_base.fieldIndex = att->tag;\n\t\tf_base.fieldType = att->data_type;\n\t\tf_base.far_ptr = att->data;\n\t\te = gf_svg_attributes_copy(&f_clone, &f_base, GF_FALSE);\n\t\tif (e) goto err_exit;\n\n\t\tif (is_fill && reset_fill) {\n\t\t\tSVG_Paint*p = (SVG_Paint*)f_clone.far_ptr;\n\t\t\tif (p->iri.string) gf_free(p->iri.string);\n\t\t\tmemset(p, 0, sizeof(SVG_Paint));\n\t\t}\n\t\tif (is_stroke && reset_stroke) {\n\t\t\tSVG_Paint*p = (SVG_Paint*)f_clone.far_ptr;\n\t\t\tif (p->iri.string) gf_free(p->iri.string);\n\t\t\tmemset(p, 0, sizeof(SVG_Paint));\n\t\t}\n\t\tatt = att->next;\n\t}\n\treturn;\n\nerr_exit:\n\tlsr->last_error = e;\n}\n\n\nstatic u32 lsr_to_dom_key(u32 lsr_k)\n{\n\tswitch (lsr_k) {\n\tcase 0:\n\t\treturn GF_KEY_STAR;\n\tcase 1:\n\t\treturn GF_KEY_0;\n\tcase 2:\n\t\treturn GF_KEY_1;\n\tcase 3:\n\t\treturn GF_KEY_2;\n\tcase 4:\n\t\treturn GF_KEY_3;\n\tcase 5:\n\t\treturn GF_KEY_4;\n\tcase 6:\n\t\treturn GF_KEY_5;\n\tcase 7:\n\t\treturn GF_KEY_6;\n\tcase 8:\n\t\treturn GF_KEY_7;\n\tcase 9:\n\t\treturn GF_KEY_8;\n\tcase 10:\n\t\treturn GF_KEY_9;\n\tcase 12:\n\t\treturn GF_KEY_DOWN;\n\tcase 14:\n\t\treturn GF_KEY_LEFT;\n\tcase 16:\n\t\treturn GF_KEY_RIGHT;\n\tcase 20:\n\t\treturn GF_KEY_UP;\n\t/*WHAT IS ANY_KEY (11) ??*/\n\tcase 13:\n\t\treturn GF_KEY_ENTER;\n\tcase 15:\n\t\treturn GF_KEY_ESCAPE;\n\tcase 17:\n\t\treturn GF_KEY_NUMBER;\n\tcase 18:\n\t\treturn GF_KEY_CELL_SOFT1;\n\tcase 19:\n\t\treturn GF_KEY_CELL_SOFT2;\n\tdefault:\n\t\t/*use '*' by default ... */\n\t\treturn 0;\n\t}\n}\n\nstatic void lsr_read_event_type(GF_LASeRCodec *lsr, XMLEV_Event *evtType)\n{\n\tu32 flag;\n\tmemset(evtType, 0, sizeof(XMLEV_Event));\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"choice\");\n\tif (!flag) {\n\t\tchar *evtName, *sep;\n\t\tevtName = NULL;\n\t\tlsr_read_byte_align_string(lsr, &evtName, \"evtString\");\n\t\tevtType->type = evtType->parameter = 0;\n\t\tif (evtName) {\n\t\t\tsep = strchr(evtName, '(');\n\t\t\tif (sep) {\n\t\t\t\tchar *param;\n\t\t\t\tsep[0] = 0;\n\t\t\t\tevtType->type = gf_dom_event_type_by_name(evtName);\n\t\t\t\tsep[0] = '(';\n\t\t\t\tparam = sep+1;\n\t\t\t\tsep = strchr(evtName, ')');\n\t\t\t\tif (sep) sep[0]=0;\n\t\t\t\tif (evtType->type==GF_EVENT_REPEAT) {\n\t\t\t\t\tevtType->parameter = atoi(param);\n\t\t\t\t} else {\n\t\t\t\t\tevtType->parameter = gf_dom_get_key_type(param);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tevtType->type = gf_dom_event_type_by_name(evtName);\n\t\t\t}\n\t\t\tgf_free(evtName);\n\t\t}\n\t} else {\n\t\tevtType->parameter = 0;\n\t\tGF_LSR_READ_INT(lsr, flag, 6, \"event\");\n\t\tswitch (flag) {\n\t\tcase LSR_EVT_abort:\n\t\t\tevtType->type = GF_EVENT_ABORT;\n\t\t\tbreak;\n\t\tcase LSR_EVT_accessKey:\n\t\t\tevtType->type = GF_EVENT_KEYDOWN;\n\t\t\tbreak;\n\t\tcase LSR_EVT_activate:\n\t\t\tevtType->type = GF_EVENT_ACTIVATE;\n\t\t\tbreak;\n\t\tcase LSR_EVT_activatedEvent:\n\t\t\tevtType->type = GF_EVENT_ACTIVATED;\n\t\t\tbreak;\n\t\tcase LSR_EVT_beginEvent:\n\t\t\tevtType->type = GF_EVENT_BEGIN_EVENT;\n\t\t\tbreak;\n\t\tcase LSR_EVT_click:\n\t\t\tevtType->type = GF_EVENT_CLICK;\n\t\t\tbreak;\n\t\tcase LSR_EVT_deactivatedEvent:\n\t\t\tevtType->type = GF_EVENT_DEACTIVATED;\n\t\t\tbreak;\n\t\tcase LSR_EVT_endEvent:\n\t\t\tevtType->type = GF_EVENT_END_EVENT;\n\t\t\tbreak;\n\t\tcase LSR_EVT_error:\n\t\t\tevtType->type = GF_EVENT_ERROR;\n\t\t\tbreak;\n\t\tcase LSR_EVT_executionTime:\n\t\t\tevtType->type = GF_EVENT_EXECUTION_TIME;\n\t\t\tbreak;\n\t\tcase LSR_EVT_focusin:\n\t\t\tevtType->type = GF_EVENT_FOCUSIN;\n\t\t\tbreak;\n\t\tcase LSR_EVT_focusout:\n\t\t\tevtType->type = GF_EVENT_FOCUSOUT;\n\t\t\tbreak;\n\t\tcase LSR_EVT_keydown:\n\t\t\tevtType->type = GF_EVENT_KEYDOWN;\n\t\t\tbreak;\n\t\tcase LSR_EVT_keyup:\n\t\t\tevtType->type = GF_EVENT_KEYUP;\n\t\t\tbreak;\n\t\tcase LSR_EVT_load:\n\t\t\tevtType->type = GF_EVENT_LOAD;\n\t\t\tbreak;\n\t\tcase LSR_EVT_longAccessKey:\n\t\t\tevtType->type = GF_EVENT_LONGKEYPRESS;\n\t\t\tbreak;\n\t\tcase LSR_EVT_mousedown:\n\t\t\tevtType->type = GF_EVENT_MOUSEDOWN;\n\t\t\tbreak;\n\t\tcase LSR_EVT_mousemove:\n\t\t\tevtType->type = GF_EVENT_MOUSEMOVE;\n\t\t\tbreak;\n\t\tcase LSR_EVT_mouseout:\n\t\t\tevtType->type = GF_EVENT_MOUSEOUT;\n\t\t\tbreak;\n\t\tcase LSR_EVT_mouseover:\n\t\t\tevtType->type = GF_EVENT_MOUSEOVER;\n\t\t\tbreak;\n\t\tcase LSR_EVT_mouseup:\n\t\t\tevtType->type = GF_EVENT_MOUSEUP;\n\t\t\tbreak;\n\t\tcase LSR_EVT_pause:\n\t\t\tevtType->type = GF_EVENT_PAUSE;\n\t\t\tbreak;\n\t\tcase LSR_EVT_pausedEvent:\n\t\t\tevtType->type = GF_EVENT_PAUSED_EVENT;\n\t\t\tbreak;\n\t\tcase LSR_EVT_play:\n\t\t\tevtType->type = GF_EVENT_PLAY;\n\t\t\tbreak;\n\t\tcase LSR_EVT_repeatEvent:\n\t\t\tevtType->type = GF_EVENT_REPEAT_EVENT;\n\t\t\tbreak;\n\t\tcase LSR_EVT_repeatKey:\n\t\t\tevtType->type = GF_EVENT_REPEAT_KEY;\n\t\t\tbreak;\n\t\tcase LSR_EVT_resize:\n\t\t\tevtType->type = GF_EVENT_RESIZE;\n\t\t\tbreak;\n\t\tcase LSR_EVT_resumedEvent:\n\t\t\tevtType->type = GF_EVENT_RESUME_EVENT;\n\t\t\tbreak;\n\t\tcase LSR_EVT_scroll:\n\t\t\tevtType->type = GF_EVENT_SCROLL;\n\t\t\tbreak;\n\t\tcase LSR_EVT_shortAccessKey:\n\t\t\tevtType->type = GF_EVENT_SHORT_ACCESSKEY;\n\t\t\tbreak;\n\t\tcase LSR_EVT_textinput:\n\t\t\tevtType->type = GF_EVENT_TEXTINPUT;\n\t\t\tbreak;\n\t\tcase LSR_EVT_unload:\n\t\t\tevtType->type = GF_EVENT_UNLOAD;\n\t\t\tbreak;\n\t\tcase LSR_EVT_zoom:\n\t\t\tevtType->type = GF_EVENT_ZOOM;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[LASeR] Undefined LASeR event %d\\n\", flag));\n\t\t\tbreak;\n\t\t}\n\t\tswitch (flag) {\n\t\tcase LSR_EVT_accessKey:\n\t\tcase LSR_EVT_longAccessKey:\n\t\tcase LSR_EVT_repeatKey:\n\t\tcase LSR_EVT_shortAccessKey:\n\t\t\tevtType->parameter = lsr_read_vluimsbf5(lsr, \"keyCode\");\n\t\t\tevtType->parameter  = lsr_to_dom_key(evtType->parameter);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic SMIL_Time *lsr_read_smil_time(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tSMIL_Time *t;\n\tu32 val;\n\n\tGF_SAFEALLOC(t, SMIL_Time);\n\tif (!t) {\n\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\treturn NULL;\n\t}\n\tt->type = GF_SMIL_TIME_CLOCK;\n\n\tGF_LSR_READ_INT(lsr, val, 1, \"hasEvent\");\n\tif (val) {\n\t\tt->type = GF_SMIL_TIME_EVENT;\n\t\tGF_LSR_READ_INT(lsr, val, 1, \"hasIdentifier\");\n\t\tif (val) {\n\t\t\tXMLRI iri;\n\t\t\tiri.type = 0xFF;\n\t\t\tiri.string = NULL;\n\t\t\tlsr_read_codec_IDREF(lsr, &iri, \"idref\");\n\t\t\tgf_node_unregister_iri(lsr->sg, &iri);\n\t\t\tif (iri.string) {\n\t\t\t\tt->element_id = iri.string;\n\t\t\t} else {\n\t\t\t\tt->element = (GF_Node *)iri.target;\n\t\t\t}\n\t\t}\n\t\tlsr_read_event_type(lsr, &t->event);\n\t\tif (t->event.type==GF_EVENT_EXECUTION_TIME) {\n\t\t\tt->type = GF_SMIL_TIME_CLOCK;\n\t\t\tt->clock = gf_node_get_scene_time(n);\n\t\t}\n\t}\n\tGF_LSR_READ_INT(lsr, val, 1, \"hasClock\");\n\tif (val) {\n\t\tu32 now;\n\t\tGF_LSR_READ_INT(lsr, val, 1, \"sign\");\n\t\tnow = lsr_read_vluimsbf5(lsr, \"value\");\n\t\tt->clock = now;\n\t\tt->clock /= lsr->time_resolution;\n\t\tif (val) t->clock *= -1;\n\t}\n\treturn t;\n}\n\nstatic void lsr_read_smil_times(GF_LASeRCodec *lsr, GF_Node *n, u32 tag, SMIL_Times *times, const char *name, Bool skipable)\n{\n\tGF_FieldInfo info;\n\tSMIL_Time *v;\n\tu32 val, i, count;\n\n\tif (skipable) {\n\t\tGF_LSR_READ_INT(lsr, val, 1, name);\n\t\tif (!val) return;\n\t}\n\tif (!times) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, tag, GF_TRUE, GF_FALSE, &info);\n\t\ttimes = (SMIL_Times*)info.far_ptr;\n\t}\n\n\twhile (gf_list_count(*times)) {\n\t\tv = (SMIL_Time *)gf_list_last(*times);\n\t\tgf_list_rem_last(*times);\n\t\tif (v->element_id) gf_free(v->element_id);\n\t\tgf_free(v);\n\t}\n\n\tGF_LSR_READ_INT(lsr, val, 1, \"choice\");\n\tif (val) {\n\t\tGF_SAFEALLOC(v, SMIL_Time);\n\t\tif (v) {\n\t\t\tv->type = GF_SMIL_TIME_INDEFINITE;\n\t\t\tgf_list_add(*times, v);\n\t\t} else {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t}\n\t\treturn;\n\t}\n\tcount = lsr_read_vluimsbf5(lsr, \"count\");\n\tfor (i=0; i<count; i++) {\n\t\tv = lsr_read_smil_time(lsr, n);\n\t\tgf_list_add(*times, v);\n\t\tif (lsr->last_error) return;\n\t}\n}\n\nstatic void lsr_read_duration_ex(GF_LASeRCodec *lsr, GF_Node *n, u32 tag, SMIL_Duration *smil, const char *name, Bool skipable)\n{\n\tGF_FieldInfo info;\n\tu32 val = 1;\n\n\tif (skipable) {\n\t\tGF_LSR_READ_INT(lsr, val, 1, name);\n\t\tif (!val) return;\n\t}\n\tif (!smil) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, tag, GF_TRUE, GF_FALSE, &info);\n\t\tif (lsr->last_error) return;\n\t\tsmil = (SMIL_Duration *)info.far_ptr;\n\t}\n\tsmil->type = 0;\n\tsmil->clock_value=0;\n\n\tGF_LSR_READ_INT(lsr, val, 1, \"choice\");\n\tif (val) {\n\t\tGF_LSR_READ_INT(lsr, smil->type, 2, \"time\");\n\t} else {\n\t\tBool sign;\n\t\tu32 now;\n\t\tGF_LSR_READ_INT(lsr, sign, 1, \"sign\");\n\t\tnow = lsr_read_vluimsbf5(lsr, \"value\");\n\t\tsmil->clock_value = now;\n\t\tsmil->clock_value /= lsr->time_resolution;\n\t\tif (sign) smil->clock_value *= -1;\n\t\tsmil->type = SMIL_DURATION_DEFINED;\n\t}\n}\nstatic void lsr_read_duration(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tlsr_read_duration_ex(lsr, n, TAG_SVG_ATT_dur, NULL, \"dur\", GF_TRUE);\n}\n/*TODO Add decent error checking...*/\nstatic void lsr_read_rare_full(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tGF_FieldInfo info;\n\tu32 i, nb_rare, field_rare;\n\ts32 field_tag;\n\n\tGF_LSR_READ_INT(lsr, nb_rare, 1, \"has_rare\");\n\tif (!nb_rare) return;\n\tGF_LSR_READ_INT(lsr, nb_rare, 6, \"nbOfAttributes\");\n\n\tfor (i=0; i<nb_rare; i++) {\n\t\tGF_LSR_READ_INT(lsr, field_rare, 6, \"attributeRARE\");\n\n\t\t/*lsr extend*/\n\t\tif (field_rare==49) {\n\t\t\tu32 extID, len, j;\n\t\t\twhile (1) {\n\t\t\t\tGF_LSR_READ_INT(lsr, extID, lsr->info->cfg.extensionIDBits, \"extensionID\");\n\t\t\t\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\t\t\t\tif (extID==2) {\n\t\t\t\t\tGF_LSR_READ_INT(lsr, len, 2, \"nbOfAttributes\");\n\t\t\t\t\tfor (j=0; j<len; j++) {\n\t\t\t\t\t\tGF_LSR_READ_INT(lsr, extID, 3, \"attributeRARE\");\n\t\t\t\t\t\tswitch (extID) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_syncMaster, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, \"syncMaster\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_focusHighlight, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FocusHighlight *)info.far_ptr, 2, \"focusHighlight\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_initialVisibility, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_InitialVisibility *)info.far_ptr, 2, \"initialVisibility\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_fullscreen, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, \"fullscreen\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_requiredFonts, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List **)info.far_ptr, \"requiredFonts\", GF_FALSE, GF_TRUE);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_read_int(lsr->bs, len);\n\t\t\t\t}\n\t\t\t\tGF_LSR_READ_INT(lsr, extID, 1, \"hasNextExtension\");\n\t\t\t\tif (!extID) break;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfield_tag = gf_lsr_rare_type_to_attribute(field_rare);\n\t\tif (field_tag==-1) {\n\t\t\treturn;\n\t\t}\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, field_tag, GF_TRUE, GF_FALSE, &info);\n\t\tif (!info.far_ptr) lsr->last_error = GF_NOT_SUPPORTED;\n\t\tif (lsr->last_error) return;\n\n\t\tswitch (field_tag) {\n\t\tcase TAG_SVG_ATT__class:\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"class\");\n\t\t\tbreak;\n\t\t/*properties*/\n\t\tcase TAG_SVG_ATT_audio_level:\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"audio-level\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_color:\n\t\t\tlsr_read_paint(lsr, (SVG_Paint *)info.far_ptr, \"color\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_color_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, \"color-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_display:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Display*)info.far_ptr, 5, \"display\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_display_align:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_DisplayAlign*)info.far_ptr, 3, \"display-align\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_fill_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"fill-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_fill_rule:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FillRule*)info.far_ptr, 2, \"fill-rule\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_image_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, \"image-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_line_increment:\n\t\t\tlsr_read_line_increment_type(lsr, info.far_ptr, \"line-increment\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_pointer_events:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_PointerEvents*)info.far_ptr, 4, \"pointer-events\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_shape_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, \"shape-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_solid_color:\n\t\t\tlsr_read_paint(lsr, info.far_ptr, \"solid-color\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_solid_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"solid-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stop_color:\n\t\t\tlsr_read_paint(lsr, info.far_ptr, \"stop-color\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stop_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"stop-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_dasharray:\n\t\t{\n\t\t\tu32 j, flag;\n\t\t\tSVG_StrokeDashArray *da = (SVG_StrokeDashArray *)info.far_ptr;\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"dashArray\");\n\t\t\tif (flag) {\n\t\t\t\tda->type=SVG_STROKEDASHARRAY_INHERIT;\n\t\t\t} else {\n\t\t\t\tda->type=SVG_STROKEDASHARRAY_ARRAY;\n\t\t\t\tda->array.count = lsr_read_vluimsbf5(lsr, \"len\");\n\t\t\t\tda->array.vals = (Fixed*)gf_malloc(sizeof(Fixed)*da->array.count);\n\t\t\t\tda->array.units = (u8*)gf_malloc(sizeof(u8)*da->array.count);\n\t\t\t\tif (!da->array.vals || !da->array.units) {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor (j=0; j<da->array.count; j++) {\n\t\t\t\t\tda->array.vals[j] = lsr_read_fixed_16_8(lsr, \"dash\");\n\t\t\t\t\tda->array.units[j] = 0;\n\t\t\t\t\tif (lsr->last_error) return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_dashoffset:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"dashOffset\");\n\t\t\tbreak;\n\n\t\tcase TAG_SVG_ATT_stroke_linecap:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_StrokeLineCap*)info.far_ptr, 2, \"stroke-linecap\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_linejoin:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_StrokeLineJoin*)info.far_ptr, 2, \"stroke-linejoin\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_miterlimit:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"miterLimit\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"stroke-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_width:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"strokeWidth\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_text_anchor:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_TextAnchor*)info.far_ptr, 2, \"text-achor\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_text_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, \"text-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_viewport_fill:\n\t\t\tlsr_read_paint(lsr, info.far_ptr, \"viewport-fill\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_viewport_fill_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"viewport-fill-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_vector_effect:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_VectorEffect*)info.far_ptr, 4, \"vector-effect\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_visibility:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Visibility*)info.far_ptr, 2, \"visibility\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_requiredExtensions:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"requiredExtensions\", GF_TRUE, GF_FALSE);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_requiredFormats:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"requiredFormats\", GF_FALSE, GF_FALSE);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_requiredFeatures:\n\t\t{\n\t\t\tu32 j, fcount = lsr_read_vluimsbf5(lsr, \"count\");\n\t\t\tfor (j=0; j<fcount; j++) {\n\t\t\t\tu32 fval;\n\t\t\t\tGF_LSR_READ_INT(lsr, fval, 6, \"feature\");\n\t\t\t\tif (lsr->last_error) return;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TAG_SVG_ATT_systemLanguage:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"systemLanguage\", GF_FALSE, GF_FALSE);\n\t\t\tbreak;\n\t\tcase TAG_XML_ATT_base:\n\t\t\tlsr_read_byte_align_string(lsr, &((XMLRI*)info.far_ptr)->string, \"xml:base\");\n\t\t\t((XMLRI*)info.far_ptr)->type = XMLRI_STRING;\n\t\t\tbreak;\n\t\tcase TAG_XML_ATT_lang:\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"xml:lang\");\n\t\t\tbreak;\n\t\tcase TAG_XML_ATT_space:\n\t\t\tGF_LSR_READ_INT(lsr, *(XML_Space*)info.far_ptr, 1, \"xml:space\");\n\t\t\tbreak;\n\t\t/*focusable*/\n\t\tcase TAG_SVG_ATT_nav_next:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNext\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_up:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNorth\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_up_left:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNorthEast\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_up_right:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNorthWest\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_prev:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusPrev\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_down:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusSouth\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_down_left:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusSouthEast\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_down_right:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusSouthWest\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_left:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusEast\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_focusable:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Focusable*)info.far_ptr, 2, \"focusable\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_right:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusWest\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_transform:\n\t\t\tlsr_read_matrix(lsr, info.far_ptr);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_text_decoration:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"textDecoration\", GF_FALSE, GF_FALSE);\n\t\t\tbreak;\n\n\t\tcase TAG_SVG_ATT_font_variant:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FontVariant*)info.far_ptr, 2, \"font-variant\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_family:\n\t\t{\n\t\t\tu32 flag;\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"isInherit\");\n\t\t\tif (flag) {\n\t\t\t\t((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_INHERIT;\n\t\t\t} else {\n\t\t\t\tchar *ft;\n\t\t\t\t((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_VALUE;\n\t\t\t\tGF_LSR_READ_INT(lsr, flag, lsr->fontIndexBits, \"fontIndex\");\n\t\t\t\tft = (char*)gf_list_get(lsr->font_table, flag);\n\t\t\t\tif (ft) ((SVG_FontFamily*)info.far_ptr)->value = gf_strdup(ft);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_size:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"fontSize\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_style:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FontStyle*)info.far_ptr, 3, \"fontStyle\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_weight:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FontWeight*)info.far_ptr, 4, \"fontWeight\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_title:\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"xlink:title\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_type:\n\t\t\t/*TODO FIXME*/\n\t\t\tGF_LSR_READ_INT(lsr, field_rare, 3, \"xlink:type\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_role:\n\t\t\tlsr_read_any_uri(lsr, info.far_ptr, \"xlink:role\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_arcrole:\n\t\t\tlsr_read_any_uri(lsr, info.far_ptr, \"xlink:arcrole\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_actuate:\n\t\t\t/*TODO FIXME*/\n\t\t\tGF_LSR_READ_INT(lsr, field_rare, 2, \"xlink:actuate\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_show:\n\t\t\t/*TODO FIXME*/\n\t\t\tGF_LSR_READ_INT(lsr, field_rare, 3, \"xlink:show\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_end:\n\t\t\tlsr_read_smil_times(lsr, NULL, 0, info.far_ptr, \"end\", 0);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_max:\n\t\t\tlsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, \"min\", 0);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_min:\n\t\t\tlsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, \"min\", 0);\n\t\t\tbreak;\n\t\t}\n\t\tif (lsr->last_error) return;\n\t}\n}\n\n#define lsr_read_rare(_a, _b) lsr_read_rare_full(_a, _b)\n\nstatic void lsr_read_fill(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tBool has_fill;\n\tGF_LSR_READ_INT(lsr, has_fill, 1, \"fill\");\n\tif (has_fill) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_fill, GF_TRUE, GF_FALSE, &info);\n\t\tlsr_read_paint(lsr, info.far_ptr, \"fill\");\n\t}\n}\n\nstatic void lsr_read_stroke(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tBool has_stroke;\n\tGF_LSR_READ_INT(lsr, has_stroke, 1, \"has_stroke\");\n\tif (has_stroke) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_stroke, GF_TRUE, GF_FALSE, &info);\n\t\tlsr_read_paint(lsr, info.far_ptr, \"stroke\");\n\t}\n}\nstatic void lsr_read_href(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tBool has_href;\n\tGF_LSR_READ_INT(lsr, has_href, 1, \"has_href\");\n\tif (has_href) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_XLINK_ATT_href, GF_TRUE, GF_FALSE, &info);\n\t\tlsr_read_any_uri(lsr, info.far_ptr, \"href\");\n\t}\n}\n\nstatic void lsr_read_accumulate(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tBool v;\n\tGF_LSR_READ_INT(lsr, v, 1, \"has_accumulate\");\n\tif (v) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_accumulate, GF_TRUE, GF_FALSE, &info);\n\t\tGF_LSR_READ_INT(lsr, *(SMIL_Accumulate*)info.far_ptr, 1, \"accumulate\");\n\t}\n}\nstatic void lsr_read_additive(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tBool v;\n\tGF_LSR_READ_INT(lsr, v, 1, \"has_additive\");\n\tif (v) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_additive, GF_TRUE, GF_FALSE, &info);\n\t\tGF_LSR_READ_INT(lsr, *(SMIL_Additive*)info.far_ptr, 1, \"additive\");\n\t}\n}\nstatic void lsr_read_calc_mode(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 v;\n\t/*SMIL_CALCMODE_LINEAR is default and 0 in our code*/\n\tGF_LSR_READ_INT(lsr, v, 1, \"has_calcMode\");\n\tif (v) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_calcMode, GF_TRUE, GF_FALSE, &info);\n\t\tGF_LSR_READ_INT(lsr, *(SMIL_CalcMode*)info.far_ptr, 2, \"calcMode\");\n\t}\n}\n\nstatic void lsr_read_attribute_name_ex(GF_LASeRCodec *lsr, GF_Node *n, Bool skippable)\n{\n\tu32 val = 1;\n\tif (skippable) {\n\t\tGF_LSR_READ_INT(lsr, val, 1, \"hasAttributeName\");\n\t\tif (!val) return;\n\t}\n\n\tGF_LSR_READ_INT(lsr, val, 1, \"choice\");\n\tif (val) {\n\t\tlsr_read_vluimsbf5(lsr, \"item[i]\");\n\t\tlsr_read_vluimsbf5(lsr, \"item[i]\");\n\t\treturn;\n\t} else {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_attributeName, GF_TRUE, GF_FALSE, &info);\n\t\tGF_LSR_READ_INT(lsr, val, 8, \"attributeType\");\n\n\t\t/*translate type to attribute tag*/\n\t\t((SMIL_AttributeName*)info.far_ptr)->type = gf_lsr_anim_type_to_attribute(val);\n\t}\n}\nstatic void lsr_read_attribute_name(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tlsr_read_attribute_name_ex(lsr, n, GF_TRUE);\n}\n\nstatic void lsr_delete_anim_value(GF_LASeRCodec *lsr, SMIL_AnimateValue *val, u32 coded_type)\n{\n\t//unable to transform, free mem and reset\n\tswitch (coded_type) {\n\tcase 0://SVG_string *\n\t\tgf_free(* (SVG_String *)val->value);\n\t\tgf_free(val->value);\n\t\tbreak;\n\tcase 1://SVG_Number *\n\t\tgf_free(val->value);\n\t\tbreak;\n\tcase 2: //SVG_PathData *\n\t\tgf_svg_delete_attribute_value(SVG_PathData_datatype, val->value, NULL);\n\t\tbreak;\n\tcase 3: //SVG_Points *pts\n\t\tgf_svg_delete_attribute_value(SVG_Points_datatype, val->value, NULL);\n\t\tbreak;\n\tcase 4: //SVG_Number*\n\t\tgf_free(val->value);\n\t\tbreak;\n\tcase 5://SVG_Paint\n\t\tgf_free(val->value);\n\t\tbreak;\n\tcase 6://u8*\n\t\tgf_free(val->value);\n\t\tbreak;\n\tcase 7: //list of u8 *\n\tcase 8: //list of floats\n\t\t{\n\t\t\tGF_List *l = (GF_List *) val->value;\n\t\t\twhile (gf_list_count(l)) {\n\t\t\t\tvoid *v = gf_list_pop_back(l);\n\t\t\t\tgf_free(v);\n\t\t\t}\n\t\t\tgf_list_del(l);\n\t\t}\n\t\tbreak;\n\t/*point */\n\tcase 9: //SVG_Point *\n\t\tgf_free(val->value);\n\t\tbreak;\n\tcase 10: //u32 *\n\t\tgf_free(val->value);\n\t\tbreak;\n\tcase 11: //SVG_FontFamily *\n\t{\n\t\tSVG_FontFamily *ft = (SVG_FontFamily *) val->value;\n\t\tif (ft->value) gf_free(ft->value);\n\t\tgf_free(ft);\n\t}\n\t\tbreak;\n\tcase 12:\n\t{\n\t\tXMLRI *iri = (XMLRI *)val->value;\n\t\tgf_list_del_item(lsr->deferred_hrefs, iri);\n\t\tgf_node_unregister_iri(lsr->sg, iri);\n\t\tif (iri->string) gf_free(iri->string);\n\t\tgf_free(iri);\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tval->value = NULL;\n}\n\nstatic void lsr_translate_anim_value(GF_LASeRCodec *lsr, SMIL_AnimateValue *val, u32 coded_type)\n{\n\tswitch (val->type) {\n\tcase SVG_StrokeDashArray_datatype:\n\t\t//if list of fixed only\n\t\tif (coded_type == 8) {\n\t\t\tSVG_StrokeDashArray *da;\n\t\t\tGF_List *l = (GF_List *)val->value;\n\t\t\tu32 i;\n\t\t\tGF_SAFEALLOC(da, SVG_StrokeDashArray);\n\t\t\tif (!da) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tda->array.count = gf_list_count(l);\n\t\t\tif (!da->array.count) {\n\t\t\t\tda->type = SVG_STROKEDASHARRAY_INHERIT;\n\t\t\t} else {\n\t\t\t\tda->type = SVG_STROKEDASHARRAY_ARRAY;\n\t\t\t\tda->array.vals = (Fixed *) gf_malloc(sizeof(Fixed)*da->array.count);\n\t\t\t\tda->array.units = (u8 *) gf_malloc(sizeof(u8)*da->array.count);\n\t\t\t\tif (!da->array.vals || !da->array.units) {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor (i=0; i<da->array.count; i++) {\n\t\t\t\t\tFixed *v = (Fixed *)gf_list_get(l, i);\n\t\t\t\t\tda->array.vals[i] = *v;\n\t\t\t\t\tda->array.units[i] = 0;\n\t\t\t\t\tgf_free(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_del(l);\n\t\t\tval->value = da;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase SVG_ViewBox_datatype:\n\t\t//if list of fixed only\n\t\tif (coded_type == 8) {\n\t\t\tSVG_ViewBox *vb;\n\t\t\tGF_List *l = (GF_List *)val->value;\n\t\t\tGF_SAFEALLOC(vb, SVG_ViewBox);\n\t\t\tif (!vb) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (gf_list_count(l)==4) {\n\t\t\t\tvb->x = * ((Fixed *)gf_list_get(l, 0));\n\t\t\t\tvb->y = * ((Fixed *)gf_list_get(l, 1));\n\t\t\t\tvb->width = * ((Fixed *)gf_list_get(l, 2));\n\t\t\t\tvb->height = * ((Fixed *)gf_list_get(l, 3));\n\t\t\t}\n\t\t\twhile (gf_list_count(l)) {\n\t\t\t\tFixed *v = (Fixed *)gf_list_last(l);\n\t\t\t\tgf_free(v);\n\t\t\t\tgf_list_rem_last(l);\n\t\t\t}\n\t\t\tgf_list_del(l);\n\t\t\tval->value = vb;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase SVG_Coordinates_datatype:\n\t{\n\t\tSVG_Coordinates *coords;\n\t\tif (coded_type==1) {\n\t\t\tGF_List *l = gf_list_new();\n\t\t\t/*allocated value is already an SVG number*/\n\t\t\tgf_list_add(l, val->value);\n\t\t\tcoords = (SVG_Coordinates*)gf_malloc(sizeof(SVG_Coordinates));\n\t\t\tif (!coords) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\t*coords = l;\n\t\t\t\tval->value = coords;\n\t\t\t}\n\t\t\treturn;\n\t\t} else if (coded_type==8) {\n\t\t\tGF_List *l = (GF_List *)val->value;\n\t\t\tu32 i, count = gf_list_count(l);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tSVG_Coordinate *c;\n\t\t\t\tFixed *v = (Fixed *)gf_list_get(l, i);\n\t\t\t\tc = (SVG_Coordinate*)gf_malloc(sizeof(SVG_Coordinate));\n\t\t\t\tif (!c) {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t} else {\n\t\t\t\t\tc->type = SVG_NUMBER_VALUE;\n\t\t\t\t\tc->value = *v;\n\t\t\t\t}\n\t\t\t\tgf_free(v);\n\t\t\t\tgf_list_rem(l, i);\n\t\t\t\tif (c)\n\t\t\t\t\tgf_list_insert(l, c, i);\n\t\t\t}\n\t\t\tcoords = (SVG_Coordinates*)gf_malloc(sizeof(SVG_Coordinates));\n\t\t\tif (!coords) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\t*coords = (GF_List *) val->value;\n\t\t\t\tval->value = coords;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\t\tbreak;\n\tcase SVG_Motion_datatype:\n\t\tif (coded_type==9) {\n\t\t\tGF_Matrix2D *mat;\n\t\t\tSVG_Point *pt = (SVG_Point *)val->value;\n\t\t\tGF_SAFEALLOC(mat, GF_Matrix2D);\n\t\t\tif (mat) {\n\t\t\t\tgf_mx2d_init(*mat);\n\t\t\t\tmat->m[2] = pt->x;\n\t\t\t\tmat->m[5] = pt->y;\n\t\t\t\tval->value = mat;\n\t\t\t} else {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tgf_free(pt);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tlsr_delete_anim_value(lsr, val, coded_type);\n}\n\n\nstatic void lsr_translate_anim_values(GF_LASeRCodec *lsr, SMIL_AnimateValues *val, u32 coded_type)\n{\n\tu32 i, count;\n\tBool handled = GF_FALSE;\n\tGF_List *list, *new_list;\n\n\tlist = val->values;\n\tswitch (val->type) {\n\tcase SVG_StrokeDashArray_datatype:\n\t\tif (coded_type == 8) handled = GF_TRUE;\n\t\tbreak;\n\tcase SVG_ViewBox_datatype:\n\t\tif (coded_type == 8) handled = GF_TRUE;\n\t\tbreak;\n\tcase SVG_Coordinates_datatype:\n\t\tif (coded_type == 8) handled = GF_TRUE;\n\t\tbreak;\n\tcase SVG_Motion_datatype:\n\t\tif (coded_type==9) handled = GF_TRUE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!handled) {\n\t\twhile (gf_list_count(list)) {\n\t\t\tSMIL_AnimateValue a_val;\n\t\t\ta_val.type = 0;\n\t\t\ta_val.value = gf_list_pop_back(list);\n\t\t\tlsr_delete_anim_value(lsr, &a_val, coded_type);\n\t\t}\n\t\tgf_list_del(list);\n\t\tval->values = gf_list_new();\n\t\treturn;\n\t}\n\n\tval->values = new_list = gf_list_new();\n\tcount = gf_list_count(list);\n\tfor (i=0; i<count; i++) {\n\t\tswitch (val->type) {\n\t\tcase SVG_StrokeDashArray_datatype:\n\t\t{\n\t\t\tSVG_StrokeDashArray *da;\n\t\t\tGF_List *l = (GF_List *)gf_list_get(list, i);\n\t\t\tu32 j;\n\t\t\tGF_SAFEALLOC(da, SVG_StrokeDashArray);\n\t\t\tif (!da) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tda->array.count = gf_list_count(l);\n\t\t\tif (!da->array.count) {\n\t\t\t\tda->type = SVG_STROKEDASHARRAY_INHERIT;\n\t\t\t} else {\n\t\t\t\tda->type = SVG_STROKEDASHARRAY_ARRAY;\n\t\t\t\tda->array.vals = (Fixed *)gf_malloc(sizeof(Fixed)*da->array.count);\n\t\t\t\tda->array.units = (u8 *) gf_malloc(sizeof(u8)*da->array.count);\n\t\t\t\tif (!da->array.vals || !da->array.units) {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor (j=0; j<da->array.count; j++) {\n\t\t\t\t\tFixed *v = (Fixed *)gf_list_get(l, j);\n\t\t\t\t\tda->array.vals[j] = *v;\n\t\t\t\t\tda->array.units[j] = 0;\n\t\t\t\t\tgf_free(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_del(l);\n\t\t\tgf_list_add(new_list, da);\n\t\t}\n\t\tbreak;\n\t\tcase SVG_ViewBox_datatype:\n\t\t{\n\t\t\tSVG_ViewBox *vb;\n\t\t\tGF_List *l = (GF_List *)gf_list_get(list, i);\n\t\t\tGF_SAFEALLOC(vb, SVG_ViewBox);\n\t\t\tif (!vb) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (gf_list_count(l)==4) {\n\t\t\t\tvb->x = * ((Fixed *)gf_list_get(l, 0));\n\t\t\t\tvb->y = * ((Fixed *)gf_list_get(l, 1));\n\t\t\t\tvb->width = * ((Fixed *)gf_list_get(l, 2));\n\t\t\t\tvb->height = * ((Fixed *)gf_list_get(l, 3));\n\t\t\t}\n\t\t\twhile (gf_list_count(l)) {\n\t\t\t\tFixed *v=(Fixed *)gf_list_last(l);\n\t\t\t\tgf_free(v);\n\t\t\t\tgf_list_rem_last(l);\n\t\t\t}\n\t\t\tgf_list_del(l);\n\t\t\tgf_list_add(new_list, vb);\n\t\t}\n\t\tbreak;\n\t\tcase SVG_Coordinates_datatype:\n\t\t{\n\t\t\tSVG_Coordinates *coords;\n\t\t\tGF_List *l = (GF_List *)gf_list_get(list, i);\n\t\t\tu32 j, count2;\n\t\t\tcount2 = gf_list_count(l);\n\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\tFixed *v = (Fixed *)gf_list_get(l, j);\n\t\t\t\tSVG_Coordinate *c = (SVG_Coordinate *)gf_malloc(sizeof(SVG_Coordinate));\n\t\t\t\tif (!c) {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t} else {\n\t\t\t\t\tc->type = SVG_NUMBER_VALUE;\n\t\t\t\t\tc->value = *v;\n\t\t\t\t}\n\t\t\t\tgf_list_rem(l, j);\n\t\t\t\tgf_free(v);\n\t\t\t\tif (c)\n\t\t\t\t\tgf_list_insert(l, c, j);\n\t\t\t}\n\n\t\t\tcoords = (SVG_Coordinates*)gf_malloc(sizeof(SVG_Coordinates));\n\t\t\tif (!coords) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\t*coords = l;\n\t\t\t\tgf_list_add(new_list, coords);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase SVG_Motion_datatype:\n \t\t{\n\t\t\tGF_Point2D *pt = (GF_Point2D *)gf_list_get(list, i);\n\t\t\tGF_Matrix2D *m = (GF_Matrix2D *)gf_malloc(sizeof(GF_Matrix2D ));\n\t\t\tif (!m) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\tgf_mx2d_init(*m);\n\t\t\t\tm->m[2] = pt->x;\n\t\t\t\tm->m[5] = pt->y;\n\t\t\t\tgf_list_add(new_list, m);\n\t\t\t}\n\t\t\tgf_free(pt);\n\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_list_del(list);\n}\n\nstatic Bool lsr_init_smil_times(GF_LASeRCodec *lsr, SVG_Element *anim, GF_List *times, SVG_Element *parent)\n{\n\tu32 i, count;\n\tcount = gf_list_count(times);\n\tfor (i=0; i<count; i++) {\n\t\tSMIL_Time *t = (SMIL_Time *)gf_list_get(times, i);\n\t\tif (t->type==GF_SMIL_TIME_EVENT) {\n\t\t\tif (t->element_id) {\n\t\t\t\tif (t->element_id[0]=='N') {\n\t\t\t\t\tt->element = gf_sg_find_node(lsr->sg, atoi(t->element_id+1) + 1);\n\t\t\t\t} else {\n\t\t\t\t\tt->element = gf_sg_find_node_by_name(lsr->sg, t->element_id);\n\t\t\t\t}\n\t\t\t\tif (!t->element) return GF_FALSE;\n\t\t\t\tgf_free(t->element_id);\n\t\t\t\tt->element_id = NULL;\n\t\t\t}\n\t\t\telse if (!t->element) {\n\t\t\t\tif (t->event.parameter && (t->event.type==GF_EVENT_KEYDOWN) ) {\n\t\t\t\t\tt->element = lsr->sg->RootNode ? lsr->sg->RootNode : lsr->current_root;\n\t\t\t\t} else {\n\t\t\t\t\tt->element = (GF_Node*)parent;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\nstatic Bool lsr_setup_smil_anim(GF_LASeRCodec *lsr, SVG_Element *anim, SVG_Element *anim_parent)\n{\n\tGF_FieldInfo info;\n\tu32 coded_type, not_res;\n\tGF_Node *target;\n\tBool is_animateMotion, is_animateTransform;\n\tXMLRI *xlink;\n\tSMIL_AttributeName *name = NULL;\n\tSMIL_AnimateValue *value;\n\n\t/*setup smil events*/\n\tnot_res = 0;\n\tif (gf_node_get_attribute_by_tag((GF_Node *)anim, TAG_SVG_ATT_begin, GF_FALSE, GF_FALSE, &info)==GF_OK) {\n\t\tif (!lsr_init_smil_times(lsr, anim, *(GF_List**)info.far_ptr, anim_parent)) not_res++;\n\t}\n\n\tif (gf_node_get_attribute_by_tag((GF_Node *)anim, TAG_SVG_ATT_end, GF_FALSE, GF_FALSE, &info)==GF_OK) {\n\t\tif (!lsr_init_smil_times(lsr, anim, *(GF_List**)info.far_ptr, anim_parent)) not_res++;\n\t}\n\n\n\t/*get xlink*/\n\txlink = NULL;\n\tif (gf_node_get_attribute_by_tag((GF_Node *)anim, TAG_XLINK_ATT_href, GF_FALSE, GF_FALSE, &info)==GF_OK) {\n\t\txlink = info.far_ptr;\n\t}\n\n\t/*setup target node*/\n\tif (!xlink || !xlink->target) {\n\t\t/*target not received*/\n\t\tif (xlink && (xlink->type == XMLRI_ELEMENTID)) return GF_FALSE;\n\n\t\tif (!xlink) {\n\t\t\t/*target is parent, initialize xlink (needed by anim module)*/\n\t\t\tif (gf_node_get_attribute_by_tag((GF_Node *)anim, TAG_XLINK_ATT_href, GF_TRUE, GF_FALSE, &info)==GF_OK) {\n\t\t\t\txlink = info.far_ptr;\n\t\t\t} else {\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\txlink->type = XMLRI_ELEMENTID;\n\t\txlink->target = anim_parent;\n\t\tgf_node_register_iri(lsr->sg, xlink);\n\t\ttarget = (GF_Node *)anim_parent;\n\t} else {\n\t\ttarget = (GF_Node *)xlink->target;\n\t}\n\tif (!target || not_res) return GF_FALSE;\n\n\tis_animateTransform = is_animateMotion = GF_FALSE;\n\tif (anim->sgprivate->tag==TAG_SVG_animateMotion) is_animateMotion = GF_TRUE;\n\telse if (anim->sgprivate->tag==TAG_SVG_animateTransform) {\n\t\tis_animateTransform = GF_TRUE;\n\t}\n\tif (is_animateMotion) goto translate_vals;\n\n\t/*for all except animateMotion, get attributeName*/\n\tif (gf_node_get_attribute_by_tag((GF_Node *)anim, TAG_SVG_ATT_attributeName, GF_FALSE, GF_FALSE, &info)==GF_OK) {\n\t\tname = info.far_ptr;\n\t}\n\tif (!name) {\n\t\treturn GF_FALSE;\n\t}\n\n\tif (!name->field_ptr) {\n\t\tif (gf_node_get_attribute_by_tag((GF_Node *)target, name->type, GF_TRUE, GF_FALSE, &info)!=GF_OK) return GF_FALSE;\n\t\tname->field_ptr = info.far_ptr;\n\t\tname->type = info.fieldType;\n\t\tname->tag = info.fieldIndex;\n\t}\n\n\n\t/*browse all anim types and retranslate anim values. This must be done in 2 steps since we may not have received\n\tthe target node when parsing the animation node*/\ntranslate_vals:\n\n\t/*and setup anim values*/\n\tif (gf_node_get_attribute_by_tag((GF_Node *)anim, TAG_SVG_ATT_from, GF_FALSE, GF_FALSE, &info)==GF_OK) {\n\t\tif (is_animateTransform) {\n\t\t\tname->type = ((SMIL_AnimateValue*)info.far_ptr)->type;\n\t\t} else {\n\t\t\tvalue = info.far_ptr;\n\t\t\tcoded_type = value->type;\n\t\t\tvalue->type = is_animateMotion ? SVG_Motion_datatype : name->type;\n\t\t\tlsr_translate_anim_value(lsr, value, coded_type);\n\t\t}\n\t}\n\tif (gf_node_get_attribute_by_tag((GF_Node *)anim, TAG_SVG_ATT_by, GF_FALSE, GF_FALSE, &info)==GF_OK) {\n\t\tif (is_animateTransform) {\n\t\t\tname->type = ((SMIL_AnimateValue*)info.far_ptr)->type;\n\t\t} else {\n\t\t\tvalue = info.far_ptr;\n\t\t\tcoded_type = value->type;\n\t\t\tvalue->type = is_animateMotion ? SVG_Motion_datatype : name->type;\n\t\t\tlsr_translate_anim_value(lsr, value, coded_type);\n\t\t}\n\t}\n\tif (gf_node_get_attribute_by_tag((GF_Node *)anim, TAG_SVG_ATT_to, GF_FALSE, GF_FALSE, &info)==GF_OK) {\n\t\tif (is_animateTransform) {\n\t\t\tname->type = ((SMIL_AnimateValue*)info.far_ptr)->type;\n\t\t} else {\n\t\t\tvalue = info.far_ptr;\n\t\t\tcoded_type = value->type;\n\t\t\tvalue->type = is_animateMotion ? SVG_Motion_datatype : name->type;\n\t\t\tlsr_translate_anim_value(lsr, value, coded_type);\n\t\t}\n\t}\n\tif (gf_node_get_attribute_by_tag((GF_Node *)anim, TAG_SVG_ATT_values, GF_FALSE, GF_FALSE, &info)==GF_OK) {\n\t\tif (is_animateTransform) {\n\t\t\tname->type = ((SMIL_AnimateValues*)info.far_ptr)->type;\n\t\t} else {\n\t\t\tSMIL_AnimateValues *values = info.far_ptr;\n\t\t\tcoded_type = values->type;\n\t\t\tvalues->type = is_animateMotion ? SVG_Motion_datatype : name->type;\n\t\t\tvalues->laser_strings = 0;\n\t\t\tlsr_translate_anim_values(lsr, values, coded_type);\n\t\t}\n\t}\n\n\treturn GF_TRUE;\n}\n\nstatic void lsr_read_anim_fill(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 val;\n\n\tGF_LSR_READ_INT(lsr, val, 1, \"has_smil_fill\");\n\tif (val) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_smil_fill, GF_TRUE, 0, &info);\n\t\t/*enumeration freeze{0} remove{1}*/\n\t\tGF_LSR_READ_INT(lsr, val, 1, \"smil_fill\");\n\t\t*(SMIL_Fill*)info.far_ptr = val ? SMIL_FILL_REMOVE : SMIL_FILL_FREEZE;\n\t}\n}\nstatic void lsr_read_anim_repeatCount(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 val;\n\tGF_LSR_READ_INT(lsr, val, 1, \"has_repeatCount\");\n\tif (val) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_repeatCount, GF_TRUE, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, val, 1, \"repeatCount\");\n\t\tif (val) ((SMIL_RepeatCount*)info.far_ptr)->type = SMIL_REPEATCOUNT_INDEFINITE;\n\t\telse {\n\t\t\t((SMIL_RepeatCount*)info.far_ptr)->type = SMIL_REPEATCOUNT_DEFINED;\n\t\t\t((SMIL_RepeatCount*)info.far_ptr)->count = lsr_read_fixed_16_8(lsr, \"repeatCount\");\n\t\t}\n\t}\n}\nstatic void lsr_read_repeat_duration(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"has_repeatDur\");\n\tif (flag) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_repeatDur, GF_TRUE, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"choice\");\n\n\t\tif (flag) {\n\t\t\t((SMIL_Duration *)info.far_ptr)->type = SMIL_DURATION_INDEFINITE;\n\t\t} else {\n\t\t\t((SMIL_Duration *)info.far_ptr)->clock_value = (Double) lsr_read_vluimsbf5(lsr, \"value\");\n\t\t\t((SMIL_Duration *)info.far_ptr)->clock_value /= lsr->time_resolution;\n\t\t\t((SMIL_Duration *)info.far_ptr)->type = SMIL_DURATION_DEFINED;\n\t\t}\n\t}\n}\nstatic void lsr_read_anim_restart(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 val;\n\tGF_LSR_READ_INT(lsr, val, 1, \"has_restart\");\n\tif (val) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_restart, GF_TRUE, 0, &info);\n\t\t/*enumeration always{0} never{1} whenNotActive{2}*/\n\t\tGF_LSR_READ_INT(lsr, *(SMIL_Restart*)info.far_ptr, 2, \"restart\");\n\t}\n}\n\nstatic void *lsr_read_an_anim_value(GF_LASeRCodec *lsr, u32 coded_type, const char *name)\n{\n\tu32 flag;\n\tu32 escapeFlag, escape_val = 0;\n\tu8 *enum_val;\n\tu32 *id_val;\n\tchar *string;\n\tSVG_String *svg_string;\n\tSVG_Number *num;\n\tXMLRI *iri;\n\tSVG_Point *pt;\n\tSVG_Paint *paint;\n\n\tGF_LSR_READ_INT(lsr, escapeFlag, 1, \"escapeFlag\");\n\tif (escapeFlag) GF_LSR_READ_INT(lsr, escape_val, 2, \"escapeEnum\");\n\n\tswitch (coded_type) {\n\tcase 0:\n\t\tstring = NULL;\n\t\tlsr_read_byte_align_string(lsr, &string, name);\n\t\tGF_SAFEALLOC(svg_string, SVG_String);\n\t\tif (!svg_string) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\t*svg_string = string;\n\t\treturn svg_string;\n\tcase 1:\n\t\tnum = (SVG_Number*)gf_malloc(sizeof(SVG_Number));\n\t\tif (!num) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tif (escapeFlag) {\n\t\t\tnum->type = (escape_val==1) ? SVG_NUMBER_INHERIT : SVG_NUMBER_VALUE;\n\t\t} else {\n\t\t\tnum->type = SVG_NUMBER_VALUE;\n\t\t\tnum->value = lsr_read_fixed_16_8(lsr, name);\n\t\t}\n\t\treturn num;\n\tcase 2:\n\t{\n\t\tSVG_PathData *pd = (SVG_PathData *)gf_svg_create_attribute_value(SVG_PathData_datatype);\n\t\tif (!pd) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\tlsr_read_path_type(lsr, NULL, 0, pd, name);\n\t\t}\n\t\treturn pd;\n\t}\n\tcase 3:\n\t{\n\t\tSVG_Points *pts = (SVG_Points *)gf_svg_create_attribute_value(SVG_Points_datatype);\n\t\tif (!pts) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\tlsr_read_point_sequence(lsr, *pts, name);\n\t\t}\n\t\treturn pts;\n\t}\n\tcase 4:\n\t\tnum = (SVG_Number*)gf_malloc(sizeof(SVG_Number));\n\t\tif (!num) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tif (escapeFlag) {\n\t\t\tnum->type = (escape_val==1) ? SVG_NUMBER_INHERIT : SVG_NUMBER_VALUE;\n\t\t} else {\n\t\t\tnum->type = SVG_NUMBER_VALUE;\n\t\t\tnum->value = lsr_read_fixed_clamp(lsr, name);\n\t\t}\n\t\treturn num;\n\tcase 5:\n\t\tGF_SAFEALLOC(paint, SVG_Paint);\n\t\tif (!paint) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tif (escapeFlag) {\n\t\t\tpaint->type = SVG_PAINT_INHERIT;\n\t\t} else {\n\t\t\tlsr_read_paint(lsr, paint, name);\n\t\t}\n\t\treturn paint;\n\tcase 6:\n\t\tenum_val = (u8*)gf_malloc(sizeof(u8));\n\t\tif (!enum_val) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\t*enum_val = lsr_read_vluimsbf5(lsr, name);\n\t\t}\n\t\treturn enum_val;\n\t/*TODO check this is correct*/\n\tcase 7:\n\t{\n\t\tGF_List *l = gf_list_new();\n\t\tif (!l) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tu32 i, count;\n\t\tcount = lsr_read_vluimsbf5(lsr, \"count\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu8 *v = (u8 *)gf_malloc(sizeof(u8));\n\t\t\tif (!v) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\t*v = lsr_read_vluimsbf5(lsr, \"val\");\n\t\t\t\tgf_list_add(l, v);\n\t\t\t}\n\t\t\tif (lsr->last_error) break;\n\t\t}\n\t\treturn l;\n\t}\n\t/*TODO check this is correct*/\n\tcase 8: // floats\n\t{\n\t\tGF_List *l = gf_list_new();\n\t\tif (!l) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tu32 i, count;\n\t\tcount = lsr_read_vluimsbf5(lsr, \"count\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\tFixed *v = (Fixed *)gf_malloc(sizeof(Fixed));\n\t\t\tif (!v) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\t*v = lsr_read_fixed_16_8(lsr, \"val\");\n\t\t\t\tgf_list_add(l, v);\n\t\t\t}\n\t\t\tif (lsr->last_error) break;\n\t\t}\n\t\treturn l;\n\t}\n\n\t/*point */\n\tcase 9:\n\t\tpt = (SVG_Point*)gf_malloc(sizeof(SVG_Point));\n\t\tif (!pt) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, \"valX\");\n\t\tpt->x = lsr_translate_coords(lsr, flag, lsr->coord_bits);\n\t\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, \"valY\");\n\t\tpt->y = lsr_translate_coords(lsr, flag, lsr->coord_bits);\n\t\treturn pt;\n\tcase 10:\n\t\tid_val = (u32*)gf_malloc(sizeof(u32));\n\t\tif (!id_val) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\t*id_val = lsr_read_vluimsbf5(lsr, name);\n\t\t}\n\t\treturn id_val;\n\tcase 11:\n\t{\n\t\tSVG_FontFamily *ft;\n\t\tu32 idx;\n\t\tGF_SAFEALLOC(ft, SVG_FontFamily);\n\t\tif (!ft) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tif (escapeFlag) {\n\t\t\tft->type = SVG_FONTFAMILY_INHERIT;\n\t\t} else {\n\t\t\tidx = lsr_read_vluimsbf5(lsr, name);\n\t\t\tft->type = SVG_FONTFAMILY_VALUE;\n\t\t\tft->value = (char*)gf_list_get(lsr->font_table, idx);\n\t\t\tif (ft->value) ft->value = gf_strdup(ft->value);\n\t\t}\n\t\treturn ft;\n\t}\n\tcase 12:\n\t\tGF_SAFEALLOC(iri, XMLRI);\n\t\tif (!iri) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\tlsr_read_any_uri(lsr, iri, name);\n\t\t}\n\t\treturn iri;\n\tdefault:\n\t\tlsr_read_extension(lsr, name);\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic void lsr_translate_anim_trans_value(GF_LASeRCodec *lsr, SMIL_AnimateValue *val, u32 transform_type)\n{\n\tSVG_Point_Angle *p;\n\tFixed *f;\n\tu32 coded_type = val->type;\n\n\tswitch(transform_type) {\n\tcase SVG_TRANSFORM_TRANSLATE:\n\t\tval->type = SVG_Transform_Translate_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_SCALE:\n\t\tval->type = SVG_Transform_Scale_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_ROTATE:\n\t\tval->type = SVG_Transform_Rotate_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_SKEWX:\n\t\tval->type = SVG_Transform_SkewX_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_SKEWY:\n\t\tval->type = SVG_Transform_SkewY_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_MATRIX:\n\t\tval->type = SVG_Transform_datatype;\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[LSR Parsing] unknown datatype for animate transform.\\n\"));\n\t\treturn;\n\t}\n\tif (!val->value) return;\n\tswitch (transform_type) {\n\tcase SVG_TRANSFORM_ROTATE:\n\t\tif (coded_type==8) {\n\t\t\tp = (SVG_Point_Angle*)gf_malloc(sizeof(SVG_Point_Angle));\n\t\t\tif (!p) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp->x = p->y = 0;\n\t\t\tGF_List *l = (GF_List *)val->value;\n\t\t\tf = (Fixed*)gf_list_get(l, 0);\n\t\t\tif (f) p->angle = *f;\n\n\t\t\tf = (Fixed*)gf_list_get(l, 1);\n\t\t\tif (f) p->x = *f;\n\n\t\t\tf = (Fixed*)gf_list_get(l, 2);\n\t\t\tif (f) p->y = *f;\n\n\t\t\twhile (gf_list_count(l)) {\n\t\t\t\tf = gf_list_pop_back(l);\n\t\t\t\tgf_free(f);\n\t\t\t}\n\t\t\tgf_list_del(l);\n\t\t\tp->angle = gf_muldiv(p->angle, GF_PI, INT2FIX(180) );\n\t\t\tval->value = p;\n\t\t\treturn;\n\t\t} else if ((coded_type==1) || (coded_type==4)) {\n\t\t\tp = (SVG_Point_Angle*)gf_malloc(sizeof(SVG_Point_Angle));\n\t\t\tif (!p) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp->x = p->y = 0;\n\t\t\tp->angle = ((SVG_Number *)val->value)->value;\n\t\t\tgf_free(val->value);\n\t\t\tp->angle = gf_muldiv(p->angle, GF_PI, INT2FIX(180) );\n\t\t\tval->value = p;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase SVG_TRANSFORM_SCALE:\n\t\tif (coded_type==8) {\n\t\t\tSVG_Point *pt;\n\t\t\tGF_List *l = (GF_List *)val->value;\n\t\t\tGF_SAFEALLOC(pt , SVG_Point);\n\t\t\tif (!pt) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf = (Fixed*)gf_list_get(l, 0);\n\t\t\tif (f) pt->x = *f;\n\t\t\tf = (Fixed*)gf_list_get(l, 1);\n\t\t\tif (f) pt->y = *f;\n\t\t\telse pt->y = pt->x;\n\n\t\t\twhile (gf_list_count(l)) {\n\t\t\t\tf = gf_list_pop_back(l);\n\t\t\t\tgf_free(f);\n\t\t\t}\n\t\t\tgf_list_del(l);\n\t\t\tval->value = pt;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase SVG_TRANSFORM_SKEWX:\n\tcase SVG_TRANSFORM_SKEWY:\n\t\tif ((coded_type==1) || (coded_type==4)) {\n\t\t\tf = (Fixed*)gf_malloc(sizeof(Fixed));\n\t\t\tif (!f) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*f = ((SVG_Number *)val->value)->value;\n\t\t\tgf_free(val->value);\n\t\t\tval->value = f;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\t//not handled\n\tlsr_delete_anim_value(lsr, val, coded_type);\n}\n\nstatic void lsr_translate_anim_trans_values(GF_LASeRCodec *lsr, SMIL_AnimateValues *val, u32 transform_type)\n{\n\tu32 count, i, coded_type;\n\tSVG_Point_Angle *p;\n\tSVG_Point *pt;\n\tFixed *f;\n\tGF_List *l;\n\tBool handled = GF_FALSE;\n\n\tcoded_type = val->type;\n\tswitch(transform_type) {\n\tcase SVG_TRANSFORM_TRANSLATE:\n\t\tval->type = SVG_Transform_Translate_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_SCALE:\n\t\tif (coded_type==8) handled = GF_TRUE;\n\t\tval->type = SVG_Transform_Scale_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_ROTATE:\n\t\tif ((coded_type==8) || (coded_type==1)) handled = GF_TRUE;\n\t\tval->type = SVG_Transform_Rotate_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_SKEWX:\n\t\tif ((coded_type==1) || (coded_type==4)) handled = GF_TRUE;\n\t\tval->type = SVG_Transform_SkewX_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_SKEWY:\n\t\tif ((coded_type==1) || (coded_type==4)) handled = GF_TRUE;\n\t\tval->type = SVG_Transform_SkewY_datatype;\n\t\tbreak;\n\tcase SVG_TRANSFORM_MATRIX:\n\t\tval->type = SVG_Transform_datatype;\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[SVG Parsing] unknown datatype for animate transform.\\n\"));\n\t\tbreak;\n\t}\n\n\tif (!handled) {\n\t\twhile (gf_list_count(val->values)) {\n\t\t\tSMIL_AnimateValue a_val;\n\t\t\ta_val.type = 0;\n\t\t\ta_val.value = gf_list_pop_back(val->values);\n\t\t\tlsr_delete_anim_value(lsr, &a_val, coded_type);\n\t\t}\n\t\treturn;\n\t}\n\n\tcount = gf_list_count(val->values);\n\tif (!count) return;\n\n\tif (transform_type==SVG_TRANSFORM_TRANSLATE)\n\t\treturn;\n\n\tfor (i=0; i<count; i++) {\n\t\tvoid *a_val = gf_list_get(val->values, i);\n\t\tswitch (transform_type) {\n\t\tcase SVG_TRANSFORM_ROTATE:\n\t\t\tGF_SAFEALLOC(p, SVG_Point_Angle);\n\t\t\tif (!p) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (coded_type==8) {\n\t\t\t\tl = (GF_List*)a_val;\n\t\t\t\tf = (Fixed*)gf_list_get(l, 0);\n\t\t\t\tif (f) p->angle = *f;\n\t\t\t\tf = (Fixed*)gf_list_get(l, 1);\n\t\t\t\tif (f) p->x = *f;\n\t\t\t\tf = (Fixed*)gf_list_get(l, 2);\n\t\t\t\tif (f) p->y = *f;\n\t\t\t\twhile (gf_list_count(l)) {\n\t\t\t\t\tf = (Fixed*)gf_list_last(l);\n\t\t\t\t\tgf_list_rem_last(l);\n\t\t\t\t\tgf_free(f);\n\t\t\t\t}\n\t\t\t\tgf_list_del(l);\n\t\t\t} else if (coded_type==1) {\n\t\t\t\tp->angle = ((SVG_Number *)a_val)->value;\n\t\t\t\tgf_free(a_val);\n\t\t\t}\n\t\t\tp->angle = gf_muldiv(p->angle, GF_PI, INT2FIX(180) );\n\t\t\tgf_list_rem(val->values, i);\n\t\t\tgf_list_insert(val->values, p, i);\n\t\t\tbreak;\n\t\tcase SVG_TRANSFORM_SKEWX:\n\t\tcase SVG_TRANSFORM_SKEWY:\n\t\t\tf = (Fixed*)gf_malloc(sizeof(Fixed));\n\t\t\tif (!f) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\t*f = ((SVG_Number *)a_val)->value;\n\t\t\t}\n\t\t\tgf_free(a_val);\n\t\t\tgf_list_rem(val->values, i);\n\t\t\tif (f)\n\t\t\t\tgf_list_insert(val->values, f, i);\n\t\t\tbreak;\n\t\tcase SVG_TRANSFORM_SCALE:\n\t\t\tGF_SAFEALLOC(pt, SVG_Point);\n\t\t\tif (!pt)\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\n\t\t\tl = (GF_List*)a_val;\n\t\t\tif (pt) {\n\t\t\t\tf = (Fixed*)gf_list_get(l, 0);\n\t\t\t\tif (f) pt->x = *f;\n\t\t\t\tf = (Fixed*)gf_list_get(l, 1);\n\t\t\t\tif (f) pt->y = *f;\n\t\t\t\telse pt->y = pt->x;\n\t\t\t}\n\n\t\t\twhile (gf_list_count(l)) {\n\t\t\t\tf = (Fixed*)gf_list_last(l);\n\t\t\t\tgf_list_rem_last(l);\n\t\t\t\tgf_free(f);\n\t\t\t}\n\t\t\tgf_list_del(l);\n\t\t\tgf_list_rem(val->values, i);\n\t\t\tif (pt)\n\t\t\t\tgf_list_insert(val->values, pt, i);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[LASeR] unknown transform type %d\\n\", transform_type));\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void lsr_read_anim_value_ex(GF_LASeRCodec *lsr, GF_Node *n, u32 tag, const char *name, u32 *tr_type)\n{\n\tu32 val, coded_type;\n\tGF_LSR_READ_INT(lsr, val, 1, name);\n\tif (val) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, tag, GF_TRUE, 0, &info);\n\n\t\tGF_LSR_READ_INT(lsr, coded_type, 4, \"type\");\n\t\t((SMIL_AnimateValue*)info.far_ptr)->value = lsr_read_an_anim_value(lsr, coded_type, name);\n\t\t((SMIL_AnimateValue*)info.far_ptr)->type = coded_type;\n\n\t\tif (tr_type) {\n\t\t\tlsr_translate_anim_trans_value(lsr, info.far_ptr, *tr_type);\n\t\t}\n\t}\n}\n\nstatic void lsr_read_anim_values_ex(GF_LASeRCodec *lsr, GF_Node *n, u32 *tr_type)\n{\n\tu32 flag, i, count = 0;\n\tu32 coded_type;\n\tGF_FieldInfo info;\n\tSMIL_AnimateValues *values;\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"values\");\n\tif (!flag) return;\n\n\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_values, GF_TRUE, 0, &info);\n\tvalues = (SMIL_AnimateValues *)info.far_ptr;\n\n\tGF_LSR_READ_INT(lsr, coded_type, 4, \"type\");\n\tvalues->type = coded_type;\n\tvalues->laser_strings = 0;\n\n\tcount = lsr_read_vluimsbf5(lsr, \"count\");\n\tfor (i=0; i<count; i++) {\n\t\tvoid *att = lsr_read_an_anim_value(lsr, coded_type, \"a_value\");\n\t\tif (att) gf_list_add(values->values, att);\n\t\tif (lsr->last_error) return;\n\t}\n\tif (tr_type) {\n\t\tlsr_translate_anim_trans_values(lsr, info.far_ptr, *tr_type);\n\t}\n}\n#define lsr_read_anim_value(_a, _b, _c, _d) lsr_read_anim_value_ex(_a, _b, _c, _d, NULL)\n#define lsr_read_anim_values(_a, _b) lsr_read_anim_values_ex(_a, _b, NULL)\n\nstatic Fixed *lsr_read_fraction_12_item(GF_LASeRCodec *lsr)\n{\n\tu32 flag;\n\tFixed *f;\n\tGF_SAFEALLOC(f, Fixed);\n\tif (!f) {\n\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\treturn NULL;\n\t}\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasShort\");\n\tif (flag) {\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"isZero\");\n\t\tif (flag) *f = 0;\n\t\telse *f = FIX_ONE;\n\t} else {\n\t\tu32 v;\n\t\tGF_LSR_READ_INT(lsr, v, 12, \"val\");\n\t\t*f = INT2FIX(v) / 4096/*(1<<12)*/;\n\t}\n\treturn f;\n}\n\nstatic void lsr_read_fraction_12(GF_LASeRCodec *lsr, GF_Node *elt, u32 tag, const char *name)\n{\n\tGF_FieldInfo info;\n\tu32 i, count;\n\tGF_LSR_READ_INT(lsr, count, 1, name);\n\tif (!count) return;\n\n\tlsr->last_error = gf_node_get_attribute_by_tag(elt, tag, GF_TRUE, 0, &info);\n\n\tcount = lsr_read_vluimsbf5(lsr, \"name\");\n\tfor (i=0; i<count; i++) {\n\t\tFixed *f = lsr_read_fraction_12_item(lsr);\n\t\tgf_list_add( *((SMIL_KeyTimes*)info.far_ptr), f);\n\t\tif (lsr->last_error) return;\n\t}\n}\nstatic void lsr_read_float_list(GF_LASeRCodec *lsr, GF_Node *n, u32 tag, SVG_Coordinates*coords, const char *name)\n{\n\tu32 i, count;\n\tGF_LSR_READ_INT(lsr, count, 1, name);\n\tif (!count) return;\n\n\tif (!coords) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, tag, GF_TRUE, 0, &info);\n\t\tcoords = (SVG_Coordinates*)info.far_ptr;\n\t} else {\n\t\twhile (gf_list_count(*coords)) {\n\t\t\tFixed *v = (Fixed *)gf_list_last(*coords);\n\t\t\tgf_list_rem_last(*coords);\n\t\t\tgf_free(v);\n\t\t}\n\t}\n\tcount = lsr_read_vluimsbf5(lsr, \"count\");\n\tif (tag == TAG_SVG_ATT_text_rotate) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tSVG_Number *num = (SVG_Number *)gf_malloc(sizeof(SVG_Number));\n\t\t\tif (!num) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\tnum->type = SVG_NUMBER_VALUE;\n\t\t\t\tnum->value = lsr_read_fixed_16_8(lsr, \"val\");\n\t\t\t\tgf_list_add(*coords, num);\n\t\t\t}\n\t\t\tif (lsr->last_error) return;\n\t\t}\n\t}\n\telse {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tFixed *num = (Fixed *)gf_malloc(sizeof(Fixed));\n\t\t\tif (!num) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\t*num = lsr_read_fixed_16_8(lsr, \"val\");\n\t\t\t}\n\t\t\tgf_list_add(*coords, num);\n\t\t\tif (lsr->last_error) return;\n\t\t}\n\t}\n}\n\nstatic void lsr_read_point_sequence(GF_LASeRCodec *lsr, GF_List *pts, const char *name)\n{\n\tu32 flag, i, count;\n\n\twhile (gf_list_count(pts)) {\n\t\tSVG_Point *v = (SVG_Point *)gf_list_last(pts);\n\t\tgf_list_rem_last(pts);\n\t\tgf_free(v);\n\t}\n\tcount = lsr_read_vluimsbf5(lsr, \"nbPoints\");\n\tif (!count) return;\n\t/*TODO golomb coding*/\n\tGF_LSR_READ_INT(lsr, flag, 1, \"flag\");\n\tif (!flag) {\n\t\tif (count < 3) {\n\t\t\tu32 nb_bits, v;\n\t\t\tGF_LSR_READ_INT(lsr, nb_bits, 5, \"bits\");\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tSVG_Point *pt = (SVG_Point *)gf_malloc(sizeof(SVG_Point));\n\t\t\t\tif (!pt) {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t} else {\n\t\t\t\t\tgf_list_add(pts, pt);\n\t\t\t\t\tGF_LSR_READ_INT(lsr, v, nb_bits, \"x\");\n\t\t\t\t\tpt->x = lsr_translate_coords(lsr, v, nb_bits);\n\t\t\t\t\tGF_LSR_READ_INT(lsr, v, nb_bits, \"y\");\n\t\t\t\t\tpt->y = lsr_translate_coords(lsr, v, nb_bits);\n\t\t\t\t}\n\t\t\t\tif (lsr->last_error) return;\n\t\t\t}\n\t\t} else {\n\t\t\tu32 nb_dx, nb_dy, k;\n\t\t\tFixed x, y;\n\t\t\tSVG_Point *pt = (SVG_Point *)gf_malloc(sizeof(SVG_Point));\n\t\t\tif (!pt) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgf_list_add(pts, pt);\n\n\t\t\tGF_LSR_READ_INT(lsr, nb_dx, 5, \"bits\");\n\t\t\tGF_LSR_READ_INT(lsr, k, nb_dx, \"x\");\n\t\t\tx = pt->x = lsr_translate_coords(lsr, k, nb_dx);\n\t\t\tGF_LSR_READ_INT(lsr, k, nb_dx, \"y\");\n\t\t\ty = pt->y = lsr_translate_coords(lsr, k, nb_dx);\n\n\t\t\tGF_LSR_READ_INT(lsr, nb_dx, 5, \"bitsx\");\n\t\t\tGF_LSR_READ_INT(lsr, nb_dy, 5, \"bitsy\");\n\t\t\tfor (i=1; i<count; i++) {\n\t\t\t\tpt = (SVG_Point *)gf_malloc(sizeof(SVG_Point));\n\t\t\t\tif (!pt) {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t} else {\n\t\t\t\t\tgf_list_add(pts, pt);\n\t\t\t\t\tGF_LSR_READ_INT(lsr, k, nb_dx, \"dx\");\n\t\t\t\t\tpt->x = x + lsr_translate_coords(lsr, k, nb_dx);\n\t\t\t\t\tx = pt->x;\n\t\t\t\t\tGF_LSR_READ_INT(lsr, k, nb_dy, \"dy\");\n\t\t\t\t\tpt->y = y + lsr_translate_coords(lsr, k, nb_dy);\n\t\t\t\t\ty = pt->y;\n\t\t\t\t}\n\t\t\t\tif (lsr->last_error) return;\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void lsr_read_path_type(GF_LASeRCodec *lsr, GF_Node *n, u32 tag, SVG_PathData *path, const char *name)\n{\n#if USE_GF_PATH\n\tGF_Point2D *pt, *ct1, *ct2, *end;\n\tGF_Point2D orig, ct_orig;\n\tu32 i, count, cur_pt, type;\n\tGF_List *pts = gf_list_new();\n\tlsr_read_point_sequence(lsr, pts, \"seq\");\n\n\tif (!path) {\n\t\tGF_FieldInfo info;\n\t\tgf_node_get_attribute_by_tag(n, tag, GF_TRUE, 0, &info);\n\t\tpath = (SVG_PathData*)info.far_ptr;\n\t} else {\n\t\tgf_path_reset(path);\n\t}\n\t/*first MoveTo is skipped in LASeR*/\n\tpt = (GF_Point2D*)gf_list_get(pts, 0);\n\tif (pt) {\n\t\tct_orig = orig = *pt;\n\t\tgf_path_add_move_to_vec(path, pt);\n\t} else {\n\t\torig.x = orig.y = 0;\n\t\tct_orig = orig;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[LASeR] Empty path found.\\n\"));\n\t}\n\tcur_pt = 1;\n\tcount = lsr_read_vluimsbf5(lsr, \"nbOfTypes\");\n\tfor (i=0; i<count; i++) {\n\t\tGF_LSR_READ_INT(lsr, type, 5, name);\n\t\tswitch (type) {\n\t\tcase LSR_PATH_COM_h:\n\t\tcase LSR_PATH_COM_l:\n\t\tcase LSR_PATH_COM_v:\n\t\tcase LSR_PATH_COM_H:\n\t\tcase LSR_PATH_COM_V:\n\t\tcase LSR_PATH_COM_L:\n\t\t\tpt = (GF_Point2D*)gf_list_get(pts, cur_pt);\n\t\t\tif (!pt) goto err_exit;\n\t\t\tgf_path_add_line_to_vec(path, pt);\n\t\t\tcur_pt++;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_m:\n\t\tcase LSR_PATH_COM_M:\n\t\t\tpt = (GF_Point2D*)gf_list_get(pts, cur_pt);\n\t\t\tif (!pt) goto err_exit;\n\t\t\tgf_path_add_move_to_vec(path, pt);\n\t\t\tcur_pt++;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_q:\n\t\tcase LSR_PATH_COM_Q:\n\t\t\tct1 = (GF_Point2D*)gf_list_get(pts, cur_pt);\n\t\t\tend = (GF_Point2D*)gf_list_get(pts, cur_pt+1);\n\t\t\tif (!ct1 || !end) goto err_exit;\n\t\t\tgf_path_add_quadratic_to_vec(path, ct1, end);\n\t\t\torig = *end;\n\t\t\tcur_pt+=2;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_c:\n\t\tcase LSR_PATH_COM_C:\n\t\t\tct1 = (GF_Point2D*)gf_list_get(pts, cur_pt);\n\t\t\tct2 = (GF_Point2D*)gf_list_get(pts, cur_pt+1);\n\t\t\tend = (GF_Point2D*)gf_list_get(pts, cur_pt+2);\n\t\t\tif (!ct1 || !ct2 || !end) goto err_exit;\n\t\t\tgf_path_add_cubic_to_vec(path, ct1, ct2, end);\n\t\t\tcur_pt+=3;\n\t\t\tct_orig = *ct2;\n\t\t\torig = *end;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_s:\n\t\tcase LSR_PATH_COM_S:\n\t\t\tct_orig.x = 2*orig.x - ct_orig.x;\n\t\t\tct_orig.y = 2*orig.y - ct_orig.y;\n\t\t\tct2 = (GF_Point2D*)gf_list_get(pts, cur_pt);\n\t\t\tend = (GF_Point2D*)gf_list_get(pts, cur_pt+1);\n\t\t\tif (!ct2 || !end) goto err_exit;\n\t\t\tgf_path_add_cubic_to_vec(path, &ct_orig, ct2, end);\n\t\t\tct_orig = *ct2;\n\t\t\torig = *end;\n\t\t\tcur_pt+=2;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_t:\n\t\tcase LSR_PATH_COM_T:\n\t\t\tct_orig.x = 2*orig.x - ct_orig.x;\n\t\t\tct_orig.y = 2*orig.y - ct_orig.y;\n\t\t\tend = gf_list_get(pts, cur_pt);\n\t\t\tif (!end) goto err_exit;\n\t\t\tgf_path_add_quadratic_to_vec(path, &ct_orig, end);\n\t\t\torig = *end;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_z:\n\t\tcase LSR_PATH_COM_Z:\n\t\t\tgf_path_close(path);\n\t\t\tbreak;\n\t\t}\n\t\tif (lsr->last_error) break;\n\t}\n\tgoto exit;\n\nerr_exit:\n\tlsr->last_error = GF_NON_COMPLIANT_BITSTREAM;\n\nexit:\n\twhile (gf_list_count(pts)) {\n\t\tend = (GF_Point2D*)gf_list_get(pts, 0);\n\t\tgf_list_rem(pts, 0);\n\t\tgf_free(end);\n\t}\n\tgf_list_del(pts);\n\n#else\n\tu32 i, count, c;\n\tif (!path) {\n\t\tlsr->last_error = GF_BAD_PARAM;\n\t\treturn;\n\t}\n\tlsr_read_point_sequence(lsr, path->points, \"seq\");\n\twhile (gf_list_count(path->commands)) {\n\t\tu8 *v = (u8 *)gf_list_last(path->commands);\n\t\tgf_list_rem_last(path->commands);\n\t\tgf_free(v);\n\t}\n\n\tcount = lsr_read_vluimsbf5(lsr, \"nbOfTypes\");\n\tfor (i=0; i<count; i++) {\n\t\tu8 *type = (u8 *)gf_malloc(sizeof(u8));\n\t\tif (!type) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn;\n\t\t}\n\t\tGF_LSR_READ_INT(lsr, c, 5, name);\n\n\t\tswitch (c) {\n\t\tcase LSR_PATH_COM_h:\n\t\tcase LSR_PATH_COM_l:\n\t\tcase LSR_PATH_COM_v:\n\t\tcase LSR_PATH_COM_H:\n\t\tcase LSR_PATH_COM_V:\n\t\tcase LSR_PATH_COM_L:\n\t\t\t*type=SVG_PATHCOMMAND_L;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_m:\n\t\tcase LSR_PATH_COM_M:\n\t\t\t*type=SVG_PATHCOMMAND_M;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_q:\n\t\tcase LSR_PATH_COM_Q:\n\t\t\t*type=SVG_PATHCOMMAND_Q;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_c:\n\t\tcase LSR_PATH_COM_C:\n\t\t\t*type=SVG_PATHCOMMAND_C;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_s:\n\t\tcase LSR_PATH_COM_S:\n\t\t\t*type=SVG_PATHCOMMAND_S;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_t:\n\t\tcase LSR_PATH_COM_T:\n\t\t\t*type=SVG_PATHCOMMAND_T;\n\t\t\tbreak;\n\t\tcase LSR_PATH_COM_z:\n\t\tcase LSR_PATH_COM_Z:\n\t\t\t*type=SVG_PATHCOMMAND_Z;\n\t\t\tbreak;\n\t\t}\n\t\tgf_list_add(path->commands, type);\n\t}\n#endif\n}\n\nstatic void lsr_read_rotate_type(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"rotate\");\n\tif (flag) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_rotate, GF_TRUE, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"choice\");\n\n\t\tif (flag) {\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"rotate\");\n\t\t\t((SVG_Number *)info.far_ptr)->type = flag ? SVG_NUMBER_AUTO_REVERSE : SVG_NUMBER_AUTO;\n\t\t} else {\n\t\t\t((SVG_Number *)info.far_ptr)->value = lsr_read_fixed_16_8(lsr, \"rotate\");\n\t\t\t((SVG_Number *)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t}\n\t}\n}\nstatic void lsr_read_sync_behavior(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"syncBehavior\");\n\tif (flag) {\n\t\tGF_FieldInfo info;\n\t\tGF_LSR_READ_INT(lsr, flag, 2, \"syncBehavior\");\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_syncBehavior, GF_TRUE, 0, &info);\n\t\t*(SMIL_SyncBehavior*)info.far_ptr = flag + 1;\n\t}\n}\nstatic void lsr_read_sync_tolerance(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"syncTolerance\");\n\tif (flag) {\n\t\tGF_FieldInfo info;\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"syncTolerance\");\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_syncTolerance, GF_TRUE, 0, &info);\n\t\tif (flag) ((SMIL_SyncTolerance *)info.far_ptr)->type = SMIL_SYNCTOLERANCE_DEFAULT;\n\t\telse {\n\t\t\tu32 v = lsr_read_vluimsbf5(lsr, \"value\");\n\t\t\t((SMIL_SyncTolerance *)info.far_ptr)->value = INT2FIX(v);\n\t\t\t((SMIL_SyncTolerance *)info.far_ptr)->value /= lsr->time_resolution;\n\t\t}\n\t}\n}\nstatic void lsr_read_sync_reference(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasSyncReference\");\n\tif (flag) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_syncReference, GF_TRUE, 0, &info);\n\t\tlsr_read_any_uri(lsr, info.far_ptr, \"syncReference\");\n\t}\n}\n\nstatic void lsr_read_coordinate(GF_LASeRCodec *lsr, SVG_Number *coord, Bool skipable, const char *name)\n{\n\tu32 flag;\n\tif (skipable) {\n\t\tGF_LSR_READ_INT(lsr, flag, 1, name);\n\t\tif (!flag) {\n\t\t\t//coord->type = SVG_NUMBER_UNKNOWN;\n\t\t\t//coord->value = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\tcoord->type = SVG_NUMBER_VALUE;\n\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, name);\n\tcoord->value = lsr_translate_coords(lsr, flag, lsr->coord_bits);\n}\nstatic void lsr_read_coordinate_ptr(GF_LASeRCodec *lsr, GF_Node *n, u32 tag, Bool skipable, const char *name)\n{\n\tu32 flag;\n\tGF_FieldInfo info;\n\tif (skipable) {\n\t\tGF_LSR_READ_INT(lsr, flag, 1, name);\n\t\tif (!flag) return;\n\t}\n\tlsr->last_error = gf_node_get_attribute_by_tag(n, tag, GF_TRUE, 0, &info);\n\n\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\tGF_LSR_READ_INT(lsr, flag, lsr->coord_bits, name);\n\t((SVG_Number*)info.far_ptr)->value = lsr_translate_coords(lsr, flag, lsr->coord_bits);\n}\n\nstatic void lsr_read_coord_list(GF_LASeRCodec *lsr, GF_Node *elt, u32 tag, const char *name)\n{\n\tGF_FieldInfo info;\n\tu32 i, count;\n\tGF_LSR_READ_INT(lsr, count, 1, name);\n\tif (!count) return;\n\tcount = lsr_read_vluimsbf5(lsr, \"nb_coords\");\n\tif (!count) return;\n\n\tlsr->last_error = gf_node_get_attribute_by_tag(elt, tag, GF_TRUE, 0, &info);\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 res;\n\t\tSVG_Coordinate *f;\n\t\tGF_SAFEALLOC(f, SVG_Coordinate );\n\t\tif (!f) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn;\n\t\t}\n\t\tGF_LSR_READ_INT(lsr, res, lsr->coord_bits, name);\n\t\tf->value = lsr_translate_coords(lsr, res, lsr->coord_bits);\n\t\tgf_list_add(*(SVG_Coordinates*)info.far_ptr, f);\n\t\tif (lsr->last_error) return;\n\t}\n}\n\nstatic void lsr_read_transform_behavior(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tGF_FieldInfo info;\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasTransformBehavior\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_transformBehavior, GF_TRUE, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, *(SVG_TransformBehavior*)info.far_ptr, 4, \"transformBehavior\");\n\t}\n}\n\nstatic void lsr_read_content_type(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasType\");\n\tif (flag) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_type, GF_TRUE, 0, &info);\n\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"type\");\n\t}\n}\nstatic void lsr_read_script_type(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasType\");\n\tif (flag) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_XLINK_ATT_type, GF_TRUE, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"choice\");\n\t\tif (flag) {\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"script\");\n\t\t\tswitch (flag) {\n\t\t\tcase 0:\n\t\t\t\t*(SVG_String*)info.far_ptr = gf_strdup(\"application/ecmascript\");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t*(SVG_String*)info.far_ptr = gf_strdup(\"application/jar-archive\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"type\");\n\t\t}\n\t}\n}\nstatic void lsr_read_value_with_units(GF_LASeRCodec *lsr, SVG_Number *n, const char *name)\n{\n\ts32 val;\n\tGF_LSR_READ_INT(lsr, val, 32, name);\n#ifdef GPAC_FIXED_POINT\n\tn->value = val << 8;\n#else\n\tn->value = INT2FIX(val) / (1<<8);\n#endif\n\tGF_LSR_READ_INT(lsr, val, 3, \"units\");\n\tswitch (val) {\n\tcase 1:\n\t\tn->type = SVG_NUMBER_IN;\n\t\tbreak;\n\tcase 2:\n\t\tn->type = SVG_NUMBER_CM;\n\t\tbreak;\n\tcase 3:\n\t\tn->type = SVG_NUMBER_MM;\n\t\tbreak;\n\tcase 4:\n\t\tn->type = SVG_NUMBER_PT;\n\t\tbreak;\n\tcase 5:\n\t\tn->type = SVG_NUMBER_PC;\n\t\tbreak;\n\tcase 6:\n\t\tn->type = SVG_NUMBER_PERCENTAGE;\n\t\tbreak;\n\tdefault:\n\t\tn->type = SVG_NUMBER_VALUE;\n\t\tbreak;\n\t}\n}\n\n\nstatic void lsr_read_clip_time(GF_LASeRCodec *lsr, GF_Node *elt, u32 tag, const char *name)\n{\n\tGF_FieldInfo info;\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, name);\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, tag, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"isEnum\");\n\t\tif (!flag) {\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"sign\");\n\t\t\tflag = lsr_read_vluimsbf5(lsr, \"val\");\n\t\t\t*((SVG_Clock *)info.far_ptr) = flag;\n\t\t\t*((SVG_Clock *)info.far_ptr) /= lsr->time_resolution;\n\t\t}\n\t}\n}\n\nstatic void lsr_read_attribute_type(GF_LASeRCodec *lsr, GF_Node *elt)\n{\n\tGF_FieldInfo info;\n\tu32 flag;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasAttributeType\");\n\tif (!flag) return;\n\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_attributeType, 1, 0, &info);\n\tGF_LSR_READ_INT(lsr, *(SMIL_AttributeType*)info.far_ptr, 2, \"attributeType\");\n}\n\nstatic void lsr_read_preserve_aspect_ratio(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tGF_FieldInfo info;\n\tu32 flag;\n\tSVG_PreserveAspectRatio *par;\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasPreserveAspectRatio\");\n\tif (!flag) return;\n\n\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_preserveAspectRatio, 1, 0, &info);\n\tpar = (SVG_PreserveAspectRatio *)info.far_ptr;\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"choice (meetOrSlice)\");\n\tGF_LSR_READ_INT(lsr, par->defer, 1, \"choice (defer)\");\n\tGF_LSR_READ_INT(lsr, flag, 4, \"alignXandY\");\n\tswitch (flag) {\n\tcase 1:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMAX;\n\t\tbreak;\n\tcase 2:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMID;\n\t\tbreak;\n\tcase 3:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMIN;\n\t\tbreak;\n\tcase 4:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMAX;\n\t\tbreak;\n\tcase 5:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMID;\n\t\tbreak;\n\tcase 6:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMIN;\n\t\tbreak;\n\tcase 7:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMAX;\n\t\tbreak;\n\tcase 8:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMID;\n\t\tbreak;\n\tcase 9:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMIN;\n\t\tbreak;\n\tdefault:\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_NONE;\n\t\tbreak;\n\t}\n}\n\nstatic void lsr_read_eRR(GF_LASeRCodec *lsr, GF_Node *elt)\n{\n\tu32 err;\n\tGF_LSR_READ_INT(lsr, err, 1, \"externalResourcesRequired\");\n\tif (err) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_externalResourcesRequired, 1, 0, &info);\n\t\t*(SVG_Boolean*)info.far_ptr = 1;\n\t}\n}\n\nstatic void lsr_read_lsr_enabled(GF_LASeRCodec *lsr, GF_Node *elt)\n{\n\tu32 err;\n\tGF_LSR_READ_INT(lsr, err, 1, \"enabled\");\n\tif (err) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_LSR_ATT_enabled, 1, 0, &info);\n\t\t*(SVG_Boolean*)info.far_ptr = 1;\n\t}\n}\n\nstatic GF_Node *lsr_read_a(GF_LASeRCodec *lsr)\n{\n\tBool flag;\n\tGF_Node *elt = (GF_Node*) gf_node_new(lsr->sg, TAG_SVG_a);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_eRR(lsr, elt);\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasTarget\");\n\tif (flag) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_target, 1, 0, &info);\n\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"target\");\n\t}\n\tlsr_read_href(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\n\n\nstatic GF_Node *lsr_read_animate(GF_LASeRCodec *lsr, SVG_Element *parent, Bool is_animateColor)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, is_animateColor ? TAG_SVG_animateColor : TAG_SVG_animate);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_attribute_name(lsr, elt);\n\n\tlsr_read_accumulate(lsr, elt);\n\tlsr_read_additive(lsr, elt);\n\tlsr_read_anim_value(lsr, elt, TAG_SVG_ATT_by, \"by\");\n\tlsr_read_calc_mode(lsr, elt);\n\tlsr_read_anim_value(lsr, elt, TAG_SVG_ATT_from, \"from\");\n\tlsr_read_fraction_12(lsr, elt, TAG_SVG_ATT_keySplines, \"keySplines\");\n\tlsr_read_fraction_12(lsr, elt, TAG_SVG_ATT_keyTimes, \"keyTimes\");\n\tlsr_read_anim_values(lsr, elt);\n\tlsr_read_attribute_type(lsr, elt);\n\tlsr_read_smil_times(lsr, elt, TAG_SVG_ATT_begin, NULL, \"begin\", 1);\n\tlsr_read_duration(lsr, elt);\n\tlsr_read_anim_fill(lsr, elt);\n\tlsr_read_anim_repeatCount(lsr, elt);\n\tlsr_read_repeat_duration(lsr, elt);\n\tlsr_read_anim_restart(lsr, elt);\n\tlsr_read_anim_value(lsr, elt, TAG_SVG_ATT_to, \"to\");\n\tlsr_read_href(lsr, elt);\n\tlsr_read_lsr_enabled(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\n\tif (!lsr_setup_smil_anim(lsr, (SVG_Element*)elt, parent)) {\n\t\tgf_list_add(lsr->deferred_anims, elt);\n\t\tlsr_read_group_content_post_init(lsr, (SVG_Element*)elt, 1);\n\t} else {\n\t\tlsr_read_group_content(lsr, elt, 0);\n\t}\n\treturn elt;\n}\n\n\nstatic GF_Node *lsr_read_animateMotion(GF_LASeRCodec *lsr, SVG_Element *parent)\n{\n\tBool flag;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_animateMotion);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_accumulate(lsr, elt);\n\tlsr_read_additive(lsr, elt);\n\tlsr_read_anim_value(lsr, elt, TAG_SVG_ATT_by, \"by\");\n\tlsr_read_calc_mode(lsr, elt);\n\tlsr_read_anim_value(lsr, elt, TAG_SVG_ATT_from, \"from\");\n\tlsr_read_fraction_12(lsr, elt, TAG_SVG_ATT_keySplines, \"keySplines\");\n\tlsr_read_fraction_12(lsr, elt, TAG_SVG_ATT_keyTimes, \"keyTimes\");\n\tlsr_read_anim_values(lsr, elt);\n\tlsr_read_attribute_type(lsr, elt);\n\tlsr_read_smil_times(lsr, elt, TAG_SVG_ATT_begin, NULL, \"begin\", 1);\n\tlsr_read_duration(lsr, elt);\n\tlsr_read_anim_fill(lsr, elt);\n\tlsr_read_anim_repeatCount(lsr, elt);\n\tlsr_read_repeat_duration(lsr, elt);\n\tlsr_read_anim_restart(lsr, elt);\n\tlsr_read_anim_value(lsr, elt, TAG_SVG_ATT_to, \"to\");\n\tlsr_read_float_list(lsr, elt, TAG_SVG_ATT_keyPoints, NULL, \"keyPoints\");\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasPath\");\n\tif (flag) lsr_read_path_type(lsr, elt, TAG_SVG_ATT_path, NULL, \"path\");\n\n\tlsr_read_rotate_type(lsr, elt);\n\tlsr_read_href(lsr, elt);\n\tlsr_read_lsr_enabled(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\n\tif (!lsr_setup_smil_anim(lsr, (SVG_Element*)elt, parent)) {\n\t\tgf_list_add(lsr->deferred_anims, elt);\n\t\tlsr_read_group_content_post_init(lsr, (SVG_Element*)elt, 1);\n\t} else {\n\t\tlsr_read_group_content_post_init(lsr, (SVG_Element*)elt, 0);\n\t}\n\treturn elt;\n}\n\n\nstatic GF_Node *lsr_read_animateTransform(GF_LASeRCodec *lsr, SVG_Element *parent)\n{\n\tu32 type;\n\tu32 flag;\n\tGF_FieldInfo info;\n\tGF_Node *elt= gf_node_new(lsr->sg, TAG_SVG_animateTransform);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_attribute_name(lsr, elt);\n\n\t/*enumeration rotate{0} scale{1} skewX{2} skewY{3} translate{4}*/\n\tGF_LSR_READ_INT(lsr, flag, 3, \"rotscatra\");\n\tswitch (flag) {\n\tcase 0:\n\t\ttype = SVG_TRANSFORM_ROTATE;\n\t\tbreak;\n\tcase 1:\n\t\ttype = SVG_TRANSFORM_SCALE;\n\t\tbreak;\n\tcase 2:\n\t\ttype = SVG_TRANSFORM_SKEWX;\n\t\tbreak;\n\tcase 3:\n\t\ttype = SVG_TRANSFORM_SKEWY;\n\t\tbreak;\n\tcase 4:\n\t\ttype = SVG_TRANSFORM_TRANSLATE;\n\t\tbreak;\n\tdefault:\n\t\ttype = SVG_TRANSFORM_ROTATE;\n\t\tbreak;\n\t}\n\tif (gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_transform_type, 1, 0, &info)==GF_OK) {\n\t\t*(SVG_TransformType *)info.far_ptr = type;\n\t}\n\n\tlsr_read_accumulate(lsr, elt);\n\tlsr_read_additive(lsr, elt);\n\tlsr_read_anim_value_ex(lsr, elt, TAG_SVG_ATT_by, \"by\", &type);\n\tlsr_read_calc_mode(lsr, elt);\n\tlsr_read_anim_value_ex(lsr, elt, TAG_SVG_ATT_from, \"from\", &type);\n\tlsr_read_fraction_12(lsr, elt, TAG_SVG_ATT_keySplines, \"keySplines\");\n\tlsr_read_fraction_12(lsr, elt, TAG_SVG_ATT_keyTimes, \"keyTimes\");\n\tlsr_read_anim_values_ex(lsr, elt, &type);\n\tlsr_read_attribute_type(lsr, elt);\n\n\tlsr_read_smil_times(lsr, elt, TAG_SVG_ATT_begin, NULL, \"begin\", 1);\n\tlsr_read_duration(lsr, elt);\n\tlsr_read_anim_fill(lsr, elt);\n\tlsr_read_anim_repeatCount(lsr, elt);\n\tlsr_read_repeat_duration(lsr, elt);\n\tlsr_read_anim_restart(lsr, elt);\n\tlsr_read_anim_value_ex(lsr, elt, TAG_SVG_ATT_to, \"to\", &type);\n\n\tlsr_read_href(lsr, elt);\n\tlsr_read_lsr_enabled(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\n\tif (!lsr_setup_smil_anim(lsr, (SVG_Element*)elt, parent)) {\n\t\tgf_list_add(lsr->deferred_anims, elt);\n\t\tlsr_read_group_content_post_init(lsr, (SVG_Element*)elt, 1);\n\t} else {\n\t\tlsr_read_group_content(lsr, elt, 0);\n\t}\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_audio(GF_LASeRCodec *lsr, SVG_Element *parent)\n{\n\tGF_Node *elt= gf_node_new(lsr->sg, TAG_SVG_audio);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_smil_times(lsr, elt, TAG_SVG_ATT_begin, NULL, \"begin\", 1);\n\tlsr_read_duration(lsr, elt);\n\tlsr_read_eRR(lsr, elt);\n\tlsr_read_anim_repeatCount(lsr, elt);\n\tlsr_read_repeat_duration(lsr, elt);\n\tlsr_read_anim_restart(lsr, elt);\n\tlsr_read_sync_behavior(lsr, elt);\n\tlsr_read_sync_tolerance(lsr, elt);\n\tlsr_read_content_type(lsr, elt);\n\tlsr_read_href(lsr, elt);\n\n\tlsr_read_clip_time(lsr, elt, TAG_SVG_ATT_clipBegin, \"clipBegin\");\n\tlsr_read_clip_time(lsr, elt, TAG_SVG_ATT_clipEnd, \"clipEnd\");\n\tlsr_read_sync_reference(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_circle(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt= gf_node_new(lsr->sg, TAG_SVG_circle);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_cx, 1, \"cx\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_cy, 1, \"cy\");\n\tlsr_read_coordinate_ptr(lsr, elt,TAG_SVG_ATT_r, 0, \"r\");\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_conditional(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_LSR_conditional);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_smil_times(lsr, elt, TAG_SVG_ATT_begin, NULL, \"begin\", 1);\n\tlsr_read_eRR(lsr, elt);\n\tlsr_read_lsr_enabled(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_command_list(lsr, NULL, (SVG_Element*)elt, 0);\n\n\tlsr->has_conditionnals = GF_TRUE;\n\tgf_node_init(elt);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_cursorManager(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_LSR_cursorManager);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt,TAG_SVG_ATT_x, 1, \"x\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y, 1, \"y\");\n\tlsr_read_href(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_data(GF_LASeRCodec *lsr, u32 node_tag)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, node_tag);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_defs(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_defs);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_ellipse(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_ellipse);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_cx, 1, \"cx\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_cy, 1, \"cy\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_rx, 0, \"rx\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_ry, 0, \"ry\");\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_foreignObject(GF_LASeRCodec *lsr)\n{\n\tu32 flag;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_foreignObject);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_eRR(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_height, 0, \"height\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_width, 0, \"width\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x, 1, \"x\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y, 1, \"y\");\n\n\tlsr_read_any_attribute(lsr, elt, 1);\n\t/*\tTODO\n\t\tbit(1) opt_group;\n\t\tif(opt_group) {\n\t\t\tvluimsbf5 occ1;\n\t\t\tfor(int t=0;t<occ1;t++) {\n\t\t\t\tprivateElementContainer child0[[t]];\n\t\t\t}\n\t\t}\n\t*/\n\tGF_LSR_READ_INT(lsr, flag, 1, \"opt_group\");\n\treturn elt;\n}\n\n\nstatic GF_Node *lsr_read_g(GF_LASeRCodec *lsr, Bool is_same)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_g);\n\tif (is_same) {\n\t\tif (lsr->prev_g) {\n\t\t\tlsr_restore_base(lsr, (SVG_Element*) elt, lsr->prev_g, 0, 0);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[LASeR] sameg coded in bitstream but no g defined !\\n\"));\n\t\t}\n\t\tlsr_read_id(lsr, elt);\n\t} else {\n\t\tlsr_read_id(lsr, elt);\n\t\tlsr_read_rare_full(lsr, elt);\n\t\tlsr_read_fill(lsr, elt);\n\t\tlsr_read_stroke(lsr, elt);\n\t\tlsr_read_eRR(lsr, elt);\n\t\tlsr_read_any_attribute(lsr, elt, 1);\n\t\tlsr->prev_g = (SVG_Element*)elt;\n\t}\n\tlsr_read_group_content(lsr, elt, is_same);\n\treturn elt;\n}\n\nstatic void lsr_read_opacity(GF_LASeRCodec *lsr, GF_Node *elt)\n{\n\tu32 flag;\n\tGF_FieldInfo info;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"opacity\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_opacity, 1, 0, &info);\n\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"opacity\");\n\t}\n\n}\nstatic GF_Node *lsr_read_image(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_image);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_eRR(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_height, 1, \"height\");\n\tlsr_read_opacity(lsr, elt);\n\n\tlsr_read_preserve_aspect_ratio(lsr, elt);\n\tlsr_read_content_type(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_width, 1, \"width\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x, 1, \"x\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y, 1, \"y\");\n\tlsr_read_href(lsr, elt);\n\tlsr_read_transform_behavior(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_line(GF_LASeRCodec *lsr, Bool is_same)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_line);\n\n\tif (is_same) {\n\t\tif (lsr->prev_line) {\n\t\t\tlsr_restore_base(lsr, (SVG_Element*) elt, (SVG_Element *)lsr->prev_line, 0, 0);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[LASeR] sameline coded in bitstream but no line defined !\\n\"));\n\t\t}\n\t\tlsr_read_id(lsr, elt);\n\t} else {\n\t\tlsr_read_id(lsr, elt);\n\t\tlsr_read_rare_full(lsr, elt);\n\t\tlsr_read_fill(lsr, elt);\n\t\tlsr_read_stroke(lsr, elt);\n\t}\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x1, 1, \"x1\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x2, 0, \"x2\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y1, 1, \"y1\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y2, 0, \"y2\");\n\tif (!is_same) {\n\t\tlsr_read_any_attribute(lsr, elt, 1);\n\t\tlsr->prev_line = (SVG_Element*)elt;\n\t}\n\tlsr_read_group_content(lsr, elt, is_same);\n\treturn elt;\n}\n\nstatic void lsr_read_gradient_units(GF_LASeRCodec *lsr, GF_Node *elt)\n{\n\tu32 flag;\n\tGF_FieldInfo info;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasGradientUnits\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_gradientUnits, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, *(SVG_GradientUnit*)info.far_ptr, 1, \"gradientUnits\");\n\t}\n}\nstatic GF_Node *lsr_read_linearGradient(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_linearGradient);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_gradient_units(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x1, 1, \"x1\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x2, 1, \"x2\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y1, 1, \"y1\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y2, 1, \"y2\");\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_mpath(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_mpath);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_href(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_path(GF_LASeRCodec *lsr, u32 same_type)\n{\n\tu32 flag;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_path);\n\n\tif (same_type) {\n\t\tif (lsr->prev_path) {\n\t\t\tlsr_restore_base(lsr, (SVG_Element*)elt, (SVG_Element *)lsr->prev_path, (same_type==2) ? 1 : 0, 0);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[LASeR] samepath coded in bitstream but no path defined !\\n\"));\n\t\t}\n\t\tlsr_read_id(lsr, elt);\n\t\tif (same_type==2) lsr_read_fill(lsr, elt);\n\t\tlsr_read_path_type(lsr, elt, TAG_SVG_ATT_d, NULL, \"d\");\n\t} else {\n\t\tlsr_read_id(lsr, elt);\n\t\tlsr_read_rare_full(lsr, elt);\n\t\tlsr_read_fill(lsr, elt);\n\t\tlsr_read_stroke(lsr, elt);\n\t\tlsr_read_path_type(lsr, elt, TAG_SVG_ATT_d, NULL, \"d\");\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"hasPathLength\");\n\t\tif (flag) {\n\t\t\tGF_FieldInfo info;\n\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_pathLength, 1, 0, &info);\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_16_8(lsr, \"pathLength\");\n\t\t}\n\t\tlsr_read_any_attribute(lsr, elt, 1);\n\t\tlsr->prev_path = (SVG_Element*)elt;\n\t}\n\tlsr_read_group_content(lsr, elt, same_type);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_polygon(GF_LASeRCodec *lsr, Bool is_polyline, u32 same_type)\n{\n\tGF_FieldInfo info;\n\tGF_Node *elt = gf_node_new(lsr->sg, is_polyline ? TAG_SVG_polyline : TAG_SVG_polygon);\n\n\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_points, 1, 0, &info);\n\n\tif (same_type) {\n\t\tif (lsr->prev_polygon) {\n\t\t\tlsr_restore_base(lsr, (SVG_Element*)elt, (SVG_Element *)lsr->prev_polygon, /*(same_type==2) ? 1 : */ 0, /*(same_type==3) ? 1 : */ 0);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[LASeR] samepolyXXX coded in bitstream but no polyXXX defined !\\n\"));\n\t\t}\n\t\tlsr_read_id(lsr, elt);\n\t\tif (same_type==2) lsr_read_fill(lsr, elt);\n\t\telse if (same_type==3) lsr_read_stroke(lsr, elt);\n\t\tlsr_read_point_sequence(lsr, *(GF_List**)info.far_ptr, \"points\");\n\t} else {\n\t\tlsr_read_id(lsr, elt);\n\t\tlsr_read_rare_full(lsr, elt);\n\t\tlsr_read_fill(lsr, elt);\n\t\tlsr_read_stroke(lsr, elt);\n\t\tlsr_read_point_sequence(lsr, *(GF_List**)info.far_ptr, \"points\");\n\t\tlsr_read_any_attribute(lsr, elt, 1);\n\t\tlsr->prev_polygon = (SVG_Element*)elt;\n\t}\n\tlsr_read_group_content(lsr, elt, same_type);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_radialGradient(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_radialGradient);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_cx, 1, \"cx\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_cy, 1, \"cy\");\n\tlsr_read_gradient_units(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_r, 1, \"r\");\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_rect(GF_LASeRCodec *lsr, u32 same_type)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_rect);\n\n\tif (same_type) {\n\t\tif (lsr->prev_rect) {\n\t\t\tlsr_restore_base(lsr, (SVG_Element*)elt, (SVG_Element *)lsr->prev_rect, (same_type==2) ? 1 : 0, 0);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[LASeR] samerect coded in bitstream but no rect defined !\\n\"));\n\t\t}\n\t\tlsr_read_id(lsr, elt);\n\t\tif (same_type==2) lsr_read_fill(lsr, elt);\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_height, 0, \"height\");\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_width, 0, \"width\");\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x, 1, \"x\");\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y, 1, \"y\");\n\t} else {\n\t\tlsr_read_id(lsr, elt);\n\t\tlsr_read_rare_full(lsr, elt);\n\t\tlsr_read_fill(lsr, elt);\n\t\tlsr_read_stroke(lsr, elt);\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_height, 0, \"height\");\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_rx, 1, \"rx\");\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_ry, 1, \"ry\");\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_width, 0, \"width\");\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x, 1, \"x\");\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y, 1, \"y\");\n\t\tlsr_read_any_attribute(lsr, elt, 1);\n\t\tlsr->prev_rect = (SVG_Element*)elt;\n\t}\n\tlsr_read_group_content(lsr, elt, same_type);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_rectClip(GF_LASeRCodec *lsr)\n{\n\tu32 flag;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_LSR_rectClip);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_eRR(lsr, elt);\n\tGF_LSR_READ_INT(lsr, flag, 1, \"has_size\");\n\tif (flag) {\n\t\tSVG_Number num;\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_size, 1, 0, &info);\n\t\tlsr_read_coordinate(lsr, & num, 0, \"width\");\n\t\t((LASeR_Size*)info.far_ptr)->width = num.value;\n\t\tlsr_read_coordinate(lsr, & num, 0, \"height\");\n\t\t((LASeR_Size*)info.far_ptr)->height = num.value;\n\t}\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_script(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_script);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_eRR(lsr, elt);\n\tlsr_read_script_type(lsr, elt);\n\tlsr_read_href(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_selector(GF_LASeRCodec *lsr)\n{\n\tu32 flag;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_LSR_selector);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_eRR(lsr, elt);\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasChoice\");\n\tif (flag) {\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_choice, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"choice\");\n\t\tif (flag) {\n\t\t\tGF_LSR_READ_INT(lsr, ((LASeR_Choice*)info.far_ptr)->type, 1, \"type\");\n\t\t} else {\n\t\t\tGF_LSR_READ_INT(lsr, ((LASeR_Choice*)info.far_ptr)->choice_index, 8, \"value\");\n\t\t\t((LASeR_Choice*)info.far_ptr)->type = LASeR_CHOICE_N;\n\t\t}\n\t}\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_set(GF_LASeRCodec *lsr, SVG_Element *parent)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_set);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_attribute_name(lsr, elt);\n\tlsr_read_attribute_type(lsr, elt);\n\n\tlsr_read_smil_times(lsr, elt, TAG_SVG_ATT_begin, NULL, \"begin\", 1);\n\tlsr_read_duration(lsr, elt);\n\tlsr_read_anim_fill(lsr, elt);\n\tlsr_read_anim_repeatCount(lsr, elt);\n\tlsr_read_repeat_duration(lsr, elt);\n\tlsr_read_anim_restart(lsr, elt);\n\tlsr_read_anim_value(lsr, elt, TAG_SVG_ATT_to, \"to\");\n\tlsr_read_href(lsr, elt);\n\tlsr_read_lsr_enabled(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\n\tif (!lsr_setup_smil_anim(lsr, (SVG_Element*)elt, parent)) {\n\t\tgf_list_add(lsr->deferred_anims, elt);\n\t\tlsr_read_group_content_post_init(lsr, (SVG_Element*)elt, 1);\n\t} else {\n\t\tlsr_read_group_content(lsr, elt, 0);\n\t}\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_simpleLayout(GF_LASeRCodec *lsr)\n{\n\tu32 flag;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_LSR_simpleLayout);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tGF_LSR_READ_INT(lsr, flag, 1, \"has_delta\");\n\tif (flag) {\n\t\tSVG_Number num;\n\t\tGF_FieldInfo info;\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_delta, 1, 0, &info);\n\t\tlsr_read_coordinate(lsr, & num, 0, \"width\");\n\t\t((LASeR_Size*)info.far_ptr)->width = num.value;\n\t\tlsr_read_coordinate(lsr, & num, 0, \"height\");\n\t\t((LASeR_Size*)info.far_ptr)->height = num.value;\n\t}\n\tlsr_read_eRR(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_stop(GF_LASeRCodec *lsr)\n{\n\tGF_FieldInfo info;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_stop);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\n\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_offset, 1, 0, &info);\n\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_16_8(lsr, \"offset\");\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\nstatic GF_Node *lsr_read_svg(GF_LASeRCodec *lsr, Bool init_node)\n{\n\tGF_FieldInfo info;\n\tSMIL_Duration snap;\n\tu32 flag;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_svg);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_string_attribute(lsr, elt, TAG_SVG_ATT_baseProfile, \"baseProfile\");\n\tlsr_read_string_attribute(lsr, elt, TAG_SVG_ATT_contentScriptType, \"contentScriptType\");\n\tlsr_read_eRR(lsr, elt);\n\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_height, 1, 0, &info);\n\tlsr_read_value_with_units(lsr, info.far_ptr, \"height\");\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasPlaybackOrder\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_playbackOrder, 1, 1, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"playbackOrder\");\n\t\tif (flag) *(SVG_PlaybackOrder*)info.far_ptr = SVG_PLAYBACKORDER_FORWARDONLY;\n\t}\n\n\tlsr_read_preserve_aspect_ratio(lsr, elt);\n\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"has_snapshotTime\");\n\tif (flag) {\n\t\tlsr_read_duration_ex(lsr, NULL, 0, &snap, \"snapshotTime\", 0);\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_snapshotTime, 1, 1, &info);\n\t\tif (snap.type==SMIL_DURATION_DEFINED) *((SVG_Clock *)info.far_ptr) = snap.clock_value;\n\t}\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasSyncBehavior\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_syncBehaviorDefault, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 2, \"syncBehaviorDefault\");\n\t\tswitch (flag) {\n\t\tcase 0:\n\t\t\t*((SMIL_SyncBehavior*)info.far_ptr) = SMIL_SYNCBEHAVIOR_CANSLIP;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*((SMIL_SyncBehavior*)info.far_ptr) = SMIL_SYNCBEHAVIOR_INDEPENDENT;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t*((SMIL_SyncBehavior*)info.far_ptr) = SMIL_SYNCBEHAVIOR_LOCKED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*((SMIL_SyncBehavior*)info.far_ptr) = SMIL_SYNCBEHAVIOR_INHERIT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasSyncToleranceDefault\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_syncToleranceDefault, 1, 0, &info);\n\t\t((SMIL_SyncTolerance*)info.far_ptr)->type = SMIL_SYNCTOLERANCE_VALUE;\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"choice\");\n\t\t((SMIL_SyncTolerance*)info.far_ptr)->value = lsr_read_vluimsbf5(lsr, \"value\");\n\t\t((SMIL_SyncTolerance*)info.far_ptr)->value /= lsr->time_resolution;\n\t}\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasTimelineBegin\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_timelineBegin, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"timelineBegin\");\n\t\tif (flag) *(SVG_TimelineBegin*)info.far_ptr = SVG_TIMELINEBEGIN_ONLOAD;\n\t}\n\tlsr_read_string_attribute(lsr, elt, TAG_SVG_ATT_version, \"version\");\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasViewBox\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_viewBox, 1, 0, &info);\n\t\t((SVG_ViewBox*)info.far_ptr)->x = lsr_read_fixed_16_8(lsr, \"viewbox.x\");\n\t\t((SVG_ViewBox*)info.far_ptr)->y = lsr_read_fixed_16_8(lsr, \"viewbox.y\");\n\t\t((SVG_ViewBox*)info.far_ptr)->width = lsr_read_fixed_16_8(lsr, \"viewbox.width\");\n\t\t((SVG_ViewBox*)info.far_ptr)->height = lsr_read_fixed_16_8(lsr, \"viewbox.height\");\n\t\t((SVG_ViewBox*)info.far_ptr)->is_set = 1;\n\t}\n\n\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_width, 1, 0, &info);\n\tlsr_read_value_with_units(lsr, info.far_ptr, \"width\");\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasZoomAndPan\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_zoomAndPan, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"zoomAndPan\");\n\t\t*((SVG_ZoomAndPan*)info.far_ptr) = flag ? SVG_ZOOMANDPAN_MAGNIFY : SVG_ZOOMANDPAN_DISABLE;\n\t}\n\tlsr_read_any_attribute(lsr, elt, 1);\n\t/*store current root for listeners with no focus target*/\n\tlsr->current_root = elt;\n\n\tif (init_node) {\n\t\tgf_node_register(elt, NULL);\n\t\tgf_sg_set_root_node(lsr->sg, elt);\n\t}\n\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_switch(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_switch);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_eRR(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\n\nstatic GF_Node *lsr_read_text(GF_LASeRCodec *lsr, u32 same_type)\n{\n\tu32 flag;\n\tGF_FieldInfo info;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_text);\n\tif (same_type) {\n\t\tif (lsr->prev_text) {\n\t\t\tlsr_restore_base(lsr, (SVG_Element *)elt, (SVG_Element *)lsr->prev_text, (same_type==2) ? 1 : 0, 0);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[LASeR] sametext coded in bitstream but no text defined !\\n\"));\n\t\t}\n\t\tlsr_read_id(lsr, elt);\n\t\tif (same_type==2) lsr_read_fill(lsr, elt);\n\t\tlsr_read_coord_list(lsr, elt, TAG_SVG_ATT_text_x, \"x\");\n\t\tlsr_read_coord_list(lsr, elt, TAG_SVG_ATT_text_y, \"y\");\n\t} else {\n\t\tlsr_read_id(lsr, elt);\n\t\tlsr_read_rare_full(lsr, elt);\n\t\tlsr_read_fill(lsr, elt);\n\t\tlsr_read_stroke(lsr, elt);\n\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"editable\");\n\t\tif (flag) {\n\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_editable, 1, 0, &info);\n\t\t\t*(SVG_Boolean*)info.far_ptr = flag;\n\t\t}\n\t\tlsr_read_float_list(lsr, elt, TAG_SVG_ATT_text_rotate, NULL, \"rotate\");\n\t\tlsr_read_coord_list(lsr, elt, TAG_SVG_ATT_text_x, \"x\");\n\t\tlsr_read_coord_list(lsr, elt, TAG_SVG_ATT_text_y, \"y\");\n\t\tlsr_read_any_attribute(lsr, elt, 1);\n\t\tlsr->prev_text = (SVG_Element*)elt;\n\t}\n\tlsr_read_group_content(lsr, elt, same_type);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_tspan(GF_LASeRCodec *lsr)\n{\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_tspan);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tlsr_read_fill(lsr, elt);\n\tlsr_read_stroke(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_use(GF_LASeRCodec *lsr, Bool is_same)\n{\n\tGF_FieldInfo info;\n\tu32 flag;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_use);\n\tif (is_same) {\n\t\tif (lsr->prev_use) {\n\t\t\tlsr_restore_base(lsr, (SVG_Element *)elt, lsr->prev_use, 0, 0);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[LASeR] sameuse coded in bitstream but no use defined !\\n\"));\n\t\t}\n\t\tlsr_read_id(lsr, elt);\n\t\tlsr_read_href(lsr, elt);\n\t} else {\n\t\tlsr_read_id(lsr, elt);\n\t\tlsr_read_rare_full(lsr, elt);\n\t\tlsr_read_fill(lsr, elt);\n\t\tlsr_read_stroke(lsr, elt);\n\t\tlsr_read_eRR(lsr, elt);\n\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"hasOverflow\");\n\t\tif (flag) {\n\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_overflow, 1, 0, &info);\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Overflow*)info.far_ptr, 2, \"overflow\");\n\t\t}\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x, 1, \"x\");\n\t\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y, 1, \"y\");\n\t\tlsr_read_href(lsr, elt);\n\t\tlsr_read_any_attribute(lsr, elt, 1);\n\t\tlsr->prev_use = (SVG_Element*)elt;\n\t}\n\tlsr_read_group_content(lsr, elt, is_same);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_video(GF_LASeRCodec *lsr, SVG_Element *parent)\n{\n\tGF_FieldInfo info;\n\tu32 flag;\n\tGF_Node*elt = gf_node_new(lsr->sg, TAG_SVG_video);\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare_full(lsr, elt);\n\tlsr_read_smil_times(lsr, elt, TAG_SVG_ATT_begin, NULL, \"begin\", 1);\n\tlsr_read_duration(lsr, elt);\n\tlsr_read_eRR(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_height, 1, \"height\");\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasOverlay\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_overlay, 1, 1, &info);\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"choice\");\n\t\tif (flag) {\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Overlay*)info.far_ptr, 1, \"choice\");\n\t\t} else {\n\t\t\tchar *str = NULL;\n\t\t\tlsr_read_byte_align_string(lsr, & str, \"overlayExt\");\n\t\t\tif (str) gf_free(str);\n\t\t}\n\t}\n\tlsr_read_preserve_aspect_ratio(lsr, elt);\n\tlsr_read_anim_repeatCount(lsr, elt);\n\tlsr_read_repeat_duration(lsr, elt);\n\tlsr_read_anim_restart(lsr, elt);\n\tlsr_read_sync_behavior(lsr, elt);\n\tlsr_read_sync_tolerance(lsr, elt);\n\tlsr_read_transform_behavior(lsr, elt);\n\tlsr_read_content_type(lsr, elt);\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_width, 1, \"width\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_x, 1, \"x\");\n\tlsr_read_coordinate_ptr(lsr, elt, TAG_SVG_ATT_y, 1, \"y\");\n\tlsr_read_href(lsr, elt);\n\n\tlsr_read_clip_time(lsr, elt, TAG_SVG_ATT_clipBegin, \"clipBegin\");\n\tlsr_read_clip_time(lsr, elt, TAG_SVG_ATT_clipEnd, \"clipEnd\");\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasFullscreen\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_SVG_ATT_fullscreen, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, \"fullscreen\");\n\t}\n\n\tlsr_read_sync_reference(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_listener(GF_LASeRCodec *lsr, SVG_Element *parent)\n{\n\tu32 flag;\n\tGF_FieldInfo info;\n\tXMLEV_Event *ev = NULL;\n\tXMLRI *observer, *target, *handler;\n\tGF_Node *elt = gf_node_new(lsr->sg, TAG_SVG_listener);\n\n\tobserver = target = handler = NULL;\n\n\tlsr_read_id(lsr, elt);\n\tlsr_read_rare(lsr, elt);\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasDefaultAction\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_XMLEV_ATT_defaultAction, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, *(XMLEV_DefaultAction*)info.far_ptr, 1, \"defaultAction\");\n\t}\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasEvent\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_XMLEV_ATT_event, 1, 0, &info);\n\t\tlsr_read_event_type(lsr, info.far_ptr);\n\t\tev = info.far_ptr;\n\t}\n\t/*create default handler but UNINITIALIZED*/\n\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_XMLEV_ATT_handler, 1, 0, &info);\n\thandler = info.far_ptr;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasHandler\");\n\tif (flag) {\n\t\tlsr_read_any_uri(lsr, info.far_ptr, \"handler\");\n\t}\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasObserver\");\n\t/*TODO double check spec here*/\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_XMLEV_ATT_observer, 1, 0, &info);\n\t\tlsr_read_codec_IDREF(lsr, info.far_ptr, \"observer\");\n\t\tobserver = info.far_ptr;\n\t}\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasPhase\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_XMLEV_ATT_phase, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, *(XMLEV_Phase*)info.far_ptr, 1, \"phase\");\n\t}\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasPropagate\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_XMLEV_ATT_propagate, 1, 0, &info);\n\t\tGF_LSR_READ_INT(lsr, *(XMLEV_Propagate*)info.far_ptr, 1, \"propagate\");\n\t}\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasTarget\");\n\tif (flag) {\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(elt, TAG_XMLEV_ATT_target, 1, 0, &info);\n\t\tlsr_read_codec_IDREF(lsr, info.far_ptr, \"target\");\n\t\ttarget = info.far_ptr;\n\t}\n\n\tlsr_read_lsr_enabled(lsr, elt);\n\tlsr_read_any_attribute(lsr, elt, 1);\n\tlsr_read_group_content(lsr, elt, 0);\n\n\t/*register listener element*/\n\t{\n\t\tBool post_pone = 0;\n\t\tSVG_Element *par = NULL;\n\t\tif (observer && observer->type == XMLRI_ELEMENTID) {\n\t\t\tif (observer->target) par = observer->target;\n\t\t}\n\t\tif (!par && target && (target->type == XMLRI_ELEMENTID)) {\n\t\t\tif (!target->target) post_pone = 1;\n\t\t\telse par = target->target;\n\t\t}\n\t\tif (!handler->target && !handler->string) {\n\t\t\thandler->type = XMLRI_ELEMENTID;\n\t\t\thandler->target = parent;\n\t\t}\n\t\t/*FIXME - double check with XML events*/\n\t\tif (!par && !observer) {\n\t\t\t/*all non-UI get attched to root*/\n\t\t\tif (ev && (ev->type>GF_EVENT_MOUSEWHEEL)) {\n\t\t\t\tpar = (SVG_Element*) lsr->current_root;\n\t\t\t}\n\t\t\telse if (parent) par = parent;\n\t\t\telse par = (SVG_Element*) lsr->current_root;\n\t\t}\n\t\tif (!par) post_pone = 1;\n\n\t\tif (post_pone) {\n\t\t\tgf_list_add(lsr->deferred_listeners, elt);\n\t\t} else {\n\t\t\tif (!par) par = parent;\n\t\t\tgf_node_dom_listener_add((GF_Node *)par, elt);\n\t\t}\n\t}\n\treturn elt;\n}\n\nstatic GF_Node *lsr_read_scene_content_model(GF_LASeRCodec *lsr, SVG_Element *parent)\n{\n\tGF_Node *n;\n\tu32 ntype;\n\tGF_LSR_READ_INT(lsr, ntype, 6, \"ch4\");\n\tn = NULL;\n\tswitch (ntype) {\n\tcase LSR_SCENE_CONTENT_MODEL_a:\n\t\tn = lsr_read_a(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_animate:\n\t\tn = lsr_read_animate(lsr, parent, 0);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_animateColor:\n\t\tn = lsr_read_animate(lsr, parent, 1);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_animateMotion:\n\t\tn = lsr_read_animateMotion(lsr, parent);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_animateTransform:\n\t\tn = lsr_read_animateTransform(lsr, parent);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_audio:\n\t\tn = lsr_read_audio(lsr, parent);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_circle:\n\t\tn = lsr_read_circle(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_conditional:\n\t\tn = lsr_read_conditional(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_cursorManager:\n\t\tn = lsr_read_cursorManager(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_defs:\n\t\tn = lsr_read_defs(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_desc:\n\t\tn = lsr_read_data(lsr, TAG_SVG_desc);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_ellipse:\n\t\tn = lsr_read_ellipse(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_foreignObject:\n\t\tn = lsr_read_foreignObject(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_g:\n\t\tn = lsr_read_g(lsr, 0);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_image:\n\t\tn = lsr_read_image(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_line:\n\t\tn = lsr_read_line(lsr, 0);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_linearGradient:\n\t\tn = lsr_read_linearGradient(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_metadata:\n\t\tn = lsr_read_data(lsr, TAG_SVG_metadata);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_mpath:\n\t\tn = lsr_read_mpath(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_path:\n\t\tn = lsr_read_path(lsr, 0);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_polygon:\n\t\tn = lsr_read_polygon(lsr, 0, 0);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_polyline:\n\t\tn = lsr_read_polygon(lsr, 1, 0);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_radialGradient:\n\t\tn = lsr_read_radialGradient(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_rect:\n\t\tn = lsr_read_rect(lsr, 0);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_rectClip:\n\t\tn = lsr_read_rectClip(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_sameg:\n\t\tn = lsr_read_g(lsr, 1);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_sameline:\n\t\tn = lsr_read_line(lsr, 1);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samepath:\n\t\tn = lsr_read_path(lsr, 1);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samepathfill:\n\t\tn = lsr_read_path(lsr, 2);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samepolygon:\n\t\tn = lsr_read_polygon(lsr, 0, 1);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samepolygonfill:\n\t\tn = lsr_read_polygon(lsr, 0, 2);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samepolygonstroke:\n\t\tn = lsr_read_polygon(lsr, 0, 3);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samepolyline:\n\t\tn = lsr_read_polygon(lsr, 1, 1);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samepolylinefill:\n\t\tn = lsr_read_polygon(lsr, 1, 2);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samepolylinestroke:\n\t\tn = lsr_read_polygon(lsr, 1, 3);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samerect:\n\t\tn = lsr_read_rect(lsr, 1);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_samerectfill:\n\t\tn = lsr_read_rect(lsr, 2);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_sametext:\n\t\tn = lsr_read_text(lsr, 1);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_sametextfill:\n\t\tn = lsr_read_text(lsr, 2);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_sameuse:\n\t\tn = lsr_read_use(lsr, 1);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_script:\n\t\tn = lsr_read_script(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_selector:\n\t\tn = lsr_read_selector(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_set:\n\t\tn = lsr_read_set(lsr, parent);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_simpleLayout:\n\t\tn = lsr_read_simpleLayout(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_stop:\n\t\tn = lsr_read_stop(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_switch:\n\t\tn = lsr_read_switch(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_text:\n\t\tn = lsr_read_text(lsr, 0);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_title:\n\t\tn = lsr_read_data(lsr, TAG_SVG_title);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_tspan:\n\t\tn = lsr_read_tspan(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_use:\n\t\tn = lsr_read_use(lsr, 0);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_video:\n\t\tn = lsr_read_video(lsr, parent);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_listener:\n\t\tn = lsr_read_listener(lsr, parent);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_element_any:\n\t\tlsr_read_extend_class(lsr, NULL, 0, \"node\");\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_privateContainer:\n\t\tlsr_read_private_element_container(lsr);\n\t\tbreak;\n\tcase LSR_SCENE_CONTENT_MODEL_textContent:\n\t\tlsr_read_text_content(lsr, (GF_Node*)parent);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (n && n->sgprivate->interact && n->sgprivate->interact->dom_evt) {\n\t\tGF_DOM_Event evt;\n\t\tmemset(&evt, 0, sizeof(GF_DOM_Event));\n\t\tevt.type = GF_EVENT_LOAD;\n\t\tgf_dom_event_fire(n, &evt);\n\t}\n\treturn n;\n}\n\nstatic GF_Node *lsr_read_update_content_model(GF_LASeRCodec *lsr, SVG_Element *parent)\n{\n\tu32 flag;\n\tGF_Node *n=NULL;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"ch4\");\n\tif (flag) {\n\t\tGF_LSR_READ_INT(lsr, flag, 3, \"ch61\");\n\t\tswitch (flag) {\n\t\tcase LSR_UPDATE_CONTENT_MODEL2_conditional:\n\t\t\tn = lsr_read_conditional(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL2_cursorManager:\n\t\t\tn = lsr_read_cursorManager(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL2_extend:\n\t\t\tlsr_read_extend_class(lsr, NULL, 0, \"extend\");\n\t\t\treturn NULL;\n\t\tcase LSR_UPDATE_CONTENT_MODEL2_private:\n\t\t\tlsr_read_private_element_container(lsr);\n\t\t\treturn NULL;\n\t\tcase LSR_UPDATE_CONTENT_MODEL2_rectClip:\n\t\t\tn = lsr_read_rectClip(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL2_simpleLayout:\n\t\t\tn = lsr_read_simpleLayout(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL2_selector:\n\t\t\tn = lsr_read_selector(lsr);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tGF_LSR_READ_INT(lsr, flag, 6, \"ch6\");\n\t\tswitch(flag) {\n\t\tcase LSR_UPDATE_CONTENT_MODEL_a:\n\t\t\tn = lsr_read_a(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_animate:\n\t\t\tn = lsr_read_animate(lsr, parent, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_animateColor:\n\t\t\tn = lsr_read_animate(lsr, parent, 1);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_animateMotion:\n\t\t\tn = lsr_read_animateMotion(lsr, parent);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_animateTransform:\n\t\t\tn = lsr_read_animateTransform(lsr, parent);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_audio:\n\t\t\tn = lsr_read_audio(lsr, parent);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_circle:\n\t\t\tn = lsr_read_circle(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_defs:\n\t\t\tn = lsr_read_defs(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_desc:\n\t\t\tn = lsr_read_data(lsr, TAG_SVG_desc);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_ellipse:\n\t\t\tn = lsr_read_ellipse(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_foreignObject:\n\t\t\tn = lsr_read_foreignObject(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_g:\n\t\t\tn = lsr_read_g(lsr, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_image:\n\t\t\tn = lsr_read_image(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_line:\n\t\t\tn = lsr_read_line(lsr, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_linearGradient:\n\t\t\tn = lsr_read_linearGradient(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_metadata:\n\t\t\tn = lsr_read_data(lsr, TAG_SVG_metadata);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_mpath:\n\t\t\tn = lsr_read_mpath(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_path:\n\t\t\tn = lsr_read_path(lsr, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_polygon:\n\t\t\tn = lsr_read_polygon(lsr, 0, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_polyline:\n\t\t\tn = lsr_read_polygon(lsr, 1, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_radialGradient:\n\t\t\tn = lsr_read_radialGradient(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_rect:\n\t\t\tn = lsr_read_rect(lsr, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_script:\n\t\t\tn = lsr_read_script(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_set:\n\t\t\tn = lsr_read_set(lsr, parent);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_stop:\n\t\t\tn = lsr_read_stop(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_svg:\n\t\t\tn = lsr_read_svg(lsr, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_switch:\n\t\t\tn = lsr_read_switch(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_text:\n\t\t\tn = lsr_read_text(lsr, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_title:\n\t\t\tn = lsr_read_data(lsr, TAG_SVG_title);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_tspan:\n\t\t\tn = lsr_read_tspan(lsr);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_use:\n\t\t\tn = lsr_read_use(lsr, 0);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_video:\n\t\t\tn = lsr_read_video(lsr, parent);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_CONTENT_MODEL_listener:\n\t\t\tn = lsr_read_listener(lsr, parent);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (n && n->sgprivate->interact && n->sgprivate->interact->dom_evt) {\n\t\tGF_DOM_Event evt;\n\t\tmemset(&evt, 0, sizeof(GF_DOM_Event));\n\t\tevt.type = GF_EVENT_LOAD;\n\t\tgf_dom_event_fire(n, &evt);\n\t}\n\treturn n;\n}\n\nstatic void lsr_read_group_content(GF_LASeRCodec *lsr, GF_Node *elt, Bool skip_object_content)\n{\n\tu32 i, count;\n\tif (lsr->last_error) return;\n\n\tif (!skip_object_content) lsr_read_object_content(lsr, (SVG_Element*)elt);\n\n\n\t/*node attributes are all parsed*/\n\tif (elt->sgprivate->tag!=TAG_SVG_script)\n\t\tgf_node_init(elt);\n\n\tGF_LSR_READ_INT(lsr, count, 1, \"opt_group\");\n\tif (count) {\n\t\tGF_ChildNodeItem *last = NULL;\n\t\tcount = lsr_read_vluimsbf5(lsr, \"occ0\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Node *n;\n\t\t\tif (lsr->last_error) return;\n\t\t\tn = lsr_read_scene_content_model(lsr, (SVG_Element*)elt);\n\t\t\tif (n) {\n\t\t\t\tgf_node_register(n, elt);\n\t\t\t\tgf_node_list_add_child_last(& ((SVG_Element*)elt)->children, n, &last);\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[LASeR] ############## end %s ###########\\n\", gf_node_get_class_name(n)));\n\t\t\t} else {\n\t\t\t\t/*either error or text content*/\n\t\t\t}\n\t\t}\n\t}\n\n\tif (elt->sgprivate->tag==TAG_SVG_script)\n\t\tgf_node_init(elt);\n}\n\nstatic void lsr_read_group_content_post_init(GF_LASeRCodec *lsr, SVG_Element *elt, Bool skip_init)\n{\n\tu32 i, count;\n\tif (lsr->last_error) return;\n\tlsr_read_object_content(lsr, elt);\n\n\tGF_LSR_READ_INT(lsr, count, 1, \"opt_group\");\n\tif (count) {\n\t\tGF_ChildNodeItem *last = NULL;\n\t\tcount = lsr_read_vluimsbf5(lsr, \"occ0\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Node *n;\n\t\t\tif (lsr->last_error) return;\n\t\t\tn = lsr_read_scene_content_model(lsr, elt);\n\t\t\tif (n) {\n\t\t\t\tgf_node_register(n, (GF_Node*)elt);\n\t\t\t\tgf_node_list_add_child_last(&elt->children, n, &last);\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[LASeR] ############## end %s ###########\\n\", gf_node_get_class_name(n)));\n\t\t\t} else {\n\t\t\t\t/*either error or text content*/\n\t\t\t}\n\t\t}\n\t}\n\tif (!skip_init) gf_node_init((GF_Node*)elt);\n}\n\nstatic void *lsr_read_update_value_indexed(GF_LASeRCodec *lsr, GF_Node*node, u32 fieldType, void *rep_val, u32 idx, Bool is_insert, Bool is_com, u32 *single_field_type)\n{\n\tFixed *f_val;\n\tSVG_Number num;\n\n\tswitch (fieldType) {\n\tcase SVG_Points_datatype/*ITYPE_point*/:\n\t{\n\t\tSVG_Point *pt;\n\t\tListOfXXX *res;\n\t\tGF_SAFEALLOC(res, ListOfXXX);\n\t\tif (!res) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\t*res = gf_list_new();\n\t\tpt = (SVG_Point*)gf_malloc(sizeof(SVG_Point));\n\t\tif (!pt) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\tlsr_read_coordinate(lsr, &num, 0, \"coordX\");\n\t\t\tpt->x = num.value;\n\t\t\tlsr_read_coordinate(lsr, &num, 0, \"coordY\");\n\t\t\tpt->y = num.value;\n\t\t\tgf_list_add(*res, pt);\n\t\t}\n\t\treturn res;\n\t}\n\tcase SMIL_KeySplines_datatype/*ITYPE_float*/:\n\t{\n\t\tListOfXXX *res;\n\t\tGF_SAFEALLOC(res, ListOfXXX);\n\t\tif (!res) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\t*res = gf_list_new();\n\t\tf_val = (Fixed*)gf_malloc(sizeof(Fixed));\n\t\tif (!f_val) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\t*f_val = lsr_read_fixed_16_8(lsr, \"floatValue\");\n\t\t\tgf_list_add(*res, f_val);\n\t\t}\n\t\treturn res;\n\t}\n\tcase SVG_StrokeDashArray_datatype:\n\tcase SVG_ViewBox_datatype:\n\t\tf_val = (Fixed*)gf_malloc(sizeof(Fixed));\n\t\tif (!f_val) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\t*f_val = lsr_read_fixed_16_8(lsr, \"floatValue\");\n\t\t}\n\t\treturn f_val;\n\tcase SMIL_KeyTimes_datatype/*ITYPE_keyTime*/:\n\t{\n\t\tListOfXXX *res;\n\t\tGF_SAFEALLOC(res, ListOfXXX);\n\t\tif (!res) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\t*res = gf_list_new();\n\t\tf_val = lsr_read_fraction_12_item(lsr);\n\t\tif (f_val) gf_list_add(*res, f_val);\n\t\treturn res;\n\t}\n\tcase SMIL_KeyPoints_datatype/*ITYPE_0to1 - keyPoints*/:\n\t{\n\t\tListOfXXX *res;\n\t\tGF_SAFEALLOC(res, ListOfXXX);\n\t\tif (!res) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\t*res = gf_list_new();\n\t\tf_val = (Fixed*)gf_malloc(sizeof(Fixed));\n\t\tif (!f_val) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\t*f_val = lsr_read_fixed_clamp(lsr, \"value\");\n\t\t\tgf_list_add(*res, f_val);\n\t\t}\n\t\treturn res;\n\t}\n\tcase SMIL_Times_datatype/*ITYPE_smil_time*/:\n\t{\n\t\tListOfXXX *res;\n\t\tGF_SAFEALLOC(res, ListOfXXX);\n\t\tif (!res) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\treturn NULL;\n\t\t}\n\t\t*res = gf_list_new();\n\t\tif (! *res) {\n\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t} else {\n\t\t\tgf_list_add(*res, lsr_read_smil_time(lsr, node) );\n\t\t}\n\t\treturn res;\n\t}\n\tdefault:\n\t\tlsr_read_extension(lsr, \"privateData\");\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic void lsr_read_update_value(GF_LASeRCodec *lsr, GF_Node *node, u32 att_tag, u32 fieldType, void *val, u32 node_tag)\n{\n\tu32 is_default, has_escape, escape_val = 0;\n\tSVG_Number num, *n;\n\n\tswitch (fieldType) {\n\tcase SVG_Boolean_datatype:\n\t\tGF_LSR_READ_INT(lsr, *(SVG_Boolean*)val, 1, \"val\");\n\t\tbreak;\n\tcase SVG_Paint_datatype:\n\t\tlsr_read_paint(lsr, (SVG_Paint*)val, \"val\");\n\t\tbreak;\n\t/*\n\t\tcase SVG_AudioLevel_datatype:\n\t\t\tn = val;\n\t\t\tGF_LSR_READ_INT(lsr, is_default, 1, \"isDefaultValue\");\n\t\t\tif (is_default) n->type=SVG_NUMBER_INHERIT;\n\t\t\telse {\n\t\t\t\tn->type = SVG_NUMBER_VALUE;\n\t\t\t\tn->value = lsr_read_fixed_clamp(lsr, \"val\");\n\t\t\t}\n\t\t\tbreak;\n\t*/\n\tcase SVG_Transform_Scale_datatype:\n\t\t((SVG_Point *)val)->x = lsr_read_fixed_16_8(lsr, \"scale_x\");\n\t\t((SVG_Point *)val)->y = lsr_read_fixed_16_8(lsr, \"scale_y\");\n\t\tbreak;\n\tcase LASeR_Size_datatype:\n\tcase SVG_Transform_Translate_datatype:\n\t\tlsr_read_coordinate(lsr, &num, 0, \"translation_x\");\n\t\t((SVG_Point *)val)->x = num.value;\n\t\tlsr_read_coordinate(lsr, &num, 0, \"translation_y\");\n\t\t((SVG_Point *)val)->y = num.value;\n\t\tbreak;\n\tcase SVG_Transform_Rotate_datatype:\n\t\tGF_LSR_READ_INT(lsr, is_default, 1, \"isDefaultValue\");\n\t\tif (is_default) ((SVG_Point_Angle*)val)->angle = 0;\n\t\telse {\n\t\t\tGF_LSR_READ_INT(lsr, has_escape, 1, \"escapeFlag\");\n\t\t\tif (has_escape) {\n\t\t\t\tGF_LSR_READ_INT(lsr, escape_val, 2, \"escapeEnum\");\n\t\t\t\t((SVG_Point_Angle*)val)->angle = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t((SVG_Point_Angle*)val)->angle = lsr_read_fixed_16_8(lsr, \"rotate\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SVG_Transform_datatype:\n\t\tlsr_read_matrix(lsr, val);\n\t\tbreak;\n\tcase SVG_Number_datatype:\n\tcase SVG_FontSize_datatype:\n\tcase SVG_Length_datatype:\n\t\tn = (SVG_Number*)val;\n\t\tswitch (att_tag) {\n\t\t/*fractions*/\n\t\tcase TAG_SVG_ATT_audio_level:\n\t\tcase TAG_SVG_ATT_fill_opacity:\n\t\tcase TAG_SVG_ATT_offset:\n\t\tcase TAG_SVG_ATT_opacity:\n\t\tcase TAG_SVG_ATT_solid_opacity:\n\t\tcase TAG_SVG_ATT_stop_opacity:\n\t\tcase TAG_SVG_ATT_stroke_opacity:\n\t\tcase TAG_SVG_ATT_viewport_fill_opacity:\n\t\t\tGF_LSR_READ_INT(lsr, is_default, 1, \"isDefaultValue\");\n\t\t\tif (is_default) n->type=SVG_NUMBER_INHERIT;\n\t\t\telse {\n\t\t\t\tn->type = SVG_NUMBER_VALUE;\n\t\t\t\tn->value = lsr_read_fixed_clamp(lsr, \"val\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_width:\n\t\tcase TAG_SVG_ATT_height:\n\t\t\tif (node_tag==TAG_SVG_svg) {\n\t\t\t\tlsr_read_value_with_units(lsr, n, \"val\");\n\t\t\t} else {\n\t\t\t\tlsr_read_coordinate(lsr, n, 0, \"val\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LSR_READ_INT(lsr, is_default, 1, \"isDefaultValue\");\n\t\t\tif (is_default) n->type=SVG_NUMBER_INHERIT;\n\t\t\telse {\n\t\t\t\tGF_LSR_READ_INT(lsr, has_escape, 1, \"escapeFlag\");\n\t\t\t\tif (has_escape) {\n\t\t\t\t\tGF_LSR_READ_INT(lsr, escape_val, 2, \"escapeEnum\");\n\t\t\t\t\tn->type = SVG_NUMBER_AUTO;//only lineIncrement\n\t\t\t\t} else {\n\t\t\t\t\tn->type = SVG_NUMBER_VALUE;\n\t\t\t\t\tn->value = lsr_read_fixed_16_8(lsr, \"val\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SVG_Coordinate_datatype:\n\t\tn = (SVG_Number*)val;\n\t\tn->type = SVG_NUMBER_VALUE;\n\t\tlsr_read_coordinate(lsr, n, 0, \"val\");\n\t\tbreak;\n\n\tcase SVG_Rotate_datatype:\n\t\tn = (SVG_Number*)val;\n\t\tGF_LSR_READ_INT(lsr, is_default, 1, \"isDefaultValue\");\n\t\tif (is_default) n->type=SVG_NUMBER_INHERIT;\n\t\telse {\n\t\t\tGF_LSR_READ_INT(lsr, has_escape, 1, \"escapeFlag\");\n\t\t\tif (has_escape) {\n\t\t\t\tGF_LSR_READ_INT(lsr, escape_val, 2, \"escapeEnum\");\n\t\t\t\tn->type = escape_val ? SVG_NUMBER_AUTO_REVERSE : SVG_NUMBER_AUTO;\n\t\t\t} else {\n\t\t\t\tn->type = SVG_NUMBER_VALUE;\n\t\t\t\tn->value = lsr_read_fixed_16_8(lsr, \"rotate\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SVG_Coordinates_datatype:\n\t\tlsr_read_float_list(lsr, NULL, 0, val, \"val\");\n\t\tbreak;\n\tcase SVG_ViewBox_datatype:\n\t{\n\t\tu32 count;\n\t\tSVG_ViewBox *vb = (SVG_ViewBox *)val;\n\t\tGF_LSR_READ_INT(lsr, count, 1, \"isDefault\");\n\t\tif (count) {\n\t\t\tvb->is_set = 0;\n\t\t} else {\n\t\t\tvb->is_set = 1;\n\t\t\tGF_LSR_READ_INT(lsr, count, 1, \"escapeFlag\");\n\t\t\tcount = lsr_read_vluimsbf5(lsr, \"count\");\n\t\t\tif (count) {\n\t\t\t\tvb->x = lsr_read_fixed_16_8(lsr, \"val\");\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\tif (count) {\n\t\t\t\tvb->y = lsr_read_fixed_16_8(lsr, \"val\");\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\tif (count) {\n\t\t\t\tvb->width = lsr_read_fixed_16_8(lsr, \"val\");\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\tif (count) {\n\t\t\t\tvb->height = lsr_read_fixed_16_8(lsr, \"val\");\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\tcase XMLRI_datatype:\n\tcase SVG_Focus_datatype:\n\t\tif ((att_tag==TAG_XLINK_ATT_href) || (att_tag==TAG_SVG_ATT_syncReference)) {\n\t\t\tlsr_read_any_uri(lsr, (XMLRI*)val, \"val\");\n\t\t} else {\n\t\t\tBool is_escape;\n\t\t\tu32 ID;\n\t\t\tescape_val = ID = 0;\n\t\t\tis_escape = 0;\n\t\t\tGF_LSR_READ_INT(lsr, is_default, 1, \"isDefault\");\n\t\t\tif (!is_default) {\n\t\t\t\tGF_LSR_READ_INT(lsr, is_escape, 1, \"isEscape\");\n\t\t\t\tif (is_escape) {\n\t\t\t\t\tGF_LSR_READ_INT(lsr, escape_val, 2, \"escapeEnumVal\");\n\t\t\t\t} else {\n\t\t\t\t\tID = lsr_read_vluimsbf5(lsr, \"ID\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (att_tag==SVG_Focus_datatype) {\n\t\t\t\tif (is_default) ((SVG_Focus*)val)->type = SVG_FOCUS_AUTO;\n\t\t\t\telse if (is_escape) ((SVG_Focus*)val)->type = escape_val;\n\t\t\t\telse {\n\t\t\t\t\t((SVG_Focus*)val)->type = SVG_FOCUS_IRI;\n\t\t\t\t\t((SVG_Focus*)val)->target.type = XMLRI_ELEMENTID;\n\t\t\t\t\t((SVG_Focus*)val)->target.node_id = ID;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (is_default) ((XMLRI*)val)->type = XMLRI_STRING;\n\t\t\t\telse {\n\t\t\t\t\t((XMLRI *)val)->type = XMLRI_ELEMENTID;\n\t\t\t\t\t((XMLRI *)val)->node_id = ID;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase DOM_String_datatype:\n\tcase SVG_ContentType_datatype:\n\tcase SVG_LanguageID_datatype:\n\t\tlsr_read_byte_align_string(lsr, (char**)val, \"val\");\n\t\tbreak;\n\tcase SVG_Motion_datatype:\n\t\tlsr_read_coordinate(lsr, &num, 0, \"pointValueX\");\n\t\t((GF_Matrix2D*)val)->m[2] = num.value;\n\t\tlsr_read_coordinate(lsr, &num, 0, \"pointValueY\");\n\t\t((GF_Matrix2D*)val)->m[5] = num.value;\n\t\tbreak;\n\tcase SVG_Points_datatype:\n\t\tlsr_read_point_sequence(lsr, *(GF_List **)val, \"val\");\n\t\tbreak;\n\tcase SVG_PathData_datatype:\n\t\tlsr_read_path_type(lsr, NULL, 0, (SVG_PathData*)val, \"val\");\n\t\tbreak;\n\tcase SVG_FontFamily_datatype:\n\t{\n\t\tu32 idx;\n\t\tSVG_FontFamily *ff = (SVG_FontFamily *)val;\n\t\tGF_LSR_READ_INT(lsr, idx, 1, \"isDefault\");\n\t\tff->type = SVG_FONTFAMILY_INHERIT;\n\t\tif (!idx) {\n\t\t\tchar *ft;\n\t\t\tGF_LSR_READ_INT(lsr, idx, 1, \"escapeFlag\");\n\t\t\tidx = lsr_read_vluimsbf5(lsr, \"index\");\n\t\t\tif (ff->value) gf_free(ff->value);\n\t\t\tff->value = NULL;\n\t\t\tft = (char*)gf_list_get(lsr->font_table, idx);\n\t\t\tif (ft) {\n\t\t\t\tff->value = gf_strdup(ft);\n\t\t\t\tff->type = SVG_FONTFAMILY_VALUE;\n\t\t\t}\n\t\t}\n\t}\n\t\tbreak;\n\tcase LASeR_Choice_datatype:\n\t\tGF_LSR_READ_INT(lsr, is_default, 1, \"isDefaultValue\");\n\t\tif (is_default) ((LASeR_Choice *)val)->type = LASeR_CHOICE_ALL;\n\t\telse {\n\t\t\tGF_LSR_READ_INT(lsr, has_escape, 1, \"escapeFlag\");\n\t\t\tif (has_escape) {\n\t\t\t\tGF_LSR_READ_INT(lsr, escape_val, 2, \"escapeEnum\");\n\t\t\t\t((LASeR_Choice *)val)->type = escape_val ? LASeR_CHOICE_NONE : LASeR_CHOICE_ALL;\n\t\t\t} else {\n\t\t\t\t((LASeR_Choice *)val)->type = LASeR_CHOICE_N;\n\t\t\t\t((LASeR_Choice *)val)->choice_index = lsr_read_vluimsbf5(lsr, \"value\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif ((fieldType>=SVG_FillRule_datatype) && (fieldType<=SVG_LAST_U8_PROPERTY)) {\n\t\t\t/*TODO fixme, check inherit values*/\n\t\t\tGF_LSR_READ_INT(lsr, is_default, 1, \"isDefaultValue\");\n\t\t\tif (is_default) *(u8 *)val = 0;\n\t\t\telse *(u8 *)val = lsr_read_vluimsbf5(lsr, \"val\");\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[LASeR] Warning: update value not supported: fieldType %d - attribute tag %d\\n\", fieldType, att_tag));\n\t\t}\n\t}\n\tif (node) {\n\t\t//gf_node_dirty_set(node, 0, 0);\n\t\tgf_node_changed(node, NULL);\n\t}\n}\n\nstatic u32 lsr_get_attribute_name(GF_LASeRCodec *lsr)\n{\n\tu32 val = 1;\n\tGF_LSR_READ_INT(lsr, val, 1, \"has_attributeName\");\n\tif (!val) return -1;\n\n\tGF_LSR_READ_INT(lsr, val, 1, \"choice\");\n\tif (val) {\n\t\tlsr_read_vluimsbf5(lsr, \"item[i]\");\n\t\tlsr_read_vluimsbf5(lsr, \"item[i]\");\n\t\treturn -1;\n\t} else {\n\t\tGF_LSR_READ_INT(lsr, val, 8, \"attributeName\");\n\t\treturn val;\n\t}\n}\n\nstatic GF_Err lsr_read_add_replace_insert(GF_LASeRCodec *lsr, GF_List *com_list, u32 com_type)\n{\n\tGF_FieldInfo info;\n\tGF_Node *n, *operandNode;\n\tGF_Command *com;\n\tGF_CommandField *field;\n\ts32 idx, att_type, op_att_type;\n\tu32 type, idref, op_idref = 0;\n\n\toperandNode = NULL;\n\top_att_type = -1;\n\n\tatt_type = lsr_get_attribute_name(lsr);\n\n\tidx = -1;\n\tif (com_type) {\n\t\tGF_LSR_READ_INT(lsr, type, 1, \"has_index\");\n\t\tif (type) idx = lsr_read_vluimsbf5(lsr, \"index\");\n\t}\n\tif (com_type!=3) {\n\t\tGF_LSR_READ_INT(lsr, type, 1, \"has_operandAttribute\");\n\t\tif (type) GF_LSR_READ_INT(lsr, op_att_type, 8, \"attributeName\");\n\t\tGF_LSR_READ_INT(lsr, type, 1, \"has_operandElementId\");\n\t\tif (type) {\n\t\t\top_idref = lsr_read_codec_IDREF_command(lsr, \"operandElementId\");\n\t\t\toperandNode = gf_sg_find_node(lsr->sg, op_idref);\n\t\t\tif (!operandNode)\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t}\n\tidref = lsr_read_codec_IDREF_command(lsr, \"ref\");\n\n\tn = gf_sg_find_node(lsr->sg, idref);\n\tif (!n) {\n\t\tif (!com_list) {\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t}\n\n\tGF_LSR_READ_INT(lsr, type, 1, \"has_value\");\n\tif (type) {\n\t\t/*node or node-list replacement*/\n\t\tif (att_type==-2) {\n\t\t\tlsr_read_byte_align_string(lsr, NULL, \"anyXML\");\n\t\t}\n\t\telse if (att_type<0) {\n\t\t\tGF_Node *new_node;\n\t\t\tif (!com_type)\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tGF_LSR_READ_INT(lsr, type, 1, \"isInherit\");\n\t\t\tif (type)\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tif (idx==-1) {\n\t\t\t\tGF_LSR_READ_INT(lsr, type, 1, \"escapeFlag\");\n\t\t\t\tif (type)\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\n\t\t\tnew_node = lsr_read_update_content_model(lsr, (idx==-1) ? NULL : (SVG_Element *)n);\n\t\t\tif (com_list) {\n\t\t\t\tcom = gf_sg_command_new(lsr->sg, (com_type==3) ? GF_SG_LSR_INSERT : GF_SG_LSR_REPLACE);\n\t\t\t\tgf_list_add(com_list, com);\n\t\t\t\tif (n) {\n\t\t\t\t\tcom->node = n;\n\t\t\t\t\tgf_node_register(com->node, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tcom->RouteID = idref;\n\t\t\t\t\tgf_list_add(lsr->unresolved_commands, com);\n\t\t\t\t}\n\t\t\t\tfield = gf_sg_command_field_new(com);\n\t\t\t\tfield->pos = idx;\n\t\t\t\tfield->new_node = new_node;\n\t\t\t\tif (new_node) gf_node_register(new_node, NULL);\n\t\t\t} else if (com_type==3) {\n\t\t\t\tgf_node_list_insert_child(& ((SVG_Element *)n)->children, new_node, idx);\n\t\t\t\tif (new_node) gf_node_register(new_node, n);\n\t\t\t} else {\n\t\t\t\t/*child replacement*/\n\t\t\t\tif (idx!=-1) {\n\t\t\t\t\tGF_Node *old = gf_node_list_get_child( ((SVG_Element *)n)->children, idx);\n\t\t\t\t\tif (old)\n\t\t\t\t\t\tgf_node_replace(old, new_node, 0);\n\t\t\t\t\telse {\n\t\t\t\t\t\tgf_node_list_add_child( & ((SVG_Element *)n)->children, new_node);\n\t\t\t\t\t\tif (new_node) gf_node_register(new_node, n);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/*node replacement*/\n\t\t\t\t\tgf_node_replace(n, new_node, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*value replace/add*/\n\t\telse if (com_list) {\n\t\t\tu32 field_type;\n\t\t\tBool text_content = 0;\n\t\t\tcom = gf_sg_command_new(lsr->sg, (com_type==0) ? GF_SG_LSR_ADD : (com_type==3) ? GF_SG_LSR_INSERT : GF_SG_LSR_REPLACE);\n\t\t\tfield = gf_sg_command_field_new(com);\n\t\t\tfield->pos = idx;\n\t\t\tfield_type = 0;\n\t\t\tswitch (att_type) {\n\t\t\t/*text*/\n\t\t\tcase LSR_UPDATE_TYPE_TEXT_CONTENT:\n\t\t\t\ttext_content = 1;\n\t\t\t\tbreak;\n\t\t\t/*matrix.translation, scale or rotate*/\n\t\t\tcase LSR_UPDATE_TYPE_SCALE:\n\t\t\t\tfield->fieldType = field_type = SVG_Transform_Scale_datatype;\n\t\t\t\tfield->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);\n\t\t\t\tbreak;\n\t\t\tcase LSR_UPDATE_TYPE_ROTATE:\n\t\t\t\tfield->fieldType = field_type = SVG_Transform_Rotate_datatype;\n\t\t\t\tfield->fieldIndex = TAG_SVG_ATT_transform;\n\t\t\t\tbreak;\n\t\t\tcase LSR_UPDATE_TYPE_TRANSLATION:\n\t\t\t\tfield->fieldType = field_type = SVG_Transform_Translate_datatype;\n\t\t\t\tfield->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);\n\t\t\t\tbreak;\n\t\t\tcase LSR_UPDATE_TYPE_SVG_HEIGHT:\n\t\t\t\tfield->fieldIndex = TAG_SVG_ATT_height;\n\t\t\t\tfield_type = field->fieldType = SVG_Length_datatype;\n\t\t\t\tbreak;\n\t\t\tcase LSR_UPDATE_TYPE_SVG_WIDTH:\n\t\t\t\tfield->fieldIndex = TAG_SVG_ATT_width;\n\t\t\t\tfield_type = field->fieldType = SVG_Length_datatype;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfield->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);\n\t\t\t\tif (field->fieldIndex == (u32)-1) {\n\t\t\t\t\tlsr->last_error = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\tgf_sg_command_del(com);\n\t\t\t\t\treturn lsr->last_error;\n\t\t\t\t}\n\t\t\t\tfield_type = field->fieldType = gf_xml_get_attribute_type(field->fieldIndex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_list_add(com_list, com);\n\t\t\tif (n) {\n\t\t\t\tcom->node = n;\n\t\t\t\tgf_node_register(com->node, NULL);\n\t\t\t} else {\n\t\t\t\tcom->RouteID = idref;\n\t\t\t\tgf_list_add(lsr->unresolved_commands, com);\n\t\t\t}\n\t\t\tif (idx==-1) {\n\t\t\t\tif (text_content) {\n\t\t\t\t\tGF_DOMText *text = gf_dom_new_text_node(lsr->sg);\n\t\t\t\t\tgf_node_register((GF_Node *)text, NULL);\n\t\t\t\t\tlsr_read_byte_align_string(lsr, &text->textContent, \"val\");\n\t\t\t\t\tfield->new_node = (GF_Node*)text;\n\t\t\t\t} else {\n\t\t\t\t\tfield->field_ptr = gf_svg_create_attribute_value(field_type);\n\t\t\t\t\tlsr_read_update_value(lsr, NULL, field->fieldIndex, field->fieldType, field->field_ptr, n ? n->sgprivate->tag : 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfield->field_ptr = lsr_read_update_value_indexed(lsr, (GF_Node*)n, field_type, NULL, idx, com_type==LSR_UPDATE_INSERT, 1, &field->fieldType);\n\t\t\t}\n\t\t} else {\n\t\t\tGF_Point2D matrix_tmp;\n\t\t\tSVG_Point_Angle matrix_tmp_rot;\n\t\t\tu32 fieldIndex = 0;\n\t\t\tu32 field_type = 0;\n\t\t\tBool text_content = 0;\n\t\t\tBool is_lsr_transform = 0;\n\t\t\tswitch (att_type) {\n\t\t\t/*text*/\n\t\t\tcase LSR_UPDATE_TYPE_TEXT_CONTENT:\n\t\t\t\ttext_content = 1;\n\t\t\t\tbreak;\n\t\t\t/*matrix.translation, scale or rotate*/\n\t\t\tcase LSR_UPDATE_TYPE_SCALE:\n\t\t\t\tinfo.far_ptr = (void *)&matrix_tmp;\n\t\t\t\tfield_type = SVG_Transform_Scale_datatype;\n\t\t\t\tis_lsr_transform = 1;\n\t\t\t\tbreak;\n\t\t\tcase LSR_UPDATE_TYPE_ROTATE:\n\t\t\t\tinfo.far_ptr = (void *)&matrix_tmp_rot;\n\t\t\t\tfield_type = SVG_Transform_Rotate_datatype;\n\t\t\t\tis_lsr_transform = 1;\n\t\t\t\tbreak;\n\t\t\tcase LSR_UPDATE_TYPE_TRANSLATION:\n\t\t\t\tinfo.far_ptr = (void *)&matrix_tmp;\n\t\t\t\tfield_type = SVG_Transform_Translate_datatype;\n\t\t\t\tis_lsr_transform = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfieldIndex = gf_lsr_anim_type_to_attribute(att_type);\n\t\t\t\tgf_node_get_attribute_by_tag(n, fieldIndex, 1, 0, &info);\n\t\t\t\tfield_type = info.fieldType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo.fieldType = field_type;\n\t\t\tif (is_lsr_transform) {\n\t\t\t\tSVG_Transform *dest;\n\t\t\t\tif (idx==-1) {\n\t\t\t\t\tlsr_read_update_value(lsr, NULL, fieldIndex, field_type, info.far_ptr, 0);\n\t\t\t\t} else {\n\t\t\t\t\tassert(0);\n\t\t\t\t}\n\n\n//\t\t\t\tfieldIndex = gf_node_get_attribute_by_tag((GF_Node*)n, TAG_SVG_ATT_transform, 1, 1, &info);\n\t\t\t\tdest = (SVG_Transform *)info.far_ptr;\n\t\t\t\tif (com_type) {\n\t\t\t\t\tGF_Point2D scale, translate;\n\t\t\t\t\tSVG_Point_Angle rotate;\n\t\t\t\t\tif (gf_mx2d_decompose(&dest->mat, &scale, &rotate.angle, &translate)) {\n\t\t\t\t\t\tgf_mx2d_init(dest->mat);\n\t\t\t\t\t\tif (att_type==LSR_UPDATE_TYPE_SCALE) scale = matrix_tmp;\n\t\t\t\t\t\telse if (att_type==LSR_UPDATE_TYPE_TRANSLATION) translate = matrix_tmp;\n\t\t\t\t\t\telse if (att_type==LSR_UPDATE_TYPE_ROTATE) rotate = matrix_tmp_rot;\n\n\t\t\t\t\t\tgf_mx2d_add_scale(&dest->mat, scale.x, scale.y);\n\t\t\t\t\t\tgf_mx2d_add_rotation(&dest->mat, 0, 0, rotate.angle);\n\t\t\t\t\t\tgf_mx2d_add_translation(&dest->mat, translate.x, translate.y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (att_type==LSR_UPDATE_TYPE_SCALE) gf_mx2d_add_scale(&dest->mat, matrix_tmp.x, matrix_tmp.y);\n\t\t\t\telse if (att_type==LSR_UPDATE_TYPE_TRANSLATION) gf_mx2d_add_translation(&dest->mat, matrix_tmp.x, matrix_tmp.y);\n\t\t\t\telse if (att_type==LSR_UPDATE_TYPE_ROTATE) gf_mx2d_add_rotation(&dest->mat, 0, 0, matrix_tmp_rot.angle);\n\n\t\t\t\tgf_node_changed((GF_Node*)n, &info);\n\t\t\t}\n\t\t\telse if (com_type) {\n\t\t\t\tif (text_content) {\n\t\t\t\t\tGF_DOMText *t = NULL;\n\t\t\t\t\tif (idx>=0) {\n\t\t\t\t\t\tif (com_type==LSR_UPDATE_INSERT) {\n\t\t\t\t\t\t\tt = gf_dom_new_text_node(n->sgprivate->scenegraph);\n\t\t\t\t\t\t\tgf_node_register((GF_Node *)t, n);\n\t\t\t\t\t\t\tgf_node_list_insert_child(&((GF_ParentNode *)n)->children, (GF_Node*)t, idx);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tt = (GF_DOMText *) gf_node_list_get_child(((SVG_Element*)n)->children, idx);\n\t\t\t\t\t\t\tif (t->sgprivate->tag!=TAG_DOMText) t = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*this is a replace, reset ALL node content*/\n\t\t\t\t\t\tgf_sg_parent_reset(n);\n\t\t\t\t\t\tt = gf_dom_add_text_node(n, NULL);\n\t\t\t\t\t}\n\t\t\t\t\tlsr_read_byte_align_string(lsr, t ? &t->textContent : NULL, \"textContent\");\n\t\t\t\t\tgf_node_changed(n, NULL);\n\t\t\t\t} else if (idx==-1) {\n\t\t\t\t\tlsr_read_update_value(lsr, (GF_Node*)n, fieldIndex, field_type, info.far_ptr, n->sgprivate->tag);\n\t\t\t\t} else {\n\t\t\t\t\tFixed *v1, *v2;\n\t\t\t\t\t//SMIL_Time *t;\n\t\t\t\t\tvoid *prev, *new_item;\n\t\t\t\t\tvoid *tmp = lsr_read_update_value_indexed(lsr, (GF_Node*)n, field_type, info.far_ptr, idx, com_type==LSR_UPDATE_INSERT, 0, NULL);\n\t\t\t\t\tswitch (field_type) {\n\t\t\t\t\t/*generic GF_List containers, no type translation needed*/\n\t\t\t\t\tcase SMIL_KeyTimes_datatype/*ITYPE_keyTime*/:\n\t\t\t\t\tcase SMIL_KeySplines_datatype/*ITYPE_float*/:\n\t\t\t\t\tcase SVG_Points_datatype/*ITYPE_point*/:\n\t\t\t\t\tcase SMIL_Times_datatype/*ITYPE_smil_time*/:\n\t\t\t\t\t\tnew_item = gf_list_pop_front(*(GF_List **)tmp);\n\t\t\t\t\t\tif (com_type==LSR_UPDATE_INSERT) {\n\t\t\t\t\t\t\tgf_list_insert(*(SVG_Coordinates*)info.far_ptr, new_item, idx);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprev = gf_list_get(*(SVG_Coordinates*)info.far_ptr, idx);\n\t\t\t\t\t\t\tgf_free(prev);\n\t\t\t\t\t\t\tgf_list_rem(*(SVG_Coordinates*)info.far_ptr, idx);\n\t\t\t\t\t\t\tgf_list_insert(*(SVG_Coordinates*)info.far_ptr, new_item, idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_node_changed((GF_Node*)n, NULL);\n\t\t\t\t\t\tgf_list_del(*(GF_List **)tmp);\n\t\t\t\t\t\tgf_free(tmp);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/*list of floats - to check when implementing it...*/\n\t\t\t\t\tcase SMIL_KeyPoints_datatype/*ITYPE_0to1 - keyPoints*/:\n\t\t\t\t\t\tv1 = (Fixed *) gf_list_pop_front(*(GF_List **)tmp);\n\t\t\t\t\t\tv2 = (Fixed *) gf_list_pop_front(*(GF_List **)tmp);\n\t\t\t\t\t\tgf_list_del(*(GF_List **)tmp);\n\t\t\t\t\t\tgf_free(tmp);\n\n\t\t\t\t\t\tif (com_type==LSR_UPDATE_INSERT) {\n\t\t\t\t\t\t\tgf_list_insert(*(SVG_Coordinates*)info.far_ptr, v1, idx);\n\t\t\t\t\t\t\tgf_list_insert(*(SVG_Coordinates*)info.far_ptr, v2, idx+1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprev = gf_list_get(*(SVG_Coordinates*)info.far_ptr, idx);\n\t\t\t\t\t\t\tgf_free(prev);\n\t\t\t\t\t\t\tgf_list_rem(*(SVG_Coordinates*)info.far_ptr, idx);\n\t\t\t\t\t\t\tprev = gf_list_get(*(SVG_Coordinates*)info.far_ptr, idx);\n\t\t\t\t\t\t\tgf_free(prev);\n\t\t\t\t\t\t\tgf_list_rem(*(SVG_Coordinates*)info.far_ptr, idx);\n\t\t\t\t\t\t\tgf_list_insert(*(SVG_Coordinates*)info.far_ptr, v1, idx);\n\t\t\t\t\t\t\tgf_list_insert(*(SVG_Coordinates*)info.far_ptr, v2, idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_node_changed((GF_Node*)n, NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SVG_ViewBox_datatype:\n\t\t\t\t\t\tv1 = (Fixed*)tmp;\n\t\t\t\t\t\tswitch (idx) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t((SVG_ViewBox*)info.far_ptr)->x = *v1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t((SVG_ViewBox*)info.far_ptr)->y = *v1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t((SVG_ViewBox*)info.far_ptr)->width = *v1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t((SVG_ViewBox*)info.far_ptr)->height = *v1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_free(tmp);\n\t\t\t\t\t\tgf_node_changed((GF_Node*)n, NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SVG_StrokeDashArray_datatype:\n\t\t\t\t\t\tv1 = (Fixed*)tmp;\n\t\t\t\t\t\tif (com_type==LSR_UPDATE_INSERT) {\n\t\t\t\t\t\t\tSVG_StrokeDashArray*da = (SVG_StrokeDashArray*)info.far_ptr;\n\t\t\t\t\t\t\t/*use MFFloat for insert*/\n\t\t\t\t\t\t\tif (gf_sg_vrml_mf_insert(&da->array, GF_SG_VRML_MFFLOAT, (void*) &v2, idx)==GF_OK)\n\t\t\t\t\t\t\t\t*v2 = *v1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSVG_StrokeDashArray*da = (SVG_StrokeDashArray*)info.far_ptr;\n\t\t\t\t\t\t\tif (idx<(s32)da->array.count) da->array.vals[idx] = *v1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_free(tmp);\n\t\t\t\t\t\tgf_node_changed((GF_Node*)n, NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgf_free(tmp);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_FieldInfo tmp;\n\t\t\t\ttmp = info;\n\t\t\t\tif (idx==-1) {\n\t\t\t\t\ttmp.far_ptr = gf_svg_create_attribute_value(info.fieldType);\n\t\t\t\t\tlsr_read_update_value(lsr, n, fieldIndex, field_type, tmp.far_ptr, n->sgprivate->tag);\n\t\t\t\t} else {\n\t\t\t\t\ttmp.far_ptr = lsr_read_update_value_indexed(lsr, n, field_type, NULL, idx, 0, 1, NULL);\n\t\t\t\t}\n\t\t\t\tgf_svg_attributes_add(&info, &tmp, &info, 0);\n\t\t\t\tgf_svg_delete_attribute_value(info.fieldType, tmp.far_ptr, gf_node_get_graph(n));\n\t\t\t}\n\t\t}\n\t}\n\t/*copy from node*/\n\telse if (operandNode && (op_att_type>=0)) {\n\t\tu32 opFieldIndex = gf_lsr_anim_type_to_attribute(op_att_type);\n\t\tif (com_list) {\n\t\t\tcom = gf_sg_command_new(lsr->sg, com_type ? GF_SG_LSR_REPLACE : GF_SG_LSR_ADD);\n\t\t\tgf_list_add(com_list, com);\n\t\t\tcom->node = n;\n\t\t\tgf_node_register(com->node, NULL);\n\t\t\tcom->fromNodeID = op_idref;\n\t\t\tcom->fromFieldIndex = opFieldIndex;\n\t\t\tfield = gf_sg_command_field_new(com);\n\t\t\tfield->pos = idx;\n\t\t\tfield->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);\n\t\t} else {\n\t\t\tu32 fieldIndex;\n\t\t\tGF_FieldInfo op_info;\n\t\t\tfieldIndex = gf_lsr_anim_type_to_attribute(att_type);\n\t\t\tgf_node_get_field(n, fieldIndex, &info);\n\t\t\tgf_node_get_field(operandNode, opFieldIndex, &op_info);\n\t\t\tif (com_type) {\n\t\t\t\tgf_svg_attributes_copy(&info, &op_info, 0);\n\t\t\t} else {\n\t\t\t\tgf_svg_attributes_add(&info, &op_info, &info, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tlsr_read_any_attribute(lsr, NULL, 1);\n\n\t/*if not add*/\n\tif (!com_type) return GF_OK;\n\n\t/*list replacement*/\n\tGF_LSR_READ_INT(lsr, type, 1, \"opt_group\");\n\tif (type) {\n\n\t\tif (com_list) {\n\t\t\tu32 count;\n\t\t\tGF_ChildNodeItem *last = NULL;\n\n\t\t\tif (com_type==LSR_UPDATE_INSERT) count = 1;\n\t\t\telse count = lsr_read_vluimsbf5(lsr, \"count\");\n\n\t\t\tcom = gf_sg_command_new(lsr->sg, (com_type==LSR_UPDATE_REPLACE) ? GF_SG_LSR_REPLACE : GF_SG_LSR_INSERT);\n\t\t\tgf_list_add(com_list, com);\n\t\t\tcom->node = n;\n\t\t\tgf_node_register(com->node, NULL);\n\t\t\tfield = gf_sg_command_field_new(com);\n\t\t\tfield->pos = idx;\n\n\t\t\tif (!count && (att_type==LSR_UPDATE_TYPE_TEXT_CONTENT)) {\n\t\t\t\tfield->fieldIndex = -1;\n\t\t\t} else if (count==1) {\n\t\t\t\tfield->new_node = lsr_read_update_content_model(lsr, (SVG_Element *) n);\n\t\t\t\tgf_node_register(field->new_node, NULL);\n\t\t\t\tif (att_type>=0) field->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);\n\t\t\t} else {\n\t\t\t\tfield->fieldType = SVG_NodeList_datatype;\n\t\t\t\tfield->field_ptr = &field->node_list;\n\t\t\t\twhile (count) {\n\t\t\t\t\tGF_Node *new_node = lsr_read_update_content_model(lsr, (SVG_Element *) n);\n\t\t\t\t\tgf_node_register(new_node, NULL);\n\t\t\t\t\tgf_node_list_add_child_last(& field->node_list, new_node, &last);\n\t\t\t\t\tcount--;\n\t\t\t\t\tif (lsr->last_error) return lsr->last_error;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tSVG_Element*elt = (SVG_Element*)n;\n\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\tu32 count;\n\t\t\tif (com_type==LSR_UPDATE_INSERT) count = 1;\n\t\t\telse count = lsr_read_vluimsbf5(lsr, \"count\");\n\n\t\t\tif (com_type==LSR_UPDATE_REPLACE) {\n\t\t\t\tif (idx>=0) {\n\t\t\t\t\tGF_Node *new_node = gf_node_list_del_child_idx(&elt->children, idx);\n\t\t\t\t\tif (new_node) gf_node_unregister(new_node, n);\n\t\t\t\t} else {\n\t\t\t\t\tgf_node_unregister_children(n, elt->children);\n\t\t\t\t\telt->children = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((com_type==LSR_UPDATE_INSERT) || (gf_lsr_anim_type_to_attribute(att_type) == TAG_LSR_ATT_children)) {\n\t\t\t\twhile (count) {\n\t\t\t\t\tGF_Node *new_node = lsr_read_update_content_model(lsr, elt);\n\t\t\t\t\tif (new_node) {\n\t\t\t\t\t\tif (idx>=0) {\n\t\t\t\t\t\t\tgf_node_list_insert_child(&elt->children, new_node, idx);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_node_list_add_child_last(&elt->children, new_node, &last);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_node_register(new_node, n);\n\t\t\t\t\t}\n\t\t\t\t\tcount--;\n\t\t\t\t\tif (lsr->last_error) return lsr->last_error;\n\t\t\t\t}\n\t\t\t\tgf_node_changed(n, NULL);\n\t\t\t}\n\t\t\t/*node replacement*/\n\t\t\telse if ((att_type==-1) && (count==1)) {\n\t\t\t\tGF_Node *new_node = lsr_read_update_content_model(lsr, elt);\n\t\t\t\tgf_node_replace((GF_Node*)elt, new_node, 0);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err lsr_read_delete(GF_LASeRCodec *lsr, GF_List *com_list)\n{\n\tGF_FieldInfo info;\n\ts32 idx, att_type;\n\tu32 type, idref;\n\n\tatt_type = lsr_get_attribute_name(lsr);\n\n\tidx = -2;\n\tGF_LSR_READ_INT(lsr, type, 1, \"has_index\");\n\tif (type) idx = (s32) lsr_read_vluimsbf5(lsr, \"index\");\n\tidref = lsr_read_codec_IDREF_command(lsr, \"ref\");\n\n\tlsr_read_any_attribute(lsr, NULL, 1);\n\tif (com_list) {\n\t\tGF_Command *com;\n\t\tcom = gf_sg_command_new(lsr->sg, GF_SG_LSR_DELETE);\n\t\tgf_list_add(com_list, com);\n\t\tcom->node = gf_sg_find_node(lsr->sg, idref);\n\t\tif (!com->node) {\n\t\t\tcom->RouteID = idref;\n\t\t\tgf_list_add(lsr->unresolved_commands, com);\n\t\t} else {\n\t\t\tgf_node_register(com->node, NULL);\n\t\t}\n\n\t\tif ((idx>=0) || (att_type>=0)) {\n\t\t\tGF_CommandField *field = gf_sg_command_field_new(com);\n\t\t\tfield->pos = idx;\n\t\t\tif (att_type>=0) {\n\t\t\t\tfield->fieldIndex = gf_lsr_anim_type_to_attribute(att_type);\n\t\t\t\tif (!com->node) return GF_SG_UNKNOWN_NODE;\n\t\t\t\tgf_node_get_field(com->node, field->fieldIndex, &info);\n\t\t\t\tfield->fieldType = info.fieldType;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tSVG_Element *elt = (SVG_Element *) gf_sg_find_node(lsr->sg, idref);\n\t\tif (!elt)\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tif (att_type>=0) {\n\t\t\ts32 fieldIndex = gf_lsr_anim_type_to_attribute(att_type);\n\t\t\tgf_node_get_field((GF_Node*)elt, fieldIndex, &info);\n\t\t\t/*TODO implement*/\n\t\t}\n\t\t/*node deletion*/\n\t\telse if (idx>=0) {\n\t\t\tGF_Node *c = (GF_Node *)gf_node_list_get_child(elt->children, idx);\n\t\t\tif (c) {\n\t\t\t\tif (!gf_node_list_del_child( & elt->children, c))\n\t\t\t\t\treturn GF_IO_ERR;\n\t\t\t\tgf_node_unregister(c, (GF_Node*)elt);\n\t\t\t}\n\t\t} else {\n\t\t\tgf_node_replace((GF_Node*)elt, NULL, 0);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err lsr_read_send_event(GF_LASeRCodec *lsr, GF_List *com_list)\n{\n\tu32 flag, idref;\n\ts32 detail;\n\tSVG_Number x, y;\n\tXMLEV_Event event;\n\tlsr_read_event_type(lsr, &event);\n\n\tdetail = 0;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"has_intvalue\");\n\tif (flag) {\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"sign\");\n\t\tdetail = lsr_read_vluimsbf5(lsr, \"value\");\n\t\tif (flag) detail = -detail;\n\n\t\tswitch (event.type) {\n\t\tcase GF_EVENT_KEYDOWN:\n\t\tcase GF_EVENT_LONGKEYPRESS:\n\t\tcase GF_EVENT_REPEAT_KEY:\n\t\tcase GF_EVENT_SHORT_ACCESSKEY:\n\t\t\tdetail = lsr_to_dom_key(detail);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tx.value = y.value = 0;\n\tGF_LSR_READ_INT(lsr, flag, 1, \"has_pointvalue\");\n\tif (flag) {\n\t\tlsr_read_coordinate(lsr, &x, 0, \"x\");\n\t\tlsr_read_coordinate(lsr, &y, 0, \"y\");\n\t}\n\tidref = lsr_read_codec_IDREF_command(lsr, \"idref\");\n\n\tGF_LSR_READ_INT(lsr, flag, 1, \"has_pointvalue\");\n\tif (flag) {\n\t\tlsr_read_byte_align_string(lsr, NULL, \"string\");\n\t}\n\tlsr_read_any_attribute(lsr, NULL, 1);\n\n\tif (!com_list) {\n\t\tGF_DOM_Event evt;\n\t\tGF_Node *target = gf_sg_find_node(lsr->sg, idref);\n\t\tif (!target) return GF_OK;\n\n\t\tmemset(&evt, 0, sizeof(GF_DOM_Event));\n\t\tevt.type = event.type;\n\t\tevt.detail = detail ? detail : (s32) event.parameter;\n\t\tevt.clientX = FIX2INT(x.value);\n\t\tevt.clientY = FIX2INT(y.value);\n\t\tgf_dom_event_fire(target, &evt);\n\n\t} else {\n\t\tGF_Command *com = gf_sg_command_new(lsr->sg, GF_SG_LSR_SEND_EVENT);\n\t\tgf_list_add(com_list, com);\n\t\tcom->node = gf_sg_find_node(lsr->sg, idref);\n\t\tif (!com->node) {\n\t\t\tcom->RouteID = idref;\n\t\t\tgf_list_add(lsr->unresolved_commands, com);\n\t\t} else {\n\t\t\tgf_node_register(com->node, NULL);\n\t\t}\n\t\tcom->send_event_integer = detail ? detail : (s32) event.parameter;\n\t\tcom->send_event_name = event.type;\n\t\tcom->send_event_x = FIX2INT(x.value);\n\t\tcom->send_event_y = FIX2INT(y.value);\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err lsr_read_save(GF_LASeRCodec *lsr, GF_List *com_list)\n{\n\tu32 i, count;\n\tcount = lsr_read_vluimsbf5(lsr, \"nbIds\");\n\tfor (i=0; i<count; i++) {\n\t\tu32 flag;\n\t\tlsr_read_vluimsbf5(lsr, \"ref[[i]]\");\n\t\tGF_LSR_READ_INT(lsr, flag, 1, \"reserved\");\n\n\t\tlsr_get_attribute_name(lsr);\n\t\tif (lsr->last_error) return lsr->last_error;\n\t}\n\tlsr_read_byte_align_string(lsr, NULL, \"groupID\");\n\tlsr_read_any_attribute(lsr, NULL, 1);\n\treturn GF_OK;\n}\n\nstatic GF_Err lsr_read_restore(GF_LASeRCodec *lsr, GF_List *com_list)\n{\n\tlsr_read_byte_align_string(lsr, NULL, \"groupID\");\n\tlsr_read_any_attribute(lsr, NULL, 1);\n\treturn GF_OK;\n}\n\nvoid lsr_exec_command_list(GF_Node *node, void *par, Bool is_destroy)\n{\n\tGF_DOMUpdates *up = (GF_DOMUpdates *)node;\n\tGF_LASeRCodec *codec = (GF_LASeRCodec *)gf_node_get_private((GF_Node*)node);\n\n\tif (is_destroy || !up || (up->sgprivate->tag!=TAG_DOMUpdates)) return;\n\tassert(!codec->bs);\n\n\tcodec->info = lsr_get_stream(codec, 0);\n\tif (!codec->info) return;\n\tcodec->coord_bits = codec->info->cfg.coord_bits;\n\tcodec->scale_bits = codec->info->cfg.scale_bits_minus_coord_bits;\n\tcodec->time_resolution = codec->info->cfg.time_resolution;\n\tcodec->color_scale = (1<<codec->info->cfg.colorComponentBits) - 1;\n\tif (codec->info->cfg.resolution >= 0)\n\t\tcodec->res_factor = INT2FIX(1<<codec->info->cfg.resolution);\n\telse\n\t\tcodec->res_factor = gf_divfix(FIX_ONE, INT2FIX(1 << (-codec->info->cfg.resolution)) );\n\n\tcodec->bs = gf_bs_new(up->data, up->data_size, GF_BITSTREAM_READ);\n\tcodec->memory_dec = 0;\n\tlsr_read_command_list(codec, NULL, NULL, 0);\n\tgf_bs_del(codec->bs);\n\tcodec->bs = NULL;\n}\n\nstatic GF_Err lsr_read_command_list(GF_LASeRCodec *lsr, GF_List *com_list, SVG_Element *cond, Bool first_imp)\n{\n\tGF_Node *n;\n\tGF_Command *com;\n\tu32 i, type, count;\n\n\tif (cond) {\n\t\tu32 s_len;\n\t\tGF_DOMUpdates *up = gf_dom_add_updates_node((GF_Node*)cond);\n\t\tgf_node_set_callback_function((GF_Node*)up, lsr_exec_command_list);\n\t\tgf_node_set_private((GF_Node *) up, lsr);\n\n\t\ts_len = lsr_read_vluimsbf5(lsr, NULL/*\"encoding-length\" - don't log to avoid corrupting the log order!!*/);\n\t\tgf_bs_align(lsr->bs);\n\t\t/*not in memory mode, direct decode*/\n\t\tif (!lsr->memory_dec) {\n\t\t\tcom_list = NULL;\n\t\t\tup->data_size = s_len;\n\t\t\tup->data = (char*)gf_malloc(sizeof(char)*s_len);\n\t\t\tif (!up->data) {\n\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t} else {\n\t\t\t\tgf_bs_read_data(lsr->bs, up->data, s_len);\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\t\t/*memory mode, decode commands*/\n\t\telse {\n\t\t\tcom_list = up->updates;\n\t\t}\n\t}\n\tcount = lsr_read_vluimsbf5(lsr, \"occ0\");\n\tif (first_imp) count++;\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_LSR_READ_INT(lsr, type, 4, \"ch4\");\n\t\tswitch (type) {\n\t\tcase LSR_UPDATE_ADD:\n\t\tcase LSR_UPDATE_INSERT:\n\t\tcase LSR_UPDATE_REPLACE:\n\t\t\tlsr_read_add_replace_insert(lsr, com_list, type);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_DELETE:\n\t\t\tlsr_read_delete(lsr, com_list);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_NEW_SCENE:\n\t\tcase LSR_UPDATE_REFRESH_SCENE: /*TODO FIXME, depends on decoder state*/\n\t\t\tif (type==5) lsr_read_vluimsbf5(lsr, \"time\");\n\t\t\tlsr_read_any_attribute(lsr, NULL, 1);\n\t\t\tif (com_list) {\n\t\t\t\tn = lsr_read_svg(lsr, 0);\n\t\t\t\tif (!n)\n\t\t\t\t\treturn (lsr->last_error = GF_NON_COMPLIANT_BITSTREAM);\n\t\t\t\tgf_node_register(n, NULL);\n\t\t\t\tcom = gf_sg_command_new(lsr->sg, (type==5) ? GF_SG_LSR_REFRESH_SCENE : GF_SG_LSR_NEW_SCENE);\n\t\t\t\tcom->node = n;\n\t\t\t\tgf_list_add(com_list, com);\n\t\t\t} else {\n\t\t\t\tgf_sg_reset(lsr->sg);\n\t\t\t\tgf_sg_set_scene_size_info(lsr->sg, 0, 0, 1);\n\t\t\t\tn = lsr_read_svg(lsr, 1);\n\t\t\t\tif (!n)\n\t\t\t\t\treturn (lsr->last_error = GF_NON_COMPLIANT_BITSTREAM);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_TEXT_CONTENT:\n\t\t\tlsr_read_byte_align_string(lsr, NULL, \"textContent\");\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_SEND_EVENT:\n\t\t\tlsr_read_send_event(lsr, com_list);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_RESTORE:\n\t\t\tlsr_read_restore(lsr, com_list);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_SAVE:\n\t\t\tlsr_read_save(lsr, com_list);\n\t\t\tbreak;\n\t\tcase LSR_UPDATE_EXTEND:\n\t\t{\n\t\t\tu32 extID;\n\t\t\tGF_LSR_READ_INT(lsr, extID, lsr->info->cfg.extensionIDBits, \"extensionID\");\n\t\t\t/*len = */lsr_read_vluimsbf5(lsr, \"len\");\n\t\t\tif (extID==2) {\n\t\t\t\tu32 j, sub_count;\n\t\t\t\tlsr_read_vluimsbf5(lsr, \"reserved\");\n\t\t\t\tsub_count = lsr_read_vluimsbf5(lsr, \"occ2\");\n\t\t\t\tfor (j=0; j<sub_count; j++) {\n\t\t\t\t\tu32 k, occ3;\n\t\t\t\t\tGF_LSR_READ_INT(lsr, k, 2, \"reserved\");\n\t\t\t\t\tocc3 = lsr_read_vluimsbf5(lsr, \"occ3\");\n\t\t\t\t\tfor (k=0; k<occ3; k++) {\n\t\t\t\t\t\tu32 sub_type, idref;\n\t\t\t\t\t\tGF_LSR_READ_INT(lsr, sub_type, 2, \"ch5\");\n\t\t\t\t\t\tswitch (sub_type) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tidref = lsr_read_codec_IDREF_command(lsr, \"ref\");\n\n\t\t\t\t\t\t\tn = gf_sg_find_node(lsr->sg, idref);\n\t\t\t\t\t\t\tif (com_list) {\n\t\t\t\t\t\t\t\tcom = gf_sg_command_new(lsr->sg, (sub_type==1) ? GF_SG_LSR_ACTIVATE : GF_SG_LSR_DEACTIVATE);\n\t\t\t\t\t\t\t\tif (n) {\n\t\t\t\t\t\t\t\t\tcom->node = n;\n\t\t\t\t\t\t\t\t\tgf_node_register(n, NULL);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcom->RouteID = idref;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgf_list_add(com_list, com);\n\t\t\t\t\t\t\t} else if (sub_type==1) {\n\t\t\t\t\t\t\t\tif (!n) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\t\t\tgf_node_activate(n);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (!n) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\t\t\tgf_node_deactivate(n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tlsr_read_private_element_container(lsr);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (lsr->last_error) return lsr->last_error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\treturn (lsr->last_error = GF_NON_COMPLIANT_BITSTREAM);\n\t\t}\n\t\t/*same-coding scope is command-based (to check in the spec)*/\n\t\tif (cond) {\n\t\t\tlsr->prev_g = NULL;\n\t\t\tlsr->prev_line = NULL;\n\t\t\tlsr->prev_path = NULL;\n\t\t\tlsr->prev_polygon = NULL;\n\t\t\tlsr->prev_rect = NULL;\n\t\t\tlsr->prev_text = NULL;\n\t\t\tlsr->prev_use = NULL;\n\t\t}\n\n\t\tif (lsr->last_error)\n\t\t\treturn lsr->last_error;\n\t}\nexit:\n\t/*script is align*/\n\tif (cond) {\n\t\tgf_bs_align(lsr->bs);\n\t\tlsr_read_object_content(lsr, (SVG_Element*)cond);\n\t\tlsr->prev_g = NULL;\n\t\tlsr->prev_line = NULL;\n\t\tlsr->prev_path = NULL;\n\t\tlsr->prev_polygon = NULL;\n\t\tlsr->prev_rect = NULL;\n\t\tlsr->prev_text = NULL;\n\t\tlsr->prev_use = NULL;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err lsr_decode_laser_unit(GF_LASeRCodec *lsr, GF_List *com_list)\n{\n\tGF_Err e;\n\tBool reset_encoding_context;\n\tu32 flag, i, count = 0, privateDataIdentifierIndexBits;\n\n\tlsr->last_error = GF_OK;\n\n\t/*\n\t *\t1 - laser unit header\n\t */\n\tGF_LSR_READ_INT(lsr, reset_encoding_context, 1, \"resetEncodingContext\");\n\tGF_LSR_READ_INT(lsr, flag, 1, \"opt_group\");\n\tif (flag) lsr_read_extension(lsr, \"ext\");\n\n\t/*clean all tables*/\n\tif (reset_encoding_context) {\n\t\tlsr->nb_cols = 0;\n\t\tif (lsr->col_table) gf_free(lsr->col_table);\n\t\tlsr->col_table = NULL;\n\t\twhile (gf_list_count(lsr->font_table)) {\n\t\t\tchar *ft = (char *)gf_list_last(lsr->font_table);\n\t\t\tgf_free(ft);\n\t\t\tgf_list_rem_last(lsr->font_table);\n\t\t}\n\t\tlsr->privateData_id_index = lsr->privateTag_index = 0;\n\t}\n\n\t/*\n\t *\t2 - codecInitialisations\n\t */\n\n\t/*\n\t * 2.a - condecInitialization.color\n\t */\n\tGF_LSR_READ_INT(lsr, flag, 1, \"colorInitialisation\");\n\n\tif (flag) {\n\t\tcount = lsr_read_vluimsbf5(lsr, \"count\");\n\t\tif (count>gf_bs_available(lsr->bs)) return lsr->last_error = GF_NON_COMPLIANT_BITSTREAM;\n\t\tlsr->col_table = (LSRCol*)gf_realloc(lsr->col_table, sizeof(LSRCol)*(lsr->nb_cols+count));\n\t\tif (!lsr->col_table)\n\t\t\treturn lsr->last_error = GF_OUT_OF_MEM;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tLSRCol c;\n\t\t\tGF_LSR_READ_INT(lsr, c.r, lsr->info->cfg.colorComponentBits, \"red\");\n\t\t\tGF_LSR_READ_INT(lsr, c.g, lsr->info->cfg.colorComponentBits, \"green\");\n\t\t\tGF_LSR_READ_INT(lsr, c.b, lsr->info->cfg.colorComponentBits, \"blue\");\n\t\t\tlsr->col_table[lsr->nb_cols+i] = c;\n\t\t\tif (lsr->last_error) return lsr->last_error;\n\t\t}\n\t\tlsr->nb_cols += count;\n\t}\n\tlsr->colorIndexBits = gf_get_bit_size(lsr->nb_cols);\n\t/*\n\t * 2.b - condecInitialization.fonts\n\t */\n\tGF_LSR_READ_INT(lsr, flag, 1, \"fontInitialisation\");\n\tcount = 0;\n\tif (flag) {\n\t\tcount = lsr_read_vluimsbf5(lsr, \"count\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\tchar *ft = NULL;\n\t\t\tlsr_read_byte_align_string(lsr, &ft, \"font\");\n\t\t\tgf_list_add(lsr->font_table, ft);\n\t\t\tif (lsr->last_error) return lsr->last_error;\n\t\t}\n\t}\n\tlsr->fontIndexBits = gf_get_bit_size(count);\n\t/*\n\t * 2.c - condecInitialization.private\n\t */\n\tGF_LSR_READ_INT(lsr, flag, 1, \"privateDataIdentifierInitialisation\");\n\n\tif (flag) {\n\t\tcount = lsr_read_vluimsbf5(lsr, \"nbPrivateDataIdentifiers\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\tlsr->privateData_id_index++;\n\t\t\tlsr_read_byte_align_string(lsr, NULL, \"privateDataIdentifier\");\n\t\t\tif (lsr->last_error) return lsr->last_error;\n\t\t}\n\t}\n\t/*\n\t * 2.d - condecInitialization.anyXML\n\t */\n\tGF_LSR_READ_INT(lsr, flag, 1, \"anyXMLInitialisation\");\n\n\tif (flag) {\n\t\tprivateDataIdentifierIndexBits = gf_get_bit_size(lsr->privateData_id_index);\n\t\tcount = lsr_read_vluimsbf5(lsr, \"nbTags\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\tlsr->privateTag_index++;\n\t\t\tif (i) {\n\t\t\t\t/* uint(privateDataIdentifierIndexBits) = */\n\t\t\t\tGF_LSR_READ_INT(lsr, flag, privateDataIdentifierIndexBits, \"privateDataIdentifierIndex\");\n\t\t\t\tlsr_read_byte_align_string(lsr, NULL, \"tag\");\n\t\t\t}\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"hasAttrs\");\n\t\t\tif (flag) {\n\t\t\t\tu32 k, c2 = lsr_read_vluimsbf5(lsr, \"nbAttrNames\");\n\t\t\t\tfor (k=0; k<c2; k++) {\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\t/* uint(privateDataIdentifierIndexBits) = */\n\t\t\t\t\t\tGF_LSR_READ_INT(lsr, flag, privateDataIdentifierIndexBits, \"privateDataIdentifierIndex\");\n\t\t\t\t\t}\n\t\t\t\t\tlsr_read_byte_align_string(lsr, NULL, \"tag\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lsr->last_error) return lsr->last_error;\n\t\t}\n\t}\n\t/*\n\t * 2.e - condecInitialization.extension\n\t */\n\tcount = lsr_read_vluimsbf5(lsr, \"countG\");\n\tfor (i=0; i<count; i++) {\n\t\t/*u32 locID = */lsr_read_vluimsbf5(lsr, \"binaryIdForThisStringID\");\n\t\tlsr_read_byte_align_string(lsr, NULL, \"stringID\");\n\t\tif (lsr->last_error) return lsr->last_error;\n\t}\n\tGF_LSR_READ_INT(lsr, flag, 1, \"hasExtension\");\n\tif (flag) {\n\t\tu32 len = lsr_read_vluimsbf5(lsr, \"len\");\n\t\tu32 pos = gf_bs_get_bit_offset(lsr->bs);\n\n\t\tcount = lsr_read_vluimsbf5(lsr, \"len\");\n\t\tfor (i=0; i<count; i++) {\n\t\t\t/*u32 locID = */lsr_read_vluimsbf5(lsr, \"localStreamIdForThisGlobal\");\n\t\t\tlsr_read_byte_align_string(lsr, NULL, \"globalName\");\n\t\t\tif (lsr->last_error) return lsr->last_error;\n\t\t}\n\t\tpos = gf_bs_get_bit_offset(lsr->bs) - pos;\n\t\tif (len<pos)\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tGF_LSR_READ_INT(lsr, flag, pos, \"remainingData\");\n\t}\n\n\te = lsr_read_command_list(lsr, com_list, NULL, 1);\n\tGF_LSR_READ_INT(lsr, flag, 1, \"opt_group\");\n\tif (flag) lsr_read_extension(lsr, \"ext\");\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_LASER*/\n"], "filenames": ["src/laser/lsr_dec.c"], "buggy_code_start_loc": [840], "buggy_code_end_loc": [840], "fixing_code_start_loc": [841], "fixing_code_end_loc": [843], "type": "CWE-190", "message": "Integer Overflow or Wraparound in GitHub repository gpac/gpac prior to 2.1-DEV.", "other": {"cve": {"id": "CVE-2022-2454", "sourceIdentifier": "security@huntr.dev", "published": "2022-07-19T14:15:08.710", "lastModified": "2023-05-27T04:15:21.350", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer Overflow or Wraparound in GitHub repository gpac/gpac prior to 2.1-DEV."}, {"lang": "es", "value": "Un Desbordamiento de Enteros o Wraparound en el repositorio de GitHub gpac/gpac versiones anteriores a 2.1-DEV."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0.0", "matchCriteriaId": "6FDA7EFB-AFD8-40D1-B517-04A825BC302A"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/faa75edde3dfeba1e2cf6ffa48e45a50f1042096", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/105d40d0-46d7-461e-9f8e-20c4cdea925f", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/faa75edde3dfeba1e2cf6ffa48e45a50f1042096"}}