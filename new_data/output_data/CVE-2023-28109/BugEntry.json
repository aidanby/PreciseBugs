{"buggy_code": ["package handlers\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"embed\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"io/fs\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"path\"\n\t\"strings\"\n\t\"time\"\n\n\t\"golang.org/x/crypto/acme/autocert\"\n\t\"golang.org/x/oauth2\"\n\n\tgh \"github.com/gorilla/handlers\"\n\t\"github.com/gorilla/mux\"\n\tlru \"github.com/hashicorp/golang-lru\"\n\t\"github.com/play-with-docker/play-with-docker/config\"\n\t\"github.com/play-with-docker/play-with-docker/event\"\n\t\"github.com/play-with-docker/play-with-docker/pwd\"\n\t\"github.com/play-with-docker/play-with-docker/pwd/types\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\t\"github.com/urfave/negroni\"\n\toauth2Github \"golang.org/x/oauth2/github\"\n\toauth2Google \"golang.org/x/oauth2/google\"\n\t\"google.golang.org/api/people/v1\"\n)\n\nvar (\n\tcore     pwd.PWDApi\n\te        event.EventApi\n\tlandings = map[string][]byte{}\n)\n\n//go:embed www/*\nvar embeddedFiles embed.FS\n\nvar staticFiles fs.FS\n\nvar latencyHistogramVec = prometheus.NewHistogramVec(prometheus.HistogramOpts{\n\tName:    \"pwd_handlers_duration_ms\",\n\tHelp:    \"How long it took to process a specific handler, in a specific host\",\n\tBuckets: []float64{300, 1200, 5000},\n}, []string{\"action\"})\n\ntype HandlerExtender func(h *mux.Router)\n\nfunc init() {\n\tprometheus.MustRegister(latencyHistogramVec)\n\tstaticFiles, _ = fs.Sub(embeddedFiles, \"www\")\n}\n\nfunc Bootstrap(c pwd.PWDApi, ev event.EventApi) {\n\tcore = c\n\te = ev\n}\n\nfunc Register(extend HandlerExtender) {\n\tinitPlaygrounds()\n\n\tr := mux.NewRouter()\n\tcorsRouter := mux.NewRouter()\n\n\tcorsHandler := gh.CORS(gh.AllowCredentials(), gh.AllowedHeaders([]string{\"x-requested-with\", \"content-type\"}), gh.AllowedMethods([]string{\"GET\", \"POST\", \"HEAD\", \"DELETE\"}), gh.AllowedOriginValidator(func(origin string) bool {\n\t\tif strings.Contains(origin, \"localhost\") ||\n\t\t\tstrings.HasSuffix(origin, \"play-with-docker.com\") ||\n\t\t\tstrings.HasSuffix(origin, \"play-with-kubernetes.com\") ||\n\t\t\tstrings.HasSuffix(origin, \"docker.com\") ||\n\t\t\tstrings.HasSuffix(origin, \"play-with-go.dev\") {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}), gh.AllowedOrigins([]string{}))\n\n\t// Specific routes\n\tr.HandleFunc(\"/ping\", Ping).Methods(\"GET\")\n\tcorsRouter.HandleFunc(\"/instances/images\", GetInstanceImages).Methods(\"GET\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}\", GetSession).Methods(\"GET\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}/close\", CloseSession).Methods(\"POST\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}\", CloseSession).Methods(\"DELETE\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}/setup\", SessionSetup).Methods(\"POST\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}/instances\", NewInstance).Methods(\"POST\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}/instances/{instanceName}/uploads\", FileUpload).Methods(\"POST\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}/instances/{instanceName}\", DeleteInstance).Methods(\"DELETE\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}/instances/{instanceName}/exec\", Exec).Methods(\"POST\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}/instances/{instanceName}/fstree\", fsTree).Methods(\"GET\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}/instances/{instanceName}/file\", file).Methods(\"GET\")\n\n\tr.HandleFunc(\"/sessions/{sessionId}/instances/{instanceName}/editor\", func(rw http.ResponseWriter, r *http.Request) {\n\t\tserveAsset(rw, r, \"editor.html\")\n\t})\n\n\tr.HandleFunc(\"/ooc\", func(rw http.ResponseWriter, r *http.Request) {\n\t\tserveAsset(rw, r, \"ooc.html\")\n\t}).Methods(\"GET\")\n\tr.HandleFunc(\"/503\", func(rw http.ResponseWriter, r *http.Request) {\n\t\tserveAsset(rw, r, \"503.html\")\n\t}).Methods(\"GET\")\n\tr.HandleFunc(\"/p/{sessionId}\", Home).Methods(\"GET\")\n\tr.PathPrefix(\"/assets\").HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {\n\t\tserveAsset(rw, r, r.URL.Path[1:])\n\t})\n\tr.HandleFunc(\"/robots.txt\", func(rw http.ResponseWriter, r *http.Request) {\n\t\tserveAsset(rw, r, \"robots.txt\")\n\t})\n\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}/ws/\", WSH)\n\tr.Handle(\"/metrics\", promhttp.Handler())\n\n\t// Generic routes\n\tr.HandleFunc(\"/\", Landing).Methods(\"GET\")\n\n\tcorsRouter.HandleFunc(\"/users/me\", LoggedInUser).Methods(\"GET\")\n\tr.HandleFunc(\"/users/{userId:.{3,}}\", GetUser).Methods(\"GET\")\n\tr.HandleFunc(\"/oauth/providers\", ListProviders).Methods(\"GET\")\n\tr.HandleFunc(\"/oauth/providers/{provider}/login\", Login).Methods(\"GET\")\n\tr.HandleFunc(\"/oauth/providers/{provider}/callback\", LoginCallback).Methods(\"GET\")\n\tr.HandleFunc(\"/playgrounds\", NewPlayground).Methods(\"PUT\")\n\tr.HandleFunc(\"/playgrounds\", ListPlaygrounds).Methods(\"GET\")\n\tr.HandleFunc(\"/my/playground\", GetCurrentPlayground).Methods(\"GET\")\n\n\tcorsRouter.HandleFunc(\"/\", NewSession).Methods(\"POST\")\n\n\tif extend != nil {\n\t\textend(corsRouter)\n\t}\n\n\tn := negroni.Classic()\n\n\tr.PathPrefix(\"/\").Handler(negroni.New(negroni.Wrap(corsHandler(corsRouter))))\n\tn.UseHandler(r)\n\n\thttpServer := http.Server{\n\t\tAddr:              \"0.0.0.0:\" + config.PortNumber,\n\t\tHandler:           n,\n\t\tIdleTimeout:       30 * time.Second,\n\t\tReadHeaderTimeout: 5 * time.Second,\n\t}\n\n\tif config.UseLetsEncrypt {\n\t\tdomainCache, err := lru.New(5000)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Could not start domain cache. Got: %v\", err)\n\t\t}\n\t\tcertManager := autocert.Manager{\n\t\t\tPrompt: autocert.AcceptTOS,\n\t\t\tHostPolicy: func(ctx context.Context, host string) error {\n\t\t\t\tif _, found := domainCache.Get(host); !found {\n\t\t\t\t\tif playground := core.PlaygroundFindByDomain(host); playground == nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"Playground for domain %s was not found\", host)\n\t\t\t\t\t}\n\t\t\t\t\tdomainCache.Add(host, true)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tCache: autocert.DirCache(config.LetsEncryptCertsDir),\n\t\t}\n\n\t\thttpServer.TLSConfig = &tls.Config{\n\t\t\tGetCertificate: certManager.GetCertificate,\n\t\t}\n\n\t\tgo func() {\n\t\t\trr := mux.NewRouter()\n\t\t\trr.HandleFunc(\"/ping\", Ping).Methods(\"GET\")\n\t\t\trr.Handle(\"/metrics\", promhttp.Handler())\n\t\t\trr.HandleFunc(\"/\", func(rw http.ResponseWriter, r *http.Request) {\n\t\t\t\ttarget := fmt.Sprintf(\"https://%s%s\", r.Host, r.URL.Path)\n\t\t\t\tif len(r.URL.RawQuery) > 0 {\n\t\t\t\t\ttarget += \"?\" + r.URL.RawQuery\n\t\t\t\t}\n\t\t\t\thttp.Redirect(rw, r, target, http.StatusMovedPermanently)\n\t\t\t})\n\t\t\tnr := negroni.Classic()\n\t\t\tnr.UseHandler(rr)\n\t\t\tlog.Println(\"Starting redirect server\")\n\t\t\tredirectServer := http.Server{\n\t\t\t\tAddr:              \"0.0.0.0:3001\",\n\t\t\t\tHandler:           certManager.HTTPHandler(nr),\n\t\t\t\tIdleTimeout:       30 * time.Second,\n\t\t\t\tReadHeaderTimeout: 5 * time.Second,\n\t\t\t}\n\t\t\tlog.Fatal(redirectServer.ListenAndServe())\n\t\t}()\n\n\t\tlog.Println(\"Listening on port \" + config.PortNumber)\n\t\tlog.Fatal(httpServer.ListenAndServeTLS(\"\", \"\"))\n\t} else {\n\t\tlog.Println(\"Listening on port \" + config.PortNumber)\n\t\tlog.Fatal(httpServer.ListenAndServe())\n\t}\n}\n\nfunc serveAsset(w http.ResponseWriter, r *http.Request, name string) {\n\ta, err := fs.ReadFile(staticFiles, name)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\thttp.ServeContent(w, r, name, time.Time{}, bytes.NewReader(a))\n}\n\nfunc initPlaygrounds() {\n\tpgs, err := core.PlaygroundList()\n\tif err != nil {\n\t\tlog.Fatal(\"Error getting playgrounds for initialization\")\n\t}\n\n\tfor _, p := range pgs {\n\t\tinitAssets(p)\n\t\tinitOauthProviders(p)\n\t}\n}\n\nfunc initAssets(p *types.Playground) {\n\tif p.AssetsDir == \"\" {\n\t\tp.AssetsDir = \"default\"\n\t}\n\n\tlpath := path.Join(p.AssetsDir, \"landing.html\")\n\tlanding, err := fs.ReadFile(staticFiles, lpath)\n\tif err != nil {\n\t\tlog.Printf(\"Could not load %v: %v\", lpath, err)\n\t\treturn\n\t}\n\n\tvar b bytes.Buffer\n\tt := template.New(\"landing.html\").Delims(\"[[\", \"]]\")\n\tt, err = t.Parse(string(landing))\n\tif err != nil {\n\t\tlog.Fatalf(\"Error parsing template %v\", err)\n\t}\n\tif err := t.Execute(&b, struct{ SegmentId string }{config.SegmentId}); err != nil {\n\t\tlog.Fatalf(\"Error executing template %v\", err)\n\t}\n\tlandingBytes, err := ioutil.ReadAll(&b)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error reading template bytes %v\", err)\n\t}\n\tlandings[p.Id] = landingBytes\n}\n\nfunc initOauthProviders(p *types.Playground) {\n\tconfig.Providers[p.Id] = map[string]*oauth2.Config{}\n\n\tif p.GithubClientID != \"\" && p.GithubClientSecret != \"\" {\n\t\tconf := &oauth2.Config{\n\t\t\tClientID:     p.GithubClientID,\n\t\t\tClientSecret: p.GithubClientSecret,\n\t\t\tScopes:       []string{\"user:email\"},\n\t\t\tEndpoint:     oauth2Github.Endpoint,\n\t\t}\n\n\t\tconfig.Providers[p.Id][\"github\"] = conf\n\t}\n\tif p.GoogleClientID != \"\" && p.GoogleClientSecret != \"\" {\n\t\tconf := &oauth2.Config{\n\t\t\tClientID:     p.GoogleClientID,\n\t\t\tClientSecret: p.GoogleClientSecret,\n\t\t\tScopes:       []string{people.UserinfoEmailScope, people.UserinfoProfileScope},\n\t\t\tEndpoint:     oauth2Google.Endpoint,\n\t\t}\n\n\t\tconfig.Providers[p.Id][\"google\"] = conf\n\t}\n\tif p.DockerClientID != \"\" && p.DockerClientSecret != \"\" {\n\n\t\tendpoint := getDockerEndpoint(p)\n\t\tconf := &oauth2.Config{\n\t\t\tClientID:     p.DockerClientID,\n\t\t\tClientSecret: p.DockerClientSecret,\n\t\t\tScopes:       []string{\"openid\"},\n\t\t\tEndpoint: oauth2.Endpoint{\n\t\t\t\tAuthURL:  fmt.Sprintf(\"https://%s/authorize/\", endpoint),\n\t\t\t\tTokenURL: fmt.Sprintf(\"https://%s/oauth/token\", endpoint),\n\t\t\t},\n\t\t}\n\n\t\tconfig.Providers[p.Id][\"docker\"] = conf\n\t}\n}\n"], "fixing_code": ["package handlers\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"embed\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"io/fs\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"path\"\n\t\"strings\"\n\t\"time\"\n\n\t\"golang.org/x/crypto/acme/autocert\"\n\t\"golang.org/x/oauth2\"\n\n\tgh \"github.com/gorilla/handlers\"\n\t\"github.com/gorilla/mux\"\n\tlru \"github.com/hashicorp/golang-lru\"\n\t\"github.com/play-with-docker/play-with-docker/config\"\n\t\"github.com/play-with-docker/play-with-docker/event\"\n\t\"github.com/play-with-docker/play-with-docker/pwd\"\n\t\"github.com/play-with-docker/play-with-docker/pwd/types\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\t\"github.com/urfave/negroni\"\n\toauth2Github \"golang.org/x/oauth2/github\"\n\toauth2Google \"golang.org/x/oauth2/google\"\n\t\"google.golang.org/api/people/v1\"\n)\n\nvar (\n\tcore     pwd.PWDApi\n\te        event.EventApi\n\tlandings = map[string][]byte{}\n)\n\n//go:embed www/*\nvar embeddedFiles embed.FS\n\nvar staticFiles fs.FS\n\nvar latencyHistogramVec = prometheus.NewHistogramVec(prometheus.HistogramOpts{\n\tName:    \"pwd_handlers_duration_ms\",\n\tHelp:    \"How long it took to process a specific handler, in a specific host\",\n\tBuckets: []float64{300, 1200, 5000},\n}, []string{\"action\"})\n\ntype HandlerExtender func(h *mux.Router)\n\nfunc init() {\n\tprometheus.MustRegister(latencyHistogramVec)\n\tstaticFiles, _ = fs.Sub(embeddedFiles, \"www\")\n}\n\nfunc Bootstrap(c pwd.PWDApi, ev event.EventApi) {\n\tcore = c\n\te = ev\n}\n\nfunc Register(extend HandlerExtender) {\n\tinitPlaygrounds()\n\n\tr := mux.NewRouter()\n\tcorsRouter := mux.NewRouter()\n\n\tcorsHandler := gh.CORS(gh.AllowCredentials(), gh.AllowedHeaders([]string{\"x-requested-with\", \"content-type\"}), gh.AllowedMethods([]string{\"GET\", \"POST\", \"HEAD\", \"DELETE\"}), gh.AllowedOriginValidator(func(origin string) bool {\n\t\tif strings.Contains(origin, \"localhost\") ||\n\t\t\tstrings.HasSuffix(origin, \".play-with-docker.com\") ||\n\t\t\tstrings.HasSuffix(origin, \".play-with-kubernetes.com\") ||\n\t\t\tstrings.HasSuffix(origin, \".docker.com\") ||\n\t\t\tstrings.HasSuffix(origin, \".play-with-go.dev\") {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}), gh.AllowedOrigins([]string{}))\n\n\t// Specific routes\n\tr.HandleFunc(\"/ping\", Ping).Methods(\"GET\")\n\tcorsRouter.HandleFunc(\"/instances/images\", GetInstanceImages).Methods(\"GET\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}\", GetSession).Methods(\"GET\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}/close\", CloseSession).Methods(\"POST\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}\", CloseSession).Methods(\"DELETE\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}/setup\", SessionSetup).Methods(\"POST\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}/instances\", NewInstance).Methods(\"POST\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}/instances/{instanceName}/uploads\", FileUpload).Methods(\"POST\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}/instances/{instanceName}\", DeleteInstance).Methods(\"DELETE\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}/instances/{instanceName}/exec\", Exec).Methods(\"POST\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}/instances/{instanceName}/fstree\", fsTree).Methods(\"GET\")\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}/instances/{instanceName}/file\", file).Methods(\"GET\")\n\n\tr.HandleFunc(\"/sessions/{sessionId}/instances/{instanceName}/editor\", func(rw http.ResponseWriter, r *http.Request) {\n\t\tserveAsset(rw, r, \"editor.html\")\n\t})\n\n\tr.HandleFunc(\"/ooc\", func(rw http.ResponseWriter, r *http.Request) {\n\t\tserveAsset(rw, r, \"ooc.html\")\n\t}).Methods(\"GET\")\n\tr.HandleFunc(\"/503\", func(rw http.ResponseWriter, r *http.Request) {\n\t\tserveAsset(rw, r, \"503.html\")\n\t}).Methods(\"GET\")\n\tr.HandleFunc(\"/p/{sessionId}\", Home).Methods(\"GET\")\n\tr.PathPrefix(\"/assets\").HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {\n\t\tserveAsset(rw, r, r.URL.Path[1:])\n\t})\n\tr.HandleFunc(\"/robots.txt\", func(rw http.ResponseWriter, r *http.Request) {\n\t\tserveAsset(rw, r, \"robots.txt\")\n\t})\n\n\tcorsRouter.HandleFunc(\"/sessions/{sessionId}/ws/\", WSH)\n\tr.Handle(\"/metrics\", promhttp.Handler())\n\n\t// Generic routes\n\tr.HandleFunc(\"/\", Landing).Methods(\"GET\")\n\n\tcorsRouter.HandleFunc(\"/users/me\", LoggedInUser).Methods(\"GET\")\n\tr.HandleFunc(\"/users/{userId:.{3,}}\", GetUser).Methods(\"GET\")\n\tr.HandleFunc(\"/oauth/providers\", ListProviders).Methods(\"GET\")\n\tr.HandleFunc(\"/oauth/providers/{provider}/login\", Login).Methods(\"GET\")\n\tr.HandleFunc(\"/oauth/providers/{provider}/callback\", LoginCallback).Methods(\"GET\")\n\tr.HandleFunc(\"/playgrounds\", NewPlayground).Methods(\"PUT\")\n\tr.HandleFunc(\"/playgrounds\", ListPlaygrounds).Methods(\"GET\")\n\tr.HandleFunc(\"/my/playground\", GetCurrentPlayground).Methods(\"GET\")\n\n\tcorsRouter.HandleFunc(\"/\", NewSession).Methods(\"POST\")\n\n\tif extend != nil {\n\t\textend(corsRouter)\n\t}\n\n\tn := negroni.Classic()\n\n\tr.PathPrefix(\"/\").Handler(negroni.New(negroni.Wrap(corsHandler(corsRouter))))\n\tn.UseHandler(r)\n\n\thttpServer := http.Server{\n\t\tAddr:              \"0.0.0.0:\" + config.PortNumber,\n\t\tHandler:           n,\n\t\tIdleTimeout:       30 * time.Second,\n\t\tReadHeaderTimeout: 5 * time.Second,\n\t}\n\n\tif config.UseLetsEncrypt {\n\t\tdomainCache, err := lru.New(5000)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Could not start domain cache. Got: %v\", err)\n\t\t}\n\t\tcertManager := autocert.Manager{\n\t\t\tPrompt: autocert.AcceptTOS,\n\t\t\tHostPolicy: func(ctx context.Context, host string) error {\n\t\t\t\tif _, found := domainCache.Get(host); !found {\n\t\t\t\t\tif playground := core.PlaygroundFindByDomain(host); playground == nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"Playground for domain %s was not found\", host)\n\t\t\t\t\t}\n\t\t\t\t\tdomainCache.Add(host, true)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tCache: autocert.DirCache(config.LetsEncryptCertsDir),\n\t\t}\n\n\t\thttpServer.TLSConfig = &tls.Config{\n\t\t\tGetCertificate: certManager.GetCertificate,\n\t\t}\n\n\t\tgo func() {\n\t\t\trr := mux.NewRouter()\n\t\t\trr.HandleFunc(\"/ping\", Ping).Methods(\"GET\")\n\t\t\trr.Handle(\"/metrics\", promhttp.Handler())\n\t\t\trr.HandleFunc(\"/\", func(rw http.ResponseWriter, r *http.Request) {\n\t\t\t\ttarget := fmt.Sprintf(\"https://%s%s\", r.Host, r.URL.Path)\n\t\t\t\tif len(r.URL.RawQuery) > 0 {\n\t\t\t\t\ttarget += \"?\" + r.URL.RawQuery\n\t\t\t\t}\n\t\t\t\thttp.Redirect(rw, r, target, http.StatusMovedPermanently)\n\t\t\t})\n\t\t\tnr := negroni.Classic()\n\t\t\tnr.UseHandler(rr)\n\t\t\tlog.Println(\"Starting redirect server\")\n\t\t\tredirectServer := http.Server{\n\t\t\t\tAddr:              \"0.0.0.0:3001\",\n\t\t\t\tHandler:           certManager.HTTPHandler(nr),\n\t\t\t\tIdleTimeout:       30 * time.Second,\n\t\t\t\tReadHeaderTimeout: 5 * time.Second,\n\t\t\t}\n\t\t\tlog.Fatal(redirectServer.ListenAndServe())\n\t\t}()\n\n\t\tlog.Println(\"Listening on port \" + config.PortNumber)\n\t\tlog.Fatal(httpServer.ListenAndServeTLS(\"\", \"\"))\n\t} else {\n\t\tlog.Println(\"Listening on port \" + config.PortNumber)\n\t\tlog.Fatal(httpServer.ListenAndServe())\n\t}\n}\n\nfunc serveAsset(w http.ResponseWriter, r *http.Request, name string) {\n\ta, err := fs.ReadFile(staticFiles, name)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\thttp.ServeContent(w, r, name, time.Time{}, bytes.NewReader(a))\n}\n\nfunc initPlaygrounds() {\n\tpgs, err := core.PlaygroundList()\n\tif err != nil {\n\t\tlog.Fatal(\"Error getting playgrounds for initialization\")\n\t}\n\n\tfor _, p := range pgs {\n\t\tinitAssets(p)\n\t\tinitOauthProviders(p)\n\t}\n}\n\nfunc initAssets(p *types.Playground) {\n\tif p.AssetsDir == \"\" {\n\t\tp.AssetsDir = \"default\"\n\t}\n\n\tlpath := path.Join(p.AssetsDir, \"landing.html\")\n\tlanding, err := fs.ReadFile(staticFiles, lpath)\n\tif err != nil {\n\t\tlog.Printf(\"Could not load %v: %v\", lpath, err)\n\t\treturn\n\t}\n\n\tvar b bytes.Buffer\n\tt := template.New(\"landing.html\").Delims(\"[[\", \"]]\")\n\tt, err = t.Parse(string(landing))\n\tif err != nil {\n\t\tlog.Fatalf(\"Error parsing template %v\", err)\n\t}\n\tif err := t.Execute(&b, struct{ SegmentId string }{config.SegmentId}); err != nil {\n\t\tlog.Fatalf(\"Error executing template %v\", err)\n\t}\n\tlandingBytes, err := ioutil.ReadAll(&b)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error reading template bytes %v\", err)\n\t}\n\tlandings[p.Id] = landingBytes\n}\n\nfunc initOauthProviders(p *types.Playground) {\n\tconfig.Providers[p.Id] = map[string]*oauth2.Config{}\n\n\tif p.GithubClientID != \"\" && p.GithubClientSecret != \"\" {\n\t\tconf := &oauth2.Config{\n\t\t\tClientID:     p.GithubClientID,\n\t\t\tClientSecret: p.GithubClientSecret,\n\t\t\tScopes:       []string{\"user:email\"},\n\t\t\tEndpoint:     oauth2Github.Endpoint,\n\t\t}\n\n\t\tconfig.Providers[p.Id][\"github\"] = conf\n\t}\n\tif p.GoogleClientID != \"\" && p.GoogleClientSecret != \"\" {\n\t\tconf := &oauth2.Config{\n\t\t\tClientID:     p.GoogleClientID,\n\t\t\tClientSecret: p.GoogleClientSecret,\n\t\t\tScopes:       []string{people.UserinfoEmailScope, people.UserinfoProfileScope},\n\t\t\tEndpoint:     oauth2Google.Endpoint,\n\t\t}\n\n\t\tconfig.Providers[p.Id][\"google\"] = conf\n\t}\n\tif p.DockerClientID != \"\" && p.DockerClientSecret != \"\" {\n\n\t\tendpoint := getDockerEndpoint(p)\n\t\tconf := &oauth2.Config{\n\t\t\tClientID:     p.DockerClientID,\n\t\t\tClientSecret: p.DockerClientSecret,\n\t\t\tScopes:       []string{\"openid\"},\n\t\t\tEndpoint: oauth2.Endpoint{\n\t\t\t\tAuthURL:  fmt.Sprintf(\"https://%s/authorize/\", endpoint),\n\t\t\t\tTokenURL: fmt.Sprintf(\"https://%s/oauth/token\", endpoint),\n\t\t\t},\n\t\t}\n\n\t\tconfig.Providers[p.Id][\"docker\"] = conf\n\t}\n}\n"], "filenames": ["handlers/bootstrap.go"], "buggy_code_start_loc": [73], "buggy_code_end_loc": [77], "fixing_code_start_loc": [73], "fixing_code_end_loc": [77], "type": "CWE-639", "message": "Play With Docker is a browser-based Docker playground. Versions 0.0.2 and prior are vulnerable to domain hijacking. Because CORS configuration was not correct, an attacker could use `play-with-docker.com` as an example and set the origin header in an http request as `evil-play-with-docker.com`. The domain would echo in response header, which successfully bypassed the CORS policy and retrieved basic user information. This issue has been fixed in commit ed82247c9ab7990ad76ec2bf1498c2b2830b6f1a. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-28109", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-16T17:15:09.763", "lastModified": "2023-03-23T14:15:49.967", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Play With Docker is a browser-based Docker playground. Versions 0.0.2 and prior are vulnerable to domain hijacking. Because CORS configuration was not correct, an attacker could use `play-with-docker.com` as an example and set the origin header in an http request as `evil-play-with-docker.com`. The domain would echo in response header, which successfully bypassed the CORS policy and retrieved basic user information. This issue has been fixed in commit ed82247c9ab7990ad76ec2bf1498c2b2830b6f1a. There are no known workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-639"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:play-with-docker:play_with_docker:0.0.1:*:*:*:*:go:*:*", "matchCriteriaId": "39F1E076-60E4-4945-950B-F37607615D26"}, {"vulnerable": true, "criteria": "cpe:2.3:a:play-with-docker:play_with_docker:0.0.2:*:*:*:*:go:*:*", "matchCriteriaId": "9FAE59ED-5C29-48FB-80EB-56F66698D613"}]}]}], "references": [{"url": "https://github.com/play-with-docker/play-with-docker/commit/ed82247c9ab7990ad76ec2bf1498c2b2830b6f1a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/play-with-docker/play-with-docker/security/advisories/GHSA-vq59-5x26-h639", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/play-with-docker/play-with-docker/commit/ed82247c9ab7990ad76ec2bf1498c2b2830b6f1a"}}