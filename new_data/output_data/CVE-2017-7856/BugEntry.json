{"buggy_code": ["/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n/*\n * This file is part of the LibreOffice project.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This file incorporates work covered by the following license notice:\n *\n *   Licensed to the Apache Software Foundation (ASF) under one or more\n *   contributor license agreements. See the NOTICE file distributed\n *   with this work for additional information regarding copyright\n *   ownership. The ASF licenses this file to you under the Apache\n *   License, Version 2.0 (the \"License\"); you may not use this file\n *   except in compliance with the License. You may obtain a copy of\n *   the License at http://www.apache.org/licenses/LICENSE-2.0 .\n */\n\n#include <algorithm>\n#include <string.h>\n#include <osl/thread.h>\n#include <tools/debug.hxx>\n#include <tools/fract.hxx>\n#include <tools/stream.hxx>\n#include <tools/helpers.hxx>\n#include <vcl/dibtools.hxx>\n#include <vcl/virdev.hxx>\n#include <vcl/graph.hxx>\n#include <vcl/lineinfo.hxx>\n#include <rtl/strbuf.hxx>\n\n#include \"svmconverter.hxx\"\n\n#include <memory>\n#include <o3tl/make_unique.hxx>\n\n// Inlines\nvoid ImplReadRect( SvStream& rIStm, Rectangle& rRect )\n{\n    Point aTL;\n    Point aBR;\n\n    ReadPair( rIStm, aTL );\n    ReadPair( rIStm, aBR );\n\n    rRect = Rectangle( aTL, aBR );\n}\n\nvoid ImplWriteRect( SvStream& rOStm, const Rectangle& rRect )\n{\n    WritePair( rOStm, rRect.TopLeft() );\n    WritePair( rOStm, rRect.BottomRight() );\n}\n\nbool ImplReadPoly(SvStream& rIStm, tools::Polygon& rPoly)\n{\n    sal_Int32 nSize32(0);\n    rIStm.ReadInt32(nSize32);\n    sal_uInt16 nSize = nSize32;\n\n    const size_t nMaxPossiblePoints = rIStm.remainingSize() / 2 * sizeof(sal_Int32);\n    if (nSize > nMaxPossiblePoints)\n    {\n        SAL_WARN(\"vcl.gdi\", \"svm record claims to have: \" << nSize << \" points, but only \" << nMaxPossiblePoints << \" possible\");\n        return false;\n    }\n\n    rPoly = tools::Polygon(nSize);\n\n    for (sal_uInt16 i = 0; i < nSize && rIStm.good(); ++i)\n        ReadPair(rIStm, rPoly[i]);\n\n    return rIStm.good();\n}\n\nbool ImplReadPolyPoly(SvStream& rIStm, tools::PolyPolygon& rPolyPoly)\n{\n    bool bSuccess = true;\n\n    tools::Polygon aPoly;\n    sal_Int32 nPolyCount32(0);\n    rIStm.ReadInt32(nPolyCount32);\n    sal_uInt16 nPolyCount = (sal_uInt16)nPolyCount32;\n\n    for (sal_uInt16 i = 0; i < nPolyCount && rIStm.good(); ++i)\n    {\n        if (!ImplReadPoly(rIStm, aPoly))\n        {\n            bSuccess = false;\n            break;\n        }\n        rPolyPoly.Insert(aPoly);\n    }\n\n    return bSuccess && rIStm.good();\n}\n\nvoid ImplWritePolyPolyAction( SvStream& rOStm, const tools::PolyPolygon& rPolyPoly )\n{\n    const sal_uInt16    nPoly = rPolyPoly.Count();\n    sal_uInt16          nPoints = 0;\n    sal_uInt16          n;\n\n    for( n = 0; n < nPoly; n++ )\n        nPoints = sal::static_int_cast<sal_uInt16>(nPoints + rPolyPoly[ n ].GetSize());\n\n    rOStm.WriteInt16( GDI_POLYPOLYGON_ACTION );\n    rOStm.WriteInt32( 8 + ( nPoly << 2 ) + ( nPoints << 3 ) );\n    rOStm.WriteInt32( nPoly );\n\n    for( n = 0; n < nPoly; n++ )\n    {\n        // #i102224# Here the possible curved nature of Polygon was\n        // ignored (for all those years). Adapted to at least write\n        // a polygon representing the curve as good as possible\n        tools::Polygon aSimplePoly;\n         rPolyPoly[n].AdaptiveSubdivide(aSimplePoly);\n         const sal_uInt16 nSize(aSimplePoly.GetSize());\n\n        rOStm.WriteInt32( nSize );\n\n        for( sal_uInt16 j = 0; j < nSize; j++ )\n            WritePair( rOStm, aSimplePoly[ j ] );\n    }\n}\n\nvoid ImplReadColor( SvStream& rIStm, Color& rColor )\n{\n    sal_Int16 nVal(0);\n\n    rIStm.ReadInt16( nVal ); rColor.SetRed( sal::static_int_cast<sal_uInt8>((sal_uInt16)nVal >> 8) );\n    rIStm.ReadInt16( nVal ); rColor.SetGreen( sal::static_int_cast<sal_uInt8>((sal_uInt16)nVal >> 8) );\n    rIStm.ReadInt16( nVal ); rColor.SetBlue( sal::static_int_cast<sal_uInt8>((sal_uInt16)nVal >> 8) );\n}\n\nvoid ImplWriteColor( SvStream& rOStm, const Color& rColor )\n{\n    sal_Int16 nVal;\n\n    nVal = ( (sal_Int16) rColor.GetRed() << 8 ) | rColor.GetRed();\n    rOStm.WriteInt16( nVal );\n\n    nVal = ( (sal_Int16) rColor.GetGreen() << 8 ) | rColor.GetGreen();\n    rOStm.WriteInt16( nVal );\n\n    nVal = ( (sal_Int16) rColor.GetBlue() << 8 ) | rColor.GetBlue();\n    rOStm.WriteInt16( nVal );\n}\n\nbool ImplReadMapMode(SvStream& rIStm, MapMode& rMapMode)\n{\n    sal_Int16 nUnit(0);\n    rIStm.ReadInt16(nUnit);\n\n    Point aOrg;\n    ReadPair(rIStm, aOrg);\n\n    sal_Int32 nXNum(0), nXDenom(0), nYNum(0), nYDenom(0);\n    rIStm.ReadInt32(nXNum).ReadInt32(nXDenom).ReadInt32(nYNum).ReadInt32(nYDenom);\n\n    if (!rIStm.good() || nXDenom == 0 || nYDenom == 0)\n    {\n        SAL_WARN(\"vcl.gdi\", \"Parsing error: invalid mapmode fraction\");\n        return false;\n    }\n\n    rMapMode = MapMode( (MapUnit) nUnit, aOrg, Fraction( nXNum, nXDenom ), Fraction( nYNum, nYDenom ) );\n\n    return true;\n}\n\nvoid ImplWriteMapMode( SvStream& rOStm, const MapMode& rMapMode )\n{\n    rOStm.WriteInt16( (sal_uInt16)rMapMode.GetMapUnit() );\n    WritePair( rOStm, rMapMode.GetOrigin() );\n    rOStm.WriteInt32( rMapMode.GetScaleX().GetNumerator() );\n    rOStm.WriteInt32( rMapMode.GetScaleX().GetDenominator() );\n    rOStm.WriteInt32( rMapMode.GetScaleY().GetNumerator() );\n    rOStm.WriteInt32( rMapMode.GetScaleY().GetDenominator() );\n}\n\nvoid ImplWritePushAction( SvStream& rOStm )\n{\n    rOStm.WriteInt16( GDI_PUSH_ACTION );\n    rOStm.WriteInt32( 4 );\n}\n\nvoid ImplWritePopAction( SvStream& rOStm )\n{\n    rOStm.WriteInt16( GDI_POP_ACTION );\n    rOStm.WriteInt32( 4 );\n}\n\nvoid ImplWriteLineColor( SvStream& rOStm, const Color& rColor, sal_Int16 nStyle, sal_Int32 nWidth = 0 )\n{\n    if( rColor.GetTransparency() > 127 )\n        nStyle = 0;\n\n    rOStm.WriteInt16( GDI_PEN_ACTION );\n    rOStm.WriteInt32( 16 );\n    ImplWriteColor( rOStm, rColor );\n    rOStm.WriteInt32( nWidth );\n    rOStm.WriteInt16( nStyle );\n}\n\nvoid ImplWriteFillColor( SvStream& rOStm, const Color& rColor, sal_Int16 nStyle )\n{\n    rOStm.WriteInt16( GDI_FILLBRUSH_ACTION );\n    rOStm.WriteInt32( 20 );\n    ImplWriteColor( rOStm, rColor );\n\n    if( rColor.GetTransparency() > 127 )\n        nStyle = 0;\n\n    if( nStyle > 1 )\n    {\n        ImplWriteColor( rOStm, COL_WHITE );\n        rOStm.WriteInt16( nStyle );\n        rOStm.WriteInt16( 1 );\n    }\n    else\n    {\n        ImplWriteColor( rOStm, COL_BLACK );\n        rOStm.WriteInt16( nStyle );\n        rOStm.WriteInt16( 0 );\n    }\n}\n\nvoid ImplWriteFont( SvStream& rOStm, const vcl::Font& rFont,\n                    rtl_TextEncoding& rActualCharSet )\n{\n    char    aName[33];\n    short   nWeight;\n\n    OString aByteName(OUStringToOString(rFont.GetFamilyName(),\n        rOStm.GetStreamCharSet()));\n    strncpy( aName, aByteName.getStr(), 32 );\n    aName[32] = 0;\n\n    switch ( rFont.GetWeight() )\n    {\n        case WEIGHT_THIN:\n        case WEIGHT_ULTRALIGHT:\n        case WEIGHT_LIGHT:\n            nWeight = 1;\n        break;\n\n        case WEIGHT_NORMAL:\n        case WEIGHT_MEDIUM:\n            nWeight = 2;\n        break;\n\n        case WEIGHT_BOLD:\n        case WEIGHT_ULTRABOLD:\n        case WEIGHT_BLACK:\n            nWeight = 3;\n        break;\n\n        default:\n            nWeight = 0;\n        break;\n    }\n\n    rOStm.WriteInt16( GDI_FONT_ACTION );\n    rOStm.WriteInt32( 78 );\n\n    rActualCharSet = GetStoreCharSet( rFont.GetCharSet() );\n    ImplWriteColor( rOStm, rFont.GetColor() );\n    ImplWriteColor( rOStm, rFont.GetFillColor() );\n    rOStm.WriteBytes( aName, 32 );\n    WritePair( rOStm, rFont.GetFontSize() );\n    rOStm.WriteInt16( 0 ); // no character orientation anymore\n    rOStm.WriteInt16( rFont.GetOrientation() );\n    rOStm.WriteInt16( rActualCharSet );\n    rOStm.WriteInt16( rFont.GetFamilyType() );\n    rOStm.WriteInt16( rFont.GetPitch() );\n    rOStm.WriteInt16( rFont.GetAlignment() );\n    rOStm.WriteInt16( nWeight );\n    rOStm.WriteInt16( rFont.GetUnderline() );\n    rOStm.WriteInt16( rFont.GetStrikeout() );\n    rOStm.WriteBool( rFont.GetItalic() != ITALIC_NONE );\n    rOStm.WriteBool( rFont.IsOutline() );\n    rOStm.WriteBool( rFont.IsShadow() );\n    rOStm.WriteBool( rFont.IsTransparent() );\n    if ( rActualCharSet == RTL_TEXTENCODING_DONTKNOW )\n        rActualCharSet = osl_getThreadTextEncoding();\n}\n\nvoid ImplWriteRasterOpAction( SvStream& rOStm, sal_Int16 nRasterOp )\n{\n    rOStm.WriteInt16( GDI_RASTEROP_ACTION ).WriteInt32( 6 ).WriteInt16( nRasterOp );\n}\n\nbool ImplWriteUnicodeComment( SvStream& rOStm, const OUString& rString )\n{\n    sal_Int32 nStringLen = rString.getLength();\n    if ( nStringLen )\n    {\n        sal_uInt32  nSize = ( nStringLen << 1 ) + 4;\n        sal_uInt16  nType = GDI_UNICODE_COMMENT;\n\n        rOStm.WriteUInt16( nType ).WriteUInt32( nSize );\n        write_uInt16s_FromOUString(rOStm, rString);\n    }\n    return nStringLen != 0;\n}\n\nvoid ImplReadUnicodeComment( sal_uInt32 nStrmPos, SvStream& rIStm, OUString& rString )\n{\n    sal_uInt32 nOld = rIStm.Tell();\n    if ( nStrmPos )\n    {\n        sal_uInt16  nType;\n        sal_uInt32  nActionSize;\n        std::size_t nStringLen;\n\n        rIStm.Seek( nStrmPos );\n        rIStm  .ReadUInt16( nType )\n               .ReadUInt32( nActionSize );\n\n        nStringLen = (nActionSize - 4) >> 1;\n\n        if ( nStringLen && ( nType == GDI_UNICODE_COMMENT ) )\n            rString = read_uInt16s_ToOUString(rIStm, nStringLen);\n    }\n    rIStm.Seek( nOld );\n}\n\nvoid ImplSkipActions(SvStream& rIStm, sal_uLong nSkipCount)\n{\n    sal_Int32 nActionSize;\n    sal_Int16 nType;\n    for (sal_uLong i = 0UL; i < nSkipCount; ++i)\n    {\n        rIStm.ReadInt16(nType).ReadInt32(nActionSize);\n        if (!rIStm.good() || nActionSize < 4)\n            break;\n        rIStm.SeekRel(nActionSize - 4);\n    }\n}\n\nbool ImplWriteExtendedPolyPolygonAction(SvStream& rOStm, const tools::PolyPolygon& rPolyPolygon, bool bOnlyWhenCurve)\n{\n    const sal_uInt16 nPolygonCount(rPolyPolygon.Count());\n\n    if(nPolygonCount)\n    {\n        sal_uInt32 nAllPolygonCount(0);\n        sal_uInt32 nAllPointCount(0);\n        sal_uInt32 nAllFlagCount(0);\n        sal_uInt16 a(0);\n\n        for(a = 0; a < nPolygonCount; a++)\n        {\n            const tools::Polygon& rCandidate = rPolyPolygon.GetObject(a);\n            const sal_uInt16 nPointCount(rCandidate.GetSize());\n\n            if(nPointCount)\n            {\n                nAllPolygonCount++;\n                nAllPointCount += nPointCount;\n\n                if(rCandidate.HasFlags())\n                {\n                    nAllFlagCount += nPointCount;\n                }\n            }\n        }\n\n        if((bOnlyWhenCurve && nAllFlagCount) || (!bOnlyWhenCurve && nAllPointCount))\n        {\n            rOStm.WriteInt16( GDI_EXTENDEDPOLYGON_ACTION );\n\n            const sal_Int32 nActionSize(\n                4 +                         // Action size\n                2 +                         // PolygonCount\n                (nAllPolygonCount * 2) +    // Points per polygon\n                (nAllPointCount << 3) +     // Points themselves\n                nAllPolygonCount +          // Bool if (when poly has points) it has flags, too\n                nAllFlagCount);             // Flags themselves\n\n            rOStm.WriteInt32( nActionSize );\n            rOStm.WriteUInt16( nAllPolygonCount );\n\n            for(a = 0; a < nPolygonCount; a++)\n            {\n                const tools::Polygon& rCandidate = rPolyPolygon.GetObject(a);\n                const sal_uInt16 nPointCount(rCandidate.GetSize());\n\n                if(nPointCount)\n                {\n                    rOStm.WriteUInt16( nPointCount );\n\n                    for(sal_uInt16 b(0); b < nPointCount; b++)\n                    {\n                        WritePair( rOStm, rCandidate[b] );\n                    }\n\n                    if(rCandidate.HasFlags())\n                    {\n                        rOStm.WriteBool( true );\n\n                        for(sal_uInt16 c(0); c < nPointCount; c++)\n                        {\n                            rOStm.WriteUChar( (sal_uInt8)rCandidate.GetFlags(c) );\n                        }\n                    }\n                    else\n                    {\n                        rOStm.WriteBool( false );\n                    }\n                }\n            }\n\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvoid ImplReadExtendedPolyPolygonAction(SvStream& rIStm, tools::PolyPolygon& rPolyPoly)\n{\n    rPolyPoly.Clear();\n    sal_uInt16 nPolygonCount(0);\n    rIStm.ReadUInt16( nPolygonCount );\n\n    if (!nPolygonCount)\n        return;\n\n    const size_t nMinRecordSize = sizeof(sal_uInt16);\n    const size_t nMaxRecords = rIStm.remainingSize() / nMinRecordSize;\n    if (nPolygonCount > nMaxRecords)\n    {\n        SAL_WARN(\"vcl.gdi\", \"Parsing error: \" << nMaxRecords <<\n                 \" max possible entries, but \" << nPolygonCount << \" claimed, truncating\");\n        nPolygonCount = nMaxRecords;\n    }\n\n    for(sal_uInt16 a(0); a < nPolygonCount; a++)\n    {\n        sal_uInt16 nPointCount(0);\n        rIStm.ReadUInt16(nPointCount);\n\n        const size_t nMinPolygonSize = sizeof(sal_Int32) * 2;\n        const size_t nMaxPolygons = rIStm.remainingSize() / nMinPolygonSize;\n        if (nPointCount > nMaxPolygons)\n        {\n            SAL_WARN(\"vcl.gdi\", \"Parsing error: \" << nMaxPolygons <<\n                     \" max possible entries, but \" << nPointCount << \" claimed, truncating\");\n            nPointCount = nMaxPolygons;\n        }\n\n        tools::Polygon aCandidate(nPointCount);\n\n        if (nPointCount)\n        {\n            for(sal_uInt16 b(0); b < nPointCount; b++)\n            {\n                ReadPair( rIStm , aCandidate[b] );\n            }\n\n            sal_uInt8 bHasFlags(int(false));\n            rIStm.ReadUChar( bHasFlags );\n\n            if(bHasFlags)\n            {\n                sal_uInt8 aPolyFlags(0);\n\n                for(sal_uInt16 c(0); c < nPointCount; c++)\n                {\n                    rIStm.ReadUChar( aPolyFlags );\n                    aCandidate.SetFlags(c, (PolyFlags)aPolyFlags);\n                }\n            }\n        }\n\n        rPolyPoly.Insert(aCandidate);\n    }\n}\n\nSVMConverter::SVMConverter( SvStream& rStm, GDIMetaFile& rMtf, sal_uLong nConvertMode )\n{\n    if( !rStm.GetError() )\n    {\n        if( CONVERT_FROM_SVM1 == nConvertMode )\n            ImplConvertFromSVM1( rStm, rMtf );\n        else if( CONVERT_TO_SVM1 == nConvertMode )\n            ImplConvertToSVM1( rStm, rMtf );\n    }\n}\n\n#define LF_FACESIZE 32\n\nvoid SVMConverter::ImplConvertFromSVM1( SvStream& rIStm, GDIMetaFile& rMtf )\n{\n    const sal_uLong         nPos = rIStm.Tell();\n    const SvStreamEndian    nOldFormat = rIStm.GetEndian();\n\n    rIStm.SetEndian( SvStreamEndian::LITTLE );\n\n    char    aCode[ 5 ];\n    Size    aPrefSz;\n\n    // read header\n    rIStm.ReadBytes(aCode, sizeof(aCode));  // Identifier\n    sal_Int16 nSize(0);\n    rIStm.ReadInt16( nSize );                                 // Size\n    sal_Int16 nVersion(0);\n    rIStm.ReadInt16( nVersion );                              // Version\n    sal_Int32 nTmp32(0);\n    rIStm.ReadInt32( nTmp32 );\n    aPrefSz.Width() = nTmp32;                       // PrefSize.Width()\n    rIStm.ReadInt32( nTmp32 );\n    aPrefSz.Height() = nTmp32;                      // PrefSize.Height()\n\n    // check header-magic and version\n    if( rIStm.GetError()\n        || ( memcmp( aCode, \"SVGDI\", sizeof( aCode ) ) != 0 )\n        || ( nVersion != 200 ) )\n    {\n        rIStm.SetError( SVSTREAM_FILEFORMAT_ERROR );\n        rIStm.SetEndian( nOldFormat );\n        rIStm.Seek( nPos );\n        return;\n    }\n\n    LineInfo            aLineInfo( LineStyle::NONE, 0 );\n    std::stack<std::unique_ptr<LineInfo>> aLIStack;\n    ScopedVclPtrInstance< VirtualDevice > aFontVDev;\n    rtl_TextEncoding    eActualCharSet = osl_getThreadTextEncoding();\n    bool                bFatLine = false;\n\n    tools::Polygon     aActionPoly;\n    Rectangle   aRect;\n    Point       aPt, aPt1;\n    Size        aSz;\n    Color       aActionColor;\n\n    sal_uInt32  nUnicodeCommentStreamPos = 0;\n    sal_Int32       nUnicodeCommentActionNumber = 0;\n\n    rMtf.SetPrefSize(aPrefSz);\n\n    MapMode aMapMode;\n    if (ImplReadMapMode(rIStm, aMapMode))           // MapMode\n        rMtf.SetPrefMapMode(aMapMode);\n\n    sal_Int32 nActions(0);\n    rIStm.ReadInt32(nActions);                      // Action count\n    if (nActions < 0)\n    {\n        SAL_WARN(\"vcl.gdi\", \"svm claims negative action count (\" << nActions << \")\");\n        nActions = 0;\n    }\n\n    const size_t nMinActionSize = sizeof(sal_uInt16) + sizeof(sal_Int32);\n    const size_t nMaxPossibleActions = rIStm.remainingSize() / nMinActionSize;\n    if (static_cast<sal_uInt32>(nActions) > nMaxPossibleActions)\n    {\n        SAL_WARN(\"vcl.gdi\", \"svm claims more actions (\" << nActions << \") than stream could provide, truncating\");\n        nActions = nMaxPossibleActions;\n    }\n\n    size_t nLastPolygonAction(0);\n\n    for (sal_Int32 i = 0; i < nActions && rIStm.good(); ++i)\n    {\n        sal_Int16 nType(0);\n        rIStm.ReadInt16(nType);\n        sal_Int32 nActBegin = rIStm.Tell();\n        sal_Int32 nActionSize(0);\n        rIStm.ReadInt32(nActionSize);\n\n        SAL_WARN_IF( ( nType > 33 ) && ( nType < 1024 ), \"vcl.gdi\", \"Unknown GDIMetaAction while converting!\" );\n\n        switch( nType )\n        {\n            case GDI_PIXEL_ACTION:\n            {\n                ReadPair( rIStm, aPt );\n                ImplReadColor( rIStm, aActionColor );\n                rMtf.AddAction( new MetaPixelAction( aPt, aActionColor ) );\n            }\n            break;\n\n            case GDI_POINT_ACTION:\n            {\n                ReadPair( rIStm, aPt );\n                rMtf.AddAction( new MetaPointAction( aPt ) );\n            }\n            break;\n\n            case GDI_LINE_ACTION:\n            {\n                ReadPair( rIStm, aPt );\n                ReadPair( rIStm, aPt1 );\n                rMtf.AddAction( new MetaLineAction( aPt, aPt1, aLineInfo ) );\n            }\n            break;\n\n            case GDI_LINEJOIN_ACTION :\n            {\n                sal_Int16 nLineJoin(0);\n                rIStm.ReadInt16( nLineJoin );\n                aLineInfo.SetLineJoin((basegfx::B2DLineJoin)nLineJoin);\n            }\n            break;\n\n            case GDI_LINECAP_ACTION :\n            {\n                sal_Int16 nLineCap(0);\n                rIStm.ReadInt16( nLineCap );\n                aLineInfo.SetLineCap((css::drawing::LineCap)nLineCap);\n            }\n            break;\n\n            case GDI_LINEDASHDOT_ACTION :\n            {\n                sal_Int16 a(0);\n                sal_Int32 b(0);\n\n                rIStm.ReadInt16( a ); aLineInfo.SetDashCount(a);\n                rIStm.ReadInt32( b ); aLineInfo.SetDashLen(b);\n                rIStm.ReadInt16( a ); aLineInfo.SetDotCount(a);\n                rIStm.ReadInt32( b ); aLineInfo.SetDotLen(b);\n                rIStm.ReadInt32( b ); aLineInfo.SetDistance(b);\n\n                if(((aLineInfo.GetDashCount() && aLineInfo.GetDashLen())\n                    || (aLineInfo.GetDotCount() && aLineInfo.GetDotLen()))\n                    && aLineInfo.GetDistance())\n                {\n                    aLineInfo.SetStyle(LineStyle::Dash);\n                }\n            }\n            break;\n\n            case GDI_EXTENDEDPOLYGON_ACTION :\n            {\n                // read the tools::PolyPolygon in every case\n                tools::PolyPolygon aInputPolyPolygon;\n                ImplReadExtendedPolyPolygonAction(rIStm, aInputPolyPolygon);\n\n                // now check if it can be set somewhere\n                if(nLastPolygonAction < rMtf.GetActionSize())\n                {\n                    MetaPolyLineAction* pPolyLineAction = dynamic_cast< MetaPolyLineAction* >(rMtf.GetAction(nLastPolygonAction));\n\n                    if(pPolyLineAction)\n                    {\n                        // replace MetaPolyLineAction when we have a single polygon. Do not rely on the\n                        // same point count; the originally written GDI_POLYLINE_ACTION may have been\n                        // Subdivided for better quality for older usages\n                        if(1 == aInputPolyPolygon.Count())\n                        {\n                            MetaAction* pAction = rMtf.ReplaceAction(\n                                new MetaPolyLineAction(\n                                    aInputPolyPolygon.GetObject(0),\n                                    pPolyLineAction->GetLineInfo()),\n                                nLastPolygonAction);\n                            if(pAction)\n                                pAction->Delete();\n                        }\n                    }\n                    else\n                    {\n                        MetaPolyPolygonAction* pPolyPolygonAction = dynamic_cast< MetaPolyPolygonAction* >(rMtf.GetAction(nLastPolygonAction));\n\n                        if(pPolyPolygonAction)\n                        {\n                            // replace MetaPolyPolygonAction when we have a curved polygon. Do rely on the\n                            // same sub-polygon count\n                            if(pPolyPolygonAction->GetPolyPolygon().Count() == aInputPolyPolygon.Count())\n                            {\n                                MetaAction* pAction = rMtf.ReplaceAction(\n                                    new MetaPolyPolygonAction(\n                                        aInputPolyPolygon),\n                                    nLastPolygonAction);\n                                if(pAction)\n                                    pAction->Delete();\n                            }\n                        }\n                        else\n                        {\n                            MetaPolygonAction* pPolygonAction = dynamic_cast< MetaPolygonAction* >(rMtf.GetAction(nLastPolygonAction));\n\n                            if(pPolygonAction)\n                            {\n                                // replace MetaPolygonAction\n                                if(1 == aInputPolyPolygon.Count())\n                                {\n                                    MetaAction* pAction = rMtf.ReplaceAction(\n                                        new MetaPolygonAction(\n                                            aInputPolyPolygon.GetObject(0)),\n                                        nLastPolygonAction);\n                                    if(pAction)\n                                        pAction->Delete();\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            break;\n\n            case GDI_RECT_ACTION:\n            {\n                ImplReadRect( rIStm, aRect );\n                sal_Int32 nTmp(0), nTmp1(0);\n                rIStm.ReadInt32( nTmp ).ReadInt32( nTmp1 );\n\n                if( nTmp || nTmp1 )\n                    rMtf.AddAction( new MetaRoundRectAction( aRect, nTmp, nTmp1 ) );\n                else\n                {\n                    rMtf.AddAction( new MetaRectAction( aRect ) );\n\n                    if( bFatLine )\n                        rMtf.AddAction( new MetaPolyLineAction( aRect, aLineInfo ) );\n                }\n            }\n            break;\n\n            case GDI_ELLIPSE_ACTION:\n            {\n                ImplReadRect( rIStm, aRect );\n\n                if( bFatLine )\n                {\n                    const tools::Polygon aPoly( aRect.Center(), aRect.GetWidth() >> 1, aRect.GetHeight() >> 1 );\n\n                    rMtf.AddAction( new MetaPushAction( PushFlags::LINECOLOR ) );\n                    rMtf.AddAction( new MetaLineColorAction( COL_TRANSPARENT, false ) );\n                    rMtf.AddAction( new MetaPolygonAction( aPoly ) );\n                    rMtf.AddAction( new MetaPopAction() );\n                    rMtf.AddAction( new MetaPolyLineAction( aPoly, aLineInfo ) );\n                }\n                else\n                    rMtf.AddAction( new MetaEllipseAction( aRect ) );\n            }\n            break;\n\n            case GDI_ARC_ACTION:\n            {\n                ImplReadRect( rIStm, aRect );\n                ReadPair( rIStm, aPt );\n                ReadPair( rIStm, aPt1 );\n\n                if( bFatLine )\n                {\n                    const tools::Polygon aPoly( aRect, aPt, aPt1, PolyStyle::Arc );\n\n                    rMtf.AddAction( new MetaPushAction( PushFlags::LINECOLOR ) );\n                    rMtf.AddAction( new MetaLineColorAction( COL_TRANSPARENT, false ) );\n                    rMtf.AddAction( new MetaPolygonAction( aPoly ) );\n                    rMtf.AddAction( new MetaPopAction() );\n                    rMtf.AddAction( new MetaPolyLineAction( aPoly, aLineInfo ) );\n                }\n                else\n                    rMtf.AddAction( new MetaArcAction( aRect, aPt, aPt1 ) );\n            }\n            break;\n\n            case GDI_PIE_ACTION:\n            {\n                ImplReadRect( rIStm, aRect );\n                ReadPair( rIStm, aPt );\n                ReadPair( rIStm, aPt1 );\n\n                if( bFatLine )\n                {\n                    const tools::Polygon aPoly( aRect, aPt, aPt1, PolyStyle::Pie );\n\n                    rMtf.AddAction( new MetaPushAction( PushFlags::LINECOLOR ) );\n                    rMtf.AddAction( new MetaLineColorAction( COL_TRANSPARENT, false ) );\n                    rMtf.AddAction( new MetaPolygonAction( aPoly ) );\n                    rMtf.AddAction( new MetaPopAction() );\n                    rMtf.AddAction( new MetaPolyLineAction( aPoly, aLineInfo ) );\n                }\n                else\n                    rMtf.AddAction( new MetaPieAction( aRect, aPt, aPt1 ) );\n            }\n            break;\n\n            case GDI_INVERTRECT_ACTION:\n            case GDI_HIGHLIGHTRECT_ACTION:\n            {\n                ImplReadRect( rIStm, aRect );\n                rMtf.AddAction( new MetaPushAction( PushFlags::RASTEROP ) );\n                rMtf.AddAction( new MetaRasterOpAction( RasterOp::Invert ) );\n                rMtf.AddAction( new MetaRectAction( aRect ) );\n                rMtf.AddAction( new MetaPopAction() );\n            }\n            break;\n\n            case GDI_POLYLINE_ACTION:\n            {\n                if (ImplReadPoly(rIStm, aActionPoly))\n                {\n                    nLastPolygonAction = rMtf.GetActionSize();\n\n                    if( bFatLine )\n                        rMtf.AddAction( new MetaPolyLineAction( aActionPoly, aLineInfo ) );\n                    else\n                        rMtf.AddAction( new MetaPolyLineAction( aActionPoly ) );\n                }\n            }\n            break;\n\n            case GDI_POLYGON_ACTION:\n            {\n                if (ImplReadPoly(rIStm, aActionPoly))\n                {\n                    if( bFatLine )\n                    {\n                        rMtf.AddAction( new MetaPushAction( PushFlags::LINECOLOR ) );\n                        rMtf.AddAction( new MetaLineColorAction( COL_TRANSPARENT, false ) );\n                        rMtf.AddAction( new MetaPolygonAction( aActionPoly ) );\n                        rMtf.AddAction( new MetaPopAction() );\n                        rMtf.AddAction( new MetaPolyLineAction( aActionPoly, aLineInfo ) );\n                    }\n                    else\n                    {\n                        nLastPolygonAction = rMtf.GetActionSize();\n                        rMtf.AddAction( new MetaPolygonAction( aActionPoly ) );\n                    }\n                }\n            }\n            break;\n\n            case GDI_POLYPOLYGON_ACTION:\n            {\n                tools::PolyPolygon aPolyPoly;\n\n                if (ImplReadPolyPoly(rIStm, aPolyPoly))\n                {\n                    if( bFatLine )\n                    {\n                        rMtf.AddAction( new MetaPushAction( PushFlags::LINECOLOR ) );\n                        rMtf.AddAction( new MetaLineColorAction( COL_TRANSPARENT, false ) );\n                        rMtf.AddAction( new MetaPolyPolygonAction( aPolyPoly ) );\n                        rMtf.AddAction( new MetaPopAction() );\n\n                        for( sal_uInt16 nPoly = 0, nCount = aPolyPoly.Count(); nPoly < nCount; nPoly++ )\n                            rMtf.AddAction( new MetaPolyLineAction( aPolyPoly[ nPoly ], aLineInfo ) );\n                    }\n                    else\n                    {\n                        nLastPolygonAction = rMtf.GetActionSize();\n                        rMtf.AddAction( new MetaPolyPolygonAction( aPolyPoly ) );\n                    }\n                }\n            }\n            break;\n\n            case GDI_FONT_ACTION:\n            {\n                vcl::Font   aFont;\n                char        aName[LF_FACESIZE+1];\n\n                ImplReadColor( rIStm, aActionColor ); aFont.SetColor( aActionColor );\n                ImplReadColor( rIStm, aActionColor ); aFont.SetFillColor( aActionColor );\n                size_t nRet = rIStm.ReadBytes(aName, LF_FACESIZE);\n                aName[nRet] = 0;\n                aFont.SetFamilyName( OUString( aName, strlen(aName), rIStm.GetStreamCharSet() ) );\n\n                sal_Int32 nWidth(0), nHeight(0);\n                rIStm.ReadInt32(nWidth).ReadInt32(nHeight);\n                sal_Int16 nCharOrient(0), nLineOrient(0);\n                rIStm.ReadInt16(nCharOrient).ReadInt16(nLineOrient);\n                sal_Int16 nCharSet(0), nFamily(0), nPitch(0), nAlign(0), nWeight(0), nUnderline(0), nStrikeout(0);\n                rIStm.ReadInt16(nCharSet).ReadInt16(nFamily).ReadInt16(nPitch).ReadInt16(nAlign).ReadInt16(nWeight).ReadInt16(nUnderline).ReadInt16(nStrikeout);\n                bool bItalic(false), bOutline(false), bShadow(false), bTransparent(false);\n                rIStm.ReadCharAsBool(bItalic).ReadCharAsBool(bOutline).ReadCharAsBool(bShadow).ReadCharAsBool(bTransparent);\n\n                aFont.SetFontSize( Size( nWidth, nHeight ) );\n                aFont.SetCharSet( (rtl_TextEncoding) nCharSet );\n                aFont.SetFamily( (FontFamily) nFamily );\n                aFont.SetPitch( (FontPitch) nPitch );\n                aFont.SetAlignment( (FontAlign) nAlign );\n                aFont.SetWeight( ( nWeight == 1 ) ? WEIGHT_LIGHT : ( nWeight == 2 ) ? WEIGHT_NORMAL :\n                                 ( nWeight == 3 ) ? WEIGHT_BOLD : WEIGHT_DONTKNOW );\n                aFont.SetUnderline( (FontLineStyle) nUnderline );\n                aFont.SetStrikeout( (FontStrikeout) nStrikeout );\n                aFont.SetItalic( bItalic ? ITALIC_NORMAL : ITALIC_NONE );\n                aFont.SetOutline( bOutline );\n                aFont.SetShadow( bShadow );\n                aFont.SetOrientation( nLineOrient );\n                aFont.SetTransparent( bTransparent );\n\n                eActualCharSet = aFont.GetCharSet();\n                if ( eActualCharSet == RTL_TEXTENCODING_DONTKNOW )\n                    eActualCharSet = osl_getThreadTextEncoding();\n\n                rMtf.AddAction( new MetaFontAction( aFont ) );\n                rMtf.AddAction( new MetaTextAlignAction( aFont.GetAlignment() ) );\n                rMtf.AddAction( new MetaTextColorAction( aFont.GetColor() ) );\n                rMtf.AddAction( new MetaTextFillColorAction( aFont.GetFillColor(), !aFont.IsTransparent() ) );\n\n                // #106172# Track font relevant data in shadow VDev\n                aFontVDev->SetFont( aFont );\n            }\n            break;\n\n            case GDI_TEXT_ACTION:\n            {\n                sal_Int32 nIndex(0), nLen(0), nTmp(0);\n\n                ReadPair( rIStm, aPt ).ReadInt32( nIndex ).ReadInt32( nLen ).ReadInt32( nTmp );\n                if (nTmp > 0)\n                {\n                    OString aByteStr = read_uInt8s_ToOString(rIStm, nTmp);\n                    sal_uInt8 nTerminator = 0;\n                    rIStm.ReadUChar( nTerminator );\n                    SAL_WARN_IF( nTerminator != 0, \"vcl.gdi\", \"expected string to be NULL terminated\" );\n\n                    OUString aStr(OStringToOUString(aByteStr, eActualCharSet));\n                    if ( nUnicodeCommentActionNumber == i )\n                        ImplReadUnicodeComment( nUnicodeCommentStreamPos, rIStm, aStr );\n                    rMtf.AddAction( new MetaTextAction( aPt, aStr, nIndex, nLen ) );\n                }\n                rIStm.Seek( nActBegin + nActionSize );\n            }\n            break;\n\n            case GDI_TEXTARRAY_ACTION:\n            {\n                sal_Int32 nIndex(0), nLen(0), nAryLen(0), nTmp(0);\n\n                ReadPair( rIStm, aPt ).ReadInt32( nIndex ).ReadInt32( nLen ).ReadInt32( nTmp ).ReadInt32( nAryLen );\n                if (nTmp > 0)\n                {\n                    OString aByteStr = read_uInt8s_ToOString(rIStm, nTmp);\n                    sal_uInt8 nTerminator = 0;\n                    rIStm.ReadUChar( nTerminator );\n                    SAL_WARN_IF( nTerminator != 0, \"vcl.gdi\", \"expected string to be NULL terminated\" );\n\n                    OUString aStr(OStringToOUString(aByteStr, eActualCharSet));\n\n                    std::unique_ptr<long[]> pDXAry;\n                    sal_Int32 nDXAryLen = 0;\n                    if (nAryLen > 0)\n                    {\n                        const size_t nMinRecordSize = sizeof(sal_Int32);\n                        const size_t nMaxRecords = rIStm.remainingSize() / nMinRecordSize;\n                        if (static_cast<sal_uInt32>(nAryLen) > nMaxRecords)\n                        {\n                            SAL_WARN(\"vcl.gdi\", \"Parsing error: \" << nMaxRecords <<\n                                     \" max possible entries, but \" << nAryLen << \" claimed, truncating\");\n                            nAryLen = nMaxRecords;\n                        }\n\n                        sal_Int32 nStrLen( aStr.getLength() );\n\n                        nDXAryLen = std::max(nAryLen, nStrLen);\n\n                        if (nDXAryLen < nLen)\n                        {\n                            //MetaTextArrayAction ctor expects pDXAry to be >= nLen if set, so if this can't\n                            //be achieved, don't read it, it's utterly broken.\n                            SAL_WARN(\"vcl.gdi\", \"dxary too short, discarding completely\");\n                            rIStm.SeekRel(sizeof(sal_Int32) * nDXAryLen);\n                            nLen = 0;\n                            nIndex = 0;\n                        }\n                        else\n                        {\n                            pDXAry.reset(new long[nDXAryLen]);\n\n                            for (sal_Int32 j = 0; j < nAryLen; ++j)\n                                rIStm.ReadInt32( nTmp ), pDXAry[ j ] = nTmp;\n\n                            // #106172# Add last DX array elem, if missing\n                            if( nAryLen != nStrLen )\n                            {\n                                if (nAryLen+1 == nStrLen && nIndex >= 0)\n                                {\n                                    std::unique_ptr<long[]> pTmpAry(new long[nStrLen]);\n\n                                    aFontVDev->GetTextArray( aStr, pTmpAry.get(), nIndex, nLen );\n\n                                    // now, the difference between the\n                                    // last and the second last DX array\n                                    // is the advancement for the last\n                                    // glyph. Thus, to complete our meta\n                                    // action's DX array, just add that\n                                    // difference to last elem and store\n                                    // in very last.\n                                    if( nStrLen > 1 )\n                                        pDXAry[ nStrLen-3 ] = pDXAry[ nStrLen-2 ] + pTmpAry[ nStrLen-1 ] - pTmpAry[ nStrLen-2 ];\n                                    else\n                                        pDXAry[ nStrLen-1 ] = pTmpAry[ nStrLen-1 ]; // len=1: 0th position taken to be 0\n                                }\n#ifdef DBG_UTIL\n                                else\n                                    OSL_FAIL(\"More than one DX array element missing on SVM import\");\n#endif\n                            }\n                        }\n                    }\n                    if ( nUnicodeCommentActionNumber == i )\n                        ImplReadUnicodeComment( nUnicodeCommentStreamPos, rIStm, aStr );\n                    rMtf.AddAction( new MetaTextArrayAction( aPt, aStr, pDXAry.get(), nIndex, nLen ) );\n                }\n                rIStm.Seek( nActBegin + nActionSize );\n            }\n            break;\n\n            case GDI_STRETCHTEXT_ACTION:\n            {\n                sal_Int32 nIndex(0), nLen(0), nWidth(0), nTmp(0);\n\n                ReadPair( rIStm, aPt ).ReadInt32( nIndex ).ReadInt32( nLen ).ReadInt32( nTmp ).ReadInt32( nWidth );\n                if (nTmp > 0)\n                {\n                    OString aByteStr = read_uInt8s_ToOString(rIStm, nTmp);\n                    sal_uInt8 nTerminator = 0;\n                    rIStm.ReadUChar( nTerminator );\n                    SAL_WARN_IF( nTerminator != 0, \"vcl.gdi\", \"expected string to be NULL terminated\" );\n\n                    OUString aStr(OStringToOUString(aByteStr, eActualCharSet));\n                    if ( nUnicodeCommentActionNumber == i )\n                        ImplReadUnicodeComment( nUnicodeCommentStreamPos, rIStm, aStr );\n                    rMtf.AddAction( new MetaStretchTextAction( aPt, nWidth, aStr, nIndex, nLen ) );\n                }\n                rIStm.Seek( nActBegin + nActionSize );\n            }\n            break;\n\n            case GDI_BITMAP_ACTION:\n            {\n                Bitmap aBmp;\n\n                ReadPair( rIStm, aPt );\n                ReadDIB(aBmp, rIStm, true);\n                rMtf.AddAction( new MetaBmpAction( aPt, aBmp ) );\n            }\n            break;\n\n            case GDI_BITMAPSCALE_ACTION:\n            {\n                Bitmap aBmp;\n\n                ReadPair( rIStm, aPt );\n                ReadPair( rIStm, aSz );\n                ReadDIB(aBmp, rIStm, true);\n                rMtf.AddAction( new MetaBmpScaleAction( aPt, aSz, aBmp ) );\n            }\n            break;\n\n            case GDI_BITMAPSCALEPART_ACTION:\n            {\n                Bitmap  aBmp;\n                Size    aSz2;\n\n                ReadPair( rIStm, aPt );\n                ReadPair( rIStm, aSz );\n                ReadPair( rIStm, aPt1 );\n                ReadPair( rIStm, aSz2 );\n                ReadDIB(aBmp, rIStm, true);\n                rMtf.AddAction( new MetaBmpScalePartAction( aPt, aSz, aPt1, aSz2, aBmp ) );\n            }\n            break;\n\n            case GDI_PEN_ACTION:\n            {\n                sal_Int32 nPenWidth;\n                sal_Int16 nPenStyle;\n\n                ImplReadColor( rIStm, aActionColor );\n                rIStm.ReadInt32( nPenWidth ).ReadInt16( nPenStyle );\n\n                aLineInfo.SetStyle( nPenStyle ? LineStyle::Solid : LineStyle::NONE );\n                aLineInfo.SetWidth( nPenWidth );\n                bFatLine = nPenStyle && !aLineInfo.IsDefault();\n\n                rMtf.AddAction( new MetaLineColorAction( aActionColor, nPenStyle != 0 ) );\n            }\n            break;\n\n            case GDI_FILLBRUSH_ACTION:\n            {\n                sal_Int16 nBrushStyle;\n\n                ImplReadColor( rIStm, aActionColor );\n                rIStm.SeekRel( 6 );\n                rIStm.ReadInt16( nBrushStyle );\n                rMtf.AddAction( new MetaFillColorAction( aActionColor, nBrushStyle != 0 ) );\n                rIStm.SeekRel( 2 );\n            }\n            break;\n\n            case GDI_MAPMODE_ACTION:\n            {\n                if (ImplReadMapMode(rIStm, aMapMode))\n                {\n                    rMtf.AddAction(new MetaMapModeAction(aMapMode));\n\n                    // #106172# Track font relevant data in shadow VDev\n                    aFontVDev->SetMapMode(aMapMode);\n                };\n            }\n            break;\n\n            case GDI_CLIPREGION_ACTION:\n            {\n                vcl::Region  aRegion;\n                sal_Int16   nRegType;\n                sal_Int16   bIntersect;\n                bool    bClip = false;\n\n                rIStm.ReadInt16( nRegType ).ReadInt16( bIntersect );\n                ImplReadRect( rIStm, aRect );\n\n                switch( nRegType )\n                {\n                    case 0:\n                    break;\n\n                    case 1:\n                    {\n                        Rectangle aRegRect;\n\n                        ImplReadRect( rIStm, aRegRect );\n                        aRegion = vcl::Region( aRegRect );\n                        bClip = true;\n                    }\n                    break;\n\n                    case 2:\n                    {\n                        if (ImplReadPoly(rIStm, aActionPoly))\n                        {\n                            aRegion = vcl::Region( aActionPoly );\n                            bClip = true;\n                        }\n                    }\n                    break;\n\n                    case 3:\n                    {\n                        bool bSuccess = true;\n                        tools::PolyPolygon aPolyPoly;\n                        sal_Int32 nPolyCount32(0);\n                        rIStm.ReadInt32(nPolyCount32);\n                        sal_uInt16 nPolyCount(nPolyCount32);\n\n                        for (sal_uInt16 j = 0; j < nPolyCount && rIStm.good(); ++j)\n                        {\n                            if (!ImplReadPoly(rIStm, aActionPoly))\n                            {\n                                bSuccess = false;\n                                break;\n                            }\n                            aPolyPoly.Insert(aActionPoly);\n                        }\n\n                        if (bSuccess)\n                        {\n                            aRegion = vcl::Region( aPolyPoly );\n                            bClip = true;\n                        }\n                    }\n                    break;\n                }\n\n                if( bIntersect )\n                    aRegion.Intersect( aRect );\n\n                rMtf.AddAction( new MetaClipRegionAction( aRegion, bClip ) );\n            }\n            break;\n\n            case GDI_MOVECLIPREGION_ACTION:\n            {\n                sal_Int32 nTmp(0), nTmp1(0);\n                rIStm.ReadInt32( nTmp ).ReadInt32( nTmp1 );\n                rMtf.AddAction( new MetaMoveClipRegionAction( nTmp, nTmp1 ) );\n            }\n            break;\n\n            case GDI_ISECTCLIPREGION_ACTION:\n            {\n                ImplReadRect( rIStm, aRect );\n                rMtf.AddAction( new MetaISectRectClipRegionAction( aRect ) );\n            }\n            break;\n\n            case GDI_RASTEROP_ACTION:\n            {\n                RasterOp    eRasterOp;\n                sal_Int16       nRasterOp;\n\n                rIStm.ReadInt16( nRasterOp );\n\n                switch( nRasterOp )\n                {\n                    case 1:\n                        eRasterOp = RasterOp::Invert;\n                    break;\n\n                    case 4:\n                    case 5:\n                        eRasterOp = RasterOp::Xor;\n                    break;\n\n                    default:\n                        eRasterOp = RasterOp::OverPaint;\n                    break;\n                }\n\n                rMtf.AddAction( new MetaRasterOpAction( eRasterOp ) );\n            }\n            break;\n\n            case GDI_PUSH_ACTION:\n            {\n                aLIStack.push(o3tl::make_unique<LineInfo>(aLineInfo));\n                rMtf.AddAction( new MetaPushAction( PushFlags::ALL ) );\n\n                // #106172# Track font relevant data in shadow VDev\n                aFontVDev->Push();\n            }\n            break;\n\n            case GDI_POP_ACTION:\n            {\n\n                std::unique_ptr<LineInfo> xLineInfo;\n                if (!aLIStack.empty())\n                {\n                    xLineInfo = std::move(aLIStack.top());\n                    aLIStack.pop();\n                }\n\n                // restore line info\n                if (xLineInfo)\n                {\n                    aLineInfo = *xLineInfo;\n                    xLineInfo.reset();\n                    bFatLine = ( LineStyle::NONE != aLineInfo.GetStyle() ) && !aLineInfo.IsDefault();\n                }\n\n                rMtf.AddAction( new MetaPopAction() );\n\n                // #106172# Track font relevant data in shadow VDev\n                aFontVDev->Pop();\n            }\n            break;\n\n            case GDI_GRADIENT_ACTION:\n            {\n                Color   aStartCol;\n                Color   aEndCol;\n                sal_Int16   nStyle;\n                sal_Int16   nAngle;\n                sal_Int16   nBorder;\n                sal_Int16   nOfsX;\n                sal_Int16   nOfsY;\n                sal_Int16   nIntensityStart;\n                sal_Int16   nIntensityEnd;\n\n                ImplReadRect( rIStm, aRect );\n                rIStm.ReadInt16( nStyle );\n                ImplReadColor( rIStm, aStartCol );\n                ImplReadColor( rIStm, aEndCol );\n                rIStm.ReadInt16( nAngle ).ReadInt16( nBorder ).ReadInt16( nOfsX ).ReadInt16( nOfsY ).ReadInt16( nIntensityStart ).ReadInt16( nIntensityEnd );\n\n                Gradient aGrad( (GradientStyle) nStyle, aStartCol, aEndCol );\n\n                aGrad.SetAngle( nAngle );\n                aGrad.SetBorder( nBorder );\n                aGrad.SetOfsX( nOfsX );\n                aGrad.SetOfsY( nOfsY );\n                aGrad.SetStartIntensity( nIntensityStart );\n                aGrad.SetEndIntensity( nIntensityEnd );\n                rMtf.AddAction( new MetaGradientAction( aRect, aGrad ) );\n            }\n            break;\n\n            case GDI_TRANSPARENT_COMMENT:\n            {\n                tools::PolyPolygon aPolyPoly;\n                sal_Int32       nFollowingActionCount;\n                sal_Int16       nTrans;\n\n                ReadPolyPolygon( rIStm, aPolyPoly );\n                rIStm.ReadInt16( nTrans ).ReadInt32( nFollowingActionCount );\n                ImplSkipActions( rIStm, nFollowingActionCount );\n                rMtf.AddAction( new MetaTransparentAction( aPolyPoly, nTrans ) );\n\n                i += nFollowingActionCount;\n            }\n            break;\n\n            case GDI_FLOATTRANSPARENT_COMMENT:\n            {\n                GDIMetaFile aMtf;\n                Point       aPos;\n                Size        aSize;\n                Gradient    aGradient;\n                sal_Int32       nFollowingActionCount;\n\n                ReadGDIMetaFile( rIStm, aMtf );\n                ReadPair( rIStm, aPos );\n                ReadPair( rIStm, aSize );\n                ReadGradient( rIStm, aGradient );\n                rIStm.ReadInt32( nFollowingActionCount );\n                ImplSkipActions( rIStm, nFollowingActionCount );\n                rMtf.AddAction( new MetaFloatTransparentAction( aMtf, aPos, aSize, aGradient ) );\n\n                i += nFollowingActionCount;\n            }\n            break;\n\n            case GDI_HATCH_COMMENT:\n            {\n                tools::PolyPolygon aPolyPoly;\n                Hatch       aHatch;\n                sal_Int32       nFollowingActionCount;\n\n                ReadPolyPolygon( rIStm, aPolyPoly );\n                ReadHatch( rIStm, aHatch );\n                rIStm.ReadInt32( nFollowingActionCount );\n                ImplSkipActions( rIStm, nFollowingActionCount );\n                rMtf.AddAction( new MetaHatchAction( aPolyPoly, aHatch ) );\n\n                i += nFollowingActionCount;\n            }\n            break;\n\n            case GDI_REFPOINT_COMMENT:\n            {\n                Point   aRefPoint;\n                bool    bSet;\n                sal_Int32   nFollowingActionCount;\n\n                ReadPair( rIStm, aRefPoint );\n                rIStm.ReadCharAsBool( bSet ).ReadInt32( nFollowingActionCount );\n                ImplSkipActions( rIStm, nFollowingActionCount );\n                rMtf.AddAction( new MetaRefPointAction( aRefPoint, bSet ) );\n\n                i += nFollowingActionCount;\n\n                // #106172# Track font relevant data in shadow VDev\n                if( bSet )\n                    aFontVDev->SetRefPoint( aRefPoint );\n                else\n                    aFontVDev->SetRefPoint();\n            }\n            break;\n\n            case GDI_TEXTLINECOLOR_COMMENT:\n            {\n                Color   aColor;\n                bool    bSet;\n                sal_Int32   nFollowingActionCount;\n\n                ReadColor( rIStm, aColor );\n                rIStm.ReadCharAsBool( bSet ).ReadInt32( nFollowingActionCount );\n                ImplSkipActions( rIStm, nFollowingActionCount );\n                rMtf.AddAction( new MetaTextLineColorAction( aColor, bSet ) );\n\n                i += nFollowingActionCount;\n            }\n            break;\n\n            case GDI_TEXTLINE_COMMENT:\n            {\n                Point   aStartPt;\n                sal_Int32  nWidth(0);\n                sal_uInt32 nStrikeout(0);\n                sal_uInt32 nUnderline(0);\n                sal_Int32  nFollowingActionCount(0);\n\n                ReadPair( rIStm, aStartPt );\n                rIStm.ReadInt32(nWidth ).ReadUInt32(nStrikeout).ReadUInt32(nUnderline).ReadInt32(nFollowingActionCount);\n                ImplSkipActions(rIStm, nFollowingActionCount);\n                rMtf.AddAction( new MetaTextLineAction( aStartPt, nWidth,\n                                                        (FontStrikeout) nStrikeout,\n                                                        (FontLineStyle) nUnderline,\n                                                        LINESTYLE_NONE ) );\n\n                i += nFollowingActionCount;\n            }\n            break;\n\n            case GDI_GRADIENTEX_COMMENT:\n            {\n                tools::PolyPolygon aPolyPoly;\n                Gradient    aGradient;\n                sal_Int32       nFollowingActionCount;\n\n                ReadPolyPolygon( rIStm, aPolyPoly );\n                ReadGradient( rIStm, aGradient );\n                rIStm.ReadInt32( nFollowingActionCount );\n                ImplSkipActions( rIStm, nFollowingActionCount );\n                rMtf.AddAction( new MetaGradientExAction( aPolyPoly, aGradient ) );\n\n                i += nFollowingActionCount;\n            }\n            break;\n\n            case GDI_COMMENT_COMMENT:\n            {\n                sal_Int32   nValue;\n                sal_uInt32  nDataSize;\n                std::vector<sal_uInt8> aData;\n                sal_Int32       nFollowingActionCount;\n\n                OString aComment = read_uInt16_lenPrefixed_uInt8s_ToOString(rIStm);\n                rIStm.ReadInt32( nValue ).ReadUInt32( nDataSize );\n\n                if (nDataSize)\n                {\n                    aData.resize(nDataSize);\n                    nDataSize = rIStm.ReadBytes(aData.data(), nDataSize);\n                }\n\n                rIStm.ReadInt32( nFollowingActionCount );\n                ImplSkipActions( rIStm, nFollowingActionCount );\n                rMtf.AddAction(new MetaCommentAction(aComment, nValue, aData.data(), nDataSize));\n\n                i += nFollowingActionCount;\n            }\n            break;\n\n            case GDI_UNICODE_COMMENT:\n            {\n                nUnicodeCommentActionNumber = i + 1;\n                nUnicodeCommentStreamPos = rIStm.Tell() - 6;\n                if (nActionSize < 4)\n                    rIStm.SetError(SVSTREAM_FILEFORMAT_ERROR);\n                else\n                    rIStm.SeekRel(nActionSize - 4);\n            }\n            break;\n\n            default:\n                if (nActionSize < 4)\n                    rIStm.SetError(SVSTREAM_FILEFORMAT_ERROR);\n                else\n                    rIStm.SeekRel(nActionSize - 4);\n            break;\n        }\n    }\n\n    rIStm.SetEndian( nOldFormat );\n}\n\nvoid SVMConverter::ImplConvertToSVM1( SvStream& rOStm, GDIMetaFile& rMtf )\n{\n    sal_uLong           nCountPos;\n    vcl::Font           aSaveFont;\n    const SvStreamEndian nOldFormat = rOStm.GetEndian();\n    rtl_TextEncoding    eActualCharSet = osl_getThreadTextEncoding();\n    const Size          aPrefSize( rMtf.GetPrefSize() );\n    bool                bRop_0_1 = false;\n    ScopedVclPtrInstance< VirtualDevice > aSaveVDev;\n    Color               aLineCol( COL_BLACK );\n    ::std::stack< Color* >  aLineColStack;\n\n    rOStm.SetEndian( SvStreamEndian::LITTLE );\n\n    // Write MagicCode\n    rOStm.WriteCharPtr( \"SVGDI\" );                                   // Identifier\n    rOStm.WriteInt16( 42 );                            // HeaderSize\n    rOStm.WriteInt16( 200 );                           // VERSION\n    rOStm.WriteInt32( aPrefSize.Width() );\n    rOStm.WriteInt32( aPrefSize.Height() );\n    ImplWriteMapMode( rOStm, rMtf.GetPrefMapMode() );\n\n    // ActionCount will be written later\n    nCountPos = rOStm.Tell();\n    rOStm.SeekRel( 4 );\n\n    const sal_Int32 nActCount = ImplWriteActions( rOStm, rMtf, *aSaveVDev.get(), bRop_0_1, aLineCol, aLineColStack, eActualCharSet );\n    const sal_uLong nActPos = rOStm.Tell();\n\n    rOStm.Seek( nCountPos );\n    rOStm.WriteInt32( nActCount );\n    rOStm.Seek( nActPos );\n    rOStm.SetEndian( nOldFormat );\n\n    // cleanup push-pop stack if necessary\n    while ( !aLineColStack.empty() )\n    {\n        delete aLineColStack.top();\n        aLineColStack.pop();\n    }\n}\n\nsal_uLong SVMConverter::ImplWriteActions( SvStream& rOStm, GDIMetaFile& rMtf,\n                                      VirtualDevice& rSaveVDev, bool& rRop_0_1,\n                                      Color& rLineCol, ::std::stack< Color* >& rLineColStack,\n                                      rtl_TextEncoding& rActualCharSet )\n{\n    sal_uLong nCount = 0;\n    for( size_t i = 0, nActionCount = rMtf.GetActionSize(); i < nActionCount; i++ )\n    {\n        const MetaAction* pAction = rMtf.GetAction( i );\n\n        switch( pAction->GetType() )\n        {\n            case MetaActionType::PIXEL:\n            {\n                const MetaPixelAction* pAct = static_cast<const MetaPixelAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_PIXEL_ACTION );\n                rOStm.WriteInt32( 18 );\n                WritePair( rOStm, pAct->GetPoint() );\n                ImplWriteColor( rOStm, pAct->GetColor() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::POINT:\n            {\n                const MetaPointAction* pAct = static_cast<const MetaPointAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_POINT_ACTION );\n                rOStm.WriteInt32( 12 );\n                WritePair( rOStm, pAct->GetPoint() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::LINE:\n            {\n                const MetaLineAction* pAct = static_cast<const MetaLineAction*>(pAction);\n                const LineInfo& rInfo = pAct->GetLineInfo();\n                const bool bFatLine(!rInfo.IsDefault() && (LineStyle::NONE != rInfo.GetStyle()));\n                const bool bLineJoin(bFatLine && basegfx::B2DLineJoin::Round != rInfo.GetLineJoin());\n                const bool bLineCap(bFatLine && css::drawing::LineCap_BUTT != rInfo.GetLineCap());\n                const bool bLineDashDot(LineStyle::Dash == rInfo.GetStyle());\n\n                if( bFatLine )\n                {\n                    ImplWritePushAction( rOStm );\n                    ImplWriteLineColor( rOStm, rLineCol, 1, rInfo.GetWidth() );\n\n                    if(bLineJoin)\n                    {\n                        rOStm.WriteInt16( GDI_LINEJOIN_ACTION );\n                        rOStm.WriteInt32( 6 );\n                        rOStm.WriteInt16( static_cast<sal_Int16>(rInfo.GetLineJoin()) );\n                    }\n\n                    if(bLineCap)\n                    {\n                        rOStm.WriteInt16( GDI_LINECAP_ACTION );\n                        rOStm.WriteInt32( 6 );\n                        rOStm.WriteInt16( rInfo.GetLineCap() );\n                    }\n                }\n\n                if(bLineDashDot)\n                {\n                    rOStm.WriteInt16( GDI_LINEDASHDOT_ACTION );\n                    rOStm.WriteInt32( 4 + 16 );\n                    rOStm.WriteInt16( rInfo.GetDashCount() );\n                    rOStm.WriteInt32( rInfo.GetDashLen() );\n                    rOStm.WriteInt16( rInfo.GetDotCount() );\n                    rOStm.WriteInt32( rInfo.GetDotLen() );\n                    rOStm.WriteInt32( rInfo.GetDistance() );\n                }\n\n                rOStm.WriteInt16( GDI_LINE_ACTION );\n                rOStm.WriteInt32( 20 );\n                WritePair( rOStm, pAct->GetStartPoint() );\n                WritePair( rOStm, pAct->GetEndPoint() );\n                nCount++;\n\n                if( bFatLine )\n                {\n                    ImplWritePopAction( rOStm );\n                    nCount += 3;\n\n                    if(bLineJoin)\n                    {\n                        nCount += 1;\n                    }\n\n                    if(bLineCap)\n                    {\n                        nCount += 1;\n                    }\n                }\n\n                if(bLineDashDot)\n                {\n                    nCount += 1;\n                }\n            }\n            break;\n\n            case MetaActionType::RECT:\n            {\n                const MetaRectAction* pAct = static_cast<const MetaRectAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_RECT_ACTION );\n                rOStm.WriteInt32( 28 );\n                ImplWriteRect( rOStm, pAct->GetRect() );\n                rOStm.WriteInt32( 0 );\n                rOStm.WriteInt32( 0 );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::ROUNDRECT:\n            {\n                const MetaRoundRectAction* pAct = static_cast<const MetaRoundRectAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_RECT_ACTION );\n                rOStm.WriteInt32( 28 );\n                ImplWriteRect( rOStm, pAct->GetRect() );\n                rOStm.WriteInt32( pAct->GetHorzRound() );\n                rOStm.WriteInt32( pAct->GetVertRound() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::ELLIPSE:\n            {\n                const MetaEllipseAction* pAct = static_cast<const MetaEllipseAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_ELLIPSE_ACTION );\n                rOStm.WriteInt32( 20 );\n                ImplWriteRect( rOStm, pAct->GetRect() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::ARC:\n            {\n                const MetaArcAction* pAct = static_cast<const MetaArcAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_ARC_ACTION );\n                rOStm.WriteInt32( 36 );\n                ImplWriteRect( rOStm, pAct->GetRect() );\n                WritePair( rOStm, pAct->GetStartPoint() );\n                WritePair( rOStm, pAct->GetEndPoint() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::PIE:\n            {\n                const MetaPieAction* pAct = static_cast<const MetaPieAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_PIE_ACTION );\n                rOStm.WriteInt32( 36 );\n                ImplWriteRect( rOStm, pAct->GetRect() );\n                WritePair( rOStm, pAct->GetStartPoint() );\n                WritePair( rOStm, pAct->GetEndPoint() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::CHORD:\n            {\n                const MetaChordAction* pAct = static_cast<const MetaChordAction*>(pAction);\n                tools::Polygon aChordPoly( pAct->GetRect(), pAct->GetStartPoint(),\n                                           pAct->GetEndPoint(), PolyStyle::Chord );\n                const sal_uInt16       nPoints = aChordPoly.GetSize();\n\n                rOStm.WriteInt16( GDI_POLYGON_ACTION );\n                rOStm.WriteInt32( 8 + ( nPoints << 3 ) );\n                rOStm.WriteInt32( nPoints );\n\n                for( sal_uInt16 n = 0; n < nPoints; n++ )\n                    WritePair( rOStm, aChordPoly[ n ] );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::POLYLINE:\n            {\n                // #i102224#\n                const MetaPolyLineAction* pAct = static_cast<const MetaPolyLineAction*>(pAction);\n                // #i102224# Here the possible curved nature of Polygon was\n                // ignored (for all those years). Adapted to at least write\n                // a polygon representing the curve as good as possible\n                tools::Polygon aSimplePoly;\n                pAct->GetPolygon().AdaptiveSubdivide(aSimplePoly);\n                const LineInfo& rInfo = pAct->GetLineInfo();\n                const sal_uInt16 nPoints(aSimplePoly.GetSize());\n                const bool bFatLine(!rInfo.IsDefault() && (LineStyle::NONE != rInfo.GetStyle()));\n                const bool bLineJoin(bFatLine && basegfx::B2DLineJoin::Round != rInfo.GetLineJoin());\n                const bool bLineCap(bFatLine && css::drawing::LineCap_BUTT != rInfo.GetLineCap());\n                const bool bLineDashDot(LineStyle::Dash == rInfo.GetStyle());\n\n                if( bFatLine )\n                {\n                    ImplWritePushAction( rOStm );\n                    ImplWriteLineColor( rOStm, rLineCol, 1, rInfo.GetWidth() );\n\n                    if(bLineJoin)\n                    {\n                        rOStm.WriteInt16( GDI_LINEJOIN_ACTION );\n                        rOStm.WriteInt32( 6 );\n                        rOStm.WriteInt16( static_cast<sal_Int16>(rInfo.GetLineJoin()) );\n                    }\n\n                    if(bLineCap)\n                    {\n                        rOStm.WriteInt16( GDI_LINECAP_ACTION );\n                        rOStm.WriteInt32( 6 );\n                        rOStm.WriteInt16( rInfo.GetLineCap() );\n                    }\n                }\n\n                if(bLineDashDot)\n                {\n                    rOStm.WriteInt16( GDI_LINEDASHDOT_ACTION );\n                    rOStm.WriteInt32( 4 + 16 );\n                    rOStm.WriteInt16( rInfo.GetDashCount() );\n                    rOStm.WriteInt32( rInfo.GetDashLen() );\n                    rOStm.WriteInt16( rInfo.GetDotCount() );\n                    rOStm.WriteInt32( rInfo.GetDotLen() );\n                    rOStm.WriteInt32( rInfo.GetDistance() );\n                }\n\n                rOStm.WriteInt16( GDI_POLYLINE_ACTION );\n                rOStm.WriteInt32( 8 + ( nPoints << 3 ) );\n                rOStm.WriteInt32( nPoints );\n\n                for( sal_uInt16 n = 0; n < nPoints; n++ )\n                {\n                    WritePair( rOStm, aSimplePoly[ n ] );\n                }\n\n                nCount++;\n\n                const tools::PolyPolygon aPolyPolygon(pAct->GetPolygon());\n                if(ImplWriteExtendedPolyPolygonAction(rOStm, aPolyPolygon, true))\n                {\n                    nCount++;\n                }\n\n                if( bFatLine )\n                {\n                    ImplWritePopAction( rOStm );\n                    nCount += 3;\n\n                    if(bLineJoin)\n                    {\n                        nCount += 1;\n                    }\n\n                    if(bLineCap)\n                    {\n                        nCount += 1;\n                    }\n                }\n\n                if(bLineDashDot)\n                {\n                    nCount += 1;\n                }\n            }\n            break;\n\n            case MetaActionType::POLYGON:\n            {\n                const MetaPolygonAction* pAct = static_cast<const MetaPolygonAction*>(pAction);\n                // #i102224# Here the possible curved nature of Polygon was\n                // ignored (for all those years). Adapted to at least write\n                // a polygon representing the curve as good as possible\n                tools::Polygon aSimplePoly;\n                pAct->GetPolygon().AdaptiveSubdivide(aSimplePoly);\n                const sal_uInt16 nPoints(aSimplePoly.GetSize());\n\n                rOStm.WriteInt16( GDI_POLYGON_ACTION );\n                rOStm.WriteInt32( 8 + ( nPoints << 3 ) );\n                rOStm.WriteInt32( nPoints );\n\n                for( sal_uInt16 n = 0; n < nPoints; n++ )\n                    WritePair( rOStm, aSimplePoly[ n ] );\n\n                nCount++;\n\n                const tools::PolyPolygon aPolyPolygon(pAct->GetPolygon());\n                if(ImplWriteExtendedPolyPolygonAction(rOStm, aPolyPolygon, true))\n                {\n                    nCount++;\n                }\n            }\n            break;\n\n            case MetaActionType::POLYPOLYGON:\n            {\n                const MetaPolyPolygonAction* pAct = static_cast<const MetaPolyPolygonAction*>(pAction);\n                ImplWritePolyPolyAction( rOStm, pAct->GetPolyPolygon() );\n                nCount++;\n\n                if(ImplWriteExtendedPolyPolygonAction(rOStm, pAct->GetPolyPolygon(), true))\n                {\n                    nCount++;\n                }\n            }\n            break;\n\n            case MetaActionType::TEXT:\n            {\n                const MetaTextAction* pAct = static_cast<const MetaTextAction*>(pAction);\n                OUString aUniText( pAct->GetText() );\n                OString  aText(OUStringToOString(aUniText, rActualCharSet));\n                const sal_Int32 nStrLen = aText.getLength();\n\n                if ( ImplWriteUnicodeComment( rOStm, aUniText ) )\n                    nCount++;\n\n                rOStm.WriteInt16( GDI_TEXT_ACTION );\n                rOStm.WriteInt32( 24 + ( nStrLen + 1 ) );\n                WritePair( rOStm, pAct->GetPoint() );\n                rOStm.WriteInt32( pAct->GetIndex() );\n                rOStm.WriteInt32( pAct->GetLen() );\n                rOStm.WriteInt32( nStrLen );\n                rOStm.WriteBytes( aText.getStr(), nStrLen + 1 );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::TEXTARRAY:\n            {\n                const MetaTextArrayAction* pAct = static_cast<const MetaTextArrayAction*>(pAction);\n                OString aText(OUStringToOString(pAct->GetText(), rActualCharSet));\n                OUString aUniText = pAct->GetText().copy(\n                        pAct->GetIndex(),\n                        std::min<sal_Int32>(pAct->GetText().getLength() - pAct->GetIndex(), pAct->GetLen()) );\n                sal_Int32 nAryLen;\n                sal_Int32 nLen = pAct->GetLen();\n                const sal_Int32 nTextLen = aText.getLength();\n                long* pDXArray = pAct->GetDXArray();\n\n                if ( ImplWriteUnicodeComment( rOStm, aUniText ) )\n                    nCount++;\n\n                if( ( nLen + pAct->GetIndex() ) > nTextLen )\n                {\n                    if( pAct->GetIndex() <= nTextLen )\n                        nLen = nTextLen - pAct->GetIndex();\n                    else\n                        nLen = 0;\n                }\n\n                if( !pDXArray || !nLen )\n                    nAryLen = 0;\n                else\n                    nAryLen = nLen; // #105987# Write out all of DX array\n\n                rOStm.WriteInt16( GDI_TEXTARRAY_ACTION );\n                rOStm.WriteInt32( 28 + ( nLen + 1 ) + ( nAryLen * 4 ) );\n                WritePair( rOStm, pAct->GetPoint() );\n                rOStm.WriteInt32( 0 );\n                rOStm.WriteInt32( nLen );\n                rOStm.WriteInt32( nLen );\n                rOStm.WriteInt32( nAryLen );\n                rOStm.WriteBytes( aText.getStr()+pAct->GetIndex(), nLen + 1 );\n\n                for (sal_Int32 n = 0; n < nAryLen; ++n)\n                    rOStm.WriteInt32( pDXArray[ n ] );\n\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::STRETCHTEXT:\n            {\n                const MetaStretchTextAction* pAct = static_cast<const MetaStretchTextAction*>(pAction);\n                OUString aUniText( pAct->GetText() );\n                OString  aText(OUStringToOString(aUniText, rActualCharSet));\n                const sal_Int32 nStrLen = aText.getLength();\n\n                if ( ImplWriteUnicodeComment( rOStm, aUniText ) )\n                    nCount++;\n\n                rOStm.WriteInt16( GDI_STRETCHTEXT_ACTION );\n                rOStm.WriteInt32( 28 + ( nStrLen + 1 ) );\n                WritePair( rOStm, pAct->GetPoint() );\n                rOStm.WriteInt32( pAct->GetIndex() );\n                rOStm.WriteInt32( pAct->GetLen() );\n                rOStm.WriteInt32( nStrLen );\n                rOStm.WriteInt32( pAct->GetWidth() );\n                rOStm.WriteBytes( aText.getStr(), nStrLen + 1 );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::BMP:\n            {\n                const MetaBmpAction* pAct = static_cast<const MetaBmpAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_BITMAP_ACTION );\n                rOStm.WriteInt32( 12 );\n                WritePair( rOStm, pAct->GetPoint() );\n                WriteDIB(pAct->GetBitmap(), rOStm, false, true);\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::BMPSCALE:\n            {\n                const MetaBmpScaleAction* pAct = static_cast<const MetaBmpScaleAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_BITMAPSCALE_ACTION );\n                rOStm.WriteInt32( 20 );\n                WritePair( rOStm, pAct->GetPoint() );\n                WritePair( rOStm, pAct->GetSize() );\n                WriteDIB(pAct->GetBitmap(), rOStm, false, true);\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::BMPSCALEPART:\n            {\n                const MetaBmpScalePartAction* pAct = static_cast<const MetaBmpScalePartAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_BITMAPSCALEPART_ACTION );\n                rOStm.WriteInt32( 36 );\n                WritePair( rOStm, pAct->GetDestPoint() );\n                WritePair( rOStm, pAct->GetDestSize() );\n                WritePair( rOStm, pAct->GetSrcPoint() );\n                WritePair( rOStm, pAct->GetSrcSize() );\n                WriteDIB(pAct->GetBitmap(), rOStm, false, true);\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::BMPEX:\n            {\n                const MetaBmpExAction* pAct = static_cast<const MetaBmpExAction*>(pAction);\n                const Bitmap           aBmp( Graphic( pAct->GetBitmapEx() ).GetBitmap() );\n\n                rOStm.WriteInt16( GDI_BITMAP_ACTION );\n                rOStm.WriteInt32( 12 );\n                WritePair( rOStm, pAct->GetPoint() );\n                WriteDIB(aBmp, rOStm, false, true);\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::BMPEXSCALE:\n            {\n                const MetaBmpExScaleAction* pAct = static_cast<const MetaBmpExScaleAction*>(pAction);\n                const Bitmap                aBmp( Graphic( pAct->GetBitmapEx() ).GetBitmap() );\n\n                rOStm.WriteInt16( GDI_BITMAPSCALE_ACTION );\n                rOStm.WriteInt32( 20 );\n                WritePair( rOStm, pAct->GetPoint() );\n                WritePair( rOStm, pAct->GetSize() );\n                WriteDIB(aBmp, rOStm, false, true);\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::BMPEXSCALEPART:\n            {\n                const MetaBmpExScalePartAction* pAct = static_cast<const MetaBmpExScalePartAction*>(pAction);\n                const Bitmap                    aBmp( Graphic( pAct->GetBitmapEx() ).GetBitmap() );\n\n                rOStm.WriteInt16( GDI_BITMAPSCALEPART_ACTION );\n                rOStm.WriteInt32( 36 );\n                WritePair( rOStm, pAct->GetDestPoint() );\n                WritePair( rOStm, pAct->GetDestSize() );\n                WritePair( rOStm, pAct->GetSrcPoint() );\n                WritePair( rOStm, pAct->GetSrcSize() );\n                WriteDIB(aBmp, rOStm, false, true);\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::GRADIENT:\n            {\n                const MetaGradientAction* pAct = static_cast<const MetaGradientAction*>(pAction);\n                const Gradient&           rGrad = pAct->GetGradient();\n\n                rOStm.WriteInt16( GDI_GRADIENT_ACTION );\n                rOStm.WriteInt32( 46 );\n                ImplWriteRect( rOStm, pAct->GetRect() );\n                rOStm.WriteInt16( (sal_Int16)rGrad.GetStyle() );\n                ImplWriteColor( rOStm, rGrad.GetStartColor() );\n                ImplWriteColor( rOStm, rGrad.GetEndColor() );\n                rOStm.WriteInt16( rGrad.GetAngle() );\n                rOStm.WriteInt16( rGrad.GetBorder() );\n                rOStm.WriteInt16( rGrad.GetOfsX() );\n                rOStm.WriteInt16( rGrad.GetOfsY() );\n                rOStm.WriteInt16( rGrad.GetStartIntensity() );\n                rOStm.WriteInt16( rGrad.GetEndIntensity() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::GRADIENTEX:\n            {\n                const MetaGradientExAction* pA = static_cast<const MetaGradientExAction*>(pAction);\n                sal_uLong                   nOldPos, nNewPos;\n\n                // write RefPoint comment\n                rOStm.WriteInt16( GDI_GRADIENTEX_COMMENT );\n\n                // we'll write the ActionSize later\n                nOldPos = rOStm.Tell();\n                rOStm.SeekRel( 4 );\n\n                // write data\n                WritePolyPolygon( rOStm, pA->GetPolyPolygon() );\n                WriteGradient( rOStm, pA->GetGradient() );\n                rOStm.WriteInt32( 0 ); // number of actions that follow this comment\n\n                // calculate and write ActionSize of comment\n                nNewPos = rOStm.Tell();\n                rOStm.Seek( nOldPos );\n                rOStm.WriteInt32( nNewPos - nOldPos );\n                rOStm.Seek( nNewPos );\n\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::WALLPAPER:\n            {\n                const MetaWallpaperAction* pAct = static_cast<const MetaWallpaperAction*>(pAction);\n                const Color&               rColor = pAct->GetWallpaper().GetColor();\n\n                ImplWritePushAction( rOStm );\n                ImplWriteLineColor( rOStm, rColor, 1 );\n                ImplWriteFillColor( rOStm, rColor, 1 );\n\n                rOStm.WriteInt16( GDI_RECT_ACTION );\n                rOStm.WriteInt32( 28 );\n                ImplWriteRect( rOStm, pAct->GetRect() );\n                rOStm.WriteInt32( 0 );\n                rOStm.WriteInt32( 0 );\n\n                ImplWritePopAction( rOStm );\n                nCount += 5;\n            }\n            break;\n\n            case MetaActionType::CLIPREGION:\n            {\n                const MetaClipRegionAction* pAct = static_cast<const MetaClipRegionAction*>(pAction);\n                const vcl::Region&          rRegion = pAct->GetRegion();\n                Rectangle                   aClipRect;\n\n                rOStm.WriteInt16( GDI_CLIPREGION_ACTION );\n                rOStm.WriteInt32( 24 );\n\n                if( pAct->IsClipping() )\n                {\n                    aClipRect = rRegion.GetBoundRect();\n                    rOStm.WriteInt16( 1 );\n                }\n                else\n                    rOStm.WriteInt16( 0 );\n\n                rOStm.WriteInt16( 0 );\n                ImplWriteRect( rOStm, aClipRect );\n\n                if( pAct->IsClipping() )\n                    ImplWriteRect( rOStm, aClipRect );\n\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::ISECTRECTCLIPREGION:\n            {\n                const MetaISectRectClipRegionAction* pAct = static_cast<const MetaISectRectClipRegionAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_ISECTCLIPREGION_ACTION );\n                rOStm.WriteInt32( 20 );\n                WriteRectangle( rOStm, pAct->GetRect() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::MOVECLIPREGION:\n            {\n                const MetaMoveClipRegionAction* pAct = static_cast<const MetaMoveClipRegionAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_MOVECLIPREGION_ACTION );\n                rOStm.WriteInt32( 12 );\n                rOStm.WriteInt32( pAct->GetHorzMove() );\n                rOStm.WriteInt32( pAct->GetVertMove() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::LINECOLOR:\n            {\n                const MetaLineColorAction* pAct = static_cast<const MetaLineColorAction*>(pAction);\n                ImplWriteLineColor( rOStm, rLineCol = pAct->GetColor(), pAct->IsSetting() ? 1 : 0 );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::FILLCOLOR:\n            {\n                const MetaFillColorAction* pAct = static_cast<const MetaFillColorAction*>(pAction);\n                ImplWriteFillColor( rOStm, pAct->GetColor(), pAct->IsSetting() ? 1 : 0 );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::FONT:\n            {\n                rSaveVDev.SetFont( static_cast<const MetaFontAction*>(pAction)->GetFont() );\n                ImplWriteFont( rOStm, rSaveVDev.GetFont(), rActualCharSet );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::TEXTCOLOR:\n            {\n                vcl::Font aSaveFont( rSaveVDev.GetFont() );\n\n                aSaveFont.SetColor( static_cast<const MetaTextColorAction*>(pAction)->GetColor() );\n                rSaveVDev.SetFont( aSaveFont );\n                ImplWriteFont( rOStm, rSaveVDev.GetFont(), rActualCharSet );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::TEXTFILLCOLOR:\n            {\n                const MetaTextFillColorAction* pAct = static_cast<const MetaTextFillColorAction*>(pAction);\n                vcl::Font                      aSaveFont( rSaveVDev.GetFont() );\n\n                if( pAct->IsSetting() )\n                    aSaveFont.SetFillColor( pAct->GetColor() );\n                else\n                    aSaveFont.SetFillColor( Color( COL_TRANSPARENT ) );\n\n                rSaveVDev.SetFont( aSaveFont );\n                ImplWriteFont( rOStm, rSaveVDev.GetFont(), rActualCharSet );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::TEXTALIGN:\n            {\n                vcl::Font aSaveFont( rSaveVDev.GetFont() );\n\n                aSaveFont.SetAlignment( static_cast<const MetaTextAlignAction*>(pAction)->GetTextAlign() );\n                rSaveVDev.SetFont( aSaveFont );\n                ImplWriteFont( rOStm, rSaveVDev.GetFont(), rActualCharSet );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::MAPMODE:\n            {\n                const MetaMapModeAction* pAct = static_cast<const MetaMapModeAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_MAPMODE_ACTION );\n                rOStm.WriteInt32( 30 );\n                ImplWriteMapMode( rOStm, pAct->GetMapMode() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::PUSH:\n            {\n                ImplWritePushAction( rOStm );\n                rLineColStack.push( new Color( rLineCol ) );\n                rSaveVDev.Push();\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::POP:\n            {\n                Color* pCol;\n                if (rLineColStack.empty())\n                    pCol = nullptr;\n                else\n                {\n                    pCol = rLineColStack.top();\n                    rLineColStack.pop();\n                }\n\n                if( pCol )\n                {\n                    rLineCol = *pCol;\n                    delete pCol;\n                }\n\n                ImplWritePopAction( rOStm );\n                rSaveVDev.Pop();\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::RASTEROP:\n            {\n                const MetaRasterOpAction* pAct = static_cast<const MetaRasterOpAction*>(pAction);\n\n                if( ( pAct->GetRasterOp() != RasterOp::N0 ) && ( pAct->GetRasterOp() != RasterOp::N1 ) )\n                {\n                    sal_Int16 nRasterOp;\n\n                    // If RasterOp::N0/1 was set earlier, restore old state\n                    // via a Pop first\n                    if( rRop_0_1 )\n                    {\n                        ImplWritePopAction( rOStm );\n                        rSaveVDev.Pop();\n                        rRop_0_1 = false;\n                        nCount++;\n                    }\n\n                    switch( pAct->GetRasterOp() )\n                    {\n                        case RasterOp::OverPaint : nRasterOp = 0; break;\n                        case RasterOp::Xor :       nRasterOp = 4; break;\n                        case RasterOp::Invert:     nRasterOp = 1; break;\n                        default:                   nRasterOp = 0; break;\n                    }\n\n                    ImplWriteRasterOpAction( rOStm, nRasterOp );\n                    nCount++;\n                }\n                else\n                {\n                    ImplWritePushAction( rOStm );\n                    rSaveVDev.Push();\n\n                    if( pAct->GetRasterOp() == RasterOp::N0 )\n                    {\n                        ImplWriteLineColor( rOStm, COL_BLACK, 1 );\n                        ImplWriteFillColor( rOStm, COL_BLACK, 1 );\n                    }\n                    else\n                    {\n                        ImplWriteLineColor( rOStm, COL_WHITE, 1 );\n                        ImplWriteFillColor( rOStm, COL_WHITE, 1 );\n                    }\n\n                    ImplWriteRasterOpAction( rOStm, 0 );\n                    rRop_0_1 = true;\n                    nCount += 4;\n                }\n            }\n            break;\n\n            case MetaActionType::Transparent:\n            {\n                const tools::PolyPolygon& rPolyPoly = static_cast<const MetaTransparentAction*>(pAction)->GetPolyPolygon();\n                const sal_Int16           nTrans = static_cast<const MetaTransparentAction*>(pAction)->GetTransparence();\n                const sal_Int16           nBrushStyle = ( nTrans < 38 ) ? 8 : ( nTrans < 63 ) ? 9 : 10;\n                sal_uLong                 nOldPos, nNewPos;\n\n                // write transparence comment\n                rOStm.WriteInt16( GDI_TRANSPARENT_COMMENT );\n\n                // we'll write the ActionSize later\n                nOldPos = rOStm.Tell();\n                rOStm.SeekRel( 4 );\n\n                // write comment data\n                WritePolyPolygon( rOStm, rPolyPoly );\n                rOStm.WriteInt16( nTrans );\n                rOStm.WriteInt32( 15 ); // number of actions that follow this comment\n\n                // calculate and write ActionSize of comment\n                nNewPos = rOStm.Tell();\n                rOStm.Seek( nOldPos );\n                rOStm.WriteInt32( nNewPos - nOldPos );\n                rOStm.Seek( nNewPos );\n\n                {\n                    // write actions for transparence\n                    ImplWritePushAction( rOStm );\n                    {\n                        ImplWriteRasterOpAction( rOStm, 4 );\n                        ImplWritePolyPolyAction( rOStm, rPolyPoly );\n\n                        ImplWritePushAction( rOStm );\n                        {\n                            ImplWriteRasterOpAction( rOStm, 2 );\n                            ImplWriteFillColor( rOStm, COL_BLACK, nBrushStyle );\n                            ImplWritePolyPolyAction( rOStm, rPolyPoly );\n                        }\n                        ImplWritePopAction( rOStm );\n\n                        ImplWriteRasterOpAction( rOStm, 4 );\n                        ImplWritePolyPolyAction( rOStm, rPolyPoly );\n                    }\n                    ImplWritePopAction( rOStm );\n\n                    ImplWritePushAction( rOStm );\n                    {\n                        ImplWriteFillColor( rOStm, Color(), 0 );\n                        ImplWritePolyPolyAction( rOStm, rPolyPoly );\n                    }\n                    ImplWritePopAction( rOStm );\n\n                    nCount += 15;\n                }\n\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::FLOATTRANSPARENT:\n            {\n                const MetaFloatTransparentAction*   pA = static_cast<const MetaFloatTransparentAction*>(pAction);\n                const GDIMetaFile&                  rTransMtf = pA->GetGDIMetaFile();\n                const Point&                        rPos = pA->GetPoint();\n                const Size&                         rSize = pA->GetSize();\n                const Gradient&                     rGradient = pA->GetGradient();\n                sal_uLong                               nOldPos, nNewPos;\n\n                // write RefPoint comment\n                rOStm.WriteInt16( GDI_FLOATTRANSPARENT_COMMENT );\n\n                // we'll write the ActionSize later\n                nOldPos = rOStm.Tell();\n                rOStm.SeekRel( 4 );\n\n                // write comment data\n                WriteGDIMetaFile( rOStm, rTransMtf );\n                WritePair( rOStm, rPos );\n                WritePair( rOStm, rSize );\n                WriteGradient( rOStm, rGradient );\n\n                // calculate and write ActionSize of comment\n                nNewPos = rOStm.Tell();\n                rOStm.Seek( nOldPos );\n                rOStm.WriteInt32( nNewPos - nOldPos + 4 );\n                rOStm.Seek( ( nOldPos = nNewPos ) + 4 );\n\n                {\n                    // write actions for float transparence\n                    sal_uLong       nAddCount;\n                    GDIMetaFile     aMtf( rTransMtf );\n                    const Size      aSrcSize( rTransMtf.GetPrefSize() );\n                    Point           aSrcPt( rTransMtf.GetPrefMapMode().GetOrigin() );\n                    const double    fScaleX = aSrcSize.Width() ? (double) rSize.Width() / aSrcSize.Width() : 1.0;\n                    const double    fScaleY = aSrcSize.Height() ? (double) rSize.Height() / aSrcSize.Height() : 1.0;\n                    long            nMoveX, nMoveY;\n\n                    if( fScaleX != 1.0 || fScaleY != 1.0 )\n                    {\n                        aMtf.Scale( fScaleX, fScaleY );\n                        aSrcPt.X() = FRound( aSrcPt.X() * fScaleX );\n                        aSrcPt.Y() = FRound( aSrcPt.Y() * fScaleY );\n                    }\n\n                    nMoveX = rPos.X() - aSrcPt.X();\n                    nMoveY = rPos.Y() - aSrcPt.Y();\n\n                    if( nMoveX || nMoveY )\n                        aMtf.Move( nMoveX, nMoveY );\n\n                    nAddCount = ImplWriteActions( rOStm, aMtf, rSaveVDev, rRop_0_1, rLineCol, rLineColStack, rActualCharSet );\n                    nNewPos = rOStm.Tell();\n                    rOStm.Seek( nOldPos );\n                    rOStm.WriteInt32( nAddCount );\n                    rOStm.Seek( nNewPos );\n\n                    nCount += nAddCount;\n                }\n\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::HATCH:\n            {\n                const MetaHatchAction*    pA = static_cast<const MetaHatchAction*>(pAction);\n                const tools::PolyPolygon& rPolyPoly = pA->GetPolyPolygon();\n                const Hatch&            rHatch = pA->GetHatch();\n                sal_uLong               nOldPos, nNewPos, nAddCount;\n\n                // write hatch comment\n                rOStm.WriteInt16( GDI_HATCH_COMMENT );\n\n                // we'll write the ActionSize later\n                nOldPos = rOStm.Tell();\n                rOStm.SeekRel( 4 );\n\n                // write comment data\n                WritePolyPolygon( rOStm, rPolyPoly );\n                WriteHatch( rOStm, rHatch );\n\n                // calculate and write ActionSize of comment\n                nNewPos = rOStm.Tell();\n                rOStm.Seek( nOldPos );\n                rOStm.WriteInt32( nNewPos - nOldPos + 4 );\n                rOStm.Seek( ( nOldPos = nNewPos ) + 4 );\n\n                {\n                    // write actions for hatch\n                    ScopedVclPtrInstance< VirtualDevice > aVDev;\n                    GDIMetaFile     aTmpMtf;\n\n                    aVDev->AddHatchActions( rPolyPoly, rHatch, aTmpMtf );\n                    nAddCount = ImplWriteActions( rOStm, aTmpMtf, rSaveVDev, rRop_0_1, rLineCol, rLineColStack, rActualCharSet );\n                    nNewPos = rOStm.Tell();\n                    rOStm.Seek( nOldPos );\n                    rOStm.WriteInt32( nAddCount );\n                    rOStm.Seek( nNewPos );\n\n                    nCount += nAddCount;\n                }\n\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::REFPOINT:\n            {\n                const MetaRefPointAction*   pA = static_cast<const MetaRefPointAction*>(pAction);\n                const Point&                rRefPoint = pA->GetRefPoint();\n                const bool                  bSet = pA->IsSetting();\n                sal_uLong                   nOldPos, nNewPos;\n\n                // write RefPoint comment\n                rOStm.WriteInt16( GDI_REFPOINT_COMMENT );\n\n                // we'll write the ActionSize later\n                nOldPos = rOStm.Tell();\n                rOStm.SeekRel( 4 );\n\n                // write data\n                WritePair( rOStm, rRefPoint );\n                rOStm.WriteBool( bSet );\n                rOStm.WriteInt32( 0 ); // number of actions that follow this comment\n\n                // calculate and write ActionSize of comment\n                nNewPos = rOStm.Tell();\n                rOStm.Seek( nOldPos );\n                rOStm.WriteInt32( nNewPos - nOldPos );\n                rOStm.Seek( nNewPos );\n\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::TEXTLINECOLOR:\n            {\n                const MetaTextLineColorAction*  pA = static_cast<const MetaTextLineColorAction*>(pAction);\n                const Color&                    rColor = pA->GetColor();\n                const bool                      bSet = pA->IsSetting();\n                sal_uLong                       nOldPos, nNewPos;\n\n                // write RefPoint comment\n                rOStm.WriteInt16( GDI_TEXTLINECOLOR_COMMENT );\n\n                // we'll write the ActionSize later\n                nOldPos = rOStm.Tell();\n                rOStm.SeekRel( 4 );\n\n                // write data\n                WriteColor( rOStm, rColor );\n                rOStm.WriteBool( bSet );\n                rOStm.WriteInt32( 0 ); // number of actions that follow this comment\n\n                // calculate and write ActionSize of comment\n                nNewPos = rOStm.Tell();\n                rOStm.Seek( nOldPos );\n                rOStm.WriteInt32( nNewPos - nOldPos );\n                rOStm.Seek( nNewPos );\n\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::TEXTLINE:\n            {\n                const MetaTextLineAction*   pA = static_cast<const MetaTextLineAction*>(pAction);\n                const Point&                rStartPt = pA->GetStartPoint();\n                const sal_Int32             nWidth = (sal_Int32) pA->GetWidth();\n                const FontStrikeout         eStrikeout = pA->GetStrikeout();\n                const FontLineStyle         eUnderline = pA->GetUnderline();\n                sal_uLong                   nOldPos, nNewPos;\n\n                // write RefPoint comment\n                rOStm.WriteInt16( GDI_TEXTLINE_COMMENT );\n\n                // we'll write the ActionSize later\n                nOldPos = rOStm.Tell();\n                rOStm.SeekRel( 4 );\n\n                // write data\n                WritePair( rOStm, rStartPt );\n                rOStm.WriteInt32( nWidth ).WriteUInt32( eStrikeout ).WriteUInt32( eUnderline );\n                rOStm.WriteInt32( 0 ); // number of actions that follow this comment\n\n                // calculate and write ActionSize of comment\n                nNewPos = rOStm.Tell();\n                rOStm.Seek( nOldPos );\n                rOStm.WriteInt32( nNewPos - nOldPos );\n                rOStm.Seek( nNewPos );\n\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::EPS:\n            break;\n\n            case MetaActionType::COMMENT:\n            {\n                const MetaCommentAction*    pA = static_cast<const MetaCommentAction*>(pAction);\n                const sal_uInt32            nDataSize = pA->GetDataSize();\n                sal_uLong                   nOldPos, nNewPos;\n\n                // write RefPoint comment\n                rOStm.WriteInt16( GDI_COMMENT_COMMENT );\n\n                // we'll write the ActionSize later\n                nOldPos = rOStm.Tell();\n                rOStm.SeekRel( 4 );\n\n                // write data\n                write_uInt16_lenPrefixed_uInt8s_FromOString(rOStm, pA->GetComment());\n                rOStm.WriteInt32( pA->GetValue() ).WriteUInt32( nDataSize );\n\n                if( nDataSize )\n                    rOStm.WriteBytes( pA->GetData(), nDataSize );\n\n                rOStm.WriteInt32( 0 ); // number of actions that follow this comment\n\n                // calculate and write ActionSize of comment\n                nNewPos = rOStm.Tell();\n                rOStm.Seek( nOldPos );\n                rOStm.WriteInt32( nNewPos - nOldPos );\n                rOStm.Seek( nNewPos );\n\n                nCount++;\n            }\n            break;\n\n            default:\n#ifdef DBG_UTIL\n            {\n                OStringBuffer aStr(\"Missing implementation for Action#: \");\n                aStr.append(static_cast<sal_Int32>(pAction->GetType()));\n                aStr.append('!');\n                OSL_FAIL(aStr.getStr());\n            }\n#endif\n            break;\n        }\n    }\n\n    return nCount;\n}\n\n/* vim:set shiftwidth=4 softtabstop=4 expandtab: */\n"], "fixing_code": ["/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n/*\n * This file is part of the LibreOffice project.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This file incorporates work covered by the following license notice:\n *\n *   Licensed to the Apache Software Foundation (ASF) under one or more\n *   contributor license agreements. See the NOTICE file distributed\n *   with this work for additional information regarding copyright\n *   ownership. The ASF licenses this file to you under the Apache\n *   License, Version 2.0 (the \"License\"); you may not use this file\n *   except in compliance with the License. You may obtain a copy of\n *   the License at http://www.apache.org/licenses/LICENSE-2.0 .\n */\n\n#include <algorithm>\n#include <string.h>\n#include <osl/thread.h>\n#include <tools/debug.hxx>\n#include <tools/fract.hxx>\n#include <tools/stream.hxx>\n#include <tools/helpers.hxx>\n#include <vcl/dibtools.hxx>\n#include <vcl/virdev.hxx>\n#include <vcl/graph.hxx>\n#include <vcl/lineinfo.hxx>\n#include <rtl/strbuf.hxx>\n\n#include \"svmconverter.hxx\"\n\n#include <memory>\n#include <o3tl/make_unique.hxx>\n\n// Inlines\nvoid ImplReadRect( SvStream& rIStm, Rectangle& rRect )\n{\n    Point aTL;\n    Point aBR;\n\n    ReadPair( rIStm, aTL );\n    ReadPair( rIStm, aBR );\n\n    rRect = Rectangle( aTL, aBR );\n}\n\nvoid ImplWriteRect( SvStream& rOStm, const Rectangle& rRect )\n{\n    WritePair( rOStm, rRect.TopLeft() );\n    WritePair( rOStm, rRect.BottomRight() );\n}\n\nbool ImplReadPoly(SvStream& rIStm, tools::Polygon& rPoly)\n{\n    sal_Int32 nSize32(0);\n    rIStm.ReadInt32(nSize32);\n    sal_uInt16 nSize = nSize32;\n\n    const size_t nMaxPossiblePoints = rIStm.remainingSize() / 2 * sizeof(sal_Int32);\n    if (nSize > nMaxPossiblePoints)\n    {\n        SAL_WARN(\"vcl.gdi\", \"svm record claims to have: \" << nSize << \" points, but only \" << nMaxPossiblePoints << \" possible\");\n        return false;\n    }\n\n    rPoly = tools::Polygon(nSize);\n\n    for (sal_uInt16 i = 0; i < nSize && rIStm.good(); ++i)\n        ReadPair(rIStm, rPoly[i]);\n\n    return rIStm.good();\n}\n\nbool ImplReadPolyPoly(SvStream& rIStm, tools::PolyPolygon& rPolyPoly)\n{\n    bool bSuccess = true;\n\n    tools::Polygon aPoly;\n    sal_Int32 nPolyCount32(0);\n    rIStm.ReadInt32(nPolyCount32);\n    sal_uInt16 nPolyCount = (sal_uInt16)nPolyCount32;\n\n    for (sal_uInt16 i = 0; i < nPolyCount && rIStm.good(); ++i)\n    {\n        if (!ImplReadPoly(rIStm, aPoly))\n        {\n            bSuccess = false;\n            break;\n        }\n        rPolyPoly.Insert(aPoly);\n    }\n\n    return bSuccess && rIStm.good();\n}\n\nvoid ImplWritePolyPolyAction( SvStream& rOStm, const tools::PolyPolygon& rPolyPoly )\n{\n    const sal_uInt16    nPoly = rPolyPoly.Count();\n    sal_uInt16          nPoints = 0;\n    sal_uInt16          n;\n\n    for( n = 0; n < nPoly; n++ )\n        nPoints = sal::static_int_cast<sal_uInt16>(nPoints + rPolyPoly[ n ].GetSize());\n\n    rOStm.WriteInt16( GDI_POLYPOLYGON_ACTION );\n    rOStm.WriteInt32( 8 + ( nPoly << 2 ) + ( nPoints << 3 ) );\n    rOStm.WriteInt32( nPoly );\n\n    for( n = 0; n < nPoly; n++ )\n    {\n        // #i102224# Here the possible curved nature of Polygon was\n        // ignored (for all those years). Adapted to at least write\n        // a polygon representing the curve as good as possible\n        tools::Polygon aSimplePoly;\n         rPolyPoly[n].AdaptiveSubdivide(aSimplePoly);\n         const sal_uInt16 nSize(aSimplePoly.GetSize());\n\n        rOStm.WriteInt32( nSize );\n\n        for( sal_uInt16 j = 0; j < nSize; j++ )\n            WritePair( rOStm, aSimplePoly[ j ] );\n    }\n}\n\nvoid ImplReadColor( SvStream& rIStm, Color& rColor )\n{\n    sal_Int16 nVal(0);\n\n    rIStm.ReadInt16( nVal ); rColor.SetRed( sal::static_int_cast<sal_uInt8>((sal_uInt16)nVal >> 8) );\n    rIStm.ReadInt16( nVal ); rColor.SetGreen( sal::static_int_cast<sal_uInt8>((sal_uInt16)nVal >> 8) );\n    rIStm.ReadInt16( nVal ); rColor.SetBlue( sal::static_int_cast<sal_uInt8>((sal_uInt16)nVal >> 8) );\n}\n\nvoid ImplWriteColor( SvStream& rOStm, const Color& rColor )\n{\n    sal_Int16 nVal;\n\n    nVal = ( (sal_Int16) rColor.GetRed() << 8 ) | rColor.GetRed();\n    rOStm.WriteInt16( nVal );\n\n    nVal = ( (sal_Int16) rColor.GetGreen() << 8 ) | rColor.GetGreen();\n    rOStm.WriteInt16( nVal );\n\n    nVal = ( (sal_Int16) rColor.GetBlue() << 8 ) | rColor.GetBlue();\n    rOStm.WriteInt16( nVal );\n}\n\nbool ImplReadMapMode(SvStream& rIStm, MapMode& rMapMode)\n{\n    sal_Int16 nUnit(0);\n    rIStm.ReadInt16(nUnit);\n\n    Point aOrg;\n    ReadPair(rIStm, aOrg);\n\n    sal_Int32 nXNum(0), nXDenom(0), nYNum(0), nYDenom(0);\n    rIStm.ReadInt32(nXNum).ReadInt32(nXDenom).ReadInt32(nYNum).ReadInt32(nYDenom);\n\n    if (!rIStm.good() || nXDenom == 0 || nYDenom == 0)\n    {\n        SAL_WARN(\"vcl.gdi\", \"Parsing error: invalid mapmode fraction\");\n        return false;\n    }\n\n    rMapMode = MapMode( (MapUnit) nUnit, aOrg, Fraction( nXNum, nXDenom ), Fraction( nYNum, nYDenom ) );\n\n    return true;\n}\n\nvoid ImplWriteMapMode( SvStream& rOStm, const MapMode& rMapMode )\n{\n    rOStm.WriteInt16( (sal_uInt16)rMapMode.GetMapUnit() );\n    WritePair( rOStm, rMapMode.GetOrigin() );\n    rOStm.WriteInt32( rMapMode.GetScaleX().GetNumerator() );\n    rOStm.WriteInt32( rMapMode.GetScaleX().GetDenominator() );\n    rOStm.WriteInt32( rMapMode.GetScaleY().GetNumerator() );\n    rOStm.WriteInt32( rMapMode.GetScaleY().GetDenominator() );\n}\n\nvoid ImplWritePushAction( SvStream& rOStm )\n{\n    rOStm.WriteInt16( GDI_PUSH_ACTION );\n    rOStm.WriteInt32( 4 );\n}\n\nvoid ImplWritePopAction( SvStream& rOStm )\n{\n    rOStm.WriteInt16( GDI_POP_ACTION );\n    rOStm.WriteInt32( 4 );\n}\n\nvoid ImplWriteLineColor( SvStream& rOStm, const Color& rColor, sal_Int16 nStyle, sal_Int32 nWidth = 0 )\n{\n    if( rColor.GetTransparency() > 127 )\n        nStyle = 0;\n\n    rOStm.WriteInt16( GDI_PEN_ACTION );\n    rOStm.WriteInt32( 16 );\n    ImplWriteColor( rOStm, rColor );\n    rOStm.WriteInt32( nWidth );\n    rOStm.WriteInt16( nStyle );\n}\n\nvoid ImplWriteFillColor( SvStream& rOStm, const Color& rColor, sal_Int16 nStyle )\n{\n    rOStm.WriteInt16( GDI_FILLBRUSH_ACTION );\n    rOStm.WriteInt32( 20 );\n    ImplWriteColor( rOStm, rColor );\n\n    if( rColor.GetTransparency() > 127 )\n        nStyle = 0;\n\n    if( nStyle > 1 )\n    {\n        ImplWriteColor( rOStm, COL_WHITE );\n        rOStm.WriteInt16( nStyle );\n        rOStm.WriteInt16( 1 );\n    }\n    else\n    {\n        ImplWriteColor( rOStm, COL_BLACK );\n        rOStm.WriteInt16( nStyle );\n        rOStm.WriteInt16( 0 );\n    }\n}\n\nvoid ImplWriteFont( SvStream& rOStm, const vcl::Font& rFont,\n                    rtl_TextEncoding& rActualCharSet )\n{\n    char    aName[33];\n    short   nWeight;\n\n    OString aByteName(OUStringToOString(rFont.GetFamilyName(),\n        rOStm.GetStreamCharSet()));\n    strncpy( aName, aByteName.getStr(), 32 );\n    aName[32] = 0;\n\n    switch ( rFont.GetWeight() )\n    {\n        case WEIGHT_THIN:\n        case WEIGHT_ULTRALIGHT:\n        case WEIGHT_LIGHT:\n            nWeight = 1;\n        break;\n\n        case WEIGHT_NORMAL:\n        case WEIGHT_MEDIUM:\n            nWeight = 2;\n        break;\n\n        case WEIGHT_BOLD:\n        case WEIGHT_ULTRABOLD:\n        case WEIGHT_BLACK:\n            nWeight = 3;\n        break;\n\n        default:\n            nWeight = 0;\n        break;\n    }\n\n    rOStm.WriteInt16( GDI_FONT_ACTION );\n    rOStm.WriteInt32( 78 );\n\n    rActualCharSet = GetStoreCharSet( rFont.GetCharSet() );\n    ImplWriteColor( rOStm, rFont.GetColor() );\n    ImplWriteColor( rOStm, rFont.GetFillColor() );\n    rOStm.WriteBytes( aName, 32 );\n    WritePair( rOStm, rFont.GetFontSize() );\n    rOStm.WriteInt16( 0 ); // no character orientation anymore\n    rOStm.WriteInt16( rFont.GetOrientation() );\n    rOStm.WriteInt16( rActualCharSet );\n    rOStm.WriteInt16( rFont.GetFamilyType() );\n    rOStm.WriteInt16( rFont.GetPitch() );\n    rOStm.WriteInt16( rFont.GetAlignment() );\n    rOStm.WriteInt16( nWeight );\n    rOStm.WriteInt16( rFont.GetUnderline() );\n    rOStm.WriteInt16( rFont.GetStrikeout() );\n    rOStm.WriteBool( rFont.GetItalic() != ITALIC_NONE );\n    rOStm.WriteBool( rFont.IsOutline() );\n    rOStm.WriteBool( rFont.IsShadow() );\n    rOStm.WriteBool( rFont.IsTransparent() );\n    if ( rActualCharSet == RTL_TEXTENCODING_DONTKNOW )\n        rActualCharSet = osl_getThreadTextEncoding();\n}\n\nvoid ImplWriteRasterOpAction( SvStream& rOStm, sal_Int16 nRasterOp )\n{\n    rOStm.WriteInt16( GDI_RASTEROP_ACTION ).WriteInt32( 6 ).WriteInt16( nRasterOp );\n}\n\nbool ImplWriteUnicodeComment( SvStream& rOStm, const OUString& rString )\n{\n    sal_Int32 nStringLen = rString.getLength();\n    if ( nStringLen )\n    {\n        sal_uInt32  nSize = ( nStringLen << 1 ) + 4;\n        sal_uInt16  nType = GDI_UNICODE_COMMENT;\n\n        rOStm.WriteUInt16( nType ).WriteUInt32( nSize );\n        write_uInt16s_FromOUString(rOStm, rString);\n    }\n    return nStringLen != 0;\n}\n\nvoid ImplReadUnicodeComment( sal_uInt32 nStrmPos, SvStream& rIStm, OUString& rString )\n{\n    sal_uInt32 nOld = rIStm.Tell();\n    if ( nStrmPos )\n    {\n        sal_uInt16  nType;\n        sal_uInt32  nActionSize;\n        std::size_t nStringLen;\n\n        rIStm.Seek( nStrmPos );\n        rIStm  .ReadUInt16( nType )\n               .ReadUInt32( nActionSize );\n\n        nStringLen = (nActionSize - 4) >> 1;\n\n        if ( nStringLen && ( nType == GDI_UNICODE_COMMENT ) )\n            rString = read_uInt16s_ToOUString(rIStm, nStringLen);\n    }\n    rIStm.Seek( nOld );\n}\n\nvoid ImplSkipActions(SvStream& rIStm, sal_uLong nSkipCount)\n{\n    sal_Int32 nActionSize;\n    sal_Int16 nType;\n    for (sal_uLong i = 0UL; i < nSkipCount; ++i)\n    {\n        rIStm.ReadInt16(nType).ReadInt32(nActionSize);\n        if (!rIStm.good() || nActionSize < 4)\n            break;\n        rIStm.SeekRel(nActionSize - 4);\n    }\n}\n\nbool ImplWriteExtendedPolyPolygonAction(SvStream& rOStm, const tools::PolyPolygon& rPolyPolygon, bool bOnlyWhenCurve)\n{\n    const sal_uInt16 nPolygonCount(rPolyPolygon.Count());\n\n    if(nPolygonCount)\n    {\n        sal_uInt32 nAllPolygonCount(0);\n        sal_uInt32 nAllPointCount(0);\n        sal_uInt32 nAllFlagCount(0);\n        sal_uInt16 a(0);\n\n        for(a = 0; a < nPolygonCount; a++)\n        {\n            const tools::Polygon& rCandidate = rPolyPolygon.GetObject(a);\n            const sal_uInt16 nPointCount(rCandidate.GetSize());\n\n            if(nPointCount)\n            {\n                nAllPolygonCount++;\n                nAllPointCount += nPointCount;\n\n                if(rCandidate.HasFlags())\n                {\n                    nAllFlagCount += nPointCount;\n                }\n            }\n        }\n\n        if((bOnlyWhenCurve && nAllFlagCount) || (!bOnlyWhenCurve && nAllPointCount))\n        {\n            rOStm.WriteInt16( GDI_EXTENDEDPOLYGON_ACTION );\n\n            const sal_Int32 nActionSize(\n                4 +                         // Action size\n                2 +                         // PolygonCount\n                (nAllPolygonCount * 2) +    // Points per polygon\n                (nAllPointCount << 3) +     // Points themselves\n                nAllPolygonCount +          // Bool if (when poly has points) it has flags, too\n                nAllFlagCount);             // Flags themselves\n\n            rOStm.WriteInt32( nActionSize );\n            rOStm.WriteUInt16( nAllPolygonCount );\n\n            for(a = 0; a < nPolygonCount; a++)\n            {\n                const tools::Polygon& rCandidate = rPolyPolygon.GetObject(a);\n                const sal_uInt16 nPointCount(rCandidate.GetSize());\n\n                if(nPointCount)\n                {\n                    rOStm.WriteUInt16( nPointCount );\n\n                    for(sal_uInt16 b(0); b < nPointCount; b++)\n                    {\n                        WritePair( rOStm, rCandidate[b] );\n                    }\n\n                    if(rCandidate.HasFlags())\n                    {\n                        rOStm.WriteBool( true );\n\n                        for(sal_uInt16 c(0); c < nPointCount; c++)\n                        {\n                            rOStm.WriteUChar( (sal_uInt8)rCandidate.GetFlags(c) );\n                        }\n                    }\n                    else\n                    {\n                        rOStm.WriteBool( false );\n                    }\n                }\n            }\n\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvoid ImplReadExtendedPolyPolygonAction(SvStream& rIStm, tools::PolyPolygon& rPolyPoly)\n{\n    rPolyPoly.Clear();\n    sal_uInt16 nPolygonCount(0);\n    rIStm.ReadUInt16( nPolygonCount );\n\n    if (!nPolygonCount)\n        return;\n\n    const size_t nMinRecordSize = sizeof(sal_uInt16);\n    const size_t nMaxRecords = rIStm.remainingSize() / nMinRecordSize;\n    if (nPolygonCount > nMaxRecords)\n    {\n        SAL_WARN(\"vcl.gdi\", \"Parsing error: \" << nMaxRecords <<\n                 \" max possible entries, but \" << nPolygonCount << \" claimed, truncating\");\n        nPolygonCount = nMaxRecords;\n    }\n\n    for(sal_uInt16 a(0); a < nPolygonCount; a++)\n    {\n        sal_uInt16 nPointCount(0);\n        rIStm.ReadUInt16(nPointCount);\n\n        const size_t nMinPolygonSize = sizeof(sal_Int32) * 2;\n        const size_t nMaxPolygons = rIStm.remainingSize() / nMinPolygonSize;\n        if (nPointCount > nMaxPolygons)\n        {\n            SAL_WARN(\"vcl.gdi\", \"Parsing error: \" << nMaxPolygons <<\n                     \" max possible entries, but \" << nPointCount << \" claimed, truncating\");\n            nPointCount = nMaxPolygons;\n        }\n\n        tools::Polygon aCandidate(nPointCount);\n\n        if (nPointCount)\n        {\n            for(sal_uInt16 b(0); b < nPointCount; b++)\n            {\n                ReadPair( rIStm , aCandidate[b] );\n            }\n\n            sal_uInt8 bHasFlags(int(false));\n            rIStm.ReadUChar( bHasFlags );\n\n            if(bHasFlags)\n            {\n                sal_uInt8 aPolyFlags(0);\n\n                for(sal_uInt16 c(0); c < nPointCount; c++)\n                {\n                    rIStm.ReadUChar( aPolyFlags );\n                    aCandidate.SetFlags(c, (PolyFlags)aPolyFlags);\n                }\n            }\n        }\n\n        rPolyPoly.Insert(aCandidate);\n    }\n}\n\nSVMConverter::SVMConverter( SvStream& rStm, GDIMetaFile& rMtf, sal_uLong nConvertMode )\n{\n    if( !rStm.GetError() )\n    {\n        if( CONVERT_FROM_SVM1 == nConvertMode )\n            ImplConvertFromSVM1( rStm, rMtf );\n        else if( CONVERT_TO_SVM1 == nConvertMode )\n            ImplConvertToSVM1( rStm, rMtf );\n    }\n}\n\n#define LF_FACESIZE 32\n\nvoid SVMConverter::ImplConvertFromSVM1( SvStream& rIStm, GDIMetaFile& rMtf )\n{\n    const sal_uLong         nPos = rIStm.Tell();\n    const SvStreamEndian    nOldFormat = rIStm.GetEndian();\n\n    rIStm.SetEndian( SvStreamEndian::LITTLE );\n\n    char    aCode[ 5 ];\n    Size    aPrefSz;\n\n    // read header\n    rIStm.ReadBytes(aCode, sizeof(aCode));  // Identifier\n    sal_Int16 nSize(0);\n    rIStm.ReadInt16( nSize );                                 // Size\n    sal_Int16 nVersion(0);\n    rIStm.ReadInt16( nVersion );                              // Version\n    sal_Int32 nTmp32(0);\n    rIStm.ReadInt32( nTmp32 );\n    aPrefSz.Width() = nTmp32;                       // PrefSize.Width()\n    rIStm.ReadInt32( nTmp32 );\n    aPrefSz.Height() = nTmp32;                      // PrefSize.Height()\n\n    // check header-magic and version\n    if( rIStm.GetError()\n        || ( memcmp( aCode, \"SVGDI\", sizeof( aCode ) ) != 0 )\n        || ( nVersion != 200 ) )\n    {\n        rIStm.SetError( SVSTREAM_FILEFORMAT_ERROR );\n        rIStm.SetEndian( nOldFormat );\n        rIStm.Seek( nPos );\n        return;\n    }\n\n    LineInfo            aLineInfo( LineStyle::NONE, 0 );\n    std::stack<std::unique_ptr<LineInfo>> aLIStack;\n    ScopedVclPtrInstance< VirtualDevice > aFontVDev;\n    rtl_TextEncoding    eActualCharSet = osl_getThreadTextEncoding();\n    bool                bFatLine = false;\n\n    tools::Polygon     aActionPoly;\n    Rectangle   aRect;\n    Point       aPt, aPt1;\n    Size        aSz;\n    Color       aActionColor;\n\n    sal_uInt32  nUnicodeCommentStreamPos = 0;\n    sal_Int32       nUnicodeCommentActionNumber = 0;\n\n    rMtf.SetPrefSize(aPrefSz);\n\n    MapMode aMapMode;\n    if (ImplReadMapMode(rIStm, aMapMode))           // MapMode\n        rMtf.SetPrefMapMode(aMapMode);\n\n    sal_Int32 nActions(0);\n    rIStm.ReadInt32(nActions);                      // Action count\n    if (nActions < 0)\n    {\n        SAL_WARN(\"vcl.gdi\", \"svm claims negative action count (\" << nActions << \")\");\n        nActions = 0;\n    }\n\n    const size_t nMinActionSize = sizeof(sal_uInt16) + sizeof(sal_Int32);\n    const size_t nMaxPossibleActions = rIStm.remainingSize() / nMinActionSize;\n    if (static_cast<sal_uInt32>(nActions) > nMaxPossibleActions)\n    {\n        SAL_WARN(\"vcl.gdi\", \"svm claims more actions (\" << nActions << \") than stream could provide, truncating\");\n        nActions = nMaxPossibleActions;\n    }\n\n    size_t nLastPolygonAction(0);\n\n    for (sal_Int32 i = 0; i < nActions && rIStm.good(); ++i)\n    {\n        sal_Int16 nType(0);\n        rIStm.ReadInt16(nType);\n        sal_Int32 nActBegin = rIStm.Tell();\n        sal_Int32 nActionSize(0);\n        rIStm.ReadInt32(nActionSize);\n\n        SAL_WARN_IF( ( nType > 33 ) && ( nType < 1024 ), \"vcl.gdi\", \"Unknown GDIMetaAction while converting!\" );\n\n        switch( nType )\n        {\n            case GDI_PIXEL_ACTION:\n            {\n                ReadPair( rIStm, aPt );\n                ImplReadColor( rIStm, aActionColor );\n                rMtf.AddAction( new MetaPixelAction( aPt, aActionColor ) );\n            }\n            break;\n\n            case GDI_POINT_ACTION:\n            {\n                ReadPair( rIStm, aPt );\n                rMtf.AddAction( new MetaPointAction( aPt ) );\n            }\n            break;\n\n            case GDI_LINE_ACTION:\n            {\n                ReadPair( rIStm, aPt );\n                ReadPair( rIStm, aPt1 );\n                rMtf.AddAction( new MetaLineAction( aPt, aPt1, aLineInfo ) );\n            }\n            break;\n\n            case GDI_LINEJOIN_ACTION :\n            {\n                sal_Int16 nLineJoin(0);\n                rIStm.ReadInt16( nLineJoin );\n                aLineInfo.SetLineJoin((basegfx::B2DLineJoin)nLineJoin);\n            }\n            break;\n\n            case GDI_LINECAP_ACTION :\n            {\n                sal_Int16 nLineCap(0);\n                rIStm.ReadInt16( nLineCap );\n                aLineInfo.SetLineCap((css::drawing::LineCap)nLineCap);\n            }\n            break;\n\n            case GDI_LINEDASHDOT_ACTION :\n            {\n                sal_Int16 a(0);\n                sal_Int32 b(0);\n\n                rIStm.ReadInt16( a ); aLineInfo.SetDashCount(a);\n                rIStm.ReadInt32( b ); aLineInfo.SetDashLen(b);\n                rIStm.ReadInt16( a ); aLineInfo.SetDotCount(a);\n                rIStm.ReadInt32( b ); aLineInfo.SetDotLen(b);\n                rIStm.ReadInt32( b ); aLineInfo.SetDistance(b);\n\n                if(((aLineInfo.GetDashCount() && aLineInfo.GetDashLen())\n                    || (aLineInfo.GetDotCount() && aLineInfo.GetDotLen()))\n                    && aLineInfo.GetDistance())\n                {\n                    aLineInfo.SetStyle(LineStyle::Dash);\n                }\n            }\n            break;\n\n            case GDI_EXTENDEDPOLYGON_ACTION :\n            {\n                // read the tools::PolyPolygon in every case\n                tools::PolyPolygon aInputPolyPolygon;\n                ImplReadExtendedPolyPolygonAction(rIStm, aInputPolyPolygon);\n\n                // now check if it can be set somewhere\n                if(nLastPolygonAction < rMtf.GetActionSize())\n                {\n                    MetaPolyLineAction* pPolyLineAction = dynamic_cast< MetaPolyLineAction* >(rMtf.GetAction(nLastPolygonAction));\n\n                    if(pPolyLineAction)\n                    {\n                        // replace MetaPolyLineAction when we have a single polygon. Do not rely on the\n                        // same point count; the originally written GDI_POLYLINE_ACTION may have been\n                        // Subdivided for better quality for older usages\n                        if(1 == aInputPolyPolygon.Count())\n                        {\n                            MetaAction* pAction = rMtf.ReplaceAction(\n                                new MetaPolyLineAction(\n                                    aInputPolyPolygon.GetObject(0),\n                                    pPolyLineAction->GetLineInfo()),\n                                nLastPolygonAction);\n                            if(pAction)\n                                pAction->Delete();\n                        }\n                    }\n                    else\n                    {\n                        MetaPolyPolygonAction* pPolyPolygonAction = dynamic_cast< MetaPolyPolygonAction* >(rMtf.GetAction(nLastPolygonAction));\n\n                        if(pPolyPolygonAction)\n                        {\n                            // replace MetaPolyPolygonAction when we have a curved polygon. Do rely on the\n                            // same sub-polygon count\n                            if(pPolyPolygonAction->GetPolyPolygon().Count() == aInputPolyPolygon.Count())\n                            {\n                                MetaAction* pAction = rMtf.ReplaceAction(\n                                    new MetaPolyPolygonAction(\n                                        aInputPolyPolygon),\n                                    nLastPolygonAction);\n                                if(pAction)\n                                    pAction->Delete();\n                            }\n                        }\n                        else\n                        {\n                            MetaPolygonAction* pPolygonAction = dynamic_cast< MetaPolygonAction* >(rMtf.GetAction(nLastPolygonAction));\n\n                            if(pPolygonAction)\n                            {\n                                // replace MetaPolygonAction\n                                if(1 == aInputPolyPolygon.Count())\n                                {\n                                    MetaAction* pAction = rMtf.ReplaceAction(\n                                        new MetaPolygonAction(\n                                            aInputPolyPolygon.GetObject(0)),\n                                        nLastPolygonAction);\n                                    if(pAction)\n                                        pAction->Delete();\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            break;\n\n            case GDI_RECT_ACTION:\n            {\n                ImplReadRect( rIStm, aRect );\n                sal_Int32 nTmp(0), nTmp1(0);\n                rIStm.ReadInt32( nTmp ).ReadInt32( nTmp1 );\n\n                if( nTmp || nTmp1 )\n                    rMtf.AddAction( new MetaRoundRectAction( aRect, nTmp, nTmp1 ) );\n                else\n                {\n                    rMtf.AddAction( new MetaRectAction( aRect ) );\n\n                    if( bFatLine )\n                        rMtf.AddAction( new MetaPolyLineAction( aRect, aLineInfo ) );\n                }\n            }\n            break;\n\n            case GDI_ELLIPSE_ACTION:\n            {\n                ImplReadRect( rIStm, aRect );\n\n                if( bFatLine )\n                {\n                    const tools::Polygon aPoly( aRect.Center(), aRect.GetWidth() >> 1, aRect.GetHeight() >> 1 );\n\n                    rMtf.AddAction( new MetaPushAction( PushFlags::LINECOLOR ) );\n                    rMtf.AddAction( new MetaLineColorAction( COL_TRANSPARENT, false ) );\n                    rMtf.AddAction( new MetaPolygonAction( aPoly ) );\n                    rMtf.AddAction( new MetaPopAction() );\n                    rMtf.AddAction( new MetaPolyLineAction( aPoly, aLineInfo ) );\n                }\n                else\n                    rMtf.AddAction( new MetaEllipseAction( aRect ) );\n            }\n            break;\n\n            case GDI_ARC_ACTION:\n            {\n                ImplReadRect( rIStm, aRect );\n                ReadPair( rIStm, aPt );\n                ReadPair( rIStm, aPt1 );\n\n                if( bFatLine )\n                {\n                    const tools::Polygon aPoly( aRect, aPt, aPt1, PolyStyle::Arc );\n\n                    rMtf.AddAction( new MetaPushAction( PushFlags::LINECOLOR ) );\n                    rMtf.AddAction( new MetaLineColorAction( COL_TRANSPARENT, false ) );\n                    rMtf.AddAction( new MetaPolygonAction( aPoly ) );\n                    rMtf.AddAction( new MetaPopAction() );\n                    rMtf.AddAction( new MetaPolyLineAction( aPoly, aLineInfo ) );\n                }\n                else\n                    rMtf.AddAction( new MetaArcAction( aRect, aPt, aPt1 ) );\n            }\n            break;\n\n            case GDI_PIE_ACTION:\n            {\n                ImplReadRect( rIStm, aRect );\n                ReadPair( rIStm, aPt );\n                ReadPair( rIStm, aPt1 );\n\n                if( bFatLine )\n                {\n                    const tools::Polygon aPoly( aRect, aPt, aPt1, PolyStyle::Pie );\n\n                    rMtf.AddAction( new MetaPushAction( PushFlags::LINECOLOR ) );\n                    rMtf.AddAction( new MetaLineColorAction( COL_TRANSPARENT, false ) );\n                    rMtf.AddAction( new MetaPolygonAction( aPoly ) );\n                    rMtf.AddAction( new MetaPopAction() );\n                    rMtf.AddAction( new MetaPolyLineAction( aPoly, aLineInfo ) );\n                }\n                else\n                    rMtf.AddAction( new MetaPieAction( aRect, aPt, aPt1 ) );\n            }\n            break;\n\n            case GDI_INVERTRECT_ACTION:\n            case GDI_HIGHLIGHTRECT_ACTION:\n            {\n                ImplReadRect( rIStm, aRect );\n                rMtf.AddAction( new MetaPushAction( PushFlags::RASTEROP ) );\n                rMtf.AddAction( new MetaRasterOpAction( RasterOp::Invert ) );\n                rMtf.AddAction( new MetaRectAction( aRect ) );\n                rMtf.AddAction( new MetaPopAction() );\n            }\n            break;\n\n            case GDI_POLYLINE_ACTION:\n            {\n                if (ImplReadPoly(rIStm, aActionPoly))\n                {\n                    nLastPolygonAction = rMtf.GetActionSize();\n\n                    if( bFatLine )\n                        rMtf.AddAction( new MetaPolyLineAction( aActionPoly, aLineInfo ) );\n                    else\n                        rMtf.AddAction( new MetaPolyLineAction( aActionPoly ) );\n                }\n            }\n            break;\n\n            case GDI_POLYGON_ACTION:\n            {\n                if (ImplReadPoly(rIStm, aActionPoly))\n                {\n                    if( bFatLine )\n                    {\n                        rMtf.AddAction( new MetaPushAction( PushFlags::LINECOLOR ) );\n                        rMtf.AddAction( new MetaLineColorAction( COL_TRANSPARENT, false ) );\n                        rMtf.AddAction( new MetaPolygonAction( aActionPoly ) );\n                        rMtf.AddAction( new MetaPopAction() );\n                        rMtf.AddAction( new MetaPolyLineAction( aActionPoly, aLineInfo ) );\n                    }\n                    else\n                    {\n                        nLastPolygonAction = rMtf.GetActionSize();\n                        rMtf.AddAction( new MetaPolygonAction( aActionPoly ) );\n                    }\n                }\n            }\n            break;\n\n            case GDI_POLYPOLYGON_ACTION:\n            {\n                tools::PolyPolygon aPolyPoly;\n\n                if (ImplReadPolyPoly(rIStm, aPolyPoly))\n                {\n                    if( bFatLine )\n                    {\n                        rMtf.AddAction( new MetaPushAction( PushFlags::LINECOLOR ) );\n                        rMtf.AddAction( new MetaLineColorAction( COL_TRANSPARENT, false ) );\n                        rMtf.AddAction( new MetaPolyPolygonAction( aPolyPoly ) );\n                        rMtf.AddAction( new MetaPopAction() );\n\n                        for( sal_uInt16 nPoly = 0, nCount = aPolyPoly.Count(); nPoly < nCount; nPoly++ )\n                            rMtf.AddAction( new MetaPolyLineAction( aPolyPoly[ nPoly ], aLineInfo ) );\n                    }\n                    else\n                    {\n                        nLastPolygonAction = rMtf.GetActionSize();\n                        rMtf.AddAction( new MetaPolyPolygonAction( aPolyPoly ) );\n                    }\n                }\n            }\n            break;\n\n            case GDI_FONT_ACTION:\n            {\n                vcl::Font   aFont;\n                char        aName[LF_FACESIZE+1];\n\n                ImplReadColor( rIStm, aActionColor ); aFont.SetColor( aActionColor );\n                ImplReadColor( rIStm, aActionColor ); aFont.SetFillColor( aActionColor );\n                size_t nRet = rIStm.ReadBytes(aName, LF_FACESIZE);\n                aName[nRet] = 0;\n                aFont.SetFamilyName( OUString( aName, strlen(aName), rIStm.GetStreamCharSet() ) );\n\n                sal_Int32 nWidth(0), nHeight(0);\n                rIStm.ReadInt32(nWidth).ReadInt32(nHeight);\n                sal_Int16 nCharOrient(0), nLineOrient(0);\n                rIStm.ReadInt16(nCharOrient).ReadInt16(nLineOrient);\n                sal_Int16 nCharSet(0), nFamily(0), nPitch(0), nAlign(0), nWeight(0), nUnderline(0), nStrikeout(0);\n                rIStm.ReadInt16(nCharSet).ReadInt16(nFamily).ReadInt16(nPitch).ReadInt16(nAlign).ReadInt16(nWeight).ReadInt16(nUnderline).ReadInt16(nStrikeout);\n                bool bItalic(false), bOutline(false), bShadow(false), bTransparent(false);\n                rIStm.ReadCharAsBool(bItalic).ReadCharAsBool(bOutline).ReadCharAsBool(bShadow).ReadCharAsBool(bTransparent);\n\n                aFont.SetFontSize( Size( nWidth, nHeight ) );\n                aFont.SetCharSet( (rtl_TextEncoding) nCharSet );\n                aFont.SetFamily( (FontFamily) nFamily );\n                aFont.SetPitch( (FontPitch) nPitch );\n                aFont.SetAlignment( (FontAlign) nAlign );\n                aFont.SetWeight( ( nWeight == 1 ) ? WEIGHT_LIGHT : ( nWeight == 2 ) ? WEIGHT_NORMAL :\n                                 ( nWeight == 3 ) ? WEIGHT_BOLD : WEIGHT_DONTKNOW );\n                aFont.SetUnderline( (FontLineStyle) nUnderline );\n                aFont.SetStrikeout( (FontStrikeout) nStrikeout );\n                aFont.SetItalic( bItalic ? ITALIC_NORMAL : ITALIC_NONE );\n                aFont.SetOutline( bOutline );\n                aFont.SetShadow( bShadow );\n                aFont.SetOrientation( nLineOrient );\n                aFont.SetTransparent( bTransparent );\n\n                eActualCharSet = aFont.GetCharSet();\n                if ( eActualCharSet == RTL_TEXTENCODING_DONTKNOW )\n                    eActualCharSet = osl_getThreadTextEncoding();\n\n                rMtf.AddAction( new MetaFontAction( aFont ) );\n                rMtf.AddAction( new MetaTextAlignAction( aFont.GetAlignment() ) );\n                rMtf.AddAction( new MetaTextColorAction( aFont.GetColor() ) );\n                rMtf.AddAction( new MetaTextFillColorAction( aFont.GetFillColor(), !aFont.IsTransparent() ) );\n\n                // #106172# Track font relevant data in shadow VDev\n                aFontVDev->SetFont( aFont );\n            }\n            break;\n\n            case GDI_TEXT_ACTION:\n            {\n                sal_Int32 nIndex(0), nLen(0), nTmp(0);\n\n                ReadPair( rIStm, aPt ).ReadInt32( nIndex ).ReadInt32( nLen ).ReadInt32( nTmp );\n                if (nTmp > 0)\n                {\n                    OString aByteStr = read_uInt8s_ToOString(rIStm, nTmp);\n                    sal_uInt8 nTerminator = 0;\n                    rIStm.ReadUChar( nTerminator );\n                    SAL_WARN_IF( nTerminator != 0, \"vcl.gdi\", \"expected string to be NULL terminated\" );\n\n                    OUString aStr(OStringToOUString(aByteStr, eActualCharSet));\n                    if ( nUnicodeCommentActionNumber == i )\n                        ImplReadUnicodeComment( nUnicodeCommentStreamPos, rIStm, aStr );\n                    rMtf.AddAction( new MetaTextAction( aPt, aStr, nIndex, nLen ) );\n                }\n                rIStm.Seek( nActBegin + nActionSize );\n            }\n            break;\n\n            case GDI_TEXTARRAY_ACTION:\n            {\n                sal_Int32 nIndex(0), nLen(0), nAryLen(0), nTmp(0);\n\n                ReadPair( rIStm, aPt ).ReadInt32( nIndex ).ReadInt32( nLen ).ReadInt32( nTmp ).ReadInt32( nAryLen );\n                if (nTmp > 0)\n                {\n                    OString aByteStr = read_uInt8s_ToOString(rIStm, nTmp);\n                    sal_uInt8 nTerminator = 0;\n                    rIStm.ReadUChar( nTerminator );\n                    SAL_WARN_IF( nTerminator != 0, \"vcl.gdi\", \"expected string to be NULL terminated\" );\n\n                    OUString aStr(OStringToOUString(aByteStr, eActualCharSet));\n\n                    std::unique_ptr<long[]> pDXAry;\n                    sal_Int32 nDXAryLen = 0;\n                    if (nAryLen > 0)\n                    {\n                        const size_t nMinRecordSize = sizeof(sal_Int32);\n                        const size_t nMaxRecords = rIStm.remainingSize() / nMinRecordSize;\n                        if (static_cast<sal_uInt32>(nAryLen) > nMaxRecords)\n                        {\n                            SAL_WARN(\"vcl.gdi\", \"Parsing error: \" << nMaxRecords <<\n                                     \" max possible entries, but \" << nAryLen << \" claimed, truncating\");\n                            nAryLen = nMaxRecords;\n                        }\n\n                        sal_Int32 nStrLen( aStr.getLength() );\n\n                        nDXAryLen = std::max(nAryLen, nStrLen);\n\n                        if (nDXAryLen < nLen)\n                        {\n                            //MetaTextArrayAction ctor expects pDXAry to be >= nLen if set, so if this can't\n                            //be achieved, don't read it, it's utterly broken.\n                            SAL_WARN(\"vcl.gdi\", \"dxary too short, discarding completely\");\n                            rIStm.SeekRel(sizeof(sal_Int32) * nDXAryLen);\n                            nLen = 0;\n                            nIndex = 0;\n                        }\n                        else\n                        {\n                            pDXAry.reset(new long[nDXAryLen]);\n\n                            for (sal_Int32 j = 0; j < nAryLen; ++j)\n                                rIStm.ReadInt32( nTmp ), pDXAry[ j ] = nTmp;\n\n                            // #106172# Add last DX array elem, if missing\n                            if( nAryLen != nStrLen )\n                            {\n                                if (nAryLen+1 == nStrLen && nIndex >= 0)\n                                {\n                                    std::unique_ptr<long[]> pTmpAry(new long[nStrLen]);\n\n                                    aFontVDev->GetTextArray( aStr, pTmpAry.get(), nIndex, nLen );\n\n                                    // now, the difference between the\n                                    // last and the second last DX array\n                                    // is the advancement for the last\n                                    // glyph. Thus, to complete our meta\n                                    // action's DX array, just add that\n                                    // difference to last elem and store\n                                    // in very last.\n                                    if( nStrLen > 1 )\n                                        pDXAry[ nStrLen-1 ] = pDXAry[ nStrLen-2 ] + pTmpAry[ nStrLen-1 ] - pTmpAry[ nStrLen-2 ];\n                                    else\n                                        pDXAry[ nStrLen-1 ] = pTmpAry[ nStrLen-1 ]; // len=1: 0th position taken to be 0\n                                }\n#ifdef DBG_UTIL\n                                else\n                                    OSL_FAIL(\"More than one DX array element missing on SVM import\");\n#endif\n                            }\n                        }\n                    }\n                    if ( nUnicodeCommentActionNumber == i )\n                        ImplReadUnicodeComment( nUnicodeCommentStreamPos, rIStm, aStr );\n                    rMtf.AddAction( new MetaTextArrayAction( aPt, aStr, pDXAry.get(), nIndex, nLen ) );\n                }\n                rIStm.Seek( nActBegin + nActionSize );\n            }\n            break;\n\n            case GDI_STRETCHTEXT_ACTION:\n            {\n                sal_Int32 nIndex(0), nLen(0), nWidth(0), nTmp(0);\n\n                ReadPair( rIStm, aPt ).ReadInt32( nIndex ).ReadInt32( nLen ).ReadInt32( nTmp ).ReadInt32( nWidth );\n                if (nTmp > 0)\n                {\n                    OString aByteStr = read_uInt8s_ToOString(rIStm, nTmp);\n                    sal_uInt8 nTerminator = 0;\n                    rIStm.ReadUChar( nTerminator );\n                    SAL_WARN_IF( nTerminator != 0, \"vcl.gdi\", \"expected string to be NULL terminated\" );\n\n                    OUString aStr(OStringToOUString(aByteStr, eActualCharSet));\n                    if ( nUnicodeCommentActionNumber == i )\n                        ImplReadUnicodeComment( nUnicodeCommentStreamPos, rIStm, aStr );\n                    rMtf.AddAction( new MetaStretchTextAction( aPt, nWidth, aStr, nIndex, nLen ) );\n                }\n                rIStm.Seek( nActBegin + nActionSize );\n            }\n            break;\n\n            case GDI_BITMAP_ACTION:\n            {\n                Bitmap aBmp;\n\n                ReadPair( rIStm, aPt );\n                ReadDIB(aBmp, rIStm, true);\n                rMtf.AddAction( new MetaBmpAction( aPt, aBmp ) );\n            }\n            break;\n\n            case GDI_BITMAPSCALE_ACTION:\n            {\n                Bitmap aBmp;\n\n                ReadPair( rIStm, aPt );\n                ReadPair( rIStm, aSz );\n                ReadDIB(aBmp, rIStm, true);\n                rMtf.AddAction( new MetaBmpScaleAction( aPt, aSz, aBmp ) );\n            }\n            break;\n\n            case GDI_BITMAPSCALEPART_ACTION:\n            {\n                Bitmap  aBmp;\n                Size    aSz2;\n\n                ReadPair( rIStm, aPt );\n                ReadPair( rIStm, aSz );\n                ReadPair( rIStm, aPt1 );\n                ReadPair( rIStm, aSz2 );\n                ReadDIB(aBmp, rIStm, true);\n                rMtf.AddAction( new MetaBmpScalePartAction( aPt, aSz, aPt1, aSz2, aBmp ) );\n            }\n            break;\n\n            case GDI_PEN_ACTION:\n            {\n                sal_Int32 nPenWidth;\n                sal_Int16 nPenStyle;\n\n                ImplReadColor( rIStm, aActionColor );\n                rIStm.ReadInt32( nPenWidth ).ReadInt16( nPenStyle );\n\n                aLineInfo.SetStyle( nPenStyle ? LineStyle::Solid : LineStyle::NONE );\n                aLineInfo.SetWidth( nPenWidth );\n                bFatLine = nPenStyle && !aLineInfo.IsDefault();\n\n                rMtf.AddAction( new MetaLineColorAction( aActionColor, nPenStyle != 0 ) );\n            }\n            break;\n\n            case GDI_FILLBRUSH_ACTION:\n            {\n                sal_Int16 nBrushStyle;\n\n                ImplReadColor( rIStm, aActionColor );\n                rIStm.SeekRel( 6 );\n                rIStm.ReadInt16( nBrushStyle );\n                rMtf.AddAction( new MetaFillColorAction( aActionColor, nBrushStyle != 0 ) );\n                rIStm.SeekRel( 2 );\n            }\n            break;\n\n            case GDI_MAPMODE_ACTION:\n            {\n                if (ImplReadMapMode(rIStm, aMapMode))\n                {\n                    rMtf.AddAction(new MetaMapModeAction(aMapMode));\n\n                    // #106172# Track font relevant data in shadow VDev\n                    aFontVDev->SetMapMode(aMapMode);\n                };\n            }\n            break;\n\n            case GDI_CLIPREGION_ACTION:\n            {\n                vcl::Region  aRegion;\n                sal_Int16   nRegType;\n                sal_Int16   bIntersect;\n                bool    bClip = false;\n\n                rIStm.ReadInt16( nRegType ).ReadInt16( bIntersect );\n                ImplReadRect( rIStm, aRect );\n\n                switch( nRegType )\n                {\n                    case 0:\n                    break;\n\n                    case 1:\n                    {\n                        Rectangle aRegRect;\n\n                        ImplReadRect( rIStm, aRegRect );\n                        aRegion = vcl::Region( aRegRect );\n                        bClip = true;\n                    }\n                    break;\n\n                    case 2:\n                    {\n                        if (ImplReadPoly(rIStm, aActionPoly))\n                        {\n                            aRegion = vcl::Region( aActionPoly );\n                            bClip = true;\n                        }\n                    }\n                    break;\n\n                    case 3:\n                    {\n                        bool bSuccess = true;\n                        tools::PolyPolygon aPolyPoly;\n                        sal_Int32 nPolyCount32(0);\n                        rIStm.ReadInt32(nPolyCount32);\n                        sal_uInt16 nPolyCount(nPolyCount32);\n\n                        for (sal_uInt16 j = 0; j < nPolyCount && rIStm.good(); ++j)\n                        {\n                            if (!ImplReadPoly(rIStm, aActionPoly))\n                            {\n                                bSuccess = false;\n                                break;\n                            }\n                            aPolyPoly.Insert(aActionPoly);\n                        }\n\n                        if (bSuccess)\n                        {\n                            aRegion = vcl::Region( aPolyPoly );\n                            bClip = true;\n                        }\n                    }\n                    break;\n                }\n\n                if( bIntersect )\n                    aRegion.Intersect( aRect );\n\n                rMtf.AddAction( new MetaClipRegionAction( aRegion, bClip ) );\n            }\n            break;\n\n            case GDI_MOVECLIPREGION_ACTION:\n            {\n                sal_Int32 nTmp(0), nTmp1(0);\n                rIStm.ReadInt32( nTmp ).ReadInt32( nTmp1 );\n                rMtf.AddAction( new MetaMoveClipRegionAction( nTmp, nTmp1 ) );\n            }\n            break;\n\n            case GDI_ISECTCLIPREGION_ACTION:\n            {\n                ImplReadRect( rIStm, aRect );\n                rMtf.AddAction( new MetaISectRectClipRegionAction( aRect ) );\n            }\n            break;\n\n            case GDI_RASTEROP_ACTION:\n            {\n                RasterOp    eRasterOp;\n                sal_Int16       nRasterOp;\n\n                rIStm.ReadInt16( nRasterOp );\n\n                switch( nRasterOp )\n                {\n                    case 1:\n                        eRasterOp = RasterOp::Invert;\n                    break;\n\n                    case 4:\n                    case 5:\n                        eRasterOp = RasterOp::Xor;\n                    break;\n\n                    default:\n                        eRasterOp = RasterOp::OverPaint;\n                    break;\n                }\n\n                rMtf.AddAction( new MetaRasterOpAction( eRasterOp ) );\n            }\n            break;\n\n            case GDI_PUSH_ACTION:\n            {\n                aLIStack.push(o3tl::make_unique<LineInfo>(aLineInfo));\n                rMtf.AddAction( new MetaPushAction( PushFlags::ALL ) );\n\n                // #106172# Track font relevant data in shadow VDev\n                aFontVDev->Push();\n            }\n            break;\n\n            case GDI_POP_ACTION:\n            {\n\n                std::unique_ptr<LineInfo> xLineInfo;\n                if (!aLIStack.empty())\n                {\n                    xLineInfo = std::move(aLIStack.top());\n                    aLIStack.pop();\n                }\n\n                // restore line info\n                if (xLineInfo)\n                {\n                    aLineInfo = *xLineInfo;\n                    xLineInfo.reset();\n                    bFatLine = ( LineStyle::NONE != aLineInfo.GetStyle() ) && !aLineInfo.IsDefault();\n                }\n\n                rMtf.AddAction( new MetaPopAction() );\n\n                // #106172# Track font relevant data in shadow VDev\n                aFontVDev->Pop();\n            }\n            break;\n\n            case GDI_GRADIENT_ACTION:\n            {\n                Color   aStartCol;\n                Color   aEndCol;\n                sal_Int16   nStyle;\n                sal_Int16   nAngle;\n                sal_Int16   nBorder;\n                sal_Int16   nOfsX;\n                sal_Int16   nOfsY;\n                sal_Int16   nIntensityStart;\n                sal_Int16   nIntensityEnd;\n\n                ImplReadRect( rIStm, aRect );\n                rIStm.ReadInt16( nStyle );\n                ImplReadColor( rIStm, aStartCol );\n                ImplReadColor( rIStm, aEndCol );\n                rIStm.ReadInt16( nAngle ).ReadInt16( nBorder ).ReadInt16( nOfsX ).ReadInt16( nOfsY ).ReadInt16( nIntensityStart ).ReadInt16( nIntensityEnd );\n\n                Gradient aGrad( (GradientStyle) nStyle, aStartCol, aEndCol );\n\n                aGrad.SetAngle( nAngle );\n                aGrad.SetBorder( nBorder );\n                aGrad.SetOfsX( nOfsX );\n                aGrad.SetOfsY( nOfsY );\n                aGrad.SetStartIntensity( nIntensityStart );\n                aGrad.SetEndIntensity( nIntensityEnd );\n                rMtf.AddAction( new MetaGradientAction( aRect, aGrad ) );\n            }\n            break;\n\n            case GDI_TRANSPARENT_COMMENT:\n            {\n                tools::PolyPolygon aPolyPoly;\n                sal_Int32       nFollowingActionCount;\n                sal_Int16       nTrans;\n\n                ReadPolyPolygon( rIStm, aPolyPoly );\n                rIStm.ReadInt16( nTrans ).ReadInt32( nFollowingActionCount );\n                ImplSkipActions( rIStm, nFollowingActionCount );\n                rMtf.AddAction( new MetaTransparentAction( aPolyPoly, nTrans ) );\n\n                i += nFollowingActionCount;\n            }\n            break;\n\n            case GDI_FLOATTRANSPARENT_COMMENT:\n            {\n                GDIMetaFile aMtf;\n                Point       aPos;\n                Size        aSize;\n                Gradient    aGradient;\n                sal_Int32       nFollowingActionCount;\n\n                ReadGDIMetaFile( rIStm, aMtf );\n                ReadPair( rIStm, aPos );\n                ReadPair( rIStm, aSize );\n                ReadGradient( rIStm, aGradient );\n                rIStm.ReadInt32( nFollowingActionCount );\n                ImplSkipActions( rIStm, nFollowingActionCount );\n                rMtf.AddAction( new MetaFloatTransparentAction( aMtf, aPos, aSize, aGradient ) );\n\n                i += nFollowingActionCount;\n            }\n            break;\n\n            case GDI_HATCH_COMMENT:\n            {\n                tools::PolyPolygon aPolyPoly;\n                Hatch       aHatch;\n                sal_Int32       nFollowingActionCount;\n\n                ReadPolyPolygon( rIStm, aPolyPoly );\n                ReadHatch( rIStm, aHatch );\n                rIStm.ReadInt32( nFollowingActionCount );\n                ImplSkipActions( rIStm, nFollowingActionCount );\n                rMtf.AddAction( new MetaHatchAction( aPolyPoly, aHatch ) );\n\n                i += nFollowingActionCount;\n            }\n            break;\n\n            case GDI_REFPOINT_COMMENT:\n            {\n                Point   aRefPoint;\n                bool    bSet;\n                sal_Int32   nFollowingActionCount;\n\n                ReadPair( rIStm, aRefPoint );\n                rIStm.ReadCharAsBool( bSet ).ReadInt32( nFollowingActionCount );\n                ImplSkipActions( rIStm, nFollowingActionCount );\n                rMtf.AddAction( new MetaRefPointAction( aRefPoint, bSet ) );\n\n                i += nFollowingActionCount;\n\n                // #106172# Track font relevant data in shadow VDev\n                if( bSet )\n                    aFontVDev->SetRefPoint( aRefPoint );\n                else\n                    aFontVDev->SetRefPoint();\n            }\n            break;\n\n            case GDI_TEXTLINECOLOR_COMMENT:\n            {\n                Color   aColor;\n                bool    bSet;\n                sal_Int32   nFollowingActionCount;\n\n                ReadColor( rIStm, aColor );\n                rIStm.ReadCharAsBool( bSet ).ReadInt32( nFollowingActionCount );\n                ImplSkipActions( rIStm, nFollowingActionCount );\n                rMtf.AddAction( new MetaTextLineColorAction( aColor, bSet ) );\n\n                i += nFollowingActionCount;\n            }\n            break;\n\n            case GDI_TEXTLINE_COMMENT:\n            {\n                Point   aStartPt;\n                sal_Int32  nWidth(0);\n                sal_uInt32 nStrikeout(0);\n                sal_uInt32 nUnderline(0);\n                sal_Int32  nFollowingActionCount(0);\n\n                ReadPair( rIStm, aStartPt );\n                rIStm.ReadInt32(nWidth ).ReadUInt32(nStrikeout).ReadUInt32(nUnderline).ReadInt32(nFollowingActionCount);\n                ImplSkipActions(rIStm, nFollowingActionCount);\n                rMtf.AddAction( new MetaTextLineAction( aStartPt, nWidth,\n                                                        (FontStrikeout) nStrikeout,\n                                                        (FontLineStyle) nUnderline,\n                                                        LINESTYLE_NONE ) );\n\n                i += nFollowingActionCount;\n            }\n            break;\n\n            case GDI_GRADIENTEX_COMMENT:\n            {\n                tools::PolyPolygon aPolyPoly;\n                Gradient    aGradient;\n                sal_Int32       nFollowingActionCount;\n\n                ReadPolyPolygon( rIStm, aPolyPoly );\n                ReadGradient( rIStm, aGradient );\n                rIStm.ReadInt32( nFollowingActionCount );\n                ImplSkipActions( rIStm, nFollowingActionCount );\n                rMtf.AddAction( new MetaGradientExAction( aPolyPoly, aGradient ) );\n\n                i += nFollowingActionCount;\n            }\n            break;\n\n            case GDI_COMMENT_COMMENT:\n            {\n                sal_Int32   nValue;\n                sal_uInt32  nDataSize;\n                std::vector<sal_uInt8> aData;\n                sal_Int32       nFollowingActionCount;\n\n                OString aComment = read_uInt16_lenPrefixed_uInt8s_ToOString(rIStm);\n                rIStm.ReadInt32( nValue ).ReadUInt32( nDataSize );\n\n                if (nDataSize)\n                {\n                    aData.resize(nDataSize);\n                    nDataSize = rIStm.ReadBytes(aData.data(), nDataSize);\n                }\n\n                rIStm.ReadInt32( nFollowingActionCount );\n                ImplSkipActions( rIStm, nFollowingActionCount );\n                rMtf.AddAction(new MetaCommentAction(aComment, nValue, aData.data(), nDataSize));\n\n                i += nFollowingActionCount;\n            }\n            break;\n\n            case GDI_UNICODE_COMMENT:\n            {\n                nUnicodeCommentActionNumber = i + 1;\n                nUnicodeCommentStreamPos = rIStm.Tell() - 6;\n                if (nActionSize < 4)\n                    rIStm.SetError(SVSTREAM_FILEFORMAT_ERROR);\n                else\n                    rIStm.SeekRel(nActionSize - 4);\n            }\n            break;\n\n            default:\n                if (nActionSize < 4)\n                    rIStm.SetError(SVSTREAM_FILEFORMAT_ERROR);\n                else\n                    rIStm.SeekRel(nActionSize - 4);\n            break;\n        }\n    }\n\n    rIStm.SetEndian( nOldFormat );\n}\n\nvoid SVMConverter::ImplConvertToSVM1( SvStream& rOStm, GDIMetaFile& rMtf )\n{\n    sal_uLong           nCountPos;\n    vcl::Font           aSaveFont;\n    const SvStreamEndian nOldFormat = rOStm.GetEndian();\n    rtl_TextEncoding    eActualCharSet = osl_getThreadTextEncoding();\n    const Size          aPrefSize( rMtf.GetPrefSize() );\n    bool                bRop_0_1 = false;\n    ScopedVclPtrInstance< VirtualDevice > aSaveVDev;\n    Color               aLineCol( COL_BLACK );\n    ::std::stack< Color* >  aLineColStack;\n\n    rOStm.SetEndian( SvStreamEndian::LITTLE );\n\n    // Write MagicCode\n    rOStm.WriteCharPtr( \"SVGDI\" );                                   // Identifier\n    rOStm.WriteInt16( 42 );                            // HeaderSize\n    rOStm.WriteInt16( 200 );                           // VERSION\n    rOStm.WriteInt32( aPrefSize.Width() );\n    rOStm.WriteInt32( aPrefSize.Height() );\n    ImplWriteMapMode( rOStm, rMtf.GetPrefMapMode() );\n\n    // ActionCount will be written later\n    nCountPos = rOStm.Tell();\n    rOStm.SeekRel( 4 );\n\n    const sal_Int32 nActCount = ImplWriteActions( rOStm, rMtf, *aSaveVDev.get(), bRop_0_1, aLineCol, aLineColStack, eActualCharSet );\n    const sal_uLong nActPos = rOStm.Tell();\n\n    rOStm.Seek( nCountPos );\n    rOStm.WriteInt32( nActCount );\n    rOStm.Seek( nActPos );\n    rOStm.SetEndian( nOldFormat );\n\n    // cleanup push-pop stack if necessary\n    while ( !aLineColStack.empty() )\n    {\n        delete aLineColStack.top();\n        aLineColStack.pop();\n    }\n}\n\nsal_uLong SVMConverter::ImplWriteActions( SvStream& rOStm, GDIMetaFile& rMtf,\n                                      VirtualDevice& rSaveVDev, bool& rRop_0_1,\n                                      Color& rLineCol, ::std::stack< Color* >& rLineColStack,\n                                      rtl_TextEncoding& rActualCharSet )\n{\n    sal_uLong nCount = 0;\n    for( size_t i = 0, nActionCount = rMtf.GetActionSize(); i < nActionCount; i++ )\n    {\n        const MetaAction* pAction = rMtf.GetAction( i );\n\n        switch( pAction->GetType() )\n        {\n            case MetaActionType::PIXEL:\n            {\n                const MetaPixelAction* pAct = static_cast<const MetaPixelAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_PIXEL_ACTION );\n                rOStm.WriteInt32( 18 );\n                WritePair( rOStm, pAct->GetPoint() );\n                ImplWriteColor( rOStm, pAct->GetColor() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::POINT:\n            {\n                const MetaPointAction* pAct = static_cast<const MetaPointAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_POINT_ACTION );\n                rOStm.WriteInt32( 12 );\n                WritePair( rOStm, pAct->GetPoint() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::LINE:\n            {\n                const MetaLineAction* pAct = static_cast<const MetaLineAction*>(pAction);\n                const LineInfo& rInfo = pAct->GetLineInfo();\n                const bool bFatLine(!rInfo.IsDefault() && (LineStyle::NONE != rInfo.GetStyle()));\n                const bool bLineJoin(bFatLine && basegfx::B2DLineJoin::Round != rInfo.GetLineJoin());\n                const bool bLineCap(bFatLine && css::drawing::LineCap_BUTT != rInfo.GetLineCap());\n                const bool bLineDashDot(LineStyle::Dash == rInfo.GetStyle());\n\n                if( bFatLine )\n                {\n                    ImplWritePushAction( rOStm );\n                    ImplWriteLineColor( rOStm, rLineCol, 1, rInfo.GetWidth() );\n\n                    if(bLineJoin)\n                    {\n                        rOStm.WriteInt16( GDI_LINEJOIN_ACTION );\n                        rOStm.WriteInt32( 6 );\n                        rOStm.WriteInt16( static_cast<sal_Int16>(rInfo.GetLineJoin()) );\n                    }\n\n                    if(bLineCap)\n                    {\n                        rOStm.WriteInt16( GDI_LINECAP_ACTION );\n                        rOStm.WriteInt32( 6 );\n                        rOStm.WriteInt16( rInfo.GetLineCap() );\n                    }\n                }\n\n                if(bLineDashDot)\n                {\n                    rOStm.WriteInt16( GDI_LINEDASHDOT_ACTION );\n                    rOStm.WriteInt32( 4 + 16 );\n                    rOStm.WriteInt16( rInfo.GetDashCount() );\n                    rOStm.WriteInt32( rInfo.GetDashLen() );\n                    rOStm.WriteInt16( rInfo.GetDotCount() );\n                    rOStm.WriteInt32( rInfo.GetDotLen() );\n                    rOStm.WriteInt32( rInfo.GetDistance() );\n                }\n\n                rOStm.WriteInt16( GDI_LINE_ACTION );\n                rOStm.WriteInt32( 20 );\n                WritePair( rOStm, pAct->GetStartPoint() );\n                WritePair( rOStm, pAct->GetEndPoint() );\n                nCount++;\n\n                if( bFatLine )\n                {\n                    ImplWritePopAction( rOStm );\n                    nCount += 3;\n\n                    if(bLineJoin)\n                    {\n                        nCount += 1;\n                    }\n\n                    if(bLineCap)\n                    {\n                        nCount += 1;\n                    }\n                }\n\n                if(bLineDashDot)\n                {\n                    nCount += 1;\n                }\n            }\n            break;\n\n            case MetaActionType::RECT:\n            {\n                const MetaRectAction* pAct = static_cast<const MetaRectAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_RECT_ACTION );\n                rOStm.WriteInt32( 28 );\n                ImplWriteRect( rOStm, pAct->GetRect() );\n                rOStm.WriteInt32( 0 );\n                rOStm.WriteInt32( 0 );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::ROUNDRECT:\n            {\n                const MetaRoundRectAction* pAct = static_cast<const MetaRoundRectAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_RECT_ACTION );\n                rOStm.WriteInt32( 28 );\n                ImplWriteRect( rOStm, pAct->GetRect() );\n                rOStm.WriteInt32( pAct->GetHorzRound() );\n                rOStm.WriteInt32( pAct->GetVertRound() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::ELLIPSE:\n            {\n                const MetaEllipseAction* pAct = static_cast<const MetaEllipseAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_ELLIPSE_ACTION );\n                rOStm.WriteInt32( 20 );\n                ImplWriteRect( rOStm, pAct->GetRect() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::ARC:\n            {\n                const MetaArcAction* pAct = static_cast<const MetaArcAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_ARC_ACTION );\n                rOStm.WriteInt32( 36 );\n                ImplWriteRect( rOStm, pAct->GetRect() );\n                WritePair( rOStm, pAct->GetStartPoint() );\n                WritePair( rOStm, pAct->GetEndPoint() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::PIE:\n            {\n                const MetaPieAction* pAct = static_cast<const MetaPieAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_PIE_ACTION );\n                rOStm.WriteInt32( 36 );\n                ImplWriteRect( rOStm, pAct->GetRect() );\n                WritePair( rOStm, pAct->GetStartPoint() );\n                WritePair( rOStm, pAct->GetEndPoint() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::CHORD:\n            {\n                const MetaChordAction* pAct = static_cast<const MetaChordAction*>(pAction);\n                tools::Polygon aChordPoly( pAct->GetRect(), pAct->GetStartPoint(),\n                                           pAct->GetEndPoint(), PolyStyle::Chord );\n                const sal_uInt16       nPoints = aChordPoly.GetSize();\n\n                rOStm.WriteInt16( GDI_POLYGON_ACTION );\n                rOStm.WriteInt32( 8 + ( nPoints << 3 ) );\n                rOStm.WriteInt32( nPoints );\n\n                for( sal_uInt16 n = 0; n < nPoints; n++ )\n                    WritePair( rOStm, aChordPoly[ n ] );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::POLYLINE:\n            {\n                // #i102224#\n                const MetaPolyLineAction* pAct = static_cast<const MetaPolyLineAction*>(pAction);\n                // #i102224# Here the possible curved nature of Polygon was\n                // ignored (for all those years). Adapted to at least write\n                // a polygon representing the curve as good as possible\n                tools::Polygon aSimplePoly;\n                pAct->GetPolygon().AdaptiveSubdivide(aSimplePoly);\n                const LineInfo& rInfo = pAct->GetLineInfo();\n                const sal_uInt16 nPoints(aSimplePoly.GetSize());\n                const bool bFatLine(!rInfo.IsDefault() && (LineStyle::NONE != rInfo.GetStyle()));\n                const bool bLineJoin(bFatLine && basegfx::B2DLineJoin::Round != rInfo.GetLineJoin());\n                const bool bLineCap(bFatLine && css::drawing::LineCap_BUTT != rInfo.GetLineCap());\n                const bool bLineDashDot(LineStyle::Dash == rInfo.GetStyle());\n\n                if( bFatLine )\n                {\n                    ImplWritePushAction( rOStm );\n                    ImplWriteLineColor( rOStm, rLineCol, 1, rInfo.GetWidth() );\n\n                    if(bLineJoin)\n                    {\n                        rOStm.WriteInt16( GDI_LINEJOIN_ACTION );\n                        rOStm.WriteInt32( 6 );\n                        rOStm.WriteInt16( static_cast<sal_Int16>(rInfo.GetLineJoin()) );\n                    }\n\n                    if(bLineCap)\n                    {\n                        rOStm.WriteInt16( GDI_LINECAP_ACTION );\n                        rOStm.WriteInt32( 6 );\n                        rOStm.WriteInt16( rInfo.GetLineCap() );\n                    }\n                }\n\n                if(bLineDashDot)\n                {\n                    rOStm.WriteInt16( GDI_LINEDASHDOT_ACTION );\n                    rOStm.WriteInt32( 4 + 16 );\n                    rOStm.WriteInt16( rInfo.GetDashCount() );\n                    rOStm.WriteInt32( rInfo.GetDashLen() );\n                    rOStm.WriteInt16( rInfo.GetDotCount() );\n                    rOStm.WriteInt32( rInfo.GetDotLen() );\n                    rOStm.WriteInt32( rInfo.GetDistance() );\n                }\n\n                rOStm.WriteInt16( GDI_POLYLINE_ACTION );\n                rOStm.WriteInt32( 8 + ( nPoints << 3 ) );\n                rOStm.WriteInt32( nPoints );\n\n                for( sal_uInt16 n = 0; n < nPoints; n++ )\n                {\n                    WritePair( rOStm, aSimplePoly[ n ] );\n                }\n\n                nCount++;\n\n                const tools::PolyPolygon aPolyPolygon(pAct->GetPolygon());\n                if(ImplWriteExtendedPolyPolygonAction(rOStm, aPolyPolygon, true))\n                {\n                    nCount++;\n                }\n\n                if( bFatLine )\n                {\n                    ImplWritePopAction( rOStm );\n                    nCount += 3;\n\n                    if(bLineJoin)\n                    {\n                        nCount += 1;\n                    }\n\n                    if(bLineCap)\n                    {\n                        nCount += 1;\n                    }\n                }\n\n                if(bLineDashDot)\n                {\n                    nCount += 1;\n                }\n            }\n            break;\n\n            case MetaActionType::POLYGON:\n            {\n                const MetaPolygonAction* pAct = static_cast<const MetaPolygonAction*>(pAction);\n                // #i102224# Here the possible curved nature of Polygon was\n                // ignored (for all those years). Adapted to at least write\n                // a polygon representing the curve as good as possible\n                tools::Polygon aSimplePoly;\n                pAct->GetPolygon().AdaptiveSubdivide(aSimplePoly);\n                const sal_uInt16 nPoints(aSimplePoly.GetSize());\n\n                rOStm.WriteInt16( GDI_POLYGON_ACTION );\n                rOStm.WriteInt32( 8 + ( nPoints << 3 ) );\n                rOStm.WriteInt32( nPoints );\n\n                for( sal_uInt16 n = 0; n < nPoints; n++ )\n                    WritePair( rOStm, aSimplePoly[ n ] );\n\n                nCount++;\n\n                const tools::PolyPolygon aPolyPolygon(pAct->GetPolygon());\n                if(ImplWriteExtendedPolyPolygonAction(rOStm, aPolyPolygon, true))\n                {\n                    nCount++;\n                }\n            }\n            break;\n\n            case MetaActionType::POLYPOLYGON:\n            {\n                const MetaPolyPolygonAction* pAct = static_cast<const MetaPolyPolygonAction*>(pAction);\n                ImplWritePolyPolyAction( rOStm, pAct->GetPolyPolygon() );\n                nCount++;\n\n                if(ImplWriteExtendedPolyPolygonAction(rOStm, pAct->GetPolyPolygon(), true))\n                {\n                    nCount++;\n                }\n            }\n            break;\n\n            case MetaActionType::TEXT:\n            {\n                const MetaTextAction* pAct = static_cast<const MetaTextAction*>(pAction);\n                OUString aUniText( pAct->GetText() );\n                OString  aText(OUStringToOString(aUniText, rActualCharSet));\n                const sal_Int32 nStrLen = aText.getLength();\n\n                if ( ImplWriteUnicodeComment( rOStm, aUniText ) )\n                    nCount++;\n\n                rOStm.WriteInt16( GDI_TEXT_ACTION );\n                rOStm.WriteInt32( 24 + ( nStrLen + 1 ) );\n                WritePair( rOStm, pAct->GetPoint() );\n                rOStm.WriteInt32( pAct->GetIndex() );\n                rOStm.WriteInt32( pAct->GetLen() );\n                rOStm.WriteInt32( nStrLen );\n                rOStm.WriteBytes( aText.getStr(), nStrLen + 1 );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::TEXTARRAY:\n            {\n                const MetaTextArrayAction* pAct = static_cast<const MetaTextArrayAction*>(pAction);\n                OString aText(OUStringToOString(pAct->GetText(), rActualCharSet));\n                OUString aUniText = pAct->GetText().copy(\n                        pAct->GetIndex(),\n                        std::min<sal_Int32>(pAct->GetText().getLength() - pAct->GetIndex(), pAct->GetLen()) );\n                sal_Int32 nAryLen;\n                sal_Int32 nLen = pAct->GetLen();\n                const sal_Int32 nTextLen = aText.getLength();\n                long* pDXArray = pAct->GetDXArray();\n\n                if ( ImplWriteUnicodeComment( rOStm, aUniText ) )\n                    nCount++;\n\n                if( ( nLen + pAct->GetIndex() ) > nTextLen )\n                {\n                    if( pAct->GetIndex() <= nTextLen )\n                        nLen = nTextLen - pAct->GetIndex();\n                    else\n                        nLen = 0;\n                }\n\n                if( !pDXArray || !nLen )\n                    nAryLen = 0;\n                else\n                    nAryLen = nLen; // #105987# Write out all of DX array\n\n                rOStm.WriteInt16( GDI_TEXTARRAY_ACTION );\n                rOStm.WriteInt32( 28 + ( nLen + 1 ) + ( nAryLen * 4 ) );\n                WritePair( rOStm, pAct->GetPoint() );\n                rOStm.WriteInt32( 0 );\n                rOStm.WriteInt32( nLen );\n                rOStm.WriteInt32( nLen );\n                rOStm.WriteInt32( nAryLen );\n                rOStm.WriteBytes( aText.getStr()+pAct->GetIndex(), nLen + 1 );\n\n                for (sal_Int32 n = 0; n < nAryLen; ++n)\n                    rOStm.WriteInt32( pDXArray[ n ] );\n\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::STRETCHTEXT:\n            {\n                const MetaStretchTextAction* pAct = static_cast<const MetaStretchTextAction*>(pAction);\n                OUString aUniText( pAct->GetText() );\n                OString  aText(OUStringToOString(aUniText, rActualCharSet));\n                const sal_Int32 nStrLen = aText.getLength();\n\n                if ( ImplWriteUnicodeComment( rOStm, aUniText ) )\n                    nCount++;\n\n                rOStm.WriteInt16( GDI_STRETCHTEXT_ACTION );\n                rOStm.WriteInt32( 28 + ( nStrLen + 1 ) );\n                WritePair( rOStm, pAct->GetPoint() );\n                rOStm.WriteInt32( pAct->GetIndex() );\n                rOStm.WriteInt32( pAct->GetLen() );\n                rOStm.WriteInt32( nStrLen );\n                rOStm.WriteInt32( pAct->GetWidth() );\n                rOStm.WriteBytes( aText.getStr(), nStrLen + 1 );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::BMP:\n            {\n                const MetaBmpAction* pAct = static_cast<const MetaBmpAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_BITMAP_ACTION );\n                rOStm.WriteInt32( 12 );\n                WritePair( rOStm, pAct->GetPoint() );\n                WriteDIB(pAct->GetBitmap(), rOStm, false, true);\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::BMPSCALE:\n            {\n                const MetaBmpScaleAction* pAct = static_cast<const MetaBmpScaleAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_BITMAPSCALE_ACTION );\n                rOStm.WriteInt32( 20 );\n                WritePair( rOStm, pAct->GetPoint() );\n                WritePair( rOStm, pAct->GetSize() );\n                WriteDIB(pAct->GetBitmap(), rOStm, false, true);\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::BMPSCALEPART:\n            {\n                const MetaBmpScalePartAction* pAct = static_cast<const MetaBmpScalePartAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_BITMAPSCALEPART_ACTION );\n                rOStm.WriteInt32( 36 );\n                WritePair( rOStm, pAct->GetDestPoint() );\n                WritePair( rOStm, pAct->GetDestSize() );\n                WritePair( rOStm, pAct->GetSrcPoint() );\n                WritePair( rOStm, pAct->GetSrcSize() );\n                WriteDIB(pAct->GetBitmap(), rOStm, false, true);\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::BMPEX:\n            {\n                const MetaBmpExAction* pAct = static_cast<const MetaBmpExAction*>(pAction);\n                const Bitmap           aBmp( Graphic( pAct->GetBitmapEx() ).GetBitmap() );\n\n                rOStm.WriteInt16( GDI_BITMAP_ACTION );\n                rOStm.WriteInt32( 12 );\n                WritePair( rOStm, pAct->GetPoint() );\n                WriteDIB(aBmp, rOStm, false, true);\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::BMPEXSCALE:\n            {\n                const MetaBmpExScaleAction* pAct = static_cast<const MetaBmpExScaleAction*>(pAction);\n                const Bitmap                aBmp( Graphic( pAct->GetBitmapEx() ).GetBitmap() );\n\n                rOStm.WriteInt16( GDI_BITMAPSCALE_ACTION );\n                rOStm.WriteInt32( 20 );\n                WritePair( rOStm, pAct->GetPoint() );\n                WritePair( rOStm, pAct->GetSize() );\n                WriteDIB(aBmp, rOStm, false, true);\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::BMPEXSCALEPART:\n            {\n                const MetaBmpExScalePartAction* pAct = static_cast<const MetaBmpExScalePartAction*>(pAction);\n                const Bitmap                    aBmp( Graphic( pAct->GetBitmapEx() ).GetBitmap() );\n\n                rOStm.WriteInt16( GDI_BITMAPSCALEPART_ACTION );\n                rOStm.WriteInt32( 36 );\n                WritePair( rOStm, pAct->GetDestPoint() );\n                WritePair( rOStm, pAct->GetDestSize() );\n                WritePair( rOStm, pAct->GetSrcPoint() );\n                WritePair( rOStm, pAct->GetSrcSize() );\n                WriteDIB(aBmp, rOStm, false, true);\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::GRADIENT:\n            {\n                const MetaGradientAction* pAct = static_cast<const MetaGradientAction*>(pAction);\n                const Gradient&           rGrad = pAct->GetGradient();\n\n                rOStm.WriteInt16( GDI_GRADIENT_ACTION );\n                rOStm.WriteInt32( 46 );\n                ImplWriteRect( rOStm, pAct->GetRect() );\n                rOStm.WriteInt16( (sal_Int16)rGrad.GetStyle() );\n                ImplWriteColor( rOStm, rGrad.GetStartColor() );\n                ImplWriteColor( rOStm, rGrad.GetEndColor() );\n                rOStm.WriteInt16( rGrad.GetAngle() );\n                rOStm.WriteInt16( rGrad.GetBorder() );\n                rOStm.WriteInt16( rGrad.GetOfsX() );\n                rOStm.WriteInt16( rGrad.GetOfsY() );\n                rOStm.WriteInt16( rGrad.GetStartIntensity() );\n                rOStm.WriteInt16( rGrad.GetEndIntensity() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::GRADIENTEX:\n            {\n                const MetaGradientExAction* pA = static_cast<const MetaGradientExAction*>(pAction);\n                sal_uLong                   nOldPos, nNewPos;\n\n                // write RefPoint comment\n                rOStm.WriteInt16( GDI_GRADIENTEX_COMMENT );\n\n                // we'll write the ActionSize later\n                nOldPos = rOStm.Tell();\n                rOStm.SeekRel( 4 );\n\n                // write data\n                WritePolyPolygon( rOStm, pA->GetPolyPolygon() );\n                WriteGradient( rOStm, pA->GetGradient() );\n                rOStm.WriteInt32( 0 ); // number of actions that follow this comment\n\n                // calculate and write ActionSize of comment\n                nNewPos = rOStm.Tell();\n                rOStm.Seek( nOldPos );\n                rOStm.WriteInt32( nNewPos - nOldPos );\n                rOStm.Seek( nNewPos );\n\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::WALLPAPER:\n            {\n                const MetaWallpaperAction* pAct = static_cast<const MetaWallpaperAction*>(pAction);\n                const Color&               rColor = pAct->GetWallpaper().GetColor();\n\n                ImplWritePushAction( rOStm );\n                ImplWriteLineColor( rOStm, rColor, 1 );\n                ImplWriteFillColor( rOStm, rColor, 1 );\n\n                rOStm.WriteInt16( GDI_RECT_ACTION );\n                rOStm.WriteInt32( 28 );\n                ImplWriteRect( rOStm, pAct->GetRect() );\n                rOStm.WriteInt32( 0 );\n                rOStm.WriteInt32( 0 );\n\n                ImplWritePopAction( rOStm );\n                nCount += 5;\n            }\n            break;\n\n            case MetaActionType::CLIPREGION:\n            {\n                const MetaClipRegionAction* pAct = static_cast<const MetaClipRegionAction*>(pAction);\n                const vcl::Region&          rRegion = pAct->GetRegion();\n                Rectangle                   aClipRect;\n\n                rOStm.WriteInt16( GDI_CLIPREGION_ACTION );\n                rOStm.WriteInt32( 24 );\n\n                if( pAct->IsClipping() )\n                {\n                    aClipRect = rRegion.GetBoundRect();\n                    rOStm.WriteInt16( 1 );\n                }\n                else\n                    rOStm.WriteInt16( 0 );\n\n                rOStm.WriteInt16( 0 );\n                ImplWriteRect( rOStm, aClipRect );\n\n                if( pAct->IsClipping() )\n                    ImplWriteRect( rOStm, aClipRect );\n\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::ISECTRECTCLIPREGION:\n            {\n                const MetaISectRectClipRegionAction* pAct = static_cast<const MetaISectRectClipRegionAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_ISECTCLIPREGION_ACTION );\n                rOStm.WriteInt32( 20 );\n                WriteRectangle( rOStm, pAct->GetRect() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::MOVECLIPREGION:\n            {\n                const MetaMoveClipRegionAction* pAct = static_cast<const MetaMoveClipRegionAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_MOVECLIPREGION_ACTION );\n                rOStm.WriteInt32( 12 );\n                rOStm.WriteInt32( pAct->GetHorzMove() );\n                rOStm.WriteInt32( pAct->GetVertMove() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::LINECOLOR:\n            {\n                const MetaLineColorAction* pAct = static_cast<const MetaLineColorAction*>(pAction);\n                ImplWriteLineColor( rOStm, rLineCol = pAct->GetColor(), pAct->IsSetting() ? 1 : 0 );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::FILLCOLOR:\n            {\n                const MetaFillColorAction* pAct = static_cast<const MetaFillColorAction*>(pAction);\n                ImplWriteFillColor( rOStm, pAct->GetColor(), pAct->IsSetting() ? 1 : 0 );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::FONT:\n            {\n                rSaveVDev.SetFont( static_cast<const MetaFontAction*>(pAction)->GetFont() );\n                ImplWriteFont( rOStm, rSaveVDev.GetFont(), rActualCharSet );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::TEXTCOLOR:\n            {\n                vcl::Font aSaveFont( rSaveVDev.GetFont() );\n\n                aSaveFont.SetColor( static_cast<const MetaTextColorAction*>(pAction)->GetColor() );\n                rSaveVDev.SetFont( aSaveFont );\n                ImplWriteFont( rOStm, rSaveVDev.GetFont(), rActualCharSet );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::TEXTFILLCOLOR:\n            {\n                const MetaTextFillColorAction* pAct = static_cast<const MetaTextFillColorAction*>(pAction);\n                vcl::Font                      aSaveFont( rSaveVDev.GetFont() );\n\n                if( pAct->IsSetting() )\n                    aSaveFont.SetFillColor( pAct->GetColor() );\n                else\n                    aSaveFont.SetFillColor( Color( COL_TRANSPARENT ) );\n\n                rSaveVDev.SetFont( aSaveFont );\n                ImplWriteFont( rOStm, rSaveVDev.GetFont(), rActualCharSet );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::TEXTALIGN:\n            {\n                vcl::Font aSaveFont( rSaveVDev.GetFont() );\n\n                aSaveFont.SetAlignment( static_cast<const MetaTextAlignAction*>(pAction)->GetTextAlign() );\n                rSaveVDev.SetFont( aSaveFont );\n                ImplWriteFont( rOStm, rSaveVDev.GetFont(), rActualCharSet );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::MAPMODE:\n            {\n                const MetaMapModeAction* pAct = static_cast<const MetaMapModeAction*>(pAction);\n\n                rOStm.WriteInt16( GDI_MAPMODE_ACTION );\n                rOStm.WriteInt32( 30 );\n                ImplWriteMapMode( rOStm, pAct->GetMapMode() );\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::PUSH:\n            {\n                ImplWritePushAction( rOStm );\n                rLineColStack.push( new Color( rLineCol ) );\n                rSaveVDev.Push();\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::POP:\n            {\n                Color* pCol;\n                if (rLineColStack.empty())\n                    pCol = nullptr;\n                else\n                {\n                    pCol = rLineColStack.top();\n                    rLineColStack.pop();\n                }\n\n                if( pCol )\n                {\n                    rLineCol = *pCol;\n                    delete pCol;\n                }\n\n                ImplWritePopAction( rOStm );\n                rSaveVDev.Pop();\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::RASTEROP:\n            {\n                const MetaRasterOpAction* pAct = static_cast<const MetaRasterOpAction*>(pAction);\n\n                if( ( pAct->GetRasterOp() != RasterOp::N0 ) && ( pAct->GetRasterOp() != RasterOp::N1 ) )\n                {\n                    sal_Int16 nRasterOp;\n\n                    // If RasterOp::N0/1 was set earlier, restore old state\n                    // via a Pop first\n                    if( rRop_0_1 )\n                    {\n                        ImplWritePopAction( rOStm );\n                        rSaveVDev.Pop();\n                        rRop_0_1 = false;\n                        nCount++;\n                    }\n\n                    switch( pAct->GetRasterOp() )\n                    {\n                        case RasterOp::OverPaint : nRasterOp = 0; break;\n                        case RasterOp::Xor :       nRasterOp = 4; break;\n                        case RasterOp::Invert:     nRasterOp = 1; break;\n                        default:                   nRasterOp = 0; break;\n                    }\n\n                    ImplWriteRasterOpAction( rOStm, nRasterOp );\n                    nCount++;\n                }\n                else\n                {\n                    ImplWritePushAction( rOStm );\n                    rSaveVDev.Push();\n\n                    if( pAct->GetRasterOp() == RasterOp::N0 )\n                    {\n                        ImplWriteLineColor( rOStm, COL_BLACK, 1 );\n                        ImplWriteFillColor( rOStm, COL_BLACK, 1 );\n                    }\n                    else\n                    {\n                        ImplWriteLineColor( rOStm, COL_WHITE, 1 );\n                        ImplWriteFillColor( rOStm, COL_WHITE, 1 );\n                    }\n\n                    ImplWriteRasterOpAction( rOStm, 0 );\n                    rRop_0_1 = true;\n                    nCount += 4;\n                }\n            }\n            break;\n\n            case MetaActionType::Transparent:\n            {\n                const tools::PolyPolygon& rPolyPoly = static_cast<const MetaTransparentAction*>(pAction)->GetPolyPolygon();\n                const sal_Int16           nTrans = static_cast<const MetaTransparentAction*>(pAction)->GetTransparence();\n                const sal_Int16           nBrushStyle = ( nTrans < 38 ) ? 8 : ( nTrans < 63 ) ? 9 : 10;\n                sal_uLong                 nOldPos, nNewPos;\n\n                // write transparence comment\n                rOStm.WriteInt16( GDI_TRANSPARENT_COMMENT );\n\n                // we'll write the ActionSize later\n                nOldPos = rOStm.Tell();\n                rOStm.SeekRel( 4 );\n\n                // write comment data\n                WritePolyPolygon( rOStm, rPolyPoly );\n                rOStm.WriteInt16( nTrans );\n                rOStm.WriteInt32( 15 ); // number of actions that follow this comment\n\n                // calculate and write ActionSize of comment\n                nNewPos = rOStm.Tell();\n                rOStm.Seek( nOldPos );\n                rOStm.WriteInt32( nNewPos - nOldPos );\n                rOStm.Seek( nNewPos );\n\n                {\n                    // write actions for transparence\n                    ImplWritePushAction( rOStm );\n                    {\n                        ImplWriteRasterOpAction( rOStm, 4 );\n                        ImplWritePolyPolyAction( rOStm, rPolyPoly );\n\n                        ImplWritePushAction( rOStm );\n                        {\n                            ImplWriteRasterOpAction( rOStm, 2 );\n                            ImplWriteFillColor( rOStm, COL_BLACK, nBrushStyle );\n                            ImplWritePolyPolyAction( rOStm, rPolyPoly );\n                        }\n                        ImplWritePopAction( rOStm );\n\n                        ImplWriteRasterOpAction( rOStm, 4 );\n                        ImplWritePolyPolyAction( rOStm, rPolyPoly );\n                    }\n                    ImplWritePopAction( rOStm );\n\n                    ImplWritePushAction( rOStm );\n                    {\n                        ImplWriteFillColor( rOStm, Color(), 0 );\n                        ImplWritePolyPolyAction( rOStm, rPolyPoly );\n                    }\n                    ImplWritePopAction( rOStm );\n\n                    nCount += 15;\n                }\n\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::FLOATTRANSPARENT:\n            {\n                const MetaFloatTransparentAction*   pA = static_cast<const MetaFloatTransparentAction*>(pAction);\n                const GDIMetaFile&                  rTransMtf = pA->GetGDIMetaFile();\n                const Point&                        rPos = pA->GetPoint();\n                const Size&                         rSize = pA->GetSize();\n                const Gradient&                     rGradient = pA->GetGradient();\n                sal_uLong                               nOldPos, nNewPos;\n\n                // write RefPoint comment\n                rOStm.WriteInt16( GDI_FLOATTRANSPARENT_COMMENT );\n\n                // we'll write the ActionSize later\n                nOldPos = rOStm.Tell();\n                rOStm.SeekRel( 4 );\n\n                // write comment data\n                WriteGDIMetaFile( rOStm, rTransMtf );\n                WritePair( rOStm, rPos );\n                WritePair( rOStm, rSize );\n                WriteGradient( rOStm, rGradient );\n\n                // calculate and write ActionSize of comment\n                nNewPos = rOStm.Tell();\n                rOStm.Seek( nOldPos );\n                rOStm.WriteInt32( nNewPos - nOldPos + 4 );\n                rOStm.Seek( ( nOldPos = nNewPos ) + 4 );\n\n                {\n                    // write actions for float transparence\n                    sal_uLong       nAddCount;\n                    GDIMetaFile     aMtf( rTransMtf );\n                    const Size      aSrcSize( rTransMtf.GetPrefSize() );\n                    Point           aSrcPt( rTransMtf.GetPrefMapMode().GetOrigin() );\n                    const double    fScaleX = aSrcSize.Width() ? (double) rSize.Width() / aSrcSize.Width() : 1.0;\n                    const double    fScaleY = aSrcSize.Height() ? (double) rSize.Height() / aSrcSize.Height() : 1.0;\n                    long            nMoveX, nMoveY;\n\n                    if( fScaleX != 1.0 || fScaleY != 1.0 )\n                    {\n                        aMtf.Scale( fScaleX, fScaleY );\n                        aSrcPt.X() = FRound( aSrcPt.X() * fScaleX );\n                        aSrcPt.Y() = FRound( aSrcPt.Y() * fScaleY );\n                    }\n\n                    nMoveX = rPos.X() - aSrcPt.X();\n                    nMoveY = rPos.Y() - aSrcPt.Y();\n\n                    if( nMoveX || nMoveY )\n                        aMtf.Move( nMoveX, nMoveY );\n\n                    nAddCount = ImplWriteActions( rOStm, aMtf, rSaveVDev, rRop_0_1, rLineCol, rLineColStack, rActualCharSet );\n                    nNewPos = rOStm.Tell();\n                    rOStm.Seek( nOldPos );\n                    rOStm.WriteInt32( nAddCount );\n                    rOStm.Seek( nNewPos );\n\n                    nCount += nAddCount;\n                }\n\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::HATCH:\n            {\n                const MetaHatchAction*    pA = static_cast<const MetaHatchAction*>(pAction);\n                const tools::PolyPolygon& rPolyPoly = pA->GetPolyPolygon();\n                const Hatch&            rHatch = pA->GetHatch();\n                sal_uLong               nOldPos, nNewPos, nAddCount;\n\n                // write hatch comment\n                rOStm.WriteInt16( GDI_HATCH_COMMENT );\n\n                // we'll write the ActionSize later\n                nOldPos = rOStm.Tell();\n                rOStm.SeekRel( 4 );\n\n                // write comment data\n                WritePolyPolygon( rOStm, rPolyPoly );\n                WriteHatch( rOStm, rHatch );\n\n                // calculate and write ActionSize of comment\n                nNewPos = rOStm.Tell();\n                rOStm.Seek( nOldPos );\n                rOStm.WriteInt32( nNewPos - nOldPos + 4 );\n                rOStm.Seek( ( nOldPos = nNewPos ) + 4 );\n\n                {\n                    // write actions for hatch\n                    ScopedVclPtrInstance< VirtualDevice > aVDev;\n                    GDIMetaFile     aTmpMtf;\n\n                    aVDev->AddHatchActions( rPolyPoly, rHatch, aTmpMtf );\n                    nAddCount = ImplWriteActions( rOStm, aTmpMtf, rSaveVDev, rRop_0_1, rLineCol, rLineColStack, rActualCharSet );\n                    nNewPos = rOStm.Tell();\n                    rOStm.Seek( nOldPos );\n                    rOStm.WriteInt32( nAddCount );\n                    rOStm.Seek( nNewPos );\n\n                    nCount += nAddCount;\n                }\n\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::REFPOINT:\n            {\n                const MetaRefPointAction*   pA = static_cast<const MetaRefPointAction*>(pAction);\n                const Point&                rRefPoint = pA->GetRefPoint();\n                const bool                  bSet = pA->IsSetting();\n                sal_uLong                   nOldPos, nNewPos;\n\n                // write RefPoint comment\n                rOStm.WriteInt16( GDI_REFPOINT_COMMENT );\n\n                // we'll write the ActionSize later\n                nOldPos = rOStm.Tell();\n                rOStm.SeekRel( 4 );\n\n                // write data\n                WritePair( rOStm, rRefPoint );\n                rOStm.WriteBool( bSet );\n                rOStm.WriteInt32( 0 ); // number of actions that follow this comment\n\n                // calculate and write ActionSize of comment\n                nNewPos = rOStm.Tell();\n                rOStm.Seek( nOldPos );\n                rOStm.WriteInt32( nNewPos - nOldPos );\n                rOStm.Seek( nNewPos );\n\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::TEXTLINECOLOR:\n            {\n                const MetaTextLineColorAction*  pA = static_cast<const MetaTextLineColorAction*>(pAction);\n                const Color&                    rColor = pA->GetColor();\n                const bool                      bSet = pA->IsSetting();\n                sal_uLong                       nOldPos, nNewPos;\n\n                // write RefPoint comment\n                rOStm.WriteInt16( GDI_TEXTLINECOLOR_COMMENT );\n\n                // we'll write the ActionSize later\n                nOldPos = rOStm.Tell();\n                rOStm.SeekRel( 4 );\n\n                // write data\n                WriteColor( rOStm, rColor );\n                rOStm.WriteBool( bSet );\n                rOStm.WriteInt32( 0 ); // number of actions that follow this comment\n\n                // calculate and write ActionSize of comment\n                nNewPos = rOStm.Tell();\n                rOStm.Seek( nOldPos );\n                rOStm.WriteInt32( nNewPos - nOldPos );\n                rOStm.Seek( nNewPos );\n\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::TEXTLINE:\n            {\n                const MetaTextLineAction*   pA = static_cast<const MetaTextLineAction*>(pAction);\n                const Point&                rStartPt = pA->GetStartPoint();\n                const sal_Int32             nWidth = (sal_Int32) pA->GetWidth();\n                const FontStrikeout         eStrikeout = pA->GetStrikeout();\n                const FontLineStyle         eUnderline = pA->GetUnderline();\n                sal_uLong                   nOldPos, nNewPos;\n\n                // write RefPoint comment\n                rOStm.WriteInt16( GDI_TEXTLINE_COMMENT );\n\n                // we'll write the ActionSize later\n                nOldPos = rOStm.Tell();\n                rOStm.SeekRel( 4 );\n\n                // write data\n                WritePair( rOStm, rStartPt );\n                rOStm.WriteInt32( nWidth ).WriteUInt32( eStrikeout ).WriteUInt32( eUnderline );\n                rOStm.WriteInt32( 0 ); // number of actions that follow this comment\n\n                // calculate and write ActionSize of comment\n                nNewPos = rOStm.Tell();\n                rOStm.Seek( nOldPos );\n                rOStm.WriteInt32( nNewPos - nOldPos );\n                rOStm.Seek( nNewPos );\n\n                nCount++;\n            }\n            break;\n\n            case MetaActionType::EPS:\n            break;\n\n            case MetaActionType::COMMENT:\n            {\n                const MetaCommentAction*    pA = static_cast<const MetaCommentAction*>(pAction);\n                const sal_uInt32            nDataSize = pA->GetDataSize();\n                sal_uLong                   nOldPos, nNewPos;\n\n                // write RefPoint comment\n                rOStm.WriteInt16( GDI_COMMENT_COMMENT );\n\n                // we'll write the ActionSize later\n                nOldPos = rOStm.Tell();\n                rOStm.SeekRel( 4 );\n\n                // write data\n                write_uInt16_lenPrefixed_uInt8s_FromOString(rOStm, pA->GetComment());\n                rOStm.WriteInt32( pA->GetValue() ).WriteUInt32( nDataSize );\n\n                if( nDataSize )\n                    rOStm.WriteBytes( pA->GetData(), nDataSize );\n\n                rOStm.WriteInt32( 0 ); // number of actions that follow this comment\n\n                // calculate and write ActionSize of comment\n                nNewPos = rOStm.Tell();\n                rOStm.Seek( nOldPos );\n                rOStm.WriteInt32( nNewPos - nOldPos );\n                rOStm.Seek( nNewPos );\n\n                nCount++;\n            }\n            break;\n\n            default:\n#ifdef DBG_UTIL\n            {\n                OStringBuffer aStr(\"Missing implementation for Action#: \");\n                aStr.append(static_cast<sal_Int32>(pAction->GetType()));\n                aStr.append('!');\n                OSL_FAIL(aStr.getStr());\n            }\n#endif\n            break;\n        }\n    }\n\n    return nCount;\n}\n\n/* vim:set shiftwidth=4 softtabstop=4 expandtab: */\n"], "filenames": ["vcl/source/gdi/svmconverter.cxx"], "buggy_code_start_loc": [991], "buggy_code_end_loc": [992], "fixing_code_start_loc": [991], "fixing_code_end_loc": [992], "type": "CWE-787", "message": "LibreOffice before 2017-03-11 has an out-of-bounds write caused by a heap-based buffer overflow in the SVMConverter::ImplConvertFromSVM1 function in vcl/source/gdi/svmconverter.cxx.", "other": {"cve": {"id": "CVE-2017-7856", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-14T04:59:00.227", "lastModified": "2017-11-15T02:29:10.563", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "LibreOffice before 2017-03-11 has an out-of-bounds write caused by a heap-based buffer overflow in the SVMConverter::ImplConvertFromSVM1 function in vcl/source/gdi/svmconverter.cxx."}, {"lang": "es", "value": "LibreOffice en versiones anteriores a 11-03-2017 tiene una escritura fuera de l\u00edmites provocado por un desbordamiento de b\u00fafer basado en memoria din\u00e1mica en la funci\u00f3n SVMConverter::ImplConvertFromSVM1 en vcl/source/gdi/svmconverter.cxx"}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libreoffice:libreoffice:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.2.6.1", "matchCriteriaId": "064A809A-AF00-4197-82E3-0B749A78EFCA"}]}]}], "references": [{"url": "http://www.libreoffice.org/about-us/security/advisories/cve-2017-7856/", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/97667", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=817", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/LibreOffice/core/commit/28e61b634353110445e334ccaa415d7fb6629d62", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibreOffice/core/commit/28e61b634353110445e334ccaa415d7fb6629d62"}}