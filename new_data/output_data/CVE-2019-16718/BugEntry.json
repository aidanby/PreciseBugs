{"buggy_code": ["/* radare - LGPL - Copyright 2011-2019 - earada, pancake */\n\n#include <r_core.h>\n#include <r_config.h>\n#include \"r_util.h\"\n#include \"r_util/r_time.h\"\n\n#define is_in_range(at, from, sz) ((at) >= (from) && (at) < ((from) + (sz)))\n\n#define VA_FALSE    0\n#define VA_TRUE     1\n#define VA_NOREBASE 2\n\n#define LOAD_BSS_MALLOC 0\n\n#define IS_MODE_SET(mode) ((mode) & R_MODE_SET)\n#define IS_MODE_SIMPLE(mode) ((mode) & R_MODE_SIMPLE)\n#define IS_MODE_SIMPLEST(mode) ((mode) & R_MODE_SIMPLEST)\n#define IS_MODE_JSON(mode) ((mode) & R_MODE_JSON)\n#define IS_MODE_RAD(mode) ((mode) & R_MODE_RADARE)\n#define IS_MODE_EQUAL(mode) ((mode) & R_MODE_EQUAL)\n#define IS_MODE_NORMAL(mode) (!(mode))\n#define IS_MODE_CLASSDUMP(mode) ((mode) & R_MODE_CLASSDUMP)\n\n// dup from cmd_info\n#define PAIR_WIDTH 9\n\n#define bprintf if (binfile && binfile->rbin && binfile->rbin->verbose) eprintf\n\nstatic void pair(const char *key, const char *val, int mode, bool last) {\n\tif (!val || !*val) {\n\t\treturn;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tconst char *lst = last ? \"\" : \",\";\n\t\tr_cons_printf (\"\\\"%s\\\":%s%s\", key, val, lst);\n\t} else {\n\t\tchar ws[16];\n\t\tconst int keyl = strlen (key);\n\t\tconst int wl = (keyl > PAIR_WIDTH) ? 0 : PAIR_WIDTH - keyl;\n\t\tmemset (ws, ' ', wl);\n\t\tws[wl] = 0;\n\t\tr_cons_printf (\"%s%s%s\\n\", key, ws, val);\n\t}\n}\n\nstatic void pair_bool(const char *key, bool val, int mode, bool last) {\n\tpair (key, r_str_bool (val), mode, last);\n}\n\nstatic void pair_int(const char *key, int val, int mode, bool last) {\n\tpair (key, sdb_fmt (\"%d\", val), mode, last);\n}\n\nstatic void pair_ut64(const char *key, ut64 val, int mode, bool last) {\n\tpair (key, sdb_fmt (\"%\"PFMT64d, val), mode, last);\n}\n\nstatic char *__filterQuotedShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tswitch (*arg) {\n\t\tcase ' ':\n\t\tcase '=':\n\t\tcase '\\r':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = *arg;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}\n// TODO: move into libr/util/name.c\nstatic char *__filterShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tswitch (*arg) {\n\t\tcase '@':\n\t\tcase '`':\n\t\tcase '|':\n\t\tcase ';':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = *arg;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}\n\nstatic void pair_ut64x(const char *key, ut64 val, int mode, bool last) {\n\tconst char *str_val = IS_MODE_JSON (mode) ? sdb_fmt (\"%\"PFMT64d, val) : sdb_fmt (\"0x%\"PFMT64x, val);\n\tpair (key, str_val, mode, last);\n}\n\nstatic void pair_str(const char *key, const char *val, int mode, int last) {\n\tif (IS_MODE_JSON (mode)) {\n\t\tif (!val) {\n\t\t\tval = \"\";\n\t\t}\n\t\tchar *encval = r_str_escape_utf8_for_json (val, -1);\n\t\tif (encval) {\n\t\t\tchar *qs = r_str_newf (\"\\\"%s\\\"\", encval);\n\t\t\tpair (key, qs, mode, last);\n\t\t\tfree (encval);\n\t\t\tfree (qs);\n\t\t}\n\t} else {\n\t\tpair (key, val, mode, last);\n\t}\n}\n\n#define STR(x) (x)? (x): \"\"\nR_API int r_core_bin_set_cur(RCore *core, RBinFile *binfile);\n\nstatic ut64 rva(RBin *bin, ut64 paddr, ut64 vaddr, int va) {\n\tif (va == VA_TRUE) {\n\t\tif (paddr != UT64_MAX) {\n\t\t\treturn r_bin_get_vaddr (bin, paddr, vaddr);\n\t\t}\n\t}\n\tif (va == VA_NOREBASE) {\n\t\treturn vaddr;\n\t}\n\treturn paddr;\n}\n\nR_API int r_core_bin_set_by_fd(RCore *core, ut64 bin_fd) {\n\tif (r_bin_file_set_cur_by_fd (core->bin, bin_fd)) {\n\t\tr_core_bin_set_cur (core, r_bin_cur (core->bin));\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_set_by_name(RCore *core, const char * name) {\n\tif (r_bin_file_set_cur_by_name (core->bin, name)) {\n\t\tr_core_bin_set_cur (core, r_bin_cur (core->bin));\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_set_env(RCore *r, RBinFile *binfile) {\n\tr_return_val_if_fail (r, false);\n\n\tRBinObject *binobj = binfile? binfile->o: NULL;\n\tRBinInfo *info = binobj? binobj->info: NULL;\n\tif (info) {\n\t\tint va = info->has_va;\n\t\tconst char *arch = info->arch;\n\t\tut16 bits = info->bits;\n\t\tut64 baseaddr = r_bin_get_baddr (r->bin);\n\t\tr_config_set_i (r->config, \"bin.baddr\", baseaddr);\n\t\tsdb_num_add (r->sdb, \"orig_baddr\", baseaddr, 0);\n\t\tr_config_set (r->config, \"asm.arch\", arch);\n\t\tr_config_set_i (r->config, \"asm.bits\", bits);\n\t\tr_config_set (r->config, \"anal.arch\", arch);\n\t\tif (info->cpu && *info->cpu) {\n\t\t\tr_config_set (r->config, \"anal.cpu\", info->cpu);\n\t\t} else {\n\t\t\tr_config_set (r->config, \"anal.cpu\", arch);\n\t\t}\n\t\tr_asm_use (r->assembler, arch);\n\t\tr_core_bin_info (r, R_CORE_BIN_ACC_ALL, R_MODE_SET, va, NULL, NULL);\n\t\tr_core_bin_set_cur (r, binfile);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_set_cur(RCore *core, RBinFile *binfile) {\n\tif (!core->bin) {\n\t\treturn false;\n\t}\n\tif (!binfile) {\n\t\t// Find first available binfile\n\t\tut32 fd = r_core_file_cur_fd (core);\n\t\tbinfile = fd != (ut32)-1\n\t\t\t\t  ? r_bin_file_find_by_fd (core->bin, fd)\n\t\t\t\t  : NULL;\n\t\tif (!binfile) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tr_bin_file_set_cur_binfile (core->bin, binfile);\n\treturn true;\n}\n\nR_API int r_core_bin_refresh_strings(RCore *r) {\n\treturn r_bin_reset_strings (r->bin)? true: false;\n}\n\nstatic void _print_strings(RCore *r, RList *list, int mode, int va) {\n\tbool b64str = r_config_get_i (r->config, \"bin.b64str\");\n\tint minstr = r_config_get_i (r->config, \"bin.minstr\");\n\tint maxstr = r_config_get_i (r->config, \"bin.maxstr\");\n\tRBin *bin = r->bin;\n\tRBinObject *obj = r_bin_cur_object (bin);\n\tRListIter *iter;\n\tRListIter *last_processed = NULL;\n\tRBinString *string;\n\tRBinSection *section;\n\tchar *q;\n\n\tbin->minstrlen = minstr;\n\tbin->maxstrlen = maxstr;\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[\");\n\t}\n\tif (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs strings\");\n\t}\n\tif (IS_MODE_SET (mode) && r_config_get_i (r->config, \"bin.strings\")) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_STRINGS);\n\t\tr_cons_break_push (NULL, NULL);\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"[Strings]\\n\");\n\t\tr_cons_printf (\"Num Paddr      Vaddr      Len Size Section  Type  String\\n\");\n\t}\n\tRBinString b64 = { 0 };\n\tr_list_foreach (list, iter, string) {\n\t\tconst char *section_name, *type_string;\n\t\tut64 paddr, vaddr;\n\t\tpaddr = string->paddr;\n\t\tvaddr = rva (r->bin, paddr, string->vaddr, va);\n\t\tif (!r_bin_string_filter (bin, string->string, vaddr)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (string->length < minstr) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (maxstr && string->length > maxstr) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsection = obj? r_bin_get_section_at (obj, paddr, 0): NULL;\n\t\tsection_name = section ? section->name : \"\";\n\t\ttype_string = r_bin_string_type (string->type);\n\t\tif (b64str) {\n\t\t\tut8 *s = r_base64_decode_dyn (string->string, -1);\n\t\t\tif (s && *s && IS_PRINTABLE (*s)) {\n\t\t\t\t// TODO: add more checks\n\t\t\t\tfree (b64.string);\n\t\t\t\tmemcpy (&b64, string, sizeof (b64));\n\t\t\t\tb64.string = (char *)s;\n\t\t\t\tb64.size = strlen (b64.string);\n\t\t\t\tstring = &b64;\n\t\t\t}\n\t\t}\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tchar *f_name, *f_realname, *str;\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_meta_add (r->anal, R_META_TYPE_STRING, vaddr, vaddr + string->size, string->string);\n\t\t\tf_name = strdup (string->string);\n\t\t\tr_name_filter (f_name, -1);\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tstr = r_str_newf (\"%s.str.%s\", r->bin->prefix, f_name);\n\t\t\t\tf_realname = r_str_newf (\"%s.\\\"%s\\\"\", r->bin->prefix, string->string);\n\t\t\t} else {\n\t\t\t\tstr = r_str_newf (\"str.%s\", f_name);\n\t\t\t\tf_realname = r_str_newf (\"\\\"%s\\\"\", string->string);\n\t\t\t}\n\t\t\tRFlagItem *flag = r_flag_set (r->flags, str, vaddr, string->size);\n\t\t\tr_flag_item_set_realname (flag, f_realname);\n\t\t\tfree (str);\n\t\t\tfree (f_name);\n\t\t\tfree (f_realname);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%\"PFMT64x\" %d %d %s\\n\", vaddr,\n\t\t\t\tstring->size, string->length, string->string);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tr_cons_println (string->string);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tint *block_list;\n\t\t\tq = r_base64_encode_dyn (string->string, -1);\n\t\t\tr_cons_printf (\"%s{\\\"vaddr\\\":%\"PFMT64u\n\t\t\t\t\",\\\"paddr\\\":%\"PFMT64u\",\\\"ordinal\\\":%d\"\n\t\t\t\t\",\\\"size\\\":%d,\\\"length\\\":%d,\\\"section\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\\\"string\\\":\\\"%s\\\"\",\n\t\t\t\tlast_processed ? \",\": \"\",\n\t\t\t\tvaddr, paddr, string->ordinal, string->size,\n\t\t\t\tstring->length, section_name, type_string, q);\n\t\t\tswitch (string->type) {\n\t\t\tcase R_STRING_TYPE_UTF8:\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tblock_list = r_utf_block_list ((const ut8*)string->string, -1, NULL);\n\t\t\t\tif (block_list) {\n\t\t\t\t\tif (block_list[0] == 0 && block_list[1] == -1) {\n\t\t\t\t\t\t/* Don't include block list if\n\t\t\t\t\t\t   just Basic Latin (0x00 - 0x7F) */\n\t\t\t\t\t\tR_FREE (block_list);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint *block_ptr = block_list;\n\t\t\t\t\tr_cons_printf (\",\\\"blocks\\\":[\");\n\t\t\t\t\tfor (; *block_ptr != -1; block_ptr++) {\n\t\t\t\t\t\tif (block_ptr != block_list) {\n\t\t\t\t\t\t\tr_cons_printf (\",\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst char *utfName = r_utf_block_name (*block_ptr);\n\t\t\t\t\t\tr_cons_printf (\"\\\"%s\\\"\", utfName? utfName: \"\");\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"]\");\n\t\t\t\t\tR_FREE (block_list);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"}\");\n\t\t\tfree (q);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tchar *f_name = strdup (string->string);\n\t\t\tr_name_filter (f_name, R_FLAG_NAME_SIZE);\n\t\t\tchar *str = (r->bin->prefix)\n\t\t\t\t? r_str_newf (\"%s.str.%s\", r->bin->prefix, f_name)\n\t\t\t\t: r_str_newf (\"str.%s\", f_name);\n\t\t\tr_cons_printf (\"f %s %\"PFMT64d\" 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\"Cs %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\tstr, string->size, vaddr,\n\t\t\t\tstring->size, vaddr);\n\t\t\tfree (str);\n\t\t\tfree (f_name);\n\t\t} else {\n\t\t\tint *block_list;\n\t\t\tchar *str = string->string;\n\t\t\tchar *no_dbl_bslash_str = NULL;\n\t\t\tif (!r->print->esc_bslash) {\n\t\t\t\tchar *ptr;\n\t\t\t\tfor (ptr = str; *ptr; ptr++) {\n\t\t\t\t\tif (*ptr != '\\\\') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (*(ptr + 1) == '\\\\') {\n\t\t\t\t\t\tif (!no_dbl_bslash_str) {\n\t\t\t\t\t\t\tno_dbl_bslash_str = strdup (str);\n\t\t\t\t\t\t\tif (!no_dbl_bslash_str) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tptr = no_dbl_bslash_str + (ptr - str);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemmove (ptr + 1, ptr + 2, strlen (ptr + 2) + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (no_dbl_bslash_str) {\n\t\t\t\t\tstr = no_dbl_bslash_str;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"%03u 0x%08\" PFMT64x \" 0x%08\" PFMT64x \" %3u %3u (%s) %5s %s\",\n\t\t\t\tstring->ordinal, paddr, vaddr,\n\t\t\t\tstring->length, string->size,\n\t\t\t\tsection_name, type_string, str);\n\t\t\tif (str == no_dbl_bslash_str) {\n\t\t\t\tR_FREE (str);\n\t\t\t}\n\t\t\tswitch (string->type) {\n\t\t\tcase R_STRING_TYPE_UTF8:\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tblock_list = r_utf_block_list ((const ut8*)string->string, -1, NULL);\n\t\t\t\tif (block_list) {\n\t\t\t\t\tif (block_list[0] == 0 && block_list[1] == -1) {\n\t\t\t\t\t\t/* Don't show block list if\n\t\t\t\t\t\t   just Basic Latin (0x00 - 0x7F) */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint *block_ptr = block_list;\n\t\t\t\t\tr_cons_printf (\" blocks=\");\n\t\t\t\t\tfor (; *block_ptr != -1; block_ptr++) {\n\t\t\t\t\t\tif (block_ptr != block_list) {\n\t\t\t\t\t\t\tr_cons_printf (\",\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst char *name = r_utf_block_name (*block_ptr);\n\t\t\t\t\t\tr_cons_printf (\"%s\", name? name: \"\");\n\t\t\t\t\t}\n\t\t\t\t\tfree (block_list);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_cons_printf (\"\\n\");\n\t\t}\n\t\tlast_processed = iter;\n\t}\n\tR_FREE (b64.string);\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tr_cons_break_pop ();\n\t}\n}\n\nstatic bool bin_raw_strings(RCore *r, int mode, int va) {\n\tRBinFile *bf = r_bin_cur (r->bin);\n\tbool new_bf = false;\n\tif (bf && strstr (bf->file, \"malloc://\")) {\n\t\t//sync bf->buf to search string on it\n\t\tut8 *tmp = R_NEWS (ut8, bf->size);\n\t\tif (!tmp) {\n\t\t\treturn false;\n\t\t}\n\t\tr_io_read_at (r->io, 0, tmp, bf->size);\n\t\tr_buf_write_at (bf->buf, 0, tmp, bf->size);\n\t}\n\tif (!r->file) {\n\t\teprintf (\"Core file not open\\n\");\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_print (\"[]\");\n\t\t}\n\t\treturn false;\n\t}\n\tif (!bf) {\n\t\tbf = R_NEW0 (RBinFile);\n\t\tif (!bf) {\n\t\t\treturn false;\n\t\t}\n\t\tRIODesc *desc = r_io_desc_get (r->io, r->file->fd);\n\t\tif (!desc) {\n\t\t\tfree (bf);\n\t\t\treturn false;\n\t\t}\n\t\tbf->file = strdup (desc->name);\n\t\tbf->size = r_io_desc_size (desc);\n\t\tif (bf->size == UT64_MAX) {\n\t\t\tfree (bf);\n\t\t\treturn false;\n\t\t}\n\t\tbf->buf = r_buf_new_with_io (&r->bin->iob, r->file->fd);\n\t\tbf->o = NULL;\n\t\tbf->rbin = r->bin;\n\t\tnew_bf = true;\n\t\tva = false;\n\t}\n\tRList *l = r_bin_raw_strings (bf, 0);\n\t_print_strings (r, l, mode, va);\n\tr_list_free (l);\n\tif (new_bf) {\n\t\tr_buf_free (bf->buf);\n\t\tbf->buf = NULL;\n\t\tbf->id = -1;\n\t\tr_bin_file_free (bf);\n\t}\n\treturn true;\n}\n\nstatic bool bin_strings(RCore *r, int mode, int va) {\n\tRList *list;\n\tRBinFile *binfile = r_bin_cur (r->bin);\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (binfile);\n\tint rawstr = r_config_get_i (r->config, \"bin.rawstr\");\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (!r_config_get_i (r->config, \"bin.strings\")) {\n\t\treturn false;\n\t}\n\tif (!plugin) {\n\t\treturn false;\n\t}\n\tif (plugin->info && plugin->name) {\n\t\tif (strcmp (plugin->name, \"any\") == 0 && !rawstr) {\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_print(\"[]\");\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!(list = r_bin_get_strings (r->bin))) {\n\t\treturn false;\n\t}\n\t_print_strings (r, list, mode, va);\n\treturn true;\n}\n\nstatic const char* get_compile_time(Sdb *binFileSdb) {\n\tSdb *info_ns = sdb_ns (binFileSdb, \"info\", false);\n\tconst char *timeDateStamp_string = sdb_const_get (info_ns,\n\t\t\"image_file_header.TimeDateStamp_string\", 0);\n\treturn timeDateStamp_string;\n}\n\nstatic bool is_executable(RBinObject *obj) {\n\tRListIter *it;\n\tRBinSection* sec;\n\tr_return_val_if_fail (obj, false);\n\tif (obj->info && obj->info->arch) {\n\t\treturn true;\n\t}\n\tr_list_foreach (obj->sections, it, sec) {\n\t\tif (sec->perm & R_PERM_X) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void sdb_concat_by_path(Sdb *s, const char *path) {\n\tSdb *db = sdb_new (0, path, 0);\n\tsdb_merge (s, db);\n\tsdb_close (db);\n\tsdb_free (db);\n}\n\nR_API void r_core_anal_type_init(RCore *core) {\n\tr_return_if_fail (core && core->anal);\n\tconst char *dir_prefix = r_config_get (core->config, \"dir.prefix\");\n\tint bits = core->assembler->bits;\n\tSdb *types = core->anal->sdb_types;\n\t// make sure they are empty this is initializing\n\tsdb_reset (types);\n\tconst char *anal_arch = r_config_get (core->config, \"anal.arch\");\n\tconst char *os = r_config_get (core->config, \"asm.os\");\n\t// spaguetti ahead\n\n\tconst char *dbpath = sdb_fmt (R_JOIN_3_PATHS (\"%s\", R2_SDB_FCNSIGN, \"types.sdb\"), dir_prefix);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (R_JOIN_3_PATHS (\"%s\", R2_SDB_FCNSIGN, \"types-%s.sdb\"),\n\t\tdir_prefix, anal_arch);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (R_JOIN_3_PATHS (\"%s\", R2_SDB_FCNSIGN, \"types-%s.sdb\"),\n\t\tdir_prefix, os);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (R_JOIN_3_PATHS (\"%s\", R2_SDB_FCNSIGN, \"types-%d.sdb\"),\n\t\tdir_prefix, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (R_JOIN_3_PATHS (\"%s\", R2_SDB_FCNSIGN, \"types-%s-%d.sdb\"),\n\t\tdir_prefix, os, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (R_JOIN_3_PATHS (\"%s\", R2_SDB_FCNSIGN, \"types-%s-%d.sdb\"),\n\t\tdir_prefix, anal_arch, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (R_JOIN_3_PATHS (\"%s\", R2_SDB_FCNSIGN, \"types-%s-%s.sdb\"),\n\t\tdir_prefix, anal_arch, os);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (R_JOIN_3_PATHS (\"%s\", R2_SDB_FCNSIGN, \"types-%s-%s-%d.sdb\"),\n\t\tdir_prefix, anal_arch, os, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n}\n\nstatic int save_ptr(void *p, const char *k, const char *v) {\n\tSdb *sdbs[2];\n\tsdbs[0] = ((Sdb**) p)[0];\n\tsdbs[1] = ((Sdb**) p)[1];\n\tif (!strncmp (v, \"cc\", strlen (\"cc\") + 1)) {\n\t\tconst char *x = sdb_const_get (sdbs[1], sdb_fmt (\"cc.%s.name\", k), 0);\n\t\tchar *tmp = sdb_fmt (\"%p\", x);\n\t\tsdb_set (sdbs[0], tmp, x, 0);\n\t}\n\treturn 1;\n}\n\nR_API void r_core_anal_cc_init(RCore *core) {\n\tSdb *sdbs[2] = {\n\t\tsdb_new0 (),\n\t\tcore->anal->sdb_cc\n\t};\n\tconst char *dir_prefix = r_config_get (core->config, \"dir.prefix\");\n\t//save pointers and values stored inside them\n\t//to recover from freeing heeps\n\tconst char *defaultcc = sdb_const_get (sdbs[1], \"default.cc\", 0);\n\tsdb_set (sdbs[0], sdb_fmt (\"0x%08\"PFMT64x, r_num_get (NULL, defaultcc)), defaultcc, 0);\n\tsdb_foreach (core->anal->sdb_cc, save_ptr, sdbs);\n\tsdb_reset (core->anal->sdb_cc);\n\tconst char *anal_arch = r_config_get (core->config, \"anal.arch\");\n\n\tint bits = core->anal->bits;\n\tchar *dbpath = sdb_fmt (\"%s/\"R2_SDB_FCNSIGN\"/cc-%s-%d.sdb\", dir_prefix, anal_arch, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (core->anal->sdb_cc, dbpath);\n\t}\n\t//restore all freed CC or replace with new default cc\n\tRListIter *it;\n\tRAnalFunction *fcn;\n\tr_list_foreach (core->anal->fcns, it, fcn) {\n\t\tconst char *cc = NULL;\n\t\tif (fcn->cc) {\n\t\t\tchar *ptr = sdb_fmt (\"%p\", fcn->cc);\n\t\t\tcc = sdb_const_get (sdbs[0], ptr, 0);\n\t\t}\n\t\tif  (!cc) {\n\t\t\tcc = r_anal_cc_default (core->anal);\n\t\t}\n\t\tfcn->cc = r_str_const (cc);\n\t}\n\tsdb_close (sdbs[0]);\n\tsdb_free (sdbs[0]);\n}\n\nstatic int bin_info(RCore *r, int mode, ut64 laddr) {\n\tint i, j, v;\n\tchar str[R_FLAG_NAME_SIZE];\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRBinFile *bf = r_bin_cur (r->bin);\n\tif (!bf) {\n\t\treturn false;\n\t}\n\tRBinObject *obj = bf->o;\n\tconst char *compiled = NULL;\n\tbool havecode;\n\n\tif (!bf || !info || !obj) {\n\t\tif (mode & R_MODE_JSON) {\n\t\t\tr_cons_printf (\"{}\");\n\t\t}\n\t\treturn false;\n\t}\n\thavecode = is_executable (obj) | (obj->entries != NULL);\n\tcompiled = get_compile_time (bf->sdb);\n\n\tif (IS_MODE_SET (mode)) {\n\t\tr_config_set (r->config, \"file.type\", info->rclass);\n\t\tr_config_set (r->config, \"cfg.bigendian\",\n\t\t\t      info->big_endian ? \"true\" : \"false\");\n\t\tif (info->rclass && !strcmp (info->rclass, \"fs\")) {\n\t\t\t// r_config_set (r->config, \"asm.arch\", info->arch);\n\t\t\t// r_core_seek (r, 0, 1);\n\t\t\t// eprintf (\"m /root %s 0\", info->arch);\n\t//\t\tr_core_cmdf (r, \"m /root hfs @ 0\", info->arch);\n\t\t} else {\n\t\t\tif (info->lang) {\n\t\t\t\tr_config_set (r->config, \"bin.lang\", info->lang);\n\t\t\t}\n\t\t\tr_config_set (r->config, \"asm.os\", info->os);\n\t\t\tif (info->rclass && !strcmp (info->rclass, \"pe\")) {\n\t\t\t\tr_config_set (r->config, \"anal.cpp.abi\", \"msvc\");\n\t\t\t} else {\n\t\t\t\tr_config_set (r->config, \"anal.cpp.abi\", \"itanium\");\n\t\t\t}\n\t\t\tr_config_set (r->config, \"asm.arch\", info->arch);\n\t\t\tif (info->cpu && *info->cpu) {\n\t\t\t\tr_config_set (r->config, \"asm.cpu\", info->cpu);\n\t\t\t}\n\t\t\tr_config_set (r->config, \"anal.arch\", info->arch);\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"%i\", info->bits);\n\t\t\tr_config_set (r->config, \"asm.bits\", str);\n\t\t\tr_config_set (r->config, \"asm.dwarf\",\n\t\t\t\t(R_BIN_DBG_STRIPPED & info->dbg_info) ? \"false\" : \"true\");\n\t\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\t\tif (v != -1) {\n\t\t\t\tr_config_set_i (r->config, \"asm.pcalign\", v);\n\t\t\t}\n\t\t}\n\t\tr_core_anal_type_init (r);\n\t\tr_core_anal_cc_init (r);\n\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\tr_cons_printf (\"arch %s\\n\", info->arch);\n\t\tif (info->cpu && *info->cpu) {\n\t\t\tr_cons_printf (\"cpu %s\\n\", info->cpu);\n\t\t}\n\t\tr_cons_printf (\"bits %d\\n\", info->bits);\n\t\tr_cons_printf (\"os %s\\n\", info->os);\n\t\tr_cons_printf (\"endian %s\\n\", info->big_endian? \"big\": \"little\");\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tr_cons_printf (\"minopsz %d\\n\", v);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tr_cons_printf (\"maxopsz %d\\n\", v);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\tif (v != -1) {\n\t\t\tr_cons_printf (\"pcalign %d\\n\", v);\n\t\t}\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tif (info->type && !strcmp (info->type, \"fs\")) {\n\t\t\tr_cons_printf (\"e file.type=fs\\n\");\n\t\t\tr_cons_printf (\"m /root %s 0\\n\", info->arch);\n\t\t} else {\n\t\t\tr_cons_printf (\"e cfg.bigendian=%s\\n\"\n\t\t\t\t\"e asm.bits=%i\\n\"\n\t\t\t\t\"e asm.dwarf=%s\\n\",\n\t\t\t\tr_str_bool (info->big_endian),\n\t\t\t\tinfo->bits,\n\t\t\t\tr_str_bool (R_BIN_DBG_STRIPPED &info->dbg_info));\n\t\t\tif (info->lang && *info->lang) {\n\t\t\t\tr_cons_printf (\"e bin.lang=%s\\n\", info->lang);\n\t\t\t}\n\t\t\tif (info->rclass && *info->rclass) {\n\t\t\t\tr_cons_printf (\"e file.type=%s\\n\",\n\t\t\t\t\tinfo->rclass);\n\t\t\t}\n\t\t\tif (info->os) {\n\t\t\t\tr_cons_printf (\"e asm.os=%s\\n\", info->os);\n\t\t\t}\n\t\t\tif (info->arch) {\n\t\t\t\tr_cons_printf (\"e asm.arch=%s\\n\", info->arch);\n\t\t\t}\n\t\t\tif (info->cpu && *info->cpu) {\n\t\t\t\tr_cons_printf (\"e asm.cpu=%s\\n\", info->cpu);\n\t\t\t}\n\t\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\t\tif (v != -1) {\n\t\t\t\tr_cons_printf (\"e asm.pcalign=%d\\n\", v);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// XXX: if type is 'fs' show something different?\n\t\tchar *tmp_buf;\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"{\");\n\t\t}\n\t\tpair_str (\"arch\", info->arch, mode, false);\n\t\tif (info->cpu && *info->cpu) {\n\t\t\tpair_str (\"cpu\", info->cpu, mode, false);\n\t\t}\n\t\tpair_ut64x (\"baddr\", r_bin_get_baddr (r->bin), mode, false);\n\t\tpair_ut64 (\"binsz\", r_bin_get_size (r->bin), mode, false);\n\t\tpair_str (\"bintype\", info->rclass, mode, false);\n\t\tpair_int (\"bits\", info->bits, mode, false);\n\t\tpair_bool (\"canary\", info->has_canary, mode, false);\n\t\tif (info->has_retguard != -1) {\n\t\t\tpair_bool (\"retguard\", info->has_retguard, mode, false);\n\t\t}\n\t\tpair_str (\"class\", info->bclass, mode, false);\n\t\tif (info->actual_checksum) {\n\t\t\t/* computed checksum */\n\t\t\tpair_str (\"cmp.csum\", info->actual_checksum, mode, false);\n\t\t}\n\t\tpair_str (\"compiled\", compiled, mode, false);\n\t\tpair_str (\"compiler\", info->compiler, mode, false);\n\t\tpair_bool (\"crypto\", info->has_crypto, mode, false);\n\t\tpair_str (\"dbg_file\", info->debug_file_name, mode, false);\n\t\tpair_str (\"endian\", info->big_endian ? \"big\" : \"little\", mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"mdmp\")) {\n\t\t\ttmp_buf = sdb_get (bf->sdb, \"mdmp.flags\", 0);\n\t\t\tif (tmp_buf) {\n\t\t\t\tpair_str (\"flags\", tmp_buf, mode, false);\n\t\t\t\tfree (tmp_buf);\n\t\t\t}\n\t\t}\n\t\tpair_bool (\"havecode\", havecode, mode, false);\n\t\tif (info->claimed_checksum) {\n\t\t\t/* checksum specified in header */\n\t\t\tpair_str (\"hdr.csum\", info->claimed_checksum, mode, false);\n\t\t}\n\t\tpair_str (\"guid\", info->guid, mode, false);\n\t\tpair_str (\"intrp\", info->intrp, mode, false);\n\t\tpair_ut64x (\"laddr\", laddr, mode, false);\n\t\tpair_str (\"lang\", info->lang, mode, false);\n\t\tpair_bool (\"linenum\", R_BIN_DBG_LINENUMS & info->dbg_info, mode, false);\n\t\tpair_bool (\"lsyms\", R_BIN_DBG_SYMS & info->dbg_info, mode, false);\n\t\tpair_str (\"machine\", info->machine, mode, false);\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tpair_int (\"maxopsz\", v, mode, false);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tpair_int (\"minopsz\", v, mode, false);\n\t\t}\n\t\tpair_bool (\"nx\", info->has_nx, mode, false);\n\t\tpair_str (\"os\", info->os, mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"pe\")) {\n\t\t\tpair_bool (\"overlay\", info->pe_overlay, mode, false);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\tif (v != -1) {\n\t\t\tpair_int (\"pcalign\", v, mode, false);\n\t\t}\n\t\tpair_bool (\"pic\", info->has_pi, mode, false);\n\t\tpair_bool (\"relocs\", R_BIN_DBG_RELOCS & info->dbg_info, mode, false);\n\t\tSdb *sdb_info = sdb_ns (obj->kv, \"info\", false);\n\t\ttmp_buf = sdb_get (sdb_info, \"elf.relro\", 0);\n\t\tif (tmp_buf) {\n\t\t\tpair_str (\"relro\", tmp_buf, mode, false);\n\t\t\tfree (tmp_buf);\n\t\t}\n\t\tpair_str (\"rpath\", info->rpath, mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"pe\")) {\n\t\t\t//this should be moved if added to mach0 (or others)\n\t\t\tpair_bool (\"signed\", info->signature, mode, false);\n\t\t}\n\t\tpair_bool (\"sanitiz\", info->has_sanitizers, mode, false);\n\t\tpair_bool (\"static\", r_bin_is_static (r->bin), mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"mdmp\")) {\n\t\t\tv = sdb_num_get (bf->sdb, \"mdmp.streams\", 0);\n\t\t\tif (v != -1) {\n\t\t\t\tpair_int (\"streams\", v, mode, false);\n\t\t\t}\n\t\t}\n\t\tpair_bool (\"stripped\", R_BIN_DBG_STRIPPED & info->dbg_info, mode, false);\n\t\tpair_str (\"subsys\", info->subsystem, mode, false);\n\t\tpair_bool (\"va\", info->has_va, mode, true);\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\",\\\"checksums\\\":{\");\n\t\t\tfor (i = 0; info->sum[i].type; i++) {\n\t\t\t\tRBinHash *h = &info->sum[i];\n\t\t\t\tut64 hash = r_hash_name_to_bits (h->type);\n\t\t\t\tRHash *rh = r_hash_new (true, hash);\n\t\t\t\tut8 *tmp = R_NEWS (ut8, h->to);\n\t\t\t\tif (!tmp) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tr_buf_read_at (bf->buf, h->from, tmp, h->to);\n\t\t\t\tint len = r_hash_calculate (rh, hash, tmp, h->to);\n\t\t\t\tfree (tmp);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\teprintf (\"Invalid checksum length\\n\");\n\t\t\t\t}\n\t\t\t\tr_hash_free (rh);\n\t\t\t\tr_cons_printf (\"%s\\\"%s\\\":{\\\"hex\\\":\\\"\", i?\",\": \"\", h->type);\n\t\t\t\t// r_cons_printf (\"%s\\t%d-%dc\\t\", h->type, h->from, h->to+h->from);\n\t\t\t\tfor (j = 0; j < h->len; j++) {\n\t\t\t\t\tr_cons_printf (\"%02x\", h->buf[j]);\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"}\");\n\t\t\t}\n\t\t\tr_cons_printf (\"}\");\n\t\t} else {\n\t\t\tfor (i = 0; info->sum[i].type; i++) {\n\t\t\t\tRBinHash *h = &info->sum[i];\n\t\t\t\tut64 hash = r_hash_name_to_bits (h->type);\n\t\t\t\tRHash *rh = r_hash_new (true, hash);\n\t\t\t\tut8 *tmp = R_NEWS (ut8, h->to);\n\t\t\t\tif (!tmp) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tr_buf_read_at (bf->buf, h->from, tmp, h->to);\n\t\t\t\tint len = r_hash_calculate (rh, hash, tmp, h->to);\n\t\t\t\tfree (tmp);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\teprintf (\"Invalid wtf\\n\");\n\t\t\t\t}\n\t\t\t\tr_hash_free (rh);\n\t\t\t\tr_cons_printf (\"%s  %d-%dc  \", h->type, h->from, h->to+h->from);\n\t\t\t\tfor (j = 0; j < h->len; j++) {\n\t\t\t\t\tr_cons_printf (\"%02x\", h->buf[j]);\n\t\t\t\t}\n\t\t\t\tr_cons_newline ();\n\t\t\t}\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"}\");\n\t\t}\n\t}\n\tconst char *dir_prefix = r_config_get (r->config, \"dir.prefix\");\n\tchar *spath = sdb_fmt (\"%s/\"R2_SDB_FCNSIGN\"/spec.sdb\", dir_prefix);\n\tif (r_file_exists (spath)) {\n\t\tsdb_concat_by_path (r->anal->sdb_fmts, spath);\n\t}\n\treturn true;\n}\n\nstatic int bin_dwarf(RCore *core, int mode) {\n\tRBinDwarfRow *row;\n\tRListIter *iter;\n\tRList *list = NULL;\n\tif (!r_config_get_i (core->config, \"bin.dbginfo\")) {\n\t\treturn false;\n\t}\n\tRBinFile *binfile = r_bin_cur (core->bin);\n\tRBinPlugin * plugin = r_bin_file_cur_plugin (binfile);\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (plugin && plugin->lines) {\n\t\tlist = plugin->lines (binfile);\n\t} else if (core->bin) {\n\t\t// TODO: complete and speed-up support for dwarf\n\t\tRBinDwarfDebugAbbrev *da = NULL;\n\t\tda = r_bin_dwarf_parse_abbrev (core->bin, mode);\n\t\tr_bin_dwarf_parse_info (da, core->bin, mode);\n\t\tr_bin_dwarf_parse_aranges (core->bin, mode);\n\t\tlist = r_bin_dwarf_parse_line (core->bin, mode);\n\t\tr_bin_dwarf_free_debug_abbrev (da);\n\t\tfree (da);\n\t}\n\tif (!list) {\n\t\treturn false;\n\t}\n\n\tr_cons_break_push (NULL, NULL);\n\t/* cache file:line contents */\n\tconst char *lastFile = NULL;\n\tint *lastFileLines = NULL;\n\tchar *lastFileContents = NULL;\n\tint lastFileLinesCount = 0;\n\n\t/* ugly dupe for speedup */\n\tconst char *lastFile2 = NULL;\n\tint *lastFileLines2 = NULL;\n\tchar *lastFileContents2 = NULL;\n\tint lastFileLinesCount2 = 0;\n\n\tconst char *lf = NULL;\n\tint *lfl = NULL;\n\tchar *lfc = NULL;\n\tint lflc = 0;\n\n\t//TODO we should need to store all this in sdb, or do a filecontentscache in libr/util\n\t//XXX this whole thing has leaks\n\tr_list_foreach (list, iter, row) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tif (mode) {\n\t\t\t// TODO: use 'Cl' instead of CC\n\t\t\tconst char *path = row->file;\n\t\t\tif (!lastFile || strcmp (path, lastFile)) {\n\t\t\t\tif (lastFile && lastFile2 && !strcmp (path, lastFile2)) {\n\t\t\t\t\tlf = lastFile;\n\t\t\t\t\tlfl = lastFileLines;\n\t\t\t\t\tlfc = lastFileContents;\n\t\t\t\t\tlflc = lastFileLinesCount;\n\t\t\t\t\tlastFile = lastFile2;\n\t\t\t\t\tlastFileLines = lastFileLines2;\n\t\t\t\t\tlastFileContents = lastFileContents2;\n\t\t\t\t\tlastFileLinesCount = lastFileLinesCount2;\n\t\t\t\t\tlastFile2 = lf;\n\t\t\t\t\tlastFileLines2 = lfl;\n\t\t\t\t\tlastFileContents2 = lfc;\n\t\t\t\t\tlastFileLinesCount2 = lflc;\n\t\t\t\t} else {\n\t\t\t\t\tlastFile2 = lastFile;\n\t\t\t\t\tlastFileLines2 = lastFileLines;\n\t\t\t\t\tlastFileContents2 = lastFileContents;\n\t\t\t\t\tlastFileLinesCount2 = lastFileLinesCount;\n\t\t\t\t\tlastFile = path;\n\t\t\t\t\tlastFileContents = r_file_slurp (path, NULL);\n\t\t\t\t\tif (lastFileContents) {\n\t\t\t\t\t\tlastFileLines = r_str_split_lines (lastFileContents, &lastFileLinesCount);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *line = NULL;\n\t\t\t//r_file_slurp_line (path, row->line - 1, 0);\n\t\t\tif (lastFileLines && lastFileContents) {\n\t\t\t\tint nl = row->line - 1;\n\t\t\t\tif (nl >= 0 && nl < lastFileLinesCount) {\n\t\t\t\t\tline = strdup (lastFileContents + lastFileLines[nl]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tline = NULL;\n\t\t\t}\n\t\t\tif (line) {\n\t\t\t\tr_str_filter (line, strlen (line));\n\t\t\t\tline = r_str_replace (line, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\t\tline = r_str_replace (line, \"\\\\\\\\\", \"\\\\\", 1);\n\t\t\t}\n\t\t\tbool chopPath = !r_config_get_i (core->config, \"dir.dwarf.abspath\");\n\t\t\tchar *file = strdup (row->file);\n\t\t\tif (chopPath) {\n\t\t\t\tconst char *slash = r_str_lchr (file, '/');\n\t\t\t\tif (slash) {\n\t\t\t\t\tmemmove (file, slash + 1, strlen (slash));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// TODO: implement internal : if ((mode & R_MODE_SET))\n\t\t\tif ((mode & R_MODE_SET)) {\n\t\t\t\t// TODO: use CL here.. but its not necessary.. so better not do anything imho\n\t\t\t\t// r_core_cmdf (core, \"CL %s:%d 0x%08\"PFMT64x, file, (int)row->line, row->address);\n#if 0\n\t\t\t\tchar *cmt = r_str_newf (\"%s:%d %s\", file, (int)row->line, line? line: \"\");\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, row->address, cmt);\n\t\t\t\tfree (cmt);\n#endif\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"CL %s:%d 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t       file, (int)row->line,\n\t\t\t\t\t       row->address);\n\t\t\t\tr_cons_printf (\"\\\"CC %s:%d %s\\\"@0x%\" PFMT64x\n\t\t\t\t\t       \"\\n\",\n\t\t\t\t\t       file, row->line,\n\t\t\t\t\t       line ? line : \"\", row->address);\n\t\t\t}\n\t\t\tfree (file);\n\t\t\tfree (line);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\t%s\\t%d\\n\",\n\t\t\t\t       row->address, row->file, row->line);\n\t\t}\n\t}\n\tr_cons_break_pop ();\n\tR_FREE (lastFileContents);\n\tR_FREE (lastFileContents2);\n\t// this list is owned by rbin, not us, we shouldn't free it\n\t// r_list_free (list);\n\tfree (lastFileLines);\n\treturn true;\n}\n\nR_API int r_core_pdb_info(RCore *core, const char *file, ut64 baddr, int mode) {\n\tR_PDB pdb = R_EMPTY;\n\n\tpdb.cb_printf = r_cons_printf;\n\tif (!init_pdb_parser (&pdb, file)) {\n\t\treturn false;\n\t}\n\tif (!pdb.pdb_parse (&pdb)) {\n\t\teprintf (\"pdb was not parsed\\n\");\n\t\tpdb.finish_pdb_parse (&pdb);\n\t\treturn false;\n\t}\n\tif (mode == R_MODE_JSON) {\n\t\tr_cons_printf (\"[\");\n\t}\n\n\tswitch (mode) {\n\tcase R_MODE_SET:\n\t\tmode = 's';\n\t\tr_core_cmd0 (core, \".iP*\");\n\t\treturn true;\n\tcase R_MODE_JSON:\n\t\tmode = 'j';\n\t\tbreak;\n\tcase '*':\n\tcase 1:\n\t\tmode = 'r';\n\t\tbreak;\n\tdefault:\n\t\tmode = 'd'; // default\n\t\tbreak;\n\t}\n\n\tpdb.print_types (&pdb, mode);\n\tif (mode == 'j') {\n\t\tr_cons_printf (\",\");\n\t}\n\tpdb.print_gvars (&pdb, baddr, mode);\n\tif (mode == 'j') {\n\t\tr_cons_printf (\"]\");\n\t}\n\tpdb.finish_pdb_parse (&pdb);\n\n\treturn true;\n}\n\nstatic int bin_pdb(RCore *core, int mode) {\n\tut64 baddr = r_bin_get_baddr (core->bin);\n\treturn r_core_pdb_info (core, core->bin->file, baddr, mode);\n}\n\nstatic int srclineCmp(const void *a, const void *b) {\n\treturn r_str_cmp (a, b, -1);\n}\n\nstatic int bin_source(RCore *r, int mode) {\n\tRList *final_list = r_list_new ();\n\tRBinFile * binfile = r->bin->cur;\n\n\tif (!binfile) {\n\t\tbprintf (\"[Error bin file]\\n\");\n\t\tr_list_free (final_list);\n\t\treturn false;\n\t}\n\n\tSdbListIter *iter;\n\tRListIter *iter2;\n\tchar* srcline;\n\tSdbKv *kv;\n\tSdbList *ls = sdb_foreach_list (binfile->sdb_addrinfo, false);\n\tls_foreach (ls, iter, kv) {\n\t\tchar *v = sdbkv_value (kv);\n\t\tRList *list = r_str_split_list (v, \"|\", 0);\n\t\tsrcline = r_list_get_bottom (list);\n\t\tif (srcline) {\n\t\t\tif (!strstr (srcline, \"0x\")){\n\t\t\t\tr_list_append (final_list, srcline);\n\t\t\t}\n\t\t}\n\t\tr_list_free (list);\n\t}\n\tr_cons_printf (\"[Source file]\\n\");\n\tRList *uniqlist = r_list_uniq (final_list, srclineCmp);\n\tr_list_foreach (uniqlist, iter2, srcline) {\n\t\tr_cons_printf (\"%s\\n\", srcline);\n\t}\n\tr_list_free (uniqlist);\n\tr_list_free (final_list);\n\treturn true;\n}\n\nstatic int bin_main(RCore *r, int mode, int va) {\n\tRBinAddr *binmain = r_bin_get_sym (r->bin, R_BIN_SYM_MAIN);\n\tut64 addr;\n\tif (!binmain) {\n\t\treturn false;\n\t}\n\taddr = va ? r_bin_a2b (r->bin, binmain->vaddr) : binmain->paddr;\n\n\tif (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);\n\t\tr_flag_set (r->flags, \"main\", addr, r->blocksize);\n\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\tr_cons_printf (\"%\"PFMT64d, addr);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs symbols\\n\");\n\t\tr_cons_printf (\"f main @ 0x%08\"PFMT64x\"\\n\", addr);\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{\\\"vaddr\\\":%\" PFMT64d\n\t\t\t\",\\\"paddr\\\":%\" PFMT64d \"}\", addr, binmain->paddr);\n\t} else {\n\t\tr_cons_printf (\"[Main]\\n\");\n\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\"\\n\",\n\t\t\taddr, binmain->paddr);\n\t}\n\treturn true;\n}\n\nstatic inline bool is_initfini(RBinAddr *entry) {\n\tswitch (entry->type) {\n\tcase R_BIN_ENTRY_TYPE_INIT:\n\tcase R_BIN_ENTRY_TYPE_FINI:\n\tcase R_BIN_ENTRY_TYPE_PREINIT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int bin_entry(RCore *r, int mode, ut64 laddr, int va, bool inifin) {\n\tchar str[R_FLAG_NAME_SIZE];\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRListIter *iter;\n\tRListIter *last_processed = NULL;\n\tRBinAddr *entry = NULL;\n\tint i = 0, init_i = 0, fini_i = 0, preinit_i = 0;\n\tut64 baddr = r_bin_get_baddr (r->bin);\n\n\tif (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs symbols\\n\");\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tif (inifin) {\n\t\t\tr_cons_printf (\"[Constructors]\\n\");\n\t\t} else {\n\t\t\tr_cons_printf (\"[Entrypoints]\\n\");\n\t\t}\n\t}\n\n\tr_list_foreach (entries, iter, entry) {\n\t\tut64 paddr = entry->paddr;\n\t\tut64 hpaddr = UT64_MAX;\n\t\tut64 hvaddr = UT64_MAX;\n\t\tif (mode != R_MODE_SET) {\n\t\t\tif (inifin) {\n\t\t\t\tif (entry->type == R_BIN_ENTRY_TYPE_PROGRAM) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (entry->type != R_BIN_ENTRY_TYPE_PROGRAM) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (entry->hpaddr) {\n\t\t\thpaddr = entry->hpaddr;\n\t\t\tif (entry->hvaddr) {\n\t\t\t\thvaddr = rva (r->bin, hpaddr, entry->hvaddr, va);\n\t\t\t}\n\t\t}\n\t\tut64 at = rva (r->bin, paddr, entry->vaddr, va);\n\t\tconst char *type = r_bin_entry_type_string (entry->type);\n\t\tif (!type) {\n\t\t\ttype = \"unknown\";\n\t\t}\n\t\tconst char *hpaddr_key = (entry->type == R_BIN_ENTRY_TYPE_PROGRAM)\n\t\t                ? \"haddr\" : \"hpaddr\";\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tr_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);\n\t\t\tif (entry->type == R_BIN_ENTRY_TYPE_INIT) {\n\t\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"entry.init%i\", init_i);\n\t\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_FINI) {\n\t\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"entry.fini%i\", fini_i);\n\t\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_PREINIT) {\n\t\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"entry.preinit%i\", preinit_i);\n\t\t\t} else {\n\t\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"entry%i\", i);\n\t\t\t}\n\t\t\tr_flag_set (r->flags, str, at, 1);\n\t\t\tif (is_initfini (entry) && hvaddr != UT64_MAX) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_DATA, hvaddr,\n\t\t\t\t            hvaddr + entry->bits / 8, NULL);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", at);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"%s{\\\"vaddr\\\":%\" PFMT64u \",\"\n\t\t\t\t\"\\\"paddr\\\":%\" PFMT64u \",\"\n\t\t\t\t\"\\\"baddr\\\":%\" PFMT64u \",\"\n\t\t\t\t\"\\\"laddr\\\":%\" PFMT64u \",\",\n\t\t\t\tlast_processed ? \",\" : \"\", at, paddr, baddr, laddr);\n\t\t\tif (hvaddr != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"hvaddr\\\":%\" PFMT64u \",\", hvaddr);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"%s\\\":%\" PFMT64u \",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\"}\",\n\t\t\t\thpaddr_key, hpaddr, type);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tchar *name = NULL;\n\t\t\tif (entry->type == R_BIN_ENTRY_TYPE_INIT) {\n\t\t\t\tname = r_str_newf (\"entry.init%i\", init_i);\n\t\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_FINI) {\n\t\t\t\tname = r_str_newf (\"entry.fini%i\", fini_i);\n\t\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_PREINIT) {\n\t\t\t\tname = r_str_newf (\"entry.preinit%i\", preinit_i);\n\t\t\t} else {\n\t\t\t\tname = r_str_newf (\"entry%i\", i);\n\t\t\t}\n\t\t\tchar *n = __filterQuotedShell (name);\n\t\t\tr_cons_printf (\"\\\"f %s 1 0x%08\"PFMT64x\"\\\"\\n\", n, at);\n\t\t\tr_cons_printf (\"\\\"f %s_%s 1 0x%08\"PFMT64x\"\\\"\\n\", n, hpaddr_key, hpaddr);\n\t\t\tr_cons_printf (\"\\\"s %s\\\"\\n\", n);\n\t\t\tfree (n);\n\t\t\tfree (name);\n\t\t} else {\n\t\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x, at, paddr);\n\t\t\tif (is_initfini (entry) && hvaddr != UT64_MAX) {\n\t\t\t\tr_cons_printf (\" hvaddr=0x%08\"PFMT64x, hvaddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" %s=\", hpaddr_key);\n\t\t\tif (hpaddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\"%\"PFMT64d, hpaddr);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x, hpaddr);\n\t\t\t}\n\t\t\tif (entry->type == R_BIN_ENTRY_TYPE_PROGRAM && hvaddr != UT64_MAX) {\n\t\t\t\tr_cons_printf (\" hvaddr=0x%08\"PFMT64x, hvaddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" type=%s\\n\", type);\n\t\t}\n\t\tif (entry->type == R_BIN_ENTRY_TYPE_INIT) {\n\t\t\tinit_i++;\n\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_FINI) {\n\t\t\tfini_i++;\n\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_PREINIT) {\n\t\t\tpreinit_i++;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t\tlast_processed = iter;\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tif (entry) {\n\t\t\tut64 at = rva (r->bin, entry->paddr, entry->vaddr, va);\n\t\t\tr_core_seek (r, at, 0);\n\t\t}\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t\tr_cons_newline ();\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i entrypoints\\n\", init_i + fini_i + preinit_i + i);\n\t}\n\treturn true;\n}\n\nstatic const char *bin_reloc_type_name(RBinReloc *reloc) {\n#define CASE(T) case R_BIN_RELOC_ ## T: return reloc->additive ? \"ADD_\" #T : \"SET_\" #T\n\tswitch (reloc->type) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t}\n\treturn \"UNKNOWN\";\n#undef CASE\n}\n\nstatic ut8 bin_reloc_size(RBinReloc *reloc) {\n#define CASE(T) case R_BIN_RELOC_ ## T: return (T) / 8\n\tswitch (reloc->type) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t}\n\treturn 0;\n#undef CASE\n}\n\nstatic char *resolveModuleOrdinal(Sdb *sdb, const char *module, int ordinal) {\n\tSdb *db = sdb;\n\tchar *foo = sdb_get (db, sdb_fmt (\"%d\", ordinal), 0);\n\treturn (foo && *foo) ? foo : NULL;\n}\n\nstatic char *get_reloc_name(RCore *r, RBinReloc *reloc, ut64 addr) {\n\tchar *reloc_name = NULL;\n\tchar *demangled_name = NULL;\n\tconst char *lang = r_config_get (r->config, \"bin.lang\");\n\tint bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tbool keep_lib = r_config_get_i (r->config, \"bin.demangle.libs\");\n\tif (reloc->import && reloc->import->name) {\n\t\tif (bin_demangle) {\n\t\t\tdemangled_name = r_bin_demangle (r->bin->cur, lang, reloc->import->name, addr, keep_lib);\n\t\t}\n\t\treloc_name = sdb_fmt (\"reloc.%s_%d\", demangled_name ? demangled_name : reloc->import->name,\n\t\t\t\t      (int)(addr & 0xff));\n\t\tif (!reloc_name) {\n\t\t\tfree (demangled_name);\n\t\t\treturn NULL;\n\t\t}\n\t\tr_str_replace_char (reloc_name, '$', '_');\n\t} else if (reloc->symbol && reloc->symbol->name) {\n\t\tif (bin_demangle) {\n\t\t\tdemangled_name = r_bin_demangle (r->bin->cur, lang, reloc->symbol->name, addr, keep_lib);\n\t\t}\n\t\treloc_name = sdb_fmt (\"reloc.%s_%d\", demangled_name ? demangled_name : reloc->symbol->name,\n\t\t\t\t      (int)(addr & 0xff));\n\t\tif (!reloc_name) {\n\t\t\tfree (demangled_name);\n\t\t\treturn NULL;\n\t\t}\n\t\tr_str_replace_char (reloc_name, '$', '_');\n\t} else if (reloc->is_ifunc) {\n\t\t// addend is the function pointer for the resolving ifunc\n\t\treloc_name = sdb_fmt (\"reloc.ifunc_%\"PFMT64x, reloc->addend);\n\t} else {\n\t\t// TODO(eddyb) implement constant relocs.\n\t}\n\tfree (demangled_name);\n\treturn reloc_name;\n}\n\nstatic void set_bin_relocs(RCore *r, RBinReloc *reloc, ut64 addr, Sdb **db, char **sdb_module) {\n\tint bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tbool keep_lib = r_config_get_i (r->config, \"bin.demangle.libs\");\n\tconst char *lang = r_config_get (r->config, \"bin.lang\");\n\tchar *reloc_name, *demname = NULL;\n\tbool is_pe = true;\n\tint is_sandbox = r_sandbox_enable (0);\n\n\tif (reloc->import && reloc->import->name[0]) {\n\t\tchar str[R_FLAG_NAME_SIZE];\n\t\tRFlagItem *fi;\n\n\t\tif (is_pe && !is_sandbox && strstr (reloc->import->name, \"Ordinal\")) {\n\t\t\tconst char *TOKEN = \".dll_Ordinal_\";\n\t\t\tchar *module = strdup (reloc->import->name);\n\t\t\tchar *import = strstr (module, TOKEN);\n\n\t\t\tr_str_case (module, false);\n\t\t\tif (import) {\n\t\t\t\tchar *filename = NULL;\n\t\t\t\tint ordinal;\n\t\t\t\t*import = 0;\n\t\t\t\timport += strlen (TOKEN);\n\t\t\t\tordinal = atoi (import);\n\t\t\t\tif (!*sdb_module || strcmp (module, *sdb_module)) {\n\t\t\t\t\tsdb_free (*db);\n\t\t\t\t\t*db = NULL;\n\t\t\t\t\tfree (*sdb_module);\n\t\t\t\t\t*sdb_module = strdup (module);\n\t\t\t\t\t/* always lowercase */\n\t\t\t\t\tfilename = sdb_fmt (\"%s.sdb\", module);\n\t\t\t\t\tr_str_case (filename, false);\n\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t*db = sdb_new (NULL, filename, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst char *dirPrefix = r_sys_prefix (NULL);\n\t\t\t\t\t\tfilename = sdb_fmt (R_JOIN_4_PATHS (\"%s\", R2_SDB_FORMAT, \"dll\", \"%s.sdb\"),\n\t\t\t\t\t\t\tdirPrefix, module);\n\t\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t\t*db = sdb_new (NULL, filename, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*db) {\n\t\t\t\t\t// ordinal-1 because we enumerate starting at 0\n\t\t\t\t\tchar *symname = resolveModuleOrdinal (*db, module, ordinal - 1);  // uses sdb_get\n\t\t\t\t\tif (symname) {\n\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\treloc->import->name = r_str_newf\n\t\t\t\t\t\t\t\t(\"%s.%s.%s\", r->bin->prefix, module, symname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treloc->import->name = r_str_newf\n\t\t\t\t\t\t\t\t(\"%s.%s\", module, symname);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tR_FREE (symname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (module);\n\t\t\tr_anal_hint_set_size (r->anal, reloc->vaddr, 4);\n\t\t\tr_meta_add (r->anal, R_META_TYPE_DATA, reloc->vaddr, reloc->vaddr+4, NULL);\n\t\t}\n\t\treloc_name = reloc->import->name;\n\t\tif (r->bin->prefix) {\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"%s.reloc.%s\", r->bin->prefix, reloc_name);\n\t\t} else {\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"reloc.%s\", reloc_name);\n\t\t}\n\t\tif (bin_demangle) {\n\t\t\tdemname = r_bin_demangle (r->bin->cur, lang, str, addr, keep_lib);\n\t\t\tif (demname) {\n\t\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"reloc.%s\", demname);\n\t\t\t}\n\t\t}\n\t\tr_name_filter (str, 0);\n\t\tfi = r_flag_set (r->flags, str, addr, bin_reloc_size (reloc));\n\t\tif (demname) {\n\t\t\tchar *realname;\n\t\t\tif (r->bin->prefix) {\n\t\t\t\trealname = sdb_fmt (\"%s.reloc.%s\", r->bin->prefix, demname);\n\t\t\t} else {\n\t\t\t\trealname = sdb_fmt (\"reloc.%s\", demname);\n\t\t\t}\n\t\t\tr_flag_item_set_realname (fi, realname);\n\t\t}\n\t} else {\n\t\tchar *reloc_name = get_reloc_name (r, reloc, addr);\n\t\tif (reloc_name) {\n\t\t\tr_flag_set (r->flags, reloc_name, addr, bin_reloc_size (reloc));\n\t\t} else {\n\t\t\t// eprintf (\"Cannot find a name for 0x%08\"PFMT64x\"\\n\", addr);\n\t\t}\n\t}\n}\n\n/* Define new data at relocation address if it's not in an executable section */\nstatic void add_metadata(RCore *r, RBinReloc *reloc, ut64 addr, int mode) {\n\tRBinFile * binfile = r->bin->cur;\n\tRBinObject *binobj = binfile ? binfile->o: NULL;\n\tRBinInfo *info = binobj ? binobj->info: NULL;\n\n\tint cdsz = info? (info->bits == 64? 8: info->bits == 32? 4: info->bits == 16 ? 4: 0): 0;\n\tif (cdsz == 0) {\n\t\treturn;\n\t}\n\n\tRIOMap *map = r_io_map_get (r->io, addr);\n\tif (!map || map ->perm & R_PERM_X) {\n\t\treturn;\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tr_meta_add (r->anal, R_META_TYPE_DATA, reloc->vaddr, reloc->vaddr + cdsz, NULL);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"Cd %d @ 0x%08\" PFMT64x \"\\n\", cdsz, addr);\n\t}\n}\n\nstatic bool is_section_symbol(RBinSymbol *s) {\n\t/* workaround for some bin plugs (e.g. ELF) */\n\tif (!s || *s->name) {\n\t\treturn false;\n\t}\n\treturn (s->type && !strcmp (s->type, R_BIN_TYPE_SECTION_STR));\n}\n\nstatic bool is_special_symbol(RBinSymbol *s) {\n\treturn s->type && !strcmp (s->type, R_BIN_TYPE_SPECIAL_SYM_STR);\n}\n\nstatic bool is_section_reloc(RBinReloc *r) {\n\treturn is_section_symbol (r->symbol);\n}\n\nstatic bool is_file_symbol(RBinSymbol *s) {\n\t/* workaround for some bin plugs (e.g. ELF) */\n\treturn (s && s->type && !strcmp (s->type, R_BIN_TYPE_FILE_STR));\n}\n\nstatic bool is_file_reloc(RBinReloc *r) {\n\treturn is_file_symbol (r->symbol);\n}\n\nstatic int bin_relocs(RCore *r, int mode, int va) {\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tbool keep_lib = r_config_get_i (r->config, \"bin.demangle.libs\");\n\tconst char *lang = r_config_get (r->config, \"bin.lang\");\n\tRBIter iter;\n\tRBinReloc *reloc = NULL;\n\tSdb *db = NULL;\n\tPJ *pj = NULL;\n\tchar *sdb_module = NULL;\n\tint i = 0;\n\n\tR_TIME_BEGIN;\n\n\tva = VA_TRUE; // XXX relocs always vaddr?\n\t//this has been created for reloc object files\n\tRBNode *relocs = r_bin_patch_relocs (r->bin);\n\tif (!relocs) {\n\t\trelocs = r_bin_get_relocs (r->bin);\n\t}\n\n\tif (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs relocs\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Relocations]\");\n\t} else if (IS_MODE_JSON (mode)) {\n\t\t// start a new JSON object\n\t\tpj = pj_new ();\n\t\tif (pj) {\n\t\t\tpj_a (pj);\n\t\t}\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_RELOCS);\n\t}\n\n\tr_rbtree_foreach (relocs, iter, reloc, RBinReloc, vrb) {\n\t\tut64 addr = rva (r->bin, reloc->paddr, reloc->vaddr, va);\n\t\tif (IS_MODE_SET (mode) && (is_section_reloc (reloc) || is_file_reloc (reloc))) {\n\t\t\t/*\n\t\t\t * Skip section reloc because they will have their own flag.\n\t\t\t * Skip also file reloc because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\tset_bin_relocs (r, reloc, addr, &db, &sdb_module);\n\t\t\tadd_metadata (r, reloc, addr, mode);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %s\\n\", addr, reloc->import ? reloc->import->name : \"\");\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tchar *name = reloc->import\n\t\t\t\t? strdup (reloc->import->name)\n\t\t\t\t: (reloc->symbol ? strdup (reloc->symbol->name) : NULL);\n\t\t\tif (name && bin_demangle) {\n\t\t\t\tchar *mn = r_bin_demangle (r->bin->cur, NULL, name, addr, keep_lib);\n\t\t\t\tif (mn) {\n\t\t\t\t\tfree (name);\n\t\t\t\t\tname = mn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (name) {\n\t\t\t\tint reloc_size = 4;\n\t\t\t\tchar *n = __filterQuotedShell (name);\n\t\t\t\tr_cons_printf (\"\\\"f %s%s%s %d 0x%08\"PFMT64x\"\\\"\\n\",\n\t\t\t\t\tr->bin->prefix ? r->bin->prefix : \"reloc.\",\n\t\t\t\t\tr->bin->prefix ? \".\" : \"\", n, reloc_size, addr);\n\t\t\t\tadd_metadata (r, reloc, addr, mode);\n\t\t\t\tfree (n);\n\t\t\t\tfree (name);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tif (pj) {\n\t\t\t\tpj_o (pj);\n\t\t\t\tchar *mn = NULL;\n\t\t\t\tchar *relname = NULL;\n\n\t\t\t\t// take care with very long symbol names! do not use sdb_fmt or similar\n\t\t\t\tif (reloc->import) {\n\t\t\t\t\tmn = r_bin_demangle (r->bin->cur, lang, reloc->import->name, addr, keep_lib);\n\t\t\t\t\trelname = strdup (reloc->import->name);\n\t\t\t\t} else if (reloc->symbol) {\n\t\t\t\t\tmn = r_bin_demangle (r->bin->cur, lang, reloc->symbol->name, addr, keep_lib);\n\t\t\t\t\trelname = strdup (reloc->symbol->name);\n\t\t\t\t}\n\n\t\t\t\t// check if name is available\n\t\t\t\tpj_ks (pj, \"name\", (relname && strcmp (relname, \"\")) ? relname : \"N/A\");\n\t\t\t\tpj_ks (pj, \"demname\", mn ? mn : \"\");\n\t\t\t\tpj_ks (pj, \"type\", bin_reloc_type_name (reloc));\n\t\t\t\tpj_kn (pj, \"vaddr\", reloc->vaddr);\n\t\t\t\tpj_kn (pj, \"paddr\", reloc->paddr);\n\t\t\t\tif (reloc->symbol) {\n\t\t\t\t\tpj_kn (pj, \"sym_va\", reloc->symbol->vaddr);\n\t\t\t\t}\n\t\t\t\tpj_kb (pj, \"is_ifunc\", reloc->is_ifunc);\n\t\t\t\t// end reloc item\n\t\t\t\tpj_end (pj);\n\n\t\t\t\tfree (mn);\n\t\t\t\tif (relname) {\n\t\t\t\t\tfree (relname);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tchar *name = reloc->import\n\t\t\t\t? strdup (reloc->import->name)\n\t\t\t\t: reloc->symbol\n\t\t\t\t? strdup (reloc->symbol->name)\n\t\t\t\t: strdup (\"null\");\n\t\t\tif (bin_demangle) {\n\t\t\t\tchar *mn = r_bin_demangle (r->bin->cur, NULL, name, addr, keep_lib);\n\t\t\t\tif (mn && *mn) {\n\t\t\t\t\tfree (name);\n\t\t\t\t\tname = mn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\" type=%s\",\n\t\t\t\taddr, reloc->paddr, bin_reloc_type_name (reloc));\n\t\t\tif (reloc->import && reloc->import->name[0]) {\n\t\t\t\tr_cons_printf (\" %s\", name);\n\t\t\t} else if (reloc->symbol && name && name[0]) {\n\t\t\t\tr_cons_printf (\" %s\", name);\n\t\t\t}\n\t\t\tR_FREE (name);\n\t\t\tif (reloc->addend) {\n\t\t\t\tif ((reloc->import || (reloc->symbol && !R_STR_ISEMPTY (name))) && reloc->addend > 0) {\n\t\t\t\t\tr_cons_printf (\" +\");\n\t\t\t\t}\n\t\t\t\tif (reloc->addend < 0) {\n\t\t\t\t\tr_cons_printf (\" - 0x%08\"PFMT64x, -reloc->addend);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, reloc->addend);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (reloc->is_ifunc) {\n\t\t\t\tr_cons_print (\" (ifunc)\");\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\t// close Json output\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i relocations\\n\", i);\n\t}\n\n\t// free PJ object if used\n\tif (pj) {\n\t\tpj_free (pj);\n\t}\n\tR_FREE (sdb_module);\n\tsdb_free (db);\n\tdb = NULL;\n\n\tR_TIME_END;\n\treturn relocs != NULL;\n}\n\n#define MYDB 1\n/* this is a hacky workaround that needs proper refactoring in Rbin to use Sdb */\n#if MYDB\nstatic Sdb *mydb = NULL;\nstatic RList *osymbols = NULL;\n\nstatic RBinSymbol *get_symbol(RBin *bin, RList *symbols, const char *name, ut64 addr) {\n\tRBinSymbol *symbol, *res = NULL;\n\tRListIter *iter;\n\tif (mydb && symbols && symbols != osymbols) {\n\t\tsdb_free (mydb);\n\t\tmydb = NULL;\n\t\tosymbols = symbols;\n\t}\n\tif (mydb) {\n\t\tif (name) {\n\t\t\tres = (RBinSymbol*)(void*)(size_t)\n\t\t\t\tsdb_num_get (mydb, sdb_fmt (\"%x\", sdb_hash (name)), NULL);\n\t\t} else {\n\t\t\tres = (RBinSymbol*)(void*)(size_t)\n\t\t\t\tsdb_num_get (mydb, sdb_fmt (\"0x\"PFMT64x, addr), NULL);\n\t\t}\n\t} else {\n\t\tmydb = sdb_new0 ();\n\t\tr_list_foreach (symbols, iter, symbol) {\n\t\t\tif (!symbol->name) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* ${name}=${ptrToSymbol} */\n\t\t\tif (!sdb_num_add (mydb, sdb_fmt (\"%x\", sdb_hash (symbol->name)), (ut64)(size_t)symbol, 0)) {\n\t\t\t//\teprintf (\"DUP (%s)\\n\", symbol->name);\n\t\t\t}\n\t\t\t/* 0x${vaddr}=${ptrToSymbol} */\n\t\t\tif (!sdb_num_add (mydb, sdb_fmt (\"0x\"PFMT64x, symbol->vaddr), (ut64)(size_t)symbol, 0)) {\n\t\t\t//\teprintf (\"DUP (%s)\\n\", symbol->name);\n\t\t\t}\n\t\t\tif (name) {\n\t\t\t\tif (!res && !strcmp (symbol->name, name)) {\n\t\t\t\t\tres = symbol;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (symbol->vaddr == addr) {\n\t\t\t\t\tres = symbol;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tosymbols = symbols;\n\t}\n\treturn res;\n}\n#else\nstatic RList *osymbols = NULL;\nstatic RBinSymbol *get_symbol(RBin *bin, RList *symbols, const char *name, ut64 addr) {\n\tRBinSymbol *symbol;\n\tRListIter *iter;\n\t// XXX this is slow, we should use a hashtable here\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (name) {\n\t\t\tif (!strcmp (symbol->name, name))\n\t\t\t\treturn symbol;\n\t\t} else {\n\t\t\tif (symbol->vaddr == addr) {\n\t\t\t\treturn symbol;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n#endif\n\n/* XXX: This is a hack to get PLT references in rabin2 -i */\n/* imp. is a prefix that can be rewritten by the symbol table */\nR_API ut64 r_core_bin_impaddr(RBin *bin, int va, const char *name) {\n\tRList *symbols;\n\n\tif (!name || !*name) {\n\t\treturn false;\n\t}\n\tif (!(symbols = r_bin_get_symbols (bin))) {\n\t\treturn false;\n\t}\n\tchar *impname = r_str_newf (\"imp.%s\", name);\n\tRBinSymbol *s = get_symbol (bin, symbols, impname, 0LL);\n\t// maybe ut64_MAX to indicate import not found?\n\tut64 addr = 0LL;\n\tif (s) {\n\t\tif (va) {\n\t\t\tif (s->paddr == UT64_MAX) {\n\t\t\t\taddr = s->vaddr;\n\t\t\t} else {\n\t\t\t\taddr = r_bin_get_vaddr (bin, s->paddr, s->vaddr);\n\t\t\t}\n\t\t} else {\n\t\t\taddr = s->paddr;\n\t\t}\n\t}\n\tfree (impname);\n\treturn addr;\n}\n\nstatic int bin_imports(RCore *r, int mode, int va, const char *name) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tint bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tbool keep_lib = r_config_get_i (r->config, \"bin.demangle.libs\");\n\tRBinImport *import;\n\tRListIter *iter;\n\tbool lit = info ? info->has_lit: false;\n\tchar *str;\n\tint i = 0;\n\n\tif (!info) {\n\t\treturn false;\n\t}\n\n\tRList *imports = r_bin_get_imports (r->bin);\n\tint cdsz = info? (info->bits == 64? 8: info->bits == 32? 4: info->bits == 16 ? 4: 0): 0;\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs imports\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Imports]\");\n\t\tr_cons_println (\"Num  Vaddr       Bind      Type Name\");\n\t}\n\tr_list_foreach (imports, iter, import) {\n\t\tif (name && strcmp (import->name, name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *symname = strdup (import->name);\n\t\tut64 addr = lit ? r_core_bin_impaddr (r->bin, va, symname): 0;\n\t\tif (bin_demangle) {\n\t\t\tchar *dname = r_bin_demangle (r->bin->cur, NULL, symname, addr, keep_lib);\n\t\t\tif (dname) {\n\t\t\t\tfree (symname);\n\t\t\t\tsymname = r_str_newf (\"sym.imp.%s\", dname);\n\t\t\t\tfree (dname);\n\t\t\t}\n\t\t}\n\t\tif (r->bin->prefix) {\n\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, symname);\n\t\t\tfree (symname);\n\t\t\tsymname = prname;\n\t\t}\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\t// TODO(eddyb) symbols that are imports.\n\t\t\t// Add a dword/qword for PE imports\n\t\t\tif (strstr (symname, \".dll_\") && cdsz) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_DATA, addr, addr + cdsz, NULL);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLE (mode) || IS_MODE_SIMPLEST (mode)) {\n\t\t\tr_cons_println (symname);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tstr = r_str_escape_utf8_for_json (symname, -1);\n\t\t\tstr = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\",\n\t\t\t\titer->p ? \",\" : \"\",\n\t\t\t\timport->ordinal,\n\t\t\t\timport->bind,\n\t\t\t\timport->type);\n\t\t\tif (import->classname && import->classname[0]) {\n\t\t\t\tr_cons_printf (\"\\\"classname\\\":\\\"%s\\\",\"\n\t\t\t\t\t\"\\\"descriptor\\\":\\\"%s\\\",\",\n\t\t\t\t\timport->classname,\n\t\t\t\t\timport->descriptor);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"name\\\":\\\"%s\\\",\\\"plt\\\":%\"PFMT64d\"}\",\n\t\t\t\tstr, addr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t// TODO(eddyb) symbols that are imports.\n\t\t} else {\n\t\t\tconst char *bind = r_str_get (import->bind);\n\t\t\tconst char *type = r_str_get (import->type);\n#if 0\n\t\t\tr_cons_printf (\"ordinal=%03d plt=0x%08\"PFMT64x\" bind=%s type=%s\",\n\t\t\t\timport->ordinal, addr, bind, type);\n\t\t\tif (import->classname && import->classname[0]) {\n\t\t\t\tr_cons_printf (\" classname=%s\", import->classname);\n\t\t\t}\n\t\t\tr_cons_printf (\" name=%s\", symname);\n\t\t\tif (import->descriptor && import->descriptor[0]) {\n\t\t\t\tr_cons_printf (\" descriptor=%s\", import->descriptor);\n\t\t\t}\n\t\t\tr_cons_newline ();\n#else\n\t\t\tr_cons_printf (\"%4d 0x%08\"PFMT64x\" %7s %7s \",\n\t\t\t\timport->ordinal, addr, bind, type);\n\t\t\tif (import->classname && import->classname[0]) {\n\t\t\t\tr_cons_printf (\"%s.\", import->classname);\n\t\t\t}\n\t\t\tr_cons_printf (\"%s\", symname);\n\t\t\tif (import->descriptor && import->descriptor[0]) {\n\t\t\t\t// Uh?\n\t\t\t\tr_cons_printf (\" descriptor=%s\", import->descriptor);\n\t\t\t}\n\t\t\tr_cons_newline ();\n#endif\n\t\t}\n\t\tR_FREE (symname);\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t// r_cons_printf (\"# %i imports\\n\", i);\n\t}\n#if MYDB\n\t// NOTE: if we comment out this, it will leak.. but it will be faster\n\t// because it will keep the cache across multiple RBin calls\n\tosymbols = NULL;\n\tsdb_free (mydb);\n\tmydb = NULL;\n#endif\n\treturn true;\n}\n\nstatic const char *getPrefixFor(const char *s) {\n\tif (s) {\n\t\t// workaround for ELF\n\t\tif (!strcmp (s, R_BIN_TYPE_NOTYPE_STR)) {\n\t\t\treturn \"loc\";\n\t\t}\n\t\tif (!strcmp (s, R_BIN_TYPE_OBJECT_STR)) {\n\t\t\treturn \"obj\";\n\t\t}\n\t}\n\treturn \"sym\";\n}\n\n#define MAXFLAG_LEN_DEFAULT 128\n\nstatic char *construct_symbol_flagname(const char *pfx, const char *symname, int len) {\n\tchar *r = r_str_newf (\"%s.%s\", pfx, symname);\n\tif (r) {\n\t\tr_name_filter (r, len); // maybe unnecessary..\n\t\tchar *R = __filterQuotedShell (r);\n\t\tfree (r);\n\t\treturn R;\n\t}\n\treturn NULL;\n}\n\ntypedef struct {\n\tconst char *pfx; // prefix for flags\n\tchar *name;      // raw symbol name\n\tchar *nameflag;  // flag name for symbol\n\tchar *demname;   // demangled raw symbol name\n\tchar *demflag;   // flag name for demangled symbol\n\tchar *classname; // classname\n\tchar *classflag; // flag for classname\n\tchar *methname;  // methods [class]::[method]\n\tchar *methflag;  // methods flag sym.[class].[method]\n} SymName;\n\nstatic void snInit(RCore *r, SymName *sn, RBinSymbol *sym, const char *lang) {\n\tint bin_demangle = lang != NULL;\n\tbool keep_lib = r_config_get_i (r->config, \"bin.demangle.libs\");\n\tif (!r || !sym || !sym->name) {\n\t\treturn;\n\t}\n\tsn->name = strdup (sym->name);\n\tconst char *pfx = getPrefixFor (sym->type);\n\tsn->nameflag = construct_symbol_flagname (pfx, r_bin_symbol_name (sym), MAXFLAG_LEN_DEFAULT);\n\tif (sym->classname && sym->classname[0]) {\n\t\tsn->classname = strdup (sym->classname);\n\t\tsn->classflag = r_str_newf (\"sym.%s.%s\", sn->classname, sn->name);\n\t\tr_name_filter (sn->classflag, MAXFLAG_LEN_DEFAULT);\n\t\tconst char *name = sym->dname? sym->dname: sym->name;\n\t\tsn->methname = r_str_newf (\"%s::%s\", sn->classname, name);\n\t\tsn->methflag = r_str_newf (\"sym.%s.%s\", sn->classname, name);\n\t\tr_name_filter (sn->methflag, strlen (sn->methflag));\n\t} else {\n\t\tsn->classname = NULL;\n\t\tsn->classflag = NULL;\n\t\tsn->methname = NULL;\n\t\tsn->methflag = NULL;\n\t}\n\tsn->demname = NULL;\n\tsn->demflag = NULL;\n\tif (bin_demangle && sym->paddr) {\n\t\tsn->demname = r_bin_demangle (r->bin->cur, lang, sn->name, sym->vaddr, keep_lib);\n\t\tif (sn->demname) {\n\t\t\tsn->demflag = construct_symbol_flagname (pfx, sn->demname, -1);\n\t\t}\n\t}\n}\n\nstatic void snFini(SymName *sn) {\n\tR_FREE (sn->name);\n\tR_FREE (sn->nameflag);\n\tR_FREE (sn->demname);\n\tR_FREE (sn->demflag);\n\tR_FREE (sn->classname);\n\tR_FREE (sn->classflag);\n\tR_FREE (sn->methname);\n\tR_FREE (sn->methflag);\n}\n\nstatic bool isAnExport(RBinSymbol *s) {\n\t/* workaround for some bin plugs */\n\tif (!strncmp (s->name, \"imp.\", 4)) {\n\t\treturn false;\n\t}\n\treturn (s->bind && !strcmp (s->bind, R_BIN_BIND_GLOBAL_STR));\n}\n\nstatic ut64 compute_addr(RBin *bin, ut64 paddr, ut64 vaddr, int va) {\n\treturn paddr == UT64_MAX? vaddr: rva (bin, paddr, vaddr, va);\n}\n\nstatic void handle_arm_special_symbol(RCore *core, RBinSymbol *symbol, int va) {\n\tut64 addr = compute_addr (core->bin, symbol->paddr, symbol->vaddr, va);\n\tif (!strcmp (symbol->name, \"$a\")) {\n\t\tr_anal_hint_set_bits (core->anal, addr, 32);\n\t} else if (!strcmp (symbol->name, \"$t\")) {\n\t\tr_anal_hint_set_bits (core->anal, addr, 16);\n\t} else if (!strcmp (symbol->name, \"$d\")) {\n\t\t// TODO: we could add data meta type at addr, but sometimes $d\n\t\t// is in the middle of the code and it would make the code less\n\t\t// readable.\n\t} else {\n\t\tR_LOG_WARN (\"Special symbol %s not handled\\n\", symbol->name);\n\t}\n}\n\nstatic void handle_arm_hint(RCore *core, RBinInfo *info, ut64 paddr, ut64 vaddr, int bits, int va) {\n\tif (info->bits > 32) { // we look at 16 or 32 bit only\n\t\treturn;\n\t}\n\n\tint force_bits = 0;\n\tut64 addr = compute_addr (core->bin, paddr, vaddr, va);\n\tif (paddr & 1 || bits == 16) {\n\t\tforce_bits = 16;\n\t} else if (info->bits == 16 && bits == 32) {\n\t\tforce_bits = 32;\n\t} else if (!(paddr & 1) && bits == 32) {\n\t\tforce_bits = 32;\n\t}\n\tif (force_bits) {\n\t\tr_anal_hint_set_bits (core->anal, addr, force_bits);\n\t}\n}\n\nstatic void handle_arm_symbol(RCore *core, RBinSymbol *symbol, RBinInfo *info, int va) {\n\treturn handle_arm_hint (core, info, symbol->paddr, symbol->vaddr, symbol->bits, va);\n}\n\nstatic void handle_arm_entry(RCore *core, RBinAddr *entry, RBinInfo *info, int va) {\n\treturn handle_arm_hint (core, info, entry->paddr, entry->vaddr, entry->bits, va);\n}\n\nstatic void select_flag_space(RCore *core, RBinSymbol *symbol) {\n\tif (!strncmp (symbol->name, \"imp.\", 4)) {\n\t\tr_flag_space_push (core->flags, R_FLAGS_FS_IMPORTS);\n\t} else if (symbol->type && !strcmp (symbol->type, R_BIN_TYPE_SECTION_STR)) {\n\t\tr_flag_space_push (core->flags, R_FLAGS_FS_SYMBOLS_SECTIONS);\n\t} else {\n\t\tr_flag_space_push (core->flags, R_FLAGS_FS_SYMBOLS);\n\t}\n}\n\nstatic int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRBinSymbol *symbol;\n\tRBinAddr *entry;\n\tRListIter *iter;\n\tbool firstexp = true;\n\tbool printHere = false;\n\tint i = 0, lastfs = 's';\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tif (!info) {\n\t\treturn 0;\n\t}\n\n\tif (args && *args == '.') {\n\t\tprintHere = true;\n\t}\n\n\tbool is_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);\n\tconst char *lang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;\n\n\tRList *symbols = r_bin_get_symbols (r->bin);\n\tr_spaces_push (&r->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);\n\t} else if (!at && exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Exports]\\n\");\n\t\t}\n\t} else if (!at && !exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Symbols]\\n\");\n\t\t}\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"Num Paddr      Vaddr      Bind     Type Size Name\\n\");\n\t}\n\n\n\tsize_t count = 0;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (!symbol->name) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true);\n\t\tut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va);\n\t\tint len = symbol->size ? symbol->size : 32;\n\t\tSymName sn = {0};\n\n\t\tif (exponly && !isAnExport (symbol)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (name && strcmp (r_symbol_name, name)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((printHere && !is_in_range (r->offset, symbol->paddr, len))\n\t\t\t\t&& (printHere && !is_in_range (r->offset, addr, len))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tcount ++;\n\t\tsnInit (r, &sn, symbol, lang);\n\n\t\tif (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) {\n\t\t\t/*\n\t\t\t * Skip section symbols because they will have their own flag.\n\t\t\t * Skip also file symbols because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) {\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_special_symbol (r, symbol, va);\n\t\t\t}\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\t// TODO: provide separate API in RBinPlugin to let plugins handle anal hints/metadata\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_symbol (r, symbol, info, va);\n\t\t\t}\n\t\t\tselect_flag_space (r, symbol);\n\t\t\t/* If that's a Classed symbol (method or so) */\n\t\t\tif (sn.classname) {\n\t\t\t\tRFlagItem *fi = r_flag_get (r->flags, sn.methflag);\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, sn.methflag);\n\t\t\t\t\tr_name_filter (sn.methflag, -1);\n\t\t\t\t\tfree (sn.methflag);\n\t\t\t\t\tsn.methflag = prname;\n\t\t\t\t}\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, sn.methname);\n\t\t\t\t\tif ((fi->offset - r->flags->base) == addr) {\n\t\t\t\t//\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\t\tr_flag_unset (r->flags, fi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);\n\t\t\t\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\tif (comment) {\n\t\t\t\t\t\tr_flag_item_set_comment (fi, comment);\n\t\t\t\t\t\tR_FREE (comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *n = sn.demname ? sn.demname : sn.name;\n\t\t\t\tconst char *fn = sn.demflag ? sn.demflag : sn.nameflag;\n\t\t\t\tchar *fnp = (r->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", r->bin->prefix, fn):\n\t\t\t\t\tstrdup (fn);\n\t\t\t\tRFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size);\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, n);\n\t\t\t\t\tfi->demangled = (bool)(size_t)sn.demname;\n\t\t\t\t} else {\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fnp);\n\t\t\t}\n\t\t\tif (sn.demname) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT,\n\t\t\t\t\taddr, symbol->size, sn.demname);\n\t\t\t}\n\t\t\tr_flag_space_pop (r->flags);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *str = r_str_escape_utf8_for_json (r_symbol_name, -1);\n\t\t\t// str = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t((exponly && firstexp) || printHere) ? \"\" : (iter->p ? \",\" : \"\"),\n\t\t\t\tstr,\n\t\t\t\tsn.demname? sn.demname: \"\",\n\t\t\t\tsn.nameflag,\n\t\t\t\tsymbol->ordinal,\n\t\t\t\tsymbol->bind,\n\t\t\t\t(int)symbol->size,\n\t\t\t\tsymbol->type,\n\t\t\t\t(ut64)addr, (ut64)symbol->paddr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %d %s\\n\",\n\t\t\t\taddr, (int)symbol->size, name);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"%s\\n\", name);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t/* Skip special symbols because we do not flag them and\n\t\t\t * they shouldn't be printed in the rad format either */\n\t\t\tif (is_special_symbol (symbol)) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tRBinFile *binfile;\n\t\t\tRBinPlugin *plugin;\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tif (!name) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (!strncmp (name, \"imp.\", 4)) {\n\t\t\t\tif (lastfs != 'i') {\n\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\t}\n\t\t\t\tlastfs = 'i';\n\t\t\t} else {\n\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\tconst char *fs = exponly? \"exports\": \"symbols\";\n\t\t\t\t\tr_cons_printf (\"fs %s\\n\", fs);\n\t\t\t\t}\n\t\t\t\tlastfs = 's';\n\t\t\t}\n\t\t\tif (r->bin->prefix || *name) { // we don't want unnamed symbol flags\n\t\t\t\tchar *flagname = construct_symbol_flagname (\"sym\", name, MAXFLAG_LEN_DEFAULT);\n\t\t\t\tif (!flagname) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"f %s%s%s %u 0x%08\" PFMT64x \"\\\"\\n\",\n\t\t\t\t\tr->bin->prefix ? r->bin->prefix : \"\", r->bin->prefix ? \".\" : \"\",\n\t\t\t\t\tflagname, symbol->size, addr);\n\t\t\t\tfree (flagname);\n\t\t\t}\n\t\t\tbinfile = r_bin_cur (r->bin);\n\t\t\tplugin = r_bin_file_cur_plugin (binfile);\n\t\t\tif (plugin && plugin->name) {\n\t\t\t\tif (r_str_startswith (plugin->name, \"pe\")) {\n\t\t\t\t\tchar *module = strdup (r_symbol_name);\n\t\t\t\t\tchar *p = strstr (module, \".dll_\");\n\t\t\t\t\tif (p && strstr (module, \"imp.\")) {\n\t\t\t\t\t\tchar *symname = __filterShell (p + 5);\n\t\t\t\t\t\tchar *m = __filterShell (module);\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s.%s\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (symname);\n\t\t\t\t\t\tfree (m);\n\t\t\t\t\t}\n\t\t\t\t\tfree (module);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *bind = symbol->bind? symbol->bind: \"NONE\";\n\t\t\tconst char *type = symbol->type? symbol->type: \"NONE\";\n\t\t\tconst char *name = r_str_get (sn.demname? sn.demname: r_symbol_name);\n\t\t\t// const char *fwd = r_str_get (symbol->forwarder);\n\t\t\tr_cons_printf (\"%03u\", symbol->ordinal);\n\t\t\tif (symbol->paddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\" ----------\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, symbol->paddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" %6s %6s %4d%s%s\\n\",\n\t\t\t               addr, bind, type, symbol->size, *name? \" \": \"\", name);\n\t\t}\nnext:\n\t\tsnFini (&sn);\n\t\ti++;\n\t\tfree (r_symbol_name);\n\t\tif (exponly && firstexp) {\n\t\t\tfirstexp = false;\n\t\t}\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (count == 0 && IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{}\");\n\t}\n\n\n\t//handle thumb and arm for entry point since they are not present in symbols\n\tif (is_arm) {\n\t\tr_list_foreach (entries, iter, entry) {\n\t\t\tif (IS_MODE_SET (mode)) {\n\t\t\t\thandle_arm_entry (r, entry, info, va);\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"]\");\n\t}\n\n\tr_spaces_pop (&r->anal->meta_spaces);\n\treturn true;\n}\n\nstatic char *build_hash_string(int mode, const char *chksum, ut8 *data, ut32 datalen) {\n\tchar *chkstr = NULL, *aux, *ret = NULL;\n\tconst char *ptr = chksum;\n\tchar tmp[128];\n\tint i;\n\tdo {\n\t\tfor (i = 0; *ptr && *ptr != ',' && i < sizeof (tmp) -1; i++) {\n\t\t\ttmp[i] = *ptr++;\n\t\t}\n\t\ttmp[i] = '\\0';\n\t\tr_str_trim_head_tail (tmp);\n\t\tchkstr = r_hash_to_string (NULL, tmp, data, datalen);\n\t\tif (!chkstr) {\n\t\t\tif (*ptr && *ptr == ',') {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (IS_MODE_SIMPLE (mode)) {\n\t\t\taux = r_str_newf (\"%s \", chkstr);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\taux = r_str_newf (\"\\\"%s\\\":\\\"%s\\\",\", tmp, chkstr);\n\t\t} else {\n\t\t\taux = r_str_newf (\"%s=%s \", tmp, chkstr);\n\t\t}\n\t\tret = r_str_append (ret, aux);\n\t\tfree (chkstr);\n\t\tfree (aux);\n\t\tif (*ptr && *ptr == ',') {\n\t\t\tptr++;\n\t\t}\n\t} while (*ptr);\n\n\treturn ret;\n}\n\ntypedef struct {\n\tconst char *uri;\n\tint perm;\n\tRIODesc *desc;\n} FindFile;\n\nstatic bool findFile(void *user, void *data, ut32 id) {\n\tFindFile *res = (FindFile*)user;\n\tRIODesc *desc = (RIODesc*)data;\n\tif (desc->perm && res->perm && !strcmp (desc->uri, res->uri)) {\n\t\tres->desc = desc;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic RIODesc *findReusableFile(RIO *io, const char *uri, int perm) {\n\tFindFile arg = {\n\t\t.uri = uri,\n\t\t.perm = perm,\n\t\t.desc = NULL,\n\t};\n\tr_id_storage_foreach (io->files, findFile, &arg);\n\treturn arg.desc;\n}\n\nstatic bool io_create_mem_map(RIO *io, RBinSection *sec, ut64 at) {\n\tr_return_val_if_fail (io && sec, false);\n\n\tbool reused = false;\n\tut64 gap = sec->vsize - sec->size;\n\tchar *uri = r_str_newf (\"null://%\"PFMT64u, gap);\n\tRIODesc *desc = findReusableFile (io, uri, sec->perm);\n\tif (desc) {\n\t\tRIOMap *map = r_io_map_get (io, at);\n\t\tif (!map) {\n\t\t\tr_io_map_add_batch (io, desc->fd, desc->perm, 0LL, at, gap);\n\t\t}\n\t\treused = true;\n\t}\n\tif (!desc) {\n\t\tdesc = r_io_open_at (io, uri, sec->perm, 0664, at);\n\t}\n\tfree (uri);\n\tif (!desc) {\n\t\treturn false;\n\t}\n\t// this works, because new maps are always born on the top\n\tRIOMap *map = r_io_map_get (io, at);\n\t// check if the mapping failed\n\tif (!map) {\n\t\tif (!reused) {\n\t\t\tr_io_desc_close (desc);\n\t\t}\n\t\treturn false;\n\t}\n\t// let the section refere to the map as a memory-map\n\tmap->name = r_str_newf (\"mmap.%s\", sec->name);\n\treturn true;\n}\n\nstatic void add_section(RCore *core, RBinSection *sec, ut64 addr, int fd) {\n\tif (!r_io_desc_get (core->io, fd) || UT64_ADD_OVFCHK (sec->size, sec->paddr) ||\n\t    UT64_ADD_OVFCHK (sec->size, addr) || !sec->vsize) {\n\t\treturn;\n\t}\n\n\tut64 size = sec->vsize;\n\t// if there is some part of the section that needs to be zeroed by the loader\n\t// we add a null map that takes care of it\n\tif (sec->vsize > sec->size) {\n\t\tif (!io_create_mem_map (core->io, sec, addr + sec->size)) {\n\t\t\treturn;\n\t\t}\n\n\t\tsize = sec->size;\n\t}\n\n\t// then we map the part of the section that comes from the physical file\n\tchar *map_name = r_str_newf (\"fmap.%s\", sec->name);\n\tif (!map_name) {\n\t\treturn;\n\t}\n\n\tint perm = sec->perm;\n\t// workaround to force exec bit in text section\n\tif (sec->name &&  strstr (sec->name, \"text\")) {\n\t\tperm |= R_PERM_X;\n\t}\n\n\tRIOMap *map = r_io_map_add_batch (core->io, fd, perm, sec->paddr, addr, size);\n\tif (!map) {\n\t\tfree (map_name);\n\t\treturn;\n\t}\n\tmap->name = map_name;\n\treturn;\n}\n\nstruct io_bin_section_info_t {\n\tRBinSection *sec;\n\tut64 addr;\n\tint fd;\n};\n\nstatic int bin_sections(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, const char *chksum, bool print_segments) {\n\tchar *str = NULL;\n\tRBinSection *section;\n\tRBinInfo *info = NULL;\n\tRList *sections;\n\tRListIter *iter;\n\tRListIter *last_processed = NULL;\n\tint i = 0;\n\tint fd = -1;\n\tbool printHere = false;\n\tsections = r_bin_get_sections (r->bin);\n#if LOAD_BSS_MALLOC\n\tbool inDebugger = r_config_get_i (r->config, \"cfg.debug\");\n#endif\n\tHtPP *dup_chk_ht = ht_pp_new0 ();\n\tbool ret = false;\n\tconst char *type = print_segments ? \"segment\" : \"section\";\n\tbool segments_only = true;\n\tRList *io_section_info = NULL;\n\n\tif (!dup_chk_ht) {\n\t\treturn false;\n\t}\n\n\tif (chksum && *chksum == '.') {\n\t\tprintHere = true;\n\t}\n\tif (IS_MODE_EQUAL (mode)) {\n\t\tint cols = r_cons_get_size (NULL);\n\t\tRList *list = r_list_newf ((RListFree) r_listinfo_free);\n\t\tif (!list) {\n\t\t\treturn false;\n\t\t}\n\t\tRBinSection *s;\n\t\tr_list_foreach (sections, iter, s) {\n\t\t\tchar humansz[8];\n\t\t\tif (print_segments != s->is_segment) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRInterval pitv = (RInterval){s->paddr, s->size};\n\t\t\tRInterval vitv = (RInterval){s->vaddr, s->vsize};\n\t\t\tr_num_units (humansz, sizeof (humansz), s->size);\n\t\t\tRListInfo *info = r_listinfo_new (s->name, pitv, vitv, s->perm, strdup (humansz));\n\t\t\tr_list_append (list, info);\n\t\t}\n\t\tr_core_visual_list (r, list, r->offset, -1, cols, r->print->flags & R_PRINT_FLAGS_COLOR);\n\t\tr_list_free (list);\n\t\tgoto out;\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_RAD (mode) && !at) {\n\t\tr_cons_printf (\"fs %ss\\n\", type);\n\t} else if (IS_MODE_NORMAL (mode) && !at && !printHere) {\n\t\tr_cons_printf (\"[%s]\\n\", print_segments ? \"Segments\" : \"Sections\");\n\t} else if (IS_MODE_NORMAL (mode) && printHere) {\n\t\tr_cons_printf (\"Current section\\n\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tfd = r_core_file_cur_fd (r);\n\t\tr_flag_space_set (r->flags, print_segments? R_FLAGS_FS_SEGMENTS: R_FLAGS_FS_SECTIONS);\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"Nm Paddr       Size Vaddr      Memsz Perms %sName\\n\",\n                   chksum ? \"Checksum          \" : \"\");\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tr_list_foreach (sections, iter, section) {\n\t\t\tif (!section->is_segment) {\n\t\t\t\tsegments_only = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tio_section_info = r_list_newf ((RListFree)free);\n\t}\n\tr_list_foreach (sections, iter, section) {\n\t\tchar perms[] = \"----\";\n\t\tint va_sect = va;\n\t\tut64 addr;\n\n\t\tif (va && !(section->perm & R_PERM_R)) {\n\t\t\tva_sect = VA_NOREBASE;\n\t\t}\n\t\taddr = rva (r->bin, section->paddr, section->vaddr, va_sect);\n\n\t\tif (name && strcmp (section->name, name)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((printHere && !(section->paddr <= r->offset && r->offset < (section->paddr + section->size)))\n\t\t\t\t&& (printHere && !(addr <= r->offset && r->offset < (addr + section->size)))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tr_name_filter (section->name, strlen (section->name) + 1);\n\t\tif (at && (!section->size || !is_in_range (at, addr, section->size))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (section->is_segment != print_segments) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (section->perm & R_PERM_SHAR) {\n\t\t\tperms[0] = 's';\n\t\t}\n\t\tif (section->perm & R_PERM_R) {\n\t\t\tperms[1] = 'r';\n\t\t}\n\t\tif (section->perm & R_PERM_W) {\n\t\t\tperms[2] = 'w';\n\t\t}\n\t\tif (section->perm & R_PERM_X) {\n\t\t\tperms[3] = 'x';\n\t\t}\n\t\tconst char *arch = NULL;\n\t\tint bits = 0;\n\t\tif (section->arch || section->bits) {\n\t\t\tarch = section->arch;\n\t\t\tbits = section->bits;\n\t\t}\n\t\tif (info) {\n\t\t\tif (!arch) {\n\t\t\t\tarch = info->arch;\n\t\t\t}\n\t\t\tif (!bits) {\n\t\t\t\tbits = info->bits;\n\t\t\t}\n\t\t}\n\t\tif (!arch) {\n\t\t\tarch = r_config_get (r->config, \"asm.arch\");\n\t\t}\n\t\tif (!bits) {\n\t\t\tbits = R_SYS_BITS;\n\t\t}\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tchar *n = __filterQuotedShell (section->name);\n\t\t\tr_cons_printf (\"\\\"f %s.%s 1 0x%08\"PFMT64x\"\\\"\\n\", type, n, section->vaddr);\n\t\t\tfree (n);\n\t\t} else if (IS_MODE_SET (mode)) {\n#if LOAD_BSS_MALLOC\n\t\t\tif (!strcmp (section->name, \".bss\")) {\n\t\t\t\t// check if there's already a file opened there\n\t\t\t\tint loaded = 0;\n\t\t\t\tRListIter *iter;\n\t\t\t\tRIOMap *m;\n\t\t\t\tr_list_foreach (r->io->maps, iter, m) {\n\t\t\t\t\tif (m->from == addr) {\n\t\t\t\t\t\tloaded = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!loaded && !inDebugger) {\n\t\t\t\t\tr_core_cmdf (r, \"on malloc://%d 0x%\"PFMT64x\" # bss\\n\",\n\t\t\t\t\t\tsection->vsize, addr);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tif (section->format) {\n\t\t\t\t// This is damn slow if section vsize is HUGE\n\t\t\t\tif (section->vsize < 1024 * 1024 * 2) {\n\t\t\t\t\tr_core_cmdf (r, \"%s @ 0x%\"PFMT64x, section->format, section->vaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tstr = r_str_newf (\"%s.%s.%s\", r->bin->prefix, type, section->name);\n\t\t\t} else {\n\t\t\t\tstr = r_str_newf (\"%s.%s\", type, section->name);\n\n\t\t\t}\n\t\t\tut64 size = r->io->va? section->vsize: section->size;\n\t\t\tr_flag_set (r->flags, str, addr, size);\n\t\t\tR_FREE (str);\n\n\t\t\tif (!section->is_segment || segments_only) {\n\t\t\t\tchar *pfx = r->bin->prefix;\n\t\t\t\tstr = r_str_newf (\"[%02d] %s %s size %\" PFMT64d\" named %s%s%s\",\n\t\t\t\t                  i, perms, type, size,\n\t\t\t\t                  pfx? pfx: \"\", pfx? \".\": \"\", section->name);\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT, addr, addr, str);\n\t\t\t\tR_FREE (str);\n\t\t\t}\n\t\t\tif (section->add) {\n\t\t\t\tbool found;\n\t\t\t\tstr = r_str_newf (\"%\"PFMT64x\".%\"PFMT64x\".%\"PFMT64x\".%\"PFMT64x\".%\"PFMT32u\".%s.%\"PFMT32u\".%d\",\n\t\t\t\t\tsection->paddr, addr, section->size, section->vsize, section->perm, section->name, r->bin->cur->id, fd);\n\t\t\t\tht_pp_find (dup_chk_ht, str, &found);\n\t\t\t\tif (!found) {\n\t\t\t\t\t// can't directly add maps because they\n\t\t\t\t\t// need to be reversed, otherwise for\n\t\t\t\t\t// the way IO works maps would be shown\n\t\t\t\t\t// in reverse order\n\t\t\t\t\tstruct io_bin_section_info_t *ibs = R_NEW (struct io_bin_section_info_t);\n\t\t\t\t\tif (!ibs) {\n\t\t\t\t\t\teprintf (\"Could not allocate memory\\n\");\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\tibs->sec = section;\n\t\t\t\t\tibs->addr = addr;\n\t\t\t\t\tibs->fd = fd;\n\t\t\t\t\tr_list_append (io_section_info, ibs);\n\t\t\t\t\tht_pp_insert (dup_chk_ht, str, NULL);\n\t\t\t\t}\n\t\t\t\tR_FREE (str);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tchar *hashstr = NULL;\n\t\t\tif (chksum) {\n\t\t\t\tut8 *data = malloc (section->size);\n\t\t\t\tif (!data) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tut32 datalen = section->size;\n\t\t\t\tr_io_pread_at (r->io, section->paddr, data, datalen);\n\t\t\t\thashstr = build_hash_string (mode, chksum,\n\t\t\t\t\t\t\tdata, datalen);\n\t\t\t\tfree (data);\n\t\t\t}\n\t\t\tr_cons_printf (\"0x%\"PFMT64x\" 0x%\"PFMT64x\" %s %s%s%s\\n\",\n\t\t\t\taddr, addr + section->size,\n\t\t\t\tperms,\n\t\t\t\thashstr ? hashstr : \"\", hashstr ? \" \" : \"\",\n\t\t\t\tsection->name\n\t\t\t);\n\t\t\tfree (hashstr);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *hashstr = NULL;\n\t\t\tif (chksum && section->size > 0) {\n\t\t\t\tut8 *data = malloc (section->size);\n\t\t\t\tif (!data) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tut32 datalen = section->size;\n\t\t\t\tr_io_pread_at (r->io, section->paddr, data, datalen);\n\t\t\t\thashstr = build_hash_string (mode, chksum,\n\t\t\t\t\t\t\tdata, datalen);\n\t\t\t\tfree (data);\n\t\t\t}\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"vsize\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"perm\\\":\\\"%s\\\",\"\n\t\t\t\t\"%s\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t(last_processed && !printHere) ? \",\" : \"\",\n\t\t\t\tsection->name,\n\t\t\t\tsection->size,\n\t\t\t\tsection->vsize,\n\t\t\t\tperms,\n\t\t\t\thashstr ? hashstr : \"\",\n\t\t\t\tsection->paddr,\n\t\t\t\taddr);\n\t\t\tfree (hashstr);\n\t\t} else {\n\t\t\tchar *hashstr = NULL, str[128];\n\t\t\tif (chksum) {\n\t\t\t\tut8 *data = malloc (section->size);\n\t\t\t\tif (!data) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tut32 datalen = section->size;\n\t\t\t\t// VA READ IS BROKEN?\n\t\t\t\tif (datalen > 0) {\n\t\t\t\t\tr_io_pread_at (r->io, section->paddr, data, datalen);\n\t\t\t\t}\n\t\t\t\thashstr = build_hash_string (mode, chksum, data, datalen);\n\t\t\t\tfree (data);\n\t\t\t}\n\t\t\tif (section->arch || section->bits) {\n\t\t\t\tsnprintf (str, sizeof (str), \"arch=%s bits=%d \",\n\t\t\t\t\tr_str_get2 (arch), bits);\n\t\t\t} else {\n\t\t\t\tstr[0] = 0;\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tr_cons_printf (\"%02i 0x%08\"PFMT64x\" %5\"PFMT64d\" 0x%08\"PFMT64x\" %5\"PFMT64d\" \"\n\t\t\t\t\t\"%s %s%s%s.%s\\n\",\n\t\t\t\t\ti, section->paddr, section->size, addr, section->vsize,\n\t\t\t\t\tperms, str, hashstr ?hashstr : \"\", r->bin->prefix, section->name);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%02i 0x%08\"PFMT64x\" %5\"PFMT64d\" 0x%08\"PFMT64x\" %5\"PFMT64d\" \"\n\t\t\t\t\t\"%s %s%s%s\\n\",\n\t\t\t\t\ti, section->paddr, (ut64)section->size, addr, (ut64)section->vsize,\n\t\t\t\t\tperms, str, hashstr ?hashstr : \"\", section->name);\n\t\t\t}\n\t\t\tfree (hashstr);\n\t\t}\n\t\ti++;\n\t\tlast_processed = iter;\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (IS_MODE_SET (mode) && !r_io_desc_is_dbg (r->io->desc)) {\n\t\tRListIter *it;\n\t\tstruct io_bin_section_info_t *ibs;\n\t\tr_list_foreach_prev (io_section_info, it, ibs) {\n\t\t\tadd_section (r, ibs->sec, ibs->addr, ibs->fd);\n\t\t}\n\t\tr_io_update (r->io);\n\t\tr_list_free (io_section_info);\n\t\tio_section_info = NULL;\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_println (\"]\");\n\t} else if (IS_MODE_NORMAL (mode) && !at && !printHere) {\n\t\t// r_cons_printf (\"\\n%i sections\\n\", i);\n\t}\n\n\tret = true;\nout:\n\tht_pp_free (dup_chk_ht);\n\treturn ret;\n}\n\nstatic int bin_fields(RCore *r, int mode, int va) {\n\tRList *fields;\n\tRListIter *iter;\n\tRBinField *field;\n\tint i = 0;\n\tRBin *bin = r->bin;\n\n\tif (!(fields = r_bin_get_fields (bin))) {\n\t\treturn false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs header\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Header fields]\");\n\t}\n\tr_list_foreach (fields, iter, field) {\n\t\tut64 addr = rva (bin, field->paddr, field->vaddr, va);\n\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tchar *n = __filterQuotedShell (field->name);\n\t\t\tr_name_filter (n, -1);\n\t\t\tr_cons_printf (\"\\\"f header.%s 1 0x%08\"PFMT64x\"\\\"\\n\", n, addr);\n\t\t\tif (field->comment && *field->comment) {\n\t\t\t\tchar *e = sdb_encode ((const ut8*)field->comment, -1);\n\t\t\t\tr_cons_printf (\"CCu %s @ 0x%\"PFMT64x\"\\n\", e, addr);\n\t\t\t\tfree (e);\n\t\t\t\tchar *f = __filterShell (field->format);\n\t\t\t\tr_cons_printf (\"Cf %d .%s @ 0x%\"PFMT64x\"\\n\", field->size, f, addr);\n\t\t\t\tfree (f);\n\t\t\t}\n\t\t\tif (field->format && *field->format) {\n\t\t\t\tr_cons_printf (\"pf.%s %s\\n\", n, field->format);\n\t\t\t}\n\t\t\tfree (n);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d,\n\t\t\t\titer->p? \",\": \"\",\n\t\t\t\tfield->name,\n\t\t\t\tfield->vaddr,\n\t\t\t\tfield->paddr\n\t\t\t\t);\n\t\t\tif (field->comment && *field->comment) {\n\t\t\t\t// TODO: filter comment before json\n\t\t\t\tr_cons_printf (\",\\\"comment\\\":\\\"%s\\\"\", field->comment);\n\t\t\t}\n\t\t\tif (field->format && *field->format) {\n\t\t\t\t// TODO: filter comment before json\n\t\t\t\tr_cons_printf (\",\\\"format\\\":\\\"%s\\\"\", field->format);\n\t\t\t}\n\t\t\tchar *o = r_core_cmd_strf (r, \"pfj.%s@0x%\"PFMT64x, field->format, field->vaddr);\n\t\t\tif (o && *o) {\n\t\t\t\tr_cons_printf (\",\\\"pf\\\":%s\", o);\n\t\t\t}\n\t\t\tfree (o);\n\t\t\tr_cons_printf (\"}\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tconst bool haveComment = (field->comment && *field->comment);\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" 0x%08\"PFMT64x\" %s%s%s\\n\",\n\t\t\t\tfield->vaddr, field->paddr, field->name,\n\t\t\t\thaveComment? \"; \": \"\",\n\t\t\t\thaveComment? field->comment: \"\");\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i fields\\n\", i);\n\t}\n\n\treturn true;\n}\n\nstatic char *get_rp(const char *rtype) {\n\tchar *rp = NULL;\n\tswitch (rtype[0]) {\n\tcase 'v':\n\t\trp = strdup (\"void\");\n\t\tbreak;\n\tcase 'c':\n\t\trp = strdup (\"char\");\n\t\tbreak;\n\tcase 'i':\n\t\trp = strdup (\"int\");\n\t\tbreak;\n\tcase 's':\n\t\trp = strdup (\"short\");\n\t\tbreak;\n\tcase 'l':\n\t\trp = strdup (\"long\");\n\t\tbreak;\n\tcase 'q':\n\t\trp = strdup (\"long long\");\n\t\tbreak;\n\tcase 'C':\n\t\trp = strdup (\"unsigned char\");\n\t\tbreak;\n\tcase 'I':\n\t\trp = strdup (\"unsigned int\");\n\t\tbreak;\n\tcase 'S':\n\t\trp = strdup (\"unsigned short\");\n\t\tbreak;\n\tcase 'L':\n\t\trp = strdup (\"unsigned long\");\n\t\tbreak;\n\tcase 'Q':\n\t\trp = strdup (\"unsigned long long\");\n\t\tbreak;\n\tcase 'f':\n\t\trp = strdup (\"float\");\n\t\tbreak;\n\tcase 'd':\n\t\trp = strdup (\"double\");\n\t\tbreak;\n\tcase 'D':\n\t\trp = strdup (\"long double\");\n\t\tbreak;\n\tcase 'B':\n\t\trp = strdup (\"bool\");\n\t\tbreak;\n\tcase '#':\n\t\trp = strdup (\"CLASS\");\n\t\tbreak;\n\tdefault:\n\t\trp = strdup (\"unknown\");\n\t\tbreak;\n\t}\n\treturn rp;\n}\n\nstatic int bin_trycatch(RCore *core, int mode) {\n\tRBinFile *bf = r_bin_cur (core->bin);\n\tRListIter *iter;\n\tRBinTrycatch *tc;\n\tRList *trycatch = r_bin_file_get_trycatch (bf);\n\tint idx = 0;\n\tr_list_foreach (trycatch, iter, tc) {\n\t\tr_cons_printf (\"f try.%d.%\"PFMT64x\".from=0x%08\"PFMT64x\"\\n\", idx, tc->source, tc->from);\n\t\tr_cons_printf (\"f try.%d.%\"PFMT64x\".to=0x%08\"PFMT64x\"\\n\", idx, tc->source, tc->to);\n\t\tr_cons_printf (\"f try.%d.%\"PFMT64x\".catch=0x%08\"PFMT64x\"\\n\", idx, tc->source, tc->handler);\n\t\tidx++;\n\t}\n\treturn true;\n}\n\nstatic void classdump_objc(RCore *r, RBinClass *c) {\n\tif (c->super) {\n\t\tr_cons_printf (\"@interface %s : %s\\n{\\n\", c->name, c->super);\n\t} else {\n\t\tr_cons_printf (\"@interface %s\\n{\\n\", c->name);\n\t}\n\tRListIter *iter2, *iter3;\n\tRBinField *f;\n\tRBinSymbol *sym;\n\tr_list_foreach (c->fields, iter2, f) {\n\t\tif (f->name && r_regex_match (\"ivar\",\"e\", f->name)) {\n\t\t\tr_cons_printf (\"  %s %s\\n\", f->type, f->name);\n\t\t}\n\t}\n\tr_cons_printf (\"}\\n\");\n\tr_list_foreach (c->methods, iter3, sym) {\n\t\tif (sym->rtype && sym->rtype[0] != '@') {\n\t\t\tchar *rp = get_rp (sym->rtype);\n\t\t\tr_cons_printf (\"%s (%s) %s\\n\",\n\t\t\t\t\tstrncmp (sym->type, R_BIN_TYPE_METH_STR, 4)? \"+\": \"-\",\n\t\t\t\t\trp, sym->dname? sym->dname: sym->name);\n\t\t\tfree (rp);\n\t\t} else if (sym->type) {\n\t\t\tr_cons_printf (\"%s (id) %s\\n\",\n\t\t\t\t\tstrncmp (sym->type, R_BIN_TYPE_METH_STR, 4)? \"+\": \"-\",\n\t\t\t\t\tsym->dname? sym->dname: sym->name);\n\t\t}\n\t}\n\tr_cons_printf (\"@end\\n\");\n}\n\nstatic void classdump_java(RCore *r, RBinClass *c) {\n\tRBinField *f;\n\tRListIter *iter2, *iter3;\n\tRBinSymbol *sym;\n\tchar *pn = strdup (c->name);\n\tchar *cn = (char *)r_str_rchr (pn, NULL, '/');\n\tif (cn) {\n\t\t*cn = 0;\n\t\tcn++;\n\t\tr_str_replace_char (pn, '/', '.');\n\t}\n\tr_cons_printf (\"package %s;\\n\\n\", pn);\n\tr_cons_printf (\"public class %s {\\n\", cn);\n\tfree (pn);\n\tr_list_foreach (c->fields, iter2, f) {\n\t\tif (f->name && r_regex_match (\"ivar\",\"e\", f->name)) {\n\t\t\tr_cons_printf (\"  public %s %s\\n\", f->type, f->name);\n\t\t}\n\t}\n\tr_list_foreach (c->methods, iter3, sym) {\n\t\tconst char *mn = sym->dname? sym->dname: sym->name;\n\t\tconst char *ms = strstr (mn, \"method.\");\n\t\tif (ms) {\n\t\t\tmn = ms + strlen (\"method.\");\n\t\t}\n\t\tr_cons_printf (\"  public %s ();\\n\", mn);\n\t}\n\tr_cons_printf (\"}\\n\\n\");\n}\n\nstatic int bin_classes(RCore *r, int mode) {\n\tRListIter *iter, *iter2, *iter3;\n\tRBinSymbol *sym;\n\tRBinClass *c;\n\tRBinField *f;\n\tchar *name;\n\tRList *cs = r_bin_get_classes (r->bin);\n\tif (!cs) {\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_print (\"[]\");\n\t\t}\n\t\treturn false;\n\t}\n\t// XXX: support for classes is broken and needs more love\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tif (!r_config_get_i (r->config, \"bin.classes\")) {\n\t\t\treturn false;\n\t\t}\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_CLASSES);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs classes\");\n\t}\n\n\tr_list_foreach (cs, iter, c) {\n\t\tif (!c || !c->name || !c->name[0]) {\n\t\t\tcontinue;\n\t\t}\n\t\tname = strdup (c->name);\n\t\tr_name_filter (name, 0);\n\t\tut64 at_min = UT64_MAX;\n\t\tut64 at_max = 0LL;\n\n\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\tif (sym->vaddr) {\n\t\t\t\tif (sym->vaddr < at_min) {\n\t\t\t\t\tat_min = sym->vaddr;\n\t\t\t\t}\n\t\t\t\tif (sym->vaddr + sym->size > at_max) {\n\t\t\t\t\tat_max = sym->vaddr + sym->size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (at_min == UT64_MAX) {\n\t\t\tat_min = c->addr;\n\t\t\tat_max = c->addr; // XXX + size?\n\t\t}\n\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tconst char *classname = sdb_fmt (\"class.%s\", name);\n\t\t\tr_flag_set (r->flags, classname, c->addr, 1);\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym->method_flags, mode);\n\t\t\t\tchar *method = sdb_fmt (\"method%s.%s.%s\",\n\t\t\t\t\tmflags, c->name, sym->name);\n\t\t\t\tR_FREE (mflags);\n\t\t\t\tr_name_filter (method, -1);\n\t\t\t\tr_flag_set (r->flags, method, sym->vaddr, 1);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tr_cons_printf (\"%s\\n\", c->name);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" [0x%08\"PFMT64x\" - 0x%08\"PFMT64x\"] %s%s%s\\n\",\n\t\t\t\tc->addr, at_min, at_max, c->name, c->super ? \" \" : \"\",\n\t\t\t\tc->super ? c->super : \"\");\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tchar *n = __filterShell (name);\n\t\t\tr_cons_printf (\"\\\"f class.%s = 0x%\"PFMT64x\"\\\"\\n\", n, at_min);\n\t\t\tfree (n);\n\t\t\tif (c->super) {\n\t\t\t\tchar *cn = c->name; // __filterShell (c->name);\n\t\t\t\tchar *su = c->super; // __filterShell (c->super);\n\t\t\t\tr_cons_printf (\"\\\"f super.%s.%s = %d\\\"\\n\",\n\t\t\t\t\t\tcn, su, c->index);\n\t\t\t\t// free (cn);\n\t\t\t\t// free (su);\n\t\t\t}\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym->method_flags, mode);\n\t\t\t\tchar *n = c->name; //  __filterShell (c->name);\n\t\t\t\tchar *sn = sym->name; //__filterShell (sym->name);\n\t\t\t\tchar *cmd = r_str_newf (\"\\\"f method%s.%s.%s = 0x%\"PFMT64x\"\\\"\\n\", mflags, n, sn, sym->vaddr);\n\t\t\t\t// free (n);\n\t\t\t\t// free (sn);\n\t\t\t\tif (cmd) {\n\t\t\t\t\tr_str_replace_char (cmd, ' ', '_');\n\t\t\t\t\tif (strlen (cmd) > 2) {\n\t\t\t\t\t\tcmd[2] = ' ';\n\t\t\t\t\t}\n\t\t\t\t\tchar *eq = (char *)r_str_rchr (cmd, NULL, '=');\n\t\t\t\t\tif (eq && eq != cmd) {\n\t\t\t\t\t\teq[-1] = eq[1] = ' ';\n\t\t\t\t\t}\n\t\t\t\t\tr_str_replace_char (cmd, '\\n', 0);\n\t\t\t\t\tr_cons_printf (\"%s\\n\", cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t}\n\t\t\t\tR_FREE (mflags);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tif (c->super) {\n\t\t\t\tr_cons_printf (\"%s{\\\"classname\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\",\\\"index\\\":%d,\\\"visibility\\\":\\\"%s\\\",\\\"super\\\":\\\"%s\\\",\\\"methods\\\":[\",\n\t\t\t\t\titer->p ? \",\" : \"\", c->name, c->addr,\n\t\t\t\t\tc->index, c->visibility_str? c->visibility_str: \"\", c->super);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s{\\\"classname\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\",\\\"index\\\":%d,\\\"methods\\\":[\",\n\t\t\t\t\titer->p ? \",\" : \"\", c->name, c->addr,\n\t\t\t\t\tc->index);\n\t\t\t}\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tif (sym->method_flags) {\n\t\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym->method_flags, mode);\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"flags\\\":%s,\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer2->p? \",\": \"\", sym->name, mflags, sym->vaddr);\n\t\t\t\t\tR_FREE (mflags);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer2->p? \",\": \"\", sym->name, sym->vaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"], \\\"fields\\\":[\");\n\t\t\tr_list_foreach (c->fields, iter3, f) {\n\t\t\t\tif (f->flags) {\n\t\t\t\t\tchar *mflags = r_core_bin_method_flags_str (f->flags, mode);\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"flags\\\":%s,\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer3->p? \",\": \"\", f->name, mflags, f->vaddr);\n\t\t\t\t\tR_FREE (mflags);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer3->p? \",\": \"\", f->name, f->vaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"]}\");\n\t\t} else if (IS_MODE_CLASSDUMP (mode)) {\n\t\t\tif (c) {\n\t\t\t\tRBinFile *bf = r_bin_cur (r->bin);\n\t\t\t\tif (bf && bf->o) {\n\t\t\t\t\tif (bf->o->lang == R_BIN_NM_JAVA || (bf->o->info && bf->o->info->lang && strstr (bf->o->info->lang, \"dalvik\"))) {\n\t\t\t\t\t\tclassdump_java (r, c);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclassdump_objc (r, c);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tclassdump_objc (r, c);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tint m = 0;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" [0x%08\"PFMT64x\" - 0x%08\"PFMT64x\"] %6\"PFMT64d\" class %d %s\",\n\t\t\t\tc->addr, at_min, at_max, (at_max - at_min), c->index, c->name);\n\t\t\tif (c->super) {\n\t\t\t\tr_cons_printf (\" :: %s\\n\", c->super);\n\t\t\t} else {\n\t\t\t\tr_cons_newline ();\n\t\t\t}\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym->method_flags, mode);\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" method %d %s %s\\n\",\n\t\t\t\t\tsym->vaddr, m, mflags, sym->dname? sym->dname: sym->name);\n\t\t\t\tR_FREE (mflags);\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t\tfree (name);\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t}\n\n\treturn true;\n}\n\nstatic int bin_size(RCore *r, int mode) {\n\tut64 size = r_bin_get_size (r->bin);\n\tif (IS_MODE_SIMPLE (mode) || IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"%\"PFMT64u\"\\n\", size);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"f bin_size @ %\"PFMT64u\"\\n\", size);\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_core_cmdf (r, \"f bin_size @ %\"PFMT64u\"\\n\", size);\n\t} else {\n\t\tr_cons_printf (\"%\"PFMT64u\"\\n\", size);\n\t}\n\treturn true;\n}\n\nstatic int bin_libs(RCore *r, int mode) {\n\tRList *libs;\n\tRListIter *iter;\n\tchar* lib;\n\tint i = 0;\n\n\tif (!(libs = r_bin_get_libs (r->bin))) {\n\t\treturn false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Linked libraries]\");\n\t}\n\tr_list_foreach (libs, iter, lib) {\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\t// Nothing to set.\n\t\t\t// TODO: load libraries with iomaps?\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"\\\"CCa entry0 %s\\\"\\n\", lib);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"%s\\\"%s\\\"\", iter->p ? \",\" : \"\", lib);\n\t\t} else {\n\t\t\t// simple and normal print mode\n\t\t\tr_cons_println (lib);\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tif (i == 1) {\n\t\t\tr_cons_printf (\"\\n%i library\\n\", i);\n\t\t} else {\n\t\t\tr_cons_printf (\"\\n%i libraries\\n\", i);\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic void bin_mem_print(RList *mems, int perms, int depth, int mode) {\n\tRBinMem *mem;\n\tRListIter *iter;\n\tif (!mems) {\n\t\treturn;\n\t}\n\tr_list_foreach (mems, iter, mem) {\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"{\\\"name\\\":\\\"%s\\\",\\\"size\\\":%d,\\\"address\\\":%d,\"\n\t\t\t\t\t\"\\\"flags\\\":\\\"%s\\\"}\", mem->name, mem->size,\n\t\t\t\t\tmem->addr, r_str_rwx_i (mem->perms & perms));\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", mem->addr);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" +0x%04x %s %*s%-*s\\n\",\n\t\t\t\t\tmem->addr, mem->size, r_str_rwx_i (mem->perms & perms),\n\t\t\t\t\tdepth, \"\", 20-depth, mem->name);\n\t\t}\n\t\tif (mem->mirrors) {\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_printf (\",\");\n\t\t\t}\n\t\t\tbin_mem_print (mem->mirrors, mem->perms & perms, depth + 1, mode);\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tif (iter->n) {\n\t\t\t\tr_cons_printf (\",\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int bin_mem(RCore *r, int mode) {\n\tRList *mem = NULL;\n\tif (!r) {\n\t\treturn false;\n\t}\n\tif (!IS_MODE_JSON (mode)) {\n\t\tif (!(IS_MODE_RAD (mode) || IS_MODE_SET (mode))) {\n\t\t\tr_cons_println (\"[Memory]\\n\");\n\t\t}\n\t}\n\tif (!(mem = r_bin_get_mem (r->bin))) {\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_print(\"[]\");\n\t\t}\n\t\treturn false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t\tbin_mem_print (mem, 7, 0, R_MODE_JSON);\n\t\tr_cons_println (\"]\");\n\t\treturn true;\n\t} else if (!(IS_MODE_RAD (mode) || IS_MODE_SET (mode))) {\n\t\tbin_mem_print (mem, 7, 0, mode);\n\t}\n\treturn true;\n}\n\nstatic void bin_pe_versioninfo(RCore *r, int mode) {\n\tSdb *sdb = NULL;\n\tint num_version = 0;\n\tint num_stringtable = 0;\n\tint num_string = 0;\n\tconst char *format_version = \"bin/cur/info/vs_version_info/VS_VERSIONINFO%d\";\n\tconst char *format_stringtable = \"%s/string_file_info/stringtable%d\";\n\tconst char *format_string = \"%s/string%d\";\n\tif (!IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"=== VS_VERSIONINFO ===\\n\\n\");\n\t}\n\tbool firstit_dowhile = true;\n\tdo {\n\t\tchar *path_version = sdb_fmt (format_version, num_version);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path_version, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!firstit_dowhile && IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\",\");\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"{\\\"VS_FIXEDFILEINFO\\\":{\");\n\t\t} else {\n\t\t\tr_cons_printf (\"# VS_FIXEDFILEINFO\\n\\n\");\n\t\t}\n\t\tconst char *path_fixedfileinfo = sdb_fmt (\"%s/fixed_file_info\", path_version);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path_fixedfileinfo, 0))) {\n\t\t\tr_cons_printf (\"}\");\n\t\t\tbreak;\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"Signature\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"Signature\", 0));\n\t\t\tr_cons_printf (\"\\\"StrucVersion\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"StrucVersion\", 0));\n\t\t\tr_cons_printf (\"\\\"FileVersion\\\":\\\"%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\\",\",\n\t\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) & 0xFFFF,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) & 0xFFFF);\n\t\t\tr_cons_printf (\"\\\"ProductVersion\\\":\\\"%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\\",\",\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) & 0xFFFF,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) & 0xFFFF);\n\t\t\tr_cons_printf (\"\\\"FileFlagsMask\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"FileFlagsMask\", 0));\n\t\t\tr_cons_printf (\"\\\"FileFlags\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"FileFlags\", 0));\n\t\t\tr_cons_printf (\"\\\"FileOS\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"FileOS\", 0));\n\t\t\tr_cons_printf (\"\\\"FileType\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"FileType\", 0));\n\t\t\tr_cons_printf (\"\\\"FileSubType\\\":%\"PFMT64u, sdb_num_get (sdb, \"FileSubType\", 0));\n\t\t\tr_cons_printf (\"},\");\n\t\t} else {\n\t\t\tr_cons_printf (\"  Signature: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"Signature\", 0));\n\t\t\tr_cons_printf (\"  StrucVersion: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"StrucVersion\", 0));\n\t\t\tr_cons_printf (\"  FileVersion: %\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\n\",\n\t\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) & 0xFFFF,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) & 0xFFFF);\n\t\t\tr_cons_printf (\"  ProductVersion: %\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\n\",\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) & 0xFFFF,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) & 0xFFFF);\n\t\t\tr_cons_printf (\"  FileFlagsMask: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileFlagsMask\", 0));\n\t\t\tr_cons_printf (\"  FileFlags: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileFlags\", 0));\n\t\t\tr_cons_printf (\"  FileOS: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileOS\", 0));\n\t\t\tr_cons_printf (\"  FileType: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileType\", 0));\n\t\t\tr_cons_printf (\"  FileSubType: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileSubType\", 0));\n\t\t\tr_cons_newline ();\n\t\t}\n#if 0\n\t\tr_cons_printf (\"  FileDate: %d.%d.%d.%d\\n\",\n\t\t\tsdb_num_get (sdb, \"FileDateMS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"FileDateMS\", 0) & 0xFFFF,\n\t\t\tsdb_num_get (sdb, \"FileDateLS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"FileDateLS\", 0) & 0xFFFF);\n#endif\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"StringTable\\\":{\");\n\t\t} else {\n\t\t\tr_cons_printf (\"# StringTable\\n\\n\");\n\t\t}\n\t\tfor (num_stringtable = 0; sdb; num_stringtable++) {\n\t\t\tchar *path_stringtable = r_str_newf (format_stringtable, path_version, num_stringtable);\n\t\t\tsdb = sdb_ns_path (r->sdb, path_stringtable, 0);\n\t\t\tbool firstit_for = true;\n\t\t\tfor (num_string = 0; sdb; num_string++) {\n\t\t\t\tchar *path_string = r_str_newf (format_string, path_stringtable, num_string);\n\t\t\t\tsdb = sdb_ns_path (r->sdb, path_string, 0);\n\t\t\t\tif (sdb) {\n\t\t\t\t\tif (!firstit_for && IS_MODE_JSON (mode)) { r_cons_printf (\",\"); }\n\t\t\t\t\tint lenkey = 0;\n\t\t\t\t\tint lenval = 0;\n\t\t\t\t\tut8 *key_utf16 = sdb_decode (sdb_const_get (sdb, \"key\", 0), &lenkey);\n\t\t\t\t\tut8 *val_utf16 = sdb_decode (sdb_const_get (sdb, \"value\", 0), &lenval);\n\t\t\t\t\tut8 *key_utf8 = calloc (lenkey * 2, 1);\n\t\t\t\t\tut8 *val_utf8 = calloc (lenval * 2, 1);\n\t\t\t\t\tif (r_str_utf16_to_utf8 (key_utf8, lenkey * 2, key_utf16, lenkey, true) < 0\n\t\t\t\t\t\t|| r_str_utf16_to_utf8 (val_utf8, lenval * 2, val_utf16, lenval, true) < 0) {\n\t\t\t\t\t\teprintf (\"Warning: Cannot decode utf16 to utf8\\n\");\n\t\t\t\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\t\t\t\tchar *escaped_key_utf8 = r_str_escape ((char*)key_utf8);\n\t\t\t\t\t\tchar *escaped_val_utf8 = r_str_escape ((char*)val_utf8);\n\t\t\t\t\t\tr_cons_printf (\"\\\"%s\\\":\\\"%s\\\"\", escaped_key_utf8, escaped_val_utf8);\n\t\t\t\t\t\tfree (escaped_key_utf8);\n\t\t\t\t\t\tfree (escaped_val_utf8);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"  %s: %s\\n\", (char*)key_utf8, (char*)val_utf8);\n\t\t\t\t\t}\n\t\t\t\t\tfree (key_utf8);\n\t\t\t\t\tfree (val_utf8);\n\t\t\t\t\tfree (key_utf16);\n\t\t\t\t\tfree (val_utf16);\n\t\t\t\t}\n\t\t\t\tfirstit_for = false;\n\t\t\t\tfree (path_string);\n\t\t\t}\n\t\t\tfree (path_stringtable);\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"}}\");\n\t\t}\n\t\tnum_version++;\n\t\tfirstit_dowhile = false;\n\t} while (sdb);\n}\n\nstatic void bin_elf_versioninfo(RCore *r, int mode) {\n\tconst char *format = \"bin/cur/info/versioninfo/%s%d\";\n\tint num_versym;\n\tint num_verneed = 0;\n\tint num_version = 0;\n\tSdb *sdb = NULL;\n\tconst char *oValue = NULL;\n\tbool firstit_for_versym = true;\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{\\\"versym\\\":[\");\n\t}\n\tfor (num_versym = 0;; num_versym++) {\n\t\tconst char *versym_path = sdb_fmt (format, \"versym\", num_versym);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, versym_path, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 addr = sdb_num_get (sdb, \"addr\", 0);\n\t\tut64 offset = sdb_num_get (sdb, \"offset\", 0);\n\t\tut64 link = sdb_num_get (sdb, \"link\", 0);\n\t\tut64 num_entries = sdb_num_get (sdb, \"num_entries\", 0);\n\t\tconst char *section_name = sdb_const_get (sdb, \"section_name\", 0);\n\t\tconst char *link_section_name = sdb_const_get (sdb, \"link_section_name\", 0);\n\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tif (!firstit_for_versym) { r_cons_printf (\",\"); }\n\t\t\tr_cons_printf (\"{\\\"section_name\\\":\\\"%s\\\",\\\"address\\\":%\"PFMT64u\",\\\"offset\\\":%\"PFMT64u\",\",\n\t\t\t\t\tsection_name, (ut64)addr, (ut64)offset);\n\t\t\tr_cons_printf (\"\\\"link\\\":%\"PFMT64u\",\\\"link_section_name\\\":\\\"%s\\\",\\\"entries\\\":[\",\n\t\t\t\t\t(ut32)link, link_section_name);\n\t\t} else {\n\t\t\tr_cons_printf (\"Version symbols section '%s' contains %\"PFMT64u\" entries:\\n\", section_name, num_entries);\n\t\t\tr_cons_printf (\" Addr: 0x%08\"PFMT64x\"  Offset: 0x%08\"PFMT64x\"  Link: %x (%s)\\n\",\n\t\t\t\t(ut64)addr, (ut64)offset, (ut32)link, link_section_name);\n\t\t}\n\t\tint i;\n\t\tfor (i = 0; i < num_entries; i++) {\n\t\t\tconst char *key = sdb_fmt (\"entry%d\", i);\n\t\t\tconst char *value = sdb_const_get (sdb, key, 0);\n\t\t\tif (value) {\n\t\t\t\tif (oValue && !strcmp (value, oValue)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\t\tif (i > 0) { r_cons_printf (\",\"); }\n\t\t\t\t\tchar *escaped_value = r_str_escape (value);\n\t\t\t\t\tr_cons_printf (\"{\\\"idx\\\":%\"PFMT64u\",\\\"value\\\":\\\"%s\\\"}\",\n\t\t\t\t\t\t\t(ut64) i, escaped_value);\n\t\t\t\t\tfree (escaped_value);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"  0x%08\"PFMT64x\": \", (ut64) i);\n\t\t\t\t\tr_cons_printf (\"%s\\n\", value);\n\t\t\t\t}\n\t\t\t\toValue = value;\n\t\t\t}\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"]}\");\n\t\t} else {\n\t\t\tr_cons_printf (\"\\n\\n\");\n\t\t}\n\t\tfirstit_for_versym = false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"],\\\"verneed\\\":[\");\n\t}\n\n\tbool firstit_dowhile_verneed = true;\n\tdo {\n\t\tchar *verneed_path = r_str_newf (format, \"verneed\", num_verneed++);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, verneed_path, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tif (!firstit_dowhile_verneed) {\n\t\t\t\tr_cons_printf (\",\");\n\t\t\t}\n\t\t\tr_cons_printf (\"{\\\"section_name\\\":\\\"%s\\\",\\\"address\\\":%\"PFMT64u\",\\\"offset\\\":%\"PFMT64u\",\",\n\t\t\t\tsdb_const_get (sdb, \"section_name\", 0), sdb_num_get (sdb, \"addr\", 0), sdb_num_get (sdb, \"offset\", 0));\n\t\t\tr_cons_printf (\"\\\"link\\\":%\"PFMT64u\",\\\"link_section_name\\\":\\\"%s\\\",\\\"entries\\\":[\",\n\t\t\t\tsdb_num_get (sdb, \"link\", 0), sdb_const_get (sdb, \"link_section_name\", 0));\n\t\t} else {\n\t\t\tr_cons_printf (\"Version need section '%s' contains %d entries:\\n\",\n\t\t\t\tsdb_const_get (sdb, \"section_name\", 0), (int)sdb_num_get (sdb, \"num_entries\", 0));\n\n\t\t\tr_cons_printf (\" Addr: 0x%08\"PFMT64x, sdb_num_get (sdb, \"addr\", 0));\n\n\t\t\tr_cons_printf (\"  Offset: 0x%08\"PFMT64x\"  Link to section: %\"PFMT64d\" (%s)\\n\",\n\t\t\t\tsdb_num_get (sdb, \"offset\", 0), sdb_num_get (sdb, \"link\", 0),\n\t\t\t\tsdb_const_get (sdb, \"link_section_name\", 0));\n\t\t}\n\t\tbool firstit_for_verneed = true;\n\t\tfor (num_version = 0;; num_version++) {\n\t\t\tconst char *filename = NULL;\n\t\t\tint num_vernaux = 0;\n\n\t\t\tchar *path_version = sdb_fmt (\"%s/version%d\", verneed_path, num_version);\n\t\t\tif (!(sdb = sdb_ns_path (r->sdb, path_version, 0))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tif (!firstit_for_verneed) { r_cons_printf (\",\"); }\n\t\t\t\tr_cons_printf (\"{\\\"idx\\\":%\"PFMT64u\",\\\"vn_version\\\":%d,\",\n\t\t\t\t\tsdb_num_get (sdb, \"idx\", 0), (int)sdb_num_get (sdb, \"vn_version\", 0));\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"  0x%08\"PFMT64x\": Version: %d\",\n\t\t\t\t\tsdb_num_get (sdb, \"idx\", 0), (int)sdb_num_get (sdb, \"vn_version\", 0));\n\t\t\t}\n\n\t\t\tif ((filename = sdb_const_get (sdb, \"file_name\", 0))) {\n\t\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\t\tchar *escaped_filename = r_str_escape (filename);\n\t\t\t\t\tr_cons_printf (\"\\\"file_name\\\":\\\"%s\\\",\", escaped_filename);\n\t\t\t\t\tfree (escaped_filename);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"  File: %s\", filename);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_printf (\"\\\"cnt\\\":%d,\", (int)sdb_num_get (sdb, \"cnt\", 0));\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"  Cnt: %d\\n\", (int)sdb_num_get (sdb, \"cnt\", 0));\n\t\t\t}\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_printf (\"\\\"vernaux\\\":[\");\n\t\t\t}\n\t\t\tbool firstit_dowhile_vernaux = true;\n\t\t\tdo {\n\t\t\t\tconst char *path_vernaux = sdb_fmt (\"%s/vernaux%d\", path_version, num_vernaux++);\n\t\t\t\tif (!(sdb = sdb_ns_path (r->sdb, path_vernaux, 0))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\t\tif (!firstit_dowhile_vernaux) { r_cons_printf (\",\"); }\n\t\t\t\t\tr_cons_printf (\"{\\\"idx\\\":%\"PFMT64u\",\\\"name\\\":\\\"%s\\\",\",\n\t\t\t\t\t\tsdb_num_get (sdb, \"idx\", 0), sdb_const_get (sdb, \"name\", 0));\n\t\t\t\t\tr_cons_printf (\"\\\"flags\\\":\\\"%s\\\",\\\"version\\\":%d}\",\n\t\t\t\t\t\tsdb_const_get (sdb, \"flags\", 0), (int)sdb_num_get (sdb, \"version\", 0));\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"  0x%08\"PFMT64x\":   Name: %s\",\n\t\t\t\t\t\tsdb_num_get (sdb, \"idx\", 0), sdb_const_get (sdb, \"name\", 0));\n\t\t\t\t\tr_cons_printf (\"  Flags: %s Version: %d\\n\",\n\t\t\t\t\t\tsdb_const_get (sdb, \"flags\", 0), (int)sdb_num_get (sdb, \"version\", 0));\n\t\t\t\t}\n\t\t\t\tfirstit_dowhile_vernaux = false;\n\t\t\t} while (sdb);\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_printf (\"]}\");\n\t\t\t}\n\t\t\tfirstit_for_verneed = false;\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"]}\");\n\t\t}\n\t\tfirstit_dowhile_verneed = false;\n\t\tfree (verneed_path);\n\t} while (sdb);\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]}\");\n\t}\n}\n\nstatic void bin_mach0_versioninfo(RCore *r) {\n\t/* TODO */\n}\n\nstatic void bin_pe_resources(RCore *r, int mode) {\n\tSdb *sdb = NULL;\n\tint index = 0;\n\tPJ *pj = NULL;\n\tconst char *pe_path = \"bin/cur/info/pe_resource\";\n\tif (!(sdb = sdb_ns_path (r->sdb, pe_path, 0))) {\n\t\treturn;\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_RESOURCES);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs resources\\n\");\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tpj = pj_new ();\n\t\tpj_a (pj);\n\t}\n\twhile (true) {\n\t\tconst char *timestrKey = sdb_fmt (\"resource.%d.timestr\", index);\n\t\tconst char *vaddrKey = sdb_fmt (\"resource.%d.vaddr\", index);\n\t\tconst char *sizeKey  = sdb_fmt (\"resource.%d.size\", index);\n\t\tconst char *typeKey  = sdb_fmt (\"resource.%d.type\", index);\n\t\tconst char *languageKey = sdb_fmt (\"resource.%d.language\", index);\n\t\tconst char *nameKey = sdb_fmt (\"resource.%d.name\", index);\n\t\tchar *timestr = sdb_get (sdb, timestrKey, 0);\n\t\tif (!timestr) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 vaddr = sdb_num_get (sdb, vaddrKey, 0);\n\t\tint size = (int)sdb_num_get (sdb, sizeKey, 0);\n\t\tchar *name = sdb_get (sdb, nameKey, 0);\n\t\tchar *type = sdb_get (sdb, typeKey, 0);\n\t\tchar *lang = sdb_get (sdb, languageKey, 0);\n\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tconst char *name = sdb_fmt (\"resource.%d\", index);\n\t\t\tr_flag_set (r->flags, name, vaddr, size);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"f resource.%d %d 0x%08\"PFMT32x\"\\n\", index, size, vaddr);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tpj_o (pj);\n\t\t\tpj_ks (pj, \"name\", name);\n\t\t\tpj_ki (pj, \"index\", index);\n\t\t\tpj_ks (pj, \"type\", type);\n\t\t\tpj_kn (pj, \"vaddr\", vaddr);\n\t\t\tpj_ki (pj, \"size\", size);\n\t\t\tpj_ks (pj, \"lang\", lang);\n\t\t\tpj_ks (pj, \"timestamp\", timestr);\n\t\t\tpj_end (pj);\n\t\t} else {\n\t\t\tchar humansz[8];\n\t\t\tr_num_units (humansz, sizeof (humansz), size);\n\t\t\tr_cons_printf (\"Resource %d\\n\", index);\n\t\t\tr_cons_printf (\"  name: %s\\n\", name);\n\t\t\tr_cons_printf (\"  timestamp: %s\\n\", timestr);\n\t\t\tr_cons_printf (\"  vaddr: 0x%08\"PFMT64x\"\\n\", vaddr);\n\t\t\tr_cons_printf (\"  size: %s\\n\", humansz);\n\t\t\tr_cons_printf (\"  type: %s\\n\", type);\n\t\t\tr_cons_printf (\"  language: %s\\n\", lang);\n\t\t}\n\n\t\tR_FREE (timestr);\n\t\tR_FREE (name);\n\t\tR_FREE (type);\n\t\tR_FREE (lang)\n\n\t\tindex++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tpj_end (pj);\n\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\tpj_free (pj);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs *\");\n\t}\n}\n\nstatic void bin_no_resources(RCore *r, int mode) {\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[]\");\n\t}\n}\n\nstatic int bin_resources(RCore *r, int mode) {\n\tconst RBinInfo *info = r_bin_get_info (r->bin);\n\tif (!info || !info->rclass) {\n\t\treturn false;\n\t}\n\tif (!strncmp (\"pe\", info->rclass, 2)) {\n\t\tbin_pe_resources (r, mode);\n\t} else {\n\t\tbin_no_resources (r, mode);\n\t}\n\treturn true;\n}\n\nstatic int bin_versioninfo(RCore *r, int mode) {\n\tconst RBinInfo *info = r_bin_get_info (r->bin);\n\tif (!info || !info->rclass) {\n\t\treturn false;\n\t}\n\tif (!strncmp (\"pe\", info->rclass, 2)) {\n\t\tbin_pe_versioninfo (r, mode);\n\t} else if (!strncmp (\"elf\", info->rclass, 3)) {\n\t\tbin_elf_versioninfo (r, mode);\n\t} else if (!strncmp (\"mach0\", info->rclass, 5)) {\n\t\tbin_mach0_versioninfo (r);\n\t} else {\n\t\tr_cons_println (\"Unknown format\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int bin_signature(RCore *r, int mode) {\n\tRBinFile *cur = r_bin_cur (r->bin);\n\tRBinPlugin *plg = r_bin_file_cur_plugin (cur);\n\tif (plg && plg->signature) {\n\t\tconst char *signature = plg->signature (cur, IS_MODE_JSON (mode));\n\t\tr_cons_println (signature);\n\t\tfree ((char*) signature);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API void r_core_bin_export_info_rad(RCore *core) {\n\tSdb *db = NULL;\n\tchar *flagname = NULL, *offset = NULL;\n\tRBinFile *bf = r_bin_cur (core->bin);\n\tif (!bf) {\n\t\treturn;\n\t}\n\tdb = sdb_ns (bf->sdb, \"info\", 0);;\n\tif (db) {\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tr_cons_printf (\"fs format\\n\");\n\t\t// iterate over all keys\n\t\tSdbList *ls = sdb_foreach_list (db, false);\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tchar *k = sdbkv_key (kv);\n\t\t\tchar *v = sdbkv_value (kv);\n\t\t\tchar *dup = strdup (k);\n\t\t\t//printf (\"?e (%s) (%s)\\n\", k, v);\n\t\t\tif ((flagname = strstr (dup, \".offset\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tflagname = dup;\n\t\t\t\tr_cons_printf (\"f %s @ %s\\n\", flagname, v);\n\t\t\t\tfree (offset);\n\t\t\t\toffset = strdup (v);\n\t\t\t}\n\t\t\tif ((flagname = strstr (dup, \".cparse\"))) {\n\t\t\t\tr_cons_printf (\"\\\"td %s\\\"\\n\", v);\n\t\t\t}\n\t\t\tfree (dup);\n\t\t}\n\t\tR_FREE (offset);\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tchar *k = sdbkv_key (kv);\n\t\t\tchar *v = sdbkv_value (kv);\n\t\t\tchar *dup = strdup (k);\n\t\t\tif ((flagname = strstr (dup, \".format\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tif (!offset) {\n\t\t\t\t\toffset = strdup (\"0\");\n\t\t\t\t}\n\t\t\t\tflagname = dup;\n\t\t\t\tr_cons_printf (\"pf.%s %s\\n\", flagname, v);\n\t\t\t}\n\t\t\tfree (dup);\n\t\t}\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tchar *k = sdbkv_key (kv);\n\t\t\tchar *v = sdbkv_value (kv);\n\t\t\tchar *dup = strdup (k);\n\t\t\tif ((flagname = strstr (dup, \".format\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tif (!offset) {\n\t\t\t\t\toffset = strdup (\"0\");\n\t\t\t\t}\n\t\t\t\tflagname = dup;\n\t\t\t\tint fmtsize = r_print_format_struct_size (core->print, v, 0, 0);\n\t\t\t\tchar *offset_key = r_str_newf (\"%s.offset\", flagname);\n\t\t\t\tconst char *off = sdb_const_get (db, offset_key, 0);\n\t\t\t\tfree (offset_key);\n\t\t\t\tif (off) {\n\t\t\t\t\tr_cons_printf (\"Cf %d %s @ %s\\n\", fmtsize, v, off);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((flagname = strstr (dup, \".size\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tflagname = dup;\n\t\t\t\tr_cons_printf (\"fl %s %s\\n\", flagname, v);\n\t\t\t}\n\t\t\tfree (dup);\n\t\t}\n\t\tfree (offset);\n\t}\n}\n\nstatic int bin_header(RCore *r, int mode) {\n\tRBinFile *cur = r_bin_cur (r->bin);\n\tRBinPlugin *plg = r_bin_file_cur_plugin (cur);\n\tif (plg && plg->header) {\n\t\tplg->header (cur);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_info(RCore *core, int action, int mode, int va, RCoreBinFilter *filter, const char *chksum) {\n\tint ret = true;\n\tconst char *name = NULL;\n\tut64 at = 0, loadaddr = r_bin_get_laddr (core->bin);\n\tif (filter && filter->offset) {\n\t\tat = filter->offset;\n\t}\n\tif (filter && filter->name) {\n\t\tname = filter->name;\n\t}\n\n\t// use our internal values for va\n\tva = va ? VA_TRUE : VA_FALSE;\n#if 0\n\tif (r_config_get_i (core->config, \"anal.strings\")) {\n\t\tr_core_cmd0 (core, \"aar\");\n\t}\n#endif\n\tif ((action & R_CORE_BIN_ACC_STRINGS)) {\n\t\tret &= bin_strings (core, mode, va);\n\t}\n\tif ((action & R_CORE_BIN_ACC_RAW_STRINGS)) {\n\t\tret &= bin_raw_strings (core, mode, va);\n\t}\n\tif ((action & R_CORE_BIN_ACC_INFO)) {\n\t\tret &= bin_info (core, mode, loadaddr);\n\t}\n\tif ((action & R_CORE_BIN_ACC_MAIN)) {\n\t\tret &= bin_main (core, mode, va);\n\t}\n\tif ((action & R_CORE_BIN_ACC_DWARF)) {\n\t\tret &= bin_dwarf (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_PDB)) {\n\t\tret &= bin_pdb (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_SOURCE)) {\n\t\tret &= bin_source (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_ENTRIES)) {\n\t\tret &= bin_entry (core, mode, loadaddr, va, false);\n\t}\n\tif ((action & R_CORE_BIN_ACC_INITFINI)) {\n\t\tret &= bin_entry (core, mode, loadaddr, va, true);\n\t}\n\tif ((action & R_CORE_BIN_ACC_SECTIONS)) {\n\t\tret &= bin_sections (core, mode, loadaddr, va, at, name, chksum, false);\n\t}\n\tif ((action & R_CORE_BIN_ACC_SEGMENTS)) {\n\t\tret &= bin_sections (core, mode, loadaddr, va, at, name, chksum, true);\n\t}\n\tif (r_config_get_i (core->config, \"bin.relocs\")) {\n\t\tif ((action & R_CORE_BIN_ACC_RELOCS)) {\n\t\t\tret &= bin_relocs (core, mode, va);\n\t\t}\n\t}\n\tif ((action & R_CORE_BIN_ACC_LIBS)) {\n\t\tret &= bin_libs (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_IMPORTS)) { // 5s\n\t\tret &= bin_imports (core, mode, va, name);\n\t}\n\tif ((action & R_CORE_BIN_ACC_EXPORTS)) {\n\t\tret &= bin_symbols (core, mode, loadaddr, va, at, name, true, chksum);\n\t}\n\tif ((action & R_CORE_BIN_ACC_SYMBOLS)) { // 6s\n\t\tret &= bin_symbols (core, mode, loadaddr, va, at, name, false, chksum);\n\t}\n\tif ((action & R_CORE_BIN_ACC_CLASSES)) { // 6s\n\t\tret &= bin_classes (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_TRYCATCH)) {\n\t\tret &= bin_trycatch (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_SIZE)) {\n\t\tret &= bin_size (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_MEM)) {\n\t\tret &= bin_mem (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_VERSIONINFO)) {\n\t\tret &= bin_versioninfo (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_RESOURCES)) {\n\t\tret &= bin_resources (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_SIGNATURE)) {\n\t\tret &= bin_signature (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_FIELDS)) {\n\t\tif (IS_MODE_SIMPLE (mode)) {\n\t\t\tif ((action & R_CORE_BIN_ACC_HEADER) || action & R_CORE_BIN_ACC_FIELDS) {\n\t\t\t\t/* ignore mode, just for quiet/simple here */\n\t\t\t\tret &= bin_fields (core, 0, va);\n\t\t\t}\n\t\t} else {\n\t\t\tif (IS_MODE_NORMAL (mode)) {\n\t\t\t\tret &= bin_header (core, mode);\n\t\t\t} else {\n\t\t\t\tif ((action & R_CORE_BIN_ACC_HEADER) || action & R_CORE_BIN_ACC_FIELDS) {\n\t\t\t\t\tret &= bin_fields (core, mode, va);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nR_API int r_core_bin_set_arch_bits(RCore *r, const char *name, const char * arch, ut16 bits) {\n\tint fd = r_io_fd_get_current (r->io);\n\tRIODesc *desc = r_io_desc_get (r->io, fd);\n\tRBinFile *curfile, *binfile = NULL;\n\tif (!name) {\n\t\tif (!desc || !desc->name) {\n\t\t\treturn false;\n\t\t}\n\t\tname = desc->name;\n\t}\n\t/* Check if the arch name is a valid name */\n\tif (!r_asm_is_valid (r->assembler, arch)) {\n\t\treturn false;\n\t}\n\t/* Find a file with the requested name/arch/bits */\n\tbinfile = r_bin_file_find_by_arch_bits (r->bin, arch, bits);\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (!r_bin_use_arch (r->bin, arch, bits, name)) {\n\t\treturn false;\n\t}\n\tcurfile = r_bin_cur (r->bin);\n\t//set env if the binfile changed or we are dealing with xtr\n\tif (curfile != binfile || binfile->curxtr) {\n\t\tr_core_bin_set_cur (r, binfile);\n\t\treturn r_core_bin_set_env (r, binfile);\n\t}\n\treturn true;\n}\n\nR_API int r_core_bin_update_arch_bits(RCore *r) {\n\tRBinFile *binfile = NULL;\n\tconst char *name = NULL, *arch = NULL;\n\tut16 bits = 0;\n\tif (!r) {\n\t\treturn 0;\n\t}\n\tif (r->assembler) {\n\t\tbits = r->assembler->bits;\n\t   \tif (r->assembler->cur) {\n\t\t\tarch = r->assembler->cur->arch;\n\t\t}\n\t}\n\tbinfile = r_bin_cur (r->bin);\n\tname = binfile ? binfile->file : NULL;\n\tif (binfile && binfile->curxtr) {\n\t\tr_anal_hint_clear (r->anal);\n\t}\n\treturn r_core_bin_set_arch_bits (r, name, arch, bits);\n}\n\nR_API bool r_core_bin_raise(RCore *core, ut32 bfid) {\n\tif (!r_bin_select_bfid (core->bin, bfid)) {\n\t\treturn false;\n\t}\n\tRBinFile *bf = r_bin_cur (core->bin);\n\tif (bf) {\n\t\tr_io_use_fd (core->io, bf->fd);\n\t}\n\t// it should be 0 to use r_io_use_fd in r_core_block_read\n\tcore->switch_file_view = 0;\n\treturn bf && r_core_bin_set_env (core, bf) && r_core_block_read (core);\n}\n\nR_API bool r_core_bin_delete(RCore *core, ut32 bf_id) {\n\tif (bf_id == UT32_MAX) {\n\t\treturn false;\n\t}\n#if 0\n\tif (!r_bin_object_delete (core->bin, bf_id)) {\n\t\treturn false;\n\t}\n// TODO: use rbinat()\n\tRBinFile *bf = r_bin_cur (core->bin);\n\tif (bf) {\n\t\tr_io_use_fd (core->io, bf->fd);\n\t}\n#endif\n\tr_bin_file_delete (core->bin, bf_id);\n\tRBinFile *bf = r_bin_file_at (core->bin, core->offset);\n\tif (bf) {\n\t\tr_io_use_fd (core->io, bf->fd);\n\t}\n\tcore->switch_file_view = 0;\n\treturn bf && r_core_bin_set_env (core, bf) && r_core_block_read (core);\n}\n\nstatic bool r_core_bin_file_print(RCore *core, RBinFile *bf, int mode) {\n\tr_return_val_if_fail (core && bf && bf->o, NULL);\n\tconst char *name = bf ? bf->file : NULL;\n\t(void)r_bin_get_info (core->bin); // XXX is this necssary for proper iniitialization\n\tut32 bin_sz = bf ? bf->size : 0;\n\t// TODO: handle mode to print in json and r2 commands\n\n\tswitch (mode) {\n\tcase '*':\n\t\t{\n\t\t\tchar *n = __filterShell (name);\n\t\t\tr_cons_printf (\"oba 0x%08\"PFMT64x\" %s # %d\\n\", bf->o->boffset, n, bf->id);\n\t\t\tfree (n);\n\t\t}\n\t\tbreak;\n\tcase 'q':\n\t\tr_cons_printf (\"%d\\n\", bf->id);\n\t\tbreak;\n\tcase 'j':\n\t\t// XXX there's only one binobj for each bf...so we should change that json\n\t\t// TODO: use pj API\n\t\tr_cons_printf (\"{\\\"name\\\":\\\"%s\\\",\\\"iofd\\\":%d,\\\"bfid\\\":%d,\\\"size\\\":%d,\\\"objs\\\":[\",\n\t\t\tname? name: \"\", bf->fd, bf->id, bin_sz);\n\t\t{\n\t\t\tRBinObject *obj = bf->o;\n\t\t\tRBinInfo *info = obj->info;\n\t\t\tut8 bits = info ? info->bits : 0;\n\t\t\tconst char *asmarch = r_config_get (core->config, \"asm.arch\");\n\t\t\tconst char *arch = info ? info->arch ? info->arch: asmarch : \"unknown\";\n\t\t\tr_cons_printf (\"{\\\"arch\\\":\\\"%s\\\",\\\"bits\\\":%d,\\\"binoffset\\\":%\"\n\t\t\t\t\tPFMT64d\",\\\"objsize\\\":%\"PFMT64d\"}\",\n\t\t\t\t\tarch, bits, obj->boffset, obj->obj_size);\n\t\t}\n\t\tr_cons_print (\"]}\");\n\t\tbreak;\n\tdefault:\n\t\t{\n\t\t\tRBinInfo *info = bf->o->info;\n\t\t\tut8 bits = info ? info->bits : 0;\n\t\t\tconst char *asmarch = r_config_get (core->config, \"asm.arch\");\n\t\t\tconst char *arch = info ? info->arch ? info->arch: asmarch: \"unknown\";\n\t\t\tr_cons_printf (\"%d %d %s-%d ba:0x%08\"PFMT64x\" sz:%\"PFMT64d\" %s\\n\",\n\t\t\t\tbf->id, bf->fd, arch, bits, bf->o->baddr, bf->o->size, name);\n\t\t}\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nR_API int r_core_bin_list(RCore *core, int mode) {\n\t// list all binfiles and there objects and there archs\n\tint count = 0;\n\tRListIter *iter;\n\tRBinFile *binfile = NULL; //, *cur_bf = r_bin_cur (core->bin) ;\n\tRBin *bin = core->bin;\n\tconst RList *binfiles = bin ? bin->binfiles: NULL;\n\tif (!binfiles) {\n\t\treturn false;\n\t}\n\tif (mode == 'j') {\n\t\tr_cons_print (\"[\");\n\t}\n\tr_list_foreach (binfiles, iter, binfile) {\n\t\tr_core_bin_file_print (core, binfile, mode);\n\t\tif (iter->n && mode == 'j') {\n\t\t\tr_cons_print (\",\");\n\t\t}\n\t}\n\tif (mode == 'j') {\n\t\tr_cons_println (\"]\");\n\t}\n\treturn count;\n}\n\nR_API char *r_core_bin_method_flags_str(ut64 flags, int mode) {\n\tint i, len = 0;\n\n\tRStrBuf *buf = r_strbuf_new (\"\");\n\tif (IS_MODE_SET (mode) || IS_MODE_RAD (mode)) {\n\t\tif (!flags) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tut64 flag = flags & (1ULL << i);\n\t\t\tif (flag) {\n\t\t\t\tconst char *flag_string = r_bin_get_meth_flag_string (flag, false);\n\t\t\t\tif (flag_string) {\n\t\t\t\t\tr_strbuf_appendf (buf, \".%s\", flag_string);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tif (!flags) {\n\t\t\tr_strbuf_append (buf, \"[]\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tr_strbuf_append (buf, \"[\");\n\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tut64 flag = flags & (1ULL << i);\n\t\t\tif (flag) {\n\t\t\t\tconst char *flag_string = r_bin_get_meth_flag_string (flag, false);\n\t\t\t\tif (len != 0) {\n\t\t\t\t\tr_strbuf_append (buf, \",\");\n\t\t\t\t}\n\t\t\t\tif (flag_string) {\n\t\t\t\t\tr_strbuf_appendf (buf, \"\\\"%s\\\"\", flag_string);\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (buf, \"\\\"0x%08\"PFMT64x\"\\\"\", flag);\n\t\t\t\t}\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\n\t\tr_strbuf_append (buf, \"]\");\n\t} else {\n\t\tint pad_len = 4; //TODO: move to a config variable\n\n\t\tif (!flags) {\n\t\t\tgoto padding;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tut64 flag = flags & (1ULL << i);\n\t\t\tif (flag) {\n\t\t\t\tconst char *flag_string = r_bin_get_meth_flag_string (flag, true);\n\t\t\t\tif (flag_string) {\n\t\t\t\t\tr_strbuf_append (buf, flag_string);\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_append (buf, \"?\");\n\t\t\t\t}\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\npadding:\n\t\tfor ( ; len < pad_len; len++) {\n\t\t\tr_strbuf_append (buf, \" \");\n\t\t}\n\t}\nout:\n\treturn r_strbuf_drain (buf);\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2011-2019 - earada, pancake */\n\n#include <r_core.h>\n#include <r_config.h>\n#include \"r_util.h\"\n#include \"r_util/r_time.h\"\n\n#define is_in_range(at, from, sz) ((at) >= (from) && (at) < ((from) + (sz)))\n\n#define VA_FALSE    0\n#define VA_TRUE     1\n#define VA_NOREBASE 2\n\n#define LOAD_BSS_MALLOC 0\n\n#define IS_MODE_SET(mode) ((mode) & R_MODE_SET)\n#define IS_MODE_SIMPLE(mode) ((mode) & R_MODE_SIMPLE)\n#define IS_MODE_SIMPLEST(mode) ((mode) & R_MODE_SIMPLEST)\n#define IS_MODE_JSON(mode) ((mode) & R_MODE_JSON)\n#define IS_MODE_RAD(mode) ((mode) & R_MODE_RADARE)\n#define IS_MODE_EQUAL(mode) ((mode) & R_MODE_EQUAL)\n#define IS_MODE_NORMAL(mode) (!(mode))\n#define IS_MODE_CLASSDUMP(mode) ((mode) & R_MODE_CLASSDUMP)\n\n// dup from cmd_info\n#define PAIR_WIDTH 9\n\n#define bprintf if (binfile && binfile->rbin && binfile->rbin->verbose) eprintf\n\nstatic void pair(const char *key, const char *val, int mode, bool last) {\n\tif (!val || !*val) {\n\t\treturn;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tconst char *lst = last ? \"\" : \",\";\n\t\tr_cons_printf (\"\\\"%s\\\":%s%s\", key, val, lst);\n\t} else {\n\t\tchar ws[16];\n\t\tconst int keyl = strlen (key);\n\t\tconst int wl = (keyl > PAIR_WIDTH) ? 0 : PAIR_WIDTH - keyl;\n\t\tmemset (ws, ' ', wl);\n\t\tws[wl] = 0;\n\t\tr_cons_printf (\"%s%s%s\\n\", key, ws, val);\n\t}\n}\n\nstatic void pair_bool(const char *key, bool val, int mode, bool last) {\n\tpair (key, r_str_bool (val), mode, last);\n}\n\nstatic void pair_int(const char *key, int val, int mode, bool last) {\n\tpair (key, sdb_fmt (\"%d\", val), mode, last);\n}\n\nstatic void pair_ut64(const char *key, ut64 val, int mode, bool last) {\n\tpair (key, sdb_fmt (\"%\"PFMT64d, val), mode, last);\n}\n\nstatic char *__filterQuotedShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tswitch (*arg) {\n\t\tcase ' ':\n\t\tcase '=':\n\t\tcase '\"':\n\t\tcase '\\\\':\n\t\tcase '\\r':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = *arg;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}\n// TODO: move into libr/util/name.c\nstatic char *__filterShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tchar ch = *arg;\n\t\tswitch (ch) {\n\t\tcase '@':\n\t\tcase '`':\n\t\tcase '|':\n\t\tcase ';':\n\t\tcase '=':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = ch;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}\n\nstatic void pair_ut64x(const char *key, ut64 val, int mode, bool last) {\n\tconst char *str_val = IS_MODE_JSON (mode) ? sdb_fmt (\"%\"PFMT64d, val) : sdb_fmt (\"0x%\"PFMT64x, val);\n\tpair (key, str_val, mode, last);\n}\n\nstatic void pair_str(const char *key, const char *val, int mode, int last) {\n\tif (IS_MODE_JSON (mode)) {\n\t\tif (!val) {\n\t\t\tval = \"\";\n\t\t}\n\t\tchar *encval = r_str_escape_utf8_for_json (val, -1);\n\t\tif (encval) {\n\t\t\tchar *qs = r_str_newf (\"\\\"%s\\\"\", encval);\n\t\t\tpair (key, qs, mode, last);\n\t\t\tfree (encval);\n\t\t\tfree (qs);\n\t\t}\n\t} else {\n\t\tpair (key, val, mode, last);\n\t}\n}\n\n#define STR(x) (x)? (x): \"\"\nR_API int r_core_bin_set_cur(RCore *core, RBinFile *binfile);\n\nstatic ut64 rva(RBin *bin, ut64 paddr, ut64 vaddr, int va) {\n\tif (va == VA_TRUE) {\n\t\tif (paddr != UT64_MAX) {\n\t\t\treturn r_bin_get_vaddr (bin, paddr, vaddr);\n\t\t}\n\t}\n\tif (va == VA_NOREBASE) {\n\t\treturn vaddr;\n\t}\n\treturn paddr;\n}\n\nR_API int r_core_bin_set_by_fd(RCore *core, ut64 bin_fd) {\n\tif (r_bin_file_set_cur_by_fd (core->bin, bin_fd)) {\n\t\tr_core_bin_set_cur (core, r_bin_cur (core->bin));\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_set_by_name(RCore *core, const char * name) {\n\tif (r_bin_file_set_cur_by_name (core->bin, name)) {\n\t\tr_core_bin_set_cur (core, r_bin_cur (core->bin));\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_set_env(RCore *r, RBinFile *binfile) {\n\tr_return_val_if_fail (r, false);\n\n\tRBinObject *binobj = binfile? binfile->o: NULL;\n\tRBinInfo *info = binobj? binobj->info: NULL;\n\tif (info) {\n\t\tint va = info->has_va;\n\t\tconst char *arch = info->arch;\n\t\tut16 bits = info->bits;\n\t\tut64 baseaddr = r_bin_get_baddr (r->bin);\n\t\tr_config_set_i (r->config, \"bin.baddr\", baseaddr);\n\t\tsdb_num_add (r->sdb, \"orig_baddr\", baseaddr, 0);\n\t\tr_config_set (r->config, \"asm.arch\", arch);\n\t\tr_config_set_i (r->config, \"asm.bits\", bits);\n\t\tr_config_set (r->config, \"anal.arch\", arch);\n\t\tif (info->cpu && *info->cpu) {\n\t\t\tr_config_set (r->config, \"anal.cpu\", info->cpu);\n\t\t} else {\n\t\t\tr_config_set (r->config, \"anal.cpu\", arch);\n\t\t}\n\t\tr_asm_use (r->assembler, arch);\n\t\tr_core_bin_info (r, R_CORE_BIN_ACC_ALL, R_MODE_SET, va, NULL, NULL);\n\t\tr_core_bin_set_cur (r, binfile);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_set_cur(RCore *core, RBinFile *binfile) {\n\tif (!core->bin) {\n\t\treturn false;\n\t}\n\tif (!binfile) {\n\t\t// Find first available binfile\n\t\tut32 fd = r_core_file_cur_fd (core);\n\t\tbinfile = fd != (ut32)-1\n\t\t\t\t  ? r_bin_file_find_by_fd (core->bin, fd)\n\t\t\t\t  : NULL;\n\t\tif (!binfile) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tr_bin_file_set_cur_binfile (core->bin, binfile);\n\treturn true;\n}\n\nR_API int r_core_bin_refresh_strings(RCore *r) {\n\treturn r_bin_reset_strings (r->bin)? true: false;\n}\n\nstatic void _print_strings(RCore *r, RList *list, int mode, int va) {\n\tbool b64str = r_config_get_i (r->config, \"bin.b64str\");\n\tint minstr = r_config_get_i (r->config, \"bin.minstr\");\n\tint maxstr = r_config_get_i (r->config, \"bin.maxstr\");\n\tRBin *bin = r->bin;\n\tRBinObject *obj = r_bin_cur_object (bin);\n\tRListIter *iter;\n\tRListIter *last_processed = NULL;\n\tRBinString *string;\n\tRBinSection *section;\n\tchar *q;\n\n\tbin->minstrlen = minstr;\n\tbin->maxstrlen = maxstr;\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[\");\n\t}\n\tif (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs strings\");\n\t}\n\tif (IS_MODE_SET (mode) && r_config_get_i (r->config, \"bin.strings\")) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_STRINGS);\n\t\tr_cons_break_push (NULL, NULL);\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"[Strings]\\n\");\n\t\tr_cons_printf (\"Num Paddr      Vaddr      Len Size Section  Type  String\\n\");\n\t}\n\tRBinString b64 = { 0 };\n\tr_list_foreach (list, iter, string) {\n\t\tconst char *section_name, *type_string;\n\t\tut64 paddr, vaddr;\n\t\tpaddr = string->paddr;\n\t\tvaddr = rva (r->bin, paddr, string->vaddr, va);\n\t\tif (!r_bin_string_filter (bin, string->string, vaddr)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (string->length < minstr) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (maxstr && string->length > maxstr) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsection = obj? r_bin_get_section_at (obj, paddr, 0): NULL;\n\t\tsection_name = section ? section->name : \"\";\n\t\ttype_string = r_bin_string_type (string->type);\n\t\tif (b64str) {\n\t\t\tut8 *s = r_base64_decode_dyn (string->string, -1);\n\t\t\tif (s && *s && IS_PRINTABLE (*s)) {\n\t\t\t\t// TODO: add more checks\n\t\t\t\tfree (b64.string);\n\t\t\t\tmemcpy (&b64, string, sizeof (b64));\n\t\t\t\tb64.string = (char *)s;\n\t\t\t\tb64.size = strlen (b64.string);\n\t\t\t\tstring = &b64;\n\t\t\t}\n\t\t}\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tchar *f_name, *f_realname, *str;\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_meta_add (r->anal, R_META_TYPE_STRING, vaddr, vaddr + string->size, string->string);\n\t\t\tf_name = strdup (string->string);\n\t\t\tr_name_filter (f_name, -1);\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tstr = r_str_newf (\"%s.str.%s\", r->bin->prefix, f_name);\n\t\t\t\tf_realname = r_str_newf (\"%s.\\\"%s\\\"\", r->bin->prefix, string->string);\n\t\t\t} else {\n\t\t\t\tstr = r_str_newf (\"str.%s\", f_name);\n\t\t\t\tf_realname = r_str_newf (\"\\\"%s\\\"\", string->string);\n\t\t\t}\n\t\t\tRFlagItem *flag = r_flag_set (r->flags, str, vaddr, string->size);\n\t\t\tr_flag_item_set_realname (flag, f_realname);\n\t\t\tfree (str);\n\t\t\tfree (f_name);\n\t\t\tfree (f_realname);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%\"PFMT64x\" %d %d %s\\n\", vaddr,\n\t\t\t\tstring->size, string->length, string->string);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tr_cons_println (string->string);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tint *block_list;\n\t\t\tq = r_base64_encode_dyn (string->string, -1);\n\t\t\tr_cons_printf (\"%s{\\\"vaddr\\\":%\"PFMT64u\n\t\t\t\t\",\\\"paddr\\\":%\"PFMT64u\",\\\"ordinal\\\":%d\"\n\t\t\t\t\",\\\"size\\\":%d,\\\"length\\\":%d,\\\"section\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\\\"string\\\":\\\"%s\\\"\",\n\t\t\t\tlast_processed ? \",\": \"\",\n\t\t\t\tvaddr, paddr, string->ordinal, string->size,\n\t\t\t\tstring->length, section_name, type_string, q);\n\t\t\tswitch (string->type) {\n\t\t\tcase R_STRING_TYPE_UTF8:\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tblock_list = r_utf_block_list ((const ut8*)string->string, -1, NULL);\n\t\t\t\tif (block_list) {\n\t\t\t\t\tif (block_list[0] == 0 && block_list[1] == -1) {\n\t\t\t\t\t\t/* Don't include block list if\n\t\t\t\t\t\t   just Basic Latin (0x00 - 0x7F) */\n\t\t\t\t\t\tR_FREE (block_list);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint *block_ptr = block_list;\n\t\t\t\t\tr_cons_printf (\",\\\"blocks\\\":[\");\n\t\t\t\t\tfor (; *block_ptr != -1; block_ptr++) {\n\t\t\t\t\t\tif (block_ptr != block_list) {\n\t\t\t\t\t\t\tr_cons_printf (\",\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst char *utfName = r_utf_block_name (*block_ptr);\n\t\t\t\t\t\tr_cons_printf (\"\\\"%s\\\"\", utfName? utfName: \"\");\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"]\");\n\t\t\t\t\tR_FREE (block_list);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"}\");\n\t\t\tfree (q);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tchar *f_name = strdup (string->string);\n\t\t\tr_name_filter (f_name, R_FLAG_NAME_SIZE);\n\t\t\tchar *str = (r->bin->prefix)\n\t\t\t\t? r_str_newf (\"%s.str.%s\", r->bin->prefix, f_name)\n\t\t\t\t: r_str_newf (\"str.%s\", f_name);\n\t\t\tr_cons_printf (\"f %s %\"PFMT64d\" 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\"Cs %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\tstr, string->size, vaddr,\n\t\t\t\tstring->size, vaddr);\n\t\t\tfree (str);\n\t\t\tfree (f_name);\n\t\t} else {\n\t\t\tint *block_list;\n\t\t\tchar *str = string->string;\n\t\t\tchar *no_dbl_bslash_str = NULL;\n\t\t\tif (!r->print->esc_bslash) {\n\t\t\t\tchar *ptr;\n\t\t\t\tfor (ptr = str; *ptr; ptr++) {\n\t\t\t\t\tif (*ptr != '\\\\') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (*(ptr + 1) == '\\\\') {\n\t\t\t\t\t\tif (!no_dbl_bslash_str) {\n\t\t\t\t\t\t\tno_dbl_bslash_str = strdup (str);\n\t\t\t\t\t\t\tif (!no_dbl_bslash_str) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tptr = no_dbl_bslash_str + (ptr - str);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemmove (ptr + 1, ptr + 2, strlen (ptr + 2) + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (no_dbl_bslash_str) {\n\t\t\t\t\tstr = no_dbl_bslash_str;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"%03u 0x%08\" PFMT64x \" 0x%08\" PFMT64x \" %3u %3u (%s) %5s %s\",\n\t\t\t\tstring->ordinal, paddr, vaddr,\n\t\t\t\tstring->length, string->size,\n\t\t\t\tsection_name, type_string, str);\n\t\t\tif (str == no_dbl_bslash_str) {\n\t\t\t\tR_FREE (str);\n\t\t\t}\n\t\t\tswitch (string->type) {\n\t\t\tcase R_STRING_TYPE_UTF8:\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tblock_list = r_utf_block_list ((const ut8*)string->string, -1, NULL);\n\t\t\t\tif (block_list) {\n\t\t\t\t\tif (block_list[0] == 0 && block_list[1] == -1) {\n\t\t\t\t\t\t/* Don't show block list if\n\t\t\t\t\t\t   just Basic Latin (0x00 - 0x7F) */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint *block_ptr = block_list;\n\t\t\t\t\tr_cons_printf (\" blocks=\");\n\t\t\t\t\tfor (; *block_ptr != -1; block_ptr++) {\n\t\t\t\t\t\tif (block_ptr != block_list) {\n\t\t\t\t\t\t\tr_cons_printf (\",\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst char *name = r_utf_block_name (*block_ptr);\n\t\t\t\t\t\tr_cons_printf (\"%s\", name? name: \"\");\n\t\t\t\t\t}\n\t\t\t\t\tfree (block_list);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_cons_printf (\"\\n\");\n\t\t}\n\t\tlast_processed = iter;\n\t}\n\tR_FREE (b64.string);\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tr_cons_break_pop ();\n\t}\n}\n\nstatic bool bin_raw_strings(RCore *r, int mode, int va) {\n\tRBinFile *bf = r_bin_cur (r->bin);\n\tbool new_bf = false;\n\tif (bf && strstr (bf->file, \"malloc://\")) {\n\t\t//sync bf->buf to search string on it\n\t\tut8 *tmp = R_NEWS (ut8, bf->size);\n\t\tif (!tmp) {\n\t\t\treturn false;\n\t\t}\n\t\tr_io_read_at (r->io, 0, tmp, bf->size);\n\t\tr_buf_write_at (bf->buf, 0, tmp, bf->size);\n\t}\n\tif (!r->file) {\n\t\teprintf (\"Core file not open\\n\");\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_print (\"[]\");\n\t\t}\n\t\treturn false;\n\t}\n\tif (!bf) {\n\t\tbf = R_NEW0 (RBinFile);\n\t\tif (!bf) {\n\t\t\treturn false;\n\t\t}\n\t\tRIODesc *desc = r_io_desc_get (r->io, r->file->fd);\n\t\tif (!desc) {\n\t\t\tfree (bf);\n\t\t\treturn false;\n\t\t}\n\t\tbf->file = strdup (desc->name);\n\t\tbf->size = r_io_desc_size (desc);\n\t\tif (bf->size == UT64_MAX) {\n\t\t\tfree (bf);\n\t\t\treturn false;\n\t\t}\n\t\tbf->buf = r_buf_new_with_io (&r->bin->iob, r->file->fd);\n\t\tbf->o = NULL;\n\t\tbf->rbin = r->bin;\n\t\tnew_bf = true;\n\t\tva = false;\n\t}\n\tRList *l = r_bin_raw_strings (bf, 0);\n\t_print_strings (r, l, mode, va);\n\tr_list_free (l);\n\tif (new_bf) {\n\t\tr_buf_free (bf->buf);\n\t\tbf->buf = NULL;\n\t\tbf->id = -1;\n\t\tr_bin_file_free (bf);\n\t}\n\treturn true;\n}\n\nstatic bool bin_strings(RCore *r, int mode, int va) {\n\tRList *list;\n\tRBinFile *binfile = r_bin_cur (r->bin);\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (binfile);\n\tint rawstr = r_config_get_i (r->config, \"bin.rawstr\");\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (!r_config_get_i (r->config, \"bin.strings\")) {\n\t\treturn false;\n\t}\n\tif (!plugin) {\n\t\treturn false;\n\t}\n\tif (plugin->info && plugin->name) {\n\t\tif (strcmp (plugin->name, \"any\") == 0 && !rawstr) {\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_print(\"[]\");\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!(list = r_bin_get_strings (r->bin))) {\n\t\treturn false;\n\t}\n\t_print_strings (r, list, mode, va);\n\treturn true;\n}\n\nstatic const char* get_compile_time(Sdb *binFileSdb) {\n\tSdb *info_ns = sdb_ns (binFileSdb, \"info\", false);\n\tconst char *timeDateStamp_string = sdb_const_get (info_ns,\n\t\t\"image_file_header.TimeDateStamp_string\", 0);\n\treturn timeDateStamp_string;\n}\n\nstatic bool is_executable(RBinObject *obj) {\n\tRListIter *it;\n\tRBinSection* sec;\n\tr_return_val_if_fail (obj, false);\n\tif (obj->info && obj->info->arch) {\n\t\treturn true;\n\t}\n\tr_list_foreach (obj->sections, it, sec) {\n\t\tif (sec->perm & R_PERM_X) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void sdb_concat_by_path(Sdb *s, const char *path) {\n\tSdb *db = sdb_new (0, path, 0);\n\tsdb_merge (s, db);\n\tsdb_close (db);\n\tsdb_free (db);\n}\n\nR_API void r_core_anal_type_init(RCore *core) {\n\tr_return_if_fail (core && core->anal);\n\tconst char *dir_prefix = r_config_get (core->config, \"dir.prefix\");\n\tint bits = core->assembler->bits;\n\tSdb *types = core->anal->sdb_types;\n\t// make sure they are empty this is initializing\n\tsdb_reset (types);\n\tconst char *anal_arch = r_config_get (core->config, \"anal.arch\");\n\tconst char *os = r_config_get (core->config, \"asm.os\");\n\t// spaguetti ahead\n\n\tconst char *dbpath = sdb_fmt (R_JOIN_3_PATHS (\"%s\", R2_SDB_FCNSIGN, \"types.sdb\"), dir_prefix);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (R_JOIN_3_PATHS (\"%s\", R2_SDB_FCNSIGN, \"types-%s.sdb\"),\n\t\tdir_prefix, anal_arch);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (R_JOIN_3_PATHS (\"%s\", R2_SDB_FCNSIGN, \"types-%s.sdb\"),\n\t\tdir_prefix, os);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (R_JOIN_3_PATHS (\"%s\", R2_SDB_FCNSIGN, \"types-%d.sdb\"),\n\t\tdir_prefix, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (R_JOIN_3_PATHS (\"%s\", R2_SDB_FCNSIGN, \"types-%s-%d.sdb\"),\n\t\tdir_prefix, os, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (R_JOIN_3_PATHS (\"%s\", R2_SDB_FCNSIGN, \"types-%s-%d.sdb\"),\n\t\tdir_prefix, anal_arch, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (R_JOIN_3_PATHS (\"%s\", R2_SDB_FCNSIGN, \"types-%s-%s.sdb\"),\n\t\tdir_prefix, anal_arch, os);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (R_JOIN_3_PATHS (\"%s\", R2_SDB_FCNSIGN, \"types-%s-%s-%d.sdb\"),\n\t\tdir_prefix, anal_arch, os, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n}\n\nstatic int save_ptr(void *p, const char *k, const char *v) {\n\tSdb *sdbs[2];\n\tsdbs[0] = ((Sdb**) p)[0];\n\tsdbs[1] = ((Sdb**) p)[1];\n\tif (!strncmp (v, \"cc\", strlen (\"cc\") + 1)) {\n\t\tconst char *x = sdb_const_get (sdbs[1], sdb_fmt (\"cc.%s.name\", k), 0);\n\t\tchar *tmp = sdb_fmt (\"%p\", x);\n\t\tsdb_set (sdbs[0], tmp, x, 0);\n\t}\n\treturn 1;\n}\n\nR_API void r_core_anal_cc_init(RCore *core) {\n\tSdb *sdbs[2] = {\n\t\tsdb_new0 (),\n\t\tcore->anal->sdb_cc\n\t};\n\tconst char *dir_prefix = r_config_get (core->config, \"dir.prefix\");\n\t//save pointers and values stored inside them\n\t//to recover from freeing heeps\n\tconst char *defaultcc = sdb_const_get (sdbs[1], \"default.cc\", 0);\n\tsdb_set (sdbs[0], sdb_fmt (\"0x%08\"PFMT64x, r_num_get (NULL, defaultcc)), defaultcc, 0);\n\tsdb_foreach (core->anal->sdb_cc, save_ptr, sdbs);\n\tsdb_reset (core->anal->sdb_cc);\n\tconst char *anal_arch = r_config_get (core->config, \"anal.arch\");\n\n\tint bits = core->anal->bits;\n\tchar *dbpath = sdb_fmt (\"%s/\"R2_SDB_FCNSIGN\"/cc-%s-%d.sdb\", dir_prefix, anal_arch, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (core->anal->sdb_cc, dbpath);\n\t}\n\t//restore all freed CC or replace with new default cc\n\tRListIter *it;\n\tRAnalFunction *fcn;\n\tr_list_foreach (core->anal->fcns, it, fcn) {\n\t\tconst char *cc = NULL;\n\t\tif (fcn->cc) {\n\t\t\tchar *ptr = sdb_fmt (\"%p\", fcn->cc);\n\t\t\tcc = sdb_const_get (sdbs[0], ptr, 0);\n\t\t}\n\t\tif  (!cc) {\n\t\t\tcc = r_anal_cc_default (core->anal);\n\t\t}\n\t\tfcn->cc = r_str_const (cc);\n\t}\n\tsdb_close (sdbs[0]);\n\tsdb_free (sdbs[0]);\n}\n\nstatic int bin_info(RCore *r, int mode, ut64 laddr) {\n\tint i, j, v;\n\tchar str[R_FLAG_NAME_SIZE];\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRBinFile *bf = r_bin_cur (r->bin);\n\tif (!bf) {\n\t\treturn false;\n\t}\n\tRBinObject *obj = bf->o;\n\tconst char *compiled = NULL;\n\tbool havecode;\n\n\tif (!bf || !info || !obj) {\n\t\tif (mode & R_MODE_JSON) {\n\t\t\tr_cons_printf (\"{}\");\n\t\t}\n\t\treturn false;\n\t}\n\thavecode = is_executable (obj) | (obj->entries != NULL);\n\tcompiled = get_compile_time (bf->sdb);\n\n\tif (IS_MODE_SET (mode)) {\n\t\tr_config_set (r->config, \"file.type\", info->rclass);\n\t\tr_config_set (r->config, \"cfg.bigendian\",\n\t\t\t      info->big_endian ? \"true\" : \"false\");\n\t\tif (info->rclass && !strcmp (info->rclass, \"fs\")) {\n\t\t\t// r_config_set (r->config, \"asm.arch\", info->arch);\n\t\t\t// r_core_seek (r, 0, 1);\n\t\t\t// eprintf (\"m /root %s 0\", info->arch);\n\t//\t\tr_core_cmdf (r, \"m /root hfs @ 0\", info->arch);\n\t\t} else {\n\t\t\tif (info->lang) {\n\t\t\t\tr_config_set (r->config, \"bin.lang\", info->lang);\n\t\t\t}\n\t\t\tr_config_set (r->config, \"asm.os\", info->os);\n\t\t\tif (info->rclass && !strcmp (info->rclass, \"pe\")) {\n\t\t\t\tr_config_set (r->config, \"anal.cpp.abi\", \"msvc\");\n\t\t\t} else {\n\t\t\t\tr_config_set (r->config, \"anal.cpp.abi\", \"itanium\");\n\t\t\t}\n\t\t\tr_config_set (r->config, \"asm.arch\", info->arch);\n\t\t\tif (info->cpu && *info->cpu) {\n\t\t\t\tr_config_set (r->config, \"asm.cpu\", info->cpu);\n\t\t\t}\n\t\t\tr_config_set (r->config, \"anal.arch\", info->arch);\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"%i\", info->bits);\n\t\t\tr_config_set (r->config, \"asm.bits\", str);\n\t\t\tr_config_set (r->config, \"asm.dwarf\",\n\t\t\t\t(R_BIN_DBG_STRIPPED & info->dbg_info) ? \"false\" : \"true\");\n\t\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\t\tif (v != -1) {\n\t\t\t\tr_config_set_i (r->config, \"asm.pcalign\", v);\n\t\t\t}\n\t\t}\n\t\tr_core_anal_type_init (r);\n\t\tr_core_anal_cc_init (r);\n\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\tr_cons_printf (\"arch %s\\n\", info->arch);\n\t\tif (info->cpu && *info->cpu) {\n\t\t\tr_cons_printf (\"cpu %s\\n\", info->cpu);\n\t\t}\n\t\tr_cons_printf (\"bits %d\\n\", info->bits);\n\t\tr_cons_printf (\"os %s\\n\", info->os);\n\t\tr_cons_printf (\"endian %s\\n\", info->big_endian? \"big\": \"little\");\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tr_cons_printf (\"minopsz %d\\n\", v);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tr_cons_printf (\"maxopsz %d\\n\", v);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\tif (v != -1) {\n\t\t\tr_cons_printf (\"pcalign %d\\n\", v);\n\t\t}\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tif (info->type && !strcmp (info->type, \"fs\")) {\n\t\t\tr_cons_printf (\"e file.type=fs\\n\");\n\t\t\tr_cons_printf (\"m /root %s 0\\n\", info->arch);\n\t\t} else {\n\t\t\tr_cons_printf (\"e cfg.bigendian=%s\\n\"\n\t\t\t\t\"e asm.bits=%i\\n\"\n\t\t\t\t\"e asm.dwarf=%s\\n\",\n\t\t\t\tr_str_bool (info->big_endian),\n\t\t\t\tinfo->bits,\n\t\t\t\tr_str_bool (R_BIN_DBG_STRIPPED &info->dbg_info));\n\t\t\tif (info->lang && *info->lang) {\n\t\t\t\tr_cons_printf (\"e bin.lang=%s\\n\", info->lang);\n\t\t\t}\n\t\t\tif (info->rclass && *info->rclass) {\n\t\t\t\tr_cons_printf (\"e file.type=%s\\n\",\n\t\t\t\t\tinfo->rclass);\n\t\t\t}\n\t\t\tif (info->os) {\n\t\t\t\tr_cons_printf (\"e asm.os=%s\\n\", info->os);\n\t\t\t}\n\t\t\tif (info->arch) {\n\t\t\t\tr_cons_printf (\"e asm.arch=%s\\n\", info->arch);\n\t\t\t}\n\t\t\tif (info->cpu && *info->cpu) {\n\t\t\t\tr_cons_printf (\"e asm.cpu=%s\\n\", info->cpu);\n\t\t\t}\n\t\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\t\tif (v != -1) {\n\t\t\t\tr_cons_printf (\"e asm.pcalign=%d\\n\", v);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// XXX: if type is 'fs' show something different?\n\t\tchar *tmp_buf;\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"{\");\n\t\t}\n\t\tpair_str (\"arch\", info->arch, mode, false);\n\t\tif (info->cpu && *info->cpu) {\n\t\t\tpair_str (\"cpu\", info->cpu, mode, false);\n\t\t}\n\t\tpair_ut64x (\"baddr\", r_bin_get_baddr (r->bin), mode, false);\n\t\tpair_ut64 (\"binsz\", r_bin_get_size (r->bin), mode, false);\n\t\tpair_str (\"bintype\", info->rclass, mode, false);\n\t\tpair_int (\"bits\", info->bits, mode, false);\n\t\tpair_bool (\"canary\", info->has_canary, mode, false);\n\t\tif (info->has_retguard != -1) {\n\t\t\tpair_bool (\"retguard\", info->has_retguard, mode, false);\n\t\t}\n\t\tpair_str (\"class\", info->bclass, mode, false);\n\t\tif (info->actual_checksum) {\n\t\t\t/* computed checksum */\n\t\t\tpair_str (\"cmp.csum\", info->actual_checksum, mode, false);\n\t\t}\n\t\tpair_str (\"compiled\", compiled, mode, false);\n\t\tpair_str (\"compiler\", info->compiler, mode, false);\n\t\tpair_bool (\"crypto\", info->has_crypto, mode, false);\n\t\tpair_str (\"dbg_file\", info->debug_file_name, mode, false);\n\t\tpair_str (\"endian\", info->big_endian ? \"big\" : \"little\", mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"mdmp\")) {\n\t\t\ttmp_buf = sdb_get (bf->sdb, \"mdmp.flags\", 0);\n\t\t\tif (tmp_buf) {\n\t\t\t\tpair_str (\"flags\", tmp_buf, mode, false);\n\t\t\t\tfree (tmp_buf);\n\t\t\t}\n\t\t}\n\t\tpair_bool (\"havecode\", havecode, mode, false);\n\t\tif (info->claimed_checksum) {\n\t\t\t/* checksum specified in header */\n\t\t\tpair_str (\"hdr.csum\", info->claimed_checksum, mode, false);\n\t\t}\n\t\tpair_str (\"guid\", info->guid, mode, false);\n\t\tpair_str (\"intrp\", info->intrp, mode, false);\n\t\tpair_ut64x (\"laddr\", laddr, mode, false);\n\t\tpair_str (\"lang\", info->lang, mode, false);\n\t\tpair_bool (\"linenum\", R_BIN_DBG_LINENUMS & info->dbg_info, mode, false);\n\t\tpair_bool (\"lsyms\", R_BIN_DBG_SYMS & info->dbg_info, mode, false);\n\t\tpair_str (\"machine\", info->machine, mode, false);\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tpair_int (\"maxopsz\", v, mode, false);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tpair_int (\"minopsz\", v, mode, false);\n\t\t}\n\t\tpair_bool (\"nx\", info->has_nx, mode, false);\n\t\tpair_str (\"os\", info->os, mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"pe\")) {\n\t\t\tpair_bool (\"overlay\", info->pe_overlay, mode, false);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\tif (v != -1) {\n\t\t\tpair_int (\"pcalign\", v, mode, false);\n\t\t}\n\t\tpair_bool (\"pic\", info->has_pi, mode, false);\n\t\tpair_bool (\"relocs\", R_BIN_DBG_RELOCS & info->dbg_info, mode, false);\n\t\tSdb *sdb_info = sdb_ns (obj->kv, \"info\", false);\n\t\ttmp_buf = sdb_get (sdb_info, \"elf.relro\", 0);\n\t\tif (tmp_buf) {\n\t\t\tpair_str (\"relro\", tmp_buf, mode, false);\n\t\t\tfree (tmp_buf);\n\t\t}\n\t\tpair_str (\"rpath\", info->rpath, mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"pe\")) {\n\t\t\t//this should be moved if added to mach0 (or others)\n\t\t\tpair_bool (\"signed\", info->signature, mode, false);\n\t\t}\n\t\tpair_bool (\"sanitiz\", info->has_sanitizers, mode, false);\n\t\tpair_bool (\"static\", r_bin_is_static (r->bin), mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"mdmp\")) {\n\t\t\tv = sdb_num_get (bf->sdb, \"mdmp.streams\", 0);\n\t\t\tif (v != -1) {\n\t\t\t\tpair_int (\"streams\", v, mode, false);\n\t\t\t}\n\t\t}\n\t\tpair_bool (\"stripped\", R_BIN_DBG_STRIPPED & info->dbg_info, mode, false);\n\t\tpair_str (\"subsys\", info->subsystem, mode, false);\n\t\tpair_bool (\"va\", info->has_va, mode, true);\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\",\\\"checksums\\\":{\");\n\t\t\tfor (i = 0; info->sum[i].type; i++) {\n\t\t\t\tRBinHash *h = &info->sum[i];\n\t\t\t\tut64 hash = r_hash_name_to_bits (h->type);\n\t\t\t\tRHash *rh = r_hash_new (true, hash);\n\t\t\t\tut8 *tmp = R_NEWS (ut8, h->to);\n\t\t\t\tif (!tmp) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tr_buf_read_at (bf->buf, h->from, tmp, h->to);\n\t\t\t\tint len = r_hash_calculate (rh, hash, tmp, h->to);\n\t\t\t\tfree (tmp);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\teprintf (\"Invalid checksum length\\n\");\n\t\t\t\t}\n\t\t\t\tr_hash_free (rh);\n\t\t\t\tr_cons_printf (\"%s\\\"%s\\\":{\\\"hex\\\":\\\"\", i?\",\": \"\", h->type);\n\t\t\t\t// r_cons_printf (\"%s\\t%d-%dc\\t\", h->type, h->from, h->to+h->from);\n\t\t\t\tfor (j = 0; j < h->len; j++) {\n\t\t\t\t\tr_cons_printf (\"%02x\", h->buf[j]);\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"}\");\n\t\t\t}\n\t\t\tr_cons_printf (\"}\");\n\t\t} else {\n\t\t\tfor (i = 0; info->sum[i].type; i++) {\n\t\t\t\tRBinHash *h = &info->sum[i];\n\t\t\t\tut64 hash = r_hash_name_to_bits (h->type);\n\t\t\t\tRHash *rh = r_hash_new (true, hash);\n\t\t\t\tut8 *tmp = R_NEWS (ut8, h->to);\n\t\t\t\tif (!tmp) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tr_buf_read_at (bf->buf, h->from, tmp, h->to);\n\t\t\t\tint len = r_hash_calculate (rh, hash, tmp, h->to);\n\t\t\t\tfree (tmp);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\teprintf (\"Invalid wtf\\n\");\n\t\t\t\t}\n\t\t\t\tr_hash_free (rh);\n\t\t\t\tr_cons_printf (\"%s  %d-%dc  \", h->type, h->from, h->to+h->from);\n\t\t\t\tfor (j = 0; j < h->len; j++) {\n\t\t\t\t\tr_cons_printf (\"%02x\", h->buf[j]);\n\t\t\t\t}\n\t\t\t\tr_cons_newline ();\n\t\t\t}\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"}\");\n\t\t}\n\t}\n\tconst char *dir_prefix = r_config_get (r->config, \"dir.prefix\");\n\tchar *spath = sdb_fmt (\"%s/\"R2_SDB_FCNSIGN\"/spec.sdb\", dir_prefix);\n\tif (r_file_exists (spath)) {\n\t\tsdb_concat_by_path (r->anal->sdb_fmts, spath);\n\t}\n\treturn true;\n}\n\nstatic int bin_dwarf(RCore *core, int mode) {\n\tRBinDwarfRow *row;\n\tRListIter *iter;\n\tRList *list = NULL;\n\tif (!r_config_get_i (core->config, \"bin.dbginfo\")) {\n\t\treturn false;\n\t}\n\tRBinFile *binfile = r_bin_cur (core->bin);\n\tRBinPlugin * plugin = r_bin_file_cur_plugin (binfile);\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (plugin && plugin->lines) {\n\t\tlist = plugin->lines (binfile);\n\t} else if (core->bin) {\n\t\t// TODO: complete and speed-up support for dwarf\n\t\tRBinDwarfDebugAbbrev *da = NULL;\n\t\tda = r_bin_dwarf_parse_abbrev (core->bin, mode);\n\t\tr_bin_dwarf_parse_info (da, core->bin, mode);\n\t\tr_bin_dwarf_parse_aranges (core->bin, mode);\n\t\tlist = r_bin_dwarf_parse_line (core->bin, mode);\n\t\tr_bin_dwarf_free_debug_abbrev (da);\n\t\tfree (da);\n\t}\n\tif (!list) {\n\t\treturn false;\n\t}\n\n\tr_cons_break_push (NULL, NULL);\n\t/* cache file:line contents */\n\tconst char *lastFile = NULL;\n\tint *lastFileLines = NULL;\n\tchar *lastFileContents = NULL;\n\tint lastFileLinesCount = 0;\n\n\t/* ugly dupe for speedup */\n\tconst char *lastFile2 = NULL;\n\tint *lastFileLines2 = NULL;\n\tchar *lastFileContents2 = NULL;\n\tint lastFileLinesCount2 = 0;\n\n\tconst char *lf = NULL;\n\tint *lfl = NULL;\n\tchar *lfc = NULL;\n\tint lflc = 0;\n\n\t//TODO we should need to store all this in sdb, or do a filecontentscache in libr/util\n\t//XXX this whole thing has leaks\n\tr_list_foreach (list, iter, row) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tif (mode) {\n\t\t\t// TODO: use 'Cl' instead of CC\n\t\t\tconst char *path = row->file;\n\t\t\tif (!lastFile || strcmp (path, lastFile)) {\n\t\t\t\tif (lastFile && lastFile2 && !strcmp (path, lastFile2)) {\n\t\t\t\t\tlf = lastFile;\n\t\t\t\t\tlfl = lastFileLines;\n\t\t\t\t\tlfc = lastFileContents;\n\t\t\t\t\tlflc = lastFileLinesCount;\n\t\t\t\t\tlastFile = lastFile2;\n\t\t\t\t\tlastFileLines = lastFileLines2;\n\t\t\t\t\tlastFileContents = lastFileContents2;\n\t\t\t\t\tlastFileLinesCount = lastFileLinesCount2;\n\t\t\t\t\tlastFile2 = lf;\n\t\t\t\t\tlastFileLines2 = lfl;\n\t\t\t\t\tlastFileContents2 = lfc;\n\t\t\t\t\tlastFileLinesCount2 = lflc;\n\t\t\t\t} else {\n\t\t\t\t\tlastFile2 = lastFile;\n\t\t\t\t\tlastFileLines2 = lastFileLines;\n\t\t\t\t\tlastFileContents2 = lastFileContents;\n\t\t\t\t\tlastFileLinesCount2 = lastFileLinesCount;\n\t\t\t\t\tlastFile = path;\n\t\t\t\t\tlastFileContents = r_file_slurp (path, NULL);\n\t\t\t\t\tif (lastFileContents) {\n\t\t\t\t\t\tlastFileLines = r_str_split_lines (lastFileContents, &lastFileLinesCount);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *line = NULL;\n\t\t\t//r_file_slurp_line (path, row->line - 1, 0);\n\t\t\tif (lastFileLines && lastFileContents) {\n\t\t\t\tint nl = row->line - 1;\n\t\t\t\tif (nl >= 0 && nl < lastFileLinesCount) {\n\t\t\t\t\tline = strdup (lastFileContents + lastFileLines[nl]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tline = NULL;\n\t\t\t}\n\t\t\tif (line) {\n\t\t\t\tr_str_filter (line, strlen (line));\n\t\t\t\tline = r_str_replace (line, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\t\tline = r_str_replace (line, \"\\\\\\\\\", \"\\\\\", 1);\n\t\t\t}\n\t\t\tbool chopPath = !r_config_get_i (core->config, \"dir.dwarf.abspath\");\n\t\t\tchar *file = strdup (row->file);\n\t\t\tif (chopPath) {\n\t\t\t\tconst char *slash = r_str_lchr (file, '/');\n\t\t\t\tif (slash) {\n\t\t\t\t\tmemmove (file, slash + 1, strlen (slash));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// TODO: implement internal : if ((mode & R_MODE_SET))\n\t\t\tif ((mode & R_MODE_SET)) {\n\t\t\t\t// TODO: use CL here.. but its not necessary.. so better not do anything imho\n\t\t\t\t// r_core_cmdf (core, \"CL %s:%d 0x%08\"PFMT64x, file, (int)row->line, row->address);\n#if 0\n\t\t\t\tchar *cmt = r_str_newf (\"%s:%d %s\", file, (int)row->line, line? line: \"\");\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, row->address, cmt);\n\t\t\t\tfree (cmt);\n#endif\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"CL %s:%d 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t       file, (int)row->line,\n\t\t\t\t\t       row->address);\n\t\t\t\tr_cons_printf (\"\\\"CC %s:%d %s\\\"@0x%\" PFMT64x\n\t\t\t\t\t       \"\\n\",\n\t\t\t\t\t       file, row->line,\n\t\t\t\t\t       line ? line : \"\", row->address);\n\t\t\t}\n\t\t\tfree (file);\n\t\t\tfree (line);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\t%s\\t%d\\n\",\n\t\t\t\t       row->address, row->file, row->line);\n\t\t}\n\t}\n\tr_cons_break_pop ();\n\tR_FREE (lastFileContents);\n\tR_FREE (lastFileContents2);\n\t// this list is owned by rbin, not us, we shouldn't free it\n\t// r_list_free (list);\n\tfree (lastFileLines);\n\treturn true;\n}\n\nR_API int r_core_pdb_info(RCore *core, const char *file, ut64 baddr, int mode) {\n\tR_PDB pdb = R_EMPTY;\n\n\tpdb.cb_printf = r_cons_printf;\n\tif (!init_pdb_parser (&pdb, file)) {\n\t\treturn false;\n\t}\n\tif (!pdb.pdb_parse (&pdb)) {\n\t\teprintf (\"pdb was not parsed\\n\");\n\t\tpdb.finish_pdb_parse (&pdb);\n\t\treturn false;\n\t}\n\tif (mode == R_MODE_JSON) {\n\t\tr_cons_printf (\"[\");\n\t}\n\n\tswitch (mode) {\n\tcase R_MODE_SET:\n\t\tmode = 's';\n\t\tr_core_cmd0 (core, \".iP*\");\n\t\treturn true;\n\tcase R_MODE_JSON:\n\t\tmode = 'j';\n\t\tbreak;\n\tcase '*':\n\tcase 1:\n\t\tmode = 'r';\n\t\tbreak;\n\tdefault:\n\t\tmode = 'd'; // default\n\t\tbreak;\n\t}\n\n\tpdb.print_types (&pdb, mode);\n\tif (mode == 'j') {\n\t\tr_cons_printf (\",\");\n\t}\n\tpdb.print_gvars (&pdb, baddr, mode);\n\tif (mode == 'j') {\n\t\tr_cons_printf (\"]\");\n\t}\n\tpdb.finish_pdb_parse (&pdb);\n\n\treturn true;\n}\n\nstatic int bin_pdb(RCore *core, int mode) {\n\tut64 baddr = r_bin_get_baddr (core->bin);\n\treturn r_core_pdb_info (core, core->bin->file, baddr, mode);\n}\n\nstatic int srclineCmp(const void *a, const void *b) {\n\treturn r_str_cmp (a, b, -1);\n}\n\nstatic int bin_source(RCore *r, int mode) {\n\tRList *final_list = r_list_new ();\n\tRBinFile * binfile = r->bin->cur;\n\n\tif (!binfile) {\n\t\tbprintf (\"[Error bin file]\\n\");\n\t\tr_list_free (final_list);\n\t\treturn false;\n\t}\n\n\tSdbListIter *iter;\n\tRListIter *iter2;\n\tchar* srcline;\n\tSdbKv *kv;\n\tSdbList *ls = sdb_foreach_list (binfile->sdb_addrinfo, false);\n\tls_foreach (ls, iter, kv) {\n\t\tchar *v = sdbkv_value (kv);\n\t\tRList *list = r_str_split_list (v, \"|\", 0);\n\t\tsrcline = r_list_get_bottom (list);\n\t\tif (srcline) {\n\t\t\tif (!strstr (srcline, \"0x\")){\n\t\t\t\tr_list_append (final_list, srcline);\n\t\t\t}\n\t\t}\n\t\tr_list_free (list);\n\t}\n\tr_cons_printf (\"[Source file]\\n\");\n\tRList *uniqlist = r_list_uniq (final_list, srclineCmp);\n\tr_list_foreach (uniqlist, iter2, srcline) {\n\t\tr_cons_printf (\"%s\\n\", srcline);\n\t}\n\tr_list_free (uniqlist);\n\tr_list_free (final_list);\n\treturn true;\n}\n\nstatic int bin_main(RCore *r, int mode, int va) {\n\tRBinAddr *binmain = r_bin_get_sym (r->bin, R_BIN_SYM_MAIN);\n\tut64 addr;\n\tif (!binmain) {\n\t\treturn false;\n\t}\n\taddr = va ? r_bin_a2b (r->bin, binmain->vaddr) : binmain->paddr;\n\n\tif (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);\n\t\tr_flag_set (r->flags, \"main\", addr, r->blocksize);\n\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\tr_cons_printf (\"%\"PFMT64d, addr);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs symbols\\n\");\n\t\tr_cons_printf (\"f main @ 0x%08\"PFMT64x\"\\n\", addr);\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{\\\"vaddr\\\":%\" PFMT64d\n\t\t\t\",\\\"paddr\\\":%\" PFMT64d \"}\", addr, binmain->paddr);\n\t} else {\n\t\tr_cons_printf (\"[Main]\\n\");\n\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\"\\n\",\n\t\t\taddr, binmain->paddr);\n\t}\n\treturn true;\n}\n\nstatic inline bool is_initfini(RBinAddr *entry) {\n\tswitch (entry->type) {\n\tcase R_BIN_ENTRY_TYPE_INIT:\n\tcase R_BIN_ENTRY_TYPE_FINI:\n\tcase R_BIN_ENTRY_TYPE_PREINIT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int bin_entry(RCore *r, int mode, ut64 laddr, int va, bool inifin) {\n\tchar str[R_FLAG_NAME_SIZE];\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRListIter *iter;\n\tRListIter *last_processed = NULL;\n\tRBinAddr *entry = NULL;\n\tint i = 0, init_i = 0, fini_i = 0, preinit_i = 0;\n\tut64 baddr = r_bin_get_baddr (r->bin);\n\n\tif (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs symbols\\n\");\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tif (inifin) {\n\t\t\tr_cons_printf (\"[Constructors]\\n\");\n\t\t} else {\n\t\t\tr_cons_printf (\"[Entrypoints]\\n\");\n\t\t}\n\t}\n\n\tr_list_foreach (entries, iter, entry) {\n\t\tut64 paddr = entry->paddr;\n\t\tut64 hpaddr = UT64_MAX;\n\t\tut64 hvaddr = UT64_MAX;\n\t\tif (mode != R_MODE_SET) {\n\t\t\tif (inifin) {\n\t\t\t\tif (entry->type == R_BIN_ENTRY_TYPE_PROGRAM) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (entry->type != R_BIN_ENTRY_TYPE_PROGRAM) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (entry->hpaddr) {\n\t\t\thpaddr = entry->hpaddr;\n\t\t\tif (entry->hvaddr) {\n\t\t\t\thvaddr = rva (r->bin, hpaddr, entry->hvaddr, va);\n\t\t\t}\n\t\t}\n\t\tut64 at = rva (r->bin, paddr, entry->vaddr, va);\n\t\tconst char *type = r_bin_entry_type_string (entry->type);\n\t\tif (!type) {\n\t\t\ttype = \"unknown\";\n\t\t}\n\t\tconst char *hpaddr_key = (entry->type == R_BIN_ENTRY_TYPE_PROGRAM)\n\t\t                ? \"haddr\" : \"hpaddr\";\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tr_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);\n\t\t\tif (entry->type == R_BIN_ENTRY_TYPE_INIT) {\n\t\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"entry.init%i\", init_i);\n\t\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_FINI) {\n\t\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"entry.fini%i\", fini_i);\n\t\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_PREINIT) {\n\t\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"entry.preinit%i\", preinit_i);\n\t\t\t} else {\n\t\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"entry%i\", i);\n\t\t\t}\n\t\t\tr_flag_set (r->flags, str, at, 1);\n\t\t\tif (is_initfini (entry) && hvaddr != UT64_MAX) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_DATA, hvaddr,\n\t\t\t\t            hvaddr + entry->bits / 8, NULL);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", at);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"%s{\\\"vaddr\\\":%\" PFMT64u \",\"\n\t\t\t\t\"\\\"paddr\\\":%\" PFMT64u \",\"\n\t\t\t\t\"\\\"baddr\\\":%\" PFMT64u \",\"\n\t\t\t\t\"\\\"laddr\\\":%\" PFMT64u \",\",\n\t\t\t\tlast_processed ? \",\" : \"\", at, paddr, baddr, laddr);\n\t\t\tif (hvaddr != UT64_MAX) {\n\t\t\t\tr_cons_printf (\"\\\"hvaddr\\\":%\" PFMT64u \",\", hvaddr);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"%s\\\":%\" PFMT64u \",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\"}\",\n\t\t\t\thpaddr_key, hpaddr, type);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tchar *name = NULL;\n\t\t\tif (entry->type == R_BIN_ENTRY_TYPE_INIT) {\n\t\t\t\tname = r_str_newf (\"entry.init%i\", init_i);\n\t\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_FINI) {\n\t\t\t\tname = r_str_newf (\"entry.fini%i\", fini_i);\n\t\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_PREINIT) {\n\t\t\t\tname = r_str_newf (\"entry.preinit%i\", preinit_i);\n\t\t\t} else {\n\t\t\t\tname = r_str_newf (\"entry%i\", i);\n\t\t\t}\n\t\t\tchar *n = __filterQuotedShell (name);\n\t\t\tr_cons_printf (\"\\\"f %s 1 0x%08\"PFMT64x\"\\\"\\n\", n, at);\n\t\t\tr_cons_printf (\"\\\"f %s_%s 1 0x%08\"PFMT64x\"\\\"\\n\", n, hpaddr_key, hpaddr);\n\t\t\tr_cons_printf (\"\\\"s %s\\\"\\n\", n);\n\t\t\tfree (n);\n\t\t\tfree (name);\n\t\t} else {\n\t\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x, at, paddr);\n\t\t\tif (is_initfini (entry) && hvaddr != UT64_MAX) {\n\t\t\t\tr_cons_printf (\" hvaddr=0x%08\"PFMT64x, hvaddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" %s=\", hpaddr_key);\n\t\t\tif (hpaddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\"%\"PFMT64d, hpaddr);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x, hpaddr);\n\t\t\t}\n\t\t\tif (entry->type == R_BIN_ENTRY_TYPE_PROGRAM && hvaddr != UT64_MAX) {\n\t\t\t\tr_cons_printf (\" hvaddr=0x%08\"PFMT64x, hvaddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" type=%s\\n\", type);\n\t\t}\n\t\tif (entry->type == R_BIN_ENTRY_TYPE_INIT) {\n\t\t\tinit_i++;\n\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_FINI) {\n\t\t\tfini_i++;\n\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_PREINIT) {\n\t\t\tpreinit_i++;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t\tlast_processed = iter;\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tif (entry) {\n\t\t\tut64 at = rva (r->bin, entry->paddr, entry->vaddr, va);\n\t\t\tr_core_seek (r, at, 0);\n\t\t}\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t\tr_cons_newline ();\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i entrypoints\\n\", init_i + fini_i + preinit_i + i);\n\t}\n\treturn true;\n}\n\nstatic const char *bin_reloc_type_name(RBinReloc *reloc) {\n#define CASE(T) case R_BIN_RELOC_ ## T: return reloc->additive ? \"ADD_\" #T : \"SET_\" #T\n\tswitch (reloc->type) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t}\n\treturn \"UNKNOWN\";\n#undef CASE\n}\n\nstatic ut8 bin_reloc_size(RBinReloc *reloc) {\n#define CASE(T) case R_BIN_RELOC_ ## T: return (T) / 8\n\tswitch (reloc->type) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t}\n\treturn 0;\n#undef CASE\n}\n\nstatic char *resolveModuleOrdinal(Sdb *sdb, const char *module, int ordinal) {\n\tSdb *db = sdb;\n\tchar *foo = sdb_get (db, sdb_fmt (\"%d\", ordinal), 0);\n\treturn (foo && *foo) ? foo : NULL;\n}\n\nstatic char *get_reloc_name(RCore *r, RBinReloc *reloc, ut64 addr) {\n\tchar *reloc_name = NULL;\n\tchar *demangled_name = NULL;\n\tconst char *lang = r_config_get (r->config, \"bin.lang\");\n\tint bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tbool keep_lib = r_config_get_i (r->config, \"bin.demangle.libs\");\n\tif (reloc->import && reloc->import->name) {\n\t\tif (bin_demangle) {\n\t\t\tdemangled_name = r_bin_demangle (r->bin->cur, lang, reloc->import->name, addr, keep_lib);\n\t\t}\n\t\treloc_name = sdb_fmt (\"reloc.%s_%d\", demangled_name ? demangled_name : reloc->import->name,\n\t\t\t\t      (int)(addr & 0xff));\n\t\tif (!reloc_name) {\n\t\t\tfree (demangled_name);\n\t\t\treturn NULL;\n\t\t}\n\t\tr_str_replace_char (reloc_name, '$', '_');\n\t} else if (reloc->symbol && reloc->symbol->name) {\n\t\tif (bin_demangle) {\n\t\t\tdemangled_name = r_bin_demangle (r->bin->cur, lang, reloc->symbol->name, addr, keep_lib);\n\t\t}\n\t\treloc_name = sdb_fmt (\"reloc.%s_%d\", demangled_name ? demangled_name : reloc->symbol->name,\n\t\t\t\t      (int)(addr & 0xff));\n\t\tif (!reloc_name) {\n\t\t\tfree (demangled_name);\n\t\t\treturn NULL;\n\t\t}\n\t\tr_str_replace_char (reloc_name, '$', '_');\n\t} else if (reloc->is_ifunc) {\n\t\t// addend is the function pointer for the resolving ifunc\n\t\treloc_name = sdb_fmt (\"reloc.ifunc_%\"PFMT64x, reloc->addend);\n\t} else {\n\t\t// TODO(eddyb) implement constant relocs.\n\t}\n\tfree (demangled_name);\n\treturn reloc_name;\n}\n\nstatic void set_bin_relocs(RCore *r, RBinReloc *reloc, ut64 addr, Sdb **db, char **sdb_module) {\n\tint bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tbool keep_lib = r_config_get_i (r->config, \"bin.demangle.libs\");\n\tconst char *lang = r_config_get (r->config, \"bin.lang\");\n\tchar *reloc_name, *demname = NULL;\n\tbool is_pe = true;\n\tint is_sandbox = r_sandbox_enable (0);\n\n\tif (reloc->import && reloc->import->name[0]) {\n\t\tchar str[R_FLAG_NAME_SIZE];\n\t\tRFlagItem *fi;\n\n\t\tif (is_pe && !is_sandbox && strstr (reloc->import->name, \"Ordinal\")) {\n\t\t\tconst char *TOKEN = \".dll_Ordinal_\";\n\t\t\tchar *module = strdup (reloc->import->name);\n\t\t\tchar *import = strstr (module, TOKEN);\n\n\t\t\tr_str_case (module, false);\n\t\t\tif (import) {\n\t\t\t\tchar *filename = NULL;\n\t\t\t\tint ordinal;\n\t\t\t\t*import = 0;\n\t\t\t\timport += strlen (TOKEN);\n\t\t\t\tordinal = atoi (import);\n\t\t\t\tif (!*sdb_module || strcmp (module, *sdb_module)) {\n\t\t\t\t\tsdb_free (*db);\n\t\t\t\t\t*db = NULL;\n\t\t\t\t\tfree (*sdb_module);\n\t\t\t\t\t*sdb_module = strdup (module);\n\t\t\t\t\t/* always lowercase */\n\t\t\t\t\tfilename = sdb_fmt (\"%s.sdb\", module);\n\t\t\t\t\tr_str_case (filename, false);\n\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t*db = sdb_new (NULL, filename, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst char *dirPrefix = r_sys_prefix (NULL);\n\t\t\t\t\t\tfilename = sdb_fmt (R_JOIN_4_PATHS (\"%s\", R2_SDB_FORMAT, \"dll\", \"%s.sdb\"),\n\t\t\t\t\t\t\tdirPrefix, module);\n\t\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t\t*db = sdb_new (NULL, filename, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*db) {\n\t\t\t\t\t// ordinal-1 because we enumerate starting at 0\n\t\t\t\t\tchar *symname = resolveModuleOrdinal (*db, module, ordinal - 1);  // uses sdb_get\n\t\t\t\t\tif (symname) {\n\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\treloc->import->name = r_str_newf\n\t\t\t\t\t\t\t\t(\"%s.%s.%s\", r->bin->prefix, module, symname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treloc->import->name = r_str_newf\n\t\t\t\t\t\t\t\t(\"%s.%s\", module, symname);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tR_FREE (symname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (module);\n\t\t\tr_anal_hint_set_size (r->anal, reloc->vaddr, 4);\n\t\t\tr_meta_add (r->anal, R_META_TYPE_DATA, reloc->vaddr, reloc->vaddr+4, NULL);\n\t\t}\n\t\treloc_name = reloc->import->name;\n\t\tif (r->bin->prefix) {\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"%s.reloc.%s\", r->bin->prefix, reloc_name);\n\t\t} else {\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"reloc.%s\", reloc_name);\n\t\t}\n\t\tif (bin_demangle) {\n\t\t\tdemname = r_bin_demangle (r->bin->cur, lang, str, addr, keep_lib);\n\t\t\tif (demname) {\n\t\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"reloc.%s\", demname);\n\t\t\t}\n\t\t}\n\t\tr_name_filter (str, 0);\n\t\tfi = r_flag_set (r->flags, str, addr, bin_reloc_size (reloc));\n\t\tif (demname) {\n\t\t\tchar *realname;\n\t\t\tif (r->bin->prefix) {\n\t\t\t\trealname = sdb_fmt (\"%s.reloc.%s\", r->bin->prefix, demname);\n\t\t\t} else {\n\t\t\t\trealname = sdb_fmt (\"reloc.%s\", demname);\n\t\t\t}\n\t\t\tr_flag_item_set_realname (fi, realname);\n\t\t}\n\t} else {\n\t\tchar *reloc_name = get_reloc_name (r, reloc, addr);\n\t\tif (reloc_name) {\n\t\t\tr_flag_set (r->flags, reloc_name, addr, bin_reloc_size (reloc));\n\t\t} else {\n\t\t\t// eprintf (\"Cannot find a name for 0x%08\"PFMT64x\"\\n\", addr);\n\t\t}\n\t}\n}\n\n/* Define new data at relocation address if it's not in an executable section */\nstatic void add_metadata(RCore *r, RBinReloc *reloc, ut64 addr, int mode) {\n\tRBinFile * binfile = r->bin->cur;\n\tRBinObject *binobj = binfile ? binfile->o: NULL;\n\tRBinInfo *info = binobj ? binobj->info: NULL;\n\n\tint cdsz = info? (info->bits == 64? 8: info->bits == 32? 4: info->bits == 16 ? 4: 0): 0;\n\tif (cdsz == 0) {\n\t\treturn;\n\t}\n\n\tRIOMap *map = r_io_map_get (r->io, addr);\n\tif (!map || map ->perm & R_PERM_X) {\n\t\treturn;\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tr_meta_add (r->anal, R_META_TYPE_DATA, reloc->vaddr, reloc->vaddr + cdsz, NULL);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"Cd %d @ 0x%08\" PFMT64x \"\\n\", cdsz, addr);\n\t}\n}\n\nstatic bool is_section_symbol(RBinSymbol *s) {\n\t/* workaround for some bin plugs (e.g. ELF) */\n\tif (!s || *s->name) {\n\t\treturn false;\n\t}\n\treturn (s->type && !strcmp (s->type, R_BIN_TYPE_SECTION_STR));\n}\n\nstatic bool is_special_symbol(RBinSymbol *s) {\n\treturn s->type && !strcmp (s->type, R_BIN_TYPE_SPECIAL_SYM_STR);\n}\n\nstatic bool is_section_reloc(RBinReloc *r) {\n\treturn is_section_symbol (r->symbol);\n}\n\nstatic bool is_file_symbol(RBinSymbol *s) {\n\t/* workaround for some bin plugs (e.g. ELF) */\n\treturn (s && s->type && !strcmp (s->type, R_BIN_TYPE_FILE_STR));\n}\n\nstatic bool is_file_reloc(RBinReloc *r) {\n\treturn is_file_symbol (r->symbol);\n}\n\nstatic int bin_relocs(RCore *r, int mode, int va) {\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tbool keep_lib = r_config_get_i (r->config, \"bin.demangle.libs\");\n\tconst char *lang = r_config_get (r->config, \"bin.lang\");\n\tRBIter iter;\n\tRBinReloc *reloc = NULL;\n\tSdb *db = NULL;\n\tPJ *pj = NULL;\n\tchar *sdb_module = NULL;\n\tint i = 0;\n\n\tR_TIME_BEGIN;\n\n\tva = VA_TRUE; // XXX relocs always vaddr?\n\t//this has been created for reloc object files\n\tRBNode *relocs = r_bin_patch_relocs (r->bin);\n\tif (!relocs) {\n\t\trelocs = r_bin_get_relocs (r->bin);\n\t}\n\n\tif (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs relocs\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Relocations]\");\n\t} else if (IS_MODE_JSON (mode)) {\n\t\t// start a new JSON object\n\t\tpj = pj_new ();\n\t\tif (pj) {\n\t\t\tpj_a (pj);\n\t\t}\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_RELOCS);\n\t}\n\n\tr_rbtree_foreach (relocs, iter, reloc, RBinReloc, vrb) {\n\t\tut64 addr = rva (r->bin, reloc->paddr, reloc->vaddr, va);\n\t\tif (IS_MODE_SET (mode) && (is_section_reloc (reloc) || is_file_reloc (reloc))) {\n\t\t\t/*\n\t\t\t * Skip section reloc because they will have their own flag.\n\t\t\t * Skip also file reloc because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\tset_bin_relocs (r, reloc, addr, &db, &sdb_module);\n\t\t\tadd_metadata (r, reloc, addr, mode);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %s\\n\", addr, reloc->import ? reloc->import->name : \"\");\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tchar *name = reloc->import\n\t\t\t\t? strdup (reloc->import->name)\n\t\t\t\t: (reloc->symbol ? strdup (reloc->symbol->name) : NULL);\n\t\t\tif (name && bin_demangle) {\n\t\t\t\tchar *mn = r_bin_demangle (r->bin->cur, NULL, name, addr, keep_lib);\n\t\t\t\tif (mn) {\n\t\t\t\t\tfree (name);\n\t\t\t\t\tname = mn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (name) {\n\t\t\t\tint reloc_size = 4;\n\t\t\t\tchar *n = __filterQuotedShell (name);\n\t\t\t\tr_cons_printf (\"\\\"f %s%s%s %d 0x%08\"PFMT64x\"\\\"\\n\",\n\t\t\t\t\tr->bin->prefix ? r->bin->prefix : \"reloc.\",\n\t\t\t\t\tr->bin->prefix ? \".\" : \"\", n, reloc_size, addr);\n\t\t\t\tadd_metadata (r, reloc, addr, mode);\n\t\t\t\tfree (n);\n\t\t\t\tfree (name);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tif (pj) {\n\t\t\t\tpj_o (pj);\n\t\t\t\tchar *mn = NULL;\n\t\t\t\tchar *relname = NULL;\n\n\t\t\t\t// take care with very long symbol names! do not use sdb_fmt or similar\n\t\t\t\tif (reloc->import) {\n\t\t\t\t\tmn = r_bin_demangle (r->bin->cur, lang, reloc->import->name, addr, keep_lib);\n\t\t\t\t\trelname = strdup (reloc->import->name);\n\t\t\t\t} else if (reloc->symbol) {\n\t\t\t\t\tmn = r_bin_demangle (r->bin->cur, lang, reloc->symbol->name, addr, keep_lib);\n\t\t\t\t\trelname = strdup (reloc->symbol->name);\n\t\t\t\t}\n\n\t\t\t\t// check if name is available\n\t\t\t\tpj_ks (pj, \"name\", (relname && strcmp (relname, \"\")) ? relname : \"N/A\");\n\t\t\t\tpj_ks (pj, \"demname\", mn ? mn : \"\");\n\t\t\t\tpj_ks (pj, \"type\", bin_reloc_type_name (reloc));\n\t\t\t\tpj_kn (pj, \"vaddr\", reloc->vaddr);\n\t\t\t\tpj_kn (pj, \"paddr\", reloc->paddr);\n\t\t\t\tif (reloc->symbol) {\n\t\t\t\t\tpj_kn (pj, \"sym_va\", reloc->symbol->vaddr);\n\t\t\t\t}\n\t\t\t\tpj_kb (pj, \"is_ifunc\", reloc->is_ifunc);\n\t\t\t\t// end reloc item\n\t\t\t\tpj_end (pj);\n\n\t\t\t\tfree (mn);\n\t\t\t\tif (relname) {\n\t\t\t\t\tfree (relname);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tchar *name = reloc->import\n\t\t\t\t? strdup (reloc->import->name)\n\t\t\t\t: reloc->symbol\n\t\t\t\t? strdup (reloc->symbol->name)\n\t\t\t\t: strdup (\"null\");\n\t\t\tif (bin_demangle) {\n\t\t\t\tchar *mn = r_bin_demangle (r->bin->cur, NULL, name, addr, keep_lib);\n\t\t\t\tif (mn && *mn) {\n\t\t\t\t\tfree (name);\n\t\t\t\t\tname = mn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\" type=%s\",\n\t\t\t\taddr, reloc->paddr, bin_reloc_type_name (reloc));\n\t\t\tif (reloc->import && reloc->import->name[0]) {\n\t\t\t\tr_cons_printf (\" %s\", name);\n\t\t\t} else if (reloc->symbol && name && name[0]) {\n\t\t\t\tr_cons_printf (\" %s\", name);\n\t\t\t}\n\t\t\tR_FREE (name);\n\t\t\tif (reloc->addend) {\n\t\t\t\tif ((reloc->import || (reloc->symbol && !R_STR_ISEMPTY (name))) && reloc->addend > 0) {\n\t\t\t\t\tr_cons_printf (\" +\");\n\t\t\t\t}\n\t\t\t\tif (reloc->addend < 0) {\n\t\t\t\t\tr_cons_printf (\" - 0x%08\"PFMT64x, -reloc->addend);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, reloc->addend);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (reloc->is_ifunc) {\n\t\t\t\tr_cons_print (\" (ifunc)\");\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\t// close Json output\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i relocations\\n\", i);\n\t}\n\n\t// free PJ object if used\n\tif (pj) {\n\t\tpj_free (pj);\n\t}\n\tR_FREE (sdb_module);\n\tsdb_free (db);\n\tdb = NULL;\n\n\tR_TIME_END;\n\treturn relocs != NULL;\n}\n\n#define MYDB 1\n/* this is a hacky workaround that needs proper refactoring in Rbin to use Sdb */\n#if MYDB\nstatic Sdb *mydb = NULL;\nstatic RList *osymbols = NULL;\n\nstatic RBinSymbol *get_symbol(RBin *bin, RList *symbols, const char *name, ut64 addr) {\n\tRBinSymbol *symbol, *res = NULL;\n\tRListIter *iter;\n\tif (mydb && symbols && symbols != osymbols) {\n\t\tsdb_free (mydb);\n\t\tmydb = NULL;\n\t\tosymbols = symbols;\n\t}\n\tif (mydb) {\n\t\tif (name) {\n\t\t\tres = (RBinSymbol*)(void*)(size_t)\n\t\t\t\tsdb_num_get (mydb, sdb_fmt (\"%x\", sdb_hash (name)), NULL);\n\t\t} else {\n\t\t\tres = (RBinSymbol*)(void*)(size_t)\n\t\t\t\tsdb_num_get (mydb, sdb_fmt (\"0x\"PFMT64x, addr), NULL);\n\t\t}\n\t} else {\n\t\tmydb = sdb_new0 ();\n\t\tr_list_foreach (symbols, iter, symbol) {\n\t\t\tif (!symbol->name) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* ${name}=${ptrToSymbol} */\n\t\t\tif (!sdb_num_add (mydb, sdb_fmt (\"%x\", sdb_hash (symbol->name)), (ut64)(size_t)symbol, 0)) {\n\t\t\t//\teprintf (\"DUP (%s)\\n\", symbol->name);\n\t\t\t}\n\t\t\t/* 0x${vaddr}=${ptrToSymbol} */\n\t\t\tif (!sdb_num_add (mydb, sdb_fmt (\"0x\"PFMT64x, symbol->vaddr), (ut64)(size_t)symbol, 0)) {\n\t\t\t//\teprintf (\"DUP (%s)\\n\", symbol->name);\n\t\t\t}\n\t\t\tif (name) {\n\t\t\t\tif (!res && !strcmp (symbol->name, name)) {\n\t\t\t\t\tres = symbol;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (symbol->vaddr == addr) {\n\t\t\t\t\tres = symbol;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tosymbols = symbols;\n\t}\n\treturn res;\n}\n#else\nstatic RList *osymbols = NULL;\nstatic RBinSymbol *get_symbol(RBin *bin, RList *symbols, const char *name, ut64 addr) {\n\tRBinSymbol *symbol;\n\tRListIter *iter;\n\t// XXX this is slow, we should use a hashtable here\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (name) {\n\t\t\tif (!strcmp (symbol->name, name))\n\t\t\t\treturn symbol;\n\t\t} else {\n\t\t\tif (symbol->vaddr == addr) {\n\t\t\t\treturn symbol;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n#endif\n\n/* XXX: This is a hack to get PLT references in rabin2 -i */\n/* imp. is a prefix that can be rewritten by the symbol table */\nR_API ut64 r_core_bin_impaddr(RBin *bin, int va, const char *name) {\n\tRList *symbols;\n\n\tif (!name || !*name) {\n\t\treturn false;\n\t}\n\tif (!(symbols = r_bin_get_symbols (bin))) {\n\t\treturn false;\n\t}\n\tchar *impname = r_str_newf (\"imp.%s\", name);\n\tRBinSymbol *s = get_symbol (bin, symbols, impname, 0LL);\n\t// maybe ut64_MAX to indicate import not found?\n\tut64 addr = 0LL;\n\tif (s) {\n\t\tif (va) {\n\t\t\tif (s->paddr == UT64_MAX) {\n\t\t\t\taddr = s->vaddr;\n\t\t\t} else {\n\t\t\t\taddr = r_bin_get_vaddr (bin, s->paddr, s->vaddr);\n\t\t\t}\n\t\t} else {\n\t\t\taddr = s->paddr;\n\t\t}\n\t}\n\tfree (impname);\n\treturn addr;\n}\n\nstatic int bin_imports(RCore *r, int mode, int va, const char *name) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tint bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tbool keep_lib = r_config_get_i (r->config, \"bin.demangle.libs\");\n\tRBinImport *import;\n\tRListIter *iter;\n\tbool lit = info ? info->has_lit: false;\n\tchar *str;\n\tint i = 0;\n\n\tif (!info) {\n\t\treturn false;\n\t}\n\n\tRList *imports = r_bin_get_imports (r->bin);\n\tint cdsz = info? (info->bits == 64? 8: info->bits == 32? 4: info->bits == 16 ? 4: 0): 0;\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs imports\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Imports]\");\n\t\tr_cons_println (\"Num  Vaddr       Bind      Type Name\");\n\t}\n\tr_list_foreach (imports, iter, import) {\n\t\tif (name && strcmp (import->name, name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *symname = strdup (import->name);\n\t\tut64 addr = lit ? r_core_bin_impaddr (r->bin, va, symname): 0;\n\t\tif (bin_demangle) {\n\t\t\tchar *dname = r_bin_demangle (r->bin->cur, NULL, symname, addr, keep_lib);\n\t\t\tif (dname) {\n\t\t\t\tfree (symname);\n\t\t\t\tsymname = r_str_newf (\"sym.imp.%s\", dname);\n\t\t\t\tfree (dname);\n\t\t\t}\n\t\t}\n\t\tif (r->bin->prefix) {\n\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, symname);\n\t\t\tfree (symname);\n\t\t\tsymname = prname;\n\t\t}\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\t// TODO(eddyb) symbols that are imports.\n\t\t\t// Add a dword/qword for PE imports\n\t\t\tif (strstr (symname, \".dll_\") && cdsz) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_DATA, addr, addr + cdsz, NULL);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLE (mode) || IS_MODE_SIMPLEST (mode)) {\n\t\t\tr_cons_println (symname);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tstr = r_str_escape_utf8_for_json (symname, -1);\n\t\t\tstr = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\",\n\t\t\t\titer->p ? \",\" : \"\",\n\t\t\t\timport->ordinal,\n\t\t\t\timport->bind,\n\t\t\t\timport->type);\n\t\t\tif (import->classname && import->classname[0]) {\n\t\t\t\tr_cons_printf (\"\\\"classname\\\":\\\"%s\\\",\"\n\t\t\t\t\t\"\\\"descriptor\\\":\\\"%s\\\",\",\n\t\t\t\t\timport->classname,\n\t\t\t\t\timport->descriptor);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"name\\\":\\\"%s\\\",\\\"plt\\\":%\"PFMT64d\"}\",\n\t\t\t\tstr, addr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t// TODO(eddyb) symbols that are imports.\n\t\t} else {\n\t\t\tconst char *bind = r_str_get (import->bind);\n\t\t\tconst char *type = r_str_get (import->type);\n#if 0\n\t\t\tr_cons_printf (\"ordinal=%03d plt=0x%08\"PFMT64x\" bind=%s type=%s\",\n\t\t\t\timport->ordinal, addr, bind, type);\n\t\t\tif (import->classname && import->classname[0]) {\n\t\t\t\tr_cons_printf (\" classname=%s\", import->classname);\n\t\t\t}\n\t\t\tr_cons_printf (\" name=%s\", symname);\n\t\t\tif (import->descriptor && import->descriptor[0]) {\n\t\t\t\tr_cons_printf (\" descriptor=%s\", import->descriptor);\n\t\t\t}\n\t\t\tr_cons_newline ();\n#else\n\t\t\tr_cons_printf (\"%4d 0x%08\"PFMT64x\" %7s %7s \",\n\t\t\t\timport->ordinal, addr, bind, type);\n\t\t\tif (import->classname && import->classname[0]) {\n\t\t\t\tr_cons_printf (\"%s.\", import->classname);\n\t\t\t}\n\t\t\tr_cons_printf (\"%s\", symname);\n\t\t\tif (import->descriptor && import->descriptor[0]) {\n\t\t\t\t// Uh?\n\t\t\t\tr_cons_printf (\" descriptor=%s\", import->descriptor);\n\t\t\t}\n\t\t\tr_cons_newline ();\n#endif\n\t\t}\n\t\tR_FREE (symname);\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t// r_cons_printf (\"# %i imports\\n\", i);\n\t}\n#if MYDB\n\t// NOTE: if we comment out this, it will leak.. but it will be faster\n\t// because it will keep the cache across multiple RBin calls\n\tosymbols = NULL;\n\tsdb_free (mydb);\n\tmydb = NULL;\n#endif\n\treturn true;\n}\n\nstatic const char *getPrefixFor(const char *s) {\n\tif (s) {\n\t\t// workaround for ELF\n\t\tif (!strcmp (s, R_BIN_TYPE_NOTYPE_STR)) {\n\t\t\treturn \"loc\";\n\t\t}\n\t\tif (!strcmp (s, R_BIN_TYPE_OBJECT_STR)) {\n\t\t\treturn \"obj\";\n\t\t}\n\t}\n\treturn \"sym\";\n}\n\n#define MAXFLAG_LEN_DEFAULT 128\n\nstatic char *construct_symbol_flagname(const char *pfx, const char *symname, int len) {\n\tchar *r = r_str_newf (\"%s.%s\", pfx, symname);\n\tif (r) {\n\t\tr_name_filter (r, len); // maybe unnecessary..\n\t\tchar *R = __filterQuotedShell (r);\n\t\tfree (r);\n\t\treturn R;\n\t}\n\treturn NULL;\n}\n\ntypedef struct {\n\tconst char *pfx; // prefix for flags\n\tchar *name;      // raw symbol name\n\tchar *nameflag;  // flag name for symbol\n\tchar *demname;   // demangled raw symbol name\n\tchar *demflag;   // flag name for demangled symbol\n\tchar *classname; // classname\n\tchar *classflag; // flag for classname\n\tchar *methname;  // methods [class]::[method]\n\tchar *methflag;  // methods flag sym.[class].[method]\n} SymName;\n\nstatic void snInit(RCore *r, SymName *sn, RBinSymbol *sym, const char *lang) {\n\tint bin_demangle = lang != NULL;\n\tbool keep_lib = r_config_get_i (r->config, \"bin.demangle.libs\");\n\tif (!r || !sym || !sym->name) {\n\t\treturn;\n\t}\n\tsn->name = strdup (sym->name);\n\tconst char *pfx = getPrefixFor (sym->type);\n\tsn->nameflag = construct_symbol_flagname (pfx, r_bin_symbol_name (sym), MAXFLAG_LEN_DEFAULT);\n\tif (sym->classname && sym->classname[0]) {\n\t\tsn->classname = strdup (sym->classname);\n\t\tsn->classflag = r_str_newf (\"sym.%s.%s\", sn->classname, sn->name);\n\t\tr_name_filter (sn->classflag, MAXFLAG_LEN_DEFAULT);\n\t\tconst char *name = sym->dname? sym->dname: sym->name;\n\t\tsn->methname = r_str_newf (\"%s::%s\", sn->classname, name);\n\t\tsn->methflag = r_str_newf (\"sym.%s.%s\", sn->classname, name);\n\t\tr_name_filter (sn->methflag, strlen (sn->methflag));\n\t} else {\n\t\tsn->classname = NULL;\n\t\tsn->classflag = NULL;\n\t\tsn->methname = NULL;\n\t\tsn->methflag = NULL;\n\t}\n\tsn->demname = NULL;\n\tsn->demflag = NULL;\n\tif (bin_demangle && sym->paddr) {\n\t\tsn->demname = r_bin_demangle (r->bin->cur, lang, sn->name, sym->vaddr, keep_lib);\n\t\tif (sn->demname) {\n\t\t\tsn->demflag = construct_symbol_flagname (pfx, sn->demname, -1);\n\t\t}\n\t}\n}\n\nstatic void snFini(SymName *sn) {\n\tR_FREE (sn->name);\n\tR_FREE (sn->nameflag);\n\tR_FREE (sn->demname);\n\tR_FREE (sn->demflag);\n\tR_FREE (sn->classname);\n\tR_FREE (sn->classflag);\n\tR_FREE (sn->methname);\n\tR_FREE (sn->methflag);\n}\n\nstatic bool isAnExport(RBinSymbol *s) {\n\t/* workaround for some bin plugs */\n\tif (!strncmp (s->name, \"imp.\", 4)) {\n\t\treturn false;\n\t}\n\treturn (s->bind && !strcmp (s->bind, R_BIN_BIND_GLOBAL_STR));\n}\n\nstatic ut64 compute_addr(RBin *bin, ut64 paddr, ut64 vaddr, int va) {\n\treturn paddr == UT64_MAX? vaddr: rva (bin, paddr, vaddr, va);\n}\n\nstatic void handle_arm_special_symbol(RCore *core, RBinSymbol *symbol, int va) {\n\tut64 addr = compute_addr (core->bin, symbol->paddr, symbol->vaddr, va);\n\tif (!strcmp (symbol->name, \"$a\")) {\n\t\tr_anal_hint_set_bits (core->anal, addr, 32);\n\t} else if (!strcmp (symbol->name, \"$t\")) {\n\t\tr_anal_hint_set_bits (core->anal, addr, 16);\n\t} else if (!strcmp (symbol->name, \"$d\")) {\n\t\t// TODO: we could add data meta type at addr, but sometimes $d\n\t\t// is in the middle of the code and it would make the code less\n\t\t// readable.\n\t} else {\n\t\tR_LOG_WARN (\"Special symbol %s not handled\\n\", symbol->name);\n\t}\n}\n\nstatic void handle_arm_hint(RCore *core, RBinInfo *info, ut64 paddr, ut64 vaddr, int bits, int va) {\n\tif (info->bits > 32) { // we look at 16 or 32 bit only\n\t\treturn;\n\t}\n\n\tint force_bits = 0;\n\tut64 addr = compute_addr (core->bin, paddr, vaddr, va);\n\tif (paddr & 1 || bits == 16) {\n\t\tforce_bits = 16;\n\t} else if (info->bits == 16 && bits == 32) {\n\t\tforce_bits = 32;\n\t} else if (!(paddr & 1) && bits == 32) {\n\t\tforce_bits = 32;\n\t}\n\tif (force_bits) {\n\t\tr_anal_hint_set_bits (core->anal, addr, force_bits);\n\t}\n}\n\nstatic void handle_arm_symbol(RCore *core, RBinSymbol *symbol, RBinInfo *info, int va) {\n\treturn handle_arm_hint (core, info, symbol->paddr, symbol->vaddr, symbol->bits, va);\n}\n\nstatic void handle_arm_entry(RCore *core, RBinAddr *entry, RBinInfo *info, int va) {\n\treturn handle_arm_hint (core, info, entry->paddr, entry->vaddr, entry->bits, va);\n}\n\nstatic void select_flag_space(RCore *core, RBinSymbol *symbol) {\n\tif (!strncmp (symbol->name, \"imp.\", 4)) {\n\t\tr_flag_space_push (core->flags, R_FLAGS_FS_IMPORTS);\n\t} else if (symbol->type && !strcmp (symbol->type, R_BIN_TYPE_SECTION_STR)) {\n\t\tr_flag_space_push (core->flags, R_FLAGS_FS_SYMBOLS_SECTIONS);\n\t} else {\n\t\tr_flag_space_push (core->flags, R_FLAGS_FS_SYMBOLS);\n\t}\n}\n\nstatic int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRBinSymbol *symbol;\n\tRBinAddr *entry;\n\tRListIter *iter;\n\tbool firstexp = true;\n\tbool printHere = false;\n\tint i = 0, lastfs = 's';\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tif (!info) {\n\t\treturn 0;\n\t}\n\n\tif (args && *args == '.') {\n\t\tprintHere = true;\n\t}\n\n\tbool is_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);\n\tconst char *lang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;\n\n\tRList *symbols = r_bin_get_symbols (r->bin);\n\tr_spaces_push (&r->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);\n\t} else if (!at && exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Exports]\\n\");\n\t\t}\n\t} else if (!at && !exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Symbols]\\n\");\n\t\t}\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"Num Paddr      Vaddr      Bind     Type Size Name\\n\");\n\t}\n\n\n\tsize_t count = 0;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (!symbol->name) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true);\n\t\tut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va);\n\t\tint len = symbol->size ? symbol->size : 32;\n\t\tSymName sn = {0};\n\n\t\tif (exponly && !isAnExport (symbol)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (name && strcmp (r_symbol_name, name)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((printHere && !is_in_range (r->offset, symbol->paddr, len))\n\t\t\t\t&& (printHere && !is_in_range (r->offset, addr, len))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tcount ++;\n\t\tsnInit (r, &sn, symbol, lang);\n\n\t\tif (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) {\n\t\t\t/*\n\t\t\t * Skip section symbols because they will have their own flag.\n\t\t\t * Skip also file symbols because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) {\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_special_symbol (r, symbol, va);\n\t\t\t}\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\t// TODO: provide separate API in RBinPlugin to let plugins handle anal hints/metadata\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_symbol (r, symbol, info, va);\n\t\t\t}\n\t\t\tselect_flag_space (r, symbol);\n\t\t\t/* If that's a Classed symbol (method or so) */\n\t\t\tif (sn.classname) {\n\t\t\t\tRFlagItem *fi = r_flag_get (r->flags, sn.methflag);\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, sn.methflag);\n\t\t\t\t\tr_name_filter (sn.methflag, -1);\n\t\t\t\t\tfree (sn.methflag);\n\t\t\t\t\tsn.methflag = prname;\n\t\t\t\t}\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, sn.methname);\n\t\t\t\t\tif ((fi->offset - r->flags->base) == addr) {\n\t\t\t\t//\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\t\tr_flag_unset (r->flags, fi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);\n\t\t\t\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\tif (comment) {\n\t\t\t\t\t\tr_flag_item_set_comment (fi, comment);\n\t\t\t\t\t\tR_FREE (comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *n = sn.demname ? sn.demname : sn.name;\n\t\t\t\tconst char *fn = sn.demflag ? sn.demflag : sn.nameflag;\n\t\t\t\tchar *fnp = (r->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", r->bin->prefix, fn):\n\t\t\t\t\tstrdup (fn);\n\t\t\t\tRFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size);\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, n);\n\t\t\t\t\tfi->demangled = (bool)(size_t)sn.demname;\n\t\t\t\t} else {\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fnp);\n\t\t\t}\n\t\t\tif (sn.demname) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT,\n\t\t\t\t\taddr, symbol->size, sn.demname);\n\t\t\t}\n\t\t\tr_flag_space_pop (r->flags);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *str = r_str_escape_utf8_for_json (r_symbol_name, -1);\n\t\t\t// str = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t((exponly && firstexp) || printHere) ? \"\" : (iter->p ? \",\" : \"\"),\n\t\t\t\tstr,\n\t\t\t\tsn.demname? sn.demname: \"\",\n\t\t\t\tsn.nameflag,\n\t\t\t\tsymbol->ordinal,\n\t\t\t\tsymbol->bind,\n\t\t\t\t(int)symbol->size,\n\t\t\t\tsymbol->type,\n\t\t\t\t(ut64)addr, (ut64)symbol->paddr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %d %s\\n\",\n\t\t\t\taddr, (int)symbol->size, name);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"%s\\n\", name);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t/* Skip special symbols because we do not flag them and\n\t\t\t * they shouldn't be printed in the rad format either */\n\t\t\tif (is_special_symbol (symbol)) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tRBinFile *binfile;\n\t\t\tRBinPlugin *plugin;\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tif (!name) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (!strncmp (name, \"imp.\", 4)) {\n\t\t\t\tif (lastfs != 'i') {\n\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\t}\n\t\t\t\tlastfs = 'i';\n\t\t\t} else {\n\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\tconst char *fs = exponly? \"exports\": \"symbols\";\n\t\t\t\t\tr_cons_printf (\"fs %s\\n\", fs);\n\t\t\t\t}\n\t\t\t\tlastfs = 's';\n\t\t\t}\n\t\t\tif (r->bin->prefix || *name) { // we don't want unnamed symbol flags\n\t\t\t\tchar *flagname = construct_symbol_flagname (\"sym\", name, MAXFLAG_LEN_DEFAULT);\n\t\t\t\tif (!flagname) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"f %s%s%s %u 0x%08\" PFMT64x \"\\\"\\n\",\n\t\t\t\t\tr->bin->prefix ? r->bin->prefix : \"\", r->bin->prefix ? \".\" : \"\",\n\t\t\t\t\tflagname, symbol->size, addr);\n\t\t\t\tfree (flagname);\n\t\t\t}\n\t\t\tbinfile = r_bin_cur (r->bin);\n\t\t\tplugin = r_bin_file_cur_plugin (binfile);\n\t\t\tif (plugin && plugin->name) {\n\t\t\t\tif (r_str_startswith (plugin->name, \"pe\")) {\n\t\t\t\t\tchar *module = strdup (r_symbol_name);\n\t\t\t\t\tchar *p = strstr (module, \".dll_\");\n\t\t\t\t\tif (p && strstr (module, \"imp.\")) {\n\t\t\t\t\t\tchar *symname = __filterShell (p + 5);\n\t\t\t\t\t\tchar *m = __filterShell (module);\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\tr_cons_printf (\"\\\"k bin/pe/%s/%d=%s.%s\\\"\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"\\\"k bin/pe/%s/%d=%s\\\"\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (symname);\n\t\t\t\t\t\tfree (m);\n\t\t\t\t\t}\n\t\t\t\t\tfree (module);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *bind = symbol->bind? symbol->bind: \"NONE\";\n\t\t\tconst char *type = symbol->type? symbol->type: \"NONE\";\n\t\t\tconst char *name = r_str_get (sn.demname? sn.demname: r_symbol_name);\n\t\t\t// const char *fwd = r_str_get (symbol->forwarder);\n\t\t\tr_cons_printf (\"%03u\", symbol->ordinal);\n\t\t\tif (symbol->paddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\" ----------\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, symbol->paddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" %6s %6s %4d%s%s\\n\",\n\t\t\t               addr, bind, type, symbol->size, *name? \" \": \"\", name);\n\t\t}\nnext:\n\t\tsnFini (&sn);\n\t\ti++;\n\t\tfree (r_symbol_name);\n\t\tif (exponly && firstexp) {\n\t\t\tfirstexp = false;\n\t\t}\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (count == 0 && IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{}\");\n\t}\n\n\n\t//handle thumb and arm for entry point since they are not present in symbols\n\tif (is_arm) {\n\t\tr_list_foreach (entries, iter, entry) {\n\t\t\tif (IS_MODE_SET (mode)) {\n\t\t\t\thandle_arm_entry (r, entry, info, va);\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"]\");\n\t}\n\n\tr_spaces_pop (&r->anal->meta_spaces);\n\treturn true;\n}\n\nstatic char *build_hash_string(int mode, const char *chksum, ut8 *data, ut32 datalen) {\n\tchar *chkstr = NULL, *aux, *ret = NULL;\n\tconst char *ptr = chksum;\n\tchar tmp[128];\n\tint i;\n\tdo {\n\t\tfor (i = 0; *ptr && *ptr != ',' && i < sizeof (tmp) -1; i++) {\n\t\t\ttmp[i] = *ptr++;\n\t\t}\n\t\ttmp[i] = '\\0';\n\t\tr_str_trim_head_tail (tmp);\n\t\tchkstr = r_hash_to_string (NULL, tmp, data, datalen);\n\t\tif (!chkstr) {\n\t\t\tif (*ptr && *ptr == ',') {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (IS_MODE_SIMPLE (mode)) {\n\t\t\taux = r_str_newf (\"%s \", chkstr);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\taux = r_str_newf (\"\\\"%s\\\":\\\"%s\\\",\", tmp, chkstr);\n\t\t} else {\n\t\t\taux = r_str_newf (\"%s=%s \", tmp, chkstr);\n\t\t}\n\t\tret = r_str_append (ret, aux);\n\t\tfree (chkstr);\n\t\tfree (aux);\n\t\tif (*ptr && *ptr == ',') {\n\t\t\tptr++;\n\t\t}\n\t} while (*ptr);\n\n\treturn ret;\n}\n\ntypedef struct {\n\tconst char *uri;\n\tint perm;\n\tRIODesc *desc;\n} FindFile;\n\nstatic bool findFile(void *user, void *data, ut32 id) {\n\tFindFile *res = (FindFile*)user;\n\tRIODesc *desc = (RIODesc*)data;\n\tif (desc->perm && res->perm && !strcmp (desc->uri, res->uri)) {\n\t\tres->desc = desc;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic RIODesc *findReusableFile(RIO *io, const char *uri, int perm) {\n\tFindFile arg = {\n\t\t.uri = uri,\n\t\t.perm = perm,\n\t\t.desc = NULL,\n\t};\n\tr_id_storage_foreach (io->files, findFile, &arg);\n\treturn arg.desc;\n}\n\nstatic bool io_create_mem_map(RIO *io, RBinSection *sec, ut64 at) {\n\tr_return_val_if_fail (io && sec, false);\n\n\tbool reused = false;\n\tut64 gap = sec->vsize - sec->size;\n\tchar *uri = r_str_newf (\"null://%\"PFMT64u, gap);\n\tRIODesc *desc = findReusableFile (io, uri, sec->perm);\n\tif (desc) {\n\t\tRIOMap *map = r_io_map_get (io, at);\n\t\tif (!map) {\n\t\t\tr_io_map_add_batch (io, desc->fd, desc->perm, 0LL, at, gap);\n\t\t}\n\t\treused = true;\n\t}\n\tif (!desc) {\n\t\tdesc = r_io_open_at (io, uri, sec->perm, 0664, at);\n\t}\n\tfree (uri);\n\tif (!desc) {\n\t\treturn false;\n\t}\n\t// this works, because new maps are always born on the top\n\tRIOMap *map = r_io_map_get (io, at);\n\t// check if the mapping failed\n\tif (!map) {\n\t\tif (!reused) {\n\t\t\tr_io_desc_close (desc);\n\t\t}\n\t\treturn false;\n\t}\n\t// let the section refere to the map as a memory-map\n\tmap->name = r_str_newf (\"mmap.%s\", sec->name);\n\treturn true;\n}\n\nstatic void add_section(RCore *core, RBinSection *sec, ut64 addr, int fd) {\n\tif (!r_io_desc_get (core->io, fd) || UT64_ADD_OVFCHK (sec->size, sec->paddr) ||\n\t    UT64_ADD_OVFCHK (sec->size, addr) || !sec->vsize) {\n\t\treturn;\n\t}\n\n\tut64 size = sec->vsize;\n\t// if there is some part of the section that needs to be zeroed by the loader\n\t// we add a null map that takes care of it\n\tif (sec->vsize > sec->size) {\n\t\tif (!io_create_mem_map (core->io, sec, addr + sec->size)) {\n\t\t\treturn;\n\t\t}\n\n\t\tsize = sec->size;\n\t}\n\n\t// then we map the part of the section that comes from the physical file\n\tchar *map_name = r_str_newf (\"fmap.%s\", sec->name);\n\tif (!map_name) {\n\t\treturn;\n\t}\n\n\tint perm = sec->perm;\n\t// workaround to force exec bit in text section\n\tif (sec->name &&  strstr (sec->name, \"text\")) {\n\t\tperm |= R_PERM_X;\n\t}\n\n\tRIOMap *map = r_io_map_add_batch (core->io, fd, perm, sec->paddr, addr, size);\n\tif (!map) {\n\t\tfree (map_name);\n\t\treturn;\n\t}\n\tmap->name = map_name;\n\treturn;\n}\n\nstruct io_bin_section_info_t {\n\tRBinSection *sec;\n\tut64 addr;\n\tint fd;\n};\n\nstatic int bin_sections(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, const char *chksum, bool print_segments) {\n\tchar *str = NULL;\n\tRBinSection *section;\n\tRBinInfo *info = NULL;\n\tRList *sections;\n\tRListIter *iter;\n\tRListIter *last_processed = NULL;\n\tint i = 0;\n\tint fd = -1;\n\tbool printHere = false;\n\tsections = r_bin_get_sections (r->bin);\n#if LOAD_BSS_MALLOC\n\tbool inDebugger = r_config_get_i (r->config, \"cfg.debug\");\n#endif\n\tHtPP *dup_chk_ht = ht_pp_new0 ();\n\tbool ret = false;\n\tconst char *type = print_segments ? \"segment\" : \"section\";\n\tbool segments_only = true;\n\tRList *io_section_info = NULL;\n\n\tif (!dup_chk_ht) {\n\t\treturn false;\n\t}\n\n\tif (chksum && *chksum == '.') {\n\t\tprintHere = true;\n\t}\n\tif (IS_MODE_EQUAL (mode)) {\n\t\tint cols = r_cons_get_size (NULL);\n\t\tRList *list = r_list_newf ((RListFree) r_listinfo_free);\n\t\tif (!list) {\n\t\t\treturn false;\n\t\t}\n\t\tRBinSection *s;\n\t\tr_list_foreach (sections, iter, s) {\n\t\t\tchar humansz[8];\n\t\t\tif (print_segments != s->is_segment) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRInterval pitv = (RInterval){s->paddr, s->size};\n\t\t\tRInterval vitv = (RInterval){s->vaddr, s->vsize};\n\t\t\tr_num_units (humansz, sizeof (humansz), s->size);\n\t\t\tRListInfo *info = r_listinfo_new (s->name, pitv, vitv, s->perm, strdup (humansz));\n\t\t\tr_list_append (list, info);\n\t\t}\n\t\tr_core_visual_list (r, list, r->offset, -1, cols, r->print->flags & R_PRINT_FLAGS_COLOR);\n\t\tr_list_free (list);\n\t\tgoto out;\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_RAD (mode) && !at) {\n\t\tr_cons_printf (\"fs %ss\\n\", type);\n\t} else if (IS_MODE_NORMAL (mode) && !at && !printHere) {\n\t\tr_cons_printf (\"[%s]\\n\", print_segments ? \"Segments\" : \"Sections\");\n\t} else if (IS_MODE_NORMAL (mode) && printHere) {\n\t\tr_cons_printf (\"Current section\\n\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tfd = r_core_file_cur_fd (r);\n\t\tr_flag_space_set (r->flags, print_segments? R_FLAGS_FS_SEGMENTS: R_FLAGS_FS_SECTIONS);\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"Nm Paddr       Size Vaddr      Memsz Perms %sName\\n\",\n                   chksum ? \"Checksum          \" : \"\");\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tr_list_foreach (sections, iter, section) {\n\t\t\tif (!section->is_segment) {\n\t\t\t\tsegments_only = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tio_section_info = r_list_newf ((RListFree)free);\n\t}\n\tr_list_foreach (sections, iter, section) {\n\t\tchar perms[] = \"----\";\n\t\tint va_sect = va;\n\t\tut64 addr;\n\n\t\tif (va && !(section->perm & R_PERM_R)) {\n\t\t\tva_sect = VA_NOREBASE;\n\t\t}\n\t\taddr = rva (r->bin, section->paddr, section->vaddr, va_sect);\n\n\t\tif (name && strcmp (section->name, name)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((printHere && !(section->paddr <= r->offset && r->offset < (section->paddr + section->size)))\n\t\t\t\t&& (printHere && !(addr <= r->offset && r->offset < (addr + section->size)))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tr_name_filter (section->name, strlen (section->name) + 1);\n\t\tif (at && (!section->size || !is_in_range (at, addr, section->size))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (section->is_segment != print_segments) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (section->perm & R_PERM_SHAR) {\n\t\t\tperms[0] = 's';\n\t\t}\n\t\tif (section->perm & R_PERM_R) {\n\t\t\tperms[1] = 'r';\n\t\t}\n\t\tif (section->perm & R_PERM_W) {\n\t\t\tperms[2] = 'w';\n\t\t}\n\t\tif (section->perm & R_PERM_X) {\n\t\t\tperms[3] = 'x';\n\t\t}\n\t\tconst char *arch = NULL;\n\t\tint bits = 0;\n\t\tif (section->arch || section->bits) {\n\t\t\tarch = section->arch;\n\t\t\tbits = section->bits;\n\t\t}\n\t\tif (info) {\n\t\t\tif (!arch) {\n\t\t\t\tarch = info->arch;\n\t\t\t}\n\t\t\tif (!bits) {\n\t\t\t\tbits = info->bits;\n\t\t\t}\n\t\t}\n\t\tif (!arch) {\n\t\t\tarch = r_config_get (r->config, \"asm.arch\");\n\t\t}\n\t\tif (!bits) {\n\t\t\tbits = R_SYS_BITS;\n\t\t}\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tchar *n = __filterQuotedShell (section->name);\n\t\t\tr_cons_printf (\"\\\"f %s.%s 1 0x%08\"PFMT64x\"\\\"\\n\", type, n, section->vaddr);\n\t\t\tfree (n);\n\t\t} else if (IS_MODE_SET (mode)) {\n#if LOAD_BSS_MALLOC\n\t\t\tif (!strcmp (section->name, \".bss\")) {\n\t\t\t\t// check if there's already a file opened there\n\t\t\t\tint loaded = 0;\n\t\t\t\tRListIter *iter;\n\t\t\t\tRIOMap *m;\n\t\t\t\tr_list_foreach (r->io->maps, iter, m) {\n\t\t\t\t\tif (m->from == addr) {\n\t\t\t\t\t\tloaded = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!loaded && !inDebugger) {\n\t\t\t\t\tr_core_cmdf (r, \"on malloc://%d 0x%\"PFMT64x\" # bss\\n\",\n\t\t\t\t\t\tsection->vsize, addr);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tif (section->format) {\n\t\t\t\t// This is damn slow if section vsize is HUGE\n\t\t\t\tif (section->vsize < 1024 * 1024 * 2) {\n\t\t\t\t\tr_core_cmdf (r, \"%s @ 0x%\"PFMT64x, section->format, section->vaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tstr = r_str_newf (\"%s.%s.%s\", r->bin->prefix, type, section->name);\n\t\t\t} else {\n\t\t\t\tstr = r_str_newf (\"%s.%s\", type, section->name);\n\n\t\t\t}\n\t\t\tut64 size = r->io->va? section->vsize: section->size;\n\t\t\tr_flag_set (r->flags, str, addr, size);\n\t\t\tR_FREE (str);\n\n\t\t\tif (!section->is_segment || segments_only) {\n\t\t\t\tchar *pfx = r->bin->prefix;\n\t\t\t\tstr = r_str_newf (\"[%02d] %s %s size %\" PFMT64d\" named %s%s%s\",\n\t\t\t\t                  i, perms, type, size,\n\t\t\t\t                  pfx? pfx: \"\", pfx? \".\": \"\", section->name);\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT, addr, addr, str);\n\t\t\t\tR_FREE (str);\n\t\t\t}\n\t\t\tif (section->add) {\n\t\t\t\tbool found;\n\t\t\t\tstr = r_str_newf (\"%\"PFMT64x\".%\"PFMT64x\".%\"PFMT64x\".%\"PFMT64x\".%\"PFMT32u\".%s.%\"PFMT32u\".%d\",\n\t\t\t\t\tsection->paddr, addr, section->size, section->vsize, section->perm, section->name, r->bin->cur->id, fd);\n\t\t\t\tht_pp_find (dup_chk_ht, str, &found);\n\t\t\t\tif (!found) {\n\t\t\t\t\t// can't directly add maps because they\n\t\t\t\t\t// need to be reversed, otherwise for\n\t\t\t\t\t// the way IO works maps would be shown\n\t\t\t\t\t// in reverse order\n\t\t\t\t\tstruct io_bin_section_info_t *ibs = R_NEW (struct io_bin_section_info_t);\n\t\t\t\t\tif (!ibs) {\n\t\t\t\t\t\teprintf (\"Could not allocate memory\\n\");\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\tibs->sec = section;\n\t\t\t\t\tibs->addr = addr;\n\t\t\t\t\tibs->fd = fd;\n\t\t\t\t\tr_list_append (io_section_info, ibs);\n\t\t\t\t\tht_pp_insert (dup_chk_ht, str, NULL);\n\t\t\t\t}\n\t\t\t\tR_FREE (str);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tchar *hashstr = NULL;\n\t\t\tif (chksum) {\n\t\t\t\tut8 *data = malloc (section->size);\n\t\t\t\tif (!data) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tut32 datalen = section->size;\n\t\t\t\tr_io_pread_at (r->io, section->paddr, data, datalen);\n\t\t\t\thashstr = build_hash_string (mode, chksum,\n\t\t\t\t\t\t\tdata, datalen);\n\t\t\t\tfree (data);\n\t\t\t}\n\t\t\tr_cons_printf (\"0x%\"PFMT64x\" 0x%\"PFMT64x\" %s %s%s%s\\n\",\n\t\t\t\taddr, addr + section->size,\n\t\t\t\tperms,\n\t\t\t\thashstr ? hashstr : \"\", hashstr ? \" \" : \"\",\n\t\t\t\tsection->name\n\t\t\t);\n\t\t\tfree (hashstr);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *hashstr = NULL;\n\t\t\tif (chksum && section->size > 0) {\n\t\t\t\tut8 *data = malloc (section->size);\n\t\t\t\tif (!data) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tut32 datalen = section->size;\n\t\t\t\tr_io_pread_at (r->io, section->paddr, data, datalen);\n\t\t\t\thashstr = build_hash_string (mode, chksum,\n\t\t\t\t\t\t\tdata, datalen);\n\t\t\t\tfree (data);\n\t\t\t}\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"vsize\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"perm\\\":\\\"%s\\\",\"\n\t\t\t\t\"%s\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t(last_processed && !printHere) ? \",\" : \"\",\n\t\t\t\tsection->name,\n\t\t\t\tsection->size,\n\t\t\t\tsection->vsize,\n\t\t\t\tperms,\n\t\t\t\thashstr ? hashstr : \"\",\n\t\t\t\tsection->paddr,\n\t\t\t\taddr);\n\t\t\tfree (hashstr);\n\t\t} else {\n\t\t\tchar *hashstr = NULL, str[128];\n\t\t\tif (chksum) {\n\t\t\t\tut8 *data = malloc (section->size);\n\t\t\t\tif (!data) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tut32 datalen = section->size;\n\t\t\t\t// VA READ IS BROKEN?\n\t\t\t\tif (datalen > 0) {\n\t\t\t\t\tr_io_pread_at (r->io, section->paddr, data, datalen);\n\t\t\t\t}\n\t\t\t\thashstr = build_hash_string (mode, chksum, data, datalen);\n\t\t\t\tfree (data);\n\t\t\t}\n\t\t\tif (section->arch || section->bits) {\n\t\t\t\tsnprintf (str, sizeof (str), \"arch=%s bits=%d \",\n\t\t\t\t\tr_str_get2 (arch), bits);\n\t\t\t} else {\n\t\t\t\tstr[0] = 0;\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tr_cons_printf (\"%02i 0x%08\"PFMT64x\" %5\"PFMT64d\" 0x%08\"PFMT64x\" %5\"PFMT64d\" \"\n\t\t\t\t\t\"%s %s%s%s.%s\\n\",\n\t\t\t\t\ti, section->paddr, section->size, addr, section->vsize,\n\t\t\t\t\tperms, str, hashstr ?hashstr : \"\", r->bin->prefix, section->name);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%02i 0x%08\"PFMT64x\" %5\"PFMT64d\" 0x%08\"PFMT64x\" %5\"PFMT64d\" \"\n\t\t\t\t\t\"%s %s%s%s\\n\",\n\t\t\t\t\ti, section->paddr, (ut64)section->size, addr, (ut64)section->vsize,\n\t\t\t\t\tperms, str, hashstr ?hashstr : \"\", section->name);\n\t\t\t}\n\t\t\tfree (hashstr);\n\t\t}\n\t\ti++;\n\t\tlast_processed = iter;\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (IS_MODE_SET (mode) && !r_io_desc_is_dbg (r->io->desc)) {\n\t\tRListIter *it;\n\t\tstruct io_bin_section_info_t *ibs;\n\t\tr_list_foreach_prev (io_section_info, it, ibs) {\n\t\t\tadd_section (r, ibs->sec, ibs->addr, ibs->fd);\n\t\t}\n\t\tr_io_update (r->io);\n\t\tr_list_free (io_section_info);\n\t\tio_section_info = NULL;\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_println (\"]\");\n\t} else if (IS_MODE_NORMAL (mode) && !at && !printHere) {\n\t\t// r_cons_printf (\"\\n%i sections\\n\", i);\n\t}\n\n\tret = true;\nout:\n\tht_pp_free (dup_chk_ht);\n\treturn ret;\n}\n\nstatic int bin_fields(RCore *r, int mode, int va) {\n\tRList *fields;\n\tRListIter *iter;\n\tRBinField *field;\n\tint i = 0;\n\tRBin *bin = r->bin;\n\n\tif (!(fields = r_bin_get_fields (bin))) {\n\t\treturn false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs header\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Header fields]\");\n\t}\n\tr_list_foreach (fields, iter, field) {\n\t\tut64 addr = rva (bin, field->paddr, field->vaddr, va);\n\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tchar *n = __filterQuotedShell (field->name);\n\t\t\tr_name_filter (n, -1);\n\t\t\tr_cons_printf (\"\\\"f header.%s 1 0x%08\"PFMT64x\"\\\"\\n\", n, addr);\n\t\t\tif (field->comment && *field->comment) {\n\t\t\t\tchar *e = sdb_encode ((const ut8*)field->comment, -1);\n\t\t\t\tr_cons_printf (\"CCu %s @ 0x%\"PFMT64x\"\\n\", e, addr);\n\t\t\t\tfree (e);\n\t\t\t\tchar *f = __filterShell (field->format);\n\t\t\t\tr_cons_printf (\"Cf %d .%s @ 0x%\"PFMT64x\"\\n\", field->size, f, addr);\n\t\t\t\tfree (f);\n\t\t\t}\n\t\t\tif (field->format && *field->format) {\n\t\t\t\tr_cons_printf (\"pf.%s %s\\n\", n, field->format);\n\t\t\t}\n\t\t\tfree (n);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d,\n\t\t\t\titer->p? \",\": \"\",\n\t\t\t\tfield->name,\n\t\t\t\tfield->vaddr,\n\t\t\t\tfield->paddr\n\t\t\t\t);\n\t\t\tif (field->comment && *field->comment) {\n\t\t\t\t// TODO: filter comment before json\n\t\t\t\tr_cons_printf (\",\\\"comment\\\":\\\"%s\\\"\", field->comment);\n\t\t\t}\n\t\t\tif (field->format && *field->format) {\n\t\t\t\t// TODO: filter comment before json\n\t\t\t\tr_cons_printf (\",\\\"format\\\":\\\"%s\\\"\", field->format);\n\t\t\t}\n\t\t\tchar *o = r_core_cmd_strf (r, \"pfj.%s@0x%\"PFMT64x, field->format, field->vaddr);\n\t\t\tif (o && *o) {\n\t\t\t\tr_cons_printf (\",\\\"pf\\\":%s\", o);\n\t\t\t}\n\t\t\tfree (o);\n\t\t\tr_cons_printf (\"}\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tconst bool haveComment = (field->comment && *field->comment);\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" 0x%08\"PFMT64x\" %s%s%s\\n\",\n\t\t\t\tfield->vaddr, field->paddr, field->name,\n\t\t\t\thaveComment? \"; \": \"\",\n\t\t\t\thaveComment? field->comment: \"\");\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i fields\\n\", i);\n\t}\n\n\treturn true;\n}\n\nstatic char *get_rp(const char *rtype) {\n\tchar *rp = NULL;\n\tswitch (rtype[0]) {\n\tcase 'v':\n\t\trp = strdup (\"void\");\n\t\tbreak;\n\tcase 'c':\n\t\trp = strdup (\"char\");\n\t\tbreak;\n\tcase 'i':\n\t\trp = strdup (\"int\");\n\t\tbreak;\n\tcase 's':\n\t\trp = strdup (\"short\");\n\t\tbreak;\n\tcase 'l':\n\t\trp = strdup (\"long\");\n\t\tbreak;\n\tcase 'q':\n\t\trp = strdup (\"long long\");\n\t\tbreak;\n\tcase 'C':\n\t\trp = strdup (\"unsigned char\");\n\t\tbreak;\n\tcase 'I':\n\t\trp = strdup (\"unsigned int\");\n\t\tbreak;\n\tcase 'S':\n\t\trp = strdup (\"unsigned short\");\n\t\tbreak;\n\tcase 'L':\n\t\trp = strdup (\"unsigned long\");\n\t\tbreak;\n\tcase 'Q':\n\t\trp = strdup (\"unsigned long long\");\n\t\tbreak;\n\tcase 'f':\n\t\trp = strdup (\"float\");\n\t\tbreak;\n\tcase 'd':\n\t\trp = strdup (\"double\");\n\t\tbreak;\n\tcase 'D':\n\t\trp = strdup (\"long double\");\n\t\tbreak;\n\tcase 'B':\n\t\trp = strdup (\"bool\");\n\t\tbreak;\n\tcase '#':\n\t\trp = strdup (\"CLASS\");\n\t\tbreak;\n\tdefault:\n\t\trp = strdup (\"unknown\");\n\t\tbreak;\n\t}\n\treturn rp;\n}\n\nstatic int bin_trycatch(RCore *core, int mode) {\n\tRBinFile *bf = r_bin_cur (core->bin);\n\tRListIter *iter;\n\tRBinTrycatch *tc;\n\tRList *trycatch = r_bin_file_get_trycatch (bf);\n\tint idx = 0;\n\tr_list_foreach (trycatch, iter, tc) {\n\t\tr_cons_printf (\"f try.%d.%\"PFMT64x\".from=0x%08\"PFMT64x\"\\n\", idx, tc->source, tc->from);\n\t\tr_cons_printf (\"f try.%d.%\"PFMT64x\".to=0x%08\"PFMT64x\"\\n\", idx, tc->source, tc->to);\n\t\tr_cons_printf (\"f try.%d.%\"PFMT64x\".catch=0x%08\"PFMT64x\"\\n\", idx, tc->source, tc->handler);\n\t\tidx++;\n\t}\n\treturn true;\n}\n\nstatic void classdump_objc(RCore *r, RBinClass *c) {\n\tif (c->super) {\n\t\tr_cons_printf (\"@interface %s : %s\\n{\\n\", c->name, c->super);\n\t} else {\n\t\tr_cons_printf (\"@interface %s\\n{\\n\", c->name);\n\t}\n\tRListIter *iter2, *iter3;\n\tRBinField *f;\n\tRBinSymbol *sym;\n\tr_list_foreach (c->fields, iter2, f) {\n\t\tif (f->name && r_regex_match (\"ivar\",\"e\", f->name)) {\n\t\t\tr_cons_printf (\"  %s %s\\n\", f->type, f->name);\n\t\t}\n\t}\n\tr_cons_printf (\"}\\n\");\n\tr_list_foreach (c->methods, iter3, sym) {\n\t\tif (sym->rtype && sym->rtype[0] != '@') {\n\t\t\tchar *rp = get_rp (sym->rtype);\n\t\t\tr_cons_printf (\"%s (%s) %s\\n\",\n\t\t\t\t\tstrncmp (sym->type, R_BIN_TYPE_METH_STR, 4)? \"+\": \"-\",\n\t\t\t\t\trp, sym->dname? sym->dname: sym->name);\n\t\t\tfree (rp);\n\t\t} else if (sym->type) {\n\t\t\tr_cons_printf (\"%s (id) %s\\n\",\n\t\t\t\t\tstrncmp (sym->type, R_BIN_TYPE_METH_STR, 4)? \"+\": \"-\",\n\t\t\t\t\tsym->dname? sym->dname: sym->name);\n\t\t}\n\t}\n\tr_cons_printf (\"@end\\n\");\n}\n\nstatic void classdump_java(RCore *r, RBinClass *c) {\n\tRBinField *f;\n\tRListIter *iter2, *iter3;\n\tRBinSymbol *sym;\n\tchar *pn = strdup (c->name);\n\tchar *cn = (char *)r_str_rchr (pn, NULL, '/');\n\tif (cn) {\n\t\t*cn = 0;\n\t\tcn++;\n\t\tr_str_replace_char (pn, '/', '.');\n\t}\n\tr_cons_printf (\"package %s;\\n\\n\", pn);\n\tr_cons_printf (\"public class %s {\\n\", cn);\n\tfree (pn);\n\tr_list_foreach (c->fields, iter2, f) {\n\t\tif (f->name && r_regex_match (\"ivar\",\"e\", f->name)) {\n\t\t\tr_cons_printf (\"  public %s %s\\n\", f->type, f->name);\n\t\t}\n\t}\n\tr_list_foreach (c->methods, iter3, sym) {\n\t\tconst char *mn = sym->dname? sym->dname: sym->name;\n\t\tconst char *ms = strstr (mn, \"method.\");\n\t\tif (ms) {\n\t\t\tmn = ms + strlen (\"method.\");\n\t\t}\n\t\tr_cons_printf (\"  public %s ();\\n\", mn);\n\t}\n\tr_cons_printf (\"}\\n\\n\");\n}\n\nstatic int bin_classes(RCore *r, int mode) {\n\tRListIter *iter, *iter2, *iter3;\n\tRBinSymbol *sym;\n\tRBinClass *c;\n\tRBinField *f;\n\tchar *name;\n\tRList *cs = r_bin_get_classes (r->bin);\n\tif (!cs) {\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_print (\"[]\");\n\t\t}\n\t\treturn false;\n\t}\n\t// XXX: support for classes is broken and needs more love\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tif (!r_config_get_i (r->config, \"bin.classes\")) {\n\t\t\treturn false;\n\t\t}\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_CLASSES);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs classes\");\n\t}\n\n\tr_list_foreach (cs, iter, c) {\n\t\tif (!c || !c->name || !c->name[0]) {\n\t\t\tcontinue;\n\t\t}\n\t\tname = strdup (c->name);\n\t\tr_name_filter (name, 0);\n\t\tut64 at_min = UT64_MAX;\n\t\tut64 at_max = 0LL;\n\n\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\tif (sym->vaddr) {\n\t\t\t\tif (sym->vaddr < at_min) {\n\t\t\t\t\tat_min = sym->vaddr;\n\t\t\t\t}\n\t\t\t\tif (sym->vaddr + sym->size > at_max) {\n\t\t\t\t\tat_max = sym->vaddr + sym->size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (at_min == UT64_MAX) {\n\t\t\tat_min = c->addr;\n\t\t\tat_max = c->addr; // XXX + size?\n\t\t}\n\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tconst char *classname = sdb_fmt (\"class.%s\", name);\n\t\t\tr_flag_set (r->flags, classname, c->addr, 1);\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym->method_flags, mode);\n\t\t\t\tchar *method = sdb_fmt (\"method%s.%s.%s\",\n\t\t\t\t\tmflags, c->name, sym->name);\n\t\t\t\tR_FREE (mflags);\n\t\t\t\tr_name_filter (method, -1);\n\t\t\t\tr_flag_set (r->flags, method, sym->vaddr, 1);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tr_cons_printf (\"%s\\n\", c->name);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" [0x%08\"PFMT64x\" - 0x%08\"PFMT64x\"] %s%s%s\\n\",\n\t\t\t\tc->addr, at_min, at_max, c->name, c->super ? \" \" : \"\",\n\t\t\t\tc->super ? c->super : \"\");\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tchar *n = __filterShell (name);\n\t\t\tr_cons_printf (\"\\\"f class.%s = 0x%\"PFMT64x\"\\\"\\n\", n, at_min);\n\t\t\tfree (n);\n\t\t\tif (c->super) {\n\t\t\t\tchar *cn = c->name; // __filterShell (c->name);\n\t\t\t\tchar *su = c->super; // __filterShell (c->super);\n\t\t\t\tr_cons_printf (\"\\\"f super.%s.%s = %d\\\"\\n\",\n\t\t\t\t\t\tcn, su, c->index);\n\t\t\t\t// free (cn);\n\t\t\t\t// free (su);\n\t\t\t}\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym->method_flags, mode);\n\t\t\t\tchar *n = c->name; //  __filterShell (c->name);\n\t\t\t\tchar *sn = sym->name; //__filterShell (sym->name);\n\t\t\t\tchar *cmd = r_str_newf (\"\\\"f method%s.%s.%s = 0x%\"PFMT64x\"\\\"\\n\", mflags, n, sn, sym->vaddr);\n\t\t\t\t// free (n);\n\t\t\t\t// free (sn);\n\t\t\t\tif (cmd) {\n\t\t\t\t\tr_str_replace_char (cmd, ' ', '_');\n\t\t\t\t\tif (strlen (cmd) > 2) {\n\t\t\t\t\t\tcmd[2] = ' ';\n\t\t\t\t\t}\n\t\t\t\t\tchar *eq = (char *)r_str_rchr (cmd, NULL, '=');\n\t\t\t\t\tif (eq && eq != cmd) {\n\t\t\t\t\t\teq[-1] = eq[1] = ' ';\n\t\t\t\t\t}\n\t\t\t\t\tr_str_replace_char (cmd, '\\n', 0);\n\t\t\t\t\tr_cons_printf (\"%s\\n\", cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t}\n\t\t\t\tR_FREE (mflags);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tif (c->super) {\n\t\t\t\tr_cons_printf (\"%s{\\\"classname\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\",\\\"index\\\":%d,\\\"visibility\\\":\\\"%s\\\",\\\"super\\\":\\\"%s\\\",\\\"methods\\\":[\",\n\t\t\t\t\titer->p ? \",\" : \"\", c->name, c->addr,\n\t\t\t\t\tc->index, c->visibility_str? c->visibility_str: \"\", c->super);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s{\\\"classname\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\",\\\"index\\\":%d,\\\"methods\\\":[\",\n\t\t\t\t\titer->p ? \",\" : \"\", c->name, c->addr,\n\t\t\t\t\tc->index);\n\t\t\t}\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tif (sym->method_flags) {\n\t\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym->method_flags, mode);\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"flags\\\":%s,\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer2->p? \",\": \"\", sym->name, mflags, sym->vaddr);\n\t\t\t\t\tR_FREE (mflags);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer2->p? \",\": \"\", sym->name, sym->vaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"], \\\"fields\\\":[\");\n\t\t\tr_list_foreach (c->fields, iter3, f) {\n\t\t\t\tif (f->flags) {\n\t\t\t\t\tchar *mflags = r_core_bin_method_flags_str (f->flags, mode);\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"flags\\\":%s,\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer3->p? \",\": \"\", f->name, mflags, f->vaddr);\n\t\t\t\t\tR_FREE (mflags);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer3->p? \",\": \"\", f->name, f->vaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"]}\");\n\t\t} else if (IS_MODE_CLASSDUMP (mode)) {\n\t\t\tif (c) {\n\t\t\t\tRBinFile *bf = r_bin_cur (r->bin);\n\t\t\t\tif (bf && bf->o) {\n\t\t\t\t\tif (bf->o->lang == R_BIN_NM_JAVA || (bf->o->info && bf->o->info->lang && strstr (bf->o->info->lang, \"dalvik\"))) {\n\t\t\t\t\t\tclassdump_java (r, c);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclassdump_objc (r, c);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tclassdump_objc (r, c);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tint m = 0;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" [0x%08\"PFMT64x\" - 0x%08\"PFMT64x\"] %6\"PFMT64d\" class %d %s\",\n\t\t\t\tc->addr, at_min, at_max, (at_max - at_min), c->index, c->name);\n\t\t\tif (c->super) {\n\t\t\t\tr_cons_printf (\" :: %s\\n\", c->super);\n\t\t\t} else {\n\t\t\t\tr_cons_newline ();\n\t\t\t}\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym->method_flags, mode);\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" method %d %s %s\\n\",\n\t\t\t\t\tsym->vaddr, m, mflags, sym->dname? sym->dname: sym->name);\n\t\t\t\tR_FREE (mflags);\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t\tfree (name);\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t}\n\n\treturn true;\n}\n\nstatic int bin_size(RCore *r, int mode) {\n\tut64 size = r_bin_get_size (r->bin);\n\tif (IS_MODE_SIMPLE (mode) || IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"%\"PFMT64u\"\\n\", size);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"f bin_size @ %\"PFMT64u\"\\n\", size);\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_core_cmdf (r, \"f bin_size @ %\"PFMT64u\"\\n\", size);\n\t} else {\n\t\tr_cons_printf (\"%\"PFMT64u\"\\n\", size);\n\t}\n\treturn true;\n}\n\nstatic int bin_libs(RCore *r, int mode) {\n\tRList *libs;\n\tRListIter *iter;\n\tchar* lib;\n\tint i = 0;\n\n\tif (!(libs = r_bin_get_libs (r->bin))) {\n\t\treturn false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Linked libraries]\");\n\t}\n\tr_list_foreach (libs, iter, lib) {\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\t// Nothing to set.\n\t\t\t// TODO: load libraries with iomaps?\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"\\\"CCa entry0 %s\\\"\\n\", lib);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"%s\\\"%s\\\"\", iter->p ? \",\" : \"\", lib);\n\t\t} else {\n\t\t\t// simple and normal print mode\n\t\t\tr_cons_println (lib);\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tif (i == 1) {\n\t\t\tr_cons_printf (\"\\n%i library\\n\", i);\n\t\t} else {\n\t\t\tr_cons_printf (\"\\n%i libraries\\n\", i);\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic void bin_mem_print(RList *mems, int perms, int depth, int mode) {\n\tRBinMem *mem;\n\tRListIter *iter;\n\tif (!mems) {\n\t\treturn;\n\t}\n\tr_list_foreach (mems, iter, mem) {\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"{\\\"name\\\":\\\"%s\\\",\\\"size\\\":%d,\\\"address\\\":%d,\"\n\t\t\t\t\t\"\\\"flags\\\":\\\"%s\\\"}\", mem->name, mem->size,\n\t\t\t\t\tmem->addr, r_str_rwx_i (mem->perms & perms));\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", mem->addr);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" +0x%04x %s %*s%-*s\\n\",\n\t\t\t\t\tmem->addr, mem->size, r_str_rwx_i (mem->perms & perms),\n\t\t\t\t\tdepth, \"\", 20-depth, mem->name);\n\t\t}\n\t\tif (mem->mirrors) {\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_printf (\",\");\n\t\t\t}\n\t\t\tbin_mem_print (mem->mirrors, mem->perms & perms, depth + 1, mode);\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tif (iter->n) {\n\t\t\t\tr_cons_printf (\",\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int bin_mem(RCore *r, int mode) {\n\tRList *mem = NULL;\n\tif (!r) {\n\t\treturn false;\n\t}\n\tif (!IS_MODE_JSON (mode)) {\n\t\tif (!(IS_MODE_RAD (mode) || IS_MODE_SET (mode))) {\n\t\t\tr_cons_println (\"[Memory]\\n\");\n\t\t}\n\t}\n\tif (!(mem = r_bin_get_mem (r->bin))) {\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_print(\"[]\");\n\t\t}\n\t\treturn false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t\tbin_mem_print (mem, 7, 0, R_MODE_JSON);\n\t\tr_cons_println (\"]\");\n\t\treturn true;\n\t} else if (!(IS_MODE_RAD (mode) || IS_MODE_SET (mode))) {\n\t\tbin_mem_print (mem, 7, 0, mode);\n\t}\n\treturn true;\n}\n\nstatic void bin_pe_versioninfo(RCore *r, int mode) {\n\tSdb *sdb = NULL;\n\tint num_version = 0;\n\tint num_stringtable = 0;\n\tint num_string = 0;\n\tconst char *format_version = \"bin/cur/info/vs_version_info/VS_VERSIONINFO%d\";\n\tconst char *format_stringtable = \"%s/string_file_info/stringtable%d\";\n\tconst char *format_string = \"%s/string%d\";\n\tif (!IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"=== VS_VERSIONINFO ===\\n\\n\");\n\t}\n\tbool firstit_dowhile = true;\n\tdo {\n\t\tchar *path_version = sdb_fmt (format_version, num_version);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path_version, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!firstit_dowhile && IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\",\");\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"{\\\"VS_FIXEDFILEINFO\\\":{\");\n\t\t} else {\n\t\t\tr_cons_printf (\"# VS_FIXEDFILEINFO\\n\\n\");\n\t\t}\n\t\tconst char *path_fixedfileinfo = sdb_fmt (\"%s/fixed_file_info\", path_version);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path_fixedfileinfo, 0))) {\n\t\t\tr_cons_printf (\"}\");\n\t\t\tbreak;\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"Signature\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"Signature\", 0));\n\t\t\tr_cons_printf (\"\\\"StrucVersion\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"StrucVersion\", 0));\n\t\t\tr_cons_printf (\"\\\"FileVersion\\\":\\\"%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\\",\",\n\t\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) & 0xFFFF,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) & 0xFFFF);\n\t\t\tr_cons_printf (\"\\\"ProductVersion\\\":\\\"%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\\",\",\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) & 0xFFFF,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) & 0xFFFF);\n\t\t\tr_cons_printf (\"\\\"FileFlagsMask\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"FileFlagsMask\", 0));\n\t\t\tr_cons_printf (\"\\\"FileFlags\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"FileFlags\", 0));\n\t\t\tr_cons_printf (\"\\\"FileOS\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"FileOS\", 0));\n\t\t\tr_cons_printf (\"\\\"FileType\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"FileType\", 0));\n\t\t\tr_cons_printf (\"\\\"FileSubType\\\":%\"PFMT64u, sdb_num_get (sdb, \"FileSubType\", 0));\n\t\t\tr_cons_printf (\"},\");\n\t\t} else {\n\t\t\tr_cons_printf (\"  Signature: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"Signature\", 0));\n\t\t\tr_cons_printf (\"  StrucVersion: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"StrucVersion\", 0));\n\t\t\tr_cons_printf (\"  FileVersion: %\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\n\",\n\t\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) & 0xFFFF,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) & 0xFFFF);\n\t\t\tr_cons_printf (\"  ProductVersion: %\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\n\",\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) & 0xFFFF,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) & 0xFFFF);\n\t\t\tr_cons_printf (\"  FileFlagsMask: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileFlagsMask\", 0));\n\t\t\tr_cons_printf (\"  FileFlags: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileFlags\", 0));\n\t\t\tr_cons_printf (\"  FileOS: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileOS\", 0));\n\t\t\tr_cons_printf (\"  FileType: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileType\", 0));\n\t\t\tr_cons_printf (\"  FileSubType: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileSubType\", 0));\n\t\t\tr_cons_newline ();\n\t\t}\n#if 0\n\t\tr_cons_printf (\"  FileDate: %d.%d.%d.%d\\n\",\n\t\t\tsdb_num_get (sdb, \"FileDateMS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"FileDateMS\", 0) & 0xFFFF,\n\t\t\tsdb_num_get (sdb, \"FileDateLS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"FileDateLS\", 0) & 0xFFFF);\n#endif\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"StringTable\\\":{\");\n\t\t} else {\n\t\t\tr_cons_printf (\"# StringTable\\n\\n\");\n\t\t}\n\t\tfor (num_stringtable = 0; sdb; num_stringtable++) {\n\t\t\tchar *path_stringtable = r_str_newf (format_stringtable, path_version, num_stringtable);\n\t\t\tsdb = sdb_ns_path (r->sdb, path_stringtable, 0);\n\t\t\tbool firstit_for = true;\n\t\t\tfor (num_string = 0; sdb; num_string++) {\n\t\t\t\tchar *path_string = r_str_newf (format_string, path_stringtable, num_string);\n\t\t\t\tsdb = sdb_ns_path (r->sdb, path_string, 0);\n\t\t\t\tif (sdb) {\n\t\t\t\t\tif (!firstit_for && IS_MODE_JSON (mode)) { r_cons_printf (\",\"); }\n\t\t\t\t\tint lenkey = 0;\n\t\t\t\t\tint lenval = 0;\n\t\t\t\t\tut8 *key_utf16 = sdb_decode (sdb_const_get (sdb, \"key\", 0), &lenkey);\n\t\t\t\t\tut8 *val_utf16 = sdb_decode (sdb_const_get (sdb, \"value\", 0), &lenval);\n\t\t\t\t\tut8 *key_utf8 = calloc (lenkey * 2, 1);\n\t\t\t\t\tut8 *val_utf8 = calloc (lenval * 2, 1);\n\t\t\t\t\tif (r_str_utf16_to_utf8 (key_utf8, lenkey * 2, key_utf16, lenkey, true) < 0\n\t\t\t\t\t\t|| r_str_utf16_to_utf8 (val_utf8, lenval * 2, val_utf16, lenval, true) < 0) {\n\t\t\t\t\t\teprintf (\"Warning: Cannot decode utf16 to utf8\\n\");\n\t\t\t\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\t\t\t\tchar *escaped_key_utf8 = r_str_escape ((char*)key_utf8);\n\t\t\t\t\t\tchar *escaped_val_utf8 = r_str_escape ((char*)val_utf8);\n\t\t\t\t\t\tr_cons_printf (\"\\\"%s\\\":\\\"%s\\\"\", escaped_key_utf8, escaped_val_utf8);\n\t\t\t\t\t\tfree (escaped_key_utf8);\n\t\t\t\t\t\tfree (escaped_val_utf8);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"  %s: %s\\n\", (char*)key_utf8, (char*)val_utf8);\n\t\t\t\t\t}\n\t\t\t\t\tfree (key_utf8);\n\t\t\t\t\tfree (val_utf8);\n\t\t\t\t\tfree (key_utf16);\n\t\t\t\t\tfree (val_utf16);\n\t\t\t\t}\n\t\t\t\tfirstit_for = false;\n\t\t\t\tfree (path_string);\n\t\t\t}\n\t\t\tfree (path_stringtable);\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"}}\");\n\t\t}\n\t\tnum_version++;\n\t\tfirstit_dowhile = false;\n\t} while (sdb);\n}\n\nstatic void bin_elf_versioninfo(RCore *r, int mode) {\n\tconst char *format = \"bin/cur/info/versioninfo/%s%d\";\n\tint num_versym;\n\tint num_verneed = 0;\n\tint num_version = 0;\n\tSdb *sdb = NULL;\n\tconst char *oValue = NULL;\n\tbool firstit_for_versym = true;\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{\\\"versym\\\":[\");\n\t}\n\tfor (num_versym = 0;; num_versym++) {\n\t\tconst char *versym_path = sdb_fmt (format, \"versym\", num_versym);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, versym_path, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 addr = sdb_num_get (sdb, \"addr\", 0);\n\t\tut64 offset = sdb_num_get (sdb, \"offset\", 0);\n\t\tut64 link = sdb_num_get (sdb, \"link\", 0);\n\t\tut64 num_entries = sdb_num_get (sdb, \"num_entries\", 0);\n\t\tconst char *section_name = sdb_const_get (sdb, \"section_name\", 0);\n\t\tconst char *link_section_name = sdb_const_get (sdb, \"link_section_name\", 0);\n\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tif (!firstit_for_versym) { r_cons_printf (\",\"); }\n\t\t\tr_cons_printf (\"{\\\"section_name\\\":\\\"%s\\\",\\\"address\\\":%\"PFMT64u\",\\\"offset\\\":%\"PFMT64u\",\",\n\t\t\t\t\tsection_name, (ut64)addr, (ut64)offset);\n\t\t\tr_cons_printf (\"\\\"link\\\":%\"PFMT64u\",\\\"link_section_name\\\":\\\"%s\\\",\\\"entries\\\":[\",\n\t\t\t\t\t(ut32)link, link_section_name);\n\t\t} else {\n\t\t\tr_cons_printf (\"Version symbols section '%s' contains %\"PFMT64u\" entries:\\n\", section_name, num_entries);\n\t\t\tr_cons_printf (\" Addr: 0x%08\"PFMT64x\"  Offset: 0x%08\"PFMT64x\"  Link: %x (%s)\\n\",\n\t\t\t\t(ut64)addr, (ut64)offset, (ut32)link, link_section_name);\n\t\t}\n\t\tint i;\n\t\tfor (i = 0; i < num_entries; i++) {\n\t\t\tconst char *key = sdb_fmt (\"entry%d\", i);\n\t\t\tconst char *value = sdb_const_get (sdb, key, 0);\n\t\t\tif (value) {\n\t\t\t\tif (oValue && !strcmp (value, oValue)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\t\tif (i > 0) { r_cons_printf (\",\"); }\n\t\t\t\t\tchar *escaped_value = r_str_escape (value);\n\t\t\t\t\tr_cons_printf (\"{\\\"idx\\\":%\"PFMT64u\",\\\"value\\\":\\\"%s\\\"}\",\n\t\t\t\t\t\t\t(ut64) i, escaped_value);\n\t\t\t\t\tfree (escaped_value);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"  0x%08\"PFMT64x\": \", (ut64) i);\n\t\t\t\t\tr_cons_printf (\"%s\\n\", value);\n\t\t\t\t}\n\t\t\t\toValue = value;\n\t\t\t}\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"]}\");\n\t\t} else {\n\t\t\tr_cons_printf (\"\\n\\n\");\n\t\t}\n\t\tfirstit_for_versym = false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"],\\\"verneed\\\":[\");\n\t}\n\n\tbool firstit_dowhile_verneed = true;\n\tdo {\n\t\tchar *verneed_path = r_str_newf (format, \"verneed\", num_verneed++);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, verneed_path, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tif (!firstit_dowhile_verneed) {\n\t\t\t\tr_cons_printf (\",\");\n\t\t\t}\n\t\t\tr_cons_printf (\"{\\\"section_name\\\":\\\"%s\\\",\\\"address\\\":%\"PFMT64u\",\\\"offset\\\":%\"PFMT64u\",\",\n\t\t\t\tsdb_const_get (sdb, \"section_name\", 0), sdb_num_get (sdb, \"addr\", 0), sdb_num_get (sdb, \"offset\", 0));\n\t\t\tr_cons_printf (\"\\\"link\\\":%\"PFMT64u\",\\\"link_section_name\\\":\\\"%s\\\",\\\"entries\\\":[\",\n\t\t\t\tsdb_num_get (sdb, \"link\", 0), sdb_const_get (sdb, \"link_section_name\", 0));\n\t\t} else {\n\t\t\tr_cons_printf (\"Version need section '%s' contains %d entries:\\n\",\n\t\t\t\tsdb_const_get (sdb, \"section_name\", 0), (int)sdb_num_get (sdb, \"num_entries\", 0));\n\n\t\t\tr_cons_printf (\" Addr: 0x%08\"PFMT64x, sdb_num_get (sdb, \"addr\", 0));\n\n\t\t\tr_cons_printf (\"  Offset: 0x%08\"PFMT64x\"  Link to section: %\"PFMT64d\" (%s)\\n\",\n\t\t\t\tsdb_num_get (sdb, \"offset\", 0), sdb_num_get (sdb, \"link\", 0),\n\t\t\t\tsdb_const_get (sdb, \"link_section_name\", 0));\n\t\t}\n\t\tbool firstit_for_verneed = true;\n\t\tfor (num_version = 0;; num_version++) {\n\t\t\tconst char *filename = NULL;\n\t\t\tint num_vernaux = 0;\n\n\t\t\tchar *path_version = sdb_fmt (\"%s/version%d\", verneed_path, num_version);\n\t\t\tif (!(sdb = sdb_ns_path (r->sdb, path_version, 0))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tif (!firstit_for_verneed) { r_cons_printf (\",\"); }\n\t\t\t\tr_cons_printf (\"{\\\"idx\\\":%\"PFMT64u\",\\\"vn_version\\\":%d,\",\n\t\t\t\t\tsdb_num_get (sdb, \"idx\", 0), (int)sdb_num_get (sdb, \"vn_version\", 0));\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"  0x%08\"PFMT64x\": Version: %d\",\n\t\t\t\t\tsdb_num_get (sdb, \"idx\", 0), (int)sdb_num_get (sdb, \"vn_version\", 0));\n\t\t\t}\n\n\t\t\tif ((filename = sdb_const_get (sdb, \"file_name\", 0))) {\n\t\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\t\tchar *escaped_filename = r_str_escape (filename);\n\t\t\t\t\tr_cons_printf (\"\\\"file_name\\\":\\\"%s\\\",\", escaped_filename);\n\t\t\t\t\tfree (escaped_filename);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"  File: %s\", filename);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_printf (\"\\\"cnt\\\":%d,\", (int)sdb_num_get (sdb, \"cnt\", 0));\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"  Cnt: %d\\n\", (int)sdb_num_get (sdb, \"cnt\", 0));\n\t\t\t}\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_printf (\"\\\"vernaux\\\":[\");\n\t\t\t}\n\t\t\tbool firstit_dowhile_vernaux = true;\n\t\t\tdo {\n\t\t\t\tconst char *path_vernaux = sdb_fmt (\"%s/vernaux%d\", path_version, num_vernaux++);\n\t\t\t\tif (!(sdb = sdb_ns_path (r->sdb, path_vernaux, 0))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\t\tif (!firstit_dowhile_vernaux) { r_cons_printf (\",\"); }\n\t\t\t\t\tr_cons_printf (\"{\\\"idx\\\":%\"PFMT64u\",\\\"name\\\":\\\"%s\\\",\",\n\t\t\t\t\t\tsdb_num_get (sdb, \"idx\", 0), sdb_const_get (sdb, \"name\", 0));\n\t\t\t\t\tr_cons_printf (\"\\\"flags\\\":\\\"%s\\\",\\\"version\\\":%d}\",\n\t\t\t\t\t\tsdb_const_get (sdb, \"flags\", 0), (int)sdb_num_get (sdb, \"version\", 0));\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"  0x%08\"PFMT64x\":   Name: %s\",\n\t\t\t\t\t\tsdb_num_get (sdb, \"idx\", 0), sdb_const_get (sdb, \"name\", 0));\n\t\t\t\t\tr_cons_printf (\"  Flags: %s Version: %d\\n\",\n\t\t\t\t\t\tsdb_const_get (sdb, \"flags\", 0), (int)sdb_num_get (sdb, \"version\", 0));\n\t\t\t\t}\n\t\t\t\tfirstit_dowhile_vernaux = false;\n\t\t\t} while (sdb);\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_printf (\"]}\");\n\t\t\t}\n\t\t\tfirstit_for_verneed = false;\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"]}\");\n\t\t}\n\t\tfirstit_dowhile_verneed = false;\n\t\tfree (verneed_path);\n\t} while (sdb);\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]}\");\n\t}\n}\n\nstatic void bin_mach0_versioninfo(RCore *r) {\n\t/* TODO */\n}\n\nstatic void bin_pe_resources(RCore *r, int mode) {\n\tSdb *sdb = NULL;\n\tint index = 0;\n\tPJ *pj = NULL;\n\tconst char *pe_path = \"bin/cur/info/pe_resource\";\n\tif (!(sdb = sdb_ns_path (r->sdb, pe_path, 0))) {\n\t\treturn;\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_RESOURCES);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs resources\\n\");\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tpj = pj_new ();\n\t\tpj_a (pj);\n\t}\n\twhile (true) {\n\t\tconst char *timestrKey = sdb_fmt (\"resource.%d.timestr\", index);\n\t\tconst char *vaddrKey = sdb_fmt (\"resource.%d.vaddr\", index);\n\t\tconst char *sizeKey  = sdb_fmt (\"resource.%d.size\", index);\n\t\tconst char *typeKey  = sdb_fmt (\"resource.%d.type\", index);\n\t\tconst char *languageKey = sdb_fmt (\"resource.%d.language\", index);\n\t\tconst char *nameKey = sdb_fmt (\"resource.%d.name\", index);\n\t\tchar *timestr = sdb_get (sdb, timestrKey, 0);\n\t\tif (!timestr) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 vaddr = sdb_num_get (sdb, vaddrKey, 0);\n\t\tint size = (int)sdb_num_get (sdb, sizeKey, 0);\n\t\tchar *name = sdb_get (sdb, nameKey, 0);\n\t\tchar *type = sdb_get (sdb, typeKey, 0);\n\t\tchar *lang = sdb_get (sdb, languageKey, 0);\n\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tconst char *name = sdb_fmt (\"resource.%d\", index);\n\t\t\tr_flag_set (r->flags, name, vaddr, size);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"f resource.%d %d 0x%08\"PFMT32x\"\\n\", index, size, vaddr);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tpj_o (pj);\n\t\t\tpj_ks (pj, \"name\", name);\n\t\t\tpj_ki (pj, \"index\", index);\n\t\t\tpj_ks (pj, \"type\", type);\n\t\t\tpj_kn (pj, \"vaddr\", vaddr);\n\t\t\tpj_ki (pj, \"size\", size);\n\t\t\tpj_ks (pj, \"lang\", lang);\n\t\t\tpj_ks (pj, \"timestamp\", timestr);\n\t\t\tpj_end (pj);\n\t\t} else {\n\t\t\tchar humansz[8];\n\t\t\tr_num_units (humansz, sizeof (humansz), size);\n\t\t\tr_cons_printf (\"Resource %d\\n\", index);\n\t\t\tr_cons_printf (\"  name: %s\\n\", name);\n\t\t\tr_cons_printf (\"  timestamp: %s\\n\", timestr);\n\t\t\tr_cons_printf (\"  vaddr: 0x%08\"PFMT64x\"\\n\", vaddr);\n\t\t\tr_cons_printf (\"  size: %s\\n\", humansz);\n\t\t\tr_cons_printf (\"  type: %s\\n\", type);\n\t\t\tr_cons_printf (\"  language: %s\\n\", lang);\n\t\t}\n\n\t\tR_FREE (timestr);\n\t\tR_FREE (name);\n\t\tR_FREE (type);\n\t\tR_FREE (lang)\n\n\t\tindex++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tpj_end (pj);\n\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\tpj_free (pj);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs *\");\n\t}\n}\n\nstatic void bin_no_resources(RCore *r, int mode) {\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[]\");\n\t}\n}\n\nstatic int bin_resources(RCore *r, int mode) {\n\tconst RBinInfo *info = r_bin_get_info (r->bin);\n\tif (!info || !info->rclass) {\n\t\treturn false;\n\t}\n\tif (!strncmp (\"pe\", info->rclass, 2)) {\n\t\tbin_pe_resources (r, mode);\n\t} else {\n\t\tbin_no_resources (r, mode);\n\t}\n\treturn true;\n}\n\nstatic int bin_versioninfo(RCore *r, int mode) {\n\tconst RBinInfo *info = r_bin_get_info (r->bin);\n\tif (!info || !info->rclass) {\n\t\treturn false;\n\t}\n\tif (!strncmp (\"pe\", info->rclass, 2)) {\n\t\tbin_pe_versioninfo (r, mode);\n\t} else if (!strncmp (\"elf\", info->rclass, 3)) {\n\t\tbin_elf_versioninfo (r, mode);\n\t} else if (!strncmp (\"mach0\", info->rclass, 5)) {\n\t\tbin_mach0_versioninfo (r);\n\t} else {\n\t\tr_cons_println (\"Unknown format\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int bin_signature(RCore *r, int mode) {\n\tRBinFile *cur = r_bin_cur (r->bin);\n\tRBinPlugin *plg = r_bin_file_cur_plugin (cur);\n\tif (plg && plg->signature) {\n\t\tconst char *signature = plg->signature (cur, IS_MODE_JSON (mode));\n\t\tr_cons_println (signature);\n\t\tfree ((char*) signature);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API void r_core_bin_export_info_rad(RCore *core) {\n\tSdb *db = NULL;\n\tchar *flagname = NULL, *offset = NULL;\n\tRBinFile *bf = r_bin_cur (core->bin);\n\tif (!bf) {\n\t\treturn;\n\t}\n\tdb = sdb_ns (bf->sdb, \"info\", 0);;\n\tif (db) {\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tr_cons_printf (\"fs format\\n\");\n\t\t// iterate over all keys\n\t\tSdbList *ls = sdb_foreach_list (db, false);\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tchar *k = sdbkv_key (kv);\n\t\t\tchar *v = sdbkv_value (kv);\n\t\t\tchar *dup = strdup (k);\n\t\t\t//printf (\"?e (%s) (%s)\\n\", k, v);\n\t\t\tif ((flagname = strstr (dup, \".offset\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tflagname = dup;\n\t\t\t\tr_cons_printf (\"f %s @ %s\\n\", flagname, v);\n\t\t\t\tfree (offset);\n\t\t\t\toffset = strdup (v);\n\t\t\t}\n\t\t\tif ((flagname = strstr (dup, \".cparse\"))) {\n\t\t\t\tr_cons_printf (\"\\\"td %s\\\"\\n\", v);\n\t\t\t}\n\t\t\tfree (dup);\n\t\t}\n\t\tR_FREE (offset);\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tchar *k = sdbkv_key (kv);\n\t\t\tchar *v = sdbkv_value (kv);\n\t\t\tchar *dup = strdup (k);\n\t\t\tif ((flagname = strstr (dup, \".format\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tif (!offset) {\n\t\t\t\t\toffset = strdup (\"0\");\n\t\t\t\t}\n\t\t\t\tflagname = dup;\n\t\t\t\tr_cons_printf (\"pf.%s %s\\n\", flagname, v);\n\t\t\t}\n\t\t\tfree (dup);\n\t\t}\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tchar *k = sdbkv_key (kv);\n\t\t\tchar *v = sdbkv_value (kv);\n\t\t\tchar *dup = strdup (k);\n\t\t\tif ((flagname = strstr (dup, \".format\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tif (!offset) {\n\t\t\t\t\toffset = strdup (\"0\");\n\t\t\t\t}\n\t\t\t\tflagname = dup;\n\t\t\t\tint fmtsize = r_print_format_struct_size (core->print, v, 0, 0);\n\t\t\t\tchar *offset_key = r_str_newf (\"%s.offset\", flagname);\n\t\t\t\tconst char *off = sdb_const_get (db, offset_key, 0);\n\t\t\t\tfree (offset_key);\n\t\t\t\tif (off) {\n\t\t\t\t\tr_cons_printf (\"Cf %d %s @ %s\\n\", fmtsize, v, off);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((flagname = strstr (dup, \".size\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tflagname = dup;\n\t\t\t\tr_cons_printf (\"fl %s %s\\n\", flagname, v);\n\t\t\t}\n\t\t\tfree (dup);\n\t\t}\n\t\tfree (offset);\n\t}\n}\n\nstatic int bin_header(RCore *r, int mode) {\n\tRBinFile *cur = r_bin_cur (r->bin);\n\tRBinPlugin *plg = r_bin_file_cur_plugin (cur);\n\tif (plg && plg->header) {\n\t\tplg->header (cur);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_info(RCore *core, int action, int mode, int va, RCoreBinFilter *filter, const char *chksum) {\n\tint ret = true;\n\tconst char *name = NULL;\n\tut64 at = 0, loadaddr = r_bin_get_laddr (core->bin);\n\tif (filter && filter->offset) {\n\t\tat = filter->offset;\n\t}\n\tif (filter && filter->name) {\n\t\tname = filter->name;\n\t}\n\n\t// use our internal values for va\n\tva = va ? VA_TRUE : VA_FALSE;\n#if 0\n\tif (r_config_get_i (core->config, \"anal.strings\")) {\n\t\tr_core_cmd0 (core, \"aar\");\n\t}\n#endif\n\tif ((action & R_CORE_BIN_ACC_STRINGS)) {\n\t\tret &= bin_strings (core, mode, va);\n\t}\n\tif ((action & R_CORE_BIN_ACC_RAW_STRINGS)) {\n\t\tret &= bin_raw_strings (core, mode, va);\n\t}\n\tif ((action & R_CORE_BIN_ACC_INFO)) {\n\t\tret &= bin_info (core, mode, loadaddr);\n\t}\n\tif ((action & R_CORE_BIN_ACC_MAIN)) {\n\t\tret &= bin_main (core, mode, va);\n\t}\n\tif ((action & R_CORE_BIN_ACC_DWARF)) {\n\t\tret &= bin_dwarf (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_PDB)) {\n\t\tret &= bin_pdb (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_SOURCE)) {\n\t\tret &= bin_source (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_ENTRIES)) {\n\t\tret &= bin_entry (core, mode, loadaddr, va, false);\n\t}\n\tif ((action & R_CORE_BIN_ACC_INITFINI)) {\n\t\tret &= bin_entry (core, mode, loadaddr, va, true);\n\t}\n\tif ((action & R_CORE_BIN_ACC_SECTIONS)) {\n\t\tret &= bin_sections (core, mode, loadaddr, va, at, name, chksum, false);\n\t}\n\tif ((action & R_CORE_BIN_ACC_SEGMENTS)) {\n\t\tret &= bin_sections (core, mode, loadaddr, va, at, name, chksum, true);\n\t}\n\tif (r_config_get_i (core->config, \"bin.relocs\")) {\n\t\tif ((action & R_CORE_BIN_ACC_RELOCS)) {\n\t\t\tret &= bin_relocs (core, mode, va);\n\t\t}\n\t}\n\tif ((action & R_CORE_BIN_ACC_LIBS)) {\n\t\tret &= bin_libs (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_IMPORTS)) { // 5s\n\t\tret &= bin_imports (core, mode, va, name);\n\t}\n\tif ((action & R_CORE_BIN_ACC_EXPORTS)) {\n\t\tret &= bin_symbols (core, mode, loadaddr, va, at, name, true, chksum);\n\t}\n\tif ((action & R_CORE_BIN_ACC_SYMBOLS)) { // 6s\n\t\tret &= bin_symbols (core, mode, loadaddr, va, at, name, false, chksum);\n\t}\n\tif ((action & R_CORE_BIN_ACC_CLASSES)) { // 6s\n\t\tret &= bin_classes (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_TRYCATCH)) {\n\t\tret &= bin_trycatch (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_SIZE)) {\n\t\tret &= bin_size (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_MEM)) {\n\t\tret &= bin_mem (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_VERSIONINFO)) {\n\t\tret &= bin_versioninfo (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_RESOURCES)) {\n\t\tret &= bin_resources (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_SIGNATURE)) {\n\t\tret &= bin_signature (core, mode);\n\t}\n\tif ((action & R_CORE_BIN_ACC_FIELDS)) {\n\t\tif (IS_MODE_SIMPLE (mode)) {\n\t\t\tif ((action & R_CORE_BIN_ACC_HEADER) || action & R_CORE_BIN_ACC_FIELDS) {\n\t\t\t\t/* ignore mode, just for quiet/simple here */\n\t\t\t\tret &= bin_fields (core, 0, va);\n\t\t\t}\n\t\t} else {\n\t\t\tif (IS_MODE_NORMAL (mode)) {\n\t\t\t\tret &= bin_header (core, mode);\n\t\t\t} else {\n\t\t\t\tif ((action & R_CORE_BIN_ACC_HEADER) || action & R_CORE_BIN_ACC_FIELDS) {\n\t\t\t\t\tret &= bin_fields (core, mode, va);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nR_API int r_core_bin_set_arch_bits(RCore *r, const char *name, const char * arch, ut16 bits) {\n\tint fd = r_io_fd_get_current (r->io);\n\tRIODesc *desc = r_io_desc_get (r->io, fd);\n\tRBinFile *curfile, *binfile = NULL;\n\tif (!name) {\n\t\tif (!desc || !desc->name) {\n\t\t\treturn false;\n\t\t}\n\t\tname = desc->name;\n\t}\n\t/* Check if the arch name is a valid name */\n\tif (!r_asm_is_valid (r->assembler, arch)) {\n\t\treturn false;\n\t}\n\t/* Find a file with the requested name/arch/bits */\n\tbinfile = r_bin_file_find_by_arch_bits (r->bin, arch, bits);\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (!r_bin_use_arch (r->bin, arch, bits, name)) {\n\t\treturn false;\n\t}\n\tcurfile = r_bin_cur (r->bin);\n\t//set env if the binfile changed or we are dealing with xtr\n\tif (curfile != binfile || binfile->curxtr) {\n\t\tr_core_bin_set_cur (r, binfile);\n\t\treturn r_core_bin_set_env (r, binfile);\n\t}\n\treturn true;\n}\n\nR_API int r_core_bin_update_arch_bits(RCore *r) {\n\tRBinFile *binfile = NULL;\n\tconst char *name = NULL, *arch = NULL;\n\tut16 bits = 0;\n\tif (!r) {\n\t\treturn 0;\n\t}\n\tif (r->assembler) {\n\t\tbits = r->assembler->bits;\n\t   \tif (r->assembler->cur) {\n\t\t\tarch = r->assembler->cur->arch;\n\t\t}\n\t}\n\tbinfile = r_bin_cur (r->bin);\n\tname = binfile ? binfile->file : NULL;\n\tif (binfile && binfile->curxtr) {\n\t\tr_anal_hint_clear (r->anal);\n\t}\n\treturn r_core_bin_set_arch_bits (r, name, arch, bits);\n}\n\nR_API bool r_core_bin_raise(RCore *core, ut32 bfid) {\n\tif (!r_bin_select_bfid (core->bin, bfid)) {\n\t\treturn false;\n\t}\n\tRBinFile *bf = r_bin_cur (core->bin);\n\tif (bf) {\n\t\tr_io_use_fd (core->io, bf->fd);\n\t}\n\t// it should be 0 to use r_io_use_fd in r_core_block_read\n\tcore->switch_file_view = 0;\n\treturn bf && r_core_bin_set_env (core, bf) && r_core_block_read (core);\n}\n\nR_API bool r_core_bin_delete(RCore *core, ut32 bf_id) {\n\tif (bf_id == UT32_MAX) {\n\t\treturn false;\n\t}\n#if 0\n\tif (!r_bin_object_delete (core->bin, bf_id)) {\n\t\treturn false;\n\t}\n// TODO: use rbinat()\n\tRBinFile *bf = r_bin_cur (core->bin);\n\tif (bf) {\n\t\tr_io_use_fd (core->io, bf->fd);\n\t}\n#endif\n\tr_bin_file_delete (core->bin, bf_id);\n\tRBinFile *bf = r_bin_file_at (core->bin, core->offset);\n\tif (bf) {\n\t\tr_io_use_fd (core->io, bf->fd);\n\t}\n\tcore->switch_file_view = 0;\n\treturn bf && r_core_bin_set_env (core, bf) && r_core_block_read (core);\n}\n\nstatic bool r_core_bin_file_print(RCore *core, RBinFile *bf, int mode) {\n\tr_return_val_if_fail (core && bf && bf->o, NULL);\n\tconst char *name = bf ? bf->file : NULL;\n\t(void)r_bin_get_info (core->bin); // XXX is this necssary for proper iniitialization\n\tut32 bin_sz = bf ? bf->size : 0;\n\t// TODO: handle mode to print in json and r2 commands\n\n\tswitch (mode) {\n\tcase '*':\n\t\t{\n\t\t\tchar *n = __filterShell (name);\n\t\t\tr_cons_printf (\"oba 0x%08\"PFMT64x\" %s # %d\\n\", bf->o->boffset, n, bf->id);\n\t\t\tfree (n);\n\t\t}\n\t\tbreak;\n\tcase 'q':\n\t\tr_cons_printf (\"%d\\n\", bf->id);\n\t\tbreak;\n\tcase 'j':\n\t\t// XXX there's only one binobj for each bf...so we should change that json\n\t\t// TODO: use pj API\n\t\tr_cons_printf (\"{\\\"name\\\":\\\"%s\\\",\\\"iofd\\\":%d,\\\"bfid\\\":%d,\\\"size\\\":%d,\\\"objs\\\":[\",\n\t\t\tname? name: \"\", bf->fd, bf->id, bin_sz);\n\t\t{\n\t\t\tRBinObject *obj = bf->o;\n\t\t\tRBinInfo *info = obj->info;\n\t\t\tut8 bits = info ? info->bits : 0;\n\t\t\tconst char *asmarch = r_config_get (core->config, \"asm.arch\");\n\t\t\tconst char *arch = info ? info->arch ? info->arch: asmarch : \"unknown\";\n\t\t\tr_cons_printf (\"{\\\"arch\\\":\\\"%s\\\",\\\"bits\\\":%d,\\\"binoffset\\\":%\"\n\t\t\t\t\tPFMT64d\",\\\"objsize\\\":%\"PFMT64d\"}\",\n\t\t\t\t\tarch, bits, obj->boffset, obj->obj_size);\n\t\t}\n\t\tr_cons_print (\"]}\");\n\t\tbreak;\n\tdefault:\n\t\t{\n\t\t\tRBinInfo *info = bf->o->info;\n\t\t\tut8 bits = info ? info->bits : 0;\n\t\t\tconst char *asmarch = r_config_get (core->config, \"asm.arch\");\n\t\t\tconst char *arch = info ? info->arch ? info->arch: asmarch: \"unknown\";\n\t\t\tr_cons_printf (\"%d %d %s-%d ba:0x%08\"PFMT64x\" sz:%\"PFMT64d\" %s\\n\",\n\t\t\t\tbf->id, bf->fd, arch, bits, bf->o->baddr, bf->o->size, name);\n\t\t}\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nR_API int r_core_bin_list(RCore *core, int mode) {\n\t// list all binfiles and there objects and there archs\n\tint count = 0;\n\tRListIter *iter;\n\tRBinFile *binfile = NULL; //, *cur_bf = r_bin_cur (core->bin) ;\n\tRBin *bin = core->bin;\n\tconst RList *binfiles = bin ? bin->binfiles: NULL;\n\tif (!binfiles) {\n\t\treturn false;\n\t}\n\tif (mode == 'j') {\n\t\tr_cons_print (\"[\");\n\t}\n\tr_list_foreach (binfiles, iter, binfile) {\n\t\tr_core_bin_file_print (core, binfile, mode);\n\t\tif (iter->n && mode == 'j') {\n\t\t\tr_cons_print (\",\");\n\t\t}\n\t}\n\tif (mode == 'j') {\n\t\tr_cons_println (\"]\");\n\t}\n\treturn count;\n}\n\nR_API char *r_core_bin_method_flags_str(ut64 flags, int mode) {\n\tint i, len = 0;\n\n\tRStrBuf *buf = r_strbuf_new (\"\");\n\tif (IS_MODE_SET (mode) || IS_MODE_RAD (mode)) {\n\t\tif (!flags) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tut64 flag = flags & (1ULL << i);\n\t\t\tif (flag) {\n\t\t\t\tconst char *flag_string = r_bin_get_meth_flag_string (flag, false);\n\t\t\t\tif (flag_string) {\n\t\t\t\t\tr_strbuf_appendf (buf, \".%s\", flag_string);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tif (!flags) {\n\t\t\tr_strbuf_append (buf, \"[]\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tr_strbuf_append (buf, \"[\");\n\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tut64 flag = flags & (1ULL << i);\n\t\t\tif (flag) {\n\t\t\t\tconst char *flag_string = r_bin_get_meth_flag_string (flag, false);\n\t\t\t\tif (len != 0) {\n\t\t\t\t\tr_strbuf_append (buf, \",\");\n\t\t\t\t}\n\t\t\t\tif (flag_string) {\n\t\t\t\t\tr_strbuf_appendf (buf, \"\\\"%s\\\"\", flag_string);\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (buf, \"\\\"0x%08\"PFMT64x\"\\\"\", flag);\n\t\t\t\t}\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\n\t\tr_strbuf_append (buf, \"]\");\n\t} else {\n\t\tint pad_len = 4; //TODO: move to a config variable\n\n\t\tif (!flags) {\n\t\t\tgoto padding;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tut64 flag = flags & (1ULL << i);\n\t\t\tif (flag) {\n\t\t\t\tconst char *flag_string = r_bin_get_meth_flag_string (flag, true);\n\t\t\t\tif (flag_string) {\n\t\t\t\t\tr_strbuf_append (buf, flag_string);\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_append (buf, \"?\");\n\t\t\t\t}\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\npadding:\n\t\tfor ( ; len < pad_len; len++) {\n\t\t\tr_strbuf_append (buf, \" \");\n\t\t}\n\t}\nout:\n\treturn r_strbuf_drain (buf);\n}\n"], "filenames": ["libr/core/cbin.c"], "buggy_code_start_loc": [69], "buggy_code_end_loc": [2232], "fixing_code_start_loc": [70], "fixing_code_end_loc": [2236], "type": "CWE-78", "message": "In radare2 before 3.9.0, a command injection vulnerability exists in bin_symbols() in libr/core/cbin.c. By using a crafted executable file, it's possible to execute arbitrary shell commands with the permissions of the victim. This vulnerability is due to an insufficient fix for CVE-2019-14745 and improper handling of symbol names embedded in executables.", "other": {"cve": {"id": "CVE-2019-16718", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-23T14:15:10.447", "lastModified": "2020-11-16T19:21:58.137", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In radare2 before 3.9.0, a command injection vulnerability exists in bin_symbols() in libr/core/cbin.c. By using a crafted executable file, it's possible to execute arbitrary shell commands with the permissions of the victim. This vulnerability is due to an insufficient fix for CVE-2019-14745 and improper handling of symbol names embedded in executables."}, {"lang": "es", "value": "En radare2 versiones anteriores a 3.9.0, se presenta una vulnerabilidad de inyecci\u00f3n de comando en la funci\u00f3n bin_symbols() en el archivo libr/core/cbin.c. Mediante el uso de un archivo ejecutable dise\u00f1ado, es posible llevar a cabo comandos de shell arbitrarios con los permisos de la v\u00edctima. Esta vulnerabilidad es debido a una correcci\u00f3n insuficiente para el CVE-2019-14745 y al manejo inapropiado de los nombres de s\u00edmbolos insertados en ejecutables."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.9.0", "matchCriteriaId": "9E2FF4CE-39E7-44D1-920D-BD04A8B94ACD"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/5411543a310a470b1257fb93273cdd6e8dfcb3af", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/radareorg/radare2/commit/dd739f5a45b3af3d1f65f00fe19af1dbfec7aea7", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/radareorg/radare2/compare/3.8.0...3.9.0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/5411543a310a470b1257fb93273cdd6e8dfcb3af"}}