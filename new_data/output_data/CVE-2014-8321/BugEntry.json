{"buggy_code": ["/*\n *  pcap-compatible 802.11 packet sniffer\n *\n *  Copyright (C) 2006-2013 Thomas d'Otreppe\n *  Copyright (C) 2004, 2005 Christophe Devine\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n *\n *  In addition, as a special exception, the copyright holders give\n *  permission to link the code of portions of this program with the\n *  OpenSSL library under certain conditions as described in each\n *  individual source file, and distribute linked combinations\n *  including the two.\n *  You must obey the GNU General Public License in all respects\n *  for all of the code used other than OpenSSL. *  If you modify\n *  file(s) with this exception, you may extend this exception to your\n *  version of the file(s), but you are not obligated to do so. *  If you\n *  do not wish to do so, delete this exception statement from your\n *  version. *  If you delete this exception statement from all source\n *  files in the program, then also delete it here.\n */\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n\n#ifndef TIOCGWINSZ\n\t#include <sys/termios.h>\n#endif\n\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <errno.h>\n#include <time.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <termios.h>\n\n#include <sys/wait.h>\n\n#ifdef HAVE_PCRE\n#include <pcre.h>\n#endif\n\n#include \"version.h\"\n#include \"pcap.h\"\n#include \"uniqueiv.h\"\n#include \"crypto.h\"\n#include \"osdep/osdep.h\"\n#include \"airodump-ng.h\"\n#include \"osdep/common.h\"\n#include \"common.h\"\n\n#ifdef USE_GCRYPT\n\tGCRY_THREAD_OPTION_PTHREAD_IMPL;\n#endif\n\nvoid dump_sort( void );\nvoid dump_print( int ws_row, int ws_col, int if_num );\n\nchar * get_manufacturer_from_string(char * buffer) {\n\tchar * manuf = NULL;\n\tchar * buffer_manuf;\n\tif (buffer != NULL && strlen(buffer) > 0) {\n\t\tbuffer_manuf = strstr(buffer, \"(hex)\");\n\t\tif (buffer_manuf != NULL) {\n\t\t\tbuffer_manuf += 6; // skip '(hex)' and one more character (there's at least one 'space' character after that string)\n\t\t\twhile (*buffer_manuf == '\\t' || *buffer_manuf == ' ') {\n\t\t\t\t++buffer_manuf;\n\t\t\t}\n\n\t\t\t// Did we stop at the manufacturer\n\t\t\tif (*buffer_manuf != '\\0') {\n\n\t\t\t\t// First make sure there's no end of line\n\t\t\t\tif (buffer_manuf[strlen(buffer_manuf) - 1] == '\\n' || buffer_manuf[strlen(buffer_manuf) - 1] == '\\r') {\n\t\t\t\t\tbuffer_manuf[strlen(buffer_manuf) - 1] = '\\0';\n\t\t\t\t\tif (*buffer_manuf != '\\0' && (buffer_manuf[strlen(buffer_manuf) - 1] == '\\n' || buffer[strlen(buffer_manuf) - 1] == '\\r')) {\n\t\t\t\t\t\tbuffer_manuf[strlen(buffer_manuf) - 1] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*buffer_manuf != '\\0') {\n\t\t\t\t\tif ((manuf = (char *)malloc((strlen(buffer_manuf) + 1) * sizeof(char))) == NULL) {\n\t\t\t\t\t\tperror(\"malloc failed\");\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tsnprintf(manuf, strlen(buffer_manuf) + 1, \"%s\", buffer_manuf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn manuf;\n}\n\nvoid textcolor(int attr, int fg, int bg)\n{\tchar command[13];\n\n\t/* Command is the control command to the terminal */\n\tsprintf(command, \"%c[%d;%d;%dm\", 0x1B, attr, fg + 30, bg + 40);\n\tfprintf(stderr, \"%s\", command);\n\tfflush(stderr);\n}\n\nvoid textcolor_fg(int fg)\n{\tchar command[13];\n\n\t/* Command is the control command to the terminal */\n\tsprintf(command, \"\\033[%dm\", fg + 30);\n\tfprintf(stderr, \"%s\", command);\n\tfflush(stderr);\n}\n\nvoid textcolor_bg(int bg)\n{\tchar command[13];\n\n\t/* Command is the control command to the terminal */\n\tsprintf(command, \"\\033[%dm\", bg + 40);\n\tfprintf(stderr, \"%s\", command);\n\tfflush(stderr);\n}\n\nvoid textstyle(int attr)\n{\tchar command[13];\n\n\t/* Command is the control command to the terminal */\n\tsprintf(command, \"\\033[%im\", attr);\n\tfprintf(stderr, \"%s\", command);\n\tfflush(stderr);\n}\n\nvoid reset_term() {\n  struct termios oldt,\n                 newt;\n  tcgetattr( STDIN_FILENO, &oldt );\n  newt = oldt;\n  newt.c_lflag |= ( ICANON | ECHO );\n  tcsetattr( STDIN_FILENO, TCSANOW, &newt );\n}\n\nint mygetch( ) {\n  struct termios oldt,\n                 newt;\n  int            ch;\n  tcgetattr( STDIN_FILENO, &oldt );\n  newt = oldt;\n  newt.c_lflag &= ~( ICANON | ECHO );\n  tcsetattr( STDIN_FILENO, TCSANOW, &newt );\n  ch = getchar();\n  tcsetattr( STDIN_FILENO, TCSANOW, &oldt );\n  return ch;\n}\n\nvoid resetSelection()\n{\n    G.sort_by = SORT_BY_POWER;\n    G.sort_inv = 1;\n\n    G.start_print_ap=1;\n    G.start_print_sta=1;\n    G.selected_ap=1;\n    G.selected_sta=1;\n    G.selection_ap=0;\n    G.selection_sta=0;\n    G.mark_cur_ap=0;\n    G.skip_columns=0;\n    G.do_pause=0;\n    G.do_sort_always=0;\n    memset(G.selected_bssid, '\\x00', 6);\n}\n\n#define KEY_TAB\t\t0x09\t//switch between APs/clients for scrolling\n#define KEY_SPACE\t0x20\t//pause/resume output\n#define KEY_ARROW_UP\t0x41\t//scroll\n#define KEY_ARROW_DOWN\t0x42\t//scroll\n#define KEY_ARROW_RIGHT 0x43\t//scroll\n#define KEY_ARROW_LEFT\t0x44\t//scroll\n#define KEY_a\t\t0x61\t//cycle through active information (ap/sta/ap+sta/ap+sta+ack)\n#define KEY_c\t\t0x63\t//cycle through channels\n#define KEY_d\t\t0x64\t//default mode\n#define KEY_i\t\t0x69\t//inverse sorting\n#define KEY_m\t\t0x6D\t//mark current AP\n#define KEY_n\t\t0x6E\t//?\n#define KEY_r\t\t0x72\t//realtime sort (de)activate\n#define KEY_s\t\t0x73\t//cycle through sorting\n\nvoid input_thread( void *arg) {\n\n    if(!arg){}\n\n    while( G.do_exit == 0 ) {\n\tint keycode=0;\n\n\tkeycode=mygetch();\n\n\tif(keycode == KEY_s) {\n\t    G.sort_by++;\n\t    G.selection_ap = 0;\n\t    G.selection_sta = 0;\n\n\t    if(G.sort_by > MAX_SORT)\n\t\tG.sort_by = 0;\n\n\t    switch(G.sort_by) {\n\t\tcase SORT_BY_NOTHING:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by first seen\");\n\t\t    break;\n\t\tcase SORT_BY_BSSID:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by bssid\");\n\t\t    break;\n\t\tcase SORT_BY_POWER:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by power level\");\n\t\t    break;\n\t\tcase SORT_BY_BEACON:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by beacon number\");\n\t\t    break;\n\t\tcase SORT_BY_DATA:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by number of data packets\");\n\t\t    break;\n\t\tcase SORT_BY_PRATE:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by packet rate\");\n\t\t    break;\n\t\tcase SORT_BY_CHAN:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by channel\");\n\t\t    break;\n\t\tcase SORT_BY_MBIT:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by max data rate\");\n\t\t    break;\n\t\tcase SORT_BY_ENC:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by encryption\");\n\t\t    break;\n\t\tcase SORT_BY_CIPHER:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by cipher\");\n\t\t    break;\n\t\tcase SORT_BY_AUTH:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by authentication\");\n\t\t    break;\n\t\tcase SORT_BY_ESSID:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by ESSID\");\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t    pthread_mutex_lock( &(G.mx_sort) );\n\t\tdump_sort();\n\t    pthread_mutex_unlock( &(G.mx_sort) );\n\t}\n\n\tif(keycode == KEY_SPACE) {\n\t    G.do_pause = (G.do_pause+1)%2;\n\t    if(G.do_pause) {\n\t\tsnprintf(G.message, sizeof(G.message), \"][ paused output\");\n\t\tpthread_mutex_lock( &(G.mx_print) );\n\n\t\t    fprintf( stderr, \"\\33[1;1H\" );\n\t\t    dump_print( G.ws.ws_row, G.ws.ws_col, G.num_cards );\n\t\t    fprintf( stderr, \"\\33[J\" );\n\t\t    fflush(stderr);\n\n\t\tpthread_mutex_unlock( &(G.mx_print) );\n\t    }\n\t    else\n\t\tsnprintf(G.message, sizeof(G.message), \"][ resumed output\");\n\t}\n\n\tif(keycode == KEY_r) {\n\t    G.do_sort_always = (G.do_sort_always+1)%2;\n\t    if(G.do_sort_always)\n\t\tsnprintf(G.message, sizeof(G.message), \"][ realtime sorting activated\");\n\t    else\n\t\tsnprintf(G.message, sizeof(G.message), \"][ realtime sorting deactivated\");\n\t}\n\n\tif(keycode == KEY_m) {\n\t    G.mark_cur_ap = 1;\n\t}\n\n\tif(keycode == KEY_ARROW_DOWN) {\n\t    if(G.selection_ap == 1) {\n\t\tG.selected_ap++;\n\t    }\n\t    if(G.selection_sta == 1) {\n\t\tG.selected_sta++;\n\t    }\n\t}\n\n\tif(keycode == KEY_ARROW_UP) {\n\t    if(G.selection_ap == 1) {\n\t\tG.selected_ap--;\n\t\tif(G.selected_ap < 1)\n\t\t    G.selected_ap = 1;\n\t    }\n\t    if(G.selection_sta == 1) {\n\t\tG.selected_sta--;\n\t\tif(G.selected_sta < 1)\n\t\t    G.selected_sta = 1;\n\t    }\n\t}\n\n\tif(keycode == KEY_i) {\n\t    G.sort_inv*=-1;\n\t    if(G.sort_inv < 0)\n\t\tsnprintf(G.message, sizeof(G.message), \"][ inverted sorting order\");\n\t    else\n\t\tsnprintf(G.message, sizeof(G.message), \"][ normal sorting order\");\n\t}\n\n\tif(keycode == KEY_TAB) {\n\t    if(G.selection_ap == 0) {\n\t\tG.selection_ap = 1;\n\t\tG.selected_ap = 1;\n\t\tsnprintf(G.message, sizeof(G.message), \"][ enabled AP selection\");\n\t\tG.sort_by = SORT_BY_NOTHING;\n\t    } else if(G.selection_ap == 1) {\n\t\tG.selection_ap = 0;\n\t\tG.sort_by = SORT_BY_NOTHING;\n\t\tsnprintf(G.message, sizeof(G.message), \"][ disabled selection\");\n\t    }\n\t}\n\n\tif(keycode == KEY_a) {\n\t    if(G.show_ap == 1 && G.show_sta == 1 && G.show_ack == 0) {\n\t\tG.show_ap = 1;\n\t\tG.show_sta = 1;\n\t\tG.show_ack = 1;\n\t\tsnprintf(G.message, sizeof(G.message), \"][ display ap+sta+ack\");\n\t    } else if(G.show_ap == 1 && G.show_sta == 1 && G.show_ack == 1) {\n\t\tG.show_ap = 1;\n\t\tG.show_sta = 0;\n\t\tG.show_ack = 0;\n\t\tsnprintf(G.message, sizeof(G.message), \"][ display ap only\");\n\t    } else if(G.show_ap == 1 && G.show_sta == 0 && G.show_ack == 0) {\n\t\tG.show_ap = 0;\n\t\tG.show_sta = 1;\n\t\tG.show_ack = 0;\n\t\tsnprintf(G.message, sizeof(G.message), \"][ display sta only\");\n\t    } else if(G.show_ap == 0 && G.show_sta == 1 && G.show_ack == 0) {\n\t\tG.show_ap = 1;\n\t\tG.show_sta = 1;\n\t\tG.show_ack = 0;\n\t\tsnprintf(G.message, sizeof(G.message), \"][ display ap+sta\");\n\t    }\n\t}\n\n\tif (keycode == KEY_d) {\n\t\tresetSelection();\n\t\tsnprintf(G.message, sizeof(G.message), \"][ reset selection to default\");\n\t}\n\n\tif(G.do_exit == 0 && !G.do_pause) {\n\t    pthread_mutex_lock( &(G.mx_print) );\n\n\t\tfprintf( stderr, \"\\33[1;1H\" );\n\t\tdump_print( G.ws.ws_row, G.ws.ws_col, G.num_cards );\n\t\tfprintf( stderr, \"\\33[J\" );\n\t\tfflush(stderr);\n\n\t    pthread_mutex_unlock( &(G.mx_print) );\n\t}\n    }\n}\n\nvoid trim(char *str)\n{\n    int i;\n    int begin = 0;\n    int end = strlen(str) - 1;\n\n    while (isspace((int)str[begin])) begin++;\n    while ((end >= begin) && isspace((int)str[end])) end--;\n    // Shift all characters back to the start of the string array.\n    for (i = begin; i <= end; i++)\n        str[i - begin] = str[i];\n    str[i - begin] = '\\0'; // Null terminate string.\n}\n\nstruct oui * load_oui_file(void) {\n\tFILE *fp;\n\tchar * manuf;\n\tchar buffer[BUFSIZ];\n\tunsigned char a[2];\n\tunsigned char b[2];\n\tunsigned char c[2];\n\tstruct oui *oui_ptr = NULL, *oui_head = NULL;\n\n\tif (!(fp = fopen(OUI_PATH0, \"r\"))) {\n\t\tif (!(fp = fopen(OUI_PATH1, \"r\"))) {\n\t\t\tif (!(fp = fopen(OUI_PATH2, \"r\"))) {\n\t\t\t\tif (!(fp = fopen(OUI_PATH3, \"r\"))) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(buffer, 0x00, sizeof(buffer));\n\twhile (fgets(buffer, sizeof(buffer), fp) != NULL) {\n\t\tif (!(strstr(buffer, \"(hex)\")))\n\t\t\tcontinue;\n\n\t\tmemset(a, 0x00, sizeof(a));\n\t\tmemset(b, 0x00, sizeof(b));\n\t\tmemset(c, 0x00, sizeof(c));\n\t\t// Remove leading/trailing whitespaces.\n\t\ttrim(buffer);\n\t\tif (sscanf(buffer, \"%2c-%2c-%2c\", a, b, c) == 3) {\n\t\t\tif (oui_ptr == NULL) {\n\t\t\t\tif (!(oui_ptr = (struct oui *)malloc(sizeof(struct oui)))) {\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\tperror(\"malloc failed\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!(oui_ptr->next = (struct oui *)malloc(sizeof(struct oui)))) {\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\tperror(\"malloc failed\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\toui_ptr = oui_ptr->next;\n\t\t\t}\n\t\t\tmemset(oui_ptr->id, 0x00, sizeof(oui_ptr->id));\n\t\t\tmemset(oui_ptr->manuf, 0x00, sizeof(oui_ptr->manuf));\n\t\t\tsnprintf(oui_ptr->id, sizeof(oui_ptr->id), \"%c%c:%c%c:%c%c\", a[0], a[1], b[0], b[1], c[0], c[1]);\n\t\t\tmanuf = get_manufacturer_from_string(buffer);\n\t\t\tif (manuf != NULL) {\n\t\t\t\tsnprintf(oui_ptr->manuf, sizeof(oui_ptr->manuf), \"%s\", manuf);\n\t\t\t\tfree(manuf);\n\t\t\t} else {\n\t\t\t\tsnprintf(oui_ptr->manuf, sizeof(oui_ptr->manuf), \"Unknown\");\n\t\t\t}\n\t\t\tif (oui_head == NULL)\n\t\t\t\toui_head = oui_ptr;\n\t\t\toui_ptr->next = NULL;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn oui_head;\n}\n\nint check_shared_key(unsigned char *h80211, int caplen)\n{\n    int m_bmac, m_smac, m_dmac, n, textlen;\n    char ofn[1024];\n    char text[4096];\n    char prga[4096];\n    unsigned int long crc;\n\n    if((unsigned)caplen > sizeof(G.sharedkey[0])) return 1;\n\n    m_bmac = 16;\n    m_smac = 10;\n    m_dmac = 4;\n\n    if( time(NULL) - G.sk_start > 5)\n    {\n        /* timeout(5sec) - remove all packets, restart timer */\n        memset(G.sharedkey, '\\x00', 4096*3);\n        G.sk_start = time(NULL);\n    }\n\n    /* is auth packet */\n    if( (h80211[1] & 0x40) != 0x40 )\n    {\n        /* not encrypted */\n        if( ( h80211[24] + (h80211[25] << 8) ) == 1 )\n        {\n            /* Shared-Key Authentication */\n            if( ( h80211[26] + (h80211[27] << 8) ) == 2 )\n            {\n                /* sequence == 2 */\n                memcpy(G.sharedkey[0], h80211, caplen);\n                G.sk_len = caplen-24;\n            }\n            if( ( h80211[26] + (h80211[27] << 8) ) == 4 )\n            {\n                /* sequence == 4 */\n                memcpy(G.sharedkey[2], h80211, caplen);\n            }\n        }\n        else return 1;\n    }\n    else\n    {\n        /* encrypted */\n        memcpy(G.sharedkey[1], h80211, caplen);\n        G.sk_len2 = caplen-24-4;\n    }\n\n    /* check if the 3 packets form a proper authentication */\n\n    if( ( memcmp(G.sharedkey[0]+m_bmac, NULL_MAC, 6) == 0 ) ||\n        ( memcmp(G.sharedkey[1]+m_bmac, NULL_MAC, 6) == 0 ) ||\n        ( memcmp(G.sharedkey[2]+m_bmac, NULL_MAC, 6) == 0 ) ) /* some bssids == zero */\n    {\n        return 1;\n    }\n\n    if( ( memcmp(G.sharedkey[0]+m_bmac, G.sharedkey[1]+m_bmac, 6) != 0 ) ||\n        ( memcmp(G.sharedkey[0]+m_bmac, G.sharedkey[2]+m_bmac, 6) != 0 ) ) /* all bssids aren't equal */\n    {\n        return 1;\n    }\n\n    if( ( memcmp(G.sharedkey[0]+m_smac, G.sharedkey[2]+m_smac, 6) != 0 ) ||\n        ( memcmp(G.sharedkey[0]+m_smac, G.sharedkey[1]+m_dmac, 6) != 0 ) ) /* SA in 2&4 != DA in 3 */\n    {\n        return 1;\n    }\n\n    if( (memcmp(G.sharedkey[0]+m_dmac, G.sharedkey[2]+m_dmac, 6) != 0 ) ||\n        (memcmp(G.sharedkey[0]+m_dmac, G.sharedkey[1]+m_smac, 6) != 0 ) ) /* DA in 2&4 != SA in 3 */\n    {\n        return 1;\n    }\n\n    textlen = G.sk_len;\n\n    if(textlen+4 != G.sk_len2)\n    {\n        snprintf(G.message, sizeof(G.message), \"][ Broken SKA: %02X:%02X:%02X:%02X:%02X:%02X \",\n                    *(G.sharedkey[0]+m_bmac), *(G.sharedkey[0]+m_bmac+1), *(G.sharedkey[0]+m_bmac+2),\n                *(G.sharedkey[0]+m_bmac+3), *(G.sharedkey[0]+m_bmac+4), *(G.sharedkey[0]+m_bmac+5));\n        return 1;\n    }\n\n    if((unsigned)textlen > sizeof(text) - 4) return 1;\n\n    memcpy(text, G.sharedkey[0]+24, textlen);\n\n    /* increment sequence number from 2 to 3 */\n    text[2] = text[2]+1;\n\n    crc = 0xFFFFFFFF;\n\n    for( n = 0; n < textlen; n++ )\n        crc = crc_tbl[(crc ^ text[n]) & 0xFF] ^ (crc >> 8);\n\n    crc = ~crc;\n\n    /* append crc32 over body */\n    text[textlen]     = (crc      ) & 0xFF;\n    text[textlen+1]   = (crc >>  8) & 0xFF;\n    text[textlen+2]   = (crc >> 16) & 0xFF;\n    text[textlen+3]   = (crc >> 24) & 0xFF;\n\n    /* cleartext XOR cipher */\n    for(n=0; n<(textlen+4); n++)\n    {\n        prga[4+n] = (text[n] ^ G.sharedkey[1][28+n]) & 0xFF;\n    }\n\n    /* write IV+index */\n    prga[0] = G.sharedkey[1][24] & 0xFF;\n    prga[1] = G.sharedkey[1][25] & 0xFF;\n    prga[2] = G.sharedkey[1][26] & 0xFF;\n    prga[3] = G.sharedkey[1][27] & 0xFF;\n\n    if( G.f_xor != NULL )\n    {\n        fclose(G.f_xor);\n        G.f_xor = NULL;\n    }\n\n    snprintf( ofn, sizeof( ofn ) - 1, \"%s-%02d-%02X-%02X-%02X-%02X-%02X-%02X.%s\", G.prefix, G.f_index,\n              *(G.sharedkey[0]+m_bmac), *(G.sharedkey[0]+m_bmac+1), *(G.sharedkey[0]+m_bmac+2),\n              *(G.sharedkey[0]+m_bmac+3), *(G.sharedkey[0]+m_bmac+4), *(G.sharedkey[0]+m_bmac+5), \"xor\" );\n\n    G.f_xor = fopen( ofn, \"w\");\n    if(G.f_xor == NULL)\n        return 1;\n\n    for(n=0; n<textlen+8; n++)\n        fputc((prga[n] & 0xFF), G.f_xor);\n\n    fflush(G.f_xor);\n\n    if( G.f_xor != NULL )\n    {\n        fclose(G.f_xor);\n        G.f_xor = NULL;\n    }\n\n    snprintf(G.message, sizeof(G.message), \"][ %d bytes keystream: %02X:%02X:%02X:%02X:%02X:%02X \",\n                textlen+4, *(G.sharedkey[0]+m_bmac), *(G.sharedkey[0]+m_bmac+1), *(G.sharedkey[0]+m_bmac+2),\n              *(G.sharedkey[0]+m_bmac+3), *(G.sharedkey[0]+m_bmac+4), *(G.sharedkey[0]+m_bmac+5));\n\n    memset(G.sharedkey, '\\x00', 512*3);\n    /* ok, keystream saved */\n    return 0;\n}\n\nchar usage[] =\n\n\"\\n\"\n\"  %s - (C) 2006-2013 Thomas d\\'Otreppe\\n\"\n\"  http://www.aircrack-ng.org\\n\"\n\"\\n\"\n\"  usage: airodump-ng <options> <interface>[,<interface>,...]\\n\"\n\"\\n\"\n\"  Options:\\n\"\n\"      --ivs                 : Save only captured IVs\\n\"\n\"      --gpsd                : Use GPSd\\n\"\n\"      --write      <prefix> : Dump file prefix\\n\"\n\"      -w                    : same as --write \\n\"\n\"      --beacons             : Record all beacons in dump file\\n\"\n\"      --update       <secs> : Display update delay in seconds\\n\"\n\"      --showack             : Prints ack/cts/rts statistics\\n\"\n\"      -h                    : Hides known stations for --showack\\n\"\n\"      -f            <msecs> : Time in ms between hopping channels\\n\"\n\"      --berlin       <secs> : Time before removing the AP/client\\n\"\n\"                              from the screen when no more packets\\n\"\n\"                              are received (Default: 120 seconds)\\n\"\n\"      -r             <file> : Read packets from that file\\n\"\n\"      -x            <msecs> : Active Scanning Simulation\\n\"\n\"      --manufacturer        : Display manufacturer from IEEE OUI list\\n\"\n\"      --uptime              : Display AP Uptime from Beacon Timestamp\\n\"\n\"      --output-format\\n\"\n\"                  <formats> : Output format. Possible values:\\n\"\n\"                              pcap, ivs, csv, gps, kismet, netxml\\n\"\n\"      --ignore-negative-one : Removes the message that says\\n\"\n\"                              fixed channel <interface>: -1\\n\"\n\"\\n\"\n\"  Filter options:\\n\"\n\"      --encrypt   <suite>   : Filter APs by cipher suite\\n\"\n\"      --netmask <netmask>   : Filter APs by mask\\n\"\n\"      --bssid     <bssid>   : Filter APs by BSSID\\n\"\n\"      --essid     <essid>   : Filter APs by ESSID\\n\"\n#ifdef HAVE_PCRE\n\"      --essid-regex <regex> : Filter APs by ESSID using a regular\\n\"\n\"                              expression\\n\"\n#endif\n\"      -a                    : Filter unassociated clients\\n\"\n\"\\n\"\n\"  By default, airodump-ng hop on 2.4GHz channels.\\n\"\n\"  You can make it capture on other/specific channel(s) by using:\\n\"\n\"      --channel <channels>  : Capture on specific channels\\n\"\n\"      --band <abg>          : Band on which airodump-ng should hop\\n\"\n\"      -C    <frequencies>   : Uses these frequencies in MHz to hop\\n\"\n\"      --cswitch  <method>   : Set channel switching method\\n\"\n\"                    0       : FIFO (default)\\n\"\n\"                    1       : Round Robin\\n\"\n\"                    2       : Hop on last\\n\"\n\"      -s                    : same as --cswitch\\n\"\n\"\\n\"\n\"      --help                : Displays this usage screen\\n\"\n\"\\n\";\n\nint is_filtered_netmask(unsigned char *bssid)\n{\n    unsigned char mac1[6];\n    unsigned char mac2[6];\n    int i;\n\n    for(i=0; i<6; i++)\n    {\n        mac1[i] = bssid[i]     & G.f_netmask[i];\n        mac2[i] = G.f_bssid[i] & G.f_netmask[i];\n    }\n\n    if( memcmp(mac1, mac2, 6) != 0 )\n    {\n        return( 1 );\n    }\n\n    return 0;\n}\n\nint is_filtered_essid(unsigned char *essid)\n{\n    int ret = 0;\n    int i;\n\n    if(G.f_essid)\n    {\n        for(i=0; i<G.f_essid_count; i++)\n        {\n            if(strncmp((char*)essid, G.f_essid[i], MAX_IE_ELEMENT_SIZE) == 0)\n            {\n                return 0;\n            }\n        }\n\n        ret = 1;\n    }\n\n#ifdef HAVE_PCRE\n    if(G.f_essid_regex)\n    {\n        return pcre_exec(G.f_essid_regex, NULL, (char*)essid, strnlen((char *)essid, MAX_IE_ELEMENT_SIZE), 0, 0, NULL, 0) < 0;\n    }\n#endif\n\n    return ret;\n}\n\nvoid update_rx_quality( )\n{\n    unsigned int time_diff, capt_time, miss_time;\n    int missed_frames;\n    struct AP_info *ap_cur = NULL;\n    struct ST_info *st_cur = NULL;\n    struct timeval cur_time;\n\n    ap_cur = G.ap_1st;\n    st_cur = G.st_1st;\n\n    gettimeofday( &cur_time, NULL );\n\n    /* accesspoints */\n    while( ap_cur != NULL )\n    {\n        time_diff = 1000000 * (cur_time.tv_sec  - ap_cur->ftimer.tv_sec )\n                            + (cur_time.tv_usec - ap_cur->ftimer.tv_usec);\n\n        /* update every `QLT_TIME`seconds if the rate is low, or every 500ms otherwise */\n        if( (ap_cur->fcapt >= QLT_COUNT && time_diff > 500000 ) || time_diff > (QLT_TIME * 1000000) )\n        {\n            /* at least one frame captured */\n            if(ap_cur->fcapt > 1)\n            {\n                capt_time =   ( 1000000 * (ap_cur->ftimel.tv_sec  - ap_cur->ftimef.tv_sec )    //time between first and last captured frame\n                                        + (ap_cur->ftimel.tv_usec - ap_cur->ftimef.tv_usec) );\n\n                miss_time =   ( 1000000 * (ap_cur->ftimef.tv_sec  - ap_cur->ftimer.tv_sec )    //time between timer reset and first frame\n                                        + (ap_cur->ftimef.tv_usec - ap_cur->ftimer.tv_usec) )\n                            + ( 1000000 * (cur_time.tv_sec  - ap_cur->ftimel.tv_sec )          //time between last frame and this moment\n                                        + (cur_time.tv_usec - ap_cur->ftimel.tv_usec) );\n\n                //number of frames missed at the time where no frames were captured; extrapolated by assuming a constant framerate\n                if(capt_time > 0 && miss_time > 200000)\n                {\n                    missed_frames = ((float)((float)miss_time/(float)capt_time) * ((float)ap_cur->fcapt + (float)ap_cur->fmiss));\n                    ap_cur->fmiss += missed_frames;\n                }\n\n                ap_cur->rx_quality = ((float)((float)ap_cur->fcapt / ((float)ap_cur->fcapt + (float)ap_cur->fmiss)) * 100.0);\n            }\n            else ap_cur->rx_quality = 0; /* no packets -> zero quality */\n\n            /* normalize, in case the seq numbers are not iterating */\n            if(ap_cur->rx_quality > 100) ap_cur->rx_quality = 100;\n            if(ap_cur->rx_quality < 0  ) ap_cur->rx_quality =   0;\n\n            /* reset variables */\n            ap_cur->fcapt = 0;\n            ap_cur->fmiss = 0;\n            gettimeofday( &(ap_cur->ftimer) ,NULL);\n        }\n        ap_cur = ap_cur->next;\n    }\n\n    /* stations */\n    while( st_cur != NULL )\n    {\n        time_diff = 1000000 * (cur_time.tv_sec  - st_cur->ftimer.tv_sec )\n                            + (cur_time.tv_usec - st_cur->ftimer.tv_usec);\n\n        if( time_diff > 10000000 )\n        {\n            st_cur->missed = 0;\n            gettimeofday( &(st_cur->ftimer), NULL );\n        }\n\n        st_cur = st_cur->next;\n    }\n\n}\n\n/* setup the output files */\n\nint dump_initialize( char *prefix, int ivs_only )\n{\n    int i, ofn_len;\n    FILE *f;\n    char * ofn = NULL;\n\n\n    /* If you only want to see what happening, send all data to /dev/null */\n\n    if ( prefix == NULL || strlen( prefix ) == 0) {\n\t    return( 0 );\n    }\n\n\t/* Create a buffer of the length of the prefix + '-' + 2 numbers + '.'\n\t   + longest extension (\"kismet.netxml\") + terminating 0. */\n\tofn_len = strlen(prefix) + 1 + 2 + 1 + 13 + 1;\n\tofn = (char *)calloc(1, ofn_len);\n\n    G.f_index = 1;\n\n\n\t/* Make sure no file with the same name & all possible file extensions. */\n    do\n    {\n        for( i = 0; i < NB_EXTENSIONS; i++ )\n        {\n\t\t\tmemset(ofn, 0, ofn_len);\n            snprintf( ofn,  ofn_len, \"%s-%02d.%s\",\n                      prefix, G.f_index, f_ext[i] );\n\n            if( ( f = fopen( ofn, \"rb+\" ) ) != NULL )\n            {\n                fclose( f );\n                G.f_index++;\n                break;\n            }\n        }\n    }\n    /* If we did all extensions then no file with that name or extension exist\n       so we can use that number */\n    while( i < NB_EXTENSIONS );\n\n    G.prefix = (char *) malloc(strlen(prefix) + 1);\n    memcpy(G.prefix, prefix, strlen(prefix) + 1);\n\n    /* create the output CSV file */\n\n\tif (G.output_format_csv) {\n\t\tmemset(ofn, 0, ofn_len);\n\t\tsnprintf( ofn,  ofn_len, \"%s-%02d.%s\",\n\t\t\t\t  prefix, G.f_index, AIRODUMP_NG_CSV_EXT );\n\n\t\tif( ( G.f_txt = fopen( ofn, \"wb+\" ) ) == NULL )\n\t\t{\n\t\t\tperror( \"fopen failed\" );\n\t\t\tfprintf( stderr, \"Could not create \\\"%s\\\".\\n\", ofn );\n\t\t\tfree( ofn );\n\t\t\treturn( 1 );\n\t\t}\n\t}\n\n    /* create the output Kismet CSV file */\n\tif (G.output_format_kismet_csv) {\n\t\tmemset(ofn, 0, ofn_len);\n\t\tsnprintf( ofn,  ofn_len, \"%s-%02d.%s\",\n\t\t\t\t  prefix, G.f_index, KISMET_CSV_EXT );\n\n\t\tif( ( G.f_kis = fopen( ofn, \"wb+\" ) ) == NULL )\n\t\t{\n\t\t\tperror( \"fopen failed\" );\n\t\t\tfprintf( stderr, \"Could not create \\\"%s\\\".\\n\", ofn );\n\t\t\tfree( ofn );\n\t\t\treturn( 1 );\n\t\t}\n\t}\n\n\t/* create the output GPS file */\n\n    if (G.usegpsd)\n    {\n        memset(ofn, 0, ofn_len);\n        snprintf( ofn,  ofn_len, \"%s-%02d.%s\",\n                  prefix, G.f_index, AIRODUMP_NG_GPS_EXT );\n\n        if( ( G.f_gps = fopen( ofn, \"wb+\" ) ) == NULL )\n        {\n            perror( \"fopen failed\" );\n            fprintf( stderr, \"Could not create \\\"%s\\\".\\n\", ofn );\n            free( ofn );\n            return( 1 );\n        }\n    }\n\n    /* Create the output kismet.netxml file */\n\n\tif (G.output_format_kismet_netxml) {\n\t\tmemset(ofn, 0, ofn_len);\n\t\tsnprintf( ofn,  ofn_len, \"%s-%02d.%s\",\n\t\t\t\t  prefix, G.f_index, KISMET_NETXML_EXT );\n\n\t\tif( ( G.f_kis_xml = fopen( ofn, \"wb+\" ) ) == NULL )\n\t\t{\n\t\t\tperror( \"fopen failed\" );\n\t\t\tfprintf( stderr, \"Could not create \\\"%s\\\".\\n\", ofn );\n\t\t\tfree( ofn );\n\t\t\treturn( 1 );\n\t\t}\n\t}\n\n    /* create the output packet capture file */\n    if( G.output_format_pcap )\n    {\n        struct pcap_file_header pfh;\n\n        memset(ofn, 0, ofn_len);\n        snprintf( ofn,  ofn_len, \"%s-%02d.%s\",\n                  prefix, G.f_index, AIRODUMP_NG_CAP_EXT );\n\n        if( ( G.f_cap = fopen( ofn, \"wb+\" ) ) == NULL )\n        {\n            perror( \"fopen failed\" );\n            fprintf( stderr, \"Could not create \\\"%s\\\".\\n\", ofn );\n            free( ofn );\n            return( 1 );\n        }\n\n        G.f_cap_name = (char *) malloc( strlen( ofn ) + 1 );\n        memcpy( G.f_cap_name, ofn, strlen( ofn ) + 1 );\n        free( ofn );\n\n        pfh.magic           = TCPDUMP_MAGIC;\n        pfh.version_major   = PCAP_VERSION_MAJOR;\n        pfh.version_minor   = PCAP_VERSION_MINOR;\n        pfh.thiszone        = 0;\n        pfh.sigfigs         = 0;\n        pfh.snaplen         = 65535;\n        pfh.linktype        = LINKTYPE_IEEE802_11;\n\n        if( fwrite( &pfh, 1, sizeof( pfh ), G.f_cap ) !=\n                    (size_t) sizeof( pfh ) )\n        {\n            perror( \"fwrite(pcap file header) failed\" );\n            return( 1 );\n        }\n    } else if ( ivs_only ) {\n        struct ivs2_filehdr fivs2;\n\n        fivs2.version = IVS2_VERSION;\n\n        memset(ofn, 0, ofn_len);\n        snprintf( ofn,  ofn_len, \"%s-%02d.%s\",\n                  prefix, G.f_index, IVS2_EXTENSION );\n\n        if( ( G.f_ivs = fopen( ofn, \"wb+\" ) ) == NULL )\n        {\n            perror( \"fopen failed\" );\n            fprintf( stderr, \"Could not create \\\"%s\\\".\\n\", ofn );\n            free( ofn );\n            return( 1 );\n        }\n        free( ofn );\n\n        if( fwrite( IVS2_MAGIC, 1, 4, G.f_ivs ) != (size_t) 4 )\n        {\n            perror( \"fwrite(IVs file MAGIC) failed\" );\n            return( 1 );\n        }\n\n        if( fwrite( &fivs2, 1, sizeof(struct ivs2_filehdr), G.f_ivs ) != (size_t) sizeof(struct ivs2_filehdr) )\n        {\n            perror( \"fwrite(IVs file header) failed\" );\n            return( 1 );\n        }\n    }\n\n    return( 0 );\n}\n\nint update_dataps()\n{\n    struct timeval tv;\n    struct AP_info *ap_cur;\n    struct NA_info *na_cur;\n    int sec, usec, diff, ps;\n    float pause;\n\n    gettimeofday(&tv, NULL);\n\n    ap_cur = G.ap_end;\n\n    while( ap_cur != NULL )\n    {\n        sec = (tv.tv_sec - ap_cur->tv.tv_sec);\n        usec = (tv.tv_usec - ap_cur->tv.tv_usec);\n        pause = (((float)(sec*1000000.0f + usec))/(1000000.0f));\n        if( pause > 2.0f )\n        {\n            diff = ap_cur->nb_data - ap_cur->nb_data_old;\n            ps = (int)(((float)diff)/pause);\n            ap_cur->nb_dataps = ps;\n            ap_cur->nb_data_old = ap_cur->nb_data;\n            gettimeofday(&(ap_cur->tv), NULL);\n        }\n        ap_cur = ap_cur->prev;\n    }\n\n    na_cur = G.na_1st;\n\n    while( na_cur != NULL )\n    {\n        sec = (tv.tv_sec - na_cur->tv.tv_sec);\n        usec = (tv.tv_usec - na_cur->tv.tv_usec);\n        pause = (((float)(sec*1000000.0f + usec))/(1000000.0f));\n        if( pause > 2.0f )\n        {\n            diff = na_cur->ack - na_cur->ack_old;\n            ps = (int)(((float)diff)/pause);\n            na_cur->ackps = ps;\n            na_cur->ack_old = na_cur->ack;\n            gettimeofday(&(na_cur->tv), NULL);\n        }\n        na_cur = na_cur->next;\n    }\n    return(0);\n}\n\nint list_tail_free(struct pkt_buf **list)\n{\n    struct pkt_buf **pkts;\n    struct pkt_buf *next;\n\n    if(list == NULL) return 1;\n\n    pkts = list;\n\n    while(*pkts != NULL)\n    {\n        next = (*pkts)->next;\n        if( (*pkts)->packet )\n        {\n            free( (*pkts)->packet);\n            (*pkts)->packet=NULL;\n        }\n\n        if(*pkts)\n        {\n            free(*pkts);\n            *pkts = NULL;\n        }\n        *pkts = next;\n    }\n\n    *list=NULL;\n\n    return 0;\n}\n\nint list_add_packet(struct pkt_buf **list, int length, unsigned char* packet)\n{\n    struct pkt_buf *next = *list;\n\n    if(length <= 0) return 1;\n    if(packet == NULL) return 1;\n    if(list == NULL) return 1;\n\n    *list = (struct pkt_buf*) malloc(sizeof(struct pkt_buf));\n    if( *list == NULL ) return 1;\n    (*list)->packet = (unsigned char*) malloc(length);\n    if( (*list)->packet == NULL ) return 1;\n\n    memcpy((*list)->packet,  packet, length);\n    (*list)->next = next;\n    (*list)->length = length;\n    gettimeofday( &((*list)->ctime), NULL);\n\n    return 0;\n}\n\n/*\n * Check if the same IV was used if the first two bytes were the same.\n * If they are not identical, it would complain.\n * The reason is that the first two bytes unencrypted are 'aa'\n * so with the same IV it should always be encrypted to the same thing.\n */\nint list_check_decloak(struct pkt_buf **list, int length, unsigned char* packet)\n{\n    struct pkt_buf *next = *list;\n    struct timeval tv1;\n    int timediff;\n    int i, correct;\n\n    if( packet == NULL) return 1;\n    if( list == NULL ) return 1;\n    if( *list == NULL ) return 1;\n    if( length <= 0) return 1;\n\n    gettimeofday(&tv1, NULL);\n\n    timediff = (((tv1.tv_sec - ((*list)->ctime.tv_sec)) * 1000000) + (tv1.tv_usec - ((*list)->ctime.tv_usec))) / 1000;\n    if( timediff > BUFFER_TIME )\n    {\n        list_tail_free(list);\n        next=NULL;\n    }\n\n    while(next != NULL)\n    {\n        if(next->next != NULL)\n        {\n            timediff = (((tv1.tv_sec - (next->next->ctime.tv_sec)) * 1000000) + (tv1.tv_usec - (next->next->ctime.tv_usec))) / 1000;\n            if( timediff > BUFFER_TIME )\n            {\n                list_tail_free(&(next->next));\n                break;\n            }\n        }\n        if( (next->length + 4) == length)\n        {\n            correct = 1;\n            // check for 4 bytes added after the end\n            for(i=28;i<length-28;i++)   //check everything (in the old packet) after the IV (including crc32 at the end)\n            {\n                if(next->packet[i] != packet[i])\n                {\n                    correct = 0;\n                    break;\n                }\n            }\n            if(!correct)\n            {\n                correct = 1;\n                // check for 4 bytes added at the beginning\n                for(i=28;i<length-28;i++)   //check everything (in the old packet) after the IV (including crc32 at the end)\n                {\n                    if(next->packet[i] != packet[4+i])\n                    {\n                        correct = 0;\n                        break;\n                    }\n                }\n            }\n            if(correct == 1)\n                    return 0;   //found decloaking!\n        }\n        next = next->next;\n    }\n\n    return 1; //didn't find decloak\n}\n\nint remove_namac(unsigned char* mac)\n{\n    struct NA_info *na_cur = NULL;\n    struct NA_info *na_prv = NULL;\n\n    if(mac == NULL)\n        return( -1 );\n\n    na_cur = G.na_1st;\n    na_prv = NULL;\n\n    while( na_cur != NULL )\n    {\n        if( ! memcmp( na_cur->namac, mac, 6 ) )\n            break;\n\n        na_prv = na_cur;\n        na_cur = na_cur->next;\n    }\n\n    /* if it's known, remove it */\n    if( na_cur != NULL )\n    {\n        /* first in linked list */\n        if(na_cur == G.na_1st)\n        {\n            G.na_1st = na_cur->next;\n        }\n        else\n        {\n            na_prv->next = na_cur->next;\n        }\n        free(na_cur);\n        na_cur=NULL;\n    }\n\n    return( 0 );\n}\n\nint dump_add_packet( unsigned char *h80211, int caplen, struct rx_info *ri, int cardnum )\n{\n    int i, n, seq, msd, dlen, offset, clen, o;\n    unsigned z;\n    int type, length, numuni=0, numauth=0;\n    struct pcap_pkthdr pkh;\n    struct timeval tv;\n    struct ivs2_pkthdr ivs2;\n    unsigned char *p, *org_p, c;\n    unsigned char bssid[6];\n    unsigned char stmac[6];\n    unsigned char namac[6];\n    unsigned char clear[2048];\n    int weight[16];\n    int num_xor=0;\n\n    struct AP_info *ap_cur = NULL;\n    struct ST_info *st_cur = NULL;\n    struct NA_info *na_cur = NULL;\n    struct AP_info *ap_prv = NULL;\n    struct ST_info *st_prv = NULL;\n    struct NA_info *na_prv = NULL;\n\n    /* skip all non probe response frames in active scanning simulation mode */\n    if( G.active_scan_sim > 0 && h80211[0] != 0x50 )\n        return(0);\n\n    /* skip packets smaller than a 802.11 header */\n\n    if( caplen < 24 )\n        goto write_packet;\n\n    /* skip (uninteresting) control frames */\n\n    if( ( h80211[0] & 0x0C ) == 0x04 )\n        goto write_packet;\n\n    /* if it's a LLC null packet, just forget it (may change in the future) */\n\n    if ( caplen > 28)\n        if ( memcmp(h80211 + 24, llcnull, 4) == 0)\n            return ( 0 );\n\n    /* grab the sequence number */\n    seq = ((h80211[22]>>4)+(h80211[23]<<4));\n\n    /* locate the access point's MAC address */\n\n    switch( h80211[1] & 3 )\n    {\n        case  0: memcpy( bssid, h80211 + 16, 6 ); break;  //Adhoc\n        case  1: memcpy( bssid, h80211 +  4, 6 ); break;  //ToDS\n        case  2: memcpy( bssid, h80211 + 10, 6 ); break;  //FromDS\n        case  3: memcpy( bssid, h80211 + 10, 6 ); break;  //WDS -> Transmitter taken as BSSID\n    }\n\n    if( memcmp(G.f_bssid, NULL_MAC, 6) != 0 )\n    {\n        if( memcmp(G.f_netmask, NULL_MAC, 6) != 0 )\n        {\n            if(is_filtered_netmask(bssid)) return(1);\n        }\n        else\n        {\n            if( memcmp(G.f_bssid, bssid, 6) != 0 ) return(1);\n        }\n    }\n\n    /* update our chained list of access points */\n\n    ap_cur = G.ap_1st;\n    ap_prv = NULL;\n\n    while( ap_cur != NULL )\n    {\n        if( ! memcmp( ap_cur->bssid, bssid, 6 ) )\n            break;\n\n        ap_prv = ap_cur;\n        ap_cur = ap_cur->next;\n    }\n\n    /* if it's a new access point, add it */\n\n    if( ap_cur == NULL )\n    {\n        if( ! ( ap_cur = (struct AP_info *) malloc(\n                         sizeof( struct AP_info ) ) ) )\n        {\n            perror( \"malloc failed\" );\n            return( 1 );\n        }\n\n        /* if mac is listed as unknown, remove it */\n        remove_namac(bssid);\n\n        memset( ap_cur, 0, sizeof( struct AP_info ) );\n\n        if( G.ap_1st == NULL )\n            G.ap_1st = ap_cur;\n        else\n            ap_prv->next  = ap_cur;\n\n        memcpy( ap_cur->bssid, bssid, 6 );\n\t\tif (ap_cur->manuf == NULL) {\n\t\t\tap_cur->manuf = get_manufacturer(ap_cur->bssid[0], ap_cur->bssid[1], ap_cur->bssid[2]);\n\t\t}\n\n        ap_cur->prev = ap_prv;\n\n        ap_cur->tinit = time( NULL );\n        ap_cur->tlast = time( NULL );\n\n        ap_cur->avg_power   = -1;\n        ap_cur->best_power  = -1;\n        ap_cur->power_index = -1;\n\n        for( i = 0; i < NB_PWR; i++ )\n            ap_cur->power_lvl[i] = -1;\n\n        ap_cur->channel    = -1;\n        ap_cur->max_speed  = -1;\n        ap_cur->security   = 0;\n\n        ap_cur->uiv_root = uniqueiv_init();\n\n        ap_cur->nb_dataps = 0;\n        ap_cur->nb_data_old = 0;\n        gettimeofday(&(ap_cur->tv), NULL);\n\n        ap_cur->dict_started = 0;\n\n        ap_cur->key = NULL;\n\n        G.ap_end = ap_cur;\n\n        ap_cur->nb_bcn     = 0;\n\n        ap_cur->rx_quality = 0;\n        ap_cur->fcapt      = 0;\n        ap_cur->fmiss      = 0;\n        ap_cur->last_seq   = 0;\n        gettimeofday( &(ap_cur->ftimef), NULL);\n        gettimeofday( &(ap_cur->ftimel), NULL);\n        gettimeofday( &(ap_cur->ftimer), NULL);\n\n        ap_cur->ssid_length = 0;\n        ap_cur->essid_stored = 0;\n        ap_cur->timestamp = 0;\n\n        ap_cur->decloak_detect=G.decloak;\n        ap_cur->is_decloak = 0;\n        ap_cur->packets = NULL;\n\n\tap_cur->marked = 0;\n\tap_cur->marked_color = 1;\n\n        ap_cur->data_root = NULL;\n        ap_cur->EAP_detected = 0;\n        memcpy(ap_cur->gps_loc_min, G.gps_loc, sizeof(float)*5);\n        memcpy(ap_cur->gps_loc_max, G.gps_loc, sizeof(float)*5);\n        memcpy(ap_cur->gps_loc_best, G.gps_loc, sizeof(float)*5);\n    }\n\n    /* update the last time seen */\n\n    ap_cur->tlast = time( NULL );\n\n    /* only update power if packets comes from\n     * the AP: either type == mgmt and SA != BSSID,\n     * or FromDS == 1 and ToDS == 0 */\n\n    if( ( ( h80211[1] & 3 ) == 0 &&\n            memcmp( h80211 + 10, bssid, 6 ) == 0 ) ||\n        ( ( h80211[1] & 3 ) == 2 ) )\n    {\n        ap_cur->power_index = ( ap_cur->power_index + 1 ) % NB_PWR;\n        ap_cur->power_lvl[ap_cur->power_index] = ri->ri_power;\n\n        ap_cur->avg_power = 0;\n\n        for( i = 0, n = 0; i < NB_PWR; i++ )\n        {\n            if( ap_cur->power_lvl[i] != -1 )\n            {\n                ap_cur->avg_power += ap_cur->power_lvl[i];\n                n++;\n            }\n        }\n\n        if( n > 0 )\n        {\n            ap_cur->avg_power /= n;\n            if( ap_cur->avg_power > ap_cur->best_power )\n            {\n                ap_cur->best_power = ap_cur->avg_power;\n                memcpy(ap_cur->gps_loc_best, G.gps_loc, sizeof(float)*5);\n            }\n        }\n        else\n            ap_cur->avg_power = -1;\n\n        /* every packet in here comes from the AP */\n\n        if(G.gps_loc[0] > ap_cur->gps_loc_max[0])\n            ap_cur->gps_loc_max[0] = G.gps_loc[0];\n        if(G.gps_loc[1] > ap_cur->gps_loc_max[1])\n            ap_cur->gps_loc_max[1] = G.gps_loc[1];\n        if(G.gps_loc[2] > ap_cur->gps_loc_max[2])\n            ap_cur->gps_loc_max[2] = G.gps_loc[2];\n\n        if(G.gps_loc[0] < ap_cur->gps_loc_min[0])\n            ap_cur->gps_loc_min[0] = G.gps_loc[0];\n        if(G.gps_loc[1] < ap_cur->gps_loc_min[1])\n            ap_cur->gps_loc_min[1] = G.gps_loc[1];\n        if(G.gps_loc[2] < ap_cur->gps_loc_min[2])\n            ap_cur->gps_loc_min[2] = G.gps_loc[2];\n//        printf(\"seqnum: %i\\n\", seq);\n\n        if(ap_cur->fcapt == 0 && ap_cur->fmiss == 0) gettimeofday( &(ap_cur->ftimef), NULL);\n        if(ap_cur->last_seq != 0) ap_cur->fmiss += (seq - ap_cur->last_seq - 1);\n        ap_cur->last_seq = seq;\n        ap_cur->fcapt++;\n        gettimeofday( &(ap_cur->ftimel), NULL);\n\n//         if(ap_cur->fcapt >= QLT_COUNT) update_rx_quality();\n    }\n\n    if( h80211[0] == 0x80 )\n    {\n        ap_cur->nb_bcn++;\n    }\n\n    ap_cur->nb_pkt++;\n\n    /* find wpa handshake */\n    if( h80211[0] == 0x10 )\n    {\n        /* reset the WPA handshake state */\n\n        if( st_cur != NULL && st_cur->wpa.state != 0xFF )\n            st_cur->wpa.state = 0;\n//        printf(\"initial auth %d\\n\", ap_cur->wpa_state);\n    }\n\n    /* locate the station MAC in the 802.11 header */\n\n    switch( h80211[1] & 3 )\n    {\n        case  0:\n\n            /* if management, check that SA != BSSID */\n\n            if( memcmp( h80211 + 10, bssid, 6 ) == 0 )\n                goto skip_station;\n\n            memcpy( stmac, h80211 + 10, 6 );\n            break;\n\n        case  1:\n\n            /* ToDS packet, must come from a client */\n\n            memcpy( stmac, h80211 + 10, 6 );\n            break;\n\n        case  2:\n\n            /* FromDS packet, reject broadcast MACs */\n\n            if( (h80211[4]%2) != 0 ) goto skip_station;\n            memcpy( stmac, h80211 +  4, 6 ); break;\n\n        default: goto skip_station;\n    }\n\n    /* update our chained list of wireless stations */\n\n    st_cur = G.st_1st;\n    st_prv = NULL;\n\n    while( st_cur != NULL )\n    {\n        if( ! memcmp( st_cur->stmac, stmac, 6 ) )\n            break;\n\n        st_prv = st_cur;\n        st_cur = st_cur->next;\n    }\n\n    /* if it's a new client, add it */\n\n    if( st_cur == NULL )\n    {\n        if( ! ( st_cur = (struct ST_info *) malloc(\n                         sizeof( struct ST_info ) ) ) )\n        {\n            perror( \"malloc failed\" );\n            return( 1 );\n        }\n\n        /* if mac is listed as unknown, remove it */\n        remove_namac(stmac);\n\n        memset( st_cur, 0, sizeof( struct ST_info ) );\n\n        if( G.st_1st == NULL )\n            G.st_1st = st_cur;\n        else\n            st_prv->next  = st_cur;\n\n        memcpy( st_cur->stmac, stmac, 6 );\n\n\t\tif (st_cur->manuf == NULL) {\n\t\t\tst_cur->manuf = get_manufacturer(st_cur->stmac[0], st_cur->stmac[1], st_cur->stmac[2]);\n\t\t}\n\n        st_cur->prev = st_prv;\n\n        st_cur->tinit = time( NULL );\n        st_cur->tlast = time( NULL );\n\n        st_cur->power = -1;\n        st_cur->rate_to = -1;\n        st_cur->rate_from = -1;\n\n        st_cur->probe_index = -1;\n        st_cur->missed  = 0;\n        st_cur->lastseq = 0;\n        st_cur->qos_fr_ds = 0;\n        st_cur->qos_to_ds = 0;\n        gettimeofday( &(st_cur->ftimer), NULL);\n\n        for( i = 0; i < NB_PRB; i++ )\n        {\n            memset( st_cur->probes[i], 0, sizeof(\n                    st_cur->probes[i] ) );\n            st_cur->ssid_length[i] = 0;\n        }\n\n        G.st_end = st_cur;\n    }\n\n    if( st_cur->base == NULL ||\n        memcmp( ap_cur->bssid, BROADCAST, 6 ) != 0 )\n        st_cur->base = ap_cur;\n\n    //update bitrate to station\n    if( (st_cur != NULL) && ( h80211[1] & 3 ) == 2 )\n        st_cur->rate_to = ri->ri_rate;\n\n    /* update the last time seen */\n\n    st_cur->tlast = time( NULL );\n\n    /* only update power if packets comes from the\n     * client: either type == Mgmt and SA != BSSID,\n     * or FromDS == 0 and ToDS == 1 */\n\n    if( ( ( h80211[1] & 3 ) == 0 &&\n            memcmp( h80211 + 10, bssid, 6 ) != 0 ) ||\n        ( ( h80211[1] & 3 ) == 1 ) )\n    {\n        st_cur->power = ri->ri_power;\n        st_cur->rate_from = ri->ri_rate;\n\n        if(st_cur->lastseq != 0)\n        {\n            msd = seq - st_cur->lastseq - 1;\n            if(msd > 0 && msd < 1000)\n                st_cur->missed += msd;\n        }\n        st_cur->lastseq = seq;\n    }\n\n    st_cur->nb_pkt++;\n\nskip_station:\n\n    /* packet parsing: Probe Request */\n\n    if( h80211[0] == 0x40 && st_cur != NULL )\n    {\n        p = h80211 + 24;\n\n        while( p < h80211 + caplen )\n        {\n            if( p + 2 + p[1] > h80211 + caplen )\n                break;\n\n            if( p[0] == 0x00 && p[1] > 0 && p[2] != '\\0' &&\n                ( p[1] > 1 || p[2] != ' ' ) )\n            {\n//                n = ( p[1] > 32 ) ? 32 : p[1];\n                n = p[1];\n\n                for( i = 0; i < n; i++ )\n                    if( p[2 + i] > 0 && p[2 + i] < ' ' )\n                        goto skip_probe;\n\n                /* got a valid ASCII probed ESSID, check if it's\n                   already in the ring buffer */\n\n                for( i = 0; i < NB_PRB; i++ )\n                    if( memcmp( st_cur->probes[i], p + 2, n ) == 0 )\n                        goto skip_probe;\n\n                st_cur->probe_index = ( st_cur->probe_index + 1 ) % NB_PRB;\n                memset( st_cur->probes[st_cur->probe_index], 0, 256 );\n                memcpy( st_cur->probes[st_cur->probe_index], p + 2, n ); //twice?!\n                st_cur->ssid_length[st_cur->probe_index] = n;\n\n                for( i = 0; i < n; i++ )\n                {\n                    c = p[2 + i];\n                    if( c == 0 || ( c > 126 && c < 160 ) ) c = '.';  //could also check ||(c>0 && c<32)\n                    st_cur->probes[st_cur->probe_index][i] = c;\n                }\n            }\n\n            p += 2 + p[1];\n        }\n    }\n\nskip_probe:\n\n    /* packet parsing: Beacon or Probe Response */\n\n    if( h80211[0] == 0x80 || h80211[0] == 0x50 )\n    {\n        if( !(ap_cur->security & (STD_OPN|STD_WEP|STD_WPA|STD_WPA2)) )\n        {\n            if( ( h80211[34] & 0x10 ) >> 4 ) ap_cur->security |= STD_WEP|ENC_WEP;\n            else ap_cur->security |= STD_OPN;\n        }\n\n        ap_cur->preamble = ( h80211[34] & 0x20 ) >> 5;\n\n        unsigned long long *tstamp = (unsigned long long *) (h80211 + 24);\n        ap_cur->timestamp = letoh64(*tstamp);\n\n        p = h80211 + 36;\n\n        while( p < h80211 + caplen )\n        {\n            if( p + 2 + p[1] > h80211 + caplen )\n                break;\n\n            //only update the essid length if the new length is > the old one\n            if( p[0] == 0x00 && (ap_cur->ssid_length < p[1]) ) ap_cur->ssid_length = p[1];\n\n            if( p[0] == 0x00 && p[1] > 0 && p[2] != '\\0' &&\n                ( p[1] > 1 || p[2] != ' ' ) )\n            {\n                /* found a non-cloaked ESSID */\n\n//                n = ( p[1] > 32 ) ? 32 : p[1];\n                n = p[1];\n\n                memset( ap_cur->essid, 0, 256 );\n                memcpy( ap_cur->essid, p + 2, n );\n\n                if( G.f_ivs != NULL && !ap_cur->essid_stored )\n                {\n                    memset(&ivs2, '\\x00', sizeof(struct ivs2_pkthdr));\n                    ivs2.flags |= IVS2_ESSID;\n                    ivs2.len += ap_cur->ssid_length;\n\n                    if( memcmp( G.prev_bssid, ap_cur->bssid, 6 ) != 0 )\n                    {\n                        ivs2.flags |= IVS2_BSSID;\n                        ivs2.len += 6;\n                        memcpy( G.prev_bssid, ap_cur->bssid,  6 );\n                    }\n\n                    /* write header */\n                    if( fwrite( &ivs2, 1, sizeof(struct ivs2_pkthdr), G.f_ivs )\n                        != (size_t) sizeof(struct ivs2_pkthdr) )\n                    {\n                        perror( \"fwrite(IV header) failed\" );\n                        return( 1 );\n                    }\n\n                    /* write BSSID */\n                    if(ivs2.flags & IVS2_BSSID)\n                    {\n                        if( fwrite( ap_cur->bssid, 1, 6, G.f_ivs )\n                            != (size_t) 6 )\n                        {\n                            perror( \"fwrite(IV bssid) failed\" );\n                            return( 1 );\n                        }\n                    }\n\n                    /* write essid */\n                    if( fwrite( ap_cur->essid, 1, ap_cur->ssid_length, G.f_ivs )\n                        != (size_t) ap_cur->ssid_length )\n                    {\n                        perror( \"fwrite(IV essid) failed\" );\n                        return( 1 );\n                    }\n\n                    ap_cur->essid_stored = 1;\n                }\n\n                for( i = 0; i < n; i++ )\n                    if( ( ap_cur->essid[i] >   0 && ap_cur->essid[i] <  32 ) ||\n                        ( ap_cur->essid[i] > 126 && ap_cur->essid[i] < 160 ) )\n                        ap_cur->essid[i] = '.';\n            }\n\n            /* get the maximum speed in Mb and the AP's channel */\n\n            if( p[0] == 0x01 || p[0] == 0x32 )\n            {\n                if(ap_cur->max_speed < ( p[1 + p[1]] & 0x7F ) / 2)\n                    ap_cur->max_speed = ( p[1 + p[1]] & 0x7F ) / 2;\n            }\n\n            if( p[0] == 0x03 )\n                ap_cur->channel = p[2];\n\n            p += 2 + p[1];\n        }\n    }\n\n    /* packet parsing: Beacon & Probe response */\n\n    if( (h80211[0] == 0x80 || h80211[0] == 0x50) && caplen > 38)\n    {\n        p=h80211+36;         //ignore hdr + fixed params\n\n        while( p < h80211 + caplen )\n        {\n            type = p[0];\n            length = p[1];\n            if(p+2+length > h80211 + caplen) {\n/*                printf(\"error parsing tags! %p vs. %p (tag: %i, length: %i,position: %i)\\n\", (p+2+length), (h80211+caplen), type, length, (p-h80211));\n                exit(1);*/\n                break;\n            }\n\n            if( (type == 0xDD && (length >= 8) && (memcmp(p+2, \"\\x00\\x50\\xF2\\x01\\x01\\x00\", 6) == 0)) || (type == 0x30) )\n            {\n                ap_cur->security &= ~(STD_WEP|ENC_WEP|STD_WPA);\n\n                org_p = p;\n                offset = 0;\n\n                if(type == 0xDD)\n                {\n                    //WPA defined in vendor specific tag -> WPA1 support\n                    ap_cur->security |= STD_WPA;\n                    offset = 4;\n                }\n\n                if(type == 0x30)\n                {\n                    ap_cur->security |= STD_WPA2;\n                    offset = 0;\n                }\n\n                if(length < (18+offset))\n                {\n                    p += length+2;\n                    continue;\n                }\n\n                if( p+9+offset > h80211+caplen )\n                    break;\n                numuni  = p[8+offset] + (p[9+offset]<<8);\n\n                if( p+ (11+offset) + 4*numuni > h80211+caplen)\n                    break;\n                numauth = p[(10+offset) + 4*numuni] + (p[(11+offset) + 4*numuni]<<8);\n\n                p += (10+offset);\n\n                if(type != 0x30)\n                {\n                    if( p + (4*numuni) + (2+4*numauth) > h80211+caplen)\n                        break;\n                }\n                else\n                {\n                    if( p + (4*numuni) + (2+4*numauth) + 2 > h80211+caplen)\n                        break;\n                }\n\n                for(i=0; i<numuni; i++)\n                {\n                    switch(p[i*4+3])\n                    {\n                    case 0x01:\n                        ap_cur->security |= ENC_WEP;\n                        break;\n                    case 0x02:\n                        ap_cur->security |= ENC_TKIP;\n                        break;\n                    case 0x03:\n                        ap_cur->security |= ENC_WRAP;\n                        break;\n                    case 0x04:\n                        ap_cur->security |= ENC_CCMP;\n                        break;\n                    case 0x05:\n                        ap_cur->security |= ENC_WEP104;\n                        break;\n                    default:\n                        break;\n                    }\n                }\n\n                p += 2+4*numuni;\n\n                for(i=0; i<numauth; i++)\n                {\n                    switch(p[i*4+3])\n                    {\n                    case 0x01:\n                        ap_cur->security |= AUTH_MGT;\n                        break;\n                    case 0x02:\n                        ap_cur->security |= AUTH_PSK;\n                        break;\n                    default:\n                        break;\n                    }\n                }\n\n                p += 2+4*numauth;\n\n                if( type == 0x30 ) p += 2;\n\n                p = org_p + length+2;\n            }\n            else if( (type == 0xDD && (length >= 8) && (memcmp(p+2, \"\\x00\\x50\\xF2\\x02\\x01\\x01\", 6) == 0)))\n            {\n                ap_cur->security |= STD_QOS;\n                p += length+2;\n            }\n            else p += length+2;\n        }\n    }\n\n    /* packet parsing: Authentication Response */\n\n    if( h80211[0] == 0xB0 && caplen >= 30)\n    {\n        if( ap_cur->security & STD_WEP )\n        {\n            //successful step 2 or 4 (coming from the AP)\n            if(memcmp(h80211+28, \"\\x00\\x00\", 2) == 0 &&\n                (h80211[26] == 0x02 || h80211[26] == 0x04))\n            {\n                ap_cur->security &= ~(AUTH_OPN | AUTH_PSK | AUTH_MGT);\n                if(h80211[24] == 0x00) ap_cur->security |= AUTH_OPN;\n                if(h80211[24] == 0x01) ap_cur->security |= AUTH_PSK;\n            }\n        }\n    }\n\n    /* packet parsing: Association Request */\n\n    if( h80211[0] == 0x00 && caplen > 28 )\n    {\n        p = h80211 + 28;\n\n        while( p < h80211 + caplen )\n        {\n            if( p + 2 + p[1] > h80211 + caplen )\n                break;\n\n            if( p[0] == 0x00 && p[1] > 0 && p[2] != '\\0' &&\n                ( p[1] > 1 || p[2] != ' ' ) )\n            {\n                /* found a non-cloaked ESSID */\n\n                n = ( p[1] > 32 ) ? 32 : p[1];\n\n                memset( ap_cur->essid, 0, 33 );\n                memcpy( ap_cur->essid, p + 2, n );\n\n                if( G.f_ivs != NULL && !ap_cur->essid_stored )\n                {\n                    memset(&ivs2, '\\x00', sizeof(struct ivs2_pkthdr));\n                    ivs2.flags |= IVS2_ESSID;\n                    ivs2.len += ap_cur->ssid_length;\n\n                    if( memcmp( G.prev_bssid, ap_cur->bssid, 6 ) != 0 )\n                    {\n                        ivs2.flags |= IVS2_BSSID;\n                        ivs2.len += 6;\n                        memcpy( G.prev_bssid, ap_cur->bssid,  6 );\n                    }\n\n                    /* write header */\n                    if( fwrite( &ivs2, 1, sizeof(struct ivs2_pkthdr), G.f_ivs )\n                        != (size_t) sizeof(struct ivs2_pkthdr) )\n                    {\n                        perror( \"fwrite(IV header) failed\" );\n                        return( 1 );\n                    }\n\n                    /* write BSSID */\n                    if(ivs2.flags & IVS2_BSSID)\n                    {\n                        if( fwrite( ap_cur->bssid, 1, 6, G.f_ivs )\n                            != (size_t) 6 )\n                        {\n                            perror( \"fwrite(IV bssid) failed\" );\n                            return( 1 );\n                        }\n                    }\n\n                    /* write essid */\n                    if( fwrite( ap_cur->essid, 1, ap_cur->ssid_length, G.f_ivs )\n                        != (size_t) ap_cur->ssid_length )\n                    {\n                        perror( \"fwrite(IV essid) failed\" );\n                        return( 1 );\n                    }\n\n                    ap_cur->essid_stored = 1;\n                }\n\n                for( i = 0; i < n; i++ )\n                    if( ap_cur->essid[i] < 32 ||\n                      ( ap_cur->essid[i] > 126 && ap_cur->essid[i] < 160 ) )\n                        ap_cur->essid[i] = '.';\n            }\n\n            p += 2 + p[1];\n        }\n        if(st_cur != NULL)\n            st_cur->wpa.state = 0;\n    }\n\n    /* packet parsing: some data */\n\n    if( ( h80211[0] & 0x0C ) == 0x08 )\n    {\n        /* update the channel if we didn't get any beacon */\n\n        if( ap_cur->channel == -1 )\n        {\n            if(ri->ri_channel > 0 && ri->ri_channel < 167)\n                ap_cur->channel = ri->ri_channel;\n            else\n                ap_cur->channel = G.channel[cardnum];\n        }\n\n        /* check the SNAP header to see if data is encrypted */\n\n        z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n\n        /* Check if 802.11e (QoS) */\n        if( (h80211[0] & 0x80) == 0x80)\n        {\n            z+=2;\n            if(st_cur != NULL)\n            {\n                if( (h80211[1] & 3) == 1 ) //ToDS\n                    st_cur->qos_to_ds = 1;\n                else\n                    st_cur->qos_fr_ds = 1;\n            }\n        }\n        else\n        {\n            if(st_cur != NULL)\n            {\n                if( (h80211[1] & 3) == 1 ) //ToDS\n                    st_cur->qos_to_ds = 0;\n                else\n                    st_cur->qos_fr_ds = 0;\n            }\n        }\n\n        if(z==24)\n        {\n            if(list_check_decloak(&(ap_cur->packets), caplen, h80211) != 0)\n            {\n                list_add_packet(&(ap_cur->packets), caplen, h80211);\n            }\n            else\n            {\n                ap_cur->is_decloak = 1;\n                ap_cur->decloak_detect = 0;\n                list_tail_free(&(ap_cur->packets));\n                memset(G.message, '\\x00', sizeof(G.message));\n                    snprintf( G.message, sizeof( G.message ) - 1,\n                        \"][ Decloak: %02X:%02X:%02X:%02X:%02X:%02X \",\n                        ap_cur->bssid[0], ap_cur->bssid[1], ap_cur->bssid[2],\n                        ap_cur->bssid[3], ap_cur->bssid[4], ap_cur->bssid[5]);\n            }\n        }\n\n        if( z + 26 > (unsigned)caplen )\n            goto write_packet;\n\n        if( h80211[z] == h80211[z + 1] && h80211[z + 2] == 0x03 )\n        {\n//            if( ap_cur->encryption < 0 )\n//                ap_cur->encryption = 0;\n\n            /* if ethertype == IPv4, find the LAN address */\n\n            if( h80211[z + 6] == 0x08 && h80211[z + 7] == 0x00 &&\n                ( h80211[1] & 3 ) == 0x01 )\n                    memcpy( ap_cur->lanip, &h80211[z + 20], 4 );\n\n            if( h80211[z + 6] == 0x08 && h80211[z + 7] == 0x06 )\n                memcpy( ap_cur->lanip, &h80211[z + 22], 4 );\n        }\n//        else\n//            ap_cur->encryption = 2 + ( ( h80211[z + 3] & 0x20 ) >> 5 );\n\n\n        if(ap_cur->security == 0 || (ap_cur->security & STD_WEP) )\n        {\n            if( (h80211[1] & 0x40) != 0x40 )\n            {\n                ap_cur->security |= STD_OPN;\n            }\n            else\n            {\n                if((h80211[z+3] & 0x20) == 0x20)\n                {\n                    ap_cur->security |= STD_WPA;\n                }\n                else\n                {\n                    ap_cur->security |= STD_WEP;\n                    if( (h80211[z+3] & 0xC0) != 0x00)\n                    {\n                        ap_cur->security |= ENC_WEP40;\n                    }\n                    else\n                    {\n                        ap_cur->security &= ~ENC_WEP40;\n                        ap_cur->security |= ENC_WEP;\n                    }\n                }\n            }\n        }\n\n        if( z + 10 > (unsigned)caplen )\n            goto write_packet;\n\n        if( ap_cur->security & STD_WEP )\n        {\n            /* WEP: check if we've already seen this IV */\n\n            if( ! uniqueiv_check( ap_cur->uiv_root, &h80211[z] ) )\n            {\n                /* first time seen IVs */\n\n                if( G.f_ivs != NULL )\n                {\n                    memset(&ivs2, '\\x00', sizeof(struct ivs2_pkthdr));\n                    ivs2.flags = 0;\n                    ivs2.len = 0;\n\n                    /* datalen = caplen - (header+iv+ivs) */\n                    dlen = caplen -z -4 -4; //original data len\n                    if(dlen > 2048) dlen = 2048;\n                    //get cleartext + len + 4(iv+idx)\n                    num_xor = known_clear(clear, &clen, weight, h80211, dlen);\n                    if(num_xor == 1)\n                    {\n                        ivs2.flags |= IVS2_XOR;\n                        ivs2.len += clen + 4;\n                        /* reveal keystream (plain^encrypted) */\n                        for(n=0; n<(ivs2.len-4); n++)\n                        {\n                            clear[n] = (clear[n] ^ h80211[z+4+n]) & 0xFF;\n                        }\n                        //clear is now the keystream\n                    }\n                    else\n                    {\n                        //do it again to get it 2 bytes higher\n                        num_xor = known_clear(clear+2, &clen, weight, h80211, dlen);\n                        ivs2.flags |= IVS2_PTW;\n                        //len = 4(iv+idx) + 1(num of keystreams) + 1(len per keystream) + 32*num_xor + 16*sizeof(int)(weight[16])\n                        ivs2.len += 4 + 1 + 1 + 32*num_xor + 16*sizeof(int);\n                        clear[0] = num_xor;\n                        clear[1] = clen;\n                        /* reveal keystream (plain^encrypted) */\n                        for(o=0; o<num_xor; o++)\n                        {\n                            for(n=0; n<(ivs2.len-4); n++)\n                            {\n                                clear[2+n+o*32] = (clear[2+n+o*32] ^ h80211[z+4+n]) & 0xFF;\n                            }\n                        }\n                        memcpy(clear+4 + 1 + 1 + 32*num_xor, weight, 16*sizeof(int));\n                        //clear is now the keystream\n                    }\n\n                    if( memcmp( G.prev_bssid, ap_cur->bssid, 6 ) != 0 )\n                    {\n                        ivs2.flags |= IVS2_BSSID;\n                        ivs2.len += 6;\n                        memcpy( G.prev_bssid, ap_cur->bssid,  6 );\n                    }\n\n                    if( fwrite( &ivs2, 1, sizeof(struct ivs2_pkthdr), G.f_ivs )\n                        != (size_t) sizeof(struct ivs2_pkthdr) )\n                    {\n                        perror( \"fwrite(IV header) failed\" );\n                        return( 1 );\n                    }\n\n                    if( ivs2.flags & IVS2_BSSID )\n                    {\n                        if( fwrite( ap_cur->bssid, 1, 6, G.f_ivs ) != (size_t) 6 )\n                        {\n                            perror( \"fwrite(IV bssid) failed\" );\n                            return( 1 );\n                        }\n                        ivs2.len -= 6;\n                    }\n\n                    if( fwrite( h80211+z, 1, 4, G.f_ivs ) != (size_t) 4 )\n                    {\n                        perror( \"fwrite(IV iv+idx) failed\" );\n                        return( 1 );\n                    }\n                    ivs2.len -= 4;\n\n                    if( fwrite( clear, 1, ivs2.len, G.f_ivs ) != (size_t) ivs2.len )\n                    {\n                        perror( \"fwrite(IV keystream) failed\" );\n                        return( 1 );\n                    }\n                }\n\n                uniqueiv_mark( ap_cur->uiv_root, &h80211[z] );\n\n                ap_cur->nb_data++;\n            }\n\n            // Record all data linked to IV to detect WEP Cloaking\n            if( G.f_ivs == NULL && G.detect_anomaly)\n            {\n\t\t\t\t// Only allocate this when seeing WEP AP\n\t\t\t\tif (ap_cur->data_root == NULL)\n\t\t\t\t\tap_cur->data_root = data_init();\n\n\t\t\t\t// Only works with full capture, not IV-only captures\n\t\t\t\tif (data_check(ap_cur->data_root, &h80211[z], &h80211[z + 4])\n\t\t\t\t\t== CLOAKING && ap_cur->EAP_detected == 0)\n\t\t\t\t{\n\n\t\t\t\t\t//If no EAP/EAP was detected, indicate WEP cloaking\n                    memset(G.message, '\\x00', sizeof(G.message));\n                    snprintf( G.message, sizeof( G.message ) - 1,\n                        \"][ WEP Cloaking: %02X:%02X:%02X:%02X:%02X:%02X \",\n                        ap_cur->bssid[0], ap_cur->bssid[1], ap_cur->bssid[2],\n                        ap_cur->bssid[3], ap_cur->bssid[4], ap_cur->bssid[5]);\n\n\t\t\t\t}\n\t\t\t}\n\n        }\n        else\n        {\n            ap_cur->nb_data++;\n        }\n\n        z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n\n        /* Check if 802.11e (QoS) */\n        if( (h80211[0] & 0x80) == 0x80) z+=2;\n\n        if( z + 26 > (unsigned)caplen )\n            goto write_packet;\n\n        z += 6;     //skip LLC header\n\n        /* check ethertype == EAPOL */\n        if( h80211[z] == 0x88 && h80211[z + 1] == 0x8E && (h80211[1] & 0x40) != 0x40 )\n        {\n\t\t\tap_cur->EAP_detected = 1;\n\n            z += 2;     //skip ethertype\n\n            if( st_cur == NULL )\n                goto write_packet;\n\n            /* frame 1: Pairwise == 1, Install == 0, Ack == 1, MIC == 0 */\n\n            if( ( h80211[z + 6] & 0x08 ) != 0 &&\n                  ( h80211[z + 6] & 0x40 ) == 0 &&\n                  ( h80211[z + 6] & 0x80 ) != 0 &&\n                  ( h80211[z + 5] & 0x01 ) == 0 )\n            {\n                memcpy( st_cur->wpa.anonce, &h80211[z + 17], 32 );\n                st_cur->wpa.state = 1;\n            }\n\n\n            /* frame 2 or 4: Pairwise == 1, Install == 0, Ack == 0, MIC == 1 */\n\n            if( z+17+32 > (unsigned)caplen )\n                goto write_packet;\n\n            if( ( h80211[z + 6] & 0x08 ) != 0 &&\n                  ( h80211[z + 6] & 0x40 ) == 0 &&\n                  ( h80211[z + 6] & 0x80 ) == 0 &&\n                  ( h80211[z + 5] & 0x01 ) != 0 )\n            {\n                if( memcmp( &h80211[z + 17], ZERO, 32 ) != 0 )\n                {\n                    memcpy( st_cur->wpa.snonce, &h80211[z + 17], 32 );\n                    st_cur->wpa.state |= 2;\n\n                }\n\n                if( (st_cur->wpa.state & 4) != 4 )\n                {\n                    st_cur->wpa.eapol_size = ( h80211[z + 2] << 8 )\n                            +   h80211[z + 3] + 4;\n\n                    if (caplen - z < st_cur->wpa.eapol_size || st_cur->wpa.eapol_size == 0 ||\n                        caplen - z < 81 + 16 || st_cur->wpa.eapol_size > sizeof(st_cur->wpa.eapol))\n                    {\n                        // Ignore the packet trying to crash us.\n                        st_cur->wpa.eapol_size = 0;\n                        goto write_packet;\n                    }\n\n                    memcpy( st_cur->wpa.keymic, &h80211[z + 81], 16 );\n                    memcpy( st_cur->wpa.eapol,  &h80211[z], st_cur->wpa.eapol_size );\n                    memset( st_cur->wpa.eapol + 81, 0, 16 );\n                    st_cur->wpa.state |= 4;\n                    st_cur->wpa.keyver = h80211[z + 6] & 7;\n                }\n            }\n\n            /* frame 3: Pairwise == 1, Install == 1, Ack == 1, MIC == 1 */\n\n            if( ( h80211[z + 6] & 0x08 ) != 0 &&\n                  ( h80211[z + 6] & 0x40 ) != 0 &&\n                  ( h80211[z + 6] & 0x80 ) != 0 &&\n                  ( h80211[z + 5] & 0x01 ) != 0 )\n            {\n                if( memcmp( &h80211[z + 17], ZERO, 32 ) != 0 )\n                {\n                    memcpy( st_cur->wpa.anonce, &h80211[z + 17], 32 );\n                    st_cur->wpa.state |= 1;\n                }\n\n                if( (st_cur->wpa.state & 4) != 4 )\n                {\n                    st_cur->wpa.eapol_size = ( h80211[z + 2] << 8 )\n                            +   h80211[z + 3] + 4;\n\n                    if (caplen - (unsigned)z < st_cur->wpa.eapol_size || st_cur->wpa.eapol_size == 0 ||\n                        caplen - (unsigned)z < 81 + 16 || st_cur->wpa.eapol_size > sizeof(st_cur->wpa.eapol))\n                    {\n                        // Ignore the packet trying to crash us.\n                        st_cur->wpa.eapol_size = 0;\n                        goto write_packet;\n                    }\n\n                    memcpy( st_cur->wpa.keymic, &h80211[z + 81], 16 );\n                    memcpy( st_cur->wpa.eapol,  &h80211[z], st_cur->wpa.eapol_size );\n                    memset( st_cur->wpa.eapol + 81, 0, 16 );\n                    st_cur->wpa.state |= 4;\n                    st_cur->wpa.keyver = h80211[z + 6] & 7;\n                }\n            }\n\n            if( st_cur->wpa.state == 7)\n            {\n                memcpy( st_cur->wpa.stmac, st_cur->stmac, 6 );\n                memcpy( G.wpa_bssid, ap_cur->bssid, 6 );\n                memset(G.message, '\\x00', sizeof(G.message));\n                snprintf( G.message, sizeof( G.message ) - 1,\n                    \"][ WPA handshake: %02X:%02X:%02X:%02X:%02X:%02X \",\n                    G.wpa_bssid[0], G.wpa_bssid[1], G.wpa_bssid[2],\n                    G.wpa_bssid[3], G.wpa_bssid[4], G.wpa_bssid[5]);\n\n\n                if( G.f_ivs != NULL )\n                {\n                    memset(&ivs2, '\\x00', sizeof(struct ivs2_pkthdr));\n                    ivs2.flags = 0;\n                    ivs2.len = 0;\n\n                    ivs2.len= sizeof(struct WPA_hdsk);\n                    ivs2.flags |= IVS2_WPA;\n\n                    if( memcmp( G.prev_bssid, ap_cur->bssid, 6 ) != 0 )\n                    {\n                        ivs2.flags |= IVS2_BSSID;\n                        ivs2.len += 6;\n                        memcpy( G.prev_bssid, ap_cur->bssid,  6 );\n                    }\n\n                    if( fwrite( &ivs2, 1, sizeof(struct ivs2_pkthdr), G.f_ivs )\n                        != (size_t) sizeof(struct ivs2_pkthdr) )\n                    {\n                        perror( \"fwrite(IV header) failed\" );\n                        return( 1 );\n                    }\n\n                    if( ivs2.flags & IVS2_BSSID )\n                    {\n                        if( fwrite( ap_cur->bssid, 1, 6, G.f_ivs ) != (size_t) 6 )\n                        {\n                            perror( \"fwrite(IV bssid) failed\" );\n                            return( 1 );\n                        }\n                        ivs2.len -= 6;\n                    }\n\n                    if( fwrite( &(st_cur->wpa), 1, sizeof(struct WPA_hdsk), G.f_ivs ) != (size_t) sizeof(struct WPA_hdsk) )\n                    {\n                        perror( \"fwrite(IV wpa_hdsk) failed\" );\n                        return( 1 );\n                    }\n                }\n            }\n        }\n    }\n\n\nwrite_packet:\n\n    if(ap_cur != NULL)\n    {\n        if( h80211[0] == 0x80 && G.one_beacon){\n            if( !ap_cur->beacon_logged )\n                ap_cur->beacon_logged = 1;\n            else return ( 0 );\n        }\n    }\n\n    if(G.record_data)\n    {\n        if( ( (h80211[0] & 0x0C) == 0x00 ) && ( (h80211[0] & 0xF0) == 0xB0 ) )\n        {\n            /* authentication packet */\n            check_shared_key(h80211, caplen);\n        }\n    }\n\n    if(ap_cur != NULL)\n    {\n        if(ap_cur->security != 0 && G.f_encrypt != 0 && ((ap_cur->security & G.f_encrypt) == 0))\n        {\n            return(1);\n        }\n\n        if(is_filtered_essid(ap_cur->essid))\n        {\n            return(1);\n        }\n\n    }\n\n    /* this changes the local ap_cur, st_cur and na_cur variables and should be the last check befor the actual write */\n    if(caplen < 24 && caplen >= 10 && h80211[0])\n    {\n        /* RTS || CTS || ACK || CF-END || CF-END&CF-ACK*/\n        //(h80211[0] == 0xB4 || h80211[0] == 0xC4 || h80211[0] == 0xD4 || h80211[0] == 0xE4 || h80211[0] == 0xF4)\n\n        /* use general control frame detection, as the structure is always the same: mac(s) starting at [4] */\n        if(h80211[0] & 0x04)\n        {\n            p=h80211+4;\n            while(p <= h80211+16 && p<=h80211+caplen)\n            {\n                memcpy(namac, p, 6);\n\n                if(memcmp(namac, NULL_MAC, 6) == 0)\n                {\n                    p+=6;\n                    continue;\n                }\n\n                if(memcmp(namac, BROADCAST, 6) == 0)\n                {\n                    p+=6;\n                    continue;\n                }\n\n                if(G.hide_known)\n                {\n                    /* check AP list */\n                    ap_cur = G.ap_1st;\n                    ap_prv = NULL;\n\n                    while( ap_cur != NULL )\n                    {\n                        if( ! memcmp( ap_cur->bssid, namac, 6 ) )\n                            break;\n\n                        ap_prv = ap_cur;\n                        ap_cur = ap_cur->next;\n                    }\n\n                    /* if it's an AP, try next mac */\n\n                    if( ap_cur != NULL )\n                    {\n                        p+=6;\n                        continue;\n                    }\n\n                    /* check ST list */\n                    st_cur = G.st_1st;\n                    st_prv = NULL;\n\n                    while( st_cur != NULL )\n                    {\n                        if( ! memcmp( st_cur->stmac, namac, 6 ) )\n                            break;\n\n                        st_prv = st_cur;\n                        st_cur = st_cur->next;\n                    }\n\n                    /* if it's a client, try next mac */\n\n                    if( st_cur != NULL )\n                    {\n                        p+=6;\n                        continue;\n                    }\n                }\n\n                /* not found in either AP list or ST list, look through NA list */\n                na_cur = G.na_1st;\n                na_prv = NULL;\n\n                while( na_cur != NULL )\n                {\n                    if( ! memcmp( na_cur->namac, namac, 6 ) )\n                        break;\n\n                    na_prv = na_cur;\n                    na_cur = na_cur->next;\n                }\n\n                /* update our chained list of unknown stations */\n                /* if it's a new mac, add it */\n\n                if( na_cur == NULL )\n                {\n                    if( ! ( na_cur = (struct NA_info *) malloc(\n                                    sizeof( struct NA_info ) ) ) )\n                    {\n                        perror( \"malloc failed\" );\n                        return( 1 );\n                    }\n\n                    memset( na_cur, 0, sizeof( struct NA_info ) );\n\n                    if( G.na_1st == NULL )\n                        G.na_1st = na_cur;\n                    else\n                        na_prv->next  = na_cur;\n\n                    memcpy( na_cur->namac, namac, 6 );\n\n                    na_cur->prev = na_prv;\n\n                    gettimeofday(&(na_cur->tv), NULL);\n                    na_cur->tinit = time( NULL );\n                    na_cur->tlast = time( NULL );\n\n                    na_cur->power   = -1;\n                    na_cur->channel = -1;\n                    na_cur->ack     = 0;\n                    na_cur->ack_old = 0;\n                    na_cur->ackps   = 0;\n                    na_cur->cts     = 0;\n                    na_cur->rts_r   = 0;\n                    na_cur->rts_t   = 0;\n                }\n\n                /* update the last time seen & power*/\n\n                na_cur->tlast = time( NULL );\n                na_cur->power = ri->ri_power;\n                na_cur->channel = ri->ri_channel;\n\n                switch(h80211[0] & 0xF0)\n                {\n                    case 0xB0:\n                        if(p == h80211+4)\n                            na_cur->rts_r++;\n                        if(p == h80211+10)\n                            na_cur->rts_t++;\n                        break;\n\n                    case 0xC0:\n                        na_cur->cts++;\n                        break;\n\n                    case 0xD0:\n                        na_cur->ack++;\n                        break;\n\n                    default:\n                        na_cur->other++;\n                        break;\n                }\n\n                /*grab next mac (for rts frames)*/\n                p+=6;\n            }\n        }\n    }\n\n    if( G.f_cap != NULL && caplen >= 10)\n    {\n        pkh.caplen = pkh.len = caplen;\n\n        gettimeofday( &tv, NULL );\n\n        pkh.tv_sec  =   tv.tv_sec;\n        pkh.tv_usec = ( tv.tv_usec & ~0x1ff ) + ri->ri_power + 64;\n\n        n = sizeof( pkh );\n\n        if( fwrite( &pkh, 1, n, G.f_cap ) != (size_t) n )\n        {\n            perror( \"fwrite(packet header) failed\" );\n            return( 1 );\n        }\n\n        fflush( stdout );\n\n        n = pkh.caplen;\n\n        if( fwrite( h80211, 1, n, G.f_cap ) != (size_t) n )\n        {\n            perror( \"fwrite(packet data) failed\" );\n            return( 1 );\n        }\n\n        fflush( stdout );\n    }\n\n    return( 0 );\n}\n\nvoid dump_sort( void )\n{\n    time_t tt = time( NULL );\n\n    /* thanks to Arnaud Cornet :-) */\n\n    struct AP_info *new_ap_1st = NULL;\n    struct AP_info *new_ap_end = NULL;\n\n    struct ST_info *new_st_1st = NULL;\n    struct ST_info *new_st_end = NULL;\n\n    struct ST_info *st_cur, *st_min;\n    struct AP_info *ap_cur, *ap_min;\n\n    /* sort the aps by WHATEVER first */\n\n    while( G.ap_1st )\n    {\n        ap_min = NULL;\n        ap_cur = G.ap_1st;\n\n        while( ap_cur != NULL )\n        {\n            if( tt - ap_cur->tlast > 20 )\n                ap_min = ap_cur;\n\n            ap_cur = ap_cur->next;\n        }\n\n        if( ap_min == NULL )\n        {\n            ap_min = ap_cur = G.ap_1st;\n\n/*#define SORT_BY_BSSID\t1\n#define SORT_BY_POWER\t2\n#define SORT_BY_BEACON\t3\n#define SORT_BY_DATA\t4\n#define SORT_BY_PRATE\t6\n#define SORT_BY_CHAN\t7\n#define\tSORT_BY_MBIT\t8\n#define SORT_BY_ENC\t9\n#define SORT_BY_CIPHER\t10\n#define SORT_BY_AUTH\t11\n#define SORT_BY_ESSID\t12*/\n\n\t    while( ap_cur != NULL )\n            {\n\t\tswitch (G.sort_by) {\n\t\t    case SORT_BY_BSSID:\n\t\t\tif( memcmp(ap_cur->bssid,ap_min->bssid,6)*G.sort_inv < 0)\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_POWER:\n\t\t\tif( (ap_cur->avg_power - ap_min->avg_power)*G.sort_inv < 0 )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_BEACON:\n\t\t\tif( (ap_cur->nb_bcn < ap_min->nb_bcn)*G.sort_inv )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_DATA:\n\t\t\tif( (ap_cur->nb_data < ap_min->nb_data)*G.sort_inv )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_PRATE:\n\t\t\tif( (ap_cur->nb_dataps - ap_min->nb_dataps)*G.sort_inv < 0 )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_CHAN:\n\t\t\tif( (ap_cur->channel - ap_min->channel)*G.sort_inv < 0 )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_MBIT:\n\t\t\tif( (ap_cur->max_speed - ap_min->max_speed)*G.sort_inv < 0 )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_ENC:\n\t\t\tif( ((ap_cur->security&STD_FIELD) - (ap_min->security&STD_FIELD))*G.sort_inv < 0 )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_CIPHER:\n\t\t\tif( ((ap_cur->security&ENC_FIELD) - (ap_min->security&ENC_FIELD))*G.sort_inv < 0 )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_AUTH:\n\t\t\tif( ((ap_cur->security&AUTH_FIELD) - (ap_min->security&AUTH_FIELD))*G.sort_inv < 0 )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_ESSID:\n\t\t\tif( (strncasecmp((char*)ap_cur->essid, (char*)ap_min->essid, MAX_IE_ELEMENT_SIZE))*G.sort_inv < 0 )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    default:\t//sort by power\n\t\t\tif( ap_cur->avg_power < ap_min->avg_power)\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t}\n                ap_cur = ap_cur->next;\n\t    }\n\t}\n\n        if( ap_min == G.ap_1st )\n            G.ap_1st = ap_min->next;\n\n        if( ap_min == G.ap_end )\n            G.ap_end = ap_min->prev;\n\n        if( ap_min->next )\n            ap_min->next->prev = ap_min->prev;\n\n        if( ap_min->prev )\n            ap_min->prev->next = ap_min->next;\n\n        if( new_ap_end )\n        {\n            new_ap_end->next = ap_min;\n            ap_min->prev = new_ap_end;\n            new_ap_end = ap_min;\n            new_ap_end->next = NULL;\n        }\n        else\n        {\n            new_ap_1st = new_ap_end = ap_min;\n            ap_min->next = ap_min->prev = NULL;\n        }\n    }\n\n    G.ap_1st = new_ap_1st;\n    G.ap_end = new_ap_end;\n\n    /* now sort the stations */\n\n    while( G.st_1st )\n    {\n        st_min = NULL;\n        st_cur = G.st_1st;\n\n        while( st_cur != NULL )\n        {\n            if( tt - st_cur->tlast > 60 )\n                st_min = st_cur;\n\n            st_cur = st_cur->next;\n        }\n\n        if( st_min == NULL )\n        {\n            st_min = st_cur = G.st_1st;\n\n            while( st_cur != NULL )\n            {\n                if( st_cur->power < st_min->power)\n                    st_min = st_cur;\n\n                st_cur = st_cur->next;\n            }\n        }\n\n        if( st_min == G.st_1st )\n            G.st_1st = st_min->next;\n\n        if( st_min == G.st_end )\n            G.st_end = st_min->prev;\n\n        if( st_min->next )\n            st_min->next->prev = st_min->prev;\n\n        if( st_min->prev )\n            st_min->prev->next = st_min->next;\n\n        if( new_st_end )\n        {\n            new_st_end->next = st_min;\n            st_min->prev = new_st_end;\n            new_st_end = st_min;\n            new_st_end->next = NULL;\n        }\n        else\n        {\n            new_st_1st = new_st_end = st_min;\n            st_min->next = st_min->prev = NULL;\n        }\n    }\n\n    G.st_1st = new_st_1st;\n    G.st_end = new_st_end;\n}\n\nint getBatteryState()\n{\n\treturn get_battery_state();\n}\n\nchar * getStringTimeFromSec(double seconds)\n{\n    int hour[3];\n    char * ret;\n    char * HourTime;\n    char * MinTime;\n\n    if (seconds <0)\n        return NULL;\n\n    ret = (char *) calloc(1,256);\n\n    HourTime = (char *) calloc (1,128);\n    MinTime  = (char *) calloc (1,128);\n\n    hour[0]  = (int) (seconds);\n    hour[1]  = hour[0] / 60;\n    hour[2]  = hour[1] / 60;\n    hour[0] %= 60 ;\n    hour[1] %= 60 ;\n\n    if (hour[2] != 0 )\n        snprintf(HourTime, 128, \"%d %s\", hour[2], ( hour[2] == 1 ) ? \"hour\" : \"hours\");\n    if (hour[1] != 0 )\n        snprintf(MinTime, 128, \"%d %s\", hour[1], ( hour[1] == 1 ) ? \"min\" : \"mins\");\n\n    if ( hour[2] != 0 && hour[1] != 0 )\n        snprintf(ret, 256, \"%s %s\", HourTime, MinTime);\n    else\n    {\n        if (hour[2] == 0 && hour[1] == 0)\n            snprintf(ret, 256, \"%d s\", hour[0] );\n        else\n            snprintf(ret, 256, \"%s\", (hour[2] == 0) ? MinTime : HourTime );\n    }\n\n    free(MinTime);\n    free(HourTime);\n\n    return ret;\n\n}\n\nchar * getBatteryString(void)\n{\n    int batt_time;\n    char * ret;\n    char * batt_string;\n\n    batt_time = getBatteryState();\n\n    if ( batt_time <= 60 ) {\n        ret = (char *) calloc(1,2);\n        ret[0] = ']';\n        return ret;\n    }\n\n    batt_string = getStringTimeFromSec( (double) batt_time );\n\n    ret = (char *) calloc( 1, 256 );\n\n    snprintf( ret, 256, \"][ BAT: %s ]\", batt_string );\n\n    free( batt_string);\n\n    return ret;\n}\n\nint get_ap_list_count() {\n    time_t tt;\n    struct tm *lt;\n    struct AP_info *ap_cur;\n\n    int num_ap;\n\n    tt = time( NULL );\n    lt = localtime( &tt );\n\n    ap_cur = G.ap_end;\n\n    num_ap = 0;\n\n    while( ap_cur != NULL )\n    {\n        /* skip APs with only one packet, or those older than 2 min.\n         * always skip if bssid == broadcast */\n\n        if( ap_cur->nb_pkt < 2 || time( NULL ) - ap_cur->tlast > G.berlin ||\n            memcmp( ap_cur->bssid, BROADCAST, 6 ) == 0 )\n        {\n            ap_cur = ap_cur->prev;\n            continue;\n        }\n\n        if(ap_cur->security != 0 && G.f_encrypt != 0 && ((ap_cur->security & G.f_encrypt) == 0))\n        {\n            ap_cur = ap_cur->prev;\n            continue;\n        }\n\n        if(is_filtered_essid(ap_cur->essid))\n        {\n            ap_cur = ap_cur->prev;\n            continue;\n        }\n\n\tnum_ap++;\n\tap_cur = ap_cur->prev;\n    }\n\n    return num_ap;\n}\n\nint get_sta_list_count() {\n    time_t tt;\n    struct tm *lt;\n    struct AP_info *ap_cur;\n    struct ST_info *st_cur;\n\n    int num_sta;\n\n    tt = time( NULL );\n    lt = localtime( &tt );\n\n    ap_cur = G.ap_end;\n\n    num_sta = 0;\n\n    while( ap_cur != NULL )\n    {\n        if( ap_cur->nb_pkt < 2 ||\n            time( NULL ) - ap_cur->tlast > G.berlin )\n        {\n            ap_cur = ap_cur->prev;\n            continue;\n        }\n\n        if(ap_cur->security != 0 && G.f_encrypt != 0 && ((ap_cur->security & G.f_encrypt) == 0))\n        {\n            ap_cur = ap_cur->prev;\n            continue;\n        }\n\n        // Don't filter unassociated clients by ESSID\n        if(memcmp(ap_cur->bssid, BROADCAST, 6) && is_filtered_essid(ap_cur->essid))\n        {\n            ap_cur = ap_cur->prev;\n            continue;\n        }\n\n        st_cur = G.st_end;\n\n        while( st_cur != NULL )\n        {\n            if( st_cur->base != ap_cur ||\n                time( NULL ) - st_cur->tlast > G.berlin )\n            {\n                st_cur = st_cur->prev;\n                continue;\n            }\n\n            if( ! memcmp( ap_cur->bssid, BROADCAST, 6 ) && G.asso_client )\n            {\n                st_cur = st_cur->prev;\n                continue;\n            }\n\n\t    num_sta++;\n\n            st_cur = st_cur->prev;\n        }\n\n        ap_cur = ap_cur->prev;\n    }\n    return num_sta;\n}\n\n#define TSTP_SEC 1000000ULL /* It's a 1 MHz clock, so a million ticks per second! */\n#define TSTP_MIN (TSTP_SEC * 60ULL)\n#define TSTP_HOUR (TSTP_MIN * 60ULL)\n#define TSTP_DAY (TSTP_HOUR * 24ULL)\n\nstatic char *parse_timestamp(unsigned long long timestamp) {\n\tstatic char s[15];\n\tunsigned long long rem;\n\tunsigned int days, hours, mins, secs;\n\n\tdays = timestamp / TSTP_DAY;\n\trem = timestamp % TSTP_DAY;\n\thours = rem / TSTP_HOUR;\n\trem %= TSTP_HOUR;\n\tmins = rem / TSTP_MIN;\n\trem %= TSTP_MIN;\n\tsecs = rem / TSTP_SEC;\n\n\tsnprintf(s, 14, \"%3dd %02d:%02d:%02d\", days, hours, mins, secs);\n\n\treturn s;\n}\n\nvoid dump_print( int ws_row, int ws_col, int if_num )\n{\n    time_t tt;\n    struct tm *lt;\n    int nlines, i, n, len;\n    char strbuf[512];\n    char buffer[512];\n    char ssid_list[512];\n    struct AP_info *ap_cur;\n    struct ST_info *st_cur;\n    struct NA_info *na_cur;\n    int columns_ap = 83;\n    int columns_sta = 74;\n    int columns_na = 68;\n\n    int num_ap;\n    int num_sta;\n\n    if(!G.singlechan) columns_ap -= 4; //no RXQ in scan mode\n    if(G.show_uptime) columns_ap += 15; //show uptime needs more space\n\n    nlines = 2;\n\n    if( nlines >= ws_row )\n        return;\n\n    if(G.do_sort_always) {\n\tpthread_mutex_lock( &(G.mx_sort) );\n\t    dump_sort();\n\tpthread_mutex_unlock( &(G.mx_sort) );\n    }\n\n    tt = time( NULL );\n    lt = localtime( &tt );\n\n    if(G.is_berlin)\n    {\n        G.maxaps = 0;\n        G.numaps = 0;\n        ap_cur = G.ap_end;\n\n        while( ap_cur != NULL )\n        {\n            G.maxaps++;\n            if( ap_cur->nb_pkt < 2 || time( NULL ) - ap_cur->tlast > G.berlin ||\n                memcmp( ap_cur->bssid, BROADCAST, 6 ) == 0 )\n            {\n                ap_cur = ap_cur->prev;\n                continue;\n            }\n            G.numaps++;\n            ap_cur = ap_cur->prev;\n        }\n\n        if(G.numaps > G.maxnumaps)\n            G.maxnumaps = G.numaps;\n\n//        G.maxaps--;\n    }\n\n    /*\n     *  display the channel, battery, position (if we are connected to GPSd)\n     *  and current time\n     */\n\n    memset( strbuf, '\\0', sizeof(strbuf) );\n    strbuf[ws_col - 1] = '\\0';\n    fprintf( stderr, \"%s\\n\", strbuf );\n\n    if(G.freqoption)\n    {\n        snprintf(strbuf, sizeof(strbuf)-1, \" Freq %4d\", G.frequency[0]);\n        for(i=1; i<if_num; i++)\n        {\n            memset( buffer, '\\0', sizeof(buffer) );\n            snprintf(buffer, sizeof(buffer) , \",%4d\", G.frequency[i]);\n            strncat(strbuf, buffer, sizeof(strbuf) - strlen(strbuf) - 1);\n        }\n    }\n    else\n    {\n        snprintf(strbuf, sizeof(strbuf)-1, \" CH %2d\", G.channel[0]);\n        for(i=1; i<if_num; i++)\n        {\n            memset( buffer, '\\0', sizeof(buffer) );\n            snprintf(buffer, sizeof(buffer) , \",%2d\", G.channel[i]);\n            strncat(strbuf, buffer, sizeof(strbuf) - strlen(strbuf) -1);\n        }\n    }\n    memset( buffer, '\\0', sizeof(buffer) );\n\n    if (G.gps_loc[0]) {\n        snprintf( buffer, sizeof( buffer ) - 1,\n              \" %s[ GPS %8.3f %8.3f %8.3f %6.2f \"\n              \"][ Elapsed: %s ][ %04d-%02d-%02d %02d:%02d \", G.batt,\n              G.gps_loc[0], G.gps_loc[1], G.gps_loc[2], G.gps_loc[3],\n              G.elapsed_time , 1900 + lt->tm_year,\n              1 + lt->tm_mon, lt->tm_mday, lt->tm_hour, lt->tm_min );\n    }\n    else\n    {\n        snprintf( buffer, sizeof( buffer ) - 1,\n              \" %s[ Elapsed: %s ][ %04d-%02d-%02d %02d:%02d \",\n              G.batt, G.elapsed_time, 1900 + lt->tm_year,\n              1 + lt->tm_mon, lt->tm_mday, lt->tm_hour, lt->tm_min );\n    }\n\n    strncat(strbuf, buffer, (512-strlen(strbuf)));\n    memset( buffer, '\\0', 512 );\n\n    if(G.is_berlin)\n    {\n        snprintf( buffer, sizeof( buffer ) - 1,\n              \" ][%3d/%3d/%4d \",\n              G.numaps, G.maxnumaps, G.maxaps);\n    }\n\n    strncat(strbuf, buffer, (512-strlen(strbuf)));\n    memset( buffer, '\\0', 512 );\n\n    if(strlen(G.message) > 0)\n    {\n        strncat(strbuf, G.message, (512-strlen(strbuf)));\n    }\n\n    //add traling spaces to overwrite previous messages\n    strncat(strbuf, \"                                        \", (512-strlen(strbuf)));\n\n    strbuf[ws_col - 1] = '\\0';\n    fprintf( stderr, \"%s\\n\", strbuf );\n\n    /* print some informations about each detected AP */\n\n    nlines += 3;\n\n    if( nlines >= ws_row )\n        return;\n\n    memset( strbuf, ' ', ws_col - 1 );\n    strbuf[ws_col - 1] = '\\0';\n    fprintf( stderr, \"%s\\n\", strbuf );\n\n    if(G.show_ap) {\n\n    strbuf[0] = 0;\n    strcat(strbuf, \" BSSID              PWR \");\n\n    if(G.singlechan)\n    \tstrcat(strbuf, \"RXQ \");\n\n    strcat(strbuf, \" Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH \");\n\n    if (G.show_uptime)\n    \tstrcat(strbuf, \"       UPTIME  \");\n\n    strcat(strbuf, \"ESSID\");\n\n\tif ( G.show_manufacturer && ( ws_col > (columns_ap - 4) ) ) {\n\t\t// write spaces (32).\n\t\tmemset(strbuf+columns_ap, 32, G.maxsize_essid_seen - 5 ); // 5 is the len of \"ESSID\"\n\t\tsnprintf(strbuf+columns_ap+G.maxsize_essid_seen-5, 15,\"%s\",\"  MANUFACTURER\");\n\t}\n\n\tstrbuf[ws_col - 1] = '\\0';\n\tfprintf( stderr, \"%s\\n\", strbuf );\n\n\tmemset( strbuf, ' ', ws_col - 1 );\n\tstrbuf[ws_col - 1] = '\\0';\n\tfprintf( stderr, \"%s\\n\", strbuf );\n\n\tap_cur = G.ap_end;\n\n\tif(G.selection_ap) {\n\t    num_ap = get_ap_list_count();\n\t    if(G.selected_ap > num_ap)\n\t\tG.selected_ap = num_ap;\n\t}\n\n\tif(G.selection_sta) {\n\t    num_sta = get_sta_list_count();\n\t    if(G.selected_sta > num_sta)\n\t\tG.selected_sta = num_sta;\n\t}\n\n\tnum_ap = 0;\n\n\tif(G.selection_ap) {\n\t    G.start_print_ap = G.selected_ap - ((ws_row-1) - nlines) + 1;\n\t    if(G.start_print_ap < 1)\n\t\tG.start_print_ap = 1;\n    //\tprintf(\"%i\\n\", G.start_print_ap);\n\t}\n\n\n\twhile( ap_cur != NULL )\n\t{\n\t    /* skip APs with only one packet, or those older than 2 min.\n\t    * always skip if bssid == broadcast */\n\n\t    if( ap_cur->nb_pkt < 2 || time( NULL ) - ap_cur->tlast > G.berlin ||\n\t\tmemcmp( ap_cur->bssid, BROADCAST, 6 ) == 0 )\n\t    {\n\t\tap_cur = ap_cur->prev;\n\t\tcontinue;\n\t    }\n\n\t    if(ap_cur->security != 0 && G.f_encrypt != 0 && ((ap_cur->security & G.f_encrypt) == 0))\n\t    {\n\t\tap_cur = ap_cur->prev;\n\t\tcontinue;\n\t    }\n\n\t    if(is_filtered_essid(ap_cur->essid))\n\t    {\n\t\tap_cur = ap_cur->prev;\n\t\tcontinue;\n\t    }\n\n\t    num_ap++;\n\n\t    if(num_ap < G.start_print_ap) {\n\t\tap_cur = ap_cur->prev;\n\t\tcontinue;\n\t    }\n\n\t    nlines++;\n\n\t    if( nlines > (ws_row-1) )\n\t\treturn;\n\n\t    memset(strbuf, '\\0', sizeof(strbuf));\n\n\t    snprintf( strbuf, sizeof(strbuf), \" %02X:%02X:%02X:%02X:%02X:%02X\",\n\t\t    ap_cur->bssid[0], ap_cur->bssid[1],\n\t\t    ap_cur->bssid[2], ap_cur->bssid[3],\n\t\t    ap_cur->bssid[4], ap_cur->bssid[5] );\n\n\t    len = strlen(strbuf);\n\n\t    if(G.singlechan)\n\t    {\n\t\tsnprintf( strbuf+len, sizeof(strbuf)-len, \"  %3d %3d %8ld %8ld %4d\",\n\t\t\tap_cur->avg_power,\n\t\t\tap_cur->rx_quality,\n\t\t\tap_cur->nb_bcn,\n\t\t\tap_cur->nb_data,\n\t\t\tap_cur->nb_dataps );\n\t    }\n\t    else\n\t    {\n\t\tsnprintf( strbuf+len, sizeof(strbuf)-len, \"  %3d %8ld %8ld %4d\",\n\t\t\tap_cur->avg_power,\n\t\t\tap_cur->nb_bcn,\n\t\t\tap_cur->nb_data,\n\t\t\tap_cur->nb_dataps );\n\t    }\n\n\t    len = strlen(strbuf);\n\n\t    snprintf( strbuf+len, sizeof(strbuf)-len, \" %3d %3d%c%c \",\n\t\t    ap_cur->channel, ap_cur->max_speed,\n\t\t    ( ap_cur->security & STD_QOS ) ? 'e' : ' ',\n\t\t    ( ap_cur->preamble ) ? '.' : ' ');\n\n\t    len = strlen(strbuf);\n\n\t    if( (ap_cur->security & (STD_OPN|STD_WEP|STD_WPA|STD_WPA2)) == 0) snprintf( strbuf+len, sizeof(strbuf)-len, \"    \" );\n\t    else if( ap_cur->security & STD_WPA2 ) snprintf( strbuf+len, sizeof(strbuf)-len, \"WPA2\" );\n\t    else if( ap_cur->security & STD_WPA  ) snprintf( strbuf+len, sizeof(strbuf)-len, \"WPA \" );\n\t    else if( ap_cur->security & STD_WEP  ) snprintf( strbuf+len, sizeof(strbuf)-len, \"WEP \" );\n\t    else if( ap_cur->security & STD_OPN  ) snprintf( strbuf+len, sizeof(strbuf)-len, \"OPN \" );\n\n\t    strncat( strbuf, \" \", sizeof(strbuf) - strlen(strbuf) - 1);\n\n\t    len = strlen(strbuf);\n\n\t    if( (ap_cur->security & (ENC_WEP|ENC_TKIP|ENC_WRAP|ENC_CCMP|ENC_WEP104|ENC_WEP40)) == 0 ) snprintf( strbuf+len, sizeof(strbuf)-len, \"       \");\n\t    else if( ap_cur->security & ENC_CCMP   ) snprintf( strbuf+len, sizeof(strbuf)-len, \"CCMP   \");\n\t    else if( ap_cur->security & ENC_WRAP   ) snprintf( strbuf+len, sizeof(strbuf)-len, \"WRAP   \");\n\t    else if( ap_cur->security & ENC_TKIP   ) snprintf( strbuf+len, sizeof(strbuf)-len, \"TKIP   \");\n\t    else if( ap_cur->security & ENC_WEP104 ) snprintf( strbuf+len, sizeof(strbuf)-len, \"WEP104 \");\n\t    else if( ap_cur->security & ENC_WEP40  ) snprintf( strbuf+len, sizeof(strbuf)-len, \"WEP40  \");\n\t    else if( ap_cur->security & ENC_WEP    ) snprintf( strbuf+len, sizeof(strbuf)-len, \"WEP    \");\n\n\t    len = strlen(strbuf);\n\n\t    if( (ap_cur->security & (AUTH_OPN|AUTH_PSK|AUTH_MGT)) == 0 ) snprintf( strbuf+len, sizeof(strbuf)-len, \"   \");\n\t    else if( ap_cur->security & AUTH_MGT   ) snprintf( strbuf+len, sizeof(strbuf)-len, \"MGT\");\n\t    else if( ap_cur->security & AUTH_PSK   )\n\t    {\n\t\tif( ap_cur->security & STD_WEP )\n\t\t    snprintf( strbuf+len, sizeof(strbuf)-len, \"SKA\");\n\t\telse\n\t\t    snprintf( strbuf+len, sizeof(strbuf)-len, \"PSK\");\n\t    }\n\t    else if( ap_cur->security & AUTH_OPN   ) snprintf( strbuf+len, sizeof(strbuf)-len, \"OPN\");\n\n\t    len = strlen(strbuf);\n\n\t    if (G.show_uptime) {\n\t    \tsnprintf(strbuf+len, sizeof(strbuf)-len, \" %14s\", parse_timestamp(ap_cur->timestamp));\n\t    \tlen = strlen(strbuf);\n\t    }\n\n\t    strbuf[ws_col-1] = '\\0';\n\n\t    if(G.selection_ap && ((num_ap) == G.selected_ap)) {\n\t\tif(G.mark_cur_ap) {\n\t\t    if(ap_cur->marked == 0) {\n\t\t\tap_cur->marked = 1;\n\t\t    }\n\t\t    else {\n\t\t\tap_cur->marked_color++;\n\t\t\tif(ap_cur->marked_color > (TEXT_MAX_COLOR-1)) {\n\t\t\t    ap_cur->marked_color = 1;\n\t\t\t    ap_cur->marked = 0;\n\t\t\t}\n\t\t    }\n\t\t    G.mark_cur_ap = 0;\n\t\t}\n\t\ttextstyle(TEXT_REVERSE);\n\t\tmemcpy(G.selected_bssid, ap_cur->bssid, 6);\n\t    }\n\n\t    if(ap_cur->marked) {\n\t\ttextcolor_fg(ap_cur->marked_color);\n\t    }\n\n\t    fprintf(stderr, \"%s\", strbuf);\n\n\t    if( ws_col > (columns_ap - 4) )\n\t    {\n\t\tmemset( strbuf, 0, sizeof( strbuf ) );\n\t\tif(ap_cur->essid[0] != 0x00)\n\t\t{\n\t\t    snprintf( strbuf,  sizeof( strbuf ) - 1,\n\t\t\t    \"%s\", ap_cur->essid );\n\t\t}\n\t\telse\n\t\t{\n\t\t    snprintf( strbuf,  sizeof( strbuf ) - 1,\n\t\t\t    \"<length:%3d>%s\", ap_cur->ssid_length, \"\\x00\" );\n\t\t}\n\n\t\tif (G.show_manufacturer) {\n\n\t\t\tif (G.maxsize_essid_seen <= strlen(strbuf))\n\t\t\t\tG.maxsize_essid_seen = strlen(strbuf);\n\t\t\telse // write spaces (32)\n\t\t\t\tmemset( strbuf+strlen(strbuf), 32,  (G.maxsize_essid_seen - strlen(strbuf))  );\n\n\t\t\tif (ap_cur->manuf == NULL)\n\t\t\t\tap_cur->manuf = get_manufacturer(ap_cur->bssid[0], ap_cur->bssid[1], ap_cur->bssid[2]);\n\n\t\t\tsnprintf( strbuf + G.maxsize_essid_seen , sizeof(strbuf)-G.maxsize_essid_seen, \"  %s\", ap_cur->manuf );\n\t\t}\n\n\t\t// write spaces (32) until the end of column\n\t\tmemset( strbuf+strlen(strbuf), 32, ws_col - (columns_ap - 4 ) );\n\n\t\t// end the string at the end of the column\n\t\tstrbuf[ws_col - (columns_ap - 4)] = '\\0';\n\n\t\tfprintf( stderr, \"  %s\", strbuf );\n\t    }\n\n\t    fprintf( stderr, \"\\n\" );\n\n\t    if( (G.selection_ap && ((num_ap) == G.selected_ap)) || (ap_cur->marked) ) {\n\t\ttextstyle(TEXT_RESET);\n\t    }\n\n\t    ap_cur = ap_cur->prev;\n\t}\n\n\t/* print some informations about each detected station */\n\n\tnlines += 3;\n\n\tif( nlines >= (ws_row-1) )\n\t    return;\n\n\tmemset( strbuf, ' ', ws_col - 1 );\n\tstrbuf[ws_col - 1] = '\\0';\n\tfprintf( stderr, \"%s\\n\", strbuf );\n    }\n\n    if(G.show_sta) {\n\tmemcpy( strbuf, \" BSSID              STATION \"\n\t\t\"           PWR   Rate    Lost    Frames  Probes\", columns_sta );\n\tstrbuf[ws_col - 1] = '\\0';\n\tfprintf( stderr, \"%s\\n\", strbuf );\n\n\tmemset( strbuf, ' ', ws_col - 1 );\n\tstrbuf[ws_col - 1] = '\\0';\n\tfprintf( stderr, \"%s\\n\", strbuf );\n\n\tap_cur = G.ap_end;\n\n\tnum_sta = 0;\n\n\twhile( ap_cur != NULL )\n\t{\n\t    if( ap_cur->nb_pkt < 2 ||\n\t\ttime( NULL ) - ap_cur->tlast > G.berlin )\n\t    {\n\t\tap_cur = ap_cur->prev;\n\t\tcontinue;\n\t    }\n\n\t    if(ap_cur->security != 0 && G.f_encrypt != 0 && ((ap_cur->security & G.f_encrypt) == 0))\n\t    {\n\t\tap_cur = ap_cur->prev;\n\t\tcontinue;\n\t    }\n\n\t    // Don't filter unassociated clients by ESSID\n\t    if(memcmp(ap_cur->bssid, BROADCAST, 6) && is_filtered_essid(ap_cur->essid))\n\t    {\n\t\tap_cur = ap_cur->prev;\n\t\tcontinue;\n\t    }\n\n\t    if( nlines >= (ws_row-1) )\n\t\treturn;\n\n\t    st_cur = G.st_end;\n\n\t    if(G.selection_ap && (memcmp(G.selected_bssid, ap_cur->bssid, 6)==0)) {\n\t\ttextstyle(TEXT_REVERSE);\n\t    }\n\n\t    if(ap_cur->marked) {\n\t\ttextcolor_fg(ap_cur->marked_color);\n\t    }\n\n\t    while( st_cur != NULL )\n\t    {\n\t\tif( st_cur->base != ap_cur ||\n\t\t    time( NULL ) - st_cur->tlast > G.berlin )\n\t\t{\n\t\t    st_cur = st_cur->prev;\n\t\t    continue;\n\t\t}\n\n\t\tif( ! memcmp( ap_cur->bssid, BROADCAST, 6 ) && G.asso_client )\n\t\t{\n\t\t    st_cur = st_cur->prev;\n\t\t    continue;\n\t\t}\n\n\t\tnum_sta++;\n\n\t\tif(G.start_print_sta > num_sta)\n\t\t    continue;\n\n\t\tnlines++;\n\n\t\tif( ws_row != 0 && nlines >= ws_row )\n\t\t    return;\n\n\t\tif( ! memcmp( ap_cur->bssid, BROADCAST, 6 ) )\n\t\t    fprintf( stderr, \" (not associated) \" );\n\t\telse\n\t\t    fprintf( stderr, \" %02X:%02X:%02X:%02X:%02X:%02X\",\n\t\t\t    ap_cur->bssid[0], ap_cur->bssid[1],\n\t\t\t    ap_cur->bssid[2], ap_cur->bssid[3],\n\t\t\t    ap_cur->bssid[4], ap_cur->bssid[5] );\n\n\t\tfprintf( stderr, \"  %02X:%02X:%02X:%02X:%02X:%02X\",\n\t\t\tst_cur->stmac[0], st_cur->stmac[1],\n\t\t\tst_cur->stmac[2], st_cur->stmac[3],\n\t\t\tst_cur->stmac[4], st_cur->stmac[5] );\n\n\t\tfprintf( stderr, \"  %3d \", st_cur->power    );\n\t\tfprintf( stderr, \"  %2d\", st_cur->rate_to/1000000  );\n\t\tfprintf( stderr,  \"%c\", (st_cur->qos_fr_ds) ? 'e' : ' ');\n\t\tfprintf( stderr,  \"-%2d\", st_cur->rate_from/1000000);\n\t\tfprintf( stderr,  \"%c\", (st_cur->qos_to_ds) ? 'e' : ' ');\n\t\tfprintf( stderr, \"  %4d\", st_cur->missed   );\n\t\tfprintf( stderr, \" %8ld\", st_cur->nb_pkt   );\n\n\t\tif( ws_col > (columns_sta - 6) )\n\t\t{\n\t\t    memset( ssid_list, 0, sizeof( ssid_list ) );\n\n\t\t    for( i = 0, n = 0; i < NB_PRB; i++ )\n\t\t    {\n\t\t\tif( st_cur->probes[i][0] == '\\0' )\n\t\t\t    continue;\n\n\t\t\tsnprintf( ssid_list + n, sizeof( ssid_list ) - n - 1,\n\t\t\t\t\"%c%s\", ( i > 0 ) ? ',' : ' ',\n\t\t\t\tst_cur->probes[i] );\n\n\t\t\tn += ( 1 + strlen( st_cur->probes[i] ) );\n\n\t\t\tif( n >= (int) sizeof( ssid_list ) )\n\t\t\t    break;\n\t\t    }\n\n\t\t    memset( strbuf, 0, sizeof( strbuf ) );\n\t\t    snprintf( strbuf,  sizeof( strbuf ) - 1,\n\t\t\t    \"%-256s\", ssid_list );\n\t\t    strbuf[ws_col - (columns_sta - 6)] = '\\0';\n\t\t    fprintf( stderr, \" %s\", strbuf );\n\t\t}\n\n\t\tfprintf( stderr, \"\\n\" );\n\n\t\tst_cur = st_cur->prev;\n\t    }\n\n\t    if( (G.selection_ap && (memcmp(G.selected_bssid, ap_cur->bssid, 6)==0)) || (ap_cur->marked) ) {\n\t\ttextstyle(TEXT_RESET);\n\t    }\n\n\t    ap_cur = ap_cur->prev;\n\t}\n    }\n\n    if(G.show_ack)\n    {\n        /* print some informations about each unknown station */\n\n        nlines += 3;\n\n        if( nlines >= (ws_row-1) )\n            return;\n\n        memset( strbuf, ' ', ws_col - 1 );\n        strbuf[ws_col - 1] = '\\0';\n        fprintf( stderr, \"%s\\n\", strbuf );\n\n        memcpy( strbuf, \" MAC       \"\n                \"          CH PWR    ACK ACK/s    CTS RTS_RX RTS_TX  OTHER\", columns_na );\n        strbuf[ws_col - 1] = '\\0';\n        fprintf( stderr, \"%s\\n\", strbuf );\n\n        memset( strbuf, ' ', ws_col - 1 );\n        strbuf[ws_col - 1] = '\\0';\n        fprintf( stderr, \"%s\\n\", strbuf );\n\n        na_cur = G.na_1st;\n\n        while( na_cur != NULL )\n        {\n            if( time( NULL ) - na_cur->tlast > 120 )\n            {\n                na_cur = na_cur->next;\n                continue;\n            }\n\n            if( nlines >= (ws_row-1) )\n                return;\n\n            nlines++;\n\n            if( ws_row != 0 && nlines >= ws_row )\n                return;\n\n            fprintf( stderr, \" %02X:%02X:%02X:%02X:%02X:%02X\",\n                    na_cur->namac[0], na_cur->namac[1],\n                    na_cur->namac[2], na_cur->namac[3],\n                    na_cur->namac[4], na_cur->namac[5] );\n\n            fprintf( stderr, \"  %3d\", na_cur->channel  );\n            fprintf( stderr, \" %3d\", na_cur->power  );\n            fprintf( stderr, \" %6d\", na_cur->ack );\n            fprintf( stderr, \"  %4d\", na_cur->ackps );\n            fprintf( stderr, \" %6d\", na_cur->cts );\n            fprintf( stderr, \" %6d\", na_cur->rts_r );\n            fprintf( stderr, \" %6d\", na_cur->rts_t );\n            fprintf( stderr, \" %6d\", na_cur->other );\n\n            fprintf( stderr, \"\\n\" );\n\n            na_cur = na_cur->next;\n        }\n    }\n}\n\nint dump_write_csv( void )\n{\n    int i, j, n;\n    struct tm *ltime;\n    char ssid_list[512];\n    struct AP_info *ap_cur;\n    struct ST_info *st_cur;\n\n    if (! G.record_data || !G.output_format_csv)\n    \treturn 0;\n\n    fseek( G.f_txt, 0, SEEK_SET );\n\n    fprintf( G.f_txt,\n        \"\\r\\nBSSID, First time seen, Last time seen, channel, Speed, \"\n        \"Privacy, Cipher, Authentication, Power, # beacons, # IV, LAN IP, ID-length, ESSID, Key\\r\\n\" );\n\n    ap_cur = G.ap_1st;\n\n    while( ap_cur != NULL )\n    {\n        if( memcmp( ap_cur->bssid, BROADCAST, 6 ) == 0 )\n        {\n            ap_cur = ap_cur->next;\n            continue;\n        }\n\n        if(ap_cur->security != 0 && G.f_encrypt != 0 && ((ap_cur->security & G.f_encrypt) == 0))\n        {\n            ap_cur = ap_cur->next;\n            continue;\n        }\n\n        if(is_filtered_essid(ap_cur->essid) || ap_cur->nb_pkt < 2)\n        {\n            ap_cur = ap_cur->next;\n            continue;\n        }\n\n        fprintf( G.f_txt, \"%02X:%02X:%02X:%02X:%02X:%02X, \",\n                 ap_cur->bssid[0], ap_cur->bssid[1],\n                 ap_cur->bssid[2], ap_cur->bssid[3],\n                 ap_cur->bssid[4], ap_cur->bssid[5] );\n\n        ltime = localtime( &ap_cur->tinit );\n\n        fprintf( G.f_txt, \"%04d-%02d-%02d %02d:%02d:%02d, \",\n                 1900 + ltime->tm_year, 1 + ltime->tm_mon,\n                 ltime->tm_mday, ltime->tm_hour,\n                 ltime->tm_min,  ltime->tm_sec );\n\n        ltime = localtime( &ap_cur->tlast );\n\n        fprintf( G.f_txt, \"%04d-%02d-%02d %02d:%02d:%02d, \",\n                 1900 + ltime->tm_year, 1 + ltime->tm_mon,\n                 ltime->tm_mday, ltime->tm_hour,\n                 ltime->tm_min,  ltime->tm_sec );\n\n        fprintf( G.f_txt, \"%2d, %3d, \",\n                 ap_cur->channel,\n                 ap_cur->max_speed );\n\n        if( (ap_cur->security & (STD_OPN|STD_WEP|STD_WPA|STD_WPA2)) == 0) fprintf( G.f_txt, \"    \" );\n        else\n        {\n            if( ap_cur->security & STD_WPA2 ) fprintf( G.f_txt, \"WPA2\" );\n            if( ap_cur->security & STD_WPA  ) fprintf( G.f_txt, \"WPA \" );\n            if( ap_cur->security & STD_WEP  ) fprintf( G.f_txt, \"WEP \" );\n            if( ap_cur->security & STD_OPN  ) fprintf( G.f_txt, \"OPN \" );\n        }\n\n        fprintf( G.f_txt, \",\");\n\n        if( (ap_cur->security & (ENC_WEP|ENC_TKIP|ENC_WRAP|ENC_CCMP|ENC_WEP104|ENC_WEP40)) == 0 ) fprintf( G.f_txt, \"       \");\n        else\n        {\n            if( ap_cur->security & ENC_CCMP   ) fprintf( G.f_txt, \" CCMP\");\n            if( ap_cur->security & ENC_WRAP   ) fprintf( G.f_txt, \" WRAP\");\n            if( ap_cur->security & ENC_TKIP   ) fprintf( G.f_txt, \" TKIP\");\n            if( ap_cur->security & ENC_WEP104 ) fprintf( G.f_txt, \" WEP104\");\n            if( ap_cur->security & ENC_WEP40  ) fprintf( G.f_txt, \" WEP40\");\n            if( ap_cur->security & ENC_WEP    ) fprintf( G.f_txt, \" WEP\");\n        }\n\n        fprintf( G.f_txt, \",\");\n\n        if( (ap_cur->security & (AUTH_OPN|AUTH_PSK|AUTH_MGT)) == 0 ) fprintf( G.f_txt, \"   \");\n        else\n        {\n            if( ap_cur->security & AUTH_MGT   ) fprintf( G.f_txt, \" MGT\");\n            if( ap_cur->security & AUTH_PSK   )\n\t\t\t{\n\t\t\t\tif( ap_cur->security & STD_WEP )\n\t\t\t\t\tfprintf( G.f_txt, \"SKA\");\n\t\t\t\telse\n\t\t\t\t\tfprintf( G.f_txt, \"PSK\");\n\t\t\t}\n            if( ap_cur->security & AUTH_OPN   ) fprintf( G.f_txt, \" OPN\");\n        }\n\n        fprintf( G.f_txt, \", %3d, %8ld, %8ld, \",\n                 ap_cur->avg_power,\n                 ap_cur->nb_bcn,\n                 ap_cur->nb_data );\n\n        fprintf( G.f_txt, \"%3d.%3d.%3d.%3d, \",\n                 ap_cur->lanip[0], ap_cur->lanip[1],\n                 ap_cur->lanip[2], ap_cur->lanip[3] );\n\n        fprintf( G.f_txt, \"%3d, \", ap_cur->ssid_length);\n\n        for(i=0; i<ap_cur->ssid_length; i++)\n        {\n            fprintf( G.f_txt, \"%c\", ap_cur->essid[i] );\n        }\n        fprintf( G.f_txt, \", \" );\n\n\n        if(ap_cur->key != NULL)\n        {\n            for(i=0; i<(int)strlen(ap_cur->key); i++)\n            {\n                fprintf( G.f_txt, \"%02X\", ap_cur->key[i]);\n                if(i<(int)(strlen(ap_cur->key)-1))\n                    fprintf( G.f_txt, \":\");\n            }\n        }\n\n        fprintf( G.f_txt, \"\\r\\n\");\n\n        ap_cur = ap_cur->next;\n    }\n\n    fprintf( G.f_txt,\n        \"\\r\\nStation MAC, First time seen, Last time seen, \"\n        \"Power, # packets, BSSID, Probed ESSIDs\\r\\n\" );\n\n    st_cur = G.st_1st;\n\n    while( st_cur != NULL )\n    {\n        ap_cur = st_cur->base;\n\n        if( ap_cur->nb_pkt < 2 )\n        {\n            st_cur = st_cur->next;\n            continue;\n        }\n\n        fprintf( G.f_txt, \"%02X:%02X:%02X:%02X:%02X:%02X, \",\n                 st_cur->stmac[0], st_cur->stmac[1],\n                 st_cur->stmac[2], st_cur->stmac[3],\n                 st_cur->stmac[4], st_cur->stmac[5] );\n\n        ltime = localtime( &st_cur->tinit );\n\n        fprintf( G.f_txt, \"%04d-%02d-%02d %02d:%02d:%02d, \",\n                 1900 + ltime->tm_year, 1 + ltime->tm_mon,\n                 ltime->tm_mday, ltime->tm_hour,\n                 ltime->tm_min,  ltime->tm_sec );\n\n        ltime = localtime( &st_cur->tlast );\n\n        fprintf( G.f_txt, \"%04d-%02d-%02d %02d:%02d:%02d, \",\n                 1900 + ltime->tm_year, 1 + ltime->tm_mon,\n                 ltime->tm_mday, ltime->tm_hour,\n                 ltime->tm_min,  ltime->tm_sec );\n\n        fprintf( G.f_txt, \"%3d, %8ld, \",\n                 st_cur->power,\n                 st_cur->nb_pkt );\n\n        if( ! memcmp( ap_cur->bssid, BROADCAST, 6 ) )\n            fprintf( G.f_txt, \"(not associated) ,\" );\n        else\n            fprintf( G.f_txt, \"%02X:%02X:%02X:%02X:%02X:%02X,\",\n                     ap_cur->bssid[0], ap_cur->bssid[1],\n                     ap_cur->bssid[2], ap_cur->bssid[3],\n                     ap_cur->bssid[4], ap_cur->bssid[5] );\n\n        memset( ssid_list, 0, sizeof( ssid_list ) );\n\n        for( i = 0, n = 0; i < NB_PRB; i++ )\n        {\n            if( st_cur->probes[i][0] == '\\0' )\n                continue;\n\n            snprintf( ssid_list + n, sizeof( ssid_list ) - n - 1,\n                      \"%c\", ( i > 0 ) ? ',' : ' ' );\n\n            for(j=0; j<st_cur->ssid_length[i]; j++)\n            {\n                snprintf( ssid_list + n + 1 + j, sizeof( ssid_list ) - n - 2 - j,\n                          \"%c\", st_cur->probes[i][j]);\n            }\n\n            n += ( 1 + st_cur->ssid_length[i] );\n            if( n >= (int) sizeof( ssid_list ) )\n                break;\n        }\n\n        fprintf( G.f_txt, \"%s\\r\\n\", ssid_list );\n\n        st_cur = st_cur->next;\n    }\n\n    fprintf( G.f_txt, \"\\r\\n\" );\n    fflush( G.f_txt );\n    return 0;\n}\n\nchar * sanitize_xml(unsigned char * text, int length)\n{\n\tint i;\n\tsize_t len;\n\tunsigned char * pos;\n\tchar * newpos;\n\tchar * newtext = NULL;\n\tif (text != NULL && length > 0) {\n\t\tlen = 6 * length;\n\t\tnewtext = (char *)calloc(1, (len + 1) * sizeof(char)); // Make sure we have enough space\n\t\tpos = text;\n\t\tfor (i = 0; i < length; ++i, ++pos) {\n\t\t\tswitch (*pos) {\n\t\t\t\tcase '&':\n\t\t\t\t\tstrncat(newtext, \"&amp;\", len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tstrncat(newtext, \"&lt;\", len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tstrncat(newtext, \"&gt;\", len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\'':\n\t\t\t\t\tstrncat(newtext, \"&apos;\", len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\"':\n\t\t\t\t\tstrncat(newtext, \"&quot;\", len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif ( isprint((int)(*pos)) || (*pos)>127 ) {\n\t\t\t\t\t\tnewtext[strlen(newtext)] = *pos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewtext[strlen(newtext)] = '\\\\';\n\t\t\t\t\t\tnewpos = newtext + strlen(newtext);\n\t\t\t\t\t\tsnprintf(newpos, strlen(newpos) + 1, \"%3u\", *pos);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnewtext = (char *) realloc(newtext, strlen(newtext) + 1);\n\t}\n\n\treturn newtext;\n}\n\n\n#define OUI_STR_SIZE 8\n#define MANUF_SIZE 128\nchar *get_manufacturer(unsigned char mac0, unsigned char mac1, unsigned char mac2) {\n\tstatic char * oui_location = NULL;\n\tchar oui[OUI_STR_SIZE + 1];\n\tchar *manuf;\n\t//char *buffer_manuf;\n\tchar * manuf_str;\n\tstruct oui *ptr;\n\tFILE *fp;\n\tchar buffer[BUFSIZ];\n\tchar temp[OUI_STR_SIZE + 1];\n\tunsigned char a[2];\n\tunsigned char b[2];\n\tunsigned char c[2];\n\tint found = 0;\n\n\tif ((manuf = (char *)calloc(1, MANUF_SIZE * sizeof(char))) == NULL) {\n\t\tperror(\"calloc failed\");\n\t\treturn NULL;\n\t}\n\n\tsnprintf(oui, sizeof(oui), \"%02X:%02X:%02X\", mac0, mac1, mac2 );\n\n\tif (G.manufList != NULL) {\n\t\t// Search in the list\n\t\tptr = G.manufList;\n\t\twhile (ptr != NULL) {\n\t\t\tfound = ! strncasecmp(ptr->id, oui, OUI_STR_SIZE);\n\t\t\tif (found) {\n\t\t\t\tmemcpy(manuf, ptr->manuf, MANUF_SIZE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr->next;\n\t\t}\n\t} else {\n\t\t// If the file exist, then query it each time we need to get a manufacturer.\n\t\tif (oui_location == NULL) {\n\t\t\tfp = fopen(OUI_PATH0, \"r\");\n\t\t\tif (fp == NULL) {\n\t\t\t\tfp = fopen(OUI_PATH1, \"r\");\n\t\t\t\tif (fp == NULL) {\n\t\t\t\t    fp = fopen(OUI_PATH2, \"r\");\n\t\t\t\t    if (fp != NULL) {\n\t\t\t\t\toui_location = OUI_PATH2;\n\t\t\t\t    }\n\t\t\t\t} else {\n\t\t\t\t    oui_location = OUI_PATH1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toui_location = OUI_PATH0;\n\t\t\t}\n\t\t} else {\n\t\t\tfp = fopen(oui_location, \"r\");\n\t\t}\n\n\t\tif (fp != NULL) {\n\n\t\t\tmemset(buffer, 0x00, sizeof(buffer));\n\t\t\twhile (fgets(buffer, sizeof(buffer), fp) != NULL) {\n\t\t\t\tif (strstr(buffer, \"(hex)\") == NULL) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmemset(a, 0x00, sizeof(a));\n\t\t\t\tmemset(b, 0x00, sizeof(b));\n\t\t\t\tmemset(c, 0x00, sizeof(c));\n\t\t\t\tif (sscanf(buffer, \"%2c-%2c-%2c\", a, b, c) == 3) {\n\t\t\t\t\tsnprintf(temp, sizeof(temp), \"%c%c:%c%c:%c%c\", a[0], a[1], b[0], b[1], c[0], c[1] );\n\t\t\t\t\tfound = !memcmp(temp, oui, strlen(oui));\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\tmanuf_str = get_manufacturer_from_string(buffer);\n\t\t\t\t\t\tif (manuf_str != NULL) {\n\t\t\t\t\t\t\tsnprintf(manuf, MANUF_SIZE, \"%s\", manuf_str);\n\t\t\t\t\t\t\tfree(manuf_str);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmemset(buffer, 0x00, sizeof(buffer));\n\t\t\t}\n\n\t\t\tfclose(fp);\n\t\t}\n\t}\n\n\t// Not found, use \"Unknown\".\n\tif (!found || *manuf == '\\0') {\n\t\tmemcpy(manuf, \"Unknown\", 7);\n\t\tmanuf[strlen(manuf)] = '\\0';\n\t}\n\n\tmanuf = (char *)realloc(manuf, (strlen(manuf) + 1) * sizeof(char));\n\n\treturn manuf;\n}\n#undef OUI_STR_SIZE\n#undef MANUF_SIZE\n\n\n#define KISMET_NETXML_HEADER_BEGIN \"<?xml version=\\\"1.0\\\" encoding=\\\"ISO-8859-1\\\"?>\\n<!DOCTYPE detection-run SYSTEM \\\"http://kismetwireless.net/kismet-3.1.0.dtd\\\">\\n\\n<detection-run kismet-version=\\\"airodump-ng-1.0\\\" start-time=\\\"\"\n#define KISMET_NETXML_HEADER_END \"\\\">\\n\\n\"\n\n#define KISMET_NETXML_TRAILER \"</detection-run>\"\n\n#define TIME_STR_LENGTH 255\nint dump_write_kismet_netxml( void )\n{\n    int network_number, average_power, client_nbr;\n    int client_max_rate, unused;\n    struct AP_info *ap_cur;\n    struct ST_info *st_cur;\n    char first_time[TIME_STR_LENGTH];\n    char last_time[TIME_STR_LENGTH];\n    char * manuf;\n    char * essid = NULL;\n\n    if (! G.record_data || !G.output_format_kismet_netxml)\n    \treturn 0;\n\n    fseek( G.f_kis_xml, 0, SEEK_SET );\n\n\t/* Header and airodump-ng start time */\n    fprintf( G.f_kis_xml, \"%s%s%s\",\n    \t\tKISMET_NETXML_HEADER_BEGIN,\n\t\t\tG.airodump_start_time,\n    \t\tKISMET_NETXML_HEADER_END );\n\n\n    ap_cur = G.ap_1st;\n\n    network_number = 0;\n    while( ap_cur != NULL )\n    {\n        if( memcmp( ap_cur->bssid, BROADCAST, 6 ) == 0 )\n        {\n            ap_cur = ap_cur->next;\n            continue;\n        }\n\n        if(ap_cur->security != 0 && G.f_encrypt != 0 && ((ap_cur->security & G.f_encrypt) == 0))\n        {\n            ap_cur = ap_cur->next;\n            continue;\n        }\n\n        if(is_filtered_essid(ap_cur->essid) || ap_cur->nb_pkt < 2 /* XXX: Maybe this last check should be removed */ )\n        {\n            ap_cur = ap_cur->next;\n            continue;\n        }\n\n\t\t++network_number; // Network Number\n\t\tstrncpy(first_time, ctime(&ap_cur->tinit), TIME_STR_LENGTH - 1);\n\t\tfirst_time[strlen(first_time) - 1] = 0; // remove new line\n\n\t\tstrncpy(last_time, ctime(&ap_cur->tlast), TIME_STR_LENGTH - 1);\n\t\tlast_time[strlen(last_time) - 1] = 0; // remove new line\n\n\t\tfprintf(G.f_kis_xml, \"\\t<wireless-network number=\\\"%d\\\" type=\\\"infrastructure\\\" \",\n\t\t\tnetwork_number);\n\t\tfprintf(G.f_kis_xml, \"first-time=\\\"%s\\\" last-time=\\\"%s\\\">\\n\", first_time, last_time);\n\n\t\tfprintf(G.f_kis_xml, \"\\t\\t<SSID first-time=\\\"%s\\\" last-time=\\\"%s\\\">\\n\",\n\t\t\t\tfirst_time, last_time);\n\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<type>Beacon</type>\\n\" );\n\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<max-rate>%d.000000</max-rate>\\n\", ap_cur->max_speed );\n\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<packets>%ld</packets>\\n\", ap_cur->nb_bcn );\n\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<beaconrate>%d</beaconrate>\\n\", 10 );\n\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<encryption>\");\n\t\t//Encryption\n\t\tif( (ap_cur->security & (STD_OPN|STD_WEP|STD_WPA|STD_WPA2)) != 0)\n\t\t{\n\t\t\tif( ap_cur->security & STD_WPA2 ) fprintf( G.f_kis_xml, \"WPA2 \" );\n\t\t\tif( ap_cur->security & STD_WPA  ) fprintf( G.f_kis_xml, \"WPA \" );\n\t\t\tif( ap_cur->security & STD_WEP  ) fprintf( G.f_kis_xml, \"WEP \" );\n\t\t\tif( ap_cur->security & STD_OPN  ) fprintf( G.f_kis_xml, \"OPN \" );\n\t\t}\n\n\t\tif( (ap_cur->security & (ENC_WEP|ENC_TKIP|ENC_WRAP|ENC_CCMP|ENC_WEP104|ENC_WEP40)) != 0 )\n\t\t{\n\t\t\tif( ap_cur->security & ENC_CCMP   ) fprintf( G.f_kis_xml, \"AES-CCM \");\n\t\t\tif( ap_cur->security & ENC_WRAP   ) fprintf( G.f_kis_xml, \"WRAP \");\n\t\t\tif( ap_cur->security & ENC_TKIP   ) fprintf( G.f_kis_xml, \"TKIP \");\n\t\t\tif( ap_cur->security & ENC_WEP104 ) fprintf( G.f_kis_xml, \"WEP104 \");\n\t\t\tif( ap_cur->security & ENC_WEP40  ) fprintf( G.f_kis_xml, \"WEP40 \");\n/*      \tif( ap_cur->security & ENC_WEP    ) fprintf( G.f_kis_xml, \"WEP \");*/\n\t\t}\n\t\tfprintf(G.f_kis_xml, \"</encryption>\\n\");\n\n\t\t/* ESSID */\n\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<essid cloaked=\\\"%s\\\">\",\n\t\t\t\t\t(ap_cur->essid[0] == 0) ? \"true\" : \"false\");\n\t\tessid = sanitize_xml(ap_cur->essid, ap_cur->ssid_length);\n\t\tif (essid != NULL) {\n\t\t\tfprintf(G.f_kis_xml, \"%s\", essid);\n\t\t\tfree(essid);\n\t\t}\n\t\tfprintf(G.f_kis_xml, \"</essid>\\n\");\n\n\t\t/* End of SSID tag */\n\t\tfprintf(G.f_kis_xml, \"\\t\\t</SSID>\\n\");\n\n\t\t/* BSSID */\n\t\tfprintf( G.f_kis_xml, \"\\t\\t<BSSID>%02X:%02X:%02X:%02X:%02X:%02X</BSSID>\\n\",\n\t\t\t\t\t ap_cur->bssid[0], ap_cur->bssid[1],\n\t\t\t\t\t ap_cur->bssid[2], ap_cur->bssid[3],\n\t\t\t\t\t ap_cur->bssid[4], ap_cur->bssid[5] );\n\n\t\t/* Manufacturer, if set using standard oui list */\n\t\tmanuf = sanitize_xml((unsigned char *)ap_cur->manuf, strlen(ap_cur->manuf));\n\t\tfprintf(G.f_kis_xml, \"\\t\\t<manuf>%s</manuf>\\n\", (manuf != NULL) ? manuf : \"Unknown\");\n\t\tfree(manuf);\n\n\t\t/* Channel\n\t\t   FIXME: Take G.freqoption in account */\n\t\tfprintf(G.f_kis_xml, \"\\t\\t<channel>%d</channel>\\n\", ap_cur->channel);\n\n\t\t/* Freq (in Mhz) and total number of packet on that frequency\n\t\t   FIXME: Take G.freqoption in account */\n\t\tfprintf(G.f_kis_xml, \"\\t\\t<freqmhz>%d %ld</freqmhz>\\n\",\n\t\t\t\t\tgetFrequencyFromChannel(ap_cur->channel),\n\t\t\t\t\t//ap_cur->nb_data + ap_cur->nb_bcn );\n\t\t\t\t\tap_cur->nb_pkt );\n\n\t\t/* XXX: What about 5.5Mbit */\n\t\tfprintf(G.f_kis_xml, \"\\t\\t<maxseenrate>%d</maxseenrate>\\n\", ap_cur->max_speed * 1000);\n\n\t\t/* Packets */\n\t\tfprintf(G.f_kis_xml, \"\\t\\t<packets>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<LLC>%ld</LLC>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<data>%ld</data>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<crypt>0</crypt>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<total>%ld</total>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<fragments>0</fragments>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<retries>0</retries>\\n\"\n\t\t\t\t\t\"\\t\\t</packets>\\n\",\n\t\t\t\t\tap_cur->nb_bcn, ap_cur->nb_data,\n\t\t\t\t\t//ap_cur->nb_data + ap_cur->nb_bcn );\n\t\t\t\t\tap_cur->nb_pkt );\n\n\n\t\t/*\n\t\t * XXX: What does that field mean? Is it the total size of data?\n\t\t *      It seems that 'd' is appended at the end for clients, why?\n\t\t */\n\t\tfprintf(G.f_kis_xml, \"\\t\\t<datasize>0</datasize>\\n\");\n\n\t\t/* Client information */\n\t\tst_cur = G.st_1st;\n\t\tclient_nbr = 0;\n\n\t\twhile ( st_cur != NULL )\n\t\t{\n\t\t\t/* If not associated or Broadcast Mac, try next one */\n\t\t\tif ( st_cur->base == NULL ||\n\t\t\t\t memcmp( st_cur->stmac, BROADCAST, 6 ) == 0  )\n\t\t\t{\n\t\t\t\tst_cur = st_cur->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Compare BSSID */\n\t\t\tif ( memcmp( st_cur->base->bssid, ap_cur->bssid, 6 ) != 0 )\n\t\t\t{\n\t\t\t\tst_cur = st_cur->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t++client_nbr;\n\n\n\t\t\tstrncpy(first_time, ctime(&st_cur->tinit), TIME_STR_LENGTH - 1);\n\t\t\tfirst_time[strlen(first_time) - 1] = 0; // remove new line\n\n\t\t\tstrncpy(last_time, ctime(&st_cur->tlast), TIME_STR_LENGTH - 1);\n\t\t\tlast_time[strlen(last_time) - 1] = 0; // remove new line\n\n\t\t\tfprintf(G.f_kis_xml, \"\\t\\t<wireless-client number=\\\"%d\\\" \"\n\t\t\t\t\t\t\t\t \"type=\\\"established\\\" first-time=\\\"%s\\\"\"\n\t\t\t\t\t\t\t\t \" last-time=\\\"%s\\\">\\n\",\n\t\t\t\t\t\t\t\t client_nbr, first_time, last_time );\n\n\t\t\tfprintf( G.f_kis_xml, \"\\t\\t\\t<client-mac>%02X:%02X:%02X:%02X:%02X:%02X</client-mac>\\n\",\n\t\t\t\t\t\t st_cur->stmac[0], st_cur->stmac[1],\n\t\t\t\t\t\t st_cur->stmac[2], st_cur->stmac[3],\n\t\t\t\t\t\t st_cur->stmac[4], st_cur->stmac[5] );\n\n\t\t\t/* Manufacturer, if set using standard oui list */\n\t\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<client-manuf>%s</client-manuf>\\n\", (st_cur->manuf != NULL) ? st_cur->manuf : \"Unknown\");\n\n\t\t\t/* Channel\n\t\t\t   FIXME: Take G.freqoption in account */\n\t\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<channel>%d</channel>\\n\", ap_cur->channel);\n\n\t\t\t/* Rate: unaccurate because it's the latest rate seen */\n\t\t\tclient_max_rate = ( st_cur->rate_from > st_cur->rate_to ) ? st_cur->rate_from : st_cur->rate_to ;\n\t\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<maxseenrate>%.6f</maxseenrate>\\n\", client_max_rate / 1000000.0 );\n\n\t\t\t/* Packets */\n\t\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<packets>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t\\t<LLC>0</LLC>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t\\t<data>0</data>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t\\t<crypt>0</crypt>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t\\t<total>%ld</total>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t\\t<fragments>0</fragments>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t\\t<retries>0</retries>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t</packets>\\n\",\n\t\t\t\t\t\tst_cur->nb_pkt );\n\n\t\t\t/* SNR information */\n\t\t\taverage_power = (st_cur->power == -1) ? 0 : st_cur->power;\n\t\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<snr-info>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<last_signal_dbm>%d</last_signal_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<last_noise_dbm>0</last_noise_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<last_signal_rssi>%d</last_signal_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<last_noise_rssi>0</last_noise_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<min_signal_dbm>%d</min_signal_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<min_noise_dbm>0</min_noise_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<min_signal_rssi>1024</min_signal_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<min_noise_rssi>1024</min_noise_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<max_signal_dbm>%d</max_signal_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<max_noise_dbm>0</max_noise_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<max_signal_rssi>%d</max_signal_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<max_noise_rssi>0</max_noise_rssi>\\n\"\n\t\t\t\t\t \"\\t\\t\\t</snr-info>\\n\",\n\t\t\t\t\t average_power, average_power, average_power,\n\t\t\t\t\t average_power, average_power );\n\n\t\t\t/* GPS Coordinates\n\t\t\t   XXX: We don't have GPS coordinates for clients */\n\t\t\tif (G.usegpsd)\n\t\t\t{\n\t\t\t\tfprintf(G.f_kis_xml, \"\\t\\t<gps-info>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<min-lat>%.6f</min-lat>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<min-lon>%.6f</min-lon>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<min-alt>%.6f</min-alt>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<min-spd>%.6f</min-spd>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<max-lat>%.6f</max-lat>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<max-lon>%.6f</max-lon>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<max-alt>%.6f</max-alt>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<max-spd>%.6f</max-spd>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<peak-lat>%.6f</peak-lat>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<peak-lon>%.6f</peak-lon>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<peak-alt>%.6f</peak-alt>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<avg-lat>%.6f</avg-lat>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<avg-lon>%.6f</avg-lon>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<avg-alt>%.6f</avg-alt>\\n\"\n\t\t\t\t\t\t\t \"\\t\\t</gps-info>\\n\",\n\t\t\t\t\t\t\t 0.0, 0.0, 0.0, 0.0,\n\t\t\t\t\t\t\t 0.0, 0.0, 0.0, 0.0,\n\t\t\t\t\t\t\t 0.0, 0.0, 0.0,\n\t\t\t\t\t\t\t 0.0, 0.0, 0.0 );\n\t\t\t}\n\n\n\t\t\t/* Trailing information */\n\t\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<cdp-device></cdp-device>\\n\"\n\t\t\t\t\t\t\t\t \"\\t\\t\\t<cdp-portid></cdp-portid>\\n\");\n\t\t\tfprintf(G.f_kis_xml, \"\\t\\t</wireless-client>\\n\" );\n\n\t\t\t/* Next client */\n\t\t\tst_cur = st_cur->next;\n\t\t}\n\n\t\t/* SNR information */\n\t\taverage_power = (ap_cur->avg_power == -1) ? 0 : ap_cur->avg_power;\n\t\tfprintf(G.f_kis_xml, \"\\t\\t<snr-info>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<last_signal_dbm>%d</last_signal_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<last_noise_dbm>0</last_noise_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<last_signal_rssi>%d</last_signal_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<last_noise_rssi>0</last_noise_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<min_signal_dbm>%d</min_signal_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<min_noise_dbm>0</min_noise_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<min_signal_rssi>1024</min_signal_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<min_noise_rssi>1024</min_noise_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<max_signal_dbm>%d</max_signal_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<max_noise_dbm>0</max_noise_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<max_signal_rssi>%d</max_signal_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<max_noise_rssi>0</max_noise_rssi>\\n\"\n\t\t\t\t\t \"\\t\\t</snr-info>\\n\",\n\t\t\t\t\t average_power, average_power, average_power,\n\t\t\t\t\t average_power, average_power );\n\n\t\t/* GPS Coordinates */\n\t\tif (G.usegpsd)\n\t\t{\n\t\t\tfprintf(G.f_kis_xml, \"\\t\\t<gps-info>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<min-lat>%.6f</min-lat>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<min-lon>%.6f</min-lon>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<min-alt>%.6f</min-alt>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<min-spd>%.6f</min-spd>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<max-lat>%.6f</max-lat>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<max-lon>%.6f</max-lon>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<max-alt>%.6f</max-alt>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<max-spd>%.6f</max-spd>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<peak-lat>%.6f</peak-lat>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<peak-lon>%.6f</peak-lon>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<peak-alt>%.6f</peak-alt>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<avg-lat>%.6f</avg-lat>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<avg-lon>%.6f</avg-lon>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<avg-alt>%.6f</avg-alt>\\n\"\n\t\t\t\t\t\t \"\\t\\t</gps-info>\\n\",\n\t\t\t\t\t\tap_cur->gps_loc_min[0],\n\t\t\t\t\t\tap_cur->gps_loc_min[1],\n\t\t\t\t\t\tap_cur->gps_loc_min[2],\n\t\t\t\t\t\tap_cur->gps_loc_min[3],\n\t\t\t\t\t\tap_cur->gps_loc_max[0],\n\t\t\t\t\t\tap_cur->gps_loc_max[1],\n\t\t\t\t\t\tap_cur->gps_loc_max[2],\n\t\t\t\t\t\tap_cur->gps_loc_max[3],\n\t\t\t\t\t\tap_cur->gps_loc_best[0],\n\t\t\t\t\t\tap_cur->gps_loc_best[1],\n\t\t\t\t\t\tap_cur->gps_loc_best[2],\n\t\t\t\t\t\t/* Can the \"best\" be considered as average??? */\n\t\t\t\t\t\tap_cur->gps_loc_best[0],\n\t\t\t\t\t\tap_cur->gps_loc_best[1],\n\t\t\t\t\t\tap_cur->gps_loc_best[2] );\n\t\t}\n\n\t\t/* Trailing information */\n\t\tfprintf(G.f_kis_xml, \"\\t\\t<bsstimestamp>0</bsstimestamp>\\n\"\n\t\t\t\t\t \"\\t\\t<cdp-device></cdp-device>\\n\"\n\t\t\t\t\t \"\\t\\t<cdp-portid></cdp-portid>\\n\");\n\n\t\t/* Closing tag for the current wireless network */\n\t\tfprintf(G.f_kis_xml, \"\\t</wireless-network>\\n\");\n\t\t//-------- End of XML\n\n        ap_cur = ap_cur->next;\n    }\n\n\t/* Trailing */\n    fprintf( G.f_kis_xml, \"%s\\n\", KISMET_NETXML_TRAILER );\n\n    fflush( G.f_kis_xml );\n\n    /* Sometimes there can be crap at the end of the file, so truncating is a good idea.\n       XXX: Is this really correct, I hope fileno() won't have any side effect */\n\tunused = ftruncate(fileno(G.f_kis_xml), ftell( G.f_kis_xml ) );\n\n    return 0;\n}\n#undef TIME_STR_LENGTH\n\n#define KISMET_HEADER \"Network;NetType;ESSID;BSSID;Info;Channel;Cloaked;Encryption;Decrypted;MaxRate;MaxSeenRate;Beacon;LLC;Data;Crypt;Weak;Total;Carrier;Encoding;FirstTime;LastTime;BestQuality;BestSignal;BestNoise;GPSMinLat;GPSMinLon;GPSMinAlt;GPSMinSpd;GPSMaxLat;GPSMaxLon;GPSMaxAlt;GPSMaxSpd;GPSBestLat;GPSBestLon;GPSBestAlt;DataSize;IPType;IP;\\n\"\n\n\nint dump_write_kismet_csv( void )\n{\n    int i, k;\n//     struct tm *ltime;\n/*    char ssid_list[512];*/\n    struct AP_info *ap_cur;\n\n    if (! G.record_data || !G.output_format_kismet_csv)\n    \treturn 0;\n\n    fseek( G.f_kis, 0, SEEK_SET );\n\n    fprintf( G.f_kis, KISMET_HEADER );\n\n    ap_cur = G.ap_1st;\n\n    k=1;\n    while( ap_cur != NULL )\n    {\n        if( memcmp( ap_cur->bssid, BROADCAST, 6 ) == 0 )\n        {\n            ap_cur = ap_cur->next;\n            continue;\n        }\n\n        if(ap_cur->security != 0 && G.f_encrypt != 0 && ((ap_cur->security & G.f_encrypt) == 0))\n        {\n            ap_cur = ap_cur->next;\n            continue;\n        }\n\n        if(is_filtered_essid(ap_cur->essid) || ap_cur->nb_pkt < 2)\n        {\n            ap_cur = ap_cur->next;\n            continue;\n        }\n\n        //Network\n        fprintf( G.f_kis, \"%d;\", k );\n\n        //NetType\n        fprintf( G.f_kis, \"infrastructure;\");\n\n        //ESSID\n        for(i=0; i<ap_cur->ssid_length; i++)\n        {\n            fprintf( G.f_kis, \"%c\", ap_cur->essid[i] );\n        }\n        fprintf( G.f_kis, \";\" );\n\n        //BSSID\n        fprintf( G.f_kis, \"%02X:%02X:%02X:%02X:%02X:%02X;\",\n                 ap_cur->bssid[0], ap_cur->bssid[1],\n                 ap_cur->bssid[2], ap_cur->bssid[3],\n                 ap_cur->bssid[4], ap_cur->bssid[5] );\n\n        //Info\n        fprintf( G.f_kis, \";\");\n\n        //Channel\n        fprintf( G.f_kis, \"%d;\", ap_cur->channel);\n\n        //Cloaked\n        fprintf( G.f_kis, \"No;\");\n\n        //Encryption\n        if( (ap_cur->security & (STD_OPN|STD_WEP|STD_WPA|STD_WPA2)) != 0)\n        {\n            if( ap_cur->security & STD_WPA2 ) fprintf( G.f_kis, \"WPA2,\" );\n            if( ap_cur->security & STD_WPA  ) fprintf( G.f_kis, \"WPA,\" );\n            if( ap_cur->security & STD_WEP  ) fprintf( G.f_kis, \"WEP,\" );\n            if( ap_cur->security & STD_OPN  ) fprintf( G.f_kis, \"OPN,\" );\n        }\n\n        if( (ap_cur->security & (ENC_WEP|ENC_TKIP|ENC_WRAP|ENC_CCMP|ENC_WEP104|ENC_WEP40)) == 0 ) fprintf( G.f_kis, \"None,\");\n        else\n        {\n            if( ap_cur->security & ENC_CCMP   ) fprintf( G.f_kis, \"AES-CCM,\");\n            if( ap_cur->security & ENC_WRAP   ) fprintf( G.f_kis, \"WRAP,\");\n            if( ap_cur->security & ENC_TKIP   ) fprintf( G.f_kis, \"TKIP,\");\n            if( ap_cur->security & ENC_WEP104 ) fprintf( G.f_kis, \"WEP104,\");\n            if( ap_cur->security & ENC_WEP40  ) fprintf( G.f_kis, \"WEP40,\");\n/*            if( ap_cur->security & ENC_WEP    ) fprintf( G.f_kis, \" WEP,\");*/\n        }\n\n        fseek(G.f_kis, -1, SEEK_CUR);\n        fprintf(G.f_kis, \";\");\n\n        //Decrypted\n        fprintf( G.f_kis, \"No;\");\n\n        //MaxRate\n        fprintf( G.f_kis, \"%d.0;\", ap_cur->max_speed );\n\n        //MaxSeenRate\n        fprintf( G.f_kis, \"0;\");\n\n        //Beacon\n        fprintf( G.f_kis, \"%ld;\", ap_cur->nb_bcn);\n\n        //LLC\n        fprintf( G.f_kis, \"0;\");\n\n        //Data\n        fprintf( G.f_kis, \"%ld;\", ap_cur->nb_data );\n\n        //Crypt\n        fprintf( G.f_kis, \"0;\");\n\n        //Weak\n        fprintf( G.f_kis, \"0;\");\n\n        //Total\n        fprintf( G.f_kis, \"%ld;\", ap_cur->nb_data );\n\n        //Carrier\n        fprintf( G.f_kis, \";\");\n\n        //Encoding\n        fprintf( G.f_kis, \";\");\n\n        //FirstTime\n        fprintf( G.f_kis, \"%s\", ctime(&ap_cur->tinit) );\n        fseek(G.f_kis, -1, SEEK_CUR);\n        fprintf( G.f_kis, \";\");\n\n        //LastTime\n        fprintf( G.f_kis, \"%s\", ctime(&ap_cur->tlast) );\n        fseek(G.f_kis, -1, SEEK_CUR);\n        fprintf( G.f_kis, \";\");\n\n        //BestQuality\n        fprintf( G.f_kis, \"%d;\", ap_cur->avg_power );\n\n        //BestSignal\n        fprintf( G.f_kis, \"0;\" );\n\n        //BestNoise\n        fprintf( G.f_kis, \"0;\" );\n\n        //GPSMinLat\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_min[0]);\n\n        //GPSMinLon\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_min[1]);\n\n        //GPSMinAlt\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_min[2]);\n\n        //GPSMinSpd\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_min[3]);\n\n        //GPSMaxLat\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_max[0]);\n\n        //GPSMaxLon\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_max[1]);\n\n        //GPSMaxAlt\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_max[2]);\n\n        //GPSMaxSpd\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_max[3]);\n\n        //GPSBestLat\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_best[0]);\n\n        //GPSBestLon\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_best[1]);\n\n        //GPSBestAlt\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_best[2]);\n\n        //DataSize\n        fprintf( G.f_kis, \"0;\" );\n\n        //IPType\n        fprintf( G.f_kis, \"0;\" );\n\n        //IP\n        fprintf( G.f_kis, \"%d.%d.%d.%d;\",\n                 ap_cur->lanip[0], ap_cur->lanip[1],\n                 ap_cur->lanip[2], ap_cur->lanip[3] );\n\n        fprintf( G.f_kis, \"\\r\\n\");\n\n        ap_cur = ap_cur->next;\n        k++;\n    }\n\n    fflush( G.f_kis );\n    return 0;\n}\n\nvoid gps_tracker( void )\n{\n\tssize_t unused;\n    int gpsd_sock;\n    char line[256], *temp;\n    struct sockaddr_in gpsd_addr;\n    int ret, is_json, pos;\n    fd_set read_fd;\n    struct timeval timeout;\n\n    /* attempt to connect to localhost, port 2947 */\n\n    pos = 0;\n    gpsd_sock = socket( AF_INET, SOCK_STREAM, 0 );\n\n    if( gpsd_sock < 0 ) {\n        return;\n    }\n\n    gpsd_addr.sin_family      = AF_INET;\n    gpsd_addr.sin_port        = htons( 2947 );\n    gpsd_addr.sin_addr.s_addr = inet_addr( \"127.0.0.1\" );\n\n    if( connect( gpsd_sock, (struct sockaddr *) &gpsd_addr,\n                 sizeof( gpsd_addr ) ) < 0 ) {\n        return;\n    }\n\n    // Check if it's GPSd < 2.92 or the new one\n    // 2.92+ immediately send stuff\n    // < 2.92 requires to send PVTAD command\n    FD_ZERO(&read_fd);\n    FD_SET(gpsd_sock, &read_fd);\n    timeout.tv_sec = 1;\n    timeout.tv_usec = 0;\n    is_json = select(gpsd_sock + 1, &read_fd, NULL, NULL, &timeout);\n    if (is_json) {\n    \t/*\n\t\t\t{\"class\":\"VERSION\",\"release\":\"2.95\",\"rev\":\"2010-11-16T21:12:35\",\"proto_major\":3,\"proto_minor\":3}\n\t\t\t?WATCH={\"json\":true};\n\t\t\t{\"class\":\"DEVICES\",\"devices\":[]}\n    \t */\n\n\n    \t// Get the crap and ignore it: {\"class\":\"VERSION\",\"release\":\"2.95\",\"rev\":\"2010-11-16T21:12:35\",\"proto_major\":3,\"proto_minor\":3}\n    \tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n    \t\treturn;\n\n    \tis_json = (line[0] == '{');\n    \tif (is_json) {\n\t\t\t// Send ?WATCH={\"json\":true};\n\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\tstrcpy(line, \"?WATCH={\\\"json\\\":true};\\n\");\n\t\t\tif( send( gpsd_sock, line, 22, 0 ) != 22 )\n\t\t\t\treturn;\n\n\t\t\t// Check that we have devices\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t\tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n\t\t\t\treturn;\n\n\t\t\t// Stop processing if there is no device\n\t\t\tif (strncmp(line, \"{\\\"class\\\":\\\"DEVICES\\\",\\\"devices\\\":[]}\", 32) == 0) {\n\t\t\t\tclose(gpsd_sock);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpos = strlen(line);\n\t\t\t}\n    \t}\n    }\n\n    /* loop reading the GPS coordinates */\n\n    while( G.do_exit == 0 )\n    {\n        usleep( 500000 );\n        memset( G.gps_loc, 0, sizeof( float ) * 5 );\n\n        /* read position, speed, heading, altitude */\n        if (is_json) {\n        \t// Format definition: http://catb.org/gpsd/gpsd_json.html\n\n        \tif (pos == sizeof( line )) {\n        \t\tmemset(line, 0, sizeof(line));\n        \t\tpos = 0;\n        \t}\n\n        \t// New version, JSON\n        \tif( recv( gpsd_sock, line + pos, sizeof( line ) - 1, 0 ) <= 0 )\n        \t\treturn;\n\n        \t// search for TPV class: {\"class\":\"TPV\"\n        \ttemp = strstr(line, \"{\\\"class\\\":\\\"TPV\\\"\");\n        \tif (temp == NULL) {\n        \t\tcontinue;\n        \t}\n\n        \t// Make sure the data we have is complete\n        \tif (strchr(temp, '}') == NULL) {\n        \t\t// Move the data at the beginning of the buffer;\n        \t\tpos = strlen(temp);\n        \t\tif (temp != line) {\n        \t\t\tmemmove(line, temp, pos);\n        \t\t\tmemset(line + pos, 0, sizeof(line) - pos);\n        \t\t}\n        \t}\n\n\t\t\t// Example line: {\"class\":\"TPV\",\"tag\":\"MID2\",\"device\":\"/dev/ttyUSB0\",\"time\":1350957517.000,\"ept\":0.005,\"lat\":46.878936576,\"lon\":-115.832602964,\"alt\":1968.382,\"track\":0.0000,\"speed\":0.000,\"climb\":0.000,\"mode\":3}\n\n        \t// Latitude\n        \ttemp = strstr(temp, \"\\\"lat\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[0]);\n\n\t\t\t// Longitude\n\t\t\ttemp = strstr(temp, \"\\\"lon\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[1]);\n\n\t\t\t// Altitude\n\t\t\ttemp = strstr(temp, \"\\\"alt\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[4]);\n\n\t\t\t// Speed\n\t\t\ttemp = strstr(temp, \"\\\"speed\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[2]);\n\n\t\t\t// No more heading\n\n\t\t\t// Get the next TPV class\n\t\t\ttemp = strstr(temp, \"{\\\"class\\\":\\\"TPV\\\"\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\t\tpos = 0;\n\t\t\t} else {\n\t\t\t\tpos = strlen(temp);\n\t\t\t\tmemmove(line, temp, pos);\n\t\t\t\tmemset(line + pos, 0, sizeof(line) - pos);\n\t\t\t}\n\n        } else {\n        \tmemset( line, 0, sizeof( line ) );\n\n\t\t\tsnprintf( line,  sizeof( line ) - 1, \"PVTAD\\r\\n\" );\n\t\t\tif( send( gpsd_sock, line, 7, 0 ) != 7 )\n\t\t\t\treturn;\n\n\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n\t\t\t\treturn;\n\n\t\t\tif( memcmp( line, \"GPSD,P=\", 7 ) != 0 )\n\t\t\t\tcontinue;\n\n\t\t\t/* make sure the coordinates are present */\n\n\t\t\tif( line[7] == '?' )\n\t\t\t\tcontinue;\n\n\t\t\tret = sscanf( line + 7, \"%f %f\", &G.gps_loc[0], &G.gps_loc[1] );\n\n\t\t\tif( ( temp = strstr( line, \"V=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[2] ); /* speed */\n\n\t\t\tif( ( temp = strstr( line, \"T=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[3] ); /* heading */\n\n\t\t\tif( ( temp = strstr( line, \"A=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[4] ); /* altitude */\n        }\n\n        if (G.record_data)\n\t\t\tfputs( line, G.f_gps );\n\n\t\tG.save_gps = 1;\n\n        if (G.do_exit == 0)\n\t\t{\n\t\t\tunused = write( G.gc_pipe[1], G.gps_loc, sizeof( float ) * 5 );\n\t\t\tkill( getppid(), SIGUSR2 );\n\t\t}\n    }\n}\n\nvoid sighandler( int signum)\n{\n\tssize_t unused;\n    int card=0;\n\n    signal( signum, sighandler );\n\n    if( signum == SIGUSR1 )\n    {\n\t\tunused = read( G.cd_pipe[0], &card, sizeof(int) );\n        if(G.freqoption)\n            unused = read( G.ch_pipe[0], &(G.frequency[card]), sizeof( int ) );\n        else\n            unused = read( G.ch_pipe[0], &(G.channel[card]), sizeof( int ) );\n    }\n\n    if( signum == SIGUSR2 )\n        unused = read( G.gc_pipe[0], &G.gps_loc, sizeof( float ) * 5 );\n\n    if( signum == SIGINT || signum == SIGTERM )\n    {\n\treset_term();\n        alarm( 1 );\n        G.do_exit = 1;\n        signal( SIGALRM, sighandler );\n        dprintf( STDOUT_FILENO, \"\\n\" );\n    }\n\n    if( signum == SIGSEGV )\n    {\n        fprintf( stderr, \"Caught signal 11 (SIGSEGV). Please\"\n                         \" contact the author!\\33[?25h\\n\\n\" );\n        fflush( stdout );\n        exit( 1 );\n    }\n\n    if( signum == SIGALRM )\n    {\n        dprintf( STDERR_FILENO, \"Caught signal 14 (SIGALRM). Please\"\n                         \" contact the author!\\33[?25h\\n\\n\" );\n        _exit( 1 );\n    }\n\n    if( signum == SIGCHLD )\n        wait( NULL );\n\n    if( signum == SIGWINCH )\n    {\n        fprintf( stderr, \"\\33[2J\" );\n        fflush( stdout );\n    }\n}\n\nint send_probe_request(struct wif *wi)\n{\n    int len;\n    unsigned char p[4096], r_smac[6];\n\n    memcpy(p, PROBE_REQ, 24);\n\n    len = 24;\n\n    p[24] = 0x00;      //ESSID Tag Number\n    p[25] = 0x00;      //ESSID Tag Length\n\n    len += 2;\n\n    memcpy(p+len, RATES, 16);\n\n    len += 16;\n\n    r_smac[0] = 0x00;\n    r_smac[1] = rand() & 0xFF;\n    r_smac[2] = rand() & 0xFF;\n    r_smac[3] = rand() & 0xFF;\n    r_smac[4] = rand() & 0xFF;\n    r_smac[5] = rand() & 0xFF;\n\n    memcpy(p+10, r_smac, 6);\n\n    if (wi_write(wi, p, len, NULL) == -1) {\n        switch (errno) {\n        case EAGAIN:\n        case ENOBUFS:\n            usleep(10000);\n            return 0; /* XXX not sure I like this... -sorbo */\n        }\n\n        perror(\"wi_write()\");\n        return -1;\n    }\n\n    return 0;\n}\n\nint send_probe_requests(struct wif *wi[], int cards)\n{\n    int i=0;\n    for(i=0; i<cards; i++)\n    {\n        send_probe_request(wi[i]);\n    }\n    return 0;\n}\n\nint getchancount(int valid)\n{\n    int i=0, chan_count=0;\n\n    while(G.channels[i])\n    {\n        i++;\n        if(G.channels[i] != -1)\n            chan_count++;\n    }\n\n    if(valid) return chan_count;\n    return i;\n}\n\nint getfreqcount(int valid)\n{\n    int i=0, freq_count=0;\n\n    while(G.own_frequencies[i])\n    {\n        i++;\n        if(G.own_frequencies[i] != -1)\n            freq_count++;\n    }\n\n    if(valid) return freq_count;\n    return i;\n}\n\nvoid channel_hopper(struct wif *wi[], int if_num, int chan_count )\n{\n\tssize_t unused;\n    int ch, ch_idx = 0, card=0, chi=0, cai=0, j=0, k=0, first=1, again=1;\n    int dropped=0;\n\n    while( getppid() != 1 )\n    {\n        for( j = 0; j < if_num; j++ )\n        {\n            again = 1;\n\n            ch_idx = chi % chan_count;\n\n            card = cai % if_num;\n\n            ++chi;\n            ++cai;\n\n            if( G.chswitch == 2 && !first )\n            {\n                j = if_num - 1;\n                card = if_num - 1;\n\n                if( getchancount(1) > if_num )\n                {\n                    while( again )\n                    {\n                        again = 0;\n                        for( k = 0; k < ( if_num - 1 ); k++ )\n                        {\n                            if( G.channels[ch_idx] == G.channel[k] )\n                            {\n                                again = 1;\n                                ch_idx = chi % chan_count;\n                                chi++;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if( G.channels[ch_idx] == -1 )\n            {\n                j--;\n                cai--;\n                dropped++;\n                if(dropped >= chan_count)\n                {\n                    ch = wi_get_channel(wi[card]);\n                    G.channel[card] = ch;\n                    unused = write( G.cd_pipe[1], &card, sizeof(int) );\n                    unused = write( G.ch_pipe[1], &ch, sizeof( int ) );\n                    kill( getppid(), SIGUSR1 );\n                    usleep(1000);\n                }\n                continue;\n            }\n\n            dropped = 0;\n\n            ch = G.channels[ch_idx];\n\n            if(wi_set_channel(wi[card], ch ) == 0 )\n            {\n                G.channel[card] = ch;\n                unused = write( G.cd_pipe[1], &card, sizeof(int) );\n                unused = write( G.ch_pipe[1], &ch, sizeof( int ) );\n                if(G.active_scan_sim > 0)\n                    send_probe_request(wi[card]);\n                kill( getppid(), SIGUSR1 );\n                usleep(1000);\n            }\n            else\n            {\n                G.channels[ch_idx] = -1;      /* remove invalid channel */\n                j--;\n                cai--;\n                continue;\n            }\n        }\n\n        if(G.chswitch == 0)\n        {\n            chi=chi-(if_num - 1);\n        }\n\n        if(first)\n        {\n            first = 0;\n        }\n\n        usleep( (G.hopfreq*1000) );\n    }\n\n    exit( 0 );\n}\n\nvoid frequency_hopper(struct wif *wi[], int if_num, int chan_count )\n{\n\tssize_t unused;\n    int ch, ch_idx = 0, card=0, chi=0, cai=0, j=0, k=0, first=1, again=1;\n    int dropped=0;\n\n    while( getppid() != 1 )\n    {\n        for( j = 0; j < if_num; j++ )\n        {\n            again = 1;\n\n            ch_idx = chi % chan_count;\n\n            card = cai % if_num;\n\n            ++chi;\n            ++cai;\n\n            if( G.chswitch == 2 && !first )\n            {\n                j = if_num - 1;\n                card = if_num - 1;\n\n                if( getfreqcount(1) > if_num )\n                {\n                    while( again )\n                    {\n                        again = 0;\n                        for( k = 0; k < ( if_num - 1 ); k++ )\n                        {\n                            if( G.own_frequencies[ch_idx] == G.frequency[k] )\n                            {\n                                again = 1;\n                                ch_idx = chi % chan_count;\n                                chi++;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if( G.own_frequencies[ch_idx] == -1 )\n            {\n                j--;\n                cai--;\n                dropped++;\n                if(dropped >= chan_count)\n                {\n                    ch = wi_get_freq(wi[card]);\n                    G.frequency[card] = ch;\n                    unused = write( G.cd_pipe[1], &card, sizeof(int) );\n                    unused = write( G.ch_pipe[1], &ch, sizeof( int ) );\n                    kill( getppid(), SIGUSR1 );\n                    usleep(1000);\n                }\n                continue;\n            }\n\n            dropped = 0;\n\n            ch = G.own_frequencies[ch_idx];\n\n            if(wi_set_freq(wi[card], ch ) == 0 )\n            {\n                G.frequency[card] = ch;\n                unused = write( G.cd_pipe[1], &card, sizeof(int) );\n                unused = write( G.ch_pipe[1], &ch, sizeof( int ) );\n                kill( getppid(), SIGUSR1 );\n                usleep(1000);\n            }\n            else\n            {\n                G.own_frequencies[ch_idx] = -1;      /* remove invalid channel */\n                j--;\n                cai--;\n                continue;\n            }\n        }\n\n        if(G.chswitch == 0)\n        {\n            chi=chi-(if_num - 1);\n        }\n\n        if(first)\n        {\n            first = 0;\n        }\n\n        usleep( (G.hopfreq*1000) );\n    }\n\n    exit( 0 );\n}\n\nint invalid_channel(int chan)\n{\n    int i=0;\n\n    do\n    {\n        if (chan == abg_chans[i] && chan != 0 )\n            return 0;\n    } while (abg_chans[++i]);\n    return 1;\n}\n\nint invalid_frequency(int freq)\n{\n    int i=0;\n\n    do\n    {\n        if (freq == frequencies[i] && freq != 0 )\n            return 0;\n    } while (frequencies[++i]);\n    return 1;\n}\n\n/* parse a string, for example \"1,2,3-7,11\" */\n\nint getchannels(const char *optarg)\n{\n    unsigned int i=0,chan_cur=0,chan_first=0,chan_last=0,chan_max=128,chan_remain=0;\n    char *optchan = NULL, *optc;\n    char *token = NULL;\n    int *tmp_channels;\n\n    //got a NULL pointer?\n    if(optarg == NULL)\n        return -1;\n\n    chan_remain=chan_max;\n\n    //create a writable string\n    optc = optchan = (char*) malloc(strlen(optarg)+1);\n    strncpy(optchan, optarg, strlen(optarg));\n    optchan[strlen(optarg)]='\\0';\n\n    tmp_channels = (int*) malloc(sizeof(int)*(chan_max+1));\n\n    //split string in tokens, separated by ','\n    while( (token = strsep(&optchan,\",\")) != NULL)\n    {\n        //range defined?\n        if(strchr(token, '-') != NULL)\n        {\n            //only 1 '-' ?\n            if(strchr(token, '-') == strrchr(token, '-'))\n            {\n                //are there any illegal characters?\n                for(i=0; i<strlen(token); i++)\n                {\n                    if( (token[i] < '0') && (token[i] > '9') && (token[i] != '-'))\n                    {\n                        free(tmp_channels);\n                        free(optc);\n                        return -1;\n                    }\n                }\n\n                if( sscanf(token, \"%d-%d\", &chan_first, &chan_last) != EOF )\n                {\n                    if(chan_first > chan_last)\n                    {\n                        free(tmp_channels);\n                        free(optc);\n                        return -1;\n                    }\n                    for(i=chan_first; i<=chan_last; i++)\n                    {\n                        if( (! invalid_channel(i)) && (chan_remain > 0) )\n                        {\n                                tmp_channels[chan_max-chan_remain]=i;\n                                chan_remain--;\n                        }\n                    }\n                }\n                else\n                {\n                    free(tmp_channels);\n                    free(optc);\n                    return -1;\n                }\n\n            }\n            else\n            {\n                free(tmp_channels);\n                free(optc);\n                return -1;\n            }\n        }\n        else\n        {\n            //are there any illegal characters?\n            for(i=0; i<strlen(token); i++)\n            {\n                if( (token[i] < '0') && (token[i] > '9') )\n                {\n                    free(tmp_channels);\n                    free(optc);\n                    return -1;\n                }\n            }\n\n            if( sscanf(token, \"%d\", &chan_cur) != EOF)\n            {\n                if( (! invalid_channel(chan_cur)) && (chan_remain > 0) )\n                {\n                        tmp_channels[chan_max-chan_remain]=chan_cur;\n                        chan_remain--;\n                }\n\n            }\n            else\n            {\n                free(tmp_channels);\n                free(optc);\n                return -1;\n            }\n        }\n    }\n\n    G.own_channels = (int*) malloc(sizeof(int)*(chan_max - chan_remain + 1));\n\n    for(i=0; i<(chan_max - chan_remain); i++)\n    {\n        G.own_channels[i]=tmp_channels[i];\n    }\n\n    G.own_channels[i]=0;\n\n    free(tmp_channels);\n    free(optc);\n    if(i==1) return G.own_channels[0];\n    if(i==0) return -1;\n    return 0;\n}\n\n/* parse a string, for example \"1,2,3-7,11\" */\n\nint getfrequencies(const char *optarg)\n{\n    unsigned int i=0,freq_cur=0,freq_first=0,freq_last=0,freq_max=10000,freq_remain=0;\n    char *optfreq = NULL, *optc;\n    char *token = NULL;\n    int *tmp_frequencies;\n\n    //got a NULL pointer?\n    if(optarg == NULL)\n        return -1;\n\n    freq_remain=freq_max;\n\n    //create a writable string\n    optc = optfreq = (char*) malloc(strlen(optarg)+1);\n    strncpy(optfreq, optarg, strlen(optarg));\n    optfreq[strlen(optarg)]='\\0';\n\n    tmp_frequencies = (int*) malloc(sizeof(int)*(freq_max+1));\n\n    //split string in tokens, separated by ','\n    while( (token = strsep(&optfreq,\",\")) != NULL)\n    {\n        //range defined?\n        if(strchr(token, '-') != NULL)\n        {\n            //only 1 '-' ?\n            if(strchr(token, '-') == strrchr(token, '-'))\n            {\n                //are there any illegal characters?\n                for(i=0; i<strlen(token); i++)\n                {\n                    if( (token[i] < '0' || token[i] > '9') && (token[i] != '-'))\n                    {\n                        free(tmp_frequencies);\n                        free(optc);\n                        return -1;\n                    }\n                }\n\n                if( sscanf(token, \"%d-%d\", &freq_first, &freq_last) != EOF )\n                {\n                    if(freq_first > freq_last)\n                    {\n                        free(tmp_frequencies);\n                        free(optc);\n                        return -1;\n                    }\n                    for(i=freq_first; i<=freq_last; i++)\n                    {\n                        if( (! invalid_frequency(i)) && (freq_remain > 0) )\n                        {\n                                tmp_frequencies[freq_max-freq_remain]=i;\n                                freq_remain--;\n                        }\n                    }\n                }\n                else\n                {\n                    free(tmp_frequencies);\n                    free(optc);\n                    return -1;\n                }\n\n            }\n            else\n            {\n                free(tmp_frequencies);\n                free(optc);\n                return -1;\n            }\n        }\n        else\n        {\n            //are there any illegal characters?\n            for(i=0; i<strlen(token); i++)\n            {\n                if( (token[i] < '0') && (token[i] > '9') )\n                {\n                    free(tmp_frequencies);\n                    free(optc);\n                    return -1;\n                }\n            }\n\n            if( sscanf(token, \"%d\", &freq_cur) != EOF)\n            {\n                if( (! invalid_frequency(freq_cur)) && (freq_remain > 0) )\n                {\n                        tmp_frequencies[freq_max-freq_remain]=freq_cur;\n                        freq_remain--;\n                }\n\n                /* special case \"-C 0\" means: scan all available frequencies */\n                if(freq_cur == 0)\n                {\n                    freq_first = 1;\n                    freq_last = 9999;\n                    for(i=freq_first; i<=freq_last; i++)\n                    {\n                        if( (! invalid_frequency(i)) && (freq_remain > 0) )\n                        {\n                                tmp_frequencies[freq_max-freq_remain]=i;\n                                freq_remain--;\n                        }\n                    }\n                }\n\n            }\n            else\n            {\n                free(tmp_frequencies);\n                free(optc);\n                return -1;\n            }\n        }\n    }\n\n    G.own_frequencies = (int*) malloc(sizeof(int)*(freq_max - freq_remain + 1));\n\n    for(i=0; i<(freq_max - freq_remain); i++)\n    {\n        G.own_frequencies[i]=tmp_frequencies[i];\n    }\n\n    G.own_frequencies[i]=0;\n\n    free(tmp_frequencies);\n    free(optc);\n    if(i==1) return G.own_frequencies[0];   //exactly 1 frequency given\n    if(i==0) return -1;                     //error occured\n    return 0;                               //frequency hopping\n}\n\nint setup_card(char *iface, struct wif **wis)\n{\n\tstruct wif *wi;\n\n\twi = wi_open(iface);\n\tif (!wi)\n\t\treturn -1;\n\t*wis = wi;\n\n\treturn 0;\n}\n\nint init_cards(const char* cardstr, char *iface[], struct wif **wi)\n{\n    char *buffer;\n    char *buf;\n    int if_count=0;\n    int i=0, again=0;\n\n    buf = buffer = (char*) malloc( sizeof(char) * 1025 );\n    strncpy( buffer, cardstr, 1025 );\n    buffer[1024] = '\\0';\n\n    while( ((iface[if_count]=strsep(&buffer, \",\")) != NULL) && (if_count < MAX_CARDS) )\n    {\n        again=0;\n        for(i=0; i<if_count; i++)\n        {\n            if(strcmp(iface[i], iface[if_count]) == 0)\n            again=1;\n        }\n        if(again) continue;\n        if(setup_card(iface[if_count], &(wi[if_count])) != 0)\n        {\n            free(buf);\n            return -1;\n        }\n        if_count++;\n    }\n\n    free(buf);\n    return if_count;\n}\n\n#if 0\nint get_if_num(const char* cardstr)\n{\n    char *buffer;\n    int if_count=0;\n\n    buffer = (char*) malloc(sizeof(char)*1025);\n    if (buffer == NULL) {\n\t\treturn -1;\n\t}\n\n    strncpy(buffer, cardstr, 1025);\n    buffer[1024] = '\\0';\n\n    while( (strsep(&buffer, \",\") != NULL) && (if_count < MAX_CARDS) )\n    {\n        if_count++;\n    }\n\n    free(buffer)\n\n    return if_count;\n}\n#endif\n\nint set_encryption_filter(const char* input)\n{\n    if(input == NULL) return 1;\n\n    if(strlen(input) < 3) return 1;\n\n    if(strcasecmp(input, \"opn\") == 0)\n        G.f_encrypt |= STD_OPN;\n\n    if(strcasecmp(input, \"wep\") == 0)\n        G.f_encrypt |= STD_WEP;\n\n    if(strcasecmp(input, \"wpa\") == 0)\n    {\n        G.f_encrypt |= STD_WPA;\n        G.f_encrypt |= STD_WPA2;\n    }\n\n    if(strcasecmp(input, \"wpa1\") == 0)\n        G.f_encrypt |= STD_WPA;\n\n    if(strcasecmp(input, \"wpa2\") == 0)\n        G.f_encrypt |= STD_WPA2;\n\n    return 0;\n}\n\nint check_monitor(struct wif *wi[], int *fd_raw, int *fdh, int cards)\n{\n    int i, monitor;\n    char ifname[64];\n\n    for(i=0; i<cards; i++)\n    {\n        monitor = wi_get_monitor(wi[i]);\n        if(monitor != 0)\n        {\n            memset(G.message, '\\x00', sizeof(G.message));\n            snprintf(G.message, sizeof(G.message), \"][ %s reset to monitor mode\", wi_get_ifname(wi[i]));\n            //reopen in monitor mode\n\n            strncpy(ifname, wi_get_ifname(wi[i]), sizeof(ifname)-1);\n            ifname[sizeof(ifname)-1] = 0;\n\n            wi_close(wi[i]);\n            wi[i] = wi_open(ifname);\n            if (!wi[i]) {\n                printf(\"Can't reopen %s\\n\", ifname);\n                exit(1);\n            }\n\n            fd_raw[i] = wi_fd(wi[i]);\n            if (fd_raw[i] > *fdh)\n                *fdh = fd_raw[i];\n        }\n    }\n    return 0;\n}\n\nint check_channel(struct wif *wi[], int cards)\n{\n    int i, chan;\n    for(i=0; i<cards; i++)\n    {\n        chan = wi_get_channel(wi[i]);\n        if(G.ignore_negative_one == 1 && chan==-1) return 0;\n        if(G.channel[i] != chan)\n        {\n            memset(G.message, '\\x00', sizeof(G.message));\n            snprintf(G.message, sizeof(G.message), \"][ fixed channel %s: %d \", wi_get_ifname(wi[i]), chan);\n            wi_set_channel(wi[i], G.channel[i]);\n        }\n    }\n    return 0;\n}\n\nint check_frequency(struct wif *wi[], int cards)\n{\n    int i, freq;\n    for(i=0; i<cards; i++)\n    {\n        freq = wi_get_freq(wi[i]);\n        if(freq < 0) continue;\n        if(G.frequency[i] != freq)\n        {\n            memset(G.message, '\\x00', sizeof(G.message));\n            snprintf(G.message, sizeof(G.message), \"][ fixed frequency %s: %d \", wi_get_ifname(wi[i]), freq);\n            wi_set_freq(wi[i], G.frequency[i]);\n        }\n    }\n    return 0;\n}\n\nint detect_frequencies(struct wif *wi)\n{\n    int start_freq = 2192;\n    int end_freq = 2732;\n    int max_freq_num = 2048; //should be enough to keep all available channels\n    int freq=0, i=0;\n\n    printf(\"Checking available frequencies, this could take few seconds.\\n\");\n\n    frequencies = (int*) malloc((max_freq_num+1) * sizeof(int)); //field for frequencies supported\n    memset(frequencies, 0, (max_freq_num+1) * sizeof(int));\n    for(freq=start_freq; freq<=end_freq; freq+=5)\n    {\n        if(wi_set_freq(wi, freq) == 0)\n        {\n            frequencies[i] = freq;\n            i++;\n        }\n        if(freq == 2482)\n        {\n            //special case for chan 14, as its 12MHz away from 13, not 5MHz\n            freq = 2484;\n            if(wi_set_freq(wi, freq) == 0)\n            {\n                frequencies[i] = freq;\n                i++;\n            }\n            freq = 2482;\n        }\n    }\n\n    //again for 5GHz channels\n    start_freq=4800;\n    end_freq=6000;\n    for(freq=start_freq; freq<=end_freq; freq+=5)\n    {\n        if(wi_set_freq(wi, freq) == 0)\n        {\n            frequencies[i] = freq;\n            i++;\n        }\n    }\n\n    printf(\"Done.\\n\");\n    return 0;\n}\n\nint array_contains(int *array, int length, int value)\n{\n    int i;\n    for(i=0;i<length;i++)\n        if(array[i] == value)\n            return 1;\n\n    return 0;\n}\n\nint rearrange_frequencies()\n{\n    int *freqs;\n    int count, left, pos;\n    int width, last_used=0;\n    int cur_freq, last_freq, round_done;\n//     int i;\n\n    width = DEFAULT_CWIDTH;\n    cur_freq=0;\n\n    count = getfreqcount(0);\n    left = count;\n    pos = 0;\n\n    freqs = malloc(sizeof(int) * (count + 1));\n    memset(freqs, 0, sizeof(int) * (count + 1));\n    round_done = 0;\n\n    while(left > 0)\n    {\n//         printf(\"pos: %d\\n\", pos);\n        last_freq = cur_freq;\n        cur_freq = G.own_frequencies[pos%count];\n        if(cur_freq == last_used)\n            round_done=1;\n//         printf(\"count: %d, left: %d, last_used: %d, cur_freq: %d, width: %d\\n\", count, left, last_used, cur_freq, width);\n        if(((count-left) > 0) && !round_done && ( ABS( last_used-cur_freq ) < width ) )\n        {\n//             printf(\"skip it!\\n\");\n            pos++;\n            continue;\n        }\n        if(!array_contains( freqs, count, cur_freq))\n        {\n//             printf(\"not in there yet: %d\\n\", cur_freq);\n            freqs[count - left] = cur_freq;\n            last_used = cur_freq;\n            left--;\n            round_done = 0;\n        }\n\n        pos++;\n    }\n\n    memcpy(G.own_frequencies, freqs, count*sizeof(int));\n    free(freqs);\n\n    return 0;\n}\n\nint main( int argc, char *argv[] )\n{\n    long time_slept, cycle_time, cycle_time2;\n    char * output_format_string;\n    int caplen=0, i, j, fdh, fd_is_set, chan_count, freq_count, unused;\n    int fd_raw[MAX_CARDS], arptype[MAX_CARDS];\n    int ivs_only, found;\n    int valid_channel;\n    int freq [2];\n    int num_opts = 0;\n    int option = 0;\n    int option_index = 0;\n    char ifnam[64];\n    int wi_read_failed=0;\n    int n = 0;\n    int output_format_first_time = 1;\n#ifdef HAVE_PCRE\n    const char *pcreerror;\n    int pcreerroffset;\n#endif\n\n    struct AP_info *ap_cur, *ap_prv, *ap_next;\n    struct ST_info *st_cur, *st_next;\n    struct NA_info *na_cur, *na_next;\n    struct oui *oui_cur, *oui_next;\n\n    struct pcap_pkthdr pkh;\n\n    time_t tt1, tt2, tt3, start_time;\n\n    struct wif\t       *wi[MAX_CARDS];\n    struct rx_info     ri;\n    unsigned char      tmpbuf[4096];\n    unsigned char      buffer[4096];\n    unsigned char      *h80211;\n    char               *iface[MAX_CARDS];\n\n    struct timeval     tv0;\n    struct timeval     tv1;\n    struct timeval     tv2;\n    struct timeval     tv3;\n    struct timeval     tv4;\n    struct tm          *lt;\n\n    /*\n    struct sockaddr_in provis_addr;\n    */\n\n    fd_set             rfds;\n\n    static struct option long_options[] = {\n        {\"band\",     1, 0, 'b'},\n        {\"beacon\",   0, 0, 'e'},\n        {\"beacons\",  0, 0, 'e'},\n        {\"cswitch\",  1, 0, 's'},\n        {\"netmask\",  1, 0, 'm'},\n        {\"bssid\",    1, 0, 'd'},\n        {\"essid\",    1, 0, 'N'},\n        {\"essid-regex\", 1, 0, 'R'},\n        {\"channel\",  1, 0, 'c'},\n        {\"gpsd\",     0, 0, 'g'},\n        {\"ivs\",      0, 0, 'i'},\n        {\"write\",    1, 0, 'w'},\n        {\"encrypt\",  1, 0, 't'},\n        {\"update\",   1, 0, 'u'},\n        {\"berlin\",   1, 0, 'B'},\n        {\"help\",     0, 0, 'H'},\n        {\"nodecloak\",0, 0, 'D'},\n        {\"showack\",  0, 0, 'A'},\n        {\"detect-anomaly\", 0, 0, 'E'},\n        {\"output-format\",  1, 0, 'o'},\n        {\"ignore-negative-one\", 0, &G.ignore_negative_one, 1},\n        {\"manufacturer\",  0, 0, 'M'},\n        {\"uptime\",   0, 0, 'U'},\n        {0,          0, 0,  0 }\n    };\n\n\n#ifdef USE_GCRYPT\n    // Register callback functions to ensure proper locking in the sensitive parts of libgcrypt.\n    gcry_control (GCRYCTL_SET_THREAD_CBS, &gcry_threads_pthread);\n    // Disable secure memory.\n    gcry_control (GCRYCTL_DISABLE_SECMEM, 0);\n    // Tell Libgcrypt that initialization has completed.\n    gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\tpthread_mutex_init( &(G.mx_print), NULL );\n    pthread_mutex_init( &(G.mx_sort), NULL );\n\n    textstyle(TEXT_RESET);//(TEXT_RESET, TEXT_BLACK, TEXT_WHITE);\n\n\t/* initialize a bunch of variables */\n\n\tsrand( time( NULL ) );\n    memset( &G, 0, sizeof( G ) );\n\n    h80211         =  NULL;\n    ivs_only       =  0;\n    G.chanoption   =  0;\n    G.freqoption   =  0;\n    G.num_cards\t   =  0;\n    fdh\t\t   =  0;\n    fd_is_set\t   =  0;\n    chan_count\t   =  0;\n    time_slept     =  0;\n    G.batt         =  NULL;\n    G.chswitch     =  0;\n    valid_channel  =  0;\n    G.usegpsd      =  0;\n    G.channels     =  bg_chans;\n    G.one_beacon   =  1;\n    G.singlechan   =  0;\n    G.singlefreq   =  0;\n    G.dump_prefix  =  NULL;\n    G.record_data  =  0;\n    G.f_cap        =  NULL;\n    G.f_ivs        =  NULL;\n    G.f_txt        =  NULL;\n    G.f_kis        =  NULL;\n    G.f_kis_xml    =  NULL;\n    G.f_gps        =  NULL;\n    G.keyout       =  NULL;\n    G.f_xor        =  NULL;\n    G.sk_len       =  0;\n    G.sk_len2      =  0;\n    G.sk_start     =  0;\n    G.prefix       =  NULL;\n    G.f_encrypt    =  0;\n    G.asso_client  =  0;\n    G.f_essid      =  NULL;\n    G.f_essid_count = 0;\n    G.active_scan_sim  =  0;\n    G.update_s     =  0;\n    G.decloak      =  1;\n    G.is_berlin    =  0;\n    G.numaps       =  0;\n    G.maxnumaps    =  0;\n    G.berlin       =  120;\n    G.show_ap      =  1;\n    G.show_sta     =  1;\n    G.show_ack     =  0;\n    G.hide_known   =  0;\n    G.maxsize_essid_seen  =  5; // Initial value: length of \"ESSID\"\n    G.show_manufacturer = 0;\n    G.show_uptime  = 0;\n    G.hopfreq      =  DEFAULT_HOPFREQ;\n    G.s_file       =  NULL;\n    G.s_iface      =  NULL;\n    G.f_cap_in     =  NULL;\n    G.detect_anomaly = 0;\n    G.airodump_start_time = NULL;\n\tG.manufList = NULL;\n\n\tG.output_format_pcap = 1;\n    G.output_format_csv = 1;\n    G.output_format_kismet_csv = 1;\n    G.output_format_kismet_netxml = 1;\n\n#ifdef HAVE_PCRE\n    G.f_essid_regex = NULL;\n#endif\n\n\t// Default selection.\n    resetSelection();\n\n    memset(G.sharedkey, '\\x00', 512*3);\n    memset(G.message, '\\x00', sizeof(G.message));\n    memset(&G.pfh_in, '\\x00', sizeof(struct pcap_file_header));\n\n    gettimeofday( &tv0, NULL );\n\n    lt = localtime( (time_t *) &tv0.tv_sec );\n\n    G.keyout = (char*) malloc(512);\n    memset( G.keyout, 0, 512 );\n    snprintf( G.keyout,  511,\n              \"keyout-%02d%02d-%02d%02d%02d.keys\",\n              lt->tm_mon + 1, lt->tm_mday,\n              lt->tm_hour, lt->tm_min, lt->tm_sec );\n\n    for(i=0; i<MAX_CARDS; i++)\n    {\n        arptype[i]=0;\n        fd_raw[i]=-1;\n        G.channel[i]=0;\n    }\n\n    memset(G.f_bssid, '\\x00', 6);\n    memset(G.f_netmask, '\\x00', 6);\n    memset(G.wpa_bssid, '\\x00', 6);\n\n\n    /* check the arguments */\n\n    for(i=0; long_options[i].name != NULL; i++);\n    num_opts = i;\n\n    for(i=0; i<argc; i++) //go through all arguments\n    {\n        found = 0;\n        if(strlen(argv[i]) >= 3)\n        {\n            if(argv[i][0] == '-' && argv[i][1] != '-')\n            {\n                //we got a single dash followed by at least 2 chars\n                //lets check that against our long options to find errors\n                for(j=0; j<num_opts;j++)\n                {\n                    if( strcmp(argv[i]+1, long_options[j].name) == 0 )\n                    {\n                        //found long option after single dash\n                        found = 1;\n                        if(i>1 && strcmp(argv[i-1], \"-\") == 0)\n                        {\n                            //separated dashes?\n                            printf(\"Notice: You specified \\\"%s %s\\\". Did you mean \\\"%s%s\\\" instead?\\n\", argv[i-1], argv[i], argv[i-1], argv[i]);\n                        }\n                        else\n                        {\n                            //forgot second dash?\n                            printf(\"Notice: You specified \\\"%s\\\". Did you mean \\\"-%s\\\" instead?\\n\", argv[i], argv[i]);\n                        }\n                        break;\n                    }\n                }\n                if(found)\n                {\n                    sleep(3);\n                    break;\n                }\n            }\n        }\n    }\n\n    do\n    {\n        option_index = 0;\n\n        option = getopt_long( argc, argv,\n                        \"b:c:egiw:s:t:u:m:d:N:R:aHDB:Ahf:r:EC:o:x:MU\",\n                        long_options, &option_index );\n\n        if( option < 0 ) break;\n\n        switch( option )\n        {\n            case 0 :\n\n                break;\n\n            case ':':\n\n                printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                return( 1 );\n\n            case '?':\n\n                printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                return( 1 );\n\n\t\t\tcase 'E':\n\t\t\t\tG.detect_anomaly = 1;\n\t\t\t\tbreak;\n\n            case 'e':\n\n                G.one_beacon = 0;\n                break;\n\n            case 'a':\n\n                G.asso_client = 1;\n                break;\n\n            case 'A':\n\n                G.show_ack = 1;\n                break;\n\n            case 'h':\n\n                G.hide_known = 1;\n                break;\n\n            case 'D':\n\n                G.decloak = 0;\n                break;\n\n\t    case 'M':\n\n                G.show_manufacturer = 1;\n                break;\n\n\t    case 'U' :\n\t    \t\tG.show_uptime = 1;\n\t    \t\tbreak;\n\n            case 'c' :\n\n                if (G.channel[0] > 0 || G.chanoption == 1) {\n                    if (G.chanoption == 1)\n                        printf( \"Notice: Channel range already given\\n\" );\n                    else\n                        printf( \"Notice: Channel already given (%d)\\n\", G.channel[0]);\n                    break;\n                }\n\n                G.channel[0] = getchannels(optarg);\n\n                if ( G.channel[0] < 0 )\n                    goto usage;\n\n                G.chanoption = 1;\n\n                if( G.channel[0] == 0 )\n                {\n                    G.channels = G.own_channels;\n                    break;\n                }\n                G.channels = bg_chans;\n                break;\n\n            case 'C' :\n\n                if (G.channel[0] > 0 || G.chanoption == 1) {\n                    if (G.chanoption == 1)\n                        printf( \"Notice: Channel range already given\\n\" );\n                    else\n                        printf( \"Notice: Channel already given (%d)\\n\", G.channel[0]);\n                    break;\n                }\n\n                if (G.freqoption == 1) {\n                    printf( \"Notice: Frequency range already given\\n\" );\n                    break;\n                }\n\n                G.freqstring = optarg;\n\n                G.freqoption = 1;\n\n                break;\n\n            case 'b' :\n\n                if (G.chanoption == 1 && option != 'c') {\n                    printf( \"Notice: Channel range already given\\n\" );\n                    break;\n                }\n                freq[0] = freq[1] = 0;\n\n                for (i = 0; i < (int)strlen(optarg); i++) {\n                    if ( optarg[i] == 'a' )\n                        freq[1] = 1;\n                    else if ( optarg[i] == 'b' || optarg[i] == 'g')\n                        freq[0] = 1;\n                    else {\n                        printf( \"Error: invalid band (%c)\\n\", optarg[i] );\n                        printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                        exit ( 1 );\n                    }\n                }\n\n                if (freq[1] + freq[0] == 2 )\n                    G.channels = abg_chans;\n                else {\n                    if ( freq[1] == 1 )\n                        G.channels = a_chans;\n                    else\n                        G.channels = bg_chans;\n                }\n\n                break;\n\n            case 'i':\n\n\t\t\t\t// Reset output format if it's the first time the option is specified\n\t\t\t\tif (output_format_first_time) {\n\t\t\t\t\toutput_format_first_time = 0;\n\n\t\t\t\t\tG.output_format_pcap = 0;\n\t\t\t\t\tG.output_format_csv = 0;\n\t\t\t\t\tG.output_format_kismet_csv = 0;\n    \t\t\t\tG.output_format_kismet_netxml = 0;\n\t\t\t\t}\n\n \t\t\t\tif (G.output_format_pcap) {\n\t\t\t\t\tprintf( usage, getVersion(\"Airodump-ng\", _MAJ, _MIN, _SUB_MIN, _REVISION, _BETA, _RC)  );\n\t\t\t\t\tfprintf(stderr, \"Invalid output format: IVS and PCAP format cannot be used together.\\n\");\n\t\t\t\t\treturn( 1 );\n\t\t\t\t}\n\n                ivs_only = 1;\n                break;\n\n            case 'g':\n\n                G.usegpsd  = 1;\n                /*\n                if (inet_aton(optarg, &provis_addr.sin_addr) == 0 )\n                {\n                    printf(\"Invalid IP address.\\n\");\n                    return (1);\n                }\n                */\n                break;\n\n            case 'w':\n\n                if (G.dump_prefix != NULL) {\n                    printf( \"Notice: dump prefix already given\\n\" );\n                    break;\n                }\n                /* Write prefix */\n                G.dump_prefix   = optarg;\n                G.record_data = 1;\n                break;\n\n            case 'r' :\n\n                if( G.s_file )\n                {\n                    printf( \"Packet source already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                G.s_file = optarg;\n                break;\n\n            case 's':\n\n                if (atoi(optarg) > 2) {\n                    goto usage;\n                }\n                if (G.chswitch != 0) {\n                    printf(\"Notice: switching method already given\\n\");\n                    break;\n                }\n                G.chswitch = atoi(optarg);\n                break;\n\n            case 'u':\n\n                G.update_s = atoi(optarg);\n\n                /* If failed to parse or value <= 0, use default, 100ms */\n                if (G.update_s <= 0)\n                \tG.update_s = REFRESH_RATE;\n\n                break;\n\n            case 'f':\n\n                G.hopfreq = atoi(optarg);\n\n                /* If failed to parse or value <= 0, use default, 100ms */\n                if (G.hopfreq <= 0)\n                \tG.hopfreq = DEFAULT_HOPFREQ;\n\n                break;\n\n            case 'B':\n\n                G.is_berlin = 1;\n                G.berlin    = atoi(optarg);\n\n                if (G.berlin <= 0)\n                \tG.berlin = 120;\n\n                break;\n\n            case 'm':\n\n                if ( memcmp(G.f_netmask, NULL_MAC, 6) != 0 )\n                {\n                    printf(\"Notice: netmask already given\\n\");\n                    break;\n                }\n                if(getmac(optarg, 1, G.f_netmask) != 0)\n                {\n                    printf(\"Notice: invalid netmask\\n\");\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'd':\n\n                if ( memcmp(G.f_bssid, NULL_MAC, 6) != 0 )\n                {\n                    printf(\"Notice: bssid already given\\n\");\n                    break;\n                }\n                if(getmac(optarg, 1, G.f_bssid) != 0)\n                {\n                    printf(\"Notice: invalid bssid\\n\");\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n\n                    return( 1 );\n                }\n                break;\n\n            case 'N':\n\n                G.f_essid_count++;\n                G.f_essid = (char**)realloc(G.f_essid, G.f_essid_count * sizeof(char*));\n                G.f_essid[G.f_essid_count-1] = optarg;\n                break;\n\n\t    case 'R':\n\n#ifdef HAVE_PCRE\n                if (G.f_essid_regex != NULL)\n                {\n\t\t\tprintf(\"Error: ESSID regular expression already given. Aborting\\n\");\n\t\t\texit(1);\n                }\n\n                G.f_essid_regex = pcre_compile(optarg, 0, &pcreerror, &pcreerroffset, NULL);\n\n                if (G.f_essid_regex == NULL)\n                {\n\t\t\tprintf(\"Error: regular expression compilation failed at offset %d: %s; aborting\\n\", pcreerroffset, pcreerror);\n\t\t\texit(1);\n\t\t}\n#else\n                printf(\"Error: Airodump-ng wasn't compiled with pcre support; aborting\\n\");\n#endif\n\n                break;\n\n            case 't':\n\n                set_encryption_filter(optarg);\n                break;\n\n\t\t\tcase 'o':\n\n\t\t\t\t// Reset output format if it's the first time the option is specified\n\t\t\t\tif (output_format_first_time) {\n\t\t\t\t\toutput_format_first_time = 0;\n\n\t\t\t\t\tG.output_format_pcap = 0;\n\t\t\t\t\tG.output_format_csv = 0;\n\t\t\t\t\tG.output_format_kismet_csv = 0;\n    \t\t\t\tG.output_format_kismet_netxml = 0;\n\t\t\t\t}\n\n\t\t\t\t// Parse the value\n\t\t\t\toutput_format_string = strtok(optarg, \",\");\n\t\t\t\twhile (output_format_string != NULL) {\n\t\t\t\t\tif (strlen(output_format_string) != 0) {\n\t\t\t\t\t\tif (strncasecmp(output_format_string, \"csv\", 3) == 0\n\t\t\t\t\t\t\t|| strncasecmp(output_format_string, \"txt\", 3) == 0) {\n\t\t\t\t\t\t\tG.output_format_csv = 1;\n\t\t\t\t\t\t} else if (strncasecmp(output_format_string, \"pcap\", 4) == 0\n\t\t\t\t\t\t\t|| strncasecmp(output_format_string, \"cap\", 3) == 0) {\n                            if (ivs_only) {\n                                printf( usage, getVersion(\"Airodump-ng\", _MAJ, _MIN, _SUB_MIN, _REVISION, _BETA, _RC)  );\n                                fprintf(stderr, \"Invalid output format: IVS and PCAP format cannot be used together.\\n\");\n                                return( 1 );\n                            }\n\t\t\t\t\t\t\tG.output_format_pcap = 1;\n\t\t\t\t\t\t} else if (strncasecmp(output_format_string, \"ivs\", 3) == 0) {\n                            if (G.output_format_pcap) {\n                                printf( usage, getVersion(\"Airodump-ng\", _MAJ, _MIN, _SUB_MIN, _REVISION, _BETA, _RC)  );\n                                fprintf(stderr, \"Invalid output format: IVS and PCAP format cannot be used together.\\n\");\n                                return( 1 );\n                            }\n\t\t\t\t\t\t\tivs_only = 1;\n\t\t\t\t\t\t} else if (strncasecmp(output_format_string, \"kismet\", 6) == 0) {\n\t\t\t\t\t\t\tG.output_format_kismet_csv = 1;\n\t\t\t\t\t\t} else if (strncasecmp(output_format_string, \"gps\", 3) == 0) {\n\t\t\t\t\t\t\tG.usegpsd  = 1;\n\t\t\t\t\t\t} else if (strncasecmp(output_format_string, \"netxml\", 6) == 0\n\t\t\t\t\t\t\t|| strncasecmp(output_format_string, \"newcore\", 7) == 0\n\t\t\t\t\t\t\t|| strncasecmp(output_format_string, \"kismet-nc\", 9) == 0\n\t\t\t\t\t\t\t|| strncasecmp(output_format_string, \"kismet_nc\", 9) == 0\n\t\t\t\t\t\t\t|| strncasecmp(output_format_string, \"kismet-newcore\", 14) == 0\n\t\t\t\t\t\t\t|| strncasecmp(output_format_string, \"kismet_newcore\", 14) == 0) {\n\t\t\t\t\t\t\tG.output_format_kismet_netxml = 1;\n\t\t\t\t\t\t} else if (strncasecmp(output_format_string, \"default\", 6) == 0) {\n\t\t\t\t\t\t\tG.output_format_pcap = 1;\n\t\t\t\t\t\t\tG.output_format_csv = 1;\n\t\t\t\t\t\t\tG.output_format_kismet_csv = 1;\n\t\t\t\t\t\t\tG.output_format_kismet_netxml = 1;\n\t\t\t\t\t\t} else if (strncasecmp(output_format_string, \"none\", 6) == 0) {\n\t\t\t\t\t\t\tG.output_format_pcap = 0;\n\t\t\t\t\t\t\tG.output_format_csv = 0;\n\t\t\t\t\t\t\tG.output_format_kismet_csv = 0;\n    \t\t\t\t\t\tG.output_format_kismet_netxml = 0;\n\n\t\t\t\t\t\t\tG.usegpsd  = 0;\n\t\t\t\t\t\t\tivs_only = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Display an error if it does not match any value\n\t\t\t\t\t\t\tfprintf(stderr, \"Invalid output format: <%s>\\n\", output_format_string);\n\t\t\t\t\t\t\texit(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toutput_format_string = strtok(NULL, \",\");\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n            case 'H':\n\n                printf( usage, getVersion(\"Airodump-ng\", _MAJ, _MIN, _SUB_MIN, _REVISION, _BETA, _RC)  );\n                return( 1 );\n\n            case 'x':\n\n                G.active_scan_sim = atoi(optarg);\n\n                if (G.active_scan_sim <= 0)\n                    G.active_scan_sim = 0;\n                break;\n\n            default : goto usage;\n        }\n    } while ( 1 );\n\n    if( argc - optind != 1 && G.s_file == NULL)\n    {\n        if(argc == 1)\n        {\nusage:\n            printf( usage, getVersion(\"Airodump-ng\", _MAJ, _MIN, _SUB_MIN, _REVISION, _BETA, _RC)  );\n        }\n        if( argc - optind == 0)\n        {\n            printf(\"No interface specified.\\n\");\n        }\n        if(argc > 1)\n        {\n            printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n        }\n        return( 1 );\n    }\n\n    if( argc - optind == 1 )\n        G.s_iface = argv[argc-1];\n\n    if( ( memcmp(G.f_netmask, NULL_MAC, 6) != 0 ) && ( memcmp(G.f_bssid, NULL_MAC, 6) == 0 ) )\n    {\n        printf(\"Notice: specify bssid \\\"--bssid\\\" with \\\"--netmask\\\"\\n\");\n        printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n        return( 1 );\n    }\n\n    if(G.s_iface != NULL)\n    {\n        /* initialize cards */\n        G.num_cards = init_cards(G.s_iface, iface, wi);\n\n        if(G.num_cards <= 0)\n            return( 1 );\n\n        for (i = 0; i < G.num_cards; i++) {\n            fd_raw[i] = wi_fd(wi[i]);\n            if (fd_raw[i] > fdh)\n                fdh = fd_raw[i];\n        }\n\n        if(G.freqoption == 1 && G.freqstring != NULL) // use frequencies\n        {\n            detect_frequencies(wi[0]);\n            G.frequency[0] = getfrequencies(G.freqstring);\n            if(G.frequency[0] == -1)\n            {\n                printf(\"No valid frequency given.\\n\");\n                return(1);\n            }\n\n//             printf(\"gonna rearrange\\n\");\n            rearrange_frequencies();\n//             printf(\"finished rearranging\\n\");\n\n            freq_count = getfreqcount(0);\n\n            /* find the interface index */\n            /* start a child to hop between frequencies */\n\n            if( G.frequency[0] == 0 )\n            {\n                unused = pipe( G.ch_pipe );\n                unused = pipe( G.cd_pipe );\n\n                signal( SIGUSR1, sighandler );\n\n                if( ! fork() )\n                {\n                    /* reopen cards.  This way parent & child don't share resources for\n                    * accessing the card (e.g. file descriptors) which may cause\n                    * problems.  -sorbo\n                    */\n                    for (i = 0; i < G.num_cards; i++) {\n                        strncpy(ifnam, wi_get_ifname(wi[i]), sizeof(ifnam)-1);\n                        ifnam[sizeof(ifnam)-1] = 0;\n\n                        wi_close(wi[i]);\n                        wi[i] = wi_open(ifnam);\n                        if (!wi[i]) {\n                                printf(\"Can't reopen %s\\n\", ifnam);\n                                exit(1);\n                        }\n                    }\n\n\t\t\t\t\t/* Drop privileges */\n\t\t\t\t\tif (setuid( getuid() ) == -1) {\n\t\t\t\t\t\tperror(\"setuid\");\n\t\t\t\t\t}\n\n                    frequency_hopper(wi, G.num_cards, freq_count);\n                    exit( 1 );\n                }\n            }\n            else\n            {\n                for( i=0; i<G.num_cards; i++ )\n                {\n                    wi_set_freq(wi[i], G.frequency[0]);\n                    G.frequency[i] = G.frequency[0];\n                }\n                G.singlefreq = 1;\n            }\n        }\n        else    //use channels\n        {\n            chan_count = getchancount(0);\n\n            /* find the interface index */\n            /* start a child to hop between channels */\n\n            if( G.channel[0] == 0 )\n            {\n                unused = pipe( G.ch_pipe );\n                unused = pipe( G.cd_pipe );\n\n                signal( SIGUSR1, sighandler );\n\n                if( ! fork() )\n                {\n                    /* reopen cards.  This way parent & child don't share resources for\n                    * accessing the card (e.g. file descriptors) which may cause\n                    * problems.  -sorbo\n                    */\n                    for (i = 0; i < G.num_cards; i++) {\n                        strncpy(ifnam, wi_get_ifname(wi[i]), sizeof(ifnam)-1);\n                        ifnam[sizeof(ifnam)-1] = 0;\n\n                        wi_close(wi[i]);\n                        wi[i] = wi_open(ifnam);\n                        if (!wi[i]) {\n                                printf(\"Can't reopen %s\\n\", ifnam);\n                                exit(1);\n                        }\n                    }\n\n\t\t\t\t\t/* Drop privileges */\n\t\t\t\t\tif (setuid( getuid() ) == -1) {\n\t\t\t\t\t\tperror(\"setuid\");\n\t\t\t\t\t}\n\n                    channel_hopper(wi, G.num_cards, chan_count);\n                    exit( 1 );\n                }\n            }\n            else\n            {\n                for( i=0; i<G.num_cards; i++ )\n                {\n                    wi_set_channel(wi[i], G.channel[0]);\n                    G.channel[i] = G.channel[0];\n                }\n                G.singlechan = 1;\n            }\n        }\n    }\n\n\t/* Drop privileges */\n\tif (setuid( getuid() ) == -1) {\n\t\tperror(\"setuid\");\n\t}\n\n    /* check if there is an input file */\n    if( G.s_file != NULL )\n    {\n        if( ! ( G.f_cap_in = fopen( G.s_file, \"rb\" ) ) )\n        {\n            perror( \"open failed\" );\n            return( 1 );\n        }\n\n        n = sizeof( struct pcap_file_header );\n\n        if( fread( &G.pfh_in, 1, n, G.f_cap_in ) != (size_t) n )\n        {\n            perror( \"fread(pcap file header) failed\" );\n            return( 1 );\n        }\n\n        if( G.pfh_in.magic != TCPDUMP_MAGIC &&\n            G.pfh_in.magic != TCPDUMP_CIGAM )\n        {\n            fprintf( stderr, \"\\\"%s\\\" isn't a pcap file (expected \"\n                             \"TCPDUMP_MAGIC).\\n\", G.s_file );\n            return( 1 );\n        }\n\n        if( G.pfh_in.magic == TCPDUMP_CIGAM )\n            SWAP32(G.pfh_in.linktype);\n\n        if( G.pfh_in.linktype != LINKTYPE_IEEE802_11 &&\n            G.pfh_in.linktype != LINKTYPE_PRISM_HEADER &&\n            G.pfh_in.linktype != LINKTYPE_RADIOTAP_HDR &&\n            G.pfh_in.linktype != LINKTYPE_PPI_HDR )\n        {\n            fprintf( stderr, \"Wrong linktype from pcap file header \"\n                             \"(expected LINKTYPE_IEEE802_11) -\\n\"\n                             \"this doesn't look like a regular 802.11 \"\n                             \"capture.\\n\" );\n            return( 1 );\n        }\n    }\n\n    /* open or create the output files */\n\n    if (G.record_data)\n    \tif( dump_initialize( G.dump_prefix, ivs_only ) )\n    \t    return( 1 );\n\n    signal( SIGINT,   sighandler );\n    signal( SIGSEGV,  sighandler );\n    signal( SIGTERM,  sighandler );\n    signal( SIGWINCH, sighandler );\n\n    sighandler( SIGWINCH );\n\n    /* fill oui struct if ram is greater than 32 MB */\n    if (get_ram_size()  > MIN_RAM_SIZE_LOAD_OUI_RAM) {\n        G.manufList = load_oui_file();\n\t}\n\n    /* start the GPS tracker */\n\n    if (G.usegpsd)\n    {\n        unused = pipe( G.gc_pipe );\n        signal( SIGUSR2, sighandler );\n\n        if( ! fork() )\n        {\n            gps_tracker();\n            exit( 1 );\n        }\n\n        usleep( 50000 );\n        waitpid( -1, NULL, WNOHANG );\n    }\n\n    fprintf( stderr, \"\\33[?25l\\33[2J\\n\" );\n\n    start_time = time( NULL );\n    tt1        = time( NULL );\n    tt2        = time( NULL );\n    tt3        = time( NULL );\n    gettimeofday( &tv3, NULL );\n    gettimeofday( &tv4, NULL );\n\n    G.batt     = getBatteryString();\n\n    G.elapsed_time = (char *) calloc( 1, 4 );\n    strncpy(G.elapsed_time, \"0 s\", 4 - 1);\n\n\t/* Create start time string for kismet netxml file */\n    G.airodump_start_time = (char *) calloc( 1, 1000 * sizeof(char) );\n    strncpy(G.airodump_start_time, ctime( & start_time ), 1000 - 1);\n    G.airodump_start_time[strlen(G.airodump_start_time) - 1] = 0; // remove new line\n    G.airodump_start_time = (char *) realloc( G.airodump_start_time, sizeof(char) * (strlen(G.airodump_start_time) + 1) );\n\n    if( pthread_create( &(G.input_tid), NULL, (void *) input_thread, NULL ) != 0 )\n    {\n\tperror( \"pthread_create failed\" );\n\treturn 1;\n    }\n\n\n    while( 1 )\n    {\n        if( G.do_exit )\n        {\n            break;\n        }\n\n        if( time( NULL ) - tt1 >= 5 )\n        {\n            /* update the csv stats file */\n\n            tt1 = time( NULL );\n            if (G. output_format_csv)  dump_write_csv();\n            if (G.output_format_kismet_csv) dump_write_kismet_csv();\n            if (G.output_format_kismet_netxml) dump_write_kismet_netxml();\n\n            /* sort the APs by power */\n\n\t    if(G.sort_by != SORT_BY_NOTHING) {\n\t\tpthread_mutex_lock( &(G.mx_sort) );\n\t\t    dump_sort();\n\t\tpthread_mutex_unlock( &(G.mx_sort) );\n\t    }\n        }\n\n        if( time( NULL ) - tt2 > 3 )\n        {\n            /* update the battery state */\n            free(G.batt);\n            G.batt = NULL;\n\n            tt2 = time( NULL );\n            G.batt = getBatteryString();\n\n            /* update elapsed time */\n\n            free(G.elapsed_time);\n            G.elapsed_time=NULL;\n            G.elapsed_time = getStringTimeFromSec(\n            difftime(tt2, start_time) );\n\n\n            /* flush the output files */\n\n            if( G.f_cap != NULL ) fflush( G.f_cap );\n            if( G.f_ivs != NULL ) fflush( G.f_ivs );\n        }\n\n        gettimeofday( &tv1, NULL );\n\n        cycle_time = 1000000 * ( tv1.tv_sec  - tv3.tv_sec  )\n                             + ( tv1.tv_usec - tv3.tv_usec );\n\n        cycle_time2 = 1000000 * ( tv1.tv_sec  - tv4.tv_sec  )\n                              + ( tv1.tv_usec - tv4.tv_usec );\n\n        if( G.active_scan_sim > 0 && cycle_time2 > G.active_scan_sim*1000 )\n        {\n            gettimeofday( &tv4, NULL );\n            send_probe_requests(wi, G.num_cards);\n        }\n\n        if( cycle_time > 500000 )\n        {\n            gettimeofday( &tv3, NULL );\n            update_rx_quality( );\n            if(G.s_iface != NULL)\n            {\n                check_monitor(wi, fd_raw, &fdh, G.num_cards);\n                if(G.singlechan)\n                    check_channel(wi, G.num_cards);\n                if(G.singlefreq)\n                    check_frequency(wi, G.num_cards);\n            }\n        }\n\n        if(G.s_file != NULL)\n        {\n            /* Read one packet */\n            n = sizeof( pkh );\n\n            if( fread( &pkh, n, 1, G.f_cap_in ) != 1 )\n            {\n                memset(G.message, '\\x00', sizeof(G.message));\n                snprintf(G.message, sizeof(G.message), \"][ Finished reading input file %s.\\n\", G.s_file);\n                G.s_file = NULL;\n                continue;\n            }\n\n            if( G.pfh_in.magic == TCPDUMP_CIGAM ) {\n                SWAP32( pkh.caplen );\n                SWAP32( pkh.len );\n            }\n\n            n = caplen = pkh.caplen;\n\n            memset(buffer, 0, sizeof(buffer));\n            h80211 = buffer;\n\n            if( n <= 0 || n > (int) sizeof( buffer ) )\n            {\n                memset(G.message, '\\x00', sizeof(G.message));\n                snprintf(G.message, sizeof(G.message), \"][ Finished reading input file %s.\\n\", G.s_file);\n                G.s_file = NULL;\n                continue;\n            }\n\n            if( fread( h80211, n, 1, G.f_cap_in ) != 1 )\n            {\n                memset(G.message, '\\x00', sizeof(G.message));\n                snprintf(G.message, sizeof(G.message), \"][ Finished reading input file %s.\\n\", G.s_file);\n                G.s_file = NULL;\n                continue;\n            }\n\n            if( G.pfh_in.linktype == LINKTYPE_PRISM_HEADER )\n            {\n                if( h80211[7] == 0x40 )\n                    n = 64;\n                else\n                    n = *(int *)( h80211 + 4 );\n\n                if( n < 8 || n >= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n\n            if( G.pfh_in.linktype == LINKTYPE_RADIOTAP_HDR )\n            {\n                /* remove the radiotap header */\n\n                n = *(unsigned short *)( h80211 + 2 );\n\n                if( n <= 0 || n >= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n\n            if( G.pfh_in.linktype == LINKTYPE_PPI_HDR )\n            {\n                /* remove the PPI header */\n\n                n = le16_to_cpu(*(unsigned short *)( h80211 + 2));\n\n                if( n <= 0 || n>= (int) caplen )\n                    continue;\n\n                /* for a while Kismet logged broken PPI headers */\n                if ( n == 24 && le16_to_cpu(*(unsigned short *)(h80211 + 8)) == 2 )\n                    n = 32;\n\n                if( n <= 0 || n>= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n\n            read_pkts++;\n\n            if(read_pkts%10 == 0)\n                usleep(1);\n        }\n        else if(G.s_iface != NULL)\n        {\n            /* capture one packet */\n\n            FD_ZERO( &rfds );\n            for(i=0; i<G.num_cards; i++)\n            {\n                FD_SET( fd_raw[i], &rfds );\n            }\n\n            tv0.tv_sec  = G.update_s;\n            tv0.tv_usec = (G.update_s == 0) ? REFRESH_RATE : 0;\n\n            gettimeofday( &tv1, NULL );\n\n            if( select( fdh + 1, &rfds, NULL, NULL, &tv0 ) < 0 )\n            {\n                if( errno == EINTR )\n                {\n                    gettimeofday( &tv2, NULL );\n\n                    time_slept += 1000000 * ( tv2.tv_sec  - tv1.tv_sec  )\n                                        + ( tv2.tv_usec - tv1.tv_usec );\n\n                    continue;\n                }\n                perror( \"select failed\" );\n\n                /* Restore terminal */\n                fprintf( stderr, \"\\33[?25h\" );\n                fflush( stdout );\n\n                return( 1 );\n            }\n        }\n        else\n            usleep(1);\n\n        gettimeofday( &tv2, NULL );\n\n        time_slept += 1000000 * ( tv2.tv_sec  - tv1.tv_sec  )\n                              + ( tv2.tv_usec - tv1.tv_usec );\n\n        if( time_slept > REFRESH_RATE && time_slept > G.update_s * 1000000)\n        {\n            time_slept = 0;\n\n            update_dataps();\n\n            /* update the window size */\n\n            if( ioctl( 0, TIOCGWINSZ, &(G.ws) ) < 0 )\n            {\n                G.ws.ws_row = 25;\n                G.ws.ws_col = 80;\n            }\n\n            if( G.ws.ws_col <   1 ) G.ws.ws_col =   1;\n            if( G.ws.ws_col > 300 ) G.ws.ws_col = 300;\n\n            /* display the list of access points we have */\n\n\t    if(!G.do_pause) {\n\t\tpthread_mutex_lock( &(G.mx_print) );\n\n\t\t    fprintf( stderr, \"\\33[1;1H\" );\n\t\t    dump_print( G.ws.ws_row, G.ws.ws_col, G.num_cards );\n\t\t    fprintf( stderr, \"\\33[J\" );\n\t\t    fflush( stdout );\n\n\t\tpthread_mutex_unlock( &(G.mx_print) );\n\t    }\n            continue;\n        }\n\n        if(G.s_file == NULL && G.s_iface != NULL)\n        {\n            fd_is_set = 0;\n\n            for(i=0; i<G.num_cards; i++)\n            {\n                if( FD_ISSET( fd_raw[i], &rfds ) )\n                {\n\n                    memset(buffer, 0, sizeof(buffer));\n                    h80211 = buffer;\n                    if ((caplen = wi_read(wi[i], h80211, sizeof(buffer), &ri)) == -1) {\n                        wi_read_failed++;\n                        if(wi_read_failed > 1)\n                        {\n                            G.do_exit = 1;\n                            break;\n                        }\n                        memset(G.message, '\\x00', sizeof(G.message));\n                        snprintf(G.message, sizeof(G.message), \"][ interface %s down \", wi_get_ifname(wi[i]));\n\n                        //reopen in monitor mode\n\n                        strncpy(ifnam, wi_get_ifname(wi[i]), sizeof(ifnam)-1);\n                        ifnam[sizeof(ifnam)-1] = 0;\n\n                        wi_close(wi[i]);\n                        wi[i] = wi_open(ifnam);\n                        if (!wi[i]) {\n                            printf(\"Can't reopen %s\\n\", ifnam);\n\n                            /* Restore terminal */\n                            fprintf( stderr, \"\\33[?25h\" );\n                            fflush( stdout );\n\n                            exit(1);\n                        }\n\n                        fd_raw[i] = wi_fd(wi[i]);\n                        if (fd_raw[i] > fdh)\n                            fdh = fd_raw[i];\n\n                        break;\n//                         return 1;\n                    }\n\n                    read_pkts++;\n\n                    wi_read_failed = 0;\n                    dump_add_packet( h80211, caplen, &ri, i );\n                }\n            }\n        }\n        else if (G.s_file != NULL)\n        {\n            dump_add_packet( h80211, caplen, &ri, i );\n        }\n    }\n\n    if(G.batt)\n        free(G.batt);\n\n    if(G.elapsed_time)\n        free(G.elapsed_time);\n\n    if(G.own_channels)\n        free(G.own_channels);\n    \n    if(G.f_essid)\n        free(G.f_essid);\n\n    if(G.prefix)\n        free(G.prefix);\n\n    if(G.f_cap_name)\n        free(G.f_cap_name);\n\n    if(G.keyout)\n        free(G.keyout);\n\n#ifdef HAVE_PCRE\n    if(G.f_essid_regex)\n        pcre_free(G.f_essid_regex);\n#endif\n\n    for(i=0; i<G.num_cards; i++)\n        wi_close(wi[i]);\n\n    if (G.record_data) {\n        if ( G. output_format_csv)  dump_write_csv();\n        if ( G.output_format_kismet_csv) dump_write_kismet_csv();\n        if ( G.output_format_kismet_netxml) dump_write_kismet_netxml();\n\n        if ( G. output_format_csv || G.f_txt != NULL ) fclose( G.f_txt );\n        if ( G.output_format_kismet_csv || G.f_kis != NULL ) fclose( G.f_kis );\n        if ( G.output_format_kismet_netxml || G.f_kis_xml != NULL )\n        {\n\t\t\tfclose( G.f_kis_xml );\n\t\t\tfree(G.airodump_start_time);\n\t\t}\n        if ( G.f_gps != NULL ) fclose( G.f_gps );\n        if ( G.output_format_pcap ||  G.f_cap != NULL ) fclose( G.f_cap );\n        if ( G.f_ivs != NULL ) fclose( G.f_ivs );\n    }\n\n    if( ! G.save_gps )\n    {\n        snprintf( (char *) buffer, 4096, \"%s-%02d.gps\", argv[2], G.f_index );\n        unlink(  (char *) buffer );\n    }\n\n    ap_prv = NULL;\n    ap_cur = G.ap_1st;\n\n    while( ap_cur != NULL )\n    {\n\t\t// Clean content of ap_cur list (first element: G.ap_1st)\n        uniqueiv_wipe( ap_cur->uiv_root );\n\n        list_tail_free(&(ap_cur->packets));\n\n\tif (G.manufList)\n\t\tfree(ap_cur->manuf);\n\n\tif (G.detect_anomaly)\n        \tdata_wipe(ap_cur->data_root);\n\n        ap_prv = ap_cur;\n        ap_cur = ap_cur->next;\n    }\n\n    ap_cur = G.ap_1st;\n\n    while( ap_cur != NULL )\n    {\n\t\t// Freeing AP List\n        ap_next = ap_cur->next;\n\n        if( ap_cur != NULL )\n            free(ap_cur);\n\n        ap_cur = ap_next;\n    }\n\n    st_cur = G.st_1st;\n    st_next= NULL;\n\n    while(st_cur != NULL)\n    {\n        st_next = st_cur->next;\n\tif (G.manufList)\n\t\tfree(st_cur->manuf);\n        free(st_cur);\n        st_cur = st_next;\n    }\n\n    na_cur = G.na_1st;\n    na_next= NULL;\n\n    while(na_cur != NULL)\n    {\n        na_next = na_cur->next;\n        free(na_cur);\n        na_cur = na_next;\n    }\n\n    if (G.manufList) {\n        oui_cur = G.manufList;\n        while (oui_cur != NULL) {\n            oui_next = oui_cur->next;\n\t    free(oui_cur);\n\t    oui_cur = oui_next;\n        }\n    }\n\n    fprintf( stderr, \"\\33[?25h\" );\n    fflush( stdout );\n\n    return( 0 );\n}\n"], "fixing_code": ["/*\n *  pcap-compatible 802.11 packet sniffer\n *\n *  Copyright (C) 2006-2013 Thomas d'Otreppe\n *  Copyright (C) 2004, 2005 Christophe Devine\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n *\n *  In addition, as a special exception, the copyright holders give\n *  permission to link the code of portions of this program with the\n *  OpenSSL library under certain conditions as described in each\n *  individual source file, and distribute linked combinations\n *  including the two.\n *  You must obey the GNU General Public License in all respects\n *  for all of the code used other than OpenSSL. *  If you modify\n *  file(s) with this exception, you may extend this exception to your\n *  version of the file(s), but you are not obligated to do so. *  If you\n *  do not wish to do so, delete this exception statement from your\n *  version. *  If you delete this exception statement from all source\n *  files in the program, then also delete it here.\n */\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n\n#ifndef TIOCGWINSZ\n\t#include <sys/termios.h>\n#endif\n\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <errno.h>\n#include <time.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <termios.h>\n\n#include <sys/wait.h>\n\n#ifdef HAVE_PCRE\n#include <pcre.h>\n#endif\n\n#include \"version.h\"\n#include \"pcap.h\"\n#include \"uniqueiv.h\"\n#include \"crypto.h\"\n#include \"osdep/osdep.h\"\n#include \"airodump-ng.h\"\n#include \"osdep/common.h\"\n#include \"common.h\"\n\n#ifdef USE_GCRYPT\n\tGCRY_THREAD_OPTION_PTHREAD_IMPL;\n#endif\n\nvoid dump_sort( void );\nvoid dump_print( int ws_row, int ws_col, int if_num );\n\nchar * get_manufacturer_from_string(char * buffer) {\n\tchar * manuf = NULL;\n\tchar * buffer_manuf;\n\tif (buffer != NULL && strlen(buffer) > 0) {\n\t\tbuffer_manuf = strstr(buffer, \"(hex)\");\n\t\tif (buffer_manuf != NULL) {\n\t\t\tbuffer_manuf += 6; // skip '(hex)' and one more character (there's at least one 'space' character after that string)\n\t\t\twhile (*buffer_manuf == '\\t' || *buffer_manuf == ' ') {\n\t\t\t\t++buffer_manuf;\n\t\t\t}\n\n\t\t\t// Did we stop at the manufacturer\n\t\t\tif (*buffer_manuf != '\\0') {\n\n\t\t\t\t// First make sure there's no end of line\n\t\t\t\tif (buffer_manuf[strlen(buffer_manuf) - 1] == '\\n' || buffer_manuf[strlen(buffer_manuf) - 1] == '\\r') {\n\t\t\t\t\tbuffer_manuf[strlen(buffer_manuf) - 1] = '\\0';\n\t\t\t\t\tif (*buffer_manuf != '\\0' && (buffer_manuf[strlen(buffer_manuf) - 1] == '\\n' || buffer[strlen(buffer_manuf) - 1] == '\\r')) {\n\t\t\t\t\t\tbuffer_manuf[strlen(buffer_manuf) - 1] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*buffer_manuf != '\\0') {\n\t\t\t\t\tif ((manuf = (char *)malloc((strlen(buffer_manuf) + 1) * sizeof(char))) == NULL) {\n\t\t\t\t\t\tperror(\"malloc failed\");\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tsnprintf(manuf, strlen(buffer_manuf) + 1, \"%s\", buffer_manuf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn manuf;\n}\n\nvoid textcolor(int attr, int fg, int bg)\n{\tchar command[13];\n\n\t/* Command is the control command to the terminal */\n\tsprintf(command, \"%c[%d;%d;%dm\", 0x1B, attr, fg + 30, bg + 40);\n\tfprintf(stderr, \"%s\", command);\n\tfflush(stderr);\n}\n\nvoid textcolor_fg(int fg)\n{\tchar command[13];\n\n\t/* Command is the control command to the terminal */\n\tsprintf(command, \"\\033[%dm\", fg + 30);\n\tfprintf(stderr, \"%s\", command);\n\tfflush(stderr);\n}\n\nvoid textcolor_bg(int bg)\n{\tchar command[13];\n\n\t/* Command is the control command to the terminal */\n\tsprintf(command, \"\\033[%dm\", bg + 40);\n\tfprintf(stderr, \"%s\", command);\n\tfflush(stderr);\n}\n\nvoid textstyle(int attr)\n{\tchar command[13];\n\n\t/* Command is the control command to the terminal */\n\tsprintf(command, \"\\033[%im\", attr);\n\tfprintf(stderr, \"%s\", command);\n\tfflush(stderr);\n}\n\nvoid reset_term() {\n  struct termios oldt,\n                 newt;\n  tcgetattr( STDIN_FILENO, &oldt );\n  newt = oldt;\n  newt.c_lflag |= ( ICANON | ECHO );\n  tcsetattr( STDIN_FILENO, TCSANOW, &newt );\n}\n\nint mygetch( ) {\n  struct termios oldt,\n                 newt;\n  int            ch;\n  tcgetattr( STDIN_FILENO, &oldt );\n  newt = oldt;\n  newt.c_lflag &= ~( ICANON | ECHO );\n  tcsetattr( STDIN_FILENO, TCSANOW, &newt );\n  ch = getchar();\n  tcsetattr( STDIN_FILENO, TCSANOW, &oldt );\n  return ch;\n}\n\nvoid resetSelection()\n{\n    G.sort_by = SORT_BY_POWER;\n    G.sort_inv = 1;\n\n    G.start_print_ap=1;\n    G.start_print_sta=1;\n    G.selected_ap=1;\n    G.selected_sta=1;\n    G.selection_ap=0;\n    G.selection_sta=0;\n    G.mark_cur_ap=0;\n    G.skip_columns=0;\n    G.do_pause=0;\n    G.do_sort_always=0;\n    memset(G.selected_bssid, '\\x00', 6);\n}\n\n#define KEY_TAB\t\t0x09\t//switch between APs/clients for scrolling\n#define KEY_SPACE\t0x20\t//pause/resume output\n#define KEY_ARROW_UP\t0x41\t//scroll\n#define KEY_ARROW_DOWN\t0x42\t//scroll\n#define KEY_ARROW_RIGHT 0x43\t//scroll\n#define KEY_ARROW_LEFT\t0x44\t//scroll\n#define KEY_a\t\t0x61\t//cycle through active information (ap/sta/ap+sta/ap+sta+ack)\n#define KEY_c\t\t0x63\t//cycle through channels\n#define KEY_d\t\t0x64\t//default mode\n#define KEY_i\t\t0x69\t//inverse sorting\n#define KEY_m\t\t0x6D\t//mark current AP\n#define KEY_n\t\t0x6E\t//?\n#define KEY_r\t\t0x72\t//realtime sort (de)activate\n#define KEY_s\t\t0x73\t//cycle through sorting\n\nvoid input_thread( void *arg) {\n\n    if(!arg){}\n\n    while( G.do_exit == 0 ) {\n\tint keycode=0;\n\n\tkeycode=mygetch();\n\n\tif(keycode == KEY_s) {\n\t    G.sort_by++;\n\t    G.selection_ap = 0;\n\t    G.selection_sta = 0;\n\n\t    if(G.sort_by > MAX_SORT)\n\t\tG.sort_by = 0;\n\n\t    switch(G.sort_by) {\n\t\tcase SORT_BY_NOTHING:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by first seen\");\n\t\t    break;\n\t\tcase SORT_BY_BSSID:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by bssid\");\n\t\t    break;\n\t\tcase SORT_BY_POWER:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by power level\");\n\t\t    break;\n\t\tcase SORT_BY_BEACON:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by beacon number\");\n\t\t    break;\n\t\tcase SORT_BY_DATA:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by number of data packets\");\n\t\t    break;\n\t\tcase SORT_BY_PRATE:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by packet rate\");\n\t\t    break;\n\t\tcase SORT_BY_CHAN:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by channel\");\n\t\t    break;\n\t\tcase SORT_BY_MBIT:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by max data rate\");\n\t\t    break;\n\t\tcase SORT_BY_ENC:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by encryption\");\n\t\t    break;\n\t\tcase SORT_BY_CIPHER:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by cipher\");\n\t\t    break;\n\t\tcase SORT_BY_AUTH:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by authentication\");\n\t\t    break;\n\t\tcase SORT_BY_ESSID:\n\t\t    snprintf(G.message, sizeof(G.message), \"][ sorting by ESSID\");\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t    pthread_mutex_lock( &(G.mx_sort) );\n\t\tdump_sort();\n\t    pthread_mutex_unlock( &(G.mx_sort) );\n\t}\n\n\tif(keycode == KEY_SPACE) {\n\t    G.do_pause = (G.do_pause+1)%2;\n\t    if(G.do_pause) {\n\t\tsnprintf(G.message, sizeof(G.message), \"][ paused output\");\n\t\tpthread_mutex_lock( &(G.mx_print) );\n\n\t\t    fprintf( stderr, \"\\33[1;1H\" );\n\t\t    dump_print( G.ws.ws_row, G.ws.ws_col, G.num_cards );\n\t\t    fprintf( stderr, \"\\33[J\" );\n\t\t    fflush(stderr);\n\n\t\tpthread_mutex_unlock( &(G.mx_print) );\n\t    }\n\t    else\n\t\tsnprintf(G.message, sizeof(G.message), \"][ resumed output\");\n\t}\n\n\tif(keycode == KEY_r) {\n\t    G.do_sort_always = (G.do_sort_always+1)%2;\n\t    if(G.do_sort_always)\n\t\tsnprintf(G.message, sizeof(G.message), \"][ realtime sorting activated\");\n\t    else\n\t\tsnprintf(G.message, sizeof(G.message), \"][ realtime sorting deactivated\");\n\t}\n\n\tif(keycode == KEY_m) {\n\t    G.mark_cur_ap = 1;\n\t}\n\n\tif(keycode == KEY_ARROW_DOWN) {\n\t    if(G.selection_ap == 1) {\n\t\tG.selected_ap++;\n\t    }\n\t    if(G.selection_sta == 1) {\n\t\tG.selected_sta++;\n\t    }\n\t}\n\n\tif(keycode == KEY_ARROW_UP) {\n\t    if(G.selection_ap == 1) {\n\t\tG.selected_ap--;\n\t\tif(G.selected_ap < 1)\n\t\t    G.selected_ap = 1;\n\t    }\n\t    if(G.selection_sta == 1) {\n\t\tG.selected_sta--;\n\t\tif(G.selected_sta < 1)\n\t\t    G.selected_sta = 1;\n\t    }\n\t}\n\n\tif(keycode == KEY_i) {\n\t    G.sort_inv*=-1;\n\t    if(G.sort_inv < 0)\n\t\tsnprintf(G.message, sizeof(G.message), \"][ inverted sorting order\");\n\t    else\n\t\tsnprintf(G.message, sizeof(G.message), \"][ normal sorting order\");\n\t}\n\n\tif(keycode == KEY_TAB) {\n\t    if(G.selection_ap == 0) {\n\t\tG.selection_ap = 1;\n\t\tG.selected_ap = 1;\n\t\tsnprintf(G.message, sizeof(G.message), \"][ enabled AP selection\");\n\t\tG.sort_by = SORT_BY_NOTHING;\n\t    } else if(G.selection_ap == 1) {\n\t\tG.selection_ap = 0;\n\t\tG.sort_by = SORT_BY_NOTHING;\n\t\tsnprintf(G.message, sizeof(G.message), \"][ disabled selection\");\n\t    }\n\t}\n\n\tif(keycode == KEY_a) {\n\t    if(G.show_ap == 1 && G.show_sta == 1 && G.show_ack == 0) {\n\t\tG.show_ap = 1;\n\t\tG.show_sta = 1;\n\t\tG.show_ack = 1;\n\t\tsnprintf(G.message, sizeof(G.message), \"][ display ap+sta+ack\");\n\t    } else if(G.show_ap == 1 && G.show_sta == 1 && G.show_ack == 1) {\n\t\tG.show_ap = 1;\n\t\tG.show_sta = 0;\n\t\tG.show_ack = 0;\n\t\tsnprintf(G.message, sizeof(G.message), \"][ display ap only\");\n\t    } else if(G.show_ap == 1 && G.show_sta == 0 && G.show_ack == 0) {\n\t\tG.show_ap = 0;\n\t\tG.show_sta = 1;\n\t\tG.show_ack = 0;\n\t\tsnprintf(G.message, sizeof(G.message), \"][ display sta only\");\n\t    } else if(G.show_ap == 0 && G.show_sta == 1 && G.show_ack == 0) {\n\t\tG.show_ap = 1;\n\t\tG.show_sta = 1;\n\t\tG.show_ack = 0;\n\t\tsnprintf(G.message, sizeof(G.message), \"][ display ap+sta\");\n\t    }\n\t}\n\n\tif (keycode == KEY_d) {\n\t\tresetSelection();\n\t\tsnprintf(G.message, sizeof(G.message), \"][ reset selection to default\");\n\t}\n\n\tif(G.do_exit == 0 && !G.do_pause) {\n\t    pthread_mutex_lock( &(G.mx_print) );\n\n\t\tfprintf( stderr, \"\\33[1;1H\" );\n\t\tdump_print( G.ws.ws_row, G.ws.ws_col, G.num_cards );\n\t\tfprintf( stderr, \"\\33[J\" );\n\t\tfflush(stderr);\n\n\t    pthread_mutex_unlock( &(G.mx_print) );\n\t}\n    }\n}\n\nvoid trim(char *str)\n{\n    int i;\n    int begin = 0;\n    int end = strlen(str) - 1;\n\n    while (isspace((int)str[begin])) begin++;\n    while ((end >= begin) && isspace((int)str[end])) end--;\n    // Shift all characters back to the start of the string array.\n    for (i = begin; i <= end; i++)\n        str[i - begin] = str[i];\n    str[i - begin] = '\\0'; // Null terminate string.\n}\n\nstruct oui * load_oui_file(void) {\n\tFILE *fp;\n\tchar * manuf;\n\tchar buffer[BUFSIZ];\n\tunsigned char a[2];\n\tunsigned char b[2];\n\tunsigned char c[2];\n\tstruct oui *oui_ptr = NULL, *oui_head = NULL;\n\n\tif (!(fp = fopen(OUI_PATH0, \"r\"))) {\n\t\tif (!(fp = fopen(OUI_PATH1, \"r\"))) {\n\t\t\tif (!(fp = fopen(OUI_PATH2, \"r\"))) {\n\t\t\t\tif (!(fp = fopen(OUI_PATH3, \"r\"))) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(buffer, 0x00, sizeof(buffer));\n\twhile (fgets(buffer, sizeof(buffer), fp) != NULL) {\n\t\tif (!(strstr(buffer, \"(hex)\")))\n\t\t\tcontinue;\n\n\t\tmemset(a, 0x00, sizeof(a));\n\t\tmemset(b, 0x00, sizeof(b));\n\t\tmemset(c, 0x00, sizeof(c));\n\t\t// Remove leading/trailing whitespaces.\n\t\ttrim(buffer);\n\t\tif (sscanf(buffer, \"%2c-%2c-%2c\", a, b, c) == 3) {\n\t\t\tif (oui_ptr == NULL) {\n\t\t\t\tif (!(oui_ptr = (struct oui *)malloc(sizeof(struct oui)))) {\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\tperror(\"malloc failed\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!(oui_ptr->next = (struct oui *)malloc(sizeof(struct oui)))) {\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\tperror(\"malloc failed\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\toui_ptr = oui_ptr->next;\n\t\t\t}\n\t\t\tmemset(oui_ptr->id, 0x00, sizeof(oui_ptr->id));\n\t\t\tmemset(oui_ptr->manuf, 0x00, sizeof(oui_ptr->manuf));\n\t\t\tsnprintf(oui_ptr->id, sizeof(oui_ptr->id), \"%c%c:%c%c:%c%c\", a[0], a[1], b[0], b[1], c[0], c[1]);\n\t\t\tmanuf = get_manufacturer_from_string(buffer);\n\t\t\tif (manuf != NULL) {\n\t\t\t\tsnprintf(oui_ptr->manuf, sizeof(oui_ptr->manuf), \"%s\", manuf);\n\t\t\t\tfree(manuf);\n\t\t\t} else {\n\t\t\t\tsnprintf(oui_ptr->manuf, sizeof(oui_ptr->manuf), \"Unknown\");\n\t\t\t}\n\t\t\tif (oui_head == NULL)\n\t\t\t\toui_head = oui_ptr;\n\t\t\toui_ptr->next = NULL;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn oui_head;\n}\n\nint check_shared_key(unsigned char *h80211, int caplen)\n{\n    int m_bmac, m_smac, m_dmac, n, textlen;\n    char ofn[1024];\n    char text[4096];\n    char prga[4096];\n    unsigned int long crc;\n\n    if((unsigned)caplen > sizeof(G.sharedkey[0])) return 1;\n\n    m_bmac = 16;\n    m_smac = 10;\n    m_dmac = 4;\n\n    if( time(NULL) - G.sk_start > 5)\n    {\n        /* timeout(5sec) - remove all packets, restart timer */\n        memset(G.sharedkey, '\\x00', 4096*3);\n        G.sk_start = time(NULL);\n    }\n\n    /* is auth packet */\n    if( (h80211[1] & 0x40) != 0x40 )\n    {\n        /* not encrypted */\n        if( ( h80211[24] + (h80211[25] << 8) ) == 1 )\n        {\n            /* Shared-Key Authentication */\n            if( ( h80211[26] + (h80211[27] << 8) ) == 2 )\n            {\n                /* sequence == 2 */\n                memcpy(G.sharedkey[0], h80211, caplen);\n                G.sk_len = caplen-24;\n            }\n            if( ( h80211[26] + (h80211[27] << 8) ) == 4 )\n            {\n                /* sequence == 4 */\n                memcpy(G.sharedkey[2], h80211, caplen);\n            }\n        }\n        else return 1;\n    }\n    else\n    {\n        /* encrypted */\n        memcpy(G.sharedkey[1], h80211, caplen);\n        G.sk_len2 = caplen-24-4;\n    }\n\n    /* check if the 3 packets form a proper authentication */\n\n    if( ( memcmp(G.sharedkey[0]+m_bmac, NULL_MAC, 6) == 0 ) ||\n        ( memcmp(G.sharedkey[1]+m_bmac, NULL_MAC, 6) == 0 ) ||\n        ( memcmp(G.sharedkey[2]+m_bmac, NULL_MAC, 6) == 0 ) ) /* some bssids == zero */\n    {\n        return 1;\n    }\n\n    if( ( memcmp(G.sharedkey[0]+m_bmac, G.sharedkey[1]+m_bmac, 6) != 0 ) ||\n        ( memcmp(G.sharedkey[0]+m_bmac, G.sharedkey[2]+m_bmac, 6) != 0 ) ) /* all bssids aren't equal */\n    {\n        return 1;\n    }\n\n    if( ( memcmp(G.sharedkey[0]+m_smac, G.sharedkey[2]+m_smac, 6) != 0 ) ||\n        ( memcmp(G.sharedkey[0]+m_smac, G.sharedkey[1]+m_dmac, 6) != 0 ) ) /* SA in 2&4 != DA in 3 */\n    {\n        return 1;\n    }\n\n    if( (memcmp(G.sharedkey[0]+m_dmac, G.sharedkey[2]+m_dmac, 6) != 0 ) ||\n        (memcmp(G.sharedkey[0]+m_dmac, G.sharedkey[1]+m_smac, 6) != 0 ) ) /* DA in 2&4 != SA in 3 */\n    {\n        return 1;\n    }\n\n    textlen = G.sk_len;\n\n    if(textlen+4 != G.sk_len2)\n    {\n        snprintf(G.message, sizeof(G.message), \"][ Broken SKA: %02X:%02X:%02X:%02X:%02X:%02X \",\n                    *(G.sharedkey[0]+m_bmac), *(G.sharedkey[0]+m_bmac+1), *(G.sharedkey[0]+m_bmac+2),\n                *(G.sharedkey[0]+m_bmac+3), *(G.sharedkey[0]+m_bmac+4), *(G.sharedkey[0]+m_bmac+5));\n        return 1;\n    }\n\n    if((unsigned)textlen > sizeof(text) - 4) return 1;\n\n    memcpy(text, G.sharedkey[0]+24, textlen);\n\n    /* increment sequence number from 2 to 3 */\n    text[2] = text[2]+1;\n\n    crc = 0xFFFFFFFF;\n\n    for( n = 0; n < textlen; n++ )\n        crc = crc_tbl[(crc ^ text[n]) & 0xFF] ^ (crc >> 8);\n\n    crc = ~crc;\n\n    /* append crc32 over body */\n    text[textlen]     = (crc      ) & 0xFF;\n    text[textlen+1]   = (crc >>  8) & 0xFF;\n    text[textlen+2]   = (crc >> 16) & 0xFF;\n    text[textlen+3]   = (crc >> 24) & 0xFF;\n\n    /* cleartext XOR cipher */\n    for(n=0; n<(textlen+4); n++)\n    {\n        prga[4+n] = (text[n] ^ G.sharedkey[1][28+n]) & 0xFF;\n    }\n\n    /* write IV+index */\n    prga[0] = G.sharedkey[1][24] & 0xFF;\n    prga[1] = G.sharedkey[1][25] & 0xFF;\n    prga[2] = G.sharedkey[1][26] & 0xFF;\n    prga[3] = G.sharedkey[1][27] & 0xFF;\n\n    if( G.f_xor != NULL )\n    {\n        fclose(G.f_xor);\n        G.f_xor = NULL;\n    }\n\n    snprintf( ofn, sizeof( ofn ) - 1, \"%s-%02d-%02X-%02X-%02X-%02X-%02X-%02X.%s\", G.prefix, G.f_index,\n              *(G.sharedkey[0]+m_bmac), *(G.sharedkey[0]+m_bmac+1), *(G.sharedkey[0]+m_bmac+2),\n              *(G.sharedkey[0]+m_bmac+3), *(G.sharedkey[0]+m_bmac+4), *(G.sharedkey[0]+m_bmac+5), \"xor\" );\n\n    G.f_xor = fopen( ofn, \"w\");\n    if(G.f_xor == NULL)\n        return 1;\n\n    for(n=0; n<textlen+8; n++)\n        fputc((prga[n] & 0xFF), G.f_xor);\n\n    fflush(G.f_xor);\n\n    if( G.f_xor != NULL )\n    {\n        fclose(G.f_xor);\n        G.f_xor = NULL;\n    }\n\n    snprintf(G.message, sizeof(G.message), \"][ %d bytes keystream: %02X:%02X:%02X:%02X:%02X:%02X \",\n                textlen+4, *(G.sharedkey[0]+m_bmac), *(G.sharedkey[0]+m_bmac+1), *(G.sharedkey[0]+m_bmac+2),\n              *(G.sharedkey[0]+m_bmac+3), *(G.sharedkey[0]+m_bmac+4), *(G.sharedkey[0]+m_bmac+5));\n\n    memset(G.sharedkey, '\\x00', 512*3);\n    /* ok, keystream saved */\n    return 0;\n}\n\nchar usage[] =\n\n\"\\n\"\n\"  %s - (C) 2006-2013 Thomas d\\'Otreppe\\n\"\n\"  http://www.aircrack-ng.org\\n\"\n\"\\n\"\n\"  usage: airodump-ng <options> <interface>[,<interface>,...]\\n\"\n\"\\n\"\n\"  Options:\\n\"\n\"      --ivs                 : Save only captured IVs\\n\"\n\"      --gpsd                : Use GPSd\\n\"\n\"      --write      <prefix> : Dump file prefix\\n\"\n\"      -w                    : same as --write \\n\"\n\"      --beacons             : Record all beacons in dump file\\n\"\n\"      --update       <secs> : Display update delay in seconds\\n\"\n\"      --showack             : Prints ack/cts/rts statistics\\n\"\n\"      -h                    : Hides known stations for --showack\\n\"\n\"      -f            <msecs> : Time in ms between hopping channels\\n\"\n\"      --berlin       <secs> : Time before removing the AP/client\\n\"\n\"                              from the screen when no more packets\\n\"\n\"                              are received (Default: 120 seconds)\\n\"\n\"      -r             <file> : Read packets from that file\\n\"\n\"      -x            <msecs> : Active Scanning Simulation\\n\"\n\"      --manufacturer        : Display manufacturer from IEEE OUI list\\n\"\n\"      --uptime              : Display AP Uptime from Beacon Timestamp\\n\"\n\"      --output-format\\n\"\n\"                  <formats> : Output format. Possible values:\\n\"\n\"                              pcap, ivs, csv, gps, kismet, netxml\\n\"\n\"      --ignore-negative-one : Removes the message that says\\n\"\n\"                              fixed channel <interface>: -1\\n\"\n\"\\n\"\n\"  Filter options:\\n\"\n\"      --encrypt   <suite>   : Filter APs by cipher suite\\n\"\n\"      --netmask <netmask>   : Filter APs by mask\\n\"\n\"      --bssid     <bssid>   : Filter APs by BSSID\\n\"\n\"      --essid     <essid>   : Filter APs by ESSID\\n\"\n#ifdef HAVE_PCRE\n\"      --essid-regex <regex> : Filter APs by ESSID using a regular\\n\"\n\"                              expression\\n\"\n#endif\n\"      -a                    : Filter unassociated clients\\n\"\n\"\\n\"\n\"  By default, airodump-ng hop on 2.4GHz channels.\\n\"\n\"  You can make it capture on other/specific channel(s) by using:\\n\"\n\"      --channel <channels>  : Capture on specific channels\\n\"\n\"      --band <abg>          : Band on which airodump-ng should hop\\n\"\n\"      -C    <frequencies>   : Uses these frequencies in MHz to hop\\n\"\n\"      --cswitch  <method>   : Set channel switching method\\n\"\n\"                    0       : FIFO (default)\\n\"\n\"                    1       : Round Robin\\n\"\n\"                    2       : Hop on last\\n\"\n\"      -s                    : same as --cswitch\\n\"\n\"\\n\"\n\"      --help                : Displays this usage screen\\n\"\n\"\\n\";\n\nint is_filtered_netmask(unsigned char *bssid)\n{\n    unsigned char mac1[6];\n    unsigned char mac2[6];\n    int i;\n\n    for(i=0; i<6; i++)\n    {\n        mac1[i] = bssid[i]     & G.f_netmask[i];\n        mac2[i] = G.f_bssid[i] & G.f_netmask[i];\n    }\n\n    if( memcmp(mac1, mac2, 6) != 0 )\n    {\n        return( 1 );\n    }\n\n    return 0;\n}\n\nint is_filtered_essid(unsigned char *essid)\n{\n    int ret = 0;\n    int i;\n\n    if(G.f_essid)\n    {\n        for(i=0; i<G.f_essid_count; i++)\n        {\n            if(strncmp((char*)essid, G.f_essid[i], MAX_IE_ELEMENT_SIZE) == 0)\n            {\n                return 0;\n            }\n        }\n\n        ret = 1;\n    }\n\n#ifdef HAVE_PCRE\n    if(G.f_essid_regex)\n    {\n        return pcre_exec(G.f_essid_regex, NULL, (char*)essid, strnlen((char *)essid, MAX_IE_ELEMENT_SIZE), 0, 0, NULL, 0) < 0;\n    }\n#endif\n\n    return ret;\n}\n\nvoid update_rx_quality( )\n{\n    unsigned int time_diff, capt_time, miss_time;\n    int missed_frames;\n    struct AP_info *ap_cur = NULL;\n    struct ST_info *st_cur = NULL;\n    struct timeval cur_time;\n\n    ap_cur = G.ap_1st;\n    st_cur = G.st_1st;\n\n    gettimeofday( &cur_time, NULL );\n\n    /* accesspoints */\n    while( ap_cur != NULL )\n    {\n        time_diff = 1000000 * (cur_time.tv_sec  - ap_cur->ftimer.tv_sec )\n                            + (cur_time.tv_usec - ap_cur->ftimer.tv_usec);\n\n        /* update every `QLT_TIME`seconds if the rate is low, or every 500ms otherwise */\n        if( (ap_cur->fcapt >= QLT_COUNT && time_diff > 500000 ) || time_diff > (QLT_TIME * 1000000) )\n        {\n            /* at least one frame captured */\n            if(ap_cur->fcapt > 1)\n            {\n                capt_time =   ( 1000000 * (ap_cur->ftimel.tv_sec  - ap_cur->ftimef.tv_sec )    //time between first and last captured frame\n                                        + (ap_cur->ftimel.tv_usec - ap_cur->ftimef.tv_usec) );\n\n                miss_time =   ( 1000000 * (ap_cur->ftimef.tv_sec  - ap_cur->ftimer.tv_sec )    //time between timer reset and first frame\n                                        + (ap_cur->ftimef.tv_usec - ap_cur->ftimer.tv_usec) )\n                            + ( 1000000 * (cur_time.tv_sec  - ap_cur->ftimel.tv_sec )          //time between last frame and this moment\n                                        + (cur_time.tv_usec - ap_cur->ftimel.tv_usec) );\n\n                //number of frames missed at the time where no frames were captured; extrapolated by assuming a constant framerate\n                if(capt_time > 0 && miss_time > 200000)\n                {\n                    missed_frames = ((float)((float)miss_time/(float)capt_time) * ((float)ap_cur->fcapt + (float)ap_cur->fmiss));\n                    ap_cur->fmiss += missed_frames;\n                }\n\n                ap_cur->rx_quality = ((float)((float)ap_cur->fcapt / ((float)ap_cur->fcapt + (float)ap_cur->fmiss)) * 100.0);\n            }\n            else ap_cur->rx_quality = 0; /* no packets -> zero quality */\n\n            /* normalize, in case the seq numbers are not iterating */\n            if(ap_cur->rx_quality > 100) ap_cur->rx_quality = 100;\n            if(ap_cur->rx_quality < 0  ) ap_cur->rx_quality =   0;\n\n            /* reset variables */\n            ap_cur->fcapt = 0;\n            ap_cur->fmiss = 0;\n            gettimeofday( &(ap_cur->ftimer) ,NULL);\n        }\n        ap_cur = ap_cur->next;\n    }\n\n    /* stations */\n    while( st_cur != NULL )\n    {\n        time_diff = 1000000 * (cur_time.tv_sec  - st_cur->ftimer.tv_sec )\n                            + (cur_time.tv_usec - st_cur->ftimer.tv_usec);\n\n        if( time_diff > 10000000 )\n        {\n            st_cur->missed = 0;\n            gettimeofday( &(st_cur->ftimer), NULL );\n        }\n\n        st_cur = st_cur->next;\n    }\n\n}\n\n/* setup the output files */\n\nint dump_initialize( char *prefix, int ivs_only )\n{\n    int i, ofn_len;\n    FILE *f;\n    char * ofn = NULL;\n\n\n    /* If you only want to see what happening, send all data to /dev/null */\n\n    if ( prefix == NULL || strlen( prefix ) == 0) {\n\t    return( 0 );\n    }\n\n\t/* Create a buffer of the length of the prefix + '-' + 2 numbers + '.'\n\t   + longest extension (\"kismet.netxml\") + terminating 0. */\n\tofn_len = strlen(prefix) + 1 + 2 + 1 + 13 + 1;\n\tofn = (char *)calloc(1, ofn_len);\n\n    G.f_index = 1;\n\n\n\t/* Make sure no file with the same name & all possible file extensions. */\n    do\n    {\n        for( i = 0; i < NB_EXTENSIONS; i++ )\n        {\n\t\t\tmemset(ofn, 0, ofn_len);\n            snprintf( ofn,  ofn_len, \"%s-%02d.%s\",\n                      prefix, G.f_index, f_ext[i] );\n\n            if( ( f = fopen( ofn, \"rb+\" ) ) != NULL )\n            {\n                fclose( f );\n                G.f_index++;\n                break;\n            }\n        }\n    }\n    /* If we did all extensions then no file with that name or extension exist\n       so we can use that number */\n    while( i < NB_EXTENSIONS );\n\n    G.prefix = (char *) malloc(strlen(prefix) + 1);\n    memcpy(G.prefix, prefix, strlen(prefix) + 1);\n\n    /* create the output CSV file */\n\n\tif (G.output_format_csv) {\n\t\tmemset(ofn, 0, ofn_len);\n\t\tsnprintf( ofn,  ofn_len, \"%s-%02d.%s\",\n\t\t\t\t  prefix, G.f_index, AIRODUMP_NG_CSV_EXT );\n\n\t\tif( ( G.f_txt = fopen( ofn, \"wb+\" ) ) == NULL )\n\t\t{\n\t\t\tperror( \"fopen failed\" );\n\t\t\tfprintf( stderr, \"Could not create \\\"%s\\\".\\n\", ofn );\n\t\t\tfree( ofn );\n\t\t\treturn( 1 );\n\t\t}\n\t}\n\n    /* create the output Kismet CSV file */\n\tif (G.output_format_kismet_csv) {\n\t\tmemset(ofn, 0, ofn_len);\n\t\tsnprintf( ofn,  ofn_len, \"%s-%02d.%s\",\n\t\t\t\t  prefix, G.f_index, KISMET_CSV_EXT );\n\n\t\tif( ( G.f_kis = fopen( ofn, \"wb+\" ) ) == NULL )\n\t\t{\n\t\t\tperror( \"fopen failed\" );\n\t\t\tfprintf( stderr, \"Could not create \\\"%s\\\".\\n\", ofn );\n\t\t\tfree( ofn );\n\t\t\treturn( 1 );\n\t\t}\n\t}\n\n\t/* create the output GPS file */\n\n    if (G.usegpsd)\n    {\n        memset(ofn, 0, ofn_len);\n        snprintf( ofn,  ofn_len, \"%s-%02d.%s\",\n                  prefix, G.f_index, AIRODUMP_NG_GPS_EXT );\n\n        if( ( G.f_gps = fopen( ofn, \"wb+\" ) ) == NULL )\n        {\n            perror( \"fopen failed\" );\n            fprintf( stderr, \"Could not create \\\"%s\\\".\\n\", ofn );\n            free( ofn );\n            return( 1 );\n        }\n    }\n\n    /* Create the output kismet.netxml file */\n\n\tif (G.output_format_kismet_netxml) {\n\t\tmemset(ofn, 0, ofn_len);\n\t\tsnprintf( ofn,  ofn_len, \"%s-%02d.%s\",\n\t\t\t\t  prefix, G.f_index, KISMET_NETXML_EXT );\n\n\t\tif( ( G.f_kis_xml = fopen( ofn, \"wb+\" ) ) == NULL )\n\t\t{\n\t\t\tperror( \"fopen failed\" );\n\t\t\tfprintf( stderr, \"Could not create \\\"%s\\\".\\n\", ofn );\n\t\t\tfree( ofn );\n\t\t\treturn( 1 );\n\t\t}\n\t}\n\n    /* create the output packet capture file */\n    if( G.output_format_pcap )\n    {\n        struct pcap_file_header pfh;\n\n        memset(ofn, 0, ofn_len);\n        snprintf( ofn,  ofn_len, \"%s-%02d.%s\",\n                  prefix, G.f_index, AIRODUMP_NG_CAP_EXT );\n\n        if( ( G.f_cap = fopen( ofn, \"wb+\" ) ) == NULL )\n        {\n            perror( \"fopen failed\" );\n            fprintf( stderr, \"Could not create \\\"%s\\\".\\n\", ofn );\n            free( ofn );\n            return( 1 );\n        }\n\n        G.f_cap_name = (char *) malloc( strlen( ofn ) + 1 );\n        memcpy( G.f_cap_name, ofn, strlen( ofn ) + 1 );\n        free( ofn );\n\n        pfh.magic           = TCPDUMP_MAGIC;\n        pfh.version_major   = PCAP_VERSION_MAJOR;\n        pfh.version_minor   = PCAP_VERSION_MINOR;\n        pfh.thiszone        = 0;\n        pfh.sigfigs         = 0;\n        pfh.snaplen         = 65535;\n        pfh.linktype        = LINKTYPE_IEEE802_11;\n\n        if( fwrite( &pfh, 1, sizeof( pfh ), G.f_cap ) !=\n                    (size_t) sizeof( pfh ) )\n        {\n            perror( \"fwrite(pcap file header) failed\" );\n            return( 1 );\n        }\n    } else if ( ivs_only ) {\n        struct ivs2_filehdr fivs2;\n\n        fivs2.version = IVS2_VERSION;\n\n        memset(ofn, 0, ofn_len);\n        snprintf( ofn,  ofn_len, \"%s-%02d.%s\",\n                  prefix, G.f_index, IVS2_EXTENSION );\n\n        if( ( G.f_ivs = fopen( ofn, \"wb+\" ) ) == NULL )\n        {\n            perror( \"fopen failed\" );\n            fprintf( stderr, \"Could not create \\\"%s\\\".\\n\", ofn );\n            free( ofn );\n            return( 1 );\n        }\n        free( ofn );\n\n        if( fwrite( IVS2_MAGIC, 1, 4, G.f_ivs ) != (size_t) 4 )\n        {\n            perror( \"fwrite(IVs file MAGIC) failed\" );\n            return( 1 );\n        }\n\n        if( fwrite( &fivs2, 1, sizeof(struct ivs2_filehdr), G.f_ivs ) != (size_t) sizeof(struct ivs2_filehdr) )\n        {\n            perror( \"fwrite(IVs file header) failed\" );\n            return( 1 );\n        }\n    }\n\n    return( 0 );\n}\n\nint update_dataps()\n{\n    struct timeval tv;\n    struct AP_info *ap_cur;\n    struct NA_info *na_cur;\n    int sec, usec, diff, ps;\n    float pause;\n\n    gettimeofday(&tv, NULL);\n\n    ap_cur = G.ap_end;\n\n    while( ap_cur != NULL )\n    {\n        sec = (tv.tv_sec - ap_cur->tv.tv_sec);\n        usec = (tv.tv_usec - ap_cur->tv.tv_usec);\n        pause = (((float)(sec*1000000.0f + usec))/(1000000.0f));\n        if( pause > 2.0f )\n        {\n            diff = ap_cur->nb_data - ap_cur->nb_data_old;\n            ps = (int)(((float)diff)/pause);\n            ap_cur->nb_dataps = ps;\n            ap_cur->nb_data_old = ap_cur->nb_data;\n            gettimeofday(&(ap_cur->tv), NULL);\n        }\n        ap_cur = ap_cur->prev;\n    }\n\n    na_cur = G.na_1st;\n\n    while( na_cur != NULL )\n    {\n        sec = (tv.tv_sec - na_cur->tv.tv_sec);\n        usec = (tv.tv_usec - na_cur->tv.tv_usec);\n        pause = (((float)(sec*1000000.0f + usec))/(1000000.0f));\n        if( pause > 2.0f )\n        {\n            diff = na_cur->ack - na_cur->ack_old;\n            ps = (int)(((float)diff)/pause);\n            na_cur->ackps = ps;\n            na_cur->ack_old = na_cur->ack;\n            gettimeofday(&(na_cur->tv), NULL);\n        }\n        na_cur = na_cur->next;\n    }\n    return(0);\n}\n\nint list_tail_free(struct pkt_buf **list)\n{\n    struct pkt_buf **pkts;\n    struct pkt_buf *next;\n\n    if(list == NULL) return 1;\n\n    pkts = list;\n\n    while(*pkts != NULL)\n    {\n        next = (*pkts)->next;\n        if( (*pkts)->packet )\n        {\n            free( (*pkts)->packet);\n            (*pkts)->packet=NULL;\n        }\n\n        if(*pkts)\n        {\n            free(*pkts);\n            *pkts = NULL;\n        }\n        *pkts = next;\n    }\n\n    *list=NULL;\n\n    return 0;\n}\n\nint list_add_packet(struct pkt_buf **list, int length, unsigned char* packet)\n{\n    struct pkt_buf *next = *list;\n\n    if(length <= 0) return 1;\n    if(packet == NULL) return 1;\n    if(list == NULL) return 1;\n\n    *list = (struct pkt_buf*) malloc(sizeof(struct pkt_buf));\n    if( *list == NULL ) return 1;\n    (*list)->packet = (unsigned char*) malloc(length);\n    if( (*list)->packet == NULL ) return 1;\n\n    memcpy((*list)->packet,  packet, length);\n    (*list)->next = next;\n    (*list)->length = length;\n    gettimeofday( &((*list)->ctime), NULL);\n\n    return 0;\n}\n\n/*\n * Check if the same IV was used if the first two bytes were the same.\n * If they are not identical, it would complain.\n * The reason is that the first two bytes unencrypted are 'aa'\n * so with the same IV it should always be encrypted to the same thing.\n */\nint list_check_decloak(struct pkt_buf **list, int length, unsigned char* packet)\n{\n    struct pkt_buf *next = *list;\n    struct timeval tv1;\n    int timediff;\n    int i, correct;\n\n    if( packet == NULL) return 1;\n    if( list == NULL ) return 1;\n    if( *list == NULL ) return 1;\n    if( length <= 0) return 1;\n\n    gettimeofday(&tv1, NULL);\n\n    timediff = (((tv1.tv_sec - ((*list)->ctime.tv_sec)) * 1000000) + (tv1.tv_usec - ((*list)->ctime.tv_usec))) / 1000;\n    if( timediff > BUFFER_TIME )\n    {\n        list_tail_free(list);\n        next=NULL;\n    }\n\n    while(next != NULL)\n    {\n        if(next->next != NULL)\n        {\n            timediff = (((tv1.tv_sec - (next->next->ctime.tv_sec)) * 1000000) + (tv1.tv_usec - (next->next->ctime.tv_usec))) / 1000;\n            if( timediff > BUFFER_TIME )\n            {\n                list_tail_free(&(next->next));\n                break;\n            }\n        }\n        if( (next->length + 4) == length)\n        {\n            correct = 1;\n            // check for 4 bytes added after the end\n            for(i=28;i<length-28;i++)   //check everything (in the old packet) after the IV (including crc32 at the end)\n            {\n                if(next->packet[i] != packet[i])\n                {\n                    correct = 0;\n                    break;\n                }\n            }\n            if(!correct)\n            {\n                correct = 1;\n                // check for 4 bytes added at the beginning\n                for(i=28;i<length-28;i++)   //check everything (in the old packet) after the IV (including crc32 at the end)\n                {\n                    if(next->packet[i] != packet[4+i])\n                    {\n                        correct = 0;\n                        break;\n                    }\n                }\n            }\n            if(correct == 1)\n                    return 0;   //found decloaking!\n        }\n        next = next->next;\n    }\n\n    return 1; //didn't find decloak\n}\n\nint remove_namac(unsigned char* mac)\n{\n    struct NA_info *na_cur = NULL;\n    struct NA_info *na_prv = NULL;\n\n    if(mac == NULL)\n        return( -1 );\n\n    na_cur = G.na_1st;\n    na_prv = NULL;\n\n    while( na_cur != NULL )\n    {\n        if( ! memcmp( na_cur->namac, mac, 6 ) )\n            break;\n\n        na_prv = na_cur;\n        na_cur = na_cur->next;\n    }\n\n    /* if it's known, remove it */\n    if( na_cur != NULL )\n    {\n        /* first in linked list */\n        if(na_cur == G.na_1st)\n        {\n            G.na_1st = na_cur->next;\n        }\n        else\n        {\n            na_prv->next = na_cur->next;\n        }\n        free(na_cur);\n        na_cur=NULL;\n    }\n\n    return( 0 );\n}\n\nint dump_add_packet( unsigned char *h80211, int caplen, struct rx_info *ri, int cardnum )\n{\n    int i, n, seq, msd, dlen, offset, clen, o;\n    unsigned z;\n    int type, length, numuni=0, numauth=0;\n    struct pcap_pkthdr pkh;\n    struct timeval tv;\n    struct ivs2_pkthdr ivs2;\n    unsigned char *p, *org_p, c;\n    unsigned char bssid[6];\n    unsigned char stmac[6];\n    unsigned char namac[6];\n    unsigned char clear[2048];\n    int weight[16];\n    int num_xor=0;\n\n    struct AP_info *ap_cur = NULL;\n    struct ST_info *st_cur = NULL;\n    struct NA_info *na_cur = NULL;\n    struct AP_info *ap_prv = NULL;\n    struct ST_info *st_prv = NULL;\n    struct NA_info *na_prv = NULL;\n\n    /* skip all non probe response frames in active scanning simulation mode */\n    if( G.active_scan_sim > 0 && h80211[0] != 0x50 )\n        return(0);\n\n    /* skip packets smaller than a 802.11 header */\n\n    if( caplen < 24 )\n        goto write_packet;\n\n    /* skip (uninteresting) control frames */\n\n    if( ( h80211[0] & 0x0C ) == 0x04 )\n        goto write_packet;\n\n    /* if it's a LLC null packet, just forget it (may change in the future) */\n\n    if ( caplen > 28)\n        if ( memcmp(h80211 + 24, llcnull, 4) == 0)\n            return ( 0 );\n\n    /* grab the sequence number */\n    seq = ((h80211[22]>>4)+(h80211[23]<<4));\n\n    /* locate the access point's MAC address */\n\n    switch( h80211[1] & 3 )\n    {\n        case  0: memcpy( bssid, h80211 + 16, 6 ); break;  //Adhoc\n        case  1: memcpy( bssid, h80211 +  4, 6 ); break;  //ToDS\n        case  2: memcpy( bssid, h80211 + 10, 6 ); break;  //FromDS\n        case  3: memcpy( bssid, h80211 + 10, 6 ); break;  //WDS -> Transmitter taken as BSSID\n    }\n\n    if( memcmp(G.f_bssid, NULL_MAC, 6) != 0 )\n    {\n        if( memcmp(G.f_netmask, NULL_MAC, 6) != 0 )\n        {\n            if(is_filtered_netmask(bssid)) return(1);\n        }\n        else\n        {\n            if( memcmp(G.f_bssid, bssid, 6) != 0 ) return(1);\n        }\n    }\n\n    /* update our chained list of access points */\n\n    ap_cur = G.ap_1st;\n    ap_prv = NULL;\n\n    while( ap_cur != NULL )\n    {\n        if( ! memcmp( ap_cur->bssid, bssid, 6 ) )\n            break;\n\n        ap_prv = ap_cur;\n        ap_cur = ap_cur->next;\n    }\n\n    /* if it's a new access point, add it */\n\n    if( ap_cur == NULL )\n    {\n        if( ! ( ap_cur = (struct AP_info *) malloc(\n                         sizeof( struct AP_info ) ) ) )\n        {\n            perror( \"malloc failed\" );\n            return( 1 );\n        }\n\n        /* if mac is listed as unknown, remove it */\n        remove_namac(bssid);\n\n        memset( ap_cur, 0, sizeof( struct AP_info ) );\n\n        if( G.ap_1st == NULL )\n            G.ap_1st = ap_cur;\n        else\n            ap_prv->next  = ap_cur;\n\n        memcpy( ap_cur->bssid, bssid, 6 );\n\t\tif (ap_cur->manuf == NULL) {\n\t\t\tap_cur->manuf = get_manufacturer(ap_cur->bssid[0], ap_cur->bssid[1], ap_cur->bssid[2]);\n\t\t}\n\n        ap_cur->prev = ap_prv;\n\n        ap_cur->tinit = time( NULL );\n        ap_cur->tlast = time( NULL );\n\n        ap_cur->avg_power   = -1;\n        ap_cur->best_power  = -1;\n        ap_cur->power_index = -1;\n\n        for( i = 0; i < NB_PWR; i++ )\n            ap_cur->power_lvl[i] = -1;\n\n        ap_cur->channel    = -1;\n        ap_cur->max_speed  = -1;\n        ap_cur->security   = 0;\n\n        ap_cur->uiv_root = uniqueiv_init();\n\n        ap_cur->nb_dataps = 0;\n        ap_cur->nb_data_old = 0;\n        gettimeofday(&(ap_cur->tv), NULL);\n\n        ap_cur->dict_started = 0;\n\n        ap_cur->key = NULL;\n\n        G.ap_end = ap_cur;\n\n        ap_cur->nb_bcn     = 0;\n\n        ap_cur->rx_quality = 0;\n        ap_cur->fcapt      = 0;\n        ap_cur->fmiss      = 0;\n        ap_cur->last_seq   = 0;\n        gettimeofday( &(ap_cur->ftimef), NULL);\n        gettimeofday( &(ap_cur->ftimel), NULL);\n        gettimeofday( &(ap_cur->ftimer), NULL);\n\n        ap_cur->ssid_length = 0;\n        ap_cur->essid_stored = 0;\n        ap_cur->timestamp = 0;\n\n        ap_cur->decloak_detect=G.decloak;\n        ap_cur->is_decloak = 0;\n        ap_cur->packets = NULL;\n\n\tap_cur->marked = 0;\n\tap_cur->marked_color = 1;\n\n        ap_cur->data_root = NULL;\n        ap_cur->EAP_detected = 0;\n        memcpy(ap_cur->gps_loc_min, G.gps_loc, sizeof(float)*5);\n        memcpy(ap_cur->gps_loc_max, G.gps_loc, sizeof(float)*5);\n        memcpy(ap_cur->gps_loc_best, G.gps_loc, sizeof(float)*5);\n    }\n\n    /* update the last time seen */\n\n    ap_cur->tlast = time( NULL );\n\n    /* only update power if packets comes from\n     * the AP: either type == mgmt and SA != BSSID,\n     * or FromDS == 1 and ToDS == 0 */\n\n    if( ( ( h80211[1] & 3 ) == 0 &&\n            memcmp( h80211 + 10, bssid, 6 ) == 0 ) ||\n        ( ( h80211[1] & 3 ) == 2 ) )\n    {\n        ap_cur->power_index = ( ap_cur->power_index + 1 ) % NB_PWR;\n        ap_cur->power_lvl[ap_cur->power_index] = ri->ri_power;\n\n        ap_cur->avg_power = 0;\n\n        for( i = 0, n = 0; i < NB_PWR; i++ )\n        {\n            if( ap_cur->power_lvl[i] != -1 )\n            {\n                ap_cur->avg_power += ap_cur->power_lvl[i];\n                n++;\n            }\n        }\n\n        if( n > 0 )\n        {\n            ap_cur->avg_power /= n;\n            if( ap_cur->avg_power > ap_cur->best_power )\n            {\n                ap_cur->best_power = ap_cur->avg_power;\n                memcpy(ap_cur->gps_loc_best, G.gps_loc, sizeof(float)*5);\n            }\n        }\n        else\n            ap_cur->avg_power = -1;\n\n        /* every packet in here comes from the AP */\n\n        if(G.gps_loc[0] > ap_cur->gps_loc_max[0])\n            ap_cur->gps_loc_max[0] = G.gps_loc[0];\n        if(G.gps_loc[1] > ap_cur->gps_loc_max[1])\n            ap_cur->gps_loc_max[1] = G.gps_loc[1];\n        if(G.gps_loc[2] > ap_cur->gps_loc_max[2])\n            ap_cur->gps_loc_max[2] = G.gps_loc[2];\n\n        if(G.gps_loc[0] < ap_cur->gps_loc_min[0])\n            ap_cur->gps_loc_min[0] = G.gps_loc[0];\n        if(G.gps_loc[1] < ap_cur->gps_loc_min[1])\n            ap_cur->gps_loc_min[1] = G.gps_loc[1];\n        if(G.gps_loc[2] < ap_cur->gps_loc_min[2])\n            ap_cur->gps_loc_min[2] = G.gps_loc[2];\n//        printf(\"seqnum: %i\\n\", seq);\n\n        if(ap_cur->fcapt == 0 && ap_cur->fmiss == 0) gettimeofday( &(ap_cur->ftimef), NULL);\n        if(ap_cur->last_seq != 0) ap_cur->fmiss += (seq - ap_cur->last_seq - 1);\n        ap_cur->last_seq = seq;\n        ap_cur->fcapt++;\n        gettimeofday( &(ap_cur->ftimel), NULL);\n\n//         if(ap_cur->fcapt >= QLT_COUNT) update_rx_quality();\n    }\n\n    if( h80211[0] == 0x80 )\n    {\n        ap_cur->nb_bcn++;\n    }\n\n    ap_cur->nb_pkt++;\n\n    /* find wpa handshake */\n    if( h80211[0] == 0x10 )\n    {\n        /* reset the WPA handshake state */\n\n        if( st_cur != NULL && st_cur->wpa.state != 0xFF )\n            st_cur->wpa.state = 0;\n//        printf(\"initial auth %d\\n\", ap_cur->wpa_state);\n    }\n\n    /* locate the station MAC in the 802.11 header */\n\n    switch( h80211[1] & 3 )\n    {\n        case  0:\n\n            /* if management, check that SA != BSSID */\n\n            if( memcmp( h80211 + 10, bssid, 6 ) == 0 )\n                goto skip_station;\n\n            memcpy( stmac, h80211 + 10, 6 );\n            break;\n\n        case  1:\n\n            /* ToDS packet, must come from a client */\n\n            memcpy( stmac, h80211 + 10, 6 );\n            break;\n\n        case  2:\n\n            /* FromDS packet, reject broadcast MACs */\n\n            if( (h80211[4]%2) != 0 ) goto skip_station;\n            memcpy( stmac, h80211 +  4, 6 ); break;\n\n        default: goto skip_station;\n    }\n\n    /* update our chained list of wireless stations */\n\n    st_cur = G.st_1st;\n    st_prv = NULL;\n\n    while( st_cur != NULL )\n    {\n        if( ! memcmp( st_cur->stmac, stmac, 6 ) )\n            break;\n\n        st_prv = st_cur;\n        st_cur = st_cur->next;\n    }\n\n    /* if it's a new client, add it */\n\n    if( st_cur == NULL )\n    {\n        if( ! ( st_cur = (struct ST_info *) malloc(\n                         sizeof( struct ST_info ) ) ) )\n        {\n            perror( \"malloc failed\" );\n            return( 1 );\n        }\n\n        /* if mac is listed as unknown, remove it */\n        remove_namac(stmac);\n\n        memset( st_cur, 0, sizeof( struct ST_info ) );\n\n        if( G.st_1st == NULL )\n            G.st_1st = st_cur;\n        else\n            st_prv->next  = st_cur;\n\n        memcpy( st_cur->stmac, stmac, 6 );\n\n\t\tif (st_cur->manuf == NULL) {\n\t\t\tst_cur->manuf = get_manufacturer(st_cur->stmac[0], st_cur->stmac[1], st_cur->stmac[2]);\n\t\t}\n\n        st_cur->prev = st_prv;\n\n        st_cur->tinit = time( NULL );\n        st_cur->tlast = time( NULL );\n\n        st_cur->power = -1;\n        st_cur->rate_to = -1;\n        st_cur->rate_from = -1;\n\n        st_cur->probe_index = -1;\n        st_cur->missed  = 0;\n        st_cur->lastseq = 0;\n        st_cur->qos_fr_ds = 0;\n        st_cur->qos_to_ds = 0;\n        gettimeofday( &(st_cur->ftimer), NULL);\n\n        for( i = 0; i < NB_PRB; i++ )\n        {\n            memset( st_cur->probes[i], 0, sizeof(\n                    st_cur->probes[i] ) );\n            st_cur->ssid_length[i] = 0;\n        }\n\n        G.st_end = st_cur;\n    }\n\n    if( st_cur->base == NULL ||\n        memcmp( ap_cur->bssid, BROADCAST, 6 ) != 0 )\n        st_cur->base = ap_cur;\n\n    //update bitrate to station\n    if( (st_cur != NULL) && ( h80211[1] & 3 ) == 2 )\n        st_cur->rate_to = ri->ri_rate;\n\n    /* update the last time seen */\n\n    st_cur->tlast = time( NULL );\n\n    /* only update power if packets comes from the\n     * client: either type == Mgmt and SA != BSSID,\n     * or FromDS == 0 and ToDS == 1 */\n\n    if( ( ( h80211[1] & 3 ) == 0 &&\n            memcmp( h80211 + 10, bssid, 6 ) != 0 ) ||\n        ( ( h80211[1] & 3 ) == 1 ) )\n    {\n        st_cur->power = ri->ri_power;\n        st_cur->rate_from = ri->ri_rate;\n\n        if(st_cur->lastseq != 0)\n        {\n            msd = seq - st_cur->lastseq - 1;\n            if(msd > 0 && msd < 1000)\n                st_cur->missed += msd;\n        }\n        st_cur->lastseq = seq;\n    }\n\n    st_cur->nb_pkt++;\n\nskip_station:\n\n    /* packet parsing: Probe Request */\n\n    if( h80211[0] == 0x40 && st_cur != NULL )\n    {\n        p = h80211 + 24;\n\n        while( p < h80211 + caplen )\n        {\n            if( p + 2 + p[1] > h80211 + caplen )\n                break;\n\n            if( p[0] == 0x00 && p[1] > 0 && p[2] != '\\0' &&\n                ( p[1] > 1 || p[2] != ' ' ) )\n            {\n//                n = ( p[1] > 32 ) ? 32 : p[1];\n                n = p[1];\n\n                for( i = 0; i < n; i++ )\n                    if( p[2 + i] > 0 && p[2 + i] < ' ' )\n                        goto skip_probe;\n\n                /* got a valid ASCII probed ESSID, check if it's\n                   already in the ring buffer */\n\n                for( i = 0; i < NB_PRB; i++ )\n                    if( memcmp( st_cur->probes[i], p + 2, n ) == 0 )\n                        goto skip_probe;\n\n                st_cur->probe_index = ( st_cur->probe_index + 1 ) % NB_PRB;\n                memset( st_cur->probes[st_cur->probe_index], 0, 256 );\n                memcpy( st_cur->probes[st_cur->probe_index], p + 2, n ); //twice?!\n                st_cur->ssid_length[st_cur->probe_index] = n;\n\n                for( i = 0; i < n; i++ )\n                {\n                    c = p[2 + i];\n                    if( c == 0 || ( c > 126 && c < 160 ) ) c = '.';  //could also check ||(c>0 && c<32)\n                    st_cur->probes[st_cur->probe_index][i] = c;\n                }\n            }\n\n            p += 2 + p[1];\n        }\n    }\n\nskip_probe:\n\n    /* packet parsing: Beacon or Probe Response */\n\n    if( h80211[0] == 0x80 || h80211[0] == 0x50 )\n    {\n        if( !(ap_cur->security & (STD_OPN|STD_WEP|STD_WPA|STD_WPA2)) )\n        {\n            if( ( h80211[34] & 0x10 ) >> 4 ) ap_cur->security |= STD_WEP|ENC_WEP;\n            else ap_cur->security |= STD_OPN;\n        }\n\n        ap_cur->preamble = ( h80211[34] & 0x20 ) >> 5;\n\n        unsigned long long *tstamp = (unsigned long long *) (h80211 + 24);\n        ap_cur->timestamp = letoh64(*tstamp);\n\n        p = h80211 + 36;\n\n        while( p < h80211 + caplen )\n        {\n            if( p + 2 + p[1] > h80211 + caplen )\n                break;\n\n            //only update the essid length if the new length is > the old one\n            if( p[0] == 0x00 && (ap_cur->ssid_length < p[1]) ) ap_cur->ssid_length = p[1];\n\n            if( p[0] == 0x00 && p[1] > 0 && p[2] != '\\0' &&\n                ( p[1] > 1 || p[2] != ' ' ) )\n            {\n                /* found a non-cloaked ESSID */\n\n//                n = ( p[1] > 32 ) ? 32 : p[1];\n                n = p[1];\n\n                memset( ap_cur->essid, 0, 256 );\n                memcpy( ap_cur->essid, p + 2, n );\n\n                if( G.f_ivs != NULL && !ap_cur->essid_stored )\n                {\n                    memset(&ivs2, '\\x00', sizeof(struct ivs2_pkthdr));\n                    ivs2.flags |= IVS2_ESSID;\n                    ivs2.len += ap_cur->ssid_length;\n\n                    if( memcmp( G.prev_bssid, ap_cur->bssid, 6 ) != 0 )\n                    {\n                        ivs2.flags |= IVS2_BSSID;\n                        ivs2.len += 6;\n                        memcpy( G.prev_bssid, ap_cur->bssid,  6 );\n                    }\n\n                    /* write header */\n                    if( fwrite( &ivs2, 1, sizeof(struct ivs2_pkthdr), G.f_ivs )\n                        != (size_t) sizeof(struct ivs2_pkthdr) )\n                    {\n                        perror( \"fwrite(IV header) failed\" );\n                        return( 1 );\n                    }\n\n                    /* write BSSID */\n                    if(ivs2.flags & IVS2_BSSID)\n                    {\n                        if( fwrite( ap_cur->bssid, 1, 6, G.f_ivs )\n                            != (size_t) 6 )\n                        {\n                            perror( \"fwrite(IV bssid) failed\" );\n                            return( 1 );\n                        }\n                    }\n\n                    /* write essid */\n                    if( fwrite( ap_cur->essid, 1, ap_cur->ssid_length, G.f_ivs )\n                        != (size_t) ap_cur->ssid_length )\n                    {\n                        perror( \"fwrite(IV essid) failed\" );\n                        return( 1 );\n                    }\n\n                    ap_cur->essid_stored = 1;\n                }\n\n                for( i = 0; i < n; i++ )\n                    if( ( ap_cur->essid[i] >   0 && ap_cur->essid[i] <  32 ) ||\n                        ( ap_cur->essid[i] > 126 && ap_cur->essid[i] < 160 ) )\n                        ap_cur->essid[i] = '.';\n            }\n\n            /* get the maximum speed in Mb and the AP's channel */\n\n            if( p[0] == 0x01 || p[0] == 0x32 )\n            {\n                if(ap_cur->max_speed < ( p[1 + p[1]] & 0x7F ) / 2)\n                    ap_cur->max_speed = ( p[1 + p[1]] & 0x7F ) / 2;\n            }\n\n            if( p[0] == 0x03 )\n                ap_cur->channel = p[2];\n\n            p += 2 + p[1];\n        }\n    }\n\n    /* packet parsing: Beacon & Probe response */\n\n    if( (h80211[0] == 0x80 || h80211[0] == 0x50) && caplen > 38)\n    {\n        p=h80211+36;         //ignore hdr + fixed params\n\n        while( p < h80211 + caplen )\n        {\n            type = p[0];\n            length = p[1];\n            if(p+2+length > h80211 + caplen) {\n/*                printf(\"error parsing tags! %p vs. %p (tag: %i, length: %i,position: %i)\\n\", (p+2+length), (h80211+caplen), type, length, (p-h80211));\n                exit(1);*/\n                break;\n            }\n\n            if( (type == 0xDD && (length >= 8) && (memcmp(p+2, \"\\x00\\x50\\xF2\\x01\\x01\\x00\", 6) == 0)) || (type == 0x30) )\n            {\n                ap_cur->security &= ~(STD_WEP|ENC_WEP|STD_WPA);\n\n                org_p = p;\n                offset = 0;\n\n                if(type == 0xDD)\n                {\n                    //WPA defined in vendor specific tag -> WPA1 support\n                    ap_cur->security |= STD_WPA;\n                    offset = 4;\n                }\n\n                if(type == 0x30)\n                {\n                    ap_cur->security |= STD_WPA2;\n                    offset = 0;\n                }\n\n                if(length < (18+offset))\n                {\n                    p += length+2;\n                    continue;\n                }\n\n                if( p+9+offset > h80211+caplen )\n                    break;\n                numuni  = p[8+offset] + (p[9+offset]<<8);\n\n                if( p+ (11+offset) + 4*numuni > h80211+caplen)\n                    break;\n                numauth = p[(10+offset) + 4*numuni] + (p[(11+offset) + 4*numuni]<<8);\n\n                p += (10+offset);\n\n                if(type != 0x30)\n                {\n                    if( p + (4*numuni) + (2+4*numauth) > h80211+caplen)\n                        break;\n                }\n                else\n                {\n                    if( p + (4*numuni) + (2+4*numauth) + 2 > h80211+caplen)\n                        break;\n                }\n\n                for(i=0; i<numuni; i++)\n                {\n                    switch(p[i*4+3])\n                    {\n                    case 0x01:\n                        ap_cur->security |= ENC_WEP;\n                        break;\n                    case 0x02:\n                        ap_cur->security |= ENC_TKIP;\n                        break;\n                    case 0x03:\n                        ap_cur->security |= ENC_WRAP;\n                        break;\n                    case 0x04:\n                        ap_cur->security |= ENC_CCMP;\n                        break;\n                    case 0x05:\n                        ap_cur->security |= ENC_WEP104;\n                        break;\n                    default:\n                        break;\n                    }\n                }\n\n                p += 2+4*numuni;\n\n                for(i=0; i<numauth; i++)\n                {\n                    switch(p[i*4+3])\n                    {\n                    case 0x01:\n                        ap_cur->security |= AUTH_MGT;\n                        break;\n                    case 0x02:\n                        ap_cur->security |= AUTH_PSK;\n                        break;\n                    default:\n                        break;\n                    }\n                }\n\n                p += 2+4*numauth;\n\n                if( type == 0x30 ) p += 2;\n\n                p = org_p + length+2;\n            }\n            else if( (type == 0xDD && (length >= 8) && (memcmp(p+2, \"\\x00\\x50\\xF2\\x02\\x01\\x01\", 6) == 0)))\n            {\n                ap_cur->security |= STD_QOS;\n                p += length+2;\n            }\n            else p += length+2;\n        }\n    }\n\n    /* packet parsing: Authentication Response */\n\n    if( h80211[0] == 0xB0 && caplen >= 30)\n    {\n        if( ap_cur->security & STD_WEP )\n        {\n            //successful step 2 or 4 (coming from the AP)\n            if(memcmp(h80211+28, \"\\x00\\x00\", 2) == 0 &&\n                (h80211[26] == 0x02 || h80211[26] == 0x04))\n            {\n                ap_cur->security &= ~(AUTH_OPN | AUTH_PSK | AUTH_MGT);\n                if(h80211[24] == 0x00) ap_cur->security |= AUTH_OPN;\n                if(h80211[24] == 0x01) ap_cur->security |= AUTH_PSK;\n            }\n        }\n    }\n\n    /* packet parsing: Association Request */\n\n    if( h80211[0] == 0x00 && caplen > 28 )\n    {\n        p = h80211 + 28;\n\n        while( p < h80211 + caplen )\n        {\n            if( p + 2 + p[1] > h80211 + caplen )\n                break;\n\n            if( p[0] == 0x00 && p[1] > 0 && p[2] != '\\0' &&\n                ( p[1] > 1 || p[2] != ' ' ) )\n            {\n                /* found a non-cloaked ESSID */\n\n                n = ( p[1] > 32 ) ? 32 : p[1];\n\n                memset( ap_cur->essid, 0, 33 );\n                memcpy( ap_cur->essid, p + 2, n );\n\n                if( G.f_ivs != NULL && !ap_cur->essid_stored )\n                {\n                    memset(&ivs2, '\\x00', sizeof(struct ivs2_pkthdr));\n                    ivs2.flags |= IVS2_ESSID;\n                    ivs2.len += ap_cur->ssid_length;\n\n                    if( memcmp( G.prev_bssid, ap_cur->bssid, 6 ) != 0 )\n                    {\n                        ivs2.flags |= IVS2_BSSID;\n                        ivs2.len += 6;\n                        memcpy( G.prev_bssid, ap_cur->bssid,  6 );\n                    }\n\n                    /* write header */\n                    if( fwrite( &ivs2, 1, sizeof(struct ivs2_pkthdr), G.f_ivs )\n                        != (size_t) sizeof(struct ivs2_pkthdr) )\n                    {\n                        perror( \"fwrite(IV header) failed\" );\n                        return( 1 );\n                    }\n\n                    /* write BSSID */\n                    if(ivs2.flags & IVS2_BSSID)\n                    {\n                        if( fwrite( ap_cur->bssid, 1, 6, G.f_ivs )\n                            != (size_t) 6 )\n                        {\n                            perror( \"fwrite(IV bssid) failed\" );\n                            return( 1 );\n                        }\n                    }\n\n                    /* write essid */\n                    if( fwrite( ap_cur->essid, 1, ap_cur->ssid_length, G.f_ivs )\n                        != (size_t) ap_cur->ssid_length )\n                    {\n                        perror( \"fwrite(IV essid) failed\" );\n                        return( 1 );\n                    }\n\n                    ap_cur->essid_stored = 1;\n                }\n\n                for( i = 0; i < n; i++ )\n                    if( ap_cur->essid[i] < 32 ||\n                      ( ap_cur->essid[i] > 126 && ap_cur->essid[i] < 160 ) )\n                        ap_cur->essid[i] = '.';\n            }\n\n            p += 2 + p[1];\n        }\n        if(st_cur != NULL)\n            st_cur->wpa.state = 0;\n    }\n\n    /* packet parsing: some data */\n\n    if( ( h80211[0] & 0x0C ) == 0x08 )\n    {\n        /* update the channel if we didn't get any beacon */\n\n        if( ap_cur->channel == -1 )\n        {\n            if(ri->ri_channel > 0 && ri->ri_channel < 167)\n                ap_cur->channel = ri->ri_channel;\n            else\n                ap_cur->channel = G.channel[cardnum];\n        }\n\n        /* check the SNAP header to see if data is encrypted */\n\n        z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n\n        /* Check if 802.11e (QoS) */\n        if( (h80211[0] & 0x80) == 0x80)\n        {\n            z+=2;\n            if(st_cur != NULL)\n            {\n                if( (h80211[1] & 3) == 1 ) //ToDS\n                    st_cur->qos_to_ds = 1;\n                else\n                    st_cur->qos_fr_ds = 1;\n            }\n        }\n        else\n        {\n            if(st_cur != NULL)\n            {\n                if( (h80211[1] & 3) == 1 ) //ToDS\n                    st_cur->qos_to_ds = 0;\n                else\n                    st_cur->qos_fr_ds = 0;\n            }\n        }\n\n        if(z==24)\n        {\n            if(list_check_decloak(&(ap_cur->packets), caplen, h80211) != 0)\n            {\n                list_add_packet(&(ap_cur->packets), caplen, h80211);\n            }\n            else\n            {\n                ap_cur->is_decloak = 1;\n                ap_cur->decloak_detect = 0;\n                list_tail_free(&(ap_cur->packets));\n                memset(G.message, '\\x00', sizeof(G.message));\n                    snprintf( G.message, sizeof( G.message ) - 1,\n                        \"][ Decloak: %02X:%02X:%02X:%02X:%02X:%02X \",\n                        ap_cur->bssid[0], ap_cur->bssid[1], ap_cur->bssid[2],\n                        ap_cur->bssid[3], ap_cur->bssid[4], ap_cur->bssid[5]);\n            }\n        }\n\n        if( z + 26 > (unsigned)caplen )\n            goto write_packet;\n\n        if( h80211[z] == h80211[z + 1] && h80211[z + 2] == 0x03 )\n        {\n//            if( ap_cur->encryption < 0 )\n//                ap_cur->encryption = 0;\n\n            /* if ethertype == IPv4, find the LAN address */\n\n            if( h80211[z + 6] == 0x08 && h80211[z + 7] == 0x00 &&\n                ( h80211[1] & 3 ) == 0x01 )\n                    memcpy( ap_cur->lanip, &h80211[z + 20], 4 );\n\n            if( h80211[z + 6] == 0x08 && h80211[z + 7] == 0x06 )\n                memcpy( ap_cur->lanip, &h80211[z + 22], 4 );\n        }\n//        else\n//            ap_cur->encryption = 2 + ( ( h80211[z + 3] & 0x20 ) >> 5 );\n\n\n        if(ap_cur->security == 0 || (ap_cur->security & STD_WEP) )\n        {\n            if( (h80211[1] & 0x40) != 0x40 )\n            {\n                ap_cur->security |= STD_OPN;\n            }\n            else\n            {\n                if((h80211[z+3] & 0x20) == 0x20)\n                {\n                    ap_cur->security |= STD_WPA;\n                }\n                else\n                {\n                    ap_cur->security |= STD_WEP;\n                    if( (h80211[z+3] & 0xC0) != 0x00)\n                    {\n                        ap_cur->security |= ENC_WEP40;\n                    }\n                    else\n                    {\n                        ap_cur->security &= ~ENC_WEP40;\n                        ap_cur->security |= ENC_WEP;\n                    }\n                }\n            }\n        }\n\n        if( z + 10 > (unsigned)caplen )\n            goto write_packet;\n\n        if( ap_cur->security & STD_WEP )\n        {\n            /* WEP: check if we've already seen this IV */\n\n            if( ! uniqueiv_check( ap_cur->uiv_root, &h80211[z] ) )\n            {\n                /* first time seen IVs */\n\n                if( G.f_ivs != NULL )\n                {\n                    memset(&ivs2, '\\x00', sizeof(struct ivs2_pkthdr));\n                    ivs2.flags = 0;\n                    ivs2.len = 0;\n\n                    /* datalen = caplen - (header+iv+ivs) */\n                    dlen = caplen -z -4 -4; //original data len\n                    if(dlen > 2048) dlen = 2048;\n                    //get cleartext + len + 4(iv+idx)\n                    num_xor = known_clear(clear, &clen, weight, h80211, dlen);\n                    if(num_xor == 1)\n                    {\n                        ivs2.flags |= IVS2_XOR;\n                        ivs2.len += clen + 4;\n                        /* reveal keystream (plain^encrypted) */\n                        for(n=0; n<(ivs2.len-4); n++)\n                        {\n                            clear[n] = (clear[n] ^ h80211[z+4+n]) & 0xFF;\n                        }\n                        //clear is now the keystream\n                    }\n                    else\n                    {\n                        //do it again to get it 2 bytes higher\n                        num_xor = known_clear(clear+2, &clen, weight, h80211, dlen);\n                        ivs2.flags |= IVS2_PTW;\n                        //len = 4(iv+idx) + 1(num of keystreams) + 1(len per keystream) + 32*num_xor + 16*sizeof(int)(weight[16])\n                        ivs2.len += 4 + 1 + 1 + 32*num_xor + 16*sizeof(int);\n                        clear[0] = num_xor;\n                        clear[1] = clen;\n                        /* reveal keystream (plain^encrypted) */\n                        for(o=0; o<num_xor; o++)\n                        {\n                            for(n=0; n<(ivs2.len-4); n++)\n                            {\n                                clear[2+n+o*32] = (clear[2+n+o*32] ^ h80211[z+4+n]) & 0xFF;\n                            }\n                        }\n                        memcpy(clear+4 + 1 + 1 + 32*num_xor, weight, 16*sizeof(int));\n                        //clear is now the keystream\n                    }\n\n                    if( memcmp( G.prev_bssid, ap_cur->bssid, 6 ) != 0 )\n                    {\n                        ivs2.flags |= IVS2_BSSID;\n                        ivs2.len += 6;\n                        memcpy( G.prev_bssid, ap_cur->bssid,  6 );\n                    }\n\n                    if( fwrite( &ivs2, 1, sizeof(struct ivs2_pkthdr), G.f_ivs )\n                        != (size_t) sizeof(struct ivs2_pkthdr) )\n                    {\n                        perror( \"fwrite(IV header) failed\" );\n                        return( 1 );\n                    }\n\n                    if( ivs2.flags & IVS2_BSSID )\n                    {\n                        if( fwrite( ap_cur->bssid, 1, 6, G.f_ivs ) != (size_t) 6 )\n                        {\n                            perror( \"fwrite(IV bssid) failed\" );\n                            return( 1 );\n                        }\n                        ivs2.len -= 6;\n                    }\n\n                    if( fwrite( h80211+z, 1, 4, G.f_ivs ) != (size_t) 4 )\n                    {\n                        perror( \"fwrite(IV iv+idx) failed\" );\n                        return( 1 );\n                    }\n                    ivs2.len -= 4;\n\n                    if( fwrite( clear, 1, ivs2.len, G.f_ivs ) != (size_t) ivs2.len )\n                    {\n                        perror( \"fwrite(IV keystream) failed\" );\n                        return( 1 );\n                    }\n                }\n\n                uniqueiv_mark( ap_cur->uiv_root, &h80211[z] );\n\n                ap_cur->nb_data++;\n            }\n\n            // Record all data linked to IV to detect WEP Cloaking\n            if( G.f_ivs == NULL && G.detect_anomaly)\n            {\n\t\t\t\t// Only allocate this when seeing WEP AP\n\t\t\t\tif (ap_cur->data_root == NULL)\n\t\t\t\t\tap_cur->data_root = data_init();\n\n\t\t\t\t// Only works with full capture, not IV-only captures\n\t\t\t\tif (data_check(ap_cur->data_root, &h80211[z], &h80211[z + 4])\n\t\t\t\t\t== CLOAKING && ap_cur->EAP_detected == 0)\n\t\t\t\t{\n\n\t\t\t\t\t//If no EAP/EAP was detected, indicate WEP cloaking\n                    memset(G.message, '\\x00', sizeof(G.message));\n                    snprintf( G.message, sizeof( G.message ) - 1,\n                        \"][ WEP Cloaking: %02X:%02X:%02X:%02X:%02X:%02X \",\n                        ap_cur->bssid[0], ap_cur->bssid[1], ap_cur->bssid[2],\n                        ap_cur->bssid[3], ap_cur->bssid[4], ap_cur->bssid[5]);\n\n\t\t\t\t}\n\t\t\t}\n\n        }\n        else\n        {\n            ap_cur->nb_data++;\n        }\n\n        z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;\n\n        /* Check if 802.11e (QoS) */\n        if( (h80211[0] & 0x80) == 0x80) z+=2;\n\n        if( z + 26 > (unsigned)caplen )\n            goto write_packet;\n\n        z += 6;     //skip LLC header\n\n        /* check ethertype == EAPOL */\n        if( h80211[z] == 0x88 && h80211[z + 1] == 0x8E && (h80211[1] & 0x40) != 0x40 )\n        {\n\t\t\tap_cur->EAP_detected = 1;\n\n            z += 2;     //skip ethertype\n\n            if( st_cur == NULL )\n                goto write_packet;\n\n            /* frame 1: Pairwise == 1, Install == 0, Ack == 1, MIC == 0 */\n\n            if( ( h80211[z + 6] & 0x08 ) != 0 &&\n                  ( h80211[z + 6] & 0x40 ) == 0 &&\n                  ( h80211[z + 6] & 0x80 ) != 0 &&\n                  ( h80211[z + 5] & 0x01 ) == 0 )\n            {\n                memcpy( st_cur->wpa.anonce, &h80211[z + 17], 32 );\n                st_cur->wpa.state = 1;\n            }\n\n\n            /* frame 2 or 4: Pairwise == 1, Install == 0, Ack == 0, MIC == 1 */\n\n            if( z+17+32 > (unsigned)caplen )\n                goto write_packet;\n\n            if( ( h80211[z + 6] & 0x08 ) != 0 &&\n                  ( h80211[z + 6] & 0x40 ) == 0 &&\n                  ( h80211[z + 6] & 0x80 ) == 0 &&\n                  ( h80211[z + 5] & 0x01 ) != 0 )\n            {\n                if( memcmp( &h80211[z + 17], ZERO, 32 ) != 0 )\n                {\n                    memcpy( st_cur->wpa.snonce, &h80211[z + 17], 32 );\n                    st_cur->wpa.state |= 2;\n\n                }\n\n                if( (st_cur->wpa.state & 4) != 4 )\n                {\n                    st_cur->wpa.eapol_size = ( h80211[z + 2] << 8 )\n                            +   h80211[z + 3] + 4;\n\n                    if (caplen - z < st_cur->wpa.eapol_size || st_cur->wpa.eapol_size == 0 ||\n                        caplen - z < 81 + 16 || st_cur->wpa.eapol_size > sizeof(st_cur->wpa.eapol))\n                    {\n                        // Ignore the packet trying to crash us.\n                        st_cur->wpa.eapol_size = 0;\n                        goto write_packet;\n                    }\n\n                    memcpy( st_cur->wpa.keymic, &h80211[z + 81], 16 );\n                    memcpy( st_cur->wpa.eapol,  &h80211[z], st_cur->wpa.eapol_size );\n                    memset( st_cur->wpa.eapol + 81, 0, 16 );\n                    st_cur->wpa.state |= 4;\n                    st_cur->wpa.keyver = h80211[z + 6] & 7;\n                }\n            }\n\n            /* frame 3: Pairwise == 1, Install == 1, Ack == 1, MIC == 1 */\n\n            if( ( h80211[z + 6] & 0x08 ) != 0 &&\n                  ( h80211[z + 6] & 0x40 ) != 0 &&\n                  ( h80211[z + 6] & 0x80 ) != 0 &&\n                  ( h80211[z + 5] & 0x01 ) != 0 )\n            {\n                if( memcmp( &h80211[z + 17], ZERO, 32 ) != 0 )\n                {\n                    memcpy( st_cur->wpa.anonce, &h80211[z + 17], 32 );\n                    st_cur->wpa.state |= 1;\n                }\n\n                if( (st_cur->wpa.state & 4) != 4 )\n                {\n                    st_cur->wpa.eapol_size = ( h80211[z + 2] << 8 )\n                            +   h80211[z + 3] + 4;\n\n                    if (caplen - (unsigned)z < st_cur->wpa.eapol_size || st_cur->wpa.eapol_size == 0 ||\n                        caplen - (unsigned)z < 81 + 16 || st_cur->wpa.eapol_size > sizeof(st_cur->wpa.eapol))\n                    {\n                        // Ignore the packet trying to crash us.\n                        st_cur->wpa.eapol_size = 0;\n                        goto write_packet;\n                    }\n\n                    memcpy( st_cur->wpa.keymic, &h80211[z + 81], 16 );\n                    memcpy( st_cur->wpa.eapol,  &h80211[z], st_cur->wpa.eapol_size );\n                    memset( st_cur->wpa.eapol + 81, 0, 16 );\n                    st_cur->wpa.state |= 4;\n                    st_cur->wpa.keyver = h80211[z + 6] & 7;\n                }\n            }\n\n            if( st_cur->wpa.state == 7)\n            {\n                memcpy( st_cur->wpa.stmac, st_cur->stmac, 6 );\n                memcpy( G.wpa_bssid, ap_cur->bssid, 6 );\n                memset(G.message, '\\x00', sizeof(G.message));\n                snprintf( G.message, sizeof( G.message ) - 1,\n                    \"][ WPA handshake: %02X:%02X:%02X:%02X:%02X:%02X \",\n                    G.wpa_bssid[0], G.wpa_bssid[1], G.wpa_bssid[2],\n                    G.wpa_bssid[3], G.wpa_bssid[4], G.wpa_bssid[5]);\n\n\n                if( G.f_ivs != NULL )\n                {\n                    memset(&ivs2, '\\x00', sizeof(struct ivs2_pkthdr));\n                    ivs2.flags = 0;\n                    ivs2.len = 0;\n\n                    ivs2.len= sizeof(struct WPA_hdsk);\n                    ivs2.flags |= IVS2_WPA;\n\n                    if( memcmp( G.prev_bssid, ap_cur->bssid, 6 ) != 0 )\n                    {\n                        ivs2.flags |= IVS2_BSSID;\n                        ivs2.len += 6;\n                        memcpy( G.prev_bssid, ap_cur->bssid,  6 );\n                    }\n\n                    if( fwrite( &ivs2, 1, sizeof(struct ivs2_pkthdr), G.f_ivs )\n                        != (size_t) sizeof(struct ivs2_pkthdr) )\n                    {\n                        perror( \"fwrite(IV header) failed\" );\n                        return( 1 );\n                    }\n\n                    if( ivs2.flags & IVS2_BSSID )\n                    {\n                        if( fwrite( ap_cur->bssid, 1, 6, G.f_ivs ) != (size_t) 6 )\n                        {\n                            perror( \"fwrite(IV bssid) failed\" );\n                            return( 1 );\n                        }\n                        ivs2.len -= 6;\n                    }\n\n                    if( fwrite( &(st_cur->wpa), 1, sizeof(struct WPA_hdsk), G.f_ivs ) != (size_t) sizeof(struct WPA_hdsk) )\n                    {\n                        perror( \"fwrite(IV wpa_hdsk) failed\" );\n                        return( 1 );\n                    }\n                }\n            }\n        }\n    }\n\n\nwrite_packet:\n\n    if(ap_cur != NULL)\n    {\n        if( h80211[0] == 0x80 && G.one_beacon){\n            if( !ap_cur->beacon_logged )\n                ap_cur->beacon_logged = 1;\n            else return ( 0 );\n        }\n    }\n\n    if(G.record_data)\n    {\n        if( ( (h80211[0] & 0x0C) == 0x00 ) && ( (h80211[0] & 0xF0) == 0xB0 ) )\n        {\n            /* authentication packet */\n            check_shared_key(h80211, caplen);\n        }\n    }\n\n    if(ap_cur != NULL)\n    {\n        if(ap_cur->security != 0 && G.f_encrypt != 0 && ((ap_cur->security & G.f_encrypt) == 0))\n        {\n            return(1);\n        }\n\n        if(is_filtered_essid(ap_cur->essid))\n        {\n            return(1);\n        }\n\n    }\n\n    /* this changes the local ap_cur, st_cur and na_cur variables and should be the last check befor the actual write */\n    if(caplen < 24 && caplen >= 10 && h80211[0])\n    {\n        /* RTS || CTS || ACK || CF-END || CF-END&CF-ACK*/\n        //(h80211[0] == 0xB4 || h80211[0] == 0xC4 || h80211[0] == 0xD4 || h80211[0] == 0xE4 || h80211[0] == 0xF4)\n\n        /* use general control frame detection, as the structure is always the same: mac(s) starting at [4] */\n        if(h80211[0] & 0x04)\n        {\n            p=h80211+4;\n            while(p <= h80211+16 && p<=h80211+caplen)\n            {\n                memcpy(namac, p, 6);\n\n                if(memcmp(namac, NULL_MAC, 6) == 0)\n                {\n                    p+=6;\n                    continue;\n                }\n\n                if(memcmp(namac, BROADCAST, 6) == 0)\n                {\n                    p+=6;\n                    continue;\n                }\n\n                if(G.hide_known)\n                {\n                    /* check AP list */\n                    ap_cur = G.ap_1st;\n                    ap_prv = NULL;\n\n                    while( ap_cur != NULL )\n                    {\n                        if( ! memcmp( ap_cur->bssid, namac, 6 ) )\n                            break;\n\n                        ap_prv = ap_cur;\n                        ap_cur = ap_cur->next;\n                    }\n\n                    /* if it's an AP, try next mac */\n\n                    if( ap_cur != NULL )\n                    {\n                        p+=6;\n                        continue;\n                    }\n\n                    /* check ST list */\n                    st_cur = G.st_1st;\n                    st_prv = NULL;\n\n                    while( st_cur != NULL )\n                    {\n                        if( ! memcmp( st_cur->stmac, namac, 6 ) )\n                            break;\n\n                        st_prv = st_cur;\n                        st_cur = st_cur->next;\n                    }\n\n                    /* if it's a client, try next mac */\n\n                    if( st_cur != NULL )\n                    {\n                        p+=6;\n                        continue;\n                    }\n                }\n\n                /* not found in either AP list or ST list, look through NA list */\n                na_cur = G.na_1st;\n                na_prv = NULL;\n\n                while( na_cur != NULL )\n                {\n                    if( ! memcmp( na_cur->namac, namac, 6 ) )\n                        break;\n\n                    na_prv = na_cur;\n                    na_cur = na_cur->next;\n                }\n\n                /* update our chained list of unknown stations */\n                /* if it's a new mac, add it */\n\n                if( na_cur == NULL )\n                {\n                    if( ! ( na_cur = (struct NA_info *) malloc(\n                                    sizeof( struct NA_info ) ) ) )\n                    {\n                        perror( \"malloc failed\" );\n                        return( 1 );\n                    }\n\n                    memset( na_cur, 0, sizeof( struct NA_info ) );\n\n                    if( G.na_1st == NULL )\n                        G.na_1st = na_cur;\n                    else\n                        na_prv->next  = na_cur;\n\n                    memcpy( na_cur->namac, namac, 6 );\n\n                    na_cur->prev = na_prv;\n\n                    gettimeofday(&(na_cur->tv), NULL);\n                    na_cur->tinit = time( NULL );\n                    na_cur->tlast = time( NULL );\n\n                    na_cur->power   = -1;\n                    na_cur->channel = -1;\n                    na_cur->ack     = 0;\n                    na_cur->ack_old = 0;\n                    na_cur->ackps   = 0;\n                    na_cur->cts     = 0;\n                    na_cur->rts_r   = 0;\n                    na_cur->rts_t   = 0;\n                }\n\n                /* update the last time seen & power*/\n\n                na_cur->tlast = time( NULL );\n                na_cur->power = ri->ri_power;\n                na_cur->channel = ri->ri_channel;\n\n                switch(h80211[0] & 0xF0)\n                {\n                    case 0xB0:\n                        if(p == h80211+4)\n                            na_cur->rts_r++;\n                        if(p == h80211+10)\n                            na_cur->rts_t++;\n                        break;\n\n                    case 0xC0:\n                        na_cur->cts++;\n                        break;\n\n                    case 0xD0:\n                        na_cur->ack++;\n                        break;\n\n                    default:\n                        na_cur->other++;\n                        break;\n                }\n\n                /*grab next mac (for rts frames)*/\n                p+=6;\n            }\n        }\n    }\n\n    if( G.f_cap != NULL && caplen >= 10)\n    {\n        pkh.caplen = pkh.len = caplen;\n\n        gettimeofday( &tv, NULL );\n\n        pkh.tv_sec  =   tv.tv_sec;\n        pkh.tv_usec = ( tv.tv_usec & ~0x1ff ) + ri->ri_power + 64;\n\n        n = sizeof( pkh );\n\n        if( fwrite( &pkh, 1, n, G.f_cap ) != (size_t) n )\n        {\n            perror( \"fwrite(packet header) failed\" );\n            return( 1 );\n        }\n\n        fflush( stdout );\n\n        n = pkh.caplen;\n\n        if( fwrite( h80211, 1, n, G.f_cap ) != (size_t) n )\n        {\n            perror( \"fwrite(packet data) failed\" );\n            return( 1 );\n        }\n\n        fflush( stdout );\n    }\n\n    return( 0 );\n}\n\nvoid dump_sort( void )\n{\n    time_t tt = time( NULL );\n\n    /* thanks to Arnaud Cornet :-) */\n\n    struct AP_info *new_ap_1st = NULL;\n    struct AP_info *new_ap_end = NULL;\n\n    struct ST_info *new_st_1st = NULL;\n    struct ST_info *new_st_end = NULL;\n\n    struct ST_info *st_cur, *st_min;\n    struct AP_info *ap_cur, *ap_min;\n\n    /* sort the aps by WHATEVER first */\n\n    while( G.ap_1st )\n    {\n        ap_min = NULL;\n        ap_cur = G.ap_1st;\n\n        while( ap_cur != NULL )\n        {\n            if( tt - ap_cur->tlast > 20 )\n                ap_min = ap_cur;\n\n            ap_cur = ap_cur->next;\n        }\n\n        if( ap_min == NULL )\n        {\n            ap_min = ap_cur = G.ap_1st;\n\n/*#define SORT_BY_BSSID\t1\n#define SORT_BY_POWER\t2\n#define SORT_BY_BEACON\t3\n#define SORT_BY_DATA\t4\n#define SORT_BY_PRATE\t6\n#define SORT_BY_CHAN\t7\n#define\tSORT_BY_MBIT\t8\n#define SORT_BY_ENC\t9\n#define SORT_BY_CIPHER\t10\n#define SORT_BY_AUTH\t11\n#define SORT_BY_ESSID\t12*/\n\n\t    while( ap_cur != NULL )\n            {\n\t\tswitch (G.sort_by) {\n\t\t    case SORT_BY_BSSID:\n\t\t\tif( memcmp(ap_cur->bssid,ap_min->bssid,6)*G.sort_inv < 0)\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_POWER:\n\t\t\tif( (ap_cur->avg_power - ap_min->avg_power)*G.sort_inv < 0 )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_BEACON:\n\t\t\tif( (ap_cur->nb_bcn < ap_min->nb_bcn)*G.sort_inv )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_DATA:\n\t\t\tif( (ap_cur->nb_data < ap_min->nb_data)*G.sort_inv )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_PRATE:\n\t\t\tif( (ap_cur->nb_dataps - ap_min->nb_dataps)*G.sort_inv < 0 )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_CHAN:\n\t\t\tif( (ap_cur->channel - ap_min->channel)*G.sort_inv < 0 )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_MBIT:\n\t\t\tif( (ap_cur->max_speed - ap_min->max_speed)*G.sort_inv < 0 )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_ENC:\n\t\t\tif( ((ap_cur->security&STD_FIELD) - (ap_min->security&STD_FIELD))*G.sort_inv < 0 )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_CIPHER:\n\t\t\tif( ((ap_cur->security&ENC_FIELD) - (ap_min->security&ENC_FIELD))*G.sort_inv < 0 )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_AUTH:\n\t\t\tif( ((ap_cur->security&AUTH_FIELD) - (ap_min->security&AUTH_FIELD))*G.sort_inv < 0 )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    case SORT_BY_ESSID:\n\t\t\tif( (strncasecmp((char*)ap_cur->essid, (char*)ap_min->essid, MAX_IE_ELEMENT_SIZE))*G.sort_inv < 0 )\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t    default:\t//sort by power\n\t\t\tif( ap_cur->avg_power < ap_min->avg_power)\n\t\t\t    ap_min = ap_cur;\n\t\t\tbreak;\n\t\t}\n                ap_cur = ap_cur->next;\n\t    }\n\t}\n\n        if( ap_min == G.ap_1st )\n            G.ap_1st = ap_min->next;\n\n        if( ap_min == G.ap_end )\n            G.ap_end = ap_min->prev;\n\n        if( ap_min->next )\n            ap_min->next->prev = ap_min->prev;\n\n        if( ap_min->prev )\n            ap_min->prev->next = ap_min->next;\n\n        if( new_ap_end )\n        {\n            new_ap_end->next = ap_min;\n            ap_min->prev = new_ap_end;\n            new_ap_end = ap_min;\n            new_ap_end->next = NULL;\n        }\n        else\n        {\n            new_ap_1st = new_ap_end = ap_min;\n            ap_min->next = ap_min->prev = NULL;\n        }\n    }\n\n    G.ap_1st = new_ap_1st;\n    G.ap_end = new_ap_end;\n\n    /* now sort the stations */\n\n    while( G.st_1st )\n    {\n        st_min = NULL;\n        st_cur = G.st_1st;\n\n        while( st_cur != NULL )\n        {\n            if( tt - st_cur->tlast > 60 )\n                st_min = st_cur;\n\n            st_cur = st_cur->next;\n        }\n\n        if( st_min == NULL )\n        {\n            st_min = st_cur = G.st_1st;\n\n            while( st_cur != NULL )\n            {\n                if( st_cur->power < st_min->power)\n                    st_min = st_cur;\n\n                st_cur = st_cur->next;\n            }\n        }\n\n        if( st_min == G.st_1st )\n            G.st_1st = st_min->next;\n\n        if( st_min == G.st_end )\n            G.st_end = st_min->prev;\n\n        if( st_min->next )\n            st_min->next->prev = st_min->prev;\n\n        if( st_min->prev )\n            st_min->prev->next = st_min->next;\n\n        if( new_st_end )\n        {\n            new_st_end->next = st_min;\n            st_min->prev = new_st_end;\n            new_st_end = st_min;\n            new_st_end->next = NULL;\n        }\n        else\n        {\n            new_st_1st = new_st_end = st_min;\n            st_min->next = st_min->prev = NULL;\n        }\n    }\n\n    G.st_1st = new_st_1st;\n    G.st_end = new_st_end;\n}\n\nint getBatteryState()\n{\n\treturn get_battery_state();\n}\n\nchar * getStringTimeFromSec(double seconds)\n{\n    int hour[3];\n    char * ret;\n    char * HourTime;\n    char * MinTime;\n\n    if (seconds <0)\n        return NULL;\n\n    ret = (char *) calloc(1,256);\n\n    HourTime = (char *) calloc (1,128);\n    MinTime  = (char *) calloc (1,128);\n\n    hour[0]  = (int) (seconds);\n    hour[1]  = hour[0] / 60;\n    hour[2]  = hour[1] / 60;\n    hour[0] %= 60 ;\n    hour[1] %= 60 ;\n\n    if (hour[2] != 0 )\n        snprintf(HourTime, 128, \"%d %s\", hour[2], ( hour[2] == 1 ) ? \"hour\" : \"hours\");\n    if (hour[1] != 0 )\n        snprintf(MinTime, 128, \"%d %s\", hour[1], ( hour[1] == 1 ) ? \"min\" : \"mins\");\n\n    if ( hour[2] != 0 && hour[1] != 0 )\n        snprintf(ret, 256, \"%s %s\", HourTime, MinTime);\n    else\n    {\n        if (hour[2] == 0 && hour[1] == 0)\n            snprintf(ret, 256, \"%d s\", hour[0] );\n        else\n            snprintf(ret, 256, \"%s\", (hour[2] == 0) ? MinTime : HourTime );\n    }\n\n    free(MinTime);\n    free(HourTime);\n\n    return ret;\n\n}\n\nchar * getBatteryString(void)\n{\n    int batt_time;\n    char * ret;\n    char * batt_string;\n\n    batt_time = getBatteryState();\n\n    if ( batt_time <= 60 ) {\n        ret = (char *) calloc(1,2);\n        ret[0] = ']';\n        return ret;\n    }\n\n    batt_string = getStringTimeFromSec( (double) batt_time );\n\n    ret = (char *) calloc( 1, 256 );\n\n    snprintf( ret, 256, \"][ BAT: %s ]\", batt_string );\n\n    free( batt_string);\n\n    return ret;\n}\n\nint get_ap_list_count() {\n    time_t tt;\n    struct tm *lt;\n    struct AP_info *ap_cur;\n\n    int num_ap;\n\n    tt = time( NULL );\n    lt = localtime( &tt );\n\n    ap_cur = G.ap_end;\n\n    num_ap = 0;\n\n    while( ap_cur != NULL )\n    {\n        /* skip APs with only one packet, or those older than 2 min.\n         * always skip if bssid == broadcast */\n\n        if( ap_cur->nb_pkt < 2 || time( NULL ) - ap_cur->tlast > G.berlin ||\n            memcmp( ap_cur->bssid, BROADCAST, 6 ) == 0 )\n        {\n            ap_cur = ap_cur->prev;\n            continue;\n        }\n\n        if(ap_cur->security != 0 && G.f_encrypt != 0 && ((ap_cur->security & G.f_encrypt) == 0))\n        {\n            ap_cur = ap_cur->prev;\n            continue;\n        }\n\n        if(is_filtered_essid(ap_cur->essid))\n        {\n            ap_cur = ap_cur->prev;\n            continue;\n        }\n\n\tnum_ap++;\n\tap_cur = ap_cur->prev;\n    }\n\n    return num_ap;\n}\n\nint get_sta_list_count() {\n    time_t tt;\n    struct tm *lt;\n    struct AP_info *ap_cur;\n    struct ST_info *st_cur;\n\n    int num_sta;\n\n    tt = time( NULL );\n    lt = localtime( &tt );\n\n    ap_cur = G.ap_end;\n\n    num_sta = 0;\n\n    while( ap_cur != NULL )\n    {\n        if( ap_cur->nb_pkt < 2 ||\n            time( NULL ) - ap_cur->tlast > G.berlin )\n        {\n            ap_cur = ap_cur->prev;\n            continue;\n        }\n\n        if(ap_cur->security != 0 && G.f_encrypt != 0 && ((ap_cur->security & G.f_encrypt) == 0))\n        {\n            ap_cur = ap_cur->prev;\n            continue;\n        }\n\n        // Don't filter unassociated clients by ESSID\n        if(memcmp(ap_cur->bssid, BROADCAST, 6) && is_filtered_essid(ap_cur->essid))\n        {\n            ap_cur = ap_cur->prev;\n            continue;\n        }\n\n        st_cur = G.st_end;\n\n        while( st_cur != NULL )\n        {\n            if( st_cur->base != ap_cur ||\n                time( NULL ) - st_cur->tlast > G.berlin )\n            {\n                st_cur = st_cur->prev;\n                continue;\n            }\n\n            if( ! memcmp( ap_cur->bssid, BROADCAST, 6 ) && G.asso_client )\n            {\n                st_cur = st_cur->prev;\n                continue;\n            }\n\n\t    num_sta++;\n\n            st_cur = st_cur->prev;\n        }\n\n        ap_cur = ap_cur->prev;\n    }\n    return num_sta;\n}\n\n#define TSTP_SEC 1000000ULL /* It's a 1 MHz clock, so a million ticks per second! */\n#define TSTP_MIN (TSTP_SEC * 60ULL)\n#define TSTP_HOUR (TSTP_MIN * 60ULL)\n#define TSTP_DAY (TSTP_HOUR * 24ULL)\n\nstatic char *parse_timestamp(unsigned long long timestamp) {\n\tstatic char s[15];\n\tunsigned long long rem;\n\tunsigned int days, hours, mins, secs;\n\n\tdays = timestamp / TSTP_DAY;\n\trem = timestamp % TSTP_DAY;\n\thours = rem / TSTP_HOUR;\n\trem %= TSTP_HOUR;\n\tmins = rem / TSTP_MIN;\n\trem %= TSTP_MIN;\n\tsecs = rem / TSTP_SEC;\n\n\tsnprintf(s, 14, \"%3dd %02d:%02d:%02d\", days, hours, mins, secs);\n\n\treturn s;\n}\n\nvoid dump_print( int ws_row, int ws_col, int if_num )\n{\n    time_t tt;\n    struct tm *lt;\n    int nlines, i, n, len;\n    char strbuf[512];\n    char buffer[512];\n    char ssid_list[512];\n    struct AP_info *ap_cur;\n    struct ST_info *st_cur;\n    struct NA_info *na_cur;\n    int columns_ap = 83;\n    int columns_sta = 74;\n    int columns_na = 68;\n\n    int num_ap;\n    int num_sta;\n\n    if(!G.singlechan) columns_ap -= 4; //no RXQ in scan mode\n    if(G.show_uptime) columns_ap += 15; //show uptime needs more space\n\n    nlines = 2;\n\n    if( nlines >= ws_row )\n        return;\n\n    if(G.do_sort_always) {\n\tpthread_mutex_lock( &(G.mx_sort) );\n\t    dump_sort();\n\tpthread_mutex_unlock( &(G.mx_sort) );\n    }\n\n    tt = time( NULL );\n    lt = localtime( &tt );\n\n    if(G.is_berlin)\n    {\n        G.maxaps = 0;\n        G.numaps = 0;\n        ap_cur = G.ap_end;\n\n        while( ap_cur != NULL )\n        {\n            G.maxaps++;\n            if( ap_cur->nb_pkt < 2 || time( NULL ) - ap_cur->tlast > G.berlin ||\n                memcmp( ap_cur->bssid, BROADCAST, 6 ) == 0 )\n            {\n                ap_cur = ap_cur->prev;\n                continue;\n            }\n            G.numaps++;\n            ap_cur = ap_cur->prev;\n        }\n\n        if(G.numaps > G.maxnumaps)\n            G.maxnumaps = G.numaps;\n\n//        G.maxaps--;\n    }\n\n    /*\n     *  display the channel, battery, position (if we are connected to GPSd)\n     *  and current time\n     */\n\n    memset( strbuf, '\\0', sizeof(strbuf) );\n    strbuf[ws_col - 1] = '\\0';\n    fprintf( stderr, \"%s\\n\", strbuf );\n\n    if(G.freqoption)\n    {\n        snprintf(strbuf, sizeof(strbuf)-1, \" Freq %4d\", G.frequency[0]);\n        for(i=1; i<if_num; i++)\n        {\n            memset( buffer, '\\0', sizeof(buffer) );\n            snprintf(buffer, sizeof(buffer) , \",%4d\", G.frequency[i]);\n            strncat(strbuf, buffer, sizeof(strbuf) - strlen(strbuf) - 1);\n        }\n    }\n    else\n    {\n        snprintf(strbuf, sizeof(strbuf)-1, \" CH %2d\", G.channel[0]);\n        for(i=1; i<if_num; i++)\n        {\n            memset( buffer, '\\0', sizeof(buffer) );\n            snprintf(buffer, sizeof(buffer) , \",%2d\", G.channel[i]);\n            strncat(strbuf, buffer, sizeof(strbuf) - strlen(strbuf) -1);\n        }\n    }\n    memset( buffer, '\\0', sizeof(buffer) );\n\n    if (G.gps_loc[0]) {\n        snprintf( buffer, sizeof( buffer ) - 1,\n              \" %s[ GPS %8.3f %8.3f %8.3f %6.2f \"\n              \"][ Elapsed: %s ][ %04d-%02d-%02d %02d:%02d \", G.batt,\n              G.gps_loc[0], G.gps_loc[1], G.gps_loc[2], G.gps_loc[3],\n              G.elapsed_time , 1900 + lt->tm_year,\n              1 + lt->tm_mon, lt->tm_mday, lt->tm_hour, lt->tm_min );\n    }\n    else\n    {\n        snprintf( buffer, sizeof( buffer ) - 1,\n              \" %s[ Elapsed: %s ][ %04d-%02d-%02d %02d:%02d \",\n              G.batt, G.elapsed_time, 1900 + lt->tm_year,\n              1 + lt->tm_mon, lt->tm_mday, lt->tm_hour, lt->tm_min );\n    }\n\n    strncat(strbuf, buffer, (512-strlen(strbuf)));\n    memset( buffer, '\\0', 512 );\n\n    if(G.is_berlin)\n    {\n        snprintf( buffer, sizeof( buffer ) - 1,\n              \" ][%3d/%3d/%4d \",\n              G.numaps, G.maxnumaps, G.maxaps);\n    }\n\n    strncat(strbuf, buffer, (512-strlen(strbuf)));\n    memset( buffer, '\\0', 512 );\n\n    if(strlen(G.message) > 0)\n    {\n        strncat(strbuf, G.message, (512-strlen(strbuf)));\n    }\n\n    //add traling spaces to overwrite previous messages\n    strncat(strbuf, \"                                        \", (512-strlen(strbuf)));\n\n    strbuf[ws_col - 1] = '\\0';\n    fprintf( stderr, \"%s\\n\", strbuf );\n\n    /* print some informations about each detected AP */\n\n    nlines += 3;\n\n    if( nlines >= ws_row )\n        return;\n\n    memset( strbuf, ' ', ws_col - 1 );\n    strbuf[ws_col - 1] = '\\0';\n    fprintf( stderr, \"%s\\n\", strbuf );\n\n    if(G.show_ap) {\n\n    strbuf[0] = 0;\n    strcat(strbuf, \" BSSID              PWR \");\n\n    if(G.singlechan)\n    \tstrcat(strbuf, \"RXQ \");\n\n    strcat(strbuf, \" Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH \");\n\n    if (G.show_uptime)\n    \tstrcat(strbuf, \"       UPTIME  \");\n\n    strcat(strbuf, \"ESSID\");\n\n\tif ( G.show_manufacturer && ( ws_col > (columns_ap - 4) ) ) {\n\t\t// write spaces (32).\n\t\tmemset(strbuf+columns_ap, 32, G.maxsize_essid_seen - 5 ); // 5 is the len of \"ESSID\"\n\t\tsnprintf(strbuf+columns_ap+G.maxsize_essid_seen-5, 15,\"%s\",\"  MANUFACTURER\");\n\t}\n\n\tstrbuf[ws_col - 1] = '\\0';\n\tfprintf( stderr, \"%s\\n\", strbuf );\n\n\tmemset( strbuf, ' ', ws_col - 1 );\n\tstrbuf[ws_col - 1] = '\\0';\n\tfprintf( stderr, \"%s\\n\", strbuf );\n\n\tap_cur = G.ap_end;\n\n\tif(G.selection_ap) {\n\t    num_ap = get_ap_list_count();\n\t    if(G.selected_ap > num_ap)\n\t\tG.selected_ap = num_ap;\n\t}\n\n\tif(G.selection_sta) {\n\t    num_sta = get_sta_list_count();\n\t    if(G.selected_sta > num_sta)\n\t\tG.selected_sta = num_sta;\n\t}\n\n\tnum_ap = 0;\n\n\tif(G.selection_ap) {\n\t    G.start_print_ap = G.selected_ap - ((ws_row-1) - nlines) + 1;\n\t    if(G.start_print_ap < 1)\n\t\tG.start_print_ap = 1;\n    //\tprintf(\"%i\\n\", G.start_print_ap);\n\t}\n\n\n\twhile( ap_cur != NULL )\n\t{\n\t    /* skip APs with only one packet, or those older than 2 min.\n\t    * always skip if bssid == broadcast */\n\n\t    if( ap_cur->nb_pkt < 2 || time( NULL ) - ap_cur->tlast > G.berlin ||\n\t\tmemcmp( ap_cur->bssid, BROADCAST, 6 ) == 0 )\n\t    {\n\t\tap_cur = ap_cur->prev;\n\t\tcontinue;\n\t    }\n\n\t    if(ap_cur->security != 0 && G.f_encrypt != 0 && ((ap_cur->security & G.f_encrypt) == 0))\n\t    {\n\t\tap_cur = ap_cur->prev;\n\t\tcontinue;\n\t    }\n\n\t    if(is_filtered_essid(ap_cur->essid))\n\t    {\n\t\tap_cur = ap_cur->prev;\n\t\tcontinue;\n\t    }\n\n\t    num_ap++;\n\n\t    if(num_ap < G.start_print_ap) {\n\t\tap_cur = ap_cur->prev;\n\t\tcontinue;\n\t    }\n\n\t    nlines++;\n\n\t    if( nlines > (ws_row-1) )\n\t\treturn;\n\n\t    memset(strbuf, '\\0', sizeof(strbuf));\n\n\t    snprintf( strbuf, sizeof(strbuf), \" %02X:%02X:%02X:%02X:%02X:%02X\",\n\t\t    ap_cur->bssid[0], ap_cur->bssid[1],\n\t\t    ap_cur->bssid[2], ap_cur->bssid[3],\n\t\t    ap_cur->bssid[4], ap_cur->bssid[5] );\n\n\t    len = strlen(strbuf);\n\n\t    if(G.singlechan)\n\t    {\n\t\tsnprintf( strbuf+len, sizeof(strbuf)-len, \"  %3d %3d %8ld %8ld %4d\",\n\t\t\tap_cur->avg_power,\n\t\t\tap_cur->rx_quality,\n\t\t\tap_cur->nb_bcn,\n\t\t\tap_cur->nb_data,\n\t\t\tap_cur->nb_dataps );\n\t    }\n\t    else\n\t    {\n\t\tsnprintf( strbuf+len, sizeof(strbuf)-len, \"  %3d %8ld %8ld %4d\",\n\t\t\tap_cur->avg_power,\n\t\t\tap_cur->nb_bcn,\n\t\t\tap_cur->nb_data,\n\t\t\tap_cur->nb_dataps );\n\t    }\n\n\t    len = strlen(strbuf);\n\n\t    snprintf( strbuf+len, sizeof(strbuf)-len, \" %3d %3d%c%c \",\n\t\t    ap_cur->channel, ap_cur->max_speed,\n\t\t    ( ap_cur->security & STD_QOS ) ? 'e' : ' ',\n\t\t    ( ap_cur->preamble ) ? '.' : ' ');\n\n\t    len = strlen(strbuf);\n\n\t    if( (ap_cur->security & (STD_OPN|STD_WEP|STD_WPA|STD_WPA2)) == 0) snprintf( strbuf+len, sizeof(strbuf)-len, \"    \" );\n\t    else if( ap_cur->security & STD_WPA2 ) snprintf( strbuf+len, sizeof(strbuf)-len, \"WPA2\" );\n\t    else if( ap_cur->security & STD_WPA  ) snprintf( strbuf+len, sizeof(strbuf)-len, \"WPA \" );\n\t    else if( ap_cur->security & STD_WEP  ) snprintf( strbuf+len, sizeof(strbuf)-len, \"WEP \" );\n\t    else if( ap_cur->security & STD_OPN  ) snprintf( strbuf+len, sizeof(strbuf)-len, \"OPN \" );\n\n\t    strncat( strbuf, \" \", sizeof(strbuf) - strlen(strbuf) - 1);\n\n\t    len = strlen(strbuf);\n\n\t    if( (ap_cur->security & (ENC_WEP|ENC_TKIP|ENC_WRAP|ENC_CCMP|ENC_WEP104|ENC_WEP40)) == 0 ) snprintf( strbuf+len, sizeof(strbuf)-len, \"       \");\n\t    else if( ap_cur->security & ENC_CCMP   ) snprintf( strbuf+len, sizeof(strbuf)-len, \"CCMP   \");\n\t    else if( ap_cur->security & ENC_WRAP   ) snprintf( strbuf+len, sizeof(strbuf)-len, \"WRAP   \");\n\t    else if( ap_cur->security & ENC_TKIP   ) snprintf( strbuf+len, sizeof(strbuf)-len, \"TKIP   \");\n\t    else if( ap_cur->security & ENC_WEP104 ) snprintf( strbuf+len, sizeof(strbuf)-len, \"WEP104 \");\n\t    else if( ap_cur->security & ENC_WEP40  ) snprintf( strbuf+len, sizeof(strbuf)-len, \"WEP40  \");\n\t    else if( ap_cur->security & ENC_WEP    ) snprintf( strbuf+len, sizeof(strbuf)-len, \"WEP    \");\n\n\t    len = strlen(strbuf);\n\n\t    if( (ap_cur->security & (AUTH_OPN|AUTH_PSK|AUTH_MGT)) == 0 ) snprintf( strbuf+len, sizeof(strbuf)-len, \"   \");\n\t    else if( ap_cur->security & AUTH_MGT   ) snprintf( strbuf+len, sizeof(strbuf)-len, \"MGT\");\n\t    else if( ap_cur->security & AUTH_PSK   )\n\t    {\n\t\tif( ap_cur->security & STD_WEP )\n\t\t    snprintf( strbuf+len, sizeof(strbuf)-len, \"SKA\");\n\t\telse\n\t\t    snprintf( strbuf+len, sizeof(strbuf)-len, \"PSK\");\n\t    }\n\t    else if( ap_cur->security & AUTH_OPN   ) snprintf( strbuf+len, sizeof(strbuf)-len, \"OPN\");\n\n\t    len = strlen(strbuf);\n\n\t    if (G.show_uptime) {\n\t    \tsnprintf(strbuf+len, sizeof(strbuf)-len, \" %14s\", parse_timestamp(ap_cur->timestamp));\n\t    \tlen = strlen(strbuf);\n\t    }\n\n\t    strbuf[ws_col-1] = '\\0';\n\n\t    if(G.selection_ap && ((num_ap) == G.selected_ap)) {\n\t\tif(G.mark_cur_ap) {\n\t\t    if(ap_cur->marked == 0) {\n\t\t\tap_cur->marked = 1;\n\t\t    }\n\t\t    else {\n\t\t\tap_cur->marked_color++;\n\t\t\tif(ap_cur->marked_color > (TEXT_MAX_COLOR-1)) {\n\t\t\t    ap_cur->marked_color = 1;\n\t\t\t    ap_cur->marked = 0;\n\t\t\t}\n\t\t    }\n\t\t    G.mark_cur_ap = 0;\n\t\t}\n\t\ttextstyle(TEXT_REVERSE);\n\t\tmemcpy(G.selected_bssid, ap_cur->bssid, 6);\n\t    }\n\n\t    if(ap_cur->marked) {\n\t\ttextcolor_fg(ap_cur->marked_color);\n\t    }\n\n\t    fprintf(stderr, \"%s\", strbuf);\n\n\t    if( ws_col > (columns_ap - 4) )\n\t    {\n\t\tmemset( strbuf, 0, sizeof( strbuf ) );\n\t\tif(ap_cur->essid[0] != 0x00)\n\t\t{\n\t\t    snprintf( strbuf,  sizeof( strbuf ) - 1,\n\t\t\t    \"%s\", ap_cur->essid );\n\t\t}\n\t\telse\n\t\t{\n\t\t    snprintf( strbuf,  sizeof( strbuf ) - 1,\n\t\t\t    \"<length:%3d>%s\", ap_cur->ssid_length, \"\\x00\" );\n\t\t}\n\n\t\tif (G.show_manufacturer) {\n\n\t\t\tif (G.maxsize_essid_seen <= strlen(strbuf))\n\t\t\t\tG.maxsize_essid_seen = strlen(strbuf);\n\t\t\telse // write spaces (32)\n\t\t\t\tmemset( strbuf+strlen(strbuf), 32,  (G.maxsize_essid_seen - strlen(strbuf))  );\n\n\t\t\tif (ap_cur->manuf == NULL)\n\t\t\t\tap_cur->manuf = get_manufacturer(ap_cur->bssid[0], ap_cur->bssid[1], ap_cur->bssid[2]);\n\n\t\t\tsnprintf( strbuf + G.maxsize_essid_seen , sizeof(strbuf)-G.maxsize_essid_seen, \"  %s\", ap_cur->manuf );\n\t\t}\n\n\t\t// write spaces (32) until the end of column\n\t\tmemset( strbuf+strlen(strbuf), 32, ws_col - (columns_ap - 4 ) );\n\n\t\t// end the string at the end of the column\n\t\tstrbuf[ws_col - (columns_ap - 4)] = '\\0';\n\n\t\tfprintf( stderr, \"  %s\", strbuf );\n\t    }\n\n\t    fprintf( stderr, \"\\n\" );\n\n\t    if( (G.selection_ap && ((num_ap) == G.selected_ap)) || (ap_cur->marked) ) {\n\t\ttextstyle(TEXT_RESET);\n\t    }\n\n\t    ap_cur = ap_cur->prev;\n\t}\n\n\t/* print some informations about each detected station */\n\n\tnlines += 3;\n\n\tif( nlines >= (ws_row-1) )\n\t    return;\n\n\tmemset( strbuf, ' ', ws_col - 1 );\n\tstrbuf[ws_col - 1] = '\\0';\n\tfprintf( stderr, \"%s\\n\", strbuf );\n    }\n\n    if(G.show_sta) {\n\tmemcpy( strbuf, \" BSSID              STATION \"\n\t\t\"           PWR   Rate    Lost    Frames  Probes\", columns_sta );\n\tstrbuf[ws_col - 1] = '\\0';\n\tfprintf( stderr, \"%s\\n\", strbuf );\n\n\tmemset( strbuf, ' ', ws_col - 1 );\n\tstrbuf[ws_col - 1] = '\\0';\n\tfprintf( stderr, \"%s\\n\", strbuf );\n\n\tap_cur = G.ap_end;\n\n\tnum_sta = 0;\n\n\twhile( ap_cur != NULL )\n\t{\n\t    if( ap_cur->nb_pkt < 2 ||\n\t\ttime( NULL ) - ap_cur->tlast > G.berlin )\n\t    {\n\t\tap_cur = ap_cur->prev;\n\t\tcontinue;\n\t    }\n\n\t    if(ap_cur->security != 0 && G.f_encrypt != 0 && ((ap_cur->security & G.f_encrypt) == 0))\n\t    {\n\t\tap_cur = ap_cur->prev;\n\t\tcontinue;\n\t    }\n\n\t    // Don't filter unassociated clients by ESSID\n\t    if(memcmp(ap_cur->bssid, BROADCAST, 6) && is_filtered_essid(ap_cur->essid))\n\t    {\n\t\tap_cur = ap_cur->prev;\n\t\tcontinue;\n\t    }\n\n\t    if( nlines >= (ws_row-1) )\n\t\treturn;\n\n\t    st_cur = G.st_end;\n\n\t    if(G.selection_ap && (memcmp(G.selected_bssid, ap_cur->bssid, 6)==0)) {\n\t\ttextstyle(TEXT_REVERSE);\n\t    }\n\n\t    if(ap_cur->marked) {\n\t\ttextcolor_fg(ap_cur->marked_color);\n\t    }\n\n\t    while( st_cur != NULL )\n\t    {\n\t\tif( st_cur->base != ap_cur ||\n\t\t    time( NULL ) - st_cur->tlast > G.berlin )\n\t\t{\n\t\t    st_cur = st_cur->prev;\n\t\t    continue;\n\t\t}\n\n\t\tif( ! memcmp( ap_cur->bssid, BROADCAST, 6 ) && G.asso_client )\n\t\t{\n\t\t    st_cur = st_cur->prev;\n\t\t    continue;\n\t\t}\n\n\t\tnum_sta++;\n\n\t\tif(G.start_print_sta > num_sta)\n\t\t    continue;\n\n\t\tnlines++;\n\n\t\tif( ws_row != 0 && nlines >= ws_row )\n\t\t    return;\n\n\t\tif( ! memcmp( ap_cur->bssid, BROADCAST, 6 ) )\n\t\t    fprintf( stderr, \" (not associated) \" );\n\t\telse\n\t\t    fprintf( stderr, \" %02X:%02X:%02X:%02X:%02X:%02X\",\n\t\t\t    ap_cur->bssid[0], ap_cur->bssid[1],\n\t\t\t    ap_cur->bssid[2], ap_cur->bssid[3],\n\t\t\t    ap_cur->bssid[4], ap_cur->bssid[5] );\n\n\t\tfprintf( stderr, \"  %02X:%02X:%02X:%02X:%02X:%02X\",\n\t\t\tst_cur->stmac[0], st_cur->stmac[1],\n\t\t\tst_cur->stmac[2], st_cur->stmac[3],\n\t\t\tst_cur->stmac[4], st_cur->stmac[5] );\n\n\t\tfprintf( stderr, \"  %3d \", st_cur->power    );\n\t\tfprintf( stderr, \"  %2d\", st_cur->rate_to/1000000  );\n\t\tfprintf( stderr,  \"%c\", (st_cur->qos_fr_ds) ? 'e' : ' ');\n\t\tfprintf( stderr,  \"-%2d\", st_cur->rate_from/1000000);\n\t\tfprintf( stderr,  \"%c\", (st_cur->qos_to_ds) ? 'e' : ' ');\n\t\tfprintf( stderr, \"  %4d\", st_cur->missed   );\n\t\tfprintf( stderr, \" %8ld\", st_cur->nb_pkt   );\n\n\t\tif( ws_col > (columns_sta - 6) )\n\t\t{\n\t\t    memset( ssid_list, 0, sizeof( ssid_list ) );\n\n\t\t    for( i = 0, n = 0; i < NB_PRB; i++ )\n\t\t    {\n\t\t\tif( st_cur->probes[i][0] == '\\0' )\n\t\t\t    continue;\n\n\t\t\tsnprintf( ssid_list + n, sizeof( ssid_list ) - n - 1,\n\t\t\t\t\"%c%s\", ( i > 0 ) ? ',' : ' ',\n\t\t\t\tst_cur->probes[i] );\n\n\t\t\tn += ( 1 + strlen( st_cur->probes[i] ) );\n\n\t\t\tif( n >= (int) sizeof( ssid_list ) )\n\t\t\t    break;\n\t\t    }\n\n\t\t    memset( strbuf, 0, sizeof( strbuf ) );\n\t\t    snprintf( strbuf,  sizeof( strbuf ) - 1,\n\t\t\t    \"%-256s\", ssid_list );\n\t\t    strbuf[ws_col - (columns_sta - 6)] = '\\0';\n\t\t    fprintf( stderr, \" %s\", strbuf );\n\t\t}\n\n\t\tfprintf( stderr, \"\\n\" );\n\n\t\tst_cur = st_cur->prev;\n\t    }\n\n\t    if( (G.selection_ap && (memcmp(G.selected_bssid, ap_cur->bssid, 6)==0)) || (ap_cur->marked) ) {\n\t\ttextstyle(TEXT_RESET);\n\t    }\n\n\t    ap_cur = ap_cur->prev;\n\t}\n    }\n\n    if(G.show_ack)\n    {\n        /* print some informations about each unknown station */\n\n        nlines += 3;\n\n        if( nlines >= (ws_row-1) )\n            return;\n\n        memset( strbuf, ' ', ws_col - 1 );\n        strbuf[ws_col - 1] = '\\0';\n        fprintf( stderr, \"%s\\n\", strbuf );\n\n        memcpy( strbuf, \" MAC       \"\n                \"          CH PWR    ACK ACK/s    CTS RTS_RX RTS_TX  OTHER\", columns_na );\n        strbuf[ws_col - 1] = '\\0';\n        fprintf( stderr, \"%s\\n\", strbuf );\n\n        memset( strbuf, ' ', ws_col - 1 );\n        strbuf[ws_col - 1] = '\\0';\n        fprintf( stderr, \"%s\\n\", strbuf );\n\n        na_cur = G.na_1st;\n\n        while( na_cur != NULL )\n        {\n            if( time( NULL ) - na_cur->tlast > 120 )\n            {\n                na_cur = na_cur->next;\n                continue;\n            }\n\n            if( nlines >= (ws_row-1) )\n                return;\n\n            nlines++;\n\n            if( ws_row != 0 && nlines >= ws_row )\n                return;\n\n            fprintf( stderr, \" %02X:%02X:%02X:%02X:%02X:%02X\",\n                    na_cur->namac[0], na_cur->namac[1],\n                    na_cur->namac[2], na_cur->namac[3],\n                    na_cur->namac[4], na_cur->namac[5] );\n\n            fprintf( stderr, \"  %3d\", na_cur->channel  );\n            fprintf( stderr, \" %3d\", na_cur->power  );\n            fprintf( stderr, \" %6d\", na_cur->ack );\n            fprintf( stderr, \"  %4d\", na_cur->ackps );\n            fprintf( stderr, \" %6d\", na_cur->cts );\n            fprintf( stderr, \" %6d\", na_cur->rts_r );\n            fprintf( stderr, \" %6d\", na_cur->rts_t );\n            fprintf( stderr, \" %6d\", na_cur->other );\n\n            fprintf( stderr, \"\\n\" );\n\n            na_cur = na_cur->next;\n        }\n    }\n}\n\nint dump_write_csv( void )\n{\n    int i, j, n;\n    struct tm *ltime;\n    char ssid_list[512];\n    struct AP_info *ap_cur;\n    struct ST_info *st_cur;\n\n    if (! G.record_data || !G.output_format_csv)\n    \treturn 0;\n\n    fseek( G.f_txt, 0, SEEK_SET );\n\n    fprintf( G.f_txt,\n        \"\\r\\nBSSID, First time seen, Last time seen, channel, Speed, \"\n        \"Privacy, Cipher, Authentication, Power, # beacons, # IV, LAN IP, ID-length, ESSID, Key\\r\\n\" );\n\n    ap_cur = G.ap_1st;\n\n    while( ap_cur != NULL )\n    {\n        if( memcmp( ap_cur->bssid, BROADCAST, 6 ) == 0 )\n        {\n            ap_cur = ap_cur->next;\n            continue;\n        }\n\n        if(ap_cur->security != 0 && G.f_encrypt != 0 && ((ap_cur->security & G.f_encrypt) == 0))\n        {\n            ap_cur = ap_cur->next;\n            continue;\n        }\n\n        if(is_filtered_essid(ap_cur->essid) || ap_cur->nb_pkt < 2)\n        {\n            ap_cur = ap_cur->next;\n            continue;\n        }\n\n        fprintf( G.f_txt, \"%02X:%02X:%02X:%02X:%02X:%02X, \",\n                 ap_cur->bssid[0], ap_cur->bssid[1],\n                 ap_cur->bssid[2], ap_cur->bssid[3],\n                 ap_cur->bssid[4], ap_cur->bssid[5] );\n\n        ltime = localtime( &ap_cur->tinit );\n\n        fprintf( G.f_txt, \"%04d-%02d-%02d %02d:%02d:%02d, \",\n                 1900 + ltime->tm_year, 1 + ltime->tm_mon,\n                 ltime->tm_mday, ltime->tm_hour,\n                 ltime->tm_min,  ltime->tm_sec );\n\n        ltime = localtime( &ap_cur->tlast );\n\n        fprintf( G.f_txt, \"%04d-%02d-%02d %02d:%02d:%02d, \",\n                 1900 + ltime->tm_year, 1 + ltime->tm_mon,\n                 ltime->tm_mday, ltime->tm_hour,\n                 ltime->tm_min,  ltime->tm_sec );\n\n        fprintf( G.f_txt, \"%2d, %3d, \",\n                 ap_cur->channel,\n                 ap_cur->max_speed );\n\n        if( (ap_cur->security & (STD_OPN|STD_WEP|STD_WPA|STD_WPA2)) == 0) fprintf( G.f_txt, \"    \" );\n        else\n        {\n            if( ap_cur->security & STD_WPA2 ) fprintf( G.f_txt, \"WPA2\" );\n            if( ap_cur->security & STD_WPA  ) fprintf( G.f_txt, \"WPA \" );\n            if( ap_cur->security & STD_WEP  ) fprintf( G.f_txt, \"WEP \" );\n            if( ap_cur->security & STD_OPN  ) fprintf( G.f_txt, \"OPN \" );\n        }\n\n        fprintf( G.f_txt, \",\");\n\n        if( (ap_cur->security & (ENC_WEP|ENC_TKIP|ENC_WRAP|ENC_CCMP|ENC_WEP104|ENC_WEP40)) == 0 ) fprintf( G.f_txt, \"       \");\n        else\n        {\n            if( ap_cur->security & ENC_CCMP   ) fprintf( G.f_txt, \" CCMP\");\n            if( ap_cur->security & ENC_WRAP   ) fprintf( G.f_txt, \" WRAP\");\n            if( ap_cur->security & ENC_TKIP   ) fprintf( G.f_txt, \" TKIP\");\n            if( ap_cur->security & ENC_WEP104 ) fprintf( G.f_txt, \" WEP104\");\n            if( ap_cur->security & ENC_WEP40  ) fprintf( G.f_txt, \" WEP40\");\n            if( ap_cur->security & ENC_WEP    ) fprintf( G.f_txt, \" WEP\");\n        }\n\n        fprintf( G.f_txt, \",\");\n\n        if( (ap_cur->security & (AUTH_OPN|AUTH_PSK|AUTH_MGT)) == 0 ) fprintf( G.f_txt, \"   \");\n        else\n        {\n            if( ap_cur->security & AUTH_MGT   ) fprintf( G.f_txt, \" MGT\");\n            if( ap_cur->security & AUTH_PSK   )\n\t\t\t{\n\t\t\t\tif( ap_cur->security & STD_WEP )\n\t\t\t\t\tfprintf( G.f_txt, \"SKA\");\n\t\t\t\telse\n\t\t\t\t\tfprintf( G.f_txt, \"PSK\");\n\t\t\t}\n            if( ap_cur->security & AUTH_OPN   ) fprintf( G.f_txt, \" OPN\");\n        }\n\n        fprintf( G.f_txt, \", %3d, %8ld, %8ld, \",\n                 ap_cur->avg_power,\n                 ap_cur->nb_bcn,\n                 ap_cur->nb_data );\n\n        fprintf( G.f_txt, \"%3d.%3d.%3d.%3d, \",\n                 ap_cur->lanip[0], ap_cur->lanip[1],\n                 ap_cur->lanip[2], ap_cur->lanip[3] );\n\n        fprintf( G.f_txt, \"%3d, \", ap_cur->ssid_length);\n\n        for(i=0; i<ap_cur->ssid_length; i++)\n        {\n            fprintf( G.f_txt, \"%c\", ap_cur->essid[i] );\n        }\n        fprintf( G.f_txt, \", \" );\n\n\n        if(ap_cur->key != NULL)\n        {\n            for(i=0; i<(int)strlen(ap_cur->key); i++)\n            {\n                fprintf( G.f_txt, \"%02X\", ap_cur->key[i]);\n                if(i<(int)(strlen(ap_cur->key)-1))\n                    fprintf( G.f_txt, \":\");\n            }\n        }\n\n        fprintf( G.f_txt, \"\\r\\n\");\n\n        ap_cur = ap_cur->next;\n    }\n\n    fprintf( G.f_txt,\n        \"\\r\\nStation MAC, First time seen, Last time seen, \"\n        \"Power, # packets, BSSID, Probed ESSIDs\\r\\n\" );\n\n    st_cur = G.st_1st;\n\n    while( st_cur != NULL )\n    {\n        ap_cur = st_cur->base;\n\n        if( ap_cur->nb_pkt < 2 )\n        {\n            st_cur = st_cur->next;\n            continue;\n        }\n\n        fprintf( G.f_txt, \"%02X:%02X:%02X:%02X:%02X:%02X, \",\n                 st_cur->stmac[0], st_cur->stmac[1],\n                 st_cur->stmac[2], st_cur->stmac[3],\n                 st_cur->stmac[4], st_cur->stmac[5] );\n\n        ltime = localtime( &st_cur->tinit );\n\n        fprintf( G.f_txt, \"%04d-%02d-%02d %02d:%02d:%02d, \",\n                 1900 + ltime->tm_year, 1 + ltime->tm_mon,\n                 ltime->tm_mday, ltime->tm_hour,\n                 ltime->tm_min,  ltime->tm_sec );\n\n        ltime = localtime( &st_cur->tlast );\n\n        fprintf( G.f_txt, \"%04d-%02d-%02d %02d:%02d:%02d, \",\n                 1900 + ltime->tm_year, 1 + ltime->tm_mon,\n                 ltime->tm_mday, ltime->tm_hour,\n                 ltime->tm_min,  ltime->tm_sec );\n\n        fprintf( G.f_txt, \"%3d, %8ld, \",\n                 st_cur->power,\n                 st_cur->nb_pkt );\n\n        if( ! memcmp( ap_cur->bssid, BROADCAST, 6 ) )\n            fprintf( G.f_txt, \"(not associated) ,\" );\n        else\n            fprintf( G.f_txt, \"%02X:%02X:%02X:%02X:%02X:%02X,\",\n                     ap_cur->bssid[0], ap_cur->bssid[1],\n                     ap_cur->bssid[2], ap_cur->bssid[3],\n                     ap_cur->bssid[4], ap_cur->bssid[5] );\n\n        memset( ssid_list, 0, sizeof( ssid_list ) );\n\n        for( i = 0, n = 0; i < NB_PRB; i++ )\n        {\n            if( st_cur->probes[i][0] == '\\0' )\n                continue;\n\n            snprintf( ssid_list + n, sizeof( ssid_list ) - n - 1,\n                      \"%c\", ( i > 0 ) ? ',' : ' ' );\n\n            for(j=0; j<st_cur->ssid_length[i]; j++)\n            {\n                snprintf( ssid_list + n + 1 + j, sizeof( ssid_list ) - n - 2 - j,\n                          \"%c\", st_cur->probes[i][j]);\n            }\n\n            n += ( 1 + st_cur->ssid_length[i] );\n            if( n >= (int) sizeof( ssid_list ) )\n                break;\n        }\n\n        fprintf( G.f_txt, \"%s\\r\\n\", ssid_list );\n\n        st_cur = st_cur->next;\n    }\n\n    fprintf( G.f_txt, \"\\r\\n\" );\n    fflush( G.f_txt );\n    return 0;\n}\n\nchar * sanitize_xml(unsigned char * text, int length)\n{\n\tint i;\n\tsize_t len;\n\tunsigned char * pos;\n\tchar * newpos;\n\tchar * newtext = NULL;\n\tif (text != NULL && length > 0) {\n\t\tlen = 6 * length;\n\t\tnewtext = (char *)calloc(1, (len + 1) * sizeof(char)); // Make sure we have enough space\n\t\tpos = text;\n\t\tfor (i = 0; i < length; ++i, ++pos) {\n\t\t\tswitch (*pos) {\n\t\t\t\tcase '&':\n\t\t\t\t\tstrncat(newtext, \"&amp;\", len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tstrncat(newtext, \"&lt;\", len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tstrncat(newtext, \"&gt;\", len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\'':\n\t\t\t\t\tstrncat(newtext, \"&apos;\", len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\"':\n\t\t\t\t\tstrncat(newtext, \"&quot;\", len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif ( isprint((int)(*pos)) || (*pos)>127 ) {\n\t\t\t\t\t\tnewtext[strlen(newtext)] = *pos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewtext[strlen(newtext)] = '\\\\';\n\t\t\t\t\t\tnewpos = newtext + strlen(newtext);\n\t\t\t\t\t\tsnprintf(newpos, strlen(newpos) + 1, \"%3u\", *pos);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnewtext = (char *) realloc(newtext, strlen(newtext) + 1);\n\t}\n\n\treturn newtext;\n}\n\n\n#define OUI_STR_SIZE 8\n#define MANUF_SIZE 128\nchar *get_manufacturer(unsigned char mac0, unsigned char mac1, unsigned char mac2) {\n\tstatic char * oui_location = NULL;\n\tchar oui[OUI_STR_SIZE + 1];\n\tchar *manuf;\n\t//char *buffer_manuf;\n\tchar * manuf_str;\n\tstruct oui *ptr;\n\tFILE *fp;\n\tchar buffer[BUFSIZ];\n\tchar temp[OUI_STR_SIZE + 1];\n\tunsigned char a[2];\n\tunsigned char b[2];\n\tunsigned char c[2];\n\tint found = 0;\n\n\tif ((manuf = (char *)calloc(1, MANUF_SIZE * sizeof(char))) == NULL) {\n\t\tperror(\"calloc failed\");\n\t\treturn NULL;\n\t}\n\n\tsnprintf(oui, sizeof(oui), \"%02X:%02X:%02X\", mac0, mac1, mac2 );\n\n\tif (G.manufList != NULL) {\n\t\t// Search in the list\n\t\tptr = G.manufList;\n\t\twhile (ptr != NULL) {\n\t\t\tfound = ! strncasecmp(ptr->id, oui, OUI_STR_SIZE);\n\t\t\tif (found) {\n\t\t\t\tmemcpy(manuf, ptr->manuf, MANUF_SIZE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr->next;\n\t\t}\n\t} else {\n\t\t// If the file exist, then query it each time we need to get a manufacturer.\n\t\tif (oui_location == NULL) {\n\t\t\tfp = fopen(OUI_PATH0, \"r\");\n\t\t\tif (fp == NULL) {\n\t\t\t\tfp = fopen(OUI_PATH1, \"r\");\n\t\t\t\tif (fp == NULL) {\n\t\t\t\t    fp = fopen(OUI_PATH2, \"r\");\n\t\t\t\t    if (fp != NULL) {\n\t\t\t\t\toui_location = OUI_PATH2;\n\t\t\t\t    }\n\t\t\t\t} else {\n\t\t\t\t    oui_location = OUI_PATH1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toui_location = OUI_PATH0;\n\t\t\t}\n\t\t} else {\n\t\t\tfp = fopen(oui_location, \"r\");\n\t\t}\n\n\t\tif (fp != NULL) {\n\n\t\t\tmemset(buffer, 0x00, sizeof(buffer));\n\t\t\twhile (fgets(buffer, sizeof(buffer), fp) != NULL) {\n\t\t\t\tif (strstr(buffer, \"(hex)\") == NULL) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmemset(a, 0x00, sizeof(a));\n\t\t\t\tmemset(b, 0x00, sizeof(b));\n\t\t\t\tmemset(c, 0x00, sizeof(c));\n\t\t\t\tif (sscanf(buffer, \"%2c-%2c-%2c\", a, b, c) == 3) {\n\t\t\t\t\tsnprintf(temp, sizeof(temp), \"%c%c:%c%c:%c%c\", a[0], a[1], b[0], b[1], c[0], c[1] );\n\t\t\t\t\tfound = !memcmp(temp, oui, strlen(oui));\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\tmanuf_str = get_manufacturer_from_string(buffer);\n\t\t\t\t\t\tif (manuf_str != NULL) {\n\t\t\t\t\t\t\tsnprintf(manuf, MANUF_SIZE, \"%s\", manuf_str);\n\t\t\t\t\t\t\tfree(manuf_str);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmemset(buffer, 0x00, sizeof(buffer));\n\t\t\t}\n\n\t\t\tfclose(fp);\n\t\t}\n\t}\n\n\t// Not found, use \"Unknown\".\n\tif (!found || *manuf == '\\0') {\n\t\tmemcpy(manuf, \"Unknown\", 7);\n\t\tmanuf[strlen(manuf)] = '\\0';\n\t}\n\n\tmanuf = (char *)realloc(manuf, (strlen(manuf) + 1) * sizeof(char));\n\n\treturn manuf;\n}\n#undef OUI_STR_SIZE\n#undef MANUF_SIZE\n\n\n#define KISMET_NETXML_HEADER_BEGIN \"<?xml version=\\\"1.0\\\" encoding=\\\"ISO-8859-1\\\"?>\\n<!DOCTYPE detection-run SYSTEM \\\"http://kismetwireless.net/kismet-3.1.0.dtd\\\">\\n\\n<detection-run kismet-version=\\\"airodump-ng-1.0\\\" start-time=\\\"\"\n#define KISMET_NETXML_HEADER_END \"\\\">\\n\\n\"\n\n#define KISMET_NETXML_TRAILER \"</detection-run>\"\n\n#define TIME_STR_LENGTH 255\nint dump_write_kismet_netxml( void )\n{\n    int network_number, average_power, client_nbr;\n    int client_max_rate, unused;\n    struct AP_info *ap_cur;\n    struct ST_info *st_cur;\n    char first_time[TIME_STR_LENGTH];\n    char last_time[TIME_STR_LENGTH];\n    char * manuf;\n    char * essid = NULL;\n\n    if (! G.record_data || !G.output_format_kismet_netxml)\n    \treturn 0;\n\n    fseek( G.f_kis_xml, 0, SEEK_SET );\n\n\t/* Header and airodump-ng start time */\n    fprintf( G.f_kis_xml, \"%s%s%s\",\n    \t\tKISMET_NETXML_HEADER_BEGIN,\n\t\t\tG.airodump_start_time,\n    \t\tKISMET_NETXML_HEADER_END );\n\n\n    ap_cur = G.ap_1st;\n\n    network_number = 0;\n    while( ap_cur != NULL )\n    {\n        if( memcmp( ap_cur->bssid, BROADCAST, 6 ) == 0 )\n        {\n            ap_cur = ap_cur->next;\n            continue;\n        }\n\n        if(ap_cur->security != 0 && G.f_encrypt != 0 && ((ap_cur->security & G.f_encrypt) == 0))\n        {\n            ap_cur = ap_cur->next;\n            continue;\n        }\n\n        if(is_filtered_essid(ap_cur->essid) || ap_cur->nb_pkt < 2 /* XXX: Maybe this last check should be removed */ )\n        {\n            ap_cur = ap_cur->next;\n            continue;\n        }\n\n\t\t++network_number; // Network Number\n\t\tstrncpy(first_time, ctime(&ap_cur->tinit), TIME_STR_LENGTH - 1);\n\t\tfirst_time[strlen(first_time) - 1] = 0; // remove new line\n\n\t\tstrncpy(last_time, ctime(&ap_cur->tlast), TIME_STR_LENGTH - 1);\n\t\tlast_time[strlen(last_time) - 1] = 0; // remove new line\n\n\t\tfprintf(G.f_kis_xml, \"\\t<wireless-network number=\\\"%d\\\" type=\\\"infrastructure\\\" \",\n\t\t\tnetwork_number);\n\t\tfprintf(G.f_kis_xml, \"first-time=\\\"%s\\\" last-time=\\\"%s\\\">\\n\", first_time, last_time);\n\n\t\tfprintf(G.f_kis_xml, \"\\t\\t<SSID first-time=\\\"%s\\\" last-time=\\\"%s\\\">\\n\",\n\t\t\t\tfirst_time, last_time);\n\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<type>Beacon</type>\\n\" );\n\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<max-rate>%d.000000</max-rate>\\n\", ap_cur->max_speed );\n\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<packets>%ld</packets>\\n\", ap_cur->nb_bcn );\n\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<beaconrate>%d</beaconrate>\\n\", 10 );\n\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<encryption>\");\n\t\t//Encryption\n\t\tif( (ap_cur->security & (STD_OPN|STD_WEP|STD_WPA|STD_WPA2)) != 0)\n\t\t{\n\t\t\tif( ap_cur->security & STD_WPA2 ) fprintf( G.f_kis_xml, \"WPA2 \" );\n\t\t\tif( ap_cur->security & STD_WPA  ) fprintf( G.f_kis_xml, \"WPA \" );\n\t\t\tif( ap_cur->security & STD_WEP  ) fprintf( G.f_kis_xml, \"WEP \" );\n\t\t\tif( ap_cur->security & STD_OPN  ) fprintf( G.f_kis_xml, \"OPN \" );\n\t\t}\n\n\t\tif( (ap_cur->security & (ENC_WEP|ENC_TKIP|ENC_WRAP|ENC_CCMP|ENC_WEP104|ENC_WEP40)) != 0 )\n\t\t{\n\t\t\tif( ap_cur->security & ENC_CCMP   ) fprintf( G.f_kis_xml, \"AES-CCM \");\n\t\t\tif( ap_cur->security & ENC_WRAP   ) fprintf( G.f_kis_xml, \"WRAP \");\n\t\t\tif( ap_cur->security & ENC_TKIP   ) fprintf( G.f_kis_xml, \"TKIP \");\n\t\t\tif( ap_cur->security & ENC_WEP104 ) fprintf( G.f_kis_xml, \"WEP104 \");\n\t\t\tif( ap_cur->security & ENC_WEP40  ) fprintf( G.f_kis_xml, \"WEP40 \");\n/*      \tif( ap_cur->security & ENC_WEP    ) fprintf( G.f_kis_xml, \"WEP \");*/\n\t\t}\n\t\tfprintf(G.f_kis_xml, \"</encryption>\\n\");\n\n\t\t/* ESSID */\n\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<essid cloaked=\\\"%s\\\">\",\n\t\t\t\t\t(ap_cur->essid[0] == 0) ? \"true\" : \"false\");\n\t\tessid = sanitize_xml(ap_cur->essid, ap_cur->ssid_length);\n\t\tif (essid != NULL) {\n\t\t\tfprintf(G.f_kis_xml, \"%s\", essid);\n\t\t\tfree(essid);\n\t\t}\n\t\tfprintf(G.f_kis_xml, \"</essid>\\n\");\n\n\t\t/* End of SSID tag */\n\t\tfprintf(G.f_kis_xml, \"\\t\\t</SSID>\\n\");\n\n\t\t/* BSSID */\n\t\tfprintf( G.f_kis_xml, \"\\t\\t<BSSID>%02X:%02X:%02X:%02X:%02X:%02X</BSSID>\\n\",\n\t\t\t\t\t ap_cur->bssid[0], ap_cur->bssid[1],\n\t\t\t\t\t ap_cur->bssid[2], ap_cur->bssid[3],\n\t\t\t\t\t ap_cur->bssid[4], ap_cur->bssid[5] );\n\n\t\t/* Manufacturer, if set using standard oui list */\n\t\tmanuf = sanitize_xml((unsigned char *)ap_cur->manuf, strlen(ap_cur->manuf));\n\t\tfprintf(G.f_kis_xml, \"\\t\\t<manuf>%s</manuf>\\n\", (manuf != NULL) ? manuf : \"Unknown\");\n\t\tfree(manuf);\n\n\t\t/* Channel\n\t\t   FIXME: Take G.freqoption in account */\n\t\tfprintf(G.f_kis_xml, \"\\t\\t<channel>%d</channel>\\n\", ap_cur->channel);\n\n\t\t/* Freq (in Mhz) and total number of packet on that frequency\n\t\t   FIXME: Take G.freqoption in account */\n\t\tfprintf(G.f_kis_xml, \"\\t\\t<freqmhz>%d %ld</freqmhz>\\n\",\n\t\t\t\t\tgetFrequencyFromChannel(ap_cur->channel),\n\t\t\t\t\t//ap_cur->nb_data + ap_cur->nb_bcn );\n\t\t\t\t\tap_cur->nb_pkt );\n\n\t\t/* XXX: What about 5.5Mbit */\n\t\tfprintf(G.f_kis_xml, \"\\t\\t<maxseenrate>%d</maxseenrate>\\n\", ap_cur->max_speed * 1000);\n\n\t\t/* Packets */\n\t\tfprintf(G.f_kis_xml, \"\\t\\t<packets>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<LLC>%ld</LLC>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<data>%ld</data>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<crypt>0</crypt>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<total>%ld</total>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<fragments>0</fragments>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<retries>0</retries>\\n\"\n\t\t\t\t\t\"\\t\\t</packets>\\n\",\n\t\t\t\t\tap_cur->nb_bcn, ap_cur->nb_data,\n\t\t\t\t\t//ap_cur->nb_data + ap_cur->nb_bcn );\n\t\t\t\t\tap_cur->nb_pkt );\n\n\n\t\t/*\n\t\t * XXX: What does that field mean? Is it the total size of data?\n\t\t *      It seems that 'd' is appended at the end for clients, why?\n\t\t */\n\t\tfprintf(G.f_kis_xml, \"\\t\\t<datasize>0</datasize>\\n\");\n\n\t\t/* Client information */\n\t\tst_cur = G.st_1st;\n\t\tclient_nbr = 0;\n\n\t\twhile ( st_cur != NULL )\n\t\t{\n\t\t\t/* If not associated or Broadcast Mac, try next one */\n\t\t\tif ( st_cur->base == NULL ||\n\t\t\t\t memcmp( st_cur->stmac, BROADCAST, 6 ) == 0  )\n\t\t\t{\n\t\t\t\tst_cur = st_cur->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Compare BSSID */\n\t\t\tif ( memcmp( st_cur->base->bssid, ap_cur->bssid, 6 ) != 0 )\n\t\t\t{\n\t\t\t\tst_cur = st_cur->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t++client_nbr;\n\n\n\t\t\tstrncpy(first_time, ctime(&st_cur->tinit), TIME_STR_LENGTH - 1);\n\t\t\tfirst_time[strlen(first_time) - 1] = 0; // remove new line\n\n\t\t\tstrncpy(last_time, ctime(&st_cur->tlast), TIME_STR_LENGTH - 1);\n\t\t\tlast_time[strlen(last_time) - 1] = 0; // remove new line\n\n\t\t\tfprintf(G.f_kis_xml, \"\\t\\t<wireless-client number=\\\"%d\\\" \"\n\t\t\t\t\t\t\t\t \"type=\\\"established\\\" first-time=\\\"%s\\\"\"\n\t\t\t\t\t\t\t\t \" last-time=\\\"%s\\\">\\n\",\n\t\t\t\t\t\t\t\t client_nbr, first_time, last_time );\n\n\t\t\tfprintf( G.f_kis_xml, \"\\t\\t\\t<client-mac>%02X:%02X:%02X:%02X:%02X:%02X</client-mac>\\n\",\n\t\t\t\t\t\t st_cur->stmac[0], st_cur->stmac[1],\n\t\t\t\t\t\t st_cur->stmac[2], st_cur->stmac[3],\n\t\t\t\t\t\t st_cur->stmac[4], st_cur->stmac[5] );\n\n\t\t\t/* Manufacturer, if set using standard oui list */\n\t\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<client-manuf>%s</client-manuf>\\n\", (st_cur->manuf != NULL) ? st_cur->manuf : \"Unknown\");\n\n\t\t\t/* Channel\n\t\t\t   FIXME: Take G.freqoption in account */\n\t\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<channel>%d</channel>\\n\", ap_cur->channel);\n\n\t\t\t/* Rate: unaccurate because it's the latest rate seen */\n\t\t\tclient_max_rate = ( st_cur->rate_from > st_cur->rate_to ) ? st_cur->rate_from : st_cur->rate_to ;\n\t\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<maxseenrate>%.6f</maxseenrate>\\n\", client_max_rate / 1000000.0 );\n\n\t\t\t/* Packets */\n\t\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<packets>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t\\t<LLC>0</LLC>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t\\t<data>0</data>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t\\t<crypt>0</crypt>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t\\t<total>%ld</total>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t\\t<fragments>0</fragments>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t\\t<retries>0</retries>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t</packets>\\n\",\n\t\t\t\t\t\tst_cur->nb_pkt );\n\n\t\t\t/* SNR information */\n\t\t\taverage_power = (st_cur->power == -1) ? 0 : st_cur->power;\n\t\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<snr-info>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<last_signal_dbm>%d</last_signal_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<last_noise_dbm>0</last_noise_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<last_signal_rssi>%d</last_signal_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<last_noise_rssi>0</last_noise_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<min_signal_dbm>%d</min_signal_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<min_noise_dbm>0</min_noise_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<min_signal_rssi>1024</min_signal_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<min_noise_rssi>1024</min_noise_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<max_signal_dbm>%d</max_signal_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<max_noise_dbm>0</max_noise_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<max_signal_rssi>%d</max_signal_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t\\t<max_noise_rssi>0</max_noise_rssi>\\n\"\n\t\t\t\t\t \"\\t\\t\\t</snr-info>\\n\",\n\t\t\t\t\t average_power, average_power, average_power,\n\t\t\t\t\t average_power, average_power );\n\n\t\t\t/* GPS Coordinates\n\t\t\t   XXX: We don't have GPS coordinates for clients */\n\t\t\tif (G.usegpsd)\n\t\t\t{\n\t\t\t\tfprintf(G.f_kis_xml, \"\\t\\t<gps-info>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<min-lat>%.6f</min-lat>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<min-lon>%.6f</min-lon>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<min-alt>%.6f</min-alt>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<min-spd>%.6f</min-spd>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<max-lat>%.6f</max-lat>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<max-lon>%.6f</max-lon>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<max-alt>%.6f</max-alt>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<max-spd>%.6f</max-spd>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<peak-lat>%.6f</peak-lat>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<peak-lon>%.6f</peak-lon>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<peak-alt>%.6f</peak-alt>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<avg-lat>%.6f</avg-lat>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<avg-lon>%.6f</avg-lon>\\n\"\n\t\t\t\t\t\t\t\"\\t\\t\\t<avg-alt>%.6f</avg-alt>\\n\"\n\t\t\t\t\t\t\t \"\\t\\t</gps-info>\\n\",\n\t\t\t\t\t\t\t 0.0, 0.0, 0.0, 0.0,\n\t\t\t\t\t\t\t 0.0, 0.0, 0.0, 0.0,\n\t\t\t\t\t\t\t 0.0, 0.0, 0.0,\n\t\t\t\t\t\t\t 0.0, 0.0, 0.0 );\n\t\t\t}\n\n\n\t\t\t/* Trailing information */\n\t\t\tfprintf(G.f_kis_xml, \"\\t\\t\\t<cdp-device></cdp-device>\\n\"\n\t\t\t\t\t\t\t\t \"\\t\\t\\t<cdp-portid></cdp-portid>\\n\");\n\t\t\tfprintf(G.f_kis_xml, \"\\t\\t</wireless-client>\\n\" );\n\n\t\t\t/* Next client */\n\t\t\tst_cur = st_cur->next;\n\t\t}\n\n\t\t/* SNR information */\n\t\taverage_power = (ap_cur->avg_power == -1) ? 0 : ap_cur->avg_power;\n\t\tfprintf(G.f_kis_xml, \"\\t\\t<snr-info>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<last_signal_dbm>%d</last_signal_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<last_noise_dbm>0</last_noise_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<last_signal_rssi>%d</last_signal_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<last_noise_rssi>0</last_noise_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<min_signal_dbm>%d</min_signal_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<min_noise_dbm>0</min_noise_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<min_signal_rssi>1024</min_signal_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<min_noise_rssi>1024</min_noise_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<max_signal_dbm>%d</max_signal_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<max_noise_dbm>0</max_noise_dbm>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<max_signal_rssi>%d</max_signal_rssi>\\n\"\n\t\t\t\t\t\"\\t\\t\\t<max_noise_rssi>0</max_noise_rssi>\\n\"\n\t\t\t\t\t \"\\t\\t</snr-info>\\n\",\n\t\t\t\t\t average_power, average_power, average_power,\n\t\t\t\t\t average_power, average_power );\n\n\t\t/* GPS Coordinates */\n\t\tif (G.usegpsd)\n\t\t{\n\t\t\tfprintf(G.f_kis_xml, \"\\t\\t<gps-info>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<min-lat>%.6f</min-lat>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<min-lon>%.6f</min-lon>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<min-alt>%.6f</min-alt>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<min-spd>%.6f</min-spd>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<max-lat>%.6f</max-lat>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<max-lon>%.6f</max-lon>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<max-alt>%.6f</max-alt>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<max-spd>%.6f</max-spd>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<peak-lat>%.6f</peak-lat>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<peak-lon>%.6f</peak-lon>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<peak-alt>%.6f</peak-alt>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<avg-lat>%.6f</avg-lat>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<avg-lon>%.6f</avg-lon>\\n\"\n\t\t\t\t\t\t\"\\t\\t\\t<avg-alt>%.6f</avg-alt>\\n\"\n\t\t\t\t\t\t \"\\t\\t</gps-info>\\n\",\n\t\t\t\t\t\tap_cur->gps_loc_min[0],\n\t\t\t\t\t\tap_cur->gps_loc_min[1],\n\t\t\t\t\t\tap_cur->gps_loc_min[2],\n\t\t\t\t\t\tap_cur->gps_loc_min[3],\n\t\t\t\t\t\tap_cur->gps_loc_max[0],\n\t\t\t\t\t\tap_cur->gps_loc_max[1],\n\t\t\t\t\t\tap_cur->gps_loc_max[2],\n\t\t\t\t\t\tap_cur->gps_loc_max[3],\n\t\t\t\t\t\tap_cur->gps_loc_best[0],\n\t\t\t\t\t\tap_cur->gps_loc_best[1],\n\t\t\t\t\t\tap_cur->gps_loc_best[2],\n\t\t\t\t\t\t/* Can the \"best\" be considered as average??? */\n\t\t\t\t\t\tap_cur->gps_loc_best[0],\n\t\t\t\t\t\tap_cur->gps_loc_best[1],\n\t\t\t\t\t\tap_cur->gps_loc_best[2] );\n\t\t}\n\n\t\t/* Trailing information */\n\t\tfprintf(G.f_kis_xml, \"\\t\\t<bsstimestamp>0</bsstimestamp>\\n\"\n\t\t\t\t\t \"\\t\\t<cdp-device></cdp-device>\\n\"\n\t\t\t\t\t \"\\t\\t<cdp-portid></cdp-portid>\\n\");\n\n\t\t/* Closing tag for the current wireless network */\n\t\tfprintf(G.f_kis_xml, \"\\t</wireless-network>\\n\");\n\t\t//-------- End of XML\n\n        ap_cur = ap_cur->next;\n    }\n\n\t/* Trailing */\n    fprintf( G.f_kis_xml, \"%s\\n\", KISMET_NETXML_TRAILER );\n\n    fflush( G.f_kis_xml );\n\n    /* Sometimes there can be crap at the end of the file, so truncating is a good idea.\n       XXX: Is this really correct, I hope fileno() won't have any side effect */\n\tunused = ftruncate(fileno(G.f_kis_xml), ftell( G.f_kis_xml ) );\n\n    return 0;\n}\n#undef TIME_STR_LENGTH\n\n#define KISMET_HEADER \"Network;NetType;ESSID;BSSID;Info;Channel;Cloaked;Encryption;Decrypted;MaxRate;MaxSeenRate;Beacon;LLC;Data;Crypt;Weak;Total;Carrier;Encoding;FirstTime;LastTime;BestQuality;BestSignal;BestNoise;GPSMinLat;GPSMinLon;GPSMinAlt;GPSMinSpd;GPSMaxLat;GPSMaxLon;GPSMaxAlt;GPSMaxSpd;GPSBestLat;GPSBestLon;GPSBestAlt;DataSize;IPType;IP;\\n\"\n\n\nint dump_write_kismet_csv( void )\n{\n    int i, k;\n//     struct tm *ltime;\n/*    char ssid_list[512];*/\n    struct AP_info *ap_cur;\n\n    if (! G.record_data || !G.output_format_kismet_csv)\n    \treturn 0;\n\n    fseek( G.f_kis, 0, SEEK_SET );\n\n    fprintf( G.f_kis, KISMET_HEADER );\n\n    ap_cur = G.ap_1st;\n\n    k=1;\n    while( ap_cur != NULL )\n    {\n        if( memcmp( ap_cur->bssid, BROADCAST, 6 ) == 0 )\n        {\n            ap_cur = ap_cur->next;\n            continue;\n        }\n\n        if(ap_cur->security != 0 && G.f_encrypt != 0 && ((ap_cur->security & G.f_encrypt) == 0))\n        {\n            ap_cur = ap_cur->next;\n            continue;\n        }\n\n        if(is_filtered_essid(ap_cur->essid) || ap_cur->nb_pkt < 2)\n        {\n            ap_cur = ap_cur->next;\n            continue;\n        }\n\n        //Network\n        fprintf( G.f_kis, \"%d;\", k );\n\n        //NetType\n        fprintf( G.f_kis, \"infrastructure;\");\n\n        //ESSID\n        for(i=0; i<ap_cur->ssid_length; i++)\n        {\n            fprintf( G.f_kis, \"%c\", ap_cur->essid[i] );\n        }\n        fprintf( G.f_kis, \";\" );\n\n        //BSSID\n        fprintf( G.f_kis, \"%02X:%02X:%02X:%02X:%02X:%02X;\",\n                 ap_cur->bssid[0], ap_cur->bssid[1],\n                 ap_cur->bssid[2], ap_cur->bssid[3],\n                 ap_cur->bssid[4], ap_cur->bssid[5] );\n\n        //Info\n        fprintf( G.f_kis, \";\");\n\n        //Channel\n        fprintf( G.f_kis, \"%d;\", ap_cur->channel);\n\n        //Cloaked\n        fprintf( G.f_kis, \"No;\");\n\n        //Encryption\n        if( (ap_cur->security & (STD_OPN|STD_WEP|STD_WPA|STD_WPA2)) != 0)\n        {\n            if( ap_cur->security & STD_WPA2 ) fprintf( G.f_kis, \"WPA2,\" );\n            if( ap_cur->security & STD_WPA  ) fprintf( G.f_kis, \"WPA,\" );\n            if( ap_cur->security & STD_WEP  ) fprintf( G.f_kis, \"WEP,\" );\n            if( ap_cur->security & STD_OPN  ) fprintf( G.f_kis, \"OPN,\" );\n        }\n\n        if( (ap_cur->security & (ENC_WEP|ENC_TKIP|ENC_WRAP|ENC_CCMP|ENC_WEP104|ENC_WEP40)) == 0 ) fprintf( G.f_kis, \"None,\");\n        else\n        {\n            if( ap_cur->security & ENC_CCMP   ) fprintf( G.f_kis, \"AES-CCM,\");\n            if( ap_cur->security & ENC_WRAP   ) fprintf( G.f_kis, \"WRAP,\");\n            if( ap_cur->security & ENC_TKIP   ) fprintf( G.f_kis, \"TKIP,\");\n            if( ap_cur->security & ENC_WEP104 ) fprintf( G.f_kis, \"WEP104,\");\n            if( ap_cur->security & ENC_WEP40  ) fprintf( G.f_kis, \"WEP40,\");\n/*            if( ap_cur->security & ENC_WEP    ) fprintf( G.f_kis, \" WEP,\");*/\n        }\n\n        fseek(G.f_kis, -1, SEEK_CUR);\n        fprintf(G.f_kis, \";\");\n\n        //Decrypted\n        fprintf( G.f_kis, \"No;\");\n\n        //MaxRate\n        fprintf( G.f_kis, \"%d.0;\", ap_cur->max_speed );\n\n        //MaxSeenRate\n        fprintf( G.f_kis, \"0;\");\n\n        //Beacon\n        fprintf( G.f_kis, \"%ld;\", ap_cur->nb_bcn);\n\n        //LLC\n        fprintf( G.f_kis, \"0;\");\n\n        //Data\n        fprintf( G.f_kis, \"%ld;\", ap_cur->nb_data );\n\n        //Crypt\n        fprintf( G.f_kis, \"0;\");\n\n        //Weak\n        fprintf( G.f_kis, \"0;\");\n\n        //Total\n        fprintf( G.f_kis, \"%ld;\", ap_cur->nb_data );\n\n        //Carrier\n        fprintf( G.f_kis, \";\");\n\n        //Encoding\n        fprintf( G.f_kis, \";\");\n\n        //FirstTime\n        fprintf( G.f_kis, \"%s\", ctime(&ap_cur->tinit) );\n        fseek(G.f_kis, -1, SEEK_CUR);\n        fprintf( G.f_kis, \";\");\n\n        //LastTime\n        fprintf( G.f_kis, \"%s\", ctime(&ap_cur->tlast) );\n        fseek(G.f_kis, -1, SEEK_CUR);\n        fprintf( G.f_kis, \";\");\n\n        //BestQuality\n        fprintf( G.f_kis, \"%d;\", ap_cur->avg_power );\n\n        //BestSignal\n        fprintf( G.f_kis, \"0;\" );\n\n        //BestNoise\n        fprintf( G.f_kis, \"0;\" );\n\n        //GPSMinLat\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_min[0]);\n\n        //GPSMinLon\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_min[1]);\n\n        //GPSMinAlt\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_min[2]);\n\n        //GPSMinSpd\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_min[3]);\n\n        //GPSMaxLat\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_max[0]);\n\n        //GPSMaxLon\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_max[1]);\n\n        //GPSMaxAlt\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_max[2]);\n\n        //GPSMaxSpd\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_max[3]);\n\n        //GPSBestLat\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_best[0]);\n\n        //GPSBestLon\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_best[1]);\n\n        //GPSBestAlt\n        fprintf( G.f_kis, \"%.6f;\", ap_cur->gps_loc_best[2]);\n\n        //DataSize\n        fprintf( G.f_kis, \"0;\" );\n\n        //IPType\n        fprintf( G.f_kis, \"0;\" );\n\n        //IP\n        fprintf( G.f_kis, \"%d.%d.%d.%d;\",\n                 ap_cur->lanip[0], ap_cur->lanip[1],\n                 ap_cur->lanip[2], ap_cur->lanip[3] );\n\n        fprintf( G.f_kis, \"\\r\\n\");\n\n        ap_cur = ap_cur->next;\n        k++;\n    }\n\n    fflush( G.f_kis );\n    return 0;\n}\n\nvoid gps_tracker( void )\n{\n\tssize_t unused;\n    int gpsd_sock;\n    char line[256], *temp;\n    struct sockaddr_in gpsd_addr;\n    int ret, is_json, pos;\n    fd_set read_fd;\n    struct timeval timeout;\n\n    /* attempt to connect to localhost, port 2947 */\n\n    pos = 0;\n    gpsd_sock = socket( AF_INET, SOCK_STREAM, 0 );\n\n    if( gpsd_sock < 0 ) {\n        return;\n    }\n\n    gpsd_addr.sin_family      = AF_INET;\n    gpsd_addr.sin_port        = htons( 2947 );\n    gpsd_addr.sin_addr.s_addr = inet_addr( \"127.0.0.1\" );\n\n    if( connect( gpsd_sock, (struct sockaddr *) &gpsd_addr,\n                 sizeof( gpsd_addr ) ) < 0 ) {\n        return;\n    }\n\n    // Check if it's GPSd < 2.92 or the new one\n    // 2.92+ immediately send stuff\n    // < 2.92 requires to send PVTAD command\n    FD_ZERO(&read_fd);\n    FD_SET(gpsd_sock, &read_fd);\n    timeout.tv_sec = 1;\n    timeout.tv_usec = 0;\n    is_json = select(gpsd_sock + 1, &read_fd, NULL, NULL, &timeout);\n    if (is_json) {\n    \t/*\n\t\t\t{\"class\":\"VERSION\",\"release\":\"2.95\",\"rev\":\"2010-11-16T21:12:35\",\"proto_major\":3,\"proto_minor\":3}\n\t\t\t?WATCH={\"json\":true};\n\t\t\t{\"class\":\"DEVICES\",\"devices\":[]}\n    \t */\n\n\n    \t// Get the crap and ignore it: {\"class\":\"VERSION\",\"release\":\"2.95\",\"rev\":\"2010-11-16T21:12:35\",\"proto_major\":3,\"proto_minor\":3}\n    \tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n    \t\treturn;\n\n    \tis_json = (line[0] == '{');\n    \tif (is_json) {\n\t\t\t// Send ?WATCH={\"json\":true};\n\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\tstrcpy(line, \"?WATCH={\\\"json\\\":true};\\n\");\n\t\t\tif( send( gpsd_sock, line, 22, 0 ) != 22 )\n\t\t\t\treturn;\n\n\t\t\t// Check that we have devices\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t\tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n\t\t\t\treturn;\n\n\t\t\t// Stop processing if there is no device\n\t\t\tif (strncmp(line, \"{\\\"class\\\":\\\"DEVICES\\\",\\\"devices\\\":[]}\", 32) == 0) {\n\t\t\t\tclose(gpsd_sock);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpos = strlen(line);\n\t\t\t}\n    \t}\n    }\n\n    /* loop reading the GPS coordinates */\n\n    while( G.do_exit == 0 )\n    {\n        usleep( 500000 );\n        memset( G.gps_loc, 0, sizeof( float ) * 5 );\n\n        /* read position, speed, heading, altitude */\n        if (is_json) {\n        \t// Format definition: http://catb.org/gpsd/gpsd_json.html\n\n        \tif (pos == sizeof( line )) {\n        \t\tmemset(line, 0, sizeof(line));\n        \t\tpos = 0;\n        \t}\n\n        \t// New version, JSON\n        \tif( recv( gpsd_sock, line + pos, sizeof( line ) - pos - 1, 0 ) <= 0 )\n        \t\treturn;\n\n        \t// search for TPV class: {\"class\":\"TPV\"\n        \ttemp = strstr(line, \"{\\\"class\\\":\\\"TPV\\\"\");\n        \tif (temp == NULL) {\n        \t\tcontinue;\n        \t}\n\n        \t// Make sure the data we have is complete\n        \tif (strchr(temp, '}') == NULL) {\n        \t\t// Move the data at the beginning of the buffer;\n        \t\tpos = strlen(temp);\n        \t\tif (temp != line) {\n        \t\t\tmemmove(line, temp, pos);\n        \t\t\tmemset(line + pos, 0, sizeof(line) - pos);\n        \t\t}\n        \t}\n\n\t\t\t// Example line: {\"class\":\"TPV\",\"tag\":\"MID2\",\"device\":\"/dev/ttyUSB0\",\"time\":1350957517.000,\"ept\":0.005,\"lat\":46.878936576,\"lon\":-115.832602964,\"alt\":1968.382,\"track\":0.0000,\"speed\":0.000,\"climb\":0.000,\"mode\":3}\n\n        \t// Latitude\n        \ttemp = strstr(temp, \"\\\"lat\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[0]);\n\n\t\t\t// Longitude\n\t\t\ttemp = strstr(temp, \"\\\"lon\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[1]);\n\n\t\t\t// Altitude\n\t\t\ttemp = strstr(temp, \"\\\"alt\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[4]);\n\n\t\t\t// Speed\n\t\t\ttemp = strstr(temp, \"\\\"speed\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[2]);\n\n\t\t\t// No more heading\n\n\t\t\t// Get the next TPV class\n\t\t\ttemp = strstr(temp, \"{\\\"class\\\":\\\"TPV\\\"\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\t\tpos = 0;\n\t\t\t} else {\n\t\t\t\tpos = strlen(temp);\n\t\t\t\tmemmove(line, temp, pos);\n\t\t\t\tmemset(line + pos, 0, sizeof(line) - pos);\n\t\t\t}\n\n        } else {\n        \tmemset( line, 0, sizeof( line ) );\n\n\t\t\tsnprintf( line,  sizeof( line ) - 1, \"PVTAD\\r\\n\" );\n\t\t\tif( send( gpsd_sock, line, 7, 0 ) != 7 )\n\t\t\t\treturn;\n\n\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n\t\t\t\treturn;\n\n\t\t\tif( memcmp( line, \"GPSD,P=\", 7 ) != 0 )\n\t\t\t\tcontinue;\n\n\t\t\t/* make sure the coordinates are present */\n\n\t\t\tif( line[7] == '?' )\n\t\t\t\tcontinue;\n\n\t\t\tret = sscanf( line + 7, \"%f %f\", &G.gps_loc[0], &G.gps_loc[1] );\n\n\t\t\tif( ( temp = strstr( line, \"V=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[2] ); /* speed */\n\n\t\t\tif( ( temp = strstr( line, \"T=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[3] ); /* heading */\n\n\t\t\tif( ( temp = strstr( line, \"A=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[4] ); /* altitude */\n        }\n\n        if (G.record_data)\n\t\t\tfputs( line, G.f_gps );\n\n\t\tG.save_gps = 1;\n\n        if (G.do_exit == 0)\n\t\t{\n\t\t\tunused = write( G.gc_pipe[1], G.gps_loc, sizeof( float ) * 5 );\n\t\t\tkill( getppid(), SIGUSR2 );\n\t\t}\n    }\n}\n\nvoid sighandler( int signum)\n{\n\tssize_t unused;\n    int card=0;\n\n    signal( signum, sighandler );\n\n    if( signum == SIGUSR1 )\n    {\n\t\tunused = read( G.cd_pipe[0], &card, sizeof(int) );\n        if(G.freqoption)\n            unused = read( G.ch_pipe[0], &(G.frequency[card]), sizeof( int ) );\n        else\n            unused = read( G.ch_pipe[0], &(G.channel[card]), sizeof( int ) );\n    }\n\n    if( signum == SIGUSR2 )\n        unused = read( G.gc_pipe[0], &G.gps_loc, sizeof( float ) * 5 );\n\n    if( signum == SIGINT || signum == SIGTERM )\n    {\n\treset_term();\n        alarm( 1 );\n        G.do_exit = 1;\n        signal( SIGALRM, sighandler );\n        dprintf( STDOUT_FILENO, \"\\n\" );\n    }\n\n    if( signum == SIGSEGV )\n    {\n        fprintf( stderr, \"Caught signal 11 (SIGSEGV). Please\"\n                         \" contact the author!\\33[?25h\\n\\n\" );\n        fflush( stdout );\n        exit( 1 );\n    }\n\n    if( signum == SIGALRM )\n    {\n        dprintf( STDERR_FILENO, \"Caught signal 14 (SIGALRM). Please\"\n                         \" contact the author!\\33[?25h\\n\\n\" );\n        _exit( 1 );\n    }\n\n    if( signum == SIGCHLD )\n        wait( NULL );\n\n    if( signum == SIGWINCH )\n    {\n        fprintf( stderr, \"\\33[2J\" );\n        fflush( stdout );\n    }\n}\n\nint send_probe_request(struct wif *wi)\n{\n    int len;\n    unsigned char p[4096], r_smac[6];\n\n    memcpy(p, PROBE_REQ, 24);\n\n    len = 24;\n\n    p[24] = 0x00;      //ESSID Tag Number\n    p[25] = 0x00;      //ESSID Tag Length\n\n    len += 2;\n\n    memcpy(p+len, RATES, 16);\n\n    len += 16;\n\n    r_smac[0] = 0x00;\n    r_smac[1] = rand() & 0xFF;\n    r_smac[2] = rand() & 0xFF;\n    r_smac[3] = rand() & 0xFF;\n    r_smac[4] = rand() & 0xFF;\n    r_smac[5] = rand() & 0xFF;\n\n    memcpy(p+10, r_smac, 6);\n\n    if (wi_write(wi, p, len, NULL) == -1) {\n        switch (errno) {\n        case EAGAIN:\n        case ENOBUFS:\n            usleep(10000);\n            return 0; /* XXX not sure I like this... -sorbo */\n        }\n\n        perror(\"wi_write()\");\n        return -1;\n    }\n\n    return 0;\n}\n\nint send_probe_requests(struct wif *wi[], int cards)\n{\n    int i=0;\n    for(i=0; i<cards; i++)\n    {\n        send_probe_request(wi[i]);\n    }\n    return 0;\n}\n\nint getchancount(int valid)\n{\n    int i=0, chan_count=0;\n\n    while(G.channels[i])\n    {\n        i++;\n        if(G.channels[i] != -1)\n            chan_count++;\n    }\n\n    if(valid) return chan_count;\n    return i;\n}\n\nint getfreqcount(int valid)\n{\n    int i=0, freq_count=0;\n\n    while(G.own_frequencies[i])\n    {\n        i++;\n        if(G.own_frequencies[i] != -1)\n            freq_count++;\n    }\n\n    if(valid) return freq_count;\n    return i;\n}\n\nvoid channel_hopper(struct wif *wi[], int if_num, int chan_count )\n{\n\tssize_t unused;\n    int ch, ch_idx = 0, card=0, chi=0, cai=0, j=0, k=0, first=1, again=1;\n    int dropped=0;\n\n    while( getppid() != 1 )\n    {\n        for( j = 0; j < if_num; j++ )\n        {\n            again = 1;\n\n            ch_idx = chi % chan_count;\n\n            card = cai % if_num;\n\n            ++chi;\n            ++cai;\n\n            if( G.chswitch == 2 && !first )\n            {\n                j = if_num - 1;\n                card = if_num - 1;\n\n                if( getchancount(1) > if_num )\n                {\n                    while( again )\n                    {\n                        again = 0;\n                        for( k = 0; k < ( if_num - 1 ); k++ )\n                        {\n                            if( G.channels[ch_idx] == G.channel[k] )\n                            {\n                                again = 1;\n                                ch_idx = chi % chan_count;\n                                chi++;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if( G.channels[ch_idx] == -1 )\n            {\n                j--;\n                cai--;\n                dropped++;\n                if(dropped >= chan_count)\n                {\n                    ch = wi_get_channel(wi[card]);\n                    G.channel[card] = ch;\n                    unused = write( G.cd_pipe[1], &card, sizeof(int) );\n                    unused = write( G.ch_pipe[1], &ch, sizeof( int ) );\n                    kill( getppid(), SIGUSR1 );\n                    usleep(1000);\n                }\n                continue;\n            }\n\n            dropped = 0;\n\n            ch = G.channels[ch_idx];\n\n            if(wi_set_channel(wi[card], ch ) == 0 )\n            {\n                G.channel[card] = ch;\n                unused = write( G.cd_pipe[1], &card, sizeof(int) );\n                unused = write( G.ch_pipe[1], &ch, sizeof( int ) );\n                if(G.active_scan_sim > 0)\n                    send_probe_request(wi[card]);\n                kill( getppid(), SIGUSR1 );\n                usleep(1000);\n            }\n            else\n            {\n                G.channels[ch_idx] = -1;      /* remove invalid channel */\n                j--;\n                cai--;\n                continue;\n            }\n        }\n\n        if(G.chswitch == 0)\n        {\n            chi=chi-(if_num - 1);\n        }\n\n        if(first)\n        {\n            first = 0;\n        }\n\n        usleep( (G.hopfreq*1000) );\n    }\n\n    exit( 0 );\n}\n\nvoid frequency_hopper(struct wif *wi[], int if_num, int chan_count )\n{\n\tssize_t unused;\n    int ch, ch_idx = 0, card=0, chi=0, cai=0, j=0, k=0, first=1, again=1;\n    int dropped=0;\n\n    while( getppid() != 1 )\n    {\n        for( j = 0; j < if_num; j++ )\n        {\n            again = 1;\n\n            ch_idx = chi % chan_count;\n\n            card = cai % if_num;\n\n            ++chi;\n            ++cai;\n\n            if( G.chswitch == 2 && !first )\n            {\n                j = if_num - 1;\n                card = if_num - 1;\n\n                if( getfreqcount(1) > if_num )\n                {\n                    while( again )\n                    {\n                        again = 0;\n                        for( k = 0; k < ( if_num - 1 ); k++ )\n                        {\n                            if( G.own_frequencies[ch_idx] == G.frequency[k] )\n                            {\n                                again = 1;\n                                ch_idx = chi % chan_count;\n                                chi++;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if( G.own_frequencies[ch_idx] == -1 )\n            {\n                j--;\n                cai--;\n                dropped++;\n                if(dropped >= chan_count)\n                {\n                    ch = wi_get_freq(wi[card]);\n                    G.frequency[card] = ch;\n                    unused = write( G.cd_pipe[1], &card, sizeof(int) );\n                    unused = write( G.ch_pipe[1], &ch, sizeof( int ) );\n                    kill( getppid(), SIGUSR1 );\n                    usleep(1000);\n                }\n                continue;\n            }\n\n            dropped = 0;\n\n            ch = G.own_frequencies[ch_idx];\n\n            if(wi_set_freq(wi[card], ch ) == 0 )\n            {\n                G.frequency[card] = ch;\n                unused = write( G.cd_pipe[1], &card, sizeof(int) );\n                unused = write( G.ch_pipe[1], &ch, sizeof( int ) );\n                kill( getppid(), SIGUSR1 );\n                usleep(1000);\n            }\n            else\n            {\n                G.own_frequencies[ch_idx] = -1;      /* remove invalid channel */\n                j--;\n                cai--;\n                continue;\n            }\n        }\n\n        if(G.chswitch == 0)\n        {\n            chi=chi-(if_num - 1);\n        }\n\n        if(first)\n        {\n            first = 0;\n        }\n\n        usleep( (G.hopfreq*1000) );\n    }\n\n    exit( 0 );\n}\n\nint invalid_channel(int chan)\n{\n    int i=0;\n\n    do\n    {\n        if (chan == abg_chans[i] && chan != 0 )\n            return 0;\n    } while (abg_chans[++i]);\n    return 1;\n}\n\nint invalid_frequency(int freq)\n{\n    int i=0;\n\n    do\n    {\n        if (freq == frequencies[i] && freq != 0 )\n            return 0;\n    } while (frequencies[++i]);\n    return 1;\n}\n\n/* parse a string, for example \"1,2,3-7,11\" */\n\nint getchannels(const char *optarg)\n{\n    unsigned int i=0,chan_cur=0,chan_first=0,chan_last=0,chan_max=128,chan_remain=0;\n    char *optchan = NULL, *optc;\n    char *token = NULL;\n    int *tmp_channels;\n\n    //got a NULL pointer?\n    if(optarg == NULL)\n        return -1;\n\n    chan_remain=chan_max;\n\n    //create a writable string\n    optc = optchan = (char*) malloc(strlen(optarg)+1);\n    strncpy(optchan, optarg, strlen(optarg));\n    optchan[strlen(optarg)]='\\0';\n\n    tmp_channels = (int*) malloc(sizeof(int)*(chan_max+1));\n\n    //split string in tokens, separated by ','\n    while( (token = strsep(&optchan,\",\")) != NULL)\n    {\n        //range defined?\n        if(strchr(token, '-') != NULL)\n        {\n            //only 1 '-' ?\n            if(strchr(token, '-') == strrchr(token, '-'))\n            {\n                //are there any illegal characters?\n                for(i=0; i<strlen(token); i++)\n                {\n                    if( (token[i] < '0') && (token[i] > '9') && (token[i] != '-'))\n                    {\n                        free(tmp_channels);\n                        free(optc);\n                        return -1;\n                    }\n                }\n\n                if( sscanf(token, \"%d-%d\", &chan_first, &chan_last) != EOF )\n                {\n                    if(chan_first > chan_last)\n                    {\n                        free(tmp_channels);\n                        free(optc);\n                        return -1;\n                    }\n                    for(i=chan_first; i<=chan_last; i++)\n                    {\n                        if( (! invalid_channel(i)) && (chan_remain > 0) )\n                        {\n                                tmp_channels[chan_max-chan_remain]=i;\n                                chan_remain--;\n                        }\n                    }\n                }\n                else\n                {\n                    free(tmp_channels);\n                    free(optc);\n                    return -1;\n                }\n\n            }\n            else\n            {\n                free(tmp_channels);\n                free(optc);\n                return -1;\n            }\n        }\n        else\n        {\n            //are there any illegal characters?\n            for(i=0; i<strlen(token); i++)\n            {\n                if( (token[i] < '0') && (token[i] > '9') )\n                {\n                    free(tmp_channels);\n                    free(optc);\n                    return -1;\n                }\n            }\n\n            if( sscanf(token, \"%d\", &chan_cur) != EOF)\n            {\n                if( (! invalid_channel(chan_cur)) && (chan_remain > 0) )\n                {\n                        tmp_channels[chan_max-chan_remain]=chan_cur;\n                        chan_remain--;\n                }\n\n            }\n            else\n            {\n                free(tmp_channels);\n                free(optc);\n                return -1;\n            }\n        }\n    }\n\n    G.own_channels = (int*) malloc(sizeof(int)*(chan_max - chan_remain + 1));\n\n    for(i=0; i<(chan_max - chan_remain); i++)\n    {\n        G.own_channels[i]=tmp_channels[i];\n    }\n\n    G.own_channels[i]=0;\n\n    free(tmp_channels);\n    free(optc);\n    if(i==1) return G.own_channels[0];\n    if(i==0) return -1;\n    return 0;\n}\n\n/* parse a string, for example \"1,2,3-7,11\" */\n\nint getfrequencies(const char *optarg)\n{\n    unsigned int i=0,freq_cur=0,freq_first=0,freq_last=0,freq_max=10000,freq_remain=0;\n    char *optfreq = NULL, *optc;\n    char *token = NULL;\n    int *tmp_frequencies;\n\n    //got a NULL pointer?\n    if(optarg == NULL)\n        return -1;\n\n    freq_remain=freq_max;\n\n    //create a writable string\n    optc = optfreq = (char*) malloc(strlen(optarg)+1);\n    strncpy(optfreq, optarg, strlen(optarg));\n    optfreq[strlen(optarg)]='\\0';\n\n    tmp_frequencies = (int*) malloc(sizeof(int)*(freq_max+1));\n\n    //split string in tokens, separated by ','\n    while( (token = strsep(&optfreq,\",\")) != NULL)\n    {\n        //range defined?\n        if(strchr(token, '-') != NULL)\n        {\n            //only 1 '-' ?\n            if(strchr(token, '-') == strrchr(token, '-'))\n            {\n                //are there any illegal characters?\n                for(i=0; i<strlen(token); i++)\n                {\n                    if( (token[i] < '0' || token[i] > '9') && (token[i] != '-'))\n                    {\n                        free(tmp_frequencies);\n                        free(optc);\n                        return -1;\n                    }\n                }\n\n                if( sscanf(token, \"%d-%d\", &freq_first, &freq_last) != EOF )\n                {\n                    if(freq_first > freq_last)\n                    {\n                        free(tmp_frequencies);\n                        free(optc);\n                        return -1;\n                    }\n                    for(i=freq_first; i<=freq_last; i++)\n                    {\n                        if( (! invalid_frequency(i)) && (freq_remain > 0) )\n                        {\n                                tmp_frequencies[freq_max-freq_remain]=i;\n                                freq_remain--;\n                        }\n                    }\n                }\n                else\n                {\n                    free(tmp_frequencies);\n                    free(optc);\n                    return -1;\n                }\n\n            }\n            else\n            {\n                free(tmp_frequencies);\n                free(optc);\n                return -1;\n            }\n        }\n        else\n        {\n            //are there any illegal characters?\n            for(i=0; i<strlen(token); i++)\n            {\n                if( (token[i] < '0') && (token[i] > '9') )\n                {\n                    free(tmp_frequencies);\n                    free(optc);\n                    return -1;\n                }\n            }\n\n            if( sscanf(token, \"%d\", &freq_cur) != EOF)\n            {\n                if( (! invalid_frequency(freq_cur)) && (freq_remain > 0) )\n                {\n                        tmp_frequencies[freq_max-freq_remain]=freq_cur;\n                        freq_remain--;\n                }\n\n                /* special case \"-C 0\" means: scan all available frequencies */\n                if(freq_cur == 0)\n                {\n                    freq_first = 1;\n                    freq_last = 9999;\n                    for(i=freq_first; i<=freq_last; i++)\n                    {\n                        if( (! invalid_frequency(i)) && (freq_remain > 0) )\n                        {\n                                tmp_frequencies[freq_max-freq_remain]=i;\n                                freq_remain--;\n                        }\n                    }\n                }\n\n            }\n            else\n            {\n                free(tmp_frequencies);\n                free(optc);\n                return -1;\n            }\n        }\n    }\n\n    G.own_frequencies = (int*) malloc(sizeof(int)*(freq_max - freq_remain + 1));\n\n    for(i=0; i<(freq_max - freq_remain); i++)\n    {\n        G.own_frequencies[i]=tmp_frequencies[i];\n    }\n\n    G.own_frequencies[i]=0;\n\n    free(tmp_frequencies);\n    free(optc);\n    if(i==1) return G.own_frequencies[0];   //exactly 1 frequency given\n    if(i==0) return -1;                     //error occured\n    return 0;                               //frequency hopping\n}\n\nint setup_card(char *iface, struct wif **wis)\n{\n\tstruct wif *wi;\n\n\twi = wi_open(iface);\n\tif (!wi)\n\t\treturn -1;\n\t*wis = wi;\n\n\treturn 0;\n}\n\nint init_cards(const char* cardstr, char *iface[], struct wif **wi)\n{\n    char *buffer;\n    char *buf;\n    int if_count=0;\n    int i=0, again=0;\n\n    buf = buffer = (char*) malloc( sizeof(char) * 1025 );\n    strncpy( buffer, cardstr, 1025 );\n    buffer[1024] = '\\0';\n\n    while( ((iface[if_count]=strsep(&buffer, \",\")) != NULL) && (if_count < MAX_CARDS) )\n    {\n        again=0;\n        for(i=0; i<if_count; i++)\n        {\n            if(strcmp(iface[i], iface[if_count]) == 0)\n            again=1;\n        }\n        if(again) continue;\n        if(setup_card(iface[if_count], &(wi[if_count])) != 0)\n        {\n            free(buf);\n            return -1;\n        }\n        if_count++;\n    }\n\n    free(buf);\n    return if_count;\n}\n\n#if 0\nint get_if_num(const char* cardstr)\n{\n    char *buffer;\n    int if_count=0;\n\n    buffer = (char*) malloc(sizeof(char)*1025);\n    if (buffer == NULL) {\n\t\treturn -1;\n\t}\n\n    strncpy(buffer, cardstr, 1025);\n    buffer[1024] = '\\0';\n\n    while( (strsep(&buffer, \",\") != NULL) && (if_count < MAX_CARDS) )\n    {\n        if_count++;\n    }\n\n    free(buffer)\n\n    return if_count;\n}\n#endif\n\nint set_encryption_filter(const char* input)\n{\n    if(input == NULL) return 1;\n\n    if(strlen(input) < 3) return 1;\n\n    if(strcasecmp(input, \"opn\") == 0)\n        G.f_encrypt |= STD_OPN;\n\n    if(strcasecmp(input, \"wep\") == 0)\n        G.f_encrypt |= STD_WEP;\n\n    if(strcasecmp(input, \"wpa\") == 0)\n    {\n        G.f_encrypt |= STD_WPA;\n        G.f_encrypt |= STD_WPA2;\n    }\n\n    if(strcasecmp(input, \"wpa1\") == 0)\n        G.f_encrypt |= STD_WPA;\n\n    if(strcasecmp(input, \"wpa2\") == 0)\n        G.f_encrypt |= STD_WPA2;\n\n    return 0;\n}\n\nint check_monitor(struct wif *wi[], int *fd_raw, int *fdh, int cards)\n{\n    int i, monitor;\n    char ifname[64];\n\n    for(i=0; i<cards; i++)\n    {\n        monitor = wi_get_monitor(wi[i]);\n        if(monitor != 0)\n        {\n            memset(G.message, '\\x00', sizeof(G.message));\n            snprintf(G.message, sizeof(G.message), \"][ %s reset to monitor mode\", wi_get_ifname(wi[i]));\n            //reopen in monitor mode\n\n            strncpy(ifname, wi_get_ifname(wi[i]), sizeof(ifname)-1);\n            ifname[sizeof(ifname)-1] = 0;\n\n            wi_close(wi[i]);\n            wi[i] = wi_open(ifname);\n            if (!wi[i]) {\n                printf(\"Can't reopen %s\\n\", ifname);\n                exit(1);\n            }\n\n            fd_raw[i] = wi_fd(wi[i]);\n            if (fd_raw[i] > *fdh)\n                *fdh = fd_raw[i];\n        }\n    }\n    return 0;\n}\n\nint check_channel(struct wif *wi[], int cards)\n{\n    int i, chan;\n    for(i=0; i<cards; i++)\n    {\n        chan = wi_get_channel(wi[i]);\n        if(G.ignore_negative_one == 1 && chan==-1) return 0;\n        if(G.channel[i] != chan)\n        {\n            memset(G.message, '\\x00', sizeof(G.message));\n            snprintf(G.message, sizeof(G.message), \"][ fixed channel %s: %d \", wi_get_ifname(wi[i]), chan);\n            wi_set_channel(wi[i], G.channel[i]);\n        }\n    }\n    return 0;\n}\n\nint check_frequency(struct wif *wi[], int cards)\n{\n    int i, freq;\n    for(i=0; i<cards; i++)\n    {\n        freq = wi_get_freq(wi[i]);\n        if(freq < 0) continue;\n        if(G.frequency[i] != freq)\n        {\n            memset(G.message, '\\x00', sizeof(G.message));\n            snprintf(G.message, sizeof(G.message), \"][ fixed frequency %s: %d \", wi_get_ifname(wi[i]), freq);\n            wi_set_freq(wi[i], G.frequency[i]);\n        }\n    }\n    return 0;\n}\n\nint detect_frequencies(struct wif *wi)\n{\n    int start_freq = 2192;\n    int end_freq = 2732;\n    int max_freq_num = 2048; //should be enough to keep all available channels\n    int freq=0, i=0;\n\n    printf(\"Checking available frequencies, this could take few seconds.\\n\");\n\n    frequencies = (int*) malloc((max_freq_num+1) * sizeof(int)); //field for frequencies supported\n    memset(frequencies, 0, (max_freq_num+1) * sizeof(int));\n    for(freq=start_freq; freq<=end_freq; freq+=5)\n    {\n        if(wi_set_freq(wi, freq) == 0)\n        {\n            frequencies[i] = freq;\n            i++;\n        }\n        if(freq == 2482)\n        {\n            //special case for chan 14, as its 12MHz away from 13, not 5MHz\n            freq = 2484;\n            if(wi_set_freq(wi, freq) == 0)\n            {\n                frequencies[i] = freq;\n                i++;\n            }\n            freq = 2482;\n        }\n    }\n\n    //again for 5GHz channels\n    start_freq=4800;\n    end_freq=6000;\n    for(freq=start_freq; freq<=end_freq; freq+=5)\n    {\n        if(wi_set_freq(wi, freq) == 0)\n        {\n            frequencies[i] = freq;\n            i++;\n        }\n    }\n\n    printf(\"Done.\\n\");\n    return 0;\n}\n\nint array_contains(int *array, int length, int value)\n{\n    int i;\n    for(i=0;i<length;i++)\n        if(array[i] == value)\n            return 1;\n\n    return 0;\n}\n\nint rearrange_frequencies()\n{\n    int *freqs;\n    int count, left, pos;\n    int width, last_used=0;\n    int cur_freq, last_freq, round_done;\n//     int i;\n\n    width = DEFAULT_CWIDTH;\n    cur_freq=0;\n\n    count = getfreqcount(0);\n    left = count;\n    pos = 0;\n\n    freqs = malloc(sizeof(int) * (count + 1));\n    memset(freqs, 0, sizeof(int) * (count + 1));\n    round_done = 0;\n\n    while(left > 0)\n    {\n//         printf(\"pos: %d\\n\", pos);\n        last_freq = cur_freq;\n        cur_freq = G.own_frequencies[pos%count];\n        if(cur_freq == last_used)\n            round_done=1;\n//         printf(\"count: %d, left: %d, last_used: %d, cur_freq: %d, width: %d\\n\", count, left, last_used, cur_freq, width);\n        if(((count-left) > 0) && !round_done && ( ABS( last_used-cur_freq ) < width ) )\n        {\n//             printf(\"skip it!\\n\");\n            pos++;\n            continue;\n        }\n        if(!array_contains( freqs, count, cur_freq))\n        {\n//             printf(\"not in there yet: %d\\n\", cur_freq);\n            freqs[count - left] = cur_freq;\n            last_used = cur_freq;\n            left--;\n            round_done = 0;\n        }\n\n        pos++;\n    }\n\n    memcpy(G.own_frequencies, freqs, count*sizeof(int));\n    free(freqs);\n\n    return 0;\n}\n\nint main( int argc, char *argv[] )\n{\n    long time_slept, cycle_time, cycle_time2;\n    char * output_format_string;\n    int caplen=0, i, j, fdh, fd_is_set, chan_count, freq_count, unused;\n    int fd_raw[MAX_CARDS], arptype[MAX_CARDS];\n    int ivs_only, found;\n    int valid_channel;\n    int freq [2];\n    int num_opts = 0;\n    int option = 0;\n    int option_index = 0;\n    char ifnam[64];\n    int wi_read_failed=0;\n    int n = 0;\n    int output_format_first_time = 1;\n#ifdef HAVE_PCRE\n    const char *pcreerror;\n    int pcreerroffset;\n#endif\n\n    struct AP_info *ap_cur, *ap_prv, *ap_next;\n    struct ST_info *st_cur, *st_next;\n    struct NA_info *na_cur, *na_next;\n    struct oui *oui_cur, *oui_next;\n\n    struct pcap_pkthdr pkh;\n\n    time_t tt1, tt2, tt3, start_time;\n\n    struct wif\t       *wi[MAX_CARDS];\n    struct rx_info     ri;\n    unsigned char      tmpbuf[4096];\n    unsigned char      buffer[4096];\n    unsigned char      *h80211;\n    char               *iface[MAX_CARDS];\n\n    struct timeval     tv0;\n    struct timeval     tv1;\n    struct timeval     tv2;\n    struct timeval     tv3;\n    struct timeval     tv4;\n    struct tm          *lt;\n\n    /*\n    struct sockaddr_in provis_addr;\n    */\n\n    fd_set             rfds;\n\n    static struct option long_options[] = {\n        {\"band\",     1, 0, 'b'},\n        {\"beacon\",   0, 0, 'e'},\n        {\"beacons\",  0, 0, 'e'},\n        {\"cswitch\",  1, 0, 's'},\n        {\"netmask\",  1, 0, 'm'},\n        {\"bssid\",    1, 0, 'd'},\n        {\"essid\",    1, 0, 'N'},\n        {\"essid-regex\", 1, 0, 'R'},\n        {\"channel\",  1, 0, 'c'},\n        {\"gpsd\",     0, 0, 'g'},\n        {\"ivs\",      0, 0, 'i'},\n        {\"write\",    1, 0, 'w'},\n        {\"encrypt\",  1, 0, 't'},\n        {\"update\",   1, 0, 'u'},\n        {\"berlin\",   1, 0, 'B'},\n        {\"help\",     0, 0, 'H'},\n        {\"nodecloak\",0, 0, 'D'},\n        {\"showack\",  0, 0, 'A'},\n        {\"detect-anomaly\", 0, 0, 'E'},\n        {\"output-format\",  1, 0, 'o'},\n        {\"ignore-negative-one\", 0, &G.ignore_negative_one, 1},\n        {\"manufacturer\",  0, 0, 'M'},\n        {\"uptime\",   0, 0, 'U'},\n        {0,          0, 0,  0 }\n    };\n\n\n#ifdef USE_GCRYPT\n    // Register callback functions to ensure proper locking in the sensitive parts of libgcrypt.\n    gcry_control (GCRYCTL_SET_THREAD_CBS, &gcry_threads_pthread);\n    // Disable secure memory.\n    gcry_control (GCRYCTL_DISABLE_SECMEM, 0);\n    // Tell Libgcrypt that initialization has completed.\n    gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\tpthread_mutex_init( &(G.mx_print), NULL );\n    pthread_mutex_init( &(G.mx_sort), NULL );\n\n    textstyle(TEXT_RESET);//(TEXT_RESET, TEXT_BLACK, TEXT_WHITE);\n\n\t/* initialize a bunch of variables */\n\n\tsrand( time( NULL ) );\n    memset( &G, 0, sizeof( G ) );\n\n    h80211         =  NULL;\n    ivs_only       =  0;\n    G.chanoption   =  0;\n    G.freqoption   =  0;\n    G.num_cards\t   =  0;\n    fdh\t\t   =  0;\n    fd_is_set\t   =  0;\n    chan_count\t   =  0;\n    time_slept     =  0;\n    G.batt         =  NULL;\n    G.chswitch     =  0;\n    valid_channel  =  0;\n    G.usegpsd      =  0;\n    G.channels     =  bg_chans;\n    G.one_beacon   =  1;\n    G.singlechan   =  0;\n    G.singlefreq   =  0;\n    G.dump_prefix  =  NULL;\n    G.record_data  =  0;\n    G.f_cap        =  NULL;\n    G.f_ivs        =  NULL;\n    G.f_txt        =  NULL;\n    G.f_kis        =  NULL;\n    G.f_kis_xml    =  NULL;\n    G.f_gps        =  NULL;\n    G.keyout       =  NULL;\n    G.f_xor        =  NULL;\n    G.sk_len       =  0;\n    G.sk_len2      =  0;\n    G.sk_start     =  0;\n    G.prefix       =  NULL;\n    G.f_encrypt    =  0;\n    G.asso_client  =  0;\n    G.f_essid      =  NULL;\n    G.f_essid_count = 0;\n    G.active_scan_sim  =  0;\n    G.update_s     =  0;\n    G.decloak      =  1;\n    G.is_berlin    =  0;\n    G.numaps       =  0;\n    G.maxnumaps    =  0;\n    G.berlin       =  120;\n    G.show_ap      =  1;\n    G.show_sta     =  1;\n    G.show_ack     =  0;\n    G.hide_known   =  0;\n    G.maxsize_essid_seen  =  5; // Initial value: length of \"ESSID\"\n    G.show_manufacturer = 0;\n    G.show_uptime  = 0;\n    G.hopfreq      =  DEFAULT_HOPFREQ;\n    G.s_file       =  NULL;\n    G.s_iface      =  NULL;\n    G.f_cap_in     =  NULL;\n    G.detect_anomaly = 0;\n    G.airodump_start_time = NULL;\n\tG.manufList = NULL;\n\n\tG.output_format_pcap = 1;\n    G.output_format_csv = 1;\n    G.output_format_kismet_csv = 1;\n    G.output_format_kismet_netxml = 1;\n\n#ifdef HAVE_PCRE\n    G.f_essid_regex = NULL;\n#endif\n\n\t// Default selection.\n    resetSelection();\n\n    memset(G.sharedkey, '\\x00', 512*3);\n    memset(G.message, '\\x00', sizeof(G.message));\n    memset(&G.pfh_in, '\\x00', sizeof(struct pcap_file_header));\n\n    gettimeofday( &tv0, NULL );\n\n    lt = localtime( (time_t *) &tv0.tv_sec );\n\n    G.keyout = (char*) malloc(512);\n    memset( G.keyout, 0, 512 );\n    snprintf( G.keyout,  511,\n              \"keyout-%02d%02d-%02d%02d%02d.keys\",\n              lt->tm_mon + 1, lt->tm_mday,\n              lt->tm_hour, lt->tm_min, lt->tm_sec );\n\n    for(i=0; i<MAX_CARDS; i++)\n    {\n        arptype[i]=0;\n        fd_raw[i]=-1;\n        G.channel[i]=0;\n    }\n\n    memset(G.f_bssid, '\\x00', 6);\n    memset(G.f_netmask, '\\x00', 6);\n    memset(G.wpa_bssid, '\\x00', 6);\n\n\n    /* check the arguments */\n\n    for(i=0; long_options[i].name != NULL; i++);\n    num_opts = i;\n\n    for(i=0; i<argc; i++) //go through all arguments\n    {\n        found = 0;\n        if(strlen(argv[i]) >= 3)\n        {\n            if(argv[i][0] == '-' && argv[i][1] != '-')\n            {\n                //we got a single dash followed by at least 2 chars\n                //lets check that against our long options to find errors\n                for(j=0; j<num_opts;j++)\n                {\n                    if( strcmp(argv[i]+1, long_options[j].name) == 0 )\n                    {\n                        //found long option after single dash\n                        found = 1;\n                        if(i>1 && strcmp(argv[i-1], \"-\") == 0)\n                        {\n                            //separated dashes?\n                            printf(\"Notice: You specified \\\"%s %s\\\". Did you mean \\\"%s%s\\\" instead?\\n\", argv[i-1], argv[i], argv[i-1], argv[i]);\n                        }\n                        else\n                        {\n                            //forgot second dash?\n                            printf(\"Notice: You specified \\\"%s\\\". Did you mean \\\"-%s\\\" instead?\\n\", argv[i], argv[i]);\n                        }\n                        break;\n                    }\n                }\n                if(found)\n                {\n                    sleep(3);\n                    break;\n                }\n            }\n        }\n    }\n\n    do\n    {\n        option_index = 0;\n\n        option = getopt_long( argc, argv,\n                        \"b:c:egiw:s:t:u:m:d:N:R:aHDB:Ahf:r:EC:o:x:MU\",\n                        long_options, &option_index );\n\n        if( option < 0 ) break;\n\n        switch( option )\n        {\n            case 0 :\n\n                break;\n\n            case ':':\n\n                printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                return( 1 );\n\n            case '?':\n\n                printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                return( 1 );\n\n\t\t\tcase 'E':\n\t\t\t\tG.detect_anomaly = 1;\n\t\t\t\tbreak;\n\n            case 'e':\n\n                G.one_beacon = 0;\n                break;\n\n            case 'a':\n\n                G.asso_client = 1;\n                break;\n\n            case 'A':\n\n                G.show_ack = 1;\n                break;\n\n            case 'h':\n\n                G.hide_known = 1;\n                break;\n\n            case 'D':\n\n                G.decloak = 0;\n                break;\n\n\t    case 'M':\n\n                G.show_manufacturer = 1;\n                break;\n\n\t    case 'U' :\n\t    \t\tG.show_uptime = 1;\n\t    \t\tbreak;\n\n            case 'c' :\n\n                if (G.channel[0] > 0 || G.chanoption == 1) {\n                    if (G.chanoption == 1)\n                        printf( \"Notice: Channel range already given\\n\" );\n                    else\n                        printf( \"Notice: Channel already given (%d)\\n\", G.channel[0]);\n                    break;\n                }\n\n                G.channel[0] = getchannels(optarg);\n\n                if ( G.channel[0] < 0 )\n                    goto usage;\n\n                G.chanoption = 1;\n\n                if( G.channel[0] == 0 )\n                {\n                    G.channels = G.own_channels;\n                    break;\n                }\n                G.channels = bg_chans;\n                break;\n\n            case 'C' :\n\n                if (G.channel[0] > 0 || G.chanoption == 1) {\n                    if (G.chanoption == 1)\n                        printf( \"Notice: Channel range already given\\n\" );\n                    else\n                        printf( \"Notice: Channel already given (%d)\\n\", G.channel[0]);\n                    break;\n                }\n\n                if (G.freqoption == 1) {\n                    printf( \"Notice: Frequency range already given\\n\" );\n                    break;\n                }\n\n                G.freqstring = optarg;\n\n                G.freqoption = 1;\n\n                break;\n\n            case 'b' :\n\n                if (G.chanoption == 1 && option != 'c') {\n                    printf( \"Notice: Channel range already given\\n\" );\n                    break;\n                }\n                freq[0] = freq[1] = 0;\n\n                for (i = 0; i < (int)strlen(optarg); i++) {\n                    if ( optarg[i] == 'a' )\n                        freq[1] = 1;\n                    else if ( optarg[i] == 'b' || optarg[i] == 'g')\n                        freq[0] = 1;\n                    else {\n                        printf( \"Error: invalid band (%c)\\n\", optarg[i] );\n                        printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                        exit ( 1 );\n                    }\n                }\n\n                if (freq[1] + freq[0] == 2 )\n                    G.channels = abg_chans;\n                else {\n                    if ( freq[1] == 1 )\n                        G.channels = a_chans;\n                    else\n                        G.channels = bg_chans;\n                }\n\n                break;\n\n            case 'i':\n\n\t\t\t\t// Reset output format if it's the first time the option is specified\n\t\t\t\tif (output_format_first_time) {\n\t\t\t\t\toutput_format_first_time = 0;\n\n\t\t\t\t\tG.output_format_pcap = 0;\n\t\t\t\t\tG.output_format_csv = 0;\n\t\t\t\t\tG.output_format_kismet_csv = 0;\n    \t\t\t\tG.output_format_kismet_netxml = 0;\n\t\t\t\t}\n\n \t\t\t\tif (G.output_format_pcap) {\n\t\t\t\t\tprintf( usage, getVersion(\"Airodump-ng\", _MAJ, _MIN, _SUB_MIN, _REVISION, _BETA, _RC)  );\n\t\t\t\t\tfprintf(stderr, \"Invalid output format: IVS and PCAP format cannot be used together.\\n\");\n\t\t\t\t\treturn( 1 );\n\t\t\t\t}\n\n                ivs_only = 1;\n                break;\n\n            case 'g':\n\n                G.usegpsd  = 1;\n                /*\n                if (inet_aton(optarg, &provis_addr.sin_addr) == 0 )\n                {\n                    printf(\"Invalid IP address.\\n\");\n                    return (1);\n                }\n                */\n                break;\n\n            case 'w':\n\n                if (G.dump_prefix != NULL) {\n                    printf( \"Notice: dump prefix already given\\n\" );\n                    break;\n                }\n                /* Write prefix */\n                G.dump_prefix   = optarg;\n                G.record_data = 1;\n                break;\n\n            case 'r' :\n\n                if( G.s_file )\n                {\n                    printf( \"Packet source already specified.\\n\" );\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                G.s_file = optarg;\n                break;\n\n            case 's':\n\n                if (atoi(optarg) > 2) {\n                    goto usage;\n                }\n                if (G.chswitch != 0) {\n                    printf(\"Notice: switching method already given\\n\");\n                    break;\n                }\n                G.chswitch = atoi(optarg);\n                break;\n\n            case 'u':\n\n                G.update_s = atoi(optarg);\n\n                /* If failed to parse or value <= 0, use default, 100ms */\n                if (G.update_s <= 0)\n                \tG.update_s = REFRESH_RATE;\n\n                break;\n\n            case 'f':\n\n                G.hopfreq = atoi(optarg);\n\n                /* If failed to parse or value <= 0, use default, 100ms */\n                if (G.hopfreq <= 0)\n                \tG.hopfreq = DEFAULT_HOPFREQ;\n\n                break;\n\n            case 'B':\n\n                G.is_berlin = 1;\n                G.berlin    = atoi(optarg);\n\n                if (G.berlin <= 0)\n                \tG.berlin = 120;\n\n                break;\n\n            case 'm':\n\n                if ( memcmp(G.f_netmask, NULL_MAC, 6) != 0 )\n                {\n                    printf(\"Notice: netmask already given\\n\");\n                    break;\n                }\n                if(getmac(optarg, 1, G.f_netmask) != 0)\n                {\n                    printf(\"Notice: invalid netmask\\n\");\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n                    return( 1 );\n                }\n                break;\n\n            case 'd':\n\n                if ( memcmp(G.f_bssid, NULL_MAC, 6) != 0 )\n                {\n                    printf(\"Notice: bssid already given\\n\");\n                    break;\n                }\n                if(getmac(optarg, 1, G.f_bssid) != 0)\n                {\n                    printf(\"Notice: invalid bssid\\n\");\n                    printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n\n                    return( 1 );\n                }\n                break;\n\n            case 'N':\n\n                G.f_essid_count++;\n                G.f_essid = (char**)realloc(G.f_essid, G.f_essid_count * sizeof(char*));\n                G.f_essid[G.f_essid_count-1] = optarg;\n                break;\n\n\t    case 'R':\n\n#ifdef HAVE_PCRE\n                if (G.f_essid_regex != NULL)\n                {\n\t\t\tprintf(\"Error: ESSID regular expression already given. Aborting\\n\");\n\t\t\texit(1);\n                }\n\n                G.f_essid_regex = pcre_compile(optarg, 0, &pcreerror, &pcreerroffset, NULL);\n\n                if (G.f_essid_regex == NULL)\n                {\n\t\t\tprintf(\"Error: regular expression compilation failed at offset %d: %s; aborting\\n\", pcreerroffset, pcreerror);\n\t\t\texit(1);\n\t\t}\n#else\n                printf(\"Error: Airodump-ng wasn't compiled with pcre support; aborting\\n\");\n#endif\n\n                break;\n\n            case 't':\n\n                set_encryption_filter(optarg);\n                break;\n\n\t\t\tcase 'o':\n\n\t\t\t\t// Reset output format if it's the first time the option is specified\n\t\t\t\tif (output_format_first_time) {\n\t\t\t\t\toutput_format_first_time = 0;\n\n\t\t\t\t\tG.output_format_pcap = 0;\n\t\t\t\t\tG.output_format_csv = 0;\n\t\t\t\t\tG.output_format_kismet_csv = 0;\n    \t\t\t\tG.output_format_kismet_netxml = 0;\n\t\t\t\t}\n\n\t\t\t\t// Parse the value\n\t\t\t\toutput_format_string = strtok(optarg, \",\");\n\t\t\t\twhile (output_format_string != NULL) {\n\t\t\t\t\tif (strlen(output_format_string) != 0) {\n\t\t\t\t\t\tif (strncasecmp(output_format_string, \"csv\", 3) == 0\n\t\t\t\t\t\t\t|| strncasecmp(output_format_string, \"txt\", 3) == 0) {\n\t\t\t\t\t\t\tG.output_format_csv = 1;\n\t\t\t\t\t\t} else if (strncasecmp(output_format_string, \"pcap\", 4) == 0\n\t\t\t\t\t\t\t|| strncasecmp(output_format_string, \"cap\", 3) == 0) {\n                            if (ivs_only) {\n                                printf( usage, getVersion(\"Airodump-ng\", _MAJ, _MIN, _SUB_MIN, _REVISION, _BETA, _RC)  );\n                                fprintf(stderr, \"Invalid output format: IVS and PCAP format cannot be used together.\\n\");\n                                return( 1 );\n                            }\n\t\t\t\t\t\t\tG.output_format_pcap = 1;\n\t\t\t\t\t\t} else if (strncasecmp(output_format_string, \"ivs\", 3) == 0) {\n                            if (G.output_format_pcap) {\n                                printf( usage, getVersion(\"Airodump-ng\", _MAJ, _MIN, _SUB_MIN, _REVISION, _BETA, _RC)  );\n                                fprintf(stderr, \"Invalid output format: IVS and PCAP format cannot be used together.\\n\");\n                                return( 1 );\n                            }\n\t\t\t\t\t\t\tivs_only = 1;\n\t\t\t\t\t\t} else if (strncasecmp(output_format_string, \"kismet\", 6) == 0) {\n\t\t\t\t\t\t\tG.output_format_kismet_csv = 1;\n\t\t\t\t\t\t} else if (strncasecmp(output_format_string, \"gps\", 3) == 0) {\n\t\t\t\t\t\t\tG.usegpsd  = 1;\n\t\t\t\t\t\t} else if (strncasecmp(output_format_string, \"netxml\", 6) == 0\n\t\t\t\t\t\t\t|| strncasecmp(output_format_string, \"newcore\", 7) == 0\n\t\t\t\t\t\t\t|| strncasecmp(output_format_string, \"kismet-nc\", 9) == 0\n\t\t\t\t\t\t\t|| strncasecmp(output_format_string, \"kismet_nc\", 9) == 0\n\t\t\t\t\t\t\t|| strncasecmp(output_format_string, \"kismet-newcore\", 14) == 0\n\t\t\t\t\t\t\t|| strncasecmp(output_format_string, \"kismet_newcore\", 14) == 0) {\n\t\t\t\t\t\t\tG.output_format_kismet_netxml = 1;\n\t\t\t\t\t\t} else if (strncasecmp(output_format_string, \"default\", 6) == 0) {\n\t\t\t\t\t\t\tG.output_format_pcap = 1;\n\t\t\t\t\t\t\tG.output_format_csv = 1;\n\t\t\t\t\t\t\tG.output_format_kismet_csv = 1;\n\t\t\t\t\t\t\tG.output_format_kismet_netxml = 1;\n\t\t\t\t\t\t} else if (strncasecmp(output_format_string, \"none\", 6) == 0) {\n\t\t\t\t\t\t\tG.output_format_pcap = 0;\n\t\t\t\t\t\t\tG.output_format_csv = 0;\n\t\t\t\t\t\t\tG.output_format_kismet_csv = 0;\n    \t\t\t\t\t\tG.output_format_kismet_netxml = 0;\n\n\t\t\t\t\t\t\tG.usegpsd  = 0;\n\t\t\t\t\t\t\tivs_only = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Display an error if it does not match any value\n\t\t\t\t\t\t\tfprintf(stderr, \"Invalid output format: <%s>\\n\", output_format_string);\n\t\t\t\t\t\t\texit(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toutput_format_string = strtok(NULL, \",\");\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n            case 'H':\n\n                printf( usage, getVersion(\"Airodump-ng\", _MAJ, _MIN, _SUB_MIN, _REVISION, _BETA, _RC)  );\n                return( 1 );\n\n            case 'x':\n\n                G.active_scan_sim = atoi(optarg);\n\n                if (G.active_scan_sim <= 0)\n                    G.active_scan_sim = 0;\n                break;\n\n            default : goto usage;\n        }\n    } while ( 1 );\n\n    if( argc - optind != 1 && G.s_file == NULL)\n    {\n        if(argc == 1)\n        {\nusage:\n            printf( usage, getVersion(\"Airodump-ng\", _MAJ, _MIN, _SUB_MIN, _REVISION, _BETA, _RC)  );\n        }\n        if( argc - optind == 0)\n        {\n            printf(\"No interface specified.\\n\");\n        }\n        if(argc > 1)\n        {\n            printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n        }\n        return( 1 );\n    }\n\n    if( argc - optind == 1 )\n        G.s_iface = argv[argc-1];\n\n    if( ( memcmp(G.f_netmask, NULL_MAC, 6) != 0 ) && ( memcmp(G.f_bssid, NULL_MAC, 6) == 0 ) )\n    {\n        printf(\"Notice: specify bssid \\\"--bssid\\\" with \\\"--netmask\\\"\\n\");\n        printf(\"\\\"%s --help\\\" for help.\\n\", argv[0]);\n        return( 1 );\n    }\n\n    if(G.s_iface != NULL)\n    {\n        /* initialize cards */\n        G.num_cards = init_cards(G.s_iface, iface, wi);\n\n        if(G.num_cards <= 0)\n            return( 1 );\n\n        for (i = 0; i < G.num_cards; i++) {\n            fd_raw[i] = wi_fd(wi[i]);\n            if (fd_raw[i] > fdh)\n                fdh = fd_raw[i];\n        }\n\n        if(G.freqoption == 1 && G.freqstring != NULL) // use frequencies\n        {\n            detect_frequencies(wi[0]);\n            G.frequency[0] = getfrequencies(G.freqstring);\n            if(G.frequency[0] == -1)\n            {\n                printf(\"No valid frequency given.\\n\");\n                return(1);\n            }\n\n//             printf(\"gonna rearrange\\n\");\n            rearrange_frequencies();\n//             printf(\"finished rearranging\\n\");\n\n            freq_count = getfreqcount(0);\n\n            /* find the interface index */\n            /* start a child to hop between frequencies */\n\n            if( G.frequency[0] == 0 )\n            {\n                unused = pipe( G.ch_pipe );\n                unused = pipe( G.cd_pipe );\n\n                signal( SIGUSR1, sighandler );\n\n                if( ! fork() )\n                {\n                    /* reopen cards.  This way parent & child don't share resources for\n                    * accessing the card (e.g. file descriptors) which may cause\n                    * problems.  -sorbo\n                    */\n                    for (i = 0; i < G.num_cards; i++) {\n                        strncpy(ifnam, wi_get_ifname(wi[i]), sizeof(ifnam)-1);\n                        ifnam[sizeof(ifnam)-1] = 0;\n\n                        wi_close(wi[i]);\n                        wi[i] = wi_open(ifnam);\n                        if (!wi[i]) {\n                                printf(\"Can't reopen %s\\n\", ifnam);\n                                exit(1);\n                        }\n                    }\n\n\t\t\t\t\t/* Drop privileges */\n\t\t\t\t\tif (setuid( getuid() ) == -1) {\n\t\t\t\t\t\tperror(\"setuid\");\n\t\t\t\t\t}\n\n                    frequency_hopper(wi, G.num_cards, freq_count);\n                    exit( 1 );\n                }\n            }\n            else\n            {\n                for( i=0; i<G.num_cards; i++ )\n                {\n                    wi_set_freq(wi[i], G.frequency[0]);\n                    G.frequency[i] = G.frequency[0];\n                }\n                G.singlefreq = 1;\n            }\n        }\n        else    //use channels\n        {\n            chan_count = getchancount(0);\n\n            /* find the interface index */\n            /* start a child to hop between channels */\n\n            if( G.channel[0] == 0 )\n            {\n                unused = pipe( G.ch_pipe );\n                unused = pipe( G.cd_pipe );\n\n                signal( SIGUSR1, sighandler );\n\n                if( ! fork() )\n                {\n                    /* reopen cards.  This way parent & child don't share resources for\n                    * accessing the card (e.g. file descriptors) which may cause\n                    * problems.  -sorbo\n                    */\n                    for (i = 0; i < G.num_cards; i++) {\n                        strncpy(ifnam, wi_get_ifname(wi[i]), sizeof(ifnam)-1);\n                        ifnam[sizeof(ifnam)-1] = 0;\n\n                        wi_close(wi[i]);\n                        wi[i] = wi_open(ifnam);\n                        if (!wi[i]) {\n                                printf(\"Can't reopen %s\\n\", ifnam);\n                                exit(1);\n                        }\n                    }\n\n\t\t\t\t\t/* Drop privileges */\n\t\t\t\t\tif (setuid( getuid() ) == -1) {\n\t\t\t\t\t\tperror(\"setuid\");\n\t\t\t\t\t}\n\n                    channel_hopper(wi, G.num_cards, chan_count);\n                    exit( 1 );\n                }\n            }\n            else\n            {\n                for( i=0; i<G.num_cards; i++ )\n                {\n                    wi_set_channel(wi[i], G.channel[0]);\n                    G.channel[i] = G.channel[0];\n                }\n                G.singlechan = 1;\n            }\n        }\n    }\n\n\t/* Drop privileges */\n\tif (setuid( getuid() ) == -1) {\n\t\tperror(\"setuid\");\n\t}\n\n    /* check if there is an input file */\n    if( G.s_file != NULL )\n    {\n        if( ! ( G.f_cap_in = fopen( G.s_file, \"rb\" ) ) )\n        {\n            perror( \"open failed\" );\n            return( 1 );\n        }\n\n        n = sizeof( struct pcap_file_header );\n\n        if( fread( &G.pfh_in, 1, n, G.f_cap_in ) != (size_t) n )\n        {\n            perror( \"fread(pcap file header) failed\" );\n            return( 1 );\n        }\n\n        if( G.pfh_in.magic != TCPDUMP_MAGIC &&\n            G.pfh_in.magic != TCPDUMP_CIGAM )\n        {\n            fprintf( stderr, \"\\\"%s\\\" isn't a pcap file (expected \"\n                             \"TCPDUMP_MAGIC).\\n\", G.s_file );\n            return( 1 );\n        }\n\n        if( G.pfh_in.magic == TCPDUMP_CIGAM )\n            SWAP32(G.pfh_in.linktype);\n\n        if( G.pfh_in.linktype != LINKTYPE_IEEE802_11 &&\n            G.pfh_in.linktype != LINKTYPE_PRISM_HEADER &&\n            G.pfh_in.linktype != LINKTYPE_RADIOTAP_HDR &&\n            G.pfh_in.linktype != LINKTYPE_PPI_HDR )\n        {\n            fprintf( stderr, \"Wrong linktype from pcap file header \"\n                             \"(expected LINKTYPE_IEEE802_11) -\\n\"\n                             \"this doesn't look like a regular 802.11 \"\n                             \"capture.\\n\" );\n            return( 1 );\n        }\n    }\n\n    /* open or create the output files */\n\n    if (G.record_data)\n    \tif( dump_initialize( G.dump_prefix, ivs_only ) )\n    \t    return( 1 );\n\n    signal( SIGINT,   sighandler );\n    signal( SIGSEGV,  sighandler );\n    signal( SIGTERM,  sighandler );\n    signal( SIGWINCH, sighandler );\n\n    sighandler( SIGWINCH );\n\n    /* fill oui struct if ram is greater than 32 MB */\n    if (get_ram_size()  > MIN_RAM_SIZE_LOAD_OUI_RAM) {\n        G.manufList = load_oui_file();\n\t}\n\n    /* start the GPS tracker */\n\n    if (G.usegpsd)\n    {\n        unused = pipe( G.gc_pipe );\n        signal( SIGUSR2, sighandler );\n\n        if( ! fork() )\n        {\n            gps_tracker();\n            exit( 1 );\n        }\n\n        usleep( 50000 );\n        waitpid( -1, NULL, WNOHANG );\n    }\n\n    fprintf( stderr, \"\\33[?25l\\33[2J\\n\" );\n\n    start_time = time( NULL );\n    tt1        = time( NULL );\n    tt2        = time( NULL );\n    tt3        = time( NULL );\n    gettimeofday( &tv3, NULL );\n    gettimeofday( &tv4, NULL );\n\n    G.batt     = getBatteryString();\n\n    G.elapsed_time = (char *) calloc( 1, 4 );\n    strncpy(G.elapsed_time, \"0 s\", 4 - 1);\n\n\t/* Create start time string for kismet netxml file */\n    G.airodump_start_time = (char *) calloc( 1, 1000 * sizeof(char) );\n    strncpy(G.airodump_start_time, ctime( & start_time ), 1000 - 1);\n    G.airodump_start_time[strlen(G.airodump_start_time) - 1] = 0; // remove new line\n    G.airodump_start_time = (char *) realloc( G.airodump_start_time, sizeof(char) * (strlen(G.airodump_start_time) + 1) );\n\n    if( pthread_create( &(G.input_tid), NULL, (void *) input_thread, NULL ) != 0 )\n    {\n\tperror( \"pthread_create failed\" );\n\treturn 1;\n    }\n\n\n    while( 1 )\n    {\n        if( G.do_exit )\n        {\n            break;\n        }\n\n        if( time( NULL ) - tt1 >= 5 )\n        {\n            /* update the csv stats file */\n\n            tt1 = time( NULL );\n            if (G. output_format_csv)  dump_write_csv();\n            if (G.output_format_kismet_csv) dump_write_kismet_csv();\n            if (G.output_format_kismet_netxml) dump_write_kismet_netxml();\n\n            /* sort the APs by power */\n\n\t    if(G.sort_by != SORT_BY_NOTHING) {\n\t\tpthread_mutex_lock( &(G.mx_sort) );\n\t\t    dump_sort();\n\t\tpthread_mutex_unlock( &(G.mx_sort) );\n\t    }\n        }\n\n        if( time( NULL ) - tt2 > 3 )\n        {\n            /* update the battery state */\n            free(G.batt);\n            G.batt = NULL;\n\n            tt2 = time( NULL );\n            G.batt = getBatteryString();\n\n            /* update elapsed time */\n\n            free(G.elapsed_time);\n            G.elapsed_time=NULL;\n            G.elapsed_time = getStringTimeFromSec(\n            difftime(tt2, start_time) );\n\n\n            /* flush the output files */\n\n            if( G.f_cap != NULL ) fflush( G.f_cap );\n            if( G.f_ivs != NULL ) fflush( G.f_ivs );\n        }\n\n        gettimeofday( &tv1, NULL );\n\n        cycle_time = 1000000 * ( tv1.tv_sec  - tv3.tv_sec  )\n                             + ( tv1.tv_usec - tv3.tv_usec );\n\n        cycle_time2 = 1000000 * ( tv1.tv_sec  - tv4.tv_sec  )\n                              + ( tv1.tv_usec - tv4.tv_usec );\n\n        if( G.active_scan_sim > 0 && cycle_time2 > G.active_scan_sim*1000 )\n        {\n            gettimeofday( &tv4, NULL );\n            send_probe_requests(wi, G.num_cards);\n        }\n\n        if( cycle_time > 500000 )\n        {\n            gettimeofday( &tv3, NULL );\n            update_rx_quality( );\n            if(G.s_iface != NULL)\n            {\n                check_monitor(wi, fd_raw, &fdh, G.num_cards);\n                if(G.singlechan)\n                    check_channel(wi, G.num_cards);\n                if(G.singlefreq)\n                    check_frequency(wi, G.num_cards);\n            }\n        }\n\n        if(G.s_file != NULL)\n        {\n            /* Read one packet */\n            n = sizeof( pkh );\n\n            if( fread( &pkh, n, 1, G.f_cap_in ) != 1 )\n            {\n                memset(G.message, '\\x00', sizeof(G.message));\n                snprintf(G.message, sizeof(G.message), \"][ Finished reading input file %s.\\n\", G.s_file);\n                G.s_file = NULL;\n                continue;\n            }\n\n            if( G.pfh_in.magic == TCPDUMP_CIGAM ) {\n                SWAP32( pkh.caplen );\n                SWAP32( pkh.len );\n            }\n\n            n = caplen = pkh.caplen;\n\n            memset(buffer, 0, sizeof(buffer));\n            h80211 = buffer;\n\n            if( n <= 0 || n > (int) sizeof( buffer ) )\n            {\n                memset(G.message, '\\x00', sizeof(G.message));\n                snprintf(G.message, sizeof(G.message), \"][ Finished reading input file %s.\\n\", G.s_file);\n                G.s_file = NULL;\n                continue;\n            }\n\n            if( fread( h80211, n, 1, G.f_cap_in ) != 1 )\n            {\n                memset(G.message, '\\x00', sizeof(G.message));\n                snprintf(G.message, sizeof(G.message), \"][ Finished reading input file %s.\\n\", G.s_file);\n                G.s_file = NULL;\n                continue;\n            }\n\n            if( G.pfh_in.linktype == LINKTYPE_PRISM_HEADER )\n            {\n                if( h80211[7] == 0x40 )\n                    n = 64;\n                else\n                    n = *(int *)( h80211 + 4 );\n\n                if( n < 8 || n >= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n\n            if( G.pfh_in.linktype == LINKTYPE_RADIOTAP_HDR )\n            {\n                /* remove the radiotap header */\n\n                n = *(unsigned short *)( h80211 + 2 );\n\n                if( n <= 0 || n >= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n\n            if( G.pfh_in.linktype == LINKTYPE_PPI_HDR )\n            {\n                /* remove the PPI header */\n\n                n = le16_to_cpu(*(unsigned short *)( h80211 + 2));\n\n                if( n <= 0 || n>= (int) caplen )\n                    continue;\n\n                /* for a while Kismet logged broken PPI headers */\n                if ( n == 24 && le16_to_cpu(*(unsigned short *)(h80211 + 8)) == 2 )\n                    n = 32;\n\n                if( n <= 0 || n>= (int) caplen )\n                    continue;\n\n                memcpy( tmpbuf, h80211, caplen );\n                caplen -= n;\n                memcpy( h80211, tmpbuf + n, caplen );\n            }\n\n            read_pkts++;\n\n            if(read_pkts%10 == 0)\n                usleep(1);\n        }\n        else if(G.s_iface != NULL)\n        {\n            /* capture one packet */\n\n            FD_ZERO( &rfds );\n            for(i=0; i<G.num_cards; i++)\n            {\n                FD_SET( fd_raw[i], &rfds );\n            }\n\n            tv0.tv_sec  = G.update_s;\n            tv0.tv_usec = (G.update_s == 0) ? REFRESH_RATE : 0;\n\n            gettimeofday( &tv1, NULL );\n\n            if( select( fdh + 1, &rfds, NULL, NULL, &tv0 ) < 0 )\n            {\n                if( errno == EINTR )\n                {\n                    gettimeofday( &tv2, NULL );\n\n                    time_slept += 1000000 * ( tv2.tv_sec  - tv1.tv_sec  )\n                                        + ( tv2.tv_usec - tv1.tv_usec );\n\n                    continue;\n                }\n                perror( \"select failed\" );\n\n                /* Restore terminal */\n                fprintf( stderr, \"\\33[?25h\" );\n                fflush( stdout );\n\n                return( 1 );\n            }\n        }\n        else\n            usleep(1);\n\n        gettimeofday( &tv2, NULL );\n\n        time_slept += 1000000 * ( tv2.tv_sec  - tv1.tv_sec  )\n                              + ( tv2.tv_usec - tv1.tv_usec );\n\n        if( time_slept > REFRESH_RATE && time_slept > G.update_s * 1000000)\n        {\n            time_slept = 0;\n\n            update_dataps();\n\n            /* update the window size */\n\n            if( ioctl( 0, TIOCGWINSZ, &(G.ws) ) < 0 )\n            {\n                G.ws.ws_row = 25;\n                G.ws.ws_col = 80;\n            }\n\n            if( G.ws.ws_col <   1 ) G.ws.ws_col =   1;\n            if( G.ws.ws_col > 300 ) G.ws.ws_col = 300;\n\n            /* display the list of access points we have */\n\n\t    if(!G.do_pause) {\n\t\tpthread_mutex_lock( &(G.mx_print) );\n\n\t\t    fprintf( stderr, \"\\33[1;1H\" );\n\t\t    dump_print( G.ws.ws_row, G.ws.ws_col, G.num_cards );\n\t\t    fprintf( stderr, \"\\33[J\" );\n\t\t    fflush( stdout );\n\n\t\tpthread_mutex_unlock( &(G.mx_print) );\n\t    }\n            continue;\n        }\n\n        if(G.s_file == NULL && G.s_iface != NULL)\n        {\n            fd_is_set = 0;\n\n            for(i=0; i<G.num_cards; i++)\n            {\n                if( FD_ISSET( fd_raw[i], &rfds ) )\n                {\n\n                    memset(buffer, 0, sizeof(buffer));\n                    h80211 = buffer;\n                    if ((caplen = wi_read(wi[i], h80211, sizeof(buffer), &ri)) == -1) {\n                        wi_read_failed++;\n                        if(wi_read_failed > 1)\n                        {\n                            G.do_exit = 1;\n                            break;\n                        }\n                        memset(G.message, '\\x00', sizeof(G.message));\n                        snprintf(G.message, sizeof(G.message), \"][ interface %s down \", wi_get_ifname(wi[i]));\n\n                        //reopen in monitor mode\n\n                        strncpy(ifnam, wi_get_ifname(wi[i]), sizeof(ifnam)-1);\n                        ifnam[sizeof(ifnam)-1] = 0;\n\n                        wi_close(wi[i]);\n                        wi[i] = wi_open(ifnam);\n                        if (!wi[i]) {\n                            printf(\"Can't reopen %s\\n\", ifnam);\n\n                            /* Restore terminal */\n                            fprintf( stderr, \"\\33[?25h\" );\n                            fflush( stdout );\n\n                            exit(1);\n                        }\n\n                        fd_raw[i] = wi_fd(wi[i]);\n                        if (fd_raw[i] > fdh)\n                            fdh = fd_raw[i];\n\n                        break;\n//                         return 1;\n                    }\n\n                    read_pkts++;\n\n                    wi_read_failed = 0;\n                    dump_add_packet( h80211, caplen, &ri, i );\n                }\n            }\n        }\n        else if (G.s_file != NULL)\n        {\n            dump_add_packet( h80211, caplen, &ri, i );\n        }\n    }\n\n    if(G.batt)\n        free(G.batt);\n\n    if(G.elapsed_time)\n        free(G.elapsed_time);\n\n    if(G.own_channels)\n        free(G.own_channels);\n    \n    if(G.f_essid)\n        free(G.f_essid);\n\n    if(G.prefix)\n        free(G.prefix);\n\n    if(G.f_cap_name)\n        free(G.f_cap_name);\n\n    if(G.keyout)\n        free(G.keyout);\n\n#ifdef HAVE_PCRE\n    if(G.f_essid_regex)\n        pcre_free(G.f_essid_regex);\n#endif\n\n    for(i=0; i<G.num_cards; i++)\n        wi_close(wi[i]);\n\n    if (G.record_data) {\n        if ( G. output_format_csv)  dump_write_csv();\n        if ( G.output_format_kismet_csv) dump_write_kismet_csv();\n        if ( G.output_format_kismet_netxml) dump_write_kismet_netxml();\n\n        if ( G. output_format_csv || G.f_txt != NULL ) fclose( G.f_txt );\n        if ( G.output_format_kismet_csv || G.f_kis != NULL ) fclose( G.f_kis );\n        if ( G.output_format_kismet_netxml || G.f_kis_xml != NULL )\n        {\n\t\t\tfclose( G.f_kis_xml );\n\t\t\tfree(G.airodump_start_time);\n\t\t}\n        if ( G.f_gps != NULL ) fclose( G.f_gps );\n        if ( G.output_format_pcap ||  G.f_cap != NULL ) fclose( G.f_cap );\n        if ( G.f_ivs != NULL ) fclose( G.f_ivs );\n    }\n\n    if( ! G.save_gps )\n    {\n        snprintf( (char *) buffer, 4096, \"%s-%02d.gps\", argv[2], G.f_index );\n        unlink(  (char *) buffer );\n    }\n\n    ap_prv = NULL;\n    ap_cur = G.ap_1st;\n\n    while( ap_cur != NULL )\n    {\n\t\t// Clean content of ap_cur list (first element: G.ap_1st)\n        uniqueiv_wipe( ap_cur->uiv_root );\n\n        list_tail_free(&(ap_cur->packets));\n\n\tif (G.manufList)\n\t\tfree(ap_cur->manuf);\n\n\tif (G.detect_anomaly)\n        \tdata_wipe(ap_cur->data_root);\n\n        ap_prv = ap_cur;\n        ap_cur = ap_cur->next;\n    }\n\n    ap_cur = G.ap_1st;\n\n    while( ap_cur != NULL )\n    {\n\t\t// Freeing AP List\n        ap_next = ap_cur->next;\n\n        if( ap_cur != NULL )\n            free(ap_cur);\n\n        ap_cur = ap_next;\n    }\n\n    st_cur = G.st_1st;\n    st_next= NULL;\n\n    while(st_cur != NULL)\n    {\n        st_next = st_cur->next;\n\tif (G.manufList)\n\t\tfree(st_cur->manuf);\n        free(st_cur);\n        st_cur = st_next;\n    }\n\n    na_cur = G.na_1st;\n    na_next= NULL;\n\n    while(na_cur != NULL)\n    {\n        na_next = na_cur->next;\n        free(na_cur);\n        na_cur = na_next;\n    }\n\n    if (G.manufList) {\n        oui_cur = G.manufList;\n        while (oui_cur != NULL) {\n            oui_next = oui_cur->next;\n\t    free(oui_cur);\n\t    oui_cur = oui_next;\n        }\n    }\n\n    fprintf( stderr, \"\\33[?25h\" );\n    fflush( stdout );\n\n    return( 0 );\n}\n"], "filenames": ["src/airodump-ng.c"], "buggy_code_start_loc": [4500], "buggy_code_end_loc": [4501], "fixing_code_start_loc": [4500], "fixing_code_end_loc": [4501], "type": "CWE-787", "message": "Stack-based buffer overflow in the gps_tracker function in airodump-ng.c in Aircrack-ng before 1.2 RC 1 allows local users to execute arbitrary code or gain privileges via unspecified vectors.", "other": {"cve": {"id": "CVE-2014-8321", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-31T22:15:10.997", "lastModified": "2020-02-05T20:30:14.387", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Stack-based buffer overflow in the gps_tracker function in airodump-ng.c in Aircrack-ng before 1.2 RC 1 allows local users to execute arbitrary code or gain privileges via unspecified vectors."}, {"lang": "es", "value": "Un desbordamiento del b\u00fafer en la regi\u00f3n stack de la memoria en la funci\u00f3n gps_tracker en el archivo airodump-ng.c en Aircrack-ng versiones anteriores a 1.2 RC 1, permite a usuarios locales ejecutar c\u00f3digo arbitrario o alcanzar privilegios por medio de vectores no especificados."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:aircrack-ng:aircrack-ng:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.1", "matchCriteriaId": "B3589281-1252-4D05-998E-39FD6336B670"}, {"vulnerable": true, "criteria": "cpe:2.3:a:aircrack-ng:aircrack-ng:1.2:beta1:*:*:*:*:*:*", "matchCriteriaId": "74AD6A4C-E624-4B24-A841-EBCD1ADE9E97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:aircrack-ng:aircrack-ng:1.2:beta2:*:*:*:*:*:*", "matchCriteriaId": "FC858C42-ADCE-4C84-A3AF-E6DB015D894D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:aircrack-ng:aircrack-ng:1.2:beta3:*:*:*:*:*:*", "matchCriteriaId": "26968784-4C5C-40CE-825B-4DE98C94FF7B"}]}]}], "references": [{"url": "http://aircrack-ng.blogspot.com/2014/10/aircrack-ng-12-release-candidate-1.html", "source": "cve@mitre.org", "tags": ["Product", "Release Notes", "Third Party Advisory"]}, {"url": "http://packetstormsecurity.com/files/128943/Aircrack-ng-1.2-Beta-3-DoS-Code-Execution.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/98458", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/aircrack-ng/aircrack-ng/commit/ff70494dd389ba570dbdbf36f217c28d4381c6b5/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/aircrack-ng/aircrack-ng/pull/13", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/aircrack-ng/aircrack-ng/commit/ff70494dd389ba570dbdbf36f217c28d4381c6b5/"}}