{"buggy_code": ["# -*- coding: utf-8 -*-\n\"\"\"\n    jinja2.nodes\n    ~~~~~~~~~~~~\n\n    This module implements additional nodes derived from the ast base node.\n\n    It also provides some node tree helper functions like `in_lineno` and\n    `get_nodes` used by the parser and translator in order to normalize\n    python and jinja nodes.\n\n    :copyright: (c) 2010 by the Jinja Team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport types\nimport operator\n\nfrom collections import deque\nfrom jinja2.utils import Markup\nfrom jinja2._compat import izip, with_metaclass, text_type\n\n\n#: the types we support for context functions\n_context_function_types = (types.FunctionType, types.MethodType)\n\n\n_binop_to_func = {\n    '*':        operator.mul,\n    '/':        operator.truediv,\n    '//':       operator.floordiv,\n    '**':       operator.pow,\n    '%':        operator.mod,\n    '+':        operator.add,\n    '-':        operator.sub\n}\n\n_uaop_to_func = {\n    'not':      operator.not_,\n    '+':        operator.pos,\n    '-':        operator.neg\n}\n\n_cmpop_to_func = {\n    'eq':       operator.eq,\n    'ne':       operator.ne,\n    'gt':       operator.gt,\n    'gteq':     operator.ge,\n    'lt':       operator.lt,\n    'lteq':     operator.le,\n    'in':       lambda a, b: a in b,\n    'notin':    lambda a, b: a not in b\n}\n\n\nclass Impossible(Exception):\n    \"\"\"Raised if the node could not perform a requested action.\"\"\"\n\n\nclass NodeType(type):\n    \"\"\"A metaclass for nodes that handles the field and attribute\n    inheritance.  fields and attributes from the parent class are\n    automatically forwarded to the child.\"\"\"\n\n    def __new__(cls, name, bases, d):\n        for attr in 'fields', 'attributes':\n            storage = []\n            storage.extend(getattr(bases[0], attr, ()))\n            storage.extend(d.get(attr, ()))\n            assert len(bases) == 1, 'multiple inheritance not allowed'\n            assert len(storage) == len(set(storage)), 'layout conflict'\n            d[attr] = tuple(storage)\n        d.setdefault('abstract', False)\n        return type.__new__(cls, name, bases, d)\n\n\nclass EvalContext(object):\n    \"\"\"Holds evaluation time information.  Custom attributes can be attached\n    to it in extensions.\n    \"\"\"\n\n    def __init__(self, environment, template_name=None):\n        self.environment = environment\n        if callable(environment.autoescape):\n            self.autoescape = environment.autoescape(template_name)\n        else:\n            self.autoescape = environment.autoescape\n        self.volatile = False\n\n    def save(self):\n        return self.__dict__.copy()\n\n    def revert(self, old):\n        self.__dict__.clear()\n        self.__dict__.update(old)\n\n\ndef get_eval_context(node, ctx):\n    if ctx is None:\n        if node.environment is None:\n            raise RuntimeError('if no eval context is passed, the '\n                               'node must have an attached '\n                               'environment.')\n        return EvalContext(node.environment)\n    return ctx\n\n\nclass Node(with_metaclass(NodeType, object)):\n    \"\"\"Baseclass for all Jinja2 nodes.  There are a number of nodes available\n    of different types.  There are four major types:\n\n    -   :class:`Stmt`: statements\n    -   :class:`Expr`: expressions\n    -   :class:`Helper`: helper nodes\n    -   :class:`Template`: the outermost wrapper node\n\n    All nodes have fields and attributes.  Fields may be other nodes, lists,\n    or arbitrary values.  Fields are passed to the constructor as regular\n    positional arguments, attributes as keyword arguments.  Each node has\n    two attributes: `lineno` (the line number of the node) and `environment`.\n    The `environment` attribute is set at the end of the parsing process for\n    all nodes automatically.\n    \"\"\"\n    fields = ()\n    attributes = ('lineno', 'environment')\n    abstract = True\n\n    def __init__(self, *fields, **attributes):\n        if self.abstract:\n            raise TypeError('abstract nodes are not instanciable')\n        if fields:\n            if len(fields) != len(self.fields):\n                if not self.fields:\n                    raise TypeError('%r takes 0 arguments' %\n                                    self.__class__.__name__)\n                raise TypeError('%r takes 0 or %d argument%s' % (\n                    self.__class__.__name__,\n                    len(self.fields),\n                    len(self.fields) != 1 and 's' or ''\n                ))\n            for name, arg in izip(self.fields, fields):\n                setattr(self, name, arg)\n        for attr in self.attributes:\n            setattr(self, attr, attributes.pop(attr, None))\n        if attributes:\n            raise TypeError('unknown attribute %r' %\n                            next(iter(attributes)))\n\n    def iter_fields(self, exclude=None, only=None):\n        \"\"\"This method iterates over all fields that are defined and yields\n        ``(key, value)`` tuples.  Per default all fields are returned, but\n        it's possible to limit that to some fields by providing the `only`\n        parameter or to exclude some using the `exclude` parameter.  Both\n        should be sets or tuples of field names.\n        \"\"\"\n        for name in self.fields:\n            if (exclude is only is None) or \\\n               (exclude is not None and name not in exclude) or \\\n               (only is not None and name in only):\n                try:\n                    yield name, getattr(self, name)\n                except AttributeError:\n                    pass\n\n    def iter_child_nodes(self, exclude=None, only=None):\n        \"\"\"Iterates over all direct child nodes of the node.  This iterates\n        over all fields and yields the values of they are nodes.  If the value\n        of a field is a list all the nodes in that list are returned.\n        \"\"\"\n        for field, item in self.iter_fields(exclude, only):\n            if isinstance(item, list):\n                for n in item:\n                    if isinstance(n, Node):\n                        yield n\n            elif isinstance(item, Node):\n                yield item\n\n    def find(self, node_type):\n        \"\"\"Find the first node of a given type.  If no such node exists the\n        return value is `None`.\n        \"\"\"\n        for result in self.find_all(node_type):\n            return result\n\n    def find_all(self, node_type):\n        \"\"\"Find all the nodes of a given type.  If the type is a tuple,\n        the check is performed for any of the tuple items.\n        \"\"\"\n        for child in self.iter_child_nodes():\n            if isinstance(child, node_type):\n                yield child\n            for result in child.find_all(node_type):\n                yield result\n\n    def set_ctx(self, ctx):\n        \"\"\"Reset the context of a node and all child nodes.  Per default the\n        parser will all generate nodes that have a 'load' context as it's the\n        most common one.  This method is used in the parser to set assignment\n        targets and other nodes to a store context.\n        \"\"\"\n        todo = deque([self])\n        while todo:\n            node = todo.popleft()\n            if 'ctx' in node.fields:\n                node.ctx = ctx\n            todo.extend(node.iter_child_nodes())\n        return self\n\n    def set_lineno(self, lineno, override=False):\n        \"\"\"Set the line numbers of the node and children.\"\"\"\n        todo = deque([self])\n        while todo:\n            node = todo.popleft()\n            if 'lineno' in node.attributes:\n                if node.lineno is None or override:\n                    node.lineno = lineno\n            todo.extend(node.iter_child_nodes())\n        return self\n\n    def set_environment(self, environment):\n        \"\"\"Set the environment for all nodes.\"\"\"\n        todo = deque([self])\n        while todo:\n            node = todo.popleft()\n            node.environment = environment\n            todo.extend(node.iter_child_nodes())\n        return self\n\n    def __eq__(self, other):\n        return type(self) is type(other) and \\\n               tuple(self.iter_fields()) == tuple(other.iter_fields())\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    # Restore Python 2 hashing behavior on Python 3\n    __hash__ = object.__hash__\n\n    def __repr__(self):\n        return '%s(%s)' % (\n            self.__class__.__name__,\n            ', '.join('%s=%r' % (arg, getattr(self, arg, None)) for\n                      arg in self.fields)\n        )\n\n\nclass Stmt(Node):\n    \"\"\"Base node for all statements.\"\"\"\n    abstract = True\n\n\nclass Helper(Node):\n    \"\"\"Nodes that exist in a specific context only.\"\"\"\n    abstract = True\n\n\nclass Template(Node):\n    \"\"\"Node that represents a template.  This must be the outermost node that\n    is passed to the compiler.\n    \"\"\"\n    fields = ('body',)\n\n\nclass Output(Stmt):\n    \"\"\"A node that holds multiple expressions which are then printed out.\n    This is used both for the `print` statement and the regular template data.\n    \"\"\"\n    fields = ('nodes',)\n\n\nclass Extends(Stmt):\n    \"\"\"Represents an extends statement.\"\"\"\n    fields = ('template',)\n\n\nclass For(Stmt):\n    \"\"\"The for loop.  `target` is the target for the iteration (usually a\n    :class:`Name` or :class:`Tuple`), `iter` the iterable.  `body` is a list\n    of nodes that are used as loop-body, and `else_` a list of nodes for the\n    `else` block.  If no else node exists it has to be an empty list.\n\n    For filtered nodes an expression can be stored as `test`, otherwise `None`.\n    \"\"\"\n    fields = ('target', 'iter', 'body', 'else_', 'test', 'recursive')\n\n\nclass If(Stmt):\n    \"\"\"If `test` is true, `body` is rendered, else `else_`.\"\"\"\n    fields = ('test', 'body', 'else_')\n\n\nclass Macro(Stmt):\n    \"\"\"A macro definition.  `name` is the name of the macro, `args` a list of\n    arguments and `defaults` a list of defaults if there are any.  `body` is\n    a list of nodes for the macro body.\n    \"\"\"\n    fields = ('name', 'args', 'defaults', 'body')\n\n\nclass CallBlock(Stmt):\n    \"\"\"Like a macro without a name but a call instead.  `call` is called with\n    the unnamed macro as `caller` argument this node holds.\n    \"\"\"\n    fields = ('call', 'args', 'defaults', 'body')\n\n\nclass FilterBlock(Stmt):\n    \"\"\"Node for filter sections.\"\"\"\n    fields = ('body', 'filter')\n\n\nclass Block(Stmt):\n    \"\"\"A node that represents a block.\"\"\"\n    fields = ('name', 'body', 'scoped')\n\n\nclass Include(Stmt):\n    \"\"\"A node that represents the include tag.\"\"\"\n    fields = ('template', 'with_context', 'ignore_missing')\n\n\nclass Import(Stmt):\n    \"\"\"A node that represents the import tag.\"\"\"\n    fields = ('template', 'target', 'with_context')\n\n\nclass FromImport(Stmt):\n    \"\"\"A node that represents the from import tag.  It's important to not\n    pass unsafe names to the name attribute.  The compiler translates the\n    attribute lookups directly into getattr calls and does *not* use the\n    subscript callback of the interface.  As exported variables may not\n    start with double underscores (which the parser asserts) this is not a\n    problem for regular Jinja code, but if this node is used in an extension\n    extra care must be taken.\n\n    The list of names may contain tuples if aliases are wanted.\n    \"\"\"\n    fields = ('template', 'names', 'with_context')\n\n\nclass ExprStmt(Stmt):\n    \"\"\"A statement that evaluates an expression and discards the result.\"\"\"\n    fields = ('node',)\n\n\nclass Assign(Stmt):\n    \"\"\"Assigns an expression to a target.\"\"\"\n    fields = ('target', 'node')\n\n\nclass AssignBlock(Stmt):\n    \"\"\"Assigns a block to a target.\"\"\"\n    fields = ('target', 'body')\n\n\nclass Expr(Node):\n    \"\"\"Baseclass for all expressions.\"\"\"\n    abstract = True\n\n    def as_const(self, eval_ctx=None):\n        \"\"\"Return the value of the expression as constant or raise\n        :exc:`Impossible` if this was not possible.\n\n        An :class:`EvalContext` can be provided, if none is given\n        a default context is created which requires the nodes to have\n        an attached environment.\n\n        .. versionchanged:: 2.4\n           the `eval_ctx` parameter was added.\n        \"\"\"\n        raise Impossible()\n\n    def can_assign(self):\n        \"\"\"Check if it's possible to assign something to this node.\"\"\"\n        return False\n\n\nclass BinExpr(Expr):\n    \"\"\"Baseclass for all binary expressions.\"\"\"\n    fields = ('left', 'right')\n    operator = None\n    abstract = True\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        # intercepted operators cannot be folded at compile time\n        if self.environment.sandboxed and \\\n           self.operator in self.environment.intercepted_binops:\n            raise Impossible()\n        f = _binop_to_func[self.operator]\n        try:\n            return f(self.left.as_const(eval_ctx), self.right.as_const(eval_ctx))\n        except Exception:\n            raise Impossible()\n\n\nclass UnaryExpr(Expr):\n    \"\"\"Baseclass for all unary expressions.\"\"\"\n    fields = ('node',)\n    operator = None\n    abstract = True\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        # intercepted operators cannot be folded at compile time\n        if self.environment.sandboxed and \\\n           self.operator in self.environment.intercepted_unops:\n            raise Impossible()\n        f = _uaop_to_func[self.operator]\n        try:\n            return f(self.node.as_const(eval_ctx))\n        except Exception:\n            raise Impossible()\n\n\nclass Name(Expr):\n    \"\"\"Looks up a name or stores a value in a name.\n    The `ctx` of the node can be one of the following values:\n\n    -   `store`: store a value in the name\n    -   `load`: load that name\n    -   `param`: like `store` but if the name was defined as function parameter.\n    \"\"\"\n    fields = ('name', 'ctx')\n\n    def can_assign(self):\n        return self.name not in ('true', 'false', 'none',\n                                 'True', 'False', 'None')\n\n\nclass Literal(Expr):\n    \"\"\"Baseclass for literals.\"\"\"\n    abstract = True\n\n\nclass Const(Literal):\n    \"\"\"All constant values.  The parser will return this node for simple\n    constants such as ``42`` or ``\"foo\"`` but it can be used to store more\n    complex values such as lists too.  Only constants with a safe\n    representation (objects where ``eval(repr(x)) == x`` is true).\n    \"\"\"\n    fields = ('value',)\n\n    def as_const(self, eval_ctx=None):\n        return self.value\n\n    @classmethod\n    def from_untrusted(cls, value, lineno=None, environment=None):\n        \"\"\"Return a const object if the value is representable as\n        constant value in the generated code, otherwise it will raise\n        an `Impossible` exception.\n        \"\"\"\n        from .compiler import has_safe_repr\n        if not has_safe_repr(value):\n            raise Impossible()\n        return cls(value, lineno=lineno, environment=environment)\n\n\nclass TemplateData(Literal):\n    \"\"\"A constant template string.\"\"\"\n    fields = ('data',)\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if eval_ctx.volatile:\n            raise Impossible()\n        if eval_ctx.autoescape:\n            return Markup(self.data)\n        return self.data\n\n\nclass Tuple(Literal):\n    \"\"\"For loop unpacking and some other things like multiple arguments\n    for subscripts.  Like for :class:`Name` `ctx` specifies if the tuple\n    is used for loading the names or storing.\n    \"\"\"\n    fields = ('items', 'ctx')\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return tuple(x.as_const(eval_ctx) for x in self.items)\n\n    def can_assign(self):\n        for item in self.items:\n            if not item.can_assign():\n                return False\n        return True\n\n\nclass List(Literal):\n    \"\"\"Any list literal such as ``[1, 2, 3]``\"\"\"\n    fields = ('items',)\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return [x.as_const(eval_ctx) for x in self.items]\n\n\nclass Dict(Literal):\n    \"\"\"Any dict literal such as ``{1: 2, 3: 4}``.  The items must be a list of\n    :class:`Pair` nodes.\n    \"\"\"\n    fields = ('items',)\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return dict(x.as_const(eval_ctx) for x in self.items)\n\n\nclass Pair(Helper):\n    \"\"\"A key, value pair for dicts.\"\"\"\n    fields = ('key', 'value')\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return self.key.as_const(eval_ctx), self.value.as_const(eval_ctx)\n\n\nclass Keyword(Helper):\n    \"\"\"A key, value pair for keyword arguments where key is a string.\"\"\"\n    fields = ('key', 'value')\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return self.key, self.value.as_const(eval_ctx)\n\n\nclass CondExpr(Expr):\n    \"\"\"A conditional expression (inline if expression).  (``{{\n    foo if bar else baz }}``)\n    \"\"\"\n    fields = ('test', 'expr1', 'expr2')\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if self.test.as_const(eval_ctx):\n            return self.expr1.as_const(eval_ctx)\n\n        # if we evaluate to an undefined object, we better do that at runtime\n        if self.expr2 is None:\n            raise Impossible()\n\n        return self.expr2.as_const(eval_ctx)\n\n\nclass Filter(Expr):\n    \"\"\"This node applies a filter on an expression.  `name` is the name of\n    the filter, the rest of the fields are the same as for :class:`Call`.\n\n    If the `node` of a filter is `None` the contents of the last buffer are\n    filtered.  Buffers are created by macros and filter blocks.\n    \"\"\"\n    fields = ('node', 'name', 'args', 'kwargs', 'dyn_args', 'dyn_kwargs')\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if eval_ctx.volatile or self.node is None:\n            raise Impossible()\n        # we have to be careful here because we call filter_ below.\n        # if this variable would be called filter, 2to3 would wrap the\n        # call in a list beause it is assuming we are talking about the\n        # builtin filter function here which no longer returns a list in\n        # python 3.  because of that, do not rename filter_ to filter!\n        filter_ = self.environment.filters.get(self.name)\n        if filter_ is None or getattr(filter_, 'contextfilter', False):\n            raise Impossible()\n        obj = self.node.as_const(eval_ctx)\n        args = [x.as_const(eval_ctx) for x in self.args]\n        if getattr(filter_, 'evalcontextfilter', False):\n            args.insert(0, eval_ctx)\n        elif getattr(filter_, 'environmentfilter', False):\n            args.insert(0, self.environment)\n        kwargs = dict(x.as_const(eval_ctx) for x in self.kwargs)\n        if self.dyn_args is not None:\n            try:\n                args.extend(self.dyn_args.as_const(eval_ctx))\n            except Exception:\n                raise Impossible()\n        if self.dyn_kwargs is not None:\n            try:\n                kwargs.update(self.dyn_kwargs.as_const(eval_ctx))\n            except Exception:\n                raise Impossible()\n        try:\n            return filter_(obj, *args, **kwargs)\n        except Exception:\n            raise Impossible()\n\n\nclass Test(Expr):\n    \"\"\"Applies a test on an expression.  `name` is the name of the test, the\n    rest of the fields are the same as for :class:`Call`.\n    \"\"\"\n    fields = ('node', 'name', 'args', 'kwargs', 'dyn_args', 'dyn_kwargs')\n\n\nclass Call(Expr):\n    \"\"\"Calls an expression.  `args` is a list of arguments, `kwargs` a list\n    of keyword arguments (list of :class:`Keyword` nodes), and `dyn_args`\n    and `dyn_kwargs` has to be either `None` or a node that is used as\n    node for dynamic positional (``*args``) or keyword (``**kwargs``)\n    arguments.\n    \"\"\"\n    fields = ('node', 'args', 'kwargs', 'dyn_args', 'dyn_kwargs')\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if eval_ctx.volatile:\n            raise Impossible()\n        obj = self.node.as_const(eval_ctx)\n\n        # don't evaluate context functions\n        args = [x.as_const(eval_ctx) for x in self.args]\n        if isinstance(obj, _context_function_types):\n            if getattr(obj, 'contextfunction', False):\n                raise Impossible()\n            elif getattr(obj, 'evalcontextfunction', False):\n                args.insert(0, eval_ctx)\n            elif getattr(obj, 'environmentfunction', False):\n                args.insert(0, self.environment)\n\n        kwargs = dict(x.as_const(eval_ctx) for x in self.kwargs)\n        if self.dyn_args is not None:\n            try:\n                args.extend(self.dyn_args.as_const(eval_ctx))\n            except Exception:\n                raise Impossible()\n        if self.dyn_kwargs is not None:\n            try:\n                kwargs.update(self.dyn_kwargs.as_const(eval_ctx))\n            except Exception:\n                raise Impossible()\n        try:\n            return obj(*args, **kwargs)\n        except Exception:\n            raise Impossible()\n\n\nclass Getitem(Expr):\n    \"\"\"Get an attribute or item from an expression and prefer the item.\"\"\"\n    fields = ('node', 'arg', 'ctx')\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if self.ctx != 'load':\n            raise Impossible()\n        try:\n            return self.environment.getitem(self.node.as_const(eval_ctx),\n                                            self.arg.as_const(eval_ctx))\n        except Exception:\n            raise Impossible()\n\n    def can_assign(self):\n        return False\n\n\nclass Getattr(Expr):\n    \"\"\"Get an attribute or item from an expression that is a ascii-only\n    bytestring and prefer the attribute.\n    \"\"\"\n    fields = ('node', 'attr', 'ctx')\n\n    def as_const(self, eval_ctx=None):\n        if self.ctx != 'load':\n            raise Impossible()\n        try:\n            eval_ctx = get_eval_context(self, eval_ctx)\n            return self.environment.getattr(self.node.as_const(eval_ctx),\n                                            self.attr)\n        except Exception:\n            raise Impossible()\n\n    def can_assign(self):\n        return False\n\n\nclass Slice(Expr):\n    \"\"\"Represents a slice object.  This must only be used as argument for\n    :class:`Subscript`.\n    \"\"\"\n    fields = ('start', 'stop', 'step')\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        def const(obj):\n            if obj is None:\n                return None\n            return obj.as_const(eval_ctx)\n        return slice(const(self.start), const(self.stop), const(self.step))\n\n\nclass Concat(Expr):\n    \"\"\"Concatenates the list of expressions provided after converting them to\n    unicode.\n    \"\"\"\n    fields = ('nodes',)\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return ''.join(text_type(x.as_const(eval_ctx)) for x in self.nodes)\n\n\nclass Compare(Expr):\n    \"\"\"Compares an expression with some other expressions.  `ops` must be a\n    list of :class:`Operand`\\s.\n    \"\"\"\n    fields = ('expr', 'ops')\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        result = value = self.expr.as_const(eval_ctx)\n        try:\n            for op in self.ops:\n                new_value = op.expr.as_const(eval_ctx)\n                result = _cmpop_to_func[op.op](value, new_value)\n                value = new_value\n        except Exception:\n            raise Impossible()\n        return result\n\n\nclass Operand(Helper):\n    \"\"\"Holds an operator and an expression.\"\"\"\n    fields = ('op', 'expr')\n\nif __debug__:\n    Operand.__doc__ += '\\nThe following operators are available: ' + \\\n        ', '.join(sorted('``%s``' % x for x in set(_binop_to_func) |\n                  set(_uaop_to_func) | set(_cmpop_to_func)))\n\n\nclass Mul(BinExpr):\n    \"\"\"Multiplies the left with the right node.\"\"\"\n    operator = '*'\n\n\nclass Div(BinExpr):\n    \"\"\"Divides the left by the right node.\"\"\"\n    operator = '/'\n\n\nclass FloorDiv(BinExpr):\n    \"\"\"Divides the left by the right node and truncates conver the\n    result into an integer by truncating.\n    \"\"\"\n    operator = '//'\n\n\nclass Add(BinExpr):\n    \"\"\"Add the left to the right node.\"\"\"\n    operator = '+'\n\n\nclass Sub(BinExpr):\n    \"\"\"Subtract the right from the left node.\"\"\"\n    operator = '-'\n\n\nclass Mod(BinExpr):\n    \"\"\"Left modulo right.\"\"\"\n    operator = '%'\n\n\nclass Pow(BinExpr):\n    \"\"\"Left to the power of right.\"\"\"\n    operator = '**'\n\n\nclass And(BinExpr):\n    \"\"\"Short circuited AND.\"\"\"\n    operator = 'and'\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return self.left.as_const(eval_ctx) and self.right.as_const(eval_ctx)\n\n\nclass Or(BinExpr):\n    \"\"\"Short circuited OR.\"\"\"\n    operator = 'or'\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return self.left.as_const(eval_ctx) or self.right.as_const(eval_ctx)\n\n\nclass Not(UnaryExpr):\n    \"\"\"Negate the expression.\"\"\"\n    operator = 'not'\n\n\nclass Neg(UnaryExpr):\n    \"\"\"Make the expression negative.\"\"\"\n    operator = '-'\n\n\nclass Pos(UnaryExpr):\n    \"\"\"Make the expression positive (noop for most expressions)\"\"\"\n    operator = '+'\n\n\n# Helpers for extensions\n\n\nclass EnvironmentAttribute(Expr):\n    \"\"\"Loads an attribute from the environment object.  This is useful for\n    extensions that want to call a callback stored on the environment.\n    \"\"\"\n    fields = ('name',)\n\n\nclass ExtensionAttribute(Expr):\n    \"\"\"Returns the attribute of an extension bound to the environment.\n    The identifier is the identifier of the :class:`Extension`.\n\n    This node is usually constructed by calling the\n    :meth:`~jinja2.ext.Extension.attr` method on an extension.\n    \"\"\"\n    fields = ('identifier', 'name')\n\n\nclass ImportedName(Expr):\n    \"\"\"If created with an import name the import name is returned on node\n    access.  For example ``ImportedName('cgi.escape')`` returns the `escape`\n    function from the cgi module on evaluation.  Imports are optimized by the\n    compiler so there is no need to assign them to local variables.\n    \"\"\"\n    fields = ('importname',)\n\n\nclass InternalName(Expr):\n    \"\"\"An internal name in the compiler.  You cannot create these nodes\n    yourself but the parser provides a\n    :meth:`~jinja2.parser.Parser.free_identifier` method that creates\n    a new identifier for you.  This identifier is not available from the\n    template and is not threated specially by the compiler.\n    \"\"\"\n    fields = ('name',)\n\n    def __init__(self):\n        raise TypeError('Can\\'t create internal names.  Use the '\n                        '`free_identifier` method on a parser.')\n\n\nclass MarkSafe(Expr):\n    \"\"\"Mark the wrapped expression as safe (wrap it as `Markup`).\"\"\"\n    fields = ('expr',)\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return Markup(self.expr.as_const(eval_ctx))\n\n\nclass MarkSafeIfAutoescape(Expr):\n    \"\"\"Mark the wrapped expression as safe (wrap it as `Markup`) but\n    only if autoescaping is active.\n\n    .. versionadded:: 2.5\n    \"\"\"\n    fields = ('expr',)\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if eval_ctx.volatile:\n            raise Impossible()\n        expr = self.expr.as_const(eval_ctx)\n        if eval_ctx.autoescape:\n            return Markup(expr)\n        return expr\n\n\nclass ContextReference(Expr):\n    \"\"\"Returns the current template context.  It can be used like a\n    :class:`Name` node, with a ``'load'`` ctx and will return the\n    current :class:`~jinja2.runtime.Context` object.\n\n    Here an example that assigns the current template name to a\n    variable named `foo`::\n\n        Assign(Name('foo', ctx='store'),\n               Getattr(ContextReference(), 'name'))\n    \"\"\"\n\n\nclass Continue(Stmt):\n    \"\"\"Continue a loop.\"\"\"\n\n\nclass Break(Stmt):\n    \"\"\"Break a loop.\"\"\"\n\n\nclass Scope(Stmt):\n    \"\"\"An artificial scope.\"\"\"\n    fields = ('body',)\n\n\nclass EvalContextModifier(Stmt):\n    \"\"\"Modifies the eval context.  For each option that should be modified,\n    a :class:`Keyword` has to be added to the :attr:`options` list.\n\n    Example to change the `autoescape` setting::\n\n        EvalContextModifier(options=[Keyword('autoescape', Const(True))])\n    \"\"\"\n    fields = ('options',)\n\n\nclass ScopedEvalContextModifier(EvalContextModifier):\n    \"\"\"Modifies the eval context and reverts it later.  Works exactly like\n    :class:`EvalContextModifier` but will only modify the\n    :class:`~jinja2.nodes.EvalContext` for nodes in the :attr:`body`.\n    \"\"\"\n    fields = ('body',)\n\n\n# make sure nobody creates custom nodes\ndef _failing_new(*args, **kwargs):\n    raise TypeError('can\\'t create custom node types')\nNodeType.__new__ = staticmethod(_failing_new); del _failing_new\n", "# -*- coding: utf-8 -*-\n\"\"\"\n    jinja2.sandbox\n    ~~~~~~~~~~~~~~\n\n    Adds a sandbox layer to Jinja as it was the default behavior in the old\n    Jinja 1 releases.  This sandbox is slightly different from Jinja 1 as the\n    default behavior is easier to use.\n\n    The behavior can be changed by subclassing the environment.\n\n    :copyright: (c) 2010 by the Jinja Team.\n    :license: BSD.\n\"\"\"\nimport types\nimport operator\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import SecurityError\nfrom jinja2._compat import string_types, PY2\n\n\n#: maximum number of items a range may produce\nMAX_RANGE = 100000\n\n#: attributes of function objects that are considered unsafe.\nif PY2:\n    UNSAFE_FUNCTION_ATTRIBUTES = set(['func_closure', 'func_code', 'func_dict',\n                                      'func_defaults', 'func_globals'])\nelse:\n    # On versions > python 2 the special attributes on functions are gone,\n    # but they remain on methods and generators for whatever reason.\n    UNSAFE_FUNCTION_ATTRIBUTES = set()\n\n\n#: unsafe method attributes.  function attributes are unsafe for methods too\nUNSAFE_METHOD_ATTRIBUTES = set(['im_class', 'im_func', 'im_self'])\n\n#: unsafe generator attirbutes.\nUNSAFE_GENERATOR_ATTRIBUTES = set(['gi_frame', 'gi_code'])\n\nimport warnings\n\n# make sure we don't warn in python 2.6 about stuff we don't care about\nwarnings.filterwarnings('ignore', 'the sets module', DeprecationWarning,\n                        module='jinja2.sandbox')\n\nfrom collections import deque\n\n_mutable_set_types = (set,)\n_mutable_mapping_types = (dict,)\n_mutable_sequence_types = (list,)\n\n\n# on python 2.x we can register the user collection types\ntry:\n    from UserDict import UserDict, DictMixin\n    from UserList import UserList\n    _mutable_mapping_types += (UserDict, DictMixin)\n    _mutable_set_types += (UserList,)\nexcept ImportError:\n    pass\n\n# if sets is still available, register the mutable set from there as well\ntry:\n    from sets import Set\n    _mutable_set_types += (Set,)\nexcept ImportError:\n    pass\n\n#: register Python 2.6 abstract base classes\ntry:\n    from collections import MutableSet, MutableMapping, MutableSequence\n    _mutable_set_types += (MutableSet,)\n    _mutable_mapping_types += (MutableMapping,)\n    _mutable_sequence_types += (MutableSequence,)\nexcept ImportError:\n    pass\n\n_mutable_spec = (\n    (_mutable_set_types, frozenset([\n        'add', 'clear', 'difference_update', 'discard', 'pop', 'remove',\n        'symmetric_difference_update', 'update'\n    ])),\n    (_mutable_mapping_types, frozenset([\n        'clear', 'pop', 'popitem', 'setdefault', 'update'\n    ])),\n    (_mutable_sequence_types, frozenset([\n        'append', 'reverse', 'insert', 'sort', 'extend', 'remove'\n    ])),\n    (deque, frozenset([\n        'append', 'appendleft', 'clear', 'extend', 'extendleft', 'pop',\n        'popleft', 'remove', 'rotate'\n    ]))\n)\n\n\ndef safe_range(*args):\n    \"\"\"A range that can't generate ranges with a length of more than\n    MAX_RANGE items.\n    \"\"\"\n    rng = range(*args)\n    if len(rng) > MAX_RANGE:\n        raise OverflowError('range too big, maximum size for range is %d' %\n                            MAX_RANGE)\n    return rng\n\n\ndef unsafe(f):\n    \"\"\"Marks a function or method as unsafe.\n\n    ::\n\n        @unsafe\n        def delete(self):\n            pass\n    \"\"\"\n    f.unsafe_callable = True\n    return f\n\n\ndef is_internal_attribute(obj, attr):\n    \"\"\"Test if the attribute given is an internal python attribute.  For\n    example this function returns `True` for the `func_code` attribute of\n    python objects.  This is useful if the environment method\n    :meth:`~SandboxedEnvironment.is_safe_attribute` is overridden.\n\n    >>> from jinja2.sandbox import is_internal_attribute\n    >>> is_internal_attribute(str, \"mro\")\n    True\n    >>> is_internal_attribute(str, \"upper\")\n    False\n    \"\"\"\n    if isinstance(obj, types.FunctionType):\n        if attr in UNSAFE_FUNCTION_ATTRIBUTES:\n            return True\n    elif isinstance(obj, types.MethodType):\n        if attr in UNSAFE_FUNCTION_ATTRIBUTES or \\\n           attr in UNSAFE_METHOD_ATTRIBUTES:\n            return True\n    elif isinstance(obj, type):\n        if attr == 'mro':\n            return True\n    elif isinstance(obj, (types.CodeType, types.TracebackType, types.FrameType)):\n        return True\n    elif isinstance(obj, types.GeneratorType):\n        if attr in UNSAFE_GENERATOR_ATTRIBUTES:\n            return True\n    return attr.startswith('__')\n\n\ndef modifies_known_mutable(obj, attr):\n    \"\"\"This function checks if an attribute on a builtin mutable object\n    (list, dict, set or deque) would modify it if called.  It also supports\n    the \"user\"-versions of the objects (`sets.Set`, `UserDict.*` etc.) and\n    with Python 2.6 onwards the abstract base classes `MutableSet`,\n    `MutableMapping`, and `MutableSequence`.\n\n    >>> modifies_known_mutable({}, \"clear\")\n    True\n    >>> modifies_known_mutable({}, \"keys\")\n    False\n    >>> modifies_known_mutable([], \"append\")\n    True\n    >>> modifies_known_mutable([], \"index\")\n    False\n\n    If called with an unsupported object (such as unicode) `False` is\n    returned.\n\n    >>> modifies_known_mutable(\"foo\", \"upper\")\n    False\n    \"\"\"\n    for typespec, unsafe in _mutable_spec:\n        if isinstance(obj, typespec):\n            return attr in unsafe\n    return False\n\n\nclass SandboxedEnvironment(Environment):\n    \"\"\"The sandboxed environment.  It works like the regular environment but\n    tells the compiler to generate sandboxed code.  Additionally subclasses of\n    this environment may override the methods that tell the runtime what\n    attributes or functions are safe to access.\n\n    If the template tries to access insecure code a :exc:`SecurityError` is\n    raised.  However also other exceptions may occour during the rendering so\n    the caller has to ensure that all exceptions are catched.\n    \"\"\"\n    sandboxed = True\n\n    #: default callback table for the binary operators.  A copy of this is\n    #: available on each instance of a sandboxed environment as\n    #: :attr:`binop_table`\n    default_binop_table = {\n        '+':        operator.add,\n        '-':        operator.sub,\n        '*':        operator.mul,\n        '/':        operator.truediv,\n        '//':       operator.floordiv,\n        '**':       operator.pow,\n        '%':        operator.mod\n    }\n\n    #: default callback table for the unary operators.  A copy of this is\n    #: available on each instance of a sandboxed environment as\n    #: :attr:`unop_table`\n    default_unop_table = {\n        '+':        operator.pos,\n        '-':        operator.neg\n    }\n\n    #: a set of binary operators that should be intercepted.  Each operator\n    #: that is added to this set (empty by default) is delegated to the\n    #: :meth:`call_binop` method that will perform the operator.  The default\n    #: operator callback is specified by :attr:`binop_table`.\n    #:\n    #: The following binary operators are interceptable:\n    #: ``//``, ``%``, ``+``, ``*``, ``-``, ``/``, and ``**``\n    #:\n    #: The default operation form the operator table corresponds to the\n    #: builtin function.  Intercepted calls are always slower than the native\n    #: operator call, so make sure only to intercept the ones you are\n    #: interested in.\n    #:\n    #: .. versionadded:: 2.6\n    intercepted_binops = frozenset()\n\n    #: a set of unary operators that should be intercepted.  Each operator\n    #: that is added to this set (empty by default) is delegated to the\n    #: :meth:`call_unop` method that will perform the operator.  The default\n    #: operator callback is specified by :attr:`unop_table`.\n    #:\n    #: The following unary operators are interceptable: ``+``, ``-``\n    #:\n    #: The default operation form the operator table corresponds to the\n    #: builtin function.  Intercepted calls are always slower than the native\n    #: operator call, so make sure only to intercept the ones you are\n    #: interested in.\n    #:\n    #: .. versionadded:: 2.6\n    intercepted_unops = frozenset()\n\n    def intercept_unop(self, operator):\n        \"\"\"Called during template compilation with the name of a unary\n        operator to check if it should be intercepted at runtime.  If this\n        method returns `True`, :meth:`call_unop` is excuted for this unary\n        operator.  The default implementation of :meth:`call_unop` will use\n        the :attr:`unop_table` dictionary to perform the operator with the\n        same logic as the builtin one.\n\n        The following unary operators are interceptable: ``+`` and ``-``\n\n        Intercepted calls are always slower than the native operator call,\n        so make sure only to intercept the ones you are interested in.\n\n        .. versionadded:: 2.6\n        \"\"\"\n        return False\n\n\n    def __init__(self, *args, **kwargs):\n        Environment.__init__(self, *args, **kwargs)\n        self.globals['range'] = safe_range\n        self.binop_table = self.default_binop_table.copy()\n        self.unop_table = self.default_unop_table.copy()\n\n    def is_safe_attribute(self, obj, attr, value):\n        \"\"\"The sandboxed environment will call this method to check if the\n        attribute of an object is safe to access.  Per default all attributes\n        starting with an underscore are considered private as well as the\n        special attributes of internal python objects as returned by the\n        :func:`is_internal_attribute` function.\n        \"\"\"\n        return not (attr.startswith('_') or is_internal_attribute(obj, attr))\n\n    def is_safe_callable(self, obj):\n        \"\"\"Check if an object is safely callable.  Per default a function is\n        considered safe unless the `unsafe_callable` attribute exists and is\n        True.  Override this method to alter the behavior, but this won't\n        affect the `unsafe` decorator from this module.\n        \"\"\"\n        return not (getattr(obj, 'unsafe_callable', False) or\n                    getattr(obj, 'alters_data', False))\n\n    def call_binop(self, context, operator, left, right):\n        \"\"\"For intercepted binary operator calls (:meth:`intercepted_binops`)\n        this function is executed instead of the builtin operator.  This can\n        be used to fine tune the behavior of certain operators.\n\n        .. versionadded:: 2.6\n        \"\"\"\n        return self.binop_table[operator](left, right)\n\n    def call_unop(self, context, operator, arg):\n        \"\"\"For intercepted unary operator calls (:meth:`intercepted_unops`)\n        this function is executed instead of the builtin operator.  This can\n        be used to fine tune the behavior of certain operators.\n\n        .. versionadded:: 2.6\n        \"\"\"\n        return self.unop_table[operator](arg)\n\n    def getitem(self, obj, argument):\n        \"\"\"Subscribe an object from sandboxed code.\"\"\"\n        try:\n            return obj[argument]\n        except (TypeError, LookupError):\n            if isinstance(argument, string_types):\n                try:\n                    attr = str(argument)\n                except Exception:\n                    pass\n                else:\n                    try:\n                        value = getattr(obj, attr)\n                    except AttributeError:\n                        pass\n                    else:\n                        if self.is_safe_attribute(obj, argument, value):\n                            return value\n                        return self.unsafe_undefined(obj, argument)\n        return self.undefined(obj=obj, name=argument)\n\n    def getattr(self, obj, attribute):\n        \"\"\"Subscribe an object from sandboxed code and prefer the\n        attribute.  The attribute passed *must* be a bytestring.\n        \"\"\"\n        try:\n            value = getattr(obj, attribute)\n        except AttributeError:\n            try:\n                return obj[attribute]\n            except (TypeError, LookupError):\n                pass\n        else:\n            if self.is_safe_attribute(obj, attribute, value):\n                return value\n            return self.unsafe_undefined(obj, attribute)\n        return self.undefined(obj=obj, name=attribute)\n\n    def unsafe_undefined(self, obj, attribute):\n        \"\"\"Return an undefined object for unsafe attributes.\"\"\"\n        return self.undefined('access to attribute %r of %r '\n                              'object is unsafe.' % (\n            attribute,\n            obj.__class__.__name__\n        ), name=attribute, obj=obj, exc=SecurityError)\n\n    def call(__self, __context, __obj, *args, **kwargs):\n        \"\"\"Call an object from sandboxed code.\"\"\"\n        # the double prefixes are to avoid double keyword argument\n        # errors when proxying the call.\n        if not __self.is_safe_callable(__obj):\n            raise SecurityError('%r is not safely callable' % (__obj,))\n        return __context.call(__obj, *args, **kwargs)\n\n\nclass ImmutableSandboxedEnvironment(SandboxedEnvironment):\n    \"\"\"Works exactly like the regular `SandboxedEnvironment` but does not\n    permit modifications on the builtin mutable objects `list`, `set`, and\n    `dict` by using the :func:`modifies_known_mutable` function.\n    \"\"\"\n\n    def is_safe_attribute(self, obj, attr, value):\n        if not SandboxedEnvironment.is_safe_attribute(self, obj, attr, value):\n            return False\n        return not modifies_known_mutable(obj, attr)\n", "# -*- coding: utf-8 -*-\n\"\"\"\n    jinja2.testsuite.security\n    ~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Checks the sandbox and other security features.\n\n    :copyright: (c) 2010 by the Jinja Team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport pytest\n\nfrom jinja2 import Environment\nfrom jinja2.sandbox import SandboxedEnvironment, \\\n     ImmutableSandboxedEnvironment, unsafe\nfrom jinja2 import Markup, escape\nfrom jinja2.exceptions import SecurityError, TemplateSyntaxError, \\\n     TemplateRuntimeError\nfrom jinja2._compat import text_type\n\n\nclass PrivateStuff(object):\n\n    def bar(self):\n        return 23\n\n    @unsafe\n    def foo(self):\n        return 42\n\n    def __repr__(self):\n        return 'PrivateStuff'\n\n\nclass PublicStuff(object):\n    bar = lambda self: 23\n    _foo = lambda self: 42\n\n    def __repr__(self):\n        return 'PublicStuff'\n\n\n@pytest.mark.sandbox\nclass TestSandbox():\n\n    def test_unsafe(self, env):\n        env = SandboxedEnvironment()\n        pytest.raises(SecurityError, env.from_string(\"{{ foo.foo() }}\").render,\n                      foo=PrivateStuff())\n        assert env.from_string(\"{{ foo.bar() }}\").render(foo=PrivateStuff()) == '23'\n\n        pytest.raises(SecurityError,\n                      env.from_string(\"{{ foo._foo() }}\").render,\n                      foo=PublicStuff())\n        assert env.from_string(\"{{ foo.bar() }}\").render(foo=PublicStuff()) == '23'\n        assert env.from_string(\"{{ foo.__class__ }}\").render(foo=42) == ''\n        assert env.from_string(\"{{ foo.func_code }}\").render(foo=lambda:None) == ''\n        # security error comes from __class__ already.\n        pytest.raises(SecurityError, env.from_string(\n            \"{{ foo.__class__.__subclasses__() }}\").render, foo=42)\n\n    def test_immutable_environment(self, env):\n        env = ImmutableSandboxedEnvironment()\n        pytest.raises(SecurityError, env.from_string(\n            '{{ [].append(23) }}').render)\n        pytest.raises(SecurityError, env.from_string(\n            '{{ {1:2}.clear() }}').render)\n\n    def test_restricted(self, env):\n        env = SandboxedEnvironment()\n        pytest.raises(TemplateSyntaxError, env.from_string,\n                      \"{% for item.attribute in seq %}...{% endfor %}\")\n        pytest.raises(TemplateSyntaxError, env.from_string,\n                      \"{% for foo, bar.baz in seq %}...{% endfor %}\")\n\n    def test_markup_operations(self, env):\n        # adding two strings should escape the unsafe one\n        unsafe = '<script type=\"application/x-some-script\">alert(\"foo\");</script>'\n        safe = Markup('<em>username</em>')\n        assert unsafe + safe == text_type(escape(unsafe)) + text_type(safe)\n\n        # string interpolations are safe to use too\n        assert Markup('<em>%s</em>') % '<bad user>' == \\\n            '<em>&lt;bad user&gt;</em>'\n        assert Markup('<em>%(username)s</em>') % {\n            'username': '<bad user>'\n        } == '<em>&lt;bad user&gt;</em>'\n\n        # an escaped object is markup too\n        assert type(Markup('foo') + 'bar') is Markup\n\n        # and it implements __html__ by returning itself\n        x = Markup(\"foo\")\n        assert x.__html__() is x\n\n        # it also knows how to treat __html__ objects\n        class Foo(object):\n            def __html__(self):\n                return '<em>awesome</em>'\n\n            def __unicode__(self):\n                return 'awesome'\n        assert Markup(Foo()) == '<em>awesome</em>'\n        assert Markup('<strong>%s</strong>') % Foo() == \\\n            '<strong><em>awesome</em></strong>'\n\n        # escaping and unescaping\n        assert escape('\"<>&\\'') == '&#34;&lt;&gt;&amp;&#39;'\n        assert Markup(\"<em>Foo &amp; Bar</em>\").striptags() == \"Foo & Bar\"\n        assert Markup(\"&lt;test&gt;\").unescape() == \"<test>\"\n\n    def test_template_data(self, env):\n        env = Environment(autoescape=True)\n        t = env.from_string('{% macro say_hello(name) %}'\n                            '<p>Hello {{ name }}!</p>{% endmacro %}'\n                            '{{ say_hello(\"<blink>foo</blink>\") }}')\n        escaped_out = '<p>Hello &lt;blink&gt;foo&lt;/blink&gt;!</p>'\n        assert t.render() == escaped_out\n        assert text_type(t.module) == escaped_out\n        assert escape(t.module) == escaped_out\n        assert t.module.say_hello('<blink>foo</blink>') == escaped_out\n        assert escape(t.module.say_hello('<blink>foo</blink>')) == escaped_out\n\n    def test_attr_filter(self, env):\n        env = SandboxedEnvironment()\n        tmpl = env.from_string('{{ cls|attr(\"__subclasses__\")() }}')\n        pytest.raises(SecurityError, tmpl.render, cls=int)\n\n    def test_binary_operator_intercepting(self, env):\n        def disable_op(left, right):\n            raise TemplateRuntimeError('that operator so does not work')\n        for expr, ctx, rv in ('1 + 2', {}, '3'), ('a + 2', {'a': 2}, '4'):\n            env = SandboxedEnvironment()\n            env.binop_table['+'] = disable_op\n            t = env.from_string('{{ %s }}' % expr)\n            assert t.render(ctx) == rv\n            env.intercepted_binops = frozenset(['+'])\n            t = env.from_string('{{ %s }}' % expr)\n            try:\n                t.render(ctx)\n            except TemplateRuntimeError as e:\n                pass\n            else:\n                assert False, 'expected runtime error'\n\n    def test_unary_operator_intercepting(self, env):\n        def disable_op(arg):\n            raise TemplateRuntimeError('that operator so does not work')\n        for expr, ctx, rv in ('-1', {}, '-1'), ('-a', {'a': 2}, '-2'):\n            env = SandboxedEnvironment()\n            env.unop_table['-'] = disable_op\n            t = env.from_string('{{ %s }}' % expr)\n            assert t.render(ctx) == rv\n            env.intercepted_unops = frozenset(['-'])\n            t = env.from_string('{{ %s }}' % expr)\n            try:\n                t.render(ctx)\n            except TemplateRuntimeError as e:\n                pass\n            else:\n                assert False, 'expected runtime error'\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n\"\"\"\n    jinja2.nodes\n    ~~~~~~~~~~~~\n\n    This module implements additional nodes derived from the ast base node.\n\n    It also provides some node tree helper functions like `in_lineno` and\n    `get_nodes` used by the parser and translator in order to normalize\n    python and jinja nodes.\n\n    :copyright: (c) 2010 by the Jinja Team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport types\nimport operator\n\nfrom collections import deque\nfrom jinja2.utils import Markup\nfrom jinja2._compat import izip, with_metaclass, text_type\n\n\n#: the types we support for context functions\n_context_function_types = (types.FunctionType, types.MethodType)\n\n\n_binop_to_func = {\n    '*':        operator.mul,\n    '/':        operator.truediv,\n    '//':       operator.floordiv,\n    '**':       operator.pow,\n    '%':        operator.mod,\n    '+':        operator.add,\n    '-':        operator.sub\n}\n\n_uaop_to_func = {\n    'not':      operator.not_,\n    '+':        operator.pos,\n    '-':        operator.neg\n}\n\n_cmpop_to_func = {\n    'eq':       operator.eq,\n    'ne':       operator.ne,\n    'gt':       operator.gt,\n    'gteq':     operator.ge,\n    'lt':       operator.lt,\n    'lteq':     operator.le,\n    'in':       lambda a, b: a in b,\n    'notin':    lambda a, b: a not in b\n}\n\n\nclass Impossible(Exception):\n    \"\"\"Raised if the node could not perform a requested action.\"\"\"\n\n\nclass NodeType(type):\n    \"\"\"A metaclass for nodes that handles the field and attribute\n    inheritance.  fields and attributes from the parent class are\n    automatically forwarded to the child.\"\"\"\n\n    def __new__(cls, name, bases, d):\n        for attr in 'fields', 'attributes':\n            storage = []\n            storage.extend(getattr(bases[0], attr, ()))\n            storage.extend(d.get(attr, ()))\n            assert len(bases) == 1, 'multiple inheritance not allowed'\n            assert len(storage) == len(set(storage)), 'layout conflict'\n            d[attr] = tuple(storage)\n        d.setdefault('abstract', False)\n        return type.__new__(cls, name, bases, d)\n\n\nclass EvalContext(object):\n    \"\"\"Holds evaluation time information.  Custom attributes can be attached\n    to it in extensions.\n    \"\"\"\n\n    def __init__(self, environment, template_name=None):\n        self.environment = environment\n        if callable(environment.autoescape):\n            self.autoescape = environment.autoescape(template_name)\n        else:\n            self.autoescape = environment.autoescape\n        self.volatile = False\n\n    def save(self):\n        return self.__dict__.copy()\n\n    def revert(self, old):\n        self.__dict__.clear()\n        self.__dict__.update(old)\n\n\ndef get_eval_context(node, ctx):\n    if ctx is None:\n        if node.environment is None:\n            raise RuntimeError('if no eval context is passed, the '\n                               'node must have an attached '\n                               'environment.')\n        return EvalContext(node.environment)\n    return ctx\n\n\nclass Node(with_metaclass(NodeType, object)):\n    \"\"\"Baseclass for all Jinja2 nodes.  There are a number of nodes available\n    of different types.  There are four major types:\n\n    -   :class:`Stmt`: statements\n    -   :class:`Expr`: expressions\n    -   :class:`Helper`: helper nodes\n    -   :class:`Template`: the outermost wrapper node\n\n    All nodes have fields and attributes.  Fields may be other nodes, lists,\n    or arbitrary values.  Fields are passed to the constructor as regular\n    positional arguments, attributes as keyword arguments.  Each node has\n    two attributes: `lineno` (the line number of the node) and `environment`.\n    The `environment` attribute is set at the end of the parsing process for\n    all nodes automatically.\n    \"\"\"\n    fields = ()\n    attributes = ('lineno', 'environment')\n    abstract = True\n\n    def __init__(self, *fields, **attributes):\n        if self.abstract:\n            raise TypeError('abstract nodes are not instanciable')\n        if fields:\n            if len(fields) != len(self.fields):\n                if not self.fields:\n                    raise TypeError('%r takes 0 arguments' %\n                                    self.__class__.__name__)\n                raise TypeError('%r takes 0 or %d argument%s' % (\n                    self.__class__.__name__,\n                    len(self.fields),\n                    len(self.fields) != 1 and 's' or ''\n                ))\n            for name, arg in izip(self.fields, fields):\n                setattr(self, name, arg)\n        for attr in self.attributes:\n            setattr(self, attr, attributes.pop(attr, None))\n        if attributes:\n            raise TypeError('unknown attribute %r' %\n                            next(iter(attributes)))\n\n    def iter_fields(self, exclude=None, only=None):\n        \"\"\"This method iterates over all fields that are defined and yields\n        ``(key, value)`` tuples.  Per default all fields are returned, but\n        it's possible to limit that to some fields by providing the `only`\n        parameter or to exclude some using the `exclude` parameter.  Both\n        should be sets or tuples of field names.\n        \"\"\"\n        for name in self.fields:\n            if (exclude is only is None) or \\\n               (exclude is not None and name not in exclude) or \\\n               (only is not None and name in only):\n                try:\n                    yield name, getattr(self, name)\n                except AttributeError:\n                    pass\n\n    def iter_child_nodes(self, exclude=None, only=None):\n        \"\"\"Iterates over all direct child nodes of the node.  This iterates\n        over all fields and yields the values of they are nodes.  If the value\n        of a field is a list all the nodes in that list are returned.\n        \"\"\"\n        for field, item in self.iter_fields(exclude, only):\n            if isinstance(item, list):\n                for n in item:\n                    if isinstance(n, Node):\n                        yield n\n            elif isinstance(item, Node):\n                yield item\n\n    def find(self, node_type):\n        \"\"\"Find the first node of a given type.  If no such node exists the\n        return value is `None`.\n        \"\"\"\n        for result in self.find_all(node_type):\n            return result\n\n    def find_all(self, node_type):\n        \"\"\"Find all the nodes of a given type.  If the type is a tuple,\n        the check is performed for any of the tuple items.\n        \"\"\"\n        for child in self.iter_child_nodes():\n            if isinstance(child, node_type):\n                yield child\n            for result in child.find_all(node_type):\n                yield result\n\n    def set_ctx(self, ctx):\n        \"\"\"Reset the context of a node and all child nodes.  Per default the\n        parser will all generate nodes that have a 'load' context as it's the\n        most common one.  This method is used in the parser to set assignment\n        targets and other nodes to a store context.\n        \"\"\"\n        todo = deque([self])\n        while todo:\n            node = todo.popleft()\n            if 'ctx' in node.fields:\n                node.ctx = ctx\n            todo.extend(node.iter_child_nodes())\n        return self\n\n    def set_lineno(self, lineno, override=False):\n        \"\"\"Set the line numbers of the node and children.\"\"\"\n        todo = deque([self])\n        while todo:\n            node = todo.popleft()\n            if 'lineno' in node.attributes:\n                if node.lineno is None or override:\n                    node.lineno = lineno\n            todo.extend(node.iter_child_nodes())\n        return self\n\n    def set_environment(self, environment):\n        \"\"\"Set the environment for all nodes.\"\"\"\n        todo = deque([self])\n        while todo:\n            node = todo.popleft()\n            node.environment = environment\n            todo.extend(node.iter_child_nodes())\n        return self\n\n    def __eq__(self, other):\n        return type(self) is type(other) and \\\n               tuple(self.iter_fields()) == tuple(other.iter_fields())\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    # Restore Python 2 hashing behavior on Python 3\n    __hash__ = object.__hash__\n\n    def __repr__(self):\n        return '%s(%s)' % (\n            self.__class__.__name__,\n            ', '.join('%s=%r' % (arg, getattr(self, arg, None)) for\n                      arg in self.fields)\n        )\n\n\nclass Stmt(Node):\n    \"\"\"Base node for all statements.\"\"\"\n    abstract = True\n\n\nclass Helper(Node):\n    \"\"\"Nodes that exist in a specific context only.\"\"\"\n    abstract = True\n\n\nclass Template(Node):\n    \"\"\"Node that represents a template.  This must be the outermost node that\n    is passed to the compiler.\n    \"\"\"\n    fields = ('body',)\n\n\nclass Output(Stmt):\n    \"\"\"A node that holds multiple expressions which are then printed out.\n    This is used both for the `print` statement and the regular template data.\n    \"\"\"\n    fields = ('nodes',)\n\n\nclass Extends(Stmt):\n    \"\"\"Represents an extends statement.\"\"\"\n    fields = ('template',)\n\n\nclass For(Stmt):\n    \"\"\"The for loop.  `target` is the target for the iteration (usually a\n    :class:`Name` or :class:`Tuple`), `iter` the iterable.  `body` is a list\n    of nodes that are used as loop-body, and `else_` a list of nodes for the\n    `else` block.  If no else node exists it has to be an empty list.\n\n    For filtered nodes an expression can be stored as `test`, otherwise `None`.\n    \"\"\"\n    fields = ('target', 'iter', 'body', 'else_', 'test', 'recursive')\n\n\nclass If(Stmt):\n    \"\"\"If `test` is true, `body` is rendered, else `else_`.\"\"\"\n    fields = ('test', 'body', 'else_')\n\n\nclass Macro(Stmt):\n    \"\"\"A macro definition.  `name` is the name of the macro, `args` a list of\n    arguments and `defaults` a list of defaults if there are any.  `body` is\n    a list of nodes for the macro body.\n    \"\"\"\n    fields = ('name', 'args', 'defaults', 'body')\n\n\nclass CallBlock(Stmt):\n    \"\"\"Like a macro without a name but a call instead.  `call` is called with\n    the unnamed macro as `caller` argument this node holds.\n    \"\"\"\n    fields = ('call', 'args', 'defaults', 'body')\n\n\nclass FilterBlock(Stmt):\n    \"\"\"Node for filter sections.\"\"\"\n    fields = ('body', 'filter')\n\n\nclass Block(Stmt):\n    \"\"\"A node that represents a block.\"\"\"\n    fields = ('name', 'body', 'scoped')\n\n\nclass Include(Stmt):\n    \"\"\"A node that represents the include tag.\"\"\"\n    fields = ('template', 'with_context', 'ignore_missing')\n\n\nclass Import(Stmt):\n    \"\"\"A node that represents the import tag.\"\"\"\n    fields = ('template', 'target', 'with_context')\n\n\nclass FromImport(Stmt):\n    \"\"\"A node that represents the from import tag.  It's important to not\n    pass unsafe names to the name attribute.  The compiler translates the\n    attribute lookups directly into getattr calls and does *not* use the\n    subscript callback of the interface.  As exported variables may not\n    start with double underscores (which the parser asserts) this is not a\n    problem for regular Jinja code, but if this node is used in an extension\n    extra care must be taken.\n\n    The list of names may contain tuples if aliases are wanted.\n    \"\"\"\n    fields = ('template', 'names', 'with_context')\n\n\nclass ExprStmt(Stmt):\n    \"\"\"A statement that evaluates an expression and discards the result.\"\"\"\n    fields = ('node',)\n\n\nclass Assign(Stmt):\n    \"\"\"Assigns an expression to a target.\"\"\"\n    fields = ('target', 'node')\n\n\nclass AssignBlock(Stmt):\n    \"\"\"Assigns a block to a target.\"\"\"\n    fields = ('target', 'body')\n\n\nclass Expr(Node):\n    \"\"\"Baseclass for all expressions.\"\"\"\n    abstract = True\n\n    def as_const(self, eval_ctx=None):\n        \"\"\"Return the value of the expression as constant or raise\n        :exc:`Impossible` if this was not possible.\n\n        An :class:`EvalContext` can be provided, if none is given\n        a default context is created which requires the nodes to have\n        an attached environment.\n\n        .. versionchanged:: 2.4\n           the `eval_ctx` parameter was added.\n        \"\"\"\n        raise Impossible()\n\n    def can_assign(self):\n        \"\"\"Check if it's possible to assign something to this node.\"\"\"\n        return False\n\n\nclass BinExpr(Expr):\n    \"\"\"Baseclass for all binary expressions.\"\"\"\n    fields = ('left', 'right')\n    operator = None\n    abstract = True\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        # intercepted operators cannot be folded at compile time\n        if self.environment.sandboxed and \\\n           self.operator in self.environment.intercepted_binops:\n            raise Impossible()\n        f = _binop_to_func[self.operator]\n        try:\n            return f(self.left.as_const(eval_ctx), self.right.as_const(eval_ctx))\n        except Exception:\n            raise Impossible()\n\n\nclass UnaryExpr(Expr):\n    \"\"\"Baseclass for all unary expressions.\"\"\"\n    fields = ('node',)\n    operator = None\n    abstract = True\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        # intercepted operators cannot be folded at compile time\n        if self.environment.sandboxed and \\\n           self.operator in self.environment.intercepted_unops:\n            raise Impossible()\n        f = _uaop_to_func[self.operator]\n        try:\n            return f(self.node.as_const(eval_ctx))\n        except Exception:\n            raise Impossible()\n\n\nclass Name(Expr):\n    \"\"\"Looks up a name or stores a value in a name.\n    The `ctx` of the node can be one of the following values:\n\n    -   `store`: store a value in the name\n    -   `load`: load that name\n    -   `param`: like `store` but if the name was defined as function parameter.\n    \"\"\"\n    fields = ('name', 'ctx')\n\n    def can_assign(self):\n        return self.name not in ('true', 'false', 'none',\n                                 'True', 'False', 'None')\n\n\nclass Literal(Expr):\n    \"\"\"Baseclass for literals.\"\"\"\n    abstract = True\n\n\nclass Const(Literal):\n    \"\"\"All constant values.  The parser will return this node for simple\n    constants such as ``42`` or ``\"foo\"`` but it can be used to store more\n    complex values such as lists too.  Only constants with a safe\n    representation (objects where ``eval(repr(x)) == x`` is true).\n    \"\"\"\n    fields = ('value',)\n\n    def as_const(self, eval_ctx=None):\n        return self.value\n\n    @classmethod\n    def from_untrusted(cls, value, lineno=None, environment=None):\n        \"\"\"Return a const object if the value is representable as\n        constant value in the generated code, otherwise it will raise\n        an `Impossible` exception.\n        \"\"\"\n        from .compiler import has_safe_repr\n        if not has_safe_repr(value):\n            raise Impossible()\n        return cls(value, lineno=lineno, environment=environment)\n\n\nclass TemplateData(Literal):\n    \"\"\"A constant template string.\"\"\"\n    fields = ('data',)\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if eval_ctx.volatile:\n            raise Impossible()\n        if eval_ctx.autoescape:\n            return Markup(self.data)\n        return self.data\n\n\nclass Tuple(Literal):\n    \"\"\"For loop unpacking and some other things like multiple arguments\n    for subscripts.  Like for :class:`Name` `ctx` specifies if the tuple\n    is used for loading the names or storing.\n    \"\"\"\n    fields = ('items', 'ctx')\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return tuple(x.as_const(eval_ctx) for x in self.items)\n\n    def can_assign(self):\n        for item in self.items:\n            if not item.can_assign():\n                return False\n        return True\n\n\nclass List(Literal):\n    \"\"\"Any list literal such as ``[1, 2, 3]``\"\"\"\n    fields = ('items',)\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return [x.as_const(eval_ctx) for x in self.items]\n\n\nclass Dict(Literal):\n    \"\"\"Any dict literal such as ``{1: 2, 3: 4}``.  The items must be a list of\n    :class:`Pair` nodes.\n    \"\"\"\n    fields = ('items',)\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return dict(x.as_const(eval_ctx) for x in self.items)\n\n\nclass Pair(Helper):\n    \"\"\"A key, value pair for dicts.\"\"\"\n    fields = ('key', 'value')\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return self.key.as_const(eval_ctx), self.value.as_const(eval_ctx)\n\n\nclass Keyword(Helper):\n    \"\"\"A key, value pair for keyword arguments where key is a string.\"\"\"\n    fields = ('key', 'value')\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return self.key, self.value.as_const(eval_ctx)\n\n\nclass CondExpr(Expr):\n    \"\"\"A conditional expression (inline if expression).  (``{{\n    foo if bar else baz }}``)\n    \"\"\"\n    fields = ('test', 'expr1', 'expr2')\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if self.test.as_const(eval_ctx):\n            return self.expr1.as_const(eval_ctx)\n\n        # if we evaluate to an undefined object, we better do that at runtime\n        if self.expr2 is None:\n            raise Impossible()\n\n        return self.expr2.as_const(eval_ctx)\n\n\nclass Filter(Expr):\n    \"\"\"This node applies a filter on an expression.  `name` is the name of\n    the filter, the rest of the fields are the same as for :class:`Call`.\n\n    If the `node` of a filter is `None` the contents of the last buffer are\n    filtered.  Buffers are created by macros and filter blocks.\n    \"\"\"\n    fields = ('node', 'name', 'args', 'kwargs', 'dyn_args', 'dyn_kwargs')\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if eval_ctx.volatile or self.node is None:\n            raise Impossible()\n        # we have to be careful here because we call filter_ below.\n        # if this variable would be called filter, 2to3 would wrap the\n        # call in a list beause it is assuming we are talking about the\n        # builtin filter function here which no longer returns a list in\n        # python 3.  because of that, do not rename filter_ to filter!\n        filter_ = self.environment.filters.get(self.name)\n        if filter_ is None or getattr(filter_, 'contextfilter', False):\n            raise Impossible()\n        obj = self.node.as_const(eval_ctx)\n        args = [x.as_const(eval_ctx) for x in self.args]\n        if getattr(filter_, 'evalcontextfilter', False):\n            args.insert(0, eval_ctx)\n        elif getattr(filter_, 'environmentfilter', False):\n            args.insert(0, self.environment)\n        kwargs = dict(x.as_const(eval_ctx) for x in self.kwargs)\n        if self.dyn_args is not None:\n            try:\n                args.extend(self.dyn_args.as_const(eval_ctx))\n            except Exception:\n                raise Impossible()\n        if self.dyn_kwargs is not None:\n            try:\n                kwargs.update(self.dyn_kwargs.as_const(eval_ctx))\n            except Exception:\n                raise Impossible()\n        try:\n            return filter_(obj, *args, **kwargs)\n        except Exception:\n            raise Impossible()\n\n\nclass Test(Expr):\n    \"\"\"Applies a test on an expression.  `name` is the name of the test, the\n    rest of the fields are the same as for :class:`Call`.\n    \"\"\"\n    fields = ('node', 'name', 'args', 'kwargs', 'dyn_args', 'dyn_kwargs')\n\n\nclass Call(Expr):\n    \"\"\"Calls an expression.  `args` is a list of arguments, `kwargs` a list\n    of keyword arguments (list of :class:`Keyword` nodes), and `dyn_args`\n    and `dyn_kwargs` has to be either `None` or a node that is used as\n    node for dynamic positional (``*args``) or keyword (``**kwargs``)\n    arguments.\n    \"\"\"\n    fields = ('node', 'args', 'kwargs', 'dyn_args', 'dyn_kwargs')\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if eval_ctx.volatile or eval_ctx.environment.sandboxed:\n            raise Impossible()\n        obj = self.node.as_const(eval_ctx)\n\n        # don't evaluate context functions\n        args = [x.as_const(eval_ctx) for x in self.args]\n        if isinstance(obj, _context_function_types):\n            if getattr(obj, 'contextfunction', False):\n                raise Impossible()\n            elif getattr(obj, 'evalcontextfunction', False):\n                args.insert(0, eval_ctx)\n            elif getattr(obj, 'environmentfunction', False):\n                args.insert(0, self.environment)\n\n        kwargs = dict(x.as_const(eval_ctx) for x in self.kwargs)\n        if self.dyn_args is not None:\n            try:\n                args.extend(self.dyn_args.as_const(eval_ctx))\n            except Exception:\n                raise Impossible()\n        if self.dyn_kwargs is not None:\n            try:\n                kwargs.update(self.dyn_kwargs.as_const(eval_ctx))\n            except Exception:\n                raise Impossible()\n        try:\n            return obj(*args, **kwargs)\n        except Exception:\n            raise Impossible()\n\n\nclass Getitem(Expr):\n    \"\"\"Get an attribute or item from an expression and prefer the item.\"\"\"\n    fields = ('node', 'arg', 'ctx')\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if self.ctx != 'load':\n            raise Impossible()\n        try:\n            return self.environment.getitem(self.node.as_const(eval_ctx),\n                                            self.arg.as_const(eval_ctx))\n        except Exception:\n            raise Impossible()\n\n    def can_assign(self):\n        return False\n\n\nclass Getattr(Expr):\n    \"\"\"Get an attribute or item from an expression that is a ascii-only\n    bytestring and prefer the attribute.\n    \"\"\"\n    fields = ('node', 'attr', 'ctx')\n\n    def as_const(self, eval_ctx=None):\n        if self.ctx != 'load':\n            raise Impossible()\n        try:\n            eval_ctx = get_eval_context(self, eval_ctx)\n            return self.environment.getattr(self.node.as_const(eval_ctx),\n                                            self.attr)\n        except Exception:\n            raise Impossible()\n\n    def can_assign(self):\n        return False\n\n\nclass Slice(Expr):\n    \"\"\"Represents a slice object.  This must only be used as argument for\n    :class:`Subscript`.\n    \"\"\"\n    fields = ('start', 'stop', 'step')\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        def const(obj):\n            if obj is None:\n                return None\n            return obj.as_const(eval_ctx)\n        return slice(const(self.start), const(self.stop), const(self.step))\n\n\nclass Concat(Expr):\n    \"\"\"Concatenates the list of expressions provided after converting them to\n    unicode.\n    \"\"\"\n    fields = ('nodes',)\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return ''.join(text_type(x.as_const(eval_ctx)) for x in self.nodes)\n\n\nclass Compare(Expr):\n    \"\"\"Compares an expression with some other expressions.  `ops` must be a\n    list of :class:`Operand`\\s.\n    \"\"\"\n    fields = ('expr', 'ops')\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        result = value = self.expr.as_const(eval_ctx)\n        try:\n            for op in self.ops:\n                new_value = op.expr.as_const(eval_ctx)\n                result = _cmpop_to_func[op.op](value, new_value)\n                value = new_value\n        except Exception:\n            raise Impossible()\n        return result\n\n\nclass Operand(Helper):\n    \"\"\"Holds an operator and an expression.\"\"\"\n    fields = ('op', 'expr')\n\nif __debug__:\n    Operand.__doc__ += '\\nThe following operators are available: ' + \\\n        ', '.join(sorted('``%s``' % x for x in set(_binop_to_func) |\n                  set(_uaop_to_func) | set(_cmpop_to_func)))\n\n\nclass Mul(BinExpr):\n    \"\"\"Multiplies the left with the right node.\"\"\"\n    operator = '*'\n\n\nclass Div(BinExpr):\n    \"\"\"Divides the left by the right node.\"\"\"\n    operator = '/'\n\n\nclass FloorDiv(BinExpr):\n    \"\"\"Divides the left by the right node and truncates conver the\n    result into an integer by truncating.\n    \"\"\"\n    operator = '//'\n\n\nclass Add(BinExpr):\n    \"\"\"Add the left to the right node.\"\"\"\n    operator = '+'\n\n\nclass Sub(BinExpr):\n    \"\"\"Subtract the right from the left node.\"\"\"\n    operator = '-'\n\n\nclass Mod(BinExpr):\n    \"\"\"Left modulo right.\"\"\"\n    operator = '%'\n\n\nclass Pow(BinExpr):\n    \"\"\"Left to the power of right.\"\"\"\n    operator = '**'\n\n\nclass And(BinExpr):\n    \"\"\"Short circuited AND.\"\"\"\n    operator = 'and'\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return self.left.as_const(eval_ctx) and self.right.as_const(eval_ctx)\n\n\nclass Or(BinExpr):\n    \"\"\"Short circuited OR.\"\"\"\n    operator = 'or'\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return self.left.as_const(eval_ctx) or self.right.as_const(eval_ctx)\n\n\nclass Not(UnaryExpr):\n    \"\"\"Negate the expression.\"\"\"\n    operator = 'not'\n\n\nclass Neg(UnaryExpr):\n    \"\"\"Make the expression negative.\"\"\"\n    operator = '-'\n\n\nclass Pos(UnaryExpr):\n    \"\"\"Make the expression positive (noop for most expressions)\"\"\"\n    operator = '+'\n\n\n# Helpers for extensions\n\n\nclass EnvironmentAttribute(Expr):\n    \"\"\"Loads an attribute from the environment object.  This is useful for\n    extensions that want to call a callback stored on the environment.\n    \"\"\"\n    fields = ('name',)\n\n\nclass ExtensionAttribute(Expr):\n    \"\"\"Returns the attribute of an extension bound to the environment.\n    The identifier is the identifier of the :class:`Extension`.\n\n    This node is usually constructed by calling the\n    :meth:`~jinja2.ext.Extension.attr` method on an extension.\n    \"\"\"\n    fields = ('identifier', 'name')\n\n\nclass ImportedName(Expr):\n    \"\"\"If created with an import name the import name is returned on node\n    access.  For example ``ImportedName('cgi.escape')`` returns the `escape`\n    function from the cgi module on evaluation.  Imports are optimized by the\n    compiler so there is no need to assign them to local variables.\n    \"\"\"\n    fields = ('importname',)\n\n\nclass InternalName(Expr):\n    \"\"\"An internal name in the compiler.  You cannot create these nodes\n    yourself but the parser provides a\n    :meth:`~jinja2.parser.Parser.free_identifier` method that creates\n    a new identifier for you.  This identifier is not available from the\n    template and is not threated specially by the compiler.\n    \"\"\"\n    fields = ('name',)\n\n    def __init__(self):\n        raise TypeError('Can\\'t create internal names.  Use the '\n                        '`free_identifier` method on a parser.')\n\n\nclass MarkSafe(Expr):\n    \"\"\"Mark the wrapped expression as safe (wrap it as `Markup`).\"\"\"\n    fields = ('expr',)\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return Markup(self.expr.as_const(eval_ctx))\n\n\nclass MarkSafeIfAutoescape(Expr):\n    \"\"\"Mark the wrapped expression as safe (wrap it as `Markup`) but\n    only if autoescaping is active.\n\n    .. versionadded:: 2.5\n    \"\"\"\n    fields = ('expr',)\n\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if eval_ctx.volatile:\n            raise Impossible()\n        expr = self.expr.as_const(eval_ctx)\n        if eval_ctx.autoescape:\n            return Markup(expr)\n        return expr\n\n\nclass ContextReference(Expr):\n    \"\"\"Returns the current template context.  It can be used like a\n    :class:`Name` node, with a ``'load'`` ctx and will return the\n    current :class:`~jinja2.runtime.Context` object.\n\n    Here an example that assigns the current template name to a\n    variable named `foo`::\n\n        Assign(Name('foo', ctx='store'),\n               Getattr(ContextReference(), 'name'))\n    \"\"\"\n\n\nclass Continue(Stmt):\n    \"\"\"Continue a loop.\"\"\"\n\n\nclass Break(Stmt):\n    \"\"\"Break a loop.\"\"\"\n\n\nclass Scope(Stmt):\n    \"\"\"An artificial scope.\"\"\"\n    fields = ('body',)\n\n\nclass EvalContextModifier(Stmt):\n    \"\"\"Modifies the eval context.  For each option that should be modified,\n    a :class:`Keyword` has to be added to the :attr:`options` list.\n\n    Example to change the `autoescape` setting::\n\n        EvalContextModifier(options=[Keyword('autoescape', Const(True))])\n    \"\"\"\n    fields = ('options',)\n\n\nclass ScopedEvalContextModifier(EvalContextModifier):\n    \"\"\"Modifies the eval context and reverts it later.  Works exactly like\n    :class:`EvalContextModifier` but will only modify the\n    :class:`~jinja2.nodes.EvalContext` for nodes in the :attr:`body`.\n    \"\"\"\n    fields = ('body',)\n\n\n# make sure nobody creates custom nodes\ndef _failing_new(*args, **kwargs):\n    raise TypeError('can\\'t create custom node types')\nNodeType.__new__ = staticmethod(_failing_new); del _failing_new\n", "# -*- coding: utf-8 -*-\n\"\"\"\n    jinja2.sandbox\n    ~~~~~~~~~~~~~~\n\n    Adds a sandbox layer to Jinja as it was the default behavior in the old\n    Jinja 1 releases.  This sandbox is slightly different from Jinja 1 as the\n    default behavior is easier to use.\n\n    The behavior can be changed by subclassing the environment.\n\n    :copyright: (c) 2010 by the Jinja Team.\n    :license: BSD.\n\"\"\"\nimport types\nimport operator\nfrom collections import Mapping\nfrom jinja2.environment import Environment\nfrom jinja2.exceptions import SecurityError\nfrom jinja2._compat import string_types, text_type, PY2\nfrom jinja2.utils import Markup\n\nhas_format = False\nif hasattr(text_type, 'format'):\n    from markupsafe import EscapeFormatter\n    from string import Formatter\n    has_format = True\n\n\n#: maximum number of items a range may produce\nMAX_RANGE = 100000\n\n#: attributes of function objects that are considered unsafe.\nif PY2:\n    UNSAFE_FUNCTION_ATTRIBUTES = set(['func_closure', 'func_code', 'func_dict',\n                                      'func_defaults', 'func_globals'])\nelse:\n    # On versions > python 2 the special attributes on functions are gone,\n    # but they remain on methods and generators for whatever reason.\n    UNSAFE_FUNCTION_ATTRIBUTES = set()\n\n\n#: unsafe method attributes.  function attributes are unsafe for methods too\nUNSAFE_METHOD_ATTRIBUTES = set(['im_class', 'im_func', 'im_self'])\n\n#: unsafe generator attirbutes.\nUNSAFE_GENERATOR_ATTRIBUTES = set(['gi_frame', 'gi_code'])\n\n#: unsafe attributes on coroutines\nUNSAFE_COROUTINE_ATTRIBUTES = set(['cr_frame', 'cr_code'])\n\n#: unsafe attributes on async generators\nUNSAFE_ASYNC_GENERATOR_ATTRIBUTES = set(['ag_code', 'ag_frame'])\n\nimport warnings\n\n# make sure we don't warn in python 2.6 about stuff we don't care about\nwarnings.filterwarnings('ignore', 'the sets module', DeprecationWarning,\n                        module='jinja2.sandbox')\n\nfrom collections import deque\n\n_mutable_set_types = (set,)\n_mutable_mapping_types = (dict,)\n_mutable_sequence_types = (list,)\n\n\n# on python 2.x we can register the user collection types\ntry:\n    from UserDict import UserDict, DictMixin\n    from UserList import UserList\n    _mutable_mapping_types += (UserDict, DictMixin)\n    _mutable_set_types += (UserList,)\nexcept ImportError:\n    pass\n\n# if sets is still available, register the mutable set from there as well\ntry:\n    from sets import Set\n    _mutable_set_types += (Set,)\nexcept ImportError:\n    pass\n\n#: register Python 2.6 abstract base classes\ntry:\n    from collections import MutableSet, MutableMapping, MutableSequence\n    _mutable_set_types += (MutableSet,)\n    _mutable_mapping_types += (MutableMapping,)\n    _mutable_sequence_types += (MutableSequence,)\nexcept ImportError:\n    pass\n\n_mutable_spec = (\n    (_mutable_set_types, frozenset([\n        'add', 'clear', 'difference_update', 'discard', 'pop', 'remove',\n        'symmetric_difference_update', 'update'\n    ])),\n    (_mutable_mapping_types, frozenset([\n        'clear', 'pop', 'popitem', 'setdefault', 'update'\n    ])),\n    (_mutable_sequence_types, frozenset([\n        'append', 'reverse', 'insert', 'sort', 'extend', 'remove'\n    ])),\n    (deque, frozenset([\n        'append', 'appendleft', 'clear', 'extend', 'extendleft', 'pop',\n        'popleft', 'remove', 'rotate'\n    ]))\n)\n\n\nclass _MagicFormatMapping(Mapping):\n    \"\"\"This class implements a dummy wrapper to fix a bug in the Python\n    standard library for string formatting.\n\n    See http://bugs.python.org/issue13598 for information about why\n    this is necessary.\n    \"\"\"\n\n    def __init__(self, args, kwargs):\n        self._args = args\n        self._kwargs = kwargs\n        self._last_index = 0\n\n    def __getitem__(self, key):\n        if key == '':\n            idx = self._last_index\n            self._last_index += 1\n            try:\n                return self._args[idx]\n            except LookupError:\n                pass\n            key = str(idx)\n        return self._kwargs[key]\n\n    def __iter__(self):\n        return iter(self._kwargs)\n\n    def __len__(self):\n        return len(self._kwargs)\n\n\ndef inspect_format_method(callable):\n    if not has_format:\n        return None\n    if not isinstance(callable, (types.MethodType,\n                                 types.BuiltinMethodType)) or \\\n       callable.__name__ != 'format':\n        return None\n    obj = callable.__self__\n    if isinstance(obj, string_types):\n        return obj\n\n\ndef safe_range(*args):\n    \"\"\"A range that can't generate ranges with a length of more than\n    MAX_RANGE items.\n    \"\"\"\n    rng = range(*args)\n    if len(rng) > MAX_RANGE:\n        raise OverflowError('range too big, maximum size for range is %d' %\n                            MAX_RANGE)\n    return rng\n\n\ndef unsafe(f):\n    \"\"\"Marks a function or method as unsafe.\n\n    ::\n\n        @unsafe\n        def delete(self):\n            pass\n    \"\"\"\n    f.unsafe_callable = True\n    return f\n\n\ndef is_internal_attribute(obj, attr):\n    \"\"\"Test if the attribute given is an internal python attribute.  For\n    example this function returns `True` for the `func_code` attribute of\n    python objects.  This is useful if the environment method\n    :meth:`~SandboxedEnvironment.is_safe_attribute` is overridden.\n\n    >>> from jinja2.sandbox import is_internal_attribute\n    >>> is_internal_attribute(str, \"mro\")\n    True\n    >>> is_internal_attribute(str, \"upper\")\n    False\n    \"\"\"\n    if isinstance(obj, types.FunctionType):\n        if attr in UNSAFE_FUNCTION_ATTRIBUTES:\n            return True\n    elif isinstance(obj, types.MethodType):\n        if attr in UNSAFE_FUNCTION_ATTRIBUTES or \\\n           attr in UNSAFE_METHOD_ATTRIBUTES:\n            return True\n    elif isinstance(obj, type):\n        if attr == 'mro':\n            return True\n    elif isinstance(obj, (types.CodeType, types.TracebackType, types.FrameType)):\n        return True\n    elif isinstance(obj, types.GeneratorType):\n        if attr in UNSAFE_GENERATOR_ATTRIBUTES:\n            return True\n    elif hasattr(types, 'CoroutineType') and isinstance(obj, types.CoroutineType):\n        if attr in UNSAFE_COROUTINE_ATTRIBUTES:\n            return True\n    elif hasattr(types, 'AsyncGeneratorType') and isinstance(obj, types.AsyncGeneratorType):\n        if attri in UNSAFE_ASYNC_GENERATOR_ATTRIBUTES:\n            return True\n    return attr.startswith('__')\n\n\ndef modifies_known_mutable(obj, attr):\n    \"\"\"This function checks if an attribute on a builtin mutable object\n    (list, dict, set or deque) would modify it if called.  It also supports\n    the \"user\"-versions of the objects (`sets.Set`, `UserDict.*` etc.) and\n    with Python 2.6 onwards the abstract base classes `MutableSet`,\n    `MutableMapping`, and `MutableSequence`.\n\n    >>> modifies_known_mutable({}, \"clear\")\n    True\n    >>> modifies_known_mutable({}, \"keys\")\n    False\n    >>> modifies_known_mutable([], \"append\")\n    True\n    >>> modifies_known_mutable([], \"index\")\n    False\n\n    If called with an unsupported object (such as unicode) `False` is\n    returned.\n\n    >>> modifies_known_mutable(\"foo\", \"upper\")\n    False\n    \"\"\"\n    for typespec, unsafe in _mutable_spec:\n        if isinstance(obj, typespec):\n            return attr in unsafe\n    return False\n\n\nclass SandboxedEnvironment(Environment):\n    \"\"\"The sandboxed environment.  It works like the regular environment but\n    tells the compiler to generate sandboxed code.  Additionally subclasses of\n    this environment may override the methods that tell the runtime what\n    attributes or functions are safe to access.\n\n    If the template tries to access insecure code a :exc:`SecurityError` is\n    raised.  However also other exceptions may occur during the rendering so\n    the caller has to ensure that all exceptions are caught.\n    \"\"\"\n    sandboxed = True\n\n    #: default callback table for the binary operators.  A copy of this is\n    #: available on each instance of a sandboxed environment as\n    #: :attr:`binop_table`\n    default_binop_table = {\n        '+':        operator.add,\n        '-':        operator.sub,\n        '*':        operator.mul,\n        '/':        operator.truediv,\n        '//':       operator.floordiv,\n        '**':       operator.pow,\n        '%':        operator.mod\n    }\n\n    #: default callback table for the unary operators.  A copy of this is\n    #: available on each instance of a sandboxed environment as\n    #: :attr:`unop_table`\n    default_unop_table = {\n        '+':        operator.pos,\n        '-':        operator.neg\n    }\n\n    #: a set of binary operators that should be intercepted.  Each operator\n    #: that is added to this set (empty by default) is delegated to the\n    #: :meth:`call_binop` method that will perform the operator.  The default\n    #: operator callback is specified by :attr:`binop_table`.\n    #:\n    #: The following binary operators are interceptable:\n    #: ``//``, ``%``, ``+``, ``*``, ``-``, ``/``, and ``**``\n    #:\n    #: The default operation form the operator table corresponds to the\n    #: builtin function.  Intercepted calls are always slower than the native\n    #: operator call, so make sure only to intercept the ones you are\n    #: interested in.\n    #:\n    #: .. versionadded:: 2.6\n    intercepted_binops = frozenset()\n\n    #: a set of unary operators that should be intercepted.  Each operator\n    #: that is added to this set (empty by default) is delegated to the\n    #: :meth:`call_unop` method that will perform the operator.  The default\n    #: operator callback is specified by :attr:`unop_table`.\n    #:\n    #: The following unary operators are interceptable: ``+``, ``-``\n    #:\n    #: The default operation form the operator table corresponds to the\n    #: builtin function.  Intercepted calls are always slower than the native\n    #: operator call, so make sure only to intercept the ones you are\n    #: interested in.\n    #:\n    #: .. versionadded:: 2.6\n    intercepted_unops = frozenset()\n\n    def intercept_unop(self, operator):\n        \"\"\"Called during template compilation with the name of a unary\n        operator to check if it should be intercepted at runtime.  If this\n        method returns `True`, :meth:`call_unop` is excuted for this unary\n        operator.  The default implementation of :meth:`call_unop` will use\n        the :attr:`unop_table` dictionary to perform the operator with the\n        same logic as the builtin one.\n\n        The following unary operators are interceptable: ``+`` and ``-``\n\n        Intercepted calls are always slower than the native operator call,\n        so make sure only to intercept the ones you are interested in.\n\n        .. versionadded:: 2.6\n        \"\"\"\n        return False\n\n\n    def __init__(self, *args, **kwargs):\n        Environment.__init__(self, *args, **kwargs)\n        self.globals['range'] = safe_range\n        self.binop_table = self.default_binop_table.copy()\n        self.unop_table = self.default_unop_table.copy()\n\n    def is_safe_attribute(self, obj, attr, value):\n        \"\"\"The sandboxed environment will call this method to check if the\n        attribute of an object is safe to access.  Per default all attributes\n        starting with an underscore are considered private as well as the\n        special attributes of internal python objects as returned by the\n        :func:`is_internal_attribute` function.\n        \"\"\"\n        return not (attr.startswith('_') or is_internal_attribute(obj, attr))\n\n    def is_safe_callable(self, obj):\n        \"\"\"Check if an object is safely callable.  Per default a function is\n        considered safe unless the `unsafe_callable` attribute exists and is\n        True.  Override this method to alter the behavior, but this won't\n        affect the `unsafe` decorator from this module.\n        \"\"\"\n        return not (getattr(obj, 'unsafe_callable', False) or\n                    getattr(obj, 'alters_data', False))\n\n    def call_binop(self, context, operator, left, right):\n        \"\"\"For intercepted binary operator calls (:meth:`intercepted_binops`)\n        this function is executed instead of the builtin operator.  This can\n        be used to fine tune the behavior of certain operators.\n\n        .. versionadded:: 2.6\n        \"\"\"\n        return self.binop_table[operator](left, right)\n\n    def call_unop(self, context, operator, arg):\n        \"\"\"For intercepted unary operator calls (:meth:`intercepted_unops`)\n        this function is executed instead of the builtin operator.  This can\n        be used to fine tune the behavior of certain operators.\n\n        .. versionadded:: 2.6\n        \"\"\"\n        return self.unop_table[operator](arg)\n\n    def getitem(self, obj, argument):\n        \"\"\"Subscribe an object from sandboxed code.\"\"\"\n        try:\n            return obj[argument]\n        except (TypeError, LookupError):\n            if isinstance(argument, string_types):\n                try:\n                    attr = str(argument)\n                except Exception:\n                    pass\n                else:\n                    try:\n                        value = getattr(obj, attr)\n                    except AttributeError:\n                        pass\n                    else:\n                        if self.is_safe_attribute(obj, argument, value):\n                            return value\n                        return self.unsafe_undefined(obj, argument)\n        return self.undefined(obj=obj, name=argument)\n\n    def getattr(self, obj, attribute):\n        \"\"\"Subscribe an object from sandboxed code and prefer the\n        attribute.  The attribute passed *must* be a bytestring.\n        \"\"\"\n        try:\n            value = getattr(obj, attribute)\n        except AttributeError:\n            try:\n                return obj[attribute]\n            except (TypeError, LookupError):\n                pass\n        else:\n            if self.is_safe_attribute(obj, attribute, value):\n                return value\n            return self.unsafe_undefined(obj, attribute)\n        return self.undefined(obj=obj, name=attribute)\n\n    def unsafe_undefined(self, obj, attribute):\n        \"\"\"Return an undefined object for unsafe attributes.\"\"\"\n        return self.undefined('access to attribute %r of %r '\n                              'object is unsafe.' % (\n            attribute,\n            obj.__class__.__name__\n        ), name=attribute, obj=obj, exc=SecurityError)\n\n    def format_string(self, s, args, kwargs):\n        \"\"\"If a format call is detected, then this is routed through this\n        method so that our safety sandbox can be used for it.\n        \"\"\"\n        if isinstance(s, Markup):\n            formatter = SandboxedEscapeFormatter(self, s.escape)\n        else:\n            formatter = SandboxedFormatter(self)\n        kwargs = _MagicFormatMapping(args, kwargs)\n        rv = formatter.vformat(s, args, kwargs)\n        return type(s)(rv)\n\n    def call(__self, __context, __obj, *args, **kwargs):\n        \"\"\"Call an object from sandboxed code.\"\"\"\n        fmt = inspect_format_method(__obj)\n        if fmt is not None:\n            return __self.format_string(fmt, args, kwargs)\n\n        # the double prefixes are to avoid double keyword argument\n        # errors when proxying the call.\n        if not __self.is_safe_callable(__obj):\n            raise SecurityError('%r is not safely callable' % (__obj,))\n        return __context.call(__obj, *args, **kwargs)\n\n\nclass ImmutableSandboxedEnvironment(SandboxedEnvironment):\n    \"\"\"Works exactly like the regular `SandboxedEnvironment` but does not\n    permit modifications on the builtin mutable objects `list`, `set`, and\n    `dict` by using the :func:`modifies_known_mutable` function.\n    \"\"\"\n\n    def is_safe_attribute(self, obj, attr, value):\n        if not SandboxedEnvironment.is_safe_attribute(self, obj, attr, value):\n            return False\n        return not modifies_known_mutable(obj, attr)\n\n\nif has_format:\n    # This really is not a public API apparenlty.\n    try:\n        from _string import formatter_field_name_split\n    except ImportError:\n        def formatter_field_name_split(field_name):\n            return field_name._formatter_field_name_split()\n\n    class SandboxedFormatterMixin(object):\n\n        def __init__(self, env):\n            self._env = env\n\n        def get_field(self, field_name, args, kwargs):\n            first, rest = formatter_field_name_split(field_name)\n            obj = self.get_value(first, args, kwargs)\n            for is_attr, i in rest:\n                if is_attr:\n                    obj = self._env.getattr(obj, i)\n                else:\n                    obj = self._env.getitem(obj, i)\n            return obj, first\n\n    class SandboxedFormatter(SandboxedFormatterMixin, Formatter):\n        def __init__(self, env):\n            SandboxedFormatterMixin.__init__(self, env)\n            Formatter.__init__(self)\n\n    class SandboxedEscapeFormatter(SandboxedFormatterMixin, EscapeFormatter):\n        def __init__(self, env, escape):\n            SandboxedFormatterMixin.__init__(self, env)\n            EscapeFormatter.__init__(self, escape)\n", "# -*- coding: utf-8 -*-\n\"\"\"\n    jinja2.testsuite.security\n    ~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Checks the sandbox and other security features.\n\n    :copyright: (c) 2010 by the Jinja Team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nimport pytest\n\nfrom jinja2 import Environment\nfrom jinja2.sandbox import SandboxedEnvironment, \\\n     ImmutableSandboxedEnvironment, unsafe, has_format\nfrom jinja2 import Markup, escape\nfrom jinja2.exceptions import SecurityError, TemplateSyntaxError, \\\n     TemplateRuntimeError\nfrom jinja2._compat import text_type\n\n\nclass PrivateStuff(object):\n\n    def bar(self):\n        return 23\n\n    @unsafe\n    def foo(self):\n        return 42\n\n    def __repr__(self):\n        return 'PrivateStuff'\n\n\nclass PublicStuff(object):\n    bar = lambda self: 23\n    _foo = lambda self: 42\n\n    def __repr__(self):\n        return 'PublicStuff'\n\n\n@pytest.mark.sandbox\nclass TestSandbox():\n\n    def test_unsafe(self, env):\n        env = SandboxedEnvironment()\n        pytest.raises(SecurityError, env.from_string(\"{{ foo.foo() }}\").render,\n                      foo=PrivateStuff())\n        assert env.from_string(\"{{ foo.bar() }}\").render(foo=PrivateStuff()) == '23'\n\n        pytest.raises(SecurityError,\n                      env.from_string(\"{{ foo._foo() }}\").render,\n                      foo=PublicStuff())\n        assert env.from_string(\"{{ foo.bar() }}\").render(foo=PublicStuff()) == '23'\n        assert env.from_string(\"{{ foo.__class__ }}\").render(foo=42) == ''\n        assert env.from_string(\"{{ foo.func_code }}\").render(foo=lambda:None) == ''\n        # security error comes from __class__ already.\n        pytest.raises(SecurityError, env.from_string(\n            \"{{ foo.__class__.__subclasses__() }}\").render, foo=42)\n\n    def test_immutable_environment(self, env):\n        env = ImmutableSandboxedEnvironment()\n        pytest.raises(SecurityError, env.from_string(\n            '{{ [].append(23) }}').render)\n        pytest.raises(SecurityError, env.from_string(\n            '{{ {1:2}.clear() }}').render)\n\n    def test_restricted(self, env):\n        env = SandboxedEnvironment()\n        pytest.raises(TemplateSyntaxError, env.from_string,\n                      \"{% for item.attribute in seq %}...{% endfor %}\")\n        pytest.raises(TemplateSyntaxError, env.from_string,\n                      \"{% for foo, bar.baz in seq %}...{% endfor %}\")\n\n    def test_markup_operations(self, env):\n        # adding two strings should escape the unsafe one\n        unsafe = '<script type=\"application/x-some-script\">alert(\"foo\");</script>'\n        safe = Markup('<em>username</em>')\n        assert unsafe + safe == text_type(escape(unsafe)) + text_type(safe)\n\n        # string interpolations are safe to use too\n        assert Markup('<em>%s</em>') % '<bad user>' == \\\n            '<em>&lt;bad user&gt;</em>'\n        assert Markup('<em>%(username)s</em>') % {\n            'username': '<bad user>'\n        } == '<em>&lt;bad user&gt;</em>'\n\n        # an escaped object is markup too\n        assert type(Markup('foo') + 'bar') is Markup\n\n        # and it implements __html__ by returning itself\n        x = Markup(\"foo\")\n        assert x.__html__() is x\n\n        # it also knows how to treat __html__ objects\n        class Foo(object):\n            def __html__(self):\n                return '<em>awesome</em>'\n\n            def __unicode__(self):\n                return 'awesome'\n        assert Markup(Foo()) == '<em>awesome</em>'\n        assert Markup('<strong>%s</strong>') % Foo() == \\\n            '<strong><em>awesome</em></strong>'\n\n        # escaping and unescaping\n        assert escape('\"<>&\\'') == '&#34;&lt;&gt;&amp;&#39;'\n        assert Markup(\"<em>Foo &amp; Bar</em>\").striptags() == \"Foo & Bar\"\n        assert Markup(\"&lt;test&gt;\").unescape() == \"<test>\"\n\n    def test_template_data(self, env):\n        env = Environment(autoescape=True)\n        t = env.from_string('{% macro say_hello(name) %}'\n                            '<p>Hello {{ name }}!</p>{% endmacro %}'\n                            '{{ say_hello(\"<blink>foo</blink>\") }}')\n        escaped_out = '<p>Hello &lt;blink&gt;foo&lt;/blink&gt;!</p>'\n        assert t.render() == escaped_out\n        assert text_type(t.module) == escaped_out\n        assert escape(t.module) == escaped_out\n        assert t.module.say_hello('<blink>foo</blink>') == escaped_out\n        assert escape(t.module.say_hello('<blink>foo</blink>')) == escaped_out\n\n    def test_attr_filter(self, env):\n        env = SandboxedEnvironment()\n        tmpl = env.from_string('{{ cls|attr(\"__subclasses__\")() }}')\n        pytest.raises(SecurityError, tmpl.render, cls=int)\n\n    def test_binary_operator_intercepting(self, env):\n        def disable_op(left, right):\n            raise TemplateRuntimeError('that operator so does not work')\n        for expr, ctx, rv in ('1 + 2', {}, '3'), ('a + 2', {'a': 2}, '4'):\n            env = SandboxedEnvironment()\n            env.binop_table['+'] = disable_op\n            t = env.from_string('{{ %s }}' % expr)\n            assert t.render(ctx) == rv\n            env.intercepted_binops = frozenset(['+'])\n            t = env.from_string('{{ %s }}' % expr)\n            try:\n                t.render(ctx)\n            except TemplateRuntimeError as e:\n                pass\n            else:\n                assert False, 'expected runtime error'\n\n    def test_unary_operator_intercepting(self, env):\n        def disable_op(arg):\n            raise TemplateRuntimeError('that operator so does not work')\n        for expr, ctx, rv in ('-1', {}, '-1'), ('-a', {'a': 2}, '-2'):\n            env = SandboxedEnvironment()\n            env.unop_table['-'] = disable_op\n            t = env.from_string('{{ %s }}' % expr)\n            assert t.render(ctx) == rv\n            env.intercepted_unops = frozenset(['-'])\n            t = env.from_string('{{ %s }}' % expr)\n            try:\n                t.render(ctx)\n            except TemplateRuntimeError as e:\n                pass\n            else:\n                assert False, 'expected runtime error'\n\n\n@pytest.mark.sandbox\n@pytest.mark.skipif(not has_format, reason='No format support')\nclass TestStringFormat(object):\n\n    def test_basic_format_safety(self):\n        env = SandboxedEnvironment()\n        t = env.from_string('{{ \"a{0.__class__}b\".format(42) }}')\n        assert t.render() == 'ab'\n\n    def test_basic_format_all_okay(self):\n        env = SandboxedEnvironment()\n        t = env.from_string('{{ \"a{0.foo}b\".format({\"foo\": 42}) }}')\n        assert t.render() == 'a42b'\n\n    def test_basic_format_safety(self):\n        env = SandboxedEnvironment()\n        t = env.from_string('{{ (\"a{0.__class__}b{1}\"|safe).format(42, \"<foo>\") }}')\n        assert t.render() == 'ab&lt;foo&gt;'\n\n    def test_basic_format_all_okay(self):\n        env = SandboxedEnvironment()\n        t = env.from_string('{{ (\"a{0.foo}b{1}\"|safe).format({\"foo\": 42}, \"<foo>\") }}')\n        assert t.render() == 'a42b&lt;foo&gt;'\n"], "filenames": ["jinja2/nodes.py", "jinja2/sandbox.py", "tests/test_security.py"], "buggy_code_start_loc": [607, 16, 15], "buggy_code_end_loc": [608, 367, 161], "fixing_code_start_loc": [607, 17, 15], "fixing_code_end_loc": [608, 481, 187], "type": "CWE-134", "message": "In Pallets Jinja before 2.8.1, str.format allows a sandbox escape.", "other": {"cve": {"id": "CVE-2016-10745", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-08T13:29:00.280", "lastModified": "2019-06-06T16:29:00.247", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In Pallets Jinja before 2.8.1, str.format allows a sandbox escape."}, {"lang": "es", "value": "En Pallets Jinja versiones anteriores a 2.8.1, str.format permite un scape de sandbox"}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-134"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:palletsprojects:jinja:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.8.1", "matchCriteriaId": "4BD6AB58-BD65-43FC-BDE9-D528F436ADA6"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-05/msg00030.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-06/msg00064.html", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:1022", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:1237", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:1260", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:3964", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:4062", "source": "cve@mitre.org"}, {"url": "https://github.com/pallets/jinja/commit/9b53045c34e61013dc8f09b7e52a555fa16bed16", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://palletsprojects.com/blog/jinja-281-released/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://usn.ubuntu.com/4011-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4011-2/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/pallets/jinja/commit/9b53045c34e61013dc8f09b7e52a555fa16bed16"}}