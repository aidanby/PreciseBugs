{"buggy_code": ["package scrypt\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"encoding/binary\"\n\t\"log\"\n\n\t\"code.google.com/p/go.crypto/scrypt\"\n)\n\n// EncryptPassphrase returns a keylen_bytes+60 bytes of encrypted text\n// from the input passphrase.\n// It runs the scrypt function for this.\nfunc EncryptPassphrase(passphrase string, keylen_bytes int) (key []byte, err error) {\n\t// Generate salt\n\tsalt := generateSalt()\n\t// Set params\n\tvar N int32 = 16384\n\tvar r int32 = 8\n\tvar p int32 = 1\n\n\t// Generate key\n\tkey, err = scrypt.Key([]byte(passphrase),\n\t\tsalt,\n\t\tint(N), // Must be a power of 2 greater than 1\n\t\tint(r),\n\t\tint(p), // r*p must be < 2^30\n\t\tkeylen_bytes)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error in encrypting passphrase: %s\\n\", err)\n\t\treturn\n\t}\n\n\t// Appending the salt\n\tkey = append(key, salt...)\n\n\t// Encoding the params to be stored\n\tbuf := new(bytes.Buffer)\n\tfor _, elem := range [3]int32{N, r, p} {\n\t\terr = binary.Write(buf, binary.LittleEndian, elem)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"binary.Write failed: %s\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tkey = append(key, buf.Bytes()...)\n\t\tbuf.Reset()\n\t}\n\n\t// appending the sha-256 of the entire header at the end\n\thash_digest := sha256.New()\n\thash_digest.Write(key)\n\tif err != nil {\n\t\tlog.Fatalf(\"hash_digest.Write failed: %s\\n\", err)\n\t\treturn\n\t}\n\thash := hash_digest.Sum(nil)\n\tkey = append(key, hash...)\n\n\treturn\n}\n\n// VerifyPassphrase takes the passphrase and the target_key to match against.\n// And returns a boolean result whether it matched or not\nfunc VerifyPassphrase(passphrase string, keylen_bytes int, target_key []byte) (result bool, err error) {\n\t// Get the master_key\n\ttarget_master_key := target_key[:keylen_bytes]\n\t// Get the salt\n\tsalt := target_key[keylen_bytes:48]\n\t// Get the params\n\tvar N, r, p int32\n\n\terr = binary.Read(bytes.NewReader(target_key[48:52]), // byte 48:52 for N\n\t\tbinary.LittleEndian,\n\t\t&N)\n\tif err != nil {\n\t\tlog.Fatalf(\"binary.Read failed for N: %s\\n\", err)\n\t\treturn\n\t}\n\n\terr = binary.Read(bytes.NewReader(target_key[52:56]), // byte 52:56 for r\n\t\tbinary.LittleEndian,\n\t\t&r)\n\tif err != nil {\n\t\tlog.Fatalf(\"binary.Read failed for r: %s\\n\", err)\n\t\treturn\n\t}\n\n\terr = binary.Read(bytes.NewReader(target_key[56:60]), // byte 56:60 for p\n\t\tbinary.LittleEndian,\n\t\t&p)\n\tif err != nil {\n\t\tlog.Fatalf(\"binary.Read failed for p: %s\\n\", err)\n\t\treturn\n\t}\n\tvar source_master_key []byte\n\tsource_master_key, err = scrypt.Key([]byte(passphrase),\n\t\tsalt,\n\t\tint(N), // Must be a power of 2 greater than 1\n\t\tint(r),\n\t\tint(p), // r*p must be < 2^30\n\t\tkeylen_bytes)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error in encrypting passphrase: %s\\n\", err)\n\t\treturn\n\t}\n\n\ttarget_hash := target_key[60:]\n\t// Doing the sha-256 checksum at the last because we want the attacker\n\t// to spend as much time possible cracking\n\thash_digest := sha256.New()\n\t_, err = hash_digest.Write(target_key[:60])\n\tif err != nil {\n\t\tlog.Fatalf(\"hash_digest.Write failed: %s\\n\", err)\n\t\treturn\n\t}\n\tsource_hash := hash_digest.Sum(nil)\n\n\tresult = bytes.Equal(source_master_key, target_master_key) &&\n\t\tbytes.Equal(target_hash, source_hash)\n\treturn\n}\n\nfunc generateSalt() (salt []byte) {\n\tsalt = make([]byte, 16)\n\t_, err := rand.Read(salt)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error in generating salt: %s\\n\", err)\n\t\treturn\n\t}\n\treturn\n}\n"], "fixing_code": ["package scrypt\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"crypto/subtle\"\n\t\"encoding/binary\"\n\t\"log\"\n\n\t\"code.google.com/p/go.crypto/scrypt\"\n)\n\n// EncryptPassphrase returns a keylen_bytes+60 bytes of encrypted text\n// from the input passphrase.\n// It runs the scrypt function for this.\nfunc EncryptPassphrase(passphrase string, keylen_bytes int) (key []byte, err error) {\n\t// Generate salt\n\tsalt := generateSalt()\n\t// Set params\n\tvar N int32 = 16384\n\tvar r int32 = 8\n\tvar p int32 = 1\n\n\t// Generate key\n\tkey, err = scrypt.Key([]byte(passphrase),\n\t\tsalt,\n\t\tint(N), // Must be a power of 2 greater than 1\n\t\tint(r),\n\t\tint(p), // r*p must be < 2^30\n\t\tkeylen_bytes)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error in encrypting passphrase: %s\\n\", err)\n\t\treturn\n\t}\n\n\t// Appending the salt\n\tkey = append(key, salt...)\n\n\t// Encoding the params to be stored\n\tbuf := new(bytes.Buffer)\n\tfor _, elem := range [3]int32{N, r, p} {\n\t\terr = binary.Write(buf, binary.LittleEndian, elem)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"binary.Write failed: %s\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tkey = append(key, buf.Bytes()...)\n\t\tbuf.Reset()\n\t}\n\n\t// appending the sha-256 of the entire header at the end\n\thash_digest := sha256.New()\n\thash_digest.Write(key)\n\tif err != nil {\n\t\tlog.Fatalf(\"hash_digest.Write failed: %s\\n\", err)\n\t\treturn\n\t}\n\thash := hash_digest.Sum(nil)\n\tkey = append(key, hash...)\n\n\treturn\n}\n\n// VerifyPassphrase takes the passphrase and the target_key to match against.\n// And returns a boolean result whether it matched or not\nfunc VerifyPassphrase(passphrase string, keylen_bytes int, target_key []byte) (result bool, err error) {\n\t// Get the master_key\n\ttarget_master_key := target_key[:keylen_bytes]\n\t// Get the salt\n\tsalt := target_key[keylen_bytes:48]\n\t// Get the params\n\tvar N, r, p int32\n\n\terr = binary.Read(bytes.NewReader(target_key[48:52]), // byte 48:52 for N\n\t\tbinary.LittleEndian,\n\t\t&N)\n\tif err != nil {\n\t\tlog.Fatalf(\"binary.Read failed for N: %s\\n\", err)\n\t\treturn\n\t}\n\n\terr = binary.Read(bytes.NewReader(target_key[52:56]), // byte 52:56 for r\n\t\tbinary.LittleEndian,\n\t\t&r)\n\tif err != nil {\n\t\tlog.Fatalf(\"binary.Read failed for r: %s\\n\", err)\n\t\treturn\n\t}\n\n\terr = binary.Read(bytes.NewReader(target_key[56:60]), // byte 56:60 for p\n\t\tbinary.LittleEndian,\n\t\t&p)\n\tif err != nil {\n\t\tlog.Fatalf(\"binary.Read failed for p: %s\\n\", err)\n\t\treturn\n\t}\n\tvar source_master_key []byte\n\tsource_master_key, err = scrypt.Key([]byte(passphrase),\n\t\tsalt,\n\t\tint(N), // Must be a power of 2 greater than 1\n\t\tint(r),\n\t\tint(p), // r*p must be < 2^30\n\t\tkeylen_bytes)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error in encrypting passphrase: %s\\n\", err)\n\t\treturn\n\t}\n\n\ttarget_hash := target_key[60:]\n\t// Doing the sha-256 checksum at the last because we want the attacker\n\t// to spend as much time possible cracking\n\thash_digest := sha256.New()\n\t_, err = hash_digest.Write(target_key[:60])\n\tif err != nil {\n\t\tlog.Fatalf(\"hash_digest.Write failed: %s\\n\", err)\n\t\treturn\n\t}\n\tsource_hash := hash_digest.Sum(nil)\n\n\t// ConstantTimeCompare returns ints. Converting it to bool\n\tkey_comp := subtle.ConstantTimeCompare(source_master_key,\n\t\ttarget_master_key) != 0\n\thash_comp := subtle.ConstantTimeCompare(target_hash,\n\t\tsource_hash) != 0\n\tresult = key_comp && hash_comp\n\treturn\n}\n\nfunc generateSalt() (salt []byte) {\n\tsalt = make([]byte, 16)\n\t_, err := rand.Read(salt)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error in generating salt: %s\\n\", err)\n\t\treturn\n\t}\n\treturn\n}\n"], "filenames": ["scrypt.go"], "buggy_code_start_loc": [6], "buggy_code_end_loc": [122], "fixing_code_start_loc": [7], "fixing_code_end_loc": [127], "type": "CWE-208", "message": "A vulnerability, which was classified as problematic, was found in agnivade easy-scrypt. Affected is the function VerifyPassphrase of the file scrypt.go. The manipulation leads to observable timing discrepancy. Upgrading to version 1.0.0 is able to address this issue. The name of the patch is 477c10cf3b144ddf96526aa09f5fdea613f21812. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217596.", "other": {"cve": {"id": "CVE-2014-125055", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-07T09:15:21.470", "lastModified": "2023-01-12T16:52:39.327", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as problematic, was found in agnivade easy-scrypt. Affected is the function VerifyPassphrase of the file scrypt.go. The manipulation leads to observable timing discrepancy. Upgrading to version 1.0.0 is able to address this issue. The name of the patch is 477c10cf3b144ddf96526aa09f5fdea613f21812. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217596."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:H/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:H/Au:S/C:P/I:N/A:N", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "HIGH", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.4}, "baseSeverity": "LOW", "exploitabilityScore": 2.5, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-208"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:easy-script_project:easy-script:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.0", "matchCriteriaId": "2B5218F1-D44E-44A5-98D0-7AF13C1F3F3F"}]}]}], "references": [{"url": "https://github.com/agnivade/easy-scrypt/commit/477c10cf3b144ddf96526aa09f5fdea613f21812", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/agnivade/easy-scrypt/releases/tag/v1.0.0", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217596", "source": "cna@vuldb.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://vuldb.com/?id.217596", "source": "cna@vuldb.com", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/agnivade/easy-scrypt/commit/477c10cf3b144ddf96526aa09f5fdea613f21812"}}