{"buggy_code": ["/* pb_decode.c -- decode a protobuf using minimal resources\n *\n * 2011 Petteri Aimonen <jpa@kapsi.fi>\n */\n\n/* Use the GCC warn_unused_result attribute to check that all return values\n * are propagated correctly. On other compilers and gcc before 3.4.0 just\n * ignore the annotation.\n */\n#if !defined(__GNUC__) || ( __GNUC__ < 3) || (__GNUC__ == 3 && __GNUC_MINOR__ < 4)\n    #define checkreturn\n#else\n    #define checkreturn __attribute__((warn_unused_result))\n#endif\n\n#include \"pb.h\"\n#include \"pb_decode.h\"\n#include \"pb_common.h\"\n\n/**************************************\n * Declarations internal to this file *\n **************************************/\n\nstatic bool checkreturn buf_read(pb_istream_t *stream, pb_byte_t *buf, size_t count);\nstatic bool checkreturn pb_decode_varint32_eof(pb_istream_t *stream, uint32_t *dest, bool *eof);\nstatic bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, pb_byte_t *buf, size_t *size);\nstatic bool checkreturn decode_basic_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field);\nstatic bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field);\nstatic bool checkreturn decode_pointer_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field);\nstatic bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field);\nstatic bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field);\nstatic bool checkreturn default_extension_decoder(pb_istream_t *stream, pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type);\nstatic bool checkreturn decode_extension(pb_istream_t *stream, uint32_t tag, pb_wire_type_t wire_type, pb_extension_t *extension);\nstatic bool pb_field_set_to_default(pb_field_iter_t *field);\nstatic bool pb_message_set_to_defaults(pb_field_iter_t *iter);\nstatic bool checkreturn pb_dec_bool(pb_istream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_dec_fixed_length_bytes(pb_istream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_skip_varint(pb_istream_t *stream);\nstatic bool checkreturn pb_skip_string(pb_istream_t *stream);\n\n#ifdef PB_ENABLE_MALLOC\nstatic bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size);\nstatic void initialize_pointer_field(void *pItem, pb_field_iter_t *field);\nstatic bool checkreturn pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field);\nstatic void pb_release_single_field(pb_field_iter_t *field);\n#endif\n\n#ifdef PB_WITHOUT_64BIT\n#define pb_int64_t int32_t\n#define pb_uint64_t uint32_t\n#else\n#define pb_int64_t int64_t\n#define pb_uint64_t uint64_t\n#endif\n\n#define PB_WT_PACKED ((pb_wire_type_t)0xFF)\n\ntypedef struct {\n    uint32_t bitfield[(PB_MAX_REQUIRED_FIELDS + 31) / 32];\n} pb_fields_seen_t;\n\n/*******************************\n * pb_istream_t implementation *\n *******************************/\n\nstatic bool checkreturn buf_read(pb_istream_t *stream, pb_byte_t *buf, size_t count)\n{\n    size_t i;\n    const pb_byte_t *source = (const pb_byte_t*)stream->state;\n    stream->state = (pb_byte_t*)stream->state + count;\n    \n    if (buf != NULL)\n    {\n        for (i = 0; i < count; i++)\n            buf[i] = source[i];\n    }\n    \n    return true;\n}\n\nbool checkreturn pb_read(pb_istream_t *stream, pb_byte_t *buf, size_t count)\n{\n    if (count == 0)\n        return true;\n\n#ifndef PB_BUFFER_ONLY\n\tif (buf == NULL && stream->callback != buf_read)\n\t{\n\t\t/* Skip input bytes */\n\t\tpb_byte_t tmp[16];\n\t\twhile (count > 16)\n\t\t{\n\t\t\tif (!pb_read(stream, tmp, 16))\n\t\t\t\treturn false;\n\t\t\t\n\t\t\tcount -= 16;\n\t\t}\n\t\t\n\t\treturn pb_read(stream, tmp, count);\n\t}\n#endif\n\n    if (stream->bytes_left < count)\n        PB_RETURN_ERROR(stream, \"end-of-stream\");\n    \n#ifndef PB_BUFFER_ONLY\n    if (!stream->callback(stream, buf, count))\n        PB_RETURN_ERROR(stream, \"io error\");\n#else\n    if (!buf_read(stream, buf, count))\n        return false;\n#endif\n    \n    stream->bytes_left -= count;\n    return true;\n}\n\n/* Read a single byte from input stream. buf may not be NULL.\n * This is an optimization for the varint decoding. */\nstatic bool checkreturn pb_readbyte(pb_istream_t *stream, pb_byte_t *buf)\n{\n    if (stream->bytes_left == 0)\n        PB_RETURN_ERROR(stream, \"end-of-stream\");\n\n#ifndef PB_BUFFER_ONLY\n    if (!stream->callback(stream, buf, 1))\n        PB_RETURN_ERROR(stream, \"io error\");\n#else\n    *buf = *(const pb_byte_t*)stream->state;\n    stream->state = (pb_byte_t*)stream->state + 1;\n#endif\n\n    stream->bytes_left--;\n    \n    return true;    \n}\n\npb_istream_t pb_istream_from_buffer(const pb_byte_t *buf, size_t msglen)\n{\n    pb_istream_t stream;\n    /* Cast away the const from buf without a compiler error.  We are\n     * careful to use it only in a const manner in the callbacks.\n     */\n    union {\n        void *state;\n        const void *c_state;\n    } state;\n#ifdef PB_BUFFER_ONLY\n    stream.callback = NULL;\n#else\n    stream.callback = &buf_read;\n#endif\n    state.c_state = buf;\n    stream.state = state.state;\n    stream.bytes_left = msglen;\n#ifndef PB_NO_ERRMSG\n    stream.errmsg = NULL;\n#endif\n    return stream;\n}\n\n/********************\n * Helper functions *\n ********************/\n\nstatic bool checkreturn pb_decode_varint32_eof(pb_istream_t *stream, uint32_t *dest, bool *eof)\n{\n    pb_byte_t byte;\n    uint32_t result;\n    \n    if (!pb_readbyte(stream, &byte))\n    {\n        if (stream->bytes_left == 0)\n        {\n            if (eof)\n            {\n                *eof = true;\n            }\n        }\n\n        return false;\n    }\n    \n    if ((byte & 0x80) == 0)\n    {\n        /* Quick case, 1 byte value */\n        result = byte;\n    }\n    else\n    {\n        /* Multibyte case */\n        uint_fast8_t bitpos = 7;\n        result = byte & 0x7F;\n        \n        do\n        {\n            if (!pb_readbyte(stream, &byte))\n                return false;\n            \n            if (bitpos >= 32)\n            {\n                /* Note: The varint could have trailing 0x80 bytes, or 0xFF for negative. */\n                pb_byte_t sign_extension = (bitpos < 63) ? 0xFF : 0x01;\n                bool valid_extension = ((byte & 0x7F) == 0x00 ||\n                         ((result >> 31) != 0 && byte == sign_extension));\n\n                if (bitpos >= 64 || !valid_extension)\n                {\n                    PB_RETURN_ERROR(stream, \"varint overflow\");\n                }\n            }\n            else\n            {\n                result |= (uint32_t)(byte & 0x7F) << bitpos;\n            }\n            bitpos = (uint_fast8_t)(bitpos + 7);\n        } while (byte & 0x80);\n        \n        if (bitpos == 35 && (byte & 0x70) != 0)\n        {\n            /* The last byte was at bitpos=28, so only bottom 4 bits fit. */\n            PB_RETURN_ERROR(stream, \"varint overflow\");\n        }\n   }\n   \n   *dest = result;\n   return true;\n}\n\nbool checkreturn pb_decode_varint32(pb_istream_t *stream, uint32_t *dest)\n{\n    return pb_decode_varint32_eof(stream, dest, NULL);\n}\n\n#ifndef PB_WITHOUT_64BIT\nbool checkreturn pb_decode_varint(pb_istream_t *stream, uint64_t *dest)\n{\n    pb_byte_t byte;\n    uint_fast8_t bitpos = 0;\n    uint64_t result = 0;\n    \n    do\n    {\n        if (bitpos >= 64)\n            PB_RETURN_ERROR(stream, \"varint overflow\");\n        \n        if (!pb_readbyte(stream, &byte))\n            return false;\n\n        result |= (uint64_t)(byte & 0x7F) << bitpos;\n        bitpos = (uint_fast8_t)(bitpos + 7);\n    } while (byte & 0x80);\n    \n    *dest = result;\n    return true;\n}\n#endif\n\nbool checkreturn pb_skip_varint(pb_istream_t *stream)\n{\n    pb_byte_t byte;\n    do\n    {\n        if (!pb_read(stream, &byte, 1))\n            return false;\n    } while (byte & 0x80);\n    return true;\n}\n\nbool checkreturn pb_skip_string(pb_istream_t *stream)\n{\n    uint32_t length;\n    if (!pb_decode_varint32(stream, &length))\n        return false;\n    \n    if ((size_t)length != length)\n    {\n        PB_RETURN_ERROR(stream, \"size too large\");\n    }\n\n    return pb_read(stream, NULL, (size_t)length);\n}\n\nbool checkreturn pb_decode_tag(pb_istream_t *stream, pb_wire_type_t *wire_type, uint32_t *tag, bool *eof)\n{\n    uint32_t temp;\n    *eof = false;\n    *wire_type = (pb_wire_type_t) 0;\n    *tag = 0;\n    \n    if (!pb_decode_varint32_eof(stream, &temp, eof))\n    {\n        return false;\n    }\n    \n    *tag = temp >> 3;\n    *wire_type = (pb_wire_type_t)(temp & 7);\n    return true;\n}\n\nbool checkreturn pb_skip_field(pb_istream_t *stream, pb_wire_type_t wire_type)\n{\n    switch (wire_type)\n    {\n        case PB_WT_VARINT: return pb_skip_varint(stream);\n        case PB_WT_64BIT: return pb_read(stream, NULL, 8);\n        case PB_WT_STRING: return pb_skip_string(stream);\n        case PB_WT_32BIT: return pb_read(stream, NULL, 4);\n        default: PB_RETURN_ERROR(stream, \"invalid wire_type\");\n    }\n}\n\n/* Read a raw value to buffer, for the purpose of passing it to callback as\n * a substream. Size is maximum size on call, and actual size on return.\n */\nstatic bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, pb_byte_t *buf, size_t *size)\n{\n    size_t max_size = *size;\n    switch (wire_type)\n    {\n        case PB_WT_VARINT:\n            *size = 0;\n            do\n            {\n                (*size)++;\n                if (*size > max_size)\n                    PB_RETURN_ERROR(stream, \"varint overflow\");\n\n                if (!pb_read(stream, buf, 1))\n                    return false;\n            } while (*buf++ & 0x80);\n            return true;\n            \n        case PB_WT_64BIT:\n            *size = 8;\n            return pb_read(stream, buf, 8);\n        \n        case PB_WT_32BIT:\n            *size = 4;\n            return pb_read(stream, buf, 4);\n        \n        case PB_WT_STRING:\n            /* Calling read_raw_value with a PB_WT_STRING is an error.\n             * Explicitly handle this case and fallthrough to default to avoid\n             * compiler warnings.\n             */\n\n        default: PB_RETURN_ERROR(stream, \"invalid wire_type\");\n    }\n}\n\n/* Decode string length from stream and return a substream with limited length.\n * Remember to close the substream using pb_close_string_substream().\n */\nbool checkreturn pb_make_string_substream(pb_istream_t *stream, pb_istream_t *substream)\n{\n    uint32_t size;\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    \n    *substream = *stream;\n    if (substream->bytes_left < size)\n        PB_RETURN_ERROR(stream, \"parent stream too short\");\n    \n    substream->bytes_left = (size_t)size;\n    stream->bytes_left -= (size_t)size;\n    return true;\n}\n\nbool checkreturn pb_close_string_substream(pb_istream_t *stream, pb_istream_t *substream)\n{\n    if (substream->bytes_left) {\n        if (!pb_read(substream, NULL, substream->bytes_left))\n            return false;\n    }\n\n    stream->state = substream->state;\n\n#ifndef PB_NO_ERRMSG\n    stream->errmsg = substream->errmsg;\n#endif\n    return true;\n}\n\n/*************************\n * Decode a single field *\n *************************/\n\nstatic bool checkreturn decode_basic_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field)\n{\n    switch (PB_LTYPE(field->type))\n    {\n        case PB_LTYPE_BOOL:\n            if (wire_type != PB_WT_VARINT && wire_type != PB_WT_PACKED)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_dec_bool(stream, field);\n\n        case PB_LTYPE_VARINT:\n        case PB_LTYPE_UVARINT:\n        case PB_LTYPE_SVARINT:\n            if (wire_type != PB_WT_VARINT && wire_type != PB_WT_PACKED)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_dec_varint(stream, field);\n\n        case PB_LTYPE_FIXED32:\n            if (wire_type != PB_WT_32BIT && wire_type != PB_WT_PACKED)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_decode_fixed32(stream, field->pData);\n\n        case PB_LTYPE_FIXED64:\n            if (wire_type != PB_WT_64BIT && wire_type != PB_WT_PACKED)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n#ifdef PB_CONVERT_DOUBLE_FLOAT\n            if (field->data_size == sizeof(float))\n            {\n                return pb_decode_double_as_float(stream, (float*)field->pData);\n            }\n#endif\n\n#ifdef PB_WITHOUT_64BIT\n            PB_RETURN_ERROR(stream, \"invalid data_size\");\n#else\n            return pb_decode_fixed64(stream, field->pData);\n#endif\n\n        case PB_LTYPE_BYTES:\n            if (wire_type != PB_WT_STRING)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_dec_bytes(stream, field);\n\n        case PB_LTYPE_STRING:\n            if (wire_type != PB_WT_STRING)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_dec_string(stream, field);\n\n        case PB_LTYPE_SUBMESSAGE:\n        case PB_LTYPE_SUBMSG_W_CB:\n            if (wire_type != PB_WT_STRING)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_dec_submessage(stream, field);\n\n        case PB_LTYPE_FIXED_LENGTH_BYTES:\n            if (wire_type != PB_WT_STRING)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_dec_fixed_length_bytes(stream, field);\n\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}\n\nstatic bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field)\n{\n    switch (PB_HTYPE(field->type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return decode_basic_field(stream, wire_type, field);\n            \n        case PB_HTYPE_OPTIONAL:\n            if (field->pSize != NULL)\n                *(bool*)field->pSize = true;\n            return decode_basic_field(stream, wire_type, field);\n    \n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(field->type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                /* Packed array */\n                bool status = true;\n                pb_istream_t substream;\n                pb_size_t *size = (pb_size_t*)field->pSize;\n                field->pData = (char*)field->pField + field->data_size * (*size);\n\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n\n                while (substream.bytes_left > 0 && *size < field->array_size)\n                {\n                    if (!decode_basic_field(&substream, PB_WT_PACKED, field))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                    field->pData = (char*)field->pData + field->data_size;\n                }\n\n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n\n                return status;\n            }\n            else\n            {\n                /* Repeated field */\n                pb_size_t *size = (pb_size_t*)field->pSize;\n                field->pData = (char*)field->pField + field->data_size * (*size);\n\n                if ((*size)++ >= field->array_size)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n\n                return decode_basic_field(stream, wire_type, field);\n            }\n\n        case PB_HTYPE_ONEOF:\n            if (PB_LTYPE_IS_SUBMSG(field->type) &&\n                *(pb_size_t*)field->pSize != field->tag)\n            {\n                /* We memset to zero so that any callbacks are set to NULL.\n                 * This is because the callbacks might otherwise have values\n                 * from some other union field.\n                 * If callbacks are needed inside oneof field, use .proto\n                 * option submsg_callback to have a separate callback function\n                 * that can set the fields before submessage is decoded.\n                 * pb_dec_submessage() will set any default values. */\n                memset(field->pData, 0, (size_t)field->data_size);\n\n                /* Set default values for the submessage fields. */\n                if (field->submsg_desc->default_value != NULL ||\n                    field->submsg_desc->field_callback != NULL ||\n                    field->submsg_desc->submsg_info[0] != NULL)\n                {\n                    pb_field_iter_t submsg_iter;\n                    if (pb_field_iter_begin(&submsg_iter, field->submsg_desc, field->pData))\n                    {\n                        if (!pb_message_set_to_defaults(&submsg_iter))\n                            PB_RETURN_ERROR(stream, \"failed to set defaults\");\n                    }\n                }\n            }\n            *(pb_size_t*)field->pSize = field->tag;\n\n            return decode_basic_field(stream, wire_type, field);\n\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}\n\n#ifdef PB_ENABLE_MALLOC\n/* Allocate storage for the field and store the pointer at iter->pData.\n * array_size is the number of entries to reserve in an array.\n * Zero size is not allowed, use pb_free() for releasing.\n */\nstatic bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size)\n{    \n    void *ptr = *(void**)pData;\n    \n    if (data_size == 0 || array_size == 0)\n        PB_RETURN_ERROR(stream, \"invalid size\");\n    \n#ifdef __AVR__\n    /* Workaround for AVR libc bug 53284: http://savannah.nongnu.org/bugs/?53284\n     * Realloc to size of 1 byte can cause corruption of the malloc structures.\n     */\n    if (data_size == 1 && array_size == 1)\n    {\n        data_size = 2;\n    }\n#endif\n\n    /* Check for multiplication overflows.\n     * This code avoids the costly division if the sizes are small enough.\n     * Multiplication is safe as long as only half of bits are set\n     * in either multiplicand.\n     */\n    {\n        const size_t check_limit = (size_t)1 << (sizeof(size_t) * 4);\n        if (data_size >= check_limit || array_size >= check_limit)\n        {\n            const size_t size_max = (size_t)-1;\n            if (size_max / array_size < data_size)\n            {\n                PB_RETURN_ERROR(stream, \"size too large\");\n            }\n        }\n    }\n    \n    /* Allocate new or expand previous allocation */\n    /* Note: on failure the old pointer will remain in the structure,\n     * the message must be freed by caller also on error return. */\n    ptr = pb_realloc(ptr, array_size * data_size);\n    if (ptr == NULL)\n        PB_RETURN_ERROR(stream, \"realloc failed\");\n    \n    *(void**)pData = ptr;\n    return true;\n}\n\n/* Clear a newly allocated item in case it contains a pointer, or is a submessage. */\nstatic void initialize_pointer_field(void *pItem, pb_field_iter_t *field)\n{\n    if (PB_LTYPE(field->type) == PB_LTYPE_STRING ||\n        PB_LTYPE(field->type) == PB_LTYPE_BYTES)\n    {\n        *(void**)pItem = NULL;\n    }\n    else if (PB_LTYPE_IS_SUBMSG(field->type))\n    {\n        /* We memset to zero so that any callbacks are set to NULL.\n         * Default values will be set by pb_dec_submessage(). */\n        memset(pItem, 0, field->data_size);\n    }\n}\n#endif\n\nstatic bool checkreturn decode_pointer_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field)\n{\n#ifndef PB_ENABLE_MALLOC\n    PB_UNUSED(wire_type);\n    PB_UNUSED(field);\n    PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n    switch (PB_HTYPE(field->type))\n    {\n        case PB_HTYPE_REQUIRED:\n        case PB_HTYPE_OPTIONAL:\n        case PB_HTYPE_ONEOF:\n            if (PB_LTYPE_IS_SUBMSG(field->type) && *(void**)field->pField != NULL)\n            {\n                /* Duplicate field, have to release the old allocation first. */\n                /* FIXME: Does this work correctly for oneofs? */\n                pb_release_single_field(field);\n            }\n        \n            if (PB_HTYPE(field->type) == PB_HTYPE_ONEOF)\n            {\n                *(pb_size_t*)field->pSize = field->tag;\n            }\n\n            if (PB_LTYPE(field->type) == PB_LTYPE_STRING ||\n                PB_LTYPE(field->type) == PB_LTYPE_BYTES)\n            {\n                /* pb_dec_string and pb_dec_bytes handle allocation themselves */\n                field->pData = field->pField;\n                return decode_basic_field(stream, wire_type, field);\n            }\n            else\n            {\n                if (!allocate_field(stream, field->pField, field->data_size, 1))\n                    return false;\n                \n                field->pData = *(void**)field->pField;\n                initialize_pointer_field(field->pData, field);\n                return decode_basic_field(stream, wire_type, field);\n            }\n    \n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(field->type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                /* Packed array, multiple items come in at once. */\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)field->pSize;\n                size_t allocated_size = *size;\n                pb_istream_t substream;\n                \n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n                \n                while (substream.bytes_left)\n                {\n                    if (*size == PB_SIZE_MAX)\n                    {\n#ifndef PB_NO_ERRMSG\n                        stream->errmsg = \"too many array entries\";\n#endif\n                        status = false;\n                        break;\n                    }\n\n                    if ((size_t)*size + 1 > allocated_size)\n                    {\n                        /* Allocate more storage. This tries to guess the\n                         * number of remaining entries. Round the division\n                         * upwards. */\n                        size_t remain = (substream.bytes_left - 1) / field->data_size + 1;\n                        if (remain < PB_SIZE_MAX - allocated_size)\n                            allocated_size += remain;\n                        else\n                            allocated_size += 1;\n                        \n                        if (!allocate_field(&substream, field->pField, field->data_size, allocated_size))\n                        {\n                            status = false;\n                            break;\n                        }\n                    }\n\n                    /* Decode the array entry */\n                    field->pData = *(char**)field->pField + field->data_size * (*size);\n                    initialize_pointer_field(field->pData, field);\n                    if (!decode_basic_field(&substream, PB_WT_PACKED, field))\n                    {\n                        status = false;\n                        break;\n                    }\n                    \n                    (*size)++;\n                }\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n                \n                return status;\n            }\n            else\n            {\n                /* Normal repeated field, i.e. only one item at a time. */\n                pb_size_t *size = (pb_size_t*)field->pSize;\n\n                if (*size == PB_SIZE_MAX)\n                    PB_RETURN_ERROR(stream, \"too many array entries\");\n                \n                if (!allocate_field(stream, field->pField, field->data_size, (size_t)(*size + 1)))\n                    return false;\n            \n                field->pData = *(char**)field->pField + field->data_size * (*size);\n                (*size)++;\n                initialize_pointer_field(field->pData, field);\n                return decode_basic_field(stream, wire_type, field);\n            }\n\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n#endif\n}\n\nstatic bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field)\n{\n    if (!field->descriptor->field_callback)\n        return pb_skip_field(stream, wire_type);\n\n    if (wire_type == PB_WT_STRING)\n    {\n        pb_istream_t substream;\n        size_t prev_bytes_left;\n        \n        if (!pb_make_string_substream(stream, &substream))\n            return false;\n        \n        do\n        {\n            prev_bytes_left = substream.bytes_left;\n            if (!field->descriptor->field_callback(&substream, NULL, field))\n                PB_RETURN_ERROR(stream, \"callback failed\");\n        } while (substream.bytes_left > 0 && substream.bytes_left < prev_bytes_left);\n        \n        if (!pb_close_string_substream(stream, &substream))\n            return false;\n\n        return true;\n    }\n    else\n    {\n        /* Copy the single scalar value to stack.\n         * This is required so that we can limit the stream length,\n         * which in turn allows to use same callback for packed and\n         * not-packed fields. */\n        pb_istream_t substream;\n        pb_byte_t buffer[10];\n        size_t size = sizeof(buffer);\n        \n        if (!read_raw_value(stream, wire_type, buffer, &size))\n            return false;\n        substream = pb_istream_from_buffer(buffer, size);\n        \n        return field->descriptor->field_callback(&substream, NULL, field);\n    }\n}\n\nstatic bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field)\n{\n#ifdef PB_ENABLE_MALLOC\n    /* When decoding an oneof field, check if there is old data that must be\n     * released first. */\n    if (PB_HTYPE(field->type) == PB_HTYPE_ONEOF)\n    {\n        if (!pb_release_union_field(stream, field))\n            return false;\n    }\n#endif\n\n    switch (PB_ATYPE(field->type))\n    {\n        case PB_ATYPE_STATIC:\n            return decode_static_field(stream, wire_type, field);\n        \n        case PB_ATYPE_POINTER:\n            return decode_pointer_field(stream, wire_type, field);\n        \n        case PB_ATYPE_CALLBACK:\n            return decode_callback_field(stream, wire_type, field);\n        \n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}\n\n/* Default handler for extension fields. Expects to have a pb_msgdesc_t\n * pointer in the extension->type->arg field, pointing to a message with\n * only one field in it.  */\nstatic bool checkreturn default_extension_decoder(pb_istream_t *stream,\n    pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type)\n{\n    pb_field_iter_t iter;\n\n    if (!pb_field_iter_begin_extension(&iter, extension))\n        PB_RETURN_ERROR(stream, \"invalid extension\");\n\n    if (iter.tag != tag || !iter.message)\n        return true;\n\n    extension->found = true;\n    return decode_field(stream, wire_type, &iter);\n}\n\n/* Try to decode an unknown field as an extension field. Tries each extension\n * decoder in turn, until one of them handles the field or loop ends. */\nstatic bool checkreturn decode_extension(pb_istream_t *stream,\n    uint32_t tag, pb_wire_type_t wire_type, pb_extension_t *extension)\n{\n    size_t pos = stream->bytes_left;\n    \n    while (extension != NULL && pos == stream->bytes_left)\n    {\n        bool status;\n        if (extension->type->decode)\n            status = extension->type->decode(stream, extension, tag, wire_type);\n        else\n            status = default_extension_decoder(stream, extension, tag, wire_type);\n\n        if (!status)\n            return false;\n        \n        extension = extension->next;\n    }\n    \n    return true;\n}\n\n/* Initialize message fields to default values, recursively */\nstatic bool pb_field_set_to_default(pb_field_iter_t *field)\n{\n    pb_type_t type;\n    type = field->type;\n\n    if (PB_LTYPE(type) == PB_LTYPE_EXTENSION)\n    {\n        pb_extension_t *ext = *(pb_extension_t* const *)field->pData;\n        while (ext != NULL)\n        {\n            pb_field_iter_t ext_iter;\n            if (pb_field_iter_begin_extension(&ext_iter, ext))\n            {\n                ext->found = false;\n                if (!pb_message_set_to_defaults(&ext_iter))\n                    return false;\n            }\n            ext = ext->next;\n        }\n    }\n    else if (PB_ATYPE(type) == PB_ATYPE_STATIC)\n    {\n        bool init_data = true;\n        if (PB_HTYPE(type) == PB_HTYPE_OPTIONAL && field->pSize != NULL)\n        {\n            /* Set has_field to false. Still initialize the optional field\n             * itself also. */\n            *(bool*)field->pSize = false;\n        }\n        else if (PB_HTYPE(type) == PB_HTYPE_REPEATED ||\n                 PB_HTYPE(type) == PB_HTYPE_ONEOF)\n        {\n            /* REPEATED: Set array count to 0, no need to initialize contents.\n               ONEOF: Set which_field to 0. */\n            *(pb_size_t*)field->pSize = 0;\n            init_data = false;\n        }\n\n        if (init_data)\n        {\n            if (PB_LTYPE_IS_SUBMSG(field->type) &&\n                (field->submsg_desc->default_value != NULL ||\n                 field->submsg_desc->field_callback != NULL ||\n                 field->submsg_desc->submsg_info[0] != NULL))\n            {\n                /* Initialize submessage to defaults.\n                 * Only needed if it has default values\n                 * or callback/submessage fields. */\n                pb_field_iter_t submsg_iter;\n                if (pb_field_iter_begin(&submsg_iter, field->submsg_desc, field->pData))\n                {\n                    if (!pb_message_set_to_defaults(&submsg_iter))\n                        return false;\n                }\n            }\n            else\n            {\n                /* Initialize to zeros */\n                memset(field->pData, 0, (size_t)field->data_size);\n            }\n        }\n    }\n    else if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n    {\n        /* Initialize the pointer to NULL. */\n        *(void**)field->pField = NULL;\n\n        /* Initialize array count to 0. */\n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED ||\n            PB_HTYPE(type) == PB_HTYPE_ONEOF)\n        {\n            *(pb_size_t*)field->pSize = 0;\n        }\n    }\n    else if (PB_ATYPE(type) == PB_ATYPE_CALLBACK)\n    {\n        /* Don't overwrite callback */\n    }\n\n    return true;\n}\n\nstatic bool pb_message_set_to_defaults(pb_field_iter_t *iter)\n{\n    pb_istream_t defstream = PB_ISTREAM_EMPTY;\n    uint32_t tag = 0;\n    pb_wire_type_t wire_type = PB_WT_VARINT;\n    bool eof;\n\n    if (iter->descriptor->default_value)\n    {\n        defstream = pb_istream_from_buffer(iter->descriptor->default_value, (size_t)-1);\n        if (!pb_decode_tag(&defstream, &wire_type, &tag, &eof))\n            return false;\n    }\n\n    do\n    {\n        if (!pb_field_set_to_default(iter))\n            return false;\n\n        if (tag != 0 && iter->tag == tag)\n        {\n            /* We have a default value for this field in the defstream */\n            if (!decode_field(&defstream, wire_type, iter))\n                return false;\n            if (!pb_decode_tag(&defstream, &wire_type, &tag, &eof))\n                return false;\n\n            if (iter->pSize)\n                *(bool*)iter->pSize = false;\n        }\n    } while (pb_field_iter_next(iter));\n\n    return true;\n}\n\n/*********************\n * Decode all fields *\n *********************/\n\nstatic bool checkreturn pb_decode_inner(pb_istream_t *stream, const pb_msgdesc_t *fields, void *dest_struct, unsigned int flags)\n{\n    uint32_t extension_range_start = 0;\n    pb_extension_t *extensions = NULL;\n\n    /* 'fixed_count_field' and 'fixed_count_size' track position of a repeated fixed\n     * count field. This can only handle _one_ repeated fixed count field that\n     * is unpacked and unordered among other (non repeated fixed count) fields.\n     */\n    pb_size_t fixed_count_field = PB_SIZE_MAX;\n    pb_size_t fixed_count_size = 0;\n    pb_size_t fixed_count_total_size = 0;\n\n    pb_fields_seen_t fields_seen = {{0, 0}};\n    const uint32_t allbits = ~(uint32_t)0;\n    pb_field_iter_t iter;\n\n    if (pb_field_iter_begin(&iter, fields, dest_struct))\n    {\n        if ((flags & PB_DECODE_NOINIT) == 0)\n        {\n            if (!pb_message_set_to_defaults(&iter))\n                PB_RETURN_ERROR(stream, \"failed to set defaults\");\n        }\n    }\n\n    while (stream->bytes_left)\n    {\n        uint32_t tag;\n        pb_wire_type_t wire_type;\n        bool eof;\n\n        if (!pb_decode_tag(stream, &wire_type, &tag, &eof))\n        {\n            if (eof)\n                break;\n            else\n                return false;\n        }\n\n        if (tag == 0)\n        {\n          if (flags & PB_DECODE_NULLTERMINATED)\n          {\n            break;\n          }\n          else\n          {\n            PB_RETURN_ERROR(stream, \"zero tag\");\n          }\n        }\n\n        if (!pb_field_iter_find(&iter, tag) || PB_LTYPE(iter.type) == PB_LTYPE_EXTENSION)\n        {\n            /* No match found, check if it matches an extension. */\n            if (extension_range_start == 0)\n            {\n                if (pb_field_iter_find_extension(&iter))\n                {\n                    extensions = *(pb_extension_t* const *)iter.pData;\n                    extension_range_start = iter.tag;\n                }\n\n                if (!extensions)\n                {\n                    extension_range_start = (uint32_t)-1;\n                }\n            }\n\n            if (tag >= extension_range_start)\n            {\n                size_t pos = stream->bytes_left;\n\n                if (!decode_extension(stream, tag, wire_type, extensions))\n                    return false;\n\n                if (pos != stream->bytes_left)\n                {\n                    /* The field was handled */\n                    continue;\n                }\n            }\n\n            /* No match found, skip data */\n            if (!pb_skip_field(stream, wire_type))\n                return false;\n            continue;\n        }\n\n        /* If a repeated fixed count field was found, get size from\n         * 'fixed_count_field' as there is no counter contained in the struct.\n         */\n        if (PB_HTYPE(iter.type) == PB_HTYPE_REPEATED && iter.pSize == &iter.array_size)\n        {\n            if (fixed_count_field != iter.index) {\n                /* If the new fixed count field does not match the previous one,\n                 * check that the previous one is NULL or that it finished\n                 * receiving all the expected data.\n                 */\n                if (fixed_count_field != PB_SIZE_MAX &&\n                    fixed_count_size != fixed_count_total_size)\n                {\n                    PB_RETURN_ERROR(stream, \"wrong size for fixed count field\");\n                }\n\n                fixed_count_field = iter.index;\n                fixed_count_size = 0;\n                fixed_count_total_size = iter.array_size;\n            }\n\n            iter.pSize = &fixed_count_size;\n        }\n\n        if (PB_HTYPE(iter.type) == PB_HTYPE_REQUIRED\n            && iter.required_field_index < PB_MAX_REQUIRED_FIELDS)\n        {\n            uint32_t tmp = ((uint32_t)1 << (iter.required_field_index & 31));\n            fields_seen.bitfield[iter.required_field_index >> 5] |= tmp;\n        }\n\n        if (!decode_field(stream, wire_type, &iter))\n            return false;\n    }\n\n    /* Check that all elements of the last decoded fixed count field were present. */\n    if (fixed_count_field != PB_SIZE_MAX &&\n        fixed_count_size != fixed_count_total_size)\n    {\n        PB_RETURN_ERROR(stream, \"wrong size for fixed count field\");\n    }\n\n    /* Check that all required fields were present. */\n    {\n        pb_size_t req_field_count = iter.descriptor->required_field_count;\n\n        if (req_field_count > 0)\n        {\n            pb_size_t i;\n\n            if (req_field_count > PB_MAX_REQUIRED_FIELDS)\n                req_field_count = PB_MAX_REQUIRED_FIELDS;\n\n            /* Check the whole words */\n            for (i = 0; i < (req_field_count >> 5); i++)\n            {\n                if (fields_seen.bitfield[i] != allbits)\n                    PB_RETURN_ERROR(stream, \"missing required field\");\n            }\n\n            /* Check the remaining bits (if any) */\n            if ((req_field_count & 31) != 0)\n            {\n                if (fields_seen.bitfield[req_field_count >> 5] !=\n                    (allbits >> (uint_least8_t)(32 - (req_field_count & 31))))\n                {\n                    PB_RETURN_ERROR(stream, \"missing required field\");\n                }\n            }\n        }\n    }\n\n    return true;\n}\n\nbool checkreturn pb_decode_ex(pb_istream_t *stream, const pb_msgdesc_t *fields, void *dest_struct, unsigned int flags)\n{\n    bool status;\n\n    if ((flags & PB_DECODE_DELIMITED) == 0)\n    {\n      status = pb_decode_inner(stream, fields, dest_struct, flags);\n    }\n    else\n    {\n      pb_istream_t substream;\n      if (!pb_make_string_substream(stream, &substream))\n        return false;\n\n      status = pb_decode_inner(&substream, fields, dest_struct, flags);\n\n      if (!pb_close_string_substream(stream, &substream))\n        return false;\n    }\n    \n#ifdef PB_ENABLE_MALLOC\n    if (!status)\n        pb_release(fields, dest_struct);\n#endif\n    \n    return status;\n}\n\nbool checkreturn pb_decode(pb_istream_t *stream, const pb_msgdesc_t *fields, void *dest_struct)\n{\n    bool status;\n\n    status = pb_decode_inner(stream, fields, dest_struct, 0);\n\n#ifdef PB_ENABLE_MALLOC\n    if (!status)\n        pb_release(fields, dest_struct);\n#endif\n\n    return status;\n}\n\n#ifdef PB_ENABLE_MALLOC\n/* Given an oneof field, if there has already been a field inside this oneof,\n * release it before overwriting with a different one. */\nstatic bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field)\n{\n    pb_field_iter_t old_field = *field;\n    pb_size_t old_tag = *(pb_size_t*)field->pSize; /* Previous which_ value */\n    pb_size_t new_tag = field->tag; /* New which_ value */\n\n    if (old_tag == 0)\n        return true; /* Ok, no old data in union */\n\n    if (old_tag == new_tag)\n        return true; /* Ok, old data is of same type => merge */\n\n    /* Release old data. The find can fail if the message struct contains\n     * invalid data. */\n    if (!pb_field_iter_find(&old_field, old_tag))\n        PB_RETURN_ERROR(stream, \"invalid union tag\");\n\n    pb_release_single_field(&old_field);\n\n    return true;\n}\n\nstatic void pb_release_single_field(pb_field_iter_t *field)\n{\n    pb_type_t type;\n    type = field->type;\n\n    if (PB_HTYPE(type) == PB_HTYPE_ONEOF)\n    {\n        if (*(pb_size_t*)field->pSize != field->tag)\n            return; /* This is not the current field in the union */\n    }\n\n    /* Release anything contained inside an extension or submsg.\n     * This has to be done even if the submsg itself is statically\n     * allocated. */\n    if (PB_LTYPE(type) == PB_LTYPE_EXTENSION)\n    {\n        /* Release fields from all extensions in the linked list */\n        pb_extension_t *ext = *(pb_extension_t**)field->pData;\n        while (ext != NULL)\n        {\n            pb_field_iter_t ext_iter;\n            if (pb_field_iter_begin_extension(&ext_iter, ext))\n            {\n                pb_release_single_field(&ext_iter);\n            }\n            ext = ext->next;\n        }\n    }\n    else if (PB_LTYPE_IS_SUBMSG(type) && PB_ATYPE(type) != PB_ATYPE_CALLBACK)\n    {\n        /* Release fields in submessage or submsg array */\n        pb_size_t count = 1;\n        \n        if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n        {\n            field->pData = *(void**)field->pField;\n        }\n        else\n        {\n            field->pData = field->pField;\n        }\n        \n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED)\n        {\n            count = *(pb_size_t*)field->pSize;\n\n            if (PB_ATYPE(type) == PB_ATYPE_STATIC && count > field->array_size)\n            {\n                /* Protect against corrupted _count fields */\n                count = field->array_size;\n            }\n        }\n        \n        if (field->pData)\n        {\n            for (; count > 0; count--)\n            {\n                pb_release(field->submsg_desc, field->pData);\n                field->pData = (char*)field->pData + field->data_size;\n            }\n        }\n    }\n    \n    if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n    {\n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED &&\n            (PB_LTYPE(type) == PB_LTYPE_STRING ||\n             PB_LTYPE(type) == PB_LTYPE_BYTES))\n        {\n            /* Release entries in repeated string or bytes array */\n            void **pItem = *(void***)field->pField;\n            pb_size_t count = *(pb_size_t*)field->pSize;\n            for (; count > 0; count--)\n            {\n                pb_free(*pItem);\n                *pItem++ = NULL;\n            }\n        }\n        \n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED)\n        {\n            /* We are going to release the array, so set the size to 0 */\n            *(pb_size_t*)field->pSize = 0;\n        }\n        \n        /* Release main pointer */\n        pb_free(*(void**)field->pField);\n        *(void**)field->pField = NULL;\n    }\n}\n\nvoid pb_release(const pb_msgdesc_t *fields, void *dest_struct)\n{\n    pb_field_iter_t iter;\n    \n    if (!dest_struct)\n        return; /* Ignore NULL pointers, similar to free() */\n\n    if (!pb_field_iter_begin(&iter, fields, dest_struct))\n        return; /* Empty message type */\n    \n    do\n    {\n        pb_release_single_field(&iter);\n    } while (pb_field_iter_next(&iter));\n}\n#endif\n\n/* Field decoders */\n\nbool pb_decode_bool(pb_istream_t *stream, bool *dest)\n{\n    uint32_t value;\n    if (!pb_decode_varint32(stream, &value))\n        return false;\n\n    *(bool*)dest = (value != 0);\n    return true;\n}\n\nbool pb_decode_svarint(pb_istream_t *stream, pb_int64_t *dest)\n{\n    pb_uint64_t value;\n    if (!pb_decode_varint(stream, &value))\n        return false;\n    \n    if (value & 1)\n        *dest = (pb_int64_t)(~(value >> 1));\n    else\n        *dest = (pb_int64_t)(value >> 1);\n    \n    return true;\n}\n\nbool pb_decode_fixed32(pb_istream_t *stream, void *dest)\n{\n    union {\n        uint32_t fixed32;\n        pb_byte_t bytes[4];\n    } u;\n\n    if (!pb_read(stream, u.bytes, 4))\n        return false;\n\n#if defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN && CHAR_BIT == 8\n    /* fast path - if we know that we're on little endian, assign directly */\n    *(uint32_t*)dest = u.fixed32;\n#else\n    *(uint32_t*)dest = ((uint32_t)u.bytes[0] << 0) |\n                       ((uint32_t)u.bytes[1] << 8) |\n                       ((uint32_t)u.bytes[2] << 16) |\n                       ((uint32_t)u.bytes[3] << 24);\n#endif\n    return true;\n}\n\n#ifndef PB_WITHOUT_64BIT\nbool pb_decode_fixed64(pb_istream_t *stream, void *dest)\n{\n    union {\n        uint64_t fixed64;\n        pb_byte_t bytes[8];\n    } u;\n\n    if (!pb_read(stream, u.bytes, 8))\n        return false;\n\n#if defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN && CHAR_BIT == 8\n    /* fast path - if we know that we're on little endian, assign directly */\n    *(uint64_t*)dest = u.fixed64;\n#else\n    *(uint64_t*)dest = ((uint64_t)u.bytes[0] << 0) |\n                       ((uint64_t)u.bytes[1] << 8) |\n                       ((uint64_t)u.bytes[2] << 16) |\n                       ((uint64_t)u.bytes[3] << 24) |\n                       ((uint64_t)u.bytes[4] << 32) |\n                       ((uint64_t)u.bytes[5] << 40) |\n                       ((uint64_t)u.bytes[6] << 48) |\n                       ((uint64_t)u.bytes[7] << 56);\n#endif\n    return true;\n}\n#endif\n\nstatic bool checkreturn pb_dec_bool(pb_istream_t *stream, const pb_field_iter_t *field)\n{\n    return pb_decode_bool(stream, (bool*)field->pData);\n}\n\nstatic bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_iter_t *field)\n{\n    if (PB_LTYPE(field->type) == PB_LTYPE_UVARINT)\n    {\n        pb_uint64_t value, clamped;\n        if (!pb_decode_varint(stream, &value))\n            return false;\n\n        /* Cast to the proper field size, while checking for overflows */\n        if (field->data_size == sizeof(pb_uint64_t))\n            clamped = *(pb_uint64_t*)field->pData = value;\n        else if (field->data_size == sizeof(uint32_t))\n            clamped = *(uint32_t*)field->pData = (uint32_t)value;\n        else if (field->data_size == sizeof(uint_least16_t))\n            clamped = *(uint_least16_t*)field->pData = (uint_least16_t)value;\n        else if (field->data_size == sizeof(uint_least8_t))\n            clamped = *(uint_least8_t*)field->pData = (uint_least8_t)value;\n        else\n            PB_RETURN_ERROR(stream, \"invalid data_size\");\n\n        if (clamped != value)\n            PB_RETURN_ERROR(stream, \"integer too large\");\n\n        return true;\n    }\n    else\n    {\n        pb_uint64_t value;\n        pb_int64_t svalue;\n        pb_int64_t clamped;\n\n        if (PB_LTYPE(field->type) == PB_LTYPE_SVARINT)\n        {\n            if (!pb_decode_svarint(stream, &svalue))\n                return false;\n        }\n        else\n        {\n            if (!pb_decode_varint(stream, &value))\n                return false;\n\n            /* See issue 97: Google's C++ protobuf allows negative varint values to\n            * be cast as int32_t, instead of the int64_t that should be used when\n            * encoding. Nanopb versions before 0.2.5 had a bug in encoding. In order to\n            * not break decoding of such messages, we cast <=32 bit fields to\n            * int32_t first to get the sign correct.\n            */\n            if (field->data_size == sizeof(pb_int64_t))\n                svalue = (pb_int64_t)value;\n            else\n                svalue = (int32_t)value;\n        }\n\n        /* Cast to the proper field size, while checking for overflows */\n        if (field->data_size == sizeof(pb_int64_t))\n            clamped = *(pb_int64_t*)field->pData = svalue;\n        else if (field->data_size == sizeof(int32_t))\n            clamped = *(int32_t*)field->pData = (int32_t)svalue;\n        else if (field->data_size == sizeof(int_least16_t))\n            clamped = *(int_least16_t*)field->pData = (int_least16_t)svalue;\n        else if (field->data_size == sizeof(int_least8_t))\n            clamped = *(int_least8_t*)field->pData = (int_least8_t)svalue;\n        else\n            PB_RETURN_ERROR(stream, \"invalid data_size\");\n\n        if (clamped != svalue)\n            PB_RETURN_ERROR(stream, \"integer too large\");\n\n        return true;\n    }\n}\n\nstatic bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_iter_t *field)\n{\n    uint32_t size;\n    size_t alloc_size;\n    pb_bytes_array_t *dest;\n    \n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    \n    if (size > PB_SIZE_MAX)\n        PB_RETURN_ERROR(stream, \"bytes overflow\");\n    \n    alloc_size = PB_BYTES_ARRAY_T_ALLOCSIZE(size);\n    if (size > alloc_size)\n        PB_RETURN_ERROR(stream, \"size too large\");\n    \n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (stream->bytes_left < size)\n            PB_RETURN_ERROR(stream, \"end-of-stream\");\n\n        if (!allocate_field(stream, field->pData, alloc_size, 1))\n            return false;\n        dest = *(pb_bytes_array_t**)field->pData;\n#endif\n    }\n    else\n    {\n        if (alloc_size > field->data_size)\n            PB_RETURN_ERROR(stream, \"bytes overflow\");\n        dest = (pb_bytes_array_t*)field->pData;\n    }\n\n    dest->size = (pb_size_t)size;\n    return pb_read(stream, dest->bytes, (size_t)size);\n}\n\nstatic bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_iter_t *field)\n{\n    uint32_t size;\n    size_t alloc_size;\n    pb_byte_t *dest = (pb_byte_t*)field->pData;\n\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n\n    if (size == (uint32_t)-1)\n        PB_RETURN_ERROR(stream, \"size too large\");\n\n    /* Space for null terminator */\n    alloc_size = (size_t)(size + 1);\n\n    if (alloc_size < size)\n        PB_RETURN_ERROR(stream, \"size too large\");\n\n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (stream->bytes_left < size)\n            PB_RETURN_ERROR(stream, \"end-of-stream\");\n\n        if (!allocate_field(stream, field->pData, alloc_size, 1))\n            return false;\n        dest = *(pb_byte_t**)field->pData;\n#endif\n    }\n    else\n    {\n        if (alloc_size > field->data_size)\n            PB_RETURN_ERROR(stream, \"string overflow\");\n    }\n    \n    dest[size] = 0;\n\n    if (!pb_read(stream, dest, (size_t)size))\n        return false;\n\n#ifdef PB_VALIDATE_UTF8\n    if (!pb_validate_utf8((const char*)dest))\n        PB_RETURN_ERROR(stream, \"invalid utf8\");\n#endif\n\n    return true;\n}\n\nstatic bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_iter_t *field)\n{\n    bool status = true;\n    bool submsg_consumed = false;\n    pb_istream_t substream;\n\n    if (!pb_make_string_substream(stream, &substream))\n        return false;\n    \n    if (field->submsg_desc == NULL)\n        PB_RETURN_ERROR(stream, \"invalid field descriptor\");\n    \n    /* Submessages can have a separate message-level callback that is called\n     * before decoding the message. Typically it is used to set callback fields\n     * inside oneofs. */\n    if (PB_LTYPE(field->type) == PB_LTYPE_SUBMSG_W_CB && field->pSize != NULL)\n    {\n        /* Message callback is stored right before pSize. */\n        pb_callback_t *callback = (pb_callback_t*)field->pSize - 1;\n        if (callback->funcs.decode)\n        {\n            status = callback->funcs.decode(&substream, field, &callback->arg);\n\n            if (substream.bytes_left == 0)\n            {\n                submsg_consumed = true;\n            }\n        }\n    }\n\n    /* Now decode the submessage contents */\n    if (status && !submsg_consumed)\n    {\n        unsigned int flags = 0;\n\n        /* Static required/optional fields are already initialized by top-level\n         * pb_decode(), no need to initialize them again. */\n        if (PB_ATYPE(field->type) == PB_ATYPE_STATIC &&\n            PB_HTYPE(field->type) != PB_HTYPE_REPEATED)\n        {\n            flags = PB_DECODE_NOINIT;\n        }\n\n        status = pb_decode_inner(&substream, field->submsg_desc, field->pData, flags);\n    }\n    \n    if (!pb_close_string_substream(stream, &substream))\n        return false;\n\n    return status;\n}\n\nstatic bool checkreturn pb_dec_fixed_length_bytes(pb_istream_t *stream, const pb_field_iter_t *field)\n{\n    uint32_t size;\n\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n\n    if (size > PB_SIZE_MAX)\n        PB_RETURN_ERROR(stream, \"bytes overflow\");\n\n    if (size == 0)\n    {\n        /* As a special case, treat empty bytes string as all zeros for fixed_length_bytes. */\n        memset(field->pData, 0, (size_t)field->data_size);\n        return true;\n    }\n\n    if (size != field->data_size)\n        PB_RETURN_ERROR(stream, \"incorrect fixed length bytes size\");\n\n    return pb_read(stream, (pb_byte_t*)field->pData, (size_t)field->data_size);\n}\n\n#ifdef PB_CONVERT_DOUBLE_FLOAT\nbool pb_decode_double_as_float(pb_istream_t *stream, float *dest)\n{\n    uint_least8_t sign;\n    int exponent;\n    uint32_t mantissa;\n    uint64_t value;\n    union { float f; uint32_t i; } out;\n\n    if (!pb_decode_fixed64(stream, &value))\n        return false;\n\n    /* Decompose input value */\n    sign = (uint_least8_t)((value >> 63) & 1);\n    exponent = (int)((value >> 52) & 0x7FF) - 1023;\n    mantissa = (value >> 28) & 0xFFFFFF; /* Highest 24 bits */\n\n    /* Figure if value is in range representable by floats. */\n    if (exponent == 1024)\n    {\n        /* Special value */\n        exponent = 128;\n        mantissa >>= 1;\n    }\n    else\n    {\n        if (exponent > 127)\n        {\n            /* Too large, convert to infinity */\n            exponent = 128;\n            mantissa = 0;\n        }\n        else if (exponent < -150)\n        {\n            /* Too small, convert to zero */\n            exponent = -127;\n            mantissa = 0;\n        }\n        else if (exponent < -126)\n        {\n            /* Denormalized */\n            mantissa |= 0x1000000;\n            mantissa >>= (-126 - exponent);\n            exponent = -127;\n        }\n\n        /* Round off mantissa */\n        mantissa = (mantissa + 1) >> 1;\n\n        /* Check if mantissa went over 2.0 */\n        if (mantissa & 0x800000)\n        {\n            exponent += 1;\n            mantissa &= 0x7FFFFF;\n            mantissa >>= 1;\n        }\n    }\n\n    /* Combine fields */\n    out.i = mantissa;\n    out.i |= (uint32_t)(exponent + 127) << 23;\n    out.i |= (uint32_t)sign << 31;\n\n    *dest = out.f;\n    return true;\n}\n#endif\n"], "fixing_code": ["/* pb_decode.c -- decode a protobuf using minimal resources\n *\n * 2011 Petteri Aimonen <jpa@kapsi.fi>\n */\n\n/* Use the GCC warn_unused_result attribute to check that all return values\n * are propagated correctly. On other compilers and gcc before 3.4.0 just\n * ignore the annotation.\n */\n#if !defined(__GNUC__) || ( __GNUC__ < 3) || (__GNUC__ == 3 && __GNUC_MINOR__ < 4)\n    #define checkreturn\n#else\n    #define checkreturn __attribute__((warn_unused_result))\n#endif\n\n#include \"pb.h\"\n#include \"pb_decode.h\"\n#include \"pb_common.h\"\n\n/**************************************\n * Declarations internal to this file *\n **************************************/\n\nstatic bool checkreturn buf_read(pb_istream_t *stream, pb_byte_t *buf, size_t count);\nstatic bool checkreturn pb_decode_varint32_eof(pb_istream_t *stream, uint32_t *dest, bool *eof);\nstatic bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, pb_byte_t *buf, size_t *size);\nstatic bool checkreturn decode_basic_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field);\nstatic bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field);\nstatic bool checkreturn decode_pointer_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field);\nstatic bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field);\nstatic bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field);\nstatic bool checkreturn default_extension_decoder(pb_istream_t *stream, pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type);\nstatic bool checkreturn decode_extension(pb_istream_t *stream, uint32_t tag, pb_wire_type_t wire_type, pb_extension_t *extension);\nstatic bool pb_field_set_to_default(pb_field_iter_t *field);\nstatic bool pb_message_set_to_defaults(pb_field_iter_t *iter);\nstatic bool checkreturn pb_dec_bool(pb_istream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_dec_fixed_length_bytes(pb_istream_t *stream, const pb_field_iter_t *field);\nstatic bool checkreturn pb_skip_varint(pb_istream_t *stream);\nstatic bool checkreturn pb_skip_string(pb_istream_t *stream);\n\n#ifdef PB_ENABLE_MALLOC\nstatic bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size);\nstatic void initialize_pointer_field(void *pItem, pb_field_iter_t *field);\nstatic bool checkreturn pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field);\nstatic void pb_release_single_field(pb_field_iter_t *field);\n#endif\n\n#ifdef PB_WITHOUT_64BIT\n#define pb_int64_t int32_t\n#define pb_uint64_t uint32_t\n#else\n#define pb_int64_t int64_t\n#define pb_uint64_t uint64_t\n#endif\n\n#define PB_WT_PACKED ((pb_wire_type_t)0xFF)\n\ntypedef struct {\n    uint32_t bitfield[(PB_MAX_REQUIRED_FIELDS + 31) / 32];\n} pb_fields_seen_t;\n\n/*******************************\n * pb_istream_t implementation *\n *******************************/\n\nstatic bool checkreturn buf_read(pb_istream_t *stream, pb_byte_t *buf, size_t count)\n{\n    size_t i;\n    const pb_byte_t *source = (const pb_byte_t*)stream->state;\n    stream->state = (pb_byte_t*)stream->state + count;\n    \n    if (buf != NULL)\n    {\n        for (i = 0; i < count; i++)\n            buf[i] = source[i];\n    }\n    \n    return true;\n}\n\nbool checkreturn pb_read(pb_istream_t *stream, pb_byte_t *buf, size_t count)\n{\n    if (count == 0)\n        return true;\n\n#ifndef PB_BUFFER_ONLY\n\tif (buf == NULL && stream->callback != buf_read)\n\t{\n\t\t/* Skip input bytes */\n\t\tpb_byte_t tmp[16];\n\t\twhile (count > 16)\n\t\t{\n\t\t\tif (!pb_read(stream, tmp, 16))\n\t\t\t\treturn false;\n\t\t\t\n\t\t\tcount -= 16;\n\t\t}\n\t\t\n\t\treturn pb_read(stream, tmp, count);\n\t}\n#endif\n\n    if (stream->bytes_left < count)\n        PB_RETURN_ERROR(stream, \"end-of-stream\");\n    \n#ifndef PB_BUFFER_ONLY\n    if (!stream->callback(stream, buf, count))\n        PB_RETURN_ERROR(stream, \"io error\");\n#else\n    if (!buf_read(stream, buf, count))\n        return false;\n#endif\n    \n    stream->bytes_left -= count;\n    return true;\n}\n\n/* Read a single byte from input stream. buf may not be NULL.\n * This is an optimization for the varint decoding. */\nstatic bool checkreturn pb_readbyte(pb_istream_t *stream, pb_byte_t *buf)\n{\n    if (stream->bytes_left == 0)\n        PB_RETURN_ERROR(stream, \"end-of-stream\");\n\n#ifndef PB_BUFFER_ONLY\n    if (!stream->callback(stream, buf, 1))\n        PB_RETURN_ERROR(stream, \"io error\");\n#else\n    *buf = *(const pb_byte_t*)stream->state;\n    stream->state = (pb_byte_t*)stream->state + 1;\n#endif\n\n    stream->bytes_left--;\n    \n    return true;    \n}\n\npb_istream_t pb_istream_from_buffer(const pb_byte_t *buf, size_t msglen)\n{\n    pb_istream_t stream;\n    /* Cast away the const from buf without a compiler error.  We are\n     * careful to use it only in a const manner in the callbacks.\n     */\n    union {\n        void *state;\n        const void *c_state;\n    } state;\n#ifdef PB_BUFFER_ONLY\n    stream.callback = NULL;\n#else\n    stream.callback = &buf_read;\n#endif\n    state.c_state = buf;\n    stream.state = state.state;\n    stream.bytes_left = msglen;\n#ifndef PB_NO_ERRMSG\n    stream.errmsg = NULL;\n#endif\n    return stream;\n}\n\n/********************\n * Helper functions *\n ********************/\n\nstatic bool checkreturn pb_decode_varint32_eof(pb_istream_t *stream, uint32_t *dest, bool *eof)\n{\n    pb_byte_t byte;\n    uint32_t result;\n    \n    if (!pb_readbyte(stream, &byte))\n    {\n        if (stream->bytes_left == 0)\n        {\n            if (eof)\n            {\n                *eof = true;\n            }\n        }\n\n        return false;\n    }\n    \n    if ((byte & 0x80) == 0)\n    {\n        /* Quick case, 1 byte value */\n        result = byte;\n    }\n    else\n    {\n        /* Multibyte case */\n        uint_fast8_t bitpos = 7;\n        result = byte & 0x7F;\n        \n        do\n        {\n            if (!pb_readbyte(stream, &byte))\n                return false;\n            \n            if (bitpos >= 32)\n            {\n                /* Note: The varint could have trailing 0x80 bytes, or 0xFF for negative. */\n                pb_byte_t sign_extension = (bitpos < 63) ? 0xFF : 0x01;\n                bool valid_extension = ((byte & 0x7F) == 0x00 ||\n                         ((result >> 31) != 0 && byte == sign_extension));\n\n                if (bitpos >= 64 || !valid_extension)\n                {\n                    PB_RETURN_ERROR(stream, \"varint overflow\");\n                }\n            }\n            else\n            {\n                result |= (uint32_t)(byte & 0x7F) << bitpos;\n            }\n            bitpos = (uint_fast8_t)(bitpos + 7);\n        } while (byte & 0x80);\n        \n        if (bitpos == 35 && (byte & 0x70) != 0)\n        {\n            /* The last byte was at bitpos=28, so only bottom 4 bits fit. */\n            PB_RETURN_ERROR(stream, \"varint overflow\");\n        }\n   }\n   \n   *dest = result;\n   return true;\n}\n\nbool checkreturn pb_decode_varint32(pb_istream_t *stream, uint32_t *dest)\n{\n    return pb_decode_varint32_eof(stream, dest, NULL);\n}\n\n#ifndef PB_WITHOUT_64BIT\nbool checkreturn pb_decode_varint(pb_istream_t *stream, uint64_t *dest)\n{\n    pb_byte_t byte;\n    uint_fast8_t bitpos = 0;\n    uint64_t result = 0;\n    \n    do\n    {\n        if (bitpos >= 64)\n            PB_RETURN_ERROR(stream, \"varint overflow\");\n        \n        if (!pb_readbyte(stream, &byte))\n            return false;\n\n        result |= (uint64_t)(byte & 0x7F) << bitpos;\n        bitpos = (uint_fast8_t)(bitpos + 7);\n    } while (byte & 0x80);\n    \n    *dest = result;\n    return true;\n}\n#endif\n\nbool checkreturn pb_skip_varint(pb_istream_t *stream)\n{\n    pb_byte_t byte;\n    do\n    {\n        if (!pb_read(stream, &byte, 1))\n            return false;\n    } while (byte & 0x80);\n    return true;\n}\n\nbool checkreturn pb_skip_string(pb_istream_t *stream)\n{\n    uint32_t length;\n    if (!pb_decode_varint32(stream, &length))\n        return false;\n    \n    if ((size_t)length != length)\n    {\n        PB_RETURN_ERROR(stream, \"size too large\");\n    }\n\n    return pb_read(stream, NULL, (size_t)length);\n}\n\nbool checkreturn pb_decode_tag(pb_istream_t *stream, pb_wire_type_t *wire_type, uint32_t *tag, bool *eof)\n{\n    uint32_t temp;\n    *eof = false;\n    *wire_type = (pb_wire_type_t) 0;\n    *tag = 0;\n    \n    if (!pb_decode_varint32_eof(stream, &temp, eof))\n    {\n        return false;\n    }\n    \n    *tag = temp >> 3;\n    *wire_type = (pb_wire_type_t)(temp & 7);\n    return true;\n}\n\nbool checkreturn pb_skip_field(pb_istream_t *stream, pb_wire_type_t wire_type)\n{\n    switch (wire_type)\n    {\n        case PB_WT_VARINT: return pb_skip_varint(stream);\n        case PB_WT_64BIT: return pb_read(stream, NULL, 8);\n        case PB_WT_STRING: return pb_skip_string(stream);\n        case PB_WT_32BIT: return pb_read(stream, NULL, 4);\n        default: PB_RETURN_ERROR(stream, \"invalid wire_type\");\n    }\n}\n\n/* Read a raw value to buffer, for the purpose of passing it to callback as\n * a substream. Size is maximum size on call, and actual size on return.\n */\nstatic bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, pb_byte_t *buf, size_t *size)\n{\n    size_t max_size = *size;\n    switch (wire_type)\n    {\n        case PB_WT_VARINT:\n            *size = 0;\n            do\n            {\n                (*size)++;\n                if (*size > max_size)\n                    PB_RETURN_ERROR(stream, \"varint overflow\");\n\n                if (!pb_read(stream, buf, 1))\n                    return false;\n            } while (*buf++ & 0x80);\n            return true;\n            \n        case PB_WT_64BIT:\n            *size = 8;\n            return pb_read(stream, buf, 8);\n        \n        case PB_WT_32BIT:\n            *size = 4;\n            return pb_read(stream, buf, 4);\n        \n        case PB_WT_STRING:\n            /* Calling read_raw_value with a PB_WT_STRING is an error.\n             * Explicitly handle this case and fallthrough to default to avoid\n             * compiler warnings.\n             */\n\n        default: PB_RETURN_ERROR(stream, \"invalid wire_type\");\n    }\n}\n\n/* Decode string length from stream and return a substream with limited length.\n * Remember to close the substream using pb_close_string_substream().\n */\nbool checkreturn pb_make_string_substream(pb_istream_t *stream, pb_istream_t *substream)\n{\n    uint32_t size;\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    \n    *substream = *stream;\n    if (substream->bytes_left < size)\n        PB_RETURN_ERROR(stream, \"parent stream too short\");\n    \n    substream->bytes_left = (size_t)size;\n    stream->bytes_left -= (size_t)size;\n    return true;\n}\n\nbool checkreturn pb_close_string_substream(pb_istream_t *stream, pb_istream_t *substream)\n{\n    if (substream->bytes_left) {\n        if (!pb_read(substream, NULL, substream->bytes_left))\n            return false;\n    }\n\n    stream->state = substream->state;\n\n#ifndef PB_NO_ERRMSG\n    stream->errmsg = substream->errmsg;\n#endif\n    return true;\n}\n\n/*************************\n * Decode a single field *\n *************************/\n\nstatic bool checkreturn decode_basic_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field)\n{\n    switch (PB_LTYPE(field->type))\n    {\n        case PB_LTYPE_BOOL:\n            if (wire_type != PB_WT_VARINT && wire_type != PB_WT_PACKED)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_dec_bool(stream, field);\n\n        case PB_LTYPE_VARINT:\n        case PB_LTYPE_UVARINT:\n        case PB_LTYPE_SVARINT:\n            if (wire_type != PB_WT_VARINT && wire_type != PB_WT_PACKED)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_dec_varint(stream, field);\n\n        case PB_LTYPE_FIXED32:\n            if (wire_type != PB_WT_32BIT && wire_type != PB_WT_PACKED)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_decode_fixed32(stream, field->pData);\n\n        case PB_LTYPE_FIXED64:\n            if (wire_type != PB_WT_64BIT && wire_type != PB_WT_PACKED)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n#ifdef PB_CONVERT_DOUBLE_FLOAT\n            if (field->data_size == sizeof(float))\n            {\n                return pb_decode_double_as_float(stream, (float*)field->pData);\n            }\n#endif\n\n#ifdef PB_WITHOUT_64BIT\n            PB_RETURN_ERROR(stream, \"invalid data_size\");\n#else\n            return pb_decode_fixed64(stream, field->pData);\n#endif\n\n        case PB_LTYPE_BYTES:\n            if (wire_type != PB_WT_STRING)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_dec_bytes(stream, field);\n\n        case PB_LTYPE_STRING:\n            if (wire_type != PB_WT_STRING)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_dec_string(stream, field);\n\n        case PB_LTYPE_SUBMESSAGE:\n        case PB_LTYPE_SUBMSG_W_CB:\n            if (wire_type != PB_WT_STRING)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_dec_submessage(stream, field);\n\n        case PB_LTYPE_FIXED_LENGTH_BYTES:\n            if (wire_type != PB_WT_STRING)\n                PB_RETURN_ERROR(stream, \"wrong wire type\");\n\n            return pb_dec_fixed_length_bytes(stream, field);\n\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}\n\nstatic bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field)\n{\n    switch (PB_HTYPE(field->type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return decode_basic_field(stream, wire_type, field);\n            \n        case PB_HTYPE_OPTIONAL:\n            if (field->pSize != NULL)\n                *(bool*)field->pSize = true;\n            return decode_basic_field(stream, wire_type, field);\n    \n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(field->type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                /* Packed array */\n                bool status = true;\n                pb_istream_t substream;\n                pb_size_t *size = (pb_size_t*)field->pSize;\n                field->pData = (char*)field->pField + field->data_size * (*size);\n\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n\n                while (substream.bytes_left > 0 && *size < field->array_size)\n                {\n                    if (!decode_basic_field(&substream, PB_WT_PACKED, field))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                    field->pData = (char*)field->pData + field->data_size;\n                }\n\n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n\n                return status;\n            }\n            else\n            {\n                /* Repeated field */\n                pb_size_t *size = (pb_size_t*)field->pSize;\n                field->pData = (char*)field->pField + field->data_size * (*size);\n\n                if ((*size)++ >= field->array_size)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n\n                return decode_basic_field(stream, wire_type, field);\n            }\n\n        case PB_HTYPE_ONEOF:\n            if (PB_LTYPE_IS_SUBMSG(field->type) &&\n                *(pb_size_t*)field->pSize != field->tag)\n            {\n                /* We memset to zero so that any callbacks are set to NULL.\n                 * This is because the callbacks might otherwise have values\n                 * from some other union field.\n                 * If callbacks are needed inside oneof field, use .proto\n                 * option submsg_callback to have a separate callback function\n                 * that can set the fields before submessage is decoded.\n                 * pb_dec_submessage() will set any default values. */\n                memset(field->pData, 0, (size_t)field->data_size);\n\n                /* Set default values for the submessage fields. */\n                if (field->submsg_desc->default_value != NULL ||\n                    field->submsg_desc->field_callback != NULL ||\n                    field->submsg_desc->submsg_info[0] != NULL)\n                {\n                    pb_field_iter_t submsg_iter;\n                    if (pb_field_iter_begin(&submsg_iter, field->submsg_desc, field->pData))\n                    {\n                        if (!pb_message_set_to_defaults(&submsg_iter))\n                            PB_RETURN_ERROR(stream, \"failed to set defaults\");\n                    }\n                }\n            }\n            *(pb_size_t*)field->pSize = field->tag;\n\n            return decode_basic_field(stream, wire_type, field);\n\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}\n\n#ifdef PB_ENABLE_MALLOC\n/* Allocate storage for the field and store the pointer at iter->pData.\n * array_size is the number of entries to reserve in an array.\n * Zero size is not allowed, use pb_free() for releasing.\n */\nstatic bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size)\n{    \n    void *ptr = *(void**)pData;\n    \n    if (data_size == 0 || array_size == 0)\n        PB_RETURN_ERROR(stream, \"invalid size\");\n    \n#ifdef __AVR__\n    /* Workaround for AVR libc bug 53284: http://savannah.nongnu.org/bugs/?53284\n     * Realloc to size of 1 byte can cause corruption of the malloc structures.\n     */\n    if (data_size == 1 && array_size == 1)\n    {\n        data_size = 2;\n    }\n#endif\n\n    /* Check for multiplication overflows.\n     * This code avoids the costly division if the sizes are small enough.\n     * Multiplication is safe as long as only half of bits are set\n     * in either multiplicand.\n     */\n    {\n        const size_t check_limit = (size_t)1 << (sizeof(size_t) * 4);\n        if (data_size >= check_limit || array_size >= check_limit)\n        {\n            const size_t size_max = (size_t)-1;\n            if (size_max / array_size < data_size)\n            {\n                PB_RETURN_ERROR(stream, \"size too large\");\n            }\n        }\n    }\n    \n    /* Allocate new or expand previous allocation */\n    /* Note: on failure the old pointer will remain in the structure,\n     * the message must be freed by caller also on error return. */\n    ptr = pb_realloc(ptr, array_size * data_size);\n    if (ptr == NULL)\n        PB_RETURN_ERROR(stream, \"realloc failed\");\n    \n    *(void**)pData = ptr;\n    return true;\n}\n\n/* Clear a newly allocated item in case it contains a pointer, or is a submessage. */\nstatic void initialize_pointer_field(void *pItem, pb_field_iter_t *field)\n{\n    if (PB_LTYPE(field->type) == PB_LTYPE_STRING ||\n        PB_LTYPE(field->type) == PB_LTYPE_BYTES)\n    {\n        *(void**)pItem = NULL;\n    }\n    else if (PB_LTYPE_IS_SUBMSG(field->type))\n    {\n        /* We memset to zero so that any callbacks are set to NULL.\n         * Default values will be set by pb_dec_submessage(). */\n        memset(pItem, 0, field->data_size);\n    }\n}\n#endif\n\nstatic bool checkreturn decode_pointer_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field)\n{\n#ifndef PB_ENABLE_MALLOC\n    PB_UNUSED(wire_type);\n    PB_UNUSED(field);\n    PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n    switch (PB_HTYPE(field->type))\n    {\n        case PB_HTYPE_REQUIRED:\n        case PB_HTYPE_OPTIONAL:\n        case PB_HTYPE_ONEOF:\n            if (PB_LTYPE_IS_SUBMSG(field->type) && *(void**)field->pField != NULL)\n            {\n                /* Duplicate field, have to release the old allocation first. */\n                /* FIXME: Does this work correctly for oneofs? */\n                pb_release_single_field(field);\n            }\n        \n            if (PB_HTYPE(field->type) == PB_HTYPE_ONEOF)\n            {\n                *(pb_size_t*)field->pSize = field->tag;\n            }\n\n            if (PB_LTYPE(field->type) == PB_LTYPE_STRING ||\n                PB_LTYPE(field->type) == PB_LTYPE_BYTES)\n            {\n                /* pb_dec_string and pb_dec_bytes handle allocation themselves */\n                field->pData = field->pField;\n                return decode_basic_field(stream, wire_type, field);\n            }\n            else\n            {\n                if (!allocate_field(stream, field->pField, field->data_size, 1))\n                    return false;\n                \n                field->pData = *(void**)field->pField;\n                initialize_pointer_field(field->pData, field);\n                return decode_basic_field(stream, wire_type, field);\n            }\n    \n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(field->type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                /* Packed array, multiple items come in at once. */\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)field->pSize;\n                size_t allocated_size = *size;\n                pb_istream_t substream;\n                \n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n                \n                while (substream.bytes_left)\n                {\n                    if (*size == PB_SIZE_MAX)\n                    {\n#ifndef PB_NO_ERRMSG\n                        stream->errmsg = \"too many array entries\";\n#endif\n                        status = false;\n                        break;\n                    }\n\n                    if ((size_t)*size + 1 > allocated_size)\n                    {\n                        /* Allocate more storage. This tries to guess the\n                         * number of remaining entries. Round the division\n                         * upwards. */\n                        size_t remain = (substream.bytes_left - 1) / field->data_size + 1;\n                        if (remain < PB_SIZE_MAX - allocated_size)\n                            allocated_size += remain;\n                        else\n                            allocated_size += 1;\n                        \n                        if (!allocate_field(&substream, field->pField, field->data_size, allocated_size))\n                        {\n                            status = false;\n                            break;\n                        }\n                    }\n\n                    /* Decode the array entry */\n                    field->pData = *(char**)field->pField + field->data_size * (*size);\n                    initialize_pointer_field(field->pData, field);\n                    if (!decode_basic_field(&substream, PB_WT_PACKED, field))\n                    {\n                        status = false;\n                        break;\n                    }\n                    \n                    (*size)++;\n                }\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n                \n                return status;\n            }\n            else\n            {\n                /* Normal repeated field, i.e. only one item at a time. */\n                pb_size_t *size = (pb_size_t*)field->pSize;\n\n                if (*size == PB_SIZE_MAX)\n                    PB_RETURN_ERROR(stream, \"too many array entries\");\n                \n                if (!allocate_field(stream, field->pField, field->data_size, (size_t)(*size + 1)))\n                    return false;\n            \n                field->pData = *(char**)field->pField + field->data_size * (*size);\n                (*size)++;\n                initialize_pointer_field(field->pData, field);\n                return decode_basic_field(stream, wire_type, field);\n            }\n\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n#endif\n}\n\nstatic bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field)\n{\n    if (!field->descriptor->field_callback)\n        return pb_skip_field(stream, wire_type);\n\n    if (wire_type == PB_WT_STRING)\n    {\n        pb_istream_t substream;\n        size_t prev_bytes_left;\n        \n        if (!pb_make_string_substream(stream, &substream))\n            return false;\n        \n        do\n        {\n            prev_bytes_left = substream.bytes_left;\n            if (!field->descriptor->field_callback(&substream, NULL, field))\n                PB_RETURN_ERROR(stream, \"callback failed\");\n        } while (substream.bytes_left > 0 && substream.bytes_left < prev_bytes_left);\n        \n        if (!pb_close_string_substream(stream, &substream))\n            return false;\n\n        return true;\n    }\n    else\n    {\n        /* Copy the single scalar value to stack.\n         * This is required so that we can limit the stream length,\n         * which in turn allows to use same callback for packed and\n         * not-packed fields. */\n        pb_istream_t substream;\n        pb_byte_t buffer[10];\n        size_t size = sizeof(buffer);\n        \n        if (!read_raw_value(stream, wire_type, buffer, &size))\n            return false;\n        substream = pb_istream_from_buffer(buffer, size);\n        \n        return field->descriptor->field_callback(&substream, NULL, field);\n    }\n}\n\nstatic bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *field)\n{\n#ifdef PB_ENABLE_MALLOC\n    /* When decoding an oneof field, check if there is old data that must be\n     * released first. */\n    if (PB_HTYPE(field->type) == PB_HTYPE_ONEOF)\n    {\n        if (!pb_release_union_field(stream, field))\n            return false;\n    }\n#endif\n\n    switch (PB_ATYPE(field->type))\n    {\n        case PB_ATYPE_STATIC:\n            return decode_static_field(stream, wire_type, field);\n        \n        case PB_ATYPE_POINTER:\n            return decode_pointer_field(stream, wire_type, field);\n        \n        case PB_ATYPE_CALLBACK:\n            return decode_callback_field(stream, wire_type, field);\n        \n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}\n\n/* Default handler for extension fields. Expects to have a pb_msgdesc_t\n * pointer in the extension->type->arg field, pointing to a message with\n * only one field in it.  */\nstatic bool checkreturn default_extension_decoder(pb_istream_t *stream,\n    pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type)\n{\n    pb_field_iter_t iter;\n\n    if (!pb_field_iter_begin_extension(&iter, extension))\n        PB_RETURN_ERROR(stream, \"invalid extension\");\n\n    if (iter.tag != tag || !iter.message)\n        return true;\n\n    extension->found = true;\n    return decode_field(stream, wire_type, &iter);\n}\n\n/* Try to decode an unknown field as an extension field. Tries each extension\n * decoder in turn, until one of them handles the field or loop ends. */\nstatic bool checkreturn decode_extension(pb_istream_t *stream,\n    uint32_t tag, pb_wire_type_t wire_type, pb_extension_t *extension)\n{\n    size_t pos = stream->bytes_left;\n    \n    while (extension != NULL && pos == stream->bytes_left)\n    {\n        bool status;\n        if (extension->type->decode)\n            status = extension->type->decode(stream, extension, tag, wire_type);\n        else\n            status = default_extension_decoder(stream, extension, tag, wire_type);\n\n        if (!status)\n            return false;\n        \n        extension = extension->next;\n    }\n    \n    return true;\n}\n\n/* Initialize message fields to default values, recursively */\nstatic bool pb_field_set_to_default(pb_field_iter_t *field)\n{\n    pb_type_t type;\n    type = field->type;\n\n    if (PB_LTYPE(type) == PB_LTYPE_EXTENSION)\n    {\n        pb_extension_t *ext = *(pb_extension_t* const *)field->pData;\n        while (ext != NULL)\n        {\n            pb_field_iter_t ext_iter;\n            if (pb_field_iter_begin_extension(&ext_iter, ext))\n            {\n                ext->found = false;\n                if (!pb_message_set_to_defaults(&ext_iter))\n                    return false;\n            }\n            ext = ext->next;\n        }\n    }\n    else if (PB_ATYPE(type) == PB_ATYPE_STATIC)\n    {\n        bool init_data = true;\n        if (PB_HTYPE(type) == PB_HTYPE_OPTIONAL && field->pSize != NULL)\n        {\n            /* Set has_field to false. Still initialize the optional field\n             * itself also. */\n            *(bool*)field->pSize = false;\n        }\n        else if (PB_HTYPE(type) == PB_HTYPE_REPEATED ||\n                 PB_HTYPE(type) == PB_HTYPE_ONEOF)\n        {\n            /* REPEATED: Set array count to 0, no need to initialize contents.\n               ONEOF: Set which_field to 0. */\n            *(pb_size_t*)field->pSize = 0;\n            init_data = false;\n        }\n\n        if (init_data)\n        {\n            if (PB_LTYPE_IS_SUBMSG(field->type) &&\n                (field->submsg_desc->default_value != NULL ||\n                 field->submsg_desc->field_callback != NULL ||\n                 field->submsg_desc->submsg_info[0] != NULL))\n            {\n                /* Initialize submessage to defaults.\n                 * Only needed if it has default values\n                 * or callback/submessage fields. */\n                pb_field_iter_t submsg_iter;\n                if (pb_field_iter_begin(&submsg_iter, field->submsg_desc, field->pData))\n                {\n                    if (!pb_message_set_to_defaults(&submsg_iter))\n                        return false;\n                }\n            }\n            else\n            {\n                /* Initialize to zeros */\n                memset(field->pData, 0, (size_t)field->data_size);\n            }\n        }\n    }\n    else if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n    {\n        /* Initialize the pointer to NULL. */\n        *(void**)field->pField = NULL;\n\n        /* Initialize array count to 0. */\n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED ||\n            PB_HTYPE(type) == PB_HTYPE_ONEOF)\n        {\n            *(pb_size_t*)field->pSize = 0;\n        }\n    }\n    else if (PB_ATYPE(type) == PB_ATYPE_CALLBACK)\n    {\n        /* Don't overwrite callback */\n    }\n\n    return true;\n}\n\nstatic bool pb_message_set_to_defaults(pb_field_iter_t *iter)\n{\n    pb_istream_t defstream = PB_ISTREAM_EMPTY;\n    uint32_t tag = 0;\n    pb_wire_type_t wire_type = PB_WT_VARINT;\n    bool eof;\n\n    if (iter->descriptor->default_value)\n    {\n        defstream = pb_istream_from_buffer(iter->descriptor->default_value, (size_t)-1);\n        if (!pb_decode_tag(&defstream, &wire_type, &tag, &eof))\n            return false;\n    }\n\n    do\n    {\n        if (!pb_field_set_to_default(iter))\n            return false;\n\n        if (tag != 0 && iter->tag == tag)\n        {\n            /* We have a default value for this field in the defstream */\n            if (!decode_field(&defstream, wire_type, iter))\n                return false;\n            if (!pb_decode_tag(&defstream, &wire_type, &tag, &eof))\n                return false;\n\n            if (iter->pSize)\n                *(bool*)iter->pSize = false;\n        }\n    } while (pb_field_iter_next(iter));\n\n    return true;\n}\n\n/*********************\n * Decode all fields *\n *********************/\n\nstatic bool checkreturn pb_decode_inner(pb_istream_t *stream, const pb_msgdesc_t *fields, void *dest_struct, unsigned int flags)\n{\n    uint32_t extension_range_start = 0;\n    pb_extension_t *extensions = NULL;\n\n    /* 'fixed_count_field' and 'fixed_count_size' track position of a repeated fixed\n     * count field. This can only handle _one_ repeated fixed count field that\n     * is unpacked and unordered among other (non repeated fixed count) fields.\n     */\n    pb_size_t fixed_count_field = PB_SIZE_MAX;\n    pb_size_t fixed_count_size = 0;\n    pb_size_t fixed_count_total_size = 0;\n\n    pb_fields_seen_t fields_seen = {{0, 0}};\n    const uint32_t allbits = ~(uint32_t)0;\n    pb_field_iter_t iter;\n\n    if (pb_field_iter_begin(&iter, fields, dest_struct))\n    {\n        if ((flags & PB_DECODE_NOINIT) == 0)\n        {\n            if (!pb_message_set_to_defaults(&iter))\n                PB_RETURN_ERROR(stream, \"failed to set defaults\");\n        }\n    }\n\n    while (stream->bytes_left)\n    {\n        uint32_t tag;\n        pb_wire_type_t wire_type;\n        bool eof;\n\n        if (!pb_decode_tag(stream, &wire_type, &tag, &eof))\n        {\n            if (eof)\n                break;\n            else\n                return false;\n        }\n\n        if (tag == 0)\n        {\n          if (flags & PB_DECODE_NULLTERMINATED)\n          {\n            break;\n          }\n          else\n          {\n            PB_RETURN_ERROR(stream, \"zero tag\");\n          }\n        }\n\n        if (!pb_field_iter_find(&iter, tag) || PB_LTYPE(iter.type) == PB_LTYPE_EXTENSION)\n        {\n            /* No match found, check if it matches an extension. */\n            if (extension_range_start == 0)\n            {\n                if (pb_field_iter_find_extension(&iter))\n                {\n                    extensions = *(pb_extension_t* const *)iter.pData;\n                    extension_range_start = iter.tag;\n                }\n\n                if (!extensions)\n                {\n                    extension_range_start = (uint32_t)-1;\n                }\n            }\n\n            if (tag >= extension_range_start)\n            {\n                size_t pos = stream->bytes_left;\n\n                if (!decode_extension(stream, tag, wire_type, extensions))\n                    return false;\n\n                if (pos != stream->bytes_left)\n                {\n                    /* The field was handled */\n                    continue;\n                }\n            }\n\n            /* No match found, skip data */\n            if (!pb_skip_field(stream, wire_type))\n                return false;\n            continue;\n        }\n\n        /* If a repeated fixed count field was found, get size from\n         * 'fixed_count_field' as there is no counter contained in the struct.\n         */\n        if (PB_HTYPE(iter.type) == PB_HTYPE_REPEATED && iter.pSize == &iter.array_size)\n        {\n            if (fixed_count_field != iter.index) {\n                /* If the new fixed count field does not match the previous one,\n                 * check that the previous one is NULL or that it finished\n                 * receiving all the expected data.\n                 */\n                if (fixed_count_field != PB_SIZE_MAX &&\n                    fixed_count_size != fixed_count_total_size)\n                {\n                    PB_RETURN_ERROR(stream, \"wrong size for fixed count field\");\n                }\n\n                fixed_count_field = iter.index;\n                fixed_count_size = 0;\n                fixed_count_total_size = iter.array_size;\n            }\n\n            iter.pSize = &fixed_count_size;\n        }\n\n        if (PB_HTYPE(iter.type) == PB_HTYPE_REQUIRED\n            && iter.required_field_index < PB_MAX_REQUIRED_FIELDS)\n        {\n            uint32_t tmp = ((uint32_t)1 << (iter.required_field_index & 31));\n            fields_seen.bitfield[iter.required_field_index >> 5] |= tmp;\n        }\n\n        if (!decode_field(stream, wire_type, &iter))\n            return false;\n    }\n\n    /* Check that all elements of the last decoded fixed count field were present. */\n    if (fixed_count_field != PB_SIZE_MAX &&\n        fixed_count_size != fixed_count_total_size)\n    {\n        PB_RETURN_ERROR(stream, \"wrong size for fixed count field\");\n    }\n\n    /* Check that all required fields were present. */\n    {\n        pb_size_t req_field_count = iter.descriptor->required_field_count;\n\n        if (req_field_count > 0)\n        {\n            pb_size_t i;\n\n            if (req_field_count > PB_MAX_REQUIRED_FIELDS)\n                req_field_count = PB_MAX_REQUIRED_FIELDS;\n\n            /* Check the whole words */\n            for (i = 0; i < (req_field_count >> 5); i++)\n            {\n                if (fields_seen.bitfield[i] != allbits)\n                    PB_RETURN_ERROR(stream, \"missing required field\");\n            }\n\n            /* Check the remaining bits (if any) */\n            if ((req_field_count & 31) != 0)\n            {\n                if (fields_seen.bitfield[req_field_count >> 5] !=\n                    (allbits >> (uint_least8_t)(32 - (req_field_count & 31))))\n                {\n                    PB_RETURN_ERROR(stream, \"missing required field\");\n                }\n            }\n        }\n    }\n\n    return true;\n}\n\nbool checkreturn pb_decode_ex(pb_istream_t *stream, const pb_msgdesc_t *fields, void *dest_struct, unsigned int flags)\n{\n    bool status;\n\n    if ((flags & PB_DECODE_DELIMITED) == 0)\n    {\n      status = pb_decode_inner(stream, fields, dest_struct, flags);\n    }\n    else\n    {\n      pb_istream_t substream;\n      if (!pb_make_string_substream(stream, &substream))\n        return false;\n\n      status = pb_decode_inner(&substream, fields, dest_struct, flags);\n\n      if (!pb_close_string_substream(stream, &substream))\n        return false;\n    }\n    \n#ifdef PB_ENABLE_MALLOC\n    if (!status)\n        pb_release(fields, dest_struct);\n#endif\n    \n    return status;\n}\n\nbool checkreturn pb_decode(pb_istream_t *stream, const pb_msgdesc_t *fields, void *dest_struct)\n{\n    bool status;\n\n    status = pb_decode_inner(stream, fields, dest_struct, 0);\n\n#ifdef PB_ENABLE_MALLOC\n    if (!status)\n        pb_release(fields, dest_struct);\n#endif\n\n    return status;\n}\n\n#ifdef PB_ENABLE_MALLOC\n/* Given an oneof field, if there has already been a field inside this oneof,\n * release it before overwriting with a different one. */\nstatic bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field)\n{\n    pb_field_iter_t old_field = *field;\n    pb_size_t old_tag = *(pb_size_t*)field->pSize; /* Previous which_ value */\n    pb_size_t new_tag = field->tag; /* New which_ value */\n\n    if (old_tag == 0)\n        return true; /* Ok, no old data in union */\n\n    if (old_tag == new_tag)\n        return true; /* Ok, old data is of same type => merge */\n\n    /* Release old data. The find can fail if the message struct contains\n     * invalid data. */\n    if (!pb_field_iter_find(&old_field, old_tag))\n        PB_RETURN_ERROR(stream, \"invalid union tag\");\n\n    pb_release_single_field(&old_field);\n\n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n        /* Initialize the pointer to NULL to make sure it is valid\n         * even in case of error return. */\n        *(void**)field->pField = NULL;\n        field->pData = NULL;\n    }\n\n    return true;\n}\n\nstatic void pb_release_single_field(pb_field_iter_t *field)\n{\n    pb_type_t type;\n    type = field->type;\n\n    if (PB_HTYPE(type) == PB_HTYPE_ONEOF)\n    {\n        if (*(pb_size_t*)field->pSize != field->tag)\n            return; /* This is not the current field in the union */\n    }\n\n    /* Release anything contained inside an extension or submsg.\n     * This has to be done even if the submsg itself is statically\n     * allocated. */\n    if (PB_LTYPE(type) == PB_LTYPE_EXTENSION)\n    {\n        /* Release fields from all extensions in the linked list */\n        pb_extension_t *ext = *(pb_extension_t**)field->pData;\n        while (ext != NULL)\n        {\n            pb_field_iter_t ext_iter;\n            if (pb_field_iter_begin_extension(&ext_iter, ext))\n            {\n                pb_release_single_field(&ext_iter);\n            }\n            ext = ext->next;\n        }\n    }\n    else if (PB_LTYPE_IS_SUBMSG(type) && PB_ATYPE(type) != PB_ATYPE_CALLBACK)\n    {\n        /* Release fields in submessage or submsg array */\n        pb_size_t count = 1;\n        \n        if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n        {\n            field->pData = *(void**)field->pField;\n        }\n        else\n        {\n            field->pData = field->pField;\n        }\n        \n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED)\n        {\n            count = *(pb_size_t*)field->pSize;\n\n            if (PB_ATYPE(type) == PB_ATYPE_STATIC && count > field->array_size)\n            {\n                /* Protect against corrupted _count fields */\n                count = field->array_size;\n            }\n        }\n        \n        if (field->pData)\n        {\n            for (; count > 0; count--)\n            {\n                pb_release(field->submsg_desc, field->pData);\n                field->pData = (char*)field->pData + field->data_size;\n            }\n        }\n    }\n    \n    if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n    {\n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED &&\n            (PB_LTYPE(type) == PB_LTYPE_STRING ||\n             PB_LTYPE(type) == PB_LTYPE_BYTES))\n        {\n            /* Release entries in repeated string or bytes array */\n            void **pItem = *(void***)field->pField;\n            pb_size_t count = *(pb_size_t*)field->pSize;\n            for (; count > 0; count--)\n            {\n                pb_free(*pItem);\n                *pItem++ = NULL;\n            }\n        }\n        \n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED)\n        {\n            /* We are going to release the array, so set the size to 0 */\n            *(pb_size_t*)field->pSize = 0;\n        }\n        \n        /* Release main pointer */\n        pb_free(*(void**)field->pField);\n        *(void**)field->pField = NULL;\n    }\n}\n\nvoid pb_release(const pb_msgdesc_t *fields, void *dest_struct)\n{\n    pb_field_iter_t iter;\n    \n    if (!dest_struct)\n        return; /* Ignore NULL pointers, similar to free() */\n\n    if (!pb_field_iter_begin(&iter, fields, dest_struct))\n        return; /* Empty message type */\n    \n    do\n    {\n        pb_release_single_field(&iter);\n    } while (pb_field_iter_next(&iter));\n}\n#endif\n\n/* Field decoders */\n\nbool pb_decode_bool(pb_istream_t *stream, bool *dest)\n{\n    uint32_t value;\n    if (!pb_decode_varint32(stream, &value))\n        return false;\n\n    *(bool*)dest = (value != 0);\n    return true;\n}\n\nbool pb_decode_svarint(pb_istream_t *stream, pb_int64_t *dest)\n{\n    pb_uint64_t value;\n    if (!pb_decode_varint(stream, &value))\n        return false;\n    \n    if (value & 1)\n        *dest = (pb_int64_t)(~(value >> 1));\n    else\n        *dest = (pb_int64_t)(value >> 1);\n    \n    return true;\n}\n\nbool pb_decode_fixed32(pb_istream_t *stream, void *dest)\n{\n    union {\n        uint32_t fixed32;\n        pb_byte_t bytes[4];\n    } u;\n\n    if (!pb_read(stream, u.bytes, 4))\n        return false;\n\n#if defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN && CHAR_BIT == 8\n    /* fast path - if we know that we're on little endian, assign directly */\n    *(uint32_t*)dest = u.fixed32;\n#else\n    *(uint32_t*)dest = ((uint32_t)u.bytes[0] << 0) |\n                       ((uint32_t)u.bytes[1] << 8) |\n                       ((uint32_t)u.bytes[2] << 16) |\n                       ((uint32_t)u.bytes[3] << 24);\n#endif\n    return true;\n}\n\n#ifndef PB_WITHOUT_64BIT\nbool pb_decode_fixed64(pb_istream_t *stream, void *dest)\n{\n    union {\n        uint64_t fixed64;\n        pb_byte_t bytes[8];\n    } u;\n\n    if (!pb_read(stream, u.bytes, 8))\n        return false;\n\n#if defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN && CHAR_BIT == 8\n    /* fast path - if we know that we're on little endian, assign directly */\n    *(uint64_t*)dest = u.fixed64;\n#else\n    *(uint64_t*)dest = ((uint64_t)u.bytes[0] << 0) |\n                       ((uint64_t)u.bytes[1] << 8) |\n                       ((uint64_t)u.bytes[2] << 16) |\n                       ((uint64_t)u.bytes[3] << 24) |\n                       ((uint64_t)u.bytes[4] << 32) |\n                       ((uint64_t)u.bytes[5] << 40) |\n                       ((uint64_t)u.bytes[6] << 48) |\n                       ((uint64_t)u.bytes[7] << 56);\n#endif\n    return true;\n}\n#endif\n\nstatic bool checkreturn pb_dec_bool(pb_istream_t *stream, const pb_field_iter_t *field)\n{\n    return pb_decode_bool(stream, (bool*)field->pData);\n}\n\nstatic bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_iter_t *field)\n{\n    if (PB_LTYPE(field->type) == PB_LTYPE_UVARINT)\n    {\n        pb_uint64_t value, clamped;\n        if (!pb_decode_varint(stream, &value))\n            return false;\n\n        /* Cast to the proper field size, while checking for overflows */\n        if (field->data_size == sizeof(pb_uint64_t))\n            clamped = *(pb_uint64_t*)field->pData = value;\n        else if (field->data_size == sizeof(uint32_t))\n            clamped = *(uint32_t*)field->pData = (uint32_t)value;\n        else if (field->data_size == sizeof(uint_least16_t))\n            clamped = *(uint_least16_t*)field->pData = (uint_least16_t)value;\n        else if (field->data_size == sizeof(uint_least8_t))\n            clamped = *(uint_least8_t*)field->pData = (uint_least8_t)value;\n        else\n            PB_RETURN_ERROR(stream, \"invalid data_size\");\n\n        if (clamped != value)\n            PB_RETURN_ERROR(stream, \"integer too large\");\n\n        return true;\n    }\n    else\n    {\n        pb_uint64_t value;\n        pb_int64_t svalue;\n        pb_int64_t clamped;\n\n        if (PB_LTYPE(field->type) == PB_LTYPE_SVARINT)\n        {\n            if (!pb_decode_svarint(stream, &svalue))\n                return false;\n        }\n        else\n        {\n            if (!pb_decode_varint(stream, &value))\n                return false;\n\n            /* See issue 97: Google's C++ protobuf allows negative varint values to\n            * be cast as int32_t, instead of the int64_t that should be used when\n            * encoding. Nanopb versions before 0.2.5 had a bug in encoding. In order to\n            * not break decoding of such messages, we cast <=32 bit fields to\n            * int32_t first to get the sign correct.\n            */\n            if (field->data_size == sizeof(pb_int64_t))\n                svalue = (pb_int64_t)value;\n            else\n                svalue = (int32_t)value;\n        }\n\n        /* Cast to the proper field size, while checking for overflows */\n        if (field->data_size == sizeof(pb_int64_t))\n            clamped = *(pb_int64_t*)field->pData = svalue;\n        else if (field->data_size == sizeof(int32_t))\n            clamped = *(int32_t*)field->pData = (int32_t)svalue;\n        else if (field->data_size == sizeof(int_least16_t))\n            clamped = *(int_least16_t*)field->pData = (int_least16_t)svalue;\n        else if (field->data_size == sizeof(int_least8_t))\n            clamped = *(int_least8_t*)field->pData = (int_least8_t)svalue;\n        else\n            PB_RETURN_ERROR(stream, \"invalid data_size\");\n\n        if (clamped != svalue)\n            PB_RETURN_ERROR(stream, \"integer too large\");\n\n        return true;\n    }\n}\n\nstatic bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_iter_t *field)\n{\n    uint32_t size;\n    size_t alloc_size;\n    pb_bytes_array_t *dest;\n    \n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    \n    if (size > PB_SIZE_MAX)\n        PB_RETURN_ERROR(stream, \"bytes overflow\");\n    \n    alloc_size = PB_BYTES_ARRAY_T_ALLOCSIZE(size);\n    if (size > alloc_size)\n        PB_RETURN_ERROR(stream, \"size too large\");\n    \n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (stream->bytes_left < size)\n            PB_RETURN_ERROR(stream, \"end-of-stream\");\n\n        if (!allocate_field(stream, field->pData, alloc_size, 1))\n            return false;\n        dest = *(pb_bytes_array_t**)field->pData;\n#endif\n    }\n    else\n    {\n        if (alloc_size > field->data_size)\n            PB_RETURN_ERROR(stream, \"bytes overflow\");\n        dest = (pb_bytes_array_t*)field->pData;\n    }\n\n    dest->size = (pb_size_t)size;\n    return pb_read(stream, dest->bytes, (size_t)size);\n}\n\nstatic bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_iter_t *field)\n{\n    uint32_t size;\n    size_t alloc_size;\n    pb_byte_t *dest = (pb_byte_t*)field->pData;\n\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n\n    if (size == (uint32_t)-1)\n        PB_RETURN_ERROR(stream, \"size too large\");\n\n    /* Space for null terminator */\n    alloc_size = (size_t)(size + 1);\n\n    if (alloc_size < size)\n        PB_RETURN_ERROR(stream, \"size too large\");\n\n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (stream->bytes_left < size)\n            PB_RETURN_ERROR(stream, \"end-of-stream\");\n\n        if (!allocate_field(stream, field->pData, alloc_size, 1))\n            return false;\n        dest = *(pb_byte_t**)field->pData;\n#endif\n    }\n    else\n    {\n        if (alloc_size > field->data_size)\n            PB_RETURN_ERROR(stream, \"string overflow\");\n    }\n    \n    dest[size] = 0;\n\n    if (!pb_read(stream, dest, (size_t)size))\n        return false;\n\n#ifdef PB_VALIDATE_UTF8\n    if (!pb_validate_utf8((const char*)dest))\n        PB_RETURN_ERROR(stream, \"invalid utf8\");\n#endif\n\n    return true;\n}\n\nstatic bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_iter_t *field)\n{\n    bool status = true;\n    bool submsg_consumed = false;\n    pb_istream_t substream;\n\n    if (!pb_make_string_substream(stream, &substream))\n        return false;\n    \n    if (field->submsg_desc == NULL)\n        PB_RETURN_ERROR(stream, \"invalid field descriptor\");\n    \n    /* Submessages can have a separate message-level callback that is called\n     * before decoding the message. Typically it is used to set callback fields\n     * inside oneofs. */\n    if (PB_LTYPE(field->type) == PB_LTYPE_SUBMSG_W_CB && field->pSize != NULL)\n    {\n        /* Message callback is stored right before pSize. */\n        pb_callback_t *callback = (pb_callback_t*)field->pSize - 1;\n        if (callback->funcs.decode)\n        {\n            status = callback->funcs.decode(&substream, field, &callback->arg);\n\n            if (substream.bytes_left == 0)\n            {\n                submsg_consumed = true;\n            }\n        }\n    }\n\n    /* Now decode the submessage contents */\n    if (status && !submsg_consumed)\n    {\n        unsigned int flags = 0;\n\n        /* Static required/optional fields are already initialized by top-level\n         * pb_decode(), no need to initialize them again. */\n        if (PB_ATYPE(field->type) == PB_ATYPE_STATIC &&\n            PB_HTYPE(field->type) != PB_HTYPE_REPEATED)\n        {\n            flags = PB_DECODE_NOINIT;\n        }\n\n        status = pb_decode_inner(&substream, field->submsg_desc, field->pData, flags);\n    }\n    \n    if (!pb_close_string_substream(stream, &substream))\n        return false;\n\n    return status;\n}\n\nstatic bool checkreturn pb_dec_fixed_length_bytes(pb_istream_t *stream, const pb_field_iter_t *field)\n{\n    uint32_t size;\n\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n\n    if (size > PB_SIZE_MAX)\n        PB_RETURN_ERROR(stream, \"bytes overflow\");\n\n    if (size == 0)\n    {\n        /* As a special case, treat empty bytes string as all zeros for fixed_length_bytes. */\n        memset(field->pData, 0, (size_t)field->data_size);\n        return true;\n    }\n\n    if (size != field->data_size)\n        PB_RETURN_ERROR(stream, \"incorrect fixed length bytes size\");\n\n    return pb_read(stream, (pb_byte_t*)field->pData, (size_t)field->data_size);\n}\n\n#ifdef PB_CONVERT_DOUBLE_FLOAT\nbool pb_decode_double_as_float(pb_istream_t *stream, float *dest)\n{\n    uint_least8_t sign;\n    int exponent;\n    uint32_t mantissa;\n    uint64_t value;\n    union { float f; uint32_t i; } out;\n\n    if (!pb_decode_fixed64(stream, &value))\n        return false;\n\n    /* Decompose input value */\n    sign = (uint_least8_t)((value >> 63) & 1);\n    exponent = (int)((value >> 52) & 0x7FF) - 1023;\n    mantissa = (value >> 28) & 0xFFFFFF; /* Highest 24 bits */\n\n    /* Figure if value is in range representable by floats. */\n    if (exponent == 1024)\n    {\n        /* Special value */\n        exponent = 128;\n        mantissa >>= 1;\n    }\n    else\n    {\n        if (exponent > 127)\n        {\n            /* Too large, convert to infinity */\n            exponent = 128;\n            mantissa = 0;\n        }\n        else if (exponent < -150)\n        {\n            /* Too small, convert to zero */\n            exponent = -127;\n            mantissa = 0;\n        }\n        else if (exponent < -126)\n        {\n            /* Denormalized */\n            mantissa |= 0x1000000;\n            mantissa >>= (-126 - exponent);\n            exponent = -127;\n        }\n\n        /* Round off mantissa */\n        mantissa = (mantissa + 1) >> 1;\n\n        /* Check if mantissa went over 2.0 */\n        if (mantissa & 0x800000)\n        {\n            exponent += 1;\n            mantissa &= 0x7FFFFF;\n            mantissa >>= 1;\n        }\n    }\n\n    /* Combine fields */\n    out.i = mantissa;\n    out.i |= (uint32_t)(exponent + 127) << 23;\n    out.i |= (uint32_t)sign << 31;\n\n    *dest = out.f;\n    return true;\n}\n#endif\n"], "filenames": ["pb_decode.c"], "buggy_code_start_loc": [1205], "buggy_code_end_loc": [1205], "fixing_code_start_loc": [1206], "fixing_code_end_loc": [1214], "type": "CWE-763", "message": "Nanopb is a small code-size Protocol Buffers implementation in ansi C. In Nanopb before versions 0.3.9.8 and 0.4.5, decoding a specifically formed message can cause invalid `free()` or `realloc()` calls if the message type contains an `oneof` field, and the `oneof` directly contains both a pointer field and a non-pointer field. If the message data first contains the non-pointer field and then the pointer field, the data of the non-pointer field is incorrectly treated as if it was a pointer value. Such message data rarely occurs in normal messages, but it is a concern when untrusted data is parsed. This has been fixed in versions 0.3.9.8 and 0.4.5. See referenced GitHub Security Advisory for more information including workarounds.", "other": {"cve": {"id": "CVE-2021-21401", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-23T18:15:13.160", "lastModified": "2021-03-29T14:50:22.217", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Nanopb is a small code-size Protocol Buffers implementation in ansi C. In Nanopb before versions 0.3.9.8 and 0.4.5, decoding a specifically formed message can cause invalid `free()` or `realloc()` calls if the message type contains an `oneof` field, and the `oneof` directly contains both a pointer field and a non-pointer field. If the message data first contains the non-pointer field and then the pointer field, the data of the non-pointer field is incorrectly treated as if it was a pointer value. Such message data rarely occurs in normal messages, but it is a concern when untrusted data is parsed. This has been fixed in versions 0.3.9.8 and 0.4.5. See referenced GitHub Security Advisory for more information including workarounds."}, {"lang": "es", "value": "Nanopb es una implementaci\u00f3n de Protocol Buffers de tama\u00f1o de c\u00f3digo peque\u00f1o en ansi C. En Nanopb versiones anteriores a 0.3.9.8 y 0.4.5, la decodificaci\u00f3n de un mensaje formado espec\u00edficamente puede causar llamadas \"free()\" o \"realloc()\" no v\u00e1lidas si el tipo de mensaje contiene un campo \"oneof\", y el \"oneof\" contiene directamente un campo pointer como un campo non-pointer.&#xa0;Si los datos del mensaje contienen primero el campo non-pointer y luego el campo pointer, los datos del campo non-pointer son tratados incorrectamente como si fuera un valor pointer.&#xa0;Estos datos de mensajes raramente ocurren en mensajes normales, pero es una preocupaci\u00f3n cuando son analizados datos que no son confiables.&#xa0;Esto ha sido corregido en versiones 0.3.9.8 y 0.4.5.&#xa0;Consulte el Aviso de Seguridad de GitHub al que se hace referencia para obtener m\u00e1s informaci\u00f3n, incluyendo las soluciones"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-763"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nanopb_project:nanopb:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.3.9.8", "matchCriteriaId": "A39AC3AB-38B5-453C-B7A8-AC4B55CA26B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nanopb_project:nanopb:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.4.0", "versionEndExcluding": "0.4.5", "matchCriteriaId": "751F562A-CABC-4E22-A0A3-12BF6171B6AE"}]}]}], "references": [{"url": "https://github.com/nanopb/nanopb/blob/c9124132a604047d0ef97a09c0e99cd9bed2c818/CHANGELOG.txt#L1", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/nanopb/nanopb/commit/e2f0ccf939d9f82931d085acb6df8e9a182a4261", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nanopb/nanopb/issues/647", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/nanopb/nanopb/security/advisories/GHSA-7mv5-5mxh-qg88", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nanopb/nanopb/commit/e2f0ccf939d9f82931d085acb6df8e9a182a4261"}}