{"buggy_code": ["import { BadRequestException, ConflictException, Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, createQueryBuilder, In, Not, EntityManager } from 'typeorm';\nimport { User } from 'src/entities/user.entity';\nimport { GroupPermission } from 'src/entities/group_permission.entity';\nimport { App } from 'src/entities/app.entity';\nimport { AppGroupPermission } from 'src/entities/app_group_permission.entity';\nimport { UserGroupPermission } from 'src/entities/user_group_permission.entity';\nimport { UsersService } from './users.service';\nimport { dbTransactionWrap } from 'src/helpers/utils.helper';\n\n@Injectable()\nexport class GroupPermissionsService {\n  constructor(\n    @InjectRepository(GroupPermission)\n    private groupPermissionsRepository: Repository<GroupPermission>,\n\n    @InjectRepository(AppGroupPermission)\n    private appGroupPermissionsRepository: Repository<AppGroupPermission>,\n\n    @InjectRepository(UserGroupPermission)\n    private userGroupPermissionsRepository: Repository<UserGroupPermission>,\n\n    @InjectRepository(User)\n    private userRepository: Repository<User>,\n\n    @InjectRepository(App)\n    private appRepository: Repository<App>,\n\n    private usersService: UsersService\n  ) {}\n\n  async create(user: User, group: string, manager?: EntityManager): Promise<void> {\n    if (!group || group === '') {\n      throw new BadRequestException('Cannot create group without name');\n    }\n\n    const reservedGroups = ['All Users', 'Admin'];\n\n    if (reservedGroups.includes(group)) {\n      throw new BadRequestException('Group name already exist');\n    }\n\n    const groupToFind = await this.groupPermissionsRepository.findOne({\n      where: {\n        organizationId: user.organizationId,\n        group,\n      },\n    });\n\n    if (groupToFind) {\n      throw new ConflictException('Group name already exist');\n    }\n\n    await dbTransactionWrap(async (manager: EntityManager) => {\n      await manager.save(\n        manager.create(GroupPermission, {\n          organizationId: user.organizationId,\n          group: group,\n        })\n      );\n    }, manager);\n  }\n\n  async destroy(user: User, groupPermissionId: string, manager?: EntityManager): Promise<void> {\n    const groupPermission = await this.groupPermissionsRepository.findOne({\n      where: {\n        id: groupPermissionId,\n      },\n    });\n\n    if (groupPermission.group == 'admin' || groupPermission.group == 'all_users') {\n      throw new BadRequestException('Cannot delete default group');\n    }\n    await dbTransactionWrap(async (manager: EntityManager) => {\n      const relationalEntitiesToBeDeleted = [AppGroupPermission, UserGroupPermission];\n\n      for (const entityToDelete of relationalEntitiesToBeDeleted) {\n        const entities = await manager.find(entityToDelete, {\n          where: { groupPermissionId },\n        });\n\n        for (const entity of entities) {\n          await manager.delete(entityToDelete, entity.id);\n        }\n      }\n\n      await manager.delete(GroupPermission, {\n        organizationId: user.organizationId,\n        id: groupPermissionId,\n      });\n    }, manager);\n  }\n\n  async updateAppGroupPermission(\n    user: User,\n    groupPermissionId: string,\n    appGroupPermissionId: string,\n    actions: any,\n    manager?: EntityManager\n  ) {\n    const appGroupPermission = await this.appGroupPermissionsRepository.findOne({\n      where: {\n        id: appGroupPermissionId,\n        groupPermissionId: groupPermissionId,\n      },\n    });\n    const groupPermission = await this.groupPermissionsRepository.findOne({\n      where: {\n        id: appGroupPermission.groupPermissionId,\n      },\n    });\n\n    if (groupPermission.organizationId !== user.organizationId) {\n      throw new BadRequestException();\n    }\n    if (groupPermission.group == 'admin') {\n      throw new BadRequestException('Cannot update admin group');\n    }\n\n    await dbTransactionWrap(async (manager: EntityManager) => {\n      await manager.update(AppGroupPermission, appGroupPermissionId, actions);\n    }, manager);\n  }\n\n  async update(user: User, groupPermissionId: string, body: any, manager?: EntityManager) {\n    const groupPermission = await this.groupPermissionsRepository.findOne({\n      where: {\n        id: groupPermissionId,\n        organizationId: user.organizationId,\n      },\n    });\n\n    const {\n      name,\n      app_create,\n      app_delete,\n      add_apps,\n      remove_apps,\n      add_users,\n      remove_users,\n      folder_create,\n      org_environment_variable_create,\n      org_environment_variable_update,\n      org_environment_variable_delete,\n      folder_delete,\n      folder_update,\n    } = body;\n\n    await dbTransactionWrap(async (manager: EntityManager) => {\n      //update user group name\n      if (name) {\n        const newName = name.trim();\n        if (!newName) {\n          throw new BadRequestException('Group name should not be empty');\n        }\n\n        const reservedGroups = ['admin', 'all_users'];\n        if (reservedGroups.includes(groupPermission.group)) {\n          throw new BadRequestException('Cannot update a default group name');\n        }\n\n        if (reservedGroups.includes(newName.replace(/ /g, '_').toLowerCase())) {\n          throw new BadRequestException('Group name already exists');\n        }\n\n        const groupToFind = await this.groupPermissionsRepository.findOne({\n          where: {\n            organizationId: user.organizationId,\n            group: newName,\n          },\n        });\n\n        if (groupToFind && groupToFind.id !== groupPermission.id) {\n          throw new ConflictException('Group name already exists');\n        } else if (!groupToFind) {\n          await manager.update(GroupPermission, groupPermissionId, { group: newName });\n        }\n      }\n\n      // update group permissions\n      const groupPermissionUpdateParams = {\n        ...(typeof app_create === 'boolean' && { appCreate: app_create }),\n        ...(typeof app_delete === 'boolean' && { appDelete: app_delete }),\n        ...(typeof folder_create === 'boolean' && { folderCreate: folder_create }),\n        ...(typeof org_environment_variable_create === 'boolean' && {\n          orgEnvironmentVariableCreate: org_environment_variable_create,\n        }),\n        ...(typeof org_environment_variable_update === 'boolean' && {\n          orgEnvironmentVariableUpdate: org_environment_variable_update,\n        }),\n        ...(typeof org_environment_variable_delete === 'boolean' && {\n          orgEnvironmentVariableDelete: org_environment_variable_delete,\n        }),\n        ...(typeof folder_delete === 'boolean' && { folderDelete: folder_delete }),\n        ...(typeof folder_update === 'boolean' && { folderUpdate: folder_update }),\n      };\n      if (Object.keys(groupPermissionUpdateParams).length !== 0) {\n        await manager.update(GroupPermission, groupPermissionId, groupPermissionUpdateParams);\n      }\n\n      // update app group permissions\n      if (remove_apps) {\n        if (groupPermission.group == 'admin') {\n          throw new BadRequestException('Cannot update admin group');\n        }\n        for (const appId of remove_apps) {\n          await manager.delete(AppGroupPermission, {\n            appId: appId,\n            groupPermissionId: groupPermissionId,\n          });\n        }\n      }\n\n      if (add_apps) {\n        if (groupPermission.group == 'admin') {\n          throw new BadRequestException('Cannot update admin group');\n        }\n        for (const appId of add_apps) {\n          await manager.save(\n            AppGroupPermission,\n            manager.create(AppGroupPermission, {\n              appId: appId,\n              groupPermissionId: groupPermissionId,\n              read: true,\n            })\n          );\n        }\n      }\n\n      // update user group permissions\n      if (remove_users) {\n        for (const userId of body.remove_users) {\n          const params = {\n            removeGroups: [groupPermission.group],\n          };\n          await this.usersService.update(userId, params, manager, user.organizationId);\n        }\n      }\n\n      if (add_users) {\n        for (const userId of body.add_users) {\n          const params = {\n            addGroups: [groupPermission.group],\n          };\n          await this.usersService.update(userId, params, manager, user.organizationId);\n        }\n      }\n    }, manager);\n  }\n\n  async findOne(user: User, groupPermissionId: string): Promise<GroupPermission> {\n    return this.groupPermissionsRepository.findOne({\n      where: {\n        organizationId: user.organizationId,\n        id: groupPermissionId,\n      },\n    });\n  }\n\n  async findAll(user: User): Promise<GroupPermission[]> {\n    return this.groupPermissionsRepository.find({\n      where: { organizationId: user.organizationId },\n      order: { createdAt: 'ASC' },\n    });\n  }\n\n  async findApps(user: User, groupPermissionId: string): Promise<App[]> {\n    return createQueryBuilder(App, 'apps')\n      .innerJoinAndSelect('apps.groupPermissions', 'group_permissions')\n      .innerJoinAndSelect('apps.appGroupPermissions', 'app_group_permissions')\n      .where('group_permissions.id = :groupPermissionId', {\n        groupPermissionId,\n      })\n      .andWhere('group_permissions.organization_id = :organizationId', {\n        organizationId: user.organizationId,\n      })\n      .andWhere('app_group_permissions.group_permission_id = :groupPermissionId', { groupPermissionId })\n      .orderBy('apps.created_at', 'DESC')\n      .getMany();\n  }\n\n  async findAddableApps(user: User, groupPermissionId: string): Promise<App[]> {\n    const groupPermission = await this.groupPermissionsRepository.findOne({\n      where: {\n        id: groupPermissionId,\n        organizationId: user.organizationId,\n      },\n    });\n\n    const appsInGroup = await groupPermission.apps;\n    const appsInGroupIds = appsInGroup.map((u) => u.id);\n\n    return await this.appRepository.find({\n      where: {\n        id: Not(In(appsInGroupIds)),\n        organizationId: user.organizationId,\n      },\n      loadEagerRelations: false,\n      relations: ['groupPermissions', 'appGroupPermissions'],\n    });\n  }\n\n  async findUsers(user: User, groupPermissionId: string): Promise<User[]> {\n    return createQueryBuilder(User, 'users')\n      .innerJoinAndSelect('users.groupPermissions', 'group_permissions')\n      .innerJoinAndSelect('users.userGroupPermissions', 'user_group_permissions')\n      .where('group_permissions.id = :groupPermissionId', {\n        groupPermissionId,\n      })\n      .andWhere('group_permissions.organization_id = :organizationId', {\n        organizationId: user.organizationId,\n      })\n      .andWhere('user_group_permissions.group_permission_id = :groupPermissionId', { groupPermissionId })\n      .orderBy('users.created_at', 'DESC')\n      .getMany();\n  }\n\n  async findAddableUsers(user: User, groupPermissionId: string): Promise<User[]> {\n    const groupPermission = await this.groupPermissionsRepository.findOne({\n      where: {\n        id: groupPermissionId,\n        organizationId: user.organizationId,\n      },\n    });\n\n    const userInGroup = await groupPermission.users;\n    const usersInGroupIds = userInGroup.map((u) => u.id);\n\n    const adminUsers = await createQueryBuilder(UserGroupPermission, 'user_group_permissions')\n      .innerJoin(\n        GroupPermission,\n        'group_permissions',\n        'group_permissions.id = user_group_permissions.group_permission_id'\n      )\n      .where('group_permissions.group = :group', { group: 'admin' })\n      .andWhere('group_permissions.organization_id = :organizationId', {\n        organizationId: user.organizationId,\n      })\n      .getMany();\n    const adminUserIds = adminUsers.map((u) => u.userId);\n\n    return await createQueryBuilder(User, 'user')\n      .select(['user.id', 'user.firstName', 'user.lastName'])\n      .innerJoin(\n        'user.organizationUsers',\n        'organization_users',\n        'organization_users.organizationId = :organizationId',\n        { organizationId: user.organizationId }\n      )\n      .where('user.id NOT IN (:...userList)', { userList: [...usersInGroupIds, ...adminUserIds] })\n      .getMany();\n  }\n\n  async createUserGroupPermission(userId: string, groupPermissionId: string, manager?: EntityManager) {\n    await dbTransactionWrap(async (manager: EntityManager) => {\n      await manager.save(\n        manager.create(UserGroupPermission, {\n          userId,\n          groupPermissionId,\n        })\n      );\n    }, manager);\n  }\n}\n", "import * as request from 'supertest';\nimport { INestApplication } from '@nestjs/common';\nimport { authHeaderForUser, clearDB, createUser, createNestAppInstance, createApplication } from '../test.helper';\nimport { getManager } from 'typeorm';\nimport { AppGroupPermission } from 'src/entities/app_group_permission.entity';\nimport { UserGroupPermission } from 'src/entities/user_group_permission.entity';\nimport { GroupPermission } from 'src/entities/group_permission.entity';\n\ndescribe('group permissions controller', () => {\n  let nestApp: INestApplication;\n\n  beforeEach(async () => {\n    await clearDB();\n  });\n\n  beforeAll(async () => {\n    nestApp = await createNestAppInstance();\n  });\n\n  describe('POST /group_permissions', () => {\n    it('should not allow non admin to create group permission', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(defaultUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should be able to create group permission for authenticated admin', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(201);\n\n      const updatedGroup: GroupPermission = await getManager().findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'avengers',\n        },\n      });\n\n      expect(updatedGroup.group).toBe('avengers');\n      expect(updatedGroup.organizationId).toBe(organization.id);\n      expect(updatedGroup.createdAt).toBeDefined();\n      expect(updatedGroup.updatedAt).toBeDefined();\n    });\n\n    it('should not allow to create system defined group names', async () => {\n      const {\n        organization: { adminUser },\n      } = await setupOrganizations(nestApp);\n\n      const reservedGroups = ['All Users', 'Admin'];\n\n      for (let i = 0; i < reservedGroups.length; i += 1) {\n        const response = await request(nestApp.getHttpServer())\n          .post('/api/group_permissions')\n          .set('Authorization', authHeaderForUser(adminUser))\n          .send({ group: reservedGroups[i] });\n\n        expect(response.statusCode).toBe(400);\n        expect(response.body.message).toBe('Group name already exist');\n      }\n    });\n\n    it('should validate uniqueness of group permission group name', async () => {\n      const {\n        organization: { adminUser },\n      } = await setupOrganizations(nestApp);\n      let response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(201);\n\n      response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(409);\n    });\n\n    it('should allow different organization to have same group name', async () => {\n      const {\n        organization: { adminUser },\n        anotherOrganization: { anotherAdminUser },\n      } = await setupOrganizations(nestApp);\n\n      let response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(201);\n\n      response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(anotherAdminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(201);\n    });\n  });\n\n  describe('GET /group_permissions/:id', () => {\n    it('should not allow unauthenticated admin', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .get('/api/group_permissions/id')\n        .set('Authorization', authHeaderForUser(defaultUser));\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should get group permission for authenticated admin within organization', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      let response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(201);\n\n      const updatedGroup: GroupPermission = await getManager().findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'avengers',\n        },\n      });\n\n      response = await request(nestApp.getHttpServer())\n        .get(`/api/group_permissions/${updatedGroup.id}`)\n        .set('Authorization', authHeaderForUser(adminUser));\n\n      expect(response.statusCode).toBe(200);\n      expect(response.body.group).toBe('avengers');\n      expect(response.body.organization_id).toBe(organization.id);\n      expect(response.body.id).toBeDefined();\n      expect(response.body.created_at).toBeDefined();\n      expect(response.body.updated_at).toBeDefined();\n    });\n\n    it('should not get group permission for authenticated admin not within organization', async () => {\n      const {\n        organization: { adminUser },\n        anotherOrganization: { anotherAdminUser },\n      } = await setupOrganizations(nestApp);\n\n      let response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      const groupPermissionId = response.body.id;\n\n      response = await request(nestApp.getHttpServer())\n        .post(`/api/group_permissions/${groupPermissionId}`)\n        .set('Authorization', authHeaderForUser(anotherAdminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(404);\n    });\n  });\n\n  describe('PUT /group_permissions/:id', () => {\n    it('should not allow unauthenticated admin', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .put('/api/group_permissions/id')\n        .set('Authorization', authHeaderForUser(defaultUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should allow admin to update a group name', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      const createResponse = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(createResponse.statusCode).toBe(201);\n\n      let updatedGroup: GroupPermission = await getManager().findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'avengers',\n        },\n      });\n\n      //update a group name\n      const updateResponse = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${updatedGroup.id}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ name: 'titans' });\n\n      expect(updateResponse.statusCode).toBe(200);\n\n      updatedGroup = await getManager().findOne(GroupPermission, updatedGroup.id);\n      expect(updatedGroup.group).toEqual('titans');\n    });\n\n    it('should not be able to update a group name with existing names', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      const createResponse = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(createResponse.statusCode).toBe(201);\n\n      const updatedGroup: GroupPermission = await getManager().findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'avengers',\n        },\n      });\n\n      //update a group name\n      const updateResponse = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${updatedGroup.id}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ name: 'All users' });\n\n      expect(updateResponse.statusCode).toBe(400);\n    });\n\n    it('should not be able to update a default group name', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      const adminGroup = await getManager().findOne(GroupPermission, {\n        where: { group: 'admin', organizationId: organization.id },\n      });\n\n      //update a group name\n      const updateResponse = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${adminGroup.id}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ name: 'titans' });\n\n      expect(updateResponse.statusCode).toBe(400);\n    });\n\n    it('should allow admin to add and remove apps to group permission', async () => {\n      const {\n        organization: { adminUser, app, organization },\n      } = await setupOrganizations(nestApp);\n\n      let response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(201);\n\n      const updatedGroup: GroupPermission = await getManager().findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'avengers',\n        },\n      });\n\n      const groupPermissionId = updatedGroup.id;\n\n      response = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${groupPermissionId}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ add_apps: [app.id] });\n\n      expect(response.statusCode).toBe(200);\n\n      const manager = getManager();\n      let appsInGroup = await manager.find(AppGroupPermission, {\n        where: { groupPermissionId },\n      });\n\n      expect(appsInGroup).toHaveLength(1);\n\n      const addedApp = appsInGroup[0];\n\n      expect(addedApp.appId).toBe(app.id);\n      expect(addedApp.read).toBe(true);\n      expect(addedApp.update).toBe(false);\n      expect(addedApp.delete).toBe(false);\n\n      response = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${groupPermissionId}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ remove_apps: [app.id] });\n\n      expect(response.statusCode).toBe(200);\n\n      appsInGroup = await manager.find(AppGroupPermission, {\n        where: { groupPermissionId },\n      });\n\n      expect(appsInGroup).toHaveLength(0);\n    });\n\n    it('should allow admin to add and remove users to group permission', async () => {\n      const {\n        organization: { adminUser, defaultUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      let response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      const updatedGroup: GroupPermission = await getManager().findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'avengers',\n        },\n      });\n      const groupPermissionId = updatedGroup.id;\n\n      response = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${groupPermissionId}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ add_users: [defaultUser.id] });\n\n      expect(response.statusCode).toBe(200);\n\n      const manager = getManager();\n      let usersInGroup = await manager.find(UserGroupPermission, {\n        where: { groupPermissionId },\n      });\n\n      expect(usersInGroup).toHaveLength(1);\n\n      const addedUser = usersInGroup[0];\n\n      expect(addedUser.userId).toBe(defaultUser.id);\n\n      response = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${groupPermissionId}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ remove_users: [defaultUser.id] });\n\n      expect(response.statusCode).toBe(200);\n\n      usersInGroup = await manager.find(UserGroupPermission, {\n        where: { groupPermissionId },\n      });\n\n      expect(usersInGroup).toHaveLength(0);\n    });\n\n    it('should not allow to remove users from admin group permission without any at least one active admin', async () => {\n      const { user, organization } = await createUser(nestApp, {\n        email: 'admin@tooljet.io',\n      });\n\n      const manager = getManager();\n      const adminGroupPermission = await manager.findOneOrFail(GroupPermission, {\n        where: {\n          group: 'admin',\n          organizationId: organization.id,\n        },\n      });\n\n      const response = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${adminGroupPermission.id}`)\n        .set('Authorization', authHeaderForUser(user))\n        .send({ remove_users: [user.id] });\n\n      expect(response.statusCode).toBe(400);\n      expect(response.body.message).toBe('Atleast one active admin is required.');\n    });\n\n    it('should not allow to remove any users from all_users group permission', async () => {\n      const {\n        organization: { adminUser, defaultUser },\n      } = await setupOrganizations(nestApp);\n\n      const manager = getManager();\n      const adminGroupPermission = await manager.findOneOrFail(GroupPermission, {\n        where: {\n          group: 'all_users',\n          organizationId: adminUser.organizationId,\n        },\n      });\n\n      const response = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${adminGroupPermission.id}/`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ remove_users: [defaultUser.id] });\n\n      expect(response.statusCode).toBe(400);\n      expect(response.body.message).toBe('Cannot remove user from default group.');\n    });\n  });\n\n  describe('GET /group_permissions', () => {\n    it('should not allow unauthenticated admin', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .get('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(defaultUser));\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should allow admin to list group permission', async () => {\n      const {\n        organization: { adminUser, defaultUser, app, organization },\n      } = await setupOrganizations(nestApp);\n\n      // create group permission\n      let response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(201);\n\n      const updatedGroup: GroupPermission = await getManager().findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'avengers',\n        },\n      });\n\n      const groupPermissionId = updatedGroup.id;\n\n      // add apps and users to group permission\n      response = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${groupPermissionId}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ add_apps: [app.id], add_users: [defaultUser.id] });\n\n      expect(response.statusCode).toBe(200);\n\n      // list group permission\n      response = await request(nestApp.getHttpServer())\n        .get('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser));\n      expect(response.statusCode).toBe(200);\n\n      const groupPermissions = response.body.group_permissions;\n      const groups = groupPermissions.map((gp) => gp.group);\n      const organizationId = [...new Set(groupPermissions.map((gp) => gp.organization_id))];\n\n      expect(new Set(groups)).toEqual(new Set(['avengers', 'all_users', 'admin']));\n      expect(organizationId).toEqual([organization.id]);\n    });\n  });\n\n  describe('GET /group_permissions/:id/apps', () => {\n    it('should not allow unauthenticated admin', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .get('/api/group_permissions/id/apps')\n        .set('Authorization', authHeaderForUser(defaultUser));\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should allow admin to list apps in group permission', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      const manager = getManager();\n      const adminGroupPermission = await manager.findOneOrFail(GroupPermission, {\n        where: {\n          group: 'admin',\n          organizationId: organization.id,\n        },\n      });\n\n      const response = await request(nestApp.getHttpServer())\n        .get(`/api/group_permissions/${adminGroupPermission.id}/apps`)\n        .set('Authorization', authHeaderForUser(adminUser));\n\n      expect(response.statusCode).toBe(200);\n\n      const apps = response.body.apps;\n      const sampleApp = apps[0];\n\n      expect(apps).toHaveLength(1);\n      expect(sampleApp.organization_id).toBe(organization.id);\n      expect(sampleApp.name).toBe('sample app');\n\n      expect(sampleApp.group_permissions).toHaveLength(1);\n      expect(sampleApp.group_permissions[0].group).toBe('admin');\n\n      expect(sampleApp.app_group_permissions).toHaveLength(1);\n      expect(sampleApp.app_group_permissions[0].group_permission_id).toBe(sampleApp.group_permissions[0].id);\n      expect(sampleApp.app_group_permissions[0].read).toBe(true);\n      expect(sampleApp.app_group_permissions[0].update).toBe(true);\n      expect(sampleApp.app_group_permissions[0].delete).toBe(true);\n    });\n  });\n\n  describe('GET /group_permissions/:id/addable_apps', () => {\n    it('should not allow unauthenticated admin', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .get('/api/group_permissions/id/addable_apps')\n        .set('Authorization', authHeaderForUser(defaultUser));\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should allow admin to list apps not in group permission', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      // create group permission\n      let response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(201);\n\n      const manager = getManager();\n      const groupPermission: GroupPermission = await manager.findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'avengers',\n        },\n      });\n\n      const groupPermissionId = groupPermission.id;\n\n      response = await request(nestApp.getHttpServer())\n        .get(`/api/group_permissions/${groupPermissionId}/addable_apps`)\n        .set('Authorization', authHeaderForUser(adminUser));\n\n      expect(response.statusCode).toBe(200);\n\n      const apps = response.body.apps;\n      const sampleApp = apps[0];\n\n      expect(apps).toHaveLength(1);\n      expect(sampleApp.organization_id).toBe(organization.id);\n      expect(sampleApp.name).toBe('sample app');\n      expect(sampleApp.group_permissions).toHaveLength(2);\n\n      const adminGroupPermission = sampleApp.group_permissions.find((a) => a.group == 'admin');\n      const adminAppGroupPermission = sampleApp.app_group_permissions.find(\n        (a) => a.group_permission_id == adminGroupPermission.id\n      );\n      expect(adminAppGroupPermission.read).toBe(true);\n      expect(adminAppGroupPermission.update).toBe(true);\n      expect(adminAppGroupPermission.delete).toBe(true);\n\n      const userGroupPermission = sampleApp.group_permissions.find((a) => a.group == 'all_users');\n      const userAppGroupPermission = sampleApp.app_group_permissions.find(\n        (a) => a.group_permission_id == userGroupPermission.id\n      );\n      expect(userAppGroupPermission.read).toBe(false);\n      expect(userAppGroupPermission.update).toBe(false);\n      expect(userAppGroupPermission.delete).toBe(false);\n    });\n  });\n\n  describe('GET /group_permissions/:id/users', () => {\n    it('should not allow unauthenticated admin', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .get('/api/group_permissions/id/users')\n        .set('Authorization', authHeaderForUser(defaultUser));\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should allow admin to list users in group permission', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      const manager = getManager();\n      const adminGroupPermission = await manager.findOneOrFail(GroupPermission, {\n        where: {\n          group: 'admin',\n          organizationId: organization.id,\n        },\n      });\n\n      const response = await request(nestApp.getHttpServer())\n        .get(`/api/group_permissions/${adminGroupPermission.id}/users`)\n        .set('Authorization', authHeaderForUser(adminUser));\n\n      expect(response.statusCode).toBe(200);\n\n      const users = response.body.users;\n\n      const user = users[0];\n\n      expect(users).toHaveLength(1);\n      expect(user.default_organization_id).toBe(organization.id);\n      expect(user.email).toBe('admin@tooljet.io');\n    });\n  });\n\n  describe('GET /group_permissions/:id/addable_users', () => {\n    it('should not allow unauthenticated admin', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .get('/api/group_permissions/id/addable_users')\n        .set('Authorization', authHeaderForUser(defaultUser));\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should allow admin to list users not in group permission', async () => {\n      const adminUser = await createUser(nestApp, { email: 'admin@tooljet.io' });\n      const userone = await createUser(nestApp, {\n        email: 'userone@tooljet.io',\n        groups: ['all_users'],\n        organization: adminUser.organization,\n      });\n\n      const manager = getManager();\n      const adminGroupPermission = await manager.findOneOrFail(GroupPermission, {\n        where: {\n          group: 'admin',\n          organizationId: adminUser.organization.id,\n        },\n      });\n      const groupPermissionId = adminGroupPermission.id;\n      const response = await request(nestApp.getHttpServer())\n        .get(`/api/group_permissions/${groupPermissionId}/addable_users`)\n        .set('Authorization', authHeaderForUser(adminUser.user));\n\n      expect(response.statusCode).toBe(200);\n\n      const users = response.body.users;\n      const user = users[0];\n\n      expect(users).toHaveLength(1);\n      expect(user.first_name).toBe('test');\n      expect(user.last_name).toBe('test');\n      expect(user.id).toBe(userone.user.id);\n      expect(Object.keys(user).sort()).toEqual(['first_name', 'last_name', 'id'].sort());\n    });\n  });\n\n  describe('PUT /group_permissions/:id/app_group_permissions/:appGroupPermisionId', () => {\n    it('should not allow unauthenticated admin', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .put('/api/group_permissions/id/app_group_permissions/id')\n        .set('Authorization', authHeaderForUser(defaultUser))\n        .send({ read: true });\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should allow admin to update app group permission', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      const manager = getManager();\n      const groupPermission = await manager.findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'all_users',\n        },\n      });\n      const groupPermissionId = groupPermission.id;\n      const appGroupPermission = await manager.findOneOrFail(AppGroupPermission, {\n        where: {\n          groupPermissionId,\n        },\n      });\n      const appGroupPermissionId = appGroupPermission.id;\n\n      expect(appGroupPermission.read).toBe(false);\n      expect(appGroupPermission.update).toBe(false);\n\n      const response = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${groupPermissionId}/app_group_permissions/${appGroupPermissionId}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ actions: { read: false, update: true } });\n\n      expect(response.statusCode).toBe(200);\n\n      await appGroupPermission.reload();\n\n      expect(appGroupPermission.read).toBe(false);\n      expect(appGroupPermission.update).toBe(true);\n    });\n\n    it('should not allow admin to update app group permission of different organization', async () => {\n      const {\n        organization: { organization },\n        anotherOrganization: { anotherAdminUser },\n      } = await setupOrganizations(nestApp);\n\n      const manager = getManager();\n      const groupPermission = await manager.findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'all_users',\n        },\n      });\n      const groupPermissionId = groupPermission.id;\n      const appGroupPermission = await manager.findOneOrFail(AppGroupPermission, {\n        where: {\n          groupPermissionId,\n        },\n      });\n      const appGroupPermissionId = appGroupPermission.id;\n\n      expect(appGroupPermission.read).toBe(false);\n      expect(appGroupPermission.update).toBe(false);\n\n      const response = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${groupPermissionId}/app_group_permissions/${appGroupPermissionId}`)\n        .set('Authorization', authHeaderForUser(anotherAdminUser))\n        .send({ actions: { read: false, update: true } });\n\n      expect(response.statusCode).toBe(400);\n    });\n  });\n\n  describe('DELETE /group_permissions/:id', () => {\n    it('should not allow unauthenicated admin', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .del('/api/group_permissions/id')\n        .set('Authorization', authHeaderForUser(defaultUser))\n        .send({ read: true });\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should allow admin to delete group', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      const manager = getManager();\n      const groupPermission: GroupPermission = await manager.findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'avengers',\n        },\n      });\n\n      const response = await request(nestApp.getHttpServer())\n        .del(`/api/group_permissions/${groupPermission.id}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(200);\n    });\n  });\n\n  async function setupOrganizations(nestApp) {\n    const adminUserData = await createUser(nestApp, {\n      email: 'admin@tooljet.io',\n      groups: ['all_users', 'admin'],\n    });\n    const adminUser = adminUserData.user;\n    const organization = adminUserData.organization;\n    const defaultUserData = await createUser(nestApp, {\n      email: 'developer@tooljet.io',\n      groups: ['all_users'],\n      organization,\n    });\n    const defaultUser = defaultUserData.user;\n\n    const app = await createApplication(nestApp, {\n      user: adminUser,\n      name: 'sample app',\n      isPublic: false,\n    });\n\n    const anotherAdminUserData = await createUser(nestApp, {\n      email: 'another_admin@tooljet.io',\n      groups: ['all_users', 'admin'],\n    });\n    const anotherAdminUser = anotherAdminUserData.user;\n    const anotherOrganization = anotherAdminUserData.organization;\n    const anotherDefaultUserData = await createUser(nestApp, {\n      email: 'another_developer@tooljet.io',\n      groups: ['all_users'],\n      organization: anotherOrganization,\n    });\n    const anotherDefaultUser = anotherDefaultUserData.user;\n\n    const anotherApp = await createApplication(nestApp, {\n      user: anotherAdminUser,\n      name: 'another app',\n      isPublic: false,\n    });\n\n    return {\n      organization: { adminUser, defaultUser, organization, app },\n      anotherOrganization: {\n        anotherAdminUser,\n        anotherDefaultUser,\n        anotherOrganization,\n        anotherApp,\n      },\n    };\n  }\n\n  afterAll(async () => {\n    await nestApp.close();\n  });\n});\n"], "fixing_code": ["import { BadRequestException, ConflictException, Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, createQueryBuilder, In, Not, EntityManager } from 'typeorm';\nimport { User } from 'src/entities/user.entity';\nimport { GroupPermission } from 'src/entities/group_permission.entity';\nimport { App } from 'src/entities/app.entity';\nimport { AppGroupPermission } from 'src/entities/app_group_permission.entity';\nimport { UserGroupPermission } from 'src/entities/user_group_permission.entity';\nimport { UsersService } from './users.service';\nimport { dbTransactionWrap } from 'src/helpers/utils.helper';\n\n@Injectable()\nexport class GroupPermissionsService {\n  constructor(\n    @InjectRepository(GroupPermission)\n    private groupPermissionsRepository: Repository<GroupPermission>,\n\n    @InjectRepository(AppGroupPermission)\n    private appGroupPermissionsRepository: Repository<AppGroupPermission>,\n\n    @InjectRepository(UserGroupPermission)\n    private userGroupPermissionsRepository: Repository<UserGroupPermission>,\n\n    @InjectRepository(User)\n    private userRepository: Repository<User>,\n\n    @InjectRepository(App)\n    private appRepository: Repository<App>,\n\n    private usersService: UsersService\n  ) {}\n\n  async create(user: User, group: string, manager?: EntityManager): Promise<void> {\n    if (!group || group === '') {\n      throw new BadRequestException('Cannot create group without name');\n    }\n\n    const reservedGroups = ['All Users', 'Admin'];\n\n    if (reservedGroups.includes(group)) {\n      throw new BadRequestException('Group name already exist');\n    }\n\n    const groupToFind = await this.groupPermissionsRepository.findOne({\n      where: {\n        organizationId: user.organizationId,\n        group,\n      },\n    });\n\n    if (groupToFind) {\n      throw new ConflictException('Group name already exist');\n    }\n\n    await dbTransactionWrap(async (manager: EntityManager) => {\n      await manager.save(\n        manager.create(GroupPermission, {\n          organizationId: user.organizationId,\n          group: group,\n        })\n      );\n    }, manager);\n  }\n\n  async destroy(user: User, groupPermissionId: string, manager?: EntityManager): Promise<void> {\n    const groupPermission = await this.groupPermissionsRepository.findOne({\n      where: {\n        id: groupPermissionId,\n      },\n    });\n\n    if (groupPermission.group == 'admin' || groupPermission.group == 'all_users') {\n      throw new BadRequestException('Cannot delete default group');\n    }\n    await dbTransactionWrap(async (manager: EntityManager) => {\n      const relationalEntitiesToBeDeleted = [AppGroupPermission, UserGroupPermission];\n\n      for (const entityToDelete of relationalEntitiesToBeDeleted) {\n        const entities = await manager.find(entityToDelete, {\n          where: { groupPermissionId },\n        });\n\n        for (const entity of entities) {\n          await manager.delete(entityToDelete, entity.id);\n        }\n      }\n\n      await manager.delete(GroupPermission, {\n        organizationId: user.organizationId,\n        id: groupPermissionId,\n      });\n    }, manager);\n  }\n\n  async updateAppGroupPermission(\n    user: User,\n    groupPermissionId: string,\n    appGroupPermissionId: string,\n    actions: any,\n    manager?: EntityManager\n  ) {\n    const appGroupPermission = await this.appGroupPermissionsRepository.findOne({\n      where: {\n        id: appGroupPermissionId,\n        groupPermissionId: groupPermissionId,\n      },\n    });\n    const groupPermission = await this.groupPermissionsRepository.findOne({\n      where: {\n        id: appGroupPermission.groupPermissionId,\n      },\n    });\n\n    if (groupPermission.organizationId !== user.organizationId) {\n      throw new BadRequestException();\n    }\n    if (groupPermission.group == 'admin') {\n      throw new BadRequestException('Cannot update admin group');\n    }\n\n    await dbTransactionWrap(async (manager: EntityManager) => {\n      await manager.update(AppGroupPermission, appGroupPermissionId, actions);\n    }, manager);\n  }\n\n  async update(user: User, groupPermissionId: string, body: any, manager?: EntityManager) {\n    const groupPermission = await this.groupPermissionsRepository.findOne({\n      where: {\n        id: groupPermissionId,\n        organizationId: user.organizationId,\n      },\n    });\n\n    const {\n      name,\n      app_create,\n      app_delete,\n      add_apps,\n      remove_apps,\n      add_users,\n      remove_users,\n      folder_create,\n      org_environment_variable_create,\n      org_environment_variable_update,\n      org_environment_variable_delete,\n      folder_delete,\n      folder_update,\n    } = body;\n\n    await dbTransactionWrap(async (manager: EntityManager) => {\n      //update user group name\n      if (name) {\n        const newName = name.trim();\n        if (!newName) {\n          throw new BadRequestException('Group name should not be empty');\n        }\n\n        const reservedGroups = ['admin', 'all_users'];\n        if (reservedGroups.includes(groupPermission.group)) {\n          throw new BadRequestException('Cannot update a default group name');\n        }\n\n        if (reservedGroups.includes(newName.replace(/ /g, '_').toLowerCase())) {\n          throw new BadRequestException('Group name already exists');\n        }\n\n        const groupToFind = await this.groupPermissionsRepository.findOne({\n          where: {\n            organizationId: user.organizationId,\n            group: newName,\n          },\n        });\n\n        if (groupToFind && groupToFind.id !== groupPermission.id) {\n          throw new ConflictException('Group name already exists');\n        } else if (!groupToFind) {\n          await manager.update(GroupPermission, groupPermissionId, { group: newName });\n        }\n      }\n\n      // update group permissions\n      const groupPermissionUpdateParams = {\n        ...(typeof app_create === 'boolean' && { appCreate: app_create }),\n        ...(typeof app_delete === 'boolean' && { appDelete: app_delete }),\n        ...(typeof folder_create === 'boolean' && { folderCreate: folder_create }),\n        ...(typeof org_environment_variable_create === 'boolean' && {\n          orgEnvironmentVariableCreate: org_environment_variable_create,\n        }),\n        ...(typeof org_environment_variable_update === 'boolean' && {\n          orgEnvironmentVariableUpdate: org_environment_variable_update,\n        }),\n        ...(typeof org_environment_variable_delete === 'boolean' && {\n          orgEnvironmentVariableDelete: org_environment_variable_delete,\n        }),\n        ...(typeof folder_delete === 'boolean' && { folderDelete: folder_delete }),\n        ...(typeof folder_update === 'boolean' && { folderUpdate: folder_update }),\n      };\n      if (Object.keys(groupPermissionUpdateParams).length !== 0) {\n        await manager.update(GroupPermission, groupPermissionId, groupPermissionUpdateParams);\n      }\n\n      // update app group permissions\n      if (remove_apps) {\n        if (groupPermission.group == 'admin') {\n          throw new BadRequestException('Cannot update admin group');\n        }\n        for (const appId of remove_apps) {\n          await manager.delete(AppGroupPermission, {\n            appId: appId,\n            groupPermissionId: groupPermissionId,\n          });\n        }\n      }\n\n      if (add_apps) {\n        if (groupPermission.group == 'admin') {\n          throw new BadRequestException('Cannot update admin group');\n        }\n        for (const appId of add_apps) {\n          await manager.save(\n            AppGroupPermission,\n            manager.create(AppGroupPermission, {\n              appId: appId,\n              groupPermissionId: groupPermissionId,\n              read: true,\n            })\n          );\n        }\n      }\n\n      // update user group permissions\n      if (remove_users) {\n        for (const userId of body.remove_users) {\n          const params = {\n            removeGroups: [groupPermission.group],\n          };\n          await this.usersService.update(userId, params, manager, user.organizationId);\n        }\n      }\n\n      if (add_users) {\n        for (const userId of body.add_users) {\n          const params = {\n            addGroups: [groupPermission.group],\n          };\n          await this.usersService.update(userId, params, manager, user.organizationId);\n        }\n      }\n    }, manager);\n  }\n\n  async findOne(user: User, groupPermissionId: string): Promise<GroupPermission> {\n    return this.groupPermissionsRepository.findOne({\n      where: {\n        organizationId: user.organizationId,\n        id: groupPermissionId,\n      },\n    });\n  }\n\n  async findAll(user: User): Promise<GroupPermission[]> {\n    return this.groupPermissionsRepository.find({\n      where: { organizationId: user.organizationId },\n      order: { createdAt: 'ASC' },\n    });\n  }\n\n  async findApps(user: User, groupPermissionId: string): Promise<App[]> {\n    return createQueryBuilder(App, 'apps')\n      .innerJoinAndSelect('apps.groupPermissions', 'group_permissions')\n      .innerJoinAndSelect('apps.appGroupPermissions', 'app_group_permissions')\n      .where('group_permissions.id = :groupPermissionId', {\n        groupPermissionId,\n      })\n      .andWhere('group_permissions.organization_id = :organizationId', {\n        organizationId: user.organizationId,\n      })\n      .andWhere('app_group_permissions.group_permission_id = :groupPermissionId', { groupPermissionId })\n      .orderBy('apps.created_at', 'DESC')\n      .getMany();\n  }\n\n  async findAddableApps(user: User, groupPermissionId: string): Promise<App[]> {\n    const groupPermission = await this.groupPermissionsRepository.findOne({\n      where: {\n        id: groupPermissionId,\n        organizationId: user.organizationId,\n      },\n    });\n\n    const appsInGroup = await groupPermission.apps;\n    const appsInGroupIds = appsInGroup.map((u) => u.id);\n\n    return await this.appRepository.find({\n      where: {\n        id: Not(In(appsInGroupIds)),\n        organizationId: user.organizationId,\n      },\n      loadEagerRelations: false,\n      relations: ['groupPermissions', 'appGroupPermissions'],\n    });\n  }\n\n  async findUsers(user: User, groupPermissionId: string): Promise<User[]> {\n    return createQueryBuilder(User, 'users')\n      .select(['users.id', 'users.firstName', 'users.lastName', 'users.email'])\n      .innerJoin('users.groupPermissions', 'group_permissions')\n      .innerJoin('users.userGroupPermissions', 'user_group_permissions')\n      .where('group_permissions.id = :groupPermissionId', {\n        groupPermissionId,\n      })\n      .andWhere('group_permissions.organization_id = :organizationId', {\n        organizationId: user.organizationId,\n      })\n      .andWhere('user_group_permissions.group_permission_id = :groupPermissionId', { groupPermissionId })\n      .orderBy('users.created_at', 'DESC')\n      .getMany();\n  }\n\n  async findAddableUsers(user: User, groupPermissionId: string): Promise<User[]> {\n    const groupPermission = await this.groupPermissionsRepository.findOne({\n      where: {\n        id: groupPermissionId,\n        organizationId: user.organizationId,\n      },\n    });\n\n    const userInGroup = await groupPermission.users;\n    const usersInGroupIds = userInGroup.map((u) => u.id);\n\n    const adminUsers = await createQueryBuilder(UserGroupPermission, 'user_group_permissions')\n      .innerJoin(\n        GroupPermission,\n        'group_permissions',\n        'group_permissions.id = user_group_permissions.group_permission_id'\n      )\n      .where('group_permissions.group = :group', { group: 'admin' })\n      .andWhere('group_permissions.organization_id = :organizationId', {\n        organizationId: user.organizationId,\n      })\n      .getMany();\n    const adminUserIds = adminUsers.map((u) => u.userId);\n\n    return await createQueryBuilder(User, 'user')\n      .select(['user.id', 'user.firstName', 'user.lastName'])\n      .innerJoin(\n        'user.organizationUsers',\n        'organization_users',\n        'organization_users.organizationId = :organizationId',\n        { organizationId: user.organizationId }\n      )\n      .where('user.id NOT IN (:...userList)', { userList: [...usersInGroupIds, ...adminUserIds] })\n      .getMany();\n  }\n\n  async createUserGroupPermission(userId: string, groupPermissionId: string, manager?: EntityManager) {\n    await dbTransactionWrap(async (manager: EntityManager) => {\n      await manager.save(\n        manager.create(UserGroupPermission, {\n          userId,\n          groupPermissionId,\n        })\n      );\n    }, manager);\n  }\n}\n", "import * as request from 'supertest';\nimport { INestApplication } from '@nestjs/common';\nimport { authHeaderForUser, clearDB, createUser, createNestAppInstance, createApplication } from '../test.helper';\nimport { getManager } from 'typeorm';\nimport { AppGroupPermission } from 'src/entities/app_group_permission.entity';\nimport { UserGroupPermission } from 'src/entities/user_group_permission.entity';\nimport { GroupPermission } from 'src/entities/group_permission.entity';\n\ndescribe('group permissions controller', () => {\n  let nestApp: INestApplication;\n\n  beforeEach(async () => {\n    await clearDB();\n  });\n\n  beforeAll(async () => {\n    nestApp = await createNestAppInstance();\n  });\n\n  describe('POST /group_permissions', () => {\n    it('should not allow non admin to create group permission', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(defaultUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should be able to create group permission for authenticated admin', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(201);\n\n      const updatedGroup: GroupPermission = await getManager().findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'avengers',\n        },\n      });\n\n      expect(updatedGroup.group).toBe('avengers');\n      expect(updatedGroup.organizationId).toBe(organization.id);\n      expect(updatedGroup.createdAt).toBeDefined();\n      expect(updatedGroup.updatedAt).toBeDefined();\n    });\n\n    it('should not allow to create system defined group names', async () => {\n      const {\n        organization: { adminUser },\n      } = await setupOrganizations(nestApp);\n\n      const reservedGroups = ['All Users', 'Admin'];\n\n      for (let i = 0; i < reservedGroups.length; i += 1) {\n        const response = await request(nestApp.getHttpServer())\n          .post('/api/group_permissions')\n          .set('Authorization', authHeaderForUser(adminUser))\n          .send({ group: reservedGroups[i] });\n\n        expect(response.statusCode).toBe(400);\n        expect(response.body.message).toBe('Group name already exist');\n      }\n    });\n\n    it('should validate uniqueness of group permission group name', async () => {\n      const {\n        organization: { adminUser },\n      } = await setupOrganizations(nestApp);\n      let response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(201);\n\n      response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(409);\n    });\n\n    it('should allow different organization to have same group name', async () => {\n      const {\n        organization: { adminUser },\n        anotherOrganization: { anotherAdminUser },\n      } = await setupOrganizations(nestApp);\n\n      let response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(201);\n\n      response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(anotherAdminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(201);\n    });\n  });\n\n  describe('GET /group_permissions/:id', () => {\n    it('should not allow unauthenticated admin', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .get('/api/group_permissions/id')\n        .set('Authorization', authHeaderForUser(defaultUser));\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should get group permission for authenticated admin within organization', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      let response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(201);\n\n      const updatedGroup: GroupPermission = await getManager().findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'avengers',\n        },\n      });\n\n      response = await request(nestApp.getHttpServer())\n        .get(`/api/group_permissions/${updatedGroup.id}`)\n        .set('Authorization', authHeaderForUser(adminUser));\n\n      expect(response.statusCode).toBe(200);\n      expect(response.body.group).toBe('avengers');\n      expect(response.body.organization_id).toBe(organization.id);\n      expect(response.body.id).toBeDefined();\n      expect(response.body.created_at).toBeDefined();\n      expect(response.body.updated_at).toBeDefined();\n    });\n\n    it('should not get group permission for authenticated admin not within organization', async () => {\n      const {\n        organization: { adminUser },\n        anotherOrganization: { anotherAdminUser },\n      } = await setupOrganizations(nestApp);\n\n      let response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      const groupPermissionId = response.body.id;\n\n      response = await request(nestApp.getHttpServer())\n        .post(`/api/group_permissions/${groupPermissionId}`)\n        .set('Authorization', authHeaderForUser(anotherAdminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(404);\n    });\n  });\n\n  describe('PUT /group_permissions/:id', () => {\n    it('should not allow unauthenticated admin', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .put('/api/group_permissions/id')\n        .set('Authorization', authHeaderForUser(defaultUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should allow admin to update a group name', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      const createResponse = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(createResponse.statusCode).toBe(201);\n\n      let updatedGroup: GroupPermission = await getManager().findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'avengers',\n        },\n      });\n\n      //update a group name\n      const updateResponse = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${updatedGroup.id}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ name: 'titans' });\n\n      expect(updateResponse.statusCode).toBe(200);\n\n      updatedGroup = await getManager().findOne(GroupPermission, updatedGroup.id);\n      expect(updatedGroup.group).toEqual('titans');\n    });\n\n    it('should not be able to update a group name with existing names', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      const createResponse = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(createResponse.statusCode).toBe(201);\n\n      const updatedGroup: GroupPermission = await getManager().findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'avengers',\n        },\n      });\n\n      //update a group name\n      const updateResponse = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${updatedGroup.id}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ name: 'All users' });\n\n      expect(updateResponse.statusCode).toBe(400);\n    });\n\n    it('should not be able to update a default group name', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      const adminGroup = await getManager().findOne(GroupPermission, {\n        where: { group: 'admin', organizationId: organization.id },\n      });\n\n      //update a group name\n      const updateResponse = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${adminGroup.id}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ name: 'titans' });\n\n      expect(updateResponse.statusCode).toBe(400);\n    });\n\n    it('should allow admin to add and remove apps to group permission', async () => {\n      const {\n        organization: { adminUser, app, organization },\n      } = await setupOrganizations(nestApp);\n\n      let response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(201);\n\n      const updatedGroup: GroupPermission = await getManager().findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'avengers',\n        },\n      });\n\n      const groupPermissionId = updatedGroup.id;\n\n      response = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${groupPermissionId}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ add_apps: [app.id] });\n\n      expect(response.statusCode).toBe(200);\n\n      const manager = getManager();\n      let appsInGroup = await manager.find(AppGroupPermission, {\n        where: { groupPermissionId },\n      });\n\n      expect(appsInGroup).toHaveLength(1);\n\n      const addedApp = appsInGroup[0];\n\n      expect(addedApp.appId).toBe(app.id);\n      expect(addedApp.read).toBe(true);\n      expect(addedApp.update).toBe(false);\n      expect(addedApp.delete).toBe(false);\n\n      response = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${groupPermissionId}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ remove_apps: [app.id] });\n\n      expect(response.statusCode).toBe(200);\n\n      appsInGroup = await manager.find(AppGroupPermission, {\n        where: { groupPermissionId },\n      });\n\n      expect(appsInGroup).toHaveLength(0);\n    });\n\n    it('should allow admin to add and remove users to group permission', async () => {\n      const {\n        organization: { adminUser, defaultUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      let response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      const updatedGroup: GroupPermission = await getManager().findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'avengers',\n        },\n      });\n      const groupPermissionId = updatedGroup.id;\n\n      response = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${groupPermissionId}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ add_users: [defaultUser.id] });\n\n      expect(response.statusCode).toBe(200);\n\n      const manager = getManager();\n      let usersInGroup = await manager.find(UserGroupPermission, {\n        where: { groupPermissionId },\n      });\n\n      expect(usersInGroup).toHaveLength(1);\n\n      const addedUser = usersInGroup[0];\n\n      expect(addedUser.userId).toBe(defaultUser.id);\n\n      response = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${groupPermissionId}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ remove_users: [defaultUser.id] });\n\n      expect(response.statusCode).toBe(200);\n\n      usersInGroup = await manager.find(UserGroupPermission, {\n        where: { groupPermissionId },\n      });\n\n      expect(usersInGroup).toHaveLength(0);\n    });\n\n    it('should not allow to remove users from admin group permission without any at least one active admin', async () => {\n      const { user, organization } = await createUser(nestApp, {\n        email: 'admin@tooljet.io',\n      });\n\n      const manager = getManager();\n      const adminGroupPermission = await manager.findOneOrFail(GroupPermission, {\n        where: {\n          group: 'admin',\n          organizationId: organization.id,\n        },\n      });\n\n      const response = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${adminGroupPermission.id}`)\n        .set('Authorization', authHeaderForUser(user))\n        .send({ remove_users: [user.id] });\n\n      expect(response.statusCode).toBe(400);\n      expect(response.body.message).toBe('Atleast one active admin is required.');\n    });\n\n    it('should not allow to remove any users from all_users group permission', async () => {\n      const {\n        organization: { adminUser, defaultUser },\n      } = await setupOrganizations(nestApp);\n\n      const manager = getManager();\n      const adminGroupPermission = await manager.findOneOrFail(GroupPermission, {\n        where: {\n          group: 'all_users',\n          organizationId: adminUser.organizationId,\n        },\n      });\n\n      const response = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${adminGroupPermission.id}/`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ remove_users: [defaultUser.id] });\n\n      expect(response.statusCode).toBe(400);\n      expect(response.body.message).toBe('Cannot remove user from default group.');\n    });\n  });\n\n  describe('GET /group_permissions', () => {\n    it('should not allow unauthenticated admin', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .get('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(defaultUser));\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should allow admin to list group permission', async () => {\n      const {\n        organization: { adminUser, defaultUser, app, organization },\n      } = await setupOrganizations(nestApp);\n\n      // create group permission\n      let response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(201);\n\n      const updatedGroup: GroupPermission = await getManager().findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'avengers',\n        },\n      });\n\n      const groupPermissionId = updatedGroup.id;\n\n      // add apps and users to group permission\n      response = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${groupPermissionId}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ add_apps: [app.id], add_users: [defaultUser.id] });\n\n      expect(response.statusCode).toBe(200);\n\n      // list group permission\n      response = await request(nestApp.getHttpServer())\n        .get('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser));\n      expect(response.statusCode).toBe(200);\n\n      const groupPermissions = response.body.group_permissions;\n      const groups = groupPermissions.map((gp) => gp.group);\n      const organizationId = [...new Set(groupPermissions.map((gp) => gp.organization_id))];\n\n      expect(new Set(groups)).toEqual(new Set(['avengers', 'all_users', 'admin']));\n      expect(organizationId).toEqual([organization.id]);\n    });\n  });\n\n  describe('GET /group_permissions/:id/apps', () => {\n    it('should not allow unauthenticated admin', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .get('/api/group_permissions/id/apps')\n        .set('Authorization', authHeaderForUser(defaultUser));\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should allow admin to list apps in group permission', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      const manager = getManager();\n      const adminGroupPermission = await manager.findOneOrFail(GroupPermission, {\n        where: {\n          group: 'admin',\n          organizationId: organization.id,\n        },\n      });\n\n      const response = await request(nestApp.getHttpServer())\n        .get(`/api/group_permissions/${adminGroupPermission.id}/apps`)\n        .set('Authorization', authHeaderForUser(adminUser));\n\n      expect(response.statusCode).toBe(200);\n\n      const apps = response.body.apps;\n      const sampleApp = apps[0];\n\n      expect(apps).toHaveLength(1);\n      expect(sampleApp.organization_id).toBe(organization.id);\n      expect(sampleApp.name).toBe('sample app');\n\n      expect(sampleApp.group_permissions).toHaveLength(1);\n      expect(sampleApp.group_permissions[0].group).toBe('admin');\n\n      expect(sampleApp.app_group_permissions).toHaveLength(1);\n      expect(sampleApp.app_group_permissions[0].group_permission_id).toBe(sampleApp.group_permissions[0].id);\n      expect(sampleApp.app_group_permissions[0].read).toBe(true);\n      expect(sampleApp.app_group_permissions[0].update).toBe(true);\n      expect(sampleApp.app_group_permissions[0].delete).toBe(true);\n    });\n  });\n\n  describe('GET /group_permissions/:id/addable_apps', () => {\n    it('should not allow unauthenticated admin', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .get('/api/group_permissions/id/addable_apps')\n        .set('Authorization', authHeaderForUser(defaultUser));\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should allow admin to list apps not in group permission', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      // create group permission\n      let response = await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(201);\n\n      const manager = getManager();\n      const groupPermission: GroupPermission = await manager.findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'avengers',\n        },\n      });\n\n      const groupPermissionId = groupPermission.id;\n\n      response = await request(nestApp.getHttpServer())\n        .get(`/api/group_permissions/${groupPermissionId}/addable_apps`)\n        .set('Authorization', authHeaderForUser(adminUser));\n\n      expect(response.statusCode).toBe(200);\n\n      const apps = response.body.apps;\n      const sampleApp = apps[0];\n\n      expect(apps).toHaveLength(1);\n      expect(sampleApp.organization_id).toBe(organization.id);\n      expect(sampleApp.name).toBe('sample app');\n      expect(sampleApp.group_permissions).toHaveLength(2);\n\n      const adminGroupPermission = sampleApp.group_permissions.find((a) => a.group == 'admin');\n      const adminAppGroupPermission = sampleApp.app_group_permissions.find(\n        (a) => a.group_permission_id == adminGroupPermission.id\n      );\n      expect(adminAppGroupPermission.read).toBe(true);\n      expect(adminAppGroupPermission.update).toBe(true);\n      expect(adminAppGroupPermission.delete).toBe(true);\n\n      const userGroupPermission = sampleApp.group_permissions.find((a) => a.group == 'all_users');\n      const userAppGroupPermission = sampleApp.app_group_permissions.find(\n        (a) => a.group_permission_id == userGroupPermission.id\n      );\n      expect(userAppGroupPermission.read).toBe(false);\n      expect(userAppGroupPermission.update).toBe(false);\n      expect(userAppGroupPermission.delete).toBe(false);\n    });\n  });\n\n  describe('GET /group_permissions/:id/users', () => {\n    it('should not allow unauthenticated admin', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .get('/api/group_permissions/id/users')\n        .set('Authorization', authHeaderForUser(defaultUser));\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should allow admin to list users in group permission', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      const manager = getManager();\n      const adminGroupPermission = await manager.findOneOrFail(GroupPermission, {\n        where: {\n          group: 'admin',\n          organizationId: organization.id,\n        },\n      });\n\n      const response = await request(nestApp.getHttpServer())\n        .get(`/api/group_permissions/${adminGroupPermission.id}/users`)\n        .set('Authorization', authHeaderForUser(adminUser));\n\n      expect(response.statusCode).toBe(200);\n\n      const users = response.body.users;\n\n      const user = users[0];\n\n      expect(users).toHaveLength(1);\n      expect(Object.keys(user).sort()).toEqual(['id', 'email', 'first_name', 'last_name'].sort());\n      expect(user.email).toBe('admin@tooljet.io');\n      expect(user.first_name).toBe('test');\n      expect(user.last_name).toBe('test');\n    });\n  });\n\n  describe('GET /group_permissions/:id/addable_users', () => {\n    it('should not allow unauthenticated admin', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .get('/api/group_permissions/id/addable_users')\n        .set('Authorization', authHeaderForUser(defaultUser));\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should allow admin to list users not in group permission', async () => {\n      const adminUser = await createUser(nestApp, { email: 'admin@tooljet.io' });\n      const userone = await createUser(nestApp, {\n        email: 'userone@tooljet.io',\n        groups: ['all_users'],\n        organization: adminUser.organization,\n      });\n\n      const manager = getManager();\n      const adminGroupPermission = await manager.findOneOrFail(GroupPermission, {\n        where: {\n          group: 'admin',\n          organizationId: adminUser.organization.id,\n        },\n      });\n      const groupPermissionId = adminGroupPermission.id;\n      const response = await request(nestApp.getHttpServer())\n        .get(`/api/group_permissions/${groupPermissionId}/addable_users`)\n        .set('Authorization', authHeaderForUser(adminUser.user));\n\n      expect(response.statusCode).toBe(200);\n\n      const users = response.body.users;\n      const user = users[0];\n\n      expect(users).toHaveLength(1);\n      expect(user.first_name).toBe('test');\n      expect(user.last_name).toBe('test');\n      expect(user.id).toBe(userone.user.id);\n      expect(Object.keys(user).sort()).toEqual(['first_name', 'last_name', 'id'].sort());\n    });\n  });\n\n  describe('PUT /group_permissions/:id/app_group_permissions/:appGroupPermisionId', () => {\n    it('should not allow unauthenticated admin', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .put('/api/group_permissions/id/app_group_permissions/id')\n        .set('Authorization', authHeaderForUser(defaultUser))\n        .send({ read: true });\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should allow admin to update app group permission', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      const manager = getManager();\n      const groupPermission = await manager.findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'all_users',\n        },\n      });\n      const groupPermissionId = groupPermission.id;\n      const appGroupPermission = await manager.findOneOrFail(AppGroupPermission, {\n        where: {\n          groupPermissionId,\n        },\n      });\n      const appGroupPermissionId = appGroupPermission.id;\n\n      expect(appGroupPermission.read).toBe(false);\n      expect(appGroupPermission.update).toBe(false);\n\n      const response = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${groupPermissionId}/app_group_permissions/${appGroupPermissionId}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ actions: { read: false, update: true } });\n\n      expect(response.statusCode).toBe(200);\n\n      await appGroupPermission.reload();\n\n      expect(appGroupPermission.read).toBe(false);\n      expect(appGroupPermission.update).toBe(true);\n    });\n\n    it('should not allow admin to update app group permission of different organization', async () => {\n      const {\n        organization: { organization },\n        anotherOrganization: { anotherAdminUser },\n      } = await setupOrganizations(nestApp);\n\n      const manager = getManager();\n      const groupPermission = await manager.findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'all_users',\n        },\n      });\n      const groupPermissionId = groupPermission.id;\n      const appGroupPermission = await manager.findOneOrFail(AppGroupPermission, {\n        where: {\n          groupPermissionId,\n        },\n      });\n      const appGroupPermissionId = appGroupPermission.id;\n\n      expect(appGroupPermission.read).toBe(false);\n      expect(appGroupPermission.update).toBe(false);\n\n      const response = await request(nestApp.getHttpServer())\n        .put(`/api/group_permissions/${groupPermissionId}/app_group_permissions/${appGroupPermissionId}`)\n        .set('Authorization', authHeaderForUser(anotherAdminUser))\n        .send({ actions: { read: false, update: true } });\n\n      expect(response.statusCode).toBe(400);\n    });\n  });\n\n  describe('DELETE /group_permissions/:id', () => {\n    it('should not allow unauthenicated admin', async () => {\n      const {\n        organization: { defaultUser },\n      } = await setupOrganizations(nestApp);\n      const response = await request(nestApp.getHttpServer())\n        .del('/api/group_permissions/id')\n        .set('Authorization', authHeaderForUser(defaultUser))\n        .send({ read: true });\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should allow admin to delete group', async () => {\n      const {\n        organization: { adminUser, organization },\n      } = await setupOrganizations(nestApp);\n\n      await request(nestApp.getHttpServer())\n        .post('/api/group_permissions')\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      const manager = getManager();\n      const groupPermission: GroupPermission = await manager.findOneOrFail(GroupPermission, {\n        where: {\n          organizationId: organization.id,\n          group: 'avengers',\n        },\n      });\n\n      const response = await request(nestApp.getHttpServer())\n        .del(`/api/group_permissions/${groupPermission.id}`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ group: 'avengers' });\n\n      expect(response.statusCode).toBe(200);\n    });\n  });\n\n  async function setupOrganizations(nestApp) {\n    const adminUserData = await createUser(nestApp, {\n      email: 'admin@tooljet.io',\n      groups: ['all_users', 'admin'],\n    });\n    const adminUser = adminUserData.user;\n    const organization = adminUserData.organization;\n    const defaultUserData = await createUser(nestApp, {\n      email: 'developer@tooljet.io',\n      groups: ['all_users'],\n      organization,\n    });\n    const defaultUser = defaultUserData.user;\n\n    const app = await createApplication(nestApp, {\n      user: adminUser,\n      name: 'sample app',\n      isPublic: false,\n    });\n\n    const anotherAdminUserData = await createUser(nestApp, {\n      email: 'another_admin@tooljet.io',\n      groups: ['all_users', 'admin'],\n    });\n    const anotherAdminUser = anotherAdminUserData.user;\n    const anotherOrganization = anotherAdminUserData.organization;\n    const anotherDefaultUserData = await createUser(nestApp, {\n      email: 'another_developer@tooljet.io',\n      groups: ['all_users'],\n      organization: anotherOrganization,\n    });\n    const anotherDefaultUser = anotherDefaultUserData.user;\n\n    const anotherApp = await createApplication(nestApp, {\n      user: anotherAdminUser,\n      name: 'another app',\n      isPublic: false,\n    });\n\n    return {\n      organization: { adminUser, defaultUser, organization, app },\n      anotherOrganization: {\n        anotherAdminUser,\n        anotherDefaultUser,\n        anotherOrganization,\n        anotherApp,\n      },\n    };\n  }\n\n  afterAll(async () => {\n    await nestApp.close();\n  });\n});\n"], "filenames": ["server/src/services/group_permissions.service.ts", "server/test/controllers/group_permissions.e2e-spec.ts"], "buggy_code_start_loc": [306, 631], "buggy_code_end_loc": [308, 632], "fixing_code_start_loc": [306, 631], "fixing_code_end_loc": [309, 635], "type": "CWE-269", "message": "Account Takeover :: when see the info i can see the hash pass i can creaked it ............... Account Takeover :: when see the info i can see the forgot_password_token the hacker can send the request and changed the pass", "other": {"cve": {"id": "CVE-2022-3422", "sourceIdentifier": "security@huntr.dev", "published": "2022-10-07T11:15:09.563", "lastModified": "2022-10-07T20:31:43.120", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Account Takeover :: when see the info i can see the hash pass i can creaked it ............... Account Takeover :: when see the info i can see the forgot_password_token the hacker can send the request and changed the pass"}, {"lang": "es", "value": "Toma de Control de la Cuenta :: cuando visualizo la informaci\u00f3n puedo visualizar el pase de hash y lo puedo crujir ............... Toma de Control de la Cuenta :: cuando visualizo la informaci\u00f3n puedo visualizar el forgot_password_token el hacker puede enviar la petici\u00f3n y cambiar el pass"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tooljet:tooljet:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.26.1", "matchCriteriaId": "0E1F1716-7DEC-4C53-9216-1B3441099089"}]}]}], "references": [{"url": "https://github.com/tooljet/tooljet/commit/7879d8a76000c014533a97a22bc276afe3ae3e54", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/02da53ab-f613-4171-8766-96b31c671551", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tooljet/tooljet/commit/7879d8a76000c014533a97a22bc276afe3ae3e54"}}