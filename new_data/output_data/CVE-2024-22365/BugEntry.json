{"buggy_code": ["/******************************************************************************\n * A module for Linux-PAM that will set the default namespace after\n * establishing a session via PAM.\n *\n * (C) Copyright IBM Corporation 2005\n * (C) Copyright Red Hat, Inc. 2006, 2008\n * All Rights Reserved.\n *\n * Written by: Janak Desai <janak@us.ibm.com>\n * With Revisions by: Steve Grubb <sgrubb@redhat.com>\n * Contributions by: Xavier Toth <txtoth@gmail.com>,\n *                   Tomas Mraz <tmraz@redhat.com>\n * Derived from a namespace setup patch by Chad Sellers <cdselle@tycho.nsa.gov>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * on the rights to use, copy, modify, merge, publish, distribute, sub\n * license, and/or sell copies of the Software, and to permit persons to whom\n * the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL\n * IBM AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n#define _ATFILE_SOURCE\n\n#include \"pam_cc_compat.h\"\n#include \"pam_inline.h\"\n#include \"pam_namespace.h\"\n#include \"argv_parse.h\"\n\n/* --- evaluating all files in VENDORDIR/security/namespace.d and /etc/security/namespace.d --- */\nstatic const char *base_name(const char *path)\n{\n    const char *base = strrchr(path, '/');\n    return base ? base+1 : path;\n}\n\nstatic int\ncompare_filename(const void *a, const void *b)\n{\n\treturn strcmp(base_name(* (char * const *) a),\n\t\t      base_name(* (char * const *) b));\n}\n\nstatic void close_fds_pre_exec(struct instance_data *idata)\n{\n\tif (pam_modutil_sanitize_helper_fds(idata->pamh, PAM_MODUTIL_IGNORE_FD,\n\t\t\tPAM_MODUTIL_IGNORE_FD, PAM_MODUTIL_IGNORE_FD) < 0) {\n\t\t_exit(1);\n\t}\n}\n\n/* Evaluating a list of files which have to be parsed in the right order:\n *\n * - If etc/security/namespace.d/@filename@.conf exists, then\n *   %vendordir%/security/namespace.d/@filename@.conf should not be used.\n * - All files in both namespace.d directories are sorted by their @filename@.conf in\n *   lexicographic order regardless of which of the directories they reside in. */\nstatic char **read_namespace_dir(struct instance_data *idata)\n{\n\tglob_t globbuf;\n\tsize_t i=0;\n\tint glob_rv = glob(NAMESPACE_D_GLOB, GLOB_ERR | GLOB_NOSORT, NULL, &globbuf);\n\tchar **file_list;\n\tsize_t file_list_size = glob_rv == 0 ? globbuf.gl_pathc : 0;\n\n#ifdef VENDOR_NAMESPACE_D_GLOB\n\tglob_t globbuf_vendor;\n\tint glob_rv_vendor = glob(VENDOR_NAMESPACE_D_GLOB, GLOB_ERR | GLOB_NOSORT, NULL, &globbuf_vendor);\n\tif (glob_rv_vendor == 0)\n\t    file_list_size += globbuf_vendor.gl_pathc;\n#endif\n\tfile_list = malloc((file_list_size + 1) * sizeof(char*));\n\tif (file_list == NULL) {\n\t    pam_syslog(idata->pamh, LOG_ERR, \"Cannot allocate memory for file list: %m\");\n#ifdef VENDOR_NAMESPACE_D_GLOB\n\t    if (glob_rv_vendor == 0)\n\t\tglobfree(&globbuf_vendor);\n#endif\n\t    if (glob_rv == 0)\n\t\tglobfree(&globbuf);\n\t    return NULL;\n\t}\n\n\tif (glob_rv == 0) {\n\t    for (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tfile_list[i] = strdup(globbuf.gl_pathv[i]);\n\t\tif (file_list[i] == NULL) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR, \"strdup failed: %m\");\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#ifdef VENDOR_NAMESPACE_D_GLOB\n\tif (glob_rv_vendor == 0) {\n\t    for (size_t j = 0; j < globbuf_vendor.gl_pathc; j++) {\n\t\tif (glob_rv == 0 && globbuf.gl_pathc > 0) {\n\t\t    int double_found = 0;\n\t\t    for (size_t k = 0; k < globbuf.gl_pathc; k++) {\n\t\t\tif (strcmp(base_name(globbuf.gl_pathv[k]),\n\t\t\t\t   base_name(globbuf_vendor.gl_pathv[j])) == 0) {\n\t\t\t\tdouble_found = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\t\t    if (double_found)\n\t\t\tcontinue;\n\t\t}\n\t\tfile_list[i] = strdup(globbuf_vendor.gl_pathv[j]);\n\t\tif (file_list[i] == NULL) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR, \"strdup failed: %m\");\n\t\t    break;\n\t\t}\n\t\ti++;\n\t    }\n\t    globfree(&globbuf_vendor);\n\t}\n#endif\n\tfile_list[i] = NULL;\n\tqsort(file_list, i, sizeof(char *), compare_filename);\n\tif (glob_rv == 0)\n\t    globfree(&globbuf);\n\n\treturn file_list;\n}\n\n/*\n * Adds an entry for a polyinstantiated directory to the linked list of\n * polyinstantiated directories. It is called from process_line() while\n * parsing the namespace configuration file.\n */\nstatic void add_polydir_entry(struct instance_data *idata,\n\tstruct polydir_s *ent)\n{\n    /* Now attach to linked list */\n    ent->next = NULL;\n    if (idata->polydirs_ptr == NULL)\n        idata->polydirs_ptr = ent;\n    else {\n        struct polydir_s *tail;\n\n        tail = idata->polydirs_ptr;\n        while (tail->next)\n            tail = tail->next;\n        tail->next = ent;\n    }\n}\n\nstatic void del_polydir(struct polydir_s *poly)\n{\n\tif (poly) {\n\t\tfree(poly->uid);\n\t\tfree(poly->init_script);\n\t\tfree(poly->mount_opts);\n\t\tfree(poly);\n\t}\n}\n\n/*\n * Deletes all the entries in the linked list.\n */\nstatic void del_polydir_list(struct polydir_s *polydirs_ptr)\n{\n        struct polydir_s *dptr = polydirs_ptr;\n\n\twhile (dptr) {\n\t\tstruct polydir_s *tptr = dptr;\n\t\tdptr = dptr->next;\n\t\tdel_polydir(tptr);\n\t}\n}\n\nstatic void unprotect_dirs(struct protect_dir_s *dir)\n{\n\tstruct protect_dir_s *next;\n\n\twhile (dir != NULL) {\n\t\tumount(dir->dir);\n\t\tfree(dir->dir);\n\t\tnext = dir->next;\n\t\tfree(dir);\n\t\tdir = next;\n\t}\n}\n\nstatic void cleanup_polydir_data(pam_handle_t *pamh UNUSED , void *data, int err UNUSED)\n{\n\tdel_polydir_list(data);\n}\n\nstatic void cleanup_protect_data(pam_handle_t *pamh UNUSED , void *data, int err UNUSED)\n{\n\tunprotect_dirs(data);\n}\n\nstatic char *expand_variables(const char *orig, const char *var_names[], const char *var_values[])\n{\n\tconst char *src = orig;\n\tchar *dst;\n\tchar *expanded;\n\tchar c;\n\tsize_t dstlen = 0;\n\twhile (*src) {\n\t\tif (*src == '$') {\n\t\t\tint i;\n\t\t\tfor (i = 0; var_names[i]; i++) {\n\t\t\t\tsize_t namelen = strlen(var_names[i]);\n\t\t\t\tif (strncmp(var_names[i], src+1, namelen) == 0) {\n\t\t\t\t\tdstlen += strlen(var_values[i]) - 1; /* $ */\n\t\t\t\t\tsrc += namelen;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++dstlen;\n\t\t++src;\n\t}\n\tif ((dst=expanded=malloc(dstlen + 1)) == NULL)\n\t\treturn NULL;\n\tsrc = orig;\n\twhile ((c=*src) != '\\0') {\n\t\tif (c == '$') {\n\t\t\tint i;\n\t\t\tfor (i = 0; var_names[i]; i++) {\n\t\t\t\tsize_t namelen = strlen(var_names[i]);\n\t\t\t\tif (strncmp(var_names[i], src+1, namelen) == 0) {\n\t\t\t\t\tdst = stpcpy(dst, var_values[i]);\n\t\t\t\t\t--dst;\n\t\t\t\t\tc = *dst; /* replace $ */\n\t\t\t\t\tsrc += namelen;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*dst = c;\n\t\t++dst;\n\t\t++src;\n\t}\n\t*dst = '\\0';\n\treturn expanded;\n}\n\nstatic int parse_create_params(char *params, struct polydir_s *poly)\n{\n    char *next;\n    struct passwd *pwd = NULL;\n    struct group *grp;\n\n    poly->mode = (mode_t)ULONG_MAX;\n    poly->owner = (uid_t)ULONG_MAX;\n    poly->group = (gid_t)ULONG_MAX;\n\n    if (*params != '=')\n\treturn 0;\n    params++;\n\n    next = strchr(params, ',');\n    if (next != NULL) {\n\t*next = '\\0';\n\tnext++;\n    }\n\n    if (*params != '\\0') {\n\terrno = 0;\n\tpoly->mode = (mode_t)strtoul(params, NULL, 0);\n\tif (errno != 0) {\n\t    poly->mode = (mode_t)ULONG_MAX;\n\t}\n    }\n\n    params = next;\n    if (params == NULL)\n\treturn 0;\n    next = strchr(params, ',');\n    if (next != NULL) {\n\t*next = '\\0';\n\tnext++;\n    }\n\n    if (*params != '\\0') {\n\tpwd = getpwnam(params); /* session modules are not reentrant */\n\tif (pwd == NULL)\n\t    return -1;\n\tpoly->owner = pwd->pw_uid;\n    }\n\n    params = next;\n    if (params == NULL || *params == '\\0') {\n\tif (pwd != NULL)\n\t    poly->group = pwd->pw_gid;\n\treturn 0;\n    }\n    grp = getgrnam(params);\n    if (grp == NULL)\n\treturn -1;\n    poly->group = grp->gr_gid;\n\n    return 0;\n}\n\nstatic int parse_iscript_params(char *params, struct polydir_s *poly)\n{\n    if (*params != '=')\n\treturn 0;\n    params++;\n\n    if (*params != '\\0') {\n\tif (*params != '/') { /* path is relative to NAMESPACE_D_DIR */\n\t\tif (asprintf(&poly->init_script, \"%s%s\", NAMESPACE_D_DIR, params) == -1)\n\t\t\treturn -1;\n\t} else {\n\t\tpoly->init_script = strdup(params);\n\t}\n\tif (poly->init_script == NULL)\n\t\treturn -1;\n    }\n    return 0;\n}\n\nstruct mntflag {\n    const char *name;\n    size_t len;\n    unsigned long flag;\n};\n\n#define LITERAL_AND_LEN(x) x, sizeof(x) - 1\n\nstatic const struct mntflag mntflags[] = {\n\t{ LITERAL_AND_LEN(\"noexec\"), MS_NOEXEC },\n\t{ LITERAL_AND_LEN(\"nosuid\"), MS_NOSUID },\n\t{ LITERAL_AND_LEN(\"nodev\"), MS_NODEV }\n    };\n\nstatic int filter_mntopts(const char *opts, char **filtered,\n\t\tunsigned long *mountflags)\n{\n    size_t origlen = strlen(opts);\n    const char *end;\n    char *dest;\n\n    dest = *filtered = NULL;\n    *mountflags = 0;\n\n    if (origlen == 0)\n\treturn 0;\n\n    do {\n\tsize_t len;\n\tunsigned int i;\n\n\tend = strchr(opts, ',');\n\tif (end == NULL) {\n\t    len = strlen(opts);\n\t} else {\n\t    len = end - opts;\n\t}\n\n\tfor (i = 0; i < PAM_ARRAY_SIZE(mntflags); i++) {\n\t    if (mntflags[i].len != len)\n\t\tcontinue;\n\t    if (memcmp(mntflags[i].name, opts, len) == 0) {\n\t\t*mountflags |= mntflags[i].flag;\n\t\topts = end;\n\t\tbreak;\n\t    }\n\t}\n\n\tif (opts != end) {\n\t    if (dest != NULL) {\n\t\t*dest = ',';\n\t\t++dest;\n\t    } else {\n\t\tdest = *filtered = calloc(1, origlen + 1);\n\t\tif (dest == NULL)\n\t\t    return -1;\n\t    }\n\t    memcpy(dest, opts, len);\n\t    dest += len;\n\t}\n\n\topts = end + 1;\n    } while (end != NULL);\n\n    return 0;\n}\n\nstatic int parse_method(char *method, struct polydir_s *poly,\n\t\tstruct instance_data *idata)\n{\n    enum polymethod pm;\n    char *sptr = NULL;\n    static const char *method_names[] = { \"user\", \"context\", \"level\", \"tmpdir\",\n\t\"tmpfs\", NULL };\n    static const char *flag_names[] = { \"create\", \"noinit\", \"iscript\",\n\t\"shared\", \"mntopts\", NULL };\n    static const unsigned int flag_values[] = { POLYDIR_CREATE, POLYDIR_NOINIT,\n\tPOLYDIR_ISCRIPT, POLYDIR_SHARED, POLYDIR_MNTOPTS };\n    int i;\n    char *flag;\n\n    method = strtok_r(method, \":\", &sptr);\n    pm = NONE;\n\n    for (i = 0; method_names[i]; i++) {\n\tif (strcmp(method, method_names[i]) == 0) {\n\t\tpm = i + 1; /* 0 = NONE */\n\t}\n    }\n\n    if (pm == NONE) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Unknown method\");\n        return -1;\n    }\n\n    poly->method = pm;\n\n    while ((flag=strtok_r(NULL, \":\", &sptr)) != NULL) {\n\tfor (i = 0; flag_names[i]; i++) {\n\t\tsize_t namelen = strlen(flag_names[i]);\n\n\t\tif (strncmp(flag, flag_names[i], namelen) == 0) {\n\t\t\tpoly->flags |= flag_values[i];\n\t\t\tswitch (flag_values[i]) {\n\t\t\t    case POLYDIR_CREATE:\n\t\t\t\tif (parse_create_params(flag+namelen, poly) != 0) {\n\t\t\t\t        pam_syslog(idata->pamh, LOG_CRIT, \"Invalid create parameters\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t    case POLYDIR_ISCRIPT:\n\t\t\t\tif (parse_iscript_params(flag+namelen, poly) != 0) {\n\t\t\t\t        pam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\t    case POLYDIR_MNTOPTS:\n\t\t\t\tif (flag[namelen] != '=')\n\t\t\t\t\tbreak;\n\t\t\t\tif (poly->method != TMPFS) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_WARNING, \"Mount options applicable only to tmpfs method\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfree(poly->mount_opts); /* if duplicate mntopts specified */\n\t\t\t\tpoly->mount_opts = NULL;\n\t\t\t\tif (filter_mntopts(flag+namelen+1, &poly->mount_opts, &poly->mount_flags) != 0) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n    }\n\n    return 0;\n}\n\n/*\n * Called from parse_config_file, this function processes a single line\n * of the namespace configuration file. It skips over comments and incomplete\n * or malformed lines. It processes a valid line with information on\n * polyinstantiating a directory by populating appropriate fields of a\n * polyinstantiated directory structure and then calling add_polydir_entry to\n * add that entry to the linked list of polyinstantiated directories.\n */\nstatic int process_line(char *line, const char *home, const char *rhome,\n\t\t\tstruct instance_data *idata)\n{\n    char *dir = NULL, *instance_prefix = NULL, *rdir = NULL;\n    char *method, *uids;\n    char *tptr;\n    struct polydir_s *poly;\n    int retval = 0;\n    char **config_options = NULL;\n    static const char *var_names[] = {\"HOME\", \"USER\", NULL};\n    const char *var_values[] = {home, idata->user};\n    const char *rvar_values[] = {rhome, idata->ruser};\n    size_t len;\n\n    /*\n     * skip the leading white space\n     */\n    while (*line && isspace((unsigned char)*line))\n        line++;\n\n    /*\n     * Rip off the comments\n     */\n    tptr = strchr(line,'#');\n    if (tptr)\n        *tptr = '\\0';\n\n    /*\n     * Rip off the newline char\n     */\n    tptr = strchr(line,'\\n');\n    if (tptr)\n        *tptr = '\\0';\n\n    /*\n     * Anything left ?\n     */\n    if (line[0] == 0)\n        return 0;\n\n    poly = calloc(1, sizeof(*poly));\n    if (poly == NULL)\n\tgoto erralloc;\n\n    /*\n     * Initialize and scan the five strings from the line from the\n     * namespace configuration file.\n     */\n    retval = argv_parse(line, NULL, &config_options);\n    if (retval != 0) {\n        goto erralloc;\n    }\n\n    dir = config_options[0];\n    if (dir == NULL) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing polydir\");\n        goto skipping;\n    }\n    instance_prefix = config_options[1];\n    if (instance_prefix == NULL) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing instance_prefix\");\n        dir = NULL;\n        goto skipping;\n    }\n    method = config_options[2];\n    if (method == NULL) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing method\");\n        instance_prefix = NULL;\n        dir = NULL;\n        goto skipping;\n    }\n\n    /*\n     * Only the uids field is allowed to be blank, to indicate no\n     * override users for polyinstantiation of that directory. If\n     * any of the other fields are blank, the line is incomplete so\n     * skip it.\n     */\n    uids = config_options[3];\n\n    /*\n     * Expand $HOME and $USER in poly dir and instance dir prefix\n     */\n    if ((rdir=expand_variables(dir, var_names, rvar_values)) == NULL) {\n\t    instance_prefix = NULL;\n\t    dir = NULL;\n\t    goto erralloc;\n    }\n\n    if ((dir=expand_variables(dir, var_names, var_values)) == NULL) {\n\t    instance_prefix = NULL;\n\t    goto erralloc;\n    }\n\n    if ((instance_prefix=expand_variables(instance_prefix, var_names, var_values))\n\t    == NULL) {\n\t    goto erralloc;\n    }\n\n    if (idata->flags & PAMNS_DEBUG) {\n\t    pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded polydir: '%s'\", dir);\n\t    pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded ruser polydir: '%s'\", rdir);\n\t    pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded instance prefix: '%s'\", instance_prefix);\n    }\n\n    len = strlen(dir);\n    if (len > 0 && dir[len-1] == '/') {\n\t    dir[len-1] = '\\0';\n    }\n\n    len = strlen(rdir);\n    if (len > 0 && rdir[len-1] == '/') {\n\t    rdir[len-1] = '\\0';\n    }\n\n    if (dir[0] == '\\0' || rdir[0] == '\\0') {\n\t    pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid polydir\");\n\t    goto skipping;\n    }\n\n    /*\n     * Populate polyinstantiated directory structure with appropriate\n     * pathnames and the method with which to polyinstantiate.\n     */\n    if (parse_method(method, poly, idata) != 0) {\n\t    goto skipping;\n    }\n\n#define COPY_STR(dst, src, apd)                                \\\n\t(snprintf((dst), sizeof(dst), \"%s%s\", (src), (apd)) != \\\n\t\t  (ssize_t) (strlen(src) + strlen(apd)))\n\n    if (COPY_STR(poly->dir, dir, \"\")\n\t|| COPY_STR(poly->rdir, rdir, \"\")\n\t|| COPY_STR(poly->instance_prefix, instance_prefix,\n\t\t    poly->method == TMPDIR ? \"XXXXXX\" : \"\")) {\n\tpam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames too long\");\n\tgoto skipping;\n    }\n\n    /*\n     * Ensure that all pathnames are absolute path names.\n     */\n    if ((poly->dir[0] != '/') || (poly->method != TMPFS && poly->instance_prefix[0] != '/')) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames must start with '/'\");\n        goto skipping;\n    }\n    if (strstr(dir, \"..\") || strstr(poly->instance_prefix, \"..\")) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames must not contain '..'\");\n        goto skipping;\n    }\n\n    /*\n     * If the line in namespace.conf for a directory to polyinstantiate\n     * contains a list of override users (users for whom polyinstantiation\n     * is not performed), read the user ids, convert names into uids, and\n     * add to polyinstantiated directory structure.\n     */\n    if (uids) {\n        uid_t *uidptr;\n        const char *ustr, *sstr;\n        size_t count, i;\n\n\tif (*uids == '~') {\n\t\tpoly->flags |= POLYDIR_EXCLUSIVE;\n\t\tuids++;\n\t}\n        for (count = 0, ustr = sstr = uids; sstr; ustr = sstr + 1, count++)\n           sstr = strchr(ustr, ',');\n\n        if (count > UINT_MAX || count > SIZE_MAX / sizeof(uid_t)) {\n            pam_syslog(idata->pamh, LOG_ERR, \"Too many uids encountered in configuration\");\n            goto skipping;\n        }\n\n        poly->num_uids = count;\n        poly->uid = malloc(count * sizeof (uid_t));\n        uidptr = poly->uid;\n        if (uidptr == NULL) {\n            goto erralloc;\n        }\n\n        ustr = uids;\n        for (i = 0; i < count; i++) {\n            struct passwd *pwd;\n\n            tptr = strchr(ustr, ',');\n            if (tptr)\n                *tptr = '\\0';\n\n            pwd = pam_modutil_getpwnam(idata->pamh, ustr);\n            if (pwd == NULL) {\n\t\tpam_syslog(idata->pamh, LOG_ERR, \"Unknown user %s in configuration\", ustr);\n\t\tpoly->num_uids--;\n            } else {\n                *uidptr = pwd->pw_uid;\n                uidptr++;\n            }\n            ustr = tptr + 1;\n        }\n    }\n\n    /*\n     * Add polyinstantiated directory structure to the linked list\n     * of all polyinstantiated directory structures.\n     */\n    add_polydir_entry(idata, poly);\n\n    goto out;\n\nerralloc:\n    pam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");\n\nskipping:\n    if (idata->flags & PAMNS_IGN_CONFIG_ERR)\n        retval = 0;\n    else\n        retval = PAM_SERVICE_ERR;\n    del_polydir(poly);\nout:\n    free(rdir);\n    free(dir);\n    free(instance_prefix);\n    argv_free(config_options);\n    return retval;\n}\n\n\n/*\n * Parses /etc/security/namespace.conf file to build a linked list of\n * polyinstantiated directory structures of type polydir_s. Each entry\n * in the linked list contains information needed to polyinstantiate\n * one directory.\n */\nstatic int parse_config_file(struct instance_data *idata)\n{\n    FILE *fil;\n    char *home, *rhome;\n    const char *confname;\n    struct passwd *cpwd;\n    char *line;\n    int retval;\n    size_t len = 0;\n    size_t n;\n\n    /*\n     * Extract the user's home directory to resolve $HOME entries\n     * in the namespace configuration file.\n     */\n    cpwd = pam_modutil_getpwnam(idata->pamh, idata->user);\n    if (!cpwd) {\n        pam_syslog(idata->pamh, LOG_ERR,\n               \"Error getting home dir for '%s'\", idata->user);\n        return PAM_SESSION_ERR;\n    }\n    if ((home=strdup(cpwd->pw_dir)) == NULL) {\n\tpam_syslog(idata->pamh, LOG_CRIT,\n\t\t\"Memory allocation error\");\n\treturn PAM_SESSION_ERR;\n    }\n\n    cpwd = pam_modutil_getpwnam(idata->pamh, idata->ruser);\n    if (!cpwd) {\n\tpam_syslog(idata->pamh, LOG_ERR,\n\t        \"Error getting home dir for '%s'\", idata->ruser);\n\tfree(home);\n\treturn PAM_SESSION_ERR;\n    }\n\n    if ((rhome=strdup(cpwd->pw_dir)) == NULL) {\n\tpam_syslog(idata->pamh, LOG_CRIT,\n\t\t\"Memory allocation error\");\n\tfree(home);\n\treturn PAM_SESSION_ERR;\n    }\n\n    /*\n     * Open configuration file, read one line at a time and call\n     * process_line to process each line.\n     */\n\n    confname = PAM_NAMESPACE_CONFIG;\n#ifdef VENDOR_PAM_NAMESPACE_CONFIG\n    /* Check whether PAM_NAMESPACE_CONFIG file is available.\n     * If it does not exist, fall back to VENDOR_PAM_NAMESPACE_CONFIG file. */\n    struct stat buffer;\n    if (stat(confname, &buffer) != 0 && errno == ENOENT) {\n\tconfname = VENDOR_PAM_NAMESPACE_CONFIG;\n    }\n#endif\n    char **filename_list = read_namespace_dir(idata);\n    n = 0;\n    for (;;) {\n\tif (idata->flags & PAMNS_DEBUG)\n\t\tpam_syslog(idata->pamh, LOG_DEBUG, \"Parsing config file %s\",\n\t\t\tconfname);\n\tfil = fopen(confname, \"r\");\n\tif (fil == NULL) {\n\t    pam_syslog(idata->pamh, LOG_ERR, \"Error opening config file %s\",\n\t\tconfname);\n\t    free(rhome);\n\t    free(home);\n\t    return PAM_SERVICE_ERR;\n\t}\n\n\t/* Use unlocked IO */\n\t__fsetlocking(fil, FSETLOCKING_BYCALLER);\n\n\tline = NULL;\n\t/* loop reading the file */\n\twhile (getline(&line, &len, fil) > 0) {\n\t    retval = process_line(line, home, rhome, idata);\n\t    if (retval) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\"Error processing conf file %s line %s\", confname, line);\n\t        fclose(fil);\n\t        free(line);\n\t        free(rhome);\n\t        free(home);\n\t        return PAM_SERVICE_ERR;\n\t    }\n\t}\n\tfclose(fil);\n\tfree(line);\n\n\tif (filename_list == NULL || filename_list[n] == NULL)\n\t    break;\n\n\tconfname = filename_list[n++];\n    }\n\n    if (filename_list != NULL) {\n\tfor (size_t i = 0; filename_list[i] != NULL; i++)\n\t    free(filename_list[i]);\n\tfree(filename_list);\n    }\n\n    free(rhome);\n    free(home);\n\n    /* All done...just some debug stuff */\n    if (idata->flags & PAMNS_DEBUG) {\n        struct polydir_s *dptr = idata->polydirs_ptr;\n        uid_t *iptr;\n        uid_t i;\n\n        pam_syslog(idata->pamh, LOG_DEBUG,\n\t    dptr?\"Configured poly dirs:\":\"No configured poly dirs\");\n        while (dptr) {\n            pam_syslog(idata->pamh, LOG_DEBUG, \"dir='%s' iprefix='%s' meth=%d\",\n\t\t   dptr->dir, dptr->instance_prefix, dptr->method);\n            for (i = 0, iptr = dptr->uid; i < dptr->num_uids; i++, iptr++)\n                pam_syslog(idata->pamh, LOG_DEBUG, \"override user %d \", *iptr);\n            dptr = dptr->next;\n        }\n    }\n\n    return PAM_SUCCESS;\n}\n\n\n/*\n * This function returns true if a given uid is present in the polyinstantiated\n * directory's list of override uids. If the uid is one of the override\n * uids for the polyinstantiated directory, polyinstantiation is not\n * performed for that user for that directory.\n * If exclusive is set the returned values are opposite.\n */\nstatic int ns_override(struct polydir_s *polyptr, struct instance_data *idata,\n\t\tuid_t uid)\n{\n    unsigned int i;\n\n    if (idata->flags & PAMNS_DEBUG)\n\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\"Checking for ns override in dir %s for uid %d\",\n\t\tpolyptr->dir, uid);\n\n    for (i = 0; i < polyptr->num_uids; i++) {\n        if (uid == polyptr->uid[i]) {\n            return !(polyptr->flags & POLYDIR_EXCLUSIVE);\n        }\n    }\n\n    return !!(polyptr->flags & POLYDIR_EXCLUSIVE);\n}\n\n/*\n * md5hash generates a hash of the passed in instance directory name.\n */\nstatic char *md5hash(const char *instname, struct instance_data *idata)\n{\n    int i;\n    char *md5inst = NULL;\n    char *to;\n    unsigned char inst_digest[MD5_DIGEST_LENGTH];\n\n    /*\n     * Create MD5 hashes for instance pathname.\n     */\n\n    MD5((const unsigned char *)instname, strlen(instname), inst_digest);\n\n    if ((md5inst = malloc(MD5_DIGEST_LENGTH * 2 + 1)) == NULL) {\n        pam_syslog(idata->pamh, LOG_CRIT, \"Unable to allocate buffer\");\n        return NULL;\n    }\n\n    to = md5inst;\n    for (i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        snprintf(to, 3, \"%02x\", (unsigned int)inst_digest[i]);\n        to += 2;\n    }\n\n    return md5inst;\n}\n\n#ifdef WITH_SELINUX\nstatic int form_context(const struct polydir_s *polyptr,\n\t\tchar **i_context, char **origcon,\n\t\tstruct instance_data *idata)\n{\n\tint rc = PAM_SUCCESS;\n\tchar *scon = NULL;\n\tsecurity_class_t tclass;\n\n\t/*\n\t * Get the security context of the directory to polyinstantiate.\n\t */\n\trc = getfilecon(polyptr->dir, origcon);\n\tif (rc < 0 || *origcon == NULL) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\"Error getting poly dir context, %m\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tif (polyptr->method == USER) return PAM_SUCCESS;\n\n\tif (idata->flags & PAMNS_USE_CURRENT_CONTEXT) {\n\t\trc = getcon(&scon);\n\t} else if (idata->flags & PAMNS_USE_DEFAULT_CONTEXT) {\n\t\tchar *seuser = NULL, *level = NULL;\n\n\t\tif ((rc=getseuserbyname(idata->user, &seuser, &level)) == 0) {\n\t\t\trc = get_default_context_with_level(seuser, level, NULL, &scon);\n\t\t\tfree(seuser);\n\t\t\tfree(level);\n\t\t}\n\t} else {\n\t\trc = getexeccon(&scon);\n\t}\n\tif (rc < 0 || scon == NULL) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t   \"Error getting exec context, %m\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\t/*\n\t * If polyinstantiating based on security context, get current\n\t * process security context, get security class for directories,\n\t * and ask the policy to provide security context of the\n\t * polyinstantiated instance directory.\n\t */\n\n\tif (polyptr->method == CONTEXT) {\n\t\ttclass = string_to_security_class(\"dir\");\n\t\tif (tclass == 0) {\n\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t   \"Error getting dir security class\");\n\t\t\tfreecon(scon);\n\t\t\treturn PAM_SESSION_ERR;\n\t\t}\n\n\t\tif (security_compute_member(scon, *origcon, tclass,\n\t\t\t\t\ti_context) < 0) {\n\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\"Error computing poly dir member context\");\n\t\t\tfreecon(scon);\n\t\t\treturn PAM_SESSION_ERR;\n\t\t} else if (idata->flags & PAMNS_DEBUG)\n\t\t\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\t\t\"member context returned by policy %s\", *i_context);\n\t\tfreecon(scon);\n\t\treturn PAM_SUCCESS;\n\t}\n\n\t/*\n\t * If polyinstantiating based on security level, get current\n\t * process security context, get security class for directories,\n\t * and change the directories MLS Level to match process.\n\t */\n\n\tif (polyptr->method == LEVEL) {\n\t\tcontext_t scontext = NULL;\n\t\tcontext_t fcontext = NULL;\n\t\trc = PAM_SESSION_ERR;\n\n\t\tscontext = context_new(scon);\n\t\tif (! scontext) {\n\t\t\tpam_syslog(idata->pamh, LOG_CRIT, \"out of memory\");\n\t\t\tgoto fail;\n\t\t}\n\t\tfcontext = context_new(*origcon);\n\t\tif (! fcontext) {\n\t\t\tpam_syslog(idata->pamh, LOG_CRIT, \"out of memory\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (context_range_set(fcontext, context_range_get(scontext)) != 0) {\n\t\t\tpam_syslog(idata->pamh, LOG_ERR, \"Unable to set MLS Component of context\");\n\t\t\tgoto fail;\n\t\t}\n\t\t*i_context=strdup(context_str(fcontext));\n\t\tif (! *i_context) {\n\t\t\tpam_syslog(idata->pamh, LOG_CRIT, \"out of memory\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\trc = PAM_SUCCESS;\n fail:\n\t\tcontext_free(scontext);\n\t\tcontext_free(fcontext);\n\t\tfreecon(scon);\n\t\treturn rc;\n\t}\n\t/* Should never get here */\n\treturn PAM_SUCCESS;\n}\n#endif\n\n/*\n * poly_name returns the name of the polyinstantiated instance directory\n * based on the method used for polyinstantiation (user, context or level)\n * In addition, the function also returns the security contexts of the\n * original directory to polyinstantiate and the polyinstantiated instance\n * directory.\n */\n#ifdef WITH_SELINUX\nstatic int poly_name(const struct polydir_s *polyptr, char **i_name,\n\tchar **i_context, char **origcon,\n        struct instance_data *idata)\n#else\nstatic int poly_name(const struct polydir_s *polyptr, char **i_name,\n\tstruct instance_data *idata)\n#endif\n{\n    int rc;\n    char *hash = NULL;\n    enum polymethod pm;\n#ifdef WITH_SELINUX\n    char *rawcon = NULL;\n#endif\n\n    *i_name = NULL;\n#ifdef WITH_SELINUX\n    *i_context = NULL;\n    *origcon = NULL;\n    if ((idata->flags & PAMNS_SELINUX_ENABLED) &&\n\t(rc=form_context(polyptr, i_context, origcon, idata)) != PAM_SUCCESS) {\n\t    return rc;\n    }\n#endif\n\n    rc = PAM_SESSION_ERR;\n    /*\n     * Set the name of the polyinstantiated instance dir based on the\n     * polyinstantiation method.\n     */\n\n    pm = polyptr->method;\n    if (pm == LEVEL || pm == CONTEXT)\n#ifdef WITH_SELINUX\n        if (!(idata->flags & PAMNS_CTXT_BASED_INST)) {\n#else\n    {\n\tpam_syslog(idata->pamh, LOG_NOTICE,\n\t\t\"Context and level methods not available, using user method\");\n#endif\n\tif (polyptr->flags & POLYDIR_SHARED) {\n\t\trc = PAM_IGNORE;\n\t\tgoto fail;\n\t}\n        pm = USER;\n    }\n\n    switch (pm) {\n        case USER:\n\t    if (asprintf(i_name, \"%s\", idata->user) < 0) {\n\t\t*i_name = NULL;\n\t\tgoto fail;\n\t    }\n\t    break;\n\n#ifdef WITH_SELINUX\n\tcase LEVEL:\n        case CONTEXT:\n\t    if (selinux_trans_to_raw_context(*i_context, &rawcon) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR, \"Error translating directory context\");\n\t\tgoto fail;\n\t    }\n\t    if (polyptr->flags & POLYDIR_SHARED) {\n\t\tif (asprintf(i_name, \"%s\", rawcon) < 0) {\n\t\t\t*i_name = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t    } else {\n\t\tif (asprintf(i_name, \"%s_%s\", rawcon, idata->user) < 0) {\n\t\t\t*i_name = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t    }\n\t    break;\n\n#endif /* WITH_SELINUX */\n\n\tcase TMPDIR:\n\tcase TMPFS:\n\t    if ((*i_name=strdup(\"\")) == NULL)\n\t\tgoto fail;\n\t    return PAM_SUCCESS;\n\n\tdefault:\n\t    if (idata->flags & PAMNS_DEBUG)\n\t        pam_syslog(idata->pamh, LOG_ERR, \"Unknown method\");\n\t    goto fail;\n    }\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"poly_name %s\", *i_name);\n\n    if ((idata->flags & PAMNS_GEN_HASH) || strlen(*i_name) > NAMESPACE_MAX_DIR_LEN) {\n        hash = md5hash(*i_name, idata);\n        if (hash == NULL) {\n\t    goto fail;\n        }\n        if (idata->flags & PAMNS_GEN_HASH) {\n\t    free(*i_name);\n\t    *i_name = hash;\n\t    hash = NULL;\n        } else {\n\t    char *newname;\n\t    if (asprintf(&newname, \"%.*s_%s\", NAMESPACE_MAX_DIR_LEN-1-(int)strlen(hash),\n\t\t*i_name, hash) < 0) {\n\t\tgoto fail;\n\t    }\n\t    free(*i_name);\n\t    *i_name = newname;\n        }\n    }\n    rc = PAM_SUCCESS;\n\nfail:\n    free(hash);\n#ifdef WITH_SELINUX\n    freecon(rawcon);\n#endif\n    if (rc != PAM_SUCCESS) {\n#ifdef WITH_SELINUX\n\tfreecon(*i_context);\n\t*i_context = NULL;\n\tfreecon(*origcon);\n\t*origcon = NULL;\n#endif\n\tfree(*i_name);\n\t*i_name = NULL;\n    }\n    return rc;\n}\n\nstatic int protect_mount(int dfd, const char *path, struct instance_data *idata)\n{\n\tstruct protect_dir_s *dir = idata->protect_dirs;\n\tchar tmpbuf[64];\n\n\twhile (dir != NULL) {\n\t\tif (strcmp(path, dir->dir) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tdir = dir->next;\n\t}\n\n\tdir = calloc(1, sizeof(*dir));\n\n\tif (dir == NULL) {\n\t\treturn -1;\n\t}\n\n\tdir->dir = strdup(path);\n\n\tif (dir->dir == NULL) {\n\t\tfree(dir);\n\t\treturn -1;\n\t}\n\n\tsnprintf(tmpbuf, sizeof(tmpbuf), \"/proc/self/fd/%d\", dfd);\n\n\tif (idata->flags & PAMNS_DEBUG) {\n\t\tpam_syslog(idata->pamh, LOG_INFO,\n\t\t\t\"Protect mount of %s over itself\", path);\n\t}\n\n\tif (mount(tmpbuf, tmpbuf, NULL, MS_BIND, NULL) != 0) {\n\t\tint save_errno = errno;\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Protect mount of %s failed: %m\", tmpbuf);\n\t\tfree(dir->dir);\n\t\tfree(dir);\n\t\terrno = save_errno;\n\t\treturn -1;\n\t}\n\n\tdir->next = idata->protect_dirs;\n\tidata->protect_dirs = dir;\n\n\treturn 0;\n}\n\nstatic int protect_dir(const char *path, mode_t mode, int do_mkdir,\n\tstruct instance_data *idata)\n{\n\tchar *p = strdup(path);\n\tchar *d;\n\tchar *dir = p;\n\tint dfd = AT_FDCWD;\n\tint dfd_next;\n\tint save_errno;\n\tint flags = O_RDONLY;\n\tint rv = -1;\n\tstruct stat st;\n\n\tif (p == NULL) {\n\t\tgoto error;\n\t}\n\n\tif (*dir == '/') {\n\t\tdfd = open(\"/\", flags);\n\t\tif (dfd == -1) {\n\t\t\tgoto error;\n\t\t}\n\t\tdir++;\t/* assume / is safe */\n\t}\n\n\twhile ((d=strchr(dir, '/')) != NULL) {\n\t\t*d = '\\0';\n\t\tdfd_next = openat(dfd, dir, flags);\n\t\tif (dfd_next == -1) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (dfd != AT_FDCWD)\n\t\t\tclose(dfd);\n\t\tdfd = dfd_next;\n\n\t\tif (fstat(dfd, &st) != 0) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (flags & O_NOFOLLOW) {\n\t\t\t/* we are inside user-owned dir - protect */\n\t\t\tif (protect_mount(dfd, p, idata) == -1)\n\t\t\t\tgoto error;\n\t\t} else if (st.st_uid != 0 || st.st_gid != 0 ||\n\t\t\t(st.st_mode & S_IWOTH)) {\n\t\t\t/* do not follow symlinks on subdirectories */\n\t\t\tflags |= O_NOFOLLOW;\n\t\t}\n\n\t\t*d = '/';\n\t\tdir = d + 1;\n\t}\n\n\trv = openat(dfd, dir, flags);\n\n\tif (rv == -1) {\n\t\tif (!do_mkdir || mkdirat(dfd, dir, mode) != 0) {\n\t\t\tgoto error;\n\t\t}\n\t\trv = openat(dfd, dir, flags);\n\t}\n\n\tif (rv != -1) {\n\t\tif (fstat(rv, &st) != 0) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(rv);\n\t\t\trv = -1;\n\t\t\terrno = save_errno;\n\t\t\tgoto error;\n\t\t}\n\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\tclose(rv);\n\t\t\terrno = ENOTDIR;\n\t\t\trv = -1;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (flags & O_NOFOLLOW) {\n\t\t/* we are inside user-owned dir - protect */\n\t\tif (protect_mount(rv, p, idata) == -1) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(rv);\n\t\t\trv = -1;\n\t\t\terrno = save_errno;\n\t\t}\n\t}\n\nerror:\n\tsave_errno = errno;\n\tfree(p);\n\tif (dfd != AT_FDCWD && dfd >= 0)\n\t\tclose(dfd);\n\terrno = save_errno;\n\n\treturn rv;\n}\n\nstatic int check_inst_parent(char *ipath, struct instance_data *idata)\n{\n\tstruct stat instpbuf;\n\tchar *inst_parent, *trailing_slash;\n\tint dfd;\n\t/*\n\t * stat the instance parent path to make sure it exists\n\t * and is a directory. Check that its mode is 000 (unless the\n\t * admin explicitly instructs to ignore the instance parent\n\t * mode by the \"ignore_instance_parent_mode\" argument).\n\t */\n\tinst_parent = strdup(ipath);\n\tif (!inst_parent) {\n\t\tpam_syslog(idata->pamh, LOG_CRIT, \"Error allocating pathname string\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\ttrailing_slash = strrchr(inst_parent, '/');\n\tif (trailing_slash)\n\t\t*trailing_slash = '\\0';\n\n\tdfd = protect_dir(inst_parent, 0, 1, idata);\n\n\tif (dfd == -1 || fstat(dfd, &instpbuf) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error creating or accessing instance parent %s, %m\", inst_parent);\n\t\tif (dfd != -1)\n\t\t\tclose(dfd);\n\t\tfree(inst_parent);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tif ((idata->flags & PAMNS_IGN_INST_PARENT_MODE) == 0) {\n\t\tif ((instpbuf.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO)) || instpbuf.st_uid != 0) {\n\t\t\tpam_syslog(idata->pamh, LOG_ERR, \"Mode of inst parent %s not 000 or owner not root\",\n\t\t\t\t\tinst_parent);\n\t\t\tclose(dfd);\n\t\t\tfree(inst_parent);\n\t\t\treturn PAM_SESSION_ERR;\n\t\t}\n\t}\n\tclose(dfd);\n\tfree(inst_parent);\n\treturn PAM_SUCCESS;\n}\n\n/*\n* Check to see if there is a namespace initialization script in\n* the /etc/security directory. If such a script exists\n* execute it and pass directory to polyinstantiate and instance\n* directory as arguments.\n*/\nstatic int inst_init(const struct polydir_s *polyptr, const char *ipath,\n\t   struct instance_data *idata, int newdir)\n{\n\tpid_t rc, pid;\n\tint status;\n\tconst char *init_script = NAMESPACE_INIT_SCRIPT;\n\n#ifdef VENDOR_NAMESPACE_INIT_SCRIPT\n\t/* Check whether NAMESPACE_INIT_SCRIPT file is available.\n\t * If it does not exist, fall back to VENDOR_NAMESPACE_INIT_SCRIPT file. */\n\tstruct stat buffer;\n\tif (stat(init_script, &buffer) != 0 && errno == ENOENT) {\n\t\tinit_script = VENDOR_NAMESPACE_INIT_SCRIPT;\n\t}\n#endif\n\n\tif ((polyptr->flags & POLYDIR_ISCRIPT) && polyptr->init_script)\n\t\tinit_script = polyptr->init_script;\n\n\tif (access(init_script, F_OK) == 0) {\n\t\tif (access(init_script, X_OK) < 0) {\n\t\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\t\"Namespace init script not executable\");\n\t\t\treturn PAM_SESSION_ERR;\n\t\t} else {\n\t\t\tstruct sigaction newsa, oldsa;\n\n\t\t\tmemset(&newsa, '\\0', sizeof(newsa));\n\t\t\tnewsa.sa_handler = SIG_DFL;\n\t\t\tif (sigaction(SIGCHLD, &newsa, &oldsa) == -1) {\n\t\t\t\tpam_syslog(idata->pamh, LOG_ERR, \"failed to reset SIGCHLD handler\");\n\t\t\t\treturn PAM_SESSION_ERR;\n\t\t\t}\n\n\t\t\tpid = fork();\n\t\t\tif (pid == 0) {\n\t\t\t\tstatic char *envp[] = { NULL };\n#ifdef WITH_SELINUX\n\t\t\t\tif (idata->flags & PAMNS_SELINUX_ENABLED) {\n\t\t\t\t\tif (setexeccon(NULL) < 0)\n\t\t\t\t\t\t_exit(1);\n\t\t\t\t}\n#endif\n\t\t\t\t/* Pass maximum privs when we exec() */\n\t\t\t\tif (setuid(geteuid()) < 0) {\n\t\t\t\t\t/* ignore failures, they don't matter */\n\t\t\t\t}\n\n\t\t\t\tclose_fds_pre_exec(idata);\n\n\t\t\t\tif (execle(init_script, init_script,\n\t\t\t\t\tpolyptr->dir, ipath, newdir?\"1\":\"0\", idata->user, NULL, envp) < 0)\n\t\t\t\t\t_exit(1);\n\t\t\t} else if (pid > 0) {\n\t\t\t\twhile (((rc = waitpid(pid, &status, 0)) == (pid_t)-1) &&\n\t\t\t\t\t\t(errno == EINTR));\n\t\t\t\tif (rc == (pid_t)-1) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_ERR, \"waitpid failed- %m\");\n\t\t\t\t\trc = PAM_SESSION_ERR;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (!WIFEXITED(status) || WIFSIGNALED(status) > 0) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\t\t\"Error initializing instance\");\n\t\t\t\t\trc = PAM_SESSION_ERR;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else if (pid < 0) {\n\t\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\t\"Cannot fork to run namespace init script, %m\");\n\t\t\t\trc = PAM_SESSION_ERR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trc = PAM_SUCCESS;\nout:\n\t\t\t(void) sigaction(SIGCHLD, &oldsa, NULL);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn PAM_SUCCESS;\n}\n\nstatic int create_polydir(struct polydir_s *polyptr,\n\tstruct instance_data *idata)\n{\n    mode_t mode;\n    int rc;\n#ifdef WITH_SELINUX\n    char *dircon_raw, *oldcon_raw = NULL;\n    struct selabel_handle *label_handle;\n#endif\n    const char *dir = polyptr->dir;\n    uid_t uid;\n    gid_t gid;\n\n    if (polyptr->mode != (mode_t)ULONG_MAX)\n            mode = polyptr->mode;\n    else\n            mode = 0777;\n\n#ifdef WITH_SELINUX\n    if (idata->flags & PAMNS_SELINUX_ENABLED) {\n\tgetfscreatecon_raw(&oldcon_raw);\n\n\tlabel_handle = selabel_open(SELABEL_CTX_FILE, NULL, 0);\n\tif (!label_handle) {\n\t    pam_syslog(idata->pamh, LOG_NOTICE,\n                       \"Unable to initialize SELinux labeling handle: %m\");\n\t} else {\n\t    rc = selabel_lookup_raw(label_handle, &dircon_raw, dir, S_IFDIR);\n\t    if (rc) {\n\t\tpam_syslog(idata->pamh, LOG_NOTICE,\n                       \"Unable to get default context for directory %s, check your policy: %m\", dir);\n\t    } else {\n\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t    pam_syslog(idata->pamh, LOG_DEBUG,\n                               \"Polydir %s context: %s\", dir, dircon_raw);\n\t\tif (setfscreatecon_raw(dircon_raw) != 0)\n\t\t    pam_syslog(idata->pamh, LOG_NOTICE,\n                               \"Error setting context for directory %s: %m\", dir);\n\t\tfreecon(dircon_raw);\n\t    }\n\t    selabel_close(label_handle);\n\t}\n    }\n#endif\n\n    rc = protect_dir(dir, mode, 1, idata);\n    if (rc == -1) {\n            pam_syslog(idata->pamh, LOG_ERR,\n                       \"Error creating directory %s: %m\", dir);\n            return PAM_SESSION_ERR;\n    }\n\n#ifdef WITH_SELINUX\n    if (idata->flags & PAMNS_SELINUX_ENABLED) {\n        if (setfscreatecon_raw(oldcon_raw) != 0)\n\t\tpam_syslog(idata->pamh, LOG_NOTICE,\n                       \"Error resetting fs create context: %m\");\n        freecon(oldcon_raw);\n    }\n#endif\n\n    if (idata->flags & PAMNS_DEBUG)\n            pam_syslog(idata->pamh, LOG_DEBUG, \"Created polydir %s\", dir);\n\n    if (polyptr->mode != (mode_t)ULONG_MAX) {\n\t/* explicit mode requested */\n\tif (fchmod(rc, mode) != 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t   \"Error changing mode of directory %s: %m\", dir);\n                close(rc);\n                umount(dir); /* undo the eventual protection bind mount */\n\t\trmdir(dir);\n\t\treturn PAM_SESSION_ERR;\n\t}\n    }\n\n    if (polyptr->owner != (uid_t)ULONG_MAX)\n\tuid = polyptr->owner;\n    else\n\tuid = idata->uid;\n\n    if (polyptr->group != (gid_t)ULONG_MAX)\n\tgid = polyptr->group;\n    else\n\tgid = idata->gid;\n\n    if (fchown(rc, uid, gid) != 0) {\n        pam_syslog(idata->pamh, LOG_ERR,\n                   \"Unable to change owner on directory %s: %m\", dir);\n        close(rc);\n        umount(dir); /* undo the eventual protection bind mount */\n\trmdir(dir);\n\treturn PAM_SESSION_ERR;\n    }\n\n    close(rc);\n\n    if (idata->flags & PAMNS_DEBUG)\n\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t           \"Polydir owner %u group %u\", uid, gid);\n\n    return PAM_SUCCESS;\n}\n\n/*\n * Create polyinstantiated instance directory (ipath).\n */\n#ifdef WITH_SELINUX\nstatic int create_instance(struct polydir_s *polyptr, char *ipath, struct stat *statbuf,\n        const char *icontext, const char *ocontext,\n\tstruct instance_data *idata)\n#else\nstatic int create_instance(struct polydir_s *polyptr, char *ipath, struct stat *statbuf,\n\tstruct instance_data *idata)\n#endif\n{\n    struct stat newstatbuf;\n    int fd;\n\n    /*\n     * Check to make sure instance parent is valid.\n     */\n    if (check_inst_parent(ipath, idata))\n\treturn PAM_SESSION_ERR;\n\n    /*\n     * Create instance directory and set its security context to the context\n     * returned by the security policy. Set its mode and ownership\n     * attributes to match that of the original directory that is being\n     * polyinstantiated.\n     */\n\n    if (polyptr->method == TMPDIR) {\n\tif (mkdtemp(polyptr->instance_prefix) == NULL) {\n            pam_syslog(idata->pamh, LOG_ERR, \"Error creating temporary instance %s, %m\",\n\t\t\tpolyptr->instance_prefix);\n\t    polyptr->method = NONE; /* do not clean up! */\n\t    return PAM_SESSION_ERR;\n\t}\n\t/* copy the actual directory name to ipath */\n\tstrcpy(ipath, polyptr->instance_prefix);\n    } else if (mkdir(ipath, S_IRUSR) < 0) {\n        if (errno == EEXIST)\n            return PAM_IGNORE;\n        else {\n            pam_syslog(idata->pamh, LOG_ERR, \"Error creating %s, %m\",\n\t\t\tipath);\n            return PAM_SESSION_ERR;\n        }\n    }\n\n    /* Open a descriptor to it to prevent races */\n    fd = open(ipath, O_DIRECTORY | O_RDONLY);\n    if (fd < 0) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Error opening %s, %m\", ipath);\n\trmdir(ipath);\n\treturn PAM_SESSION_ERR;\n    }\n#ifdef WITH_SELINUX\n    /* If SE Linux is disabled, no need to label it */\n    if (idata->flags & PAMNS_SELINUX_ENABLED) {\n        /* If method is USER, icontext is NULL */\n        if (icontext) {\n            if (fsetfilecon(fd, icontext) < 0) {\n                pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error setting context of %s to %s\", ipath, icontext);\n                close(fd);\n\t\trmdir(ipath);\n                return PAM_SESSION_ERR;\n            }\n        } else {\n            if (fsetfilecon(fd, ocontext) < 0) {\n                pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error setting context of %s to %s\", ipath, ocontext);\n\t\tclose(fd);\n\t\trmdir(ipath);\n                return PAM_SESSION_ERR;\n            }\n        }\n    }\n#endif\n    if (fstat(fd, &newstatbuf) < 0) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error stating %s, %m\",\n\t\tipath);\n\tclose(fd);\n\trmdir(ipath);\n        return PAM_SESSION_ERR;\n    }\n    if (newstatbuf.st_uid != statbuf->st_uid ||\n\t\t\t newstatbuf.st_gid != statbuf->st_gid) {\n        if (fchown(fd, statbuf->st_uid, statbuf->st_gid) < 0) {\n            pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error changing owner for %s, %m\",\n\t\t\tipath);\n\t    close(fd);\n\t    rmdir(ipath);\n            return PAM_SESSION_ERR;\n        }\n    }\n    if (fchmod(fd, statbuf->st_mode & 07777) < 0) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error changing mode for %s, %m\",\n\t\t\tipath);\n\tclose(fd);\n\trmdir(ipath);\n        return PAM_SESSION_ERR;\n    }\n    close(fd);\n    return PAM_SUCCESS;\n}\n\n\n/*\n * This function performs the namespace setup for a particular directory\n * that is being polyinstantiated. It calls poly_name to create name of instance\n * directory, calls create_instance to mkdir it with appropriate\n * security attributes, and performs bind mount to setup the process\n * namespace.\n */\nstatic int ns_setup(struct polydir_s *polyptr,\n\tstruct instance_data *idata)\n{\n    int retval;\n    int newdir = 1;\n    char *inst_dir = NULL;\n    char *instname = NULL;\n    struct stat statbuf;\n#ifdef WITH_SELINUX\n    char *instcontext = NULL, *origcontext = NULL;\n#endif\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG,\n               \"Set namespace for directory %s\", polyptr->dir);\n\n    retval = protect_dir(polyptr->dir, 0, 0, idata);\n\n    if (retval < 0 && errno != ENOENT) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Polydir %s access error: %m\",\n\t\tpolyptr->dir);\n\treturn PAM_SESSION_ERR;\n    }\n\n    if (retval < 0) {\n\tif ((polyptr->flags & POLYDIR_CREATE) &&\n\t\tcreate_polydir(polyptr, idata) != PAM_SUCCESS)\n\t\treturn PAM_SESSION_ERR;\n    } else {\n\tclose(retval);\n    }\n\n    if (polyptr->method == TMPFS) {\n\tif (mount(\"tmpfs\", polyptr->dir, \"tmpfs\", polyptr->mount_flags, polyptr->mount_opts) < 0) {\n\t    pam_syslog(idata->pamh, LOG_ERR, \"Error mounting tmpfs on %s, %m\",\n\t\tpolyptr->dir);\n            return PAM_SESSION_ERR;\n\t}\n\n\tif (polyptr->flags & POLYDIR_NOINIT)\n\t    return PAM_SUCCESS;\n\n\treturn inst_init(polyptr, \"tmpfs\", idata, 1);\n    }\n\n    if (stat(polyptr->dir, &statbuf) < 0) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Error stating %s: %m\",\n\t\tpolyptr->dir);\n        return PAM_SESSION_ERR;\n    }\n\n    /*\n     * Obtain the name of instance pathname based on the\n     * polyinstantiation method and instance context returned by\n     * security policy.\n     */\n#ifdef WITH_SELINUX\n    retval = poly_name(polyptr, &instname, &instcontext,\n\t\t\t&origcontext, idata);\n#else\n    retval = poly_name(polyptr, &instname, idata);\n#endif\n\n    if (retval != PAM_SUCCESS) {\n\tif (retval != PAM_IGNORE)\n\t\tpam_syslog(idata->pamh, LOG_ERR, \"Error getting instance name\");\n        goto cleanup;\n    } else {\n#ifdef WITH_SELINUX\n        if ((idata->flags & PAMNS_DEBUG) &&\n            (idata->flags & PAMNS_SELINUX_ENABLED))\n            pam_syslog(idata->pamh, LOG_DEBUG, \"Inst ctxt %s Orig ctxt %s\",\n\t\t instcontext, origcontext);\n#endif\n    }\n\n    if (asprintf(&inst_dir, \"%s%s\", polyptr->instance_prefix, instname) < 0)\n\tgoto error_out;\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"instance_dir %s\",\n\t\tinst_dir);\n\n    /*\n     * Create instance directory with appropriate security\n     * contexts, owner, group and mode bits.\n     */\n#ifdef WITH_SELINUX\n    retval = create_instance(polyptr, inst_dir, &statbuf, instcontext,\n\t\t\t origcontext, idata);\n#else\n    retval = create_instance(polyptr, inst_dir, &statbuf, idata);\n#endif\n\n    if (retval == PAM_IGNORE) {\n\tnewdir = 0;\n\tretval = PAM_SUCCESS;\n    }\n\n    if (retval != PAM_SUCCESS) {\n        goto error_out;\n    }\n\n    /*\n     * Bind mount instance directory on top of the polyinstantiated\n     * directory to provide an instance of polyinstantiated directory\n     * based on polyinstantiated method.\n     */\n    if (mount(inst_dir, polyptr->dir, NULL, MS_BIND, NULL) < 0) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error mounting %s on %s, %m\",\n                   inst_dir, polyptr->dir);\n        goto error_out;\n    }\n\n    if (!(polyptr->flags & POLYDIR_NOINIT))\n\tretval = inst_init(polyptr, inst_dir, idata, newdir);\n\n    goto cleanup;\n\n    /*\n     * various error exit points. Free allocated memory and set return\n     * value to indicate a pam session error.\n     */\nerror_out:\n    retval = PAM_SESSION_ERR;\n\ncleanup:\n    free(inst_dir);\n    free(instname);\n#ifdef WITH_SELINUX\n    freecon(instcontext);\n    freecon(origcontext);\n#endif\n    return retval;\n}\n\n\n/*\n * This function checks to see if the current working directory is\n * inside the directory passed in as the first argument.\n */\nstatic int cwd_in(char *dir, struct instance_data *idata)\n{\n    int retval = 0;\n    char cwd[PATH_MAX];\n\n    if (getcwd(cwd, PATH_MAX) == NULL) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Can't get current dir, %m\");\n        return -1;\n    }\n\n    if (strncmp(cwd, dir, strlen(dir)) == 0) {\n        if (idata->flags & PAMNS_DEBUG)\n            pam_syslog(idata->pamh, LOG_DEBUG, \"cwd is inside %s\", dir);\n        retval = 1;\n    } else {\n        if (idata->flags & PAMNS_DEBUG)\n            pam_syslog(idata->pamh, LOG_DEBUG, \"cwd is outside %s\", dir);\n    }\n\n    return retval;\n}\n\nstatic int cleanup_tmpdirs(struct instance_data *idata)\n{\n    struct polydir_s *pptr;\n    pid_t rc, pid;\n    struct sigaction newsa, oldsa;\n    int status;\n\n    memset(&newsa, '\\0', sizeof(newsa));\n    newsa.sa_handler = SIG_DFL;\n    if (sigaction(SIGCHLD, &newsa, &oldsa) == -1) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Cannot set signal value\");\n\treturn PAM_SESSION_ERR;\n    }\n\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n\tif (pptr->method == TMPDIR && access(pptr->instance_prefix, F_OK) == 0) {\n\t    pid = fork();\n\t    if (pid == 0) {\n\t\tstatic char *envp[] = { NULL };\n#ifdef WITH_SELINUX\n\t\tif (idata->flags & PAMNS_SELINUX_ENABLED) {\n\t\t    if (setexeccon(NULL) < 0)\n\t\t\t_exit(1);\n\t\t}\n#endif\n\t\tclose_fds_pre_exec(idata);\n\t\tif (execle(\"/bin/rm\", \"/bin/rm\", \"-rf\", pptr->instance_prefix, NULL, envp) < 0)\n\t\t\t_exit(1);\n\t    } else if (pid > 0) {\n\t\twhile (((rc = waitpid(pid, &status, 0)) == (pid_t)-1) &&\n\t\t    (errno == EINTR));\n\t\tif (rc == (pid_t)-1) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR, \"waitpid failed: %m\");\n\t\t    rc = PAM_SESSION_ERR;\n\t\t    goto out;\n\t\t}\n\t\tif (!WIFEXITED(status) || WIFSIGNALED(status) > 0) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error removing %s\", pptr->instance_prefix);\n\t\t}\n\t    } else if (pid < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Cannot fork to cleanup temporary directory, %m\");\n\t\trc = PAM_SESSION_ERR;\n\t\tgoto out;\n\t    }\n        }\n    }\n\n    rc = PAM_SUCCESS;\nout:\n    sigaction(SIGCHLD, &oldsa, NULL);\n    return rc;\n}\n\n/*\n * This function checks to see if polyinstantiation is needed for any\n * of the directories listed in the configuration file. If needed,\n * cycles through all polyinstantiated directory entries and calls\n * ns_setup to setup polyinstantiation for each one of them.\n */\nstatic int setup_namespace(struct instance_data *idata, enum unmnt_op unmnt)\n{\n    int retval = 0, need_poly = 0, changing_dir = 0;\n    char *cptr, *fptr, poly_parent[PATH_MAX];\n    struct polydir_s *pptr;\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"Set up namespace for pid %d\",\n\t\tgetpid());\n\n    /*\n     * Cycle through all polyinstantiated directory entries to see if\n     * polyinstantiation is needed at all.\n     */\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n        if (ns_override(pptr, idata, idata->uid)) {\n\t    if (unmnt == NO_UNMNT || ns_override(pptr, idata, idata->ruid)) {\n\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t    pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Overriding poly for user %d for dir %s\",\n\t\t\tidata->uid, pptr->dir);\n\t    } else {\n\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t    pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Need unmount ns for user %d for dir %s\",\n\t\t\tidata->ruid, pptr->dir);\n\t\tneed_poly = 1;\n\t\tbreak;\n\t    }\n            continue;\n        } else {\n            if (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Need poly ns for user %d for dir %s\",\n\t\t\tidata->uid, pptr->dir);\n            need_poly = 1;\n            break;\n        }\n    }\n\n    /*\n     * If polyinstantiation is needed, call the unshare system call to\n     * disassociate from the parent namespace.\n     */\n    if (need_poly) {\n        if (unshare(CLONE_NEWNS) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\"Unable to unshare from parent namespace, %m\");\n            return PAM_SESSION_ERR;\n        }\n\tif (idata->flags & PAMNS_MOUNT_PRIVATE) {\n\t    /*\n\t     * Remount / as SLAVE so that nothing mounted in the namespace\n\t     * shows up in the parent\n\t     */\n\t    if (mount(\"/\", \"/\", NULL, MS_SLAVE | MS_REC , NULL) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Failed to mark / as a slave mount point, %m\");\n\t\treturn PAM_SESSION_ERR;\n\t    }\n\t    if (idata->flags & PAMNS_DEBUG)\n\t\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"The / mount point was marked as slave\");\n\t}\n    } else {\n\tdel_polydir_list(idata->polydirs_ptr);\n        return PAM_SUCCESS;\n    }\n\n    /*\n     * Again cycle through all polyinstantiated directories, this time,\n     * call ns_setup to setup polyinstantiation for a particular entry.\n     */\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n\tenum unmnt_op dir_unmnt = unmnt;\n\n\tif (ns_override(pptr, idata, idata->ruid)) {\n\t    dir_unmnt = NO_UNMNT;\n\t}\n\tif (ns_override(pptr, idata, idata->uid)) {\n\t    if (dir_unmnt == NO_UNMNT) {\n\t\tcontinue;\n\t    } else {\n\t\tdir_unmnt = UNMNT_ONLY;\n\t    }\n\t}\n\n\tif (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Setting poly ns for user %d for dir %s\",\n                      idata->uid, pptr->dir);\n\n\tif ((dir_unmnt == UNMNT_REMNT) || (dir_unmnt == UNMNT_ONLY)) {\n                /*\n                 * Check to see if process current directory is in the\n                 * bind mounted instance_parent directory that we are trying to\n                 * umount\n                 */\n                if ((changing_dir = cwd_in(pptr->rdir, idata)) < 0) {\n                    retval = PAM_SESSION_ERR;\n                    goto out;\n                } else if (changing_dir) {\n                    if (idata->flags & PAMNS_DEBUG)\n                        pam_syslog(idata->pamh, LOG_DEBUG, \"changing cwd\");\n\n                    /*\n                     * Change current working directory to the parent of\n                     * the mount point, that is parent of the orig\n                     * directory where original contents of the polydir\n                     * are available from\n                     */\n                    strcpy(poly_parent, pptr->rdir);\n\t\t    fptr = strchr(poly_parent, '/');\n\t\t    cptr = strrchr(poly_parent, '/');\n\t\t    if (fptr && cptr && (fptr == cptr))\n\t\t\tstrcpy(poly_parent, \"/\");\n\t\t    else if (cptr)\n\t\t\t*cptr = '\\0';\n                    if (chdir(poly_parent) < 0) {\n                        pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\"Can't chdir to %s, %m\", poly_parent);\n                    }\n                }\n\n                if (umount(pptr->rdir) < 0) {\n\t\t    int saved_errno = errno;\n\t\t    pam_syslog(idata->pamh, LOG_ERR, \"Unmount of %s failed, %m\",\n\t\t\tpptr->rdir);\n\t\t    if (saved_errno != EINVAL) {\n\t\t\tretval = PAM_SESSION_ERR;\n\t\t\tgoto out;\n                    }\n                } else if (idata->flags & PAMNS_DEBUG)\n                    pam_syslog(idata->pamh, LOG_DEBUG, \"Umount succeeded %s\",\n\t\t\t\tpptr->rdir);\n\t}\n\n\tif (dir_unmnt != UNMNT_ONLY) {\n                retval = ns_setup(pptr, idata);\n                if (retval == PAM_IGNORE)\n                     retval = PAM_SUCCESS;\n                if (retval != PAM_SUCCESS)\n                     break;\n        }\n    }\nout:\n    if (retval != PAM_SUCCESS) {\n\tcleanup_tmpdirs(idata);\n\tunprotect_dirs(idata->protect_dirs);\n    } else if (pam_set_data(idata->pamh, NAMESPACE_PROTECT_DATA, idata->protect_dirs,\n\t\tcleanup_protect_data) != PAM_SUCCESS) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Unable to set namespace protect data\");\n\tcleanup_tmpdirs(idata);\n\tunprotect_dirs(idata->protect_dirs);\n\treturn PAM_SYSTEM_ERR;\n    } else if (pam_set_data(idata->pamh, NAMESPACE_POLYDIR_DATA, idata->polydirs_ptr,\n\t\tcleanup_polydir_data) != PAM_SUCCESS) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Unable to set namespace polydir data\");\n\tcleanup_tmpdirs(idata);\n\tpam_set_data(idata->pamh, NAMESPACE_PROTECT_DATA, NULL, NULL);\n\tidata->protect_dirs = NULL;\n\treturn PAM_SYSTEM_ERR;\n    }\n    return retval;\n}\n\n\n/*\n * Orig namespace. This function is called from when closing a pam\n * session. If authorized, it unmounts instance directory.\n */\nstatic int orig_namespace(struct instance_data *idata)\n{\n    struct polydir_s *pptr;\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"orig namespace for pid %d\",\n\t\tgetpid());\n\n    /*\n     * Cycle through all polyinstantiated directories from the namespace\n     * configuration file to see if polyinstantiation was performed for\n     * this user for each of the entry. If it was, try and unmount\n     * appropriate polyinstantiated instance directories.\n     */\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n        if (ns_override(pptr, idata, idata->uid))\n            continue;\n        else {\n            if (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Unmounting instance dir for user %d & dir %s\",\n                       idata->uid, pptr->dir);\n\n            if (umount(pptr->dir) < 0) {\n                pam_syslog(idata->pamh, LOG_ERR, \"Unmount of %s failed, %m\",\n                       pptr->dir);\n                return PAM_SESSION_ERR;\n            } else if (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG, \"Unmount of %s succeeded\",\n\t\t\tpptr->dir);\n\t}\n    }\n\n    cleanup_tmpdirs(idata);\n    return 0;\n}\n\n\n#ifdef WITH_SELINUX\n/*\n * This function checks if the calling program has requested context\n * change by calling setexeccon(). If context change is not requested\n * then it does not make sense to polyinstantiate based on context.\n * The return value from this function is used when selecting the\n * polyinstantiation method. If context change is not requested then\n * the polyinstantiation method is set to USER, even if the configuration\n * file lists the method as \"context\" or \"level\".\n */\nstatic int ctxt_based_inst_needed(void)\n{\n    char *scon = NULL;\n    int rc = 0;\n\n    rc = getexeccon(&scon);\n    if (rc < 0 || scon == NULL)\n        return 0;\n    else {\n        freecon(scon);\n        return 1;\n    }\n}\n#endif\n\nstatic int root_shared(void)\n{\n    FILE *f;\n    char *line = NULL;\n    size_t n = 0;\n    int rv = 0;\n\n    f = fopen(\"/proc/self/mountinfo\", \"r\");\n\n    if (f == NULL)\n        return 0;\n\n    while(getline(&line, &n, f) != -1) {\n        char *l;\n        char *sptr;\n        int i;\n\n        l = line;\n        sptr = NULL;\n        for (i = 0; i < 7; i++) {\n             char *tok;\n\n             tok = strtok_r(l, \" \", &sptr);\n             l = NULL;\n             if (tok == NULL)\n                 /* next mountinfo line */\n                 break;\n\n             if (i == 4 && strcmp(tok, \"/\") != 0)\n                 /* next mountinfo line */\n                 break;\n\n             if (i == 6) {\n                if (pam_str_skip_prefix(tok, \"shared:\") != NULL)\n                 /* there might be more / mounts, the last one counts */\n                    rv = 1;\n                else\n                    rv = 0;\n             }\n        }\n    }\n\n    free(line);\n    fclose(f);\n\n    return rv;\n}\n\nstatic int get_user_data(struct instance_data *idata)\n{\n    int retval;\n    char *user_name;\n    struct passwd *pwd;\n    /*\n     * Lookup user and fill struct items\n     */\n    retval = pam_get_item(idata->pamh, PAM_USER, (void*) &user_name );\n    if ( user_name == NULL || retval != PAM_SUCCESS ) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error recovering pam user name\");\n        return PAM_SESSION_ERR;\n    }\n\n    pwd = pam_modutil_getpwnam(idata->pamh, user_name);\n    if (!pwd) {\n        pam_syslog(idata->pamh, LOG_ERR, \"user unknown '%s'\", user_name);\n        return PAM_USER_UNKNOWN;\n    }\n\n    /*\n     * Add the user info to the instance data so we can refer to them later.\n     */\n    idata->user[0] = 0;\n    strncat(idata->user, user_name, sizeof(idata->user) - 1);\n    idata->uid = pwd->pw_uid;\n    idata->gid = pwd->pw_gid;\n\n    /* Fill in RUSER too */\n    retval = pam_get_item(idata->pamh, PAM_RUSER, (void*) &user_name );\n    if ( user_name != NULL && retval == PAM_SUCCESS && user_name[0] != '\\0' ) {\n\tstrncat(idata->ruser, user_name, sizeof(idata->ruser) - 1);\n\tpwd = pam_modutil_getpwnam(idata->pamh, user_name);\n    } else {\n\tpwd = pam_modutil_getpwuid(idata->pamh, getuid());\n    }\n    if (!pwd) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"user unknown '%s'\", user_name);\n\treturn PAM_USER_UNKNOWN;\n    }\n    user_name = pwd->pw_name;\n\n    idata->ruser[0] = 0;\n    strncat(idata->ruser, user_name, sizeof(idata->ruser) - 1);\n    idata->ruid = pwd->pw_uid;\n\n    return PAM_SUCCESS;\n}\n\n/*\n * Entry point from pam_open_session call.\n */\nint pam_sm_open_session(pam_handle_t *pamh, int flags UNUSED,\n                                   int argc, const char **argv)\n{\n    int i, retval;\n    struct instance_data idata;\n    enum unmnt_op unmnt = NO_UNMNT;\n\n    /* init instance data */\n    idata.flags = 0;\n    idata.polydirs_ptr = NULL;\n    idata.protect_dirs = NULL;\n    idata.pamh = pamh;\n#ifdef WITH_SELINUX\n    if (is_selinux_enabled())\n        idata.flags |= PAMNS_SELINUX_ENABLED;\n    if (ctxt_based_inst_needed())\n        idata.flags |= PAMNS_CTXT_BASED_INST;\n#endif\n\n    /* Parse arguments. */\n    for (i = 0; i < argc; i++) {\n        if (strcmp(argv[i], \"debug\") == 0)\n            idata.flags |= PAMNS_DEBUG;\n        if (strcmp(argv[i], \"gen_hash\") == 0)\n            idata.flags |= PAMNS_GEN_HASH;\n        if (strcmp(argv[i], \"ignore_config_error\") == 0)\n            idata.flags |= PAMNS_IGN_CONFIG_ERR;\n        if (strcmp(argv[i], \"ignore_instance_parent_mode\") == 0)\n            idata.flags |= PAMNS_IGN_INST_PARENT_MODE;\n        if (strcmp(argv[i], \"use_current_context\") == 0) {\n            idata.flags |= PAMNS_USE_CURRENT_CONTEXT;\n            idata.flags |= PAMNS_CTXT_BASED_INST;\n        }\n        if (strcmp(argv[i], \"use_default_context\") == 0) {\n            idata.flags |= PAMNS_USE_DEFAULT_CONTEXT;\n            idata.flags |= PAMNS_CTXT_BASED_INST;\n        }\n        if (strcmp(argv[i], \"mount_private\") == 0) {\n            idata.flags |= PAMNS_MOUNT_PRIVATE;\n        }\n        if (strcmp(argv[i], \"unmnt_remnt\") == 0)\n            unmnt = UNMNT_REMNT;\n        if (strcmp(argv[i], \"unmnt_only\") == 0)\n            unmnt = UNMNT_ONLY;\n\tif (strcmp(argv[i], \"require_selinux\") == 0) {\n\t\tif (!(idata.flags & PAMNS_SELINUX_ENABLED)) {\n\t\t\tpam_syslog(idata.pamh, LOG_ERR,\n\t\t    \"selinux_required option given and selinux is disabled\");\n\t\t\treturn PAM_SESSION_ERR;\n\t\t}\n\t}\n    }\n    if (idata.flags & PAMNS_DEBUG)\n        pam_syslog(idata.pamh, LOG_DEBUG, \"open_session - start\");\n\n    retval = get_user_data(&idata);\n    if (retval != PAM_SUCCESS)\n\treturn retval;\n\n    if (root_shared()) {\n\tidata.flags |= PAMNS_MOUNT_PRIVATE;\n    }\n\n    /*\n     * Parse namespace configuration file which lists directories to\n     * polyinstantiate, directory where instance directories are to\n     * be created and the method used for polyinstantiation.\n     */\n    retval = parse_config_file(&idata);\n    if (retval != PAM_SUCCESS) {\n\tdel_polydir_list(idata.polydirs_ptr);\n        return PAM_SESSION_ERR;\n    }\n\n    if (idata.polydirs_ptr) {\n        retval = setup_namespace(&idata, unmnt);\n        if (idata.flags & PAMNS_DEBUG) {\n            if (retval)\n                pam_syslog(idata.pamh, LOG_DEBUG,\n\t\t\t\"namespace setup failed for pid %d\", getpid());\n            else\n                pam_syslog(idata.pamh, LOG_DEBUG,\n\t\t\t\"namespace setup ok for pid %d\", getpid());\n        }\n    } else if (idata.flags & PAMNS_DEBUG)\n        pam_syslog(idata.pamh, LOG_DEBUG, \"Nothing to polyinstantiate\");\n\n    if (retval != PAM_SUCCESS)\n\tdel_polydir_list(idata.polydirs_ptr);\n    return retval;\n}\n\n\n/*\n * Entry point from pam_close_session call.\n */\nint pam_sm_close_session(pam_handle_t *pamh, int flags UNUSED,\n                                    int argc, const char **argv)\n{\n    int i, retval;\n    struct instance_data idata;\n    const void *polyptr;\n\n    /* init instance data */\n    idata.flags = 0;\n    idata.polydirs_ptr = NULL;\n    idata.pamh = pamh;\n#ifdef WITH_SELINUX\n    if (is_selinux_enabled())\n        idata.flags |= PAMNS_SELINUX_ENABLED;\n    if (ctxt_based_inst_needed())\n        idata.flags |= PAMNS_CTXT_BASED_INST;\n#endif\n\n    /* Parse arguments. */\n    for (i = 0; i < argc; i++) {\n        if (strcmp(argv[i], \"debug\") == 0)\n            idata.flags |= PAMNS_DEBUG;\n        if (strcmp(argv[i], \"ignore_config_error\") == 0)\n            idata.flags |= PAMNS_IGN_CONFIG_ERR;\n        if (strcmp(argv[i], \"unmount_on_close\") == 0)\n            idata.flags |= PAMNS_UNMOUNT_ON_CLOSE;\n    }\n\n    if (idata.flags & PAMNS_DEBUG)\n        pam_syslog(idata.pamh, LOG_DEBUG, \"close_session - start\");\n\n    /*\n     * Normally the unmount is implicitly done when the last\n     * process in the private namespace exits.\n     * If it is ensured that there are no child processes left in\n     * the private namespace by other means and if there are\n     * multiple sessions opened and closed sequentially by the\n     * same process, the \"unmount_on_close\" option might be\n     * used to unmount the polydirs explicitly.\n     */\n    if (!(idata.flags & PAMNS_UNMOUNT_ON_CLOSE)) {\n\tpam_set_data(idata.pamh, NAMESPACE_POLYDIR_DATA, NULL, NULL);\n\tpam_set_data(idata.pamh, NAMESPACE_PROTECT_DATA, NULL, NULL);\n\n\tif (idata.flags & PAMNS_DEBUG)\n\t    pam_syslog(idata.pamh, LOG_DEBUG, \"close_session - successful\");\n        return PAM_SUCCESS;\n    }\n\n    retval = get_user_data(&idata);\n    if (retval != PAM_SUCCESS)\n\treturn retval;\n\n    retval = pam_get_data(idata.pamh, NAMESPACE_POLYDIR_DATA, &polyptr);\n    if (retval != PAM_SUCCESS || polyptr == NULL)\n\t/* nothing to reset */\n\treturn PAM_SUCCESS;\n\n    DIAG_PUSH_IGNORE_CAST_QUAL;\n    idata.polydirs_ptr = (void *)polyptr;\n    DIAG_POP_IGNORE_CAST_QUAL;\n\n    if (idata.flags & PAMNS_DEBUG)\n        pam_syslog(idata.pamh, LOG_DEBUG, \"Resetting namespace for pid %d\",\n\t\tgetpid());\n\n    retval = orig_namespace(&idata);\n    if (idata.flags & PAMNS_DEBUG) {\n        if (retval)\n            pam_syslog(idata.pamh, LOG_DEBUG,\n\t\t\"resetting namespace failed for pid %d\", getpid());\n        else\n            pam_syslog(idata.pamh, LOG_DEBUG,\n\t\t\"resetting namespace ok for pid %d\", getpid());\n    }\n\n    pam_set_data(idata.pamh, NAMESPACE_POLYDIR_DATA, NULL, NULL);\n    pam_set_data(idata.pamh, NAMESPACE_PROTECT_DATA, NULL, NULL);\n\n    return PAM_SUCCESS;\n}\n"], "fixing_code": ["/******************************************************************************\n * A module for Linux-PAM that will set the default namespace after\n * establishing a session via PAM.\n *\n * (C) Copyright IBM Corporation 2005\n * (C) Copyright Red Hat, Inc. 2006, 2008\n * All Rights Reserved.\n *\n * Written by: Janak Desai <janak@us.ibm.com>\n * With Revisions by: Steve Grubb <sgrubb@redhat.com>\n * Contributions by: Xavier Toth <txtoth@gmail.com>,\n *                   Tomas Mraz <tmraz@redhat.com>\n * Derived from a namespace setup patch by Chad Sellers <cdselle@tycho.nsa.gov>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * on the rights to use, copy, modify, merge, publish, distribute, sub\n * license, and/or sell copies of the Software, and to permit persons to whom\n * the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL\n * IBM AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n#define _ATFILE_SOURCE\n\n#include \"pam_cc_compat.h\"\n#include \"pam_inline.h\"\n#include \"pam_namespace.h\"\n#include \"argv_parse.h\"\n\n/* --- evaluating all files in VENDORDIR/security/namespace.d and /etc/security/namespace.d --- */\nstatic const char *base_name(const char *path)\n{\n    const char *base = strrchr(path, '/');\n    return base ? base+1 : path;\n}\n\nstatic int\ncompare_filename(const void *a, const void *b)\n{\n\treturn strcmp(base_name(* (char * const *) a),\n\t\t      base_name(* (char * const *) b));\n}\n\nstatic void close_fds_pre_exec(struct instance_data *idata)\n{\n\tif (pam_modutil_sanitize_helper_fds(idata->pamh, PAM_MODUTIL_IGNORE_FD,\n\t\t\tPAM_MODUTIL_IGNORE_FD, PAM_MODUTIL_IGNORE_FD) < 0) {\n\t\t_exit(1);\n\t}\n}\n\n/* Evaluating a list of files which have to be parsed in the right order:\n *\n * - If etc/security/namespace.d/@filename@.conf exists, then\n *   %vendordir%/security/namespace.d/@filename@.conf should not be used.\n * - All files in both namespace.d directories are sorted by their @filename@.conf in\n *   lexicographic order regardless of which of the directories they reside in. */\nstatic char **read_namespace_dir(struct instance_data *idata)\n{\n\tglob_t globbuf;\n\tsize_t i=0;\n\tint glob_rv = glob(NAMESPACE_D_GLOB, GLOB_ERR | GLOB_NOSORT, NULL, &globbuf);\n\tchar **file_list;\n\tsize_t file_list_size = glob_rv == 0 ? globbuf.gl_pathc : 0;\n\n#ifdef VENDOR_NAMESPACE_D_GLOB\n\tglob_t globbuf_vendor;\n\tint glob_rv_vendor = glob(VENDOR_NAMESPACE_D_GLOB, GLOB_ERR | GLOB_NOSORT, NULL, &globbuf_vendor);\n\tif (glob_rv_vendor == 0)\n\t    file_list_size += globbuf_vendor.gl_pathc;\n#endif\n\tfile_list = malloc((file_list_size + 1) * sizeof(char*));\n\tif (file_list == NULL) {\n\t    pam_syslog(idata->pamh, LOG_ERR, \"Cannot allocate memory for file list: %m\");\n#ifdef VENDOR_NAMESPACE_D_GLOB\n\t    if (glob_rv_vendor == 0)\n\t\tglobfree(&globbuf_vendor);\n#endif\n\t    if (glob_rv == 0)\n\t\tglobfree(&globbuf);\n\t    return NULL;\n\t}\n\n\tif (glob_rv == 0) {\n\t    for (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tfile_list[i] = strdup(globbuf.gl_pathv[i]);\n\t\tif (file_list[i] == NULL) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR, \"strdup failed: %m\");\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#ifdef VENDOR_NAMESPACE_D_GLOB\n\tif (glob_rv_vendor == 0) {\n\t    for (size_t j = 0; j < globbuf_vendor.gl_pathc; j++) {\n\t\tif (glob_rv == 0 && globbuf.gl_pathc > 0) {\n\t\t    int double_found = 0;\n\t\t    for (size_t k = 0; k < globbuf.gl_pathc; k++) {\n\t\t\tif (strcmp(base_name(globbuf.gl_pathv[k]),\n\t\t\t\t   base_name(globbuf_vendor.gl_pathv[j])) == 0) {\n\t\t\t\tdouble_found = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\t\t    if (double_found)\n\t\t\tcontinue;\n\t\t}\n\t\tfile_list[i] = strdup(globbuf_vendor.gl_pathv[j]);\n\t\tif (file_list[i] == NULL) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR, \"strdup failed: %m\");\n\t\t    break;\n\t\t}\n\t\ti++;\n\t    }\n\t    globfree(&globbuf_vendor);\n\t}\n#endif\n\tfile_list[i] = NULL;\n\tqsort(file_list, i, sizeof(char *), compare_filename);\n\tif (glob_rv == 0)\n\t    globfree(&globbuf);\n\n\treturn file_list;\n}\n\n/*\n * Adds an entry for a polyinstantiated directory to the linked list of\n * polyinstantiated directories. It is called from process_line() while\n * parsing the namespace configuration file.\n */\nstatic void add_polydir_entry(struct instance_data *idata,\n\tstruct polydir_s *ent)\n{\n    /* Now attach to linked list */\n    ent->next = NULL;\n    if (idata->polydirs_ptr == NULL)\n        idata->polydirs_ptr = ent;\n    else {\n        struct polydir_s *tail;\n\n        tail = idata->polydirs_ptr;\n        while (tail->next)\n            tail = tail->next;\n        tail->next = ent;\n    }\n}\n\nstatic void del_polydir(struct polydir_s *poly)\n{\n\tif (poly) {\n\t\tfree(poly->uid);\n\t\tfree(poly->init_script);\n\t\tfree(poly->mount_opts);\n\t\tfree(poly);\n\t}\n}\n\n/*\n * Deletes all the entries in the linked list.\n */\nstatic void del_polydir_list(struct polydir_s *polydirs_ptr)\n{\n        struct polydir_s *dptr = polydirs_ptr;\n\n\twhile (dptr) {\n\t\tstruct polydir_s *tptr = dptr;\n\t\tdptr = dptr->next;\n\t\tdel_polydir(tptr);\n\t}\n}\n\nstatic void unprotect_dirs(struct protect_dir_s *dir)\n{\n\tstruct protect_dir_s *next;\n\n\twhile (dir != NULL) {\n\t\tumount(dir->dir);\n\t\tfree(dir->dir);\n\t\tnext = dir->next;\n\t\tfree(dir);\n\t\tdir = next;\n\t}\n}\n\nstatic void cleanup_polydir_data(pam_handle_t *pamh UNUSED , void *data, int err UNUSED)\n{\n\tdel_polydir_list(data);\n}\n\nstatic void cleanup_protect_data(pam_handle_t *pamh UNUSED , void *data, int err UNUSED)\n{\n\tunprotect_dirs(data);\n}\n\nstatic char *expand_variables(const char *orig, const char *var_names[], const char *var_values[])\n{\n\tconst char *src = orig;\n\tchar *dst;\n\tchar *expanded;\n\tchar c;\n\tsize_t dstlen = 0;\n\twhile (*src) {\n\t\tif (*src == '$') {\n\t\t\tint i;\n\t\t\tfor (i = 0; var_names[i]; i++) {\n\t\t\t\tsize_t namelen = strlen(var_names[i]);\n\t\t\t\tif (strncmp(var_names[i], src+1, namelen) == 0) {\n\t\t\t\t\tdstlen += strlen(var_values[i]) - 1; /* $ */\n\t\t\t\t\tsrc += namelen;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++dstlen;\n\t\t++src;\n\t}\n\tif ((dst=expanded=malloc(dstlen + 1)) == NULL)\n\t\treturn NULL;\n\tsrc = orig;\n\twhile ((c=*src) != '\\0') {\n\t\tif (c == '$') {\n\t\t\tint i;\n\t\t\tfor (i = 0; var_names[i]; i++) {\n\t\t\t\tsize_t namelen = strlen(var_names[i]);\n\t\t\t\tif (strncmp(var_names[i], src+1, namelen) == 0) {\n\t\t\t\t\tdst = stpcpy(dst, var_values[i]);\n\t\t\t\t\t--dst;\n\t\t\t\t\tc = *dst; /* replace $ */\n\t\t\t\t\tsrc += namelen;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*dst = c;\n\t\t++dst;\n\t\t++src;\n\t}\n\t*dst = '\\0';\n\treturn expanded;\n}\n\nstatic int parse_create_params(char *params, struct polydir_s *poly)\n{\n    char *next;\n    struct passwd *pwd = NULL;\n    struct group *grp;\n\n    poly->mode = (mode_t)ULONG_MAX;\n    poly->owner = (uid_t)ULONG_MAX;\n    poly->group = (gid_t)ULONG_MAX;\n\n    if (*params != '=')\n\treturn 0;\n    params++;\n\n    next = strchr(params, ',');\n    if (next != NULL) {\n\t*next = '\\0';\n\tnext++;\n    }\n\n    if (*params != '\\0') {\n\terrno = 0;\n\tpoly->mode = (mode_t)strtoul(params, NULL, 0);\n\tif (errno != 0) {\n\t    poly->mode = (mode_t)ULONG_MAX;\n\t}\n    }\n\n    params = next;\n    if (params == NULL)\n\treturn 0;\n    next = strchr(params, ',');\n    if (next != NULL) {\n\t*next = '\\0';\n\tnext++;\n    }\n\n    if (*params != '\\0') {\n\tpwd = getpwnam(params); /* session modules are not reentrant */\n\tif (pwd == NULL)\n\t    return -1;\n\tpoly->owner = pwd->pw_uid;\n    }\n\n    params = next;\n    if (params == NULL || *params == '\\0') {\n\tif (pwd != NULL)\n\t    poly->group = pwd->pw_gid;\n\treturn 0;\n    }\n    grp = getgrnam(params);\n    if (grp == NULL)\n\treturn -1;\n    poly->group = grp->gr_gid;\n\n    return 0;\n}\n\nstatic int parse_iscript_params(char *params, struct polydir_s *poly)\n{\n    if (*params != '=')\n\treturn 0;\n    params++;\n\n    if (*params != '\\0') {\n\tif (*params != '/') { /* path is relative to NAMESPACE_D_DIR */\n\t\tif (asprintf(&poly->init_script, \"%s%s\", NAMESPACE_D_DIR, params) == -1)\n\t\t\treturn -1;\n\t} else {\n\t\tpoly->init_script = strdup(params);\n\t}\n\tif (poly->init_script == NULL)\n\t\treturn -1;\n    }\n    return 0;\n}\n\nstruct mntflag {\n    const char *name;\n    size_t len;\n    unsigned long flag;\n};\n\n#define LITERAL_AND_LEN(x) x, sizeof(x) - 1\n\nstatic const struct mntflag mntflags[] = {\n\t{ LITERAL_AND_LEN(\"noexec\"), MS_NOEXEC },\n\t{ LITERAL_AND_LEN(\"nosuid\"), MS_NOSUID },\n\t{ LITERAL_AND_LEN(\"nodev\"), MS_NODEV }\n    };\n\nstatic int filter_mntopts(const char *opts, char **filtered,\n\t\tunsigned long *mountflags)\n{\n    size_t origlen = strlen(opts);\n    const char *end;\n    char *dest;\n\n    dest = *filtered = NULL;\n    *mountflags = 0;\n\n    if (origlen == 0)\n\treturn 0;\n\n    do {\n\tsize_t len;\n\tunsigned int i;\n\n\tend = strchr(opts, ',');\n\tif (end == NULL) {\n\t    len = strlen(opts);\n\t} else {\n\t    len = end - opts;\n\t}\n\n\tfor (i = 0; i < PAM_ARRAY_SIZE(mntflags); i++) {\n\t    if (mntflags[i].len != len)\n\t\tcontinue;\n\t    if (memcmp(mntflags[i].name, opts, len) == 0) {\n\t\t*mountflags |= mntflags[i].flag;\n\t\topts = end;\n\t\tbreak;\n\t    }\n\t}\n\n\tif (opts != end) {\n\t    if (dest != NULL) {\n\t\t*dest = ',';\n\t\t++dest;\n\t    } else {\n\t\tdest = *filtered = calloc(1, origlen + 1);\n\t\tif (dest == NULL)\n\t\t    return -1;\n\t    }\n\t    memcpy(dest, opts, len);\n\t    dest += len;\n\t}\n\n\topts = end + 1;\n    } while (end != NULL);\n\n    return 0;\n}\n\nstatic int parse_method(char *method, struct polydir_s *poly,\n\t\tstruct instance_data *idata)\n{\n    enum polymethod pm;\n    char *sptr = NULL;\n    static const char *method_names[] = { \"user\", \"context\", \"level\", \"tmpdir\",\n\t\"tmpfs\", NULL };\n    static const char *flag_names[] = { \"create\", \"noinit\", \"iscript\",\n\t\"shared\", \"mntopts\", NULL };\n    static const unsigned int flag_values[] = { POLYDIR_CREATE, POLYDIR_NOINIT,\n\tPOLYDIR_ISCRIPT, POLYDIR_SHARED, POLYDIR_MNTOPTS };\n    int i;\n    char *flag;\n\n    method = strtok_r(method, \":\", &sptr);\n    pm = NONE;\n\n    for (i = 0; method_names[i]; i++) {\n\tif (strcmp(method, method_names[i]) == 0) {\n\t\tpm = i + 1; /* 0 = NONE */\n\t}\n    }\n\n    if (pm == NONE) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Unknown method\");\n        return -1;\n    }\n\n    poly->method = pm;\n\n    while ((flag=strtok_r(NULL, \":\", &sptr)) != NULL) {\n\tfor (i = 0; flag_names[i]; i++) {\n\t\tsize_t namelen = strlen(flag_names[i]);\n\n\t\tif (strncmp(flag, flag_names[i], namelen) == 0) {\n\t\t\tpoly->flags |= flag_values[i];\n\t\t\tswitch (flag_values[i]) {\n\t\t\t    case POLYDIR_CREATE:\n\t\t\t\tif (parse_create_params(flag+namelen, poly) != 0) {\n\t\t\t\t        pam_syslog(idata->pamh, LOG_CRIT, \"Invalid create parameters\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t    case POLYDIR_ISCRIPT:\n\t\t\t\tif (parse_iscript_params(flag+namelen, poly) != 0) {\n\t\t\t\t        pam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\t    case POLYDIR_MNTOPTS:\n\t\t\t\tif (flag[namelen] != '=')\n\t\t\t\t\tbreak;\n\t\t\t\tif (poly->method != TMPFS) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_WARNING, \"Mount options applicable only to tmpfs method\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfree(poly->mount_opts); /* if duplicate mntopts specified */\n\t\t\t\tpoly->mount_opts = NULL;\n\t\t\t\tif (filter_mntopts(flag+namelen+1, &poly->mount_opts, &poly->mount_flags) != 0) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n    }\n\n    return 0;\n}\n\n/*\n * Called from parse_config_file, this function processes a single line\n * of the namespace configuration file. It skips over comments and incomplete\n * or malformed lines. It processes a valid line with information on\n * polyinstantiating a directory by populating appropriate fields of a\n * polyinstantiated directory structure and then calling add_polydir_entry to\n * add that entry to the linked list of polyinstantiated directories.\n */\nstatic int process_line(char *line, const char *home, const char *rhome,\n\t\t\tstruct instance_data *idata)\n{\n    char *dir = NULL, *instance_prefix = NULL, *rdir = NULL;\n    char *method, *uids;\n    char *tptr;\n    struct polydir_s *poly;\n    int retval = 0;\n    char **config_options = NULL;\n    static const char *var_names[] = {\"HOME\", \"USER\", NULL};\n    const char *var_values[] = {home, idata->user};\n    const char *rvar_values[] = {rhome, idata->ruser};\n    size_t len;\n\n    /*\n     * skip the leading white space\n     */\n    while (*line && isspace((unsigned char)*line))\n        line++;\n\n    /*\n     * Rip off the comments\n     */\n    tptr = strchr(line,'#');\n    if (tptr)\n        *tptr = '\\0';\n\n    /*\n     * Rip off the newline char\n     */\n    tptr = strchr(line,'\\n');\n    if (tptr)\n        *tptr = '\\0';\n\n    /*\n     * Anything left ?\n     */\n    if (line[0] == 0)\n        return 0;\n\n    poly = calloc(1, sizeof(*poly));\n    if (poly == NULL)\n\tgoto erralloc;\n\n    /*\n     * Initialize and scan the five strings from the line from the\n     * namespace configuration file.\n     */\n    retval = argv_parse(line, NULL, &config_options);\n    if (retval != 0) {\n        goto erralloc;\n    }\n\n    dir = config_options[0];\n    if (dir == NULL) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing polydir\");\n        goto skipping;\n    }\n    instance_prefix = config_options[1];\n    if (instance_prefix == NULL) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing instance_prefix\");\n        dir = NULL;\n        goto skipping;\n    }\n    method = config_options[2];\n    if (method == NULL) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing method\");\n        instance_prefix = NULL;\n        dir = NULL;\n        goto skipping;\n    }\n\n    /*\n     * Only the uids field is allowed to be blank, to indicate no\n     * override users for polyinstantiation of that directory. If\n     * any of the other fields are blank, the line is incomplete so\n     * skip it.\n     */\n    uids = config_options[3];\n\n    /*\n     * Expand $HOME and $USER in poly dir and instance dir prefix\n     */\n    if ((rdir=expand_variables(dir, var_names, rvar_values)) == NULL) {\n\t    instance_prefix = NULL;\n\t    dir = NULL;\n\t    goto erralloc;\n    }\n\n    if ((dir=expand_variables(dir, var_names, var_values)) == NULL) {\n\t    instance_prefix = NULL;\n\t    goto erralloc;\n    }\n\n    if ((instance_prefix=expand_variables(instance_prefix, var_names, var_values))\n\t    == NULL) {\n\t    goto erralloc;\n    }\n\n    if (idata->flags & PAMNS_DEBUG) {\n\t    pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded polydir: '%s'\", dir);\n\t    pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded ruser polydir: '%s'\", rdir);\n\t    pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded instance prefix: '%s'\", instance_prefix);\n    }\n\n    len = strlen(dir);\n    if (len > 0 && dir[len-1] == '/') {\n\t    dir[len-1] = '\\0';\n    }\n\n    len = strlen(rdir);\n    if (len > 0 && rdir[len-1] == '/') {\n\t    rdir[len-1] = '\\0';\n    }\n\n    if (dir[0] == '\\0' || rdir[0] == '\\0') {\n\t    pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid polydir\");\n\t    goto skipping;\n    }\n\n    /*\n     * Populate polyinstantiated directory structure with appropriate\n     * pathnames and the method with which to polyinstantiate.\n     */\n    if (parse_method(method, poly, idata) != 0) {\n\t    goto skipping;\n    }\n\n#define COPY_STR(dst, src, apd)                                \\\n\t(snprintf((dst), sizeof(dst), \"%s%s\", (src), (apd)) != \\\n\t\t  (ssize_t) (strlen(src) + strlen(apd)))\n\n    if (COPY_STR(poly->dir, dir, \"\")\n\t|| COPY_STR(poly->rdir, rdir, \"\")\n\t|| COPY_STR(poly->instance_prefix, instance_prefix,\n\t\t    poly->method == TMPDIR ? \"XXXXXX\" : \"\")) {\n\tpam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames too long\");\n\tgoto skipping;\n    }\n\n    /*\n     * Ensure that all pathnames are absolute path names.\n     */\n    if ((poly->dir[0] != '/') || (poly->method != TMPFS && poly->instance_prefix[0] != '/')) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames must start with '/'\");\n        goto skipping;\n    }\n    if (strstr(dir, \"..\") || strstr(poly->instance_prefix, \"..\")) {\n        pam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames must not contain '..'\");\n        goto skipping;\n    }\n\n    /*\n     * If the line in namespace.conf for a directory to polyinstantiate\n     * contains a list of override users (users for whom polyinstantiation\n     * is not performed), read the user ids, convert names into uids, and\n     * add to polyinstantiated directory structure.\n     */\n    if (uids) {\n        uid_t *uidptr;\n        const char *ustr, *sstr;\n        size_t count, i;\n\n\tif (*uids == '~') {\n\t\tpoly->flags |= POLYDIR_EXCLUSIVE;\n\t\tuids++;\n\t}\n        for (count = 0, ustr = sstr = uids; sstr; ustr = sstr + 1, count++)\n           sstr = strchr(ustr, ',');\n\n        if (count > UINT_MAX || count > SIZE_MAX / sizeof(uid_t)) {\n            pam_syslog(idata->pamh, LOG_ERR, \"Too many uids encountered in configuration\");\n            goto skipping;\n        }\n\n        poly->num_uids = count;\n        poly->uid = malloc(count * sizeof (uid_t));\n        uidptr = poly->uid;\n        if (uidptr == NULL) {\n            goto erralloc;\n        }\n\n        ustr = uids;\n        for (i = 0; i < count; i++) {\n            struct passwd *pwd;\n\n            tptr = strchr(ustr, ',');\n            if (tptr)\n                *tptr = '\\0';\n\n            pwd = pam_modutil_getpwnam(idata->pamh, ustr);\n            if (pwd == NULL) {\n\t\tpam_syslog(idata->pamh, LOG_ERR, \"Unknown user %s in configuration\", ustr);\n\t\tpoly->num_uids--;\n            } else {\n                *uidptr = pwd->pw_uid;\n                uidptr++;\n            }\n            ustr = tptr + 1;\n        }\n    }\n\n    /*\n     * Add polyinstantiated directory structure to the linked list\n     * of all polyinstantiated directory structures.\n     */\n    add_polydir_entry(idata, poly);\n\n    goto out;\n\nerralloc:\n    pam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");\n\nskipping:\n    if (idata->flags & PAMNS_IGN_CONFIG_ERR)\n        retval = 0;\n    else\n        retval = PAM_SERVICE_ERR;\n    del_polydir(poly);\nout:\n    free(rdir);\n    free(dir);\n    free(instance_prefix);\n    argv_free(config_options);\n    return retval;\n}\n\n\n/*\n * Parses /etc/security/namespace.conf file to build a linked list of\n * polyinstantiated directory structures of type polydir_s. Each entry\n * in the linked list contains information needed to polyinstantiate\n * one directory.\n */\nstatic int parse_config_file(struct instance_data *idata)\n{\n    FILE *fil;\n    char *home, *rhome;\n    const char *confname;\n    struct passwd *cpwd;\n    char *line;\n    int retval;\n    size_t len = 0;\n    size_t n;\n\n    /*\n     * Extract the user's home directory to resolve $HOME entries\n     * in the namespace configuration file.\n     */\n    cpwd = pam_modutil_getpwnam(idata->pamh, idata->user);\n    if (!cpwd) {\n        pam_syslog(idata->pamh, LOG_ERR,\n               \"Error getting home dir for '%s'\", idata->user);\n        return PAM_SESSION_ERR;\n    }\n    if ((home=strdup(cpwd->pw_dir)) == NULL) {\n\tpam_syslog(idata->pamh, LOG_CRIT,\n\t\t\"Memory allocation error\");\n\treturn PAM_SESSION_ERR;\n    }\n\n    cpwd = pam_modutil_getpwnam(idata->pamh, idata->ruser);\n    if (!cpwd) {\n\tpam_syslog(idata->pamh, LOG_ERR,\n\t        \"Error getting home dir for '%s'\", idata->ruser);\n\tfree(home);\n\treturn PAM_SESSION_ERR;\n    }\n\n    if ((rhome=strdup(cpwd->pw_dir)) == NULL) {\n\tpam_syslog(idata->pamh, LOG_CRIT,\n\t\t\"Memory allocation error\");\n\tfree(home);\n\treturn PAM_SESSION_ERR;\n    }\n\n    /*\n     * Open configuration file, read one line at a time and call\n     * process_line to process each line.\n     */\n\n    confname = PAM_NAMESPACE_CONFIG;\n#ifdef VENDOR_PAM_NAMESPACE_CONFIG\n    /* Check whether PAM_NAMESPACE_CONFIG file is available.\n     * If it does not exist, fall back to VENDOR_PAM_NAMESPACE_CONFIG file. */\n    struct stat buffer;\n    if (stat(confname, &buffer) != 0 && errno == ENOENT) {\n\tconfname = VENDOR_PAM_NAMESPACE_CONFIG;\n    }\n#endif\n    char **filename_list = read_namespace_dir(idata);\n    n = 0;\n    for (;;) {\n\tif (idata->flags & PAMNS_DEBUG)\n\t\tpam_syslog(idata->pamh, LOG_DEBUG, \"Parsing config file %s\",\n\t\t\tconfname);\n\tfil = fopen(confname, \"r\");\n\tif (fil == NULL) {\n\t    pam_syslog(idata->pamh, LOG_ERR, \"Error opening config file %s\",\n\t\tconfname);\n\t    free(rhome);\n\t    free(home);\n\t    return PAM_SERVICE_ERR;\n\t}\n\n\t/* Use unlocked IO */\n\t__fsetlocking(fil, FSETLOCKING_BYCALLER);\n\n\tline = NULL;\n\t/* loop reading the file */\n\twhile (getline(&line, &len, fil) > 0) {\n\t    retval = process_line(line, home, rhome, idata);\n\t    if (retval) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\"Error processing conf file %s line %s\", confname, line);\n\t        fclose(fil);\n\t        free(line);\n\t        free(rhome);\n\t        free(home);\n\t        return PAM_SERVICE_ERR;\n\t    }\n\t}\n\tfclose(fil);\n\tfree(line);\n\n\tif (filename_list == NULL || filename_list[n] == NULL)\n\t    break;\n\n\tconfname = filename_list[n++];\n    }\n\n    if (filename_list != NULL) {\n\tfor (size_t i = 0; filename_list[i] != NULL; i++)\n\t    free(filename_list[i]);\n\tfree(filename_list);\n    }\n\n    free(rhome);\n    free(home);\n\n    /* All done...just some debug stuff */\n    if (idata->flags & PAMNS_DEBUG) {\n        struct polydir_s *dptr = idata->polydirs_ptr;\n        uid_t *iptr;\n        uid_t i;\n\n        pam_syslog(idata->pamh, LOG_DEBUG,\n\t    dptr?\"Configured poly dirs:\":\"No configured poly dirs\");\n        while (dptr) {\n            pam_syslog(idata->pamh, LOG_DEBUG, \"dir='%s' iprefix='%s' meth=%d\",\n\t\t   dptr->dir, dptr->instance_prefix, dptr->method);\n            for (i = 0, iptr = dptr->uid; i < dptr->num_uids; i++, iptr++)\n                pam_syslog(idata->pamh, LOG_DEBUG, \"override user %d \", *iptr);\n            dptr = dptr->next;\n        }\n    }\n\n    return PAM_SUCCESS;\n}\n\n\n/*\n * This function returns true if a given uid is present in the polyinstantiated\n * directory's list of override uids. If the uid is one of the override\n * uids for the polyinstantiated directory, polyinstantiation is not\n * performed for that user for that directory.\n * If exclusive is set the returned values are opposite.\n */\nstatic int ns_override(struct polydir_s *polyptr, struct instance_data *idata,\n\t\tuid_t uid)\n{\n    unsigned int i;\n\n    if (idata->flags & PAMNS_DEBUG)\n\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\"Checking for ns override in dir %s for uid %d\",\n\t\tpolyptr->dir, uid);\n\n    for (i = 0; i < polyptr->num_uids; i++) {\n        if (uid == polyptr->uid[i]) {\n            return !(polyptr->flags & POLYDIR_EXCLUSIVE);\n        }\n    }\n\n    return !!(polyptr->flags & POLYDIR_EXCLUSIVE);\n}\n\n/*\n * md5hash generates a hash of the passed in instance directory name.\n */\nstatic char *md5hash(const char *instname, struct instance_data *idata)\n{\n    int i;\n    char *md5inst = NULL;\n    char *to;\n    unsigned char inst_digest[MD5_DIGEST_LENGTH];\n\n    /*\n     * Create MD5 hashes for instance pathname.\n     */\n\n    MD5((const unsigned char *)instname, strlen(instname), inst_digest);\n\n    if ((md5inst = malloc(MD5_DIGEST_LENGTH * 2 + 1)) == NULL) {\n        pam_syslog(idata->pamh, LOG_CRIT, \"Unable to allocate buffer\");\n        return NULL;\n    }\n\n    to = md5inst;\n    for (i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        snprintf(to, 3, \"%02x\", (unsigned int)inst_digest[i]);\n        to += 2;\n    }\n\n    return md5inst;\n}\n\n#ifdef WITH_SELINUX\nstatic int form_context(const struct polydir_s *polyptr,\n\t\tchar **i_context, char **origcon,\n\t\tstruct instance_data *idata)\n{\n\tint rc = PAM_SUCCESS;\n\tchar *scon = NULL;\n\tsecurity_class_t tclass;\n\n\t/*\n\t * Get the security context of the directory to polyinstantiate.\n\t */\n\trc = getfilecon(polyptr->dir, origcon);\n\tif (rc < 0 || *origcon == NULL) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\"Error getting poly dir context, %m\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tif (polyptr->method == USER) return PAM_SUCCESS;\n\n\tif (idata->flags & PAMNS_USE_CURRENT_CONTEXT) {\n\t\trc = getcon(&scon);\n\t} else if (idata->flags & PAMNS_USE_DEFAULT_CONTEXT) {\n\t\tchar *seuser = NULL, *level = NULL;\n\n\t\tif ((rc=getseuserbyname(idata->user, &seuser, &level)) == 0) {\n\t\t\trc = get_default_context_with_level(seuser, level, NULL, &scon);\n\t\t\tfree(seuser);\n\t\t\tfree(level);\n\t\t}\n\t} else {\n\t\trc = getexeccon(&scon);\n\t}\n\tif (rc < 0 || scon == NULL) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t   \"Error getting exec context, %m\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\t/*\n\t * If polyinstantiating based on security context, get current\n\t * process security context, get security class for directories,\n\t * and ask the policy to provide security context of the\n\t * polyinstantiated instance directory.\n\t */\n\n\tif (polyptr->method == CONTEXT) {\n\t\ttclass = string_to_security_class(\"dir\");\n\t\tif (tclass == 0) {\n\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t   \"Error getting dir security class\");\n\t\t\tfreecon(scon);\n\t\t\treturn PAM_SESSION_ERR;\n\t\t}\n\n\t\tif (security_compute_member(scon, *origcon, tclass,\n\t\t\t\t\ti_context) < 0) {\n\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\"Error computing poly dir member context\");\n\t\t\tfreecon(scon);\n\t\t\treturn PAM_SESSION_ERR;\n\t\t} else if (idata->flags & PAMNS_DEBUG)\n\t\t\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\t\t\"member context returned by policy %s\", *i_context);\n\t\tfreecon(scon);\n\t\treturn PAM_SUCCESS;\n\t}\n\n\t/*\n\t * If polyinstantiating based on security level, get current\n\t * process security context, get security class for directories,\n\t * and change the directories MLS Level to match process.\n\t */\n\n\tif (polyptr->method == LEVEL) {\n\t\tcontext_t scontext = NULL;\n\t\tcontext_t fcontext = NULL;\n\t\trc = PAM_SESSION_ERR;\n\n\t\tscontext = context_new(scon);\n\t\tif (! scontext) {\n\t\t\tpam_syslog(idata->pamh, LOG_CRIT, \"out of memory\");\n\t\t\tgoto fail;\n\t\t}\n\t\tfcontext = context_new(*origcon);\n\t\tif (! fcontext) {\n\t\t\tpam_syslog(idata->pamh, LOG_CRIT, \"out of memory\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (context_range_set(fcontext, context_range_get(scontext)) != 0) {\n\t\t\tpam_syslog(idata->pamh, LOG_ERR, \"Unable to set MLS Component of context\");\n\t\t\tgoto fail;\n\t\t}\n\t\t*i_context=strdup(context_str(fcontext));\n\t\tif (! *i_context) {\n\t\t\tpam_syslog(idata->pamh, LOG_CRIT, \"out of memory\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\trc = PAM_SUCCESS;\n fail:\n\t\tcontext_free(scontext);\n\t\tcontext_free(fcontext);\n\t\tfreecon(scon);\n\t\treturn rc;\n\t}\n\t/* Should never get here */\n\treturn PAM_SUCCESS;\n}\n#endif\n\n/*\n * poly_name returns the name of the polyinstantiated instance directory\n * based on the method used for polyinstantiation (user, context or level)\n * In addition, the function also returns the security contexts of the\n * original directory to polyinstantiate and the polyinstantiated instance\n * directory.\n */\n#ifdef WITH_SELINUX\nstatic int poly_name(const struct polydir_s *polyptr, char **i_name,\n\tchar **i_context, char **origcon,\n        struct instance_data *idata)\n#else\nstatic int poly_name(const struct polydir_s *polyptr, char **i_name,\n\tstruct instance_data *idata)\n#endif\n{\n    int rc;\n    char *hash = NULL;\n    enum polymethod pm;\n#ifdef WITH_SELINUX\n    char *rawcon = NULL;\n#endif\n\n    *i_name = NULL;\n#ifdef WITH_SELINUX\n    *i_context = NULL;\n    *origcon = NULL;\n    if ((idata->flags & PAMNS_SELINUX_ENABLED) &&\n\t(rc=form_context(polyptr, i_context, origcon, idata)) != PAM_SUCCESS) {\n\t    return rc;\n    }\n#endif\n\n    rc = PAM_SESSION_ERR;\n    /*\n     * Set the name of the polyinstantiated instance dir based on the\n     * polyinstantiation method.\n     */\n\n    pm = polyptr->method;\n    if (pm == LEVEL || pm == CONTEXT)\n#ifdef WITH_SELINUX\n        if (!(idata->flags & PAMNS_CTXT_BASED_INST)) {\n#else\n    {\n\tpam_syslog(idata->pamh, LOG_NOTICE,\n\t\t\"Context and level methods not available, using user method\");\n#endif\n\tif (polyptr->flags & POLYDIR_SHARED) {\n\t\trc = PAM_IGNORE;\n\t\tgoto fail;\n\t}\n        pm = USER;\n    }\n\n    switch (pm) {\n        case USER:\n\t    if (asprintf(i_name, \"%s\", idata->user) < 0) {\n\t\t*i_name = NULL;\n\t\tgoto fail;\n\t    }\n\t    break;\n\n#ifdef WITH_SELINUX\n\tcase LEVEL:\n        case CONTEXT:\n\t    if (selinux_trans_to_raw_context(*i_context, &rawcon) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR, \"Error translating directory context\");\n\t\tgoto fail;\n\t    }\n\t    if (polyptr->flags & POLYDIR_SHARED) {\n\t\tif (asprintf(i_name, \"%s\", rawcon) < 0) {\n\t\t\t*i_name = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t    } else {\n\t\tif (asprintf(i_name, \"%s_%s\", rawcon, idata->user) < 0) {\n\t\t\t*i_name = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t    }\n\t    break;\n\n#endif /* WITH_SELINUX */\n\n\tcase TMPDIR:\n\tcase TMPFS:\n\t    if ((*i_name=strdup(\"\")) == NULL)\n\t\tgoto fail;\n\t    return PAM_SUCCESS;\n\n\tdefault:\n\t    if (idata->flags & PAMNS_DEBUG)\n\t        pam_syslog(idata->pamh, LOG_ERR, \"Unknown method\");\n\t    goto fail;\n    }\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"poly_name %s\", *i_name);\n\n    if ((idata->flags & PAMNS_GEN_HASH) || strlen(*i_name) > NAMESPACE_MAX_DIR_LEN) {\n        hash = md5hash(*i_name, idata);\n        if (hash == NULL) {\n\t    goto fail;\n        }\n        if (idata->flags & PAMNS_GEN_HASH) {\n\t    free(*i_name);\n\t    *i_name = hash;\n\t    hash = NULL;\n        } else {\n\t    char *newname;\n\t    if (asprintf(&newname, \"%.*s_%s\", NAMESPACE_MAX_DIR_LEN-1-(int)strlen(hash),\n\t\t*i_name, hash) < 0) {\n\t\tgoto fail;\n\t    }\n\t    free(*i_name);\n\t    *i_name = newname;\n        }\n    }\n    rc = PAM_SUCCESS;\n\nfail:\n    free(hash);\n#ifdef WITH_SELINUX\n    freecon(rawcon);\n#endif\n    if (rc != PAM_SUCCESS) {\n#ifdef WITH_SELINUX\n\tfreecon(*i_context);\n\t*i_context = NULL;\n\tfreecon(*origcon);\n\t*origcon = NULL;\n#endif\n\tfree(*i_name);\n\t*i_name = NULL;\n    }\n    return rc;\n}\n\nstatic int protect_mount(int dfd, const char *path, struct instance_data *idata)\n{\n\tstruct protect_dir_s *dir = idata->protect_dirs;\n\tchar tmpbuf[64];\n\n\twhile (dir != NULL) {\n\t\tif (strcmp(path, dir->dir) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tdir = dir->next;\n\t}\n\n\tdir = calloc(1, sizeof(*dir));\n\n\tif (dir == NULL) {\n\t\treturn -1;\n\t}\n\n\tdir->dir = strdup(path);\n\n\tif (dir->dir == NULL) {\n\t\tfree(dir);\n\t\treturn -1;\n\t}\n\n\tsnprintf(tmpbuf, sizeof(tmpbuf), \"/proc/self/fd/%d\", dfd);\n\n\tif (idata->flags & PAMNS_DEBUG) {\n\t\tpam_syslog(idata->pamh, LOG_INFO,\n\t\t\t\"Protect mount of %s over itself\", path);\n\t}\n\n\tif (mount(tmpbuf, tmpbuf, NULL, MS_BIND, NULL) != 0) {\n\t\tint save_errno = errno;\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Protect mount of %s failed: %m\", tmpbuf);\n\t\tfree(dir->dir);\n\t\tfree(dir);\n\t\terrno = save_errno;\n\t\treturn -1;\n\t}\n\n\tdir->next = idata->protect_dirs;\n\tidata->protect_dirs = dir;\n\n\treturn 0;\n}\n\nstatic int protect_dir(const char *path, mode_t mode, int do_mkdir,\n\tstruct instance_data *idata)\n{\n\tchar *p = strdup(path);\n\tchar *d;\n\tchar *dir = p;\n\tint dfd = AT_FDCWD;\n\tint dfd_next;\n\tint save_errno;\n\tint flags = O_RDONLY | O_DIRECTORY;\n\tint rv = -1;\n\tstruct stat st;\n\n\tif (p == NULL) {\n\t\tgoto error;\n\t}\n\n\tif (*dir == '/') {\n\t\tdfd = open(\"/\", flags);\n\t\tif (dfd == -1) {\n\t\t\tgoto error;\n\t\t}\n\t\tdir++;\t/* assume / is safe */\n\t}\n\n\twhile ((d=strchr(dir, '/')) != NULL) {\n\t\t*d = '\\0';\n\t\tdfd_next = openat(dfd, dir, flags);\n\t\tif (dfd_next == -1) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (dfd != AT_FDCWD)\n\t\t\tclose(dfd);\n\t\tdfd = dfd_next;\n\n\t\tif (fstat(dfd, &st) != 0) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (flags & O_NOFOLLOW) {\n\t\t\t/* we are inside user-owned dir - protect */\n\t\t\tif (protect_mount(dfd, p, idata) == -1)\n\t\t\t\tgoto error;\n\t\t} else if (st.st_uid != 0 || st.st_gid != 0 ||\n\t\t\t(st.st_mode & S_IWOTH)) {\n\t\t\t/* do not follow symlinks on subdirectories */\n\t\t\tflags |= O_NOFOLLOW;\n\t\t}\n\n\t\t*d = '/';\n\t\tdir = d + 1;\n\t}\n\n\trv = openat(dfd, dir, flags);\n\n\tif (rv == -1) {\n\t\tif (!do_mkdir || mkdirat(dfd, dir, mode) != 0) {\n\t\t\tgoto error;\n\t\t}\n\t\trv = openat(dfd, dir, flags);\n\t}\n\n\tif (flags & O_NOFOLLOW) {\n\t\t/* we are inside user-owned dir - protect */\n\t\tif (protect_mount(rv, p, idata) == -1) {\n\t\t\tsave_errno = errno;\n\t\t\tclose(rv);\n\t\t\trv = -1;\n\t\t\terrno = save_errno;\n\t\t}\n\t}\n\nerror:\n\tsave_errno = errno;\n\tfree(p);\n\tif (dfd != AT_FDCWD && dfd >= 0)\n\t\tclose(dfd);\n\terrno = save_errno;\n\n\treturn rv;\n}\n\nstatic int check_inst_parent(char *ipath, struct instance_data *idata)\n{\n\tstruct stat instpbuf;\n\tchar *inst_parent, *trailing_slash;\n\tint dfd;\n\t/*\n\t * stat the instance parent path to make sure it exists\n\t * and is a directory. Check that its mode is 000 (unless the\n\t * admin explicitly instructs to ignore the instance parent\n\t * mode by the \"ignore_instance_parent_mode\" argument).\n\t */\n\tinst_parent = strdup(ipath);\n\tif (!inst_parent) {\n\t\tpam_syslog(idata->pamh, LOG_CRIT, \"Error allocating pathname string\");\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\ttrailing_slash = strrchr(inst_parent, '/');\n\tif (trailing_slash)\n\t\t*trailing_slash = '\\0';\n\n\tdfd = protect_dir(inst_parent, 0, 1, idata);\n\n\tif (dfd == -1 || fstat(dfd, &instpbuf) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error creating or accessing instance parent %s, %m\", inst_parent);\n\t\tif (dfd != -1)\n\t\t\tclose(dfd);\n\t\tfree(inst_parent);\n\t\treturn PAM_SESSION_ERR;\n\t}\n\n\tif ((idata->flags & PAMNS_IGN_INST_PARENT_MODE) == 0) {\n\t\tif ((instpbuf.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO)) || instpbuf.st_uid != 0) {\n\t\t\tpam_syslog(idata->pamh, LOG_ERR, \"Mode of inst parent %s not 000 or owner not root\",\n\t\t\t\t\tinst_parent);\n\t\t\tclose(dfd);\n\t\t\tfree(inst_parent);\n\t\t\treturn PAM_SESSION_ERR;\n\t\t}\n\t}\n\tclose(dfd);\n\tfree(inst_parent);\n\treturn PAM_SUCCESS;\n}\n\n/*\n* Check to see if there is a namespace initialization script in\n* the /etc/security directory. If such a script exists\n* execute it and pass directory to polyinstantiate and instance\n* directory as arguments.\n*/\nstatic int inst_init(const struct polydir_s *polyptr, const char *ipath,\n\t   struct instance_data *idata, int newdir)\n{\n\tpid_t rc, pid;\n\tint status;\n\tconst char *init_script = NAMESPACE_INIT_SCRIPT;\n\n#ifdef VENDOR_NAMESPACE_INIT_SCRIPT\n\t/* Check whether NAMESPACE_INIT_SCRIPT file is available.\n\t * If it does not exist, fall back to VENDOR_NAMESPACE_INIT_SCRIPT file. */\n\tstruct stat buffer;\n\tif (stat(init_script, &buffer) != 0 && errno == ENOENT) {\n\t\tinit_script = VENDOR_NAMESPACE_INIT_SCRIPT;\n\t}\n#endif\n\n\tif ((polyptr->flags & POLYDIR_ISCRIPT) && polyptr->init_script)\n\t\tinit_script = polyptr->init_script;\n\n\tif (access(init_script, F_OK) == 0) {\n\t\tif (access(init_script, X_OK) < 0) {\n\t\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\t\"Namespace init script not executable\");\n\t\t\treturn PAM_SESSION_ERR;\n\t\t} else {\n\t\t\tstruct sigaction newsa, oldsa;\n\n\t\t\tmemset(&newsa, '\\0', sizeof(newsa));\n\t\t\tnewsa.sa_handler = SIG_DFL;\n\t\t\tif (sigaction(SIGCHLD, &newsa, &oldsa) == -1) {\n\t\t\t\tpam_syslog(idata->pamh, LOG_ERR, \"failed to reset SIGCHLD handler\");\n\t\t\t\treturn PAM_SESSION_ERR;\n\t\t\t}\n\n\t\t\tpid = fork();\n\t\t\tif (pid == 0) {\n\t\t\t\tstatic char *envp[] = { NULL };\n#ifdef WITH_SELINUX\n\t\t\t\tif (idata->flags & PAMNS_SELINUX_ENABLED) {\n\t\t\t\t\tif (setexeccon(NULL) < 0)\n\t\t\t\t\t\t_exit(1);\n\t\t\t\t}\n#endif\n\t\t\t\t/* Pass maximum privs when we exec() */\n\t\t\t\tif (setuid(geteuid()) < 0) {\n\t\t\t\t\t/* ignore failures, they don't matter */\n\t\t\t\t}\n\n\t\t\t\tclose_fds_pre_exec(idata);\n\n\t\t\t\tif (execle(init_script, init_script,\n\t\t\t\t\tpolyptr->dir, ipath, newdir?\"1\":\"0\", idata->user, NULL, envp) < 0)\n\t\t\t\t\t_exit(1);\n\t\t\t} else if (pid > 0) {\n\t\t\t\twhile (((rc = waitpid(pid, &status, 0)) == (pid_t)-1) &&\n\t\t\t\t\t\t(errno == EINTR));\n\t\t\t\tif (rc == (pid_t)-1) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_ERR, \"waitpid failed- %m\");\n\t\t\t\t\trc = PAM_SESSION_ERR;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (!WIFEXITED(status) || WIFSIGNALED(status) > 0) {\n\t\t\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\t\t\"Error initializing instance\");\n\t\t\t\t\trc = PAM_SESSION_ERR;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else if (pid < 0) {\n\t\t\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\t\t\"Cannot fork to run namespace init script, %m\");\n\t\t\t\trc = PAM_SESSION_ERR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trc = PAM_SUCCESS;\nout:\n\t\t\t(void) sigaction(SIGCHLD, &oldsa, NULL);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn PAM_SUCCESS;\n}\n\nstatic int create_polydir(struct polydir_s *polyptr,\n\tstruct instance_data *idata)\n{\n    mode_t mode;\n    int rc;\n#ifdef WITH_SELINUX\n    char *dircon_raw, *oldcon_raw = NULL;\n    struct selabel_handle *label_handle;\n#endif\n    const char *dir = polyptr->dir;\n    uid_t uid;\n    gid_t gid;\n\n    if (polyptr->mode != (mode_t)ULONG_MAX)\n            mode = polyptr->mode;\n    else\n            mode = 0777;\n\n#ifdef WITH_SELINUX\n    if (idata->flags & PAMNS_SELINUX_ENABLED) {\n\tgetfscreatecon_raw(&oldcon_raw);\n\n\tlabel_handle = selabel_open(SELABEL_CTX_FILE, NULL, 0);\n\tif (!label_handle) {\n\t    pam_syslog(idata->pamh, LOG_NOTICE,\n                       \"Unable to initialize SELinux labeling handle: %m\");\n\t} else {\n\t    rc = selabel_lookup_raw(label_handle, &dircon_raw, dir, S_IFDIR);\n\t    if (rc) {\n\t\tpam_syslog(idata->pamh, LOG_NOTICE,\n                       \"Unable to get default context for directory %s, check your policy: %m\", dir);\n\t    } else {\n\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t    pam_syslog(idata->pamh, LOG_DEBUG,\n                               \"Polydir %s context: %s\", dir, dircon_raw);\n\t\tif (setfscreatecon_raw(dircon_raw) != 0)\n\t\t    pam_syslog(idata->pamh, LOG_NOTICE,\n                               \"Error setting context for directory %s: %m\", dir);\n\t\tfreecon(dircon_raw);\n\t    }\n\t    selabel_close(label_handle);\n\t}\n    }\n#endif\n\n    rc = protect_dir(dir, mode, 1, idata);\n    if (rc == -1) {\n            pam_syslog(idata->pamh, LOG_ERR,\n                       \"Error creating directory %s: %m\", dir);\n            return PAM_SESSION_ERR;\n    }\n\n#ifdef WITH_SELINUX\n    if (idata->flags & PAMNS_SELINUX_ENABLED) {\n        if (setfscreatecon_raw(oldcon_raw) != 0)\n\t\tpam_syslog(idata->pamh, LOG_NOTICE,\n                       \"Error resetting fs create context: %m\");\n        freecon(oldcon_raw);\n    }\n#endif\n\n    if (idata->flags & PAMNS_DEBUG)\n            pam_syslog(idata->pamh, LOG_DEBUG, \"Created polydir %s\", dir);\n\n    if (polyptr->mode != (mode_t)ULONG_MAX) {\n\t/* explicit mode requested */\n\tif (fchmod(rc, mode) != 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t   \"Error changing mode of directory %s: %m\", dir);\n                close(rc);\n                umount(dir); /* undo the eventual protection bind mount */\n\t\trmdir(dir);\n\t\treturn PAM_SESSION_ERR;\n\t}\n    }\n\n    if (polyptr->owner != (uid_t)ULONG_MAX)\n\tuid = polyptr->owner;\n    else\n\tuid = idata->uid;\n\n    if (polyptr->group != (gid_t)ULONG_MAX)\n\tgid = polyptr->group;\n    else\n\tgid = idata->gid;\n\n    if (fchown(rc, uid, gid) != 0) {\n        pam_syslog(idata->pamh, LOG_ERR,\n                   \"Unable to change owner on directory %s: %m\", dir);\n        close(rc);\n        umount(dir); /* undo the eventual protection bind mount */\n\trmdir(dir);\n\treturn PAM_SESSION_ERR;\n    }\n\n    close(rc);\n\n    if (idata->flags & PAMNS_DEBUG)\n\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t           \"Polydir owner %u group %u\", uid, gid);\n\n    return PAM_SUCCESS;\n}\n\n/*\n * Create polyinstantiated instance directory (ipath).\n */\n#ifdef WITH_SELINUX\nstatic int create_instance(struct polydir_s *polyptr, char *ipath, struct stat *statbuf,\n        const char *icontext, const char *ocontext,\n\tstruct instance_data *idata)\n#else\nstatic int create_instance(struct polydir_s *polyptr, char *ipath, struct stat *statbuf,\n\tstruct instance_data *idata)\n#endif\n{\n    struct stat newstatbuf;\n    int fd;\n\n    /*\n     * Check to make sure instance parent is valid.\n     */\n    if (check_inst_parent(ipath, idata))\n\treturn PAM_SESSION_ERR;\n\n    /*\n     * Create instance directory and set its security context to the context\n     * returned by the security policy. Set its mode and ownership\n     * attributes to match that of the original directory that is being\n     * polyinstantiated.\n     */\n\n    if (polyptr->method == TMPDIR) {\n\tif (mkdtemp(polyptr->instance_prefix) == NULL) {\n            pam_syslog(idata->pamh, LOG_ERR, \"Error creating temporary instance %s, %m\",\n\t\t\tpolyptr->instance_prefix);\n\t    polyptr->method = NONE; /* do not clean up! */\n\t    return PAM_SESSION_ERR;\n\t}\n\t/* copy the actual directory name to ipath */\n\tstrcpy(ipath, polyptr->instance_prefix);\n    } else if (mkdir(ipath, S_IRUSR) < 0) {\n        if (errno == EEXIST)\n            return PAM_IGNORE;\n        else {\n            pam_syslog(idata->pamh, LOG_ERR, \"Error creating %s, %m\",\n\t\t\tipath);\n            return PAM_SESSION_ERR;\n        }\n    }\n\n    /* Open a descriptor to it to prevent races */\n    fd = open(ipath, O_DIRECTORY | O_RDONLY);\n    if (fd < 0) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Error opening %s, %m\", ipath);\n\trmdir(ipath);\n\treturn PAM_SESSION_ERR;\n    }\n#ifdef WITH_SELINUX\n    /* If SE Linux is disabled, no need to label it */\n    if (idata->flags & PAMNS_SELINUX_ENABLED) {\n        /* If method is USER, icontext is NULL */\n        if (icontext) {\n            if (fsetfilecon(fd, icontext) < 0) {\n                pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error setting context of %s to %s\", ipath, icontext);\n                close(fd);\n\t\trmdir(ipath);\n                return PAM_SESSION_ERR;\n            }\n        } else {\n            if (fsetfilecon(fd, ocontext) < 0) {\n                pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error setting context of %s to %s\", ipath, ocontext);\n\t\tclose(fd);\n\t\trmdir(ipath);\n                return PAM_SESSION_ERR;\n            }\n        }\n    }\n#endif\n    if (fstat(fd, &newstatbuf) < 0) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error stating %s, %m\",\n\t\tipath);\n\tclose(fd);\n\trmdir(ipath);\n        return PAM_SESSION_ERR;\n    }\n    if (newstatbuf.st_uid != statbuf->st_uid ||\n\t\t\t newstatbuf.st_gid != statbuf->st_gid) {\n        if (fchown(fd, statbuf->st_uid, statbuf->st_gid) < 0) {\n            pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error changing owner for %s, %m\",\n\t\t\tipath);\n\t    close(fd);\n\t    rmdir(ipath);\n            return PAM_SESSION_ERR;\n        }\n    }\n    if (fchmod(fd, statbuf->st_mode & 07777) < 0) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error changing mode for %s, %m\",\n\t\t\tipath);\n\tclose(fd);\n\trmdir(ipath);\n        return PAM_SESSION_ERR;\n    }\n    close(fd);\n    return PAM_SUCCESS;\n}\n\n\n/*\n * This function performs the namespace setup for a particular directory\n * that is being polyinstantiated. It calls poly_name to create name of instance\n * directory, calls create_instance to mkdir it with appropriate\n * security attributes, and performs bind mount to setup the process\n * namespace.\n */\nstatic int ns_setup(struct polydir_s *polyptr,\n\tstruct instance_data *idata)\n{\n    int retval;\n    int newdir = 1;\n    char *inst_dir = NULL;\n    char *instname = NULL;\n    struct stat statbuf;\n#ifdef WITH_SELINUX\n    char *instcontext = NULL, *origcontext = NULL;\n#endif\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG,\n               \"Set namespace for directory %s\", polyptr->dir);\n\n    retval = protect_dir(polyptr->dir, 0, 0, idata);\n\n    if (retval < 0 && errno != ENOENT) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Polydir %s access error: %m\",\n\t\tpolyptr->dir);\n\treturn PAM_SESSION_ERR;\n    }\n\n    if (retval < 0) {\n\tif ((polyptr->flags & POLYDIR_CREATE) &&\n\t\tcreate_polydir(polyptr, idata) != PAM_SUCCESS)\n\t\treturn PAM_SESSION_ERR;\n    } else {\n\tclose(retval);\n    }\n\n    if (polyptr->method == TMPFS) {\n\tif (mount(\"tmpfs\", polyptr->dir, \"tmpfs\", polyptr->mount_flags, polyptr->mount_opts) < 0) {\n\t    pam_syslog(idata->pamh, LOG_ERR, \"Error mounting tmpfs on %s, %m\",\n\t\tpolyptr->dir);\n            return PAM_SESSION_ERR;\n\t}\n\n\tif (polyptr->flags & POLYDIR_NOINIT)\n\t    return PAM_SUCCESS;\n\n\treturn inst_init(polyptr, \"tmpfs\", idata, 1);\n    }\n\n    if (stat(polyptr->dir, &statbuf) < 0) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Error stating %s: %m\",\n\t\tpolyptr->dir);\n        return PAM_SESSION_ERR;\n    }\n\n    /*\n     * Obtain the name of instance pathname based on the\n     * polyinstantiation method and instance context returned by\n     * security policy.\n     */\n#ifdef WITH_SELINUX\n    retval = poly_name(polyptr, &instname, &instcontext,\n\t\t\t&origcontext, idata);\n#else\n    retval = poly_name(polyptr, &instname, idata);\n#endif\n\n    if (retval != PAM_SUCCESS) {\n\tif (retval != PAM_IGNORE)\n\t\tpam_syslog(idata->pamh, LOG_ERR, \"Error getting instance name\");\n        goto cleanup;\n    } else {\n#ifdef WITH_SELINUX\n        if ((idata->flags & PAMNS_DEBUG) &&\n            (idata->flags & PAMNS_SELINUX_ENABLED))\n            pam_syslog(idata->pamh, LOG_DEBUG, \"Inst ctxt %s Orig ctxt %s\",\n\t\t instcontext, origcontext);\n#endif\n    }\n\n    if (asprintf(&inst_dir, \"%s%s\", polyptr->instance_prefix, instname) < 0)\n\tgoto error_out;\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"instance_dir %s\",\n\t\tinst_dir);\n\n    /*\n     * Create instance directory with appropriate security\n     * contexts, owner, group and mode bits.\n     */\n#ifdef WITH_SELINUX\n    retval = create_instance(polyptr, inst_dir, &statbuf, instcontext,\n\t\t\t origcontext, idata);\n#else\n    retval = create_instance(polyptr, inst_dir, &statbuf, idata);\n#endif\n\n    if (retval == PAM_IGNORE) {\n\tnewdir = 0;\n\tretval = PAM_SUCCESS;\n    }\n\n    if (retval != PAM_SUCCESS) {\n        goto error_out;\n    }\n\n    /*\n     * Bind mount instance directory on top of the polyinstantiated\n     * directory to provide an instance of polyinstantiated directory\n     * based on polyinstantiated method.\n     */\n    if (mount(inst_dir, polyptr->dir, NULL, MS_BIND, NULL) < 0) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error mounting %s on %s, %m\",\n                   inst_dir, polyptr->dir);\n        goto error_out;\n    }\n\n    if (!(polyptr->flags & POLYDIR_NOINIT))\n\tretval = inst_init(polyptr, inst_dir, idata, newdir);\n\n    goto cleanup;\n\n    /*\n     * various error exit points. Free allocated memory and set return\n     * value to indicate a pam session error.\n     */\nerror_out:\n    retval = PAM_SESSION_ERR;\n\ncleanup:\n    free(inst_dir);\n    free(instname);\n#ifdef WITH_SELINUX\n    freecon(instcontext);\n    freecon(origcontext);\n#endif\n    return retval;\n}\n\n\n/*\n * This function checks to see if the current working directory is\n * inside the directory passed in as the first argument.\n */\nstatic int cwd_in(char *dir, struct instance_data *idata)\n{\n    int retval = 0;\n    char cwd[PATH_MAX];\n\n    if (getcwd(cwd, PATH_MAX) == NULL) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Can't get current dir, %m\");\n        return -1;\n    }\n\n    if (strncmp(cwd, dir, strlen(dir)) == 0) {\n        if (idata->flags & PAMNS_DEBUG)\n            pam_syslog(idata->pamh, LOG_DEBUG, \"cwd is inside %s\", dir);\n        retval = 1;\n    } else {\n        if (idata->flags & PAMNS_DEBUG)\n            pam_syslog(idata->pamh, LOG_DEBUG, \"cwd is outside %s\", dir);\n    }\n\n    return retval;\n}\n\nstatic int cleanup_tmpdirs(struct instance_data *idata)\n{\n    struct polydir_s *pptr;\n    pid_t rc, pid;\n    struct sigaction newsa, oldsa;\n    int status;\n\n    memset(&newsa, '\\0', sizeof(newsa));\n    newsa.sa_handler = SIG_DFL;\n    if (sigaction(SIGCHLD, &newsa, &oldsa) == -1) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Cannot set signal value\");\n\treturn PAM_SESSION_ERR;\n    }\n\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n\tif (pptr->method == TMPDIR && access(pptr->instance_prefix, F_OK) == 0) {\n\t    pid = fork();\n\t    if (pid == 0) {\n\t\tstatic char *envp[] = { NULL };\n#ifdef WITH_SELINUX\n\t\tif (idata->flags & PAMNS_SELINUX_ENABLED) {\n\t\t    if (setexeccon(NULL) < 0)\n\t\t\t_exit(1);\n\t\t}\n#endif\n\t\tclose_fds_pre_exec(idata);\n\t\tif (execle(\"/bin/rm\", \"/bin/rm\", \"-rf\", pptr->instance_prefix, NULL, envp) < 0)\n\t\t\t_exit(1);\n\t    } else if (pid > 0) {\n\t\twhile (((rc = waitpid(pid, &status, 0)) == (pid_t)-1) &&\n\t\t    (errno == EINTR));\n\t\tif (rc == (pid_t)-1) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR, \"waitpid failed: %m\");\n\t\t    rc = PAM_SESSION_ERR;\n\t\t    goto out;\n\t\t}\n\t\tif (!WIFEXITED(status) || WIFSIGNALED(status) > 0) {\n\t\t    pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Error removing %s\", pptr->instance_prefix);\n\t\t}\n\t    } else if (pid < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Cannot fork to cleanup temporary directory, %m\");\n\t\trc = PAM_SESSION_ERR;\n\t\tgoto out;\n\t    }\n        }\n    }\n\n    rc = PAM_SUCCESS;\nout:\n    sigaction(SIGCHLD, &oldsa, NULL);\n    return rc;\n}\n\n/*\n * This function checks to see if polyinstantiation is needed for any\n * of the directories listed in the configuration file. If needed,\n * cycles through all polyinstantiated directory entries and calls\n * ns_setup to setup polyinstantiation for each one of them.\n */\nstatic int setup_namespace(struct instance_data *idata, enum unmnt_op unmnt)\n{\n    int retval = 0, need_poly = 0, changing_dir = 0;\n    char *cptr, *fptr, poly_parent[PATH_MAX];\n    struct polydir_s *pptr;\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"Set up namespace for pid %d\",\n\t\tgetpid());\n\n    /*\n     * Cycle through all polyinstantiated directory entries to see if\n     * polyinstantiation is needed at all.\n     */\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n        if (ns_override(pptr, idata, idata->uid)) {\n\t    if (unmnt == NO_UNMNT || ns_override(pptr, idata, idata->ruid)) {\n\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t    pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Overriding poly for user %d for dir %s\",\n\t\t\tidata->uid, pptr->dir);\n\t    } else {\n\t\tif (idata->flags & PAMNS_DEBUG)\n\t\t    pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Need unmount ns for user %d for dir %s\",\n\t\t\tidata->ruid, pptr->dir);\n\t\tneed_poly = 1;\n\t\tbreak;\n\t    }\n            continue;\n        } else {\n            if (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Need poly ns for user %d for dir %s\",\n\t\t\tidata->uid, pptr->dir);\n            need_poly = 1;\n            break;\n        }\n    }\n\n    /*\n     * If polyinstantiation is needed, call the unshare system call to\n     * disassociate from the parent namespace.\n     */\n    if (need_poly) {\n        if (unshare(CLONE_NEWNS) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\"Unable to unshare from parent namespace, %m\");\n            return PAM_SESSION_ERR;\n        }\n\tif (idata->flags & PAMNS_MOUNT_PRIVATE) {\n\t    /*\n\t     * Remount / as SLAVE so that nothing mounted in the namespace\n\t     * shows up in the parent\n\t     */\n\t    if (mount(\"/\", \"/\", NULL, MS_SLAVE | MS_REC , NULL) < 0) {\n\t\tpam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\"Failed to mark / as a slave mount point, %m\");\n\t\treturn PAM_SESSION_ERR;\n\t    }\n\t    if (idata->flags & PAMNS_DEBUG)\n\t\tpam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"The / mount point was marked as slave\");\n\t}\n    } else {\n\tdel_polydir_list(idata->polydirs_ptr);\n        return PAM_SUCCESS;\n    }\n\n    /*\n     * Again cycle through all polyinstantiated directories, this time,\n     * call ns_setup to setup polyinstantiation for a particular entry.\n     */\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n\tenum unmnt_op dir_unmnt = unmnt;\n\n\tif (ns_override(pptr, idata, idata->ruid)) {\n\t    dir_unmnt = NO_UNMNT;\n\t}\n\tif (ns_override(pptr, idata, idata->uid)) {\n\t    if (dir_unmnt == NO_UNMNT) {\n\t\tcontinue;\n\t    } else {\n\t\tdir_unmnt = UNMNT_ONLY;\n\t    }\n\t}\n\n\tif (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Setting poly ns for user %d for dir %s\",\n                      idata->uid, pptr->dir);\n\n\tif ((dir_unmnt == UNMNT_REMNT) || (dir_unmnt == UNMNT_ONLY)) {\n                /*\n                 * Check to see if process current directory is in the\n                 * bind mounted instance_parent directory that we are trying to\n                 * umount\n                 */\n                if ((changing_dir = cwd_in(pptr->rdir, idata)) < 0) {\n                    retval = PAM_SESSION_ERR;\n                    goto out;\n                } else if (changing_dir) {\n                    if (idata->flags & PAMNS_DEBUG)\n                        pam_syslog(idata->pamh, LOG_DEBUG, \"changing cwd\");\n\n                    /*\n                     * Change current working directory to the parent of\n                     * the mount point, that is parent of the orig\n                     * directory where original contents of the polydir\n                     * are available from\n                     */\n                    strcpy(poly_parent, pptr->rdir);\n\t\t    fptr = strchr(poly_parent, '/');\n\t\t    cptr = strrchr(poly_parent, '/');\n\t\t    if (fptr && cptr && (fptr == cptr))\n\t\t\tstrcpy(poly_parent, \"/\");\n\t\t    else if (cptr)\n\t\t\t*cptr = '\\0';\n                    if (chdir(poly_parent) < 0) {\n                        pam_syslog(idata->pamh, LOG_ERR,\n\t\t\t\t\"Can't chdir to %s, %m\", poly_parent);\n                    }\n                }\n\n                if (umount(pptr->rdir) < 0) {\n\t\t    int saved_errno = errno;\n\t\t    pam_syslog(idata->pamh, LOG_ERR, \"Unmount of %s failed, %m\",\n\t\t\tpptr->rdir);\n\t\t    if (saved_errno != EINVAL) {\n\t\t\tretval = PAM_SESSION_ERR;\n\t\t\tgoto out;\n                    }\n                } else if (idata->flags & PAMNS_DEBUG)\n                    pam_syslog(idata->pamh, LOG_DEBUG, \"Umount succeeded %s\",\n\t\t\t\tpptr->rdir);\n\t}\n\n\tif (dir_unmnt != UNMNT_ONLY) {\n                retval = ns_setup(pptr, idata);\n                if (retval == PAM_IGNORE)\n                     retval = PAM_SUCCESS;\n                if (retval != PAM_SUCCESS)\n                     break;\n        }\n    }\nout:\n    if (retval != PAM_SUCCESS) {\n\tcleanup_tmpdirs(idata);\n\tunprotect_dirs(idata->protect_dirs);\n    } else if (pam_set_data(idata->pamh, NAMESPACE_PROTECT_DATA, idata->protect_dirs,\n\t\tcleanup_protect_data) != PAM_SUCCESS) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Unable to set namespace protect data\");\n\tcleanup_tmpdirs(idata);\n\tunprotect_dirs(idata->protect_dirs);\n\treturn PAM_SYSTEM_ERR;\n    } else if (pam_set_data(idata->pamh, NAMESPACE_POLYDIR_DATA, idata->polydirs_ptr,\n\t\tcleanup_polydir_data) != PAM_SUCCESS) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"Unable to set namespace polydir data\");\n\tcleanup_tmpdirs(idata);\n\tpam_set_data(idata->pamh, NAMESPACE_PROTECT_DATA, NULL, NULL);\n\tidata->protect_dirs = NULL;\n\treturn PAM_SYSTEM_ERR;\n    }\n    return retval;\n}\n\n\n/*\n * Orig namespace. This function is called from when closing a pam\n * session. If authorized, it unmounts instance directory.\n */\nstatic int orig_namespace(struct instance_data *idata)\n{\n    struct polydir_s *pptr;\n\n    if (idata->flags & PAMNS_DEBUG)\n        pam_syslog(idata->pamh, LOG_DEBUG, \"orig namespace for pid %d\",\n\t\tgetpid());\n\n    /*\n     * Cycle through all polyinstantiated directories from the namespace\n     * configuration file to see if polyinstantiation was performed for\n     * this user for each of the entry. If it was, try and unmount\n     * appropriate polyinstantiated instance directories.\n     */\n    for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {\n        if (ns_override(pptr, idata, idata->uid))\n            continue;\n        else {\n            if (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG,\n\t\t\t\"Unmounting instance dir for user %d & dir %s\",\n                       idata->uid, pptr->dir);\n\n            if (umount(pptr->dir) < 0) {\n                pam_syslog(idata->pamh, LOG_ERR, \"Unmount of %s failed, %m\",\n                       pptr->dir);\n                return PAM_SESSION_ERR;\n            } else if (idata->flags & PAMNS_DEBUG)\n                pam_syslog(idata->pamh, LOG_DEBUG, \"Unmount of %s succeeded\",\n\t\t\tpptr->dir);\n\t}\n    }\n\n    cleanup_tmpdirs(idata);\n    return 0;\n}\n\n\n#ifdef WITH_SELINUX\n/*\n * This function checks if the calling program has requested context\n * change by calling setexeccon(). If context change is not requested\n * then it does not make sense to polyinstantiate based on context.\n * The return value from this function is used when selecting the\n * polyinstantiation method. If context change is not requested then\n * the polyinstantiation method is set to USER, even if the configuration\n * file lists the method as \"context\" or \"level\".\n */\nstatic int ctxt_based_inst_needed(void)\n{\n    char *scon = NULL;\n    int rc = 0;\n\n    rc = getexeccon(&scon);\n    if (rc < 0 || scon == NULL)\n        return 0;\n    else {\n        freecon(scon);\n        return 1;\n    }\n}\n#endif\n\nstatic int root_shared(void)\n{\n    FILE *f;\n    char *line = NULL;\n    size_t n = 0;\n    int rv = 0;\n\n    f = fopen(\"/proc/self/mountinfo\", \"r\");\n\n    if (f == NULL)\n        return 0;\n\n    while(getline(&line, &n, f) != -1) {\n        char *l;\n        char *sptr;\n        int i;\n\n        l = line;\n        sptr = NULL;\n        for (i = 0; i < 7; i++) {\n             char *tok;\n\n             tok = strtok_r(l, \" \", &sptr);\n             l = NULL;\n             if (tok == NULL)\n                 /* next mountinfo line */\n                 break;\n\n             if (i == 4 && strcmp(tok, \"/\") != 0)\n                 /* next mountinfo line */\n                 break;\n\n             if (i == 6) {\n                if (pam_str_skip_prefix(tok, \"shared:\") != NULL)\n                 /* there might be more / mounts, the last one counts */\n                    rv = 1;\n                else\n                    rv = 0;\n             }\n        }\n    }\n\n    free(line);\n    fclose(f);\n\n    return rv;\n}\n\nstatic int get_user_data(struct instance_data *idata)\n{\n    int retval;\n    char *user_name;\n    struct passwd *pwd;\n    /*\n     * Lookup user and fill struct items\n     */\n    retval = pam_get_item(idata->pamh, PAM_USER, (void*) &user_name );\n    if ( user_name == NULL || retval != PAM_SUCCESS ) {\n        pam_syslog(idata->pamh, LOG_ERR, \"Error recovering pam user name\");\n        return PAM_SESSION_ERR;\n    }\n\n    pwd = pam_modutil_getpwnam(idata->pamh, user_name);\n    if (!pwd) {\n        pam_syslog(idata->pamh, LOG_ERR, \"user unknown '%s'\", user_name);\n        return PAM_USER_UNKNOWN;\n    }\n\n    /*\n     * Add the user info to the instance data so we can refer to them later.\n     */\n    idata->user[0] = 0;\n    strncat(idata->user, user_name, sizeof(idata->user) - 1);\n    idata->uid = pwd->pw_uid;\n    idata->gid = pwd->pw_gid;\n\n    /* Fill in RUSER too */\n    retval = pam_get_item(idata->pamh, PAM_RUSER, (void*) &user_name );\n    if ( user_name != NULL && retval == PAM_SUCCESS && user_name[0] != '\\0' ) {\n\tstrncat(idata->ruser, user_name, sizeof(idata->ruser) - 1);\n\tpwd = pam_modutil_getpwnam(idata->pamh, user_name);\n    } else {\n\tpwd = pam_modutil_getpwuid(idata->pamh, getuid());\n    }\n    if (!pwd) {\n\tpam_syslog(idata->pamh, LOG_ERR, \"user unknown '%s'\", user_name);\n\treturn PAM_USER_UNKNOWN;\n    }\n    user_name = pwd->pw_name;\n\n    idata->ruser[0] = 0;\n    strncat(idata->ruser, user_name, sizeof(idata->ruser) - 1);\n    idata->ruid = pwd->pw_uid;\n\n    return PAM_SUCCESS;\n}\n\n/*\n * Entry point from pam_open_session call.\n */\nint pam_sm_open_session(pam_handle_t *pamh, int flags UNUSED,\n                                   int argc, const char **argv)\n{\n    int i, retval;\n    struct instance_data idata;\n    enum unmnt_op unmnt = NO_UNMNT;\n\n    /* init instance data */\n    idata.flags = 0;\n    idata.polydirs_ptr = NULL;\n    idata.protect_dirs = NULL;\n    idata.pamh = pamh;\n#ifdef WITH_SELINUX\n    if (is_selinux_enabled())\n        idata.flags |= PAMNS_SELINUX_ENABLED;\n    if (ctxt_based_inst_needed())\n        idata.flags |= PAMNS_CTXT_BASED_INST;\n#endif\n\n    /* Parse arguments. */\n    for (i = 0; i < argc; i++) {\n        if (strcmp(argv[i], \"debug\") == 0)\n            idata.flags |= PAMNS_DEBUG;\n        if (strcmp(argv[i], \"gen_hash\") == 0)\n            idata.flags |= PAMNS_GEN_HASH;\n        if (strcmp(argv[i], \"ignore_config_error\") == 0)\n            idata.flags |= PAMNS_IGN_CONFIG_ERR;\n        if (strcmp(argv[i], \"ignore_instance_parent_mode\") == 0)\n            idata.flags |= PAMNS_IGN_INST_PARENT_MODE;\n        if (strcmp(argv[i], \"use_current_context\") == 0) {\n            idata.flags |= PAMNS_USE_CURRENT_CONTEXT;\n            idata.flags |= PAMNS_CTXT_BASED_INST;\n        }\n        if (strcmp(argv[i], \"use_default_context\") == 0) {\n            idata.flags |= PAMNS_USE_DEFAULT_CONTEXT;\n            idata.flags |= PAMNS_CTXT_BASED_INST;\n        }\n        if (strcmp(argv[i], \"mount_private\") == 0) {\n            idata.flags |= PAMNS_MOUNT_PRIVATE;\n        }\n        if (strcmp(argv[i], \"unmnt_remnt\") == 0)\n            unmnt = UNMNT_REMNT;\n        if (strcmp(argv[i], \"unmnt_only\") == 0)\n            unmnt = UNMNT_ONLY;\n\tif (strcmp(argv[i], \"require_selinux\") == 0) {\n\t\tif (!(idata.flags & PAMNS_SELINUX_ENABLED)) {\n\t\t\tpam_syslog(idata.pamh, LOG_ERR,\n\t\t    \"selinux_required option given and selinux is disabled\");\n\t\t\treturn PAM_SESSION_ERR;\n\t\t}\n\t}\n    }\n    if (idata.flags & PAMNS_DEBUG)\n        pam_syslog(idata.pamh, LOG_DEBUG, \"open_session - start\");\n\n    retval = get_user_data(&idata);\n    if (retval != PAM_SUCCESS)\n\treturn retval;\n\n    if (root_shared()) {\n\tidata.flags |= PAMNS_MOUNT_PRIVATE;\n    }\n\n    /*\n     * Parse namespace configuration file which lists directories to\n     * polyinstantiate, directory where instance directories are to\n     * be created and the method used for polyinstantiation.\n     */\n    retval = parse_config_file(&idata);\n    if (retval != PAM_SUCCESS) {\n\tdel_polydir_list(idata.polydirs_ptr);\n        return PAM_SESSION_ERR;\n    }\n\n    if (idata.polydirs_ptr) {\n        retval = setup_namespace(&idata, unmnt);\n        if (idata.flags & PAMNS_DEBUG) {\n            if (retval)\n                pam_syslog(idata.pamh, LOG_DEBUG,\n\t\t\t\"namespace setup failed for pid %d\", getpid());\n            else\n                pam_syslog(idata.pamh, LOG_DEBUG,\n\t\t\t\"namespace setup ok for pid %d\", getpid());\n        }\n    } else if (idata.flags & PAMNS_DEBUG)\n        pam_syslog(idata.pamh, LOG_DEBUG, \"Nothing to polyinstantiate\");\n\n    if (retval != PAM_SUCCESS)\n\tdel_polydir_list(idata.polydirs_ptr);\n    return retval;\n}\n\n\n/*\n * Entry point from pam_close_session call.\n */\nint pam_sm_close_session(pam_handle_t *pamh, int flags UNUSED,\n                                    int argc, const char **argv)\n{\n    int i, retval;\n    struct instance_data idata;\n    const void *polyptr;\n\n    /* init instance data */\n    idata.flags = 0;\n    idata.polydirs_ptr = NULL;\n    idata.pamh = pamh;\n#ifdef WITH_SELINUX\n    if (is_selinux_enabled())\n        idata.flags |= PAMNS_SELINUX_ENABLED;\n    if (ctxt_based_inst_needed())\n        idata.flags |= PAMNS_CTXT_BASED_INST;\n#endif\n\n    /* Parse arguments. */\n    for (i = 0; i < argc; i++) {\n        if (strcmp(argv[i], \"debug\") == 0)\n            idata.flags |= PAMNS_DEBUG;\n        if (strcmp(argv[i], \"ignore_config_error\") == 0)\n            idata.flags |= PAMNS_IGN_CONFIG_ERR;\n        if (strcmp(argv[i], \"unmount_on_close\") == 0)\n            idata.flags |= PAMNS_UNMOUNT_ON_CLOSE;\n    }\n\n    if (idata.flags & PAMNS_DEBUG)\n        pam_syslog(idata.pamh, LOG_DEBUG, \"close_session - start\");\n\n    /*\n     * Normally the unmount is implicitly done when the last\n     * process in the private namespace exits.\n     * If it is ensured that there are no child processes left in\n     * the private namespace by other means and if there are\n     * multiple sessions opened and closed sequentially by the\n     * same process, the \"unmount_on_close\" option might be\n     * used to unmount the polydirs explicitly.\n     */\n    if (!(idata.flags & PAMNS_UNMOUNT_ON_CLOSE)) {\n\tpam_set_data(idata.pamh, NAMESPACE_POLYDIR_DATA, NULL, NULL);\n\tpam_set_data(idata.pamh, NAMESPACE_PROTECT_DATA, NULL, NULL);\n\n\tif (idata.flags & PAMNS_DEBUG)\n\t    pam_syslog(idata.pamh, LOG_DEBUG, \"close_session - successful\");\n        return PAM_SUCCESS;\n    }\n\n    retval = get_user_data(&idata);\n    if (retval != PAM_SUCCESS)\n\treturn retval;\n\n    retval = pam_get_data(idata.pamh, NAMESPACE_POLYDIR_DATA, &polyptr);\n    if (retval != PAM_SUCCESS || polyptr == NULL)\n\t/* nothing to reset */\n\treturn PAM_SUCCESS;\n\n    DIAG_PUSH_IGNORE_CAST_QUAL;\n    idata.polydirs_ptr = (void *)polyptr;\n    DIAG_POP_IGNORE_CAST_QUAL;\n\n    if (idata.flags & PAMNS_DEBUG)\n        pam_syslog(idata.pamh, LOG_DEBUG, \"Resetting namespace for pid %d\",\n\t\tgetpid());\n\n    retval = orig_namespace(&idata);\n    if (idata.flags & PAMNS_DEBUG) {\n        if (retval)\n            pam_syslog(idata.pamh, LOG_DEBUG,\n\t\t\"resetting namespace failed for pid %d\", getpid());\n        else\n            pam_syslog(idata.pamh, LOG_DEBUG,\n\t\t\"resetting namespace ok for pid %d\", getpid());\n    }\n\n    pam_set_data(idata.pamh, NAMESPACE_POLYDIR_DATA, NULL, NULL);\n    pam_set_data(idata.pamh, NAMESPACE_PROTECT_DATA, NULL, NULL);\n\n    return PAM_SUCCESS;\n}\n"], "filenames": ["modules/pam_namespace/pam_namespace.c"], "buggy_code_start_loc": [1204], "buggy_code_end_loc": [1272], "fixing_code_start_loc": [1204], "fixing_code_end_loc": [1255], "type": "NVD-CWE-noinfo", "message": "linux-pam (aka Linux PAM) before 1.6.0 allows attackers to cause a denial of service (blocked login process) via mkfifo because the openat call (for protect_dir) lacks O_DIRECTORY.", "other": {"cve": {"id": "CVE-2024-22365", "sourceIdentifier": "cve@mitre.org", "published": "2024-02-06T08:15:52.203", "lastModified": "2024-02-14T00:27:40.143", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "linux-pam (aka Linux PAM) before 1.6.0 allows attackers to cause a denial of service (blocked login process) via mkfifo because the openat call (for protect_dir) lacks O_DIRECTORY."}, {"lang": "es", "value": "linux-pam (tambi\u00e9n conocido como Linux PAM) anterior a 1.6.0 permite a los atacantes provocar una denegaci\u00f3n de servicio (proceso de inicio de sesi\u00f3n bloqueado) a trav\u00e9s de mkfifo porque la llamada openat (para protect_dir) carece de O_DIRECTORY."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linux-pam:linux-pam:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.6.0", "matchCriteriaId": "8B735A60-FB87-4597-BFF4-A6ED201E71A1"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2024/01/18/3", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Patch", "Release Notes"]}, {"url": "https://github.com/linux-pam/linux-pam", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://github.com/linux-pam/linux-pam/commit/031bb5a5d0d950253b68138b498dc93be69a64cb", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/linux-pam/linux-pam/releases/tag/v1.6.0", "source": "cve@mitre.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/linux-pam/linux-pam/commit/031bb5a5d0d950253b68138b498dc93be69a64cb"}}