{"buggy_code": ["/*\n * read.c - read the blkid cache from disk, to avoid scanning all devices\n *\n * Copyright (C) 2001, 2003 Theodore Y. Ts'o\n * Copyright (C) 2001 Andreas Dilger\n *\n * %Begin-Header%\n * This file may be redistributed under the terms of the\n * GNU Lesser General Public License.\n * %End-Header%\n */\n\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n\n#include \"blkidP.h\"\n\n#ifdef HAVE_STDLIB_H\n# ifndef _XOPEN_SOURCE\n#  define _XOPEN_SOURCE 600\t/* for inclusion of strtoull */\n# endif\n# include <stdlib.h>\n#endif\n\n#ifdef HAVE_STRTOULL\n#define STRTOULL strtoull /* defined in stdlib.h if you try hard enough */\n#else\n/* FIXME: need to support real strtoull here */\n#define STRTOULL strtoul\n#endif\n\n#ifdef TEST_PROGRAM\n#define blkid_debug_dump_dev(dev)\t(debug_dump_dev(dev))\nstatic void debug_dump_dev(blkid_dev dev);\n#endif\n\n/*\n * File format:\n *\n *\t<device [<NAME=\"value\"> ...]>device_name</device>\n *\n *\tThe following tags are required for each entry:\n *\t<ID=\"id\">\tunique (within this file) ID number of this device\n *\t<TIME=\"sec.usec\"> (time_t and suseconds_t) time this entry was last\n *\t                 read from disk\n *\t<TYPE=\"type\">\t(detected) type of filesystem/data for this partition\n *\n *\tThe following tags may be present, depending on the device contents\n *\t<LABEL=\"label\">\t(user supplied) label (volume name, etc)\n *\t<UUID=\"uuid\">\t(generated) universally unique identifier (serial no)\n */\n\nstatic char *skip_over_blank(char *cp)\n{\n\twhile (*cp && isspace(*cp))\n\t\tcp++;\n\treturn cp;\n}\n\nstatic char *skip_over_word(char *cp)\n{\n\tchar ch;\n\n\twhile ((ch = *cp)) {\n\t\t/* If we see a backslash, skip the next character */\n\t\tif (ch == '\\\\') {\n\t\t\tcp++;\n\t\t\tif (*cp == '\\0')\n\t\t\t\tbreak;\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (isspace(ch) || ch == '<' || ch == '>')\n\t\t\tbreak;\n\t\tcp++;\n\t}\n\treturn cp;\n}\n\nstatic char *strip_line(char *line)\n{\n\tchar\t*p;\n\n\tline = skip_over_blank(line);\n\n\tp = line + strlen(line) - 1;\n\n\twhile (*line) {\n\t\tif (isspace(*p))\n\t\t\t*p-- = '\\0';\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn line;\n}\n\n#if 0\nstatic char *parse_word(char **buf)\n{\n\tchar *word, *next;\n\n\tword = *buf;\n\tif (*word == '\\0')\n\t\treturn NULL;\n\n\tword = skip_over_blank(word);\n\tnext = skip_over_word(word);\n\tif (*next) {\n\t\tchar *end = next - 1;\n\t\tif (*end == '\"' || *end == '\\'')\n\t\t\t*end = '\\0';\n\t\t*next++ = '\\0';\n\t}\n\t*buf = next;\n\n\tif (*word == '\"' || *word == '\\'')\n\t\tword++;\n\treturn word;\n}\n#endif\n\n/*\n * Start parsing a new line from the cache.\n *\n * line starts with \"<device\" return 1 -> continue parsing line\n * line starts with \"<foo\", empty, or # return 0 -> skip line\n * line starts with other, return -BLKID_ERR_CACHE -> error\n */\nstatic int parse_start(char **cp)\n{\n\tchar *p;\n\n\tp = strip_line(*cp);\n\n\t/* Skip comment or blank lines.  We can't just NUL the first '#' char,\n\t * in case it is inside quotes, or escaped.\n\t */\n\tif (*p == '\\0' || *p == '#')\n\t\treturn 0;\n\n\tif (!strncmp(p, \"<device\", 7)) {\n\t\tDBG(READ, ul_debug(\"found device header: %8s\", p));\n\t\tp += 7;\n\n\t\t*cp = p;\n\t\treturn 1;\n\t}\n\n\tif (*p == '<')\n\t\treturn 0;\n\n\treturn -BLKID_ERR_CACHE;\n}\n\n/* Consume the remaining XML on the line (cosmetic only) */\nstatic int parse_end(char **cp)\n{\n\t*cp = skip_over_blank(*cp);\n\n\tif (!strncmp(*cp, \"</device>\", 9)) {\n\t\tDBG(READ, ul_debug(\"found device trailer %9s\", *cp));\n\t\t*cp += 9;\n\t\treturn 0;\n\t}\n\n\treturn -BLKID_ERR_CACHE;\n}\n\n/*\n * Allocate a new device struct with device name filled in.  Will handle\n * finding the device on lines of the form:\n * <device foo=bar>devname</device>\n * <device>devname<foo>bar</foo></device>\n */\nstatic int parse_dev(blkid_cache cache, blkid_dev *dev, char **cp)\n{\n\tchar *start, *tmp, *end, *name;\n\tint ret;\n\n\tif ((ret = parse_start(cp)) <= 0)\n\t\treturn ret;\n\n\tstart = tmp = strchr(*cp, '>');\n\tif (!start) {\n\t\tDBG(READ, ul_debug(\"blkid: short line parsing dev: %s\", *cp));\n\t\treturn -BLKID_ERR_CACHE;\n\t}\n\tstart = skip_over_blank(start + 1);\n\tend = skip_over_word(start);\n\n\tDBG(READ, ul_debug(\"device should be %*s\",\n\t\t\t       (int)(end - start), start));\n\n\tif (**cp == '>')\n\t\t*cp = end;\n\telse\n\t\t(*cp)++;\n\n\t*tmp = '\\0';\n\n\tif (!(tmp = strrchr(end, '<')) || parse_end(&tmp) < 0) {\n\t\tDBG(READ, ul_debug(\"blkid: missing </device> ending: %s\", end));\n\t} else if (tmp)\n\t\t*tmp = '\\0';\n\n\tif (end - start <= 1) {\n\t\tDBG(READ, ul_debug(\"blkid: empty device name: %s\", *cp));\n\t\treturn -BLKID_ERR_CACHE;\n\t}\n\n\tname = strndup(start, end - start);\n\tif (name == NULL)\n\t\treturn -BLKID_ERR_MEM;\n\n\tDBG(READ, ul_debug(\"found dev %s\", name));\n\n\tif (!(*dev = blkid_get_dev(cache, name, BLKID_DEV_CREATE))) {\n\t\tfree(name);\n\t\treturn -BLKID_ERR_MEM;\n\t}\n\n\tfree(name);\n\treturn 1;\n}\n\n/*\n * Extract a tag of the form NAME=\"value\" from the line.\n */\nstatic int parse_token(char **name, char **value, char **cp)\n{\n\tchar *end;\n\n\tif (!name || !value || !cp)\n\t\treturn -BLKID_ERR_PARAM;\n\n\tif (!(*value = strchr(*cp, '=')))\n\t\treturn 0;\n\n\t**value = '\\0';\n\t*name = strip_line(*cp);\n\t*value = skip_over_blank(*value + 1);\n\n\tif (**value == '\"') {\n\t\tend = strchr(*value + 1, '\"');\n\t\tif (!end) {\n\t\t\tDBG(READ, ul_debug(\"unbalanced quotes at: %s\", *value));\n\t\t\t*cp = *value;\n\t\t\treturn -BLKID_ERR_CACHE;\n\t\t}\n\t\t(*value)++;\n\t\t*end = '\\0';\n\t\tend++;\n\t} else {\n\t\tend = skip_over_word(*value);\n\t\tif (*end) {\n\t\t\t*end = '\\0';\n\t\t\tend++;\n\t\t}\n\t}\n\t*cp = end;\n\n\treturn 1;\n}\n\n/*\n * Extract a tag of the form <NAME>value</NAME> from the line.\n */\n/*\nstatic int parse_xml(char **name, char **value, char **cp)\n{\n\tchar *end;\n\n\tif (!name || !value || !cp)\n\t\treturn -BLKID_ERR_PARAM;\n\n\t*name = strip_line(*cp);\n\n\tif ((*name)[0] != '<' || (*name)[1] == '/')\n\t\treturn 0;\n\n\tFIXME: finish this.\n}\n*/\n\n/*\n * Extract a tag from the line.\n *\n * Return 1 if a valid tag was found.\n * Return 0 if no tag found.\n * Return -ve error code.\n */\nstatic int parse_tag(blkid_cache cache, blkid_dev dev, char **cp)\n{\n\tchar *name = NULL;\n\tchar *value = NULL;\n\tint ret;\n\n\tif (!cache || !dev)\n\t\treturn -BLKID_ERR_PARAM;\n\n\tif ((ret = parse_token(&name, &value, cp)) <= 0 /* &&\n\t    (ret = parse_xml(&name, &value, cp)) <= 0 */)\n\t\treturn ret;\n\n\t/* Some tags are stored directly in the device struct */\n\tif (!strcmp(name, \"DEVNO\"))\n\t\tdev->bid_devno = STRTOULL(value, 0, 0);\n\telse if (!strcmp(name, \"PRI\"))\n\t\tdev->bid_pri = strtol(value, 0, 0);\n\telse if (!strcmp(name, \"TIME\")) {\n\t\tchar *end = NULL;\n\t\tdev->bid_time = STRTOULL(value, &end, 0);\n\t\tif (end && *end == '.')\n\t\t\tdev->bid_utime = STRTOULL(end + 1, 0, 0);\n\t} else\n\t\tret = blkid_set_tag(dev, name, value, strlen(value));\n\n\tDBG(READ, ul_debug(\"    tag: %s=\\\"%s\\\"\", name, value));\n\n\treturn ret < 0 ? ret : 1;\n}\n\n/*\n * Parse a single line of data, and return a newly allocated dev struct.\n * Add the new device to the cache struct, if one was read.\n *\n * Lines are of the form <device [TAG=\"value\" ...]>/dev/foo</device>\n *\n * Returns -ve value on error.\n * Returns 0 otherwise.\n * If a valid device was read, *dev_p is non-NULL, otherwise it is NULL\n * (e.g. comment lines, unknown XML content, etc).\n */\nstatic int blkid_parse_line(blkid_cache cache, blkid_dev *dev_p, char *cp)\n{\n\tblkid_dev dev;\n\tint ret;\n\n\tif (!cache || !dev_p)\n\t\treturn -BLKID_ERR_PARAM;\n\n\t*dev_p = NULL;\n\n\tDBG(READ, ul_debug(\"line: %s\", cp));\n\n\tif ((ret = parse_dev(cache, dev_p, &cp)) <= 0)\n\t\treturn ret;\n\n\tdev = *dev_p;\n\n\twhile ((ret = parse_tag(cache, dev, &cp)) > 0) {\n\t\t;\n\t}\n\n\tif (dev->bid_type == NULL) {\n\t\tDBG(READ, ul_debug(\"blkid: device %s has no TYPE\",dev->bid_name));\n\t\tblkid_free_dev(dev);\n\t\tgoto done;\n\t}\n\n\tDBG(READ, blkid_debug_dump_dev(dev));\n\ndone:\n\treturn ret;\n}\n\n/*\n * Parse the specified filename, and return the data in the supplied or\n * a newly allocated cache struct.  If the file doesn't exist, return a\n * new empty cache struct.\n */\nvoid blkid_read_cache(blkid_cache cache)\n{\n\tFILE *file;\n\tchar buf[4096];\n\tint fd, lineno = 0;\n\tstruct stat st;\n\n\tif (!cache)\n\t\treturn;\n\n\t/*\n\t * If the file doesn't exist, then we just return an empty\n\t * struct so that the cache can be populated.\n\t */\n\tif ((fd = open(cache->bic_filename, O_RDONLY|O_CLOEXEC)) < 0)\n\t\treturn;\n\tif (fstat(fd, &st) < 0)\n\t\tgoto errout;\n\tif ((st.st_mtime == cache->bic_ftime) ||\n\t    (cache->bic_flags & BLKID_BIC_FL_CHANGED)) {\n\t\tDBG(CACHE, ul_debug(\"skipping re-read of %s\",\n\t\t\t\t\tcache->bic_filename));\n\t\tgoto errout;\n\t}\n\n\tDBG(CACHE, ul_debug(\"reading cache file %s\",\n\t\t\t\tcache->bic_filename));\n\n\tfile = fdopen(fd, \"r\" UL_CLOEXECSTR);\n\tif (!file)\n\t\tgoto errout;\n\n\twhile (fgets(buf, sizeof(buf), file)) {\n\t\tblkid_dev dev;\n\t\tunsigned int end;\n\n\t\tlineno++;\n\t\tif (buf[0] == 0)\n\t\t\tcontinue;\n\t\tend = strlen(buf) - 1;\n\t\t/* Continue reading next line if it ends with a backslash */\n\t\twhile (end < (sizeof(buf) - 2) && buf[end] == '\\\\' &&\n\t\t       fgets(buf + end, sizeof(buf) - end, file)) {\n\t\t\tend = strlen(buf) - 1;\n\t\t\tlineno++;\n\t\t}\n\n\t\tif (blkid_parse_line(cache, &dev, buf) < 0) {\n\t\t\tDBG(READ, ul_debug(\"blkid: bad format on line %d\", lineno));\n\t\t\tcontinue;\n\t\t}\n\t}\n\tfclose(file);\n\n\t/*\n\t * Initially we do not need to write out the cache file.\n\t */\n\tcache->bic_flags &= ~BLKID_BIC_FL_CHANGED;\n\tcache->bic_ftime = st.st_mtime;\n\n\treturn;\nerrout:\n\tclose(fd);\n\treturn;\n}\n\n#ifdef TEST_PROGRAM\nstatic void debug_dump_dev(blkid_dev dev)\n{\n\tstruct list_head *p;\n\n\tif (!dev) {\n\t\tprintf(\"  dev: NULL\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"  dev: name = %s\\n\", dev->bid_name);\n\tprintf(\"  dev: DEVNO=\\\"0x%0llx\\\"\\n\", (long long)dev->bid_devno);\n\tprintf(\"  dev: TIME=\\\"%ld.%ld\\\"\\n\", (long)dev->bid_time, (long)dev->bid_utime);\n\tprintf(\"  dev: PRI=\\\"%d\\\"\\n\", dev->bid_pri);\n\tprintf(\"  dev: flags = 0x%08X\\n\", dev->bid_flags);\n\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\t\tif (tag)\n\t\t\tprintf(\"    tag: %s=\\\"%s\\\"\\n\", tag->bit_name,\n\t\t\t       tag->bit_val);\n\t\telse\n\t\t\tprintf(\"    tag: NULL\\n\");\n\t}\n\tprintf(\"\\n\");\n}\n\nint main(int argc, char**argv)\n{\n\tblkid_cache cache = NULL;\n\tint ret;\n\n\tblkid_init_debug(BLKID_DEBUG_ALL);\n\tif (argc > 2) {\n\t\tfprintf(stderr, \"Usage: %s [filename]\\n\"\n\t\t\t\"Test parsing of the cache (filename)\\n\", argv[0]);\n\t\texit(1);\n\t}\n\tif ((ret = blkid_get_cache(&cache, argv[1])) < 0)\n\t\tfprintf(stderr, \"error %d reading cache file %s\\n\", ret,\n\t\t\targv[1] ? argv[1] : blkid_get_cache_filename(NULL));\n\n\tblkid_put_cache(cache);\n\n\treturn ret;\n}\n#endif\n", "/*\n * save.c - write the cache struct to disk\n *\n * Copyright (C) 2001 by Andreas Dilger\n * Copyright (C) 2003 Theodore Ts'o\n *\n * %Begin-Header%\n * This file may be redistributed under the terms of the\n * GNU Lesser General Public License.\n * %End-Header%\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n\n#include \"closestream.h\"\n\n#include \"blkidP.h\"\n\nstatic int save_dev(blkid_dev dev, FILE *file)\n{\n\tstruct list_head *p;\n\n\tif (!dev || dev->bid_name[0] != '/')\n\t\treturn 0;\n\n\tDBG(SAVE, ul_debug(\"device %s, type %s\", dev->bid_name, dev->bid_type ?\n\t\t   dev->bid_type : \"(null)\"));\n\n\tfprintf(file, \"<device DEVNO=\\\"0x%04lx\\\" TIME=\\\"%ld.%ld\\\"\",\n\t\t\t(unsigned long) dev->bid_devno,\n\t\t\t(long) dev->bid_time,\n\t\t\t(long) dev->bid_utime);\n\n\tif (dev->bid_pri)\n\t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\t\tfprintf(file, \" %s=\\\"%s\\\"\", tag->bit_name,tag->bit_val);\n\t}\n\tfprintf(file, \">%s</device>\\n\", dev->bid_name);\n\n\treturn 0;\n}\n\n/*\n * Write out the cache struct to the cache file on disk.\n */\nint blkid_flush_cache(blkid_cache cache)\n{\n\tstruct list_head *p;\n\tchar *tmp = NULL;\n\tchar *opened = NULL;\n\tchar *filename;\n\tFILE *file = NULL;\n\tint fd, ret = 0;\n\tstruct stat st;\n\n\tif (!cache)\n\t\treturn -BLKID_ERR_PARAM;\n\n\tif (list_empty(&cache->bic_devs) ||\n\t    !(cache->bic_flags & BLKID_BIC_FL_CHANGED)) {\n\t\tDBG(SAVE, ul_debug(\"skipping cache file write\"));\n\t\treturn 0;\n\t}\n\n\tfilename = cache->bic_filename ? cache->bic_filename :\n\t\t\t\t\t blkid_get_cache_filename(NULL);\n\tif (!filename)\n\t\treturn -BLKID_ERR_PARAM;\n\n\tif (strncmp(filename,\n\t    BLKID_RUNTIME_DIR \"/\", sizeof(BLKID_RUNTIME_DIR)) == 0) {\n\n\t\t/* default destination, create the directory if necessary */\n\t\tif (stat(BLKID_RUNTIME_DIR, &st)\n\t\t    && errno == ENOENT\n\t\t    && mkdir(BLKID_RUNTIME_DIR, S_IWUSR|\n\t\t\t\t\t\tS_IRUSR|S_IRGRP|S_IROTH|\n\t\t\t\t\t\tS_IXUSR|S_IXGRP|S_IXOTH) != 0\n\t\t    && errno != EEXIST) {\n\t\t\tDBG(SAVE, ul_debug(\"can't create %s directory for cache file\",\n\t\t\t\t\tBLKID_RUNTIME_DIR));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* If we can't write to the cache file, then don't even try */\n\tif (((ret = stat(filename, &st)) < 0 && errno != ENOENT) ||\n\t    (ret == 0 && access(filename, W_OK) < 0)) {\n\t\tDBG(SAVE, ul_debug(\"can't write to cache file %s\", filename));\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Try and create a temporary file in the same directory so\n\t * that in case of error we don't overwrite the cache file.\n\t * If the cache file doesn't yet exist, it isn't a regular\n\t * file (e.g. /dev/null or a socket), or we couldn't create\n\t * a temporary file then we open it directly.\n\t */\n\tif (ret == 0 && S_ISREG(st.st_mode)) {\n\t\ttmp = malloc(strlen(filename) + 8);\n\t\tif (tmp) {\n\t\t\tsprintf(tmp, \"%s-XXXXXX\", filename);\n\t\t\tfd = mkostemp(tmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n\t\t\tif (fd >= 0) {\n\t\t\t\tif (fchmod(fd, 0644) != 0)\n\t\t\t\t\tDBG(SAVE, ul_debug(\"%s: fchmod failed\", filename));\n\t\t\t\telse if ((file = fdopen(fd, \"w\" UL_CLOEXECSTR)))\n\t\t\t\t\topened = tmp;\n\t\t\t\tif (!file)\n\t\t\t\t\tclose(fd);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!file) {\n\t\tfile = fopen(filename, \"w\" UL_CLOEXECSTR);\n\t\topened = filename;\n\t}\n\n\tDBG(SAVE, ul_debug(\"writing cache file %s (really %s)\",\n\t\t   filename, opened));\n\n\tif (!file) {\n\t\tret = errno;\n\t\tgoto errout;\n\t}\n\n\tlist_for_each(p, &cache->bic_devs) {\n\t\tblkid_dev dev = list_entry(p, struct blkid_struct_dev, bid_devs);\n\t\tif (!dev->bid_type || (dev->bid_flags & BLKID_BID_FL_REMOVABLE))\n\t\t\tcontinue;\n\t\tif ((ret = save_dev(dev, file)) < 0)\n\t\t\tbreak;\n\t}\n\n\tif (ret >= 0) {\n\t\tcache->bic_flags &= ~BLKID_BIC_FL_CHANGED;\n\t\tret = 1;\n\t}\n\n\tif (close_stream(file) != 0)\n\t\tDBG(SAVE, ul_debug(\"write failed: %s\", filename));\n\n\tif (opened != filename) {\n\t\tif (ret < 0) {\n\t\t\tunlink(opened);\n\t\t\tDBG(SAVE, ul_debug(\"unlinked temp cache %s\", opened));\n\t\t} else {\n\t\t\tchar *backup;\n\n\t\t\tbackup = malloc(strlen(filename) + 5);\n\t\t\tif (backup) {\n\t\t\t\tsprintf(backup, \"%s.old\", filename);\n\t\t\t\tunlink(backup);\n\t\t\t\tif (link(filename, backup)) {\n\t\t\t\t\tDBG(SAVE, ul_debug(\"can't link %s to %s\",\n\t\t\t\t\t\t\tfilename, backup));\n\t\t\t\t}\n\t\t\t\tfree(backup);\n\t\t\t}\n\t\t\tif (rename(opened, filename)) {\n\t\t\t\tret = errno;\n\t\t\t\tDBG(SAVE, ul_debug(\"can't rename %s to %s\",\n\t\t\t\t\t\topened, filename));\n\t\t\t} else {\n\t\t\t\tDBG(SAVE, ul_debug(\"moved temp cache %s\", opened));\n\t\t\t}\n\t\t}\n\t}\n\nerrout:\n\tfree(tmp);\n\tif (filename != cache->bic_filename)\n\t\tfree(filename);\n\treturn ret;\n}\n\n#ifdef TEST_PROGRAM\nint main(int argc, char **argv)\n{\n\tblkid_cache cache = NULL;\n\tint ret;\n\n\tblkid_init_debug(BLKID_DEBUG_ALL);\n\tif (argc > 2) {\n\t\tfprintf(stderr, \"Usage: %s [filename]\\n\"\n\t\t\t\"Test loading/saving a cache (filename)\\n\", argv[0]);\n\t\texit(1);\n\t}\n\n\tif ((ret = blkid_get_cache(&cache, \"/dev/null\")) != 0) {\n\t\tfprintf(stderr, \"%s: error creating cache (%d)\\n\",\n\t\t\targv[0], ret);\n\t\texit(1);\n\t}\n\tif ((ret = blkid_probe_all(cache)) < 0) {\n\t\tfprintf(stderr, \"error (%d) probing devices\\n\", ret);\n\t\texit(1);\n\t}\n\tcache->bic_filename = strdup(argv[1]);\n\n\tif ((ret = blkid_flush_cache(cache)) < 0) {\n\t\tfprintf(stderr, \"error (%d) saving cache\\n\", ret);\n\t\texit(1);\n\t}\n\n\tblkid_put_cache(cache);\n\n\treturn ret;\n}\n#endif\n", ".\\\" Copyright 2000 Andreas Dilger (adilger@turbolinux.com)\n.\\\"\n.\\\" This man page was created for blkid from e2fsprogs-1.25.\n.\\\"\n.\\\" This file may be copied under the terms of the GNU Public License.\n.\\\"\n.\\\" Based on uuidgen, Mon Sep 17 10:42:12 2000, Andreas Dilger\n.TH BLKID 8 \"March 2013\" \"util-linux\" \"System Administration\"\n.SH NAME\nblkid \\- locate/print block device attributes\n.SH SYNOPSIS\n.B blkid\n.BI \\-L \" label\"\n|\n.BI \\-U \" uuid\"\n\n.B blkid\n.RB [ \\-dghlv ]\n.RB [ \\-c\n.IR file ]\n.RB [ \\-o\n.IR format ]\n.RB [ \\-s\n.IR tag ]\n.in +6\n.RB [ \\-t\n.IR NAME=value ]\n.RI [ device \" ...]\"\n.in -6\n\n.B blkid\n.BR -p \" [\" \\-O\n.IR offset ]\n.RB [ \\-o\n.IR format ]\n.RB [ \\-S\n.IR size ]\n.RB [ \\-s\n.IR tag ]\n.in +9\n.RB [ \\-n\n.IR list ]\n.RB [ \\-u\n.IR list ]\n.IR device \" ...\"\n.in -9\n\n.B blkid\n.BR -i \" [\" \\-o\n.IR format ]\n.RB [ \\-s\n.IR tag ]\n.IR device \" ...\"\n\n.SH DESCRIPTION\nThe\n.B blkid\nprogram is the command-line interface to working with the\n.BR libblkid (3)\nlibrary.  It can determine the type of content (e.g. filesystem or swap)\nthat a block device holds, and also the attributes (tokens, NAME=value pairs)\nfrom the content metadata (e.g. LABEL or UUID fields).\n.PP\nIt is recommended to use\n.BR lsblk (8)\ncommand to get information about block devices rather than blkid.\n.BR lsblk (8)\nprovides more information, better control on output formatting and it does not\nrequire root permissions to get actual information.\n.PP\nWhen\n.I device\nis specified, tokens from only this device are displayed.\nIt is possible to specify multiple\n.I device\narguments on the command line.\nIf none is given, all devices which appear in\n.I /proc/partitions\nare shown, if they are recognized.\n.PP\nNote that\n.B blkid\nreads information directly from devices and for non-root users\nit returns cached unverified information.  It is better to use\n.B lsblk --fs\nto get a user-friendly overview of filesystems and devices.\n.BR lsblk (8)\nis also easy to use in scripts.\n.B blkid\nis mostly designed for system services and to test libblkid functionality.\n.PP\n.B blkid\nhas two main forms of operation: either searching for a device with a\nspecific NAME=value pair, or displaying NAME=value pairs for one or\nmore specified devices.\n.SH OPTIONS\nThe \\fIsize\\fR and \\fIoffset\\fR arguments may be followed by the multiplicative\nsuffixes like KiB (=1024), MiB (=1024*1024), and so on for GiB, TiB, PiB, EiB, ZiB and YiB\n(the \"iB\" is optional, e.g. \"K\" has the same meaning as \"KiB\"), or the suffixes\nKB (=1000), MB (=1000*1000), and so on for GB, TB, PB, EB, ZB and YB.\n.TP\n.BI \\-c \" cachefile\"\nRead from\n.I cachefile\ninstead of reading from the default cache file (see the CONFIGURATION FILE section\nfor more details).  If you want to start with a clean cache (i.e. don't report\ndevices previously scanned but not necessarily available at this time), specify\n.IR /dev/null .\n.TP\n.B \\-d\nDon't encode non-printing characters.  The non-printing characters are encoded\nby ^ and M- notation by default.  Note that the \\fB-o udev\\fR output format uses\na different encoding which cannot be disabled.\n.TP\n.B \\-g\nPerform a garbage collection pass on the blkid cache to remove\ndevices which no longer exist.\n.TP\n.B \\-h\nDisplay a usage message and exit.\n.TP\n.B \\-i\nDisplay information about I/O Limits (aka I/O topology).  The 'export' output format is\nautomatically enabled.  This option can be used together with the \\fB-p\\fR option.\n.TP\n.B \\-k\nList all known filesystems and RAIDs and exit.\n.TP\n.B \\-l\nLook up only one device that matches the search parameter specified with the \\fB-t\\fR\noption.  If there are multiple devices that match the specified search\nparameter, then the device with the highest priority is returned, and/or\nthe first device found at a given priority.  Device types in order of\ndecreasing priority are: Device Mapper, EVMS, LVM, MD, and finally regular\nblock devices.  If this option is not specified,\n.B blkid\nwill print all of the devices that match the search parameter.\n.TP\n.BI \\-L \" label\"\nLook up the device that uses this filesystem \\fIlabel\\fR; this is equal to\n.BR \"-l -o device -t LABEL=\\fIlabel\\fR\" .\nThis lookup method is able to reliably use /dev/disk/by-label\nudev symlinks (dependent on a setting in /etc/blkid.conf).  Avoid using the\nsymlinks directly; it is not reliable to use the symlinks without verification.\nThe \\fB-L\\fR option works on systems with and without udev.\n\nUnfortunately, the original\n.BR blkid (8)\nfrom e2fsprogs uses the \\fB-L\\fR option as a\nsynonym for \\fB-o list\\fR.  For better portability, use \\fB-l -o device\n-t LABEL=\\fIlabel\\fR and \\fB-o list\\fR in your scripts rather than the \\fB-L\\fR option.\n.TP\n.BI \\-n \" list\"\nRestrict the probing functions to the specified (comma-separated) \\fIlist\\fR of\nsuperblock types (names).\nThe list items may be prefixed with \"no\" to specify the types which should be ignored.\nFor example:\n.sp\n  blkid -p -n vfat,ext3,ext4 /dev/sda1\n.sp\nprobes for vfat, ext3 and ext4 filesystems, and\n.sp\n  blkid -p -n nominix /dev/sda1\n.sp\nprobes for all supported formats except minix filesystems.\nThis option is only useful together with \\fB-p\\fR.\n.TP\n.BI \\-o \" format\"\nUse the specified output format.  Note that the order of variables and\ndevices is not fixed.  See also option \\fB-s\\fR.  The\n.I format\nparameter may be:\n.RS\n.TP\n.B full\nprint all tags (the default)\n.TP\n.B value\nprint the value of the tags\n.TP\n.B list\nprint the devices in a user-friendly format; this output format is unsupported\nfor low-level probing (\\fB-p\\fR or \\fB-i\\fR).\n\nThis output format is \\fBDEPRECATED\\fR in favour of the\n.BR lsblk (8)\ncommand.\n.TP\n.B device\nprint the device name only; this output format is always enabled for the \\fB-L\\fR\nand \\fB-U\\fR options\n.TP\n.B udev\nprint key=\"value\" pairs for easy import into the udev environment; the keys are\nprefixed by ID_FS_ or ID_PART_ prefixes\n\nThe udev output returns the ID_FS_AMBIVALENT tag if more superblocks are detected,\nand ID_PART_ENTRY_* tags are always returned for all partitions including empty\npartitions.  This output format is \\fBDEPRECATED\\fR.\n.TP\n.B export\nprint key=value pairs for easy import into the environment; this output format\nis automatically enabled when I/O Limits (\\fB-i\\fR option) are requested\n.RE\n.TP\n.BI \\-O \" offset\"\nProbe at the given \\fIoffset\\fR (only useful with \\fB-p\\fR).  This option can be\nused together with the \\fB-i\\fR option.\n.TP\n.BI \\-p\nSwitch to low-level superblock probing mode (bypassing the cache).\n\nNote that low-level probing also returns information about partition table type\n(PTTYPE tag) and partitions (PART_ENTRY_* tags).\n.TP\n.BI \\-s \" tag\"\nFor each (specified) device, show only the tags that match\n.IR tag .\nIt is possible to specify multiple\n.B \\-s\noptions.  If no tag is specified, then all tokens are shown for all\n(specified) devices.\nIn order to just refresh the cache without showing any tokens, use\n.B \"-s none\"\nwith no other options.\n.TP\n.BI \\-S \" size\"\nOverride the size of device/file (only useful with \\fB-p\\fR).\n.TP\n.BI \\-t \" NAME\" = value\nSearch for block devices with tokens named\n.I NAME\nthat have the value\n.IR value ,\nand display any devices which are found.\nCommon values for\n.I NAME\ninclude\n.BR TYPE ,\n.BR LABEL ,\nand\n.BR UUID .\nIf there are no devices specified on the command line, all block devices\nwill be searched; otherwise only the specified devices are searched.\n.TP\n.BI \\-u \" list\"\nRestrict the probing functions to the specified (comma-separated) \\fIlist\\fR of \"usage\" types.\nSupported usage types are: filesystem, raid, crypto and other.  The list items may be\nprefixed with \"no\" to specify the usage types which should be ignored.  For example:\n.sp\n  blkid -p -u filesystem,other /dev/sda1\n.sp\nprobes for all filesystem and other (e.g. swap) formats, and\n.sp\n  blkid -p -u noraid /dev/sda1\n.sp\nprobes for all supported formats except RAIDs.\nThis option is only useful together with \\fB-p\\fR.\n.TP\n.BI \\-U \" uuid\"\nLook up the device that uses this filesystem \\fIuuid\\fR.  For more details see the \\fB-L\\fR option.\n.TP\n.B \\-V\nDisplay version number and exit.\n.SH \"RETURN CODE\"\nIf the specified token was found, or if any tags were shown from (specified)\ndevices, 0 is returned.\n\nIf the specified token was not found, or no (specified) devices could be\nidentified, an exit code of 2 is returned.\n\nFor usage or other errors, an exit code of 4 is returned.\n\nIf an ambivalent low-level probing result was detected, an exit code of 8 is\nreturned.\n.SH CONFIGURATION FILE\nThe standard location of the\n.I /etc/blkid.conf\nconfig file can be overridden by the environment variable BLKID_CONF.\nThe following options control the libblkid library:\n.TP\n.I SEND_UEVENT=<yes|not>\nSends uevent when\n.I /dev/disk/by-{label,uuid,partuuid,partlabel}/\nsymlink does not match with LABEL, UUID, PARTUUID or PARTLABEL on the device.  Default is \"yes\".\n.TP\n.I CACHE_FILE=<path>\nOverrides the standard location of the cache file.  This setting can be\noverridden by the environment variable BLKID_FILE.  Default is\n.IR /run/blkid/blkid.tab ,\nor\n.I /etc/blkid.tab\non systems without a /run directory.\n.TP\n.I EVALUATE=<methods>\nDefines LABEL and UUID evaluation method(s).  Currently, the libblkid library\nsupports the \"udev\" and \"scan\" methods.  More than one method may be specified in\na comma-separated list.  Default is \"udev,scan\".  The \"udev\" method uses udev\n.I /dev/disk/by-*\nsymlinks and the \"scan\" method scans all block devices from the\n.I /proc/partitions\nfile.\n.SH AUTHOR\n.B blkid\nwas written by Andreas Dilger for libblkid and improved by Theodore Ts'o\nand Karel Zak.\n.SH ENVIRONMENT\n.IP \"Setting LIBBLKID_DEBUG=all enables debug output.\"\n.SH SEE ALSO\n.BR libblkid (3),\n.BR findfs (8),\n.BR wipefs (8),\n.BR lsblk (8),\n.SH AVAILABILITY\nThe blkid command is part of the util-linux package and is available from\nftp://ftp.kernel.org/pub/linux/utils/util-linux/.\n", "/*\n * blkid.c - User command-line interface for libblkid\n *\n * Copyright (C) 2001 Andreas Dilger\n *\n * %Begin-Header%\n * This file may be redistributed under the terms of the\n * GNU Lesser General Public License.\n * %End-Header%\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#ifdef HAVE_GETOPT_H\n#include <getopt.h>\n#else\nextern int getopt(int argc, char * const argv[], const char *optstring);\nextern char *optarg;\nextern int optind;\n#endif\n\n#define OUTPUT_VALUE_ONLY\t(1 << 1)\n#define OUTPUT_DEVICE_ONLY\t(1 << 2)\n#define OUTPUT_PRETTY_LIST\t(1 << 3)\t\t/* deprecated */\n#define OUTPUT_UDEV_LIST\t(1 << 4)\t\t/* deprecated */\n#define OUTPUT_EXPORT_LIST\t(1 << 5)\n\n#define LOWPROBE_TOPOLOGY\t(1 << 1)\n#define LOWPROBE_SUPERBLOCKS\t(1 << 2)\n\n#define BLKID_EXIT_NOTFOUND\t2\t/* token or device not found */\n#define BLKID_EXIT_OTHER\t4\t/* bad usage or other error */\n#define BLKID_EXIT_AMBIVAL\t8\t/* ambivalent low-level probing detected */\n\n#include <blkid.h>\n\n#include \"ismounted.h\"\n\n#define STRTOXX_EXIT_CODE\tBLKID_EXIT_OTHER\t/* strtoxx_or_err() */\n#include \"strutils.h\"\n#define OPTUTILS_EXIT_CODE\tBLKID_EXIT_OTHER\t/* exclusive_option() */\n#include \"optutils.h\"\n\n#include \"closestream.h\"\n#include \"ttyutils.h\"\n#include \"xalloc.h\"\n\nint raw_chars;\n\nstatic void print_version(FILE *out)\n{\n\tfprintf(out, \"%s from %s  (libblkid %s, %s)\\n\",\n\t\tprogram_invocation_short_name, PACKAGE_STRING,\n\t\tLIBBLKID_VERSION, LIBBLKID_DATE);\n}\n\nstatic void usage(int error)\n{\n\tFILE *out = error ? stderr : stdout;\n\n\tprint_version(out);\n\tfprintf(out,\n\t\t\"Usage:\\n\"\n\t\t\" %1$s -L <label> | -U <uuid>\\n\\n\"\n\t\t\" %1$s [-c <file>] [-ghlLv] [-o <format>] [-s <tag>] \\n\"\n\t\t\"       [-t <token>] [<dev> ...]\\n\\n\"\n\t\t\" %1$s -p [-s <tag>] [-O <offset>] [-S <size>] \\n\"\n\t\t\"       [-o <format>] <dev> ...\\n\\n\"\n\t\t\" %1$s -i [-s <tag>] [-o <format>] <dev> ...\\n\\n\"\n\t\t\"Options:\\n\"\n\t\t\" -c <file>   read from <file> instead of reading from the default\\n\"\n\t\t\"               cache file (-c /dev/null means no cache)\\n\"\n\t\t\" -d          don't encode non-printing characters\\n\"\n\t\t\" -h          print this usage message and exit\\n\"\n\t\t\" -g          garbage collect the blkid cache\\n\"\n\t\t\" -o <format> output format; can be one of:\\n\"\n\t\t\"               value, device, export or full; (default: full)\\n\"\n\t\t\" -k          list all known filesystems/RAIDs and exit\\n\"\n\t\t\" -s <tag>    show specified tag(s) (default show all tags)\\n\"\n\t\t\" -t <token>  find device with a specific token (NAME=value pair)\\n\"\n\t\t\" -l          look up only first device with token specified by -t\\n\"\n\t\t\" -L <label>  convert LABEL to device name\\n\"\n\t\t\" -U <uuid>   convert UUID to device name\\n\"\n\t\t\" -V          print version and exit\\n\"\n\t\t\" <dev>       specify device(s) to probe (default: all devices)\\n\\n\"\n\t\t\"Low-level probing options:\\n\"\n\t\t\" -p          low-level superblocks probing (bypass cache)\\n\"\n\t\t\" -i          gather information about I/O limits\\n\"\n\t\t\" -S <size>   overwrite device size\\n\"\n\t\t\" -O <offset> probe at the given offset\\n\"\n\t\t\" -u <list>   filter by \\\"usage\\\" (e.g. -u filesystem,raid)\\n\"\n\t\t\" -n <list>   filter by filesystem type (e.g. -n vfat,ext3)\\n\"\n\t\t\"\\n\", program_invocation_short_name);\n\n\texit(error);\n}\n\n/*\n * This function does \"safe\" printing.  It will convert non-printable\n * ASCII characters using '^' and M- notation.\n *\n * If 'esc' is defined then escape all chars from esc by \\.\n */\nstatic void safe_print(const char *cp, int len, const char *esc)\n{\n\tunsigned char\tch;\n\n\tif (len < 0)\n\t\tlen = strlen(cp);\n\n\twhile (len--) {\n\t\tch = *cp++;\n\t\tif (!raw_chars) {\n\t\t\tif (ch >= 128) {\n\t\t\t\tfputs(\"M-\", stdout);\n\t\t\t\tch -= 128;\n\t\t\t}\n\t\t\tif ((ch < 32) || (ch == 0x7f)) {\n\t\t\t\tfputc('^', stdout);\n\t\t\t\tch ^= 0x40; /* ^@, ^A, ^B; ^? for DEL */\n\n\t\t\t} else if (esc && strchr(esc, ch))\n\t\t\t\tfputc('\\\\', stdout);\n\t\t}\n\t\tfputc(ch, stdout);\n\t}\n}\n\nstatic int pretty_print_word(const char *str, int max_len,\n\t\t\t     int left_len, int overflow_nl)\n{\n\tint len = strlen(str) + left_len;\n\tint ret = 0;\n\n\tfputs(str, stdout);\n\tif (overflow_nl && len > max_len) {\n\t\tfputc('\\n', stdout);\n\t\tlen = 0;\n\t} else if (len > max_len)\n\t\tret = len - max_len;\n\tdo\n\t\tfputc(' ', stdout);\n\twhile (len++ < max_len);\n\treturn ret;\n}\n\nstatic void pretty_print_line(const char *device, const char *fs_type,\n\t\t\t      const char *label, const char *mtpt,\n\t\t\t      const char *uuid)\n{\n\tstatic int device_len = 10, fs_type_len = 7;\n\tstatic int label_len = 8, mtpt_len = 14;\n\tstatic int term_width = -1;\n\tint len, w;\n\n\tif (term_width < 0) {\n\t\tterm_width = get_terminal_width();\n\t\tif (term_width <= 0)\n\t\t\tterm_width = 80;\n\t}\n\tif (term_width > 80) {\n\t\tterm_width -= 80;\n\t\tw = term_width / 10;\n\t\tif (w > 8)\n\t\t\tw = 8;\n\t\tterm_width -= 2*w;\n\t\tlabel_len += w;\n\t\tfs_type_len += w;\n\t\tw = term_width/2;\n\t\tdevice_len += w;\n\t\tmtpt_len +=w;\n\t}\n\n\tlen = pretty_print_word(device, device_len, 0, 1);\n\tlen = pretty_print_word(fs_type, fs_type_len, len, 0);\n\tlen = pretty_print_word(label, label_len, len, 0);\n\tpretty_print_word(mtpt, mtpt_len, len, 0);\n\n\tfputs(uuid, stdout);\n\tfputc('\\n', stdout);\n}\n\nstatic void pretty_print_dev(blkid_dev dev)\n{\n\tblkid_tag_iterate\titer;\n\tconst char\t\t*type, *value, *devname;\n\tconst char\t\t*uuid = \"\", *fs_type = \"\", *label = \"\";\n\tint\t\t\tlen, mount_flags;\n\tchar\t\t\tmtpt[80];\n\tint\t\t\tretval;\n\n\tif (dev == NULL) {\n\t\tpretty_print_line(\"device\", \"fs_type\", \"label\",\n\t\t\t\t  \"mount point\", \"UUID\");\n\t\tfor (len=get_terminal_width()-1; len > 0; len--)\n\t\t\tfputc('-', stdout);\n\t\tfputc('\\n', stdout);\n\t\treturn;\n\t}\n\n\tdevname = blkid_dev_devname(dev);\n\tif (access(devname, F_OK))\n\t\treturn;\n\n\t/* Get the uuid, label, type */\n\titer = blkid_tag_iterate_begin(dev);\n\twhile (blkid_tag_next(iter, &type, &value) == 0) {\n\t\tif (!strcmp(type, \"UUID\"))\n\t\t\tuuid = value;\n\t\tif (!strcmp(type, \"TYPE\"))\n\t\t\tfs_type = value;\n\t\tif (!strcmp(type, \"LABEL\"))\n\t\t\tlabel = value;\n\t}\n\tblkid_tag_iterate_end(iter);\n\n\t/* Get the mount point */\n\tmtpt[0] = 0;\n\tretval = check_mount_point(devname, &mount_flags, mtpt, sizeof(mtpt));\n\tif (retval == 0) {\n\t\tif (mount_flags & MF_MOUNTED) {\n\t\t\tif (!mtpt[0])\n\t\t\t\tstrcpy(mtpt, \"(mounted, mtpt unknown)\");\n\t\t} else if (mount_flags & MF_BUSY)\n\t\t\tstrcpy(mtpt, \"(in use)\");\n\t\telse\n\t\t\tstrcpy(mtpt, \"(not mounted)\");\n\t}\n\n\tpretty_print_line(devname, fs_type, label, mtpt, uuid);\n}\n\nstatic void print_udev_format(const char *name, const char *value)\n{\n\tchar enc[265], safe[256];\n\tsize_t namelen = strlen(name);\n\n\t*safe = *enc = '\\0';\n\n\tif (!strcmp(name, \"TYPE\") || !strcmp(name, \"VERSION\")) {\n\t\tblkid_encode_string(value, enc, sizeof(enc));\n\t\tprintf(\"ID_FS_%s=%s\\n\", name, enc);\n\n\t} else if (!strcmp(name, \"UUID\") ||\n\t\t !strcmp(name, \"LABEL\") ||\n\t\t !strcmp(name, \"UUID_SUB\")) {\n\n\t\tblkid_safe_string(value, safe, sizeof(safe));\n\t\tprintf(\"ID_FS_%s=%s\\n\", name, safe);\n\n\t\tblkid_encode_string(value, enc, sizeof(enc));\n\t\tprintf(\"ID_FS_%s_ENC=%s\\n\", name, enc);\n\n\t} else if (!strcmp(name, \"PTUUID\")) {\n\t\tprintf(\"ID_PART_TABLE_UUID=%s\\n\", value);\n\n\t} else if (!strcmp(name, \"PTTYPE\")) {\n\t\tprintf(\"ID_PART_TABLE_TYPE=%s\\n\", value);\n\n\t} else if (!strcmp(name, \"PART_ENTRY_NAME\") ||\n\t\t  !strcmp(name, \"PART_ENTRY_TYPE\")) {\n\n\t\tblkid_encode_string(value, enc, sizeof(enc));\n\t\tprintf(\"ID_%s=%s\\n\", name, enc);\n\n\t} else if (!strncmp(name, \"PART_ENTRY_\", 11))\n\t\tprintf(\"ID_%s=%s\\n\", name, value);\n\n\telse if (namelen >= 15 && (\n\t\t   !strcmp(name + (namelen - 12), \"_SECTOR_SIZE\") ||\n\t\t   !strcmp(name + (namelen - 8), \"_IO_SIZE\") ||\n\t\t   !strcmp(name, \"ALIGNMENT_OFFSET\")))\n\t\t\tprintf(\"ID_IOLIMIT_%s=%s\\n\", name, value);\n\telse\n\t\tprintf(\"ID_FS_%s=%s\\n\", name, value);\n}\n\nstatic int has_item(char *ary[], const char *item)\n{\n\tchar **p;\n\n\tfor (p = ary; *p != NULL; p++)\n\t\tif (!strcmp(item, *p))\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic void print_value(int output, int num, const char *devname,\n\t\t\tconst char *value, const char *name, size_t valsz)\n{\n\tif (output & OUTPUT_VALUE_ONLY) {\n\t\tfputs(value, stdout);\n\t\tfputc('\\n', stdout);\n\n\t} else if (output & OUTPUT_UDEV_LIST) {\n\t\tprint_udev_format(name, value);\n\n\t} else if (output & OUTPUT_EXPORT_LIST) {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"DEVNAME=%s\\n\", devname);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\", stdout);\n\t\tsafe_print(value, valsz, NULL);\n\t\tfputs(\"\\n\", stdout);\n\n\t} else {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"%s:\", devname);\n\t\tfputs(\" \", stdout);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\\\"\", stdout);\n\t\tsafe_print(value, valsz, \"\\\"\");\n\t\tfputs(\"\\\"\", stdout);\n\t}\n}\n\nstatic void print_tags(blkid_dev dev, char *show[], int output)\n{\n\tblkid_tag_iterate\titer;\n\tconst char\t\t*type, *value, *devname;\n\tint\t\t\tnum = 1;\n\tstatic int\t\tfirst = 1;\n\n\tif (!dev)\n\t\treturn;\n\n\tif (output & OUTPUT_PRETTY_LIST) {\n\t\tpretty_print_dev(dev);\n\t\treturn;\n\t}\n\n\tdevname = blkid_dev_devname(dev);\n\n\tif (output & OUTPUT_DEVICE_ONLY) {\n\t\tprintf(\"%s\\n\", devname);\n\t\treturn;\n\t}\n\n\titer = blkid_tag_iterate_begin(dev);\n\twhile (blkid_tag_next(iter, &type, &value) == 0) {\n\t\tif (show[0] && !has_item(show, type))\n\t\t\tcontinue;\n\n\t\tif (num == 1 && !first &&\n\t\t    (output & (OUTPUT_UDEV_LIST | OUTPUT_EXPORT_LIST)))\n\t\t\t/* add extra line between output from more devices */\n\t\t\tfputc('\\n', stdout);\n\n\t\tprint_value(output, num++, devname, value, type, strlen(value));\n\t}\n\tblkid_tag_iterate_end(iter);\n\n\tif (num > 1) {\n\t\tif (!(output & (OUTPUT_VALUE_ONLY | OUTPUT_UDEV_LIST |\n\t\t\t\t\t\tOUTPUT_EXPORT_LIST)))\n\t\t\tprintf(\"\\n\");\n\t\tfirst = 0;\n\t}\n}\n\n\nstatic int append_str(char **res, size_t *sz, const char *a, const char *b)\n{\n\tchar *str = *res;\n\tsize_t asz = a ? strlen(a) : 0;\n\tsize_t bsz = b ? strlen(b) : 0;\n\tsize_t len = *sz + asz + bsz;\n\n\tif (!len)\n\t\treturn -1;\n\n\t*res = str = xrealloc(str, len + 1);\n\tstr += *sz;\n\n\tif (a) {\n\t\tmemcpy(str, a, asz);\n\t\tstr += asz;\n\t}\n\tif (b) {\n\t\tmemcpy(str, b, bsz);\n\t\tstr += bsz;\n\t}\n\t*str = '\\0';\n\t*sz = len;\n\treturn 0;\n}\n\n/*\n * Compose and print ID_FS_AMBIVALENT for udev\n */\nstatic int print_udev_ambivalent(blkid_probe pr)\n{\n\tchar *val = NULL;\n\tsize_t valsz = 0;\n\tint count = 0, rc = -1;\n\n\twhile (!blkid_do_probe(pr)) {\n\t\tconst char *usage_txt = NULL, *type = NULL, *version = NULL;\n\t\tchar enc[256];\n\n\t\tblkid_probe_lookup_value(pr, \"USAGE\", &usage_txt, NULL);\n\t\tblkid_probe_lookup_value(pr, \"TYPE\", &type, NULL);\n\t\tblkid_probe_lookup_value(pr, \"VERSION\", &version, NULL);\n\n\t\tif (!usage_txt || !type)\n\t\t\tcontinue;\n\n\t\tblkid_encode_string(usage_txt, enc, sizeof(enc));\n\t\tif (append_str(&val, &valsz, enc, \":\"))\n\t\t\tgoto done;\n\n\t\tblkid_encode_string(type, enc, sizeof(enc));\n\t\tif (append_str(&val, &valsz, enc, version ? \":\" : \" \"))\n\t\t\tgoto done;\n\n\t\tif (version) {\n\t\t\tblkid_encode_string(version, enc, sizeof(enc));\n\t\t\tif (append_str(&val, &valsz, enc, \" \"))\n\t\t\t\tgoto done;\n\t\t}\n\t\tcount++;\n\t}\n\n\tif (count > 1) {\n\t\t*(val + valsz - 1) = '\\0';\t\t/* rem tailing whitespace */\n\t\tprintf(\"ID_FS_AMBIVALENT=%s\\n\", val);\n\t\trc = 0;\n\t}\ndone:\n\tfree(val);\n\treturn rc;\n}\n\nstatic int lowprobe_superblocks(blkid_probe pr)\n{\n\tstruct stat st;\n\tint rc, fd = blkid_probe_get_fd(pr);\n\n\tif (fd < 0 || fstat(fd, &st))\n\t\treturn -1;\n\n\tblkid_probe_enable_partitions(pr, 1);\n\n\tif (!S_ISCHR(st.st_mode) && blkid_probe_get_size(pr) <= 1024 * 1440 &&\n\t    blkid_probe_is_wholedisk(pr)) {\n\t\t/*\n\t\t * check if the small disk is partitioned, if yes then\n\t\t * don't probe for filesystems.\n\t\t */\n\t\tblkid_probe_enable_superblocks(pr, 0);\n\n\t\trc = blkid_do_fullprobe(pr);\n\t\tif (rc < 0)\n\t\t\treturn rc;\t/* -1 = error, 1 = nothing, 0 = succes */\n\n\t\tif (blkid_probe_lookup_value(pr, \"PTTYPE\", NULL, NULL) == 0)\n\t\t\treturn 0;\t/* partition table detected */\n\t}\n\n\tblkid_probe_set_partitions_flags(pr, BLKID_PARTS_ENTRY_DETAILS);\n\tblkid_probe_enable_superblocks(pr, 1);\n\n\treturn blkid_do_safeprobe(pr);\n}\n\nstatic int lowprobe_topology(blkid_probe pr)\n{\n\t/* enable topology probing only */\n\tblkid_probe_enable_topology(pr, 1);\n\n\tblkid_probe_enable_superblocks(pr, 0);\n\tblkid_probe_enable_partitions(pr, 0);\n\n\treturn blkid_do_fullprobe(pr);\n}\n\nstatic int lowprobe_device(blkid_probe pr, const char *devname,\n\t\t\tint chain, char *show[], int output,\n\t\t\tblkid_loff_t offset, blkid_loff_t size)\n{\n\tconst char *data;\n\tconst char *name;\n\tint nvals = 0, n, num = 1;\n\tsize_t len;\n\tint fd;\n\tint rc = 0;\n\tstatic int first = 1;\n\n\tfd = open(devname, O_RDONLY|O_CLOEXEC);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"error: %s: %m\\n\", devname);\n\t\treturn BLKID_EXIT_NOTFOUND;\n\t}\n\tif (blkid_probe_set_device(pr, fd, offset, size))\n\t\tgoto done;\n\n\tif (chain & LOWPROBE_TOPOLOGY)\n\t\trc = lowprobe_topology(pr);\n\tif (rc >= 0 && (chain & LOWPROBE_SUPERBLOCKS))\n\t\trc = lowprobe_superblocks(pr);\n\tif (rc < 0)\n\t\tgoto done;\n\n\tif (!rc)\n\t\tnvals = blkid_probe_numof_values(pr);\n\n\tif (nvals &&\n\t    !(chain & LOWPROBE_TOPOLOGY) &&\n\t    !(output & OUTPUT_UDEV_LIST) &&\n\t    !blkid_probe_has_value(pr, \"TYPE\") &&\n\t    !blkid_probe_has_value(pr, \"PTTYPE\"))\n\t\t/*\n\t\t * Ignore probing result if there is not any filesystem or\n\t\t * partition table on the device and udev output is not\n\t\t * requested.\n\t\t *\n\t\t * The udev db stores information about partitions, so\n\t\t * PART_ENTRY_* values are alway important.\n\t\t */\n\t\tnvals = 0;\n\n\tif (nvals && !first && output & (OUTPUT_UDEV_LIST | OUTPUT_EXPORT_LIST))\n\t\t/* add extra line between output from devices */\n\t\tfputc('\\n', stdout);\n\n\tif (nvals && (output & OUTPUT_DEVICE_ONLY)) {\n\t\tprintf(\"%s\\n\", devname);\n\t\tgoto done;\n\t}\n\n\tfor (n = 0; n < nvals; n++) {\n\t\tif (blkid_probe_get_value(pr, n, &name, &data, &len))\n\t\t\tcontinue;\n\t\tif (show[0] && !has_item(show, name))\n\t\t\tcontinue;\n\t\tlen = strnlen((char *) data, len);\n\t\tprint_value(output, num++, devname, (char *) data, name, len);\n\t}\n\n\tif (first)\n\t\tfirst = 0;\n\tif (nvals >= 1 && !(output & (OUTPUT_VALUE_ONLY |\n\t\t\t\t\tOUTPUT_UDEV_LIST | OUTPUT_EXPORT_LIST)))\n\t\tprintf(\"\\n\");\ndone:\n\tif (rc == -2) {\n\t\tif (output & OUTPUT_UDEV_LIST)\n\t\t\tprint_udev_ambivalent(pr);\n\t\telse\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%s: ambivalent result (probably more \"\n\t\t\t\t\"filesystems on the device, use wipefs(8) \"\n\t\t\t\t\"to see more details)\\n\",\n\t\t\t\tdevname);\n\t}\n\tclose(fd);\n\n\tif (rc == -2)\n\t\treturn BLKID_EXIT_AMBIVAL;\t/* ambivalent probing result */\n\tif (!nvals)\n\t\treturn BLKID_EXIT_NOTFOUND;\t/* nothing detected */\n\n\treturn 0;\t\t/* success */\n}\n\n/* converts comma separated list to BLKID_USAGE_* mask */\nstatic int list_to_usage(const char *list, int *flag)\n{\n\tint mask = 0;\n\tconst char *word = NULL, *p = list;\n\n\tif (p && strncmp(p, \"no\", 2) == 0) {\n\t\t*flag = BLKID_FLTR_NOTIN;\n\t\tp += 2;\n\t}\n\tif (!p || !*p)\n\t\tgoto err;\n\twhile(p) {\n\t\tword = p;\n\t\tp = strchr(p, ',');\n\t\tif (p)\n\t\t\tp++;\n\t\tif (!strncmp(word, \"filesystem\", 10))\n\t\t\tmask |= BLKID_USAGE_FILESYSTEM;\n\t\telse if (!strncmp(word, \"raid\", 4))\n\t\t\tmask |= BLKID_USAGE_RAID;\n\t\telse if (!strncmp(word, \"crypto\", 6))\n\t\t\tmask |= BLKID_USAGE_CRYPTO;\n\t\telse if (!strncmp(word, \"other\", 5))\n\t\t\tmask |= BLKID_USAGE_OTHER;\n\t\telse\n\t\t\tgoto err;\n\t}\n\treturn mask;\nerr:\n\t*flag = 0;\n\tfprintf(stderr, \"unknown keyword in -u <list> argument: '%s'\\n\",\n\t\t\tword ? word : list);\n\texit(BLKID_EXIT_OTHER);\n}\n\n/* converts comma separated list to types[] */\nstatic char **list_to_types(const char *list, int *flag)\n{\n\tint i;\n\tconst char *p = list;\n\tchar **res = NULL;\n\n\tif (p && strncmp(p, \"no\", 2) == 0) {\n\t\t*flag = BLKID_FLTR_NOTIN;\n\t\tp += 2;\n\t}\n\tif (!p || !*p) {\n\t\tfprintf(stderr, \"error: -u <list> argument is empty\\n\");\n\t\tgoto err;\n\t}\n\tfor (i = 1; p && (p = strchr(p, ',')); i++, p++);\n\n\tres = xcalloc(i + 1, sizeof(char *));\n\tp = *flag & BLKID_FLTR_NOTIN ? list + 2 : list;\n\ti = 0;\n\n\twhile(p) {\n\t\tconst char *word = p;\n\t\tp = strchr(p, ',');\n\t\tres[i++] = p ? xstrndup(word, p - word) : xstrdup(word);\n\t\tif (p)\n\t\t\tp++;\n\t}\n\tres[i] = NULL;\n\treturn res;\nerr:\n\t*flag = 0;\n\tfree(res);\n\texit(BLKID_EXIT_OTHER);\n}\n\nstatic void free_types_list(char *list[])\n{\n\tchar **n;\n\n\tif (!list)\n\t\treturn;\n\tfor (n = list; *n; n++)\n\t\tfree(*n);\n\tfree(list);\n}\n\nint main(int argc, char **argv)\n{\n\tblkid_cache cache = NULL;\n\tchar **devices = NULL;\n\tchar *show[128] = { NULL, };\n\tchar *search_type = NULL, *search_value = NULL;\n\tchar *read = NULL;\n\tint fltr_usage = 0;\n\tchar **fltr_type = NULL;\n\tint fltr_flag = BLKID_FLTR_ONLYIN;\n\tunsigned int numdev = 0, numtag = 0;\n\tint version = 0;\n\tint err = BLKID_EXIT_OTHER;\n\tunsigned int i;\n\tint output_format = 0;\n\tint lookup = 0, gc = 0, lowprobe = 0, eval = 0;\n\tint c;\n\tuintmax_t offset = 0, size = 0;\n\n\tstatic const ul_excl_t excl[] = {       /* rows and cols in in ASCII order */\n\t\t{ 'n','u' },\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\n\tshow[0] = NULL;\n\tatexit(close_stdout);\n\n\twhile ((c = getopt (argc, argv,\n\t\t\t    \"c:df:ghilL:n:ko:O:ps:S:t:u:U:w:Vv\")) != EOF) {\n\n\t\terr_exclusive_options(c, NULL, excl, excl_st);\n\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tif (optarg && !*optarg)\n\t\t\t\tread = NULL;\n\t\t\telse\n\t\t\t\tread = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\traw_chars = 1;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\teval++;\n\t\t\tsearch_value = xstrdup(optarg);\n\t\t\tsearch_type = xstrdup(\"LABEL\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tfltr_type = list_to_types(optarg, &fltr_flag);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tfltr_usage = list_to_usage(optarg, &fltr_flag);\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\teval++;\n\t\t\tsearch_value = xstrdup(optarg);\n\t\t\tsearch_type = xstrdup(\"UUID\");\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tlowprobe |= LOWPROBE_TOPOLOGY;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlookup++;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tgc = 1;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t{\n\t\t\tsize_t idx = 0;\n\t\t\tconst char *name = NULL;\n\n\t\t\twhile (blkid_superblocks_get_name(idx++, &name, NULL) == 0)\n\t\t\t\tprintf(\"%s\\n\", name);\n\t\t\texit(EXIT_SUCCESS);\n\t\t}\n\t\tcase 'o':\n\t\t\tif (!strcmp(optarg, \"value\"))\n\t\t\t\toutput_format = OUTPUT_VALUE_ONLY;\n\t\t\telse if (!strcmp(optarg, \"device\"))\n\t\t\t\toutput_format = OUTPUT_DEVICE_ONLY;\n\t\t\telse if (!strcmp(optarg, \"list\"))\n\t\t\t\toutput_format = OUTPUT_PRETTY_LIST;\t/* deprecated */\n\t\t\telse if (!strcmp(optarg, \"udev\"))\n\t\t\t\toutput_format = OUTPUT_UDEV_LIST;\n\t\t\telse if (!strcmp(optarg, \"export\"))\n\t\t\t\toutput_format = OUTPUT_EXPORT_LIST;\n\t\t\telse if (!strcmp(optarg, \"full\"))\n\t\t\t\toutput_format = 0;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Invalid output format %s. \"\n\t\t\t\t\t\"Choose from value,\\n\\t\"\n\t\t\t\t\t\"device, list, udev or full\\n\", optarg);\n\t\t\t\texit(BLKID_EXIT_OTHER);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\toffset = strtosize_or_err(optarg, \"invalid offset argument\");\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tlowprobe |= LOWPROBE_SUPERBLOCKS;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (numtag + 1 >= sizeof(show) / sizeof(*show)) {\n\t\t\t\tfprintf(stderr, \"Too many tags specified\\n\");\n\t\t\t\tusage(err);\n\t\t\t}\n\t\t\tshow[numtag++] = optarg;\n\t\t\tshow[numtag] = NULL;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tsize = strtosize_or_err(optarg, \"invalid size argument\");\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (search_type) {\n\t\t\t\tfprintf(stderr, \"Can only search for \"\n\t\t\t\t\t\t\"one NAME=value pair\\n\");\n\t\t\t\tusage(err);\n\t\t\t}\n\t\t\tif (blkid_parse_tag_string(optarg,\n\t\t\t\t\t\t   &search_type,\n\t\t\t\t\t\t   &search_value)) {\n\t\t\t\tfprintf(stderr, \"-t needs NAME=value pair\\n\");\n\t\t\t\tusage(err);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'V':\n\t\tcase 'v':\n\t\t\tversion = 1;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\t/* ignore - backward compatibility */\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\terr = 0;\n\t\t\t/* fallthrough */\n\t\tdefault:\n\t\t\tusage(err);\n\t\t}\n\t}\n\n\n\t/* The rest of the args are device names */\n\tif (optind < argc) {\n\t\tdevices = xcalloc(argc - optind, sizeof(char *));\n\t\twhile (optind < argc)\n\t\t\tdevices[numdev++] = argv[optind++];\n\t}\n\n\tif (version) {\n\t\tprint_version(stdout);\n\t\tgoto exit;\n\t}\n\n\t/* convert LABEL/UUID lookup to evaluate request */\n\tif (lookup && output_format == OUTPUT_DEVICE_ONLY && search_type &&\n\t    (!strcmp(search_type, \"LABEL\") || !strcmp(search_type, \"UUID\"))) {\n\t\teval++;\n\t\tlookup = 0;\n\t}\n\n\tif (!lowprobe && !eval && blkid_get_cache(&cache, read) < 0)\n\t\tgoto exit;\n\n\tif (gc) {\n\t\tblkid_gc_cache(cache);\n\t\terr = 0;\n\t\tgoto exit;\n\t}\n\terr = BLKID_EXIT_NOTFOUND;\n\n\tif (eval == 0 && (output_format & OUTPUT_PRETTY_LIST)) {\n\t\tif (lowprobe) {\n\t\t\tfprintf(stderr, \"The low-level probing mode does not \"\n\t\t\t\t\t\"support 'list' output format\\n\");\n\t\t\texit(BLKID_EXIT_OTHER);\n\t\t}\n\t\tpretty_print_dev(NULL);\n\t}\n\n\tif (lowprobe) {\n\t\t/*\n\t\t * Low-level API\n\t\t */\n\t\tblkid_probe pr;\n\n\t\tif (!numdev) {\n\t\t\tfprintf(stderr, \"The low-level probing mode \"\n\t\t\t\t\t\"requires a device\\n\");\n\t\t\texit(BLKID_EXIT_OTHER);\n\t\t}\n\n\t\t/* automatically enable 'export' format for I/O Limits */\n\t\tif (!output_format  && (lowprobe & LOWPROBE_TOPOLOGY))\n\t\t\toutput_format = OUTPUT_EXPORT_LIST;\n\n\t\tpr = blkid_new_probe();\n\t\tif (!pr)\n\t\t\tgoto exit;\n\n\t\tif (lowprobe & LOWPROBE_SUPERBLOCKS) {\n\t\t\tblkid_probe_set_superblocks_flags(pr,\n\t\t\t\tBLKID_SUBLKS_LABEL | BLKID_SUBLKS_UUID |\n\t\t\t\tBLKID_SUBLKS_TYPE | BLKID_SUBLKS_SECTYPE |\n\t\t\t\tBLKID_SUBLKS_USAGE | BLKID_SUBLKS_VERSION);\n\n\t\t\tif (fltr_usage && blkid_probe_filter_superblocks_usage(\n\t\t\t\t\t\tpr, fltr_flag, fltr_usage))\n\t\t\t\tgoto exit;\n\n\t\t\telse if (fltr_type && blkid_probe_filter_superblocks_type(\n\t\t\t\t\t\tpr, fltr_flag, fltr_type))\n\t\t\t\tgoto exit;\n\t\t}\n\n\t\tfor (i = 0; i < numdev; i++) {\n\t\t\terr = lowprobe_device(pr, devices[i], lowprobe, show,\n\t\t\t\t\toutput_format,\n\t\t\t\t\t(blkid_loff_t) offset,\n\t\t\t\t\t(blkid_loff_t) size);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\tblkid_free_probe(pr);\n\t} else if (eval) {\n\t\t/*\n\t\t * Evaluate API\n\t\t */\n\t\tchar *res = blkid_evaluate_tag(search_type, search_value, NULL);\n\t\tif (res) {\n\t\t\terr = 0;\n\t\t\tprintf(\"%s\\n\", res);\n\t\t}\n\t} else if (lookup) {\n\t\t/*\n\t\t * Classic (cache based) API\n\t\t */\n\t\tblkid_dev dev;\n\n\t\tif (!search_type) {\n\t\t\tfprintf(stderr, \"The lookup option requires a \"\n\t\t\t\t\"search type specified using -t\\n\");\n\t\t\texit(BLKID_EXIT_OTHER);\n\t\t}\n\t\t/* Load any additional devices not in the cache */\n\t\tfor (i = 0; i < numdev; i++)\n\t\t\tblkid_get_dev(cache, devices[i], BLKID_DEV_NORMAL);\n\n\t\tif ((dev = blkid_find_dev_with_tag(cache, search_type,\n\t\t\t\t\t\t   search_value))) {\n\t\t\tprint_tags(dev, show, output_format);\n\t\t\terr = 0;\n\t\t}\n\t/* If we didn't specify a single device, show all available devices */\n\t} else if (!numdev) {\n\t\tblkid_dev_iterate\titer;\n\t\tblkid_dev\t\tdev;\n\n\t\tblkid_probe_all(cache);\n\n\t\titer = blkid_dev_iterate_begin(cache);\n\t\tblkid_dev_set_search(iter, search_type, search_value);\n\t\twhile (blkid_dev_next(iter, &dev) == 0) {\n\t\t\tdev = blkid_verify(cache, dev);\n\t\t\tif (!dev)\n\t\t\t\tcontinue;\n\t\t\tprint_tags(dev, show, output_format);\n\t\t\terr = 0;\n\t\t}\n\t\tblkid_dev_iterate_end(iter);\n\t/* Add all specified devices to cache (optionally display tags) */\n\t} else for (i = 0; i < numdev; i++) {\n\t\tblkid_dev dev = blkid_get_dev(cache, devices[i],\n\t\t\t\t\t\t  BLKID_DEV_NORMAL);\n\n\t\tif (dev) {\n\t\t\tif (search_type &&\n\t\t\t    !blkid_dev_has_tag(dev, search_type,\n\t\t\t\t\t       search_value))\n\t\t\t\tcontinue;\n\t\t\tprint_tags(dev, show, output_format);\n\t\t\terr = 0;\n\t\t}\n\t}\n\nexit:\n\tfree(search_type);\n\tfree(search_value);\n\tfree_types_list(fltr_type);\n\tif (!lowprobe && !eval)\n\t\tblkid_put_cache(cache);\n\tfree(devices);\n\treturn err;\n}\n"], "fixing_code": ["/*\n * read.c - read the blkid cache from disk, to avoid scanning all devices\n *\n * Copyright (C) 2001, 2003 Theodore Y. Ts'o\n * Copyright (C) 2001 Andreas Dilger\n *\n * %Begin-Header%\n * This file may be redistributed under the terms of the\n * GNU Lesser General Public License.\n * %End-Header%\n */\n\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n\n#include \"blkidP.h\"\n\n#ifdef HAVE_STDLIB_H\n# ifndef _XOPEN_SOURCE\n#  define _XOPEN_SOURCE 600\t/* for inclusion of strtoull */\n# endif\n# include <stdlib.h>\n#endif\n\n#ifdef HAVE_STRTOULL\n#define STRTOULL strtoull /* defined in stdlib.h if you try hard enough */\n#else\n/* FIXME: need to support real strtoull here */\n#define STRTOULL strtoul\n#endif\n\n#ifdef TEST_PROGRAM\n#define blkid_debug_dump_dev(dev)\t(debug_dump_dev(dev))\nstatic void debug_dump_dev(blkid_dev dev);\n#endif\n\n/*\n * File format:\n *\n *\t<device [<NAME=\"value\"> ...]>device_name</device>\n *\n *\tThe following tags are required for each entry:\n *\t<ID=\"id\">\tunique (within this file) ID number of this device\n *\t<TIME=\"sec.usec\"> (time_t and suseconds_t) time this entry was last\n *\t                 read from disk\n *\t<TYPE=\"type\">\t(detected) type of filesystem/data for this partition\n *\n *\tThe following tags may be present, depending on the device contents\n *\t<LABEL=\"label\">\t(user supplied) label (volume name, etc)\n *\t<UUID=\"uuid\">\t(generated) universally unique identifier (serial no)\n */\n\nstatic char *skip_over_blank(char *cp)\n{\n\twhile (*cp && isspace(*cp))\n\t\tcp++;\n\treturn cp;\n}\n\nstatic char *skip_over_word(char *cp)\n{\n\tchar ch;\n\n\twhile ((ch = *cp)) {\n\t\t/* If we see a backslash, skip the next character */\n\t\tif (ch == '\\\\') {\n\t\t\tcp++;\n\t\t\tif (*cp == '\\0')\n\t\t\t\tbreak;\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (isspace(ch) || ch == '<' || ch == '>')\n\t\t\tbreak;\n\t\tcp++;\n\t}\n\treturn cp;\n}\n\nstatic char *strip_line(char *line)\n{\n\tchar\t*p;\n\n\tline = skip_over_blank(line);\n\n\tp = line + strlen(line) - 1;\n\n\twhile (*line) {\n\t\tif (isspace(*p))\n\t\t\t*p-- = '\\0';\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn line;\n}\n\n#if 0\nstatic char *parse_word(char **buf)\n{\n\tchar *word, *next;\n\n\tword = *buf;\n\tif (*word == '\\0')\n\t\treturn NULL;\n\n\tword = skip_over_blank(word);\n\tnext = skip_over_word(word);\n\tif (*next) {\n\t\tchar *end = next - 1;\n\t\tif (*end == '\"' || *end == '\\'')\n\t\t\t*end = '\\0';\n\t\t*next++ = '\\0';\n\t}\n\t*buf = next;\n\n\tif (*word == '\"' || *word == '\\'')\n\t\tword++;\n\treturn word;\n}\n#endif\n\n/*\n * Start parsing a new line from the cache.\n *\n * line starts with \"<device\" return 1 -> continue parsing line\n * line starts with \"<foo\", empty, or # return 0 -> skip line\n * line starts with other, return -BLKID_ERR_CACHE -> error\n */\nstatic int parse_start(char **cp)\n{\n\tchar *p;\n\n\tp = strip_line(*cp);\n\n\t/* Skip comment or blank lines.  We can't just NUL the first '#' char,\n\t * in case it is inside quotes, or escaped.\n\t */\n\tif (*p == '\\0' || *p == '#')\n\t\treturn 0;\n\n\tif (!strncmp(p, \"<device\", 7)) {\n\t\tDBG(READ, ul_debug(\"found device header: %8s\", p));\n\t\tp += 7;\n\n\t\t*cp = p;\n\t\treturn 1;\n\t}\n\n\tif (*p == '<')\n\t\treturn 0;\n\n\treturn -BLKID_ERR_CACHE;\n}\n\n/* Consume the remaining XML on the line (cosmetic only) */\nstatic int parse_end(char **cp)\n{\n\t*cp = skip_over_blank(*cp);\n\n\tif (!strncmp(*cp, \"</device>\", 9)) {\n\t\tDBG(READ, ul_debug(\"found device trailer %9s\", *cp));\n\t\t*cp += 9;\n\t\treturn 0;\n\t}\n\n\treturn -BLKID_ERR_CACHE;\n}\n\n/*\n * Allocate a new device struct with device name filled in.  Will handle\n * finding the device on lines of the form:\n * <device foo=bar>devname</device>\n * <device>devname<foo>bar</foo></device>\n */\nstatic int parse_dev(blkid_cache cache, blkid_dev *dev, char **cp)\n{\n\tchar *start, *tmp, *end, *name;\n\tint ret;\n\n\tif ((ret = parse_start(cp)) <= 0)\n\t\treturn ret;\n\n\tstart = tmp = strchr(*cp, '>');\n\tif (!start) {\n\t\tDBG(READ, ul_debug(\"blkid: short line parsing dev: %s\", *cp));\n\t\treturn -BLKID_ERR_CACHE;\n\t}\n\tstart = skip_over_blank(start + 1);\n\tend = skip_over_word(start);\n\n\tDBG(READ, ul_debug(\"device should be %*s\",\n\t\t\t       (int)(end - start), start));\n\n\tif (**cp == '>')\n\t\t*cp = end;\n\telse\n\t\t(*cp)++;\n\n\t*tmp = '\\0';\n\n\tif (!(tmp = strrchr(end, '<')) || parse_end(&tmp) < 0) {\n\t\tDBG(READ, ul_debug(\"blkid: missing </device> ending: %s\", end));\n\t} else if (tmp)\n\t\t*tmp = '\\0';\n\n\tif (end - start <= 1) {\n\t\tDBG(READ, ul_debug(\"blkid: empty device name: %s\", *cp));\n\t\treturn -BLKID_ERR_CACHE;\n\t}\n\n\tname = strndup(start, end - start);\n\tif (name == NULL)\n\t\treturn -BLKID_ERR_MEM;\n\n\tDBG(READ, ul_debug(\"found dev %s\", name));\n\n\tif (!(*dev = blkid_get_dev(cache, name, BLKID_DEV_CREATE))) {\n\t\tfree(name);\n\t\treturn -BLKID_ERR_MEM;\n\t}\n\n\tfree(name);\n\treturn 1;\n}\n\n/*\n * Extract a tag of the form NAME=\"value\" from the line.\n */\nstatic int parse_token(char **name, char **value, char **cp)\n{\n\tchar *end;\n\n\tif (!name || !value || !cp)\n\t\treturn -BLKID_ERR_PARAM;\n\n\tif (!(*value = strchr(*cp, '=')))\n\t\treturn 0;\n\n\t**value = '\\0';\n\t*name = strip_line(*cp);\n\t*value = skip_over_blank(*value + 1);\n\n\tif (**value == '\"') {\n\t\tchar *p = end = *value + 1;\n\n\t\t/* convert 'foo\\\"bar'  to 'foo\"bar' */\n\t\twhile (*p) {\n\t\t\tif (*p == '\\\\') {\n\t\t\t\tp++;\n\t\t\t\t*end = *p;\n\t\t\t} else {\n\t\t\t\t*end = *p;\n\t\t\t\tif (*p == '\"')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t\tend++;\n\t\t}\n\n\t\tif (*end != '\"') {\n\t\t\tDBG(READ, ul_debug(\"unbalanced quotes at: %s\", *value));\n\t\t\t*cp = *value;\n\t\t\treturn -BLKID_ERR_CACHE;\n\t\t}\n\t\t(*value)++;\n\t\t*end = '\\0';\n\t\tend = ++p;\n\t} else {\n\t\tend = skip_over_word(*value);\n\t\tif (*end) {\n\t\t\t*end = '\\0';\n\t\t\tend++;\n\t\t}\n\t}\n\t*cp = end;\n\n\treturn 1;\n}\n\n/*\n * Extract a tag of the form <NAME>value</NAME> from the line.\n */\n/*\nstatic int parse_xml(char **name, char **value, char **cp)\n{\n\tchar *end;\n\n\tif (!name || !value || !cp)\n\t\treturn -BLKID_ERR_PARAM;\n\n\t*name = strip_line(*cp);\n\n\tif ((*name)[0] != '<' || (*name)[1] == '/')\n\t\treturn 0;\n\n\tFIXME: finish this.\n}\n*/\n\n/*\n * Extract a tag from the line.\n *\n * Return 1 if a valid tag was found.\n * Return 0 if no tag found.\n * Return -ve error code.\n */\nstatic int parse_tag(blkid_cache cache, blkid_dev dev, char **cp)\n{\n\tchar *name = NULL;\n\tchar *value = NULL;\n\tint ret;\n\n\tif (!cache || !dev)\n\t\treturn -BLKID_ERR_PARAM;\n\n\tif ((ret = parse_token(&name, &value, cp)) <= 0 /* &&\n\t    (ret = parse_xml(&name, &value, cp)) <= 0 */)\n\t\treturn ret;\n\n\t/* Some tags are stored directly in the device struct */\n\tif (!strcmp(name, \"DEVNO\"))\n\t\tdev->bid_devno = STRTOULL(value, 0, 0);\n\telse if (!strcmp(name, \"PRI\"))\n\t\tdev->bid_pri = strtol(value, 0, 0);\n\telse if (!strcmp(name, \"TIME\")) {\n\t\tchar *end = NULL;\n\t\tdev->bid_time = STRTOULL(value, &end, 0);\n\t\tif (end && *end == '.')\n\t\t\tdev->bid_utime = STRTOULL(end + 1, 0, 0);\n\t} else\n\t\tret = blkid_set_tag(dev, name, value, strlen(value));\n\n\tDBG(READ, ul_debug(\"    tag: %s=\\\"%s\\\"\", name, value));\n\n\treturn ret < 0 ? ret : 1;\n}\n\n/*\n * Parse a single line of data, and return a newly allocated dev struct.\n * Add the new device to the cache struct, if one was read.\n *\n * Lines are of the form <device [TAG=\"value\" ...]>/dev/foo</device>\n *\n * Returns -ve value on error.\n * Returns 0 otherwise.\n * If a valid device was read, *dev_p is non-NULL, otherwise it is NULL\n * (e.g. comment lines, unknown XML content, etc).\n */\nstatic int blkid_parse_line(blkid_cache cache, blkid_dev *dev_p, char *cp)\n{\n\tblkid_dev dev;\n\tint ret;\n\n\tif (!cache || !dev_p)\n\t\treturn -BLKID_ERR_PARAM;\n\n\t*dev_p = NULL;\n\n\tDBG(READ, ul_debug(\"line: %s\", cp));\n\n\tif ((ret = parse_dev(cache, dev_p, &cp)) <= 0)\n\t\treturn ret;\n\n\tdev = *dev_p;\n\n\twhile ((ret = parse_tag(cache, dev, &cp)) > 0) {\n\t\t;\n\t}\n\n\tif (dev->bid_type == NULL) {\n\t\tDBG(READ, ul_debug(\"blkid: device %s has no TYPE\",dev->bid_name));\n\t\tblkid_free_dev(dev);\n\t\tgoto done;\n\t}\n\n\tDBG(READ, blkid_debug_dump_dev(dev));\n\ndone:\n\treturn ret;\n}\n\n/*\n * Parse the specified filename, and return the data in the supplied or\n * a newly allocated cache struct.  If the file doesn't exist, return a\n * new empty cache struct.\n */\nvoid blkid_read_cache(blkid_cache cache)\n{\n\tFILE *file;\n\tchar buf[4096];\n\tint fd, lineno = 0;\n\tstruct stat st;\n\n\tif (!cache)\n\t\treturn;\n\n\t/*\n\t * If the file doesn't exist, then we just return an empty\n\t * struct so that the cache can be populated.\n\t */\n\tif ((fd = open(cache->bic_filename, O_RDONLY|O_CLOEXEC)) < 0)\n\t\treturn;\n\tif (fstat(fd, &st) < 0)\n\t\tgoto errout;\n\tif ((st.st_mtime == cache->bic_ftime) ||\n\t    (cache->bic_flags & BLKID_BIC_FL_CHANGED)) {\n\t\tDBG(CACHE, ul_debug(\"skipping re-read of %s\",\n\t\t\t\t\tcache->bic_filename));\n\t\tgoto errout;\n\t}\n\n\tDBG(CACHE, ul_debug(\"reading cache file %s\",\n\t\t\t\tcache->bic_filename));\n\n\tfile = fdopen(fd, \"r\" UL_CLOEXECSTR);\n\tif (!file)\n\t\tgoto errout;\n\n\twhile (fgets(buf, sizeof(buf), file)) {\n\t\tblkid_dev dev;\n\t\tunsigned int end;\n\n\t\tlineno++;\n\t\tif (buf[0] == 0)\n\t\t\tcontinue;\n\t\tend = strlen(buf) - 1;\n\t\t/* Continue reading next line if it ends with a backslash */\n\t\twhile (end < (sizeof(buf) - 2) && buf[end] == '\\\\' &&\n\t\t       fgets(buf + end, sizeof(buf) - end, file)) {\n\t\t\tend = strlen(buf) - 1;\n\t\t\tlineno++;\n\t\t}\n\n\t\tif (blkid_parse_line(cache, &dev, buf) < 0) {\n\t\t\tDBG(READ, ul_debug(\"blkid: bad format on line %d\", lineno));\n\t\t\tcontinue;\n\t\t}\n\t}\n\tfclose(file);\n\n\t/*\n\t * Initially we do not need to write out the cache file.\n\t */\n\tcache->bic_flags &= ~BLKID_BIC_FL_CHANGED;\n\tcache->bic_ftime = st.st_mtime;\n\n\treturn;\nerrout:\n\tclose(fd);\n\treturn;\n}\n\n#ifdef TEST_PROGRAM\nstatic void debug_dump_dev(blkid_dev dev)\n{\n\tstruct list_head *p;\n\n\tif (!dev) {\n\t\tprintf(\"  dev: NULL\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"  dev: name = %s\\n\", dev->bid_name);\n\tprintf(\"  dev: DEVNO=\\\"0x%0llx\\\"\\n\", (long long)dev->bid_devno);\n\tprintf(\"  dev: TIME=\\\"%ld.%ld\\\"\\n\", (long)dev->bid_time, (long)dev->bid_utime);\n\tprintf(\"  dev: PRI=\\\"%d\\\"\\n\", dev->bid_pri);\n\tprintf(\"  dev: flags = 0x%08X\\n\", dev->bid_flags);\n\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\t\tif (tag)\n\t\t\tprintf(\"    tag: %s=\\\"%s\\\"\\n\", tag->bit_name,\n\t\t\t       tag->bit_val);\n\t\telse\n\t\t\tprintf(\"    tag: NULL\\n\");\n\t}\n\tprintf(\"\\n\");\n}\n\nint main(int argc, char**argv)\n{\n\tblkid_cache cache = NULL;\n\tint ret;\n\n\tblkid_init_debug(BLKID_DEBUG_ALL);\n\tif (argc > 2) {\n\t\tfprintf(stderr, \"Usage: %s [filename]\\n\"\n\t\t\t\"Test parsing of the cache (filename)\\n\", argv[0]);\n\t\texit(1);\n\t}\n\tif ((ret = blkid_get_cache(&cache, argv[1])) < 0)\n\t\tfprintf(stderr, \"error %d reading cache file %s\\n\", ret,\n\t\t\targv[1] ? argv[1] : blkid_get_cache_filename(NULL));\n\n\tblkid_put_cache(cache);\n\n\treturn ret;\n}\n#endif\n", "/*\n * save.c - write the cache struct to disk\n *\n * Copyright (C) 2001 by Andreas Dilger\n * Copyright (C) 2003 Theodore Ts'o\n *\n * %Begin-Header%\n * This file may be redistributed under the terms of the\n * GNU Lesser General Public License.\n * %End-Header%\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n\n#include \"closestream.h\"\n\n#include \"blkidP.h\"\n\n\nstatic void save_quoted(const char *data, FILE *file)\n{\n\tconst char *p;\n\n\tfputc('\"', file);\n\tfor (p = data; p && *p; p++) {\n\t\tif ((unsigned char) *p == 0x22 ||\t\t/* \" */\n\t\t    (unsigned char) *p == 0x5c)\t\t\t/* \\ */\n\t\t\tfputc('\\\\', file);\n\n\t\tfputc(*p, file);\n\t}\n\tfputc('\"', file);\n}\nstatic int save_dev(blkid_dev dev, FILE *file)\n{\n\tstruct list_head *p;\n\n\tif (!dev || dev->bid_name[0] != '/')\n\t\treturn 0;\n\n\tDBG(SAVE, ul_debug(\"device %s, type %s\", dev->bid_name, dev->bid_type ?\n\t\t   dev->bid_type : \"(null)\"));\n\n\tfprintf(file, \"<device DEVNO=\\\"0x%04lx\\\" TIME=\\\"%ld.%ld\\\"\",\n\t\t\t(unsigned long) dev->bid_devno,\n\t\t\t(long) dev->bid_time,\n\t\t\t(long) dev->bid_utime);\n\n\tif (dev->bid_pri)\n\t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);\n\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\n\t\tfputc(' ', file);\t\t\t/* space between tags */\n\t\tfputs(tag->bit_name, file);\t\t/* tag NAME */\n\t\tfputc('=', file);\t\t\t/* separator between NAME and VALUE */\n\t\tsave_quoted(tag->bit_val, file);\t/* tag \"VALUE\" */\n\t}\n\tfprintf(file, \">%s</device>\\n\", dev->bid_name);\n\n\treturn 0;\n}\n\n/*\n * Write out the cache struct to the cache file on disk.\n */\nint blkid_flush_cache(blkid_cache cache)\n{\n\tstruct list_head *p;\n\tchar *tmp = NULL;\n\tchar *opened = NULL;\n\tchar *filename;\n\tFILE *file = NULL;\n\tint fd, ret = 0;\n\tstruct stat st;\n\n\tif (!cache)\n\t\treturn -BLKID_ERR_PARAM;\n\n\tif (list_empty(&cache->bic_devs) ||\n\t    !(cache->bic_flags & BLKID_BIC_FL_CHANGED)) {\n\t\tDBG(SAVE, ul_debug(\"skipping cache file write\"));\n\t\treturn 0;\n\t}\n\n\tfilename = cache->bic_filename ? cache->bic_filename :\n\t\t\t\t\t blkid_get_cache_filename(NULL);\n\tif (!filename)\n\t\treturn -BLKID_ERR_PARAM;\n\n\tif (strncmp(filename,\n\t    BLKID_RUNTIME_DIR \"/\", sizeof(BLKID_RUNTIME_DIR)) == 0) {\n\n\t\t/* default destination, create the directory if necessary */\n\t\tif (stat(BLKID_RUNTIME_DIR, &st)\n\t\t    && errno == ENOENT\n\t\t    && mkdir(BLKID_RUNTIME_DIR, S_IWUSR|\n\t\t\t\t\t\tS_IRUSR|S_IRGRP|S_IROTH|\n\t\t\t\t\t\tS_IXUSR|S_IXGRP|S_IXOTH) != 0\n\t\t    && errno != EEXIST) {\n\t\t\tDBG(SAVE, ul_debug(\"can't create %s directory for cache file\",\n\t\t\t\t\tBLKID_RUNTIME_DIR));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* If we can't write to the cache file, then don't even try */\n\tif (((ret = stat(filename, &st)) < 0 && errno != ENOENT) ||\n\t    (ret == 0 && access(filename, W_OK) < 0)) {\n\t\tDBG(SAVE, ul_debug(\"can't write to cache file %s\", filename));\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Try and create a temporary file in the same directory so\n\t * that in case of error we don't overwrite the cache file.\n\t * If the cache file doesn't yet exist, it isn't a regular\n\t * file (e.g. /dev/null or a socket), or we couldn't create\n\t * a temporary file then we open it directly.\n\t */\n\tif (ret == 0 && S_ISREG(st.st_mode)) {\n\t\ttmp = malloc(strlen(filename) + 8);\n\t\tif (tmp) {\n\t\t\tsprintf(tmp, \"%s-XXXXXX\", filename);\n\t\t\tfd = mkostemp(tmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n\t\t\tif (fd >= 0) {\n\t\t\t\tif (fchmod(fd, 0644) != 0)\n\t\t\t\t\tDBG(SAVE, ul_debug(\"%s: fchmod failed\", filename));\n\t\t\t\telse if ((file = fdopen(fd, \"w\" UL_CLOEXECSTR)))\n\t\t\t\t\topened = tmp;\n\t\t\t\tif (!file)\n\t\t\t\t\tclose(fd);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!file) {\n\t\tfile = fopen(filename, \"w\" UL_CLOEXECSTR);\n\t\topened = filename;\n\t}\n\n\tDBG(SAVE, ul_debug(\"writing cache file %s (really %s)\",\n\t\t   filename, opened));\n\n\tif (!file) {\n\t\tret = errno;\n\t\tgoto errout;\n\t}\n\n\tlist_for_each(p, &cache->bic_devs) {\n\t\tblkid_dev dev = list_entry(p, struct blkid_struct_dev, bid_devs);\n\t\tif (!dev->bid_type || (dev->bid_flags & BLKID_BID_FL_REMOVABLE))\n\t\t\tcontinue;\n\t\tif ((ret = save_dev(dev, file)) < 0)\n\t\t\tbreak;\n\t}\n\n\tif (ret >= 0) {\n\t\tcache->bic_flags &= ~BLKID_BIC_FL_CHANGED;\n\t\tret = 1;\n\t}\n\n\tif (close_stream(file) != 0)\n\t\tDBG(SAVE, ul_debug(\"write failed: %s\", filename));\n\n\tif (opened != filename) {\n\t\tif (ret < 0) {\n\t\t\tunlink(opened);\n\t\t\tDBG(SAVE, ul_debug(\"unlinked temp cache %s\", opened));\n\t\t} else {\n\t\t\tchar *backup;\n\n\t\t\tbackup = malloc(strlen(filename) + 5);\n\t\t\tif (backup) {\n\t\t\t\tsprintf(backup, \"%s.old\", filename);\n\t\t\t\tunlink(backup);\n\t\t\t\tif (link(filename, backup)) {\n\t\t\t\t\tDBG(SAVE, ul_debug(\"can't link %s to %s\",\n\t\t\t\t\t\t\tfilename, backup));\n\t\t\t\t}\n\t\t\t\tfree(backup);\n\t\t\t}\n\t\t\tif (rename(opened, filename)) {\n\t\t\t\tret = errno;\n\t\t\t\tDBG(SAVE, ul_debug(\"can't rename %s to %s\",\n\t\t\t\t\t\topened, filename));\n\t\t\t} else {\n\t\t\t\tDBG(SAVE, ul_debug(\"moved temp cache %s\", opened));\n\t\t\t}\n\t\t}\n\t}\n\nerrout:\n\tfree(tmp);\n\tif (filename != cache->bic_filename)\n\t\tfree(filename);\n\treturn ret;\n}\n\n#ifdef TEST_PROGRAM\nint main(int argc, char **argv)\n{\n\tblkid_cache cache = NULL;\n\tint ret;\n\n\tblkid_init_debug(BLKID_DEBUG_ALL);\n\tif (argc > 2) {\n\t\tfprintf(stderr, \"Usage: %s [filename]\\n\"\n\t\t\t\"Test loading/saving a cache (filename)\\n\", argv[0]);\n\t\texit(1);\n\t}\n\n\tif ((ret = blkid_get_cache(&cache, \"/dev/null\")) != 0) {\n\t\tfprintf(stderr, \"%s: error creating cache (%d)\\n\",\n\t\t\targv[0], ret);\n\t\texit(1);\n\t}\n\tif ((ret = blkid_probe_all(cache)) < 0) {\n\t\tfprintf(stderr, \"error (%d) probing devices\\n\", ret);\n\t\texit(1);\n\t}\n\tcache->bic_filename = strdup(argv[1]);\n\n\tif ((ret = blkid_flush_cache(cache)) < 0) {\n\t\tfprintf(stderr, \"error (%d) saving cache\\n\", ret);\n\t\texit(1);\n\t}\n\n\tblkid_put_cache(cache);\n\n\treturn ret;\n}\n#endif\n", ".\\\" Copyright 2000 Andreas Dilger (adilger@turbolinux.com)\n.\\\"\n.\\\" This man page was created for blkid from e2fsprogs-1.25.\n.\\\"\n.\\\" This file may be copied under the terms of the GNU Public License.\n.\\\"\n.\\\" Based on uuidgen, Mon Sep 17 10:42:12 2000, Andreas Dilger\n.TH BLKID 8 \"March 2013\" \"util-linux\" \"System Administration\"\n.SH NAME\nblkid \\- locate/print block device attributes\n.SH SYNOPSIS\n.B blkid\n.BI \\-L \" label\"\n|\n.BI \\-U \" uuid\"\n\n.B blkid\n.RB [ \\-dghlv ]\n.RB [ \\-c\n.IR file ]\n.RB [ \\-o\n.IR format ]\n.RB [ \\-s\n.IR tag ]\n.in +6\n.RB [ \\-t\n.IR NAME=value ]\n.RI [ device \" ...]\"\n.in -6\n\n.B blkid\n.BR -p \" [\" \\-O\n.IR offset ]\n.RB [ \\-o\n.IR format ]\n.RB [ \\-S\n.IR size ]\n.RB [ \\-s\n.IR tag ]\n.in +9\n.RB [ \\-n\n.IR list ]\n.RB [ \\-u\n.IR list ]\n.IR device \" ...\"\n.in -9\n\n.B blkid\n.BR -i \" [\" \\-o\n.IR format ]\n.RB [ \\-s\n.IR tag ]\n.IR device \" ...\"\n\n.SH DESCRIPTION\nThe\n.B blkid\nprogram is the command-line interface to working with the\n.BR libblkid (3)\nlibrary.  It can determine the type of content (e.g. filesystem or swap)\nthat a block device holds, and also the attributes (tokens, NAME=value pairs)\nfrom the content metadata (e.g. LABEL or UUID fields).\n.PP\nIt is recommended to use\n.BR lsblk (8)\ncommand to get information about block devices rather than blkid.\n.BR lsblk (8)\nprovides more information, better control on output formatting and it does not\nrequire root permissions to get actual information.\n.PP\nWhen\n.I device\nis specified, tokens from only this device are displayed.\nIt is possible to specify multiple\n.I device\narguments on the command line.\nIf none is given, all devices which appear in\n.I /proc/partitions\nare shown, if they are recognized.\n.PP\nNote that\n.B blkid\nreads information directly from devices and for non-root users\nit returns cached unverified information.  It is better to use\n.B lsblk --fs\nto get a user-friendly overview of filesystems and devices.\n.BR lsblk (8)\nis also easy to use in scripts.\n.B blkid\nis mostly designed for system services and to test libblkid functionality.\n.PP\n.B blkid\nhas two main forms of operation: either searching for a device with a\nspecific NAME=value pair, or displaying NAME=value pairs for one or\nmore specified devices.\n.SH OPTIONS\nThe \\fIsize\\fR and \\fIoffset\\fR arguments may be followed by the multiplicative\nsuffixes like KiB (=1024), MiB (=1024*1024), and so on for GiB, TiB, PiB, EiB, ZiB and YiB\n(the \"iB\" is optional, e.g. \"K\" has the same meaning as \"KiB\"), or the suffixes\nKB (=1000), MB (=1000*1000), and so on for GB, TB, PB, EB, ZB and YB.\n.TP\n.BI \\-c \" cachefile\"\nRead from\n.I cachefile\ninstead of reading from the default cache file (see the CONFIGURATION FILE section\nfor more details).  If you want to start with a clean cache (i.e. don't report\ndevices previously scanned but not necessarily available at this time), specify\n.IR /dev/null .\n.TP\n.B \\-d\nDon't encode non-printing characters.  The non-printing characters are encoded\nby ^ and M- notation by default.  Note that the \\fB-o udev\\fR output format uses\na different encoding which cannot be disabled.\n.TP\n.B \\-g\nPerform a garbage collection pass on the blkid cache to remove\ndevices which no longer exist.\n.TP\n.B \\-h\nDisplay a usage message and exit.\n.TP\n.B \\-i\nDisplay information about I/O Limits (aka I/O topology).  The 'export' output format is\nautomatically enabled.  This option can be used together with the \\fB-p\\fR option.\n.TP\n.B \\-k\nList all known filesystems and RAIDs and exit.\n.TP\n.B \\-l\nLook up only one device that matches the search parameter specified with the \\fB-t\\fR\noption.  If there are multiple devices that match the specified search\nparameter, then the device with the highest priority is returned, and/or\nthe first device found at a given priority.  Device types in order of\ndecreasing priority are: Device Mapper, EVMS, LVM, MD, and finally regular\nblock devices.  If this option is not specified,\n.B blkid\nwill print all of the devices that match the search parameter.\n.TP\n.BI \\-L \" label\"\nLook up the device that uses this filesystem \\fIlabel\\fR; this is equal to\n.BR \"-l -o device -t LABEL=\\fIlabel\\fR\" .\nThis lookup method is able to reliably use /dev/disk/by-label\nudev symlinks (dependent on a setting in /etc/blkid.conf).  Avoid using the\nsymlinks directly; it is not reliable to use the symlinks without verification.\nThe \\fB-L\\fR option works on systems with and without udev.\n\nUnfortunately, the original\n.BR blkid (8)\nfrom e2fsprogs uses the \\fB-L\\fR option as a\nsynonym for \\fB-o list\\fR.  For better portability, use \\fB-l -o device\n-t LABEL=\\fIlabel\\fR and \\fB-o list\\fR in your scripts rather than the \\fB-L\\fR option.\n.TP\n.BI \\-n \" list\"\nRestrict the probing functions to the specified (comma-separated) \\fIlist\\fR of\nsuperblock types (names).\nThe list items may be prefixed with \"no\" to specify the types which should be ignored.\nFor example:\n.sp\n  blkid -p -n vfat,ext3,ext4 /dev/sda1\n.sp\nprobes for vfat, ext3 and ext4 filesystems, and\n.sp\n  blkid -p -n nominix /dev/sda1\n.sp\nprobes for all supported formats except minix filesystems.\nThis option is only useful together with \\fB-p\\fR.\n.TP\n.BI \\-o \" format\"\nUse the specified output format.  Note that the order of variables and\ndevices is not fixed.  See also option \\fB-s\\fR.  The\n.I format\nparameter may be:\n.RS\n.TP\n.B full\nprint all tags (the default)\n.TP\n.B value\nprint the value of the tags\n.TP\n.B list\nprint the devices in a user-friendly format; this output format is unsupported\nfor low-level probing (\\fB-p\\fR or \\fB-i\\fR).\n\nThis output format is \\fBDEPRECATED\\fR in favour of the\n.BR lsblk (8)\ncommand.\n.TP\n.B device\nprint the device name only; this output format is always enabled for the \\fB-L\\fR\nand \\fB-U\\fR options\n.TP\n.B udev\nprint key=\"value\" pairs for easy import into the udev environment; the keys are\nprefixed by ID_FS_ or ID_PART_ prefixes\n\nThe udev output returns the ID_FS_AMBIVALENT tag if more superblocks are detected,\nand ID_PART_ENTRY_* tags are always returned for all partitions including empty\npartitions.  This output format is \\fBDEPRECATED\\fR.\n.TP\n.B export\nprint key=value pairs for easy import into the environment; this output format\nis automatically enabled when I/O Limits (\\fB-i\\fR option) are requested.\n\nThe non-printing characters are encoded by ^ and M- notation and all\npotentially unsafe characters are escaped.\n.RE\n.TP\n.BI \\-O \" offset\"\nProbe at the given \\fIoffset\\fR (only useful with \\fB-p\\fR).  This option can be\nused together with the \\fB-i\\fR option.\n.TP\n.BI \\-p\nSwitch to low-level superblock probing mode (bypassing the cache).\n\nNote that low-level probing also returns information about partition table type\n(PTTYPE tag) and partitions (PART_ENTRY_* tags).\n.TP\n.BI \\-s \" tag\"\nFor each (specified) device, show only the tags that match\n.IR tag .\nIt is possible to specify multiple\n.B \\-s\noptions.  If no tag is specified, then all tokens are shown for all\n(specified) devices.\nIn order to just refresh the cache without showing any tokens, use\n.B \"-s none\"\nwith no other options.\n.TP\n.BI \\-S \" size\"\nOverride the size of device/file (only useful with \\fB-p\\fR).\n.TP\n.BI \\-t \" NAME\" = value\nSearch for block devices with tokens named\n.I NAME\nthat have the value\n.IR value ,\nand display any devices which are found.\nCommon values for\n.I NAME\ninclude\n.BR TYPE ,\n.BR LABEL ,\nand\n.BR UUID .\nIf there are no devices specified on the command line, all block devices\nwill be searched; otherwise only the specified devices are searched.\n.TP\n.BI \\-u \" list\"\nRestrict the probing functions to the specified (comma-separated) \\fIlist\\fR of \"usage\" types.\nSupported usage types are: filesystem, raid, crypto and other.  The list items may be\nprefixed with \"no\" to specify the usage types which should be ignored.  For example:\n.sp\n  blkid -p -u filesystem,other /dev/sda1\n.sp\nprobes for all filesystem and other (e.g. swap) formats, and\n.sp\n  blkid -p -u noraid /dev/sda1\n.sp\nprobes for all supported formats except RAIDs.\nThis option is only useful together with \\fB-p\\fR.\n.TP\n.BI \\-U \" uuid\"\nLook up the device that uses this filesystem \\fIuuid\\fR.  For more details see the \\fB-L\\fR option.\n.TP\n.B \\-V\nDisplay version number and exit.\n.SH \"RETURN CODE\"\nIf the specified token was found, or if any tags were shown from (specified)\ndevices, 0 is returned.\n\nIf the specified token was not found, or no (specified) devices could be\nidentified, an exit code of 2 is returned.\n\nFor usage or other errors, an exit code of 4 is returned.\n\nIf an ambivalent low-level probing result was detected, an exit code of 8 is\nreturned.\n.SH CONFIGURATION FILE\nThe standard location of the\n.I /etc/blkid.conf\nconfig file can be overridden by the environment variable BLKID_CONF.\nThe following options control the libblkid library:\n.TP\n.I SEND_UEVENT=<yes|not>\nSends uevent when\n.I /dev/disk/by-{label,uuid,partuuid,partlabel}/\nsymlink does not match with LABEL, UUID, PARTUUID or PARTLABEL on the device.  Default is \"yes\".\n.TP\n.I CACHE_FILE=<path>\nOverrides the standard location of the cache file.  This setting can be\noverridden by the environment variable BLKID_FILE.  Default is\n.IR /run/blkid/blkid.tab ,\nor\n.I /etc/blkid.tab\non systems without a /run directory.\n.TP\n.I EVALUATE=<methods>\nDefines LABEL and UUID evaluation method(s).  Currently, the libblkid library\nsupports the \"udev\" and \"scan\" methods.  More than one method may be specified in\na comma-separated list.  Default is \"udev,scan\".  The \"udev\" method uses udev\n.I /dev/disk/by-*\nsymlinks and the \"scan\" method scans all block devices from the\n.I /proc/partitions\nfile.\n.SH AUTHOR\n.B blkid\nwas written by Andreas Dilger for libblkid and improved by Theodore Ts'o\nand Karel Zak.\n.SH ENVIRONMENT\n.IP \"Setting LIBBLKID_DEBUG=all enables debug output.\"\n.SH SEE ALSO\n.BR libblkid (3),\n.BR findfs (8),\n.BR wipefs (8),\n.BR lsblk (8),\n.SH AVAILABILITY\nThe blkid command is part of the util-linux package and is available from\nftp://ftp.kernel.org/pub/linux/utils/util-linux/.\n", "/*\n * blkid.c - User command-line interface for libblkid\n *\n * Copyright (C) 2001 Andreas Dilger\n *\n * %Begin-Header%\n * This file may be redistributed under the terms of the\n * GNU Lesser General Public License.\n * %End-Header%\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#ifdef HAVE_GETOPT_H\n#include <getopt.h>\n#else\nextern int getopt(int argc, char * const argv[], const char *optstring);\nextern char *optarg;\nextern int optind;\n#endif\n\n#define OUTPUT_VALUE_ONLY\t(1 << 1)\n#define OUTPUT_DEVICE_ONLY\t(1 << 2)\n#define OUTPUT_PRETTY_LIST\t(1 << 3)\t\t/* deprecated */\n#define OUTPUT_UDEV_LIST\t(1 << 4)\t\t/* deprecated */\n#define OUTPUT_EXPORT_LIST\t(1 << 5)\n\n#define LOWPROBE_TOPOLOGY\t(1 << 1)\n#define LOWPROBE_SUPERBLOCKS\t(1 << 2)\n\n#define BLKID_EXIT_NOTFOUND\t2\t/* token or device not found */\n#define BLKID_EXIT_OTHER\t4\t/* bad usage or other error */\n#define BLKID_EXIT_AMBIVAL\t8\t/* ambivalent low-level probing detected */\n\n#include <blkid.h>\n\n#include \"ismounted.h\"\n\n#define STRTOXX_EXIT_CODE\tBLKID_EXIT_OTHER\t/* strtoxx_or_err() */\n#include \"strutils.h\"\n#define OPTUTILS_EXIT_CODE\tBLKID_EXIT_OTHER\t/* exclusive_option() */\n#include \"optutils.h\"\n\n#include \"closestream.h\"\n#include \"ttyutils.h\"\n#include \"xalloc.h\"\n\nint raw_chars;\n\nstatic void print_version(FILE *out)\n{\n\tfprintf(out, \"%s from %s  (libblkid %s, %s)\\n\",\n\t\tprogram_invocation_short_name, PACKAGE_STRING,\n\t\tLIBBLKID_VERSION, LIBBLKID_DATE);\n}\n\nstatic void usage(int error)\n{\n\tFILE *out = error ? stderr : stdout;\n\n\tprint_version(out);\n\tfprintf(out,\n\t\t\"Usage:\\n\"\n\t\t\" %1$s -L <label> | -U <uuid>\\n\\n\"\n\t\t\" %1$s [-c <file>] [-ghlLv] [-o <format>] [-s <tag>] \\n\"\n\t\t\"       [-t <token>] [<dev> ...]\\n\\n\"\n\t\t\" %1$s -p [-s <tag>] [-O <offset>] [-S <size>] \\n\"\n\t\t\"       [-o <format>] <dev> ...\\n\\n\"\n\t\t\" %1$s -i [-s <tag>] [-o <format>] <dev> ...\\n\\n\"\n\t\t\"Options:\\n\"\n\t\t\" -c <file>   read from <file> instead of reading from the default\\n\"\n\t\t\"               cache file (-c /dev/null means no cache)\\n\"\n\t\t\" -d          don't encode non-printing characters\\n\"\n\t\t\" -h          print this usage message and exit\\n\"\n\t\t\" -g          garbage collect the blkid cache\\n\"\n\t\t\" -o <format> output format; can be one of:\\n\"\n\t\t\"               value, device, export or full; (default: full)\\n\"\n\t\t\" -k          list all known filesystems/RAIDs and exit\\n\"\n\t\t\" -s <tag>    show specified tag(s) (default show all tags)\\n\"\n\t\t\" -t <token>  find device with a specific token (NAME=value pair)\\n\"\n\t\t\" -l          look up only first device with token specified by -t\\n\"\n\t\t\" -L <label>  convert LABEL to device name\\n\"\n\t\t\" -U <uuid>   convert UUID to device name\\n\"\n\t\t\" -V          print version and exit\\n\"\n\t\t\" <dev>       specify device(s) to probe (default: all devices)\\n\\n\"\n\t\t\"Low-level probing options:\\n\"\n\t\t\" -p          low-level superblocks probing (bypass cache)\\n\"\n\t\t\" -i          gather information about I/O limits\\n\"\n\t\t\" -S <size>   overwrite device size\\n\"\n\t\t\" -O <offset> probe at the given offset\\n\"\n\t\t\" -u <list>   filter by \\\"usage\\\" (e.g. -u filesystem,raid)\\n\"\n\t\t\" -n <list>   filter by filesystem type (e.g. -n vfat,ext3)\\n\"\n\t\t\"\\n\", program_invocation_short_name);\n\n\texit(error);\n}\n\n/*\n * This function does \"safe\" printing.  It will convert non-printable\n * ASCII characters using '^' and M- notation.\n *\n * If 'esc' is defined then escape all chars from esc by \\.\n */\nstatic void safe_print(const char *cp, int len, const char *esc)\n{\n\tunsigned char\tch;\n\n\tif (len < 0)\n\t\tlen = strlen(cp);\n\n\twhile (len--) {\n\t\tch = *cp++;\n\t\tif (!raw_chars) {\n\t\t\tif (ch >= 128) {\n\t\t\t\tfputs(\"M-\", stdout);\n\t\t\t\tch -= 128;\n\t\t\t}\n\t\t\tif ((ch < 32) || (ch == 0x7f)) {\n\t\t\t\tfputc('^', stdout);\n\t\t\t\tch ^= 0x40; /* ^@, ^A, ^B; ^? for DEL */\n\n\t\t\t} else if (esc && strchr(esc, ch))\n\t\t\t\tfputc('\\\\', stdout);\n\t\t}\n\t\tfputc(ch, stdout);\n\t}\n}\n\nstatic int pretty_print_word(const char *str, int max_len,\n\t\t\t     int left_len, int overflow_nl)\n{\n\tint len = strlen(str) + left_len;\n\tint ret = 0;\n\n\tfputs(str, stdout);\n\tif (overflow_nl && len > max_len) {\n\t\tfputc('\\n', stdout);\n\t\tlen = 0;\n\t} else if (len > max_len)\n\t\tret = len - max_len;\n\tdo\n\t\tfputc(' ', stdout);\n\twhile (len++ < max_len);\n\treturn ret;\n}\n\nstatic void pretty_print_line(const char *device, const char *fs_type,\n\t\t\t      const char *label, const char *mtpt,\n\t\t\t      const char *uuid)\n{\n\tstatic int device_len = 10, fs_type_len = 7;\n\tstatic int label_len = 8, mtpt_len = 14;\n\tstatic int term_width = -1;\n\tint len, w;\n\n\tif (term_width < 0) {\n\t\tterm_width = get_terminal_width();\n\t\tif (term_width <= 0)\n\t\t\tterm_width = 80;\n\t}\n\tif (term_width > 80) {\n\t\tterm_width -= 80;\n\t\tw = term_width / 10;\n\t\tif (w > 8)\n\t\t\tw = 8;\n\t\tterm_width -= 2*w;\n\t\tlabel_len += w;\n\t\tfs_type_len += w;\n\t\tw = term_width/2;\n\t\tdevice_len += w;\n\t\tmtpt_len +=w;\n\t}\n\n\tlen = pretty_print_word(device, device_len, 0, 1);\n\tlen = pretty_print_word(fs_type, fs_type_len, len, 0);\n\tlen = pretty_print_word(label, label_len, len, 0);\n\tpretty_print_word(mtpt, mtpt_len, len, 0);\n\n\tfputs(uuid, stdout);\n\tfputc('\\n', stdout);\n}\n\nstatic void pretty_print_dev(blkid_dev dev)\n{\n\tblkid_tag_iterate\titer;\n\tconst char\t\t*type, *value, *devname;\n\tconst char\t\t*uuid = \"\", *fs_type = \"\", *label = \"\";\n\tint\t\t\tlen, mount_flags;\n\tchar\t\t\tmtpt[80];\n\tint\t\t\tretval;\n\n\tif (dev == NULL) {\n\t\tpretty_print_line(\"device\", \"fs_type\", \"label\",\n\t\t\t\t  \"mount point\", \"UUID\");\n\t\tfor (len=get_terminal_width()-1; len > 0; len--)\n\t\t\tfputc('-', stdout);\n\t\tfputc('\\n', stdout);\n\t\treturn;\n\t}\n\n\tdevname = blkid_dev_devname(dev);\n\tif (access(devname, F_OK))\n\t\treturn;\n\n\t/* Get the uuid, label, type */\n\titer = blkid_tag_iterate_begin(dev);\n\twhile (blkid_tag_next(iter, &type, &value) == 0) {\n\t\tif (!strcmp(type, \"UUID\"))\n\t\t\tuuid = value;\n\t\tif (!strcmp(type, \"TYPE\"))\n\t\t\tfs_type = value;\n\t\tif (!strcmp(type, \"LABEL\"))\n\t\t\tlabel = value;\n\t}\n\tblkid_tag_iterate_end(iter);\n\n\t/* Get the mount point */\n\tmtpt[0] = 0;\n\tretval = check_mount_point(devname, &mount_flags, mtpt, sizeof(mtpt));\n\tif (retval == 0) {\n\t\tif (mount_flags & MF_MOUNTED) {\n\t\t\tif (!mtpt[0])\n\t\t\t\tstrcpy(mtpt, \"(mounted, mtpt unknown)\");\n\t\t} else if (mount_flags & MF_BUSY)\n\t\t\tstrcpy(mtpt, \"(in use)\");\n\t\telse\n\t\t\tstrcpy(mtpt, \"(not mounted)\");\n\t}\n\n\tpretty_print_line(devname, fs_type, label, mtpt, uuid);\n}\n\nstatic void print_udev_format(const char *name, const char *value)\n{\n\tchar enc[265], safe[256];\n\tsize_t namelen = strlen(name);\n\n\t*safe = *enc = '\\0';\n\n\tif (!strcmp(name, \"TYPE\") || !strcmp(name, \"VERSION\")) {\n\t\tblkid_encode_string(value, enc, sizeof(enc));\n\t\tprintf(\"ID_FS_%s=%s\\n\", name, enc);\n\n\t} else if (!strcmp(name, \"UUID\") ||\n\t\t !strcmp(name, \"LABEL\") ||\n\t\t !strcmp(name, \"UUID_SUB\")) {\n\n\t\tblkid_safe_string(value, safe, sizeof(safe));\n\t\tprintf(\"ID_FS_%s=%s\\n\", name, safe);\n\n\t\tblkid_encode_string(value, enc, sizeof(enc));\n\t\tprintf(\"ID_FS_%s_ENC=%s\\n\", name, enc);\n\n\t} else if (!strcmp(name, \"PTUUID\")) {\n\t\tprintf(\"ID_PART_TABLE_UUID=%s\\n\", value);\n\n\t} else if (!strcmp(name, \"PTTYPE\")) {\n\t\tprintf(\"ID_PART_TABLE_TYPE=%s\\n\", value);\n\n\t} else if (!strcmp(name, \"PART_ENTRY_NAME\") ||\n\t\t  !strcmp(name, \"PART_ENTRY_TYPE\")) {\n\n\t\tblkid_encode_string(value, enc, sizeof(enc));\n\t\tprintf(\"ID_%s=%s\\n\", name, enc);\n\n\t} else if (!strncmp(name, \"PART_ENTRY_\", 11))\n\t\tprintf(\"ID_%s=%s\\n\", name, value);\n\n\telse if (namelen >= 15 && (\n\t\t   !strcmp(name + (namelen - 12), \"_SECTOR_SIZE\") ||\n\t\t   !strcmp(name + (namelen - 8), \"_IO_SIZE\") ||\n\t\t   !strcmp(name, \"ALIGNMENT_OFFSET\")))\n\t\t\tprintf(\"ID_IOLIMIT_%s=%s\\n\", name, value);\n\telse\n\t\tprintf(\"ID_FS_%s=%s\\n\", name, value);\n}\n\nstatic int has_item(char *ary[], const char *item)\n{\n\tchar **p;\n\n\tfor (p = ary; *p != NULL; p++)\n\t\tif (!strcmp(item, *p))\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic void print_value(int output, int num, const char *devname,\n\t\t\tconst char *value, const char *name, size_t valsz)\n{\n\tif (output & OUTPUT_VALUE_ONLY) {\n\t\tfputs(value, stdout);\n\t\tfputc('\\n', stdout);\n\n\t} else if (output & OUTPUT_UDEV_LIST) {\n\t\tprint_udev_format(name, value);\n\n\t} else if (output & OUTPUT_EXPORT_LIST) {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"DEVNAME=%s\\n\", devname);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\", stdout);\n\t\tsafe_print(value, valsz, \" \\\\\\\"'$`<>\");\n\t\tfputs(\"\\n\", stdout);\n\n\t} else {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"%s:\", devname);\n\t\tfputs(\" \", stdout);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\\\"\", stdout);\n\t\tsafe_print(value, valsz, \"\\\"\\\\\");\n\t\tfputs(\"\\\"\", stdout);\n\t}\n}\n\nstatic void print_tags(blkid_dev dev, char *show[], int output)\n{\n\tblkid_tag_iterate\titer;\n\tconst char\t\t*type, *value, *devname;\n\tint\t\t\tnum = 1;\n\tstatic int\t\tfirst = 1;\n\n\tif (!dev)\n\t\treturn;\n\n\tif (output & OUTPUT_PRETTY_LIST) {\n\t\tpretty_print_dev(dev);\n\t\treturn;\n\t}\n\n\tdevname = blkid_dev_devname(dev);\n\n\tif (output & OUTPUT_DEVICE_ONLY) {\n\t\tprintf(\"%s\\n\", devname);\n\t\treturn;\n\t}\n\n\titer = blkid_tag_iterate_begin(dev);\n\twhile (blkid_tag_next(iter, &type, &value) == 0) {\n\t\tif (show[0] && !has_item(show, type))\n\t\t\tcontinue;\n\n\t\tif (num == 1 && !first &&\n\t\t    (output & (OUTPUT_UDEV_LIST | OUTPUT_EXPORT_LIST)))\n\t\t\t/* add extra line between output from more devices */\n\t\t\tfputc('\\n', stdout);\n\n\t\tprint_value(output, num++, devname, value, type, strlen(value));\n\t}\n\tblkid_tag_iterate_end(iter);\n\n\tif (num > 1) {\n\t\tif (!(output & (OUTPUT_VALUE_ONLY | OUTPUT_UDEV_LIST |\n\t\t\t\t\t\tOUTPUT_EXPORT_LIST)))\n\t\t\tprintf(\"\\n\");\n\t\tfirst = 0;\n\t}\n}\n\n\nstatic int append_str(char **res, size_t *sz, const char *a, const char *b)\n{\n\tchar *str = *res;\n\tsize_t asz = a ? strlen(a) : 0;\n\tsize_t bsz = b ? strlen(b) : 0;\n\tsize_t len = *sz + asz + bsz;\n\n\tif (!len)\n\t\treturn -1;\n\n\t*res = str = xrealloc(str, len + 1);\n\tstr += *sz;\n\n\tif (a) {\n\t\tmemcpy(str, a, asz);\n\t\tstr += asz;\n\t}\n\tif (b) {\n\t\tmemcpy(str, b, bsz);\n\t\tstr += bsz;\n\t}\n\t*str = '\\0';\n\t*sz = len;\n\treturn 0;\n}\n\n/*\n * Compose and print ID_FS_AMBIVALENT for udev\n */\nstatic int print_udev_ambivalent(blkid_probe pr)\n{\n\tchar *val = NULL;\n\tsize_t valsz = 0;\n\tint count = 0, rc = -1;\n\n\twhile (!blkid_do_probe(pr)) {\n\t\tconst char *usage_txt = NULL, *type = NULL, *version = NULL;\n\t\tchar enc[256];\n\n\t\tblkid_probe_lookup_value(pr, \"USAGE\", &usage_txt, NULL);\n\t\tblkid_probe_lookup_value(pr, \"TYPE\", &type, NULL);\n\t\tblkid_probe_lookup_value(pr, \"VERSION\", &version, NULL);\n\n\t\tif (!usage_txt || !type)\n\t\t\tcontinue;\n\n\t\tblkid_encode_string(usage_txt, enc, sizeof(enc));\n\t\tif (append_str(&val, &valsz, enc, \":\"))\n\t\t\tgoto done;\n\n\t\tblkid_encode_string(type, enc, sizeof(enc));\n\t\tif (append_str(&val, &valsz, enc, version ? \":\" : \" \"))\n\t\t\tgoto done;\n\n\t\tif (version) {\n\t\t\tblkid_encode_string(version, enc, sizeof(enc));\n\t\t\tif (append_str(&val, &valsz, enc, \" \"))\n\t\t\t\tgoto done;\n\t\t}\n\t\tcount++;\n\t}\n\n\tif (count > 1) {\n\t\t*(val + valsz - 1) = '\\0';\t\t/* rem tailing whitespace */\n\t\tprintf(\"ID_FS_AMBIVALENT=%s\\n\", val);\n\t\trc = 0;\n\t}\ndone:\n\tfree(val);\n\treturn rc;\n}\n\nstatic int lowprobe_superblocks(blkid_probe pr)\n{\n\tstruct stat st;\n\tint rc, fd = blkid_probe_get_fd(pr);\n\n\tif (fd < 0 || fstat(fd, &st))\n\t\treturn -1;\n\n\tblkid_probe_enable_partitions(pr, 1);\n\n\tif (!S_ISCHR(st.st_mode) && blkid_probe_get_size(pr) <= 1024 * 1440 &&\n\t    blkid_probe_is_wholedisk(pr)) {\n\t\t/*\n\t\t * check if the small disk is partitioned, if yes then\n\t\t * don't probe for filesystems.\n\t\t */\n\t\tblkid_probe_enable_superblocks(pr, 0);\n\n\t\trc = blkid_do_fullprobe(pr);\n\t\tif (rc < 0)\n\t\t\treturn rc;\t/* -1 = error, 1 = nothing, 0 = succes */\n\n\t\tif (blkid_probe_lookup_value(pr, \"PTTYPE\", NULL, NULL) == 0)\n\t\t\treturn 0;\t/* partition table detected */\n\t}\n\n\tblkid_probe_set_partitions_flags(pr, BLKID_PARTS_ENTRY_DETAILS);\n\tblkid_probe_enable_superblocks(pr, 1);\n\n\treturn blkid_do_safeprobe(pr);\n}\n\nstatic int lowprobe_topology(blkid_probe pr)\n{\n\t/* enable topology probing only */\n\tblkid_probe_enable_topology(pr, 1);\n\n\tblkid_probe_enable_superblocks(pr, 0);\n\tblkid_probe_enable_partitions(pr, 0);\n\n\treturn blkid_do_fullprobe(pr);\n}\n\nstatic int lowprobe_device(blkid_probe pr, const char *devname,\n\t\t\tint chain, char *show[], int output,\n\t\t\tblkid_loff_t offset, blkid_loff_t size)\n{\n\tconst char *data;\n\tconst char *name;\n\tint nvals = 0, n, num = 1;\n\tsize_t len;\n\tint fd;\n\tint rc = 0;\n\tstatic int first = 1;\n\n\tfd = open(devname, O_RDONLY|O_CLOEXEC);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"error: %s: %m\\n\", devname);\n\t\treturn BLKID_EXIT_NOTFOUND;\n\t}\n\tif (blkid_probe_set_device(pr, fd, offset, size))\n\t\tgoto done;\n\n\tif (chain & LOWPROBE_TOPOLOGY)\n\t\trc = lowprobe_topology(pr);\n\tif (rc >= 0 && (chain & LOWPROBE_SUPERBLOCKS))\n\t\trc = lowprobe_superblocks(pr);\n\tif (rc < 0)\n\t\tgoto done;\n\n\tif (!rc)\n\t\tnvals = blkid_probe_numof_values(pr);\n\n\tif (nvals &&\n\t    !(chain & LOWPROBE_TOPOLOGY) &&\n\t    !(output & OUTPUT_UDEV_LIST) &&\n\t    !blkid_probe_has_value(pr, \"TYPE\") &&\n\t    !blkid_probe_has_value(pr, \"PTTYPE\"))\n\t\t/*\n\t\t * Ignore probing result if there is not any filesystem or\n\t\t * partition table on the device and udev output is not\n\t\t * requested.\n\t\t *\n\t\t * The udev db stores information about partitions, so\n\t\t * PART_ENTRY_* values are alway important.\n\t\t */\n\t\tnvals = 0;\n\n\tif (nvals && !first && output & (OUTPUT_UDEV_LIST | OUTPUT_EXPORT_LIST))\n\t\t/* add extra line between output from devices */\n\t\tfputc('\\n', stdout);\n\n\tif (nvals && (output & OUTPUT_DEVICE_ONLY)) {\n\t\tprintf(\"%s\\n\", devname);\n\t\tgoto done;\n\t}\n\n\tfor (n = 0; n < nvals; n++) {\n\t\tif (blkid_probe_get_value(pr, n, &name, &data, &len))\n\t\t\tcontinue;\n\t\tif (show[0] && !has_item(show, name))\n\t\t\tcontinue;\n\t\tlen = strnlen((char *) data, len);\n\t\tprint_value(output, num++, devname, (char *) data, name, len);\n\t}\n\n\tif (first)\n\t\tfirst = 0;\n\tif (nvals >= 1 && !(output & (OUTPUT_VALUE_ONLY |\n\t\t\t\t\tOUTPUT_UDEV_LIST | OUTPUT_EXPORT_LIST)))\n\t\tprintf(\"\\n\");\ndone:\n\tif (rc == -2) {\n\t\tif (output & OUTPUT_UDEV_LIST)\n\t\t\tprint_udev_ambivalent(pr);\n\t\telse\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%s: ambivalent result (probably more \"\n\t\t\t\t\"filesystems on the device, use wipefs(8) \"\n\t\t\t\t\"to see more details)\\n\",\n\t\t\t\tdevname);\n\t}\n\tclose(fd);\n\n\tif (rc == -2)\n\t\treturn BLKID_EXIT_AMBIVAL;\t/* ambivalent probing result */\n\tif (!nvals)\n\t\treturn BLKID_EXIT_NOTFOUND;\t/* nothing detected */\n\n\treturn 0;\t\t/* success */\n}\n\n/* converts comma separated list to BLKID_USAGE_* mask */\nstatic int list_to_usage(const char *list, int *flag)\n{\n\tint mask = 0;\n\tconst char *word = NULL, *p = list;\n\n\tif (p && strncmp(p, \"no\", 2) == 0) {\n\t\t*flag = BLKID_FLTR_NOTIN;\n\t\tp += 2;\n\t}\n\tif (!p || !*p)\n\t\tgoto err;\n\twhile(p) {\n\t\tword = p;\n\t\tp = strchr(p, ',');\n\t\tif (p)\n\t\t\tp++;\n\t\tif (!strncmp(word, \"filesystem\", 10))\n\t\t\tmask |= BLKID_USAGE_FILESYSTEM;\n\t\telse if (!strncmp(word, \"raid\", 4))\n\t\t\tmask |= BLKID_USAGE_RAID;\n\t\telse if (!strncmp(word, \"crypto\", 6))\n\t\t\tmask |= BLKID_USAGE_CRYPTO;\n\t\telse if (!strncmp(word, \"other\", 5))\n\t\t\tmask |= BLKID_USAGE_OTHER;\n\t\telse\n\t\t\tgoto err;\n\t}\n\treturn mask;\nerr:\n\t*flag = 0;\n\tfprintf(stderr, \"unknown keyword in -u <list> argument: '%s'\\n\",\n\t\t\tword ? word : list);\n\texit(BLKID_EXIT_OTHER);\n}\n\n/* converts comma separated list to types[] */\nstatic char **list_to_types(const char *list, int *flag)\n{\n\tint i;\n\tconst char *p = list;\n\tchar **res = NULL;\n\n\tif (p && strncmp(p, \"no\", 2) == 0) {\n\t\t*flag = BLKID_FLTR_NOTIN;\n\t\tp += 2;\n\t}\n\tif (!p || !*p) {\n\t\tfprintf(stderr, \"error: -u <list> argument is empty\\n\");\n\t\tgoto err;\n\t}\n\tfor (i = 1; p && (p = strchr(p, ',')); i++, p++);\n\n\tres = xcalloc(i + 1, sizeof(char *));\n\tp = *flag & BLKID_FLTR_NOTIN ? list + 2 : list;\n\ti = 0;\n\n\twhile(p) {\n\t\tconst char *word = p;\n\t\tp = strchr(p, ',');\n\t\tres[i++] = p ? xstrndup(word, p - word) : xstrdup(word);\n\t\tif (p)\n\t\t\tp++;\n\t}\n\tres[i] = NULL;\n\treturn res;\nerr:\n\t*flag = 0;\n\tfree(res);\n\texit(BLKID_EXIT_OTHER);\n}\n\nstatic void free_types_list(char *list[])\n{\n\tchar **n;\n\n\tif (!list)\n\t\treturn;\n\tfor (n = list; *n; n++)\n\t\tfree(*n);\n\tfree(list);\n}\n\nint main(int argc, char **argv)\n{\n\tblkid_cache cache = NULL;\n\tchar **devices = NULL;\n\tchar *show[128] = { NULL, };\n\tchar *search_type = NULL, *search_value = NULL;\n\tchar *read = NULL;\n\tint fltr_usage = 0;\n\tchar **fltr_type = NULL;\n\tint fltr_flag = BLKID_FLTR_ONLYIN;\n\tunsigned int numdev = 0, numtag = 0;\n\tint version = 0;\n\tint err = BLKID_EXIT_OTHER;\n\tunsigned int i;\n\tint output_format = 0;\n\tint lookup = 0, gc = 0, lowprobe = 0, eval = 0;\n\tint c;\n\tuintmax_t offset = 0, size = 0;\n\n\tstatic const ul_excl_t excl[] = {       /* rows and cols in in ASCII order */\n\t\t{ 'n','u' },\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\n\tshow[0] = NULL;\n\tatexit(close_stdout);\n\n\twhile ((c = getopt (argc, argv,\n\t\t\t    \"c:df:ghilL:n:ko:O:ps:S:t:u:U:w:Vv\")) != EOF) {\n\n\t\terr_exclusive_options(c, NULL, excl, excl_st);\n\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tif (optarg && !*optarg)\n\t\t\t\tread = NULL;\n\t\t\telse\n\t\t\t\tread = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\traw_chars = 1;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\teval++;\n\t\t\tsearch_value = xstrdup(optarg);\n\t\t\tsearch_type = xstrdup(\"LABEL\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tfltr_type = list_to_types(optarg, &fltr_flag);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tfltr_usage = list_to_usage(optarg, &fltr_flag);\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\teval++;\n\t\t\tsearch_value = xstrdup(optarg);\n\t\t\tsearch_type = xstrdup(\"UUID\");\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tlowprobe |= LOWPROBE_TOPOLOGY;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlookup++;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tgc = 1;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t{\n\t\t\tsize_t idx = 0;\n\t\t\tconst char *name = NULL;\n\n\t\t\twhile (blkid_superblocks_get_name(idx++, &name, NULL) == 0)\n\t\t\t\tprintf(\"%s\\n\", name);\n\t\t\texit(EXIT_SUCCESS);\n\t\t}\n\t\tcase 'o':\n\t\t\tif (!strcmp(optarg, \"value\"))\n\t\t\t\toutput_format = OUTPUT_VALUE_ONLY;\n\t\t\telse if (!strcmp(optarg, \"device\"))\n\t\t\t\toutput_format = OUTPUT_DEVICE_ONLY;\n\t\t\telse if (!strcmp(optarg, \"list\"))\n\t\t\t\toutput_format = OUTPUT_PRETTY_LIST;\t/* deprecated */\n\t\t\telse if (!strcmp(optarg, \"udev\"))\n\t\t\t\toutput_format = OUTPUT_UDEV_LIST;\n\t\t\telse if (!strcmp(optarg, \"export\"))\n\t\t\t\toutput_format = OUTPUT_EXPORT_LIST;\n\t\t\telse if (!strcmp(optarg, \"full\"))\n\t\t\t\toutput_format = 0;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Invalid output format %s. \"\n\t\t\t\t\t\"Choose from value,\\n\\t\"\n\t\t\t\t\t\"device, list, udev or full\\n\", optarg);\n\t\t\t\texit(BLKID_EXIT_OTHER);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\toffset = strtosize_or_err(optarg, \"invalid offset argument\");\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tlowprobe |= LOWPROBE_SUPERBLOCKS;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (numtag + 1 >= sizeof(show) / sizeof(*show)) {\n\t\t\t\tfprintf(stderr, \"Too many tags specified\\n\");\n\t\t\t\tusage(err);\n\t\t\t}\n\t\t\tshow[numtag++] = optarg;\n\t\t\tshow[numtag] = NULL;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tsize = strtosize_or_err(optarg, \"invalid size argument\");\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (search_type) {\n\t\t\t\tfprintf(stderr, \"Can only search for \"\n\t\t\t\t\t\t\"one NAME=value pair\\n\");\n\t\t\t\tusage(err);\n\t\t\t}\n\t\t\tif (blkid_parse_tag_string(optarg,\n\t\t\t\t\t\t   &search_type,\n\t\t\t\t\t\t   &search_value)) {\n\t\t\t\tfprintf(stderr, \"-t needs NAME=value pair\\n\");\n\t\t\t\tusage(err);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'V':\n\t\tcase 'v':\n\t\t\tversion = 1;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\t/* ignore - backward compatibility */\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\terr = 0;\n\t\t\t/* fallthrough */\n\t\tdefault:\n\t\t\tusage(err);\n\t\t}\n\t}\n\n\n\t/* The rest of the args are device names */\n\tif (optind < argc) {\n\t\tdevices = xcalloc(argc - optind, sizeof(char *));\n\t\twhile (optind < argc)\n\t\t\tdevices[numdev++] = argv[optind++];\n\t}\n\n\tif (version) {\n\t\tprint_version(stdout);\n\t\tgoto exit;\n\t}\n\n\t/* convert LABEL/UUID lookup to evaluate request */\n\tif (lookup && output_format == OUTPUT_DEVICE_ONLY && search_type &&\n\t    (!strcmp(search_type, \"LABEL\") || !strcmp(search_type, \"UUID\"))) {\n\t\teval++;\n\t\tlookup = 0;\n\t}\n\n\tif (!lowprobe && !eval && blkid_get_cache(&cache, read) < 0)\n\t\tgoto exit;\n\n\tif (gc) {\n\t\tblkid_gc_cache(cache);\n\t\terr = 0;\n\t\tgoto exit;\n\t}\n\terr = BLKID_EXIT_NOTFOUND;\n\n\tif (eval == 0 && (output_format & OUTPUT_PRETTY_LIST)) {\n\t\tif (lowprobe) {\n\t\t\tfprintf(stderr, \"The low-level probing mode does not \"\n\t\t\t\t\t\"support 'list' output format\\n\");\n\t\t\texit(BLKID_EXIT_OTHER);\n\t\t}\n\t\tpretty_print_dev(NULL);\n\t}\n\n\tif (lowprobe) {\n\t\t/*\n\t\t * Low-level API\n\t\t */\n\t\tblkid_probe pr;\n\n\t\tif (!numdev) {\n\t\t\tfprintf(stderr, \"The low-level probing mode \"\n\t\t\t\t\t\"requires a device\\n\");\n\t\t\texit(BLKID_EXIT_OTHER);\n\t\t}\n\n\t\t/* automatically enable 'export' format for I/O Limits */\n\t\tif (!output_format  && (lowprobe & LOWPROBE_TOPOLOGY))\n\t\t\toutput_format = OUTPUT_EXPORT_LIST;\n\n\t\tpr = blkid_new_probe();\n\t\tif (!pr)\n\t\t\tgoto exit;\n\n\t\tif (lowprobe & LOWPROBE_SUPERBLOCKS) {\n\t\t\tblkid_probe_set_superblocks_flags(pr,\n\t\t\t\tBLKID_SUBLKS_LABEL | BLKID_SUBLKS_UUID |\n\t\t\t\tBLKID_SUBLKS_TYPE | BLKID_SUBLKS_SECTYPE |\n\t\t\t\tBLKID_SUBLKS_USAGE | BLKID_SUBLKS_VERSION);\n\n\t\t\tif (fltr_usage && blkid_probe_filter_superblocks_usage(\n\t\t\t\t\t\tpr, fltr_flag, fltr_usage))\n\t\t\t\tgoto exit;\n\n\t\t\telse if (fltr_type && blkid_probe_filter_superblocks_type(\n\t\t\t\t\t\tpr, fltr_flag, fltr_type))\n\t\t\t\tgoto exit;\n\t\t}\n\n\t\tfor (i = 0; i < numdev; i++) {\n\t\t\terr = lowprobe_device(pr, devices[i], lowprobe, show,\n\t\t\t\t\toutput_format,\n\t\t\t\t\t(blkid_loff_t) offset,\n\t\t\t\t\t(blkid_loff_t) size);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\tblkid_free_probe(pr);\n\t} else if (eval) {\n\t\t/*\n\t\t * Evaluate API\n\t\t */\n\t\tchar *res = blkid_evaluate_tag(search_type, search_value, NULL);\n\t\tif (res) {\n\t\t\terr = 0;\n\t\t\tprintf(\"%s\\n\", res);\n\t\t}\n\t} else if (lookup) {\n\t\t/*\n\t\t * Classic (cache based) API\n\t\t */\n\t\tblkid_dev dev;\n\n\t\tif (!search_type) {\n\t\t\tfprintf(stderr, \"The lookup option requires a \"\n\t\t\t\t\"search type specified using -t\\n\");\n\t\t\texit(BLKID_EXIT_OTHER);\n\t\t}\n\t\t/* Load any additional devices not in the cache */\n\t\tfor (i = 0; i < numdev; i++)\n\t\t\tblkid_get_dev(cache, devices[i], BLKID_DEV_NORMAL);\n\n\t\tif ((dev = blkid_find_dev_with_tag(cache, search_type,\n\t\t\t\t\t\t   search_value))) {\n\t\t\tprint_tags(dev, show, output_format);\n\t\t\terr = 0;\n\t\t}\n\t/* If we didn't specify a single device, show all available devices */\n\t} else if (!numdev) {\n\t\tblkid_dev_iterate\titer;\n\t\tblkid_dev\t\tdev;\n\n\t\tblkid_probe_all(cache);\n\n\t\titer = blkid_dev_iterate_begin(cache);\n\t\tblkid_dev_set_search(iter, search_type, search_value);\n\t\twhile (blkid_dev_next(iter, &dev) == 0) {\n\t\t\tdev = blkid_verify(cache, dev);\n\t\t\tif (!dev)\n\t\t\t\tcontinue;\n\t\t\tprint_tags(dev, show, output_format);\n\t\t\terr = 0;\n\t\t}\n\t\tblkid_dev_iterate_end(iter);\n\t/* Add all specified devices to cache (optionally display tags) */\n\t} else for (i = 0; i < numdev; i++) {\n\t\tblkid_dev dev = blkid_get_dev(cache, devices[i],\n\t\t\t\t\t\t  BLKID_DEV_NORMAL);\n\n\t\tif (dev) {\n\t\t\tif (search_type &&\n\t\t\t    !blkid_dev_has_tag(dev, search_type,\n\t\t\t\t\t       search_value))\n\t\t\t\tcontinue;\n\t\t\tprint_tags(dev, show, output_format);\n\t\t\terr = 0;\n\t\t}\n\t}\n\nexit:\n\tfree(search_type);\n\tfree(search_value);\n\tfree_types_list(fltr_type);\n\tif (!lowprobe && !eval)\n\t\tblkid_put_cache(cache);\n\tfree(devices);\n\treturn err;\n}\n"], "filenames": ["libblkid/src/read.c", "libblkid/src/save.c", "misc-utils/blkid.8", "misc-utils/blkid.c"], "buggy_code_start_loc": [255, 28, 203, 309], "buggy_code_end_loc": [264, 49, 204, 319], "fixing_code_start_loc": [255, 29, 203, 309], "fixing_code_end_loc": [279, 69, 207, 319], "type": "CWE-77", "message": "Blkid in util-linux before 2.26rc-1 allows local users to execute arbitrary code.", "other": {"cve": {"id": "CVE-2014-9114", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-31T16:59:00.397", "lastModified": "2021-06-29T15:15:09.550", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Blkid in util-linux before 2.26rc-1 allows local users to execute arbitrary code."}, {"lang": "es", "value": "Blkid en util-linux en versiones anteriores a 2.26rc-1 permite a usuarios locales ejecutar c\u00f3digo arbitrario."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.1:*:*:*:*:*:*:*", "matchCriteriaId": "A10BC294-9196-425F-9FB0-B1625465B47F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:20:*:*:*:*:*:*:*", "matchCriteriaId": "FF47C9F0-D8DA-4B55-89EB-9B2C9383ADB9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:21:*:*:*:*:*:*:*", "matchCriteriaId": "56BDB5A0-0839-4A20-A003-B8CD56F48171"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kernel:util-linux:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.24.2-1", "matchCriteriaId": "3D658A6B-7068-4B7C-A11E-9B7FDA1DB986"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-December/145188.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-December/146229.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2015-01/msg00035.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/11/26/21", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/71327", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1168485", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory", "VDB Entry", "Patch"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/98993", "source": "cve@mitre.org"}, {"url": "https://github.com/karelzak/util-linux/commit/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r58af02e294bd07f487e2c64ffc0a29b837db5600e33b6e698b9d696b@%3Cissues.bookkeeper.apache.org%3E", "source": "cve@mitre.org"}, {"url": "https://lists.apache.org/thread.html/rf4c02775860db415b4955778a131c2795223f61cb8c6a450893651e4@%3Cissues.bookkeeper.apache.org%3E", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/201612-14", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/karelzak/util-linux/commit/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc"}}