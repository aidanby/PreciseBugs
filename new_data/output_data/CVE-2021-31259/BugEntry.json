{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *          Authors: Cyril Concolato / Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2005-2020\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\nGF_ISMASample *gf_isom_ismacryp_new_sample()\n{\n\tGF_ISMASample *tmp = (GF_ISMASample *) gf_malloc(sizeof(GF_ISMASample));\n\tif (!tmp) return NULL;\n\tmemset(tmp, 0, sizeof(GF_ISMASample));\n\treturn tmp;\n}\nGF_EXPORT\nvoid gf_isom_ismacryp_delete_sample(GF_ISMASample *samp)\n{\n\tif (!samp) return;\n\tif (samp->data && samp->dataLength) gf_free(samp->data);\n\tif (samp->key_indicator) gf_free(samp->key_indicator);\n\tgf_free(samp);\n}\n\n\nGF_ISMASample *gf_isom_ismacryp_sample_from_data(u8 *data, u32 dataLength, Bool use_selective_encryption, u8 KI_length, u8 IV_length)\n{\n\tGF_ISMASample *s;\n\tGF_BitStream *bs;\n\t/*empty text sample*/\n\tif (!data || !dataLength) {\n\t\treturn gf_isom_ismacryp_new_sample();\n\t}\n\n\ts = gf_isom_ismacryp_new_sample();\n\n\t/*empty sample*/\n\tif (!data || !dataLength) return s;\n\n\tbs = gf_bs_new(data, dataLength, GF_BITSTREAM_READ);\n\n\ts->dataLength = dataLength;\n\ts->IV_length = IV_length;\n\ts->KI_length = KI_length;\n\n\tif (use_selective_encryption) {\n\t\ts->flags = GF_ISOM_ISMA_USE_SEL_ENC;\n\t\tif (s->dataLength < 1) goto exit;\n\t\tif (gf_bs_read_int(bs, 1)) s->flags |= GF_ISOM_ISMA_IS_ENCRYPTED;\n\t\tgf_bs_read_int(bs, 7);\n\t\ts->dataLength -= 1;\n\t} else {\n\t\ts->flags = GF_ISOM_ISMA_IS_ENCRYPTED;\n\t}\n\tif (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) {\n\t\tif (IV_length != 0) {\n\t\t\tif (s->dataLength < IV_length) goto exit;\n\t\t\ts->IV = gf_bs_read_long_int(bs, 8*IV_length);\n\t\t\ts->dataLength -= IV_length;\n\t\t}\n\t\tif (KI_length) {\n\t\t\tif (s->dataLength < KI_length) goto exit;\n\t\t\ts->key_indicator = (u8 *)gf_malloc(KI_length);\n\t\t\tif (!s->key_indicator) goto exit;\n\t\t\tgf_bs_read_data(bs, (char*)s->key_indicator, KI_length);\n\t\t\ts->dataLength -= KI_length;\n\t\t}\n\t}\n\ts->data = (char*)gf_malloc(sizeof(char)*s->dataLength);\n\tif (!s->data) goto exit;\n\tgf_bs_read_data(bs, s->data, s->dataLength);\n\tgf_bs_del(bs);\n\treturn s;\n\nexit:\n\tgf_isom_ismacryp_delete_sample(s);\n\treturn NULL;\n}\n\n#if 0 //unused\n/*! rewrites ISMA sample as an ISO sample\n\\param s the ISMA sample to rewrite\n\\param dest the destination ISO sample\n\\return error if any\n*/\nGF_Err gf_isom_ismacryp_sample_to_sample(const GF_ISMASample *s, GF_ISOSample *dest)\n{\n\tGF_BitStream *bs;\n\tif (!s || !dest) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tif (s->flags & GF_ISOM_ISMA_USE_SEL_ENC) {\n\t\tgf_bs_write_int(bs, (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) ? 1 : 0, 1);\n\t\tgf_bs_write_int(bs, 0, 7);\n\t}\n\tif (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) {\n\t\tif (s->IV_length) gf_bs_write_long_int(bs, (s64) s->IV, 8*s->IV_length);\n\t\tif (s->KI_length) gf_bs_write_data(bs, (char*)s->key_indicator, s->KI_length);\n\t}\n\tgf_bs_write_data(bs, s->data, s->dataLength);\n\tif (dest->data) gf_free(dest->data);\n\tdest->data = NULL;\n\tdest->dataLength = 0;\n\tgf_bs_get_content(bs, &dest->data, &dest->dataLength);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n#endif\n\n\nstatic GF_ProtectionSchemeInfoBox *isom_get_sinf_entry(GF_TrackBox *trak, u32 sampleDescriptionIndex, u32 scheme_type, GF_SampleEntryBox **out_sea)\n{\n\tu32 i=0;\n\tGF_SampleEntryBox *sea=NULL;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\tMedia_GetSampleDesc(trak->Media, sampleDescriptionIndex, &sea, NULL);\n\tif (!sea) return NULL;\n\n\ti = 0;\n\twhile ((sinf = (GF_ProtectionSchemeInfoBox*)gf_list_enum(sea->child_boxes, &i))) {\n\t\tif (sinf->type != GF_ISOM_BOX_TYPE_SINF) continue;\n\n\t\tif (sinf->original_format && sinf->scheme_type && sinf->info) {\n\t\t\tif (!scheme_type || (sinf->scheme_type->scheme_type == scheme_type)) {\n\t\t\t\tif (out_sea)\n\t\t\t\t\t*out_sea = sea;\n\t\t\t\treturn sinf;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nGF_ISMASample *gf_isom_get_ismacryp_sample(GF_ISOFile *the_file, u32 trackNumber, const GF_ISOSample *samp, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_ISMASampleFormatBox *fmt;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, 0, NULL);\n\tif (!sinf) return NULL;\n\n\t/*ISMA*/\n\tif (sinf->scheme_type->scheme_type == GF_ISOM_ISMACRYP_SCHEME) {\n\t\tfmt = sinf->info->isfm;\n\t\tif (!fmt) return NULL;\n\t\treturn gf_isom_ismacryp_sample_from_data(samp->data, samp->dataLength, sinf->info->isfm->selective_encryption, sinf->info->isfm->key_indicator_length, sinf->info->isfm->IV_length);\n\t}\n\t/*OMA*/\n\telse if (sinf->scheme_type->scheme_type == GF_ISOM_OMADRM_SCHEME ) {\n\t\tif (!sinf->info->odkm) return NULL;\n\t\tfmt = sinf->info->odkm->fmt;\n\n\t\tif (fmt) {\n\t\t\treturn gf_isom_ismacryp_sample_from_data(samp->data, samp->dataLength, fmt->selective_encryption, fmt->key_indicator_length, fmt->IV_length);\n\t\t}\n\t\t/*OMA default: no selective encryption, one key, 128 bit IV*/\n\t\treturn gf_isom_ismacryp_sample_from_data(samp->data, samp->dataLength, GF_FALSE, 0, 128);\n\t}\n\treturn NULL;\n}\n\n\nGF_EXPORT\nu32 gf_isom_is_media_encrypted(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\tcount = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tif (sampleDescriptionIndex && (i+1 != sampleDescriptionIndex))\n\t\t\tcontinue;\n\n\t\tsinf = isom_get_sinf_entry(trak, i+1, 0, NULL);\n\t\tif (!sinf) continue;\n\n\t\t/*non-encrypted or non-ISMA*/\n\t\tif (!sinf->scheme_type) return 0;\n\t\tif (sinf->scheme_type->scheme_type == GF_ISOM_PIFF_SCHEME) return GF_ISOM_CENC_SCHEME;\n\t\treturn sinf->scheme_type->scheme_type;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nBool gf_isom_is_ismacryp_media(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_ISMACRYP_SCHEME, NULL);\n\tif (!sinf) return GF_FALSE;\n\n\t/*non-encrypted or non-ISMA*/\n\tif (!sinf->info || !sinf->info->ikms || !sinf->info->isfm )\n\t\treturn GF_FALSE;\n\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_isom_is_omadrm_media(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_OMADRM_SCHEME, NULL);\n\tif (!sinf) return GF_FALSE;\n\n\t/*non-encrypted or non-OMA*/\n\tif (!sinf->info || !sinf->info->odkm || !sinf->info->odkm->hdr)\n\t\treturn GF_FALSE;\n\n\treturn GF_TRUE;\n}\n\n/*retrieves ISMACryp info for the given track & SDI*/\nGF_EXPORT\nGF_Err gf_isom_get_ismacryp_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat, u32 *outSchemeType, u32 *outSchemeVersion, const char **outSchemeURI, const char **outKMS_URI, Bool *outSelectiveEncryption, u32 *outIVLength, u32 *outKeyIndicationLength)\n{\n\tGF_TrackBox *trak;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_ISMACRYP_SCHEME, NULL);\n\tif (!sinf) return GF_OK;\n\n\tif (outOriginalFormat) {\n\t\t*outOriginalFormat = sinf->original_format->data_format;\n\t\tif (IsMP4Description(sinf->original_format->data_format)) *outOriginalFormat = GF_ISOM_SUBTYPE_MPEG4;\n\t}\n\tif (outSchemeType) *outSchemeType = sinf->scheme_type->scheme_type;\n\tif (outSchemeVersion) *outSchemeVersion = sinf->scheme_type->scheme_version;\n\tif (outSchemeURI) *outSchemeURI = sinf->scheme_type->URI;\n\n\tif (sinf->info && sinf->info->ikms) {\n\t\tif (outKMS_URI) *outKMS_URI = sinf->info->ikms->URI;\n\t} else {\n\t\tif (outKMS_URI) *outKMS_URI = NULL;\n\t}\n\tif (sinf->info && sinf->info->isfm) {\n\t\tif (outSelectiveEncryption) *outSelectiveEncryption = sinf->info->isfm->selective_encryption;\n\t\tif (outIVLength) *outIVLength = sinf->info->isfm->IV_length;\n\t\tif (outKeyIndicationLength) *outKeyIndicationLength = sinf->info->isfm->key_indicator_length;\n\t} else {\n\t\tif (outSelectiveEncryption) *outSelectiveEncryption = GF_FALSE;\n\t\tif (outIVLength) *outIVLength = 0;\n\t\tif (outKeyIndicationLength) *outKeyIndicationLength = 0;\n\t}\n\treturn GF_OK;\n}\n\n\n/*retrieves ISMACryp info for the given track & SDI*/\nGF_EXPORT\nGF_Err gf_isom_get_omadrm_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat,\n                               u32 *outSchemeType, u32 *outSchemeVersion,\n                               const char **outContentID, const char **outRightsIssuerURL, const char **outTextualHeaders, u32 *outTextualHeadersLen, u64 *outPlaintextLength, u32 *outEncryptionType, Bool *outSelectiveEncryption, u32 *outIVLength, u32 *outKeyIndicationLength)\n{\n\tGF_TrackBox *trak;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_OMADRM_SCHEME, NULL);\n\tif (!sinf) return GF_OK;\n\n\tif (!sinf->info || !sinf->info->odkm || !sinf->info->odkm->hdr) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tif (outOriginalFormat) {\n\t\t*outOriginalFormat = sinf->original_format->data_format;\n\t\tif (IsMP4Description(sinf->original_format->data_format)) *outOriginalFormat = GF_ISOM_SUBTYPE_MPEG4;\n\t}\n\tif (outSchemeType) *outSchemeType = sinf->scheme_type->scheme_type;\n\tif (outSchemeVersion) *outSchemeVersion = sinf->scheme_type->scheme_version;\n\tif (outContentID) *outContentID = sinf->info->odkm->hdr->ContentID;\n\tif (outRightsIssuerURL) *outRightsIssuerURL = sinf->info->odkm->hdr->RightsIssuerURL;\n\tif (outTextualHeaders) {\n\t\t*outTextualHeaders = sinf->info->odkm->hdr->TextualHeaders;\n\t\tif (outTextualHeadersLen) *outTextualHeadersLen = sinf->info->odkm->hdr->TextualHeadersLen;\n\t}\n\tif (outPlaintextLength) *outPlaintextLength = sinf->info->odkm->hdr->PlaintextLength;\n\tif (outEncryptionType) *outEncryptionType = sinf->info->odkm->hdr->EncryptionMethod;\n\n\tif (sinf->info && sinf->info->odkm && sinf->info->odkm->fmt) {\n\t\tif (outSelectiveEncryption) *outSelectiveEncryption = sinf->info->odkm->fmt->selective_encryption;\n\t\tif (outIVLength) *outIVLength = sinf->info->odkm->fmt->IV_length;\n\t\tif (outKeyIndicationLength) *outKeyIndicationLength = sinf->info->odkm->fmt->key_indicator_length;\n\t} else {\n\t\tif (outSelectiveEncryption) *outSelectiveEncryption = GF_FALSE;\n\t\tif (outIVLength) *outIVLength = 0;\n\t\tif (outKeyIndicationLength) *outKeyIndicationLength = 0;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n#if 0 //unused\n/*! removes protection info (does not perform decryption), for ISMA, OMA and CENC of a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\return error if any\n*/\nGF_Err gf_isom_remove_track_protection(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleEntryBox *sea;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !sampleDescriptionIndex) return GF_BAD_PARAM;\n\n\tsea = NULL;\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENC_SCHEME, &sea);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBC_SCHEME, &sea);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENS_SCHEME, &sea);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBCS_SCHEME, &sea);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_ISMACRYP_SCHEME, &sea);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_OMADRM_SCHEME, &sea);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_ADOBE_SCHEME, &sea);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_PIFF_SCHEME, &sea);\n\tif (!sinf) return GF_OK;\n\n\tsea->type = sinf->original_format->data_format;\n\twhile (1) {\n\t\tGF_Box *b = gf_isom_box_find_child(sea->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (!b) break;\n\t\tgf_isom_box_del_parent(&sea->child_boxes, b);\n\t}\n\tif (sea->type == GF_ISOM_BOX_TYPE_264B) sea->type = GF_ISOM_BOX_TYPE_AVC1;\n\tif (sea->type == GF_ISOM_BOX_TYPE_265B) sea->type = GF_ISOM_BOX_TYPE_HVC1;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_change_ismacryp_protection(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex, char *scheme_uri, char *kms_uri)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleEntryBox *sea;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !sampleDescriptionIndex) return GF_BAD_PARAM;\n\n\tsea = NULL;\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_ISMACRYP_SCHEME, &sea);\n\tif (!sinf) return GF_OK;\n\n\tif (scheme_uri) {\n\t\tgf_free(sinf->scheme_type->URI);\n\t\tsinf->scheme_type->URI = gf_strdup(scheme_uri);\n\t}\n\tif (kms_uri) {\n\t\tgf_free(sinf->info->ikms->URI);\n\t\tsinf->info->ikms->URI = gf_strdup(kms_uri);\n\t}\n\treturn GF_OK;\n}\n\n\nstatic GF_Err isom_set_protected_entry(GF_ISOFile *the_file, u32 trackNumber, u32 desc_index, u8 version, u32 flags,\n        u32 scheme_type, u32 scheme_version, char *scheme_uri, Bool is_isma, GF_ProtectionSchemeInfoBox **out_sinf)\n{\n\tu32 original_format;\n\tGF_Err e;\n\tGF_SampleEntryBox *sea;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, desc_index, &sea, NULL);\n\tif (e) return e;\n\n\toriginal_format = sea->type;\n\tif (original_format==GF_ISOM_BOX_TYPE_GNRA) {\n\t\toriginal_format = ((GF_GenericAudioSampleEntryBox*)sea)->EntryType;\n\t} else if (original_format==GF_ISOM_BOX_TYPE_GNRV) {\n\t\toriginal_format = ((GF_GenericVisualSampleEntryBox*)sea)->EntryType;\n\t} else if (original_format==GF_ISOM_BOX_TYPE_GNRM) {\n\t\toriginal_format = ((GF_GenericSampleEntryBox*)sea)->EntryType;\n\t}\n\n\t/* Replacing the Media Type */\n\tswitch (sea->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\tcase GF_ISOM_BOX_TYPE_DAMR:\n\tcase GF_ISOM_BOX_TYPE_DEVC:\n\tcase GF_ISOM_BOX_TYPE_DQCP:\n\tcase GF_ISOM_BOX_TYPE_DSMV:\n\tcase GF_ISOM_BOX_TYPE_AC3:\n\tcase GF_ISOM_BOX_TYPE_EC3:\n\t\tsea->type = GF_ISOM_BOX_TYPE_ENCA;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\tcase GF_ISOM_BOX_TYPE_D263:\n\t\tsea->type = GF_ISOM_BOX_TYPE_ENCV;\n\t\tbreak;\n\t/*special case for AVC1*/\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tif (is_isma)\n\t\t\toriginal_format = GF_ISOM_BOX_TYPE_264B;\n\t\tsea->type = GF_ISOM_BOX_TYPE_ENCV;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tif (is_isma)\n\t\t\toriginal_format = GF_ISOM_BOX_TYPE_265B;\n\t\tsea->type = GF_ISOM_BOX_TYPE_ENCV;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VVC1:\n\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tsea->type = GF_ISOM_BOX_TYPE_ENCV;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VP09:\n\t\tsea->type = GF_ISOM_BOX_TYPE_ENCV;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tsea->type = GF_ISOM_BOX_TYPE_ENCV;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\tcase GF_ISOM_BOX_TYPE_LSR1:\n\t\tsea->type = GF_ISOM_BOX_TYPE_ENCS;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STXT:\n\tcase GF_ISOM_BOX_TYPE_WVTT:\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\tsea->type = GF_ISOM_BOX_TYPE_ENCT;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_ENCT:\n\tcase GF_ISOM_BOX_TYPE_ENCM:\n\tcase GF_ISOM_BOX_TYPE_ENCF:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] cannot set protection entry: file is already encrypted.\\n\"));\n\t\treturn GF_BAD_PARAM;\n\tdefault:\n\t\tif (sea->internal_type == GF_ISOM_SAMPLE_ENTRY_AUDIO) {\n\t\t\tsea->type = GF_ISOM_BOX_TYPE_ENCA;\n\t\t} else if (sea->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\tsea->type = GF_ISOM_BOX_TYPE_ENCV;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] unsupported entry type %s for CENC.\\n\", gf_4cc_to_str(sea->type) ));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\n\tsinf = (GF_ProtectionSchemeInfoBox *)gf_isom_box_new_parent(&sea->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\tif (!sinf) return GF_OUT_OF_MEM;\n\n\tsinf->scheme_type = (GF_SchemeTypeBox *)gf_isom_box_new_parent(&sinf->child_boxes, GF_ISOM_BOX_TYPE_SCHM);\n\tif (!sinf->scheme_type) return GF_OUT_OF_MEM;\n\n\tsinf->scheme_type->version = version;\n\tsinf->scheme_type->flags = flags;\n\tsinf->scheme_type->scheme_type = scheme_type;\n\tsinf->scheme_type->scheme_version = scheme_version;\n\tif (scheme_uri && (sinf->scheme_type->flags == 1)) {\n\t\tsinf->scheme_type->URI = (char *)gf_malloc(sizeof(char)*strlen(scheme_uri));\n\t\tif (!sinf->scheme_type->URI) return GF_OUT_OF_MEM;\n\t\tmemmove(sinf->scheme_type->URI, scheme_uri, strlen(scheme_uri));\n\t}\n\n\tsinf->original_format = (GF_OriginalFormatBox *)gf_isom_box_new_parent(&sinf->child_boxes, GF_ISOM_BOX_TYPE_FRMA);\n\tif (!sinf->original_format) return GF_OUT_OF_MEM;\n\tsinf->original_format->data_format = original_format;\n\n\t//common to isma, cenc and oma\n\tsinf->info = (GF_SchemeInformationBox *)gf_isom_box_new_parent(&sinf->child_boxes, GF_ISOM_BOX_TYPE_SCHI);\n\n\t*out_sinf = sinf;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_ismacryp_protection(GF_ISOFile *the_file, u32 trackNumber, u32 desc_index, u32 scheme_type,\n                                       u32 scheme_version, char *scheme_uri, char *kms_URI,\n                                       Bool selective_encryption, u32 KI_length, u32 IV_length)\n{\n\tGF_Err e;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\t//setup generic protection\n\te = isom_set_protected_entry(the_file, trackNumber, desc_index, 0, 0, scheme_type, scheme_version, NULL, GF_TRUE, &sinf);\n\tif (e) return e;\n\n\tif (scheme_uri) {\n\t\tsinf->scheme_type->flags |= 0x000001;\n\t\tsinf->scheme_type->URI = gf_strdup(scheme_uri);\n\t}\n\n\tsinf->info->ikms = (GF_ISMAKMSBox *)gf_isom_box_new_parent(&sinf->info->child_boxes, GF_ISOM_BOX_TYPE_IKMS);\n\tif (!sinf->info->ikms) return GF_OUT_OF_MEM;\n\tsinf->info->ikms->URI = gf_strdup(kms_URI);\n\tif (!sinf->info->ikms->URI) return GF_OUT_OF_MEM;\n\n\tsinf->info->isfm = (GF_ISMASampleFormatBox *)gf_isom_box_new_parent(&sinf->info->child_boxes, GF_ISOM_BOX_TYPE_ISFM);\n\tif (!sinf->info->isfm) return GF_OUT_OF_MEM;\n\n\tsinf->info->isfm->selective_encryption = selective_encryption;\n\tsinf->info->isfm->key_indicator_length = KI_length;\n\tsinf->info->isfm->IV_length = IV_length;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_oma_protection(GF_ISOFile *the_file, u32 trackNumber, u32 desc_index,\n                                  char *contentID, char *kms_URI, u32 encryption_type, u64 plainTextLength, char *textual_headers, u32 textual_headers_len,\n                                  Bool selective_encryption, u32 KI_length, u32 IV_length)\n{\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tGF_Err e;\n\n\t//setup generic protection\n\te = isom_set_protected_entry(the_file, trackNumber, desc_index, 0, 0, GF_ISOM_OMADRM_SCHEME, 0x00000200, NULL, GF_FALSE, &sinf);\n\tif (e) return e;\n\n\tsinf->info->odkm = (GF_OMADRMKMSBox *)gf_isom_box_new_parent(&sinf->info->child_boxes, GF_ISOM_BOX_TYPE_ODKM);\n\tif (!sinf->info->odkm) return GF_OUT_OF_MEM;\n\tsinf->info->odkm->fmt = (GF_OMADRMAUFormatBox*)gf_isom_box_new_parent(&sinf->info->odkm->child_boxes, GF_ISOM_BOX_TYPE_ODAF);\n\tif (!sinf->info->odkm->fmt) return GF_OUT_OF_MEM;\n\tsinf->info->odkm->fmt->selective_encryption = selective_encryption;\n\tsinf->info->odkm->fmt->key_indicator_length = KI_length;\n\tsinf->info->odkm->fmt->IV_length = IV_length;\n\n\tsinf->info->odkm->hdr = (GF_OMADRMCommonHeaderBox*)gf_isom_box_new_parent(&sinf->info->odkm->child_boxes, GF_ISOM_BOX_TYPE_OHDR);\n\tif (!sinf->info->odkm->hdr) return GF_OUT_OF_MEM;\n\tsinf->info->odkm->hdr->EncryptionMethod = encryption_type;\n\tsinf->info->odkm->hdr->PaddingScheme = (encryption_type==0x01) ? 1 : 0;\n\tsinf->info->odkm->hdr->PlaintextLength = plainTextLength;\n\tif (contentID) sinf->info->odkm->hdr->ContentID = gf_strdup(contentID);\n\tif (kms_URI) sinf->info->odkm->hdr->RightsIssuerURL = gf_strdup(kms_URI);\n\tif (textual_headers) {\n\t\tsinf->info->odkm->hdr->TextualHeaders = (char*)gf_malloc(sizeof(char)*textual_headers_len);\n\t\tif (!sinf->info->odkm->hdr->TextualHeaders) return GF_OUT_OF_MEM;\n\t\tmemcpy(sinf->info->odkm->hdr->TextualHeaders, textual_headers, sizeof(char)*textual_headers_len);\n\t\tsinf->info->odkm->hdr->TextualHeadersLen = textual_headers_len;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_generic_protection(GF_ISOFile *the_file, u32 trackNumber, u32 desc_index, u32 scheme_type, u32 scheme_version, char *scheme_uri, char *kms_URI)\n{\n\tGF_Err e;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\t//setup generic protection\n\te = isom_set_protected_entry(the_file, trackNumber, desc_index, 0, 0, scheme_type, scheme_version, NULL, GF_TRUE, &sinf);\n\tif (e) return e;\n\n\tif (scheme_uri) {\n\t\tsinf->scheme_type->flags |= 0x000001;\n\t\tsinf->scheme_type->URI = gf_strdup(scheme_uri);\n\t}\n\n\tif (kms_URI) {\n\t\tsinf->info->ikms = (GF_ISMAKMSBox *)gf_isom_box_new_parent(&sinf->info->child_boxes, GF_ISOM_BOX_TYPE_IKMS);\n\t\tsinf->info->ikms->URI = gf_strdup(kms_URI);\n\t}\n\treturn GF_OK;\n}\n#endif // GPAC_DISABLE_ISOM_WRITE\n\nGF_EXPORT\nGF_Err gf_isom_get_original_format_type(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *sea;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tu32 i, count;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tif (sampleDescriptionIndex && (i+1 != sampleDescriptionIndex)) continue;\n\n\t\tMedia_GetSampleDesc(trak->Media, i+1, &sea, NULL);\n\t\tif (!sea) return GF_BAD_PARAM;\n\t\tsinf = (GF_ProtectionSchemeInfoBox*) gf_isom_box_find_child(sea->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (!sinf) continue;\n\n\t\tif (outOriginalFormat && sinf->original_format) {\n\t\t\t*outOriginalFormat = sinf->original_format->data_format;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (outOriginalFormat) *outOriginalFormat = 0;\n\treturn GF_OK;\n}\n\n\n/* Common Encryption*/\nGF_EXPORT\nBool gf_isom_is_cenc_media(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tu32 i, count;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tif (sampleDescriptionIndex && (i+1 != sampleDescriptionIndex)) continue;\n\n\t\tsinf = isom_get_sinf_entry(trak, i+1, GF_ISOM_CENC_SCHEME, NULL);\n\t\tif (!sinf) sinf = isom_get_sinf_entry(trak, i+1, GF_ISOM_CBC_SCHEME, NULL);\n\t\tif (!sinf) sinf = isom_get_sinf_entry(trak, i+1, GF_ISOM_CENS_SCHEME, NULL);\n\t\tif (!sinf) sinf = isom_get_sinf_entry(trak, i+1, GF_ISOM_CBCS_SCHEME, NULL);\n\t\tif (!sinf) sinf = isom_get_sinf_entry(trak, i+1, GF_ISOM_PIFF_SCHEME, NULL);\n\n\t\tif (!sinf) continue;\n\n\t\t/*non-encrypted or non-CENC*/\n\t\tif (!sinf->scheme_type)\n\t\t\treturn GF_FALSE;\n\n\t\tswitch (sinf->scheme_type->scheme_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_ISOM_SVE1_SCHEME:\n\t\t\treturn GF_TRUE;\n\t\tdefault:\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_cenc_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat, u32 *outSchemeType, u32 *outSchemeVersion)\n{\n\tGF_TrackBox *trak;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENC_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBC_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENS_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBCS_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_PIFF_SCHEME, NULL);\n\n\tif (!sinf) return GF_BAD_PARAM;\n\n\tif (outOriginalFormat) {\n\t\t*outOriginalFormat = sinf->original_format->data_format;\n\t\tif (IsMP4Description(sinf->original_format->data_format)) *outOriginalFormat = GF_ISOM_SUBTYPE_MPEG4;\n\t}\n\tif (outSchemeType) *outSchemeType = sinf->scheme_type->scheme_type;\n\tif (outSchemeVersion) *outSchemeVersion = sinf->scheme_type->scheme_version;\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gf_isom_set_cenc_protection(GF_ISOFile *the_file, u32 trackNumber, u32 desc_index, u32 scheme_type,\n                                   u32 scheme_version, u32 default_IsEncrypted, u8 default_crypt_byte_block, u8 default_skip_byte_block,\n\t\t\t\t\t\t\t\t    u8 *key_info, u32 key_info_size)\n{\n\tGF_Err e;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\tif (!gf_cenc_validate_key_info(key_info, key_info_size))\n\t\treturn GF_BAD_PARAM;\n\n\t//setup generic protection\n\te = isom_set_protected_entry(the_file, trackNumber, desc_index, 0, 0, scheme_type, scheme_version, NULL, GF_FALSE, &sinf);\n\tif (e) return e;\n\n\tif (scheme_type==GF_ISOM_PIFF_SCHEME) {\n\t\tsinf->info->piff_tenc = (GF_PIFFTrackEncryptionBox *) gf_isom_box_new_parent(&sinf->info->child_boxes, GF_ISOM_BOX_UUID_TENC);\n\t\tif (!sinf->info->piff_tenc) return GF_OUT_OF_MEM;\n\t\tsinf->info->piff_tenc->AlgorithmID = 1;\n\t\tsinf->info->piff_tenc->key_info[0] = 0;\n\t\tsinf->info->piff_tenc->key_info[1] = 0;\n\t\tsinf->info->piff_tenc->key_info[2] = 0;\n\t\tsinf->info->piff_tenc->key_info[3] = key_info[3];\n\t\tmemcpy(sinf->info->piff_tenc->key_info+4, key_info+4, 16*sizeof(char));\n\t}\n\t//tenc only for mkey\n\telse if (!key_info[0]) {\n\t\tif (key_info_size<20) return GF_BAD_PARAM;\n\t\tsinf->info->tenc = (GF_TrackEncryptionBox *)gf_isom_box_new_parent(&sinf->info->child_boxes, GF_ISOM_BOX_TYPE_TENC);\n\t\tif (!sinf->info->tenc) return GF_OUT_OF_MEM;\n\n\t\tsinf->info->tenc->isProtected = default_IsEncrypted;\n\t\tif ((scheme_type == GF_ISOM_CENS_SCHEME) || (scheme_type == GF_ISOM_CBCS_SCHEME)) {\n\t\t\tsinf->info->tenc->version = 1;\n\t\t\tsinf->info->tenc->crypt_byte_block = default_crypt_byte_block;\n\t\t\tsinf->info->tenc->skip_byte_block = default_skip_byte_block;\n\t\t}\n\t\tif (key_info_size>37) key_info_size = 37;\n\t\tmemcpy(sinf->info->tenc->key_info, key_info, key_info_size);\n\t}\n\treturn GF_OK;\n}\n\n\n#if 0\n/*! removes CENC SAI size info\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_remove_cenc_saiz(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tu32 i;\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl)\n\t\treturn GF_BAD_PARAM;\n\n\tfor (i = 0; i < gf_list_count(stbl->sai_sizes); i++) {\n\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(stbl->sai_sizes, i);\n\t\tswitch (saiz->aux_info_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *)saiz);\n\t\tgf_list_rem(stbl->sai_sizes, i);\n\t\ti--;\n\t}\n\n\tif (!gf_list_count(stbl->sai_sizes)) {\n\t\tgf_list_del(stbl->sai_sizes);\n\t\tstbl->sai_sizes = NULL;\n\t}\n\n\treturn GF_OK;\n}\n\n/*! removes CENC SAI offset info\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_remove_cenc_saio(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tu32 i;\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl)\n\t\treturn GF_BAD_PARAM;\n\n\tfor (i = 0; i < gf_list_count(stbl->sai_offsets); i++) {\n\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(stbl->sai_offsets, i);\n\t\tswitch (saio->aux_info_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *)saio);\n\t\tgf_list_rem(stbl->sai_offsets, i);\n\t\ti--;\n\t}\n\n\tif (!gf_list_count(stbl->sai_offsets)) {\n\t\tgf_list_del(stbl->sai_offsets);\n\t\tstbl->sai_offsets = NULL;\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\nGF_Err gf_cenc_set_pssh(GF_ISOFile *file, bin128 systemID, u32 version, u32 KID_count, bin128 *KIDs, u8 *data, u32 len, u32 pssh_mode)\n{\n\tGF_ProtectionSystemHeaderBox *pssh = NULL;\n\tGF_PIFFProtectionSystemHeaderBox *pssh_piff = NULL;\n\tu32 i=0;\n\tGF_Box *a;\n\tGF_List **child_boxes = NULL;\n\n\tif (pssh_mode==2) {\n\t\tif (!file->meta) return GF_BAD_PARAM;\n\t\tif (!file->meta->child_boxes) file->meta->child_boxes = gf_list_new();\n\t\tchild_boxes = &file->meta->child_boxes;\n\t} else if (file->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) {\n\t\tif (!file->moof) return GF_BAD_PARAM;\n\t\tif (!file->moof->PSSHs) file->moof->PSSHs = gf_list_new();\n\t\tchild_boxes = &file->moof->PSSHs;\n\t} else {\n\t\tif (!file->moov) return GF_BAD_PARAM;\n\t\tif (!file->moov->child_boxes) file->moov->child_boxes = gf_list_new();\n\t\tchild_boxes = &file->moov->child_boxes;\n\t}\n\n\twhile ((a = gf_list_enum(*child_boxes, &i))) {\n\t\tGF_UUIDBox *uuid = (GF_UUIDBox *)a;\n\t\tif (a->type==GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\tpssh = (GF_ProtectionSystemHeaderBox *)a;\n\t\t\tif (!memcmp(pssh->SystemID, systemID, sizeof(bin128))) break;\n\t\t\tpssh = NULL;\n\t\t} else if ((a->type==GF_ISOM_BOX_TYPE_UUID) && (uuid->internal_4cc==GF_ISOM_BOX_UUID_PSSH)) {\n\t\t\tpssh_piff = (GF_PIFFProtectionSystemHeaderBox *)a;\n\t\t\tif (!memcmp(pssh_piff->SystemID, systemID, sizeof(bin128))) break;\n\t\t\tpssh_piff = NULL;\n\t\t}\n\t}\n\t//we had a pssh with same ID but different private data, keep both...\n\tif (pssh && pssh->private_data && len && memcmp(pssh->private_data, data, sizeof(char)*len) ) {\n\t\tpssh = NULL;\n\t}\n\telse if (pssh_piff && pssh_piff->private_data && len && memcmp(pssh_piff->private_data, data, sizeof(char)*len) ) {\n\t\tpssh_piff = NULL;\n\t}\n\n\tif (!pssh && !pssh_piff) {\n\t\tif (pssh_mode==1) {\n\t\t\tpssh_piff = (GF_PIFFProtectionSystemHeaderBox *)gf_isom_box_new_parent(child_boxes, GF_ISOM_BOX_UUID_PSSH);\n\t\t\tif (!pssh_piff) return GF_IO_ERR;\n\t\t\tmemcpy((char *)pssh_piff->SystemID, systemID, sizeof(bin128));\n\t\t\tpssh_piff->version = version;\n\t\t} else {\n\t\t\tpssh = (GF_ProtectionSystemHeaderBox *)gf_isom_box_new_parent(child_boxes, GF_ISOM_BOX_TYPE_PSSH);\n\t\t\tif (!pssh) return GF_IO_ERR;\n\t\t\tmemcpy((char *)pssh->SystemID, systemID, sizeof(bin128));\n\t\t\tpssh->version = version;\n\t\t}\n\t}\n\n\tif (pssh && KID_count) {\n\t\tu32 j;\n\t\tfor (j=0; j<KID_count; j++) {\n\t\t\tBool found = GF_FALSE;\n\t\t\tfor (i=0; i<pssh->KID_count; i++) {\n\t\t\t\tif (!memcmp(pssh->KIDs[i], KIDs[j], sizeof(bin128))) found = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (!found) {\n\t\t\t\tpssh->KIDs = gf_realloc(pssh->KIDs, sizeof(bin128) * (pssh->KID_count+1));\n\t\t\t\tif (!pssh->KIDs) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(pssh->KIDs[pssh->KID_count], KIDs[j], sizeof(bin128));\n\t\t\t\tpssh->KID_count++;\n\t\t\t}\n\t\t}\n\t\tif (!pssh->version)\n\t\t\tpssh->version = 1;\n\t}\n\n\tif (pssh) {\n\t\tif (!pssh->private_data_size) {\n\t\t\tpssh->private_data_size = len;\n\t\t\tif (len) {\n\t\t\t\tif (!pssh->private_data) {\n\t\t\t\t\tpssh->private_data = (u8 *)gf_malloc(pssh->private_data_size*sizeof(char));\n\t\t\t\t\tif (!pssh->private_data) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tmemcpy((char *)pssh->private_data, data, pssh->private_data_size);\n\t\t\t}\n\t\t}\n\t} else if (pssh_piff) {\n\t\tif (!pssh_piff->private_data_size) {\n\t\t\tpssh_piff->private_data_size = len;\n\t\t\tif (len) {\n\t\t\t\tif (!pssh_piff->private_data) {\n\t\t\t\t\tpssh_piff->private_data = (u8 *)gf_malloc(pssh_piff->private_data_size*sizeof(char));\n\t\t\t\t\tif (!pssh_piff->private_data) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tmemcpy((char *)pssh_piff->private_data, data, pssh_piff->private_data_size);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\n\nGF_Err gf_isom_remove_samp_enc_box(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tu32 i;\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl)\n\t\treturn GF_BAD_PARAM;\n\n\tfor (i = 0; i < gf_list_count(stbl->child_boxes); i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(stbl->child_boxes, i);\n\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\ti--;\n\t\t}\n\t\telse if (a->type == GF_ISOM_BOX_TYPE_SENC) {\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\ti--;\n\t\t}\n\t}\n\n\tif (!gf_list_count(stbl->child_boxes)) {\n\t\tgf_list_del(stbl->child_boxes);\n\t\tstbl->child_boxes = NULL;\n\t}\n\tfor (i = 0; i < gf_list_count(trak->child_boxes); i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->child_boxes, i);\n\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\tgf_isom_box_del_parent(&trak->child_boxes, a);\n\t\t\ti--;\n\t\t}\n\t\telse if (a->type == GF_ISOM_BOX_TYPE_SENC) {\n\t\t\tgf_isom_box_del_parent(&trak->child_boxes, a);\n\t\t\ti--;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_remove_samp_group_box(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tu32 i;\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl)\n\t\treturn GF_BAD_PARAM;\n\n\tfor (i = 0; i < gf_list_count(stbl->sampleGroupsDescription); i++) {\n\t\tGF_SampleGroupDescriptionBox *a = (GF_SampleGroupDescriptionBox *)gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tif (a->grouping_type == GF_ISOM_SAMPLE_GROUP_SEIG) {\n\t\t\tgf_list_rem(stbl->sampleGroupsDescription, i);\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *) a);\n\t\t\ti--;\n\t\t}\n\t}\n\tif (!gf_list_count(stbl->sampleGroupsDescription)) {\n\t\tgf_list_del(stbl->sampleGroupsDescription);\n\t\tstbl->sampleGroupsDescription = NULL;\n\t}\n\n\tfor (i = 0; i < gf_list_count(stbl->sampleGroups); i++) {\n\t\tGF_SampleGroupBox *a = (GF_SampleGroupBox *)gf_list_get(stbl->sampleGroups, i);\n\t\tif (a->grouping_type == GF_ISOM_SAMPLE_GROUP_SEIG) {\n\t\t\tgf_list_rem(stbl->sampleGroups, i);\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *) a);\n\t\t\ti--;\n\t\t}\n\t}\n\tif (!gf_list_count(stbl->sampleGroups)) {\n\t\tgf_list_del(stbl->sampleGroups);\n\t\tstbl->sampleGroups = NULL;\n\t}\n\n\treturn GF_OK;\n}\n\n#if 0 //unused\n/*! removes CENC PSSH box\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_remove_pssh_box(GF_ISOFile *the_file)\n{\n\tu32 i;\n\tfor (i = 0; i < gf_list_count(the_file->moov->child_boxes); i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(the_file->moov->child_boxes, i);\n\t\tGF_UUIDBox *uuid = (GF_UUIDBox *)a;\n\t\tif ((a->type == GF_ISOM_BOX_TYPE_PSSH)\n\t\t\t|| ((a->type == GF_ISOM_BOX_TYPE_UUID) && (uuid->internal_4cc == GF_ISOM_BOX_UUID_PSSH))\n\t\t) {\n\t\t\tgf_isom_box_del_parent(&the_file->moov->child_boxes, a);\n\t\t\ti--;\n\t\t}\n\t}\n\n\tif (!gf_list_count(the_file->moov->child_boxes)) {\n\t\tgf_list_del(the_file->moov->child_boxes);\n\t\tthe_file->moov->child_boxes = NULL;\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_SampleEncryptionBox * gf_isom_create_piff_psec_box(u8 version, u32 flags, u32 AlgorithmID, u8 IV_size, bin128 KID)\n{\n\tGF_SampleEncryptionBox *psec;\n\n\tpsec = (GF_SampleEncryptionBox *) gf_isom_box_new(GF_ISOM_BOX_UUID_PSEC);\n\tif (!psec)\n\t\treturn NULL;\n\tpsec->version = version;\n\tpsec->flags = flags;\n\tpsec->piff_type = 1;\n\tif (psec->flags & 0x1) {\n\t\tpsec->AlgorithmID = AlgorithmID;\n\t\tpsec->IV_size = IV_size;\n\t\tstrcpy((char *)psec->KID, (const char *)KID);\n\t}\n\tpsec->samp_aux_info = gf_list_new();\n\n\treturn psec;\n}\n\nGF_SampleEncryptionBox * gf_isom_create_samp_enc_box(u8 version, u32 flags)\n{\n\tGF_SampleEncryptionBox *senc;\n\n\tsenc = (GF_SampleEncryptionBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SENC);\n\tif (!senc)\n\t\treturn NULL;\n\tsenc->version = version;\n\tsenc->flags = flags;\n\tsenc->samp_aux_info = gf_list_new();\n\n\treturn senc;\n}\n\nGF_Err gf_isom_cenc_allocate_storage(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->sample_encryption) return GF_OK;\n\ttrak->sample_encryption = (GF_SampleEncryptionBox *)gf_isom_create_samp_enc_box(0, 0);\n\t//senc will be written and destroyed with the other boxes\n\tif (!trak->child_boxes) trak->child_boxes = gf_list_new();\n\treturn gf_list_add(trak->child_boxes, trak->sample_encryption);\n}\n\nGF_Err gf_isom_piff_allocate_storage(GF_ISOFile *the_file, u32 trackNumber, u32 AlgorithmID, u8 IV_size, bin128 KID)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->sample_encryption) return GF_OK;\n\ttrak->sample_encryption = (GF_SampleEncryptionBox *)gf_isom_create_piff_psec_box(1, 0, AlgorithmID, IV_size, KID);\n\t//senc will be written and destroyed with the other boxes\n\tif (!trak->child_boxes) trak->child_boxes = gf_list_new();\n\treturn gf_list_add(trak->child_boxes, trak->sample_encryption);\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nvoid gf_isom_cenc_set_saiz_saio(GF_SampleEncryptionBox *senc, GF_SampleTableBox *stbl, GF_TrackFragmentBox  *traf, u32 len, Bool saio_32bits, Bool use_multikey)\n{\n\tu32  i;\n\tGF_List **child_boxes = stbl ? &stbl->child_boxes : &traf->child_boxes;\n\tif (!senc->cenc_saiz) {\n\t\tsenc->cenc_saiz = (GF_SampleAuxiliaryInfoSizeBox *) gf_isom_box_new_parent(child_boxes, GF_ISOM_BOX_TYPE_SAIZ);\n\t\tif (!senc->cenc_saiz) return;\n\t\t//as per 3rd edition of cenc \"so content SHOULD be created omitting these optional fields\" ...\n\t\tsenc->cenc_saiz->aux_info_type = 0;\n\t\tsenc->cenc_saiz->aux_info_type_parameter = use_multikey ? 1 : 0;\n\t\tif (stbl)\n\t\t\tstbl_on_child_box((GF_Box*)stbl, (GF_Box *)senc->cenc_saiz, GF_FALSE);\n\t\telse\n\t\t\ttraf_on_child_box((GF_Box*)traf, (GF_Box *)senc->cenc_saiz, GF_FALSE);\n\t}\n\tif (!senc->cenc_saio) {\n\t\tsenc->cenc_saio = (GF_SampleAuxiliaryInfoOffsetBox *) gf_isom_box_new_parent(child_boxes, GF_ISOM_BOX_TYPE_SAIO);\n\t\tif (!senc->cenc_saio) return;\n\t\t//force using version 1 for saio box, it could be redundant when we use 64 bits for offset\n\t\tsenc->cenc_saio->version = saio_32bits ? 0 : 1;\n\t\t//as per 3rd edition of cenc \"so content SHOULD be created omitting these optional fields\" ...\n\t\tsenc->cenc_saio->aux_info_type = 0;\n\t\tsenc->cenc_saiz->aux_info_type_parameter = use_multikey ? 1 : 0;\n\t\tsenc->cenc_saio->entry_count = 1;\n\t\tif (stbl)\n\t\t\tstbl_on_child_box((GF_Box*)stbl, (GF_Box *)senc->cenc_saio, GF_FALSE);\n\t\telse\n\t\t\ttraf_on_child_box((GF_Box*)traf, (GF_Box *)senc->cenc_saio, GF_FALSE);\n\t}\n\n\tif (!senc->cenc_saiz->sample_count || ((senc->cenc_saiz->default_sample_info_size==len) && len) ) {\n\t\tsenc->cenc_saiz->sample_count ++;\n\t\tsenc->cenc_saiz->default_sample_info_size = len;\n\t} else {\n\t\tif (senc->cenc_saiz->sample_count + 1 > senc->cenc_saiz->sample_alloc) {\n\t\t\tif (!senc->cenc_saiz->sample_alloc) senc->cenc_saiz->sample_alloc = senc->cenc_saiz->sample_count+1;\n\t\t\telse senc->cenc_saiz->sample_alloc *= 2;\n\n\t\t\tsenc->cenc_saiz->sample_info_size = (u8*)gf_realloc(senc->cenc_saiz->sample_info_size, sizeof(u8)*(senc->cenc_saiz->sample_alloc));\n\t\t}\n\n\t\tif (senc->cenc_saiz->default_sample_info_size || (senc->cenc_saiz->sample_count==1)) {\n\t\t\tfor (i=0; i<senc->cenc_saiz->sample_count; i++)\n\t\t\t\tsenc->cenc_saiz->sample_info_size[i] = senc->cenc_saiz->default_sample_info_size;\n\t\t\tsenc->cenc_saiz->default_sample_info_size = 0;\n\t\t}\n\t\tsenc->cenc_saiz->sample_info_size[senc->cenc_saiz->sample_count] = len;\n\t\tsenc->cenc_saiz->sample_count++;\n\t}\n}\n\nGF_Err gf_isom_cenc_merge_saiz_saio(GF_SampleEncryptionBox *senc, GF_SampleTableBox *stbl, u64 offset, u32 len)\n{\n\tu32  i;\n\tassert(stbl);\n\tif (!senc->cenc_saiz) {\n\t\tsenc->cenc_saiz = (GF_SampleAuxiliaryInfoSizeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_SAIZ);\n\t\tif (!senc->cenc_saiz) return GF_OUT_OF_MEM;\n\t\tsenc->cenc_saiz->aux_info_type = GF_ISOM_CENC_SCHEME;\n\t\tsenc->cenc_saiz->aux_info_type_parameter = 0;\n\t\tstbl_on_child_box((GF_Box*)stbl, (GF_Box *)senc->cenc_saiz, GF_FALSE);\n\t}\n\tif (!senc->cenc_saio) {\n\t\tsenc->cenc_saio = (GF_SampleAuxiliaryInfoOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_SAIO);\n\t\tif (!senc->cenc_saio) return GF_OUT_OF_MEM;\n\t\t//force using version 1 for saio box, it could be redundant when we use 64 bits for offset\n\t\tsenc->cenc_saio->version = 1;\n\t\tsenc->cenc_saio->aux_info_type = GF_ISOM_CENC_SCHEME;\n\t\tsenc->cenc_saio->aux_info_type_parameter = 0;\n\t\tstbl_on_child_box((GF_Box*)stbl, (GF_Box *)senc->cenc_saio, GF_FALSE);\n\t}\n\n\tif (!senc->cenc_saiz->sample_count || (!senc->cenc_saiz->sample_alloc && (senc->cenc_saiz->default_sample_info_size==len))) {\n\t\tsenc->cenc_saiz->sample_count ++;\n\t\tsenc->cenc_saiz->default_sample_info_size = len;\n\t} else {\n\t\tif (senc->cenc_saiz->sample_count + 1 > senc->cenc_saiz->sample_alloc) {\n\t\t\tif (!senc->cenc_saiz->sample_alloc) senc->cenc_saiz->sample_alloc = senc->cenc_saiz->sample_count + 1;\n\t\t\telse senc->cenc_saiz->sample_alloc *= 2;\n\t\t\tsenc->cenc_saiz->sample_info_size = (u8*)gf_realloc(senc->cenc_saiz->sample_info_size, sizeof(u8)*(senc->cenc_saiz->sample_alloc));\n\t\t\tif (!senc->cenc_saiz->sample_info_size) return GF_OUT_OF_MEM;\n\t\t}\n\n\t\tif (senc->cenc_saiz->default_sample_info_size) {\n\t\t\tfor (i=0; i<senc->cenc_saiz->sample_count; i++)\n\t\t\t\tsenc->cenc_saiz->sample_info_size[i] = senc->cenc_saiz->default_sample_info_size;\n\t\t\tsenc->cenc_saiz->default_sample_info_size = 0;\n\t\t}\n\t\tsenc->cenc_saiz->sample_info_size[senc->cenc_saiz->sample_count] = len;\n\t\tsenc->cenc_saiz->sample_count++;\n\t}\n\n\tif (!senc->cenc_saio->entry_count) {\n\t\tsenc->cenc_saio->offsets = (u64 *)gf_malloc(sizeof(u64));\n\t\tif (!senc->cenc_saio->offsets) return GF_OUT_OF_MEM;\n\t\tsenc->cenc_saio->offsets[0] = offset;\n\t\tsenc->cenc_saio->entry_count ++;\n\t\tsenc->cenc_saio->entry_alloc = 1;\n\t} else {\n\t\tif (senc->cenc_saio->entry_count >= senc->cenc_saio->entry_alloc) {\n\t\t\tsenc->cenc_saio->entry_alloc += 50;\n\t\t\tsenc->cenc_saio->offsets = (u64*)gf_realloc(senc->cenc_saio->offsets, sizeof(u64)*(senc->cenc_saio->entry_alloc));\n\t\t\tif (!senc->cenc_saio->offsets) return GF_OUT_OF_MEM;\n\t\t}\n\t\tsenc->cenc_saio->offsets[senc->cenc_saio->entry_count] = offset;\n\t\tsenc->cenc_saio->entry_count++;\n\t}\n\tif (offset > 0xFFFFFFFFUL)\n\t\tsenc->cenc_saio->version=1;\n\treturn GF_OK;\n}\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n\nGF_Err gf_isom_track_cenc_add_sample_info(GF_ISOFile *the_file, u32 trackNumber, u32 container_type, u8 *buf, u32 len, Bool use_subsamples, Bool use_saio_32bit, Bool use_multikey)\n{\n\tGF_SampleEncryptionBox *senc;\n\tGF_CENCSampleAuxInfo *sai;\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl) return GF_BAD_PARAM;\n\n\tswitch (container_type) {\n\tcase GF_ISOM_BOX_UUID_PSEC:\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\tcase 0:\n\t\tsenc = trak->sample_encryption;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif (len && buf) {\n\t\tGF_SAFEALLOC(sai, GF_CENCSampleAuxInfo);\n\t\tif (!sai) return GF_OUT_OF_MEM;\n\t\tsai->cenc_data_size = len;\n\t\tsai->cenc_data = gf_malloc(sizeof(u8) * len);\n\t\tif (!sai->cenc_data) {\n\t\t\tgf_free(sai);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tmemcpy(sai->cenc_data, buf, len);\n\n\t\tgf_list_add(senc->samp_aux_info, sai);\n\t} else {\n\t\tGF_SAFEALLOC(sai, GF_CENCSampleAuxInfo);\n\t\tif (!sai) return GF_OUT_OF_MEM;\n\t\tgf_list_add(senc->samp_aux_info, sai);\n\t\tsai->isNotProtected = 1;\n\t}\n\tif (use_subsamples)\n\t\tsenc->flags = 0x00000002;\n\tif (use_multikey)\n\t\tsenc->version = 1;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tgf_isom_cenc_set_saiz_saio(senc, stbl, NULL, sai->cenc_data_size, use_saio_32bit, use_multikey);\n#endif\n\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nvoid gf_isom_cenc_samp_aux_info_del(GF_CENCSampleAuxInfo *samp)\n{\n\tif (!samp) return;\n\tif (samp->cenc_data) gf_free(samp->cenc_data);\n\tgf_free(samp);\n}\n\nBool gf_isom_cenc_has_saiz_saio_full(GF_SampleTableBox *stbl, void *_traf, u32 scheme_type)\n{\n\tu32 i, c1, c2;\n\tGF_List *sai_sizes, *sai_offsets;\n\tu32 sinf_fmt = 0;\n\tBool has_saiz, has_saio;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf=(GF_TrackFragmentBox *)_traf;\n#endif\n\thas_saiz = has_saio = GF_FALSE;\n\n\tif (stbl) {\n\t\tsai_sizes = stbl->sai_sizes;\n\t\tsai_offsets = stbl->sai_offsets;\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\telse if (_traf) {\n\t\tsai_sizes = traf->sai_sizes;\n\t\tsai_offsets = traf->sai_offsets;\n\t}\n#endif\n\telse\n\t\treturn GF_FALSE;\n\n\tc1 = gf_list_count(sai_sizes);\n\tc2 = gf_list_count(sai_offsets);\n\tfor (i = 0; i < c1; i++) {\n\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(sai_sizes, i);\n\t\tu32 saiz_aux_info_type = saiz->aux_info_type;\n\t\tif (!saiz_aux_info_type) saiz_aux_info_type = scheme_type;\n\n\n\t\tif (!saiz_aux_info_type) {\n\t\t\tGF_SampleEntryBox *entry = NULL;\n\t\t\tGF_ProtectionSchemeInfoBox *sinf = NULL;\n\t\t\tif (stbl) {\n\t\t\t\tentry = gf_list_get(stbl->SampleDescription->child_boxes, 0);\n\t\t\t} else {\n\t\t\t\tentry = gf_list_get(traf->trex->track->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\t\t}\n\n\t\t\tif (entry)\n\t\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\t\tif (sinf && sinf->scheme_type) {\n\t\t\t\tsaiz_aux_info_type = sinf_fmt = sinf->scheme_type->scheme_type;\n\t\t\t}\n\t\t}\n\t\tif (!saiz_aux_info_type && (c1==1) && (c2==1)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] saiz box without flags nor aux info type and no default scheme, ignoring\\n\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (saiz_aux_info_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_ISOM_PIFF_SCHEME:\n\t\t\thas_saiz = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < c2; i++) {\n\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(sai_offsets, i);\n\t\tu32 saio_aux_info_type = saio->aux_info_type;\n\t\tif (!saio_aux_info_type) saio_aux_info_type = scheme_type;\n\t\tif (!saio_aux_info_type) saio_aux_info_type = sinf_fmt;\n\n\t\tif (!saio_aux_info_type) {\n\t\t\tGF_SampleEntryBox *entry = NULL;\n\t\t\tGF_ProtectionSchemeInfoBox *sinf = NULL;\n\t\t\tif (stbl) {\n\t\t\t\tentry = gf_list_get(stbl->SampleDescription->child_boxes, 0);\n\t\t\t} else {\n\t\t\t\tentry = gf_list_get(traf->trex->track->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\t\t}\n\t\t\tif (entry)\n\t\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\t\tif (sinf && sinf->scheme_type) {\n\t\t\t\tsaio_aux_info_type = sinf_fmt = sinf->scheme_type->scheme_type;\n\t\t\t}\n\t\t}\n\t\tif (!saio_aux_info_type && (c1==1) && (c2==1)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] saio box without flags nor aux info type and no default scheme, ignoring\\n\"));\n\t\t\tcontinue;\n\t\t}\n\t\t//special case for query on a file that has just been imported but not yet written: saio offset is NULL, we must use senc\n\t\tif (saio->entry_count && !saio->offsets)\n\t\t\tcontinue;\n\t\tswitch (saio_aux_info_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_ISOM_PIFF_SCHEME:\n\t\t\thas_saio = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (has_saiz && has_saio);\n}\n\nBool gf_isom_cenc_has_saiz_saio_track(GF_SampleTableBox *stbl, u32 scheme_type)\n{\n\treturn gf_isom_cenc_has_saiz_saio_full(stbl, NULL, scheme_type);\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nBool gf_isom_cenc_has_saiz_saio_traf(GF_TrackFragmentBox *traf, u32 scheme_type)\n{\n\treturn gf_isom_cenc_has_saiz_saio_full(NULL, traf, scheme_type);\n}\n#endif\n\n\nstatic GF_Err isom_cenc_get_sai_by_saiz_saio(GF_MediaBox *mdia, u32 sampleNumber, u32 scheme_type, u8 **out_buffer, u32 *out_size)\n{\n\tu32  prev_sai_size, size, i, j, nb_saio;\n\tu64 cur_position, offset;\n\tGF_Err e = GF_OK;\n\tGF_SampleAuxiliaryInfoOffsetBox *saio_cenc=NULL;\n\tGF_SampleAuxiliaryInfoSizeBox *saiz_cenc=NULL;\n\tnb_saio = size = prev_sai_size = 0;\n\toffset = 0;\n\n\tif (! out_buffer || !out_size) return GF_BAD_PARAM;\n\n\tfor (i = 0; i < gf_list_count(mdia->information->sampleTable->sai_offsets); i++) {\n\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(mdia->information->sampleTable->sai_offsets, i);\n\t\tu32 aux_info_type = saio->aux_info_type;\n\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\n\t\tswitch (aux_info_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_ISOM_PIFF_SCHEME:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (saio->entry_count == 1)\n\t\t\toffset = saio->offsets[0];\n\t\telse\n\t\t\toffset = saio->offsets[sampleNumber-1];\n\t\tnb_saio = saio->entry_count;\n\t\tsaio_cenc = saio;\n\t\tbreak;\n\t}\n\tif (!saio_cenc) return GF_ISOM_INVALID_FILE;\n\n\tfor (i = 0; i < gf_list_count(mdia->information->sampleTable->sai_sizes); i++) {\n\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(mdia->information->sampleTable->sai_sizes, i);\n\t\tu32 aux_info_type = saiz->aux_info_type;\n\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\n\t\tswitch (aux_info_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_ISOM_PIFF_SCHEME:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif (sampleNumber>saiz->sample_count) {\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tif ((nb_saio==1) && !saio_cenc->total_size) {\n\t\t\tfor (j = 0; j < saiz->sample_count; j++) {\n\t\t\t\tsaio_cenc->total_size += saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[j];\n\t\t\t}\n\t\t}\n\t\tif (saiz->cached_sample_num+1== sampleNumber) {\n\t\t\tprev_sai_size = saiz->cached_prev_size;\n\t\t} else {\n\t\t\tfor (j = 0; j < sampleNumber-1; j++)\n\t\t\t\tprev_sai_size += saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[j];\n\t\t}\n\t\tsize = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[sampleNumber-1];\n\t\tsaiz_cenc=saiz;\n\t\tbreak;\n\t}\n\tif (!saiz_cenc) return GF_BAD_PARAM;\n\n\tsaiz_cenc->cached_sample_num = sampleNumber;\n\tsaiz_cenc->cached_prev_size = prev_sai_size + size;\n\n\tif (saio_cenc->total_size) {\n\t\tif (!saio_cenc->cached_data) {\n\t\t\tsaio_cenc->cached_data = gf_malloc(sizeof(u8)*saio_cenc->total_size);\n\t\t\tif (!saio_cenc->cached_data) return GF_OUT_OF_MEM;\n\t\t\tcur_position = gf_bs_get_position(mdia->information->dataHandler->bs);\n\t\t\tgf_bs_seek(mdia->information->dataHandler->bs, offset);\n\t\t\tgf_bs_read_data(mdia->information->dataHandler->bs, saio_cenc->cached_data, saio_cenc->total_size);\n\t\t\tgf_bs_seek(mdia->information->dataHandler->bs, cur_position);\n\t\t}\n\t\tif (out_size) {\n\t\t\tif (out_buffer) {\n\t\t\t\tif ((*out_size) < size) {\n\t\t\t\t\t(*out_buffer) = gf_realloc((*out_buffer), sizeof(char)*(size) );\n\t\t\t\t\tif (! *out_buffer) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tmemcpy((*out_buffer), saio_cenc->cached_data + prev_sai_size, size);\n\t\t\t}\n\t\t\t(*out_size) = size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\toffset += (nb_saio == 1) ? prev_sai_size : 0;\n\tcur_position = gf_bs_get_position(mdia->information->dataHandler->bs);\n\tgf_bs_seek(mdia->information->dataHandler->bs, offset);\n\n\tif (out_buffer) {\n\t\tif ((*out_size) < size) {\n\t\t\t(*out_buffer) = gf_realloc((*out_buffer), sizeof(char)*(size) );\n\t\t\tif (! *out_buffer) return GF_OUT_OF_MEM;\n\t\t}\n\t\tgf_bs_read_data(mdia->information->dataHandler->bs, (*out_buffer), size);\n\t}\n\t(*out_size) = size;\n\n\tgf_bs_seek(mdia->information->dataHandler->bs, cur_position);\n\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_cenc_get_sample_aux_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 sampleDescIndex, u32 *container_type, u8 **out_buffer, u32 *outSize)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\tGF_SampleEncryptionBox *senc = NULL;\n\tu32 type, scheme_type = -1;\n\tGF_CENCSampleAuxInfo *a_sai;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl)\n\t\treturn GF_BAD_PARAM;\n\n\ttype = 0;\n\tsenc = trak->sample_encryption;\n\t//no senc is OK\n\tif (senc) {\n\t\tif ((senc->type == GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)senc)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\ttype = GF_ISOM_BOX_UUID_PSEC;\n\t\t} else if (senc->type == GF_ISOM_BOX_TYPE_SENC) {\n\t\t\ttype = GF_ISOM_BOX_TYPE_SENC;\n\t\t}\n\n\t\tif (container_type) *container_type = type;\n\t}\n\n\tif (!out_buffer) return GF_OK; /*we need only container_type*/\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\tgf_isom_get_cenc_info(the_file, trackNumber, sampleDescIndex, NULL, &scheme_type, NULL);\n\n\t/*get sample auxiliary information by saiz/saio rather than by parsing senc box*/\n\tif (gf_isom_cenc_has_saiz_saio_track(stbl, scheme_type)) {\n\t\treturn isom_cenc_get_sai_by_saiz_saio(trak->Media, sampleNumber, scheme_type, out_buffer, outSize);\n\t}\n\tif (!senc)\n\t\treturn GF_OK;\n\n\t//senc is not loaded by default, do it now\n\tif (!gf_list_count(senc->samp_aux_info)) {\n\t\tGF_Err e = senc_Parse(trak->Media->information->dataHandler->bs, trak, NULL, senc);\n\t\tif (e) return e;\n\t}\n\n\ta_sai = NULL;\n\tswitch (type) {\n\tcase GF_ISOM_BOX_UUID_PSEC:\n\t\tif (senc)\n\t\t\ta_sai = (GF_CENCSampleAuxInfo *)gf_list_get(senc->samp_aux_info, sampleNumber-1);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\t\tif (senc)\n\t\t\ta_sai = (GF_CENCSampleAuxInfo *)gf_list_get(senc->samp_aux_info, sampleNumber-1);\n\t\tbreak;\n\t}\n\t//not present, check we use constant IV and no IV size\n\tif (!a_sai) {\n\t\tconst u8 *key_info=NULL;\n\t\tu32 key_info_size=0;\n\t\tu8 IV_size=0, constant_IV_size=0;\n\t\tBool is_Protected;\n\n\t\tgf_isom_get_sample_cenc_info_internal(trak, NULL, senc, sampleNumber, &is_Protected, NULL, NULL, &key_info, &key_info_size);\n\t\tif (!key_info) {\n\t\t\tIV_size = key_info_size; //piff default\n\t\t} else {\n\t\t\tIV_size = key_info[3];\n\t\t\tif (!IV_size)\n\t\t\t\tconstant_IV_size = key_info[20];\n\t\t}\n\t\tif (!IV_size && constant_IV_size)\n\t\t\treturn GF_OK;\n\t\treturn GF_NOT_FOUND;\n\t}\n\n\tif (*outSize < a_sai->cenc_data_size) {\n\t\t*out_buffer = gf_realloc(*out_buffer, sizeof(char) * a_sai->cenc_data_size);\n\t\tif (! *out_buffer) return GF_OUT_OF_MEM;\n\t\t*outSize = a_sai->cenc_data_size;\n\t}\n\tmemcpy(*out_buffer, a_sai->cenc_data, a_sai->cenc_data_size);\n\treturn GF_OK;\n}\n\nu32 gf_isom_has_cenc_sample_group_ex(GF_TrackBox *trak);\n\nvoid gf_isom_cenc_get_default_info_internal(GF_TrackBox *trak, u32 sampleDescriptionIndex, u32 *container_type, Bool *default_IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n{\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\n\t//setup all default as not encrypted\n\tif (default_IsEncrypted) *default_IsEncrypted = GF_FALSE;\n\tif (crypt_byte_block) *crypt_byte_block = 0;\n\tif (skip_byte_block) *skip_byte_block = 0;\n\tif (container_type) *container_type = 0;\n\tif (key_info) *key_info = NULL;\n\tif (key_info_size) *key_info_size = 0;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENC_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBC_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENS_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBCS_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_PIFF_SCHEME, NULL);\n\n\tif (!sinf) {\n\t\tu32 i, nb_stsd = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\t\tfor (i=0; i<nb_stsd; i++) {\n\t\t\tGF_ProtectionSchemeInfoBox *a_sinf;\n\t\t\tGF_SampleEntryBox *sentry=NULL;\n\t\t\tif (i+1==sampleDescriptionIndex) continue;\n\t\t\tsentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\t\ta_sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(sentry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\t\tif (!a_sinf) continue;\n\t\t\t//signal default (not encrypted)\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (sinf && sinf->info && sinf->info->tenc) {\n\t\tif (default_IsEncrypted) *default_IsEncrypted = sinf->info->tenc->isProtected;\n\t\tif (crypt_byte_block) *crypt_byte_block = sinf->info->tenc->crypt_byte_block;\n\t\tif (skip_byte_block) *skip_byte_block = sinf->info->tenc->skip_byte_block;\n\t\tif (key_info) *key_info = sinf->info->tenc->key_info;\n\t\tif (key_info_size) {\n\t\t\t*key_info_size = 20;\n\t\t\tif (!sinf->info->tenc->key_info[3])\n\t\t\t\t*key_info_size += 1 + sinf->info->tenc->key_info[20];\n\t\t}\n\n\t\t//set default value, overwritten below\n\t\tif (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC;\n\t} else if (sinf && sinf->info && sinf->info->piff_tenc) {\n\t\tif (default_IsEncrypted) *default_IsEncrypted = GF_TRUE;\n\t\tif (key_info) *key_info = sinf->info->piff_tenc->key_info;\n\t\tif (key_info_size) *key_info_size = 19;\n\t\t//set default value, overwritten below\n\t\tif (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC;\n\t} else {\n\t\tu32 i, count = 0;\n\t\tGF_CENCSampleEncryptionGroupEntry *seig_entry = NULL;\n\n\t\tif (!trak->moov->mov->is_smooth)\n\t\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\tif (sgdesc->grouping_type!=GF_ISOM_SAMPLE_GROUP_SEIG) continue;\n\t\t\tif (sgdesc->default_description_index)\n\t\t\t\tseig_entry = gf_list_get(sgdesc->group_descriptions, sgdesc->default_description_index-1);\n\t\t\telse\n\t\t\t\tseig_entry = gf_list_get(sgdesc->group_descriptions, 0);\n\t\t\tif (!seig_entry->key_info[0])\n\t\t\t\tseig_entry = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (seig_entry) {\n\t\t\tif (default_IsEncrypted) *default_IsEncrypted = seig_entry->IsProtected;\n\t\t\tif (crypt_byte_block) *crypt_byte_block = seig_entry->crypt_byte_block;\n\t\t\tif (skip_byte_block) *skip_byte_block = seig_entry->skip_byte_block;\n\t\t\tif (key_info) *key_info = seig_entry->key_info;\n\t\t\tif (key_info_size) *key_info_size = seig_entry->key_info_size;\n\t\t\tif (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC;\n\t\t} else {\n\t\t\tif (! trak->moov->mov->is_smooth ) {\n\t\t\t\ttrak->moov->mov->is_smooth = GF_TRUE;\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] senc box without tenc, assuming MS smooth+piff\\n\"));\n\t\t\t}\n\t\t\tif (default_IsEncrypted) *default_IsEncrypted = GF_TRUE;\n\t\t\t//set default value, overwritten below\n\t\t\tif (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC;\n\t\t}\n\t}\n\n\tif (container_type && trak->sample_encryption) {\n\t\tif (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_SENC) *container_type = GF_ISOM_BOX_TYPE_SENC;\n\t\telse if (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_UUID) *container_type = ((GF_UUIDBox*)trak->sample_encryption)->internal_4cc;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_cenc_get_default_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *container_type, Bool *default_IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tgf_isom_cenc_get_default_info_internal(trak, sampleDescriptionIndex, container_type, default_IsEncrypted, crypt_byte_block, skip_byte_block, key_info, key_info_size);\n\treturn GF_OK;\n}\n\n/*\n\tAdobe'protection scheme\n*/\nGF_Err gf_isom_set_adobe_protection(GF_ISOFile *the_file, u32 trackNumber, u32 desc_index, u32 scheme_type, u32 scheme_version, Bool is_selective_enc, char *metadata, u32 len)\n{\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\t//setup generic protection\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_Err e;\n\te = isom_set_protected_entry(the_file, trackNumber, desc_index, 1, 0, scheme_type, scheme_version, NULL, GF_FALSE, &sinf);\n\tif (e) return e;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n\n\tsinf->info->adkm = (GF_AdobeDRMKeyManagementSystemBox *)gf_isom_box_new_parent(&sinf->info->child_boxes, GF_ISOM_BOX_TYPE_ADKM);\n\tif (!sinf->info->adkm) return GF_OUT_OF_MEM;\n\n\tsinf->info->adkm->header = (GF_AdobeDRMHeaderBox *)gf_isom_box_new_parent(&sinf->info->adkm->child_boxes, GF_ISOM_BOX_TYPE_AHDR);\n\tif (!sinf->info->adkm->header) return GF_OUT_OF_MEM;\n\n\tsinf->info->adkm->header->std_enc_params = (GF_AdobeStdEncryptionParamsBox *)gf_isom_box_new_parent(& sinf->info->adkm->header->child_boxes, GF_ISOM_BOX_TYPE_APRM);\n\tif (!sinf->info->adkm->header->std_enc_params) return GF_OUT_OF_MEM;\n\n\tsinf->info->adkm->header->std_enc_params->enc_info = (GF_AdobeEncryptionInfoBox *)gf_isom_box_new_parent(&sinf->info->adkm->header->std_enc_params->child_boxes, GF_ISOM_BOX_TYPE_AEIB);\n\tif (!sinf->info->adkm->header->std_enc_params->enc_info) return GF_OUT_OF_MEM;\n\n\tsinf->info->adkm->header->std_enc_params->enc_info->enc_algo = (char *)gf_malloc(8*sizeof(char));\n\tif (!sinf->info->adkm->header->std_enc_params->enc_info->enc_algo) return GF_OUT_OF_MEM;\n\n\tstrcpy(sinf->info->adkm->header->std_enc_params->enc_info->enc_algo, \"AES-CBC\");\n\tsinf->info->adkm->header->std_enc_params->enc_info->key_length = 16;\n\n\tsinf->info->adkm->header->std_enc_params->key_info = (GF_AdobeKeyInfoBox *)gf_isom_box_new_parent(&sinf->info->adkm->header->std_enc_params->child_boxes, GF_ISOM_BOX_TYPE_AKEY);\n\tif (!sinf->info->adkm->header->std_enc_params->key_info) return GF_OUT_OF_MEM;\n\n\tsinf->info->adkm->header->std_enc_params->key_info->params = (GF_AdobeFlashAccessParamsBox *)gf_isom_box_new_parent(&sinf->info->adkm->header->std_enc_params->key_info->child_boxes, GF_ISOM_BOX_TYPE_FLXS);\n\tif (!sinf->info->adkm->header->std_enc_params->key_info->params) return GF_OUT_OF_MEM;\n\n\tif (metadata && len) {\n\t\tsinf->info->adkm->header->std_enc_params->key_info->params->metadata = (char *)gf_malloc((len+1)*sizeof(char));\n\t\tif (!sinf->info->adkm->header->std_enc_params->key_info->params->metadata) return GF_OUT_OF_MEM;\n\n\t\tstrncpy(sinf->info->adkm->header->std_enc_params->key_info->params->metadata, metadata, len);\n\t\tsinf->info->adkm->header->std_enc_params->key_info->params->metadata[len] = 0;\n\t}\n\n\tsinf->info->adkm->au_format = (GF_AdobeDRMAUFormatBox *)gf_isom_box_new_parent(&sinf->info->adkm->child_boxes, GF_ISOM_BOX_TYPE_ADAF);\n\tif (!sinf->info->adkm->au_format) return GF_OUT_OF_MEM;\n\n\tsinf->info->adkm->au_format->selective_enc = is_selective_enc ? 0x10 : 0x00;\n\tsinf->info->adkm->au_format->IV_length = 16;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_isom_is_adobe_protection_media(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_ADOBE_SCHEME, NULL);\n\n\tif (!sinf) return GF_FALSE;\n\n\t/*non-encrypted or non-ADOBE*/\n\tif (!sinf->info || !sinf->info->adkm)\n\t\treturn GF_FALSE;\n\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_adobe_protection_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat, u32 *outSchemeType, u32 *outSchemeVersion, const char **outMetadata)\n{\n\tGF_TrackBox *trak;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_ADOBE_SCHEME, NULL);\n\n\tif (!sinf) return GF_BAD_PARAM;\n\n\tif (outOriginalFormat) {\n\t\t*outOriginalFormat = sinf->original_format->data_format;\n\t\tif (IsMP4Description(sinf->original_format->data_format)) *outOriginalFormat = GF_ISOM_SUBTYPE_MPEG4;\n\t}\n\tif (outSchemeType) *outSchemeType = sinf->scheme_type->scheme_type;\n\tif (outSchemeVersion) *outSchemeVersion = sinf->scheme_type->scheme_version;\n\n\tif (outMetadata) {\n\t\t*outMetadata = NULL;\n\t\tif (sinf->info && sinf->info->adkm && sinf->info->adkm->header && sinf->info->adkm->header->std_enc_params && sinf->info->adkm->header->std_enc_params->key_info\n\t\t\t&& sinf->info->adkm->header->std_enc_params->key_info->params && sinf->info->adkm->header->std_enc_params->key_info->params->metadata)\n\t\t{\n\t\t\t*outMetadata = sinf->info->adkm->header->std_enc_params->key_info->params->metadata;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\n\n#if 0 //unused\n/*! removes the IPMPX tools from files\n\\param isom_file the target ISO file\n*/\nvoid gf_isom_ipmpx_remove_tool_list(GF_ISOFile *the_file)\n{\n\t/*remove IPMPToolList if any*/\n\tif (the_file && the_file->moov && the_file->moov->iods && (the_file ->moov->iods->descriptor->tag == GF_ODF_ISOM_IOD_TAG) ) {\n\t\tGF_IsomInitialObjectDescriptor *iod = (GF_IsomInitialObjectDescriptor *)the_file ->moov->iods->descriptor;\n\t\tif (iod->IPMPToolList) gf_odf_desc_del((GF_Descriptor*) iod->IPMPToolList);\n\t\tiod->IPMPToolList = NULL;\n\t}\n}\n#endif\n\n\nBool gf_cenc_validate_key_info(const u8 *key_info, u32 key_info_size)\n{\n\tu32 i, n_keys, kpos, nb_missing = 19;\n\tif (!key_info|| (key_info_size<19))\n\t\tgoto exit;\n\n\tn_keys = 1;\n\tif (key_info[0]) {\n\t\tn_keys = key_info[1];\n\t\tn_keys <<= 8;\n\t\tn_keys |= key_info[2];\n\t}\n\tkpos=3;\n\tfor (i=0;i<n_keys; i++) {\n\t\tu8 iv_size;\n\t\tif (kpos + 17 > key_info_size) {\n\t\t\tnb_missing = kpos + 17 - key_info_size;\n\t\t\tgoto exit;\n\t\t}\n\t\tiv_size = key_info[kpos];\n\t\tkpos += 17;\n\t\tif (!iv_size) {\n\t\t\tif (kpos + 1 > key_info_size) {\n\t\t\t\tnb_missing = kpos + 1  - key_info_size;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tiv_size = key_info[kpos];\n\t\t\tif (kpos + 1 + iv_size > key_info_size) {\n\t\t\t\tnb_missing = kpos + 1 + iv_size - key_info_size;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tkpos += 1 + iv_size;\n\t\t}\n\t}\n\treturn GF_TRUE;\n\nexit:\n\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"Invalid key info format, missing %d bytes\\n\", nb_missing));\n\treturn GF_FALSE;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *          Authors: Cyril Concolato / Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2005-2020\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\nGF_ISMASample *gf_isom_ismacryp_new_sample()\n{\n\tGF_ISMASample *tmp = (GF_ISMASample *) gf_malloc(sizeof(GF_ISMASample));\n\tif (!tmp) return NULL;\n\tmemset(tmp, 0, sizeof(GF_ISMASample));\n\treturn tmp;\n}\nGF_EXPORT\nvoid gf_isom_ismacryp_delete_sample(GF_ISMASample *samp)\n{\n\tif (!samp) return;\n\tif (samp->data && samp->dataLength) gf_free(samp->data);\n\tif (samp->key_indicator) gf_free(samp->key_indicator);\n\tgf_free(samp);\n}\n\n\nGF_ISMASample *gf_isom_ismacryp_sample_from_data(u8 *data, u32 dataLength, Bool use_selective_encryption, u8 KI_length, u8 IV_length)\n{\n\tGF_ISMASample *s;\n\tGF_BitStream *bs;\n\t/*empty text sample*/\n\tif (!data || !dataLength) {\n\t\treturn gf_isom_ismacryp_new_sample();\n\t}\n\n\ts = gf_isom_ismacryp_new_sample();\n\n\t/*empty sample*/\n\tif (!data || !dataLength) return s;\n\n\tbs = gf_bs_new(data, dataLength, GF_BITSTREAM_READ);\n\n\ts->dataLength = dataLength;\n\ts->IV_length = IV_length;\n\ts->KI_length = KI_length;\n\n\tif (use_selective_encryption) {\n\t\ts->flags = GF_ISOM_ISMA_USE_SEL_ENC;\n\t\tif (s->dataLength < 1) goto exit;\n\t\tif (gf_bs_read_int(bs, 1)) s->flags |= GF_ISOM_ISMA_IS_ENCRYPTED;\n\t\tgf_bs_read_int(bs, 7);\n\t\ts->dataLength -= 1;\n\t} else {\n\t\ts->flags = GF_ISOM_ISMA_IS_ENCRYPTED;\n\t}\n\tif (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) {\n\t\tif (IV_length != 0) {\n\t\t\tif (s->dataLength < IV_length) goto exit;\n\t\t\ts->IV = gf_bs_read_long_int(bs, 8*IV_length);\n\t\t\ts->dataLength -= IV_length;\n\t\t}\n\t\tif (KI_length) {\n\t\t\tif (s->dataLength < KI_length) goto exit;\n\t\t\ts->key_indicator = (u8 *)gf_malloc(KI_length);\n\t\t\tif (!s->key_indicator) goto exit;\n\t\t\tgf_bs_read_data(bs, (char*)s->key_indicator, KI_length);\n\t\t\ts->dataLength -= KI_length;\n\t\t}\n\t}\n\ts->data = (char*)gf_malloc(sizeof(char)*s->dataLength);\n\tif (!s->data) goto exit;\n\tgf_bs_read_data(bs, s->data, s->dataLength);\n\tgf_bs_del(bs);\n\treturn s;\n\nexit:\n\tgf_isom_ismacryp_delete_sample(s);\n\treturn NULL;\n}\n\n#if 0 //unused\n/*! rewrites ISMA sample as an ISO sample\n\\param s the ISMA sample to rewrite\n\\param dest the destination ISO sample\n\\return error if any\n*/\nGF_Err gf_isom_ismacryp_sample_to_sample(const GF_ISMASample *s, GF_ISOSample *dest)\n{\n\tGF_BitStream *bs;\n\tif (!s || !dest) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tif (s->flags & GF_ISOM_ISMA_USE_SEL_ENC) {\n\t\tgf_bs_write_int(bs, (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) ? 1 : 0, 1);\n\t\tgf_bs_write_int(bs, 0, 7);\n\t}\n\tif (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) {\n\t\tif (s->IV_length) gf_bs_write_long_int(bs, (s64) s->IV, 8*s->IV_length);\n\t\tif (s->KI_length) gf_bs_write_data(bs, (char*)s->key_indicator, s->KI_length);\n\t}\n\tgf_bs_write_data(bs, s->data, s->dataLength);\n\tif (dest->data) gf_free(dest->data);\n\tdest->data = NULL;\n\tdest->dataLength = 0;\n\tgf_bs_get_content(bs, &dest->data, &dest->dataLength);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n#endif\n\n\nstatic GF_ProtectionSchemeInfoBox *isom_get_sinf_entry(GF_TrackBox *trak, u32 sampleDescriptionIndex, u32 scheme_type, GF_SampleEntryBox **out_sea)\n{\n\tu32 i=0;\n\tGF_SampleEntryBox *sea=NULL;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\tMedia_GetSampleDesc(trak->Media, sampleDescriptionIndex, &sea, NULL);\n\tif (!sea) return NULL;\n\n\ti = 0;\n\twhile ((sinf = (GF_ProtectionSchemeInfoBox*)gf_list_enum(sea->child_boxes, &i))) {\n\t\tif (sinf->type != GF_ISOM_BOX_TYPE_SINF) continue;\n\n\t\tif (sinf->original_format && sinf->scheme_type && sinf->info) {\n\t\t\tif (!scheme_type || (sinf->scheme_type->scheme_type == scheme_type)) {\n\t\t\t\tif (out_sea)\n\t\t\t\t\t*out_sea = sea;\n\t\t\t\treturn sinf;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nGF_ISMASample *gf_isom_get_ismacryp_sample(GF_ISOFile *the_file, u32 trackNumber, const GF_ISOSample *samp, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_ISMASampleFormatBox *fmt;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, 0, NULL);\n\tif (!sinf) return NULL;\n\n\t/*ISMA*/\n\tif (sinf->scheme_type->scheme_type == GF_ISOM_ISMACRYP_SCHEME) {\n\t\tfmt = sinf->info->isfm;\n\t\tif (!fmt) return NULL;\n\t\treturn gf_isom_ismacryp_sample_from_data(samp->data, samp->dataLength, sinf->info->isfm->selective_encryption, sinf->info->isfm->key_indicator_length, sinf->info->isfm->IV_length);\n\t}\n\t/*OMA*/\n\telse if (sinf->scheme_type->scheme_type == GF_ISOM_OMADRM_SCHEME ) {\n\t\tif (!sinf->info->odkm) return NULL;\n\t\tfmt = sinf->info->odkm->fmt;\n\n\t\tif (fmt) {\n\t\t\treturn gf_isom_ismacryp_sample_from_data(samp->data, samp->dataLength, fmt->selective_encryption, fmt->key_indicator_length, fmt->IV_length);\n\t\t}\n\t\t/*OMA default: no selective encryption, one key, 128 bit IV*/\n\t\treturn gf_isom_ismacryp_sample_from_data(samp->data, samp->dataLength, GF_FALSE, 0, 128);\n\t}\n\treturn NULL;\n}\n\n\nGF_EXPORT\nu32 gf_isom_is_media_encrypted(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\tcount = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tif (sampleDescriptionIndex && (i+1 != sampleDescriptionIndex))\n\t\t\tcontinue;\n\n\t\tsinf = isom_get_sinf_entry(trak, i+1, 0, NULL);\n\t\tif (!sinf) continue;\n\n\t\t/*non-encrypted or non-ISMA*/\n\t\tif (!sinf->scheme_type) return 0;\n\t\tif (sinf->scheme_type->scheme_type == GF_ISOM_PIFF_SCHEME) return GF_ISOM_CENC_SCHEME;\n\t\treturn sinf->scheme_type->scheme_type;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nBool gf_isom_is_ismacryp_media(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_ISMACRYP_SCHEME, NULL);\n\tif (!sinf) return GF_FALSE;\n\n\t/*non-encrypted or non-ISMA*/\n\tif (!sinf->info || !sinf->info->ikms || !sinf->info->isfm )\n\t\treturn GF_FALSE;\n\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_isom_is_omadrm_media(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_OMADRM_SCHEME, NULL);\n\tif (!sinf) return GF_FALSE;\n\n\t/*non-encrypted or non-OMA*/\n\tif (!sinf->info || !sinf->info->odkm || !sinf->info->odkm->hdr)\n\t\treturn GF_FALSE;\n\n\treturn GF_TRUE;\n}\n\n/*retrieves ISMACryp info for the given track & SDI*/\nGF_EXPORT\nGF_Err gf_isom_get_ismacryp_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat, u32 *outSchemeType, u32 *outSchemeVersion, const char **outSchemeURI, const char **outKMS_URI, Bool *outSelectiveEncryption, u32 *outIVLength, u32 *outKeyIndicationLength)\n{\n\tGF_TrackBox *trak;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_ISMACRYP_SCHEME, NULL);\n\tif (!sinf) return GF_OK;\n\n\tif (outOriginalFormat) {\n\t\t*outOriginalFormat = sinf->original_format->data_format;\n\t\tif (IsMP4Description(sinf->original_format->data_format)) *outOriginalFormat = GF_ISOM_SUBTYPE_MPEG4;\n\t}\n\tif (outSchemeType) *outSchemeType = sinf->scheme_type->scheme_type;\n\tif (outSchemeVersion) *outSchemeVersion = sinf->scheme_type->scheme_version;\n\tif (outSchemeURI) *outSchemeURI = sinf->scheme_type->URI;\n\n\tif (sinf->info && sinf->info->ikms) {\n\t\tif (outKMS_URI) *outKMS_URI = sinf->info->ikms->URI;\n\t} else {\n\t\tif (outKMS_URI) *outKMS_URI = NULL;\n\t}\n\tif (sinf->info && sinf->info->isfm) {\n\t\tif (outSelectiveEncryption) *outSelectiveEncryption = sinf->info->isfm->selective_encryption;\n\t\tif (outIVLength) *outIVLength = sinf->info->isfm->IV_length;\n\t\tif (outKeyIndicationLength) *outKeyIndicationLength = sinf->info->isfm->key_indicator_length;\n\t} else {\n\t\tif (outSelectiveEncryption) *outSelectiveEncryption = GF_FALSE;\n\t\tif (outIVLength) *outIVLength = 0;\n\t\tif (outKeyIndicationLength) *outKeyIndicationLength = 0;\n\t}\n\treturn GF_OK;\n}\n\n\n/*retrieves ISMACryp info for the given track & SDI*/\nGF_EXPORT\nGF_Err gf_isom_get_omadrm_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat,\n                               u32 *outSchemeType, u32 *outSchemeVersion,\n                               const char **outContentID, const char **outRightsIssuerURL, const char **outTextualHeaders, u32 *outTextualHeadersLen, u64 *outPlaintextLength, u32 *outEncryptionType, Bool *outSelectiveEncryption, u32 *outIVLength, u32 *outKeyIndicationLength)\n{\n\tGF_TrackBox *trak;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_OMADRM_SCHEME, NULL);\n\tif (!sinf) return GF_OK;\n\n\tif (!sinf->info || !sinf->info->odkm || !sinf->info->odkm->hdr) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tif (outOriginalFormat) {\n\t\t*outOriginalFormat = sinf->original_format->data_format;\n\t\tif (IsMP4Description(sinf->original_format->data_format)) *outOriginalFormat = GF_ISOM_SUBTYPE_MPEG4;\n\t}\n\tif (outSchemeType) *outSchemeType = sinf->scheme_type->scheme_type;\n\tif (outSchemeVersion) *outSchemeVersion = sinf->scheme_type->scheme_version;\n\tif (outContentID) *outContentID = sinf->info->odkm->hdr->ContentID;\n\tif (outRightsIssuerURL) *outRightsIssuerURL = sinf->info->odkm->hdr->RightsIssuerURL;\n\tif (outTextualHeaders) {\n\t\t*outTextualHeaders = sinf->info->odkm->hdr->TextualHeaders;\n\t\tif (outTextualHeadersLen) *outTextualHeadersLen = sinf->info->odkm->hdr->TextualHeadersLen;\n\t}\n\tif (outPlaintextLength) *outPlaintextLength = sinf->info->odkm->hdr->PlaintextLength;\n\tif (outEncryptionType) *outEncryptionType = sinf->info->odkm->hdr->EncryptionMethod;\n\n\tif (sinf->info && sinf->info->odkm && sinf->info->odkm->fmt) {\n\t\tif (outSelectiveEncryption) *outSelectiveEncryption = sinf->info->odkm->fmt->selective_encryption;\n\t\tif (outIVLength) *outIVLength = sinf->info->odkm->fmt->IV_length;\n\t\tif (outKeyIndicationLength) *outKeyIndicationLength = sinf->info->odkm->fmt->key_indicator_length;\n\t} else {\n\t\tif (outSelectiveEncryption) *outSelectiveEncryption = GF_FALSE;\n\t\tif (outIVLength) *outIVLength = 0;\n\t\tif (outKeyIndicationLength) *outKeyIndicationLength = 0;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n#if 0 //unused\n/*! removes protection info (does not perform decryption), for ISMA, OMA and CENC of a sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the sample description index\n\\return error if any\n*/\nGF_Err gf_isom_remove_track_protection(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleEntryBox *sea;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !sampleDescriptionIndex) return GF_BAD_PARAM;\n\n\tsea = NULL;\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENC_SCHEME, &sea);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBC_SCHEME, &sea);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENS_SCHEME, &sea);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBCS_SCHEME, &sea);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_ISMACRYP_SCHEME, &sea);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_OMADRM_SCHEME, &sea);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_ADOBE_SCHEME, &sea);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_PIFF_SCHEME, &sea);\n\tif (!sinf) return GF_OK;\n\n\tsea->type = sinf->original_format->data_format;\n\twhile (1) {\n\t\tGF_Box *b = gf_isom_box_find_child(sea->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (!b) break;\n\t\tgf_isom_box_del_parent(&sea->child_boxes, b);\n\t}\n\tif (sea->type == GF_ISOM_BOX_TYPE_264B) sea->type = GF_ISOM_BOX_TYPE_AVC1;\n\tif (sea->type == GF_ISOM_BOX_TYPE_265B) sea->type = GF_ISOM_BOX_TYPE_HVC1;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_change_ismacryp_protection(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex, char *scheme_uri, char *kms_uri)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleEntryBox *sea;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !sampleDescriptionIndex) return GF_BAD_PARAM;\n\n\tsea = NULL;\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_ISMACRYP_SCHEME, &sea);\n\tif (!sinf) return GF_OK;\n\n\tif (scheme_uri) {\n\t\tgf_free(sinf->scheme_type->URI);\n\t\tsinf->scheme_type->URI = gf_strdup(scheme_uri);\n\t}\n\tif (kms_uri) {\n\t\tgf_free(sinf->info->ikms->URI);\n\t\tsinf->info->ikms->URI = gf_strdup(kms_uri);\n\t}\n\treturn GF_OK;\n}\n\n\nstatic GF_Err isom_set_protected_entry(GF_ISOFile *the_file, u32 trackNumber, u32 desc_index, u8 version, u32 flags,\n        u32 scheme_type, u32 scheme_version, char *scheme_uri, Bool is_isma, GF_ProtectionSchemeInfoBox **out_sinf)\n{\n\tu32 original_format;\n\tGF_Err e;\n\tGF_SampleEntryBox *sea;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, desc_index, &sea, NULL);\n\tif (e) return e;\n\n\toriginal_format = sea->type;\n\tif (original_format==GF_ISOM_BOX_TYPE_GNRA) {\n\t\toriginal_format = ((GF_GenericAudioSampleEntryBox*)sea)->EntryType;\n\t} else if (original_format==GF_ISOM_BOX_TYPE_GNRV) {\n\t\toriginal_format = ((GF_GenericVisualSampleEntryBox*)sea)->EntryType;\n\t} else if (original_format==GF_ISOM_BOX_TYPE_GNRM) {\n\t\toriginal_format = ((GF_GenericSampleEntryBox*)sea)->EntryType;\n\t}\n\n\t/* Replacing the Media Type */\n\tswitch (sea->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\tcase GF_ISOM_BOX_TYPE_DAMR:\n\tcase GF_ISOM_BOX_TYPE_DEVC:\n\tcase GF_ISOM_BOX_TYPE_DQCP:\n\tcase GF_ISOM_BOX_TYPE_DSMV:\n\tcase GF_ISOM_BOX_TYPE_AC3:\n\tcase GF_ISOM_BOX_TYPE_EC3:\n\t\tsea->type = GF_ISOM_BOX_TYPE_ENCA;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\tcase GF_ISOM_BOX_TYPE_D263:\n\t\tsea->type = GF_ISOM_BOX_TYPE_ENCV;\n\t\tbreak;\n\t/*special case for AVC1*/\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tif (is_isma)\n\t\t\toriginal_format = GF_ISOM_BOX_TYPE_264B;\n\t\tsea->type = GF_ISOM_BOX_TYPE_ENCV;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tif (is_isma)\n\t\t\toriginal_format = GF_ISOM_BOX_TYPE_265B;\n\t\tsea->type = GF_ISOM_BOX_TYPE_ENCV;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VVC1:\n\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tsea->type = GF_ISOM_BOX_TYPE_ENCV;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VP09:\n\t\tsea->type = GF_ISOM_BOX_TYPE_ENCV;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tsea->type = GF_ISOM_BOX_TYPE_ENCV;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\tcase GF_ISOM_BOX_TYPE_LSR1:\n\t\tsea->type = GF_ISOM_BOX_TYPE_ENCS;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STXT:\n\tcase GF_ISOM_BOX_TYPE_WVTT:\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\tsea->type = GF_ISOM_BOX_TYPE_ENCT;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_ENCT:\n\tcase GF_ISOM_BOX_TYPE_ENCM:\n\tcase GF_ISOM_BOX_TYPE_ENCF:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] cannot set protection entry: file is already encrypted.\\n\"));\n\t\treturn GF_BAD_PARAM;\n\tdefault:\n\t\tif (sea->internal_type == GF_ISOM_SAMPLE_ENTRY_AUDIO) {\n\t\t\tsea->type = GF_ISOM_BOX_TYPE_ENCA;\n\t\t} else if (sea->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\tsea->type = GF_ISOM_BOX_TYPE_ENCV;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] unsupported entry type %s for CENC.\\n\", gf_4cc_to_str(sea->type) ));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\n\tsinf = (GF_ProtectionSchemeInfoBox *)gf_isom_box_new_parent(&sea->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\tif (!sinf) return GF_OUT_OF_MEM;\n\n\tsinf->scheme_type = (GF_SchemeTypeBox *)gf_isom_box_new_parent(&sinf->child_boxes, GF_ISOM_BOX_TYPE_SCHM);\n\tif (!sinf->scheme_type) return GF_OUT_OF_MEM;\n\n\tsinf->scheme_type->version = version;\n\tsinf->scheme_type->flags = flags;\n\tsinf->scheme_type->scheme_type = scheme_type;\n\tsinf->scheme_type->scheme_version = scheme_version;\n\tif (scheme_uri && (sinf->scheme_type->flags == 1)) {\n\t\tsinf->scheme_type->URI = (char *)gf_malloc(sizeof(char)*strlen(scheme_uri));\n\t\tif (!sinf->scheme_type->URI) return GF_OUT_OF_MEM;\n\t\tmemmove(sinf->scheme_type->URI, scheme_uri, strlen(scheme_uri));\n\t}\n\n\tsinf->original_format = (GF_OriginalFormatBox *)gf_isom_box_new_parent(&sinf->child_boxes, GF_ISOM_BOX_TYPE_FRMA);\n\tif (!sinf->original_format) return GF_OUT_OF_MEM;\n\tsinf->original_format->data_format = original_format;\n\n\t//common to isma, cenc and oma\n\tsinf->info = (GF_SchemeInformationBox *)gf_isom_box_new_parent(&sinf->child_boxes, GF_ISOM_BOX_TYPE_SCHI);\n\n\t*out_sinf = sinf;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_ismacryp_protection(GF_ISOFile *the_file, u32 trackNumber, u32 desc_index, u32 scheme_type,\n                                       u32 scheme_version, char *scheme_uri, char *kms_URI,\n                                       Bool selective_encryption, u32 KI_length, u32 IV_length)\n{\n\tGF_Err e;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\t//setup generic protection\n\te = isom_set_protected_entry(the_file, trackNumber, desc_index, 0, 0, scheme_type, scheme_version, NULL, GF_TRUE, &sinf);\n\tif (e) return e;\n\n\tif (scheme_uri) {\n\t\tsinf->scheme_type->flags |= 0x000001;\n\t\tsinf->scheme_type->URI = gf_strdup(scheme_uri);\n\t}\n\n\tsinf->info->ikms = (GF_ISMAKMSBox *)gf_isom_box_new_parent(&sinf->info->child_boxes, GF_ISOM_BOX_TYPE_IKMS);\n\tif (!sinf->info->ikms) return GF_OUT_OF_MEM;\n\tsinf->info->ikms->URI = gf_strdup(kms_URI);\n\tif (!sinf->info->ikms->URI) return GF_OUT_OF_MEM;\n\n\tsinf->info->isfm = (GF_ISMASampleFormatBox *)gf_isom_box_new_parent(&sinf->info->child_boxes, GF_ISOM_BOX_TYPE_ISFM);\n\tif (!sinf->info->isfm) return GF_OUT_OF_MEM;\n\n\tsinf->info->isfm->selective_encryption = selective_encryption;\n\tsinf->info->isfm->key_indicator_length = KI_length;\n\tsinf->info->isfm->IV_length = IV_length;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_oma_protection(GF_ISOFile *the_file, u32 trackNumber, u32 desc_index,\n                                  char *contentID, char *kms_URI, u32 encryption_type, u64 plainTextLength, char *textual_headers, u32 textual_headers_len,\n                                  Bool selective_encryption, u32 KI_length, u32 IV_length)\n{\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tGF_Err e;\n\n\t//setup generic protection\n\te = isom_set_protected_entry(the_file, trackNumber, desc_index, 0, 0, GF_ISOM_OMADRM_SCHEME, 0x00000200, NULL, GF_FALSE, &sinf);\n\tif (e) return e;\n\n\tsinf->info->odkm = (GF_OMADRMKMSBox *)gf_isom_box_new_parent(&sinf->info->child_boxes, GF_ISOM_BOX_TYPE_ODKM);\n\tif (!sinf->info->odkm) return GF_OUT_OF_MEM;\n\tsinf->info->odkm->fmt = (GF_OMADRMAUFormatBox*)gf_isom_box_new_parent(&sinf->info->odkm->child_boxes, GF_ISOM_BOX_TYPE_ODAF);\n\tif (!sinf->info->odkm->fmt) return GF_OUT_OF_MEM;\n\tsinf->info->odkm->fmt->selective_encryption = selective_encryption;\n\tsinf->info->odkm->fmt->key_indicator_length = KI_length;\n\tsinf->info->odkm->fmt->IV_length = IV_length;\n\n\tsinf->info->odkm->hdr = (GF_OMADRMCommonHeaderBox*)gf_isom_box_new_parent(&sinf->info->odkm->child_boxes, GF_ISOM_BOX_TYPE_OHDR);\n\tif (!sinf->info->odkm->hdr) return GF_OUT_OF_MEM;\n\tsinf->info->odkm->hdr->EncryptionMethod = encryption_type;\n\tsinf->info->odkm->hdr->PaddingScheme = (encryption_type==0x01) ? 1 : 0;\n\tsinf->info->odkm->hdr->PlaintextLength = plainTextLength;\n\tif (contentID) sinf->info->odkm->hdr->ContentID = gf_strdup(contentID);\n\tif (kms_URI) sinf->info->odkm->hdr->RightsIssuerURL = gf_strdup(kms_URI);\n\tif (textual_headers) {\n\t\tsinf->info->odkm->hdr->TextualHeaders = (char*)gf_malloc(sizeof(char)*textual_headers_len);\n\t\tif (!sinf->info->odkm->hdr->TextualHeaders) return GF_OUT_OF_MEM;\n\t\tmemcpy(sinf->info->odkm->hdr->TextualHeaders, textual_headers, sizeof(char)*textual_headers_len);\n\t\tsinf->info->odkm->hdr->TextualHeadersLen = textual_headers_len;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_generic_protection(GF_ISOFile *the_file, u32 trackNumber, u32 desc_index, u32 scheme_type, u32 scheme_version, char *scheme_uri, char *kms_URI)\n{\n\tGF_Err e;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\t//setup generic protection\n\te = isom_set_protected_entry(the_file, trackNumber, desc_index, 0, 0, scheme_type, scheme_version, NULL, GF_TRUE, &sinf);\n\tif (e) return e;\n\n\tif (scheme_uri) {\n\t\tsinf->scheme_type->flags |= 0x000001;\n\t\tsinf->scheme_type->URI = gf_strdup(scheme_uri);\n\t}\n\n\tif (kms_URI) {\n\t\tsinf->info->ikms = (GF_ISMAKMSBox *)gf_isom_box_new_parent(&sinf->info->child_boxes, GF_ISOM_BOX_TYPE_IKMS);\n\t\tsinf->info->ikms->URI = gf_strdup(kms_URI);\n\t}\n\treturn GF_OK;\n}\n#endif // GPAC_DISABLE_ISOM_WRITE\n\nGF_EXPORT\nGF_Err gf_isom_get_original_format_type(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *sea;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tu32 i, count;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tif (sampleDescriptionIndex && (i+1 != sampleDescriptionIndex)) continue;\n\n\t\tMedia_GetSampleDesc(trak->Media, i+1, &sea, NULL);\n\t\tif (!sea) return GF_BAD_PARAM;\n\t\tsinf = (GF_ProtectionSchemeInfoBox*) gf_isom_box_find_child(sea->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (!sinf) continue;\n\n\t\tif (outOriginalFormat && sinf->original_format) {\n\t\t\t*outOriginalFormat = sinf->original_format->data_format;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (outOriginalFormat) *outOriginalFormat = 0;\n\treturn GF_OK;\n}\n\n\n/* Common Encryption*/\nGF_EXPORT\nBool gf_isom_is_cenc_media(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tu32 i, count;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tif (sampleDescriptionIndex && (i+1 != sampleDescriptionIndex)) continue;\n\n\t\tsinf = isom_get_sinf_entry(trak, i+1, GF_ISOM_CENC_SCHEME, NULL);\n\t\tif (!sinf) sinf = isom_get_sinf_entry(trak, i+1, GF_ISOM_CBC_SCHEME, NULL);\n\t\tif (!sinf) sinf = isom_get_sinf_entry(trak, i+1, GF_ISOM_CENS_SCHEME, NULL);\n\t\tif (!sinf) sinf = isom_get_sinf_entry(trak, i+1, GF_ISOM_CBCS_SCHEME, NULL);\n\t\tif (!sinf) sinf = isom_get_sinf_entry(trak, i+1, GF_ISOM_PIFF_SCHEME, NULL);\n\n\t\tif (!sinf) continue;\n\n\t\t/*non-encrypted or non-CENC*/\n\t\tif (!sinf->scheme_type)\n\t\t\treturn GF_FALSE;\n\n\t\tswitch (sinf->scheme_type->scheme_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_ISOM_SVE1_SCHEME:\n\t\t\treturn GF_TRUE;\n\t\tdefault:\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_cenc_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat, u32 *outSchemeType, u32 *outSchemeVersion)\n{\n\tGF_TrackBox *trak;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENC_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBC_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENS_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBCS_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_PIFF_SCHEME, NULL);\n\n\tif (!sinf) return GF_BAD_PARAM;\n\n\tif (outOriginalFormat) {\n\t\t*outOriginalFormat = sinf->original_format->data_format;\n\t\tif (IsMP4Description(sinf->original_format->data_format)) *outOriginalFormat = GF_ISOM_SUBTYPE_MPEG4;\n\t}\n\tif (outSchemeType) *outSchemeType = sinf->scheme_type->scheme_type;\n\tif (outSchemeVersion) *outSchemeVersion = sinf->scheme_type->scheme_version;\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gf_isom_set_cenc_protection(GF_ISOFile *the_file, u32 trackNumber, u32 desc_index, u32 scheme_type,\n                                   u32 scheme_version, u32 default_IsEncrypted, u8 default_crypt_byte_block, u8 default_skip_byte_block,\n\t\t\t\t\t\t\t\t    u8 *key_info, u32 key_info_size)\n{\n\tGF_Err e;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\tif (!gf_cenc_validate_key_info(key_info, key_info_size))\n\t\treturn GF_BAD_PARAM;\n\n\t//setup generic protection\n\te = isom_set_protected_entry(the_file, trackNumber, desc_index, 0, 0, scheme_type, scheme_version, NULL, GF_FALSE, &sinf);\n\tif (e) return e;\n\n\tif (scheme_type==GF_ISOM_PIFF_SCHEME) {\n\t\tsinf->info->piff_tenc = (GF_PIFFTrackEncryptionBox *) gf_isom_box_new_parent(&sinf->info->child_boxes, GF_ISOM_BOX_UUID_TENC);\n\t\tif (!sinf->info->piff_tenc) return GF_OUT_OF_MEM;\n\t\tsinf->info->piff_tenc->AlgorithmID = 1;\n\t\tsinf->info->piff_tenc->key_info[0] = 0;\n\t\tsinf->info->piff_tenc->key_info[1] = 0;\n\t\tsinf->info->piff_tenc->key_info[2] = 0;\n\t\tsinf->info->piff_tenc->key_info[3] = key_info[3];\n\t\tmemcpy(sinf->info->piff_tenc->key_info+4, key_info+4, 16*sizeof(char));\n\t}\n\t//tenc only for mkey\n\telse if (!key_info[0]) {\n\t\tif (key_info_size<20) return GF_BAD_PARAM;\n\t\tsinf->info->tenc = (GF_TrackEncryptionBox *)gf_isom_box_new_parent(&sinf->info->child_boxes, GF_ISOM_BOX_TYPE_TENC);\n\t\tif (!sinf->info->tenc) return GF_OUT_OF_MEM;\n\n\t\tsinf->info->tenc->isProtected = default_IsEncrypted;\n\t\tif ((scheme_type == GF_ISOM_CENS_SCHEME) || (scheme_type == GF_ISOM_CBCS_SCHEME)) {\n\t\t\tsinf->info->tenc->version = 1;\n\t\t\tsinf->info->tenc->crypt_byte_block = default_crypt_byte_block;\n\t\t\tsinf->info->tenc->skip_byte_block = default_skip_byte_block;\n\t\t}\n\t\tif (key_info_size>37) key_info_size = 37;\n\t\tmemcpy(sinf->info->tenc->key_info, key_info, key_info_size);\n\t}\n\treturn GF_OK;\n}\n\n\n#if 0\n/*! removes CENC SAI size info\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_remove_cenc_saiz(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tu32 i;\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl)\n\t\treturn GF_BAD_PARAM;\n\n\tfor (i = 0; i < gf_list_count(stbl->sai_sizes); i++) {\n\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(stbl->sai_sizes, i);\n\t\tswitch (saiz->aux_info_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *)saiz);\n\t\tgf_list_rem(stbl->sai_sizes, i);\n\t\ti--;\n\t}\n\n\tif (!gf_list_count(stbl->sai_sizes)) {\n\t\tgf_list_del(stbl->sai_sizes);\n\t\tstbl->sai_sizes = NULL;\n\t}\n\n\treturn GF_OK;\n}\n\n/*! removes CENC SAI offset info\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\return error if any\n*/\nGF_Err gf_isom_remove_cenc_saio(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tu32 i;\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl)\n\t\treturn GF_BAD_PARAM;\n\n\tfor (i = 0; i < gf_list_count(stbl->sai_offsets); i++) {\n\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(stbl->sai_offsets, i);\n\t\tswitch (saio->aux_info_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *)saio);\n\t\tgf_list_rem(stbl->sai_offsets, i);\n\t\ti--;\n\t}\n\n\tif (!gf_list_count(stbl->sai_offsets)) {\n\t\tgf_list_del(stbl->sai_offsets);\n\t\tstbl->sai_offsets = NULL;\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\nGF_Err gf_cenc_set_pssh(GF_ISOFile *file, bin128 systemID, u32 version, u32 KID_count, bin128 *KIDs, u8 *data, u32 len, u32 pssh_mode)\n{\n\tGF_ProtectionSystemHeaderBox *pssh = NULL;\n\tGF_PIFFProtectionSystemHeaderBox *pssh_piff = NULL;\n\tu32 i=0;\n\tGF_Box *a;\n\tGF_List **child_boxes = NULL;\n\n\tif (pssh_mode==2) {\n\t\tif (!file->meta) return GF_BAD_PARAM;\n\t\tif (!file->meta->child_boxes) file->meta->child_boxes = gf_list_new();\n\t\tchild_boxes = &file->meta->child_boxes;\n\t} else if (file->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) {\n\t\tif (!file->moof) return GF_BAD_PARAM;\n\t\tif (!file->moof->PSSHs) file->moof->PSSHs = gf_list_new();\n\t\tchild_boxes = &file->moof->PSSHs;\n\t} else {\n\t\tif (!file->moov) return GF_BAD_PARAM;\n\t\tif (!file->moov->child_boxes) file->moov->child_boxes = gf_list_new();\n\t\tchild_boxes = &file->moov->child_boxes;\n\t}\n\n\twhile ((a = gf_list_enum(*child_boxes, &i))) {\n\t\tGF_UUIDBox *uuid = (GF_UUIDBox *)a;\n\t\tif (a->type==GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\tpssh = (GF_ProtectionSystemHeaderBox *)a;\n\t\t\tif (!memcmp(pssh->SystemID, systemID, sizeof(bin128))) break;\n\t\t\tpssh = NULL;\n\t\t} else if ((a->type==GF_ISOM_BOX_TYPE_UUID) && (uuid->internal_4cc==GF_ISOM_BOX_UUID_PSSH)) {\n\t\t\tpssh_piff = (GF_PIFFProtectionSystemHeaderBox *)a;\n\t\t\tif (!memcmp(pssh_piff->SystemID, systemID, sizeof(bin128))) break;\n\t\t\tpssh_piff = NULL;\n\t\t}\n\t}\n\t//we had a pssh with same ID but different private data, keep both...\n\tif (pssh && pssh->private_data && len && memcmp(pssh->private_data, data, sizeof(char)*len) ) {\n\t\tpssh = NULL;\n\t}\n\telse if (pssh_piff && pssh_piff->private_data && len && memcmp(pssh_piff->private_data, data, sizeof(char)*len) ) {\n\t\tpssh_piff = NULL;\n\t}\n\n\tif (!pssh && !pssh_piff) {\n\t\tif (pssh_mode==1) {\n\t\t\tpssh_piff = (GF_PIFFProtectionSystemHeaderBox *)gf_isom_box_new_parent(child_boxes, GF_ISOM_BOX_UUID_PSSH);\n\t\t\tif (!pssh_piff) return GF_IO_ERR;\n\t\t\tmemcpy((char *)pssh_piff->SystemID, systemID, sizeof(bin128));\n\t\t\tpssh_piff->version = version;\n\t\t} else {\n\t\t\tpssh = (GF_ProtectionSystemHeaderBox *)gf_isom_box_new_parent(child_boxes, GF_ISOM_BOX_TYPE_PSSH);\n\t\t\tif (!pssh) return GF_IO_ERR;\n\t\t\tmemcpy((char *)pssh->SystemID, systemID, sizeof(bin128));\n\t\t\tpssh->version = version;\n\t\t}\n\t}\n\n\tif (pssh && KID_count) {\n\t\tu32 j;\n\t\tfor (j=0; j<KID_count; j++) {\n\t\t\tBool found = GF_FALSE;\n\t\t\tfor (i=0; i<pssh->KID_count; i++) {\n\t\t\t\tif (!memcmp(pssh->KIDs[i], KIDs[j], sizeof(bin128))) found = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (!found) {\n\t\t\t\tpssh->KIDs = gf_realloc(pssh->KIDs, sizeof(bin128) * (pssh->KID_count+1));\n\t\t\t\tif (!pssh->KIDs) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(pssh->KIDs[pssh->KID_count], KIDs[j], sizeof(bin128));\n\t\t\t\tpssh->KID_count++;\n\t\t\t}\n\t\t}\n\t\tif (!pssh->version)\n\t\t\tpssh->version = 1;\n\t}\n\n\tif (pssh) {\n\t\tif (!pssh->private_data_size) {\n\t\t\tpssh->private_data_size = len;\n\t\t\tif (len) {\n\t\t\t\tif (!pssh->private_data) {\n\t\t\t\t\tpssh->private_data = (u8 *)gf_malloc(pssh->private_data_size*sizeof(char));\n\t\t\t\t\tif (!pssh->private_data) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tmemcpy((char *)pssh->private_data, data, pssh->private_data_size);\n\t\t\t}\n\t\t}\n\t} else if (pssh_piff) {\n\t\tif (!pssh_piff->private_data_size) {\n\t\t\tpssh_piff->private_data_size = len;\n\t\t\tif (len) {\n\t\t\t\tif (!pssh_piff->private_data) {\n\t\t\t\t\tpssh_piff->private_data = (u8 *)gf_malloc(pssh_piff->private_data_size*sizeof(char));\n\t\t\t\t\tif (!pssh_piff->private_data) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tmemcpy((char *)pssh_piff->private_data, data, pssh_piff->private_data_size);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\n\nGF_Err gf_isom_remove_samp_enc_box(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tu32 i;\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl)\n\t\treturn GF_BAD_PARAM;\n\n\tfor (i = 0; i < gf_list_count(stbl->child_boxes); i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(stbl->child_boxes, i);\n\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\ti--;\n\t\t}\n\t\telse if (a->type == GF_ISOM_BOX_TYPE_SENC) {\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\ti--;\n\t\t}\n\t}\n\n\tif (!gf_list_count(stbl->child_boxes)) {\n\t\tgf_list_del(stbl->child_boxes);\n\t\tstbl->child_boxes = NULL;\n\t}\n\tfor (i = 0; i < gf_list_count(trak->child_boxes); i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->child_boxes, i);\n\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\tgf_isom_box_del_parent(&trak->child_boxes, a);\n\t\t\ti--;\n\t\t}\n\t\telse if (a->type == GF_ISOM_BOX_TYPE_SENC) {\n\t\t\tgf_isom_box_del_parent(&trak->child_boxes, a);\n\t\t\ti--;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_remove_samp_group_box(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tu32 i;\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl)\n\t\treturn GF_BAD_PARAM;\n\n\tfor (i = 0; i < gf_list_count(stbl->sampleGroupsDescription); i++) {\n\t\tGF_SampleGroupDescriptionBox *a = (GF_SampleGroupDescriptionBox *)gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tif (a->grouping_type == GF_ISOM_SAMPLE_GROUP_SEIG) {\n\t\t\tgf_list_rem(stbl->sampleGroupsDescription, i);\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *) a);\n\t\t\ti--;\n\t\t}\n\t}\n\tif (!gf_list_count(stbl->sampleGroupsDescription)) {\n\t\tgf_list_del(stbl->sampleGroupsDescription);\n\t\tstbl->sampleGroupsDescription = NULL;\n\t}\n\n\tfor (i = 0; i < gf_list_count(stbl->sampleGroups); i++) {\n\t\tGF_SampleGroupBox *a = (GF_SampleGroupBox *)gf_list_get(stbl->sampleGroups, i);\n\t\tif (a->grouping_type == GF_ISOM_SAMPLE_GROUP_SEIG) {\n\t\t\tgf_list_rem(stbl->sampleGroups, i);\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *) a);\n\t\t\ti--;\n\t\t}\n\t}\n\tif (!gf_list_count(stbl->sampleGroups)) {\n\t\tgf_list_del(stbl->sampleGroups);\n\t\tstbl->sampleGroups = NULL;\n\t}\n\n\treturn GF_OK;\n}\n\n#if 0 //unused\n/*! removes CENC PSSH box\n\\param isom_file the target ISO file\n\\return error if any\n*/\nGF_Err gf_isom_remove_pssh_box(GF_ISOFile *the_file)\n{\n\tu32 i;\n\tfor (i = 0; i < gf_list_count(the_file->moov->child_boxes); i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(the_file->moov->child_boxes, i);\n\t\tGF_UUIDBox *uuid = (GF_UUIDBox *)a;\n\t\tif ((a->type == GF_ISOM_BOX_TYPE_PSSH)\n\t\t\t|| ((a->type == GF_ISOM_BOX_TYPE_UUID) && (uuid->internal_4cc == GF_ISOM_BOX_UUID_PSSH))\n\t\t) {\n\t\t\tgf_isom_box_del_parent(&the_file->moov->child_boxes, a);\n\t\t\ti--;\n\t\t}\n\t}\n\n\tif (!gf_list_count(the_file->moov->child_boxes)) {\n\t\tgf_list_del(the_file->moov->child_boxes);\n\t\tthe_file->moov->child_boxes = NULL;\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_SampleEncryptionBox * gf_isom_create_piff_psec_box(u8 version, u32 flags, u32 AlgorithmID, u8 IV_size, bin128 KID)\n{\n\tGF_SampleEncryptionBox *psec;\n\n\tpsec = (GF_SampleEncryptionBox *) gf_isom_box_new(GF_ISOM_BOX_UUID_PSEC);\n\tif (!psec)\n\t\treturn NULL;\n\tpsec->version = version;\n\tpsec->flags = flags;\n\tpsec->piff_type = 1;\n\tif (psec->flags & 0x1) {\n\t\tpsec->AlgorithmID = AlgorithmID;\n\t\tpsec->IV_size = IV_size;\n\t\tstrcpy((char *)psec->KID, (const char *)KID);\n\t}\n\tpsec->samp_aux_info = gf_list_new();\n\n\treturn psec;\n}\n\nGF_SampleEncryptionBox * gf_isom_create_samp_enc_box(u8 version, u32 flags)\n{\n\tGF_SampleEncryptionBox *senc;\n\n\tsenc = (GF_SampleEncryptionBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SENC);\n\tif (!senc)\n\t\treturn NULL;\n\tsenc->version = version;\n\tsenc->flags = flags;\n\tsenc->samp_aux_info = gf_list_new();\n\n\treturn senc;\n}\n\nGF_Err gf_isom_cenc_allocate_storage(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->sample_encryption) return GF_OK;\n\ttrak->sample_encryption = (GF_SampleEncryptionBox *)gf_isom_create_samp_enc_box(0, 0);\n\t//senc will be written and destroyed with the other boxes\n\tif (!trak->child_boxes) trak->child_boxes = gf_list_new();\n\treturn gf_list_add(trak->child_boxes, trak->sample_encryption);\n}\n\nGF_Err gf_isom_piff_allocate_storage(GF_ISOFile *the_file, u32 trackNumber, u32 AlgorithmID, u8 IV_size, bin128 KID)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->sample_encryption) return GF_OK;\n\ttrak->sample_encryption = (GF_SampleEncryptionBox *)gf_isom_create_piff_psec_box(1, 0, AlgorithmID, IV_size, KID);\n\t//senc will be written and destroyed with the other boxes\n\tif (!trak->child_boxes) trak->child_boxes = gf_list_new();\n\treturn gf_list_add(trak->child_boxes, trak->sample_encryption);\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nvoid gf_isom_cenc_set_saiz_saio(GF_SampleEncryptionBox *senc, GF_SampleTableBox *stbl, GF_TrackFragmentBox  *traf, u32 len, Bool saio_32bits, Bool use_multikey)\n{\n\tu32  i;\n\tGF_List **child_boxes = stbl ? &stbl->child_boxes : &traf->child_boxes;\n\tif (!senc->cenc_saiz) {\n\t\tsenc->cenc_saiz = (GF_SampleAuxiliaryInfoSizeBox *) gf_isom_box_new_parent(child_boxes, GF_ISOM_BOX_TYPE_SAIZ);\n\t\tif (!senc->cenc_saiz) return;\n\t\t//as per 3rd edition of cenc \"so content SHOULD be created omitting these optional fields\" ...\n\t\tsenc->cenc_saiz->aux_info_type = 0;\n\t\tsenc->cenc_saiz->aux_info_type_parameter = use_multikey ? 1 : 0;\n\t\tif (stbl)\n\t\t\tstbl_on_child_box((GF_Box*)stbl, (GF_Box *)senc->cenc_saiz, GF_FALSE);\n\t\telse\n\t\t\ttraf_on_child_box((GF_Box*)traf, (GF_Box *)senc->cenc_saiz, GF_FALSE);\n\t}\n\tif (!senc->cenc_saio) {\n\t\tsenc->cenc_saio = (GF_SampleAuxiliaryInfoOffsetBox *) gf_isom_box_new_parent(child_boxes, GF_ISOM_BOX_TYPE_SAIO);\n\t\tif (!senc->cenc_saio) return;\n\t\t//force using version 1 for saio box, it could be redundant when we use 64 bits for offset\n\t\tsenc->cenc_saio->version = saio_32bits ? 0 : 1;\n\t\t//as per 3rd edition of cenc \"so content SHOULD be created omitting these optional fields\" ...\n\t\tsenc->cenc_saio->aux_info_type = 0;\n\t\tsenc->cenc_saiz->aux_info_type_parameter = use_multikey ? 1 : 0;\n\t\tsenc->cenc_saio->entry_count = 1;\n\t\tif (stbl)\n\t\t\tstbl_on_child_box((GF_Box*)stbl, (GF_Box *)senc->cenc_saio, GF_FALSE);\n\t\telse\n\t\t\ttraf_on_child_box((GF_Box*)traf, (GF_Box *)senc->cenc_saio, GF_FALSE);\n\t}\n\n\tif (!senc->cenc_saiz->sample_count || ((senc->cenc_saiz->default_sample_info_size==len) && len) ) {\n\t\tsenc->cenc_saiz->sample_count ++;\n\t\tsenc->cenc_saiz->default_sample_info_size = len;\n\t} else {\n\t\tif (senc->cenc_saiz->sample_count + 1 > senc->cenc_saiz->sample_alloc) {\n\t\t\tif (!senc->cenc_saiz->sample_alloc) senc->cenc_saiz->sample_alloc = senc->cenc_saiz->sample_count+1;\n\t\t\telse senc->cenc_saiz->sample_alloc *= 2;\n\n\t\t\tsenc->cenc_saiz->sample_info_size = (u8*)gf_realloc(senc->cenc_saiz->sample_info_size, sizeof(u8)*(senc->cenc_saiz->sample_alloc));\n\t\t}\n\n\t\tif (senc->cenc_saiz->default_sample_info_size || (senc->cenc_saiz->sample_count==1)) {\n\t\t\tfor (i=0; i<senc->cenc_saiz->sample_count; i++)\n\t\t\t\tsenc->cenc_saiz->sample_info_size[i] = senc->cenc_saiz->default_sample_info_size;\n\t\t\tsenc->cenc_saiz->default_sample_info_size = 0;\n\t\t}\n\t\tsenc->cenc_saiz->sample_info_size[senc->cenc_saiz->sample_count] = len;\n\t\tsenc->cenc_saiz->sample_count++;\n\t}\n}\n\nGF_Err gf_isom_cenc_merge_saiz_saio(GF_SampleEncryptionBox *senc, GF_SampleTableBox *stbl, u64 offset, u32 len)\n{\n\tu32  i;\n\tassert(stbl);\n\tif (!senc->cenc_saiz) {\n\t\tsenc->cenc_saiz = (GF_SampleAuxiliaryInfoSizeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_SAIZ);\n\t\tif (!senc->cenc_saiz) return GF_OUT_OF_MEM;\n\t\tsenc->cenc_saiz->aux_info_type = GF_ISOM_CENC_SCHEME;\n\t\tsenc->cenc_saiz->aux_info_type_parameter = 0;\n\t\tstbl_on_child_box((GF_Box*)stbl, (GF_Box *)senc->cenc_saiz, GF_FALSE);\n\t}\n\tif (!senc->cenc_saio) {\n\t\tsenc->cenc_saio = (GF_SampleAuxiliaryInfoOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_SAIO);\n\t\tif (!senc->cenc_saio) return GF_OUT_OF_MEM;\n\t\t//force using version 1 for saio box, it could be redundant when we use 64 bits for offset\n\t\tsenc->cenc_saio->version = 1;\n\t\tsenc->cenc_saio->aux_info_type = GF_ISOM_CENC_SCHEME;\n\t\tsenc->cenc_saio->aux_info_type_parameter = 0;\n\t\tstbl_on_child_box((GF_Box*)stbl, (GF_Box *)senc->cenc_saio, GF_FALSE);\n\t}\n\n\tif (!senc->cenc_saiz->sample_count || (!senc->cenc_saiz->sample_alloc && (senc->cenc_saiz->default_sample_info_size==len))) {\n\t\tsenc->cenc_saiz->sample_count ++;\n\t\tsenc->cenc_saiz->default_sample_info_size = len;\n\t} else {\n\t\tif (senc->cenc_saiz->sample_count + 1 > senc->cenc_saiz->sample_alloc) {\n\t\t\tif (!senc->cenc_saiz->sample_alloc) senc->cenc_saiz->sample_alloc = senc->cenc_saiz->sample_count + 1;\n\t\t\telse senc->cenc_saiz->sample_alloc *= 2;\n\t\t\tsenc->cenc_saiz->sample_info_size = (u8*)gf_realloc(senc->cenc_saiz->sample_info_size, sizeof(u8)*(senc->cenc_saiz->sample_alloc));\n\t\t\tif (!senc->cenc_saiz->sample_info_size) return GF_OUT_OF_MEM;\n\t\t}\n\n\t\tif (senc->cenc_saiz->default_sample_info_size) {\n\t\t\tfor (i=0; i<senc->cenc_saiz->sample_count; i++)\n\t\t\t\tsenc->cenc_saiz->sample_info_size[i] = senc->cenc_saiz->default_sample_info_size;\n\t\t\tsenc->cenc_saiz->default_sample_info_size = 0;\n\t\t}\n\t\tsenc->cenc_saiz->sample_info_size[senc->cenc_saiz->sample_count] = len;\n\t\tsenc->cenc_saiz->sample_count++;\n\t}\n\n\tif (!senc->cenc_saio->entry_count) {\n\t\tsenc->cenc_saio->offsets = (u64 *)gf_malloc(sizeof(u64));\n\t\tif (!senc->cenc_saio->offsets) return GF_OUT_OF_MEM;\n\t\tsenc->cenc_saio->offsets[0] = offset;\n\t\tsenc->cenc_saio->entry_count ++;\n\t\tsenc->cenc_saio->entry_alloc = 1;\n\t} else {\n\t\tif (senc->cenc_saio->entry_count >= senc->cenc_saio->entry_alloc) {\n\t\t\tsenc->cenc_saio->entry_alloc += 50;\n\t\t\tsenc->cenc_saio->offsets = (u64*)gf_realloc(senc->cenc_saio->offsets, sizeof(u64)*(senc->cenc_saio->entry_alloc));\n\t\t\tif (!senc->cenc_saio->offsets) return GF_OUT_OF_MEM;\n\t\t}\n\t\tsenc->cenc_saio->offsets[senc->cenc_saio->entry_count] = offset;\n\t\tsenc->cenc_saio->entry_count++;\n\t}\n\tif (offset > 0xFFFFFFFFUL)\n\t\tsenc->cenc_saio->version=1;\n\treturn GF_OK;\n}\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n\nGF_Err gf_isom_track_cenc_add_sample_info(GF_ISOFile *the_file, u32 trackNumber, u32 container_type, u8 *buf, u32 len, Bool use_subsamples, Bool use_saio_32bit, Bool use_multikey)\n{\n\tGF_SampleEncryptionBox *senc;\n\tGF_CENCSampleAuxInfo *sai;\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl) return GF_BAD_PARAM;\n\n\tswitch (container_type) {\n\tcase GF_ISOM_BOX_UUID_PSEC:\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\tcase 0:\n\t\tsenc = trak->sample_encryption;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif (len && buf) {\n\t\tGF_SAFEALLOC(sai, GF_CENCSampleAuxInfo);\n\t\tif (!sai) return GF_OUT_OF_MEM;\n\t\tsai->cenc_data_size = len;\n\t\tsai->cenc_data = gf_malloc(sizeof(u8) * len);\n\t\tif (!sai->cenc_data) {\n\t\t\tgf_free(sai);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tmemcpy(sai->cenc_data, buf, len);\n\n\t\tgf_list_add(senc->samp_aux_info, sai);\n\t} else {\n\t\tGF_SAFEALLOC(sai, GF_CENCSampleAuxInfo);\n\t\tif (!sai) return GF_OUT_OF_MEM;\n\t\tgf_list_add(senc->samp_aux_info, sai);\n\t\tsai->isNotProtected = 1;\n\t}\n\tif (use_subsamples)\n\t\tsenc->flags = 0x00000002;\n\tif (use_multikey)\n\t\tsenc->version = 1;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tgf_isom_cenc_set_saiz_saio(senc, stbl, NULL, sai->cenc_data_size, use_saio_32bit, use_multikey);\n#endif\n\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nvoid gf_isom_cenc_samp_aux_info_del(GF_CENCSampleAuxInfo *samp)\n{\n\tif (!samp) return;\n\tif (samp->cenc_data) gf_free(samp->cenc_data);\n\tgf_free(samp);\n}\n\nBool gf_isom_cenc_has_saiz_saio_full(GF_SampleTableBox *stbl, void *_traf, u32 scheme_type)\n{\n\tu32 i, c1, c2;\n\tGF_List *sai_sizes, *sai_offsets;\n\tu32 sinf_fmt = 0;\n\tBool has_saiz, has_saio;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf=(GF_TrackFragmentBox *)_traf;\n#endif\n\thas_saiz = has_saio = GF_FALSE;\n\n\tif (stbl) {\n\t\tsai_sizes = stbl->sai_sizes;\n\t\tsai_offsets = stbl->sai_offsets;\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\telse if (_traf) {\n\t\tsai_sizes = traf->sai_sizes;\n\t\tsai_offsets = traf->sai_offsets;\n\t}\n#endif\n\telse\n\t\treturn GF_FALSE;\n\n\tc1 = gf_list_count(sai_sizes);\n\tc2 = gf_list_count(sai_offsets);\n\tfor (i = 0; i < c1; i++) {\n\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(sai_sizes, i);\n\t\tu32 saiz_aux_info_type = saiz->aux_info_type;\n\t\tif (!saiz_aux_info_type) saiz_aux_info_type = scheme_type;\n\n\n\t\tif (!saiz_aux_info_type) {\n\t\t\tGF_SampleEntryBox *entry = NULL;\n\t\t\tGF_ProtectionSchemeInfoBox *sinf = NULL;\n\t\t\tif (stbl) {\n\t\t\t\tentry = gf_list_get(stbl->SampleDescription->child_boxes, 0);\n\t\t\t} else {\n\t\t\t\tentry = gf_list_get(traf->trex->track->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\t\t}\n\n\t\t\tif (entry)\n\t\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\t\tif (sinf && sinf->scheme_type) {\n\t\t\t\tsaiz_aux_info_type = sinf_fmt = sinf->scheme_type->scheme_type;\n\t\t\t}\n\t\t}\n\t\tif (!saiz_aux_info_type && (c1==1) && (c2==1)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] saiz box without flags nor aux info type and no default scheme, ignoring\\n\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (saiz_aux_info_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_ISOM_PIFF_SCHEME:\n\t\t\thas_saiz = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < c2; i++) {\n\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(sai_offsets, i);\n\t\tu32 saio_aux_info_type = saio->aux_info_type;\n\t\tif (!saio_aux_info_type) saio_aux_info_type = scheme_type;\n\t\tif (!saio_aux_info_type) saio_aux_info_type = sinf_fmt;\n\n\t\tif (!saio_aux_info_type) {\n\t\t\tGF_SampleEntryBox *entry = NULL;\n\t\t\tGF_ProtectionSchemeInfoBox *sinf = NULL;\n\t\t\tif (stbl) {\n\t\t\t\tentry = gf_list_get(stbl->SampleDescription->child_boxes, 0);\n\t\t\t} else {\n\t\t\t\tentry = gf_list_get(traf->trex->track->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\t\t}\n\t\t\tif (entry)\n\t\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\t\tif (sinf && sinf->scheme_type) {\n\t\t\t\tsaio_aux_info_type = sinf_fmt = sinf->scheme_type->scheme_type;\n\t\t\t}\n\t\t}\n\t\tif (!saio_aux_info_type && (c1==1) && (c2==1)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] saio box without flags nor aux info type and no default scheme, ignoring\\n\"));\n\t\t\tcontinue;\n\t\t}\n\t\t//special case for query on a file that has just been imported but not yet written: saio offset is NULL, we must use senc\n\t\tif (saio->entry_count && !saio->offsets)\n\t\t\tcontinue;\n\t\tswitch (saio_aux_info_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_ISOM_PIFF_SCHEME:\n\t\t\thas_saio = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (has_saiz && has_saio);\n}\n\nBool gf_isom_cenc_has_saiz_saio_track(GF_SampleTableBox *stbl, u32 scheme_type)\n{\n\treturn gf_isom_cenc_has_saiz_saio_full(stbl, NULL, scheme_type);\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nBool gf_isom_cenc_has_saiz_saio_traf(GF_TrackFragmentBox *traf, u32 scheme_type)\n{\n\treturn gf_isom_cenc_has_saiz_saio_full(NULL, traf, scheme_type);\n}\n#endif\n\n\nstatic GF_Err isom_cenc_get_sai_by_saiz_saio(GF_MediaBox *mdia, u32 sampleNumber, u32 scheme_type, u8 **out_buffer, u32 *out_size)\n{\n\tu32  prev_sai_size, size, i, j, nb_saio;\n\tu64 cur_position, offset;\n\tGF_Err e = GF_OK;\n\tGF_SampleAuxiliaryInfoOffsetBox *saio_cenc=NULL;\n\tGF_SampleAuxiliaryInfoSizeBox *saiz_cenc=NULL;\n\tnb_saio = size = prev_sai_size = 0;\n\toffset = 0;\n\n\tif (! out_buffer || !out_size) return GF_BAD_PARAM;\n\n\tfor (i = 0; i < gf_list_count(mdia->information->sampleTable->sai_offsets); i++) {\n\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(mdia->information->sampleTable->sai_offsets, i);\n\t\tu32 aux_info_type = saio->aux_info_type;\n\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\n\t\tswitch (aux_info_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_ISOM_PIFF_SCHEME:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (saio->entry_count == 1)\n\t\t\toffset = saio->offsets[0];\n\t\telse\n\t\t\toffset = saio->offsets[sampleNumber-1];\n\t\tnb_saio = saio->entry_count;\n\t\tsaio_cenc = saio;\n\t\tbreak;\n\t}\n\tif (!saio_cenc) return GF_ISOM_INVALID_FILE;\n\n\tfor (i = 0; i < gf_list_count(mdia->information->sampleTable->sai_sizes); i++) {\n\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(mdia->information->sampleTable->sai_sizes, i);\n\t\tu32 aux_info_type = saiz->aux_info_type;\n\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\n\t\tswitch (aux_info_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_ISOM_PIFF_SCHEME:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif (sampleNumber>saiz->sample_count) {\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tif ((nb_saio==1) && !saio_cenc->total_size) {\n\t\t\tfor (j = 0; j < saiz->sample_count; j++) {\n\t\t\t\tsaio_cenc->total_size += saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[j];\n\t\t\t}\n\t\t}\n\t\tif (saiz->cached_sample_num+1== sampleNumber) {\n\t\t\tprev_sai_size = saiz->cached_prev_size;\n\t\t} else {\n\t\t\tfor (j = 0; j < sampleNumber-1; j++)\n\t\t\t\tprev_sai_size += saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[j];\n\t\t}\n\t\tsize = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[sampleNumber-1];\n\t\tsaiz_cenc=saiz;\n\t\tbreak;\n\t}\n\tif (!saiz_cenc) return GF_BAD_PARAM;\n\n\tsaiz_cenc->cached_sample_num = sampleNumber;\n\tsaiz_cenc->cached_prev_size = prev_sai_size + size;\n\n\tif (saio_cenc->total_size) {\n\t\tif (!saio_cenc->cached_data) {\n\t\t\tsaio_cenc->cached_data = gf_malloc(sizeof(u8)*saio_cenc->total_size);\n\t\t\tif (!saio_cenc->cached_data) return GF_OUT_OF_MEM;\n\t\t\tcur_position = gf_bs_get_position(mdia->information->dataHandler->bs);\n\t\t\tgf_bs_seek(mdia->information->dataHandler->bs, offset);\n\t\t\tgf_bs_read_data(mdia->information->dataHandler->bs, saio_cenc->cached_data, saio_cenc->total_size);\n\t\t\tgf_bs_seek(mdia->information->dataHandler->bs, cur_position);\n\t\t}\n\t\tif (out_size) {\n\t\t\tif (out_buffer) {\n\t\t\t\tif ((*out_size) < size) {\n\t\t\t\t\t(*out_buffer) = gf_realloc((*out_buffer), sizeof(char)*(size) );\n\t\t\t\t\tif (! *out_buffer) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tmemcpy((*out_buffer), saio_cenc->cached_data + prev_sai_size, size);\n\t\t\t}\n\t\t\t(*out_size) = size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\toffset += (nb_saio == 1) ? prev_sai_size : 0;\n\tcur_position = gf_bs_get_position(mdia->information->dataHandler->bs);\n\tgf_bs_seek(mdia->information->dataHandler->bs, offset);\n\n\tif (out_buffer) {\n\t\tif ((*out_size) < size) {\n\t\t\t(*out_buffer) = gf_realloc((*out_buffer), sizeof(char)*(size) );\n\t\t\tif (! *out_buffer) return GF_OUT_OF_MEM;\n\t\t}\n\t\tgf_bs_read_data(mdia->information->dataHandler->bs, (*out_buffer), size);\n\t}\n\t(*out_size) = size;\n\n\tgf_bs_seek(mdia->information->dataHandler->bs, cur_position);\n\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_cenc_get_sample_aux_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 sampleDescIndex, u32 *container_type, u8 **out_buffer, u32 *outSize)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\tGF_SampleEncryptionBox *senc = NULL;\n\tu32 type, scheme_type = -1;\n\tGF_CENCSampleAuxInfo *a_sai;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl)\n\t\treturn GF_BAD_PARAM;\n\n\ttype = 0;\n\tsenc = trak->sample_encryption;\n\t//no senc is OK\n\tif (senc) {\n\t\tif ((senc->type == GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)senc)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\ttype = GF_ISOM_BOX_UUID_PSEC;\n\t\t} else if (senc->type == GF_ISOM_BOX_TYPE_SENC) {\n\t\t\ttype = GF_ISOM_BOX_TYPE_SENC;\n\t\t}\n\n\t\tif (container_type) *container_type = type;\n\t}\n\n\tif (!out_buffer) return GF_OK; /*we need only container_type*/\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\tgf_isom_get_cenc_info(the_file, trackNumber, sampleDescIndex, NULL, &scheme_type, NULL);\n\n\t/*get sample auxiliary information by saiz/saio rather than by parsing senc box*/\n\tif (gf_isom_cenc_has_saiz_saio_track(stbl, scheme_type)) {\n\t\treturn isom_cenc_get_sai_by_saiz_saio(trak->Media, sampleNumber, scheme_type, out_buffer, outSize);\n\t}\n\tif (!senc)\n\t\treturn GF_OK;\n\n\t//senc is not loaded by default, do it now\n\tif (!gf_list_count(senc->samp_aux_info)) {\n\t\tGF_Err e = senc_Parse(trak->Media->information->dataHandler->bs, trak, NULL, senc);\n\t\tif (e) return e;\n\t}\n\n\ta_sai = NULL;\n\tswitch (type) {\n\tcase GF_ISOM_BOX_UUID_PSEC:\n\t\tif (senc)\n\t\t\ta_sai = (GF_CENCSampleAuxInfo *)gf_list_get(senc->samp_aux_info, sampleNumber-1);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\t\tif (senc)\n\t\t\ta_sai = (GF_CENCSampleAuxInfo *)gf_list_get(senc->samp_aux_info, sampleNumber-1);\n\t\tbreak;\n\t}\n\t//not present, check we use constant IV and no IV size\n\tif (!a_sai) {\n\t\tconst u8 *key_info=NULL;\n\t\tu32 key_info_size=0;\n\t\tu8 IV_size=0, constant_IV_size=0;\n\t\tBool is_Protected;\n\n\t\tgf_isom_get_sample_cenc_info_internal(trak, NULL, senc, sampleNumber, &is_Protected, NULL, NULL, &key_info, &key_info_size);\n\t\tif (!key_info) {\n\t\t\tIV_size = key_info_size; //piff default\n\t\t} else {\n\t\t\tIV_size = key_info[3];\n\t\t\tif (!IV_size)\n\t\t\t\tconstant_IV_size = key_info[20];\n\t\t}\n\t\tif (!IV_size && constant_IV_size)\n\t\t\treturn GF_OK;\n\t\treturn GF_NOT_FOUND;\n\t}\n\n\tif (*outSize < a_sai->cenc_data_size) {\n\t\t*out_buffer = gf_realloc(*out_buffer, sizeof(char) * a_sai->cenc_data_size);\n\t\tif (! *out_buffer) return GF_OUT_OF_MEM;\n\t\t*outSize = a_sai->cenc_data_size;\n\t}\n\tmemcpy(*out_buffer, a_sai->cenc_data, a_sai->cenc_data_size);\n\treturn GF_OK;\n}\n\nu32 gf_isom_has_cenc_sample_group_ex(GF_TrackBox *trak);\n\nvoid gf_isom_cenc_get_default_info_internal(GF_TrackBox *trak, u32 sampleDescriptionIndex, u32 *container_type, Bool *default_IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n{\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\n\t//setup all default as not encrypted\n\tif (default_IsEncrypted) *default_IsEncrypted = GF_FALSE;\n\tif (crypt_byte_block) *crypt_byte_block = 0;\n\tif (skip_byte_block) *skip_byte_block = 0;\n\tif (container_type) *container_type = 0;\n\tif (key_info) *key_info = NULL;\n\tif (key_info_size) *key_info_size = 0;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENC_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBC_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENS_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBCS_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_PIFF_SCHEME, NULL);\n\n\tif (!sinf) {\n\t\tu32 i, nb_stsd = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\t\tfor (i=0; i<nb_stsd; i++) {\n\t\t\tGF_ProtectionSchemeInfoBox *a_sinf;\n\t\t\tGF_SampleEntryBox *sentry=NULL;\n\t\t\tif (i+1==sampleDescriptionIndex) continue;\n\t\t\tsentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\t\ta_sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(sentry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\t\tif (!a_sinf) continue;\n\t\t\t//signal default (not encrypted)\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (sinf && sinf->info && sinf->info->tenc) {\n\t\tif (default_IsEncrypted) *default_IsEncrypted = sinf->info->tenc->isProtected;\n\t\tif (crypt_byte_block) *crypt_byte_block = sinf->info->tenc->crypt_byte_block;\n\t\tif (skip_byte_block) *skip_byte_block = sinf->info->tenc->skip_byte_block;\n\t\tif (key_info) *key_info = sinf->info->tenc->key_info;\n\t\tif (key_info_size) {\n\t\t\t*key_info_size = 20;\n\t\t\tif (!sinf->info->tenc->key_info[3])\n\t\t\t\t*key_info_size += 1 + sinf->info->tenc->key_info[20];\n\t\t}\n\n\t\t//set default value, overwritten below\n\t\tif (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC;\n\t} else if (sinf && sinf->info && sinf->info->piff_tenc) {\n\t\tif (default_IsEncrypted) *default_IsEncrypted = GF_TRUE;\n\t\tif (key_info) *key_info = sinf->info->piff_tenc->key_info;\n\t\tif (key_info_size) *key_info_size = 19;\n\t\t//set default value, overwritten below\n\t\tif (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC;\n\t} else {\n\t\tu32 i, count = 0;\n\t\tGF_CENCSampleEncryptionGroupEntry *seig_entry = NULL;\n\n\t\tif (!trak->moov->mov->is_smooth)\n\t\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\tif (sgdesc->grouping_type!=GF_ISOM_SAMPLE_GROUP_SEIG) continue;\n\t\t\tif (sgdesc->default_description_index)\n\t\t\t\tseig_entry = gf_list_get(sgdesc->group_descriptions, sgdesc->default_description_index-1);\n\t\t\telse\n\t\t\t\tseig_entry = gf_list_get(sgdesc->group_descriptions, 0);\n\t\t\tif (seig_entry && !seig_entry->key_info[0])\n\t\t\t\tseig_entry = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (seig_entry) {\n\t\t\tif (default_IsEncrypted) *default_IsEncrypted = seig_entry->IsProtected;\n\t\t\tif (crypt_byte_block) *crypt_byte_block = seig_entry->crypt_byte_block;\n\t\t\tif (skip_byte_block) *skip_byte_block = seig_entry->skip_byte_block;\n\t\t\tif (key_info) *key_info = seig_entry->key_info;\n\t\t\tif (key_info_size) *key_info_size = seig_entry->key_info_size;\n\t\t\tif (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC;\n\t\t} else {\n\t\t\tif (! trak->moov->mov->is_smooth ) {\n\t\t\t\ttrak->moov->mov->is_smooth = GF_TRUE;\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] senc box without tenc, assuming MS smooth+piff\\n\"));\n\t\t\t}\n\t\t\tif (default_IsEncrypted) *default_IsEncrypted = GF_TRUE;\n\t\t\t//set default value, overwritten below\n\t\t\tif (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC;\n\t\t}\n\t}\n\n\tif (container_type && trak->sample_encryption) {\n\t\tif (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_SENC) *container_type = GF_ISOM_BOX_TYPE_SENC;\n\t\telse if (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_UUID) *container_type = ((GF_UUIDBox*)trak->sample_encryption)->internal_4cc;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_cenc_get_default_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *container_type, Bool *default_IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tgf_isom_cenc_get_default_info_internal(trak, sampleDescriptionIndex, container_type, default_IsEncrypted, crypt_byte_block, skip_byte_block, key_info, key_info_size);\n\treturn GF_OK;\n}\n\n/*\n\tAdobe'protection scheme\n*/\nGF_Err gf_isom_set_adobe_protection(GF_ISOFile *the_file, u32 trackNumber, u32 desc_index, u32 scheme_type, u32 scheme_version, Bool is_selective_enc, char *metadata, u32 len)\n{\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\t//setup generic protection\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_Err e;\n\te = isom_set_protected_entry(the_file, trackNumber, desc_index, 1, 0, scheme_type, scheme_version, NULL, GF_FALSE, &sinf);\n\tif (e) return e;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n\n\tsinf->info->adkm = (GF_AdobeDRMKeyManagementSystemBox *)gf_isom_box_new_parent(&sinf->info->child_boxes, GF_ISOM_BOX_TYPE_ADKM);\n\tif (!sinf->info->adkm) return GF_OUT_OF_MEM;\n\n\tsinf->info->adkm->header = (GF_AdobeDRMHeaderBox *)gf_isom_box_new_parent(&sinf->info->adkm->child_boxes, GF_ISOM_BOX_TYPE_AHDR);\n\tif (!sinf->info->adkm->header) return GF_OUT_OF_MEM;\n\n\tsinf->info->adkm->header->std_enc_params = (GF_AdobeStdEncryptionParamsBox *)gf_isom_box_new_parent(& sinf->info->adkm->header->child_boxes, GF_ISOM_BOX_TYPE_APRM);\n\tif (!sinf->info->adkm->header->std_enc_params) return GF_OUT_OF_MEM;\n\n\tsinf->info->adkm->header->std_enc_params->enc_info = (GF_AdobeEncryptionInfoBox *)gf_isom_box_new_parent(&sinf->info->adkm->header->std_enc_params->child_boxes, GF_ISOM_BOX_TYPE_AEIB);\n\tif (!sinf->info->adkm->header->std_enc_params->enc_info) return GF_OUT_OF_MEM;\n\n\tsinf->info->adkm->header->std_enc_params->enc_info->enc_algo = (char *)gf_malloc(8*sizeof(char));\n\tif (!sinf->info->adkm->header->std_enc_params->enc_info->enc_algo) return GF_OUT_OF_MEM;\n\n\tstrcpy(sinf->info->adkm->header->std_enc_params->enc_info->enc_algo, \"AES-CBC\");\n\tsinf->info->adkm->header->std_enc_params->enc_info->key_length = 16;\n\n\tsinf->info->adkm->header->std_enc_params->key_info = (GF_AdobeKeyInfoBox *)gf_isom_box_new_parent(&sinf->info->adkm->header->std_enc_params->child_boxes, GF_ISOM_BOX_TYPE_AKEY);\n\tif (!sinf->info->adkm->header->std_enc_params->key_info) return GF_OUT_OF_MEM;\n\n\tsinf->info->adkm->header->std_enc_params->key_info->params = (GF_AdobeFlashAccessParamsBox *)gf_isom_box_new_parent(&sinf->info->adkm->header->std_enc_params->key_info->child_boxes, GF_ISOM_BOX_TYPE_FLXS);\n\tif (!sinf->info->adkm->header->std_enc_params->key_info->params) return GF_OUT_OF_MEM;\n\n\tif (metadata && len) {\n\t\tsinf->info->adkm->header->std_enc_params->key_info->params->metadata = (char *)gf_malloc((len+1)*sizeof(char));\n\t\tif (!sinf->info->adkm->header->std_enc_params->key_info->params->metadata) return GF_OUT_OF_MEM;\n\n\t\tstrncpy(sinf->info->adkm->header->std_enc_params->key_info->params->metadata, metadata, len);\n\t\tsinf->info->adkm->header->std_enc_params->key_info->params->metadata[len] = 0;\n\t}\n\n\tsinf->info->adkm->au_format = (GF_AdobeDRMAUFormatBox *)gf_isom_box_new_parent(&sinf->info->adkm->child_boxes, GF_ISOM_BOX_TYPE_ADAF);\n\tif (!sinf->info->adkm->au_format) return GF_OUT_OF_MEM;\n\n\tsinf->info->adkm->au_format->selective_enc = is_selective_enc ? 0x10 : 0x00;\n\tsinf->info->adkm->au_format->IV_length = 16;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_isom_is_adobe_protection_media(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_ADOBE_SCHEME, NULL);\n\n\tif (!sinf) return GF_FALSE;\n\n\t/*non-encrypted or non-ADOBE*/\n\tif (!sinf->info || !sinf->info->adkm)\n\t\treturn GF_FALSE;\n\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_adobe_protection_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat, u32 *outSchemeType, u32 *outSchemeVersion, const char **outMetadata)\n{\n\tGF_TrackBox *trak;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_ADOBE_SCHEME, NULL);\n\n\tif (!sinf) return GF_BAD_PARAM;\n\n\tif (outOriginalFormat) {\n\t\t*outOriginalFormat = sinf->original_format->data_format;\n\t\tif (IsMP4Description(sinf->original_format->data_format)) *outOriginalFormat = GF_ISOM_SUBTYPE_MPEG4;\n\t}\n\tif (outSchemeType) *outSchemeType = sinf->scheme_type->scheme_type;\n\tif (outSchemeVersion) *outSchemeVersion = sinf->scheme_type->scheme_version;\n\n\tif (outMetadata) {\n\t\t*outMetadata = NULL;\n\t\tif (sinf->info && sinf->info->adkm && sinf->info->adkm->header && sinf->info->adkm->header->std_enc_params && sinf->info->adkm->header->std_enc_params->key_info\n\t\t\t&& sinf->info->adkm->header->std_enc_params->key_info->params && sinf->info->adkm->header->std_enc_params->key_info->params->metadata)\n\t\t{\n\t\t\t*outMetadata = sinf->info->adkm->header->std_enc_params->key_info->params->metadata;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\n\n#if 0 //unused\n/*! removes the IPMPX tools from files\n\\param isom_file the target ISO file\n*/\nvoid gf_isom_ipmpx_remove_tool_list(GF_ISOFile *the_file)\n{\n\t/*remove IPMPToolList if any*/\n\tif (the_file && the_file->moov && the_file->moov->iods && (the_file ->moov->iods->descriptor->tag == GF_ODF_ISOM_IOD_TAG) ) {\n\t\tGF_IsomInitialObjectDescriptor *iod = (GF_IsomInitialObjectDescriptor *)the_file ->moov->iods->descriptor;\n\t\tif (iod->IPMPToolList) gf_odf_desc_del((GF_Descriptor*) iod->IPMPToolList);\n\t\tiod->IPMPToolList = NULL;\n\t}\n}\n#endif\n\n\nBool gf_cenc_validate_key_info(const u8 *key_info, u32 key_info_size)\n{\n\tu32 i, n_keys, kpos, nb_missing = 19;\n\tif (!key_info|| (key_info_size<19))\n\t\tgoto exit;\n\n\tn_keys = 1;\n\tif (key_info[0]) {\n\t\tn_keys = key_info[1];\n\t\tn_keys <<= 8;\n\t\tn_keys |= key_info[2];\n\t}\n\tkpos=3;\n\tfor (i=0;i<n_keys; i++) {\n\t\tu8 iv_size;\n\t\tif (kpos + 17 > key_info_size) {\n\t\t\tnb_missing = kpos + 17 - key_info_size;\n\t\t\tgoto exit;\n\t\t}\n\t\tiv_size = key_info[kpos];\n\t\tkpos += 17;\n\t\tif (!iv_size) {\n\t\t\tif (kpos + 1 > key_info_size) {\n\t\t\t\tnb_missing = kpos + 1  - key_info_size;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tiv_size = key_info[kpos];\n\t\t\tif (kpos + 1 + iv_size > key_info_size) {\n\t\t\t\tnb_missing = kpos + 1 + iv_size - key_info_size;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tkpos += 1 + iv_size;\n\t\t}\n\t}\n\treturn GF_TRUE;\n\nexit:\n\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"Invalid key info format, missing %d bytes\\n\", nb_missing));\n\treturn GF_FALSE;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/isomedia/drm_sample.c"], "buggy_code_start_loc": [1689], "buggy_code_end_loc": [1690], "fixing_code_start_loc": [1689], "fixing_code_end_loc": [1690], "type": "CWE-476", "message": "The gf_isom_cenc_get_default_info_internal function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.", "other": {"cve": {"id": "CVE-2021-31259", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-19T19:15:18.373", "lastModified": "2021-04-21T19:23:43.293", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The gf_isom_cenc_get_default_info_internal function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command."}, {"lang": "es", "value": "La funci\u00f3n gf_isom_cenc_get_default_info_internal en GPAC versi\u00f3n 1.0.1, permite a atacantes causar una denegaci\u00f3n de servicio (desreferencia del puntero NULL) por medio de un archivo dise\u00f1ado en el comando MP4Box"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/3b84ffcbacf144ce35650df958432f472b6483f8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1735", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/3b84ffcbacf144ce35650df958432f472b6483f8"}}