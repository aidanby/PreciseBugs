{"buggy_code": ["/*\n * Copyright (C) 2009 Michal Kowalski <superflouos{at}gmail[dot]com>\n * Copyright (C) 2012-2013 Sean Timothy Noonan <stnoonan@obsolescence.net>\n * Copyright (C) 2013 Marcello Barnaba <vjt@openssl.it>\n * Copyright (C) 2013 Alexander Pyhalov <alp@sfedu.ru>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n */\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_http.h>\n\n#include <stdbool.h>\n#include <gssapi/gssapi.h>\n#include <gssapi/gssapi_krb5.h>\n#include <krb5.h>\n\n#define discard_const(ptr) ((void *)((uintptr_t)(ptr)))\n\n#define spnego_log_krb5_error(context,code) {\\\n    const char* ___kerror = krb5_get_error_message(context, code);\\\n    spnego_debug2(\"Kerberos error: %d, %s\", code , ___kerror);\\\n    krb5_free_error_message( context, ___kerror  ); }\n#define spnego_error(code) ret = code; goto end\n#define spnego_debug0(msg) ngx_log_debug0(\\\n        NGX_LOG_DEBUG_HTTP, r->connection->log, 0, msg)\n#define spnego_debug1(msg, one) ngx_log_debug1(\\\n        NGX_LOG_DEBUG_HTTP, r->connection->log, 0, msg, one)\n#define spnego_debug2(msg, one, two) ngx_log_debug2(\\\n        NGX_LOG_DEBUG_HTTP, r->connection->log, 0, msg, one, two)\n#define spnego_debug3(msg, one, two, three) ngx_log_debug3(\\\n        NGX_LOG_DEBUG_HTTP, r->connection->log, 0, msg, one, two, three)\n#define spnego_log_error(fmt, args...) ngx_log_error(\\\n        NGX_LOG_ERR, r->connection->log, 0, fmt, ##args)\n\n/* Module handler */\nstatic ngx_int_t ngx_http_auth_spnego_handler(ngx_http_request_t *);\n\nstatic void *ngx_http_auth_spnego_create_loc_conf(ngx_conf_t *);\nstatic char *ngx_http_auth_spnego_merge_loc_conf(\n        ngx_conf_t *, void *, void *);\nstatic ngx_int_t ngx_http_auth_spnego_init(ngx_conf_t *);\n\nngx_int_t\nngx_http_auth_spnego_set_bogus_authorization(ngx_http_request_t * r);\n\n    const char *\nget_gss_error(\n        ngx_pool_t * p,\n        OM_uint32 error_status,\n        char *prefix)\n{\n    OM_uint32 maj_stat, min_stat;\n    OM_uint32 msg_ctx = 0;\n    gss_buffer_desc status_string;\n    char buf[1024];\n    size_t len;\n    ngx_str_t str;\n    ngx_snprintf((u_char *) buf, sizeof(buf), \"%s: %Z\", prefix);\n    len = ngx_strlen(buf);\n    do {\n        maj_stat =\n            gss_display_status(&min_stat, error_status, GSS_C_MECH_CODE,\n                    GSS_C_NO_OID, &msg_ctx, &status_string);\n        if (sizeof(buf) > len + status_string.length + 1) {\n            ngx_sprintf((u_char *) buf + len, \"%s:%Z\",\n                    (char *) status_string.value);\n            len += (status_string.length + 1);\n        }\n        gss_release_buffer(&min_stat, &status_string);\n    }\n    while (!GSS_ERROR(maj_stat) && msg_ctx != 0);\n\n    str.len = len + 1; /* \"include\" '\\0' */\n    str.data = (u_char *) buf;\n    return (char *) (ngx_pstrdup(p, &str));\n}\n\n/* per request/connection */\ntypedef struct {\n    ngx_str_t token; /* decoded Negotiate token */\n    ngx_int_t head; /* non-zero flag if headers set */\n    ngx_int_t ret; /* current return code */\n    ngx_str_t token_out_b64; /* base64 encoded output tokent */\n} ngx_http_auth_spnego_ctx_t;\n\ntypedef struct {\n    ngx_flag_t protect;\n    ngx_str_t realm;\n    ngx_str_t keytab;\n    ngx_str_t srvcname;\n    ngx_flag_t fqun;\n    ngx_flag_t force_realm;\n    ngx_flag_t allow_basic;\n    ngx_array_t *auth_princs;\n    ngx_flag_t map_to_local;\n} ngx_http_auth_spnego_loc_conf_t;\n\n#define SPNEGO_NGX_CONF_FLAGS NGX_HTTP_MAIN_CONF\\\n    | NGX_HTTP_SRV_CONF\\\n| NGX_HTTP_LOC_CONF\\\n| NGX_HTTP_LMT_CONF\\\n| NGX_CONF_FLAG\n\n/* Module Directives */\nstatic ngx_command_t ngx_http_auth_spnego_commands[] = {\n    {ngx_string(\"auth_gss\"),\n        SPNEGO_NGX_CONF_FLAGS,\n        ngx_conf_set_flag_slot,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_http_auth_spnego_loc_conf_t, protect),\n        NULL},\n\n    {ngx_string(\"auth_gss_realm\"),\n        SPNEGO_NGX_CONF_FLAGS,\n        ngx_conf_set_str_slot,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_http_auth_spnego_loc_conf_t, realm),\n        NULL},\n\n    {ngx_string(\"auth_gss_keytab\"),\n        SPNEGO_NGX_CONF_FLAGS,\n        ngx_conf_set_str_slot,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_http_auth_spnego_loc_conf_t, keytab),\n        NULL},\n\n    {ngx_string(\"auth_gss_service_name\"),\n        SPNEGO_NGX_CONF_FLAGS,\n        ngx_conf_set_str_slot,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_http_auth_spnego_loc_conf_t, srvcname),\n        NULL},\n\n    {ngx_string(\"auth_gss_format_full\"),\n        SPNEGO_NGX_CONF_FLAGS,\n        ngx_conf_set_flag_slot,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_http_auth_spnego_loc_conf_t, fqun),\n        NULL},\n\n    {ngx_string(\"auth_gss_force_realm\"),\n        SPNEGO_NGX_CONF_FLAGS,\n        ngx_conf_set_flag_slot,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_http_auth_spnego_loc_conf_t, force_realm),\n        NULL},\n\n    {ngx_string(\"auth_gss_allow_basic_fallback\"),\n        SPNEGO_NGX_CONF_FLAGS,\n        ngx_conf_set_flag_slot,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_http_auth_spnego_loc_conf_t, allow_basic),\n        NULL},\n\n    {ngx_string(\"auth_gss_authorized_principal\"),\n        SPNEGO_NGX_CONF_FLAGS | NGX_CONF_1MORE,\n        ngx_conf_set_str_array_slot,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_http_auth_spnego_loc_conf_t, auth_princs),\n        NULL},\n\n    {ngx_string(\"auth_gss_map_to_local\"),\n        SPNEGO_NGX_CONF_FLAGS,\n        ngx_conf_set_flag_slot,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_http_auth_spnego_loc_conf_t, map_to_local),\n        NULL},\n\n    ngx_null_command\n};\n\n/* Module Context */\nstatic ngx_http_module_t ngx_http_auth_spnego_module_ctx = {\n    NULL, /* preconf */\n    ngx_http_auth_spnego_init, /* postconf */\n    NULL, /* create main conf (defaults) */\n    NULL, /* init main conf (what's in nginx.conf) */\n    NULL, /* create server conf */\n    NULL, /* merge with main */\n\n    ngx_http_auth_spnego_create_loc_conf, /* create location conf */\n    ngx_http_auth_spnego_merge_loc_conf, /* merge with server */\n};\n\n/* Module Definition */\nngx_module_t ngx_http_auth_spnego_module = {\n    /* ngx_uint_t ctx_index, index, spare{0-3}, version; */\n    NGX_MODULE_V1, /* 0, 0, 0, 0, 0, 0, 1 */\n    &ngx_http_auth_spnego_module_ctx, /* void *ctx */\n    ngx_http_auth_spnego_commands, /* ngx_command_t *commands */\n    NGX_HTTP_MODULE, /* ngx_uint_t type = 0x50545448 */\n    NULL, /* ngx_int_t (*init_master)(ngx_log_t *log) */\n    NULL, /* ngx_int_t (*init_module)(ngx_cycle_t *cycle) */\n    NULL, /* ngx_int_t (*init_process)(ngx_cycle_t *cycle) */\n    NULL, /* ngx_int_t (*init_thread)(ngx_cycle_t *cycle) */\n    NULL, /* void (*exit_thread)(ngx_cycle_t *cycle) */\n    NULL, /* void (*exit_process)(ngx_cycle_t *cycle) */\n    NULL, /* void (*exit_master)(ngx_cycle_t *cycle) */\n    NGX_MODULE_V1_PADDING, /* 0, 0, 0, 0, 0, 0, 0, 0 */\n    /* uintptr_t spare_hook{0-7}; */\n};\n\n    static void *\nngx_http_auth_spnego_create_loc_conf(\n        ngx_conf_t * cf)\n{\n    ngx_http_auth_spnego_loc_conf_t *conf;\n\n    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_auth_spnego_loc_conf_t));\n    if (NULL == conf) {\n        return NGX_CONF_ERROR;\n    }\n\n    conf->protect = NGX_CONF_UNSET;\n    conf->fqun = NGX_CONF_UNSET;\n    conf->force_realm = NGX_CONF_UNSET;\n    conf->allow_basic = NGX_CONF_UNSET;\n    conf->auth_princs = NGX_CONF_UNSET_PTR;\n    conf->map_to_local = NGX_CONF_UNSET;\n\n    return conf;\n}\n\n    static char *\nngx_http_auth_spnego_merge_loc_conf(\n        ngx_conf_t * cf,\n        void *parent,\n        void *child)\n{\n    ngx_http_auth_spnego_loc_conf_t *prev = parent;\n    ngx_http_auth_spnego_loc_conf_t *conf = child;\n\n    /* \"off\" by default */\n    ngx_conf_merge_off_value(conf->protect, prev->protect, 0);\n\n    ngx_conf_merge_str_value(conf->realm, prev->realm, \"\");\n    ngx_conf_merge_str_value(conf->keytab, prev->keytab,\n            \"/etc/krb5.keytab\");\n    ngx_conf_merge_str_value(conf->srvcname, prev->srvcname, \"\");\n\n    ngx_conf_merge_off_value(conf->fqun, prev->fqun, 0);\n    ngx_conf_merge_off_value(conf->force_realm, prev->force_realm, 0);\n    ngx_conf_merge_off_value(conf->allow_basic, prev->allow_basic, 1);\n    ngx_conf_merge_ptr_value(conf->auth_princs, prev->auth_princs, NGX_CONF_UNSET_PTR);\n\n    ngx_conf_merge_off_value(conf->map_to_local, prev->map_to_local, 0);\n\n#if (NGX_DEBUG)\n    ngx_conf_log_error(NGX_LOG_INFO, cf, 0, \"auth_spnego: protect = %i\",\n            conf->protect);\n    ngx_conf_log_error(NGX_LOG_INFO, cf, 0, \"auth_spnego: realm@0x%p = %s\",\n            conf->realm.data, conf->realm.data);\n    ngx_conf_log_error(NGX_LOG_INFO, cf, 0,\n            \"auth_spnego: keytab@0x%p = %s\", conf->keytab.data,\n            conf->keytab.data);\n    ngx_conf_log_error(NGX_LOG_INFO, cf, 0,\n            \"auth_spnego: srvcname@0x%p = %s\",\n            conf->srvcname.data, conf->srvcname.data);\n    ngx_conf_log_error(NGX_LOG_INFO, cf, 0, \"auth_spnego: fqun = %i\",\n            conf->fqun);\n    ngx_conf_log_error(NGX_LOG_INFO, cf, 0, \"auth_spnego: allow_basic = %i\",\n            conf->allow_basic);\n    ngx_conf_log_error(NGX_LOG_INFO, cf, 0, \"auth_spnego: force_realm = %i\",\n            conf->force_realm);\n    if (NGX_CONF_UNSET_PTR != conf->auth_princs) {\n        size_t ii = 0;\n        ngx_str_t *auth_princs = conf->auth_princs->elts;\n        for (; ii < conf->auth_princs->nelts; ++ii) {\n            ngx_conf_log_error(NGX_LOG_DEBUG, cf, 0,\n                    \"auth_spnego: auth_princs = %.*s\", auth_princs[ii].len, auth_princs[ii].data);\n        }\n    }\n    ngx_conf_log_error(NGX_LOG_INFO, cf, 0, \"auth_spnego: map_to_local = %i\",\n            conf->map_to_local);\n#endif\n\n    return NGX_CONF_OK;\n}\n\n    static ngx_int_t\nngx_http_auth_spnego_init(\n        ngx_conf_t * cf)\n{\n    ngx_http_handler_pt *h;\n    ngx_http_core_main_conf_t *cmcf;\n\n    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);\n\n    h = ngx_array_push(&cmcf->phases[NGX_HTTP_ACCESS_PHASE].handlers);\n    if (NULL == h) {\n        return NGX_ERROR;\n    }\n\n    *h = ngx_http_auth_spnego_handler;\n\n    return NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_auth_spnego_headers_basic_only(\n    ngx_http_request_t *r,\n    ngx_http_auth_spnego_ctx_t *ctx,\n    ngx_http_auth_spnego_loc_conf_t *alcf)\n{\n    ngx_str_t value = ngx_null_string;\n    value.len = sizeof(\"Basic realm=\\\"\\\"\") - 1 + alcf->realm.len;\n    value.data = ngx_pcalloc(r->pool, value.len);\n    if (NULL == value.data) {\n        return NGX_ERROR;\n    }\n    ngx_snprintf(value.data, value.len, \"Basic realm=\\\"%V\\\"\",\n            &alcf->realm);\n    r->headers_out.www_authenticate =\n        ngx_list_push(&r->headers_out.headers);\n    if (NULL == r->headers_out.www_authenticate) {\n        return NGX_ERROR;\n    }\n\n    r->headers_out.www_authenticate->hash = 1;\n    r->headers_out.www_authenticate->key.len = sizeof(\"WWW-Authenticate\") - 1;\n    r->headers_out.www_authenticate->key.data = (u_char *) \"WWW-Authenticate\";\n    r->headers_out.www_authenticate->value.len = value.len;\n    r->headers_out.www_authenticate->value.data = value.data;\n\n    ctx->head = 1;\n\n    return NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_auth_spnego_headers(\n        ngx_http_request_t *r,\n        ngx_http_auth_spnego_ctx_t *ctx,\n        ngx_str_t *token,\n        ngx_http_auth_spnego_loc_conf_t *alcf)\n{\n    ngx_str_t value = ngx_null_string;\n    /* only use token if authorized as there appears to be a bug in\n     * Google Chrome when parsing a 401 Negotiate with a token */\n    if (NULL == token || ctx->ret != NGX_OK) {\n        value.len = sizeof(\"Negotiate\") - 1;\n        value.data = (u_char *) \"Negotiate\";\n    } else {\n        value.len = sizeof(\"Negotiate\") + token->len; /* space accounts for \\0 */\n        value.data = ngx_pcalloc(r->pool, value.len);\n        if (NULL == value.data) {\n            return NGX_ERROR;\n        }\n        ngx_snprintf(value.data, value.len, \"Negotiate %V\", token);\n    }\n\n    r->headers_out.www_authenticate =\n        ngx_list_push(&r->headers_out.headers);\n    if (NULL == r->headers_out.www_authenticate) {\n        return NGX_ERROR;\n    }\n\n    r->headers_out.www_authenticate->hash = 1;\n    r->headers_out.www_authenticate->key.len = sizeof(\"WWW-Authenticate\") - 1;\n    r->headers_out.www_authenticate->key.data = (u_char *) \"WWW-Authenticate\";\n    r->headers_out.www_authenticate->value.len = value.len;\n    r->headers_out.www_authenticate->value.data = value.data;\n\n    if (alcf->allow_basic) {\n        ngx_str_t value2 = ngx_null_string;\n        value2.len = sizeof(\"Basic realm=\\\"\\\"\") - 1 + alcf->realm.len;\n        value2.data = ngx_pcalloc(r->pool, value2.len);\n        if (NULL == value2.data) {\n            return NGX_ERROR;\n        }\n        ngx_snprintf(value2.data, value2.len, \"Basic realm=\\\"%V\\\"\",\n                &alcf->realm);\n        r->headers_out.www_authenticate =\n            ngx_list_push(&r->headers_out.headers);\n        if (NULL == r->headers_out.www_authenticate) {\n            return NGX_ERROR;\n        }\n\n        r->headers_out.www_authenticate->hash = 2;\n        r->headers_out.www_authenticate->key.len = sizeof(\"WWW-Authenticate\") - 1;\n        r->headers_out.www_authenticate->key.data = (u_char *) \"WWW-Authenticate\";\n        r->headers_out.www_authenticate->value.len = value2.len;\n        r->headers_out.www_authenticate->value.data = value2.data;\n    }\n\n    ctx->head = 1;\n\n    return NGX_OK;\n}\n\n    static bool\nngx_spnego_authorized_principal(\n        ngx_http_request_t * r,\n        ngx_str_t *princ,\n        ngx_http_auth_spnego_loc_conf_t *alcf)\n{\n    if (NGX_CONF_UNSET_PTR == alcf->auth_princs) {\n        return true;\n    }\n    size_t ii = 0;\n    ngx_str_t *auth_princs = alcf->auth_princs->elts;\n    spnego_debug1(\"Testing against %d auth princs\", alcf->auth_princs->nelts);\n    for (; ii < alcf->auth_princs->nelts; ++ii) {\n        if (auth_princs[ii].len != princ->len) {\n            continue;\n        }\n        if (ngx_strncmp(auth_princs[ii].data, princ->data, princ->len) == 0) {\n            spnego_debug2(\"Authorized user %.*s\", princ->len, princ->data);\n            return true;\n        }\n    }\n    return false;\n}\n\n    ngx_int_t\nngx_http_auth_spnego_token(\n        ngx_http_request_t *r,\n        ngx_http_auth_spnego_ctx_t *ctx)\n{\n    ngx_str_t token;\n    ngx_str_t decoded;\n    size_t nego_sz = sizeof(\"Negotiate\");\n\n    if (NULL == r->headers_in.authorization) {\n        return NGX_DECLINED;\n    }\n\n    /* but don't decode second time? */\n    if (ctx->token.len)\n        return NGX_OK;\n\n    token = r->headers_in.authorization->value;\n\n    if (token.len < nego_sz ||\n            ngx_strncasecmp(token.data, (u_char *) \"Negotiate \", nego_sz) != 0) {\n        if (ngx_strncasecmp(\n                    token.data, (u_char *) \"NTLM\", sizeof(\"NTLM\")) == 0) {\n            spnego_log_error(\"Detected unsupported mechanism: NTLM\");\n        }\n        return NGX_DECLINED;\n    }\n\n    token.len -= nego_sz;\n    token.data += nego_sz;\n\n    while (token.len && token.data[0] == ' ') {\n        token.len--;\n        token.data++;\n    }\n\n    if (token.len == 0) {\n        return NGX_DECLINED;\n    }\n\n    decoded.len = ngx_base64_decoded_length(token.len);\n    decoded.data = ngx_pnalloc(r->pool, decoded.len);\n    if (NULL == decoded.data) {\n        return NGX_ERROR;\n    }\n\n    if (ngx_decode_base64(&decoded, &token) != NGX_OK) {\n        return NGX_DECLINED;\n    }\n\n    ctx->token.len = decoded.len;\n    ctx->token.data = decoded.data;\n    spnego_debug2(\"Token decoded: %*s\", token.len, token.data);\n\n    return NGX_OK;\n}\n\n    ngx_int_t\nngx_http_auth_spnego_basic(\n        ngx_http_request_t * r,\n        ngx_http_auth_spnego_ctx_t * ctx,\n        ngx_http_auth_spnego_loc_conf_t * alcf)\n{\n    ngx_str_t host_name;\n    ngx_str_t service;\n    ngx_str_t user;\n    user.data = NULL;\n    ngx_str_t new_user;\n    ngx_int_t ret = NGX_DECLINED;\n\n    krb5_context kcontext = NULL;\n    krb5_error_code code;\n    krb5_principal client = NULL;\n    krb5_principal server = NULL;\n    krb5_creds creds;\n    krb5_get_init_creds_opt *gic_options = NULL;\n    int kret = 0;\n    char *name = NULL;\n    char *p = NULL;\n\n    code = krb5_init_context(&kcontext);\n    if (code) {\n        spnego_debug0(\"Kerberos error: Cannot initialize kerberos context\");\n        return NGX_ERROR;\n    }\n\n    host_name = r->headers_in.host->value;\n    service.len = alcf->srvcname.len + alcf->realm.len + 3;\n\n    if (ngx_strchr(alcf->srvcname.data, '/')) {\n        service.data = ngx_palloc(r->pool, service.len);\n        if (NULL == service.data) {\n            spnego_error(NGX_ERROR);\n        }\n\n        ngx_snprintf(service.data, service.len, \"%V@%V%Z\",\n                &alcf->srvcname, &alcf->realm);\n    } else {\n        service.len += host_name.len;\n        service.data = ngx_palloc(r->pool, service.len);\n        if (NULL == service.data) {\n            spnego_error(NGX_ERROR);\n        }\n\n        ngx_snprintf(service.data, service.len, \"%V/%V@%V%Z\",\n                &alcf->srvcname, &host_name, &alcf->realm);\n    }\n\n    kret = krb5_parse_name(kcontext, (const char *) service.data, &server);\n\n    if (kret) {\n        spnego_log_error(\"Kerberos error:  Unable to parse service name\");\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_ERROR);\n    }\n\n    code = krb5_unparse_name(kcontext, server, &name);\n    if (code) {\n        spnego_log_error(\"Kerberos error: Cannot unparse servicename\");\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_ERROR);\n    }\n\n    free(name);\n    name = NULL;\n\n    p = ngx_strchr(r->headers_in.user.data, '@');\n    user.len = r->headers_in.user.len + 1;\n    if (NULL == p) {\n        if (alcf->force_realm && alcf->realm.len && alcf->realm.data ) {\n            user.len += alcf->realm.len + 1; /* +1 for @ */\n            user.data = ngx_palloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\"Not enough memory\");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(user.data, user.len, \"%V@%V%Z\", &r->headers_in.user,\n                    &alcf->realm);\n        } else {\n            user.data = ngx_palloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\"Not enough memory\");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(user.data, user.len, \"%V%Z\", &r->headers_in.user);\n        }\n    } else {\n        if (alcf->realm.len && alcf->realm.data && ngx_strncmp(p + 1,\n                    alcf->realm.data, alcf->realm.len) == 0) {\n            user.data = ngx_palloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\"Not enough memory\");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(user.data, user.len, \"%V%Z\",\n                    &r->headers_in.user);\n            if (alcf->fqun == 0) {\n                /*\n                 * Specified realm is identical to configured realm.\n                 * Truncate $remote_user to strip @REALM.\n                 */\n                r->headers_in.user.len -= alcf->realm.len + 1;\n            }\n        } else if (alcf->force_realm) {\n            *p = '\\0';\n            user.len = ngx_strlen(r->headers_in.user.data) + 1;\n            if (alcf->realm.len && alcf->realm.data)\n                user.len += alcf->realm.len + 1;\n            user.data = ngx_pcalloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\"Not enough memory\");\n                spnego_error(NGX_ERROR);\n            }\n            if (alcf->realm.len && alcf->realm.data)\n                ngx_snprintf(user.data, user.len, \"%s@%V%Z\",\n                        r->headers_in.user.data, &alcf->realm);\n            else\n                ngx_snprintf(user.data, user.len, \"%s%Z\",\n                        r->headers_in.user.data);\n            /*\n             * Rewrite $remote_user with the forced realm.\n             * If the forced realm is shorter than the\n             * specified realm, we can reuse the original\n             * buffer.\n             */\n            if (r->headers_in.user.len >= user.len - 1)\n                r->headers_in.user.len = user.len - 1;\n            else {\n                new_user.len = user.len - 1;\n                new_user.data = ngx_palloc(r->pool, new_user.len);\n                if (NULL == new_user.data) {\n                    spnego_log_error(\"Not enough memory\");\n                    spnego_error(NGX_ERROR);\n                }\n                ngx_pfree(r->pool, r->headers_in.user.data);\n                r->headers_in.user.data = new_user.data;\n                r->headers_in.user.len = new_user.len;\n            }\n            ngx_memcpy(r->headers_in.user.data, user.data,\n                    r->headers_in.user.len);\n        } else {\n            user.data = ngx_palloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\"Not enough memory\");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(user.data, user.len, \"%V%Z\", &r->headers_in.user);\n        }\n    }\n\n    spnego_debug1(\"Attempting authentication with principal %s\",\n            (const char *)user.data);\n\n    code = krb5_parse_name(kcontext, (const char *) user.data, &client);\n    if (code) {\n        spnego_log_error(\"Kerberos error: Unable to parse username\");\n        spnego_debug1(\"username is %s.\", (const char *) user.data);\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_ERROR);\n    }\n\n    memset(&creds, 0, sizeof(creds));\n\n    code = krb5_unparse_name(kcontext, client, &name);\n    if (code) {\n        spnego_log_error(\"Kerberos error: Cannot unparse username\");\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_ERROR);\n    }\n\n    krb5_get_init_creds_opt_alloc(kcontext, &gic_options);\n\n    code = krb5_get_init_creds_password(kcontext, &creds, client,\n                (char *) r->headers_in.passwd.data,\n                NULL, NULL, 0, NULL, gic_options);\n\n    krb5_free_cred_contents(kcontext, &creds);\n\n    if (code) {\n        spnego_log_error(\"Kerberos error: Credentials failed\");\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_DECLINED);\n    }\n\n    /* Try to add the system realm to $remote_user if needed. */\n    if (alcf->fqun && !ngx_strchr(r->headers_in.user.data, '@')) {\n#ifdef krb5_princ_realm\n        /*\n         * MIT does not have krb5_principal_get_realm() but its\n         * krb5_princ_realm() is a macro that effectively points\n         * to a char *.\n         */\n        const char *realm = krb5_princ_realm(kcontext, client)->data;\n#else\n        const char *realm = krb5_principal_get_realm(kcontext, client);\n#endif\n        if (realm) {\n            new_user.len = r->headers_in.user.len + 1 + ngx_strlen(realm);\n            new_user.data = ngx_palloc(r->pool, new_user.len);\n            if (NULL == new_user.data) {\n                spnego_log_error(\"Not enough memory\");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(new_user.data, new_user.len, \"%V@%s\",\n                    &r->headers_in.user, realm);\n            ngx_pfree(r->pool, r->headers_in.user.data);\n            r->headers_in.user.data = new_user.data;\n            r->headers_in.user.len = new_user.len;\n        }\n    }\n\n    spnego_debug1(\"Setting $remote_user to %V\", &r->headers_in.user);\n    if (ngx_http_auth_spnego_set_bogus_authorization(r) != NGX_OK)\n        spnego_log_error(\"Failed to set $remote_user\");\n\n    spnego_debug0(\"ngx_http_auth_spnego_basic: returning NGX_OK\");\n\n    ret = NGX_OK;\n\nend:\n    if (name)\n        free(name);\n    if (client)\n        krb5_free_principal(kcontext, client);\n    if (server)\n        krb5_free_principal(kcontext, server);\n    if (service.data)\n        ngx_pfree(r->pool, service.data);\n    if (user.data)\n        ngx_pfree(r->pool, user.data);\n\n    krb5_get_init_creds_opt_free(kcontext, gic_options);\n\n    krb5_free_context(kcontext);\n\n    return ret;\n}\n\n\n/*\n * Because 'remote_user' is assumed to be provided by basic authorization\n * (see ngx_http_variable_remote_user) we are forced to create bogus\n * non-Negotiate authorization header. This may possibly clobber Negotiate\n * token too soon.\n */\n    ngx_int_t\nngx_http_auth_spnego_set_bogus_authorization(\n        ngx_http_request_t *r)\n{\n    const char *bogus_passwd = \"bogus_auth_gss_passwd\";\n    ngx_str_t plain, encoded, final;\n\n    if (r->headers_in.user.len == 0) {\n        spnego_debug0(\"ngx_http_auth_spnego_set_bogus_authorization: no user NGX_DECLINED\");\n        return NGX_DECLINED;\n    }\n\n    /* +1 because of the \":\" in \"user:password\" */\n    plain.len = r->headers_in.user.len + ngx_strlen(bogus_passwd) + 1;\n    plain.data = ngx_pnalloc(r->pool, plain.len);\n    if (NULL == plain.data) {\n        return NGX_ERROR;\n    }\n\n    ngx_snprintf(plain.data, plain.len, \"%V:%s\",\n            &r->headers_in.user, bogus_passwd);\n\n    encoded.len = ngx_base64_encoded_length(plain.len);\n    encoded.data = ngx_pnalloc(r->pool, encoded.len);\n    if (NULL == encoded.data) {\n        return NGX_ERROR;\n    }\n\n    ngx_encode_base64(&encoded, &plain);\n\n    final.len = sizeof(\"Basic \") + encoded.len - 1;\n    final.data = ngx_pnalloc(r->pool, final.len);\n    if (NULL == final.data) {\n        return NGX_ERROR;\n    }\n\n    ngx_snprintf(final.data, final.len, \"Basic %V\", &encoded);\n\n    /* WARNING clobbering authorization header value */\n    r->headers_in.authorization->value.len = final.len;\n    r->headers_in.authorization->value.data = final.data;\n\n    spnego_debug0(\"ngx_http_auth_spnego_set_bogus_authorization: bogus user set\");\n    return NGX_OK;\n}\n\n    static bool\nuse_keytab(\n        ngx_http_request_t * r,\n        ngx_str_t *keytab)\n{\n    size_t kt_sz = keytab->len + 1;\n    char *kt = (char *) ngx_pcalloc(r->pool, kt_sz);\n    if (NULL == kt) {\n        return false;\n    }\n    ngx_snprintf((u_char *) kt, kt_sz, \"%V%Z\", keytab);\n    OM_uint32 major_status, minor_status = 0;\n    major_status = gsskrb5_register_acceptor_identity(kt);\n    if (GSS_ERROR(major_status)) {\n        spnego_log_error(\"%s failed to register keytab\", get_gss_error(\n                    r->pool, minor_status,\n                    \"gsskrb5_register_acceptor_identity() failed\"));\n        return false;\n    }\n\n    spnego_debug1(\"Use keytab %V\", keytab);\n    return true;\n}\n\n    ngx_int_t\nngx_http_auth_spnego_auth_user_gss(\n        ngx_http_request_t * r,\n        ngx_http_auth_spnego_ctx_t * ctx,\n        ngx_http_auth_spnego_loc_conf_t * alcf)\n{\n    ngx_int_t ret = NGX_DECLINED;\n    u_char *pu;\n    ngx_str_t spnego_token = ngx_null_string;\n    OM_uint32 major_status, minor_status, minor_status2;\n    gss_buffer_desc service = GSS_C_EMPTY_BUFFER;\n    gss_name_t my_gss_name = GSS_C_NO_NAME;\n    gss_cred_id_t my_gss_creds = GSS_C_NO_CREDENTIAL;\n    gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;\n    gss_ctx_id_t gss_context = GSS_C_NO_CONTEXT;\n    gss_name_t client_name = GSS_C_NO_NAME;\n    gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;\n\n    if (NULL == ctx || ctx->token.len == 0)\n        return ret;\n\n    spnego_debug0(\"GSSAPI authorizing\");\n\n    if (!use_keytab(r, &alcf->keytab)) {\n        spnego_debug0(\"Failed to specify keytab\");\n        spnego_error(NGX_ERROR);\n    }\n\n    if (alcf->srvcname.len > 0) {\n        /* if there is a specific service prinicipal set in the configuration\n         * file, we need to use it.  Otherwise, use the default of no credentials\n         */\n        service.length = alcf->srvcname.len + alcf->realm.len + 2;\n        service.value = ngx_palloc(r->pool, service.length);\n        if (NULL == service.value) {\n            spnego_error(NGX_ERROR);\n        }\n        ngx_snprintf(service.value, service.length, \"%V@%V%Z\",\n                &alcf->srvcname, &alcf->realm);\n\n        spnego_debug1(\"Using service principal: %s\", service.value);\n        major_status = gss_import_name(&minor_status, &service,\n                (gss_OID) GSS_KRB5_NT_PRINCIPAL_NAME, &my_gss_name);\n        if (GSS_ERROR(major_status)) {\n            spnego_log_error(\"%s Used service principal: %s\", get_gss_error(\n                        r->pool, minor_status, \"gss_import_name() failed\"),\n                    (u_char *) service.value);\n            spnego_error(NGX_ERROR);\n        }\n        gss_buffer_desc human_readable_gss_name = GSS_C_EMPTY_BUFFER;\n        major_status = gss_display_name(&minor_status, my_gss_name,\n                &human_readable_gss_name, NULL);\n\n        if (GSS_ERROR(major_status)) {\n            spnego_log_error(\"%s Used service principal: %s \", get_gss_error(\n                        r->pool, minor_status, \"gss_display_name() failed\"),\n                    (u_char *) service.value);\n        }\n        spnego_debug1(\"my_gss_name %s\", human_readable_gss_name.value);\n\n        /* Obtain credentials */\n        major_status = gss_acquire_cred(&minor_status, my_gss_name,\n                GSS_C_INDEFINITE, GSS_C_NO_OID_SET, GSS_C_ACCEPT, &my_gss_creds,\n                NULL, NULL);\n        if (GSS_ERROR(major_status)) {\n            spnego_log_error(\"%s Used service principal: %s\", get_gss_error(\n                        r->pool, minor_status, \"gss_acquire_cred() failed\"),\n                    (u_char *) service.value);\n            spnego_error(NGX_ERROR);\n        }\n\n    }\n\n    input_token.length = ctx->token.len;\n    input_token.value = (void *) ctx->token.data;\n\n    major_status = gss_accept_sec_context(&minor_status, &gss_context,\n            my_gss_creds, &input_token, GSS_C_NO_CHANNEL_BINDINGS, &client_name,\n            NULL, &output_token, NULL, NULL, NULL);\n    if (GSS_ERROR(major_status)) {\n        spnego_debug1(\"%s\", get_gss_error(\n                    r->pool, minor_status, \"gss_accept_sec_context() failed\"));\n        spnego_error(NGX_DECLINED);\n    }\n\n    if (major_status & GSS_S_CONTINUE_NEEDED) {\n        spnego_debug0(\"only one authentication iteration allowed\");\n        spnego_error(NGX_DECLINED);\n    }\n\n    if (output_token.length) {\n        spnego_token.data = (u_char *) output_token.value;\n        spnego_token.len = output_token.length;\n\n        ctx->token_out_b64.len = ngx_base64_encoded_length(spnego_token.len);\n        ctx->token_out_b64.data = ngx_pcalloc(r->pool, ctx->token_out_b64.len + 1);\n        if (NULL == ctx->token_out_b64.data) {\n            spnego_log_error(\"Not enough memory\");\n            gss_release_buffer(&minor_status2, &output_token);\n            spnego_error(NGX_ERROR);\n        }\n        ngx_encode_base64(&ctx->token_out_b64, &spnego_token);\n        gss_release_buffer(&minor_status2, &output_token);\n    }\n\telse {\n        ctx->token_out_b64.len = 0;\n\t}\n\n    /* getting user name at the other end of the request */\n    major_status = gss_display_name(&minor_status, client_name, &output_token, NULL);\n    if (GSS_ERROR(major_status)) {\n        spnego_log_error(\"%s\", get_gss_error(r->pool, minor_status,\n                    \"gss_display_name() failed\"));\n        spnego_error(NGX_ERROR);\n    }\n\n    if (output_token.length) {\n        /* Apply local rules to map Kerberos Principals to short names */\n        if (alcf->map_to_local) {\n            gss_OID mech_type = discard_const(gss_mech_krb5);\n            output_token = (gss_buffer_desc) GSS_C_EMPTY_BUFFER;\n            major_status = gss_localname(&minor_status, client_name,\n                    mech_type, &output_token);\n            if (GSS_ERROR(major_status)) {\n                spnego_log_error(\"%s\", get_gss_error(r->pool, minor_status,\n                            \"gss_localname() failed\"));\n                spnego_error(NGX_ERROR);\n            }\n        }\n\n        /* TOFIX dirty quick trick for now (no \"-1\" i.e. include '\\0' */\n        ngx_str_t user = {\n            output_token.length,\n            (u_char *) output_token.value\n        };\n\n        r->headers_in.user.data = ngx_pstrdup(r->pool, &user);\n        if (NULL == r->headers_in.user.data) {\n            spnego_log_error(\"ngx_pstrdup failed to allocate\");\n            spnego_error(NGX_ERROR);\n        }\n\n        r->headers_in.user.len = user.len;\n        if (alcf->fqun == 0) {\n            pu = ngx_strlchr(r->headers_in.user.data,\n                    r->headers_in.user.data + r->headers_in.user.len, '@');\n            if (pu != NULL && ngx_strncmp(pu + 1, alcf->realm.data, alcf->realm.len) == 0) {\n                *pu = '\\0';\n                r->headers_in.user.len = ngx_strlen(r->headers_in.user.data);\n            }\n        }\n\n        /* this for the sake of ngx_http_variable_remote_user */\n        if (ngx_http_auth_spnego_set_bogus_authorization(r) != NGX_OK) {\n            spnego_log_error(\"Failed to set remote_user\");\n        }\n        spnego_debug1(\"user is %V\", &r->headers_in.user);\n    }\n\n    gss_release_buffer(&minor_status, &output_token);\n\n    ret = NGX_OK;\n    goto end;\n\nend:\n    if (output_token.length)\n        gss_release_buffer(&minor_status, &output_token);\n\n    if (client_name != GSS_C_NO_NAME)\n        gss_release_name(&minor_status, &client_name);\n\n    if (gss_context != GSS_C_NO_CONTEXT)\n        gss_delete_sec_context(&minor_status, &gss_context,\n                GSS_C_NO_BUFFER);\n\n    if (my_gss_name != GSS_C_NO_NAME)\n        gss_release_name(&minor_status, &my_gss_name);\n\n    if (my_gss_creds != GSS_C_NO_CREDENTIAL)\n        gss_release_cred(&minor_status, &my_gss_creds);\n\n    return ret;\n}\n\n    static ngx_int_t\nngx_http_auth_spnego_handler(\n        ngx_http_request_t * r)\n{\n    ngx_int_t ret = NGX_DECLINED;\n    ngx_http_auth_spnego_ctx_t *ctx;\n    ngx_http_auth_spnego_loc_conf_t *alcf;\n\n    alcf = ngx_http_get_module_loc_conf(r, ngx_http_auth_spnego_module);\n\n    if (alcf->protect == 0) {\n        return NGX_DECLINED;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_auth_spnego_module);\n    if (NULL == ctx) {\n        ctx = ngx_palloc(r->pool, sizeof(ngx_http_auth_spnego_ctx_t));\n        if (NULL == ctx) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n        ctx->token.len = 0;\n        ctx->token.data = NULL;\n        ctx->head = 0;\n        ctx->ret = NGX_HTTP_UNAUTHORIZED;\n        ngx_http_set_ctx(r, ctx, ngx_http_auth_spnego_module);\n    }\n\n    spnego_debug3(\"SSO auth handling IN: token.len=%d, head=%d, ret=%d\",\n            ctx->token.len, ctx->head, ctx->ret);\n\n    if (ctx->token.len && ctx->head) {\n        spnego_debug1(\"Found token and head, returning %d\", ctx->ret);\n        return ctx->ret;\n    }\n\n    if (NULL != r->headers_in.user.data) {\n        spnego_debug0(\"User header set\");\n        return NGX_OK;\n    }\n\n    spnego_debug0(\"Begin auth\");\n\n    if (alcf->allow_basic) {\n        spnego_debug0(\"Detect basic auth\");\n        ret = ngx_http_auth_basic_user(r);\n        if (NGX_OK == ret) {\n            spnego_debug0(\"Basic auth credentials supplied by client\");\n            /* If basic auth is enabled and basic creds are supplied\n             * attempt basic auth.  If we attempt basic auth, we do\n             * not fall through to real SPNEGO */\n            if (NGX_DECLINED == ngx_http_auth_spnego_basic(r, ctx, alcf)) {\n                spnego_debug0(\"Basic auth failed\");\n                if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                    spnego_debug0(\"Error setting headers\");\n                    return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n                }\n                return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n            }\n\n            if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n                spnego_debug0(\"User not authorized\");\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n\n            spnego_debug0(\"Basic auth succeeded\");\n            return (ctx->ret = NGX_OK);\n        }\n    }\n\n    /* Basic auth either disabled or not supplied by client */\n    spnego_debug0(\"Detect SPNEGO token\");\n    ret = ngx_http_auth_spnego_token(r, ctx);\n    if (NGX_OK == ret) {\n        spnego_debug0(\"Client sent a reasonable Negotiate header\");\n        ret = ngx_http_auth_spnego_auth_user_gss(r, ctx, alcf);\n        if (NGX_ERROR == ret) {\n            spnego_debug0(\"GSSAPI failed\");\n            return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n        }\n        /* There are chances that client knows about Negotiate\n         * but doesn't support GSSAPI. We could attempt to fall\n         * back to basic here... */\n        if (NGX_DECLINED == ret) {\n            spnego_debug0(\"GSSAPI failed\");\n            if(!alcf->allow_basic) {\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n            if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                spnego_debug0(\"Error setting headers\");\n                return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n            }\n            return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n        }\n\n        if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n            spnego_debug0(\"User not authorized\");\n            return (ctx->ret = NGX_HTTP_FORBIDDEN);\n        }\n\n        spnego_debug0(\"GSSAPI auth succeeded\");\n    }\n\n    ngx_str_t *token_out_b64 = NULL;\n    switch(ret) {\n        case NGX_DECLINED: /* DECLINED, but not yet FORBIDDEN */\n            ctx->ret = NGX_HTTP_UNAUTHORIZED;\n            break;\n        case NGX_OK:\n            ctx->ret = NGX_OK;\n            token_out_b64 = &ctx->token_out_b64;\n            break;\n        case NGX_ERROR:\n        default:\n            ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n            break;\n    }\n\n    if (NGX_ERROR == ngx_http_auth_spnego_headers(r, ctx, token_out_b64, alcf)) {\n        spnego_debug0(\"Error setting headers\");\n        ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    spnego_debug3(\"SSO auth handling OUT: token.len=%d, head=%d, ret=%d\",\n            ctx->token.len, ctx->head, ctx->ret);\n    return ctx->ret;\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2009 Michal Kowalski <superflouos{at}gmail[dot]com>\n * Copyright (C) 2012-2013 Sean Timothy Noonan <stnoonan@obsolescence.net>\n * Copyright (C) 2013 Marcello Barnaba <vjt@openssl.it>\n * Copyright (C) 2013 Alexander Pyhalov <alp@sfedu.ru>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n */\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_http.h>\n\n#include <stdbool.h>\n#include <gssapi/gssapi.h>\n#include <gssapi/gssapi_krb5.h>\n#include <krb5.h>\n\n#define discard_const(ptr) ((void *)((uintptr_t)(ptr)))\n\n#define spnego_log_krb5_error(context,code) {\\\n    const char* ___kerror = krb5_get_error_message(context, code);\\\n    spnego_debug2(\"Kerberos error: %d, %s\", code , ___kerror);\\\n    krb5_free_error_message( context, ___kerror  ); }\n#define spnego_error(code) ret = code; goto end\n#define spnego_debug0(msg) ngx_log_debug0(\\\n        NGX_LOG_DEBUG_HTTP, r->connection->log, 0, msg)\n#define spnego_debug1(msg, one) ngx_log_debug1(\\\n        NGX_LOG_DEBUG_HTTP, r->connection->log, 0, msg, one)\n#define spnego_debug2(msg, one, two) ngx_log_debug2(\\\n        NGX_LOG_DEBUG_HTTP, r->connection->log, 0, msg, one, two)\n#define spnego_debug3(msg, one, two, three) ngx_log_debug3(\\\n        NGX_LOG_DEBUG_HTTP, r->connection->log, 0, msg, one, two, three)\n#define spnego_log_error(fmt, args...) ngx_log_error(\\\n        NGX_LOG_ERR, r->connection->log, 0, fmt, ##args)\n\n/* Module handler */\nstatic ngx_int_t ngx_http_auth_spnego_handler(ngx_http_request_t *);\n\nstatic void *ngx_http_auth_spnego_create_loc_conf(ngx_conf_t *);\nstatic char *ngx_http_auth_spnego_merge_loc_conf(\n        ngx_conf_t *, void *, void *);\nstatic ngx_int_t ngx_http_auth_spnego_init(ngx_conf_t *);\n\nngx_int_t\nngx_http_auth_spnego_set_bogus_authorization(ngx_http_request_t * r);\n\n    const char *\nget_gss_error(\n        ngx_pool_t * p,\n        OM_uint32 error_status,\n        char *prefix)\n{\n    OM_uint32 maj_stat, min_stat;\n    OM_uint32 msg_ctx = 0;\n    gss_buffer_desc status_string;\n    char buf[1024];\n    size_t len;\n    ngx_str_t str;\n    ngx_snprintf((u_char *) buf, sizeof(buf), \"%s: %Z\", prefix);\n    len = ngx_strlen(buf);\n    do {\n        maj_stat =\n            gss_display_status(&min_stat, error_status, GSS_C_MECH_CODE,\n                    GSS_C_NO_OID, &msg_ctx, &status_string);\n        if (sizeof(buf) > len + status_string.length + 1) {\n            ngx_sprintf((u_char *) buf + len, \"%s:%Z\",\n                    (char *) status_string.value);\n            len += (status_string.length + 1);\n        }\n        gss_release_buffer(&min_stat, &status_string);\n    }\n    while (!GSS_ERROR(maj_stat) && msg_ctx != 0);\n\n    str.len = len + 1; /* \"include\" '\\0' */\n    str.data = (u_char *) buf;\n    return (char *) (ngx_pstrdup(p, &str));\n}\n\n/* per request/connection */\ntypedef struct {\n    ngx_str_t token; /* decoded Negotiate token */\n    ngx_int_t head; /* non-zero flag if headers set */\n    ngx_int_t ret; /* current return code */\n    ngx_str_t token_out_b64; /* base64 encoded output tokent */\n} ngx_http_auth_spnego_ctx_t;\n\ntypedef struct {\n    ngx_flag_t protect;\n    ngx_str_t realm;\n    ngx_str_t keytab;\n    ngx_str_t srvcname;\n    ngx_flag_t fqun;\n    ngx_flag_t force_realm;\n    ngx_flag_t allow_basic;\n    ngx_array_t *auth_princs;\n    ngx_flag_t map_to_local;\n} ngx_http_auth_spnego_loc_conf_t;\n\n#define SPNEGO_NGX_CONF_FLAGS NGX_HTTP_MAIN_CONF\\\n    | NGX_HTTP_SRV_CONF\\\n| NGX_HTTP_LOC_CONF\\\n| NGX_HTTP_LMT_CONF\\\n| NGX_CONF_FLAG\n\n/* Module Directives */\nstatic ngx_command_t ngx_http_auth_spnego_commands[] = {\n    {ngx_string(\"auth_gss\"),\n        SPNEGO_NGX_CONF_FLAGS,\n        ngx_conf_set_flag_slot,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_http_auth_spnego_loc_conf_t, protect),\n        NULL},\n\n    {ngx_string(\"auth_gss_realm\"),\n        SPNEGO_NGX_CONF_FLAGS,\n        ngx_conf_set_str_slot,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_http_auth_spnego_loc_conf_t, realm),\n        NULL},\n\n    {ngx_string(\"auth_gss_keytab\"),\n        SPNEGO_NGX_CONF_FLAGS,\n        ngx_conf_set_str_slot,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_http_auth_spnego_loc_conf_t, keytab),\n        NULL},\n\n    {ngx_string(\"auth_gss_service_name\"),\n        SPNEGO_NGX_CONF_FLAGS,\n        ngx_conf_set_str_slot,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_http_auth_spnego_loc_conf_t, srvcname),\n        NULL},\n\n    {ngx_string(\"auth_gss_format_full\"),\n        SPNEGO_NGX_CONF_FLAGS,\n        ngx_conf_set_flag_slot,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_http_auth_spnego_loc_conf_t, fqun),\n        NULL},\n\n    {ngx_string(\"auth_gss_force_realm\"),\n        SPNEGO_NGX_CONF_FLAGS,\n        ngx_conf_set_flag_slot,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_http_auth_spnego_loc_conf_t, force_realm),\n        NULL},\n\n    {ngx_string(\"auth_gss_allow_basic_fallback\"),\n        SPNEGO_NGX_CONF_FLAGS,\n        ngx_conf_set_flag_slot,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_http_auth_spnego_loc_conf_t, allow_basic),\n        NULL},\n\n    {ngx_string(\"auth_gss_authorized_principal\"),\n        SPNEGO_NGX_CONF_FLAGS | NGX_CONF_1MORE,\n        ngx_conf_set_str_array_slot,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_http_auth_spnego_loc_conf_t, auth_princs),\n        NULL},\n\n    {ngx_string(\"auth_gss_map_to_local\"),\n        SPNEGO_NGX_CONF_FLAGS,\n        ngx_conf_set_flag_slot,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_http_auth_spnego_loc_conf_t, map_to_local),\n        NULL},\n\n    ngx_null_command\n};\n\n/* Module Context */\nstatic ngx_http_module_t ngx_http_auth_spnego_module_ctx = {\n    NULL, /* preconf */\n    ngx_http_auth_spnego_init, /* postconf */\n    NULL, /* create main conf (defaults) */\n    NULL, /* init main conf (what's in nginx.conf) */\n    NULL, /* create server conf */\n    NULL, /* merge with main */\n\n    ngx_http_auth_spnego_create_loc_conf, /* create location conf */\n    ngx_http_auth_spnego_merge_loc_conf, /* merge with server */\n};\n\n/* Module Definition */\nngx_module_t ngx_http_auth_spnego_module = {\n    /* ngx_uint_t ctx_index, index, spare{0-3}, version; */\n    NGX_MODULE_V1, /* 0, 0, 0, 0, 0, 0, 1 */\n    &ngx_http_auth_spnego_module_ctx, /* void *ctx */\n    ngx_http_auth_spnego_commands, /* ngx_command_t *commands */\n    NGX_HTTP_MODULE, /* ngx_uint_t type = 0x50545448 */\n    NULL, /* ngx_int_t (*init_master)(ngx_log_t *log) */\n    NULL, /* ngx_int_t (*init_module)(ngx_cycle_t *cycle) */\n    NULL, /* ngx_int_t (*init_process)(ngx_cycle_t *cycle) */\n    NULL, /* ngx_int_t (*init_thread)(ngx_cycle_t *cycle) */\n    NULL, /* void (*exit_thread)(ngx_cycle_t *cycle) */\n    NULL, /* void (*exit_process)(ngx_cycle_t *cycle) */\n    NULL, /* void (*exit_master)(ngx_cycle_t *cycle) */\n    NGX_MODULE_V1_PADDING, /* 0, 0, 0, 0, 0, 0, 0, 0 */\n    /* uintptr_t spare_hook{0-7}; */\n};\n\n    static void *\nngx_http_auth_spnego_create_loc_conf(\n        ngx_conf_t * cf)\n{\n    ngx_http_auth_spnego_loc_conf_t *conf;\n\n    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_auth_spnego_loc_conf_t));\n    if (NULL == conf) {\n        return NGX_CONF_ERROR;\n    }\n\n    conf->protect = NGX_CONF_UNSET;\n    conf->fqun = NGX_CONF_UNSET;\n    conf->force_realm = NGX_CONF_UNSET;\n    conf->allow_basic = NGX_CONF_UNSET;\n    conf->auth_princs = NGX_CONF_UNSET_PTR;\n    conf->map_to_local = NGX_CONF_UNSET;\n\n    return conf;\n}\n\n    static char *\nngx_http_auth_spnego_merge_loc_conf(\n        ngx_conf_t * cf,\n        void *parent,\n        void *child)\n{\n    ngx_http_auth_spnego_loc_conf_t *prev = parent;\n    ngx_http_auth_spnego_loc_conf_t *conf = child;\n\n    /* \"off\" by default */\n    ngx_conf_merge_off_value(conf->protect, prev->protect, 0);\n\n    ngx_conf_merge_str_value(conf->realm, prev->realm, \"\");\n    ngx_conf_merge_str_value(conf->keytab, prev->keytab,\n            \"/etc/krb5.keytab\");\n    ngx_conf_merge_str_value(conf->srvcname, prev->srvcname, \"\");\n\n    ngx_conf_merge_off_value(conf->fqun, prev->fqun, 0);\n    ngx_conf_merge_off_value(conf->force_realm, prev->force_realm, 0);\n    ngx_conf_merge_off_value(conf->allow_basic, prev->allow_basic, 1);\n    ngx_conf_merge_ptr_value(conf->auth_princs, prev->auth_princs, NGX_CONF_UNSET_PTR);\n\n    ngx_conf_merge_off_value(conf->map_to_local, prev->map_to_local, 0);\n\n#if (NGX_DEBUG)\n    ngx_conf_log_error(NGX_LOG_INFO, cf, 0, \"auth_spnego: protect = %i\",\n            conf->protect);\n    ngx_conf_log_error(NGX_LOG_INFO, cf, 0, \"auth_spnego: realm@0x%p = %s\",\n            conf->realm.data, conf->realm.data);\n    ngx_conf_log_error(NGX_LOG_INFO, cf, 0,\n            \"auth_spnego: keytab@0x%p = %s\", conf->keytab.data,\n            conf->keytab.data);\n    ngx_conf_log_error(NGX_LOG_INFO, cf, 0,\n            \"auth_spnego: srvcname@0x%p = %s\",\n            conf->srvcname.data, conf->srvcname.data);\n    ngx_conf_log_error(NGX_LOG_INFO, cf, 0, \"auth_spnego: fqun = %i\",\n            conf->fqun);\n    ngx_conf_log_error(NGX_LOG_INFO, cf, 0, \"auth_spnego: allow_basic = %i\",\n            conf->allow_basic);\n    ngx_conf_log_error(NGX_LOG_INFO, cf, 0, \"auth_spnego: force_realm = %i\",\n            conf->force_realm);\n    if (NGX_CONF_UNSET_PTR != conf->auth_princs) {\n        size_t ii = 0;\n        ngx_str_t *auth_princs = conf->auth_princs->elts;\n        for (; ii < conf->auth_princs->nelts; ++ii) {\n            ngx_conf_log_error(NGX_LOG_DEBUG, cf, 0,\n                    \"auth_spnego: auth_princs = %.*s\", auth_princs[ii].len, auth_princs[ii].data);\n        }\n    }\n    ngx_conf_log_error(NGX_LOG_INFO, cf, 0, \"auth_spnego: map_to_local = %i\",\n            conf->map_to_local);\n#endif\n\n    return NGX_CONF_OK;\n}\n\n    static ngx_int_t\nngx_http_auth_spnego_init(\n        ngx_conf_t * cf)\n{\n    ngx_http_handler_pt *h;\n    ngx_http_core_main_conf_t *cmcf;\n\n    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);\n\n    h = ngx_array_push(&cmcf->phases[NGX_HTTP_ACCESS_PHASE].handlers);\n    if (NULL == h) {\n        return NGX_ERROR;\n    }\n\n    *h = ngx_http_auth_spnego_handler;\n\n    return NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_auth_spnego_headers_basic_only(\n    ngx_http_request_t *r,\n    ngx_http_auth_spnego_ctx_t *ctx,\n    ngx_http_auth_spnego_loc_conf_t *alcf)\n{\n    ngx_str_t value = ngx_null_string;\n    value.len = sizeof(\"Basic realm=\\\"\\\"\") - 1 + alcf->realm.len;\n    value.data = ngx_pcalloc(r->pool, value.len);\n    if (NULL == value.data) {\n        return NGX_ERROR;\n    }\n    ngx_snprintf(value.data, value.len, \"Basic realm=\\\"%V\\\"\",\n            &alcf->realm);\n    r->headers_out.www_authenticate =\n        ngx_list_push(&r->headers_out.headers);\n    if (NULL == r->headers_out.www_authenticate) {\n        return NGX_ERROR;\n    }\n\n    r->headers_out.www_authenticate->hash = 1;\n    r->headers_out.www_authenticate->key.len = sizeof(\"WWW-Authenticate\") - 1;\n    r->headers_out.www_authenticate->key.data = (u_char *) \"WWW-Authenticate\";\n    r->headers_out.www_authenticate->value.len = value.len;\n    r->headers_out.www_authenticate->value.data = value.data;\n\n    ctx->head = 1;\n\n    return NGX_OK;\n}\n\nstatic ngx_int_t\nngx_http_auth_spnego_headers(\n        ngx_http_request_t *r,\n        ngx_http_auth_spnego_ctx_t *ctx,\n        ngx_str_t *token,\n        ngx_http_auth_spnego_loc_conf_t *alcf)\n{\n    ngx_str_t value = ngx_null_string;\n    /* only use token if authorized as there appears to be a bug in\n     * Google Chrome when parsing a 401 Negotiate with a token */\n    if (NULL == token || ctx->ret != NGX_OK) {\n        value.len = sizeof(\"Negotiate\") - 1;\n        value.data = (u_char *) \"Negotiate\";\n    } else {\n        value.len = sizeof(\"Negotiate\") + token->len; /* space accounts for \\0 */\n        value.data = ngx_pcalloc(r->pool, value.len);\n        if (NULL == value.data) {\n            return NGX_ERROR;\n        }\n        ngx_snprintf(value.data, value.len, \"Negotiate %V\", token);\n    }\n\n    r->headers_out.www_authenticate =\n        ngx_list_push(&r->headers_out.headers);\n    if (NULL == r->headers_out.www_authenticate) {\n        return NGX_ERROR;\n    }\n\n    r->headers_out.www_authenticate->hash = 1;\n    r->headers_out.www_authenticate->key.len = sizeof(\"WWW-Authenticate\") - 1;\n    r->headers_out.www_authenticate->key.data = (u_char *) \"WWW-Authenticate\";\n    r->headers_out.www_authenticate->value.len = value.len;\n    r->headers_out.www_authenticate->value.data = value.data;\n\n    if (alcf->allow_basic) {\n        ngx_str_t value2 = ngx_null_string;\n        value2.len = sizeof(\"Basic realm=\\\"\\\"\") - 1 + alcf->realm.len;\n        value2.data = ngx_pcalloc(r->pool, value2.len);\n        if (NULL == value2.data) {\n            return NGX_ERROR;\n        }\n        ngx_snprintf(value2.data, value2.len, \"Basic realm=\\\"%V\\\"\",\n                &alcf->realm);\n        r->headers_out.www_authenticate =\n            ngx_list_push(&r->headers_out.headers);\n        if (NULL == r->headers_out.www_authenticate) {\n            return NGX_ERROR;\n        }\n\n        r->headers_out.www_authenticate->hash = 2;\n        r->headers_out.www_authenticate->key.len = sizeof(\"WWW-Authenticate\") - 1;\n        r->headers_out.www_authenticate->key.data = (u_char *) \"WWW-Authenticate\";\n        r->headers_out.www_authenticate->value.len = value2.len;\n        r->headers_out.www_authenticate->value.data = value2.data;\n    }\n\n    ctx->head = 1;\n\n    return NGX_OK;\n}\n\n    static bool\nngx_spnego_authorized_principal(\n        ngx_http_request_t * r,\n        ngx_str_t *princ,\n        ngx_http_auth_spnego_loc_conf_t *alcf)\n{\n    if (NGX_CONF_UNSET_PTR == alcf->auth_princs) {\n        return true;\n    }\n    size_t ii = 0;\n    ngx_str_t *auth_princs = alcf->auth_princs->elts;\n    spnego_debug1(\"Testing against %d auth princs\", alcf->auth_princs->nelts);\n    for (; ii < alcf->auth_princs->nelts; ++ii) {\n        if (auth_princs[ii].len != princ->len) {\n            continue;\n        }\n        if (ngx_strncmp(auth_princs[ii].data, princ->data, princ->len) == 0) {\n            spnego_debug2(\"Authorized user %.*s\", princ->len, princ->data);\n            return true;\n        }\n    }\n    return false;\n}\n\n    ngx_int_t\nngx_http_auth_spnego_token(\n        ngx_http_request_t *r,\n        ngx_http_auth_spnego_ctx_t *ctx)\n{\n    ngx_str_t token;\n    ngx_str_t decoded;\n    size_t nego_sz = sizeof(\"Negotiate\");\n\n    if (NULL == r->headers_in.authorization) {\n        return NGX_DECLINED;\n    }\n\n    /* but don't decode second time? */\n    if (ctx->token.len)\n        return NGX_OK;\n\n    token = r->headers_in.authorization->value;\n\n    if (token.len < nego_sz ||\n            ngx_strncasecmp(token.data, (u_char *) \"Negotiate \", nego_sz) != 0) {\n        if (ngx_strncasecmp(\n                    token.data, (u_char *) \"NTLM\", sizeof(\"NTLM\")) == 0) {\n            spnego_log_error(\"Detected unsupported mechanism: NTLM\");\n        }\n        return NGX_DECLINED;\n    }\n\n    token.len -= nego_sz;\n    token.data += nego_sz;\n\n    while (token.len && token.data[0] == ' ') {\n        token.len--;\n        token.data++;\n    }\n\n    if (token.len == 0) {\n        return NGX_DECLINED;\n    }\n\n    decoded.len = ngx_base64_decoded_length(token.len);\n    decoded.data = ngx_pnalloc(r->pool, decoded.len);\n    if (NULL == decoded.data) {\n        return NGX_ERROR;\n    }\n\n    if (ngx_decode_base64(&decoded, &token) != NGX_OK) {\n        return NGX_DECLINED;\n    }\n\n    ctx->token.len = decoded.len;\n    ctx->token.data = decoded.data;\n    spnego_debug2(\"Token decoded: %*s\", token.len, token.data);\n\n    return NGX_OK;\n}\n\n    ngx_int_t\nngx_http_auth_spnego_basic(\n        ngx_http_request_t * r,\n        ngx_http_auth_spnego_ctx_t * ctx,\n        ngx_http_auth_spnego_loc_conf_t * alcf)\n{\n    ngx_str_t host_name;\n    ngx_str_t service;\n    ngx_str_t user;\n    user.data = NULL;\n    ngx_str_t new_user;\n    ngx_int_t ret = NGX_DECLINED;\n\n    krb5_context kcontext = NULL;\n    krb5_error_code code;\n    krb5_principal client = NULL;\n    krb5_principal server = NULL;\n    krb5_creds creds;\n    krb5_get_init_creds_opt *gic_options = NULL;\n    int kret = 0;\n    char *name = NULL;\n    char *p = NULL;\n\n    code = krb5_init_context(&kcontext);\n    if (code) {\n        spnego_debug0(\"Kerberos error: Cannot initialize kerberos context\");\n        return NGX_ERROR;\n    }\n\n    host_name = r->headers_in.host->value;\n    service.len = alcf->srvcname.len + alcf->realm.len + 3;\n\n    if (ngx_strchr(alcf->srvcname.data, '/')) {\n        service.data = ngx_palloc(r->pool, service.len);\n        if (NULL == service.data) {\n            spnego_error(NGX_ERROR);\n        }\n\n        ngx_snprintf(service.data, service.len, \"%V@%V%Z\",\n                &alcf->srvcname, &alcf->realm);\n    } else {\n        service.len += host_name.len;\n        service.data = ngx_palloc(r->pool, service.len);\n        if (NULL == service.data) {\n            spnego_error(NGX_ERROR);\n        }\n\n        ngx_snprintf(service.data, service.len, \"%V/%V@%V%Z\",\n                &alcf->srvcname, &host_name, &alcf->realm);\n    }\n\n    kret = krb5_parse_name(kcontext, (const char *) service.data, &server);\n\n    if (kret) {\n        spnego_log_error(\"Kerberos error:  Unable to parse service name\");\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_ERROR);\n    }\n\n    code = krb5_unparse_name(kcontext, server, &name);\n    if (code) {\n        spnego_log_error(\"Kerberos error: Cannot unparse servicename\");\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_ERROR);\n    }\n\n    free(name);\n    name = NULL;\n\n    p = ngx_strchr(r->headers_in.user.data, '@');\n    user.len = r->headers_in.user.len + 1;\n    if (NULL == p) {\n        if (alcf->force_realm && alcf->realm.len && alcf->realm.data ) {\n            user.len += alcf->realm.len + 1; /* +1 for @ */\n            user.data = ngx_palloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\"Not enough memory\");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(user.data, user.len, \"%V@%V%Z\", &r->headers_in.user,\n                    &alcf->realm);\n        } else {\n            user.data = ngx_palloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\"Not enough memory\");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(user.data, user.len, \"%V%Z\", &r->headers_in.user);\n        }\n    } else {\n        if (alcf->realm.len && alcf->realm.data && ngx_strncmp(p + 1,\n                    alcf->realm.data, alcf->realm.len) == 0) {\n            user.data = ngx_palloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\"Not enough memory\");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(user.data, user.len, \"%V%Z\",\n                    &r->headers_in.user);\n            if (alcf->fqun == 0) {\n                /*\n                 * Specified realm is identical to configured realm.\n                 * Truncate $remote_user to strip @REALM.\n                 */\n                r->headers_in.user.len -= alcf->realm.len + 1;\n            }\n        } else if (alcf->force_realm) {\n            *p = '\\0';\n            user.len = ngx_strlen(r->headers_in.user.data) + 1;\n            if (alcf->realm.len && alcf->realm.data)\n                user.len += alcf->realm.len + 1;\n            user.data = ngx_pcalloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\"Not enough memory\");\n                spnego_error(NGX_ERROR);\n            }\n            if (alcf->realm.len && alcf->realm.data)\n                ngx_snprintf(user.data, user.len, \"%s@%V%Z\",\n                        r->headers_in.user.data, &alcf->realm);\n            else\n                ngx_snprintf(user.data, user.len, \"%s%Z\",\n                        r->headers_in.user.data);\n            /*\n             * Rewrite $remote_user with the forced realm.\n             * If the forced realm is shorter than the\n             * specified realm, we can reuse the original\n             * buffer.\n             */\n            if (r->headers_in.user.len >= user.len - 1)\n                r->headers_in.user.len = user.len - 1;\n            else {\n                new_user.len = user.len - 1;\n                new_user.data = ngx_palloc(r->pool, new_user.len);\n                if (NULL == new_user.data) {\n                    spnego_log_error(\"Not enough memory\");\n                    spnego_error(NGX_ERROR);\n                }\n                ngx_pfree(r->pool, r->headers_in.user.data);\n                r->headers_in.user.data = new_user.data;\n                r->headers_in.user.len = new_user.len;\n            }\n            ngx_memcpy(r->headers_in.user.data, user.data,\n                    r->headers_in.user.len);\n        } else {\n            user.data = ngx_palloc(r->pool, user.len);\n            if (NULL == user.data) {\n                spnego_log_error(\"Not enough memory\");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(user.data, user.len, \"%V%Z\", &r->headers_in.user);\n        }\n    }\n\n    spnego_debug1(\"Attempting authentication with principal %s\",\n            (const char *)user.data);\n\n    code = krb5_parse_name(kcontext, (const char *) user.data, &client);\n    if (code) {\n        spnego_log_error(\"Kerberos error: Unable to parse username\");\n        spnego_debug1(\"username is %s.\", (const char *) user.data);\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_ERROR);\n    }\n\n    memset(&creds, 0, sizeof(creds));\n\n    code = krb5_unparse_name(kcontext, client, &name);\n    if (code) {\n        spnego_log_error(\"Kerberos error: Cannot unparse username\");\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_ERROR);\n    }\n\n    krb5_get_init_creds_opt_alloc(kcontext, &gic_options);\n\n    code = krb5_get_init_creds_password(kcontext, &creds, client,\n                (char *) r->headers_in.passwd.data,\n                NULL, NULL, 0, NULL, gic_options);\n\n    krb5_free_cred_contents(kcontext, &creds);\n\n    if (code) {\n        spnego_log_error(\"Kerberos error: Credentials failed\");\n        spnego_log_krb5_error(kcontext, code);\n        spnego_error(NGX_DECLINED);\n    }\n\n    /* Try to add the system realm to $remote_user if needed. */\n    if (alcf->fqun && !ngx_strchr(r->headers_in.user.data, '@')) {\n#ifdef krb5_princ_realm\n        /*\n         * MIT does not have krb5_principal_get_realm() but its\n         * krb5_princ_realm() is a macro that effectively points\n         * to a char *.\n         */\n        const char *realm = krb5_princ_realm(kcontext, client)->data;\n#else\n        const char *realm = krb5_principal_get_realm(kcontext, client);\n#endif\n        if (realm) {\n            new_user.len = r->headers_in.user.len + 1 + ngx_strlen(realm);\n            new_user.data = ngx_palloc(r->pool, new_user.len);\n            if (NULL == new_user.data) {\n                spnego_log_error(\"Not enough memory\");\n                spnego_error(NGX_ERROR);\n            }\n            ngx_snprintf(new_user.data, new_user.len, \"%V@%s\",\n                    &r->headers_in.user, realm);\n            ngx_pfree(r->pool, r->headers_in.user.data);\n            r->headers_in.user.data = new_user.data;\n            r->headers_in.user.len = new_user.len;\n        }\n    }\n\n    spnego_debug1(\"Setting $remote_user to %V\", &r->headers_in.user);\n    if (ngx_http_auth_spnego_set_bogus_authorization(r) != NGX_OK)\n        spnego_log_error(\"Failed to set $remote_user\");\n\n    spnego_debug0(\"ngx_http_auth_spnego_basic: returning NGX_OK\");\n\n    ret = NGX_OK;\n\nend:\n    if (name)\n        free(name);\n    if (client)\n        krb5_free_principal(kcontext, client);\n    if (server)\n        krb5_free_principal(kcontext, server);\n    if (service.data)\n        ngx_pfree(r->pool, service.data);\n    if (user.data)\n        ngx_pfree(r->pool, user.data);\n\n    krb5_get_init_creds_opt_free(kcontext, gic_options);\n\n    krb5_free_context(kcontext);\n\n    return ret;\n}\n\n\n/*\n * Because 'remote_user' is assumed to be provided by basic authorization\n * (see ngx_http_variable_remote_user) we are forced to create bogus\n * non-Negotiate authorization header. This may possibly clobber Negotiate\n * token too soon.\n */\n    ngx_int_t\nngx_http_auth_spnego_set_bogus_authorization(\n        ngx_http_request_t *r)\n{\n    const char *bogus_passwd = \"bogus_auth_gss_passwd\";\n    ngx_str_t plain, encoded, final;\n\n    if (r->headers_in.user.len == 0) {\n        spnego_debug0(\"ngx_http_auth_spnego_set_bogus_authorization: no user NGX_DECLINED\");\n        return NGX_DECLINED;\n    }\n\n    /* +1 because of the \":\" in \"user:password\" */\n    plain.len = r->headers_in.user.len + ngx_strlen(bogus_passwd) + 1;\n    plain.data = ngx_pnalloc(r->pool, plain.len);\n    if (NULL == plain.data) {\n        return NGX_ERROR;\n    }\n\n    ngx_snprintf(plain.data, plain.len, \"%V:%s\",\n            &r->headers_in.user, bogus_passwd);\n\n    encoded.len = ngx_base64_encoded_length(plain.len);\n    encoded.data = ngx_pnalloc(r->pool, encoded.len);\n    if (NULL == encoded.data) {\n        return NGX_ERROR;\n    }\n\n    ngx_encode_base64(&encoded, &plain);\n\n    final.len = sizeof(\"Basic \") + encoded.len - 1;\n    final.data = ngx_pnalloc(r->pool, final.len);\n    if (NULL == final.data) {\n        return NGX_ERROR;\n    }\n\n    ngx_snprintf(final.data, final.len, \"Basic %V\", &encoded);\n\n    /* WARNING clobbering authorization header value */\n    r->headers_in.authorization->value.len = final.len;\n    r->headers_in.authorization->value.data = final.data;\n\n    spnego_debug0(\"ngx_http_auth_spnego_set_bogus_authorization: bogus user set\");\n    return NGX_OK;\n}\n\n    static bool\nuse_keytab(\n        ngx_http_request_t * r,\n        ngx_str_t *keytab)\n{\n    size_t kt_sz = keytab->len + 1;\n    char *kt = (char *) ngx_pcalloc(r->pool, kt_sz);\n    if (NULL == kt) {\n        return false;\n    }\n    ngx_snprintf((u_char *) kt, kt_sz, \"%V%Z\", keytab);\n    OM_uint32 major_status, minor_status = 0;\n    major_status = gsskrb5_register_acceptor_identity(kt);\n    if (GSS_ERROR(major_status)) {\n        spnego_log_error(\"%s failed to register keytab\", get_gss_error(\n                    r->pool, minor_status,\n                    \"gsskrb5_register_acceptor_identity() failed\"));\n        return false;\n    }\n\n    spnego_debug1(\"Use keytab %V\", keytab);\n    return true;\n}\n\n    ngx_int_t\nngx_http_auth_spnego_auth_user_gss(\n        ngx_http_request_t * r,\n        ngx_http_auth_spnego_ctx_t * ctx,\n        ngx_http_auth_spnego_loc_conf_t * alcf)\n{\n    ngx_int_t ret = NGX_DECLINED;\n    u_char *pu;\n    ngx_str_t spnego_token = ngx_null_string;\n    OM_uint32 major_status, minor_status, minor_status2;\n    gss_buffer_desc service = GSS_C_EMPTY_BUFFER;\n    gss_name_t my_gss_name = GSS_C_NO_NAME;\n    gss_cred_id_t my_gss_creds = GSS_C_NO_CREDENTIAL;\n    gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;\n    gss_ctx_id_t gss_context = GSS_C_NO_CONTEXT;\n    gss_name_t client_name = GSS_C_NO_NAME;\n    gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;\n\n    if (NULL == ctx || ctx->token.len == 0)\n        return ret;\n\n    spnego_debug0(\"GSSAPI authorizing\");\n\n    if (!use_keytab(r, &alcf->keytab)) {\n        spnego_debug0(\"Failed to specify keytab\");\n        spnego_error(NGX_ERROR);\n    }\n\n    if (alcf->srvcname.len > 0) {\n        /* if there is a specific service prinicipal set in the configuration\n         * file, we need to use it.  Otherwise, use the default of no credentials\n         */\n        service.length = alcf->srvcname.len + alcf->realm.len + 2;\n        service.value = ngx_palloc(r->pool, service.length);\n        if (NULL == service.value) {\n            spnego_error(NGX_ERROR);\n        }\n        ngx_snprintf(service.value, service.length, \"%V@%V%Z\",\n                &alcf->srvcname, &alcf->realm);\n\n        spnego_debug1(\"Using service principal: %s\", service.value);\n        major_status = gss_import_name(&minor_status, &service,\n                (gss_OID) GSS_KRB5_NT_PRINCIPAL_NAME, &my_gss_name);\n        if (GSS_ERROR(major_status)) {\n            spnego_log_error(\"%s Used service principal: %s\", get_gss_error(\n                        r->pool, minor_status, \"gss_import_name() failed\"),\n                    (u_char *) service.value);\n            spnego_error(NGX_ERROR);\n        }\n        gss_buffer_desc human_readable_gss_name = GSS_C_EMPTY_BUFFER;\n        major_status = gss_display_name(&minor_status, my_gss_name,\n                &human_readable_gss_name, NULL);\n\n        if (GSS_ERROR(major_status)) {\n            spnego_log_error(\"%s Used service principal: %s \", get_gss_error(\n                        r->pool, minor_status, \"gss_display_name() failed\"),\n                    (u_char *) service.value);\n        }\n        spnego_debug1(\"my_gss_name %s\", human_readable_gss_name.value);\n\n        /* Obtain credentials */\n        major_status = gss_acquire_cred(&minor_status, my_gss_name,\n                GSS_C_INDEFINITE, GSS_C_NO_OID_SET, GSS_C_ACCEPT, &my_gss_creds,\n                NULL, NULL);\n        if (GSS_ERROR(major_status)) {\n            spnego_log_error(\"%s Used service principal: %s\", get_gss_error(\n                        r->pool, minor_status, \"gss_acquire_cred() failed\"),\n                    (u_char *) service.value);\n            spnego_error(NGX_ERROR);\n        }\n\n    }\n\n    input_token.length = ctx->token.len;\n    input_token.value = (void *) ctx->token.data;\n\n    major_status = gss_accept_sec_context(&minor_status, &gss_context,\n            my_gss_creds, &input_token, GSS_C_NO_CHANNEL_BINDINGS, &client_name,\n            NULL, &output_token, NULL, NULL, NULL);\n    if (GSS_ERROR(major_status)) {\n        spnego_debug1(\"%s\", get_gss_error(\n                    r->pool, minor_status, \"gss_accept_sec_context() failed\"));\n        spnego_error(NGX_DECLINED);\n    }\n\n    if (major_status & GSS_S_CONTINUE_NEEDED) {\n        spnego_debug0(\"only one authentication iteration allowed\");\n        spnego_error(NGX_DECLINED);\n    }\n\n    if (output_token.length) {\n        spnego_token.data = (u_char *) output_token.value;\n        spnego_token.len = output_token.length;\n\n        ctx->token_out_b64.len = ngx_base64_encoded_length(spnego_token.len);\n        ctx->token_out_b64.data = ngx_pcalloc(r->pool, ctx->token_out_b64.len + 1);\n        if (NULL == ctx->token_out_b64.data) {\n            spnego_log_error(\"Not enough memory\");\n            gss_release_buffer(&minor_status2, &output_token);\n            spnego_error(NGX_ERROR);\n        }\n        ngx_encode_base64(&ctx->token_out_b64, &spnego_token);\n        gss_release_buffer(&minor_status2, &output_token);\n    }\n\telse {\n        ctx->token_out_b64.len = 0;\n\t}\n\n    /* getting user name at the other end of the request */\n    major_status = gss_display_name(&minor_status, client_name, &output_token, NULL);\n    if (GSS_ERROR(major_status)) {\n        spnego_log_error(\"%s\", get_gss_error(r->pool, minor_status,\n                    \"gss_display_name() failed\"));\n        spnego_error(NGX_ERROR);\n    }\n\n    if (output_token.length) {\n        /* Apply local rules to map Kerberos Principals to short names */\n        if (alcf->map_to_local) {\n            gss_OID mech_type = discard_const(gss_mech_krb5);\n            output_token = (gss_buffer_desc) GSS_C_EMPTY_BUFFER;\n            major_status = gss_localname(&minor_status, client_name,\n                    mech_type, &output_token);\n            if (GSS_ERROR(major_status)) {\n                spnego_log_error(\"%s\", get_gss_error(r->pool, minor_status,\n                            \"gss_localname() failed\"));\n                spnego_error(NGX_ERROR);\n            }\n        }\n\n        /* TOFIX dirty quick trick for now (no \"-1\" i.e. include '\\0' */\n        ngx_str_t user = {\n            output_token.length,\n            (u_char *) output_token.value\n        };\n\n        r->headers_in.user.data = ngx_pstrdup(r->pool, &user);\n        if (NULL == r->headers_in.user.data) {\n            spnego_log_error(\"ngx_pstrdup failed to allocate\");\n            spnego_error(NGX_ERROR);\n        }\n\n        r->headers_in.user.len = user.len;\n        if (alcf->fqun == 0) {\n            pu = ngx_strlchr(r->headers_in.user.data,\n                    r->headers_in.user.data + r->headers_in.user.len, '@');\n            if (pu != NULL && ngx_strncmp(pu + 1, alcf->realm.data, alcf->realm.len) == 0) {\n                *pu = '\\0';\n                r->headers_in.user.len = ngx_strlen(r->headers_in.user.data);\n            }\n        }\n\n        /* this for the sake of ngx_http_variable_remote_user */\n        if (ngx_http_auth_spnego_set_bogus_authorization(r) != NGX_OK) {\n            spnego_log_error(\"Failed to set remote_user\");\n        }\n        spnego_debug1(\"user is %V\", &r->headers_in.user);\n    }\n\n    gss_release_buffer(&minor_status, &output_token);\n\n    ret = NGX_OK;\n    goto end;\n\nend:\n    if (output_token.length)\n        gss_release_buffer(&minor_status, &output_token);\n\n    if (client_name != GSS_C_NO_NAME)\n        gss_release_name(&minor_status, &client_name);\n\n    if (gss_context != GSS_C_NO_CONTEXT)\n        gss_delete_sec_context(&minor_status, &gss_context,\n                GSS_C_NO_BUFFER);\n\n    if (my_gss_name != GSS_C_NO_NAME)\n        gss_release_name(&minor_status, &my_gss_name);\n\n    if (my_gss_creds != GSS_C_NO_CREDENTIAL)\n        gss_release_cred(&minor_status, &my_gss_creds);\n\n    return ret;\n}\n\n    static ngx_int_t\nngx_http_auth_spnego_handler(\n        ngx_http_request_t * r)\n{\n    ngx_int_t ret = NGX_DECLINED;\n    ngx_http_auth_spnego_ctx_t *ctx;\n    ngx_http_auth_spnego_loc_conf_t *alcf;\n\n    alcf = ngx_http_get_module_loc_conf(r, ngx_http_auth_spnego_module);\n\n    if (alcf->protect == 0) {\n        return NGX_DECLINED;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_auth_spnego_module);\n    if (NULL == ctx) {\n        ctx = ngx_palloc(r->pool, sizeof(ngx_http_auth_spnego_ctx_t));\n        if (NULL == ctx) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n        ctx->token.len = 0;\n        ctx->token.data = NULL;\n        ctx->head = 0;\n        ctx->ret = NGX_HTTP_UNAUTHORIZED;\n        ngx_http_set_ctx(r, ctx, ngx_http_auth_spnego_module);\n    }\n\n    spnego_debug3(\"SSO auth handling IN: token.len=%d, head=%d, ret=%d\",\n            ctx->token.len, ctx->head, ctx->ret);\n\n    if (ctx->token.len && ctx->head) {\n        spnego_debug1(\"Found token and head, returning %d\", ctx->ret);\n        return ctx->ret;\n    }\n\n    if (NULL != r->headers_in.user.data) {\n        spnego_debug0(\"User header set\");\n        return NGX_OK;\n    }\n\n    spnego_debug0(\"Begin auth\");\n\n    if (alcf->allow_basic) {\n        spnego_debug0(\"Detect basic auth\");\n        ret = ngx_http_auth_basic_user(r);\n        if (NGX_OK == ret) {\n            spnego_debug0(\"Basic auth credentials supplied by client\");\n            /* If basic auth is enabled and basic creds are supplied\n             * attempt basic auth.  If we attempt basic auth, we do\n             * not fall through to real SPNEGO */\n            if (NGX_OK != ngx_http_auth_spnego_basic(r, ctx, alcf)) {\n                spnego_debug0(\"Basic auth failed\");\n                if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                    spnego_debug0(\"Error setting headers\");\n                    return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n                }\n                return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n            }\n\n            if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n                spnego_debug0(\"User not authorized\");\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n\n            spnego_debug0(\"Basic auth succeeded\");\n            return (ctx->ret = NGX_OK);\n        }\n    }\n\n    /* Basic auth either disabled or not supplied by client */\n    spnego_debug0(\"Detect SPNEGO token\");\n    ret = ngx_http_auth_spnego_token(r, ctx);\n    if (NGX_OK == ret) {\n        spnego_debug0(\"Client sent a reasonable Negotiate header\");\n        ret = ngx_http_auth_spnego_auth_user_gss(r, ctx, alcf);\n        if (NGX_ERROR == ret) {\n            spnego_debug0(\"GSSAPI failed\");\n            return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n        }\n        /* There are chances that client knows about Negotiate\n         * but doesn't support GSSAPI. We could attempt to fall\n         * back to basic here... */\n        if (NGX_DECLINED == ret) {\n            spnego_debug0(\"GSSAPI failed\");\n            if(!alcf->allow_basic) {\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n            if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                spnego_debug0(\"Error setting headers\");\n                return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n            }\n            return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n        }\n\n        if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n            spnego_debug0(\"User not authorized\");\n            return (ctx->ret = NGX_HTTP_FORBIDDEN);\n        }\n\n        spnego_debug0(\"GSSAPI auth succeeded\");\n    }\n\n    ngx_str_t *token_out_b64 = NULL;\n    switch(ret) {\n        case NGX_DECLINED: /* DECLINED, but not yet FORBIDDEN */\n            ctx->ret = NGX_HTTP_UNAUTHORIZED;\n            break;\n        case NGX_OK:\n            ctx->ret = NGX_OK;\n            token_out_b64 = &ctx->token_out_b64;\n            break;\n        case NGX_ERROR:\n        default:\n            ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n            break;\n    }\n\n    if (NGX_ERROR == ngx_http_auth_spnego_headers(r, ctx, token_out_b64, alcf)) {\n        spnego_debug0(\"Error setting headers\");\n        ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    spnego_debug3(\"SSO auth handling OUT: token.len=%d, head=%d, ret=%d\",\n            ctx->token.len, ctx->head, ctx->ret);\n    return ctx->ret;\n}\n"], "filenames": ["ngx_http_auth_spnego_module.c"], "buggy_code_start_loc": [1046], "buggy_code_end_loc": [1047], "fixing_code_start_loc": [1046], "fixing_code_end_loc": [1047], "type": "CWE-287", "message": "In the SPNEGO HTTP Authentication Module for nginx (spnego-http-auth-nginx-module) before version 1.1.1 basic Authentication can be bypassed using a malformed username. This affects users of spnego-http-auth-nginx-module that have enabled basic authentication. This is fixed in version 1.1.1 of spnego-http-auth-nginx-module. As a workaround, one may disable basic authentication.", "other": {"cve": {"id": "CVE-2021-21335", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-08T21:15:16.573", "lastModified": "2021-03-12T14:21:39.980", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the SPNEGO HTTP Authentication Module for nginx (spnego-http-auth-nginx-module) before version 1.1.1 basic Authentication can be bypassed using a malformed username. This affects users of spnego-http-auth-nginx-module that have enabled basic authentication. This is fixed in version 1.1.1 of spnego-http-auth-nginx-module. As a workaround, one may disable basic authentication."}, {"lang": "es", "value": "En el m\u00f3dulo de autenticaci\u00f3n HTTP SPNEGO para nginx (spnego-http-auth-nginx-module) versiones anteriores a 1.1.1, la Autenticaci\u00f3n b\u00e1sica puede ser omitido usando un nombre de usuario malformado.&#xa0;Esto afecta a usuarios de spnego-http-auth-nginx-module que han habilitado la autenticaci\u00f3n b\u00e1sica.&#xa0;Esto es corregido en versi\u00f3n 1.1.1 de spnego-http-auth-nginx-module.&#xa0;Como una soluci\u00f3n alternativa, puede ser deshabilitar la autenticaci\u00f3n b\u00e1sica"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:spnego_http_authentication_module_project:spnego_http_authentication_module:*:*:*:*:*:nginx:*:*", "versionEndExcluding": "1.1.1", "matchCriteriaId": "89B04778-31B0-41E8-856F-DE883677ED15"}]}]}], "references": [{"url": "https://github.com/stnoonan/spnego-http-auth-nginx-module/commit/a06f9efca373e25328b1c53639a48decd0854570", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/stnoonan/spnego-http-auth-nginx-module/releases/tag/v1.1.1", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/stnoonan/spnego-http-auth-nginx-module/security/advisories/GHSA-ww8q-72rx-hc54", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/stnoonan/spnego-http-auth-nginx-module/commit/a06f9efca373e25328b1c53639a48decd0854570"}}