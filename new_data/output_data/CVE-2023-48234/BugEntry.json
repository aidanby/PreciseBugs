{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar et al.\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * normal.c:\tContains the main routine for processing characters in command\n *\t\tmode.  Communicates closely with the code in ops.c to handle\n *\t\tthe operators.\n */\n\n#include \"vim.h\"\n\nstatic int\tVIsual_mode_orig = NUL;\t\t// saved Visual mode\n\n#ifdef FEAT_EVAL\nstatic void\tset_vcount_ca(cmdarg_T *cap, int *set_prevcount);\n#endif\nstatic void\tunshift_special(cmdarg_T *cap);\nstatic void\tdel_from_showcmd(int);\n\n/*\n * nv_*(): functions called to handle Normal and Visual mode commands.\n * n_*(): functions called to handle Normal mode commands.\n * v_*(): functions called to handle Visual mode commands.\n */\nstatic void\tnv_ignore(cmdarg_T *cap);\nstatic void\tnv_nop(cmdarg_T *cap);\nstatic void\tnv_error(cmdarg_T *cap);\nstatic void\tnv_help(cmdarg_T *cap);\nstatic void\tnv_addsub(cmdarg_T *cap);\nstatic void\tnv_page(cmdarg_T *cap);\nstatic void\tnv_zet(cmdarg_T *cap);\n#ifdef FEAT_GUI\nstatic void\tnv_ver_scrollbar(cmdarg_T *cap);\nstatic void\tnv_hor_scrollbar(cmdarg_T *cap);\n#endif\n#ifdef FEAT_GUI_TABLINE\nstatic void\tnv_tabline(cmdarg_T *cap);\nstatic void\tnv_tabmenu(cmdarg_T *cap);\n#endif\nstatic void\tnv_exmode(cmdarg_T *cap);\nstatic void\tnv_colon(cmdarg_T *cap);\nstatic void\tnv_ctrlg(cmdarg_T *cap);\nstatic void\tnv_ctrlh(cmdarg_T *cap);\nstatic void\tnv_clear(cmdarg_T *cap);\nstatic void\tnv_ctrlo(cmdarg_T *cap);\nstatic void\tnv_hat(cmdarg_T *cap);\nstatic void\tnv_Zet(cmdarg_T *cap);\nstatic void\tnv_ident(cmdarg_T *cap);\nstatic void\tnv_tagpop(cmdarg_T *cap);\nstatic void\tnv_scroll(cmdarg_T *cap);\nstatic void\tnv_right(cmdarg_T *cap);\nstatic void\tnv_left(cmdarg_T *cap);\nstatic void\tnv_up(cmdarg_T *cap);\nstatic void\tnv_down(cmdarg_T *cap);\nstatic void\tnv_end(cmdarg_T *cap);\nstatic void\tnv_dollar(cmdarg_T *cap);\nstatic void\tnv_search(cmdarg_T *cap);\nstatic void\tnv_next(cmdarg_T *cap);\nstatic int\tnormal_search(cmdarg_T *cap, int dir, char_u *pat, int opt, int *wrapped);\nstatic void\tnv_csearch(cmdarg_T *cap);\nstatic void\tnv_brackets(cmdarg_T *cap);\nstatic void\tnv_percent(cmdarg_T *cap);\nstatic void\tnv_brace(cmdarg_T *cap);\nstatic void\tnv_mark(cmdarg_T *cap);\nstatic void\tnv_findpar(cmdarg_T *cap);\nstatic void\tnv_undo(cmdarg_T *cap);\nstatic void\tnv_kundo(cmdarg_T *cap);\nstatic void\tnv_Replace(cmdarg_T *cap);\nstatic void\tnv_replace(cmdarg_T *cap);\nstatic void\tnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos);\nstatic void\tv_visop(cmdarg_T *cap);\nstatic void\tnv_subst(cmdarg_T *cap);\nstatic void\tnv_abbrev(cmdarg_T *cap);\nstatic void\tnv_optrans(cmdarg_T *cap);\nstatic void\tnv_gomark(cmdarg_T *cap);\nstatic void\tnv_pcmark(cmdarg_T *cap);\nstatic void\tnv_regname(cmdarg_T *cap);\nstatic void\tnv_visual(cmdarg_T *cap);\nstatic void\tn_start_visual_mode(int c);\nstatic void\tnv_window(cmdarg_T *cap);\nstatic void\tnv_suspend(cmdarg_T *cap);\nstatic void\tnv_g_cmd(cmdarg_T *cap);\nstatic void\tnv_dot(cmdarg_T *cap);\nstatic void\tnv_redo_or_register(cmdarg_T *cap);\nstatic void\tnv_Undo(cmdarg_T *cap);\nstatic void\tnv_tilde(cmdarg_T *cap);\nstatic void\tnv_operator(cmdarg_T *cap);\n#ifdef FEAT_EVAL\nstatic void\tset_op_var(int optype);\n#endif\nstatic void\tnv_lineop(cmdarg_T *cap);\nstatic void\tnv_home(cmdarg_T *cap);\nstatic void\tnv_pipe(cmdarg_T *cap);\nstatic void\tnv_bck_word(cmdarg_T *cap);\nstatic void\tnv_wordcmd(cmdarg_T *cap);\nstatic void\tnv_beginline(cmdarg_T *cap);\nstatic void\tadjust_cursor(oparg_T *oap);\nstatic void\tadjust_for_sel(cmdarg_T *cap);\nstatic void\tnv_select(cmdarg_T *cap);\nstatic void\tnv_goto(cmdarg_T *cap);\nstatic void\tnv_normal(cmdarg_T *cap);\nstatic void\tnv_esc(cmdarg_T *oap);\nstatic void\tnv_edit(cmdarg_T *cap);\nstatic void\tinvoke_edit(cmdarg_T *cap, int repl, int cmd, int startln);\nstatic void\tnv_object(cmdarg_T *cap);\nstatic void\tnv_record(cmdarg_T *cap);\nstatic void\tnv_at(cmdarg_T *cap);\nstatic void\tnv_halfpage(cmdarg_T *cap);\nstatic void\tnv_join(cmdarg_T *cap);\nstatic void\tnv_put(cmdarg_T *cap);\nstatic void\tnv_put_opt(cmdarg_T *cap, int fix_indent);\nstatic void\tnv_open(cmdarg_T *cap);\n#ifdef FEAT_NETBEANS_INTG\nstatic void\tnv_nbcmd(cmdarg_T *cap);\n#endif\n#ifdef FEAT_DND\nstatic void\tnv_drop(cmdarg_T *cap);\n#endif\nstatic void\tnv_cursorhold(cmdarg_T *cap);\n\n// Declare nv_cmds[].\n#define DO_DECLARE_NVCMD\n#include \"nv_cmds.h\"\n\n// Include the lookuptable generated by create_nvcmdidx.vim.\n#include \"nv_cmdidxs.h\"\n\n/*\n * Search for a command in the commands table.\n * Returns -1 for invalid command.\n */\n    static int\nfind_command(int cmdchar)\n{\n    int\t\ti;\n    int\t\tidx;\n    int\t\ttop, bot;\n    int\t\tc;\n\n    // A multi-byte character is never a command.\n    if (cmdchar >= 0x100)\n\treturn -1;\n\n    // We use the absolute value of the character.  Special keys have a\n    // negative value, but are sorted on their absolute value.\n    if (cmdchar < 0)\n\tcmdchar = -cmdchar;\n\n    // If the character is in the first part: The character is the index into\n    // nv_cmd_idx[].\n    if (cmdchar <= nv_max_linear)\n\treturn nv_cmd_idx[cmdchar];\n\n    // Perform a binary search.\n    bot = nv_max_linear + 1;\n    top = NV_CMDS_SIZE - 1;\n    idx = -1;\n    while (bot <= top)\n    {\n\ti = (top + bot) / 2;\n\tc = nv_cmds[nv_cmd_idx[i]].cmd_char;\n\tif (c < 0)\n\t    c = -c;\n\tif (cmdchar == c)\n\t{\n\t    idx = nv_cmd_idx[i];\n\t    break;\n\t}\n\tif (cmdchar > c)\n\t    bot = i + 1;\n\telse\n\t    top = i - 1;\n    }\n    return idx;\n}\n\n/*\n * If currently editing a cmdline or text is locked: beep and give an error\n * message, return TRUE.\n */\n    static int\ncheck_text_locked(oparg_T *oap)\n{\n    if (!text_locked())\n\treturn FALSE;\n\n    if (oap != NULL)\n\tclearopbeep(oap);\n    text_locked_msg();\n    return TRUE;\n}\n\n/*\n * If text is locked, \"curbuf_lock\" or \"allbuf_lock\" is set:\n * Give an error message, possibly beep and return TRUE.\n * \"oap\" may be NULL.\n */\n    int\ncheck_text_or_curbuf_locked(oparg_T *oap)\n{\n    if (check_text_locked(oap))\n\treturn TRUE;\n\n    if (!curbuf_locked())\n\treturn FALSE;\n\n    if (oap != NULL)\n\tclearop(oap);\n    return TRUE;\n}\n\n/*\n * Handle the count before a normal command and set cap->count0.\n */\n    static int\nnormal_cmd_get_count(\n\tcmdarg_T\t*cap,\n\tint\t\tc,\n\tint\t\ttoplevel UNUSED,\n\tint\t\tset_prevcount UNUSED,\n\tint\t\t*ctrl_w,\n\tint\t\t*need_flushbuf UNUSED)\n{\ngetcount:\n    if (!(VIsual_active && VIsual_select))\n    {\n\t// Handle a count before a command and compute ca.count0.\n\t// Note that '0' is a command and not the start of a count, but it's\n\t// part of a count after other digits.\n\twhile ((c >= '1' && c <= '9')\n\t\t|| (cap->count0 != 0 && (c == K_DEL || c == K_KDEL\n\t\t\t|| c == '0')))\n\t{\n\t    if (c == K_DEL || c == K_KDEL)\n\t    {\n\t\tcap->count0 /= 10;\n\t\tdel_from_showcmd(4);\t// delete the digit and ~@%\n\t    }\n\t    else if (cap->count0 > 99999999L)\n\t    {\n\t\tcap->count0 = 999999999L;\n\t    }\n\t    else\n\t    {\n\t\tcap->count0 = cap->count0 * 10 + (c - '0');\n\t    }\n#ifdef FEAT_EVAL\n\t    // Set v:count here, when called from main() and not a stuffed\n\t    // command, so that v:count can be used in an expression mapping\n\t    // right after the count. Do set it for redo.\n\t    if (toplevel && readbuf1_empty())\n\t\tset_vcount_ca(cap, &set_prevcount);\n#endif\n\t    if (*ctrl_w)\n\t    {\n\t\t++no_mapping;\n\t\t++allow_keys;\t\t// no mapping for nchar, but keys\n\t    }\n\t    ++no_zero_mapping;\t\t// don't map zero here\n\t    c = plain_vgetc();\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_zero_mapping;\n\t    if (*ctrl_w)\n\t    {\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t    }\n\t    *need_flushbuf |= add_to_showcmd(c);\n\t}\n\n\t// If we got CTRL-W there may be a/another count\n\tif (c == Ctrl_W && !*ctrl_w && cap->oap->op_type == OP_NOP)\n\t{\n\t    *ctrl_w = TRUE;\n\t    cap->opcount = cap->count0;\t// remember first count\n\t    cap->count0 = 0;\n\t    ++no_mapping;\n\t    ++allow_keys;\t\t// no mapping for nchar, but keys\n\t    c = plain_vgetc();\t\t// get next character\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_mapping;\n\t    --allow_keys;\n\t    *need_flushbuf |= add_to_showcmd(c);\n\t    goto getcount;\t\t// jump back\n\t}\n    }\n\n    if (c == K_CURSORHOLD)\n    {\n\t// Save the count values so that ca.opcount and ca.count0 are exactly\n\t// the same when coming back here after handling K_CURSORHOLD.\n\tcap->oap->prev_opcount = cap->opcount;\n\tcap->oap->prev_count0 = cap->count0;\n    }\n    else if (cap->opcount != 0)\n    {\n\t// If we're in the middle of an operator (including after entering a\n\t// yank buffer with '\"') AND we had a count before the operator, then\n\t// that count overrides the current value of ca.count0.\n\t// What this means effectively, is that commands like \"3dw\" get turned\n\t// into \"d3w\" which makes things fall into place pretty neatly.\n\t// If you give a count before AND after the operator, they are\n\t// multiplied.\n\tif (cap->count0)\n\t{\n\t    if (cap->opcount >= 999999999L / cap->count0)\n\t\tcap->count0 = 999999999L;\n\t    else\n\t\tcap->count0 *= cap->opcount;\n\t}\n\telse\n\t    cap->count0 = cap->opcount;\n    }\n\n    // Always remember the count.  It will be set to zero (on the next call,\n    // above) when there is no pending operator.\n    // When called from main(), save the count for use by the \"count\" built-in\n    // variable.\n    cap->opcount = cap->count0;\n    cap->count1 = (cap->count0 == 0 ? 1 : cap->count0);\n\n#ifdef FEAT_EVAL\n    // Only set v:count when called from main() and not a stuffed command.\n    // Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount(cap->count0, cap->count1, set_prevcount);\n#endif\n\n    return c;\n}\n\n/*\n * Returns TRUE if the normal command (cap) needs a second character.\n */\n    static int\nnormal_cmd_needs_more_chars(cmdarg_T *cap, short_u cmd_flags)\n{\n    return ((cmd_flags & NV_NCH)\n\t    && (((cmd_flags & NV_NCH_NOP) == NV_NCH_NOP\n\t\t    && cap->oap->op_type == OP_NOP)\n\t\t|| (cmd_flags & NV_NCH_ALW) == NV_NCH_ALW\n\t\t|| (cap->cmdchar == 'q'\n\t\t    && cap->oap->op_type == OP_NOP\n\t\t    && reg_recording == 0\n\t\t    && reg_executing == 0)\n\t\t|| ((cap->cmdchar == 'a' || cap->cmdchar == 'i')\n\t\t    && (cap->oap->op_type != OP_NOP || VIsual_active))));\n}\n\n/*\n * Get one or more additional characters for a normal command.\n * Return the updated command index (if changed).\n */\n    static int\nnormal_cmd_get_more_chars(\n\tint\t    idx_arg,\n\tcmdarg_T    *cap,\n\tint\t    *need_flushbuf UNUSED)\n{\n    int\t\tidx = idx_arg;\n    int\t\tc;\n    int\t\t*cp;\n    int\t\trepl = FALSE;\t// get character for replace mode\n    int\t\tlit = FALSE;\t// get extra character literally\n    int\t\tlangmap_active = FALSE;    // using :lmap mappings\n    int\t\tlang;\t\t// getting a text character\n#ifdef HAVE_INPUT_METHOD\n    int\t\tsave_smd;\t// saved value of p_smd\n#endif\n\n    ++no_mapping;\n    ++allow_keys;\t\t// no mapping for nchar, but allow key codes\n    // Don't generate a CursorHold event here, most commands can't handle\n    // it, e.g., nv_replace(), nv_csearch().\n    did_cursorhold = TRUE;\n    if (cap->cmdchar == 'g')\n    {\n\t/*\n\t * For 'g' get the next character now, so that we can check for\n\t * \"gr\", \"g'\" and \"g`\".\n\t */\n\tcap->nchar = plain_vgetc();\n\tLANGMAP_ADJUST(cap->nchar, TRUE);\n\t*need_flushbuf |= add_to_showcmd(cap->nchar);\n\tif (cap->nchar == 'r' || cap->nchar == '\\'' || cap->nchar == '`'\n\t\t|| cap->nchar == Ctrl_BSL)\n\t{\n\t    cp = &cap->extra_char;\t// need to get a third character\n\t    if (cap->nchar != 'r')\n\t\tlit = TRUE;\t\t\t// get it literally\n\t    else\n\t\trepl = TRUE;\t\t// get it in replace mode\n\t}\n\telse\n\t    cp = NULL;\t\t// no third character needed\n    }\n    else\n    {\n\tif (cap->cmdchar == 'r')\t\t// get it in replace mode\n\t    repl = TRUE;\n\tcp = &cap->nchar;\n    }\n    lang = (repl || (nv_cmds[idx].cmd_flags & NV_LANG));\n\n    /*\n     * Get a second or third character.\n     */\n    if (cp != NULL)\n    {\n\tif (repl)\n\t{\n\t    State = MODE_REPLACE;\t// pretend Replace mode\n#ifdef CURSOR_SHAPE\n\t    ui_cursor_shape();\t// show different cursor shape\n#endif\n\t}\n\tif (lang && curbuf->b_p_iminsert == B_IMODE_LMAP)\n\t{\n\t    // Allow mappings defined with \":lmap\".\n\t    --no_mapping;\n\t    --allow_keys;\n\t    if (repl)\n\t\tState = MODE_LREPLACE;\n\t    else\n\t\tState = MODE_LANGMAP;\n\t    langmap_active = TRUE;\n\t}\n#ifdef HAVE_INPUT_METHOD\n\tsave_smd = p_smd;\n\tp_smd = FALSE;\t// Don't let the IM code show the mode here\n\tif (lang && curbuf->b_p_iminsert == B_IMODE_IM)\n\t    im_set_active(TRUE);\n#endif\n\tif ((State & MODE_INSERT) && !p_ek)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\n\t    // Disable bracketed paste and modifyOtherKeys here, we won't\n\t    // recognize the escape sequences with 'esckeys' off.\n\t    out_str(T_BD);\n\t    out_str_t_TE();\n\t}\n\n\t*cp = plain_vgetc();\n\n\tif ((State & MODE_INSERT) && !p_ek)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\n\t    // Re-enable bracketed paste mode and modifyOtherKeys\n\t    out_str_t_BE();\n\t    out_str_t_TI();\n\t}\n\n\tif (langmap_active)\n\t{\n\t    // Undo the decrement done above\n\t    ++no_mapping;\n\t    ++allow_keys;\n\t    State = MODE_NORMAL_BUSY;\n\t}\n#ifdef HAVE_INPUT_METHOD\n\tif (lang)\n\t{\n\t    if (curbuf->b_p_iminsert != B_IMODE_LMAP)\n\t\tim_save_status(&curbuf->b_p_iminsert);\n\t    im_set_active(FALSE);\n\t}\n\tp_smd = save_smd;\n#endif\n\tState = MODE_NORMAL_BUSY;\n\t*need_flushbuf |= add_to_showcmd(*cp);\n\n\tif (!lit)\n\t{\n#ifdef FEAT_DIGRAPHS\n\t    // Typing CTRL-K gets a digraph.\n\t    if (*cp == Ctrl_K\n\t\t    && ((nv_cmds[idx].cmd_flags & NV_LANG)\n\t\t\t|| cp == &cap->extra_char)\n\t\t    && vim_strchr(p_cpo, CPO_DIGRAPH) == NULL)\n\t    {\n\t\tc = get_digraph(FALSE);\n\t\tif (c > 0)\n\t\t{\n\t\t    *cp = c;\n\t\t    // Guessing how to update showcmd here...\n\t\t    del_from_showcmd(3);\n\t\t    *need_flushbuf |= add_to_showcmd(*cp);\n\t\t}\n\t    }\n#endif\n\n\t    // adjust chars > 127, except after \"tTfFr\" commands\n\t    LANGMAP_ADJUST(*cp, !lang);\n#ifdef FEAT_RIGHTLEFT\n\t    // adjust Hebrew mapped char\n\t    if (p_hkmap && lang && KeyTyped)\n\t\t*cp = hkmap(*cp);\n#endif\n\t}\n\n\t// When the next character is CTRL-\\ a following CTRL-N means the\n\t// command is aborted and we go to Normal mode.\n\tif (cp == &cap->extra_char\n\t\t&& cap->nchar == Ctrl_BSL\n\t\t&& (cap->extra_char == Ctrl_N || cap->extra_char == Ctrl_G))\n\t{\n\t    cap->cmdchar = Ctrl_BSL;\n\t    cap->nchar = cap->extra_char;\n\t    idx = find_command(cap->cmdchar);\n\t}\n\telse if ((cap->nchar == 'n' || cap->nchar == 'N')\n\t\t\t\t\t\t\t&& cap->cmdchar == 'g')\n\t    cap->oap->op_type = get_op_type(*cp, NUL);\n\telse if (*cp == Ctrl_BSL)\n\t{\n\t    long towait = (p_ttm >= 0 ? p_ttm : p_tm);\n\n\t    // There is a busy wait here when typing \"f<C-\\>\" and then\n\t    // something different from CTRL-N.  Can't be avoided.\n\t    while ((c = vpeekc()) <= 0 && towait > 0L)\n\t    {\n\t\tdo_sleep(towait > 50L ? 50L : towait, FALSE);\n\t\ttowait -= 50L;\n\t    }\n\t    if (c > 0)\n\t    {\n\t\tc = plain_vgetc();\n\t\tif (c != Ctrl_N && c != Ctrl_G)\n\t\t    vungetc(c);\n\t\telse\n\t\t{\n\t\t    cap->cmdchar = Ctrl_BSL;\n\t\t    cap->nchar = c;\n\t\t    idx = find_command(cap->cmdchar);\n\t\t}\n\t    }\n\t}\n\n\tif (enc_utf8 && lang)\n\t{\n\t    // When getting a text character and the next character is a\n\t    // multi-byte character, it could be a composing character.\n\t    // However, don't wait for it to arrive. Also, do enable mapping,\n\t    // because if it's put back with vungetc() it's too late to apply\n\t    // mapping.\n\t    --no_mapping;\n\t    while ((c = vpeekc()) > 0\n\t\t    && (c >= 0x100 || MB_BYTE2LEN(vpeekc()) > 1))\n\t    {\n\t\tc = plain_vgetc();\n\t\tif (!utf_iscomposing(c))\n\t\t{\n\t\t    vungetc(c);\t\t// it wasn't, put it back\n\t\t    break;\n\t\t}\n\t\telse if (cap->ncharC1 == 0)\n\t\t    cap->ncharC1 = c;\n\t\telse\n\t\t    cap->ncharC2 = c;\n\t    }\n\t    ++no_mapping;\n\t    // Vim may be in a different mode when the user types the next key,\n\t    // but when replaying a recording the next key is already in the\n\t    // typeahead buffer, so record a <Nop> before that to prevent the\n\t    // vpeekc() above from applying wrong mappings when replaying.\n\t    ++no_u_sync;\n\t    gotchars_nop();\n\t    --no_u_sync;\n\t}\n    }\n    --no_mapping;\n    --allow_keys;\n\n    return idx;\n}\n\n/*\n * Returns TRUE if after processing a normal mode command, need to wait for a\n * moment when a message is displayed that will be overwritten by the mode\n * message.\n */\n    static int\nnormal_cmd_need_to_wait_for_msg(cmdarg_T *cap, pos_T *old_pos)\n{\n    // In Visual mode and with \"^O\" in Insert mode, a short message will be\n    // overwritten by the mode message.  Wait a bit, until a key is hit.\n    // In Visual mode, it's more important to keep the Visual area updated\n    // than keeping a message (e.g. from a /pat search).\n    // Only do this if the command was typed, not from a mapping.\n    // Don't wait when emsg_silent is non-zero.\n    // Also wait a bit after an error message, e.g. for \"^O:\".\n    // Don't redraw the screen, it would remove the message.\n    return (       ((p_smd\n\t\t    && msg_silent == 0\n\t\t    && (restart_edit != 0\n\t\t\t|| (VIsual_active\n\t\t\t    && old_pos->lnum == curwin->w_cursor.lnum\n\t\t\t    && old_pos->col == curwin->w_cursor.col)\n\t\t       )\n\t\t    && (clear_cmdline\n\t\t\t|| redraw_cmdline)\n\t\t    && (msg_didout || (msg_didany && msg_scroll))\n\t\t    && !msg_nowait\n\t\t    && KeyTyped)\n\t\t|| (restart_edit != 0\n\t\t    && !VIsual_active\n\t\t    && (msg_scroll\n\t\t\t|| emsg_on_display)))\n\t    && cap->oap->regname == 0\n\t    && !(cap->retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && typebuf_typed()\n\t    && emsg_silent == 0\n\t    && !in_assert_fails\n\t    && !did_wait_return\n\t    && cap->oap->op_type == OP_NOP);\n}\n\n/*\n * After processing a normal mode command, wait for a moment when a message is\n * displayed that will be overwritten by the mode message.\n */\n    static void\nnormal_cmd_wait_for_msg(void)\n{\n    int\tsave_State = State;\n\n    // Draw the cursor with the right shape here\n    if (restart_edit != 0)\n\tState = MODE_INSERT;\n\n    // If need to redraw, and there is a \"keep_msg\", redraw before the\n    // delay\n    if (must_redraw && keep_msg != NULL && !emsg_on_display)\n    {\n\tchar_u\t*kmsg;\n\n\tkmsg = keep_msg;\n\tkeep_msg = NULL;\n\t// Showmode() will clear keep_msg, but we want to use it anyway.\n\t// First update w_topline.\n\tsetcursor();\n\tupdate_screen(0);\n\t// now reset it, otherwise it's put in the history again\n\tkeep_msg = kmsg;\n\n\tkmsg = vim_strsave(keep_msg);\n\tif (kmsg != NULL)\n\t{\n\t    msg_attr((char *)kmsg, keep_msg_attr);\n\t    vim_free(kmsg);\n\t}\n    }\n    setcursor();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    cursor_on();\n    out_flush();\n    if (msg_scroll || emsg_on_display)\n\tui_delay(1003L, TRUE);\t// wait at least one second\n    ui_delay(3003L, FALSE);\t\t// wait up to three seconds\n    State = save_State;\n\n    msg_scroll = FALSE;\n    emsg_on_display = FALSE;\n}\n\n/*\n * Execute a command in Normal mode.\n */\n    void\nnormal_cmd(\n    oparg_T\t*oap,\n    int\t\ttoplevel UNUSED)\t// TRUE when called from main()\n{\n    cmdarg_T\tca;\t\t\t// command arguments\n    int\t\tc;\n    int\t\tctrl_w = FALSE;\t\t// got CTRL-W command\n    int\t\told_col = curwin->w_curswant;\n    int\t\tneed_flushbuf = FALSE;\t// need to call out_flush()\n    pos_T\told_pos;\t\t// cursor position before command\n    int\t\tmapped_len;\n    static int\told_mapped_len = 0;\n    int\t\tidx;\n    int\t\tset_prevcount = FALSE;\n    int\t\tsave_did_cursorhold = did_cursorhold;\n\n    CLEAR_FIELD(ca);\t// also resets ca.retval\n    ca.oap = oap;\n\n    // Use a count remembered from before entering an operator.  After typing\n    // \"3d\" we return from normal_cmd() and come back here, the \"3\" is\n    // remembered in \"opcount\".\n    ca.opcount = opcount;\n\n    // If there is an operator pending, then the command we take this time\n    // will terminate it. Finish_op tells us to finish the operation before\n    // returning this time (unless the operation was cancelled).\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = (oap->op_type != OP_NOP);\n#ifdef CURSOR_SHAPE\n    if (finish_op != c)\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n    may_trigger_modechanged();\n\n    // When not finishing an operator and no register name typed, reset the\n    // count.\n    if (!finish_op && !oap->regname)\n    {\n\tca.opcount = 0;\n#ifdef FEAT_EVAL\n\tset_prevcount = TRUE;\n#endif\n    }\n\n    // Restore counts from before receiving K_CURSORHOLD.  This means after\n    // typing \"3\", handling K_CURSORHOLD and then typing \"2\" we get \"32\", not\n    // \"3 * 2\".\n    if (oap->prev_opcount > 0 || oap->prev_count0 > 0)\n    {\n\tca.opcount = oap->prev_opcount;\n\tca.count0 = oap->prev_count0;\n\toap->prev_opcount = 0;\n\toap->prev_count0 = 0;\n    }\n\n    mapped_len = typebuf_maplen();\n\n    State = MODE_NORMAL_BUSY;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = FALSE;\t// allow scrolling here\n#endif\n\n#ifdef FEAT_EVAL\n    // Set v:count here, when called from main() and not a stuffed\n    // command, so that v:count can be used in an expression mapping\n    // when there is no count. Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount_ca(&ca, &set_prevcount);\n#endif\n\n    /*\n     * Get the command character from the user.\n     */\n    c = safe_vgetc();\n    LANGMAP_ADJUST(c, get_real_state() != MODE_SELECT);\n\n    // If a mapping was started in Visual or Select mode, remember the length\n    // of the mapping.  This is used below to not return to Insert mode for as\n    // long as the mapping is being executed.\n    if (restart_edit == 0)\n\told_mapped_len = 0;\n    else if (old_mapped_len\n\t\t|| (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0))\n\told_mapped_len = typebuf_maplen();\n\n    if (c == NUL)\n\tc = K_ZERO;\n\n    // In Select mode, typed text replaces the selection.\n    if (VIsual_active\n\t    && VIsual_select\n\t    && (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER))\n    {\n\tint len;\n\n\t// Fake a \"c\"hange command.  When \"restart_edit\" is set (e.g., because\n\t// 'insertmode' is set) fake a \"d\"elete command, Insert mode will\n\t// restart automatically.\n\t// Insert the typed character in the typeahead buffer, so that it can\n\t// be mapped in Insert mode.  Required for \":lmap\" to work.\n\tlen = ins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\n\t// When recording and gotchars() was called the character will be\n\t// recorded again, remove the previous recording.\n\tif (KeyTyped)\n\t    ungetchars(len);\n\n\tif (restart_edit != 0)\n\t    c = 'd';\n\telse\n\t    c = 'c';\n\tmsg_nowait = TRUE;\t// don't delay going to insert mode\n\told_mapped_len = 0;\t// do go to Insert mode\n    }\n\n    // If the window was made so small that nothing shows, make it at least one\n    // line and one column when typing a command.\n    if (KeyTyped && !KeyStuffed)\n\twin_ensure_size();\n\n    need_flushbuf = add_to_showcmd(c);\n\n    // Get the command count\n    c = normal_cmd_get_count(&ca, c, toplevel, set_prevcount, &ctrl_w,\n\t\t\t\t\t\t\t&need_flushbuf);\n\n    // Find the command character in the table of commands.\n    // For CTRL-W we already got nchar when looking for a count.\n    if (ctrl_w)\n    {\n\tca.nchar = c;\n\tca.cmdchar = Ctrl_W;\n    }\n    else\n\tca.cmdchar = c;\n    idx = find_command(ca.cmdchar);\n    if (idx < 0)\n    {\n\t// Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if ((nv_cmds[idx].cmd_flags & NV_NCW) && check_text_or_curbuf_locked(oap))\n\t// this command is not allowed now\n\tgoto normal_end;\n\n    // In Visual/Select mode, a few keys are handled in a special way.\n    if (VIsual_active)\n    {\n\t// when 'keymodel' contains \"stopsel\" may stop Select/Visual mode\n\tif (km_stopsel\n\t\t&& (nv_cmds[idx].cmd_flags & NV_STS)\n\t\t&& !(mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    end_visual_mode();\n\t    redraw_curbuf_later(UPD_INVERTED);\n\t}\n\n\t// Keys that work different when 'keymodel' contains \"startsel\"\n\tif (km_startsel)\n\t{\n\t    if (nv_cmds[idx].cmd_flags & NV_SS)\n\t    {\n\t\tunshift_special(&ca);\n\t\tidx = find_command(ca.cmdchar);\n\t\tif (idx < 0)\n\t\t{\n\t\t    // Just in case\n\t\t    clearopbeep(oap);\n\t\t    goto normal_end;\n\t\t}\n\t    }\n\t    else if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t       && (mod_mask & MOD_MASK_SHIFT))\n\t\tmod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && KeyTyped && !KeyStuffed\n\t\t\t\t\t  && (nv_cmds[idx].cmd_flags & NV_RL))\n    {\n\t// Invert horizontal movements and operations.  Only when typed by the\n\t// user directly, not when the result of a mapping or \"x\" translated\n\t// to \"dl\".\n\tswitch (ca.cmdchar)\n\t{\n\t    case 'l':\t    ca.cmdchar = 'h'; break;\n\t    case K_RIGHT:   ca.cmdchar = K_LEFT; break;\n\t    case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break;\n\t    case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break;\n\t    case 'h':\t    ca.cmdchar = 'l'; break;\n\t    case K_LEFT:    ca.cmdchar = K_RIGHT; break;\n\t    case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break;\n\t    case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break;\n\t    case '>':\t    ca.cmdchar = '<'; break;\n\t    case '<':\t    ca.cmdchar = '>'; break;\n\t}\n\tidx = find_command(ca.cmdchar);\n    }\n#endif\n\n    // Get additional characters if we need them.\n    if (normal_cmd_needs_more_chars(&ca, nv_cmds[idx].cmd_flags))\n\tidx = normal_cmd_get_more_chars(idx, &ca, &need_flushbuf);\n\n    // Flush the showcmd characters onto the screen so we can see them while\n    // the command is being executed.  Only do this when the shown command was\n    // actually displayed, otherwise this will slow down a lot when executing\n    // mappings.\n    if (need_flushbuf)\n\tout_flush();\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tif (ex_normal_busy)\n\t    did_cursorhold = save_did_cursorhold;\n\telse\n\t    did_cursorhold = FALSE;\n    }\n\n    State = MODE_NORMAL;\n\n    if (ca.nchar == ESC || ca.extra_char == ESC)\n    {\n\tclearop(oap);\n\tif (restart_edit == 0 && goto_im())\n\t    restart_edit = 'a';\n\tgoto normal_end;\n    }\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tmsg_didout = FALSE;    // don't scroll screen up for normal command\n\tmsg_col = 0;\n    }\n\n    old_pos = curwin->w_cursor;\t\t// remember where the cursor was\n\n    // When 'keymodel' contains \"startsel\" some keys start Select/Visual\n    // mode.\n    if (!VIsual_active && km_startsel)\n    {\n\tif (nv_cmds[idx].cmd_flags & NV_SS)\n\t{\n\t    start_selection();\n\t    unshift_special(&ca);\n\t    idx = find_command(ca.cmdchar);\n\t}\n\telse if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t   && (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    start_selection();\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    // Execute the command!\n    // Call the command function found in the commands table.\n    ca.arg = nv_cmds[idx].cmd_arg;\n    (nv_cmds[idx].cmd_func)(&ca);\n\n    // If we didn't start or finish an operator, reset oap->regname, unless we\n    // need it later.\n    if (!finish_op\n\t    && !oap->op_type\n\t    && (idx < 0 || !(nv_cmds[idx].cmd_flags & NV_KEEPREG)))\n    {\n\tclearop(oap);\n#ifdef FEAT_EVAL\n\treset_reg_var();\n#endif\n    }\n\n    // Get the length of mapped chars again after typing a count, second\n    // character or \"z333<cr>\".\n    if (old_mapped_len > 0)\n\told_mapped_len = typebuf_maplen();\n\n    // If an operation is pending, handle it.  But not for K_IGNORE or\n    // K_MOUSEMOVE.\n    if (ca.cmdchar != K_IGNORE && ca.cmdchar != K_MOUSEMOVE)\n\tdo_pending_operator(&ca, old_col, FALSE);\n\n    // Wait for a moment when a message is displayed that will be overwritten\n    // by the mode message.\n    if (normal_cmd_need_to_wait_for_msg(&ca, &old_pos))\n\tnormal_cmd_wait_for_msg();\n\n    // Finish up after executing a Normal mode command.\nnormal_end:\n\n    msg_nowait = FALSE;\n\n#ifdef FEAT_EVAL\n    if (finish_op)\n\treset_reg_var();\n#endif\n\n#ifdef CURSOR_SHAPE\n    int prev_finish_op = finish_op;\n#endif\n    if (oap->op_type == OP_NOP)\n    {\n\t// Reset finish_op, in case it was set\n\tfinish_op = FALSE;\n\tmay_trigger_modechanged();\n    }\n#ifdef CURSOR_SHAPE\n    // Redraw the cursor with another shape, if we were in Operator-pending\n    // mode or did a replace command.\n    if (prev_finish_op || ca.cmdchar == 'r'\n\t\t\t\t     || (ca.cmdchar == 'g' && ca.nchar == 'r'))\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n\n    if (oap->op_type == OP_NOP && oap->regname == 0\n\t\t\t\t\t\t && ca.cmdchar != K_CURSORHOLD)\n\tclear_showcmd();\n\n    checkpcmark();\t\t// check if we moved since setting pcmark\n    vim_free(ca.searchbuf);\n\n    if (has_mbyte)\n\tmb_adjust_cursor();\n\n    if (curwin->w_p_scb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_scrollbind(TRUE);\n    }\n\n    if (curwin->w_p_crb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_cursorbind();\n    }\n\n#ifdef FEAT_TERMINAL\n    // don't go to Insert mode if a terminal has a running job\n    if (term_job_running(curbuf->b_term))\n\trestart_edit = 0;\n#endif\n\n    // May restart edit(), if we got here with CTRL-O in Insert mode (but not\n    // if still inside a mapping that started in Visual mode).\n    // May switch from Visual to Select mode after CTRL-O command.\n    if (       oap->op_type == OP_NOP\n\t    && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t\t|| restart_VIsual_select == 1)\n\t    && !(ca.retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && oap->regname == 0)\n    {\n\tif (restart_VIsual_select == 1)\n\t{\n\t    VIsual_select = TRUE;\n\t    may_trigger_modechanged();\n\t    showmode();\n\t    restart_VIsual_select = 0;\n\t    VIsual_select_reg = 0;\n\t}\n\tif (restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t    (void)edit(restart_edit, FALSE, 1L);\n    }\n\n    if (restart_VIsual_select == 2)\n\trestart_VIsual_select = 1;\n\n    // Save count before an operator for next time.\n    opcount = ca.opcount;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:count and v:count1 according to \"cap\".\n * Set v:prevcount only when \"set_prevcount\" is TRUE.\n */\n    static void\nset_vcount_ca(cmdarg_T *cap, int *set_prevcount)\n{\n    long count = cap->count0;\n\n    // multiply with cap->opcount the same way as above\n    if (cap->opcount != 0)\n\tcount = cap->opcount * (count == 0 ? 1 : count);\n    set_vcount(count, count == 0 ? 1 : count, *set_prevcount);\n    *set_prevcount = FALSE;  // only set v:prevcount once\n}\n#endif\n\n/*\n * Check if highlighting for Visual mode is possible, give a warning message\n * if not.\n */\n    void\ncheck_visual_highlight(void)\n{\n    static int\t    did_check = FALSE;\n\n    if (full_screen)\n    {\n\tif (!did_check && HL_ATTR(HLF_V) == 0)\n\t    msg(_(\"Warning: terminal cannot highlight\"));\n\tdid_check = TRUE;\n    }\n}\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_EVAL)\n/*\n * Call yank_do_autocmd() for \"regname\".\n */\n    static void\ncall_yank_do_autocmd(int regname)\n{\n    oparg_T\toa;\n    yankreg_T\t*reg;\n\n    clear_oparg(&oa);\n    oa.regname = regname;\n    oa.op_type = OP_YANK;\n    oa.is_VIsual = TRUE;\n    reg = get_register(regname, TRUE);\n    yank_do_autocmd(&oa, reg);\n    free_register(reg);\n}\n#endif\n\n/*\n * End Visual mode.\n * This function or the next should ALWAYS be called to end Visual mode, except\n * from do_pending_operator().\n */\n    void\nend_visual_mode(void)\n{\n    end_visual_mode_keep_button();\n    reset_held_button();\n}\n\n    void\nend_visual_mode_keep_button(void)\n{\n#ifdef FEAT_CLIPBOARD\n    // If we are using the clipboard, then remember what was selected in case\n    // we need to paste it somewhere while we still own the selection.\n    // Only do this when the clipboard is already owned.  Don't want to grab\n    // the selection when hitting ESC.\n    if (clip_star.available && clip_star.owned)\n\tclip_auto_select();\n\n# if defined(FEAT_EVAL)\n    // Emit a TextYankPost for the automatic copy of the selection into the\n    // star and/or plus register.\n    if (has_textyankpost())\n    {\n\tif (clip_isautosel_star())\n\t    call_yank_do_autocmd('*');\n\tif (clip_isautosel_plus())\n\t    call_yank_do_autocmd('+');\n    }\n# endif\n#endif\n\n    VIsual_active = FALSE;\n    setmouse();\n    mouse_dragging = 0;\n\n    // Save the current VIsual area for '< and '> marks, and \"gv\"\n    curbuf->b_visual.vi_mode = VIsual_mode;\n    curbuf->b_visual.vi_start = VIsual;\n    curbuf->b_visual.vi_end = curwin->w_cursor;\n    curbuf->b_visual.vi_curswant = curwin->w_curswant;\n#ifdef FEAT_EVAL\n    curbuf->b_visual_mode_eval = VIsual_mode;\n#endif\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    may_clear_cmdline();\n\n    adjust_cursor_eol();\n    may_trigger_modechanged();\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect.\n */\n    void\nreset_VIsual_and_resel(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(UPD_INVERTED);\t// delete the inversion later\n    }\n    VIsual_reselect = FALSE;\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect if it's set.\n */\n    void\nreset_VIsual(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(UPD_INVERTED);\t// delete the inversion later\n\tVIsual_reselect = FALSE;\n    }\n}\n\n    void\nrestore_visual_mode(void)\n{\n    if (VIsual_mode_orig != NUL)\n    {\n\tcurbuf->b_visual.vi_mode = VIsual_mode_orig;\n\tVIsual_mode_orig = NUL;\n    }\n}\n\n/*\n * Check for a balloon-eval special item to include when searching for an\n * identifier.  When \"dir\" is BACKWARD \"ptr[-1]\" must be valid!\n * Returns TRUE if the character at \"*ptr\" should be included.\n * \"dir\" is FORWARD or BACKWARD, the direction of searching.\n * \"*colp\" is in/decremented if \"ptr[-dir]\" should also be included.\n * \"bnp\" points to a counter for square brackets.\n */\n    static int\nfind_is_eval_item(\n    char_u\t*ptr,\n    int\t\t*colp,\n    int\t\t*bnp,\n    int\t\tdir)\n{\n    // Accept everything inside [].\n    if ((*ptr == ']' && dir == BACKWARD) || (*ptr == '[' && dir == FORWARD))\n\t++*bnp;\n    if (*bnp > 0)\n    {\n\tif ((*ptr == '[' && dir == BACKWARD) || (*ptr == ']' && dir == FORWARD))\n\t    --*bnp;\n\treturn TRUE;\n    }\n\n    // skip over \"s.var\"\n    if (*ptr == '.')\n\treturn TRUE;\n\n    // two-character item: s->var\n    if (ptr[dir == BACKWARD ? 0 : 1] == '>'\n\t    && ptr[dir == BACKWARD ? -1 : 0] == '-')\n    {\n\t*colp += dir;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Find the identifier under or to the right of the cursor.\n * \"find_type\" can have one of three values:\n * FIND_IDENT:   find an identifier (keyword)\n * FIND_STRING:  find any non-white text\n * FIND_IDENT + FIND_STRING: find any non-white text, identifier preferred.\n * FIND_EVAL:\t find text useful for C program debugging\n *\n * There are three steps:\n * 1. Search forward for the start of an identifier/text.  Doesn't move if\n *    already on one.\n * 2. Search backward for the start of this identifier/text.\n *    This doesn't match the real Vi but I like it a little better and it\n *    shouldn't bother anyone.\n * 3. Search forward to the end of this identifier/text.\n *    When FIND_IDENT isn't defined, we backup until a blank.\n *\n * Returns the length of the text, or zero if no text is found.\n * If text is found, a pointer to the text is put in \"*text\".  This\n * points into the current buffer line and is not always NUL terminated.\n */\n    int\nfind_ident_under_cursor(char_u **text, int find_type)\n{\n    return find_ident_at_pos(curwin, curwin->w_cursor.lnum,\n\t\t\t\tcurwin->w_cursor.col, text, NULL, find_type);\n}\n\n/*\n * Like find_ident_under_cursor(), but for any window and any position.\n * However: Uses 'iskeyword' from the current window!.\n */\n    int\nfind_ident_at_pos(\n    win_T\t*wp,\n    linenr_T\tlnum,\n    colnr_T\tstartcol,\n    char_u\t**text,\n    int\t\t*textcol,\t// column where \"text\" starts, can be NULL\n    int\t\tfind_type)\n{\n    char_u\t*ptr;\n    int\t\tcol = 0;\t// init to shut up GCC\n    int\t\ti;\n    int\t\tthis_class = 0;\n    int\t\tprev_class;\n    int\t\tprevcol;\n    int\t\tbn = 0;\t\t// bracket nesting\n\n    // if i == 0: try to find an identifier\n    // if i == 1: try to find any non-white text\n    ptr = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    for (i = (find_type & FIND_IDENT) ? 0 : 1;\ti < 2; ++i)\n    {\n\t/*\n\t * 1. skip to start of identifier/text\n\t */\n\tcol = startcol;\n\tif (has_mbyte)\n\t{\n\t    while (ptr[col] != NUL)\n\t    {\n\t\t// Stop at a ']' to evaluate \"a[x]\".\n\t\tif ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\t    break;\n\t\tthis_class = mb_get_class(ptr + col);\n\t\tif (this_class != 0 && (i == 1 || this_class != 1))\n\t\t    break;\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    }\n\t}\n\telse\n\t    while (ptr[col] != NUL\n\t\t    && (i == 0 ? !vim_iswordc(ptr[col]) : VIM_ISWHITE(ptr[col]))\n\t\t    && (!(find_type & FIND_EVAL) || ptr[col] != ']')\n\t\t    )\n\t\t++col;\n\n\t// When starting on a ']' count it, so that we include the '['.\n\tbn = ptr[col] == ']';\n\n\t/*\n\t * 2. Back up to start of identifier/text.\n\t */\n\tif (has_mbyte)\n\t{\n\t    // Remember class of character under cursor.\n\t    if ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\tthis_class = mb_get_class((char_u *)\"a\");\n\t    else\n\t\tthis_class = mb_get_class(ptr + col);\n\t    while (col > 0 && this_class != 0)\n\t    {\n\t\tprevcol = col - 1 - (*mb_head_off)(ptr, ptr + col - 1);\n\t\tprev_class = mb_get_class(ptr + prevcol);\n\t\tif (this_class != prev_class\n\t\t\t&& (i == 0\n\t\t\t    || prev_class == 0\n\t\t\t    || (find_type & FIND_IDENT))\n\t\t\t&& (!(find_type & FIND_EVAL)\n\t\t\t    || prevcol == 0\n\t\t\t    || !find_is_eval_item(ptr + prevcol, &prevcol,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t)\n\t\t    break;\n\t\tcol = prevcol;\n\t    }\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (this_class > 2)\n\t\tthis_class = 2;\n\t    if (!(find_type & FIND_STRING) || this_class == 2)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    while (col > 0\n\t\t    && ((i == 0\n\t\t\t    ? vim_iswordc(ptr[col - 1])\n\t\t\t    : (!VIM_ISWHITE(ptr[col - 1])\n\t\t\t\t&& (!(find_type & FIND_IDENT)\n\t\t\t\t    || !vim_iswordc(ptr[col - 1]))))\n\t\t\t|| ((find_type & FIND_EVAL)\n\t\t\t    && col > 1\n\t\t\t    && find_is_eval_item(ptr + col - 1, &col,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t))\n\t\t--col;\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (!(find_type & FIND_STRING) || vim_iswordc(ptr[col]))\n\t\tbreak;\n\t}\n    }\n\n    if (ptr[col] == NUL || (i == 0\n\t\t&& (has_mbyte ? this_class != 2 : !vim_iswordc(ptr[col]))))\n    {\n\t// didn't find an identifier or text\n\tif ((find_type & FIND_NOERROR) == 0)\n\t{\n\t    if (find_type & FIND_STRING)\n\t\temsg(_(e_no_string_under_cursor));\n\t    else\n\t\temsg(_(e_no_identifier_under_cursor));\n\t}\n\treturn 0;\n    }\n    ptr += col;\n    *text = ptr;\n    if (textcol != NULL)\n\t*textcol = col;\n\n    /*\n     * 3. Find the end if the identifier/text.\n     */\n    bn = 0;\n    startcol -= col;\n    col = 0;\n    if (has_mbyte)\n    {\n\t// Search for point of changing multibyte character class.\n\tthis_class = mb_get_class(ptr);\n\twhile (ptr[col] != NUL\n\t\t&& ((i == 0 ? mb_get_class(ptr + col) == this_class\n\t\t\t    : mb_get_class(ptr + col) != 0)\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t))\n\t    col += (*mb_ptr2len)(ptr + col);\n    }\n    else\n\twhile ((i == 0 ? vim_iswordc(ptr[col])\n\t\t       : (ptr[col] != NUL && !VIM_ISWHITE(ptr[col])))\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t)\n\t    ++col;\n\n    return col;\n}\n\n/*\n * Prepare for redo of a normal command.\n */\n    static void\nprep_redo_cmd(cmdarg_T *cap)\n{\n    prep_redo(cap->oap->regname, cap->count0,\n\t\t\t\t     NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n}\n\n/*\n * Prepare for redo of any command.\n * Note that only the last argument can be a multi-byte char.\n */\n    void\nprep_redo(\n    int\t    regname,\n    long    num,\n    int\t    cmd1,\n    int\t    cmd2,\n    int\t    cmd3,\n    int\t    cmd4,\n    int\t    cmd5)\n{\n    prep_redo_num2(regname, num, cmd1, cmd2, 0L, cmd3, cmd4, cmd5);\n}\n\n/*\n * Prepare for redo of any command with extra count after \"cmd2\".\n */\n    void\nprep_redo_num2(\n    int\t    regname,\n    long    num1,\n    int\t    cmd1,\n    int\t    cmd2,\n    long    num2,\n    int\t    cmd3,\n    int\t    cmd4,\n    int\t    cmd5)\n{\n    ResetRedobuff();\n\n#ifdef FEAT_EVAL\n    // Put info about a mapping in the redo buffer, so that \".\" will use the\n    // same script context.\n    may_add_last_used_map_to_redobuff();\n#endif\n\n    if (regname != 0)\t// yank from specified buffer\n    {\n\tAppendCharToRedobuff('\"');\n\tAppendCharToRedobuff(regname);\n    }\n    if (num1 != 0)\n\tAppendNumberToRedobuff(num1);\n    if (cmd1 != NUL)\n\tAppendCharToRedobuff(cmd1);\n    if (cmd2 != NUL)\n\tAppendCharToRedobuff(cmd2);\n    if (num2 != 0)\n\tAppendNumberToRedobuff(num2);\n    if (cmd3 != NUL)\n\tAppendCharToRedobuff(cmd3);\n    if (cmd4 != NUL)\n\tAppendCharToRedobuff(cmd4);\n    if (cmd5 != NUL)\n\tAppendCharToRedobuff(cmd5);\n}\n\n/*\n * Check for operator active and clear it.\n *\n * Beep and return TRUE if an operator was active.\n */\n    static int\ncheckclearop(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n/*\n * Check for operator or Visual active.  Clear active operator.\n *\n * Beep and return TRUE if an operator or Visual was active.\n */\n    static int\ncheckclearopq(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP && !VIsual_active)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n    void\nclearop(oparg_T *oap)\n{\n    oap->op_type = OP_NOP;\n    oap->regname = 0;\n    oap->motion_force = NUL;\n    oap->use_reg_one = FALSE;\n    motion_force = NUL;\n}\n\n    void\nclearopbeep(oparg_T *oap)\n{\n    clearop(oap);\n    beep_flush();\n}\n\n/*\n * Remove the shift modifier from a special key.\n */\n    static void\nunshift_special(cmdarg_T *cap)\n{\n    switch (cap->cmdchar)\n    {\n\tcase K_S_RIGHT:\tcap->cmdchar = K_RIGHT; break;\n\tcase K_S_LEFT:\tcap->cmdchar = K_LEFT; break;\n\tcase K_S_UP:\tcap->cmdchar = K_UP; break;\n\tcase K_S_DOWN:\tcap->cmdchar = K_DOWN; break;\n\tcase K_S_HOME:\tcap->cmdchar = K_HOME; break;\n\tcase K_S_END:\tcap->cmdchar = K_END; break;\n    }\n    cap->cmdchar = simplify_key(cap->cmdchar, &mod_mask);\n}\n\n/*\n * If the mode is currently displayed clear the command line or update the\n * command displayed.\n */\n    void\nmay_clear_cmdline(void)\n{\n    if (mode_displayed)\n\tclear_cmdline = TRUE;   // unshow visual mode later\n    else\n\tclear_showcmd();\n}\n\n/*\n * Routines for displaying a partly typed command\n */\n\nstatic char_u\told_showcmd_buf[SHOWCMD_BUFLEN];  // For push_showcmd()\nstatic int\tshowcmd_is_clear = TRUE;\nstatic int\tshowcmd_visual = FALSE;\n\nstatic void display_showcmd(void);\n\n    void\nclear_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    if (VIsual_active && !char_avail())\n    {\n\tint\t\tcursor_bot = LT_POS(VIsual, curwin->w_cursor);\n\tlong\t\tlines;\n\tcolnr_T\t\tleftcol, rightcol;\n\tlinenr_T\ttop, bot;\n\n\t// Show the size of the Visual area.\n\tif (cursor_bot)\n\t{\n\t    top = VIsual.lnum;\n\t    bot = curwin->w_cursor.lnum;\n\t}\n\telse\n\t{\n\t    top = curwin->w_cursor.lnum;\n\t    bot = VIsual.lnum;\n\t}\n# ifdef FEAT_FOLDING\n\t// Include closed folds as a whole.\n\t(void)hasFolding(top, &top, NULL);\n\t(void)hasFolding(bot, NULL, &bot);\n# endif\n\tlines = bot - top + 1;\n\n\tif (VIsual_mode == Ctrl_V)\n\t{\n# ifdef FEAT_LINEBREAK\n\t    char_u *saved_sbr = p_sbr;\n\t    char_u *saved_w_sbr = curwin->w_p_sbr;\n\n\t    // Make 'sbr' empty for a moment to get the correct size.\n\t    p_sbr = empty_option;\n\t    curwin->w_p_sbr = empty_option;\n# endif\n\t    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);\n# ifdef FEAT_LINEBREAK\n\t    p_sbr = saved_sbr;\n\t    curwin->w_p_sbr = saved_w_sbr;\n# endif\n\t    sprintf((char *)showcmd_buf, \"%ldx%ld\", lines,\n\t\t\t\t\t      (long)(rightcol - leftcol + 1));\n\t}\n\telse if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)\n\t    sprintf((char *)showcmd_buf, \"%ld\", lines);\n\telse\n\t{\n\t    char_u  *s, *e;\n\t    int\t    l;\n\t    int\t    bytes = 0;\n\t    int\t    chars = 0;\n\n\t    if (cursor_bot)\n\t    {\n\t\ts = ml_get_pos(&VIsual);\n\t\te = ml_get_cursor();\n\t    }\n\t    else\n\t    {\n\t\ts = ml_get_cursor();\n\t\te = ml_get_pos(&VIsual);\n\t    }\n\t    while ((*p_sel != 'e') ? s <= e : s < e)\n\t    {\n\t\tl = (*mb_ptr2len)(s);\n\t\tif (l == 0)\n\t\t{\n\t\t    ++bytes;\n\t\t    ++chars;\n\t\t    break;  // end of line\n\t\t}\n\t\tbytes += l;\n\t\t++chars;\n\t\ts += l;\n\t    }\n\t    if (bytes == chars)\n\t\tsprintf((char *)showcmd_buf, \"%d\", chars);\n\t    else\n\t\tsprintf((char *)showcmd_buf, \"%d-%d\", chars, bytes);\n\t}\n\tshowcmd_buf[SHOWCMD_COLS] = NUL;\t// truncate\n\tshowcmd_visual = TRUE;\n    }\n    else\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n\n\t// Don't actually display something if there is nothing to clear.\n\tif (showcmd_is_clear)\n\t    return;\n    }\n\n    display_showcmd();\n}\n\n/*\n * Add 'c' to string of shown command chars.\n * Return TRUE if output has been written (and setcursor() has been called).\n */\n    int\nadd_to_showcmd(int c)\n{\n    char_u\t*p;\n    int\t\told_len;\n    int\t\textra_len;\n    int\t\toverflow;\n    int\t\ti;\n    static int\tignore[] =\n    {\n#ifdef FEAT_GUI\n\tK_VER_SCROLLBAR, K_HOR_SCROLLBAR,\n\tK_LEFTMOUSE_NM, K_LEFTRELEASE_NM,\n#endif\n\tK_IGNORE, K_PS,\n\tK_LEFTMOUSE, K_LEFTDRAG, K_LEFTRELEASE, K_MOUSEMOVE,\n\tK_MIDDLEMOUSE, K_MIDDLEDRAG, K_MIDDLERELEASE,\n\tK_RIGHTMOUSE, K_RIGHTDRAG, K_RIGHTRELEASE,\n\tK_MOUSEDOWN, K_MOUSEUP, K_MOUSELEFT, K_MOUSERIGHT,\n\tK_X1MOUSE, K_X1DRAG, K_X1RELEASE, K_X2MOUSE, K_X2DRAG, K_X2RELEASE,\n\tK_CURSORHOLD,\n\t0\n    };\n\n    if (!p_sc || msg_silent != 0)\n\treturn FALSE;\n\n    if (showcmd_visual)\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n    }\n\n    // Ignore keys that are scrollbar updates and mouse clicks\n    if (IS_SPECIAL(c))\n\tfor (i = 0; ignore[i] != 0; ++i)\n\t    if (ignore[i] == c)\n\t\treturn FALSE;\n\n    p = transchar(c);\n    if (*p == ' ')\n\tSTRCPY(p, \"<20>\");\n    old_len = (int)STRLEN(showcmd_buf);\n    extra_len = (int)STRLEN(p);\n    overflow = old_len + extra_len - SHOWCMD_COLS;\n    if (overflow > 0)\n\tmch_memmove(showcmd_buf, showcmd_buf + overflow,\n\t\t\t\t\t\t      old_len - overflow + 1);\n    STRCAT(showcmd_buf, p);\n\n    if (char_avail())\n\treturn FALSE;\n\n    display_showcmd();\n\n    return TRUE;\n}\n\n    void\nadd_to_showcmd_c(int c)\n{\n    if (!add_to_showcmd(c))\n\tsetcursor();\n}\n\n/*\n * Delete 'len' characters from the end of the shown command.\n */\n    static void\ndel_from_showcmd(int len)\n{\n    int\t    old_len;\n\n    if (!p_sc)\n\treturn;\n\n    old_len = (int)STRLEN(showcmd_buf);\n    if (len > old_len)\n\tlen = old_len;\n    showcmd_buf[old_len - len] = NUL;\n\n    if (!char_avail())\n\tdisplay_showcmd();\n}\n\n/*\n * push_showcmd() and pop_showcmd() are used when waiting for the user to type\n * something and there is a partial mapping.\n */\n    void\npush_showcmd(void)\n{\n    if (p_sc)\n\tSTRCPY(old_showcmd_buf, showcmd_buf);\n}\n\n    void\npop_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    STRCPY(showcmd_buf, old_showcmd_buf);\n\n    display_showcmd();\n}\n\n    static void\ndisplay_showcmd(void)\n{\n    int\t    len = (int)STRLEN(showcmd_buf);\n\n    showcmd_is_clear = (len == 0);\n    cursor_off();\n\n    if (*p_sloc == 's')\n    {\n\tif (showcmd_is_clear)\n\t    curwin->w_redr_status = TRUE;\n\telse\n\t    win_redr_status(curwin, FALSE);\n    }\n    else if (*p_sloc == 't')\n    {\n\tif (showcmd_is_clear)\n\t    redraw_tabline = TRUE;\n\telse\n\t    draw_tabline();\n    }\n    else // 'showcmdloc' is \"last\" or empty\n    {\n\tif (!showcmd_is_clear)\n\t    screen_puts(showcmd_buf, (int)Rows - 1, sc_col, 0);\n\n\t// clear the rest of an old message by outputting up to SHOWCMD_COLS\n\t// spaces\n\tscreen_puts((char_u *)\"          \" + len,\n\t\t\t\t\t\t(int)Rows - 1, sc_col + len, 0);\n    }\n\n    setcursor();\t    // put cursor back where it belongs\n}\n\n/*\n * When \"check\" is FALSE, prepare for commands that scroll the window.\n * When \"check\" is TRUE, take care of scroll-binding after the window has\n * scrolled.  Called from normal_cmd() and edit().\n */\n    void\ndo_check_scrollbind(int check)\n{\n    static win_T\t*old_curwin = NULL;\n    static linenr_T\told_topline = 0;\n#ifdef FEAT_DIFF\n    static int\t\told_topfill = 0;\n#endif\n    static buf_T\t*old_buf = NULL;\n    static colnr_T\told_leftcol = 0;\n\n    if (check && curwin->w_p_scb)\n    {\n\t// If a \":syncbind\" command was just used, don't scroll, only reset\n\t// the values.\n\tif (did_syncbind)\n\t    did_syncbind = FALSE;\n\telse if (curwin == old_curwin)\n\t{\n\t    // Synchronize other windows, as necessary according to\n\t    // 'scrollbind'.  Don't do this after an \":edit\" command, except\n\t    // when 'diff' is set.\n\t    if ((curwin->w_buffer == old_buf\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_p_diff\n#endif\n\t\t)\n\t\t&& (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t\t|| curwin->w_leftcol != old_leftcol))\n\t    {\n\t\tcheck_scrollbind(curwin->w_topline - old_topline,\n\t\t\t(long)(curwin->w_leftcol - old_leftcol));\n\t    }\n\t}\n\telse if (vim_strchr(p_sbo, 'j')) // jump flag set in 'scrollopt'\n\t{\n\t    // When switching between windows, make sure that the relative\n\t    // vertical offset is valid for the new window.  The relative\n\t    // offset is invalid whenever another 'scrollbind' window has\n\t    // scrolled to a point that would force the current window to\n\t    // scroll past the beginning or end of its buffer.  When the\n\t    // resync is performed, some of the other 'scrollbind' windows may\n\t    // need to jump so that the current window's relative position is\n\t    // visible on-screen.\n\t    check_scrollbind(curwin->w_topline - curwin->w_scbind_pos, 0L);\n\t}\n\tcurwin->w_scbind_pos = curwin->w_topline;\n    }\n\n    old_curwin = curwin;\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n    old_buf = curwin->w_buffer;\n    old_leftcol = curwin->w_leftcol;\n}\n\n/*\n * Synchronize any windows that have \"scrollbind\" set, based on the\n * number of rows by which the current window has changed\n * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)\n */\n    void\ncheck_scrollbind(linenr_T topline_diff, long leftcol_diff)\n{\n    int\t\twant_ver;\n    int\t\twant_hor;\n    win_T\t*old_curwin = curwin;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\told_VIsual_select = VIsual_select;\n    int\t\told_VIsual_active = VIsual_active;\n    colnr_T\ttgt_leftcol = curwin->w_leftcol;\n    long\ttopline;\n    long\ty;\n\n    // check 'scrollopt' string for vertical and horizontal scroll options\n    want_ver = (vim_strchr(p_sbo, 'v') && topline_diff != 0);\n#ifdef FEAT_DIFF\n    want_ver |= old_curwin->w_p_diff;\n#endif\n    want_hor = (vim_strchr(p_sbo, 'h') && (leftcol_diff || topline_diff != 0));\n\n    // loop through the scrollbound windows and scroll accordingly\n    VIsual_select = VIsual_active = 0;\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tcurbuf = curwin->w_buffer;\n\t// skip original window and windows with 'noscrollbind'\n\tif (curwin == old_curwin || !curwin->w_p_scb)\n\t    continue;\n\n\t// do the vertical scroll\n\tif (want_ver)\n\t{\n#ifdef FEAT_DIFF\n\t    if (old_curwin->w_p_diff && curwin->w_p_diff)\n\t    {\n\t\tdiff_set_topline(old_curwin, curwin);\n\t    }\n\t    else\n#endif\n\t    {\n\t\tcurwin->w_scbind_pos += topline_diff;\n\t\ttopline = curwin->w_scbind_pos;\n\t\tif (topline > curbuf->b_ml.ml_line_count)\n\t\t    topline = curbuf->b_ml.ml_line_count;\n\t\tif (topline < 1)\n\t\t    topline = 1;\n\n\t\ty = topline - curwin->w_topline;\n\t\tif (y > 0)\n\t\t    scrollup(y, FALSE);\n\t\telse\n\t\t    scrolldown(-y, FALSE);\n\t    }\n\n\t    redraw_later(UPD_VALID);\n\t    cursor_correct();\n\t    curwin->w_redr_status = TRUE;\n\t}\n\n\t// do the horizontal scroll\n\tif (want_hor)\n\t    (void)set_leftcol(tgt_leftcol);\n    }\n\n    // reset current-window\n    VIsual_select = old_VIsual_select;\n    VIsual_active = old_VIsual_active;\n    curwin = old_curwin;\n    curbuf = old_curbuf;\n}\n\n/*\n * Command character that's ignored.\n * Used for CTRL-Q and CTRL-S to avoid problems with terminals that use\n * xon/xoff.\n */\n    static void\nnv_ignore(cmdarg_T *cap)\n{\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n\n/*\n * Command character that doesn't do anything, but unlike nv_ignore() does\n * start edit().  Used for \"startinsert\" executed while starting up.\n */\n    static void\nnv_nop(cmdarg_T *cap UNUSED)\n{\n}\n\n/*\n * Command character doesn't exist.\n */\n    static void\nnv_error(cmdarg_T *cap)\n{\n    clearopbeep(cap->oap);\n}\n\n/*\n * <Help> and <F1> commands.\n */\n    static void\nnv_help(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tex_help(NULL);\n}\n\n/*\n * CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.\n */\n    static void\nnv_addsub(cmdarg_T *cap)\n{\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n\tclearopbeep(cap->oap);\n    else\n#endif\n    if (!VIsual_active && cap->oap->op_type == OP_NOP)\n    {\n\tprep_redo_cmd(cap);\n\tcap->oap->op_type = cap->cmdchar == Ctrl_A ?  OP_NR_ADD : OP_NR_SUB;\n\top_addsub(cap->oap, cap->count1, cap->arg);\n\tcap->oap->op_type = OP_NOP;\n    }\n    else if (VIsual_active)\n\tnv_operator(cap);\n    else\n\tclearop(cap->oap);\n}\n\n/*\n * CTRL-F, CTRL-B, etc: Scroll page up or down.\n */\n    static void\nnv_page(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n\n    if (mod_mask & MOD_MASK_CTRL)\n    {\n\t// <C-PageUp>: tab page back; <C-PageDown>: tab page forward\n\tif (cap->arg == BACKWARD)\n\t    goto_tabpage(-(int)cap->count1);\n\telse\n\t    goto_tabpage((int)cap->count0);\n    }\n    else\n\t(void)onepage(cap->arg, cap->count1);\n}\n\n/*\n * Implementation of \"gd\" and \"gD\" command.\n */\n    static void\nnv_gd(\n    oparg_T\t*oap,\n    int\t\tnchar,\n    int\t\tthisblock)\t// 1 for \"1gd\" and \"1gD\"\n{\n    int\t\tlen;\n    char_u\t*ptr;\n\n    if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0\n\t    || find_decl(ptr, len, nchar == 'd', thisblock, SEARCH_START)\n\t\t\t\t\t\t\t\t       == FAIL)\n    {\n\tclearopbeep(oap);\n\treturn;\n    }\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_SEARCH) && KeyTyped && oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n    // clear any search statistics\n    if (messaging() && !msg_silent && !shortmess(SHM_SEARCHCOUNT))\n\tclear_cmdline = TRUE;\n}\n\n/*\n * Return TRUE if line[offset] is not inside a C-style comment or string, FALSE\n * otherwise.\n */\n    static int\nis_ident(char_u *line, int offset)\n{\n    int\ti;\n    int\tincomment = FALSE;\n    int\tinstring = 0;\n    int\tprev = 0;\n\n    for (i = 0; i < offset && line[i] != NUL; i++)\n    {\n\tif (instring != 0)\n\t{\n\t    if (prev != '\\\\' && line[i] == instring)\n\t\tinstring = 0;\n\t}\n\telse if ((line[i] == '\"' || line[i] == '\\'') && !incomment)\n\t{\n\t    instring = line[i];\n\t}\n\telse\n\t{\n\t    if (incomment)\n\t    {\n\t\tif (prev == '*' && line[i] == '/')\n\t\t    incomment = FALSE;\n\t    }\n\t    else if (prev == '/' && line[i] == '*')\n\t    {\n\t\tincomment = TRUE;\n\t    }\n\t    else if (prev == '/' && line[i] == '/')\n\t    {\n\t\treturn FALSE;\n\t    }\n\t}\n\n\tprev = line[i];\n    }\n\n    return incomment == FALSE && instring == 0;\n}\n\n/*\n * Search for variable declaration of \"ptr[len]\".\n * When \"locally\" is TRUE in the current function (\"gd\"), otherwise in the\n * current file (\"gD\").\n * When \"thisblock\" is TRUE check the {} block scope.\n * Return FAIL when not found.\n */\n    int\nfind_decl(\n    char_u\t*ptr,\n    int\t\tlen,\n    int\t\tlocally,\n    int\t\tthisblock,\n    int\t\tflags_arg)\t// flags passed to searchit()\n{\n    char_u\t*pat;\n    pos_T\told_pos;\n    pos_T\tpar_pos;\n    pos_T\tfound_pos;\n    int\t\tt;\n    int\t\tsave_p_ws;\n    int\t\tsave_p_scs;\n    int\t\tretval = OK;\n    int\t\tincll;\n    int\t\tsearchflags = flags_arg;\n    int\t\tvalid;\n\n    if ((pat = alloc(len + 7)) == NULL)\n\treturn FAIL;\n\n    // Put \"\\V\" before the pattern to avoid that the special meaning of \".\"\n    // and \"~\" causes trouble.\n    sprintf((char *)pat, vim_iswordp(ptr) ? \"\\\\V\\\\<%.*s\\\\>\" : \"\\\\V%.*s\",\n\t\t\t\t\t\t\t\t    len, ptr);\n    old_pos = curwin->w_cursor;\n    save_p_ws = p_ws;\n    save_p_scs = p_scs;\n    p_ws = FALSE;\t// don't wrap around end of file now\n    p_scs = FALSE;\t// don't switch ignorecase off now\n\n    // With \"gD\" go to line 1.\n    // With \"gd\" Search back for the start of the current function, then go\n    // back until a blank line.  If this fails go to line 1.\n    if (!locally || !findpar(&incll, BACKWARD, 1L, '{', FALSE))\n    {\n\tsetpcmark();\t\t\t// Set in findpar() otherwise\n\tcurwin->w_cursor.lnum = 1;\n\tpar_pos = curwin->w_cursor;\n    }\n    else\n    {\n\tpar_pos = curwin->w_cursor;\n\twhile (curwin->w_cursor.lnum > 1 && *skipwhite(ml_get_curline()) != NUL)\n\t    --curwin->w_cursor.lnum;\n    }\n    curwin->w_cursor.col = 0;\n\n    // Search forward for the identifier, ignore comment lines.\n    CLEAR_POS(&found_pos);\n    for (;;)\n    {\n\tt = searchit(curwin, curbuf, &curwin->w_cursor, NULL, FORWARD,\n\t\t\t\t\t  pat, 1L, searchflags, RE_LAST, NULL);\n\tif (curwin->w_cursor.lnum >= old_pos.lnum)\n\t    t = FAIL;\t// match after start is failure too\n\n\tif (thisblock && t != FAIL)\n\t{\n\t    pos_T\t*pos;\n\n\t    // Check that the block the match is in doesn't end before the\n\t    // position where we started the search from.\n\t    if ((pos = findmatchlimit(NULL, '}', FM_FORWARD,\n\t\t     (int)(old_pos.lnum - curwin->w_cursor.lnum + 1))) != NULL\n\t\t    && pos->lnum < old_pos.lnum)\n\t    {\n\t\t// There can't be a useful match before the end of this block.\n\t\t// Skip to the end.\n\t\tcurwin->w_cursor = *pos;\n\t\tcontinue;\n\t    }\n\t}\n\n\tif (t == FAIL)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t    {\n\t\tcurwin->w_cursor = found_pos;\n\t\tt = OK;\n\t    }\n\t    break;\n\t}\n\tif (get_leader_len(ml_get_curline(), NULL, FALSE, TRUE) > 0)\n\t{\n\t    // Ignore this line, continue at start of next line.\n\t    ++curwin->w_cursor.lnum;\n\t    curwin->w_cursor.col = 0;\n\t    continue;\n\t}\n\tvalid = is_ident(ml_get_curline(), curwin->w_cursor.col);\n\n\t// If the current position is not a valid identifier and a previous\n\t// match is present, favor that one instead.\n\tif (!valid && found_pos.lnum != 0)\n\t{\n\t    curwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// Global search: use first valid match found\n\tif (valid && !locally)\n\t    break;\n\tif (valid && curwin->w_cursor.lnum >= par_pos.lnum)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t\tcurwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// For finding a local variable and the match is before the \"{\" or\n\t// inside a comment, continue searching.  For K&R style function\n\t// declarations this skips the function header without types.\n\tif (!valid)\n\t    CLEAR_POS(&found_pos);\n\telse\n\t    found_pos = curwin->w_cursor;\n\t// Remove SEARCH_START from flags to avoid getting stuck at one\n\t// position.\n\tsearchflags &= ~SEARCH_START;\n    }\n\n    if (t == FAIL)\n    {\n\tretval = FAIL;\n\tcurwin->w_cursor = old_pos;\n    }\n    else\n    {\n\tcurwin->w_set_curswant = TRUE;\n\t// \"n\" searches forward now\n\treset_search_dir();\n    }\n\n    vim_free(pat);\n    p_ws = save_p_ws;\n    p_scs = save_p_scs;\n\n    return retval;\n}\n\n/*\n * Move 'dist' lines in direction 'dir', counting lines by *screen*\n * lines rather than lines in the file.\n * 'dist' must be positive.\n *\n * Return OK if able to move cursor, FAIL otherwise.\n */\n    static int\nnv_screengo(oparg_T *oap, int dir, long dist)\n{\n    int\t\tlinelen = linetabsize(curwin, curwin->w_cursor.lnum);\n    int\t\tretval = OK;\n    int\t\tatend = FALSE;\n    int\t\tn;\n    int\t\tcol_off1;\t// margin offset for first screen line\n    int\t\tcol_off2;\t// margin offset for wrapped screen line\n    int\t\twidth1;\t\t// text width for first screen line\n    int\t\twidth2;\t\t// text width for wrapped screen line\n\n    oap->motion_type = MCHAR;\n    oap->inclusive = (curwin->w_curswant == MAXCOL);\n\n    col_off1 = curwin_col_off();\n    col_off2 = col_off1 - curwin_col_off2();\n    width1 = curwin->w_width - col_off1;\n    width2 = curwin->w_width - col_off2;\n    if (width2 == 0)\n\twidth2 = 1; // avoid divide by zero\n\n    if (curwin->w_width != 0)\n    {\n      // Instead of sticking at the last character of the buffer line we\n      // try to stick in the last column of the screen.\n      if (curwin->w_curswant == MAXCOL)\n      {\n\tatend = TRUE;\n\tvalidate_virtcol();\n\tif (width1 <= 0)\n\t    curwin->w_curswant = 0;\n\telse\n\t{\n\t    curwin->w_curswant = width1 - 1;\n\t    if (curwin->w_virtcol > curwin->w_curswant)\n\t\tcurwin->w_curswant += ((curwin->w_virtcol\n\t\t\t     - curwin->w_curswant - 1) / width2 + 1) * width2;\n\t}\n      }\n      else\n      {\n\tif (linelen > width1)\n\t    n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\telse\n\t    n = width1;\n\tif (curwin->w_curswant >= (colnr_T)n)\n\t    curwin->w_curswant = n - 1;\n      }\n\n      while (dist--)\n      {\n\tif (dir == BACKWARD)\n\t{\n\t    if ((long)curwin->w_curswant >= width1\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t       )\n\t\t// Move back within the line. This can give a negative value\n\t\t// for w_curswant if width1 < width2 (with cpoptions+=n),\n\t\t// which will get clipped to column 0.\n\t\tcurwin->w_curswant -= width2;\n\t    else\n\t    {\n\t\t// to previous line\n\t\tif (curwin->w_cursor.lnum <= 1)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\tcursor_up_inner(curwin, 1);\n\n\t\tlinelen = linetabsize(curwin, curwin->w_cursor.lnum);\n\t\tif (linelen > width1)\n\t\t    curwin->w_curswant += (((linelen - width1 - 1) / width2)\n\t\t\t\t\t\t\t\t+ 1) * width2;\n\t    }\n\t}\n\telse // dir == FORWARD\n\t{\n\t    if (linelen > width1)\n\t\tn = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\t    else\n\t\tn = width1;\n\t    if (curwin->w_curswant + width2 < (colnr_T)n\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t\t    )\n\t\t// move forward within line\n\t\tcurwin->w_curswant += width2;\n\t    else\n\t    {\n\t\t// to next line\n\t\tif (curwin->w_cursor.lnum\n\t\t\t\t       >= curwin->w_buffer->b_ml.ml_line_count)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\tcursor_down_inner(curwin, 1);\n\t\tcurwin->w_curswant %= width2;\n\n\t\t// Check if the cursor has moved below the number display\n\t\t// when width1 < width2 (with cpoptions+=n). Subtract width2\n\t\t// to get a negative value for w_curswant, which will get\n\t\t// clipped to column 0.\n\t\tif (curwin->w_curswant >= width1)\n\t\t    curwin->w_curswant -= width2;\n\t\tlinelen = linetabsize(curwin, curwin->w_cursor.lnum);\n\t    }\n\t}\n      }\n    }\n\n    if (virtual_active() && atend)\n\tcoladvance(MAXCOL);\n    else\n\tcoladvance(curwin->w_curswant);\n\n    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n    {\n\tcolnr_T virtcol;\n\tint\tc;\n\n\t// Check for landing on a character that got split at the end of the\n\t// last line.  We want to advance a screenline, not end up in the same\n\t// screenline or move two screenlines.\n\tvalidate_virtcol();\n\tvirtcol = curwin->w_virtcol;\n#if defined(FEAT_LINEBREAK)\n\tif (virtcol > (colnr_T)width1 && *get_showbreak_value(curwin) != NUL)\n\t    virtcol -= vim_strsize(get_showbreak_value(curwin));\n#endif\n\n\tc = (*mb_ptr2char)(ml_get_cursor());\n\tif (dir == FORWARD && virtcol < curwin->w_curswant\n\t\t&& (curwin->w_curswant <= (colnr_T)width1)\n\t\t&& !vim_isprintc(c) && c > 255)\n\t    oneright();\n\n\tif (virtcol > curwin->w_curswant\n\t\t&& (curwin->w_curswant < (colnr_T)width1\n\t\t    ? (curwin->w_curswant > (colnr_T)width1 / 2)\n\t\t    : ((curwin->w_curswant - width1) % width2\n\t\t\t\t\t\t      > (colnr_T)width2 / 2)))\n\t    --curwin->w_cursor.col;\n    }\n\n    if (atend)\n\tcurwin->w_curswant = MAXCOL;\t    // stick in the last column\n    adjust_skipcol();\n\n    return retval;\n}\n\n/*\n * Handle CTRL-E and CTRL-Y commands: scroll a line up or down.\n * cap->arg must be TRUE for CTRL-E.\n */\n    void\nnv_scroll_line(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n\tscroll_redraw(cap->arg, cap->count1);\n}\n\n/*\n * Scroll \"count\" lines up or down, and redraw.\n */\n    void\nscroll_redraw(int up, long count)\n{\n    linenr_T\tprev_topline = curwin->w_topline;\n    int\t\tprev_skipcol = curwin->w_skipcol;\n#ifdef FEAT_DIFF\n    int\t\tprev_topfill = curwin->w_topfill;\n#endif\n    linenr_T\tprev_lnum = curwin->w_cursor.lnum;\n\n    if (up)\n\tscrollup(count, TRUE);\n    else\n\tscrolldown(count, TRUE);\n    if (get_scrolloff_value() > 0)\n    {\n\t// Adjust the cursor position for 'scrolloff'.  Mark w_topline as\n\t// valid, otherwise the screen jumps back at the end of the file.\n\tcursor_correct();\n\tcheck_cursor_moved(curwin);\n\tcurwin->w_valid |= VALID_TOPLINE;\n\n\t// If moved back to where we were, at least move the cursor, otherwise\n\t// we get stuck at one position.  Don't move the cursor up if the\n\t// first line of the buffer is already on the screen\n\twhile (curwin->w_topline == prev_topline\n\t\t&& curwin->w_skipcol == prev_skipcol\n#ifdef FEAT_DIFF\n\t\t&& curwin->w_topfill == prev_topfill\n#endif\n\t\t)\n\t{\n\t    if (up)\n\t    {\n\t\tif (curwin->w_cursor.lnum > prev_lnum\n\t\t\t|| cursor_down(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    else\n\t    {\n\t\tif (curwin->w_cursor.lnum < prev_lnum\n\t\t\t|| prev_topline == 1L\n\t\t\t|| cursor_up(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    // Mark w_topline as valid, otherwise the screen jumps back at the\n\t    // end of the file.\n\t    check_cursor_moved(curwin);\n\t    curwin->w_valid |= VALID_TOPLINE;\n\t}\n    }\n    if (curwin->w_cursor.lnum != prev_lnum)\n\tcoladvance(curwin->w_curswant);\n    redraw_later(UPD_VALID);\n}\n\n/*\n * Get the count specified after a 'z' command. Only the 'z<CR>', 'zl', 'zh',\n * 'z<Left>', and 'z<Right>' commands accept a count after 'z'.\n * Returns TRUE to process the 'z' command and FALSE to skip it.\n */\n    static int\nnv_z_get_count(cmdarg_T *cap, int *nchar_arg)\n{\n    int\t\tnchar = *nchar_arg;\n    long\tn;\n\n    // \"z123{nchar}\": edit the count before obtaining {nchar}\n    if (checkclearop(cap->oap))\n\treturn FALSE;\n    n = nchar - '0';\n\n    for (;;)\n    {\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t++no_mapping;\n\t++allow_keys;   // no mapping for nchar, but allow key codes\n\tnchar = plain_vgetc();\n\tLANGMAP_ADJUST(nchar, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\t(void)add_to_showcmd(nchar);\n\n\tif (nchar == K_DEL || nchar == K_KDEL)\n\t    n /= 10;\n\telse if (VIM_ISDIGIT(nchar))\n\t    n = n * 10 + (nchar - '0');\n\telse if (nchar == CAR)\n\t{\n#ifdef FEAT_GUI\n\t    need_mouse_correct = TRUE;\n#endif\n\t    win_setheight((int)n);\n\t    break;\n\t}\n\telse if (nchar == 'l'\n\t\t|| nchar == 'h'\n\t\t|| nchar == K_LEFT\n\t\t|| nchar == K_RIGHT)\n\t{\n\t    cap->count1 = n ? n * cap->count1 : cap->count1;\n\t    *nchar_arg = nchar;\n\t    return TRUE;\n\t}\n\telse\n\t{\n\t    clearopbeep(cap->oap);\n\t    break;\n\t}\n    }\n    cap->oap->op_type = OP_NOP;\n    return FALSE;\n}\n\n#ifdef FEAT_SPELL\n/*\n * \"zug\" and \"zuw\": undo \"zg\" and \"zw\"\n * \"zg\": add good word to word list\n * \"zw\": add wrong word to word list\n * \"zG\": add good word to temp word list\n * \"zW\": add wrong word to temp word list\n */\n    static int\nnv_zg_zw(cmdarg_T *cap, int nchar)\n{\n    char_u\t*ptr = NULL;\n    int\t\tlen;\n    int\t\tundo = FALSE;\n\n    if (nchar == 'u')\n    {\n\t++no_mapping;\n\t++allow_keys;   // no mapping for nchar, but allow key codes\n\tnchar = plain_vgetc();\n\tLANGMAP_ADJUST(nchar, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\t(void)add_to_showcmd(nchar);\n\n\tif (vim_strchr((char_u *)\"gGwW\", nchar) == NULL)\n\t{\n\t    clearopbeep(cap->oap);\n\t    return OK;\n\t}\n\tundo = TRUE;\n    }\n\n    if (checkclearop(cap->oap))\n\treturn OK;\n    if (VIsual_active && get_visual_text(cap, &ptr, &len) == FAIL)\n\treturn FAIL;\n    if (ptr == NULL)\n    {\n\tpos_T\tpos = curwin->w_cursor;\n\n\t// Find bad word under the cursor.  When 'spell' is\n\t// off this fails and find_ident_under_cursor() is\n\t// used below.\n\temsg_off++;\n\tlen = spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL);\n\temsg_off--;\n\tif (len != 0 && curwin->w_cursor.col <= pos.col)\n\t    ptr = ml_get_pos(&curwin->w_cursor);\n\tcurwin->w_cursor = pos;\n    }\n\n    if (ptr == NULL\n\t\t&& (len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\treturn FAIL;\n    spell_add_word(ptr, len, nchar == 'w' || nchar == 'W'\n\t    ? SPELL_ADD_BAD : SPELL_ADD_GOOD,\n\t    (nchar == 'G' || nchar == 'W') ? 0 : (int)cap->count1, undo);\n\n    return OK;\n}\n#endif\n\n/*\n * Commands that start with \"z\".\n */\n    static void\nnv_zet(cmdarg_T *cap)\n{\n    long\tn;\n    colnr_T\tcol;\n    int\t\tnchar = cap->nchar;\n#ifdef FEAT_FOLDING\n    long\told_fdl = curwin->w_p_fdl;\n    int\t\told_fen = curwin->w_p_fen;\n#endif\n    long\tsiso = get_sidescrolloff_value();\n\n    if (VIM_ISDIGIT(nchar) && !nv_z_get_count(cap, &nchar))\n\t    return;\n\n    if (\n#ifdef FEAT_FOLDING\n\t    // \"zf\" and \"zF\" are always an operator, \"zd\", \"zo\", \"zO\", \"zc\"\n\t    // and \"zC\" only in Visual mode.  \"zj\" and \"zk\" are motion\n\t    // commands.\n\t    cap->nchar != 'f' && cap->nchar != 'F'\n\t    && !(VIsual_active && vim_strchr((char_u *)\"dcCoO\", cap->nchar))\n\t    && cap->nchar != 'j' && cap->nchar != 'k'\n\t    &&\n#endif\n\t    checkclearop(cap->oap))\n\treturn;\n\n    // For \"z+\", \"z<CR>\", \"zt\", \"z.\", \"zz\", \"z^\", \"z-\", \"zb\":\n    // If line number given, set cursor.\n    if ((vim_strchr((char_u *)\"+\\r\\nt.z^-b\", nchar) != NULL)\n\t    && cap->count0\n\t    && cap->count0 != curwin->w_cursor.lnum)\n    {\n\tsetpcmark();\n\tif (cap->count0 > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\telse\n\t    curwin->w_cursor.lnum = cap->count0;\n\tcheck_cursor_col();\n    }\n\n    switch (nchar)\n    {\n\t\t// \"z+\", \"z<CR>\" and \"zt\": put cursor at top of screen\n    case '+':\n\t\tif (cap->count0 == 0)\n\t\t{\n\t\t    // No count given: put cursor at the line below screen\n\t\t    validate_botline();\t// make sure w_botline is valid\n\t\t    if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = curwin->w_botline;\n\t\t}\n\t\t// FALLTHROUGH\n    case NL:\n    case CAR:\n    case K_KENTER:\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 't':\tscroll_cursor_top(0, TRUE);\n\t\tredraw_later(UPD_VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z.\" and \"zz\": put cursor in middle of screen\n    case '.':\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'z':\tscroll_cursor_halfway(TRUE, FALSE);\n\t\tredraw_later(UPD_VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z^\", \"z-\" and \"zb\": put cursor at bottom of screen\n    case '^':\t// Strange Vi behavior: <count>z^ finds line at top of window\n\t\t// when <count> is at bottom of window, and puts that one at\n\t\t// bottom of window.\n\t\tif (cap->count0 != 0)\n\t\t{\n\t\t    scroll_cursor_bot(0, TRUE);\n\t\t    curwin->w_cursor.lnum = curwin->w_topline;\n\t\t}\n\t\telse if (curwin->w_topline == 1)\n\t\t    curwin->w_cursor.lnum = 1;\n\t\telse\n\t\t    curwin->w_cursor.lnum = curwin->w_topline - 1;\n\t\t// FALLTHROUGH\n    case '-':\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'b':\tscroll_cursor_bot(0, TRUE);\n\t\tredraw_later(UPD_VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"zH\" - scroll screen right half-page\n    case 'H':\n\t\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zh\" - scroll screen to the right\n    case 'h':\n    case K_LEFT:\n\t\tif (!curwin->w_p_wrap)\n\t\t    (void)set_leftcol((colnr_T)cap->count1 > curwin->w_leftcol\n\t\t\t       ? 0 : curwin->w_leftcol - (colnr_T)cap->count1);\n\t\tbreak;\n\n\t\t// \"zL\" - scroll window left half-page\n    case 'L':\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zl\" - scroll window to the left if not wrapping\n    case 'l':\n    case K_RIGHT:\n\t\tif (!curwin->w_p_wrap)\n\t\t    (void)set_leftcol(curwin->w_leftcol + (colnr_T)cap->count1);\n\t\tbreak;\n\n\t\t// \"zs\" - scroll screen, cursor at the start\n    case 's':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, NULL);\n\t\t    if ((long)col > siso)\n\t\t\tcol -= siso;\n\t\t    else\n\t\t\tcol = 0;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(UPD_NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"ze\" - scroll screen, cursor at the end\n    case 'e':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\t\t    n = curwin->w_width - curwin_col_off();\n\t\t    if ((long)col + siso < n)\n\t\t\tcol = 0;\n\t\t    else\n\t\t\tcol = col + siso - n + 1;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(UPD_NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"zp\", \"zP\" in block mode put without addind trailing spaces\n    case 'P':\n    case 'p':  nv_put(cap);\n\t       break;\n\t\t// \"zy\" Yank without trailing spaces\n    case 'y':  nv_operator(cap);\n\t       break;\n#ifdef FEAT_FOLDING\n\t\t// \"zF\": create fold command\n\t\t// \"zf\": create fold operator\n    case 'F':\n    case 'f':   if (foldManualAllowed(TRUE))\n\t\t{\n\t\t    cap->nchar = 'f';\n\t\t    nv_operator(cap);\n\t\t    curwin->w_p_fen = TRUE;\n\n\t\t    // \"zF\" is like \"zfzf\"\n\t\t    if (nchar == 'F' && cap->oap->op_type == OP_FOLD)\n\t\t    {\n\t\t\tnv_operator(cap);\n\t\t\tfinish_op = TRUE;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n\t\t// \"zd\": delete fold at cursor\n\t\t// \"zD\": delete fold at cursor recursively\n    case 'd':\n    case 'D':\tif (foldManualAllowed(FALSE))\n\t\t{\n\t\t    if (VIsual_active)\n\t\t\tnv_operator(cap);\n\t\t    else\n\t\t\tdeleteFold(curwin->w_cursor.lnum,\n\t\t\t\t  curwin->w_cursor.lnum, nchar == 'D', FALSE);\n\t\t}\n\t\tbreak;\n\n\t\t// \"zE\": erase all folds\n    case 'E':\tif (foldmethodIsManual(curwin))\n\t\t{\n\t\t    clearFolding(curwin);\n\t\t    changed_window_setting();\n\t\t}\n\t\telse if (foldmethodIsMarker(curwin))\n\t\t    deleteFold((linenr_T)1, curbuf->b_ml.ml_line_count,\n\t\t\t\t\t\t\t\t TRUE, FALSE);\n\t\telse\n\t\t    emsg(_(e_cannot_erase_folds_with_current_foldmethod));\n\t\tbreak;\n\n\t\t// \"zn\": fold none: reset 'foldenable'\n    case 'n':\tcurwin->w_p_fen = FALSE;\n\t\tbreak;\n\n\t\t// \"zN\": fold Normal: set 'foldenable'\n    case 'N':\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zi\": invert folding: toggle 'foldenable'\n    case 'i':\tcurwin->w_p_fen = !curwin->w_p_fen;\n\t\tbreak;\n\n\t\t// \"za\": open closed fold or close open fold at cursor\n    case 'a':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\telse\n\t\t{\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zA\": open fold at cursor recursively\n    case 'A':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\telse\n\t\t{\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zo\": open fold at cursor or Visual area\n    case 'o':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\tbreak;\n\n\t\t// \"zO\": open fold recursively\n    case 'O':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\tbreak;\n\n\t\t// \"zc\": close fold at cursor or Visual area\n    case 'c':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zC\": close fold recursively\n    case 'C':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zv\": open folds at the cursor\n    case 'v':\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zx\": re-apply 'foldlevel' and open folds at the cursor\n    case 'x':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\tnewFoldLevel();\t\t\t// update right now\n\t\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zX\": undo manual opens/closes, re-apply 'foldlevel'\n    case 'X':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\told_fdl = -1;\t\t\t// force an update\n\t\tbreak;\n\n\t\t// \"zm\": fold more\n    case 'm':\tif (curwin->w_p_fdl > 0)\n\t\t{\n\t\t    curwin->w_p_fdl -= cap->count1;\n\t\t    if (curwin->w_p_fdl < 0)\n\t\t\tcurwin->w_p_fdl = 0;\n\t\t}\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zM\": close all folds\n    case 'M':\tcurwin->w_p_fdl = 0;\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zr\": reduce folding\n    case 'r':\tcurwin->w_p_fdl += cap->count1;\n\t\t{\n\t\t    int d = getDeepestNesting();\n\n\t\t    if (curwin->w_p_fdl >= d)\n\t\t\tcurwin->w_p_fdl = d;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zR\": open all folds\n    case 'R':\tcurwin->w_p_fdl = getDeepestNesting();\n\t\told_fdl = -1;\t\t// force an update\n\t\tbreak;\n\n    case 'j':\t// \"zj\" move to next fold downwards\n    case 'k':\t// \"zk\" move to next fold upwards\n\t\tif (foldMoveTo(TRUE, nchar == 'j' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t  cap->count1) == FAIL)\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n#endif // FEAT_FOLDING\n\n#ifdef FEAT_SPELL\n    case 'u':\t// \"zug\" and \"zuw\": undo \"zg\" and \"zw\"\n    case 'g':\t// \"zg\": add good word to word list\n    case 'w':\t// \"zw\": add wrong word to word list\n    case 'G':\t// \"zG\": add good word to temp word list\n    case 'W':\t// \"zW\": add wrong word to temp word list\n\t\tif (nv_zg_zw(cap, nchar) == FAIL)\n\t\t    return;\n\t\tbreak;\n\n    case '=':\t// \"z=\": suggestions for a badly spelled word\n\t\tif (!checkclearop(cap->oap))\n\t\t    spell_suggest((int)cap->count0);\n\t\tbreak;\n#endif\n\n    default:\tclearopbeep(cap->oap);\n    }\n\n#ifdef FEAT_FOLDING\n    // Redraw when 'foldenable' changed\n    if (old_fen != curwin->w_p_fen)\n    {\n# ifdef FEAT_DIFF\n\twin_T\t    *wp;\n\n\tif (foldmethodIsDiff(curwin) && curwin->w_p_scb)\n\t{\n\t    // Adjust 'foldenable' in diff-synced windows.\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tif (wp != curwin && foldmethodIsDiff(wp) && wp->w_p_scb)\n\t\t{\n\t\t    wp->w_p_fen = curwin->w_p_fen;\n\t\t    changed_window_setting_win(wp);\n\t\t}\n\t    }\n\t}\n# endif\n\tchanged_window_setting();\n    }\n\n    // Redraw when 'foldlevel' changed.\n    if (old_fdl != curwin->w_p_fdl)\n\tnewFoldLevel();\n#endif\n}\n\n#ifdef FEAT_GUI\n/*\n * Vertical scrollbar movement.\n */\n    static void\nnv_ver_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    gui_do_scroll();\n}\n\n/*\n * Horizontal scrollbar movement.\n */\n    static void\nnv_hor_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    do_mousescroll_horiz(scrollbar_value);\n}\n#endif\n\n#if defined(FEAT_GUI_TABLINE) || defined(PROTO)\n/*\n * Click in GUI tab.\n */\n    static void\nnv_tabline(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    goto_tabpage(current_tab);\n}\n\n/*\n * Selected item in tab line menu.\n */\n    static void\nnv_tabmenu(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    handle_tabmenu();\n}\n\n/*\n * Handle selecting an item of the GUI tab line menu.\n * Used in Normal and Insert mode.\n */\n    void\nhandle_tabmenu(void)\n{\n    switch (current_tabmenu)\n    {\n\tcase TABLINE_MENU_CLOSE:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"tabclose\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"tabclose %d\",\n\t\t\t\t\t\t\t\t current_tab);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_NEW:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"$tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"%dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_OPEN:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"browse $tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"browse %dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n    }\n}\n#endif\n\n/*\n * \"Q\" command.\n */\n    static void\nnv_exmode(cmdarg_T *cap)\n{\n    // Ignore 'Q' in Visual mode, just give a beep.\n    if (VIsual_active)\n\tvim_beep(BO_EX);\n    else if (!checkclearop(cap->oap))\n\tdo_exmode(FALSE);\n}\n\n/*\n * Handle a \":\" command.\n */\n    static void\nnv_colon(cmdarg_T *cap)\n{\n    int\told_p_im;\n    int\tcmd_result;\n    int\tis_cmdkey = cap->cmdchar == K_COMMAND\n\t\t\t\t\t   || cap->cmdchar == K_SCRIPT_COMMAND;\n    int\tflags;\n\n    if (VIsual_active && !is_cmdkey)\n    {\n\tnv_operator(cap);\n\treturn;\n    }\n\n    if (cap->oap->op_type != OP_NOP)\n    {\n\t// Using \":\" as a movement is characterwise exclusive.\n\tcap->oap->motion_type = MCHAR;\n\tcap->oap->inclusive = FALSE;\n    }\n    else if (cap->count0 && !is_cmdkey)\n    {\n\t// translate \"count:\" into \":.,.+(count - 1)\"\n\tstuffcharReadbuff('.');\n\tif (cap->count0 > 1)\n\t{\n\t    stuffReadbuff((char_u *)\",.+\");\n\t    stuffnumReadbuff((long)cap->count0 - 1L);\n\t}\n    }\n\n    // When typing, don't type below an old message\n    if (KeyTyped)\n\tcompute_cmdrow();\n\n    old_p_im = p_im;\n\n    // get a command line and execute it\n    flags = cap->oap->op_type != OP_NOP ? DOCMD_KEEPLINE : 0;\n    if (is_cmdkey)\n\tcmd_result = do_cmdkey_command(cap->cmdchar, flags);\n    else\n\tcmd_result = do_cmdline(NULL, getexline, NULL, flags);\n\n    // If 'insertmode' changed, enter or exit Insert mode\n    if (p_im != old_p_im)\n    {\n\tif (p_im)\n\t    restart_edit = 'i';\n\telse\n\t    restart_edit = 0;\n    }\n\n    if (cmd_result == FAIL)\n\t// The Ex command failed, do not execute the operator.\n\tclearop(cap->oap);\n    else if (cap->oap->op_type != OP_NOP\n\t    && (cap->oap->start.lnum > curbuf->b_ml.ml_line_count\n\t\t|| cap->oap->start.col >\n\t\t\t\t  (colnr_T)STRLEN(ml_get(cap->oap->start.lnum))\n\t\t|| did_emsg\n\t       ))\n\t// The start of the operator has become invalid by the Ex command.\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle CTRL-G command.\n */\n    static void\nnv_ctrlg(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// toggle Selection/Visual mode\n    {\n\tVIsual_select = !VIsual_select;\n\tmay_trigger_modechanged();\n\tshowmode();\n    }\n    else if (!checkclearop(cap->oap))\n\t// print full name if count given or :cd used\n\tfileinfo((int)cap->count0, FALSE, TRUE);\n}\n\n/*\n * Handle CTRL-H <Backspace> command.\n */\n    static void\nnv_ctrlh(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tcap->cmdchar = 'x';\t// BS key behaves like 'x' in Select mode\n\tv_visop(cap);\n    }\n    else\n\tnv_left(cap);\n}\n\n/*\n * CTRL-L: clear screen and redraw.\n */\n    static void\nnv_clear(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n\n#ifdef FEAT_SYN_HL\n    // Clear all syntax states to force resyncing.\n    syn_stack_free_all(curwin->w_s);\n# ifdef FEAT_RELTIME\n    {\n\twin_T *wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    wp->w_s->b_syn_slow = FALSE;\n    }\n# endif\n#endif\n    redraw_later(UPD_CLEAR);\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!gui.in_use)\n# endif\n\tresize_console_buf();\n#endif\n}\n\n/*\n * CTRL-O: In Select mode: switch to Visual mode for one command.\n * Otherwise: Go to older pcmark.\n */\n    static void\nnv_ctrlo(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tVIsual_select = FALSE;\n\tmay_trigger_modechanged();\n\tshowmode();\n\trestart_VIsual_select = 2;\t// restart Select mode later\n    }\n    else\n    {\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n    }\n}\n\n/*\n * CTRL-^ command, short for \":e #\".  Works even when the alternate buffer is\n * not named.\n */\n    static void\nnv_hat(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\t(void)buflist_getfile((int)cap->count0, (linenr_T)0,\n\t\t\t\t\t\tGETF_SETMARK|GETF_ALT, FALSE);\n}\n\n/*\n * \"Z\" commands.\n */\n    static void\nnv_Zet(cmdarg_T *cap)\n{\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    switch (cap->nchar)\n    {\n\t// \"ZZ\": equivalent to \":x\".\n\tcase 'Z':\tdo_cmdline_cmd((char_u *)\"x\");\n\t\t\tbreak;\n\n\t\t\t// \"ZQ\": equivalent to \":q!\" (Elvis compatible).\n\tcase 'Q':\tdo_cmdline_cmd((char_u *)\"q!\");\n\t\t\tbreak;\n\n\tdefault:\tclearopbeep(cap->oap);\n    }\n}\n\n/*\n * Call nv_ident() as if \"c1\" was used, with \"c2\" as next character.\n */\n    void\ndo_nv_ident(int c1, int c2)\n{\n    oparg_T\toa;\n    cmdarg_T\tca;\n\n    clear_oparg(&oa);\n    CLEAR_FIELD(ca);\n    ca.oap = &oa;\n    ca.cmdchar = c1;\n    ca.nchar = c2;\n    nv_ident(&ca);\n}\n\n/*\n * 'K' normal-mode command. Get the command to lookup the keyword under the\n * cursor.\n */\n    static int\nnv_K_getcmd(\n\tcmdarg_T\t*cap,\n\tchar_u\t\t*kp,\n\tint\t\tkp_help,\n\tint\t\tkp_ex,\n\tchar_u\t\t**ptr_arg,\n\tint\t\tn,\n\tchar_u\t\t*buf,\n\tunsigned\tbuflen)\n{\n    char_u\t*ptr = *ptr_arg;\n    int\t\tisman;\n    int\t\tisman_s;\n\n    if (kp_help)\n    {\n\t// in the help buffer\n\tSTRCPY(buf, \"he! \");\n\treturn n;\n    }\n\n    if (kp_ex)\n    {\n\t// 'keywordprog' is an ex command\n\tif (cap->count0 != 0)\n\t    vim_snprintf((char *)buf, buflen, \"%s %ld\", kp, cap->count0);\n\telse\n\t    STRCPY(buf, kp);\n\tSTRCAT(buf, \" \");\n\treturn n;\n    }\n\n    // An external command will probably use an argument starting\n    // with \"-\" as an option.  To avoid trouble we skip the \"-\".\n    while (*ptr == '-' && n > 0)\n    {\n\t++ptr;\n\t--n;\n    }\n    if (n == 0)\n    {\n\t// found dashes only\n\temsg(_(e_no_identifier_under_cursor));\n\tvim_free(buf);\n\t*ptr_arg = ptr;\n\treturn 0;\n    }\n\n    // When a count is given, turn it into a range.  Is this\n    // really what we want?\n    isman = (STRCMP(kp, \"man\") == 0);\n    isman_s = (STRCMP(kp, \"man -s\") == 0);\n    if (cap->count0 != 0 && !(isman || isman_s))\n\tsprintf((char *)buf, \".,.+%ld\", cap->count0 - 1);\n\n    STRCAT(buf, \"! \");\n    if (cap->count0 == 0 && isman_s)\n\tSTRCAT(buf, \"man\");\n    else\n\tSTRCAT(buf, kp);\n    STRCAT(buf, \" \");\n    if (cap->count0 != 0 && (isman || isman_s))\n    {\n\tsprintf((char *)buf + STRLEN(buf), \"%ld\", cap->count0);\n\tSTRCAT(buf, \" \");\n    }\n\n    *ptr_arg = ptr;\n    return n;\n}\n\n/*\n * Handle the commands that use the word under the cursor.\n * [g] CTRL-]\t:ta to current identifier\n * [g] 'K'\trun program for current identifier\n * [g] '*'\t/ to current identifier or string\n * [g] '#'\t? to current identifier or string\n *  g  ']'\t:tselect for current identifier\n */\n    static void\nnv_ident(cmdarg_T *cap)\n{\n    char_u\t*ptr = NULL;\n    char_u\t*buf;\n    unsigned\tbuflen;\n    char_u\t*newbuf;\n    char_u\t*p;\n    char_u\t*kp;\t\t// value of 'keywordprg'\n    int\t\tkp_help;\t// 'keywordprg' is \":he\"\n    int\t\tkp_ex;\t\t// 'keywordprg' starts with \":\"\n    int\t\tn = 0;\t\t// init for GCC\n    int\t\tcmdchar;\n    int\t\tg_cmd;\t\t// \"g\" command\n    int\t\ttag_cmd = FALSE;\n    char_u\t*aux_ptr;\n\n    if (cap->cmdchar == 'g')\t// \"g*\", \"g#\", \"g]\" and \"gCTRL-]\"\n    {\n\tcmdchar = cap->nchar;\n\tg_cmd = TRUE;\n    }\n    else\n    {\n\tcmdchar = cap->cmdchar;\n\tg_cmd = FALSE;\n    }\n\n    if (cmdchar == POUND)\t// the pound sign, '#' for English keyboards\n\tcmdchar = '#';\n\n    // The \"]\", \"CTRL-]\" and \"K\" commands accept an argument in Visual mode.\n    if (cmdchar == ']' || cmdchar == Ctrl_RSB || cmdchar == 'K')\n    {\n\tif (VIsual_active && get_visual_text(cap, &ptr, &n) == FAIL)\n\t    return;\n\tif (checkclearopq(cap->oap))\n\t    return;\n    }\n\n    if (ptr == NULL && (n = find_ident_under_cursor(&ptr,\n\t\t    (cmdchar == '*' || cmdchar == '#')\n\t\t\t\t ? FIND_IDENT|FIND_STRING : FIND_IDENT)) == 0)\n    {\n\tclearop(cap->oap);\n\treturn;\n    }\n\n    // Allocate buffer to put the command in.  Inserting backslashes can\n    // double the length of the word.  p_kp / curbuf->b_p_kp could be added\n    // and some numbers.\n    kp = (*curbuf->b_p_kp == NUL ? p_kp : curbuf->b_p_kp);\n    kp_help = (*kp == NUL || STRCMP(kp, \":he\") == 0\n\t\t\t\t\t\t || STRCMP(kp, \":help\") == 0);\n    if (kp_help && *skipwhite(ptr) == NUL)\n    {\n\temsg(_(e_no_identifier_under_cursor));\t // found white space only\n\treturn;\n    }\n    kp_ex = (*kp == ':');\n    buflen = (unsigned)(n * 2 + 30 + STRLEN(kp));\n    buf = alloc(buflen);\n    if (buf == NULL)\n\treturn;\n    buf[0] = NUL;\n\n    switch (cmdchar)\n    {\n\tcase '*':\n\tcase '#':\n\t    // Put cursor at start of word, makes search skip the word\n\t    // under the cursor.\n\t    // Call setpcmark() first, so \"*``\" puts the cursor back where\n\t    // it was.\n\t    setpcmark();\n\t    curwin->w_cursor.col = (colnr_T) (ptr - ml_get_curline());\n\n\t    if (!g_cmd && vim_iswordp(ptr))\n\t\tSTRCPY(buf, \"\\\\<\");\n\t    no_smartcase = TRUE;\t// don't use 'smartcase' now\n\t    break;\n\n\tcase 'K':\n\t    n = nv_K_getcmd(cap, kp, kp_help, kp_ex, &ptr, n, buf, buflen);\n\t    if (n == 0)\n\t\treturn;\n\t    break;\n\n\tcase ']':\n\t    tag_cmd = TRUE;\n#ifdef FEAT_CSCOPE\n\t    if (p_cst)\n\t\tSTRCPY(buf, \"cstag \");\n\t    else\n#endif\n\t\tSTRCPY(buf, \"ts \");\n\t    break;\n\n\tdefault:\n\t    tag_cmd = TRUE;\n\t    if (curbuf->b_help)\n\t\tSTRCPY(buf, \"he! \");\n\t    else\n\t    {\n\t\tif (g_cmd)\n\t\t    STRCPY(buf, \"tj \");\n\t\telse if (cap->count0 == 0)\n\t\t    STRCPY(buf, \"ta \");\n\t\telse\n\t\t    sprintf((char *)buf, \":%ldta \", cap->count0);\n\t    }\n    }\n\n    // Now grab the chars in the identifier\n    if (cmdchar == 'K' && !kp_help)\n    {\n\tptr = vim_strnsave(ptr, n);\n\tif (kp_ex)\n\t    // Escape the argument properly for an Ex command\n\t    p = vim_strsave_fnameescape(ptr, VSE_NONE);\n\telse\n\t    // Escape the argument properly for a shell command\n\t    p = vim_strsave_shellescape(ptr, TRUE, TRUE);\n\tvim_free(ptr);\n\tif (p == NULL)\n\t{\n\t    vim_free(buf);\n\t    return;\n\t}\n\tnewbuf = vim_realloc(buf, STRLEN(buf) + STRLEN(p) + 1);\n\tif (newbuf == NULL)\n\t{\n\t    vim_free(buf);\n\t    vim_free(p);\n\t    return;\n\t}\n\tbuf = newbuf;\n\tSTRCAT(buf, p);\n\tvim_free(p);\n    }\n    else\n    {\n\tif (cmdchar == '*')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/.*~[^$\\\\\" : \"/^$\\\\\");\n\telse if (cmdchar == '#')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/?.*~[^$\\\\\" : \"/?^$\\\\\");\n\telse if (tag_cmd)\n\t{\n\t    if (curbuf->b_help)\n\t\t// \":help\" handles unescaped argument\n\t\taux_ptr = (char_u *)\"\";\n\t    else\n\t\taux_ptr = (char_u *)\"\\\\|\\\"\\n[\";\n\t}\n\telse\n\t    aux_ptr = (char_u *)\"\\\\|\\\"\\n*?[\";\n\n\tp = buf + STRLEN(buf);\n\twhile (n-- > 0)\n\t{\n\t    // put a backslash before \\ and some others\n\t    if (vim_strchr(aux_ptr, *ptr) != NULL)\n\t\t*p++ = '\\\\';\n\t    // When current byte is a part of multibyte character, copy all\n\t    // bytes of that character.\n\t    if (has_mbyte)\n\t    {\n\t\tint i;\n\t\tint len = (*mb_ptr2len)(ptr) - 1;\n\n\t\tfor (i = 0; i < len && n >= 1; ++i, --n)\n\t\t    *p++ = *ptr++;\n\t    }\n\t    *p++ = *ptr++;\n\t}\n\t*p = NUL;\n    }\n\n    // Execute the command.\n    if (cmdchar == '*' || cmdchar == '#')\n    {\n\tif (!g_cmd && (has_mbyte\n\t\t    ? vim_iswordp(mb_prevptr(ml_get_curline(), ptr))\n\t\t    : vim_iswordc(ptr[-1])))\n\t    STRCAT(buf, \"\\\\>\");\n\n\t// put pattern in search history\n\tinit_history();\n\tadd_to_history(HIST_SEARCH, buf, TRUE, NUL);\n\n\t(void)normal_search(cap, cmdchar == '*' ? '/' : '?', buf, 0, NULL);\n    }\n    else\n    {\n\tg_tag_at_cursor = TRUE;\n\tdo_cmdline_cmd(buf);\n\tg_tag_at_cursor = FALSE;\n    }\n\n    vim_free(buf);\n}\n\n/*\n * Get visually selected text, within one line only.\n * Returns FAIL if more than one line selected.\n */\n    int\nget_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    // return: start of selected text\n    int\t\t*lenp)\t    // return: length of selected text\n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (*lenp > 0)\n\t{\n\t    if (has_mbyte)\n\t\t// Correct the length to include all bytes of the last\n\t\t// character.\n\t\t*lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n\t    else if ((*pp)[*lenp - 1] == NUL)\n\t\t// Do not include a trailing NUL.\n\t\t*lenp -= 1;\n\t}\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}\n\n/*\n * CTRL-T: backwards in tag stack\n */\n    static void\nnv_tagpop(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tdo_tag((char_u *)\"\", DT_POP, (int)cap->count1, FALSE, TRUE);\n}\n\n/*\n * Handle scrolling command 'H', 'L' and 'M'.\n */\n    static void\nnv_scroll(cmdarg_T *cap)\n{\n    int\t\tused = 0;\n    long\tn;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\thalf;\n\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    if (cap->cmdchar == 'L')\n    {\n\tvalidate_botline();\t    // make sure curwin->w_botline is valid\n\tcurwin->w_cursor.lnum = curwin->w_botline - 1;\n\tif (cap->count1 - 1 >= curwin->w_cursor.lnum)\n\t    curwin->w_cursor.lnum = 1;\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tfor (n = cap->count1 - 1; n > 0\n\t\t\t    && curwin->w_cursor.lnum > curwin->w_topline; --n)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t    if (curwin->w_cursor.lnum > curwin->w_topline)\n\t\t\t--curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tcurwin->w_cursor.lnum -= cap->count1 - 1;\n\t}\n    }\n    else\n    {\n\tif (cap->cmdchar == 'M')\n\t{\n#ifdef FEAT_DIFF\n\t    // Don't count filler lines above the window.\n\t    used -= diff_check_fill(curwin, curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    validate_botline();\t    // make sure w_empty_rows is valid\n\t    half = (curwin->w_height - curwin->w_empty_rows + 1) / 2;\n\t    for (n = 0; curwin->w_topline + n < curbuf->b_ml.ml_line_count; ++n)\n\t    {\n#ifdef FEAT_DIFF\n\t\t// Count half he number of filler lines to be \"below this\n\t\t// line\" and half to be \"above the next line\".\n\t\tif (n > 0 && used + diff_check_fill(curwin, curwin->w_topline\n\t\t\t\t\t\t\t     + n) / 2 >= half)\n\t\t{\n\t\t    --n;\n\t\t    break;\n\t\t}\n#endif\n\t\tused += plines(curwin->w_topline + n);\n\t\tif (used >= half)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\tif (hasFolding(curwin->w_topline + n, NULL, &lnum))\n\t\t    n = lnum - curwin->w_topline;\n#endif\n\t    }\n\t    if (n > 0 && used > curwin->w_height)\n\t\t--n;\n\t}\n\telse // (cap->cmdchar == 'H')\n\t{\n\t    n = cap->count1 - 1;\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tlnum = curwin->w_topline;\n\t\twhile (n-- > 0 && lnum < curwin->w_botline - 1)\n\t\t{\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t    ++lnum;\n\t\t}\n\t\tn = lnum - curwin->w_topline;\n\t    }\n#endif\n\t}\n\tcurwin->w_cursor.lnum = curwin->w_topline + n;\n\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    }\n\n    // Correct for 'so', except when an operator is pending.\n    if (cap->oap->op_type == OP_NOP)\n\tcursor_correct();\n    beginline(BL_SOL | BL_FIX);\n}\n\n/*\n * Cursor right commands.\n */\n    static void\nnv_right(cmdarg_T *cap)\n{\n    long\tn;\n    int\t\tpast_line;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Right> and <S-Right> move a word or WORD right\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = TRUE;\n\tnv_wordcmd(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    past_line = (VIsual_active && *p_sel != 'o');\n\n    // In virtual edit mode, there's no such thing as \"past_line\", as lines\n    // are (theoretically) infinitely long.\n    if (virtual_active())\n\tpast_line = 0;\n\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif ((!past_line && oneright() == FAIL)\n\t\t|| (past_line && *ml_get_cursor() == NUL)\n\t\t)\n\t{\n\t    //\t  <Space> wraps to next line if 'whichwrap' has 's'.\n\t    //\t      'l' wraps to next line if 'whichwrap' has 'l'.\n\t    // CURS_RIGHT wraps to next line if 'whichwrap' has '>'.\n\t    if (       ((cap->cmdchar == ' '\n\t\t\t    && vim_strchr(p_ww, 's') != NULL)\n\t\t\t|| (cap->cmdchar == 'l'\n\t\t\t    && vim_strchr(p_ww, 'l') != NULL)\n\t\t\t|| (cap->cmdchar == K_RIGHT\n\t\t\t    && vim_strchr(p_ww, '>') != NULL))\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// When deleting we also count the NL as a character.\n\t\t// Set cap->oap->inclusive when last char in the line is\n\t\t// included, move to next line after that\n\t\tif (\t   cap->oap->op_type != OP_NOP\n\t\t\t&& !cap->oap->inclusive\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t\telse\n\t\t{\n\t\t    ++curwin->w_cursor.lnum;\n\t\t    curwin->w_cursor.col = 0;\n\t\t    curwin->w_cursor.coladd = 0;\n\t\t    curwin->w_set_curswant = TRUE;\n\t\t    cap->oap->inclusive = FALSE;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    if (cap->oap->op_type == OP_NOP)\n\t    {\n\t\t// Only beep and flush if not moved at all\n\t\tif (n == cap->count1)\n\t\t    beep_flush();\n\t    }\n\t    else\n\t    {\n\t\tif (!LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t    }\n\t    break;\n\t}\n\telse if (past_line)\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    if (virtual_active())\n\t\toneright();\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t    curwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t\telse\n\t\t    ++curwin->w_cursor.col;\n\t    }\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor left commands.\n *\n * Returns TRUE when operator end should not be adjusted.\n */\n    static void\nnv_left(cmdarg_T *cap)\n{\n    long\tn;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Left> and <S-Left> move a word or WORD left\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = 1;\n\tnv_bck_word(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif (oneleft() == FAIL)\n\t{\n\t    // <BS> and <Del> wrap to previous line if 'whichwrap' has 'b'.\n\t    //\t\t 'h' wraps to previous line if 'whichwrap' has 'h'.\n\t    //\t   CURS_LEFT wraps to previous line if 'whichwrap' has '<'.\n\t    if (       (((cap->cmdchar == K_BS\n\t\t\t\t|| cap->cmdchar == Ctrl_H)\n\t\t\t    && vim_strchr(p_ww, 'b') != NULL)\n\t\t\t|| (cap->cmdchar == 'h'\n\t\t\t    && vim_strchr(p_ww, 'h') != NULL)\n\t\t\t|| (cap->cmdchar == K_LEFT\n\t\t\t    && vim_strchr(p_ww, '<') != NULL))\n\t\t    && curwin->w_cursor.lnum > 1)\n\t    {\n\t\t--(curwin->w_cursor.lnum);\n\t\tcoladvance((colnr_T)MAXCOL);\n\t\tcurwin->w_set_curswant = TRUE;\n\n\t\t// When the NL before the first char has to be deleted we\n\t\t// put the cursor on the NUL after the previous line.\n\t\t// This is a very special case, be careful!\n\t\t// Don't adjust op_end now, otherwise it won't work.\n\t\tif (\t   (cap->oap->op_type == OP_DELETE\n\t\t\t    || cap->oap->op_type == OP_CHANGE)\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t{\n\t\t    char_u *cp = ml_get_cursor();\n\n\t\t    if (*cp != NUL)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    curwin->w_cursor.col += (*mb_ptr2len)(cp);\n\t\t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t    cap->retval |= CA_NO_ADJ_OP_END;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    // Only beep and flush if not moved at all\n\t    else if (cap->oap->op_type == OP_NOP && n == cap->count1)\n\t\tbeep_flush();\n\t    break;\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor up commands.\n * cap->arg is TRUE for \"-\": Move cursor to first non-blank.\n */\n    static void\nnv_up(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Up> is page up\n\tcap->arg = BACKWARD;\n\tnv_page(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MLINE;\n    if (cursor_up(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n    else if (cap->arg)\n\tbeginline(BL_WHITE | BL_FIX);\n}\n\n/*\n * Cursor down commands.\n * cap->arg is TRUE for CR and \"+\": Move cursor to first non-blank.\n */\n    static void\nnv_down(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Down> is page down\n\tcap->arg = FORWARD;\n\tnv_page(cap);\n    }\n#if defined(FEAT_QUICKFIX)\n    // Quickfix window only: view the result under the cursor.\n    else if (bt_quickfix(curbuf) && cap->cmdchar == CAR)\n\tqf_view_result(FALSE);\n#endif\n    else\n    {\n\t// In the cmdline window a <CR> executes the command.\n\tif (cmdwin_type != 0 && cap->cmdchar == CAR)\n\t    cmdwin_result = CAR;\n\telse\n#ifdef FEAT_JOB_CHANNEL\n\t// In a prompt buffer a <CR> in the last line invokes the callback.\n\tif (bt_prompt(curbuf) && cap->cmdchar == CAR\n\t\t       && curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t{\n\t    invoke_prompt_callback();\n\t    if (restart_edit == 0)\n\t\trestart_edit = 'a';\n\t}\n\telse\n#endif\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    if (cursor_down(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\t\tclearopbeep(cap->oap);\n\t    else if (cap->arg)\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t}\n    }\n}\n\n/*\n * Grab the file name under the cursor and edit it.\n */\n    static void\nnv_gotofile(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    linenr_T\tlnum = -1;\n\n    if (check_text_or_curbuf_locked(cap->oap))\n\treturn;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n\n    ptr = grab_file_name(cap->count1, &lnum);\n\n    if (ptr != NULL)\n    {\n\t// do autowrite if necessary\n\tif (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf))\n\t    (void)autowrite(curbuf, FALSE);\n\tsetpcmark();\n\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,\n\t\t\t\tbuf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK\n\t\t&& cap->nchar == 'F' && lnum >= 0)\n\t{\n\t    curwin->w_cursor.lnum = lnum;\n\t    check_cursor_lnum();\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n\tvim_free(ptr);\n    }\n    else\n\tclearop(cap->oap);\n}\n\n/*\n * <End> command: to end of current line or last line.\n */\n    static void\nnv_end(cmdarg_T *cap)\n{\n    if (cap->arg || (mod_mask & MOD_MASK_CTRL))\t// CTRL-END = goto last line\n    {\n\tcap->arg = TRUE;\n\tnv_goto(cap);\n\tcap->count1 = 1;\t\t// to end of current line\n    }\n    nv_dollar(cap);\n}\n\n/*\n * Handle the \"$\" command.\n */\n    static void\nnv_dollar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = TRUE;\n    // In virtual mode when off the edge of a line and an operator\n    // is pending (whew!) keep the cursor where it is.\n    // Otherwise, send it to the end of the line.\n    if (!virtual_active() || gchar_cursor() != NUL\n\t\t\t\t\t       || cap->oap->op_type == OP_NOP)\n\tcurwin->w_curswant = MAXCOL;\t// so we stay at the end\n    if (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\t cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Implementation of '?' and '/' commands.\n * If cap->arg is TRUE don't set PC mark.\n */\n    static void\nnv_search(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    pos_T\tsave_cursor = curwin->w_cursor;\n\n    if (cap->cmdchar == '?' && cap->oap->op_type == OP_ROT13)\n    {\n\t// Translate \"g??\" to \"g?g?\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = '?';\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // When using 'incsearch' the cursor may be moved to set a different search\n    // start position.\n    cap->searchbuf = getcmdline(cap->cmdchar, cap->count1, 0, 0);\n\n    if (cap->searchbuf == NULL)\n    {\n\tclearop(oap);\n\treturn;\n    }\n\n    (void)normal_search(cap, cap->cmdchar, cap->searchbuf,\n\t\t\t(cap->arg || !EQUAL_POS(save_cursor, curwin->w_cursor))\n\t\t\t\t\t\t      ? 0 : SEARCH_MARK, NULL);\n}\n\n\n/*\n * Handle \"N\" and \"n\" commands.\n * cap->arg is SEARCH_REV for \"N\", 0 for \"n\".\n */\n    static void\nnv_next(cmdarg_T *cap)\n{\n    pos_T   old = curwin->w_cursor;\n    int\t    wrapped = FALSE;\n    int\t    i = normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, &wrapped);\n\n    if (i == 1 && !wrapped && EQUAL_POS(old, curwin->w_cursor))\n    {\n\t// Avoid getting stuck on the current cursor position, which can\n\t// happen when an offset is given and the cursor is on the last char\n\t// in the buffer: Repeat with count + 1.\n\tcap->count1 += 1;\n\t(void)normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, NULL);\n\tcap->count1 -= 1;\n    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    // Redraw the window to refresh the highlighted matches.\n    if (i > 0 && p_hls && !no_hlsearch)\n\tredraw_later(UPD_SOME_VALID);\n#endif\n}\n\n/*\n * Search for \"pat\" in direction \"dir\" ('/' or '?', 0 for repeat).\n * Uses only cap->count1 and cap->oap from \"cap\".\n * Return 0 for failure, 1 for found, 2 for found and line offset added.\n */\n    static int\nnormal_search(\n    cmdarg_T\t*cap,\n    int\t\tdir,\n    char_u\t*pat,\n    int\t\topt,\t\t// extra flags for do_search()\n    int\t\t*wrapped)\n{\n    int\t\ti;\n    searchit_arg_T sia;\n#ifdef FEAT_SEARCH_EXTRA\n    pos_T\tprev_cursor = curwin->w_cursor;\n#endif\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n\n    CLEAR_FIELD(sia);\n    i = do_search(cap->oap, dir, dir, pat, cap->count1,\n\t\t\t    opt | SEARCH_OPT | SEARCH_ECHO | SEARCH_MSG, &sia);\n    if (wrapped != NULL)\n\t*wrapped = sia.sa_wrapped;\n    if (i == 0)\n\tclearop(cap->oap);\n    else\n    {\n\tif (i == 2)\n\t    cap->oap->motion_type = MLINE;\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n#endif\n    }\n#ifdef FEAT_SEARCH_EXTRA\n    // Redraw the window to refresh the highlighted matches.\n    if (!EQUAL_POS(curwin->w_cursor, prev_cursor) && p_hls && !no_hlsearch)\n\tredraw_later(UPD_SOME_VALID);\n#endif\n\n    // \"/$\" will put the cursor after the end of the line, may need to\n    // correct that here\n    check_cursor();\n    return i;\n}\n\n/*\n * Character search commands.\n * cap->arg is BACKWARD for 'F' and 'T', FORWARD for 'f' and 't', TRUE for\n * ',' and FALSE for ';'.\n * cap->nchar is NUL for ',' and ';' (repeat the search)\n */\n    static void\nnv_csearch(cmdarg_T *cap)\n{\n    int\t\tt_cmd;\n\n    if (cap->cmdchar == 't' || cap->cmdchar == 'T')\n\tt_cmd = TRUE;\n    else\n\tt_cmd = FALSE;\n\n    cap->oap->motion_type = MCHAR;\n    if (IS_SPECIAL(cap->nchar) || searchc(cap, t_cmd) == FAIL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    curwin->w_set_curswant = TRUE;\n    // Include a Tab for \"tx\" and for \"dfx\".\n    if (gchar_cursor() == TAB && virtual_active() && cap->arg == FORWARD\n\t    && (t_cmd || cap->oap->op_type != OP_NOP))\n    {\n\tcolnr_T\tscol, ecol;\n\n\tgetvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);\n\tcurwin->w_cursor.coladd = ecol - scol;\n    }\n    else\n\tcurwin->w_cursor.coladd = 0;\n    adjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n * \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n * \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n * \"[m\" or \"]m\" search for prev/next start of (Java) method.\n * \"[M\" or \"]M\" search for prev/next end of (Java) method.\n */\n    static void\nnv_bracket_block(cmdarg_T *cap, pos_T *old_pos)\n{\n    pos_T\tnew_pos = {0, 0, 0};\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\tprev_pos;\n    long\tn;\n    int\t\tfindc;\n    int\t\tc;\n\n    if (cap->nchar == '*')\n\tcap->nchar = '/';\n    prev_pos.lnum = 0;\n    if (cap->nchar == 'm' || cap->nchar == 'M')\n    {\n\tif (cap->cmdchar == '[')\n\t    findc = '{';\n\telse\n\t    findc = '}';\n\tn = 9999;\n    }\n    else\n    {\n\tfindc = cap->nchar;\n\tn = cap->count1;\n    }\n    for ( ; n > 0; --n)\n    {\n\tif ((pos = findmatchlimit(cap->oap, findc,\n\t\t\t(cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD, 0)) == NULL)\n\t{\n\t    if (new_pos.lnum == 0)\t// nothing found\n\t    {\n\t\tif (cap->nchar != 'm' && cap->nchar != 'M')\n\t\t    clearopbeep(cap->oap);\n\t    }\n\t    else\n\t\tpos = &new_pos;\t// use last one found\n\t    break;\n\t}\n\tprev_pos = new_pos;\n\tcurwin->w_cursor = *pos;\n\tnew_pos = *pos;\n    }\n    curwin->w_cursor = *old_pos;\n\n    // Handle \"[m\", \"]m\", \"[M\" and \"[M\".  The findmatchlimit() only\n    // brought us to the match for \"[m\" and \"]M\" when inside a method.\n    // Try finding the '{' or '}' we want to be at.\n    // Also repeat for the given count.\n    if (cap->nchar == 'm' || cap->nchar == 'M')\n    {\n\t// norm is TRUE for \"]M\" and \"[m\"\n\tint\t    norm = ((findc == '{') == (cap->nchar == 'm'));\n\n\tn = cap->count1;\n\t// found a match: we were inside a method\n\tif (prev_pos.lnum != 0)\n\t{\n\t    pos = &prev_pos;\n\t    curwin->w_cursor = prev_pos;\n\t    if (norm)\n\t\t--n;\n\t}\n\telse\n\t    pos = NULL;\n\twhile (n > 0)\n\t{\n\t    for (;;)\n\t    {\n\t\tif ((findc == '{' ? dec_cursor() : inc_cursor()) < 0)\n\t\t{\n\t\t    // if not found anything, that's an error\n\t\t    if (pos == NULL)\n\t\t\tclearopbeep(cap->oap);\n\t\t    n = 0;\n\t\t    break;\n\t\t}\n\t\tc = gchar_cursor();\n\t\tif (c == '{' || c == '}')\n\t\t{\n\t\t    // Must have found end/start of class: use it.\n\t\t    // Or found the place to be at.\n\t\t    if ((c == findc && norm) || (n == 1 && !norm))\n\t\t    {\n\t\t\tnew_pos = curwin->w_cursor;\n\t\t\tpos = &new_pos;\n\t\t\tn = 0;\n\t\t    }\n\t\t    // if no match found at all, we started outside of the\n\t\t    // class and we're inside now.  Just go on.\n\t\t    else if (new_pos.lnum == 0)\n\t\t    {\n\t\t\tnew_pos = curwin->w_cursor;\n\t\t\tpos = &new_pos;\n\t\t    }\n\t\t    // found start/end of other method: go to match\n\t\t    else if ((pos = findmatchlimit(cap->oap, findc,\n\t\t\t      (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,\n\t\t\t\t\t\t\t\t   0)) == NULL)\n\t\t\tn = 0;\n\t\t    else\n\t\t\tcurwin->w_cursor = *pos;\n\t\t    break;\n\t\t}\n\t    }\n\t    --n;\n\t}\n\tcurwin->w_cursor = *old_pos;\n\tif (pos == NULL && new_pos.lnum != 0)\n\t    clearopbeep(cap->oap);\n    }\n    if (pos != NULL)\n    {\n\tsetpcmark();\n\tcurwin->w_cursor = *pos;\n\tcurwin->w_set_curswant = TRUE;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped\n\t\t&& cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"[\" and \"]\" commands.\n * cap->arg is BACKWARD for \"[\" and FORWARD for \"]\".\n */\n    static void\nnv_brackets(cmdarg_T *cap)\n{\n    pos_T\tprev_pos;\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\told_pos;\t    // cursor position before command\n    int\t\tflag;\n    long\tn;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    old_pos = curwin->w_cursor;\n    curwin->w_cursor.coladd = 0;    // TODO: don't do this for an error.\n\n    // \"[f\" or \"]f\" : Edit file under the cursor (same as \"gf\")\n    if (cap->nchar == 'f')\n\tnv_gotofile(cap);\n    else\n\n#ifdef FEAT_FIND_ID\n    // Find the occurrence(s) of the identifier or define under cursor\n    // in current and included files or jump to the first occurrence.\n    //\n    //\t\t\tsearch\t     list\t    jump\n    //\t\t      fwd   bwd    fwd\t bwd\t fwd\tbwd\n    // identifier     \"]i\"  \"[i\"   \"]I\"  \"[I\"\t\"]^I\"  \"[^I\"\n    // define\t      \"]d\"  \"[d\"   \"]D\"  \"[D\"\t\"]^D\"  \"[^D\"\n    if (vim_strchr((char_u *)\"iI\\011dD\\004\", cap->nchar) != NULL)\n    {\n\tchar_u\t*ptr;\n\tint\tlen;\n\n\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t    clearop(cap->oap);\n\telse\n\t{\n\t    // Make a copy, if the line was changed it will be freed.\n\t    ptr = vim_strnsave(ptr, len);\n\t    if (ptr == NULL)\n\t\treturn;\n\n\t    find_pattern_in_path(ptr, 0, len, TRUE,\n\t\tcap->count0 == 0 ? !isupper(cap->nchar) : FALSE,\n\t\t((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,\n\t\tcap->count1,\n\t\tisupper(cap->nchar) ? ACTION_SHOW_ALL :\n\t\t\t    islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,\n\t\tcap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,\n\t\t(linenr_T)MAXLNUM);\n\t    vim_free(ptr);\n\t    curwin->w_set_curswant = TRUE;\n\t}\n    }\n    else\n#endif\n\n    // \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n    // \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n    // \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n    // \"[m\" or \"]m\" search for prev/next start of (Java) method.\n    // \"[M\" or \"]M\" search for prev/next end of (Java) method.\n    if (  (cap->cmdchar == '['\n\t\t&& vim_strchr((char_u *)\"{(*/#mM\", cap->nchar) != NULL)\n\t    || (cap->cmdchar == ']'\n\t\t&& vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL))\n\tnv_bracket_block(cap, &old_pos);\n\n    // \"[[\", \"[]\", \"]]\" and \"][\": move to start or end of function\n    else if (cap->nchar == '[' || cap->nchar == ']')\n    {\n\tif (cap->nchar == cap->cmdchar)\t\t    // \"]]\" or \"[[\"\n\t    flag = '{';\n\telse\n\t    flag = '}';\t\t    // \"][\" or \"[]\"\n\n\tcurwin->w_set_curswant = TRUE;\n\t// Imitate strange Vi behaviour: When using \"]]\" with an operator\n\t// we also stop at '}'.\n\tif (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,\n\t      (cap->oap->op_type != OP_NOP\n\t\t\t\t      && cap->arg == FORWARD && flag == '{')))\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    if (cap->oap->op_type == OP_NOP)\n\t\tbeginline(BL_WHITE | BL_FIX);\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t\tfoldOpenCursor();\n#endif\n\t}\n    }\n\n    // \"[p\", \"[P\", \"]P\" and \"]p\": put with indent adjustment\n    else if (cap->nchar == 'p' || cap->nchar == 'P')\n    {\n\tnv_put_opt(cap, TRUE);\n    }\n\n    // \"['\", \"[`\", \"]'\" and \"]`\": jump to next mark\n    else if (cap->nchar == '\\'' || cap->nchar == '`')\n    {\n\tpos = &curwin->w_cursor;\n\tfor (n = cap->count1; n > 0; --n)\n\t{\n\t    prev_pos = *pos;\n\t    pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,\n\t\t\t\t\t\t\t  cap->nchar == '\\'');\n\t    if (pos == NULL)\n\t\tbreak;\n\t}\n\tif (pos == NULL)\n\t    pos = &prev_pos;\n\tnv_cursormark(cap, cap->nchar == '\\'', pos);\n    }\n\n    // [ or ] followed by a middle mouse click: put selected text with\n    // indent adjustment.  Any other button just does as usual.\n    else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE)\n    {\n\t(void)do_mouse(cap->oap, cap->nchar,\n\t\t       (cap->cmdchar == ']') ? FORWARD : BACKWARD,\n\t\t       cap->count1, PUT_FIXINDENT);\n    }\n\n#ifdef FEAT_FOLDING\n    // \"[z\" and \"]z\": move to start or end of open fold.\n    else if (cap->nchar == 'z')\n    {\n\tif (foldMoveTo(FALSE, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    // \"[c\" and \"]c\": move to next or previous diff-change.\n    else if (cap->nchar == 'c')\n    {\n\tif (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // \"[s\", \"[S\", \"]s\" and \"]S\": move to next spell error.\n    else if (cap->nchar == 's' || cap->nchar == 'S')\n    {\n\tsetpcmark();\n\tfor (n = 0; n < cap->count1; ++n)\n\t    if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t  cap->nchar == 's' ? TRUE : FALSE, FALSE, NULL) == 0)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n#endif\n\n    // Not a valid cap->nchar.\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle Normal mode \"%\" command.\n */\n    static void\nnv_percent(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n#if defined(FEAT_FOLDING)\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n#endif\n\n    cap->oap->inclusive = TRUE;\n    if (cap->count0)\t    // {cnt}% : goto {cnt} percentage in file\n    {\n\tif (cap->count0 > 100)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    setpcmark();\n\t    // Round up, so 'normal 100%' always jumps at the line line.\n\t    // Beyond 21474836 lines, (ml_line_count * 100 + 99) would\n\t    // overflow on 32-bits, so use a formula with less accuracy\n\t    // to avoid overflows.\n\t    if (curbuf->b_ml.ml_line_count >= 21474836)\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count + 99L)\n\t\t\t\t\t\t\t / 100L * cap->count0;\n\t    else\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count *\n\t\t\t\t\t\t    cap->count0 + 99L) / 100L;\n\t    if (curwin->w_cursor.lnum < 1)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n    }\n    else\t\t    // \"%\" : go to matching paren\n    {\n\tcap->oap->motion_type = MCHAR;\n\tcap->oap->use_reg_one = TRUE;\n\tif ((pos = findmatch(cap->oap, NUL)) == NULL)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    setpcmark();\n\t    curwin->w_cursor = *pos;\n\t    curwin->w_set_curswant = TRUE;\n\t    curwin->w_cursor.coladd = 0;\n\t    adjust_for_sel(cap);\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && lnum != curwin->w_cursor.lnum\n\t    && (fdo_flags & FDO_PERCENT)\n\t    && KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle \"(\" and \")\" commands.\n * cap->arg is BACKWARD for \"(\" and FORWARD for \")\".\n */\n    static void\nnv_brace(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->use_reg_one = TRUE;\n    // The motion used to be inclusive for \"(\", but that is not what Vi does.\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n\n    if (findsent(cap->arg, cap->count1) == FAIL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Don't leave the cursor on the NUL past end of line.\n    adjust_cursor(cap->oap);\n    curwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * \"m\" command: Mark a position.\n */\n    static void\nnv_mark(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n\n    if (setmark(cap->nchar) == FAIL)\n\tclearopbeep(cap->oap);\n}\n\n/*\n * \"{\" and \"}\" commands.\n * cmd->arg is BACKWARD for \"{\" and FORWARD for \"}\".\n */\n    static void\nnv_findpar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n    if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, NUL, FALSE))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    curwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * \"u\" command: Undo or make lower case.\n */\n    static void\nnv_undo(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_LOWER || VIsual_active)\n    {\n\t// translate \"<Visual>u\" to \"<Visual>gu\" and \"guu\" to \"gugu\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'u';\n\tnv_operator(cap);\n    }\n    else\n\tnv_kundo(cap);\n}\n\n/*\n * <Undo> command.\n */\n    static void\nnv_kundo(cmdarg_T *cap)\n{\n    if (checkclearopq(cap->oap))\n\treturn;\n\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n    u_undo((int)cap->count1);\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * Handle the \"r\" command.\n */\n    static void\nnv_replace(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    int\t\thad_ctrl_v;\n    long\tn;\n\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    // get another character\n    if (cap->nchar == Ctrl_V || cap->nchar == Ctrl_Q)\n    {\n\thad_ctrl_v = Ctrl_V;\n\tcap->nchar = get_literal(FALSE);\n\t// Don't redo a multibyte character with CTRL-V.\n\tif (cap->nchar > DEL)\n\t    had_ctrl_v = NUL;\n    }\n    else\n\thad_ctrl_v = NUL;\n\n    // Abort if the character is a special key.\n    if (IS_SPECIAL(cap->nchar))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Visual mode \"r\"\n    if (VIsual_active)\n    {\n\tif (got_int)\n\t    got_int = FALSE;\n\tif (had_ctrl_v)\n\t{\n\t    // Use a special (negative) number to make a difference between a\n\t    // literal CR or NL and a line break.\n\t    if (cap->nchar == CAR)\n\t\tcap->nchar = REPLACE_CR_NCHAR;\n\t    else if (cap->nchar == NL)\n\t\tcap->nchar = REPLACE_NL_NCHAR;\n\t}\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // Break tabs, etc.\n    if (virtual_active())\n    {\n\tif (u_save_cursor() == FAIL)\n\t    return;\n\tif (gchar_cursor() == NUL)\n\t{\n\t    // Add extra space and put the cursor on the first one.\n\t    coladvance_force((colnr_T)(getviscol() + cap->count1));\n\t    curwin->w_cursor.col -= cap->count1;\n\t}\n\telse if (gchar_cursor() == TAB)\n\t    coladvance_force(getviscol());\n    }\n\n    // Abort if not enough characters to replace.\n    ptr = ml_get_cursor();\n    if (STRLEN(ptr) < (unsigned)cap->count1\n\t    || (has_mbyte && mb_charlen(ptr) < cap->count1))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Replacing with a TAB is done by edit() when it is complicated because\n    // 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.\n    // Other characters are done below to avoid problems with things like\n    // CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).\n    if (had_ctrl_v != Ctrl_V && cap->nchar == '\\t' && (curbuf->b_p_et || p_sta))\n    {\n\tstuffnumReadbuff(cap->count1);\n\tstuffcharReadbuff('R');\n\tstuffcharReadbuff('\\t');\n\tstuffcharReadbuff(ESC);\n\treturn;\n    }\n\n    // save line for undo\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    if (had_ctrl_v != Ctrl_V && (cap->nchar == '\\r' || cap->nchar == '\\n'))\n    {\n\t// Replace character(s) by a single newline.\n\t// Strange vi behaviour: Only one newline is inserted.\n\t// Delete the characters here.\n\t// Insert the newline with an insert command, takes care of\n\t// autoindent.\tThe insert command depends on being on the last\n\t// character of a line or not.\n\t(void)del_chars(cap->count1, FALSE);\t// delete the characters\n\tstuffcharReadbuff('\\r');\n\tstuffcharReadbuff(ESC);\n\n\t// Give 'r' to edit(), to get the redo command right.\n\tinvoke_edit(cap, TRUE, 'r', FALSE);\n    }\n    else\n    {\n\tprep_redo(cap->oap->regname, cap->count1,\n\t\t\t\t       NUL, 'r', NUL, had_ctrl_v, cap->nchar);\n\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tif (has_mbyte)\n\t{\n\t    int\t\told_State = State;\n\n\t    if (cap->ncharC1 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC1);\n\t    if (cap->ncharC2 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC2);\n\n\t    // This is slow, but it handles replacing a single-byte with a\n\t    // multi-byte and the other way around.  Also handles adding\n\t    // composing characters for utf-8.\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\tState = MODE_REPLACE;\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t    int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\t\t    if (c != NUL)\n\t\t\tins_char(c);\n\t\t    else\n\t\t\t// will be decremented further down\n\t\t\t++curwin->w_cursor.col;\n\t\t}\n\t\telse\n\t\t    ins_char(cap->nchar);\n\t\tState = old_State;\n\t\tif (cap->ncharC1 != 0)\n\t\t    ins_char(cap->ncharC1);\n\t\tif (cap->ncharC2 != 0)\n\t\t    ins_char(cap->ncharC2);\n\t    }\n\t}\n\telse\n\t{\n\t    // Replace the characters within one line.\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\t// Get ptr again, because u_save and/or showmatch() will have\n\t\t// released the line.  This may also happen in ins_copychar().\n\t\t// At the same time we let know that the line will be changed.\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t  int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\n\t\t  ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t  if (c != NUL)\n\t\t    ptr[curwin->w_cursor.col] = c;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t    ptr[curwin->w_cursor.col] = cap->nchar;\n\t\t}\n\t\tif (p_sm && msg_silent == 0)\n\t\t    showmatch(cap->nchar);\n\t\t++curwin->w_cursor.col;\n\t    }\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tcolnr_T  start = (colnr_T)(curwin->w_cursor.col - cap->count1);\n\n\t\tnetbeans_removed(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t\t\t   cap->count1);\n\t\tnetbeans_inserted(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t       &ptr[start], (int)cap->count1);\n\t    }\n#endif\n\n\t    // mark the buffer as changed and prepare for displaying\n\t    changed_bytes(curwin->w_cursor.lnum,\n\t\t\t       (colnr_T)(curwin->w_cursor.col - cap->count1));\n\t}\n\t--curwin->w_cursor.col;\t    // cursor on the last replaced char\n\t// if the character on the left of the current cursor is a multi-byte\n\t// character, move two characters left\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tcurwin->w_set_curswant = TRUE;\n\tset_last_insert(cap->nchar);\n    }\n}\n\n/*\n * 'o': Exchange start and end of Visual area.\n * 'O': same, but in block mode exchange left and right corners.\n */\n    static void\nv_swap_corners(int cmdchar)\n{\n    pos_T\told_cursor;\n    colnr_T\tleft, right;\n\n    if (cmdchar == 'O' && VIsual_mode == Ctrl_V)\n    {\n\told_cursor = curwin->w_cursor;\n\tgetvcols(curwin, &old_cursor, &VIsual, &left, &right);\n\tcurwin->w_cursor.lnum = VIsual.lnum;\n\tcoladvance(left);\n\tVIsual = curwin->w_cursor;\n\n\tcurwin->w_cursor.lnum = old_cursor.lnum;\n\tcurwin->w_curswant = right;\n\t// 'selection \"exclusive\" and cursor at right-bottom corner: move it\n\t// right one column\n\tif (old_cursor.lnum >= VIsual.lnum && *p_sel == 'e')\n\t    ++curwin->w_curswant;\n\tcoladvance(curwin->w_curswant);\n\tif (curwin->w_cursor.col == old_cursor.col\n\t\t&& (!virtual_active()\n\t\t    || curwin->w_cursor.coladd == old_cursor.coladd))\n\t{\n\t    curwin->w_cursor.lnum = VIsual.lnum;\n\t    if (old_cursor.lnum <= VIsual.lnum && *p_sel == 'e')\n\t\t++right;\n\t    coladvance(right);\n\t    VIsual = curwin->w_cursor;\n\n\t    curwin->w_cursor.lnum = old_cursor.lnum;\n\t    coladvance(left);\n\t    curwin->w_curswant = left;\n\t}\n    }\n    else\n    {\n\told_cursor = curwin->w_cursor;\n\tcurwin->w_cursor = VIsual;\n\tVIsual = old_cursor;\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * \"R\" (cap->arg is FALSE) and \"gR\" (cap->arg is TRUE).\n */\n    static void\nnv_Replace(cmdarg_T *cap)\n{\n    if (VIsual_active)\t\t// \"R\" is replace lines\n    {\n\tcap->cmdchar = 'c';\n\tcap->nchar = NUL;\n\tVIsual_mode_orig = VIsual_mode; // remember original area for gv\n\tVIsual_mode = 'V';\n\tnv_operator(cap);\n\treturn;\n    }\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    if (!curbuf->b_p_ma)\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n    else\n    {\n\tif (virtual_active())\n\t    coladvance(getviscol());\n\tinvoke_edit(cap, FALSE, cap->arg ? 'V' : 'R', FALSE);\n    }\n}\n\n/*\n * \"gr\".\n */\n    static void\nnv_vreplace(cmdarg_T *cap)\n{\n    if (VIsual_active)\n    {\n\tcap->cmdchar = 'r';\n\tcap->nchar = cap->extra_char;\n\tnv_replace(cap);\t// Do same as \"r\" in Visual mode for now\n\treturn;\n    }\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    if (!curbuf->b_p_ma)\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n    else\n    {\n\tif (cap->extra_char == Ctrl_V || cap->extra_char == Ctrl_Q)\n\t    // get another character\n\t    cap->extra_char = get_literal(FALSE);\n\tif (cap->extra_char < ' ')\n\t    // Prefix a control character with CTRL-V to avoid it being used as\n\t    // a command.\n\t    stuffcharReadbuff(Ctrl_V);\n\tstuffcharReadbuff(cap->extra_char);\n\tstuffcharReadbuff(ESC);\n\tif (virtual_active())\n\t    coladvance(getviscol());\n\tinvoke_edit(cap, TRUE, 'v', FALSE);\n    }\n}\n\n/*\n * Swap case for \"~\" command, when it does not work like an operator.\n */\n    static void\nn_swapchar(cmdarg_T *cap)\n{\n    long\tn;\n    pos_T\tstartpos;\n    int\t\tdid_change = 0;\n#ifdef FEAT_NETBEANS_INTG\n    pos_T\tpos;\n    char_u\t*ptr;\n    int\t\tcount;\n#endif\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    if (LINEEMPTY(curwin->w_cursor.lnum) && vim_strchr(p_ww, '~') == NULL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    prep_redo_cmd(cap);\n\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    startpos = curwin->w_cursor;\n#ifdef FEAT_NETBEANS_INTG\n    pos = startpos;\n#endif\n    for (n = cap->count1; n > 0; --n)\n    {\n\tdid_change |= swapchar(cap->oap->op_type, &curwin->w_cursor);\n\tinc_cursor();\n\tif (gchar_cursor() == NUL)\n\t{\n\t    if (vim_strchr(p_ww, '~') != NULL\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n#ifdef FEAT_NETBEANS_INTG\n\t\tif (netbeans_active())\n\t\t{\n\t\t    if (did_change)\n\t\t    {\n\t\t\tptr = ml_get(pos.lnum);\n\t\t\tcount = (int)STRLEN(ptr) - pos.col;\n\t\t\tnetbeans_removed(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t\t (long)count);\n\t\t\t// line may have been flushed, get it again\n\t\t\tptr = ml_get(pos.lnum);\n\t\t\tnetbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t&ptr[pos.col], count);\n\t\t    }\n\t\t    pos.col = 0;\n\t\t    pos.lnum++;\n\t\t}\n#endif\n\t\t++curwin->w_cursor.lnum;\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (n > 1)\n\t\t{\n\t\t    if (u_savesub(curwin->w_cursor.lnum) == FAIL)\n\t\t\tbreak;\n\t\t    u_clearline();\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n    }\n#ifdef FEAT_NETBEANS_INTG\n    if (did_change && netbeans_active())\n    {\n\tptr = ml_get(pos.lnum);\n\tcount = curwin->w_cursor.col - pos.col;\n\tnetbeans_removed(curbuf, pos.lnum, pos.col, (long)count);\n\tnetbeans_inserted(curbuf, pos.lnum, pos.col, &ptr[pos.col], count);\n    }\n#endif\n\n\n    check_cursor();\n    curwin->w_set_curswant = TRUE;\n    if (did_change)\n    {\n\tchanged_lines(startpos.lnum, startpos.col, curwin->w_cursor.lnum + 1,\n\t\t\t\t\t\t\t\t\t  0L);\n\tcurbuf->b_op_start = startpos;\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tif (curbuf->b_op_end.col > 0)\n\t    --curbuf->b_op_end.col;\n    }\n}\n\n/*\n * Move cursor to mark.\n */\n    static void\nnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos)\n{\n    if (check_mark(pos) == FAIL)\n\tclearop(cap->oap);\n    else\n    {\n\tif (cap->cmdchar == '\\''\n\t\t|| cap->cmdchar == '`'\n\t\t|| cap->cmdchar == '['\n\t\t|| cap->cmdchar == ']')\n\t    setpcmark();\n\tcurwin->w_cursor = *pos;\n\tif (flag)\n\t    beginline(BL_WHITE | BL_FIX);\n\telse\n\t    check_cursor();\n    }\n    cap->oap->motion_type = flag ? MLINE : MCHAR;\n    if (cap->cmdchar == '`')\n\tcap->oap->use_reg_one = TRUE;\n    cap->oap->inclusive = FALSE;\t\t// ignored if not MCHAR\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * Handle commands that are operators in Visual mode.\n */\n    static void\nv_visop(cmdarg_T *cap)\n{\n    static char_u trans[] = \"YyDdCcxdXdAAIIrr\";\n\n    // Uppercase means linewise, except in block mode, then \"D\" deletes till\n    // the end of the line, and \"C\" replaces till EOL\n    if (isupper(cap->cmdchar))\n    {\n\tif (VIsual_mode != Ctrl_V)\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\telse if (cap->cmdchar == 'C' || cap->cmdchar == 'D')\n\t    curwin->w_curswant = MAXCOL;\n    }\n    cap->cmdchar = *(vim_strchr(trans, cap->cmdchar) + 1);\n    nv_operator(cap);\n}\n\n/*\n * \"s\" and \"S\" commands.\n */\n    static void\nnv_subst(cmdarg_T *cap)\n{\n#ifdef FEAT_TERMINAL\n    // When showing output of term_dumpdiff() swap the top and bottom.\n    if (term_swap_diff() == OK)\n\treturn;\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n    if (VIsual_active)\t// \"vs\" and \"vS\" are the same as \"vc\"\n    {\n\tif (cap->cmdchar == 'S')\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\tcap->cmdchar = 'c';\n\tnv_operator(cap);\n    }\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Abbreviated commands.\n */\n    static void\nnv_abbrev(cmdarg_T *cap)\n{\n    if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)\n\tcap->cmdchar = 'x';\t\t// DEL key behaves like 'x'\n\n    // in Visual mode these commands are operators\n    if (VIsual_active)\n\tv_visop(cap);\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Translate a command into another command.\n */\n    static void\nnv_optrans(cmdarg_T *cap)\n{\n    static char_u *(ar[8]) = {(char_u *)\"dl\", (char_u *)\"dh\",\n\t\t\t      (char_u *)\"d$\", (char_u *)\"c$\",\n\t\t\t      (char_u *)\"cl\", (char_u *)\"cc\",\n\t\t\t      (char_u *)\"yy\", (char_u *)\":s\\r\"};\n    static char_u *str = (char_u *)\"xXDCsSY&\";\n\n    if (!checkclearopq(cap->oap))\n    {\n\t// In Vi \"2D\" doesn't delete the next line.  Can't translate it\n\t// either, because \"2.\" should also not use the count.\n\tif (cap->cmdchar == 'D' && vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t{\n\t    cap->oap->start = curwin->w_cursor;\n\t    cap->oap->op_type = OP_DELETE;\n#ifdef FEAT_EVAL\n\t    set_op_var(OP_DELETE);\n#endif\n\t    cap->count1 = 1;\n\t    nv_dollar(cap);\n\t    finish_op = TRUE;\n\t    ResetRedobuff();\n\t    AppendCharToRedobuff('D');\n\t}\n\telse\n\t{\n\t    if (cap->count0)\n\t\tstuffnumReadbuff(cap->count0);\n\t    stuffReadbuff(ar[(int)(vim_strchr(str, cap->cmdchar) - str)]);\n\t}\n    }\n    cap->opcount = 0;\n}\n\n/*\n * \"'\" and \"`\" commands.  Also for \"g'\" and \"g`\".\n * cap->arg is TRUE for \"'\" and \"g'\".\n */\n    static void\nnv_gomark(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n    int\t\tc;\n#ifdef FEAT_FOLDING\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n#endif\n\n    if (cap->cmdchar == 'g')\n\tc = cap->extra_char;\n    else\n\tc = cap->nchar;\n    pos = getmark(c, (cap->oap->op_type == OP_NOP));\n    if (pos == (pos_T *)-1)\t    // jumped to other file\n    {\n\tif (cap->arg)\n\t{\n\t    check_cursor_lnum();\n\t    beginline(BL_WHITE | BL_FIX);\n\t}\n\telse\n\t    check_cursor();\n    }\n    else\n\tnv_cursormark(cap, cap->arg, pos);\n\n    // May need to clear the coladd that a mark includes.\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    check_cursor_col();\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && pos != NULL\n\t    && (pos == (pos_T *)-1 || !EQUAL_POS(old_cursor, *pos))\n\t    && (fdo_flags & FDO_MARK)\n\t    && old_KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle CTRL-O, CTRL-I, \"g;\", \"g,\" and \"CTRL-Tab\" commands.\n */\n    static void\nnv_pcmark(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n#endif\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    if (cap->cmdchar == TAB && mod_mask == MOD_MASK_CTRL)\n    {\n\tif (goto_tabpage_lastused() == FAIL)\n\t    clearopbeep(cap->oap);\n\treturn;\n    }\n    if (cap->cmdchar == 'g')\n\tpos = movechangelist((int)cap->count1);\n    else\n\tpos = movemark((int)cap->count1);\n    if (pos == (pos_T *)-1)\t\t// jump to other file\n    {\n\tcurwin->w_set_curswant = TRUE;\n\tcheck_cursor();\n    }\n    else if (pos != NULL)\t\t    // can jump\n\tnv_cursormark(cap, FALSE, pos);\n    else if (cap->cmdchar == 'g')\n    {\n\tif (curbuf->b_changelistlen == 0)\n\t    emsg(_(e_changelist_is_empty));\n\telse if (cap->count1 < 0)\n\t    emsg(_(e_at_start_of_changelist));\n\telse\n\t    emsg(_(e_at_end_of_changelist));\n    }\n    else\n\tclearopbeep(cap->oap);\n# ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && (pos == (pos_T *)-1 || lnum != curwin->w_cursor.lnum)\n\t    && (fdo_flags & FDO_MARK)\n\t    && old_KeyTyped)\n\tfoldOpenCursor();\n# endif\n}\n\n/*\n * Handle '\"' command.\n */\n    static void\nnv_regname(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n\tcap->nchar = get_expr_register();\n#endif\n    if (cap->nchar != NUL && valid_yank_reg(cap->nchar, FALSE))\n    {\n\tcap->oap->regname = cap->nchar;\n\tcap->opcount = cap->count0;\t// remember count before '\"'\n#ifdef FEAT_EVAL\n\tset_reg_var(cap->oap->regname);\n#endif\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle \"v\", \"V\" and \"CTRL-V\" commands.\n * Also for \"gh\", \"gH\" and \"g^H\" commands: Always start Select mode, cap->arg\n * is TRUE.\n * Handle CTRL-Q just like CTRL-V.\n */\n    static void\nnv_visual(cmdarg_T *cap)\n{\n    if (cap->cmdchar == Ctrl_Q)\n\tcap->cmdchar = Ctrl_V;\n\n    // 'v', 'V' and CTRL-V can be used while an operator is pending to make it\n    // characterwise, linewise, or blockwise.\n    if (cap->oap->op_type != OP_NOP)\n    {\n\tmotion_force = cap->oap->motion_force = cap->cmdchar;\n\tfinish_op = FALSE;\t// operator doesn't finish now but later\n\treturn;\n    }\n\n    VIsual_select = cap->arg;\n    if (VIsual_active)\t    // change Visual mode\n    {\n\tif (VIsual_mode == cap->cmdchar)    // stop visual mode\n\t    end_visual_mode();\n\telse\t\t\t\t    // toggle char/block mode\n\t{\t\t\t\t    //\t   or char/line mode\n\t    VIsual_mode = cap->cmdchar;\n\t    showmode();\n\t    may_trigger_modechanged();\n\t}\n\tredraw_curbuf_later(UPD_INVERTED);\t    // update the inversion\n    }\n    else\t\t    // start Visual mode\n    {\n\tcheck_visual_highlight();\n\tif (cap->count0 > 0 && resel_VIsual_mode != NUL)\n\t{\n\t    // use previously selected part\n\t    VIsual = curwin->w_cursor;\n\n\t    VIsual_active = TRUE;\n\t    VIsual_reselect = TRUE;\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    setmouse();\n\t    if (p_smd && msg_silent == 0)\n\t\tredraw_cmdline = TRUE;\t    // show visual mode later\n\t    // For V and ^V, we multiply the number of lines even if there\n\t    // was only one -- webb\n\t    if (resel_VIsual_mode != 'v' || resel_VIsual_line_count > 1)\n\t    {\n\t\tcurwin->w_cursor.lnum +=\n\t\t\t\t    resel_VIsual_line_count * cap->count0 - 1;\n\t\tcheck_cursor();\n\t    }\n\t    VIsual_mode = resel_VIsual_mode;\n\t    if (VIsual_mode == 'v')\n\t    {\n\t\tif (resel_VIsual_line_count <= 1)\n\t\t{\n\t\t    update_curswant_force();\n\t\t    curwin->w_curswant += resel_VIsual_vcol * cap->count0;\n\t\t    if (*p_sel != 'e')\n\t\t\t--curwin->w_curswant;\n\t\t}\n\t\telse\n\t\t    curwin->w_curswant = resel_VIsual_vcol;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    if (resel_VIsual_vcol == MAXCOL)\n\t    {\n\t\tcurwin->w_curswant = MAXCOL;\n\t\tcoladvance((colnr_T)MAXCOL);\n\t    }\n\t    else if (VIsual_mode == Ctrl_V)\n\t    {\n\t\t// Update curswant on the original line, that is where \"col\" is\n\t\t// valid.\n\t\tlinenr_T lnum = curwin->w_cursor.lnum;\n\t\tcurwin->w_cursor.lnum = VIsual.lnum;\n\t\tupdate_curswant_force();\n\t\tcurwin->w_curswant += resel_VIsual_vcol * cap->count0 - 1;\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n\t    redraw_curbuf_later(UPD_INVERTED);\t// show the inversion\n\t}\n\telse\n\t{\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    n_start_visual_mode(cap->cmdchar);\n\t    if (VIsual_mode != 'V' && *p_sel == 'e')\n\t\t++cap->count1;  // include one more char\n\t    if (cap->count0 > 0 && --cap->count1 > 0)\n\t    {\n\t\t// With a count select that many characters or lines.\n\t\tif (VIsual_mode == 'v' || VIsual_mode == Ctrl_V)\n\t\t    nv_right(cap);\n\t\telse if (VIsual_mode == 'V')\n\t\t    nv_down(cap);\n\t    }\n\t}\n    }\n}\n\n/*\n * Start selection for Shift-movement keys.\n */\n    void\nstart_selection(void)\n{\n    // if 'selectmode' contains \"key\", start Select mode\n    may_start_select('k');\n    n_start_visual_mode('v');\n}\n\n/*\n * Start Select mode, if \"c\" is in 'selectmode' and not in a mapping or menu.\n * When \"c\" is 'o' (checking for \"mouse\") then also when mapped.\n */\n    void\nmay_start_select(int c)\n{\n    VIsual_select = (c == 'o' || (stuff_empty() && typebuf_typed()))\n\t\t    && vim_strchr(p_slm, c) != NULL;\n}\n\n/*\n * Start Visual mode \"c\".\n * Should set VIsual_select before calling this.\n */\n    static void\nn_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    // Corner case: the 0 position in a tab may change when going into\n    // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n\n    may_trigger_modechanged();\n    setmouse();\n#ifdef FEAT_CONCEAL\n    // Check if redraw is needed after changing the state.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t// show visual mode later\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end may still be the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n\n    // Only need to redraw this line, unless still need to redraw an old\n    // Visual area (when 'lazyredraw' is set).\n    if (curwin->w_redr_type < UPD_INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}\n\n\n/*\n * CTRL-W: Window commands\n */\n    static void\nnv_window(cmdarg_T *cap)\n{\n    if (cap->nchar == ':')\n    {\n\t// \"CTRL-W :\" is the same as typing \":\"; useful in a terminal window\n\tcap->cmdchar = ':';\n\tcap->nchar = NUL;\n\tnv_colon(cap);\n    }\n    else if (!checkclearop(cap->oap))\n\tdo_window(cap->nchar, cap->count0, NUL); // everything is in window.c\n}\n\n/*\n * CTRL-Z: Suspend\n */\n    static void\nnv_suspend(cmdarg_T *cap)\n{\n    clearop(cap->oap);\n    if (VIsual_active)\n\tend_visual_mode();\t\t// stop Visual mode\n    do_cmdline_cmd((char_u *)\"stop\");\n}\n\n/*\n * \"gv\": Reselect the previous Visual area.  If Visual already active,\n *       exchange previous and current Visual area.\n */\n    static void\nnv_gv_cmd(cmdarg_T *cap)\n{\n    pos_T\ttpos;\n    int\t\ti;\n\n    if (checkclearop(cap->oap))\n\treturn;\n\n    if (curbuf->b_visual.vi_start.lnum == 0\n\t    || curbuf->b_visual.vi_start.lnum > curbuf->b_ml.ml_line_count\n\t    || curbuf->b_visual.vi_end.lnum == 0)\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    // set w_cursor to the start of the Visual area, tpos to the end\n    if (VIsual_active)\n    {\n\ti = VIsual_mode;\n\tVIsual_mode = curbuf->b_visual.vi_mode;\n\tcurbuf->b_visual.vi_mode = i;\n# ifdef FEAT_EVAL\n\tcurbuf->b_visual_mode_eval = i;\n# endif\n\ti = curwin->w_curswant;\n\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\tcurbuf->b_visual.vi_curswant = i;\n\n\ttpos = curbuf->b_visual.vi_end;\n\tcurbuf->b_visual.vi_end = curwin->w_cursor;\n\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n\tcurbuf->b_visual.vi_start = VIsual;\n    }\n    else\n    {\n\tVIsual_mode = curbuf->b_visual.vi_mode;\n\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\ttpos = curbuf->b_visual.vi_end;\n\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n    }\n\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    // Set Visual to the start and w_cursor to the end of the Visual\n    // area.  Make sure they are on an existing character.\n    check_cursor();\n    VIsual = curwin->w_cursor;\n    curwin->w_cursor = tpos;\n    check_cursor();\n    update_topline();\n\n    // When called from normal \"g\" command: start Select mode when\n    // 'selectmode' contains \"cmd\".  When called for K_SELECT, always\n    // start Select mode.\n    if (cap->arg)\n    {\n\tVIsual_select = TRUE;\n\tVIsual_select_reg = 0;\n    }\n    else\n\tmay_start_select('c');\n    setmouse();\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end are still the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n    redraw_curbuf_later(UPD_INVERTED);\n    showmode();\n}\n\n/*\n * \"g0\", \"g^\" : Like \"0\" and \"^\" but for screen lines.\n * \"gm\": middle of \"g0\" and \"g$\".\n */\n    static void\nnv_g_home_m_cmd(cmdarg_T *cap)\n{\n    int\t\ti;\n    int\t\tflag = FALSE;\n\n    if (cap->nchar == '^')\n\tflag = TRUE;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tint\twidth1 = curwin->w_width - curwin_col_off();\n\tint\twidth2 = width1 + curwin_col_off2();\n\tint\tvirtcol;\n\n\tvalidate_virtcol();\n\tvirtcol = curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t    - curwin->w_virtcol_first_char\n#endif\n\t    ;\n\ti = 0;\n\tif (virtcol >= (colnr_T)width1 && width2 > 0)\n\t    i = (virtcol - width1) / width2 * width2 + width1;\n    }\n    else\n\ti = curwin->w_leftcol;\n    // Go to the middle of the screen line.  When 'number' or\n    // 'relativenumber' is on and lines are wrapping the middle can be more\n    // to the left.\n    if (cap->nchar == 'm')\n\ti += (curwin->w_width - curwin_col_off()\n\t\t+ ((curwin->w_p_wrap && i > 0)\n\t\t    ? curwin_col_off2() : 0)) / 2;\n    coladvance((colnr_T)i);\n    if (flag)\n    {\n\tdo\n\t    i = gchar_cursor();\n\twhile (VIM_ISWHITE(i) && oneright() == OK);\n\tcurwin->w_valid &= ~VALID_WCOL;\n    }\n    curwin->w_set_curswant = TRUE;\n    adjust_skipcol();\n}\n\n/*\n * \"g_\": to the last non-blank character in the line or <count> lines\n *       downward.\n */\n    static void\nnv_g_underscore_cmd(cmdarg_T *cap)\n{\n    char_u  *ptr;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = TRUE;\n    curwin->w_curswant = MAXCOL;\n    if (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\tcap->oap->op_type == OP_NOP) == FAIL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    ptr = ml_get_curline();\n\n    // In Visual mode we may end up after the line.\n    if (curwin->w_cursor.col > 0 && ptr[curwin->w_cursor.col] == NUL)\n\t--curwin->w_cursor.col;\n\n    // Decrease the cursor column until it's on a non-blank.\n    while (curwin->w_cursor.col > 0\n\t    && VIM_ISWHITE(ptr[curwin->w_cursor.col]))\n\t--curwin->w_cursor.col;\n    curwin->w_set_curswant = TRUE;\n    adjust_for_sel(cap);\n}\n\n/*\n * \"g$\" : Like \"$\" but for screen lines.\n */\n    static void\nnv_g_dollar_cmd(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    int\t\ti;\n    int\t\tcol_off = curwin_col_off();\n    int\t\tflag = FALSE;\n\n    if (cap->nchar == K_END || cap->nchar == K_KEND)\n\tflag = TRUE;\n\n    oap->motion_type = MCHAR;\n    oap->inclusive = TRUE;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tcurwin->w_curswant = MAXCOL;    // so we stay at the end\n\tif (cap->count1 == 1)\n\t{\n\t    int\t\twidth1 = curwin->w_width - col_off;\n\t    int\t\twidth2 = width1 + curwin_col_off2();\n\t    int\t\tvirtcol;\n\n\t    validate_virtcol();\n\t    virtcol = curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t\t- curwin->w_virtcol_first_char\n#endif\n\t\t;\n\t    i = width1 - 1;\n\t    if (virtcol >= (colnr_T)width1)\n\t\ti += ((virtcol - width1) / width2 + 1)\n\t\t    * width2;\n\t    coladvance((colnr_T)i);\n\n\t    // Make sure we stick in this column.\n\t    update_curswant_force();\n\t    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n\t    {\n\t\t// Check for landing on a character that got split at\n\t\t// the end of the line.  We do not want to advance to\n\t\t// the next screen line.\n\t\tif (curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t\t\t- curwin->w_virtcol_first_char\n#endif\n\t\t\t\t\t\t> (colnr_T)i)\n\t\t    --curwin->w_cursor.col;\n\t    }\n\t}\n\telse if (nv_screengo(oap, FORWARD, cap->count1 - 1) == FAIL)\n\t    clearopbeep(oap);\n    }\n    else\n    {\n\tif (cap->count1 > 1)\n\t    // if it fails, let the cursor still move to the last char\n\t    (void)cursor_down(cap->count1 - 1, FALSE);\n\n\ti = curwin->w_leftcol + curwin->w_width - col_off - 1;\n\tcoladvance((colnr_T)i);\n\n\t// if the character doesn't fit move one back\n\tif (curwin->w_cursor.col > 0\n\t\t&& (*mb_ptr2cells)(ml_get_cursor()) > 1)\n\t{\n\t    colnr_T vcol;\n\n\t    getvvcol(curwin, &curwin->w_cursor, NULL, NULL, &vcol);\n\t    if (vcol >= curwin->w_leftcol + curwin->w_width - col_off)\n\t\t--curwin->w_cursor.col;\n\t}\n\n\t// Make sure we stick in this column.\n\tupdate_curswant_force();\n    }\n    if (flag)\n    {\n\tdo\n\t    i = gchar_cursor();\n\twhile (VIM_ISWHITE(i) && oneleft() == OK);\n\tcurwin->w_valid &= ~VALID_WCOL;\n    }\n}\n\n/*\n * \"gi\": start Insert at the last position.\n */\n    static void\nnv_gi_cmd(cmdarg_T *cap)\n{\n    int\t\ti;\n\n    if (curbuf->b_last_insert.lnum != 0)\n    {\n\tcurwin->w_cursor = curbuf->b_last_insert;\n\tcheck_cursor_lnum();\n\ti = (int)STRLEN(ml_get_curline());\n\tif (curwin->w_cursor.col > (colnr_T)i)\n\t{\n\t    if (virtual_active())\n\t\tcurwin->w_cursor.coladd += curwin->w_cursor.col - i;\n\t    curwin->w_cursor.col = i;\n\t}\n    }\n    cap->cmdchar = 'i';\n    nv_edit(cap);\n}\n\n/*\n * Commands starting with \"g\".\n */\n    static void\nnv_g_cmd(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    int\t\ti;\n\n    switch (cap->nchar)\n    {\n    case Ctrl_A:\n    case Ctrl_X:\n#ifdef MEM_PROFILE\n    // \"g^A\": dump log of used memory.\n\tif (!VIsual_active && cap->nchar == Ctrl_A)\n\t    vim_mem_profile_dump();\n\telse\n#endif\n    // \"g^A/g^X\": sequentially increment visually selected region\n\tif (VIsual_active)\n\t{\n\t    cap->arg = TRUE;\n\t    cap->cmdchar = cap->nchar;\n\t    cap->nchar = NUL;\n\t    nv_addsub(cap);\n\t}\n\telse\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gR\": Enter virtual replace mode.\n    case 'R':\n\tcap->arg = TRUE;\n\tnv_Replace(cap);\n\tbreak;\n\n    case 'r':\n\tnv_vreplace(cap);\n\tbreak;\n\n    case '&':\n\tdo_cmdline_cmd((char_u *)\"%s//~/&\");\n\tbreak;\n\n    // \"gv\": Reselect the previous Visual area.  If Visual already active,\n    // exchange previous and current Visual area.\n    case 'v':\n\tnv_gv_cmd(cap);\n\tbreak;\n\n    // \"gV\": Don't reselect the previous Visual area after a Select mode\n    // mapping of menu.\n    case 'V':\n\tVIsual_reselect = FALSE;\n\tbreak;\n\n    // \"gh\":  start Select mode.\n    // \"gH\":  start Select line mode.\n    // \"g^H\": start Select block mode.\n    case K_BS:\n\tcap->nchar = Ctrl_H;\n\t// FALLTHROUGH\n    case 'h':\n    case 'H':\n    case Ctrl_H:\n\tcap->cmdchar = cap->nchar + ('v' - 'h');\n\tcap->arg = TRUE;\n\tnv_visual(cap);\n\tbreak;\n\n    // \"gn\", \"gN\" visually select next/previous search match\n    // \"gn\" selects next match\n    // \"gN\" selects previous match\n    case 'N':\n    case 'n':\n\tif (!current_search(cap->count1, cap->nchar == 'n'))\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gj\" and \"gk\" two new funny movement keys -- up and down\n    // movement based on *screen* line rather than *file* line.\n    case 'j':\n    case K_DOWN:\n\t// with 'nowrap' it works just like the normal \"j\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_down(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, FORWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case 'k':\n    case K_UP:\n\t// with 'nowrap' it works just like the normal \"k\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_up(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, BACKWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gJ\": join two lines without inserting a space.\n    case 'J':\n\tnv_join(cap);\n\tbreak;\n\n    // \"g0\", \"g^\" : Like \"0\" and \"^\" but for screen lines.\n    // \"gm\": middle of \"g0\" and \"g$\".\n    case '^':\n    case '0':\n    case 'm':\n    case K_HOME:\n    case K_KHOME:\n\tnv_g_home_m_cmd(cap);\n\tbreak;\n\n    case 'M':\n\t{\n\t    oap->motion_type = MCHAR;\n\t    oap->inclusive = FALSE;\n\t    i = linetabsize(curwin, curwin->w_cursor.lnum);\n\t    if (cap->count0 > 0 && cap->count0 <= 100)\n\t\tcoladvance((colnr_T)(i * cap->count0 / 100));\n\t    else\n\t\tcoladvance((colnr_T)(i / 2));\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tbreak;\n\n    // \"g_\": to the last non-blank character in the line or <count> lines\n    // downward.\n    case '_':\n\tnv_g_underscore_cmd(cap);\n\tbreak;\n\n    // \"g$\" : Like \"$\" but for screen lines.\n    case '$':\n    case K_END:\n    case K_KEND:\n\tnv_g_dollar_cmd(cap);\n\tbreak;\n\n    // \"g*\" and \"g#\", like \"*\" and \"#\" but without using \"\\<\" and \"\\>\"\n    case '*':\n    case '#':\n#if POUND != '#'\n    case POUND:\t\t// pound sign (sometimes equal to '#')\n#endif\n    case Ctrl_RSB:\t\t// :tag or :tselect for current identifier\n    case ']':\t\t\t// :tselect for current identifier\n\tnv_ident(cap);\n\tbreak;\n\n    // ge and gE: go back to end of word\n    case 'e':\n    case 'E':\n\toap->motion_type = MCHAR;\n\tcurwin->w_set_curswant = TRUE;\n\toap->inclusive = TRUE;\n\tif (bckend_word(cap->count1, cap->nchar == 'E', FALSE) == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"g CTRL-G\": display info about cursor position\n    case Ctrl_G:\n\tcursor_pos_info(NULL);\n\tbreak;\n\n    // \"gi\": start Insert at the last position.\n    case 'i':\n\tnv_gi_cmd(cap);\n\tbreak;\n\n    // \"gI\": Start insert in column 1.\n    case 'I':\n\tbeginline(0);\n\tif (!checkclearopq(oap))\n\t    invoke_edit(cap, FALSE, 'g', FALSE);\n\tbreak;\n\n    // \"gf\": goto file, edit file under cursor\n    // \"]f\" and \"[f\": can also be used.\n    case 'f':\n    case 'F':\n\tnv_gotofile(cap);\n\tbreak;\n\n    // \"g'm\" and \"g`m\": jump to mark without setting pcmark\n    case '\\'':\n\tcap->arg = TRUE;\n\t// FALLTHROUGH\n    case '`':\n\tnv_gomark(cap);\n\tbreak;\n\n    // \"gs\": Goto sleep.\n    case 's':\n\tdo_sleep(cap->count1 * 1000L, FALSE);\n\tbreak;\n\n    // \"ga\": Display the ascii value of the character under the\n    // cursor.\tIt is displayed in decimal, hex, and octal. -- webb\n    case 'a':\n\tdo_ascii(NULL);\n\tbreak;\n\n    // \"g8\": Display the bytes used for the UTF-8 character under the\n    // cursor.\tIt is displayed in hex.\n    // \"8g8\" finds illegal byte sequence.\n    case '8':\n\tif (cap->count0 == 8)\n\t    utf_find_illegal();\n\telse\n\t    show_utf8();\n\tbreak;\n\n    // \"g<\": show scrollback text\n    case '<':\n\tshow_sb_text();\n\tbreak;\n\n    // \"gg\": Goto the first line in file.  With a count it goes to\n    // that line number like for \"G\". -- webb\n    case 'g':\n\tcap->arg = FALSE;\n\tnv_goto(cap);\n\tbreak;\n\n    //\t Two-character operators:\n    //\t \"gq\"\t    Format text\n    //\t \"gw\"\t    Format text and keep cursor position\n    //\t \"g~\"\t    Toggle the case of the text.\n    //\t \"gu\"\t    Change text to lower case.\n    //\t \"gU\"\t    Change text to upper case.\n    //   \"g?\"\t    rot13 encoding\n    //   \"g@\"\t    call 'operatorfunc'\n    case 'q':\n    case 'w':\n\toap->cursor_start = curwin->w_cursor;\n\t// FALLTHROUGH\n    case '~':\n    case 'u':\n    case 'U':\n    case '?':\n    case '@':\n\tnv_operator(cap);\n\tbreak;\n\n    // \"gd\": Find first occurrence of pattern under the cursor in the\n    //\t current function\n    // \"gD\": idem, but in the current file.\n    case 'd':\n    case 'D':\n\tnv_gd(oap, cap->nchar, (int)cap->count0);\n\tbreak;\n\n    // g<*Mouse> : <C-*mouse>\n    case K_MIDDLEMOUSE:\n    case K_MIDDLEDRAG:\n    case K_MIDDLERELEASE:\n    case K_LEFTMOUSE:\n    case K_LEFTDRAG:\n    case K_LEFTRELEASE:\n    case K_MOUSEMOVE:\n    case K_RIGHTMOUSE:\n    case K_RIGHTDRAG:\n    case K_RIGHTRELEASE:\n    case K_X1MOUSE:\n    case K_X1DRAG:\n    case K_X1RELEASE:\n    case K_X2MOUSE:\n    case K_X2DRAG:\n    case K_X2RELEASE:\n\tmod_mask = MOD_MASK_CTRL;\n\t(void)do_mouse(oap, cap->nchar, BACKWARD, cap->count1, 0);\n\tbreak;\n\n    case K_IGNORE:\n\tbreak;\n\n    // \"gP\" and \"gp\": same as \"P\" and \"p\" but leave cursor just after new text\n    case 'p':\n    case 'P':\n\tnv_put(cap);\n\tbreak;\n\n#ifdef FEAT_BYTEOFF\n    // \"go\": goto byte count from start of buffer\n    case 'o':\n\tgoto_byte(cap->count0);\n\tbreak;\n#endif\n\n    // \"gQ\": improved Ex mode\n    case 'Q':\n\tif (!check_text_locked(cap->oap) && !checkclearopq(oap))\n\t    do_exmode(TRUE);\n\tbreak;\n\n    case ',':\n\tnv_pcmark(cap);\n\tbreak;\n\n    case ';':\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n\tbreak;\n\n    case 't':\n\tif (!checkclearop(oap))\n\t    goto_tabpage((int)cap->count0);\n\tbreak;\n    case 'T':\n\tif (!checkclearop(oap))\n\t    goto_tabpage(-(int)cap->count1);\n\tbreak;\n\n    case TAB:\n\tif (!checkclearop(oap) && goto_tabpage_lastused() == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case '+':\n    case '-': // \"g+\" and \"g-\": undo or redo along the timeline\n\tif (!checkclearopq(oap))\n\t    undo_time(cap->nchar == '-' ? -cap->count1 : cap->count1,\n\t\t\t\t\t\t\t FALSE, FALSE, FALSE);\n\tbreak;\n\n    default:\n\tclearopbeep(oap);\n\tbreak;\n    }\n}\n\n/*\n * Handle \"o\" and \"O\" commands.\n */\n    static void\nn_opencmd(cmdarg_T *cap)\n{\n#ifdef FEAT_CONCEAL\n    linenr_T\toldline = curwin->w_cursor.lnum;\n#endif\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n#ifdef FEAT_FOLDING\n    if (cap->cmdchar == 'O')\n\t// Open above the first line of a folded sequence of lines\n\t(void)hasFolding(curwin->w_cursor.lnum,\n\t\t&curwin->w_cursor.lnum, NULL);\n    else\n\t// Open below the last line of a folded sequence of lines\n\t(void)hasFolding(curwin->w_cursor.lnum,\n\t\tNULL, &curwin->w_cursor.lnum);\n#endif\n    // trigger TextChangedI for the 'o/O' command\n    curbuf->b_last_changedtick_i = CHANGEDTICK(curbuf);\n    if (u_save((linenr_T)(curwin->w_cursor.lnum -\n\t\t    (cap->cmdchar == 'O' ? 1 : 0)),\n\t\t(linenr_T)(curwin->w_cursor.lnum +\n\t\t    (cap->cmdchar == 'o' ? 1 : 0))\n\t      ) == OK\n\t    && open_line(cap->cmdchar == 'O' ? BACKWARD : FORWARD,\n\t\thas_format_option(FO_OPEN_COMS) ? OPENLINE_DO_COM : 0,\n\t\t0, NULL) == OK)\n    {\n#ifdef FEAT_CONCEAL\n\tif (curwin->w_p_cole > 0 && oldline != curwin->w_cursor.lnum)\n\t    redrawWinline(curwin, oldline);\n#endif\n#ifdef FEAT_SYN_HL\n\tif (curwin->w_p_cul)\n\t    // force redraw of cursorline\n\t    curwin->w_valid &= ~VALID_CROW;\n#endif\n\t// When '#' is in 'cpoptions' ignore the count.\n\tif (vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t    cap->count1 = 1;\n\tinvoke_edit(cap, FALSE, cap->cmdchar, TRUE);\n    }\n}\n\n/*\n * \".\" command: redo last change.\n */\n    static void\nnv_dot(cmdarg_T *cap)\n{\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    // If \"restart_edit\" is TRUE, the last but one command is repeated\n    // instead of the last command (inserting text). This is used for\n    // CTRL-O <.> in insert mode.\n    if (start_redo(cap->count0, restart_edit != 0 && !arrow_used) == FAIL)\n\tclearopbeep(cap->oap);\n}\n\n/*\n * CTRL-R: undo undo or specify register in select mode\n */\n    static void\nnv_redo_or_register(cmdarg_T *cap)\n{\n    if (VIsual_select && VIsual_active)\n    {\n\tint reg;\n\t// Get register name\n\t++no_mapping;\n\t++allow_keys;\n\treg = plain_vgetc();\n\tLANGMAP_ADJUST(reg, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\n\tif (reg == '\"')\n\t    // the unnamed register is 0\n\t    reg = 0;\n\n\tVIsual_select_reg = valid_yank_reg(reg, TRUE) ? reg : 0;\n\treturn;\n    }\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    u_redo((int)cap->count1);\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * Handle \"U\" command.\n */\n    static void\nnv_Undo(cmdarg_T *cap)\n{\n    // In Visual mode and typing \"gUU\" triggers an operator\n    if (cap->oap->op_type == OP_UPPER || VIsual_active)\n    {\n\t// translate \"gUU\" to \"gUgU\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'U';\n\tnv_operator(cap);\n\treturn;\n    }\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    u_undoline();\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * '~' command: If tilde is not an operator and Visual is off: swap case of a\n * single character.\n */\n    static void\nnv_tilde(cmdarg_T *cap)\n{\n    if (!p_to && !VIsual_active && cap->oap->op_type != OP_TILDE)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf) && !prompt_curpos_editable())\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n#endif\n\tn_swapchar(cap);\n    }\n    else\n\tnv_operator(cap);\n}\n\n/*\n * Handle an operator command.\n * The actual work is done by do_pending_operator().\n */\n    static void\nnv_operator(cmdarg_T *cap)\n{\n    int\t    op_type;\n\n    op_type = get_op_type(cap->cmdchar, cap->nchar);\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && op_is_change(op_type) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    if (op_type == cap->oap->op_type)\t    // double operator works on lines\n\tnv_lineop(cap);\n    else if (!checkclearop(cap->oap))\n    {\n\tcap->oap->start = curwin->w_cursor;\n\tcap->oap->op_type = op_type;\n#ifdef FEAT_EVAL\n\tset_op_var(op_type);\n#endif\n    }\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:operator to the characters for \"optype\".\n */\n    static void\nset_op_var(int optype)\n{\n    char_u\topchars[3];\n\n    if (optype == OP_NOP)\n\tset_vim_var_string(VV_OP, NULL, 0);\n    else\n    {\n\topchars[0] = get_op_char(optype);\n\topchars[1] = get_extra_op_char(optype);\n\topchars[2] = NUL;\n\tset_vim_var_string(VV_OP, opchars, -1);\n    }\n}\n#endif\n\n/*\n * Handle linewise operator \"dd\", \"yy\", etc.\n *\n * \"_\" is is a strange motion command that helps make operators more logical.\n * It is actually implemented, but not documented in the real Vi.  This motion\n * command actually refers to \"the current line\".  Commands like \"dd\" and \"yy\"\n * are really an alternate form of \"d_\" and \"y_\".  It does accept a count, so\n * \"d3_\" works to delete 3 lines.\n */\n    static void\nnv_lineop(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MLINE;\n    if (cursor_down(cap->count1 - 1L, cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n    else if (  (cap->oap->op_type == OP_DELETE // only with linewise motions\n\t\t&& cap->oap->motion_force != 'v'\n\t\t&& cap->oap->motion_force != Ctrl_V)\n\t    || cap->oap->op_type == OP_LSHIFT\n\t    || cap->oap->op_type == OP_RSHIFT)\n\tbeginline(BL_SOL | BL_FIX);\n    else if (cap->oap->op_type != OP_YANK)\t// 'Y' does not move cursor\n\tbeginline(BL_WHITE | BL_FIX);\n}\n\n/*\n * <Home> command.\n */\n    static void\nnv_home(cmdarg_T *cap)\n{\n    // CTRL-HOME is like \"gg\"\n    if (mod_mask & MOD_MASK_CTRL)\n\tnv_goto(cap);\n    else\n    {\n\tcap->count0 = 1;\n\tnv_pipe(cap);\n    }\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * \"|\" command.\n */\n    static void\nnv_pipe(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(0);\n    if (cap->count0 > 0)\n    {\n\tcoladvance((colnr_T)(cap->count0 - 1));\n\tcurwin->w_curswant = (colnr_T)(cap->count0 - 1);\n    }\n    else\n\tcurwin->w_curswant = 0;\n    // keep curswant at the column where we wanted to go, not where\n    // we ended; differs if line is too short\n    curwin->w_set_curswant = FALSE;\n}\n\n/*\n * Handle back-word command \"b\" and \"B\".\n * cap->arg is 1 for \"B\"\n */\n    static void\nnv_bck_word(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n    if (bck_word(cap->count1, cap->arg, FALSE) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle word motion commands \"e\", \"E\", \"w\" and \"W\".\n * cap->arg is TRUE for \"E\" and \"W\".\n */\n    static void\nnv_wordcmd(cmdarg_T *cap)\n{\n    int\t\tn;\n    int\t\tword_end;\n    int\t\tflag = FALSE;\n    pos_T\tstartpos = curwin->w_cursor;\n\n    // Set inclusive for the \"E\" and \"e\" command.\n    if (cap->cmdchar == 'e' || cap->cmdchar == 'E')\n\tword_end = TRUE;\n    else\n\tword_end = FALSE;\n    cap->oap->inclusive = word_end;\n\n    // \"cw\" and \"cW\" are a special case.\n    if (!word_end && cap->oap->op_type == OP_CHANGE)\n    {\n\tn = gchar_cursor();\n\tif (n != NUL)\t\t\t// not an empty line\n\t{\n\t    if (VIM_ISWHITE(n))\n\t    {\n\t\t// Reproduce a funny Vi behaviour: \"cw\" on a blank only\n\t\t// changes one character, not all blanks until the start of\n\t\t// the next word.  Only do this when the 'w' flag is included\n\t\t// in 'cpoptions'.\n\t\tif (cap->count1 == 1 && vim_strchr(p_cpo, CPO_CW) != NULL)\n\t\t{\n\t\t    cap->oap->inclusive = TRUE;\n\t\t    cap->oap->motion_type = MCHAR;\n\t\t    return;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// This is a little strange. To match what the real Vi does,\n\t\t// we effectively map 'cw' to 'ce', and 'cW' to 'cE', provided\n\t\t// that we are not on a space or a TAB.  This seems impolite\n\t\t// at first, but it's really more what we mean when we say\n\t\t// 'cw'.\n\t\t// Another strangeness: When standing on the end of a word\n\t\t// \"ce\" will change until the end of the next word, but \"cw\"\n\t\t// will change only one character! This is done by setting\n\t\t// flag.\n\t\tcap->oap->inclusive = TRUE;\n\t\tword_end = TRUE;\n\t\tflag = TRUE;\n\t    }\n\t}\n    }\n\n    cap->oap->motion_type = MCHAR;\n    curwin->w_set_curswant = TRUE;\n    if (word_end)\n\tn = end_word(cap->count1, cap->arg, flag, FALSE);\n    else\n\tn = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);\n\n    // Don't leave the cursor on the NUL past the end of line. Unless we\n    // didn't move it forward.\n    if (LT_POS(startpos, curwin->w_cursor))\n\tadjust_cursor(cap->oap);\n\n    if (n == FAIL && cap->oap->op_type == OP_NOP)\n\tclearopbeep(cap->oap);\n    else\n    {\n\tadjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * Used after a movement command: If the cursor ends up on the NUL after the\n * end of the line, may move it back to the last character and make the motion\n * inclusive.\n */\n    static void\nadjust_cursor(oparg_T *oap)\n{\n    // The cursor cannot remain on the NUL when:\n    // - the column is > 0\n    // - not in Visual mode or 'selection' is \"o\"\n    // - 'virtualedit' is not \"all\" and not \"onemore\".\n    if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL\n\t\t&& (!VIsual_active || *p_sel == 'o')\n\t\t&& !virtual_active() && (get_ve_flags() & VE_ONEMORE) == 0)\n    {\n\t--curwin->w_cursor.col;\n\t// prevent cursor from moving on the trail byte\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\toap->inclusive = TRUE;\n    }\n}\n\n/*\n * \"0\" and \"^\" commands.\n * cap->arg is the argument for beginline().\n */\n    static void\nnv_beginline(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(cap->arg);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * In exclusive Visual mode, may include the last character.\n */\n    static void\nadjust_for_sel(cmdarg_T *cap)\n{\n    if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'\n\t    && gchar_cursor() != NUL && LT_POS(VIsual, curwin->w_cursor))\n    {\n\tif (has_mbyte)\n\t    inc_cursor();\n\telse\n\t    ++curwin->w_cursor.col;\n\tcap->oap->inclusive = FALSE;\n    }\n}\n\n/*\n * Exclude last character at end of Visual area for 'selection' == \"exclusive\".\n * Should check VIsual_mode before calling this.\n * Returns TRUE when backed up to the previous line.\n */\n    int\nunadjust_for_sel(void)\n{\n    pos_T\t*pp;\n\n    if (*p_sel == 'e' && !EQUAL_POS(VIsual, curwin->w_cursor))\n    {\n\tif (LT_POS(VIsual, curwin->w_cursor))\n\t    pp = &curwin->w_cursor;\n\telse\n\t    pp = &VIsual;\n\tif (pp->coladd > 0)\n\t    --pp->coladd;\n\telse\n\tif (pp->col > 0)\n\t{\n\t    --pp->col;\n\t    mb_adjustpos(curbuf, pp);\n\t}\n\telse if (pp->lnum > 1)\n\t{\n\t    --pp->lnum;\n\t    pp->col = (colnr_T)STRLEN(ml_get(pp->lnum));\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * SELECT key in Normal or Visual mode: end of Select mode mapping.\n */\n    static void\nnv_select(cmdarg_T *cap)\n{\n    if (VIsual_active)\n    {\n\tVIsual_select = TRUE;\n\tVIsual_select_reg = 0;\n    }\n    else if (VIsual_reselect)\n    {\n\tcap->nchar = 'v';\t    // fake \"gv\" command\n\tcap->arg = TRUE;\n\tnv_g_cmd(cap);\n    }\n}\n\n\n/*\n * \"G\", \"gg\", CTRL-END, CTRL-HOME.\n * cap->arg is TRUE for \"G\".\n */\n    static void\nnv_goto(cmdarg_T *cap)\n{\n    linenr_T\tlnum;\n\n    if (cap->arg)\n\tlnum = curbuf->b_ml.ml_line_count;\n    else\n\tlnum = 1L;\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    // When a count is given, use it instead of the default lnum\n    if (cap->count0 != 0)\n\tlnum = cap->count0;\n    if (lnum < 1L)\n\tlnum = 1L;\n    else if (lnum > curbuf->b_ml.ml_line_count)\n\tlnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.lnum = lnum;\n    beginline(BL_SOL | BL_FIX);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_JUMP) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * CTRL-\\ in Normal mode.\n */\n    static void\nnv_normal(cmdarg_T *cap)\n{\n    if (cap->nchar == Ctrl_N || cap->nchar == Ctrl_G)\n    {\n\tclearop(cap->oap);\n\tif (restart_edit != 0 && mode_displayed)\n\t    clear_cmdline = TRUE;\t\t// unshow mode later\n\trestart_edit = 0;\n\tif (cmdwin_type != 0)\n\t    cmdwin_result = Ctrl_C;\n\tif (VIsual_active)\n\t{\n\t    end_visual_mode();\t\t// stop Visual\n\t    redraw_curbuf_later(UPD_INVERTED);\n\t}\n\t// CTRL-\\ CTRL-G restarts Insert mode when 'insertmode' is set.\n\tif (cap->nchar == Ctrl_G && p_im)\n\t    restart_edit = 'a';\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * ESC in Normal mode: beep, but don't flush buffers.\n * Don't even beep if we are canceling a command.\n */\n    static void\nnv_esc(cmdarg_T *cap)\n{\n    int\t\tno_reason;\n\n    no_reason = (cap->oap->op_type == OP_NOP\n\t\t&& cap->opcount == 0\n\t\t&& cap->count0 == 0\n\t\t&& cap->oap->regname == 0\n\t\t&& !p_im);\n\n    if (cap->arg)\t\t// TRUE for CTRL-C\n    {\n\tif (restart_edit == 0 && cmdwin_type == 0\n\t\t\t\t\t\t&& !VIsual_active && no_reason)\n\t{\n\t    int\tout_redir = !stdout_isatty && !is_not_a_term_or_gui();\n\n\t    // The user may accidentally do \"vim file | grep word\" and then\n\t    // CTRL-C doesn't show anything.  With a changed buffer give the\n\t    // message on stderr.  Without any changes might as well exit.\n\t    if (anyBufIsChanged())\n\t    {\n\t\tchar *ms = _(\"Type  :qa!  and press <Enter> to abandon all changes and exit Vim\");\n\n\t\tif (out_redir)\n\t\t    mch_errmsg(ms);\n\t\telse\n\t\t    msg(ms);\n\t    }\n\t    else\n\t    {\n\t\tif (out_redir)\n\t\t{\n\t\t    got_int = FALSE;\n\t\t    do_cmdline_cmd((char_u *)\"qa\");\n\t\t}\n\t\telse\n\t\t    msg(_(\"Type  :qa  and press <Enter> to exit Vim\"));\n\t    }\n\t}\n\n\tif (restart_edit != 0)\n\t    redraw_mode = TRUE;  // remove \"-- (insert) --\"\n\n\t// Don't reset \"restart_edit\" when 'insertmode' is set, it won't be\n\t// set again below when halfway a mapping.\n\tif (!p_im)\n\t    restart_edit = 0;\n\tif (cmdwin_type != 0)\n\t{\n\t    cmdwin_result = K_IGNORE;\n\t    got_int = FALSE;\t// don't stop executing autocommands et al.\n\t    return;\n\t}\n    }\n    else if (cmdwin_type != 0 && ex_normal_busy && typebuf_was_empty)\n    {\n\t// When :normal runs out of characters while in the command line window\n\t// vgetorpeek() will repeatedly return ESC.  Exit the cmdline window to\n\t// break the loop.\n\tcmdwin_result = K_IGNORE;\n\treturn;\n    }\n\n    if (VIsual_active)\n    {\n\tend_visual_mode();\t// stop Visual\n\tcheck_cursor_col();\t// make sure cursor is not beyond EOL\n\tcurwin->w_set_curswant = TRUE;\n\tredraw_curbuf_later(UPD_INVERTED);\n    }\n    else if (no_reason)\n    {\n#ifdef HAS_MESSAGE_WINDOW\n\tif (!cap->arg && popup_message_win_visible())\n\t    popup_hide_message_win();\n\telse\n#endif\n\t    vim_beep(BO_ESC);\n    }\n    clearop(cap->oap);\n\n    // A CTRL-C is often used at the start of a menu.  When 'insertmode' is\n    // set return to Insert mode afterwards.\n    if (restart_edit == 0 && goto_im() && ex_normal_busy == 0)\n\trestart_edit = 'a';\n}\n\n/*\n * Move the cursor for the \"A\" command.\n */\n    void\nset_cursor_for_append_to_line(void)\n{\n    curwin->w_set_curswant = TRUE;\n    if (get_ve_flags() == VE_ALL)\n    {\n\tint save_State = State;\n\n\t// Pretend Insert mode here to allow the cursor on the\n\t// character past the end of the line\n\tState = MODE_INSERT;\n\tcoladvance((colnr_T)MAXCOL);\n\tState = save_State;\n    }\n    else\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(ml_get_cursor());\n}\n\n/*\n * Handle \"A\", \"a\", \"I\", \"i\" and <Insert> commands.\n * Also handle K_PS, start bracketed paste.\n */\n    static void\nnv_edit(cmdarg_T *cap)\n{\n    // <Insert> is equal to \"i\"\n    if (cap->cmdchar == K_INS || cap->cmdchar == K_KINS)\n\tcap->cmdchar = 'i';\n\n    // in Visual mode \"A\" and \"I\" are an operator\n    if (VIsual_active && (cap->cmdchar == 'A' || cap->cmdchar == 'I'))\n    {\n#ifdef FEAT_TERMINAL\n\tif (term_in_normal_mode())\n\t{\n\t    end_visual_mode();\n\t    clearop(cap->oap);\n\t    term_enter_job_mode();\n\t    return;\n\t}\n#endif\n\tv_visop(cap);\n    }\n\n    // in Visual mode and after an operator \"a\" and \"i\" are for text objects\n    else if ((cap->cmdchar == 'a' || cap->cmdchar == 'i')\n\t    && (cap->oap->op_type != OP_NOP || VIsual_active))\n    {\n\tnv_object(cap);\n    }\n#ifdef FEAT_TERMINAL\n    else if (term_in_normal_mode())\n    {\n\tclearop(cap->oap);\n\tterm_enter_job_mode();\n\treturn;\n    }\n#endif\n    else if (!curbuf->b_p_ma && !p_im)\n    {\n\t// Only give this error when 'insertmode' is off.\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\tclearop(cap->oap);\n\tif (cap->cmdchar == K_PS)\n\t    // drop the pasted text\n\t    bracketed_paste(PASTE_INSERT, TRUE, NULL);\n    }\n    else if (cap->cmdchar == K_PS && VIsual_active)\n    {\n\tpos_T old_pos = curwin->w_cursor;\n\tpos_T old_visual = VIsual;\n\tint old_visual_mode = VIsual_mode;\n\n\t// In Visual mode the selected text is deleted.\n\tif (VIsual_mode == 'V' || curwin->w_cursor.lnum != VIsual.lnum)\n\t{\n\t    shift_delete_registers();\n\t    cap->oap->regname = '1';\n\t}\n\telse\n\t    cap->oap->regname = '-';\n\tcap->cmdchar = 'd';\n\tcap->nchar = NUL;\n\tnv_operator(cap);\n\tdo_pending_operator(cap, 0, FALSE);\n\tcap->cmdchar = K_PS;\n\n\tif (*ml_get_cursor() != NUL)\n\t{\n\t    if (old_visual_mode == 'V')\n\t    {\n\t\t// In linewise Visual mode insert before the beginning of the\n\t\t// next line.\n\t\t// When the last line in the buffer was deleted then create a\n\t\t// new line, otherwise there is not need to move cursor.\n\t\t// Detect this by checking if cursor moved above Visual area.\n\t\tif (curwin->w_cursor.lnum < old_pos.lnum\n\t\t\t\t&& curwin->w_cursor.lnum < old_visual.lnum)\n\t\t{\n\t\t    if (u_save_cursor() == OK)\n\t\t    {\n\t\t\tml_append(curwin->w_cursor.lnum, (char_u *)\"\", 0,\n\t\t\t\t\t\t\t\t\tFALSE);\n\t\t\tappended_lines(curwin->w_cursor.lnum++, 1L);\n\t\t    }\n\t\t}\n\t    }\n\t    // When the last char in the line was deleted then append.\n\t    // Detect this by checking if cursor moved before Visual area.\n\t    else if (curwin->w_cursor.col < old_pos.col\n\t\t\t\t&& curwin->w_cursor.col < old_visual.col)\n\t\tinc_cursor();\n\t}\n\n\t// Insert to replace the deleted text with the pasted text.\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tswitch (cap->cmdchar)\n\t{\n\t    case 'A':\t// \"A\"ppend after the line\n\t\tset_cursor_for_append_to_line();\n\t\tbreak;\n\n\t    case 'I':\t// \"I\"nsert before the first non-blank\n\t\tif (vim_strchr(p_cpo, CPO_INSEND) == NULL)\n\t\t    beginline(BL_WHITE);\n\t\telse\n\t\t    beginline(BL_WHITE|BL_FIX);\n\t\tbreak;\n\n\t    case K_PS:\n\t\t// Bracketed paste works like \"a\"ppend, unless the cursor is in\n\t\t// the first column, then it inserts.\n\t\tif (curwin->w_cursor.col == 0)\n\t\t    break;\n\t\t// FALLTHROUGH\n\n\t    case 'a':\t// \"a\"ppend is like \"i\"nsert on the next character.\n\t\t// increment coladd when in virtual space, increment the\n\t\t// column otherwise, also to append after an unprintable char\n\t\tif (virtual_active()\n\t\t\t&& (curwin->w_cursor.coladd > 0\n\t\t\t    || *ml_get_cursor() == NUL\n\t\t\t    || *ml_get_cursor() == TAB))\n\t\t    curwin->w_cursor.coladd++;\n\t\telse if (*ml_get_cursor() != NUL)\n\t\t    inc_cursor();\n\t\tbreak;\n\t}\n\n\tif (curwin->w_cursor.coladd && cap->cmdchar != 'A')\n\t{\n\t    int save_State = State;\n\n\t    // Pretend Insert mode here to allow the cursor on the\n\t    // character past the end of the line\n\t    State = MODE_INSERT;\n\t    coladvance(getviscol());\n\t    State = save_State;\n\t}\n\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (cap->cmdchar == K_PS)\n\t// drop the pasted text\n\tbracketed_paste(PASTE_INSERT, TRUE, NULL);\n}\n\n/*\n * Invoke edit() and take care of \"restart_edit\" and the return value.\n */\n    static void\ninvoke_edit(\n    cmdarg_T\t*cap,\n    int\t\trepl,\t\t// \"r\" or \"gr\" command\n    int\t\tcmd,\n    int\t\tstartln)\n{\n    int\t\trestart_edit_save = 0;\n\n    // Complicated: When the user types \"a<C-O>a\" we don't want to do Insert\n    // mode recursively.  But when doing \"a<C-O>.\" or \"a<C-O>rx\" we do allow\n    // it.\n    if (repl || !stuff_empty())\n\trestart_edit_save = restart_edit;\n    else\n\trestart_edit_save = 0;\n\n    // Always reset \"restart_edit\", this is not a restarted edit.\n    restart_edit = 0;\n\n    // Reset Changedtick_i, so that TextChangedI will only be triggered for stuff\n    // from insert mode, for 'o/O' this has already been done in n_opencmd\n    if (cap->cmdchar != 'O' && cap->cmdchar != 'o')\n\tcurbuf->b_last_changedtick_i = CHANGEDTICK(curbuf);\n    if (edit(cmd, startln, cap->count1))\n\tcap->retval |= CA_COMMAND_BUSY;\n\n    if (restart_edit == 0)\n\trestart_edit = restart_edit_save;\n}\n\n/*\n * \"a\" or \"i\" while an operator is pending or in Visual mode: object motion.\n */\n    static void\nnv_object(\n    cmdarg_T\t*cap)\n{\n    int\t\tflag;\n    int\t\tinclude;\n    char_u\t*mps_save;\n\n    if (cap->cmdchar == 'i')\n\tinclude = FALSE;    // \"ix\" = inner object: exclude white space\n    else\n\tinclude = TRUE;\t    // \"ax\" = an object: include white space\n\n    // Make sure (), [], {} and <> are in 'matchpairs'\n    mps_save = curbuf->b_p_mps;\n    curbuf->b_p_mps = (char_u *)\"(:),{:},[:],<:>\";\n\n    switch (cap->nchar)\n    {\n\tcase 'w': // \"aw\" = a word\n\t\tflag = current_word(cap->oap, cap->count1, include, FALSE);\n\t\tbreak;\n\tcase 'W': // \"aW\" = a WORD\n\t\tflag = current_word(cap->oap, cap->count1, include, TRUE);\n\t\tbreak;\n\tcase 'b': // \"ab\" = a braces block\n\tcase '(':\n\tcase ')':\n\t\tflag = current_block(cap->oap, cap->count1, include, '(', ')');\n\t\tbreak;\n\tcase 'B': // \"aB\" = a Brackets block\n\tcase '{':\n\tcase '}':\n\t\tflag = current_block(cap->oap, cap->count1, include, '{', '}');\n\t\tbreak;\n\tcase '[': // \"a[\" = a [] block\n\tcase ']':\n\t\tflag = current_block(cap->oap, cap->count1, include, '[', ']');\n\t\tbreak;\n\tcase '<': // \"a<\" = a <> block\n\tcase '>':\n\t\tflag = current_block(cap->oap, cap->count1, include, '<', '>');\n\t\tbreak;\n#ifdef FEAT_EVAL\n\tcase 't': // \"at\" = a tag block (xml and html)\n\t\t// Do not adjust oap->end in do_pending_operator()\n\t\t// otherwise there are different results for 'dit'\n\t\t// (note leading whitespace in last line):\n\t\t// 1) <b>      2) <b>\n\t\t//    foobar      foobar\n\t\t//    </b>            </b>\n\t\tcap->retval |= CA_NO_ADJ_OP_END;\n\t\tflag = current_tagblock(cap->oap, cap->count1, include);\n\t\tbreak;\n#endif\n\tcase 'p': // \"ap\" = a paragraph\n\t\tflag = current_par(cap->oap, cap->count1, include, 'p');\n\t\tbreak;\n\tcase 's': // \"as\" = a sentence\n\t\tflag = current_sent(cap->oap, cap->count1, include);\n\t\tbreak;\n\tcase '\"': // \"a\"\" = a double quoted string\n\tcase '\\'': // \"a'\" = a single quoted string\n\tcase '`': // \"a`\" = a backtick quoted string\n\t\tflag = current_quote(cap->oap, cap->count1, include,\n\t\t\t\t\t\t\t\t  cap->nchar);\n\t\tbreak;\n#if 0\t// TODO\n\tcase 'S': // \"aS\" = a section\n\tcase 'f': // \"af\" = a filename\n\tcase 'u': // \"au\" = a URL\n#endif\n\tdefault:\n\t\tflag = FAIL;\n\t\tbreak;\n    }\n\n    curbuf->b_p_mps = mps_save;\n    if (flag == FAIL)\n\tclearopbeep(cap->oap);\n    adjust_cursor_col();\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * \"q\" command: Start/stop recording.\n * \"q:\", \"q/\", \"q?\": edit command-line in command-line window.\n */\n    static void\nnv_record(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_FORMAT)\n    {\n\t// \"gqq\" is the same as \"gqgq\": format line\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'q';\n\tnv_operator(cap);\n\treturn;\n    }\n\n    if (checkclearop(cap->oap))\n\treturn;\n\n    if (cap->nchar == ':' || cap->nchar == '/' || cap->nchar == '?')\n    {\n\tif (cmdwin_type != 0)\n\t{\n\t    emsg(_(e_cmdline_window_already_open));\n\t    return;\n\t}\n\tstuffcharReadbuff(cap->nchar);\n\tstuffcharReadbuff(K_CMDWIN);\n    }\n    else\n\t// (stop) recording into a named register, unless executing a\n\t// register\n\tif (reg_executing == 0 && do_record(cap->nchar) == FAIL)\n\t    clearopbeep(cap->oap);\n}\n\n/*\n * Handle the \"@r\" command.\n */\n    static void\nnv_at(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n    {\n\tif (get_expr_register() == NUL)\n\t    return;\n    }\n#endif\n    while (cap->count1-- && !got_int)\n    {\n\tif (do_execreg(cap->nchar, FALSE, FALSE, FALSE) == FAIL)\n\t{\n\t    clearopbeep(cap->oap);\n\t    break;\n\t}\n\tline_breakcheck();\n    }\n}\n\n/*\n * Handle the CTRL-U and CTRL-D commands.\n */\n    static void\nnv_halfpage(cmdarg_T *cap)\n{\n    if ((cap->cmdchar == Ctrl_U && curwin->w_cursor.lnum == 1)\n\t    || (cap->cmdchar == Ctrl_D\n\t\t&& curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count))\n\tclearopbeep(cap->oap);\n    else if (!checkclearop(cap->oap))\n\thalfpage(cap->cmdchar == Ctrl_D, cap->count0);\n}\n\n/*\n * Handle \"J\" or \"gJ\" command.\n */\n    static void\nnv_join(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// join the visual lines\n    {\n\tnv_operator(cap);\n\treturn;\n    }\n\n    if (checkclearop(cap->oap))\n\treturn;\n\n    if (cap->count0 <= 1)\n\tcap->count0 = 2;\t    // default for join is two lines!\n    if (curwin->w_cursor.lnum + cap->count0 - 1 >\n\t    curbuf->b_ml.ml_line_count)\n    {\n\t// can't join when on the last line\n\tif (cap->count0 <= 2)\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n\tcap->count0 = curbuf->b_ml.ml_line_count\n\t    - curwin->w_cursor.lnum + 1;\n    }\n\n    prep_redo(cap->oap->regname, cap->count0,\n\t    NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n    (void)do_join(cap->count0, cap->nchar == NUL, TRUE, TRUE, TRUE);\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n */\n    static void\nnv_put(cmdarg_T *cap)\n{\n    nv_put_opt(cap, FALSE);\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n * \"fix_indent\" is TRUE for \"[p\", \"[P\", \"]p\" and \"]P\".\n */\n    static void\nnv_put_opt(cmdarg_T *cap, int fix_indent)\n{\n    int\t\tregname = 0;\n    void\t*reg1 = NULL, *reg2 = NULL;\n    int\t\tempty = FALSE;\n    int\t\twas_visual = FALSE;\n    int\t\tdir;\n    int\t\tflags = 0;\n    int\t\tkeep_registers = FALSE;\n\n    if (cap->oap->op_type != OP_NOP)\n    {\n#ifdef FEAT_DIFF\n\t// \"dp\" is \":diffput\"\n\tif (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'p')\n\t{\n\t    clearop(cap->oap);\n\t    nv_diffgetput(TRUE, cap->opcount);\n\t}\n\telse\n#endif\n\t    clearopbeep(cap->oap);\n\treturn;\n    }\n\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    if (fix_indent)\n    {\n\tdir = (cap->cmdchar == ']' && cap->nchar == 'p')\n\t    ? FORWARD : BACKWARD;\n\tflags |= PUT_FIXINDENT;\n    }\n    else\n\tdir = (cap->cmdchar == 'P'\n\t\t|| ((cap->cmdchar == 'g' || cap->cmdchar == 'z')\n\t\t    && cap->nchar == 'P')) ? BACKWARD : FORWARD;\n    prep_redo_cmd(cap);\n    if (cap->cmdchar == 'g')\n\tflags |= PUT_CURSEND;\n    else if (cap->cmdchar == 'z')\n\tflags |= PUT_BLOCK_INNER;\n\n    if (VIsual_active)\n    {\n\t// Putting in Visual mode: The put text replaces the selected\n\t// text.  First delete the selected text, then put the new text.\n\t// Need to save and restore the registers that the delete\n\t// overwrites if the old contents is being put.\n\twas_visual = TRUE;\n\tregname = cap->oap->regname;\n\tkeep_registers = cap->cmdchar == 'P';\n#ifdef FEAT_CLIPBOARD\n\tadjust_clip_reg(&regname);\n#endif\n\tif (regname == 0 || regname == '\"'\n\t\t|| VIM_ISDIGIT(regname) || regname == '-'\n#ifdef FEAT_CLIPBOARD\n\t\t|| (clip_unnamed && (regname == '*' || regname == '+'))\n#endif\n\n\t   )\n\t{\n\t    // The delete is going to overwrite the register we want to\n\t    // put, save it first.\n\t    reg1 = get_register(regname, TRUE);\n\t}\n\n\t// Now delete the selected text. Avoid messages here.\n\tcap->cmdchar = 'd';\n\tcap->nchar = NUL;\n\tcap->oap->regname = keep_registers ? '_' : NUL;\n\t++msg_silent;\n\tnv_operator(cap);\n\tdo_pending_operator(cap, 0, FALSE);\n\tempty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n\t--msg_silent;\n\n\t// delete PUT_LINE_BACKWARD;\n\tcap->oap->regname = regname;\n\n\tif (reg1 != NULL)\n\t{\n\t    // Delete probably changed the register we want to put, save\n\t    // it first. Then put back what was there before the delete.\n\t    reg2 = get_register(regname, FALSE);\n\t    put_register(regname, reg1);\n\t}\n\n\t// When deleted a linewise Visual area, put the register as\n\t// lines to avoid it joined with the next line.  When deletion was\n\t// characterwise, split a line when putting lines.\n\tif (VIsual_mode == 'V')\n\t    flags |= PUT_LINE;\n\telse if (VIsual_mode == 'v')\n\t    flags |= PUT_LINE_SPLIT;\n\tif (VIsual_mode == Ctrl_V && dir == FORWARD)\n\t    flags |= PUT_LINE_FORWARD;\n\tdir = BACKWARD;\n\tif ((VIsual_mode != 'V'\n\t\t    && curwin->w_cursor.col < curbuf->b_op_start.col)\n\t\t|| (VIsual_mode == 'V'\n\t\t    && curwin->w_cursor.lnum < curbuf->b_op_start.lnum))\n\t    // cursor is at the end of the line or end of file, put\n\t    // forward.\n\t    dir = FORWARD;\n\t// May have been reset in do_put().\n\tVIsual_active = TRUE;\n    }\n    do_put(cap->oap->regname, NULL, dir, cap->count1, flags);\n\n    // If a register was saved, put it back now.\n    if (reg2 != NULL)\n\tput_register(regname, reg2);\n\n    // What to reselect with \"gv\"?  Selecting the just put text seems to\n    // be the most useful, since the original text was removed.\n    if (was_visual)\n    {\n\tcurbuf->b_visual.vi_start = curbuf->b_op_start;\n\tcurbuf->b_visual.vi_end = curbuf->b_op_end;\n\t// need to adjust cursor position\n\tif (*p_sel == 'e')\n\t    inc(&curbuf->b_visual.vi_end);\n    }\n\n    // When all lines were selected and deleted do_put() leaves an empty\n    // line that needs to be deleted now.\n    if (empty && *ml_get(curbuf->b_ml.ml_line_count) == NUL)\n    {\n\tml_delete_flags(curbuf->b_ml.ml_line_count, ML_DEL_MESSAGE);\n\tdeleted_lines(curbuf->b_ml.ml_line_count + 1, 1);\n\n\t// If the cursor was in that line, move it to the end of the last\n\t// line.\n\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t{\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    coladvance((colnr_T)MAXCOL);\n\t}\n    }\n    auto_format(FALSE, TRUE);\n}\n\n/*\n * \"o\" and \"O\" commands.\n */\n    static void\nnv_open(cmdarg_T *cap)\n{\n#ifdef FEAT_DIFF\n    // \"do\" is \":diffget\"\n    if (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'o')\n    {\n\tclearop(cap->oap);\n\tnv_diffgetput(FALSE, cap->opcount);\n    }\n    else\n#endif\n    if (VIsual_active)  // switch start and end of visual\n\tv_swap_corners(cap->cmdchar);\n#ifdef FEAT_JOB_CHANNEL\n    else if (bt_prompt(curbuf))\n\tclearopbeep(cap->oap);\n#endif\n    else\n\tn_opencmd(cap);\n}\n\n#ifdef FEAT_NETBEANS_INTG\n    static void\nnv_nbcmd(cmdarg_T *cap)\n{\n    netbeans_keycommand(cap->nchar);\n}\n#endif\n\n#ifdef FEAT_DND\n    static void\nnv_drop(cmdarg_T *cap UNUSED)\n{\n    do_put('~', NULL, BACKWARD, 1L, PUT_CURSEND);\n}\n#endif\n\n/*\n * Trigger CursorHold event.\n * When waiting for a character for 'updatetime' K_CURSORHOLD is put in the\n * input buffer.  \"did_cursorhold\" is set to avoid retriggering.\n */\n    static void\nnv_cursorhold(cmdarg_T *cap)\n{\n    apply_autocmds(EVENT_CURSORHOLD, NULL, NULL, FALSE, curbuf);\n    did_cursorhold = TRUE;\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n", "\" Test for various Normal mode commands\n\nsource shared.vim\nsource check.vim\nsource view_util.vim\nimport './vim9.vim' as v9\nsource screendump.vim\n\nfunc Setup_NewWindow()\n  10new\n  call setline(1, range(1,100))\nendfunc\n\nfunc MyFormatExpr()\n  \" Adds '->$' at lines having numbers followed by trailing whitespace\n  for ln in range(v:lnum, v:lnum+v:count-1)\n    let line = getline(ln)\n    if getline(ln) =~# '\\d\\s\\+$'\n      call setline(ln, substitute(line, '\\s\\+$', '', '') . '->$')\n    endif\n  endfor\nendfunc\n\nfunc CountSpaces(type, ...)\n  \" for testing operatorfunc\n  \" will count the number of spaces\n  \" and return the result in g:a\n  let sel_save = &selection\n  let &selection = \"inclusive\"\n  let reg_save = @@\n\n  if a:0  \" Invoked from Visual mode, use gv command.\n    silent exe \"normal! gvy\"\n  elseif a:type == 'line'\n    silent exe \"normal! '[V']y\"\n  else\n    silent exe \"normal! `[v`]y\"\n  endif\n  let g:a = strlen(substitute(@@, '[^ ]', '', 'g'))\n  let &selection = sel_save\n  let @@ = reg_save\nendfunc\n\nfunc OpfuncDummy(type, ...)\n  \" for testing operatorfunc\n  let g:opt = &linebreak\n\n  if a:0  \" Invoked from Visual mode, use gv command.\n    silent exe \"normal! gvy\"\n  elseif a:type == 'line'\n    silent exe \"normal! '[V']y\"\n  else\n    silent exe \"normal! `[v`]y\"\n  endif\n  \" Create a new dummy window\n  new\n  let g:bufnr = bufnr('%')\nendfunc\n\nfunc Test_normal00_optrans()\n  new\n  call append(0, ['1 This is a simple test: abcd', '2 This is the second line', '3 this is the third line'])\n  1\n  exe \"norm! Sfoobar\\<esc>\"\n  call assert_equal(['foobar', '2 This is the second line', '3 this is the third line', ''], getline(1,'$'))\n  2\n  exe \"norm! $vbsone\"\n  call assert_equal(['foobar', '2 This is the second one', '3 this is the third line', ''], getline(1,'$'))\n  norm! VS Second line here\n  call assert_equal(['foobar', ' Second line here', '3 this is the third line', ''], getline(1, '$'))\n  %d\n  call append(0, ['4 This is a simple test: abcd', '5 This is the second line', '6 this is the third line'])\n  call append(0, ['1 This is a simple test: abcd', '2 This is the second line', '3 this is the third line'])\n\n  1\n  norm! 2D\n  call assert_equal(['3 this is the third line', '4 This is a simple test: abcd', '5 This is the second line', '6 this is the third line', ''], getline(1,'$'))\n  set cpo+=#\n  norm! 4D\n  call assert_equal(['', '4 This is a simple test: abcd', '5 This is the second line', '6 this is the third line', ''], getline(1,'$'))\n\n  \" clean up\n  set cpo-=#\n  bw!\nendfunc\n\nfunc Test_normal01_keymodel()\n  call Setup_NewWindow()\n  \" Test 1: depending on 'keymodel' <s-down> does something different\n  50\n  call feedkeys(\"V\\<S-Up>y\", 'tx')\n  call assert_equal(['47', '48', '49', '50'], getline(\"'<\", \"'>\"))\n  set keymodel=startsel\n  50\n  call feedkeys(\"V\\<S-Up>y\", 'tx')\n  call assert_equal(['49', '50'], getline(\"'<\", \"'>\"))\n  \" Start visual mode when keymodel = startsel\n  50\n  call feedkeys(\"\\<S-Up>y\", 'tx')\n  call assert_equal(['49', '5'], getreg(0, 0, 1))\n  \" Use the different Shift special keys\n  50\n  call feedkeys(\"\\<S-Right>\\<S-Left>\\<S-Up>\\<S-Down>\\<S-Home>\\<S-End>y\", 'tx')\n  call assert_equal(['50'], getline(\"'<\", \"'>\"))\n  call assert_equal(['50', ''], getreg(0, 0, 1))\n\n  \" Do not start visual mode when keymodel=\n  set keymodel=\n  50\n  call feedkeys(\"\\<S-Up>y$\", 'tx')\n  call assert_equal(['42'], getreg(0, 0, 1))\n  \" Stop visual mode when keymodel=stopsel\n  set keymodel=stopsel\n  50\n  call feedkeys(\"Vkk\\<Up>yy\", 'tx')\n  call assert_equal(['47'], getreg(0, 0, 1))\n\n  set keymodel=\n  50\n  call feedkeys(\"Vkk\\<Up>yy\", 'tx')\n  call assert_equal(['47', '48', '49', '50'], getreg(0, 0, 1))\n\n  \" Test for using special keys to start visual selection\n  %d\n  call setline(1, ['red fox tail', 'red fox tail', 'red fox tail'])\n  set keymodel=startsel\n  \" Test for <S-PageUp> and <S-PageDown>\n  call cursor(1, 1)\n  call feedkeys(\"\\<S-PageDown>y\", 'xt')\n  call assert_equal([0, 1, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 3, 1, 0], getpos(\"'>\"))\n  call feedkeys(\"Gz\\<CR>8|\\<S-PageUp>y\", 'xt')\n  call assert_equal([0, 2, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 3, 8, 0], getpos(\"'>\"))\n  \" Test for <S-C-Home> and <S-C-End>\n  call cursor(2, 12)\n  call feedkeys(\"\\<S-C-Home>y\", 'xt')\n  call assert_equal([0, 1, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 2, 12, 0], getpos(\"'>\"))\n  call cursor(1, 4)\n  call feedkeys(\"\\<S-C-End>y\", 'xt')\n  call assert_equal([0, 1, 4, 0], getpos(\"'<\"))\n  call assert_equal([0, 3, 13, 0], getpos(\"'>\"))\n  \" Test for <S-C-Left> and <S-C-Right>\n  call cursor(2, 5)\n  call feedkeys(\"\\<S-C-Right>y\", 'xt')\n  call assert_equal([0, 2, 5, 0], getpos(\"'<\"))\n  call assert_equal([0, 2, 9, 0], getpos(\"'>\"))\n  call cursor(2, 9)\n  call feedkeys(\"\\<S-C-Left>y\", 'xt')\n  call assert_equal([0, 2, 5, 0], getpos(\"'<\"))\n  call assert_equal([0, 2, 9, 0], getpos(\"'>\"))\n\n  set keymodel&\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal03_join()\n  \" basic join test\n  call Setup_NewWindow()\n  50\n  norm! VJ\n  call assert_equal('50 51', getline('.'))\n  $\n  norm! J\n  call assert_equal('100', getline('.'))\n  $\n  norm! V9-gJ\n  call assert_equal('919293949596979899100', getline('.'))\n  call setline(1, range(1,100))\n  $\n  :j 10\n  call assert_equal('100', getline('.'))\n  call assert_beeps('normal GVJ')\n  \" clean up\n  bw!\nendfunc\n\n\" basic filter test\nfunc Test_normal04_filter()\n  \" only test on non windows platform\n  CheckNotMSWindows\n  call Setup_NewWindow()\n  1\n  call feedkeys(\"!!sed -e 's/^/|    /'\\n\", 'tx')\n  call assert_equal('|    1', getline('.'))\n  90\n  :sil :!echo one\n  call feedkeys('.', 'tx')\n  call assert_equal('|    90', getline('.'))\n  95\n  set cpo+=!\n  \" 2 <CR>, 1: for executing the command,\n  \"         2: clear hit-enter-prompt\n  call feedkeys(\"!!\\n\", 'tx')\n  call feedkeys(\":!echo one\\n\\n\", 'tx')\n  call feedkeys(\".\", 'tx')\n  call assert_equal('one', getline('.'))\n  set cpo-=!\n  bw!\nendfunc\n\nfunc Test_normal05_formatexpr()\n  \" basic formatexpr test\n  call Setup_NewWindow()\n  %d_\n  call setline(1, ['here: 1   ', '2', 'here: 3   ', '4', 'not here:   '])\n  1\n  set formatexpr=MyFormatExpr()\n  norm! gqG\n  call assert_equal(['here: 1->$', '2', 'here: 3->$', '4', 'not here:   '], getline(1,'$'))\n  set formatexpr=\n  bw!\nendfunc\n\nfunc Test_normal05_formatexpr_newbuf()\n  \" Edit another buffer in the 'formatexpr' function\n  new\n  func! Format()\n    edit another\n  endfunc\n  set formatexpr=Format()\n  norm gqG\n  bw!\n  set formatexpr=\nendfunc\n\nfunc Test_normal05_formatexpr_setopt()\n  \" Change the 'formatexpr' value in the function\n  new\n  func! Format()\n    set formatexpr=\n  endfunc\n  set formatexpr=Format()\n  norm gqG\n  bw!\n  set formatexpr=\nendfunc\n\n\" When 'formatexpr' returns non-zero, internal formatting is used.\nfunc Test_normal_formatexpr_returns_nonzero()\n  new\n  call setline(1, ['one', 'two'])\n  func! Format()\n    return 1\n  endfunc\n  setlocal formatexpr=Format()\n  normal VGgq\n  call assert_equal(['one two'], getline(1, '$'))\n\n  setlocal formatexpr=\n  delfunc Format\n  bwipe!\nendfunc\n\n\" Test for using a script-local function for 'formatexpr'\nfunc Test_formatexpr_scriptlocal_func()\n  func! s:Format()\n    let g:FormatArgs = [v:lnum, v:count]\n  endfunc\n  set formatexpr=s:Format()\n  call assert_equal(expand('<SID>') .. 'Format()', &formatexpr)\n  call assert_equal(expand('<SID>') .. 'Format()', &g:formatexpr)\n  new | only\n  call setline(1, range(1, 40))\n  let g:FormatArgs = []\n  normal! 2GVjgq\n  call assert_equal([2, 2], g:FormatArgs)\n  bw!\n  set formatexpr=<SID>Format()\n  call assert_equal(expand('<SID>') .. 'Format()', &formatexpr)\n  call assert_equal(expand('<SID>') .. 'Format()', &g:formatexpr)\n  new | only\n  call setline(1, range(1, 40))\n  let g:FormatArgs = []\n  normal! 4GVjgq\n  call assert_equal([4, 2], g:FormatArgs)\n  bw!\n  let &formatexpr = 's:Format()'\n  call assert_equal(expand('<SID>') .. 'Format()', &g:formatexpr)\n  new | only\n  call setline(1, range(1, 40))\n  let g:FormatArgs = []\n  normal! 6GVjgq\n  call assert_equal([6, 2], g:FormatArgs)\n  bw!\n  let &formatexpr = '<SID>Format()'\n  call assert_equal(expand('<SID>') .. 'Format()', &g:formatexpr)\n  new | only\n  call setline(1, range(1, 40))\n  let g:FormatArgs = []\n  normal! 8GVjgq\n  call assert_equal([8, 2], g:FormatArgs)\n  bw!\n  setlocal formatexpr=\n  setglobal formatexpr=s:Format()\n  call assert_equal(expand('<SID>') .. 'Format()', &g:formatexpr)\n  call assert_equal('', &formatexpr)\n  new\n  call assert_equal(expand('<SID>') .. 'Format()', &formatexpr)\n  call setline(1, range(1, 40))\n  let g:FormatArgs = []\n  normal! 10GVjgq\n  call assert_equal([10, 2], g:FormatArgs)\n  bw!\n  setglobal formatexpr=<SID>Format()\n  call assert_equal(expand('<SID>') .. 'Format()', &g:formatexpr)\n  call assert_equal('', &formatexpr)\n  new\n  call assert_equal(expand('<SID>') .. 'Format()', &formatexpr)\n  call setline(1, range(1, 40))\n  let g:FormatArgs = []\n  normal! 12GVjgq\n  call assert_equal([12, 2], g:FormatArgs)\n  bw!\n  let &g:formatexpr = 's:Format()'\n  call assert_equal(expand('<SID>') .. 'Format()', &g:formatexpr)\n  call assert_equal('', &formatexpr)\n  new\n  call assert_equal(expand('<SID>') .. 'Format()', &formatexpr)\n  call setline(1, range(1, 40))\n  let g:FormatArgs = []\n  normal! 14GVjgq\n  call assert_equal([14, 2], g:FormatArgs)\n  bw!\n  let &g:formatexpr = '<SID>Format()'\n  call assert_equal(expand('<SID>') .. 'Format()', &g:formatexpr)\n  call assert_equal('', &formatexpr)\n  new\n  call assert_equal(expand('<SID>') .. 'Format()', &formatexpr)\n  call setline(1, range(1, 40))\n  let g:FormatArgs = []\n  normal! 16GVjgq\n  call assert_equal([16, 2], g:FormatArgs)\n  bw!\n  set formatexpr=\n  delfunc s:Format\n  bw!\nendfunc\n\n\" basic test for formatprg\nfunc Test_normal06_formatprg()\n  \" only test on non windows platform\n  CheckNotMSWindows\n\n  \" uses sed to number non-empty lines\n  call writefile(['#!/bin/sh', 'sed ''/./=''|sed ''/./{', 'N', 's/\\n/    /', '}'''], 'Xsed_format.sh', 'D')\n  call system('chmod +x ./Xsed_format.sh')\n  let text = ['a', '', 'c', '', ' ', 'd', 'e']\n  let expected = ['1    a', '', '3    c', '', '5     ', '6    d', '7    e']\n\n  10new\n  call setline(1, text)\n  set formatprg=./Xsed_format.sh\n  norm! gggqG\n  call assert_equal(expected, getline(1, '$'))\n  %d\n\n  call setline(1, text)\n  set formatprg=donothing\n  setlocal formatprg=./Xsed_format.sh\n  norm! gggqG\n  call assert_equal(expected, getline(1, '$'))\n  %d\n\n  \" Check for the command-line ranges added to 'formatprg'\n  set formatprg=cat\n  call setline(1, ['one', 'two', 'three', 'four', 'five'])\n  call feedkeys('gggqG', 'xt')\n  call assert_equal('.,$!cat', @:)\n  call feedkeys('2Ggq2j', 'xt')\n  call assert_equal('.,.+2!cat', @:)\n\n  bw!\n  \" clean up\n  set formatprg=\n  setlocal formatprg=\nendfunc\n\nfunc Test_normal07_internalfmt()\n  \" basic test for internal formatter to textwidth of 12\n  let list=range(1,11)\n  call map(list, 'v:val.\"    \"')\n  10new\n  call setline(1, list)\n  set tw=12\n  norm! ggVGgq\n  call assert_equal(['1    2    3', '4    5    6', '7    8    9', '10    11    '], getline(1, '$'))\n  \" clean up\n  set tw=0\n  bw!\nendfunc\n\n\" basic tests for foldopen/folddelete\nfunc Test_normal08_fold()\n  CheckFeature folding\n  call Setup_NewWindow()\n  50\n  setl foldenable fdm=marker\n  \" First fold\n  norm! V4jzf\n  \" check that folds have been created\n  call assert_equal(['50/*{{{*/', '51', '52', '53', '54/*}}}*/'], getline(50,54))\n  \" Second fold\n  46\n  norm! V10jzf\n  \" check that folds have been created\n  call assert_equal('46/*{{{*/', getline(46))\n  call assert_equal('60/*}}}*/', getline(60))\n  norm! k\n  call assert_equal('45', getline('.'))\n  norm! j\n  call assert_equal('46/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('61', getline('.'))\n  norm! k\n  \" open a fold\n  norm! Vzo\n  norm! k\n  call assert_equal('45', getline('.'))\n  norm! j\n  call assert_equal('46/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('47', getline('.'))\n  norm! k\n  norm! zcVzO\n  call assert_equal('46/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('47', getline('.'))\n  norm! j\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51', getline('.'))\n  \" delete folds\n  :46\n  \" collapse fold\n  norm! V14jzC\n  \" delete all folds recursively\n  norm! VzD\n  call assert_equal(['46', '47', '48', '49', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '60'], getline(46,60))\n\n  \" clean up\n  setl nofoldenable fdm=marker\n  bw!\nendfunc\n\nfunc Test_normal09a_operatorfunc()\n  \" Test operatorfunc\n  call Setup_NewWindow()\n  \" Add some spaces for counting\n  50,60s/$/  /\n  unlet! g:a\n  let g:a=0\n  nmap <buffer><silent> ,, :set opfunc=CountSpaces<CR>g@\n  vmap <buffer><silent> ,, :<C-U>call CountSpaces(visualmode(), 1)<CR>\n  50\n  norm V2j,,\n  call assert_equal(6, g:a)\n  norm V,,\n  call assert_equal(2, g:a)\n  norm ,,l\n  call assert_equal(0, g:a)\n  50\n  exe \"norm 0\\<c-v>10j2l,,\"\n  call assert_equal(11, g:a)\n  50\n  norm V10j,,\n  call assert_equal(22, g:a)\n\n  \" clean up\n  unmap <buffer> ,,\n  set opfunc=\n  unlet! g:a\n  bw!\nendfunc\n\nfunc Test_normal09b_operatorfunc()\n  \" Test operatorfunc\n  call Setup_NewWindow()\n  \" Add some spaces for counting\n  50,60s/$/  /\n  unlet! g:opt\n  set linebreak\n  nmap <buffer><silent> ,, :set opfunc=OpfuncDummy<CR>g@\n  50\n  norm ,,j\n  exe \"bd!\" g:bufnr\n  call assert_true(&linebreak)\n  call assert_equal(g:opt, &linebreak)\n  set nolinebreak\n  norm ,,j\n  exe \"bd!\" g:bufnr\n  call assert_false(&linebreak)\n  call assert_equal(g:opt, &linebreak)\n\n  \" clean up\n  unmap <buffer> ,,\n  set opfunc=\n  call assert_fails('normal Vg@', 'E774:')\n  bw!\n  unlet! g:opt\nendfunc\n\nfunc OperatorfuncRedo(_)\n  let g:opfunc_count = v:count\nendfunc\n\nfunc Underscorize(_)\n  normal! '[V']r_\nendfunc\n\nfunc Test_normal09c_operatorfunc()\n  \" Test redoing operatorfunc\n  new\n  call setline(1, 'some text')\n  set operatorfunc=OperatorfuncRedo\n  normal v3g@\n  call assert_equal(3, g:opfunc_count)\n  let g:opfunc_count = 0\n  normal .\n  call assert_equal(3, g:opfunc_count)\n\n  bw!\n  unlet g:opfunc_count\n\n  \" Test redoing Visual mode\n  set operatorfunc=Underscorize\n  new\n  call setline(1, ['first', 'first', 'third', 'third', 'second'])\n  normal! 1GVjg@\n  normal! 5G.\n  normal! 3G.\n  call assert_equal(['_____', '_____', '_____', '_____', '______'], getline(1, '$'))\n  bwipe!\n  set operatorfunc=\nendfunc\n\n\" Test for different ways of setting the 'operatorfunc' option\nfunc Test_opfunc_callback()\n  new\n  func OpFunc1(callnr, type)\n    let g:OpFunc1Args = [a:callnr, a:type]\n  endfunc\n  func OpFunc2(type)\n    let g:OpFunc2Args = [a:type]\n  endfunc\n\n  let lines =<< trim END\n    #\" Test for using a function name\n    LET &opfunc = 'g:OpFunc2'\n    LET g:OpFunc2Args = []\n    normal! g@l\n    call assert_equal(['char'], g:OpFunc2Args)\n\n    #\" Test for using a function()\n    set opfunc=function('g:OpFunc1',\\ [10])\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([10, 'char'], g:OpFunc1Args)\n\n    #\" Using a funcref variable to set 'operatorfunc'\n    VAR Fn = function('g:OpFunc1', [11])\n    LET &opfunc = Fn\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([11, 'char'], g:OpFunc1Args)\n\n    #\" Using a string(funcref_variable) to set 'operatorfunc'\n    LET Fn = function('g:OpFunc1', [12])\n    LET &operatorfunc = string(Fn)\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([12, 'char'], g:OpFunc1Args)\n\n    #\" Test for using a funcref()\n    set operatorfunc=funcref('g:OpFunc1',\\ [13])\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([13, 'char'], g:OpFunc1Args)\n\n    #\" Using a funcref variable to set 'operatorfunc'\n    LET Fn = funcref('g:OpFunc1', [14])\n    LET &opfunc = Fn\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([14, 'char'], g:OpFunc1Args)\n\n    #\" Using a string(funcref_variable) to set 'operatorfunc'\n    LET Fn = funcref('g:OpFunc1', [15])\n    LET &opfunc = string(Fn)\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([15, 'char'], g:OpFunc1Args)\n\n    #\" Test for using a lambda function using set\n    VAR optval = \"LSTART a LMIDDLE OpFunc1(16, a) LEND\"\n    LET optval = substitute(optval, ' ', '\\\\ ', 'g')\n    exe \"set opfunc=\" .. optval\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([16, 'char'], g:OpFunc1Args)\n\n    #\" Test for using a lambda function using LET\n    LET &opfunc = LSTART a LMIDDLE OpFunc1(17, a) LEND\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([17, 'char'], g:OpFunc1Args)\n\n    #\" Set 'operatorfunc' to a string(lambda expression)\n    LET &opfunc = 'LSTART a LMIDDLE OpFunc1(18, a) LEND'\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([18, 'char'], g:OpFunc1Args)\n\n    #\" Set 'operatorfunc' to a variable with a lambda expression\n    VAR Lambda = LSTART a LMIDDLE OpFunc1(19, a) LEND\n    LET &opfunc = Lambda\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([19, 'char'], g:OpFunc1Args)\n\n    #\" Set 'operatorfunc' to a string(variable with a lambda expression)\n    LET Lambda = LSTART a LMIDDLE OpFunc1(20, a) LEND\n    LET &opfunc = string(Lambda)\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([20, 'char'], g:OpFunc1Args)\n\n    #\" Try to use 'operatorfunc' after the function is deleted\n    func g:TmpOpFunc1(type)\n      let g:TmpOpFunc1Args = [21, a:type]\n    endfunc\n    LET &opfunc = function('g:TmpOpFunc1')\n    delfunc g:TmpOpFunc1\n    call test_garbagecollect_now()\n    LET g:TmpOpFunc1Args = []\n    call assert_fails('normal! g@l', 'E117:')\n    call assert_equal([], g:TmpOpFunc1Args)\n\n    #\" Try to use a function with two arguments for 'operatorfunc'\n    func g:TmpOpFunc2(x, y)\n      let g:TmpOpFunc2Args = [a:x, a:y]\n    endfunc\n    set opfunc=TmpOpFunc2\n    LET g:TmpOpFunc2Args = []\n    call assert_fails('normal! g@l', 'E119:')\n    call assert_equal([], g:TmpOpFunc2Args)\n    delfunc TmpOpFunc2\n\n    #\" Try to use a lambda function with two arguments for 'operatorfunc'\n    LET &opfunc = LSTART a, b LMIDDLE OpFunc1(22, b) LEND\n    LET g:OpFunc1Args = []\n    call assert_fails('normal! g@l', 'E119:')\n    call assert_equal([], g:OpFunc1Args)\n\n    #\" Test for clearing the 'operatorfunc' option\n    set opfunc=''\n    set opfunc&\n    call assert_fails(\"set opfunc=function('abc')\", \"E700:\")\n    call assert_fails(\"set opfunc=funcref('abc')\", \"E700:\")\n\n    #\" set 'operatorfunc' to a non-existing function\n    LET &opfunc = function('g:OpFunc1', [23])\n    call assert_fails(\"set opfunc=function('NonExistingFunc')\", 'E700:')\n    call assert_fails(\"LET &opfunc = function('NonExistingFunc')\", 'E700:')\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([23, 'char'], g:OpFunc1Args)\n  END\n  call v9.CheckTransLegacySuccess(lines)\n\n  \" Test for using a script-local function name\n  func s:OpFunc3(type)\n    let g:OpFunc3Args = [a:type]\n  endfunc\n  set opfunc=s:OpFunc3\n  let g:OpFunc3Args = []\n  normal! g@l\n  call assert_equal(['char'], g:OpFunc3Args)\n\n  let &opfunc = 's:OpFunc3'\n  let g:OpFunc3Args = []\n  normal! g@l\n  call assert_equal(['char'], g:OpFunc3Args)\n  delfunc s:OpFunc3\n\n  \" Using Vim9 lambda expression in legacy context should fail\n  set opfunc=(a)\\ =>\\ OpFunc1(24,\\ a)\n  let g:OpFunc1Args = []\n  call assert_fails('normal! g@l', 'E117:')\n  call assert_equal([], g:OpFunc1Args)\n\n  \" set 'operatorfunc' to a partial with dict. This used to cause a crash.\n  func SetOpFunc()\n    let operator = {'execute': function('OperatorExecute')}\n    let &opfunc = operator.execute\n  endfunc\n  func OperatorExecute(_) dict\n  endfunc\n  call SetOpFunc()\n  call test_garbagecollect_now()\n  set operatorfunc=\n  delfunc SetOpFunc\n  delfunc OperatorExecute\n\n  \" Vim9 tests\n  let lines =<< trim END\n    vim9script\n\n    def g:Vim9opFunc(val: number, type: string): void\n      g:OpFunc1Args = [val, type]\n    enddef\n\n    # Test for using a def function with opfunc\n    set opfunc=function('g:Vim9opFunc',\\ [60])\n    g:OpFunc1Args = []\n    normal! g@l\n    assert_equal([60, 'char'], g:OpFunc1Args)\n\n    # Test for using a global function name\n    &opfunc = g:OpFunc2\n    g:OpFunc2Args = []\n    normal! g@l\n    assert_equal(['char'], g:OpFunc2Args)\n    bw!\n\n    # Test for using a script-local function name\n    def LocalOpFunc(type: string): void\n      g:LocalOpFuncArgs = [type]\n    enddef\n    &opfunc = LocalOpFunc\n    g:LocalOpFuncArgs = []\n    normal! g@l\n    assert_equal(['char'], g:LocalOpFuncArgs)\n    bw!\n  END\n  call v9.CheckScriptSuccess(lines)\n\n  \" setting 'opfunc' to a script local function outside of a script context\n  \" should fail\n  let cleanup =<< trim END\n    call writefile([execute('messages')], 'Xtest.out')\n    qall\n  END\n  call writefile(cleanup, 'Xverify.vim', 'D')\n  call RunVim([], [], \"-c \\\"set opfunc=s:abc\\\" -S Xverify.vim\")\n  call assert_match('E81: Using <SID> not in a', readfile('Xtest.out')[0])\n  call delete('Xtest.out')\n\n  \" cleanup\n  set opfunc&\n  delfunc OpFunc1\n  delfunc OpFunc2\n  unlet g:OpFunc1Args g:OpFunc2Args\n  %bw!\nendfunc\n\nfunc Test_normal10_expand()\n  \" Test for expand()\n  10new\n  call setline(1, ['1', 'ifooar,,cbar'])\n  2\n  norm! $\n  call assert_equal('cbar', expand('<cword>'))\n  call assert_equal('ifooar,,cbar', expand('<cWORD>'))\n\n  call setline(1, ['prx = list[idx];'])\n  1\n  let expected = ['', 'prx', 'prx', 'prx',\n\t\\ 'list', 'list', 'list', 'list', 'list', 'list', 'list',\n\t\\ 'idx', 'idx', 'idx', 'idx',\n\t\\ 'list[idx]',\n\t\\ '];',\n\t\\ ]\n  for i in range(1, 16)\n    exe 'norm ' . i . '|'\n    call assert_equal(expected[i], expand('<cexpr>'), 'i == ' . i)\n  endfor\n\n  \" Test for <cexpr> in state.val and ptr->val\n  call setline(1, 'x = state.val;')\n  call cursor(1, 10)\n  call assert_equal('state.val', expand('<cexpr>'))\n  call setline(1, 'x = ptr->val;')\n  call cursor(1, 9)\n  call assert_equal('ptr->val', expand('<cexpr>'))\n\n  if executable('echo')\n    \" Test expand(`...`) i.e. backticks command expansion.\n    call assert_equal('abcde', expand('`echo abcde`'))\n  endif\n\n  \" Test expand(`=...`) i.e. backticks expression expansion\n  call assert_equal('5', expand('`=2+3`'))\n  call assert_equal('3.14', expand('`=3.14`'))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for expand() in latin1 encoding\nfunc Test_normal_expand_latin1()\n  new\n  let save_enc = &encoding\n  set encoding=latin1\n  call setline(1, 'val = item->color;')\n  call cursor(1, 11)\n  call assert_equal('color', expand(\"<cword>\"))\n  call assert_equal('item->color', expand(\"<cexpr>\"))\n  let &encoding = save_enc\n  bw!\nendfunc\n\nfunc Test_normal11_showcmd()\n  \" test for 'showcmd'\n  10new\n  exe \"norm! ofoobar\\<esc>\"\n  call assert_equal(2, line('$'))\n  set showcmd\n  exe \"norm! ofoobar2\\<esc>\"\n  call assert_equal(3, line('$'))\n  exe \"norm! VAfoobar3\\<esc>\"\n  call assert_equal(3, line('$'))\n  exe \"norm! 0d3\\<del>2l\"\n  call assert_equal('obar2foobar3', getline('.'))\n  \" test for the visual block size displayed in the status line\n  call setline(1, ['aaaaa', 'bbbbb', 'ccccc'])\n  call feedkeys(\"ggl\\<C-V>lljj\", 'xt')\n  redraw!\n  call assert_match('3x3$', Screenline(&lines))\n  call feedkeys(\"\\<C-V>\", 'xt')\n  \" test for visually selecting a multi-byte character\n  call setline(1, [\"\\U2206\"])\n  call feedkeys(\"ggv\", 'xt')\n  redraw!\n  call assert_match('1-3$', Screenline(&lines))\n  call feedkeys(\"v\", 'xt')\n  \" test for visually selecting the end of line\n  call setline(1, [\"foobar\"])\n  call feedkeys(\"$vl\", 'xt')\n  redraw!\n  call assert_match('2$', Screenline(&lines))\n  call feedkeys(\"y\", 'xt')\n  call assert_equal(\"r\\n\", @\")\n  bw!\nendfunc\n\n\" Test for nv_error and normal command errors\nfunc Test_normal12_nv_error()\n  10new\n  call setline(1, range(1,5))\n  \" should not do anything, just beep\n  call assert_beeps('exe \"norm! <c-k>\"')\n  call assert_equal(map(range(1,5), 'string(v:val)'), getline(1,'$'))\n  call assert_beeps('normal! G2dd')\n  call assert_beeps(\"normal! g\\<C-A>\")\n  call assert_beeps(\"normal! g\\<C-X>\")\n  call assert_beeps(\"normal! g\\<C-B>\")\n  call assert_beeps(\"normal! vQ\\<Esc>\")\n  call assert_beeps(\"normal! 2[[\")\n  call assert_beeps(\"normal! 2]]\")\n  call assert_beeps(\"normal! 2[]\")\n  call assert_beeps(\"normal! 2][\")\n  call assert_beeps(\"normal! 4[z\")\n  call assert_beeps(\"normal! 4]z\")\n  call assert_beeps(\"normal! 4[c\")\n  call assert_beeps(\"normal! 4]c\")\n  call assert_beeps(\"normal! 200%\")\n  call assert_beeps(\"normal! %\")\n  call assert_beeps(\"normal! 2{\")\n  call assert_beeps(\"normal! 2}\")\n  call assert_beeps(\"normal! r\\<Right>\")\n  call assert_beeps(\"normal! 8ry\")\n  call assert_beeps('normal! \"@')\n  bw!\nendfunc\n\nfunc Test_normal13_help()\n  \" Test for F1\n  call assert_equal(1, winnr())\n  call feedkeys(\"\\<f1>\", 'txi')\n  call assert_match('help\\.txt', bufname('%'))\n  call assert_equal(2, winnr('$'))\n  bw!\nendfunc\n\nfunc Test_normal14_page()\n  \" basic test for Ctrl-F and Ctrl-B\n  call Setup_NewWindow()\n  exe \"norm! \\<c-f>\"\n  call assert_equal('9', getline('.'))\n  exe \"norm! 2\\<c-f>\"\n  call assert_equal('25', getline('.'))\n  exe \"norm! 2\\<c-b>\"\n  call assert_equal('18', getline('.'))\n  1\n  set scrolloff=5\n  exe \"norm! 2\\<c-f>\"\n  call assert_equal('21', getline('.'))\n  exe \"norm! \\<c-b>\"\n  call assert_equal('13', getline('.'))\n  1\n  set scrolloff=99\n  exe \"norm! \\<c-f>\"\n  call assert_equal('13', getline('.'))\n  set scrolloff=0\n  100\n  exe \"norm! $\\<c-b>\"\n  call assert_equal('92', getline('.'))\n  call assert_equal([0, 92, 1, 0, 1], getcurpos())\n  100\n  set nostartofline\n  exe \"norm! $\\<c-b>\"\n  call assert_equal('92', getline('.'))\n  call assert_equal([0, 92, 2, 0, v:maxcol], getcurpos())\n  \" cleanup\n  set startofline\n  bw!\nendfunc\n\nfunc Test_normal14_page_eol()\n  10new\n  norm oxxxxxxx\n  exe \"norm 2\\<c-f>\"\n  \" check with valgrind that cursor is put back in column 1\n  exe \"norm 2\\<c-b>\"\n  bw!\nendfunc\n\n\" Test for errors with z command\nfunc Test_normal_z_error()\n  call assert_beeps('normal! z2p')\n  call assert_beeps('normal! zq')\n  call assert_beeps('normal! cz1')\nendfunc\n\nfunc Test_normal15_z_scroll_vert()\n  \" basic test for z commands that scroll the window\n  call Setup_NewWindow()\n  100\n  norm! >>\n  \" Test for z<cr>\n  exe \"norm! z\\<cr>\"\n  call assert_equal('\t100', getline('.'))\n  call assert_equal(100, winsaveview()['topline'])\n  call assert_equal([0, 100, 2, 0, 9], getcurpos())\n\n  \" Test for zt\n  21\n  norm! >>0zt\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(21, winsaveview()['topline'])\n  call assert_equal([0, 21, 1, 0, 8], getcurpos())\n\n  \" Test for zb\n  30\n  norm! >>$ztzb\n  call assert_equal('\t30', getline('.'))\n  call assert_equal(30, winsaveview()['topline']+winheight(0)-1)\n  call assert_equal([0, 30, 3, 0, v:maxcol], getcurpos())\n\n  \" Test for z-\n  1\n  30\n  norm! 0z-\n  call assert_equal('\t30', getline('.'))\n  call assert_equal(30, winsaveview()['topline']+winheight(0)-1)\n  call assert_equal([0, 30, 2, 0, 9], getcurpos())\n\n  \" Test for z{height}<cr>\n  call assert_equal(10, winheight(0))\n  exe \"norm! z12\\<cr>\"\n  call assert_equal(12, winheight(0))\n  exe \"norm! z15\\<Del>0\\<cr>\"\n  call assert_equal(10, winheight(0))\n\n  \" Test for z.\n  1\n  21\n  norm! 0z.\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(17, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" Test for zz\n  1\n  21\n  norm! 0zz\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(17, winsaveview()['topline'])\n  call assert_equal([0, 21, 1, 0, 8], getcurpos())\n\n  \" Test for z+\n  11\n  norm! zt\n  norm! z+\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(21, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" Test for [count]z+\n  1\n  norm! 21z+\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(21, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" Test for z+ with [count] greater than buffer size\n  1\n  norm! 1000z+\n  call assert_equal('\t100', getline('.'))\n  call assert_equal(100, winsaveview()['topline'])\n  call assert_equal([0, 100, 2, 0, 9], getcurpos())\n\n  \" Test for z+ from the last buffer line\n  norm! Gz.z+\n  call assert_equal('\t100', getline('.'))\n  call assert_equal(100, winsaveview()['topline'])\n  call assert_equal([0, 100, 2, 0, 9], getcurpos())\n\n  \" Test for z^\n  norm! 22z+0\n  norm! z^\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(12, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" Test for z^ from first buffer line\n  norm! ggz^\n  call assert_equal('1', getline('.'))\n  call assert_equal(1, winsaveview()['topline'])\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n\n  \" Test for [count]z^\n  1\n  norm! 30z^\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(12, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" cleanup\n  bw!\nendfunc\n\nfunc Test_normal16_z_scroll_hor()\n  \" basic test for z commands that scroll the window\n  10new\n  15vsp\n  set nowrap listchars=\n  let lineA='abcdefghijklmnopqrstuvwxyz'\n  let lineB='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  $put =lineA\n  $put =lineB\n  1d\n\n  \" Test for zl and zh with a count\n  norm! 0z10l\n  call assert_equal([11, 1], [col('.'), wincol()])\n  norm! z4h\n  call assert_equal([11, 5], [col('.'), wincol()])\n  normal! 2gg\n\n  \" Test for zl\n  1\n  norm! 5zl\n  call assert_equal(lineA, getline('.'))\n  call assert_equal(6, col('.'))\n  call assert_equal(5, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('f', @0)\n\n  \" Test for zh\n  norm! 2zh\n  call assert_equal(lineA, getline('.'))\n  call assert_equal(6, col('.'))\n  norm! yl\n  call assert_equal('f', @0)\n  call assert_equal(3, winsaveview()['leftcol'])\n\n  \" Test for zL\n  norm! zL\n  call assert_equal(11, col('.'))\n  norm! yl\n  call assert_equal('k', @0)\n  call assert_equal(10, winsaveview()['leftcol'])\n  norm! 2zL\n  call assert_equal(25, col('.'))\n  norm! yl\n  call assert_equal('y', @0)\n  call assert_equal(24, winsaveview()['leftcol'])\n\n  \" Test for zH\n  norm! 2zH\n  call assert_equal(25, col('.'))\n  call assert_equal(10, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('y', @0)\n\n  \" Test for zs\n  norm! $zs\n  call assert_equal(26, col('.'))\n  call assert_equal(25, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" Test for ze\n  norm! ze\n  call assert_equal(26, col('.'))\n  call assert_equal(11, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" Test for zs and ze with folds\n  %fold\n  norm! $zs\n  call assert_equal(26, col('.'))\n  call assert_equal(0, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n  norm! ze\n  call assert_equal(26, col('.'))\n  call assert_equal(0, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" cleanup\n  set wrap listchars=eol:$\n  bw!\nendfunc\n\nfunc Test_normal17_z_scroll_hor2()\n  \" basic test for z commands that scroll the window\n  \" using 'sidescrolloff' setting\n  10new\n  20vsp\n  set nowrap listchars= sidescrolloff=5\n  let lineA='abcdefghijklmnopqrstuvwxyz'\n  let lineB='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  $put =lineA\n  $put =lineB\n  1d\n\n  \" Test for zl\n  1\n  norm! 5zl\n  call assert_equal(lineA, getline('.'))\n  call assert_equal(11, col('.'))\n  call assert_equal(5, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('k', @0)\n\n  \" Test for zh\n  norm! 2zh\n  call assert_equal(lineA, getline('.'))\n  call assert_equal(11, col('.'))\n  norm! yl\n  call assert_equal('k', @0)\n  call assert_equal(3, winsaveview()['leftcol'])\n\n  \" Test for zL\n  norm! 0zL\n  call assert_equal(16, col('.'))\n  norm! yl\n  call assert_equal('p', @0)\n  call assert_equal(10, winsaveview()['leftcol'])\n  norm! 2zL\n  call assert_equal(26, col('.'))\n  norm! yl\n  call assert_equal('z', @0)\n  call assert_equal(15, winsaveview()['leftcol'])\n\n  \" Test for zH\n  norm! 2zH\n  call assert_equal(15, col('.'))\n  call assert_equal(0, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('o', @0)\n\n  \" Test for zs\n  norm! $zs\n  call assert_equal(26, col('.'))\n  call assert_equal(20, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" Test for ze\n  norm! ze\n  call assert_equal(26, col('.'))\n  call assert_equal(11, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" cleanup\n  set wrap listchars=eol:$ sidescrolloff=0\n  bw!\nendfunc\n\n\" Test for commands that scroll the window horizontally. Test with folds.\n\"   H, M, L, CTRL-E, CTRL-Y, CTRL-U, CTRL-D, PageUp, PageDown commands\nfunc Test_vert_scroll_cmds()\n  15new\n  call setline(1, range(1, 100))\n  exe \"normal! 30ggz\\<CR>\"\n  set foldenable\n  33,36fold\n  40,43fold\n  46,49fold\n  let h = winheight(0)\n\n  \" Test for H, M and L commands\n  \" Top of the screen = 30\n  \" Folded lines = 9\n  \" Bottom of the screen = 30 + h + 9 - 1\n  normal! 4L\n  call assert_equal(35 + h, line('.'))\n  normal! 4H\n  call assert_equal(33, line('.'))\n\n  \" Test for using a large count value\n  %d\n  call setline(1, range(1, 4))\n  norm! 6H\n  call assert_equal(4, line('.'))\n\n  \" Test for 'M' with folded lines\n  %d\n  call setline(1, range(1, 20))\n  1,5fold\n  norm! LM\n  call assert_equal(12, line('.'))\n\n  \" Test for the CTRL-E and CTRL-Y commands with folds\n  %d\n  call setline(1, range(1, 10))\n  3,5fold\n  exe \"normal 6G3\\<C-E>\"\n  call assert_equal(6, line('w0'))\n  exe \"normal 2\\<C-Y>\"\n  call assert_equal(2, line('w0'))\n\n  \" Test for CTRL-Y on a folded line\n  %d\n  call setline(1, range(1, 100))\n  exe (h + 2) .. \",\" .. (h + 4) .. \"fold\"\n  exe h + 5\n  normal z-\n  exe \"normal \\<C-Y>\\<C-Y>\"\n  call assert_equal(h + 1, line('w$'))\n\n  \" Test for CTRL-Y from the first line and CTRL-E from the last line\n  %d\n  set scrolloff=2\n  call setline(1, range(1, 4))\n  exe \"normal gg\\<C-Y>\"\n  call assert_equal(1, line('w0'))\n  call assert_equal(1, line('.'))\n  exe \"normal G4\\<C-E>\\<C-E>\"\n  call assert_equal(4, line('w$'))\n  call assert_equal(4, line('.'))\n  set scrolloff&\n\n  \" Using <PageUp> and <PageDown> in an empty buffer should beep\n  %d\n  call assert_beeps('exe \"normal \\<PageUp>\"')\n  call assert_beeps('exe \"normal \\<C-B>\"')\n  call assert_beeps('exe \"normal \\<PageDown>\"')\n  call assert_beeps('exe \"normal \\<C-F>\"')\n\n  \" Test for <C-U> and <C-D> with fold\n  %d\n  call setline(1, range(1, 100))\n  10,35fold\n  set scroll=10\n  exe \"normal \\<C-D>\"\n  call assert_equal(36, line('.'))\n  exe \"normal \\<C-D>\"\n  call assert_equal(46, line('.'))\n  exe \"normal \\<C-U>\"\n  call assert_equal(36, line('.'))\n  exe \"normal \\<C-U>\"\n  call assert_equal(10, line('.'))\n  exe \"normal \\<C-U>\"\n  call assert_equal(1, line('.'))\n  set scroll&\n\n  \" Test for scrolling to the top of the file with <C-U> and a fold\n  10\n  normal ztL\n  exe \"normal \\<C-U>\\<C-U>\"\n  call assert_equal(1, line('w0'))\n\n  \" Test for CTRL-D on a folded line\n  %d\n  call setline(1, range(1, 100))\n  50,100fold\n  75\n  normal z-\n  exe \"normal \\<C-D>\"\n  call assert_equal(50, line('.'))\n  call assert_equal(100, line('w$'))\n  normal z.\n  let lnum = winline()\n  exe \"normal \\<C-D>\"\n  call assert_equal(lnum, winline())\n  call assert_equal(50, line('.'))\n  normal zt\n  exe \"normal \\<C-D>\"\n  call assert_equal(50, line('w0'))\n\n  \" Test for <S-CR>. Page down.\n  %d\n  call setline(1, range(1, 100))\n  call feedkeys(\"\\<S-CR>\", 'xt')\n  call assert_equal(14, line('w0'))\n  call assert_equal(28, line('w$'))\n\n  \" Test for <S-->. Page up.\n  call feedkeys(\"\\<S-->\", 'xt')\n  call assert_equal(1, line('w0'))\n  call assert_equal(15, line('w$'))\n\n  set foldenable&\n  bwipe!\nendfunc\n\nfunc Test_scroll_in_ex_mode()\n  \" This was using invalid memory because w_botline was invalid.\n  let lines =<< trim END\n      diffsplit\n      norm os0\u00030(\u0004\n      call writefile(['done'], 'Xdone')\n      qa!\n  END\n  call writefile(lines, 'Xscript', 'D')\n  call assert_equal(1, RunVim([], [], '--clean -X -Z -e -s -S Xscript'))\n  call assert_equal(['done'], readfile('Xdone'))\n\n  call delete('Xdone')\nendfunc\n\n\" Test for the 'sidescroll' option\nfunc Test_sidescroll_opt()\n  new\n  20vnew\n\n  \" scroll by 2 characters horizontally\n  set sidescroll=2 nowrap\n  call setline(1, repeat('a', 40))\n  normal g$l\n  call assert_equal(19, screenpos(0, 1, 21).col)\n  normal l\n  call assert_equal(20, screenpos(0, 1, 22).col)\n  normal g0h\n  call assert_equal(2, screenpos(0, 1, 2).col)\n  call assert_equal(20, screenpos(0, 1, 20).col)\n\n  \" when 'sidescroll' is 0, cursor positioned at the center\n  set sidescroll=0\n  normal g$l\n  call assert_equal(11, screenpos(0, 1, 21).col)\n  normal g0h\n  call assert_equal(10, screenpos(0, 1, 10).col)\n\n  %bw!\n  set wrap& sidescroll&\nendfunc\n\n\" basic tests for foldopen/folddelete\nfunc Test_normal18_z_fold()\n  CheckFeature folding\n  call Setup_NewWindow()\n  50\n  setl foldenable fdm=marker foldlevel=5\n\n  call assert_beeps('normal! zj')\n  call assert_beeps('normal! zk')\n\n  \" Test for zF\n  \" First fold\n  norm! 4zF\n  \" check that folds have been created\n  call assert_equal(['50/*{{{*/', '51', '52', '53/*}}}*/'], getline(50,53))\n\n  \" Test for zd\n  51\n  norm! 2zF\n  call assert_equal(2, foldlevel('.'))\n  norm! kzd\n  call assert_equal(['50', '51/*{{{*/', '52/*}}}*/', '53'], getline(50,53))\n  norm! j\n  call assert_equal(1, foldlevel('.'))\n\n  \" Test for zD\n  \" also deletes partially selected folds recursively\n  51\n  norm! zF\n  call assert_equal(2, foldlevel('.'))\n  norm! kV2jzD\n  call assert_equal(['50', '51', '52', '53'], getline(50,53))\n\n  \" Test for zE\n  85\n  norm! 4zF\n  86\n  norm! 2zF\n  90\n  norm! 4zF\n  call assert_equal(['85/*{{{*/', '86/*{{{*/', '87/*}}}*/', '88/*}}}*/', '89', '90/*{{{*/', '91', '92', '93/*}}}*/'], getline(85,93))\n  norm! zE\n  call assert_equal(['85', '86', '87', '88', '89', '90', '91', '92', '93'], getline(85,93))\n\n  \" Test for zn\n  50\n  set foldlevel=0\n  norm! 2zF\n  norm! zn\n  norm! k\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  call assert_equal(0, &foldenable)\n\n  \" Test for zN\n  49\n  norm! zN\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  call assert_equal(1, &foldenable)\n\n  \" Test for zi\n  norm! zi\n  call assert_equal(0, &foldenable)\n  norm! zi\n  call assert_equal(1, &foldenable)\n  norm! zi\n  call assert_equal(0, &foldenable)\n  norm! zi\n  call assert_equal(1, &foldenable)\n\n  \" Test for za\n  50\n  norm! za\n  norm! k\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  50\n  norm! za\n  norm! k\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  49\n  norm! 5zF\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n  49\n  norm! za\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  set nofoldenable\n  \" close fold and set foldenable\n  norm! za\n  call assert_equal(1, &foldenable)\n\n  50\n  \" have to use {count}za to open all folds and make the cursor visible\n  norm! 2za\n  norm! 2k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  \" Test for zA\n  49\n  set foldlevel=0\n  50\n  norm! zA\n  norm! 2k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  \" zA on an opened fold when foldenable is not set\n  50\n  set nofoldenable\n  norm! zA\n  call assert_equal(1, &foldenable)\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zc\n  norm! zE\n  50\n  norm! 2zF\n  49\n  norm! 5zF\n  set nofoldenable\n  50\n  \" There most likely is a bug somewhere:\n  \" https://groups.google.com/d/msg/vim_dev/v2EkfJ_KQjI/u-Cvv94uCAAJ\n  \" TODO: Should this only close the inner most fold or both folds?\n  norm! zc\n  call assert_equal(1, &foldenable)\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n  set nofoldenable\n  50\n  norm! Vjzc\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zC\n  set nofoldenable\n  50\n  norm! zCk\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zx\n  \" 1) close folds at line 49-54\n  set nofoldenable\n  48\n  norm! zx\n  call assert_equal(1, &foldenable)\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" 2) do not close fold under cursor\n  51\n  set nofoldenable\n  norm! zx\n  call assert_equal(1, &foldenable)\n  norm! 3k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  norm! j\n  call assert_equal('53', getline('.'))\n  norm! j\n  call assert_equal('54/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" 3) close one level of folds\n  48\n  set nofoldenable\n  set foldlevel=1\n  norm! zx\n  call assert_equal(1, &foldenable)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  norm! j\n  call assert_equal('53', getline('.'))\n  norm! j\n  call assert_equal('54/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zX\n  \" Close all folds\n  set foldlevel=0 nofoldenable\n  50\n  norm! zX\n  call assert_equal(1, &foldenable)\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zm\n  50\n  set nofoldenable foldlevel=2\n  norm! zm\n  call assert_equal(1, &foldenable)\n  call assert_equal(1, &foldlevel)\n  norm! zm\n  call assert_equal(0, &foldlevel)\n  norm! zm\n  call assert_equal(0, &foldlevel)\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zm with a count\n  50\n  set foldlevel=2\n  norm! 3zm\n  call assert_equal(0, &foldlevel)\n  call assert_equal(49, foldclosed(line('.')))\n\n  \" Test for zM\n  48\n  set nofoldenable foldlevel=99\n  norm! zM\n  call assert_equal(1, &foldenable)\n  call assert_equal(0, &foldlevel)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zr\n  48\n  set nofoldenable foldlevel=0\n  norm! zr\n  call assert_equal(0, &foldenable)\n  call assert_equal(1, &foldlevel)\n  set foldlevel=0 foldenable\n  norm! zr\n  call assert_equal(1, &foldenable)\n  call assert_equal(1, &foldlevel)\n  norm! zr\n  call assert_equal(2, &foldlevel)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  \" Test for zR\n  48\n  set nofoldenable foldlevel=0\n  norm! zR\n  call assert_equal(0, &foldenable)\n  call assert_equal(2, &foldlevel)\n  set foldenable foldlevel=0\n  norm! zR\n  call assert_equal(1, &foldenable)\n  call assert_equal(2, &foldlevel)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  call append(50, ['a /*{{{*/', 'b /*}}}*/'])\n  48\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('a /*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  48\n  norm! zR\n  call assert_equal(1, &foldenable)\n  call assert_equal(3, &foldlevel)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('a /*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('b /*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  \" clean up\n  setl nofoldenable fdm=marker foldlevel=0\n  bw!\nendfunc\n\nfunc Test_normal20_exmode()\n  \" Reading from redirected file doesn't work on MS-Windows\n  CheckNotMSWindows\n  call writefile(['1a', 'foo', 'bar', '.', 'w! Xn20file2', 'q!'], 'Xn20script', 'D')\n  call writefile(['1', '2'], 'Xn20file', 'D')\n  call system(GetVimCommand() .. ' -e -s < Xn20script Xn20file')\n  let a = readfile('Xn20file2')\n  call assert_equal(['1', 'foo', 'bar', '2'], a)\n\n  \" clean up\n  call delete('Xn20file2')\n  bw!\nendfunc\n\nfunc Test_normal21_nv_hat()\n\n  \" Edit a fresh file and wipe the buffer list so that there is no alternate\n  \" file present.  Next, check for the expected command failures.\n  edit Xfoo | %bw\n  call assert_fails(':buffer #', 'E86:')\n  call assert_fails(':execute \"normal! \\<C-^>\"', 'E23:')\n  call assert_fails(\"normal i\\<C-R>#\", 'E23:')\n\n  \" Test for the expected behavior when switching between two named buffers.\n  edit Xfoo | edit Xbar\n  call feedkeys(\"\\<C-^>\", 'tx')\n  call assert_equal('Xfoo', fnamemodify(bufname('%'), ':t'))\n  call feedkeys(\"\\<C-^>\", 'tx')\n  call assert_equal('Xbar', fnamemodify(bufname('%'), ':t'))\n\n  \" Test for the expected behavior when only one buffer is named.\n  enew | let l:nr = bufnr('%')\n  call feedkeys(\"\\<C-^>\", 'tx')\n  call assert_equal('Xbar', fnamemodify(bufname('%'), ':t'))\n  call feedkeys(\"\\<C-^>\", 'tx')\n  call assert_equal('', bufname('%'))\n  call assert_equal(l:nr, bufnr('%'))\n\n  \" Test that no action is taken by \"<C-^>\" when an operator is pending.\n  edit Xfoo\n  call feedkeys(\"ci\\<C-^>\", 'tx')\n  call assert_equal('Xfoo', fnamemodify(bufname('%'), ':t'))\n\n  %bw!\nendfunc\n\nfunc Test_normal22_zet()\n  \" Test for ZZ\n  \" let shell = &shell\n  \" let &shell = 'sh'\n  call writefile(['1', '2'], 'Xn22file', 'D')\n  let args = ' -N -i NONE --noplugins -X --not-a-term'\n  call system(GetVimCommand() .. args .. ' -c \"%d\" -c \":norm! ZZ\" Xn22file')\n  let a = readfile('Xn22file')\n  call assert_equal([], a)\n  \" Test for ZQ\n  call writefile(['1', '2'], 'Xn22file')\n  call system(GetVimCommand() . args . ' -c \"%d\" -c \":norm! ZQ\" Xn22file')\n  let a = readfile('Xn22file')\n  call assert_equal(['1', '2'], a)\n\n  \" Unsupported Z command\n  call assert_beeps('normal! ZW')\n\n  \" clean up\n  \" let &shell = shell\nendfunc\n\nfunc Test_normal23_K()\n  \" Test for K command\n  new\n  call append(0, ['version8.txt', 'man', 'aa%bb', 'cc|dd'])\n  let k = &keywordprg\n  set keywordprg=:help\n  1\n  norm! VK\n  call assert_equal('version8.txt', fnamemodify(bufname('%'), ':t'))\n  call assert_equal('help', &ft)\n  call assert_match('\\*version8.txt\\*', getline('.'))\n  helpclose\n  norm! 0K\n  call assert_equal('version8.txt', fnamemodify(bufname('%'), ':t'))\n  call assert_equal('help', &ft)\n  call assert_match('\\*version8\\.\\d\\*', getline('.'))\n  helpclose\n\n  set keywordprg=:new\n  set iskeyword+=%\n  set iskeyword+=\\|\n  2\n  norm! K\n  call assert_equal('man', fnamemodify(bufname('%'), ':t'))\n  bwipe!\n  3\n  norm! K\n  call assert_equal('aa%bb', fnamemodify(bufname('%'), ':t'))\n  bwipe!\n  if !has('win32')\n    4\n    norm! K\n    call assert_equal('cc|dd', fnamemodify(bufname('%'), ':t'))\n    bwipe!\n  endif\n  set iskeyword-=%\n  set iskeyword-=\\|\n\n  \" Test for specifying a count to K\n  1\n  com! -nargs=* Kprog let g:Kprog_Args = <q-args>\n  set keywordprg=:Kprog\n  norm! 3K\n  call assert_equal('3 version8', g:Kprog_Args)\n  delcom Kprog\n\n  \" Only expect \"man\" to work on Unix\n  if !has(\"unix\")\n    let &keywordprg = k\n    bw!\n    return\n  endif\n\n  let not_gnu_man = has('mac') || has('bsd')\n  if not_gnu_man\n    \" In macOS and BSD, the option for specifying a pager is different\n    set keywordprg=man\\ -P\\ cat\n  else\n    set keywordprg=man\\ --pager=cat\n  endif\n  \" Test for using man\n  2\n  let a = execute('unsilent norm! K')\n  if not_gnu_man\n    call assert_match(\"man -P cat 'man'\", a)\n  else\n    call assert_match(\"man --pager=cat 'man'\", a)\n  endif\n\n  \" Error cases\n  call setline(1, '#$#')\n  call assert_fails('normal! ggK', 'E349:')\n  call setline(1, '---')\n  call assert_fails('normal! ggv2lK', 'E349:')\n  call setline(1, ['abc', 'xyz'])\n  call assert_fails(\"normal! gg2lv2h\\<C-]>\", 'E433:')\n  call assert_beeps(\"normal! ggVjK\")\n  norm! V\n  call assert_beeps(\"norm! cK\")\n\n  \" clean up\n  let &keywordprg = k\n  bw!\nendfunc\n\nfunc Test_normal24_rot13()\n  \" Testing for g?? g?g?\n  new\n  call append(0, 'abcdefghijklmnopqrstuvwxyz\u00e4\u00fc\u00f6')\n  1\n  norm! g??\n  call assert_equal('nopqrstuvwxyzabcdefghijklm\u00e4\u00fc\u00f6', getline('.'))\n  norm! g?g?\n  call assert_equal('abcdefghijklmnopqrstuvwxyz\u00e4\u00fc\u00f6', getline('.'))\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal25_tag()\n  CheckFeature quickfix\n\n  \" Testing for CTRL-] g CTRL-] g]\n  \" CTRL-W g] CTRL-W CTRL-] CTRL-W g CTRL-]\n  h\n  \" Test for CTRL-]\n  call search('\\<x\\>$')\n  exe \"norm! \\<c-]>\"\n  call assert_equal(\"change.txt\", fnamemodify(bufname('%'), ':t'))\n  norm! yiW\n  call assert_equal(\"*x*\", @0)\n  exe \":norm \\<c-o>\"\n\n  \" Test for g_CTRL-]\n  call search('\\<v_u\\>$')\n  exe \"norm! g\\<c-]>\"\n  call assert_equal(\"change.txt\", fnamemodify(bufname('%'), ':t'))\n  norm! yiW\n  call assert_equal(\"*v_u*\", @0)\n  exe \":norm \\<c-o>\"\n\n  \" Test for g]\n  call search('\\<i_<Esc>$')\n  let a = execute(\":norm! g]\")\n  call assert_match('i_<Esc>.*insert.txt', a)\n\n  if !empty(exepath('cscope')) && has('cscope')\n    \" setting cscopetag changes how g] works\n    set cst\n    exe \"norm! g]\"\n    call assert_equal(\"insert.txt\", fnamemodify(bufname('%'), ':t'))\n    norm! yiW\n    call assert_equal(\"*i_<Esc>*\", @0)\n    exe \":norm \\<c-o>\"\n    \" Test for CTRL-W g]\n    exe \"norm! \\<C-W>g]\"\n    call assert_equal(\"insert.txt\", fnamemodify(bufname('%'), ':t'))\n    norm! yiW\n    call assert_equal(\"*i_<Esc>*\", @0)\n    call assert_equal(3, winnr('$'))\n    helpclose\n    set nocst\n  endif\n\n  \" Test for CTRL-W g]\n  let a = execute(\"norm! \\<C-W>g]\")\n  call assert_match('i_<Esc>.*insert.txt', a)\n\n  \" Test for CTRL-W CTRL-]\n  exe \"norm! \\<C-W>\\<C-]>\"\n  call assert_equal(\"insert.txt\", fnamemodify(bufname('%'), ':t'))\n  norm! yiW\n  call assert_equal(\"*i_<Esc>*\", @0)\n  call assert_equal(3, winnr('$'))\n  helpclose\n\n  \" Test for CTRL-W g CTRL-]\n  exe \"norm! \\<C-W>g\\<C-]>\"\n  call assert_equal(\"insert.txt\", fnamemodify(bufname('%'), ':t'))\n  norm! yiW\n  call assert_equal(\"*i_<Esc>*\", @0)\n  call assert_equal(3, winnr('$'))\n  helpclose\n\n  \" clean up\n  helpclose\nendfunc\n\nfunc Test_normal26_put()\n  \" Test for ]p ]P [p and [P\n  new\n  call append(0, ['while read LINE', 'do', '  ((count++))', '  if [ $? -ne 0 ]; then', \"    echo 'Error writing file'\", '  fi', 'done'])\n  1\n  /Error/y a\n  2\n  norm! \"a]pj\"a[p\n  call assert_equal(['do', \"echo 'Error writing file'\", \"  echo 'Error writing file'\", '  ((count++))'], getline(2,5))\n  1\n  /^\\s\\{4}/\n  exe \"norm!  \\\"a]P3Eldt'\"\n  exe \"norm! j\\\"a[P2Eldt'\"\n  call assert_equal(['  if [ $? -ne 0 ]; then', \"    echo 'Error writing'\", \"    echo 'Error'\", \"    echo 'Error writing file'\", '  fi'], getline(6,10))\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal27_bracket()\n  \" Test for [' [` ]' ]`\n  call Setup_NewWindow()\n  1,21s/.\\+/  &   b/\n  1\n  norm! $ma\n  5\n  norm! $mb\n  10\n  norm! $mc\n  15\n  norm! $md\n  20\n  norm! $me\n\n  \" Test for ['\n  9\n  norm! 2['\n  call assert_equal('  1   b', getline('.'))\n  call assert_equal(1, line('.'))\n  call assert_equal(3, col('.'))\n\n  \" Test for ]'\n  norm! ]'\n  call assert_equal('  5   b', getline('.'))\n  call assert_equal(5, line('.'))\n  call assert_equal(3, col('.'))\n\n  \" No mark before line 1, cursor moves to first non-blank on current line\n  1\n  norm! 5|['\n  call assert_equal('  1   b', getline('.'))\n  call assert_equal(1, line('.'))\n  call assert_equal(3, col('.'))\n\n  \" No mark after line 21, cursor moves to first non-blank on current line\n  21\n  norm! 5|]'\n  call assert_equal('  21   b', getline('.'))\n  call assert_equal(21, line('.'))\n  call assert_equal(3, col('.'))\n\n  \" Test for [`\n  norm! 2[`\n  call assert_equal('  15   b', getline('.'))\n  call assert_equal(15, line('.'))\n  call assert_equal(8, col('.'))\n\n  \" Test for ]`\n  norm! ]`\n  call assert_equal('  20   b', getline('.'))\n  call assert_equal(20, line('.'))\n  call assert_equal(8, col('.'))\n\n  \" No mark before line 1, cursor does not move\n  1\n  norm! 5|[`\n  call assert_equal('  1   b', getline('.'))\n  call assert_equal(1, line('.'))\n  call assert_equal(5, col('.'))\n\n  \" No mark after line 21, cursor does not move\n  21\n  norm! 5|]`\n  call assert_equal('  21   b', getline('.'))\n  call assert_equal(21, line('.'))\n  call assert_equal(5, col('.'))\n\n  \" Count too large for [`\n  \" cursor moves to first lowercase mark\n  norm! 99[`\n  call assert_equal('  1   b', getline('.'))\n  call assert_equal(1, line('.'))\n  call assert_equal(7, col('.'))\n\n  \" Count too large for ]`\n  \" cursor moves to last lowercase mark\n  norm! 99]`\n  call assert_equal('  20   b', getline('.'))\n  call assert_equal(20, line('.'))\n  call assert_equal(8, col('.'))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for ( and ) sentence movements\nfunc Test_normal28_parenthesis()\n  new\n  call append(0, ['This is a test. With some sentences!', '', 'Even with a question? And one more. And no sentence here'])\n\n  $\n  norm! d(\n  call assert_equal(['This is a test. With some sentences!', '', 'Even with a question? And one more. ', ''], getline(1, '$'))\n  norm! 2d(\n  call assert_equal(['This is a test. With some sentences!', '', ' ', ''], getline(1, '$'))\n  1\n  norm! 0d)\n  call assert_equal(['With some sentences!', '', ' ', ''], getline(1, '$'))\n\n  call append('$', ['This is a long sentence', '', 'spanning', 'over several lines. '])\n  $\n  norm! $d(\n  call assert_equal(['With some sentences!', '', ' ', '', 'This is a long sentence', ''], getline(1, '$'))\n\n  \" Move to the next sentence from a paragraph macro\n  %d\n  call setline(1, ['.LP', 'blue sky!. blue sky.', 'blue sky. blue sky.'])\n  call cursor(1, 1)\n  normal )\n  call assert_equal([2, 1], [line('.'), col('.')])\n  normal )\n  call assert_equal([2, 12], [line('.'), col('.')])\n  normal ((\n  call assert_equal([1, 1], [line('.'), col('.')])\n\n  \" It is an error if a next sentence is not found\n  %d\n  call setline(1, '.SH')\n  call assert_beeps('normal )')\n\n  \" If only dot is present, don't treat that as a sentence\n  call setline(1, '. This is a sentence.')\n  normal $((\n  call assert_equal(3, col('.'))\n\n  \" Jumping to a fold should open the fold\n  call setline(1, ['', '', 'one', 'two', 'three'])\n  set foldenable\n  2,$fold\n  call feedkeys(')', 'xt')\n  call assert_equal(3, line('.'))\n  call assert_equal(1, foldlevel('.'))\n  call assert_equal(-1, foldclosed('.'))\n  set foldenable&\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for { and } paragraph movements\nfunc Test_normal29_brace()\n  let text =<< trim [DATA]\n    A paragraph begins after each empty line, and also at each of a set of\n    paragraph macros, specified by the pairs of characters in the 'paragraphs'\n    option.  The default is \"IPLPPPQPP TPHPLIPpLpItpplpipbp\", which corresponds to\n    the macros \".IP\", \".LP\", etc.  (These are nroff macros, so the dot must be in\n    the first column).  A section boundary is also a paragraph boundary.\n    Note that a blank line (only containing white space) is NOT a paragraph\n    boundary.\n\n\n    Also note that this does not include a '{' or '}' in the first column.  When\n    the '{' flag is in 'cpoptions' then '{' in the first column is used as a\n    paragraph boundary |posix|.\n    {\n    This is no paragraph\n    unless the '{' is set\n    in 'cpoptions'\n    }\n    .IP\n    The nroff macros IP separates a paragraph\n    That means, it must be a '.'\n    followed by IP\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n  [DATA]\n\n  new\n  call append(0, text)\n  1\n  norm! 0d2}\n\n  let expected =<< trim [DATA]\n    .IP\n    The nroff macros IP separates a paragraph\n    That means, it must be a '.'\n    followed by IP\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  norm! 0d}\n\n  let expected =<< trim [DATA]\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  $\n  norm! d{\n\n  let expected =<< trim [DATA]\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  norm! d{\n\n  let expected =<< trim [DATA]\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test with { in cpooptions\n  %d\n  call append(0, text)\n  set cpo+={\n  1\n  norm! 0d2}\n\n  let expected =<< trim [DATA]\n    {\n    This is no paragraph\n    unless the '{' is set\n    in 'cpoptions'\n    }\n    .IP\n    The nroff macros IP separates a paragraph\n    That means, it must be a '.'\n    followed by IP\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  $\n  norm! d}\n\n  let expected =<< trim [DATA]\n    {\n    This is no paragraph\n    unless the '{' is set\n    in 'cpoptions'\n    }\n    .IP\n    The nroff macros IP separates a paragraph\n    That means, it must be a '.'\n    followed by IP\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  norm! gg}\n  norm! d5}\n\n  let expected =<< trim [DATA]\n    {\n    This is no paragraph\n    unless the '{' is set\n    in 'cpoptions'\n    }\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Jumping to a fold should open the fold\n  %d\n  call setline(1, ['', 'one', 'two', ''])\n  set foldenable\n  2,$fold\n  call feedkeys('}', 'xt')\n  call assert_equal(4, line('.'))\n  call assert_equal(1, foldlevel('.'))\n  call assert_equal(-1, foldclosed('.'))\n  set foldenable&\n\n  \" clean up\n  set cpo-={\n  bw!\nendfunc\n\n\" Test for section movements\nfunc Test_normal_section()\n  new\n  let lines =<< trim [END]\n    int foo()\n    {\n      if (1)\n      {\n        a = 1;\n      }\n    }\n  [END]\n  call setline(1, lines)\n\n  \" jumping to a folded line using [[ should open the fold\n  2,3fold\n  call cursor(5, 1)\n  call feedkeys(\"[[\", 'xt')\n  call assert_equal(2, line('.'))\n  call assert_equal(-1, foldclosedend(line('.')))\n\n  bwipe!\nendfunc\n\n\" Test for changing case using u, U, gu, gU and ~ (tilde) commands\nfunc Test_normal30_changecase()\n  new\n  call append(0, 'This is a simple test: \u00e4\u00fc\u00f6\u00df')\n  norm! 1ggVu\n  call assert_equal('this is a simple test: \u00e4\u00fc\u00f6\u00df', getline('.'))\n  norm! VU\n  call assert_equal('THIS IS A SIMPLE TEST: \u00c4\u00dc\u00d6SS', getline('.'))\n  norm! guu\n  call assert_equal('this is a simple test: \u00e4\u00fc\u00f6ss', getline('.'))\n  norm! gUgU\n  call assert_equal('THIS IS A SIMPLE TEST: \u00c4\u00dc\u00d6SS', getline('.'))\n  norm! gugu\n  call assert_equal('this is a simple test: \u00e4\u00fc\u00f6ss', getline('.'))\n  norm! gUU\n  call assert_equal('THIS IS A SIMPLE TEST: \u00c4\u00dc\u00d6SS', getline('.'))\n  norm! 010~\n  call assert_equal('this is a SIMPLE TEST: \u00c4\u00dc\u00d6SS', getline('.'))\n  norm! V~\n  call assert_equal('THIS IS A simple test: \u00e4\u00fc\u00f6ss', getline('.'))\n  call assert_beeps('norm! c~')\n  %d\n  call assert_beeps('norm! ~')\n\n  \" Test for changing case across lines using 'whichwrap'\n  call setline(1, ['aaaaaa', 'aaaaaa'])\n  normal! gg10~\n  call assert_equal(['AAAAAA', 'aaaaaa'], getline(1, 2))\n  set whichwrap+=~\n  normal! gg10~\n  call assert_equal(['aaaaaa', 'AAAAaa'], getline(1, 2))\n  set whichwrap&\n\n  \" try changing the case with a double byte encoding (DBCS)\n  %bw!\n  let enc = &enc\n  set encoding=cp932\n  call setline(1, \"\\u8470\")\n  normal ~\n  normal gU$gu$gUgUg~g~gugu\n  call assert_equal(\"\\u8470\", getline(1))\n  let &encoding = enc\n\n  \" clean up\n  bw!\nendfunc\n\n\" Turkish ASCII turns to multi-byte.  On some systems Turkish locale\n\" is available but toupper()/tolower() don't do the right thing.\nfunc Test_normal_changecase_turkish()\n  new\n  try\n    lang tr_TR.UTF-8\n    set casemap=\n    let iupper = toupper('i')\n    if iupper == \"\\u0130\"\n      call setline(1, 'iI')\n      1normal gUU\n      call assert_equal(\"\\u0130I\", getline(1))\n      call assert_equal(\"\\u0130I\", toupper(\"iI\"))\n\n      call setline(1, 'iI')\n      1normal guu\n      call assert_equal(\"i\\u0131\", getline(1))\n      call assert_equal(\"i\\u0131\", tolower(\"iI\"))\n    elseif iupper == \"I\"\n      call setline(1, 'iI')\n      1normal gUU\n      call assert_equal(\"II\", getline(1))\n      call assert_equal(\"II\", toupper(\"iI\"))\n\n      call setline(1, 'iI')\n      1normal guu\n      call assert_equal(\"ii\", getline(1))\n      call assert_equal(\"ii\", tolower(\"iI\"))\n    else\n      call assert_true(false, \"expected toupper('i') to be either 'I' or '\\u0130'\")\n    endif\n    set casemap&\n    call setline(1, 'iI')\n    1normal gUU\n    call assert_equal(\"II\", getline(1))\n    call assert_equal(\"II\", toupper(\"iI\"))\n\n    call setline(1, 'iI')\n    1normal guu\n    call assert_equal(\"ii\", getline(1))\n    call assert_equal(\"ii\", tolower(\"iI\"))\n\n    lang en_US.UTF-8\n  catch /E197:/\n    \" can't use Turkish locale\n    throw 'Skipped: Turkish locale not available'\n  endtry\n\n  bwipe!\nendfunc\n\n\" Test for r (replace) command\nfunc Test_normal31_r_cmd()\n  new\n  call append(0, 'This is a simple test: abcd')\n  exe \"norm! 1gg$r\\<cr>\"\n  call assert_equal(['This is a simple test: abc', '', ''], getline(1,'$'))\n  exe \"norm! 1gg2wlr\\<cr>\"\n  call assert_equal(['This is a', 'simple test: abc', '', ''], getline(1,'$'))\n  exe \"norm! 2gg0W5r\\<cr>\"\n  call assert_equal(['This is a', 'simple ', ' abc', '', ''], getline('1', '$'))\n  set autoindent\n  call setline(2, ['simple test: abc', ''])\n  exe \"norm! 2gg0W5r\\<cr>\"\n  call assert_equal(['This is a', 'simple ', 'abc', '', '', ''], getline('1', '$'))\n  exe \"norm! 1ggVr\\<cr>\"\n  call assert_equal('^M^M^M^M^M^M^M^M^M', strtrans(getline(1)))\n  call setline(1, 'This is a')\n  exe \"norm! 1gg05rf\"\n  call assert_equal('fffffis a', getline(1))\n\n  \" When replacing characters, copy characters from above and below lines\n  \" using CTRL-Y and CTRL-E.\n  \" Different code paths are used for utf-8 and latin1 encodings\n  set showmatch\n  for enc in ['latin1', 'utf-8']\n    enew!\n    let &encoding = enc\n    call setline(1, [' {a}', 'xxxxxxxxxx', '      [b]'])\n    exe \"norm! 2gg5r\\<C-Y>l5r\\<C-E>\"\n    call assert_equal(' {a}x [b]x', getline(2))\n  endfor\n  set showmatch&\n\n  \" r command should fail in operator pending mode\n  call assert_beeps('normal! cr')\n\n  \" replace a tab character in visual mode\n  %d\n  call setline(1, [\"a\\tb\", \"c\\td\", \"e\\tf\"])\n  normal gglvjjrx\n  call assert_equal(['axx', 'xxx', 'xxf'], getline(1, '$'))\n\n  \" replace with a multibyte character (with multiple composing characters)\n  %d\n  new\n  call setline(1, 'aaa')\n  exe \"normal $ra\\u0328\\u0301\"\n  call assert_equal(\"aaa\\u0328\\u0301\", getline(1))\n\n  \" clean up\n  set noautoindent\n  bw!\nendfunc\n\n\" Test for g*, g#\nfunc Test_normal32_g_cmd1()\n  new\n  call append(0, ['abc.x_foo', 'x_foobar.abc'])\n  1\n  norm! $g*\n  call assert_equal('x_foo', @/)\n  call assert_equal('x_foobar.abc', getline('.'))\n  norm! $g#\n  call assert_equal('abc', @/)\n  call assert_equal('abc.x_foo', getline('.'))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for g`, g;, g,, g&, gv, gk, gj, gJ, g0, g^, g_, gm, g$, gM, g CTRL-G,\n\" gi and gI commands\nfunc Test_normal33_g_cmd2()\n  call Setup_NewWindow()\n  \" Test for g`\n  clearjumps\n  norm! ma10j\n  let a=execute(':jumps')\n  \" empty jumplist\n  call assert_equal('>', a[-1:])\n  norm! g`a\n  call assert_equal('>', a[-1:])\n  call assert_equal(1, line('.'))\n  call assert_equal('1', getline('.'))\n  call cursor(10, 1)\n  norm! g'a\n  call assert_equal('>', a[-1:])\n  call assert_equal(1, line('.'))\n  let v:errmsg = ''\n  call assert_nobeep(\"normal! g`\\<Esc>\")\n  call assert_equal('', v:errmsg)\n  call assert_nobeep(\"normal! g'\\<Esc>\")\n  call assert_equal('', v:errmsg)\n\n  \" Test for g; and g,\n  norm! g;\n  \" there is only one change in the changelist\n  \" currently, when we setup the window\n  call assert_equal(2, line('.'))\n  call assert_fails(':norm! g;', 'E662:')\n  call assert_fails(':norm! g,', 'E663:')\n  let &ul = &ul\n  call append('$', ['a', 'b', 'c', 'd'])\n  let &ul = &ul\n  call append('$', ['Z', 'Y', 'X', 'W'])\n  let a = execute(':changes')\n  call assert_match('2\\s\\+0\\s\\+2', a)\n  call assert_match('101\\s\\+0\\s\\+a', a)\n  call assert_match('105\\s\\+0\\s\\+Z', a)\n  norm! 3g;\n  call assert_equal(2, line('.'))\n  norm! 2g,\n  call assert_equal(105, line('.'))\n\n  \" Test for g& - global substitute\n  %d\n  call setline(1, range(1,10))\n  call append('$', ['a', 'b', 'c', 'd'])\n  $s/\\w/&&/g\n  exe \"norm! /[1-8]\\<cr>\"\n  norm! g&\n  call assert_equal(['11', '22', '33', '44', '55', '66', '77', '88', '9', '110', 'a', 'b', 'c', 'dd'], getline(1, '$'))\n\n  \" Jumping to a fold using gg should open the fold\n  set foldenable\n  set foldopen+=jump\n  5,8fold\n  call feedkeys('6gg', 'xt')\n  call assert_equal(1, foldlevel('.'))\n  call assert_equal(-1, foldclosed('.'))\n  set foldopen-=jump\n  set foldenable&\n\n  \" Test for gv\n  %d\n  call append('$', repeat(['abcdefgh'], 8))\n  exe \"norm! 2gg02l\\<c-v>2j2ly\"\n  call assert_equal(['cde', 'cde', 'cde'], getreg(0, 1, 1))\n  \" in visual mode, gv swaps current and last selected region\n  exe \"norm! G0\\<c-v>4k4lgvd\"\n  call assert_equal(['', 'abfgh', 'abfgh', 'abfgh', 'abcdefgh', 'abcdefgh', 'abcdefgh', 'abcdefgh', 'abcdefgh'], getline(1,'$'))\n  exe \"norm! G0\\<c-v>4k4ly\"\n  exe \"norm! gvood\"\n  call assert_equal(['', 'abfgh', 'abfgh', 'abfgh', 'fgh', 'fgh', 'fgh', 'fgh', 'fgh'], getline(1,'$'))\n  \" gv cannot be used in operator pending mode\n  call assert_beeps('normal! cgv')\n  \" gv should beep without a previously selected visual area\n  new\n  call assert_beeps('normal! gv')\n  close\n\n  \" Test for gk/gj\n  %d\n  15vsp\n  set wrap listchars= sbr=\n  let lineA = 'abcdefghijklmnopqrstuvwxyz'\n  let lineB = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  let lineC = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'\n  $put =lineA\n  $put =lineB\n\n  norm! 3gg0dgk\n  call assert_equal(['', 'abcdefghijklmno', '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'], getline(1, '$'))\n  set nu\n  norm! 3gg0gjdgj\n  call assert_equal(['', 'abcdefghijklmno', '0123456789AMNOPQRSTUVWXYZ'], getline(1,'$'))\n\n  \" Test for gJ\n  norm! 2gggJ\n  call assert_equal(['', 'abcdefghijklmno0123456789AMNOPQRSTUVWXYZ'], getline(1,'$'))\n  call assert_equal(16, col('.'))\n  \" shouldn't do anything\n  norm! 10gJ\n  call assert_equal(1, col('.'))\n\n  \" Test for g0 g^ gm g$\n  exe \"norm! 2gg0gji   \"\n  call assert_equal(['', 'abcdefghijk   lmno0123456789AMNOPQRSTUVWXYZ'], getline(1,'$'))\n  norm! g0yl\n  call assert_equal(12, col('.'))\n  call assert_equal(' ', getreg(0))\n  norm! g$yl\n  call assert_equal(22, col('.'))\n  call assert_equal('3', getreg(0))\n  norm! gmyl\n  call assert_equal(17, col('.'))\n  call assert_equal('n', getreg(0))\n  norm! g^yl\n  call assert_equal(15, col('.'))\n  call assert_equal('l', getreg(0))\n  call assert_beeps('normal 5g$')\n\n  \" Test for g$ with double-width character half displayed\n  vsplit\n  9wincmd |\n  setlocal nowrap nonumber\n  call setline(2, 'asdfasdf\u30e8')\n  2\n  normal 0g$\n  call assert_equal(8, col('.'))\n  10wincmd |\n  normal 0g$\n  call assert_equal(9, col('.'))\n\n  setlocal signcolumn=yes\n  11wincmd |\n  normal 0g$\n  call assert_equal(8, col('.'))\n  12wincmd |\n  normal 0g$\n  call assert_equal(9, col('.'))\n\n  close\n\n  \" Test for g_\n  call assert_beeps('normal! 100g_')\n  call setline(2, ['  foo  ', '  foobar  '])\n  normal! 2ggg_\n  call assert_equal(5, col('.'))\n  normal! 2g_\n  call assert_equal(8, col('.'))\n\n  norm! 2ggdG\n  $put =lineC\n\n  \" Test for gM\n  norm! gMyl\n  call assert_equal(73, col('.'))\n  call assert_equal('0', getreg(0))\n  \" Test for 20gM\n  norm! 20gMyl\n  call assert_equal(29, col('.'))\n  call assert_equal('S', getreg(0))\n  \" Test for 60gM\n  norm! 60gMyl\n  call assert_equal(87, col('.'))\n  call assert_equal('E', getreg(0))\n\n  \" Test for gM with Tab characters\n  call setline('.', \"\\ta\\tb\\tc\\td\\te\\tf\")\n  norm! gMyl\n  call assert_equal(6, col('.'))\n  call assert_equal(\"c\", getreg(0))\n\n  \" Test for g Ctrl-G\n  call setline('.', lineC)\n  norm! 60gMyl\n  set ff=unix\n  let a=execute(\":norm! g\\<c-g>\")\n  call assert_match('Col 87 of 144; Line 2 of 2; Word 1 of 1; Byte 88 of 146', a)\n\n  \" Test for gI\n  norm! gIfoo\n  call assert_equal(['', 'foo0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'], getline(1,'$'))\n\n  \" Test for gi\n  wincmd c\n  %d\n  set tw=0\n  call setline(1, ['foobar', 'new line'])\n  norm! A next word\n  $put ='third line'\n  norm! gi another word\n  call assert_equal(['foobar next word another word', 'new line', 'third line'], getline(1,'$'))\n  call setline(1, 'foobar')\n  normal! Ggifirst line\n  call assert_equal('foobarfirst line', getline(1))\n  \" Test gi in 'virtualedit' mode with cursor after the end of the line\n  set virtualedit=all\n  call setline(1, 'foo')\n  exe \"normal! Abar\\<Right>\\<Right>\\<Right>\\<Right>\"\n  call setline(1, 'foo')\n  normal! Ggifirst line\n  call assert_equal('foo       first line', getline(1))\n  set virtualedit&\n\n  \" Test for aborting a g command using CTRL-\\ CTRL-G\n  exe \"normal! g\\<C-\\>\\<C-G>\"\n  call assert_equal('foo       first line', getline('.'))\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal_ex_substitute()\n  \" This was hanging on the substitute prompt.\n  new\n  call setline(1, 'a')\n  exe \"normal! gggQs/a/b/c\\<CR>\"\n  call assert_equal('a', getline(1))\n  bwipe!\nendfunc\n\n\" Test for g CTRL-G\nfunc Test_g_ctrl_g()\n  new\n\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\n--No lines in buffer--\", a)\n\n  \" Test for CTRL-G (same as :file)\n  let a = execute(\":norm! \\<c-g>\")\n  call assert_equal(\"\\n\\n\\\"[No Name]\\\" --No lines in buffer--\", a)\n\n  call setline(1, ['first line', 'second line'])\n\n  \" Test g CTRL-g with dos, mac and unix file type.\n  norm! gojll\n  set ff=dos\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 3 of 11; Line 2 of 2; Word 3 of 4; Byte 15 of 25\", a)\n\n  set ff=mac\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 3 of 11; Line 2 of 2; Word 3 of 4; Byte 14 of 23\", a)\n\n  set ff=unix\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 3 of 11; Line 2 of 2; Word 3 of 4; Byte 14 of 23\", a)\n\n  \" Test g CTRL-g in visual mode (v)\n  let a = execute(\":norm! gojllvlg\\<c-g>\")\n  call assert_equal(\"\\nSelected 1 of 2 Lines; 1 of 4 Words; 2 of 23 Bytes\", a)\n\n  \" Test g CTRL-g in visual mode (CTRL-V) with end col > start col\n  let a = execute(\":norm! \\<Esc>gojll\\<C-V>kllg\\<c-g>\")\n  call assert_equal(\"\\nSelected 3 Cols; 2 of 2 Lines; 2 of 4 Words; 6 of 23 Bytes\", a)\n\n  \" Test g_CTRL-g in visual mode (CTRL-V) with end col < start col\n  let a = execute(\":norm! \\<Esc>goll\\<C-V>jhhg\\<c-g>\")\n  call assert_equal(\"\\nSelected 3 Cols; 2 of 2 Lines; 2 of 4 Words; 6 of 23 Bytes\", a)\n\n  \" Test g CTRL-g in visual mode (CTRL-V) with end_vcol being MAXCOL\n  let a = execute(\":norm! \\<Esc>gojll\\<C-V>k$g\\<c-g>\")\n  call assert_equal(\"\\nSelected 2 of 2 Lines; 4 of 4 Words; 17 of 23 Bytes\", a)\n\n  \" There should be one byte less with noeol\n  set bin noeol\n  let a = execute(\":norm! \\<Esc>gog\\<c-g>\")\n  call assert_equal(\"\\nCol 1 of 10; Line 1 of 2; Word 1 of 4; Char 1 of 23; Byte 1 of 22\", a)\n  set bin & eol&\n\n  call setline(1, ['Fran\u00e7ais', '\u65e5\u672c\u8a9e'])\n\n  let a = execute(\":norm! \\<Esc>gojlg\\<c-g>\")\n  call assert_equal(\"\\nCol 4-3 of 9-6; Line 2 of 2; Word 2 of 2; Char 11 of 13; Byte 16 of 20\", a)\n\n  let a = execute(\":norm! \\<Esc>gojvlg\\<c-g>\")\n  call assert_equal(\"\\nSelected 1 of 2 Lines; 1 of 2 Words; 2 of 13 Chars; 6 of 20 Bytes\", a)\n\n  let a = execute(\":norm! \\<Esc>goll\\<c-v>jlg\\<c-g>\")\n  call assert_equal(\"\\nSelected 4 Cols; 2 of 2 Lines; 2 of 2 Words; 6 of 13 Chars; 11 of 20 Bytes\", a)\n\n  set fenc=utf8 bomb\n  let a = execute(\":norm! \\<Esc>gojlg\\<c-g>\")\n  call assert_equal(\"\\nCol 4-3 of 9-6; Line 2 of 2; Word 2 of 2; Char 11 of 13; Byte 16 of 20(+3 for BOM)\", a)\n\n  set fenc=utf16 bomb\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 4-3 of 9-6; Line 2 of 2; Word 2 of 2; Char 11 of 13; Byte 16 of 20(+2 for BOM)\", a)\n\n  set fenc=utf32 bomb\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 4-3 of 9-6; Line 2 of 2; Word 2 of 2; Char 11 of 13; Byte 16 of 20(+4 for BOM)\", a)\n\n  set fenc& bomb&\n\n  set ff&\n  bwipe!\nendfunc\n\n\" Test for g8\nfunc Test_normal34_g_cmd3()\n  new\n  let a=execute(':norm! 1G0g8')\n  call assert_equal(\"\\nNUL\", a)\n\n  call setline(1, 'abcdefghijklmnopqrstuvwxyz\u00e4\u00fc\u00f6')\n  let a=execute(':norm! 1G$g8')\n  call assert_equal(\"\\nc3 b6 \", a)\n\n  call setline(1, \"a\\u0302\")\n  let a=execute(':norm! 1G0g8')\n  call assert_equal(\"\\n61 + cc 82 \", a)\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test 8g8 which finds invalid utf8 at or after the cursor.\nfunc Test_normal_8g8()\n  new\n\n  \" With invalid byte.\n  call setline(1, \"___\\xff___\")\n  norm! 1G08g8g\n  call assert_equal([0, 1, 4, 0, 1], getcurpos())\n\n  \" With invalid byte before the cursor.\n  call setline(1, \"___\\xff___\")\n  norm! 1G$h8g8g\n  call assert_equal([0, 1, 6, 0, 9], getcurpos())\n\n  \" With truncated sequence.\n  call setline(1, \"___\\xE2\\x82___\")\n  norm! 1G08g8g\n  call assert_equal([0, 1, 4, 0, 1], getcurpos())\n\n  \" With overlong sequence.\n  call setline(1, \"___\\xF0\\x82\\x82\\xAC___\")\n  norm! 1G08g8g\n  call assert_equal([0, 1, 4, 0, 1], getcurpos())\n\n  \" With valid utf8.\n  call setline(1, \"caf\u00e9\")\n  norm! 1G08g8\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n\n  bw!\nendfunc\n\n\" Test for g<\nfunc Test_normal35_g_cmd4()\n  \" Cannot capture its output,\n  \" probably a bug, therefore, test disabled:\n  throw \"Skipped: output of g< can't be tested currently\"\n  echo \"a\\nb\\nc\\nd\"\n  let b=execute(':norm! g<')\n  call assert_true(!empty(b), 'failed `execute(g<)`')\nendfunc\n\n\" Test for gp gP go\nfunc Test_normal36_g_cmd5()\n  new\n  call append(0, 'abcdefghijklmnopqrstuvwxyz')\n  set ff=unix\n  \" Test for gp gP\n  call append(1, range(1,10))\n  1\n  norm! 1yy\n  3\n  norm! gp\n  call assert_equal([0, 5, 1, 0, 1], getcurpos())\n  $\n  norm! gP\n  call assert_equal([0, 14, 1, 0, 1], getcurpos())\n\n  \" Test for go\n  norm! 26go\n  call assert_equal([0, 1, 26, 0, 26], getcurpos())\n  norm! 27go\n  call assert_equal([0, 1, 26, 0, 26], getcurpos())\n  norm! 28go\n  call assert_equal([0, 2, 1, 0, 1], getcurpos())\n  set ff=dos\n  norm! 29go\n  call assert_equal([0, 2, 1, 0, 1], getcurpos())\n  set ff=unix\n  norm! gg0\n  norm! 101go\n  call assert_equal([0, 13, 26, 0, 26], getcurpos())\n  norm! 103go\n  call assert_equal([0, 14, 1, 0, 1], getcurpos())\n  \" count > buffer content\n  norm! 120go\n  call assert_equal([0, 14, 1, 0, v:maxcol], getcurpos())\n  \" clean up\n  bw!\nendfunc\n\n\" Test for gt and gT\nfunc Test_normal37_g_cmd6()\n  tabnew 1.txt\n  tabnew 2.txt\n  tabnew 3.txt\n  norm! 1gt\n  call assert_equal(1, tabpagenr())\n  norm! 3gt\n  call assert_equal(3, tabpagenr())\n  norm! 1gT\n  \" count gT goes not to the absolute tabpagenumber\n  \" but, but goes to the count previous tabpagenumber\n  call assert_equal(2, tabpagenr())\n  \" wrap around\n  norm! 3gT\n  call assert_equal(3, tabpagenr())\n  \" gt does not wrap around\n  norm! 5gt\n  call assert_equal(3, tabpagenr())\n\n  for i in range(3)\n    tabclose\n  endfor\n  \" clean up\n  call assert_fails(':tabclose', 'E784:')\nendfunc\n\n\" Test for <Home> and <C-Home> key\nfunc Test_normal38_nvhome()\n  new\n  call setline(1, range(10))\n  $\n  setl et sw=2\n  norm! V10>$\n  \" count is ignored\n  exe \"norm! 10\\<home>\"\n  call assert_equal(1, col('.'))\n  exe \"norm! \\<home>\"\n  call assert_equal([0, 10, 1, 0, 1], getcurpos())\n  exe \"norm! 5\\<c-home>\"\n  call assert_equal([0, 5, 1, 0, 1], getcurpos())\n  exe \"norm! \\<c-home>\"\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n  exe \"norm! G\\<c-kHome>\"\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for <End> and <C-End> keys\nfunc Test_normal_nvend()\n  new\n  call setline(1, map(range(1, 10), '\"line\" .. v:val'))\n  exe \"normal! \\<End>\"\n  call assert_equal(5, col('.'))\n  exe \"normal! 4\\<End>\"\n  call assert_equal([4, 5], [line('.'), col('.')])\n  exe \"normal! \\<C-End>\"\n  call assert_equal([10, 6], [line('.'), col('.')])\n\n  bwipe!\nendfunc\n\n\" Test for cw cW ce\nfunc Test_normal39_cw()\n  \" Test for cw and cW on whitespace\n  new\n  set tw=0\n  call append(0, 'here      are   some words')\n  norm! 1gg0elcwZZZ\n  call assert_equal('hereZZZare   some words', getline('.'))\n  norm! 1gg0elcWYYY\n  call assert_equal('hereZZZareYYYsome words', getline('.'))\n  norm! 2gg0cwfoo\n  call assert_equal('foo', getline('.'))\n\n  call setline(1, 'one; two')\n  call cursor(1, 1)\n  call feedkeys('cwvim', 'xt')\n  call assert_equal('vim; two', getline(1))\n  call feedkeys('0cWone', 'xt')\n  call assert_equal('one two', getline(1))\n  \"When cursor is at the end of a word 'ce' will change until the end of the\n  \"next word, but 'cw' will change only one character\n  call setline(1, 'one two')\n  call feedkeys('0ecwce', 'xt')\n  call assert_equal('once two', getline(1))\n  call setline(1, 'one two')\n  call feedkeys('0ecely', 'xt')\n  call assert_equal('only', getline(1))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for CTRL-\\ commands\nfunc Test_normal40_ctrl_bsl()\n  new\n  call append(0, 'here      are   some words')\n  exe \"norm! 1gg0a\\<C-\\>\\<C-N>\"\n  call assert_equal('n', mode())\n  call assert_equal(1, col('.'))\n  call assert_equal('', visualmode())\n  exe \"norm! 1gg0viw\\<C-\\>\\<C-N>\"\n  call assert_equal('n', mode())\n  call assert_equal(4, col('.'))\n  exe \"norm! 1gg0a\\<C-\\>\\<C-G>\"\n  call assert_equal('n', mode())\n  call assert_equal(1, col('.'))\n  \"imap <buffer> , <c-\\><c-n>\n  set im\n  exe \":norm! \\<c-\\>\\<c-n>dw\"\n  set noim\n  call assert_equal('are   some words', getline(1))\n  call assert_false(&insertmode)\n  call assert_beeps(\"normal! \\<C-\\>\\<C-A>\")\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for <c-r>=, <c-r><c-r>= and <c-r><c-o>= in insert mode\nfunc Test_normal41_insert_reg()\n  new\n  set sts=2 sw=2 ts=8 tw=0\n  call append(0, [\"aaa\\tbbb\\tccc\", '', '', ''])\n  let a=getline(1)\n  norm! 2gg0\n  exe \"norm! a\\<c-r>=a\\<cr>\"\n  norm! 3gg0\n  exe \"norm! a\\<c-r>\\<c-r>=a\\<cr>\"\n  norm! 4gg0\n  exe \"norm! a\\<c-r>\\<c-o>=a\\<cr>\"\n  call assert_equal(['aaa\tbbb\tccc', 'aaa bbb\tccc', 'aaa bbb\tccc', 'aaa\tbbb\tccc', ''], getline(1, '$'))\n\n  \" clean up\n  set sts=0 sw=8 ts=8\n  bw!\nendfunc\n\n\" Test for Ctrl-D and Ctrl-U\nfunc Test_normal42_halfpage()\n  call Setup_NewWindow()\n  call assert_equal(5, &scroll)\n  exe \"norm! \\<c-d>\"\n  call assert_equal('6', getline('.'))\n  exe \"norm! 2\\<c-d>\"\n  call assert_equal('8', getline('.'))\n  call assert_equal(2, &scroll)\n  set scroll=5\n  exe \"norm! \\<c-u>\"\n  call assert_equal('3', getline('.'))\n  1\n  set scrolloff=5\n  exe \"norm! \\<c-d>\"\n  call assert_equal('10', getline('.'))\n  exe \"norm! \\<c-u>\"\n  call assert_equal('5', getline('.'))\n  1\n  set scrolloff=99\n  exe \"norm! \\<c-d>\"\n  call assert_equal('10', getline('.'))\n  set scrolloff=0\n  100\n  exe \"norm! $\\<c-u>\"\n  call assert_equal('95', getline('.'))\n  call assert_equal([0, 95, 1, 0, 1], getcurpos())\n  100\n  set nostartofline\n  exe \"norm! $\\<c-u>\"\n  call assert_equal('95', getline('.'))\n  call assert_equal([0, 95, 2, 0, v:maxcol], getcurpos())\n  \" cleanup\n  set startofline\n  bw!\nendfunc\n\nfunc Test_normal45_drop()\n  if !has('dnd')\n    \" The ~ register does not exist\n    call assert_beeps('norm! \"~')\n    return\n  endif\n\n  \" basic test for drag-n-drop\n  \" unfortunately, without a gui, we can't really test much here,\n  \" so simply test that ~p fails (which uses the drop register)\n  new\n  call assert_fails(':norm! \"~p', 'E353:')\n  call assert_equal([],  getreg('~', 1, 1))\n  \" the ~ register is read only\n  call assert_fails(':let @~=\"1\"', 'E354:')\n  bw!\nendfunc\n\nfunc Test_normal46_ignore()\n  new\n  \" How to test this?\n  \" let's just for now test, that the buffer\n  \" does not change\n  call feedkeys(\"\\<c-s>\", 't')\n  call assert_equal([''], getline(1,'$'))\n\n  \" no valid commands\n  exe \"norm! \\<char-0x100>\"\n  call assert_equal([''], getline(1,'$'))\n\n  exe \"norm! \u00e4\"\n  call assert_equal([''], getline(1,'$'))\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal47_visual_buf_wipe()\n  \" This was causing a crash or ml_get error.\n  enew!\n  call setline(1,'xxx')\n  normal $\n  new\n  call setline(1, range(1,2))\n  2\n  exe \"norm \\<C-V>$\"\n  bw!\n  norm yp\n  set nomodified\nendfunc\n\nfunc Test_normal48_wincmd()\n  new\n  exe \"norm! \\<c-w>c\"\n  call assert_equal(1, winnr('$'))\n  call assert_fails(\":norm! \\<c-w>c\", 'E444:')\nendfunc\n\nfunc Test_normal49_counts()\n  new\n  call setline(1, 'one two three four five six seven eight nine ten')\n  1\n  norm! 3d2w\n  call assert_equal('seven eight nine ten', getline(1))\n  bw!\nendfunc\n\nfunc Test_normal50_commandline()\n  CheckFeature timers\n  CheckFeature cmdline_hist\n\n  func! DoTimerWork(id)\n    call assert_equal('[Command Line]', bufname(''))\n\n    \" should fail, with E11, but does fail with E23?\n    \"call feedkeys(\"\\<c-^>\", 'tm')\n\n    \" should fail with E11 - \"Invalid in command-line window\"\n    call assert_fails(\":wincmd p\", 'E11:')\n\n    \" Return from commandline window.\n    call feedkeys(\"\\<CR>\", 't')\n  endfunc\n\n  let oldlang=v:lang\n  lang C\n  set updatetime=20\n  call timer_start(100, 'DoTimerWork')\n  try\n    \" throws E23, for whatever reason...\n    call feedkeys('q:', 'x!')\n  catch /E23/\n    \" no-op\n  endtry\n\n  \" clean up\n  delfunc DoTimerWork\n  set updatetime=4000\n  exe \"lang\" oldlang\n  bw!\nendfunc\n\nfunc Test_normal51_FileChangedRO()\n  CheckFeature autocmd\n  \" Don't sleep after the warning message.\n  call test_settime(1)\n  call writefile(['foo'], 'Xreadonly.log', 'D')\n  new Xreadonly.log\n  setl ro\n  au FileChangedRO <buffer> :call feedkeys(\"\\<c-^>\", 'tix')\n  call assert_fails(\":norm! Af\", 'E788:')\n  call assert_equal(['foo'], getline(1,'$'))\n  call assert_equal('Xreadonly.log', bufname(''))\n\n  \" cleanup\n  call test_settime(0)\n  bw!\nendfunc\n\nfunc Test_normal52_rl()\n  CheckFeature rightleft\n  new\n  call setline(1, 'abcde fghij klmnopq')\n  norm! 1gg$\n  set rl\n  call assert_equal(19, col('.'))\n  call feedkeys('l', 'tx')\n  call assert_equal(18, col('.'))\n  call feedkeys('h', 'tx')\n  call assert_equal(19, col('.'))\n  call feedkeys(\"\\<right>\", 'tx')\n  call assert_equal(18, col('.'))\n  call feedkeys(\"\\<left>\", 'tx')\n  call assert_equal(19, col('.'))\n  call feedkeys(\"\\<s-right>\", 'tx')\n  call assert_equal(13, col('.'))\n  call feedkeys(\"\\<c-right>\", 'tx')\n  call assert_equal(7, col('.'))\n  call feedkeys(\"\\<c-left>\", 'tx')\n  call assert_equal(13, col('.'))\n  call feedkeys(\"\\<s-left>\", 'tx')\n  call assert_equal(19, col('.'))\n  call feedkeys(\"<<\", 'tx')\n  call assert_equal('\tabcde fghij klmnopq',getline(1))\n  call feedkeys(\">>\", 'tx')\n  call assert_equal('abcde fghij klmnopq',getline(1))\n\n  \" cleanup\n  set norl\n  bw!\nendfunc\n\nfunc Test_normal54_Ctrl_bsl()\n  new\n  call setline(1, 'abcdefghijklmn')\n  exe \"norm! df\\<c-\\>\\<c-n>\"\n  call assert_equal(['abcdefghijklmn'], getline(1,'$'))\n  exe \"norm! df\\<c-\\>\\<c-g>\"\n  call assert_equal(['abcdefghijklmn'], getline(1,'$'))\n  exe \"norm! df\\<c-\\>m\"\n  call assert_equal(['abcdefghijklmn'], getline(1,'$'))\n\n  call setline(2, 'abcdefghijklmn\u0101f')\n  norm! 2gg0\n  exe \"norm! df\\<Char-0x101>\"\n  call assert_equal(['abcdefghijklmn', 'f'], getline(1,'$'))\n  norm! 1gg0\n  exe \"norm! df\\<esc>\"\n  call assert_equal(['abcdefghijklmn', 'f'], getline(1,'$'))\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal_large_count()\n  \" This may fail with 32bit long, how do we detect that?\n  new\n  normal o\n  normal 6666666666dL\n  bwipe!\nendfunc\n\nfunc Test_delete_until_paragraph()\n  new\n  normal gr\u00e1dv}\n  call assert_equal('\u00e1', getline(1))\n  normal gr\u00e1d}\n  call assert_equal('', getline(1))\n  bwipe!\nendfunc\n\n\" Test for the gr (virtual replace) command\nfunc Test_gr_command()\n  enew!\n  \" Test for the bug fixed by 7.4.387\n  let save_cpo = &cpo\n  call append(0, ['First line', 'Second line', 'Third line'])\n  exe \"normal i\\<C-G>u\"\n  call cursor(2, 1)\n  set cpo-=X\n  normal 4gro\n  call assert_equal('oooond line', getline(2))\n  undo\n  set cpo+=X\n  normal 4gro\n  call assert_equal('ooooecond line', getline(2))\n  let &cpo = save_cpo\n\n  normal! ggvegrx\n  call assert_equal('xxxxx line', getline(1))\n  exe \"normal! gggr\\<C-V>122\"\n  call assert_equal('zxxxx line', getline(1))\n\n  set virtualedit=all\n  normal! 15|grl\n  call assert_equal('zxxxx line    l', getline(1))\n  set virtualedit&\n  set nomodifiable\n  call assert_fails('normal! grx', 'E21:')\n  call assert_fails('normal! gRx', 'E21:')\n  call assert_nobeep(\"normal! gr\\<Esc>\")\n  set modifiable&\n\n  call assert_nobeep(\"normal! gr\\<Esc>\")\n  call assert_nobeep(\"normal! cgr\\<Esc>\")\n  call assert_beeps(\"normal! cgrx\")\n\n  call assert_equal('zxxxx line    l', getline(1))\n  exe \"normal! 2|gr\\<C-V>\\<Esc>\"\n  call assert_equal(\"z\\<Esc>xx line    l\", getline(1))\n\n  call setline(1, 'abcdef')\n  exe \"normal! 0gr\\<C-O>lx\"\n  call assert_equal(\"\\<C-O>def\", getline(1))\n\n  call setline(1, 'abcdef')\n  exe \"normal! 0gr\\<C-G>lx\"\n  call assert_equal(\"\\<C-G>def\", getline(1))\n\n  bwipe!\nendfunc\n\nfunc Test_nv_hat_count()\n  %bwipeout!\n  let l:nr = bufnr('%') + 1\n  call assert_fails(':execute \"normal! ' . l:nr . '\\<C-^>\"', 'E92:')\n\n  edit Xfoo\n  let l:foo_nr = bufnr('Xfoo')\n\n  edit Xbar\n  let l:bar_nr = bufnr('Xbar')\n\n  \" Make sure we are not just using the alternate file.\n  edit Xbaz\n\n  call feedkeys(l:foo_nr . \"\\<C-^>\", 'tx')\n  call assert_equal('Xfoo', fnamemodify(bufname('%'), ':t'))\n\n  call feedkeys(l:bar_nr . \"\\<C-^>\", 'tx')\n  call assert_equal('Xbar', fnamemodify(bufname('%'), ':t'))\n\n  %bwipeout!\nendfunc\n\nfunc Test_message_when_using_ctrl_c()\n  \" Make sure no buffers are changed.\n  %bwipe!\n\n  exe \"normal \\<C-C>\"\n  call assert_match(\"Type  :qa  and press <Enter> to exit Vim\", Screenline(&lines))\n\n  new\n  cal setline(1, 'hi!')\n  exe \"normal \\<C-C>\"\n  call assert_match(\"Type  :qa!  and press <Enter> to abandon all changes and exit Vim\", Screenline(&lines))\n\n  bwipe!\nendfunc\n\nfunc Test_mode_updated_after_ctrl_c()\n  CheckScreendump\n\n  let buf = RunVimInTerminal('', {'rows': 5})\n  call term_sendkeys(buf, \"i\")\n  call term_sendkeys(buf, \"\\<C-O>\")\n  \" wait a moment so that the \"-- (insert) --\" message is displayed\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \"\\<C-C>\")\n  call VerifyScreenDump(buf, 'Test_mode_updated_1', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test for '[m', ']m', '[M' and ']M'\n\" Jumping to beginning and end of methods in Java-like languages\nfunc Test_java_motion()\n  new\n  call assert_beeps('normal! [m')\n  call assert_beeps('normal! ]m')\n  call assert_beeps('normal! [M')\n  call assert_beeps('normal! ]M')\n  let lines =<< trim [CODE]\n\tPiece of Java\n\t{\n\t\ttt m1 {\n\t\t\tt1;\n\t\t} e1\n\n\t\ttt m2 {\n\t\t\tt2;\n\t\t} e2\n\n\t\ttt m3 {\n\t\t\tif (x)\n\t\t\t{\n\t\t\t\tt3;\n\t\t\t}\n\t\t} e3\n\t}\n  [CODE]\n  call setline(1, lines)\n\n  normal gg\n\n  normal 2]maA\n  call assert_equal(\"\\ttt m1 {A\", getline('.'))\n  call assert_equal([3, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal j]maB\n  call assert_equal(\"\\ttt m2 {B\", getline('.'))\n  call assert_equal([7, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal ]maC\n  call assert_equal(\"\\ttt m3 {C\", getline('.'))\n  call assert_equal([11, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal [maD\n  call assert_equal(\"\\ttt m3 {DC\", getline('.'))\n  call assert_equal([11, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal k2[maE\n  call assert_equal(\"\\ttt m1 {EA\", getline('.'))\n  call assert_equal([3, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal 3[maF\n  call assert_equal(\"{F\", getline('.'))\n  call assert_equal([2, 2, 2], [line('.'), col('.'), virtcol('.')])\n\n  normal ]MaG\n  call assert_equal(\"\\t}G e1\", getline('.'))\n  call assert_equal([5, 3, 10], [line('.'), col('.'), virtcol('.')])\n\n  normal j2]MaH\n  call assert_equal(\"\\t}H e3\", getline('.'))\n  call assert_equal([16, 3, 10], [line('.'), col('.'), virtcol('.')])\n\n  normal ]M]M\n  normal aI\n  call assert_equal(\"}I\", getline('.'))\n  call assert_equal([17, 2, 2], [line('.'), col('.'), virtcol('.')])\n\n  normal 2[MaJ\n  call assert_equal(\"\\t}JH e3\", getline('.'))\n  call assert_equal([16, 3, 10], [line('.'), col('.'), virtcol('.')])\n\n  normal k[MaK\n  call assert_equal(\"\\t}K e2\", getline('.'))\n  call assert_equal([9, 3, 10], [line('.'), col('.'), virtcol('.')])\n\n  normal 3[MaL\n  call assert_equal(\"{LF\", getline('.'))\n  call assert_equal([2, 2, 2], [line('.'), col('.'), virtcol('.')])\n\n  call cursor(2, 1)\n  call assert_beeps('norm! 5]m')\n\n  \" jumping to a method in a fold should open the fold\n  6,10fold\n  call feedkeys(\"gg3]m\", 'xt')\n  call assert_equal([7, 8, 15], [line('.'), col('.'), virtcol('.')])\n  call assert_equal(-1, foldclosedend(7))\n\n  bwipe!\nendfunc\n\n\" Tests for g cmds\nfunc Test_normal_gdollar_cmd()\n  call Setup_NewWindow()\n  \" Make long lines that will wrap\n  %s/$/\\=repeat(' foobar', 10)/\n  20vsp\n  set wrap\n  \" Test for g$ with count\n  norm! gg\n  norm! 0vg$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('1 foobar foobar foob', getreg(0))\n  norm! gg\n  norm! 0v4g$y\n  call assert_equal(72, col(\"'>\"))\n  call assert_equal('1 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'..\"\\n\", getreg(0))\n  norm! gg\n  norm! 0v6g$y\n  call assert_equal(40, col(\"'>\"))\n  call assert_equal('1 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n\t\t  \\ '2 foobar foobar foobar foobar foobar foo', getreg(0))\n  set nowrap\n  \" clean up\n  norm! gg\n  norm! 0vg$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('1 foobar foobar foob', getreg(0))\n  norm! gg\n  norm! 0v4g$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('1 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '2 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '3 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '4 foobar foobar foob', getreg(0))\n  norm! gg\n  norm! 0v6g$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('1 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '2 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '3 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '4 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '5 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '6 foobar foobar foob', getreg(0))\n  \" Move to last line, also down movement is not possible, should still move\n  \" the cursor to the last visible char\n  norm! G\n  norm! 0v6g$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('100 foobar foobar fo', getreg(0))\n  bw!\nendfunc\n\nfunc Test_normal_gk_gj()\n  \" needs 80 column new window\n  new\n  vert 80new\n  call assert_beeps('normal gk')\n  put =[repeat('x',90)..' {{{1', 'x {{{1']\n  norm! gk\n  \" In a 80 column wide terminal the window will be only 78 char\n  \" (because Vim will leave space for the other window),\n  \" but if the terminal is larger, it will be 80 chars, so verify the\n  \" cursor column correctly.\n  call assert_equal(winwidth(0)+1, col('.'))\n  call assert_equal(winwidth(0)+1, virtcol('.'))\n  norm! j\n  call assert_equal(6, col('.'))\n  call assert_equal(6, virtcol('.'))\n  norm! gk\n  call assert_equal(95, col('.'))\n  call assert_equal(95, virtcol('.'))\n  %bw!\n\n  \" needs 80 column new window\n  new\n  vert 80new\n  call assert_beeps('normal gj')\n  set number\n  set numberwidth=10\n  set cpoptions+=n\n  put =[repeat('0',90), repeat('1',90)]\n  norm! 075l\n  call assert_equal(76, col('.'))\n  norm! gk\n  call assert_equal(1, col('.'))\n  norm! gk\n  call assert_equal(76, col('.'))\n  norm! gk\n  call assert_equal(1, col('.'))\n  norm! gj\n  call assert_equal(76, col('.'))\n  norm! gj\n  call assert_equal(1, col('.'))\n  norm! gj\n  call assert_equal(76, col('.'))\n  \" When 'nowrap' is set, gk and gj behave like k and j\n  set nowrap\n  normal! gk\n  call assert_equal([2, 76], [line('.'), col('.')])\n  normal! gj\n  call assert_equal([3, 76], [line('.'), col('.')])\n  %bw!\n  set cpoptions& number& numberwidth& wrap&\nendfunc\n\n\" Test for using : to run a multi-line Ex command in operator pending mode\nfunc Test_normal_yank_with_excmd()\n  new\n  call setline(1, ['foo', 'bar', 'baz'])\n  let @a = ''\n  call feedkeys(\"\\\"ay:if v:true\\<CR>normal l\\<CR>endif\\<CR>\", 'xt')\n  call assert_equal('f', @a)\n\n  bwipe!\nendfunc\n\n\" Test for supplying a count to a normal-mode command across a cursorhold call\nfunc Test_normal_cursorhold_with_count()\n  func s:cHold()\n    let g:cHold_Called += 1\n  endfunc\n  new\n  augroup normalcHoldTest\n    au!\n    au CursorHold <buffer> call s:cHold()\n  augroup END\n  let g:cHold_Called = 0\n  call feedkeys(\"3\\<CursorHold>2ix\", 'xt')\n  call assert_equal(1, g:cHold_Called)\n  call assert_equal(repeat('x', 32), getline(1))\n  augroup normalcHoldTest\n    au!\n  augroup END\n  au! normalcHoldTest\n\n  bwipe!\n  delfunc s:cHold\nendfunc\n\n\" Test for using a count and a command with CTRL-W\nfunc Test_wincmd_with_count()\n  call feedkeys(\"\\<C-W>12n\", 'xt')\n  call assert_equal(12, winheight(0))\nendfunc\n\n\" Test for 'b', 'B' 'ge' and 'gE' commands\nfunc Test_horiz_motion()\n  new\n  normal! gg\n  call assert_beeps('normal! b')\n  call assert_beeps('normal! B')\n  call assert_beeps('normal! gE')\n  call assert_beeps('normal! ge')\n  \" <S-Backspace> moves one word left and <C-Backspace> moves one WORD left\n  call setline(1, 'one ,two ,three')\n  exe \"normal! $\\<S-BS>\"\n  call assert_equal(11, col('.'))\n  exe \"normal! $\\<C-BS>\"\n  call assert_equal(10, col('.'))\n\n  bwipe!\nendfunc\n\n\" Test for using a \":\" command in operator pending mode\nfunc Test_normal_colon_op()\n  new\n  call setline(1, ['one', 'two'])\n  call assert_beeps(\"normal! Gc:d\\<CR>\")\n  call assert_equal(['one'], getline(1, '$'))\n\n  call setline(1, ['one\u2026two\u2026three!'])\n  normal! $\n  \" Using \":\" as a movement is characterwise exclusive\n  call feedkeys(\"d:normal! F\u2026\\<CR>\", 'xt')\n  call assert_equal(['one\u2026two!'], getline(1, '$'))\n  \" Check that redoing a command with 0x80 bytes works\n  call feedkeys('.', 'xt')\n  call assert_equal(['one!'], getline(1, '$'))\n\n  call setline(1, ['one', 'two', 'three', 'four', 'five'])\n  \" Add this to the command history\n  call feedkeys(\":normal! G0\\<CR>\", 'xt')\n  \" Use :normal! with control characters in operator pending mode\n  call feedkeys(\"d:normal! \\<C-V>\\<C-P>\\<C-V>\\<C-P>\\<CR>\", 'xt')\n  call assert_equal(['one', 'two', 'five'], getline(1, '$'))\n  \" Check that redoing a command with control characters works\n  call feedkeys('.', 'xt')\n  call assert_equal(['five'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Test for d and D commands\nfunc Test_normal_delete_cmd()\n  new\n  \" D in an empty line\n  call setline(1, '')\n  normal D\n  call assert_equal('', getline(1))\n  \" D in an empty line in virtualedit mode\n  set virtualedit=all\n  normal D\n  call assert_equal('', getline(1))\n  set virtualedit&\n  \" delete to a readonly register\n  call setline(1, ['abcd'])\n  call assert_beeps('normal \":d2l')\n\n  \" D and d with 'nomodifiable'\n  call setline(1, ['abcd'])\n  setlocal nomodifiable\n  call assert_fails('normal D', 'E21:')\n  call assert_fails('normal d$', 'E21:')\n\n  bwipe!\nendfunc\n\n\" Test for deleting or changing characters across lines with 'whichwrap'\n\" containing 's'. Should count <EOL> as one character.\nfunc Test_normal_op_across_lines()\n  new\n  set whichwrap&\n  call setline(1, ['one two', 'three four'])\n  exe \"norm! $3d\\<Space>\"\n  call assert_equal(['one twhree four'], getline(1, '$'))\n\n  call setline(1, ['one two', 'three four'])\n  exe \"norm! $3c\\<Space>x\"\n  call assert_equal(['one twxhree four'], getline(1, '$'))\n\n  set whichwrap+=l\n  call setline(1, ['one two', 'three four'])\n  exe \"norm! $3x\"\n  call assert_equal(['one twhree four'], getline(1, '$'))\n\n  bwipe!\n  set whichwrap&\nendfunc\n\n\" Test for 'w' and 'b' commands\nfunc Test_normal_word_move()\n  new\n  call setline(1, ['foo bar a', '', 'foo bar b'])\n  \" copy a single character word at the end of a line\n  normal 1G$yw\n  call assert_equal('a', @\")\n  \" copy a single character word at the end of a file\n  normal G$yw\n  call assert_equal('b', @\")\n  \" check for a word movement handling an empty line properly\n  normal 1G$vwy\n  call assert_equal(\"a\\n\\n\", @\")\n\n  \" copy using 'b' command\n  %d\n  \" non-empty blank line at the start of file\n  call setline(1, ['  ', 'foo bar'])\n  normal 2Gyb\n  call assert_equal(\"  \\n\", @\")\n  \" try to copy backwards from the start of the file\n  call setline(1, ['one two', 'foo bar'])\n  call assert_beeps('normal ggyb')\n  \" 'b' command should stop at an empty line\n  call setline(1, ['one two', '', 'foo bar'])\n  normal 3Gyb\n  call assert_equal(\"\\n\", @\")\n  normal 3Gy2b\n  call assert_equal(\"two\\n\", @\")\n  \" 'b' command should not stop at a non-empty blank line\n  call setline(1, ['one two', '  ', 'foo bar'])\n  normal 3Gyb\n  call assert_equal(\"two\\n  \", @\")\n\n  bwipe!\nendfunc\n\n\" Test for 'scrolloff' with a long line that doesn't fit in the screen\nfunc Test_normal_scrolloff()\n  10new\n  60vnew\n  call setline(1, ' 1 ' .. repeat('a', 57)\n             \\ .. ' 2 ' .. repeat('b', 57)\n             \\ .. ' 3 ' .. repeat('c', 57)\n             \\ .. ' 4 ' .. repeat('d', 57)\n             \\ .. ' 5 ' .. repeat('e', 57)\n             \\ .. ' 6 ' .. repeat('f', 57)\n             \\ .. ' 7 ' .. repeat('g', 57)\n             \\ .. ' 8 ' .. repeat('h', 57)\n             \\ .. ' 9 ' .. repeat('i', 57)\n             \\ .. '10 ' .. repeat('j', 57)\n             \\ .. '11 ' .. repeat('k', 57)\n             \\ .. '12 ' .. repeat('l', 57)\n             \\ .. '13 ' .. repeat('m', 57)\n             \\ .. '14 ' .. repeat('n', 57)\n             \\ .. '15 ' .. repeat('o', 57)\n             \\ .. '16 ' .. repeat('p', 57)\n             \\ .. '17 ' .. repeat('q', 57)\n             \\ .. '18 ' .. repeat('r', 57)\n             \\ .. '19 ' .. repeat('s', 57)\n             \\ .. '20 ' .. repeat('t', 57)\n             \\ .. '21 ' .. repeat('u', 57)\n             \\ .. '22 ' .. repeat('v', 57)\n             \\ .. '23 ' .. repeat('w', 57)\n             \\ .. '24 ' .. repeat('x', 57)\n             \\ .. '25 ' .. repeat('y', 57)\n             \\ .. '26 ' .. repeat('z', 57)\n             \\ )\n  set scrolloff=10\n  normal gg10gj\n  call assert_equal(6, winline())\n  normal 10gj\n  call assert_equal(6, winline())\n  normal 10gk\n  call assert_equal(6, winline())\n  normal 0\n  call assert_equal(1, winline())\n  normal $\n  call assert_equal(10, winline())\n\n  set scrolloff&\n  bwipe!\nendfunc\n\n\" Test for vertical scrolling with CTRL-F and CTRL-B with a long line\nfunc Test_normal_vert_scroll_longline()\n  10new\n  80vnew\n  call setline(1, range(1, 10))\n  call append(5, repeat('a', 1000))\n  exe \"normal gg\\<C-F>\"\n  call assert_equal(6, line('.'))\n  exe \"normal \\<C-F>\\<C-F>\"\n  call assert_equal(11, line('.'))\n  call assert_equal(1, winline())\n  exe \"normal \\<C-B>\"\n  call assert_equal(10, line('.'))\n  call assert_equal(3, winline())\n  exe \"normal \\<C-B>\\<C-B>\"\n  call assert_equal(5, line('.'))\n  call assert_equal(5, winline())\n\n  bwipe!\nendfunc\n\n\" Test for jumping in a file using %\nfunc Test_normal_percent_jump()\n  new\n  call setline(1, range(1, 100))\n\n  \" jumping to a folded line should open the fold\n  25,75fold\n  call feedkeys('50%', 'xt')\n  call assert_equal(50, line('.'))\n  call assert_equal(-1, foldclosedend(50))\n\n  bwipe!\nendfunc\n\n\" Test for << and >> commands to shift text by 'shiftwidth'\nfunc Test_normal_shift_rightleft()\n  new\n  call setline(1, ['one', '', \"\\t\", '  two', \"\\tthree\", '      four'])\n  set shiftwidth=2 tabstop=8\n  normal gg6>>\n  call assert_equal(['  one', '', \"\\t  \", '    two', \"\\t  three\", \"\\tfour\"],\n        \\ getline(1, '$'))\n  normal ggVG2>>\n  call assert_equal(['      one', '', \"\\t      \", \"\\ttwo\",\n        \\ \"\\t      three\", \"\\t    four\"], getline(1, '$'))\n  normal gg6<<\n  call assert_equal(['    one', '', \"\\t    \", '      two', \"\\t    three\",\n        \\ \"\\t  four\"], getline(1, '$'))\n  normal ggVG2<<\n  call assert_equal(['one', '', \"\\t\", '  two', \"\\tthree\", '      four'],\n        \\ getline(1, '$'))\n  set shiftwidth& tabstop&\n  bw!\nendfunc\n\n\" Some commands like yy, cc, dd, >>, << and !! accept a count after\n\" typing the first letter of the command.\nfunc Test_normal_count_after_operator()\n  new\n  setlocal shiftwidth=4 tabstop=8 autoindent\n  call setline(1, ['one', 'two', 'three', 'four', 'five'])\n  let @a = ''\n  normal! j\"ay4y\n  call assert_equal(\"two\\nthree\\nfour\\nfive\\n\", @a)\n  normal! 3G>2>\n  call assert_equal(['one', 'two', '    three', '    four', 'five'],\n        \\ getline(1, '$'))\n  exe \"normal! 3G0c2cred\\nblue\"\n  call assert_equal(['one', 'two', '    red', '    blue', 'five'],\n        \\ getline(1, '$'))\n  exe \"normal! gg<8<\"\n  call assert_equal(['one', 'two', 'red', 'blue', 'five'],\n        \\ getline(1, '$'))\n  exe \"normal! ggd3d\"\n  call assert_equal(['blue', 'five'], getline(1, '$'))\n  call setline(1, range(1, 4))\n  call feedkeys(\"gg!3!\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\".,.+2!', @:)\n  call feedkeys(\"gg!1!\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\".!', @:)\n  call feedkeys(\"gg!9!\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\".,$!', @:)\n  bw!\nendfunc\n\nfunc Test_normal_gj_on_extra_wide_char()\n  new | 25vsp\n  let text='1 foooooooo ar e  ins\u200dzwe1 foooooooo ins\u200dzwei' .\n         \\ ' i drei vier f\u00fcnf sechs sieben acht un zehn elf zw\u00f6fl' .\n         \\ ' dreizehn v ierzehn f\u00fcnfzehn'\n  put =text\n  call cursor(2,1)\n  norm! gj\n  call assert_equal([0,2,25,0], getpos('.'))\n  bw!\nendfunc\n\nfunc Test_normal_count_out_of_range()\n  new\n  call setline(1, 'text')\n  normal 44444444444|\n  call assert_equal(999999999, v:count)\n  normal 444444444444|\n  call assert_equal(999999999, v:count)\n  normal 4444444444444|\n  call assert_equal(999999999, v:count)\n  normal 4444444444444444444|\n  call assert_equal(999999999, v:count)\n\n  normal 9y99999999|\n  call assert_equal(899999991, v:count)\n  normal 10y99999999|\n  call assert_equal(999999999, v:count)\n  normal 44444444444y44444444444|\n  call assert_equal(999999999, v:count)\n  bwipe!\nendfunc\n\n\" Test that mouse shape is restored to Normal mode after failed \"c\" operation.\nfunc Test_mouse_shape_after_failed_change()\n  CheckFeature mouseshape\n  CheckCanRunGui\n\n  let lines =<< trim END\n    vim9script\n    set mouseshape+=o:busy\n    setlocal nomodifiable\n    var mouse_shapes = []\n\n    feedkeys('c')\n    timer_start(50, (_) => {\n      mouse_shapes += [getmouseshape()]\n      timer_start(50, (_) => {\n        feedkeys('c')\n        timer_start(50, (_) => {\n          mouse_shapes += [getmouseshape()]\n          timer_start(50, (_) => {\n            writefile(mouse_shapes, 'Xmouseshapes')\n            quit\n          })\n        })\n      })\n    })\n  END\n  call writefile(lines, 'Xmouseshape.vim', 'D')\n  call RunVim([], [], \"-g -S Xmouseshape.vim\")\n  sleep 300m\n  call assert_equal(['busy', 'arrow'], readfile('Xmouseshapes'))\n\n  call delete('Xmouseshapes')\nendfunc\n\n\" Test that mouse shape is restored to Normal mode after cancelling \"gr\".\nfunc Test_mouse_shape_after_cancelling_gr()\n  CheckFeature mouseshape\n  CheckCanRunGui\n\n  let lines =<< trim END\n    vim9script\n    var mouse_shapes = []\n\n    feedkeys('gr')\n    timer_start(50, (_) => {\n      mouse_shapes += [getmouseshape()]\n      timer_start(50, (_) => {\n        feedkeys(\"\\<Esc>\")\n        timer_start(50, (_) => {\n          mouse_shapes += [getmouseshape()]\n          timer_start(50, (_) => {\n            writefile(mouse_shapes, 'Xmouseshapes')\n            quit\n          })\n        })\n      })\n    })\n  END\n  call writefile(lines, 'Xmouseshape.vim', 'D')\n  call RunVim([], [], \"-g -S Xmouseshape.vim\")\n  sleep 300m\n  call assert_equal(['beam', 'arrow'], readfile('Xmouseshapes'))\n\n  call delete('Xmouseshapes')\nendfunc\n\n\" Test that \"j\" does not skip lines when scrolling below botline and\n\" 'foldmethod' is not \"manual\".\nfunc Test_normal_j_below_botline()\n  CheckScreendump\n\n  let lines =<< trim END\n    set number foldmethod=diff scrolloff=0\n    call setline(1, map(range(1, 9), 'repeat(v:val, 200)'))\n    norm Lj\n  END\n  call writefile(lines, 'XNormalJBelowBotline', 'D')\n  let buf = RunVimInTerminal('-S XNormalJBelowBotline', #{rows: 19, cols: 40})\n\n  call VerifyScreenDump(buf, 'Test_normal_j_below_botline', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test for r (replace) command with CTRL_V and CTRL_Q\nfunc Test_normal_r_ctrl_v_cmd()\n  new\n  call append(0, 'This is a simple test: abcd')\n  exe \"norm! 1gg$r\\<C-V>\\<C-V>\"\n  call assert_equal(['This is a simple test: abc\u0016', ''], getline(1,'$'))\n  exe \"norm! 1gg$hr\\<C-Q>\\<C-Q>\"\n  call assert_equal(['This is a simple test: ab\u0011\u0016', ''], getline(1,'$'))\n  exe \"norm! 1gg$2hr\\<C-V>x7e\"\n  call assert_equal(['This is a simple test: a~\u0011\u0016', ''], getline(1,'$'))\n  exe \"norm! 1gg$3hr\\<C-Q>x7e\"\n  call assert_equal(['This is a simple test: ~~\u0011\u0016', ''], getline(1,'$'))\n\n  if &encoding == 'utf-8'\n    exe \"norm! 1gg$4hr\\<C-V>u20ac\"\n    call assert_equal(['This is a simple test:\u20ac~~\u0011\u0016', ''], getline(1,'$'))\n    exe \"norm! 1gg$5hr\\<C-Q>u20ac\"\n    call assert_equal(['This is a simple test\u20ac\u20ac~~\u0011\u0016', ''], getline(1,'$'))\n    exe \"norm! 1gg0R\\<C-V>xff WAS  \\<esc>\"\n    call assert_equal(['\u00ff WAS   a simple test\u20ac\u20ac~~\u0011\u0016', ''], getline(1,'$'))\n    exe \"norm! 1gg0elR\\<C-Q>xffNOT\\<esc>\"\n    call assert_equal(['\u00ff WAS\u00ffNOT simple test\u20ac\u20ac~~\u0011\u0016', ''], getline(1,'$'))\n  endif\n\n  call setline(1, 'This is a simple test: abcd')\n  exe \"norm! 1gg$gr\\<C-V>\\<C-V>\"\n  call assert_equal(['This is a simple test: abc\u0016', ''], getline(1,'$'))\n  exe \"norm! 1gg$hgr\\<C-Q>\\<C-Q>\"\n  call assert_equal(['This is a simple test: ab\u0011 ', ''], getline(1,'$'))\n  exe \"norm! 1gg$2hgr\\<C-V>x7e\"\n  call assert_equal(['This is a simple test: a~\u0011 ', ''], getline(1,'$'))\n  exe \"norm! 1gg$3hgr\\<C-Q>x7e\"\n  call assert_equal(['This is a simple test: ~~\u0011 ', ''], getline(1,'$'))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test clicking on a TAB or an unprintable character in Normal mode\nfunc Test_normal_click_on_ctrl_char()\n  let save_mouse = &mouse\n  set mouse=a\n  new\n\n  call setline(1, \"a\\<Tab>b\\<C-K>c\")\n  redraw\n  call test_setmouse(1, 1)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n  call test_setmouse(1, 2)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 2, 0, 2], getcurpos())\n  call test_setmouse(1, 3)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 2, 0, 3], getcurpos())\n  call test_setmouse(1, 7)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 2, 0, 7], getcurpos())\n  call test_setmouse(1, 8)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 2, 0, 8], getcurpos())\n  call test_setmouse(1, 9)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 3, 0, 9], getcurpos())\n  call test_setmouse(1, 10)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 4, 0, 10], getcurpos())\n  call test_setmouse(1, 11)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 4, 0, 11], getcurpos())\n  call test_setmouse(1, 12)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 5, 0, 12], getcurpos())\n  call test_setmouse(1, 13)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 5, 0, 13], getcurpos())\n\n  bwipe!\n  let &mouse = save_mouse\nendfunc\n\n\" Test clicking on a double-width character in Normal mode\nfunc Test_normal_click_on_double_width_char()\n  let save_mouse = &mouse\n  set mouse=a\n  new\n\n  call setline(1, \"\u53e3\u53e3\")\n  redraw\n  call test_setmouse(1, 1)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n  call test_setmouse(1, 2)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 1, 0, 2], getcurpos())\n  call test_setmouse(1, 3)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 4, 0, 3], getcurpos())\n  call test_setmouse(1, 4)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 4, 0, 4], getcurpos())\n\n  bwipe!\n  let &mouse = save_mouse\nendfunc\n\nfunc Test_normal_click_on_empty_line()\n  let save_mouse = &mouse\n  set mouse=a\n  botright new\n  call setline(1, ['', '', ''])\n  let row = win_screenpos(0)[0] + 2\n  20vsplit\n  redraw\n\n  call test_setmouse(row, 1)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 3, 1, 0, 1], getcurpos())\n  call test_setmouse(row, 2)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 3, 1, 0, 2], getcurpos())\n  call test_setmouse(row, 10)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 3, 1, 0, 10], getcurpos())\n\n  call test_setmouse(row, 21 + 1)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 3, 1, 0, 1], getcurpos())\n  call test_setmouse(row, 21 + 2)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 3, 1, 0, 2], getcurpos())\n  call test_setmouse(row, 21 + 10)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 3, 1, 0, 10], getcurpos())\n\n  bwipe!\n  let &mouse = save_mouse\nendfunc\n\nfunc Test_normal33_g_cmd_nonblank()\n  \" Test that g<End> goes to the last non-blank char and g$ to the last\n  \" visible column\n  20vnew\n  setlocal nowrap nonumber signcolumn=no\n  call setline(1, ['fooo   fooo         fooo   fooo         fooo   fooo         fooo   fooo        '])\n  exe \"normal 0g\\<End>\"\n  call assert_equal(11, col('.'))\n  normal 0g$\n  call assert_equal(20, col('.'))\n  exe \"normal 0g\\<kEnd>\"\n  call assert_equal(11, col('.'))\n  setlocal wrap\n  exe \"normal 0g\\<End>\"\n  call assert_equal(11, col('.'))\n  normal 0g$\n  call assert_equal(20, col('.'))\n  exe \"normal 0g\\<kEnd>\"\n  call assert_equal(11, col('.'))\n  bw!\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n#  ifdef DYNAMIC_PYTHON3_STABLE_ABI\n\t\"+python3/dyn-stable\",\n#  else\n\t\"+python3/dyn\",\n#  endif\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n# ifdef FEAT_XATTR\n\t\"+xattr\",\n# else\n\t\"-xattr\",\n# endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar et al.\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * normal.c:\tContains the main routine for processing characters in command\n *\t\tmode.  Communicates closely with the code in ops.c to handle\n *\t\tthe operators.\n */\n\n#include \"vim.h\"\n\nstatic int\tVIsual_mode_orig = NUL;\t\t// saved Visual mode\n\n#ifdef FEAT_EVAL\nstatic void\tset_vcount_ca(cmdarg_T *cap, int *set_prevcount);\n#endif\nstatic void\tunshift_special(cmdarg_T *cap);\nstatic void\tdel_from_showcmd(int);\n\n/*\n * nv_*(): functions called to handle Normal and Visual mode commands.\n * n_*(): functions called to handle Normal mode commands.\n * v_*(): functions called to handle Visual mode commands.\n */\nstatic void\tnv_ignore(cmdarg_T *cap);\nstatic void\tnv_nop(cmdarg_T *cap);\nstatic void\tnv_error(cmdarg_T *cap);\nstatic void\tnv_help(cmdarg_T *cap);\nstatic void\tnv_addsub(cmdarg_T *cap);\nstatic void\tnv_page(cmdarg_T *cap);\nstatic void\tnv_zet(cmdarg_T *cap);\n#ifdef FEAT_GUI\nstatic void\tnv_ver_scrollbar(cmdarg_T *cap);\nstatic void\tnv_hor_scrollbar(cmdarg_T *cap);\n#endif\n#ifdef FEAT_GUI_TABLINE\nstatic void\tnv_tabline(cmdarg_T *cap);\nstatic void\tnv_tabmenu(cmdarg_T *cap);\n#endif\nstatic void\tnv_exmode(cmdarg_T *cap);\nstatic void\tnv_colon(cmdarg_T *cap);\nstatic void\tnv_ctrlg(cmdarg_T *cap);\nstatic void\tnv_ctrlh(cmdarg_T *cap);\nstatic void\tnv_clear(cmdarg_T *cap);\nstatic void\tnv_ctrlo(cmdarg_T *cap);\nstatic void\tnv_hat(cmdarg_T *cap);\nstatic void\tnv_Zet(cmdarg_T *cap);\nstatic void\tnv_ident(cmdarg_T *cap);\nstatic void\tnv_tagpop(cmdarg_T *cap);\nstatic void\tnv_scroll(cmdarg_T *cap);\nstatic void\tnv_right(cmdarg_T *cap);\nstatic void\tnv_left(cmdarg_T *cap);\nstatic void\tnv_up(cmdarg_T *cap);\nstatic void\tnv_down(cmdarg_T *cap);\nstatic void\tnv_end(cmdarg_T *cap);\nstatic void\tnv_dollar(cmdarg_T *cap);\nstatic void\tnv_search(cmdarg_T *cap);\nstatic void\tnv_next(cmdarg_T *cap);\nstatic int\tnormal_search(cmdarg_T *cap, int dir, char_u *pat, int opt, int *wrapped);\nstatic void\tnv_csearch(cmdarg_T *cap);\nstatic void\tnv_brackets(cmdarg_T *cap);\nstatic void\tnv_percent(cmdarg_T *cap);\nstatic void\tnv_brace(cmdarg_T *cap);\nstatic void\tnv_mark(cmdarg_T *cap);\nstatic void\tnv_findpar(cmdarg_T *cap);\nstatic void\tnv_undo(cmdarg_T *cap);\nstatic void\tnv_kundo(cmdarg_T *cap);\nstatic void\tnv_Replace(cmdarg_T *cap);\nstatic void\tnv_replace(cmdarg_T *cap);\nstatic void\tnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos);\nstatic void\tv_visop(cmdarg_T *cap);\nstatic void\tnv_subst(cmdarg_T *cap);\nstatic void\tnv_abbrev(cmdarg_T *cap);\nstatic void\tnv_optrans(cmdarg_T *cap);\nstatic void\tnv_gomark(cmdarg_T *cap);\nstatic void\tnv_pcmark(cmdarg_T *cap);\nstatic void\tnv_regname(cmdarg_T *cap);\nstatic void\tnv_visual(cmdarg_T *cap);\nstatic void\tn_start_visual_mode(int c);\nstatic void\tnv_window(cmdarg_T *cap);\nstatic void\tnv_suspend(cmdarg_T *cap);\nstatic void\tnv_g_cmd(cmdarg_T *cap);\nstatic void\tnv_dot(cmdarg_T *cap);\nstatic void\tnv_redo_or_register(cmdarg_T *cap);\nstatic void\tnv_Undo(cmdarg_T *cap);\nstatic void\tnv_tilde(cmdarg_T *cap);\nstatic void\tnv_operator(cmdarg_T *cap);\n#ifdef FEAT_EVAL\nstatic void\tset_op_var(int optype);\n#endif\nstatic void\tnv_lineop(cmdarg_T *cap);\nstatic void\tnv_home(cmdarg_T *cap);\nstatic void\tnv_pipe(cmdarg_T *cap);\nstatic void\tnv_bck_word(cmdarg_T *cap);\nstatic void\tnv_wordcmd(cmdarg_T *cap);\nstatic void\tnv_beginline(cmdarg_T *cap);\nstatic void\tadjust_cursor(oparg_T *oap);\nstatic void\tadjust_for_sel(cmdarg_T *cap);\nstatic void\tnv_select(cmdarg_T *cap);\nstatic void\tnv_goto(cmdarg_T *cap);\nstatic void\tnv_normal(cmdarg_T *cap);\nstatic void\tnv_esc(cmdarg_T *oap);\nstatic void\tnv_edit(cmdarg_T *cap);\nstatic void\tinvoke_edit(cmdarg_T *cap, int repl, int cmd, int startln);\nstatic void\tnv_object(cmdarg_T *cap);\nstatic void\tnv_record(cmdarg_T *cap);\nstatic void\tnv_at(cmdarg_T *cap);\nstatic void\tnv_halfpage(cmdarg_T *cap);\nstatic void\tnv_join(cmdarg_T *cap);\nstatic void\tnv_put(cmdarg_T *cap);\nstatic void\tnv_put_opt(cmdarg_T *cap, int fix_indent);\nstatic void\tnv_open(cmdarg_T *cap);\n#ifdef FEAT_NETBEANS_INTG\nstatic void\tnv_nbcmd(cmdarg_T *cap);\n#endif\n#ifdef FEAT_DND\nstatic void\tnv_drop(cmdarg_T *cap);\n#endif\nstatic void\tnv_cursorhold(cmdarg_T *cap);\n\n// Declare nv_cmds[].\n#define DO_DECLARE_NVCMD\n#include \"nv_cmds.h\"\n\n// Include the lookuptable generated by create_nvcmdidx.vim.\n#include \"nv_cmdidxs.h\"\n\n/*\n * Search for a command in the commands table.\n * Returns -1 for invalid command.\n */\n    static int\nfind_command(int cmdchar)\n{\n    int\t\ti;\n    int\t\tidx;\n    int\t\ttop, bot;\n    int\t\tc;\n\n    // A multi-byte character is never a command.\n    if (cmdchar >= 0x100)\n\treturn -1;\n\n    // We use the absolute value of the character.  Special keys have a\n    // negative value, but are sorted on their absolute value.\n    if (cmdchar < 0)\n\tcmdchar = -cmdchar;\n\n    // If the character is in the first part: The character is the index into\n    // nv_cmd_idx[].\n    if (cmdchar <= nv_max_linear)\n\treturn nv_cmd_idx[cmdchar];\n\n    // Perform a binary search.\n    bot = nv_max_linear + 1;\n    top = NV_CMDS_SIZE - 1;\n    idx = -1;\n    while (bot <= top)\n    {\n\ti = (top + bot) / 2;\n\tc = nv_cmds[nv_cmd_idx[i]].cmd_char;\n\tif (c < 0)\n\t    c = -c;\n\tif (cmdchar == c)\n\t{\n\t    idx = nv_cmd_idx[i];\n\t    break;\n\t}\n\tif (cmdchar > c)\n\t    bot = i + 1;\n\telse\n\t    top = i - 1;\n    }\n    return idx;\n}\n\n/*\n * If currently editing a cmdline or text is locked: beep and give an error\n * message, return TRUE.\n */\n    static int\ncheck_text_locked(oparg_T *oap)\n{\n    if (!text_locked())\n\treturn FALSE;\n\n    if (oap != NULL)\n\tclearopbeep(oap);\n    text_locked_msg();\n    return TRUE;\n}\n\n/*\n * If text is locked, \"curbuf_lock\" or \"allbuf_lock\" is set:\n * Give an error message, possibly beep and return TRUE.\n * \"oap\" may be NULL.\n */\n    int\ncheck_text_or_curbuf_locked(oparg_T *oap)\n{\n    if (check_text_locked(oap))\n\treturn TRUE;\n\n    if (!curbuf_locked())\n\treturn FALSE;\n\n    if (oap != NULL)\n\tclearop(oap);\n    return TRUE;\n}\n\n/*\n * Handle the count before a normal command and set cap->count0.\n */\n    static int\nnormal_cmd_get_count(\n\tcmdarg_T\t*cap,\n\tint\t\tc,\n\tint\t\ttoplevel UNUSED,\n\tint\t\tset_prevcount UNUSED,\n\tint\t\t*ctrl_w,\n\tint\t\t*need_flushbuf UNUSED)\n{\ngetcount:\n    if (!(VIsual_active && VIsual_select))\n    {\n\t// Handle a count before a command and compute ca.count0.\n\t// Note that '0' is a command and not the start of a count, but it's\n\t// part of a count after other digits.\n\twhile ((c >= '1' && c <= '9')\n\t\t|| (cap->count0 != 0 && (c == K_DEL || c == K_KDEL\n\t\t\t|| c == '0')))\n\t{\n\t    if (c == K_DEL || c == K_KDEL)\n\t    {\n\t\tcap->count0 /= 10;\n\t\tdel_from_showcmd(4);\t// delete the digit and ~@%\n\t    }\n\t    else if (cap->count0 > 99999999L)\n\t    {\n\t\tcap->count0 = 999999999L;\n\t    }\n\t    else\n\t    {\n\t\tcap->count0 = cap->count0 * 10 + (c - '0');\n\t    }\n#ifdef FEAT_EVAL\n\t    // Set v:count here, when called from main() and not a stuffed\n\t    // command, so that v:count can be used in an expression mapping\n\t    // right after the count. Do set it for redo.\n\t    if (toplevel && readbuf1_empty())\n\t\tset_vcount_ca(cap, &set_prevcount);\n#endif\n\t    if (*ctrl_w)\n\t    {\n\t\t++no_mapping;\n\t\t++allow_keys;\t\t// no mapping for nchar, but keys\n\t    }\n\t    ++no_zero_mapping;\t\t// don't map zero here\n\t    c = plain_vgetc();\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_zero_mapping;\n\t    if (*ctrl_w)\n\t    {\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t    }\n\t    *need_flushbuf |= add_to_showcmd(c);\n\t}\n\n\t// If we got CTRL-W there may be a/another count\n\tif (c == Ctrl_W && !*ctrl_w && cap->oap->op_type == OP_NOP)\n\t{\n\t    *ctrl_w = TRUE;\n\t    cap->opcount = cap->count0;\t// remember first count\n\t    cap->count0 = 0;\n\t    ++no_mapping;\n\t    ++allow_keys;\t\t// no mapping for nchar, but keys\n\t    c = plain_vgetc();\t\t// get next character\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_mapping;\n\t    --allow_keys;\n\t    *need_flushbuf |= add_to_showcmd(c);\n\t    goto getcount;\t\t// jump back\n\t}\n    }\n\n    if (c == K_CURSORHOLD)\n    {\n\t// Save the count values so that ca.opcount and ca.count0 are exactly\n\t// the same when coming back here after handling K_CURSORHOLD.\n\tcap->oap->prev_opcount = cap->opcount;\n\tcap->oap->prev_count0 = cap->count0;\n    }\n    else if (cap->opcount != 0)\n    {\n\t// If we're in the middle of an operator (including after entering a\n\t// yank buffer with '\"') AND we had a count before the operator, then\n\t// that count overrides the current value of ca.count0.\n\t// What this means effectively, is that commands like \"3dw\" get turned\n\t// into \"d3w\" which makes things fall into place pretty neatly.\n\t// If you give a count before AND after the operator, they are\n\t// multiplied.\n\tif (cap->count0)\n\t{\n\t    if (cap->opcount >= 999999999L / cap->count0)\n\t\tcap->count0 = 999999999L;\n\t    else\n\t\tcap->count0 *= cap->opcount;\n\t}\n\telse\n\t    cap->count0 = cap->opcount;\n    }\n\n    // Always remember the count.  It will be set to zero (on the next call,\n    // above) when there is no pending operator.\n    // When called from main(), save the count for use by the \"count\" built-in\n    // variable.\n    cap->opcount = cap->count0;\n    cap->count1 = (cap->count0 == 0 ? 1 : cap->count0);\n\n#ifdef FEAT_EVAL\n    // Only set v:count when called from main() and not a stuffed command.\n    // Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount(cap->count0, cap->count1, set_prevcount);\n#endif\n\n    return c;\n}\n\n/*\n * Returns TRUE if the normal command (cap) needs a second character.\n */\n    static int\nnormal_cmd_needs_more_chars(cmdarg_T *cap, short_u cmd_flags)\n{\n    return ((cmd_flags & NV_NCH)\n\t    && (((cmd_flags & NV_NCH_NOP) == NV_NCH_NOP\n\t\t    && cap->oap->op_type == OP_NOP)\n\t\t|| (cmd_flags & NV_NCH_ALW) == NV_NCH_ALW\n\t\t|| (cap->cmdchar == 'q'\n\t\t    && cap->oap->op_type == OP_NOP\n\t\t    && reg_recording == 0\n\t\t    && reg_executing == 0)\n\t\t|| ((cap->cmdchar == 'a' || cap->cmdchar == 'i')\n\t\t    && (cap->oap->op_type != OP_NOP || VIsual_active))));\n}\n\n/*\n * Get one or more additional characters for a normal command.\n * Return the updated command index (if changed).\n */\n    static int\nnormal_cmd_get_more_chars(\n\tint\t    idx_arg,\n\tcmdarg_T    *cap,\n\tint\t    *need_flushbuf UNUSED)\n{\n    int\t\tidx = idx_arg;\n    int\t\tc;\n    int\t\t*cp;\n    int\t\trepl = FALSE;\t// get character for replace mode\n    int\t\tlit = FALSE;\t// get extra character literally\n    int\t\tlangmap_active = FALSE;    // using :lmap mappings\n    int\t\tlang;\t\t// getting a text character\n#ifdef HAVE_INPUT_METHOD\n    int\t\tsave_smd;\t// saved value of p_smd\n#endif\n\n    ++no_mapping;\n    ++allow_keys;\t\t// no mapping for nchar, but allow key codes\n    // Don't generate a CursorHold event here, most commands can't handle\n    // it, e.g., nv_replace(), nv_csearch().\n    did_cursorhold = TRUE;\n    if (cap->cmdchar == 'g')\n    {\n\t/*\n\t * For 'g' get the next character now, so that we can check for\n\t * \"gr\", \"g'\" and \"g`\".\n\t */\n\tcap->nchar = plain_vgetc();\n\tLANGMAP_ADJUST(cap->nchar, TRUE);\n\t*need_flushbuf |= add_to_showcmd(cap->nchar);\n\tif (cap->nchar == 'r' || cap->nchar == '\\'' || cap->nchar == '`'\n\t\t|| cap->nchar == Ctrl_BSL)\n\t{\n\t    cp = &cap->extra_char;\t// need to get a third character\n\t    if (cap->nchar != 'r')\n\t\tlit = TRUE;\t\t\t// get it literally\n\t    else\n\t\trepl = TRUE;\t\t// get it in replace mode\n\t}\n\telse\n\t    cp = NULL;\t\t// no third character needed\n    }\n    else\n    {\n\tif (cap->cmdchar == 'r')\t\t// get it in replace mode\n\t    repl = TRUE;\n\tcp = &cap->nchar;\n    }\n    lang = (repl || (nv_cmds[idx].cmd_flags & NV_LANG));\n\n    /*\n     * Get a second or third character.\n     */\n    if (cp != NULL)\n    {\n\tif (repl)\n\t{\n\t    State = MODE_REPLACE;\t// pretend Replace mode\n#ifdef CURSOR_SHAPE\n\t    ui_cursor_shape();\t// show different cursor shape\n#endif\n\t}\n\tif (lang && curbuf->b_p_iminsert == B_IMODE_LMAP)\n\t{\n\t    // Allow mappings defined with \":lmap\".\n\t    --no_mapping;\n\t    --allow_keys;\n\t    if (repl)\n\t\tState = MODE_LREPLACE;\n\t    else\n\t\tState = MODE_LANGMAP;\n\t    langmap_active = TRUE;\n\t}\n#ifdef HAVE_INPUT_METHOD\n\tsave_smd = p_smd;\n\tp_smd = FALSE;\t// Don't let the IM code show the mode here\n\tif (lang && curbuf->b_p_iminsert == B_IMODE_IM)\n\t    im_set_active(TRUE);\n#endif\n\tif ((State & MODE_INSERT) && !p_ek)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\n\t    // Disable bracketed paste and modifyOtherKeys here, we won't\n\t    // recognize the escape sequences with 'esckeys' off.\n\t    out_str(T_BD);\n\t    out_str_t_TE();\n\t}\n\n\t*cp = plain_vgetc();\n\n\tif ((State & MODE_INSERT) && !p_ek)\n\t{\n\t    MAY_WANT_TO_LOG_THIS;\n\n\t    // Re-enable bracketed paste mode and modifyOtherKeys\n\t    out_str_t_BE();\n\t    out_str_t_TI();\n\t}\n\n\tif (langmap_active)\n\t{\n\t    // Undo the decrement done above\n\t    ++no_mapping;\n\t    ++allow_keys;\n\t    State = MODE_NORMAL_BUSY;\n\t}\n#ifdef HAVE_INPUT_METHOD\n\tif (lang)\n\t{\n\t    if (curbuf->b_p_iminsert != B_IMODE_LMAP)\n\t\tim_save_status(&curbuf->b_p_iminsert);\n\t    im_set_active(FALSE);\n\t}\n\tp_smd = save_smd;\n#endif\n\tState = MODE_NORMAL_BUSY;\n\t*need_flushbuf |= add_to_showcmd(*cp);\n\n\tif (!lit)\n\t{\n#ifdef FEAT_DIGRAPHS\n\t    // Typing CTRL-K gets a digraph.\n\t    if (*cp == Ctrl_K\n\t\t    && ((nv_cmds[idx].cmd_flags & NV_LANG)\n\t\t\t|| cp == &cap->extra_char)\n\t\t    && vim_strchr(p_cpo, CPO_DIGRAPH) == NULL)\n\t    {\n\t\tc = get_digraph(FALSE);\n\t\tif (c > 0)\n\t\t{\n\t\t    *cp = c;\n\t\t    // Guessing how to update showcmd here...\n\t\t    del_from_showcmd(3);\n\t\t    *need_flushbuf |= add_to_showcmd(*cp);\n\t\t}\n\t    }\n#endif\n\n\t    // adjust chars > 127, except after \"tTfFr\" commands\n\t    LANGMAP_ADJUST(*cp, !lang);\n#ifdef FEAT_RIGHTLEFT\n\t    // adjust Hebrew mapped char\n\t    if (p_hkmap && lang && KeyTyped)\n\t\t*cp = hkmap(*cp);\n#endif\n\t}\n\n\t// When the next character is CTRL-\\ a following CTRL-N means the\n\t// command is aborted and we go to Normal mode.\n\tif (cp == &cap->extra_char\n\t\t&& cap->nchar == Ctrl_BSL\n\t\t&& (cap->extra_char == Ctrl_N || cap->extra_char == Ctrl_G))\n\t{\n\t    cap->cmdchar = Ctrl_BSL;\n\t    cap->nchar = cap->extra_char;\n\t    idx = find_command(cap->cmdchar);\n\t}\n\telse if ((cap->nchar == 'n' || cap->nchar == 'N')\n\t\t\t\t\t\t\t&& cap->cmdchar == 'g')\n\t    cap->oap->op_type = get_op_type(*cp, NUL);\n\telse if (*cp == Ctrl_BSL)\n\t{\n\t    long towait = (p_ttm >= 0 ? p_ttm : p_tm);\n\n\t    // There is a busy wait here when typing \"f<C-\\>\" and then\n\t    // something different from CTRL-N.  Can't be avoided.\n\t    while ((c = vpeekc()) <= 0 && towait > 0L)\n\t    {\n\t\tdo_sleep(towait > 50L ? 50L : towait, FALSE);\n\t\ttowait -= 50L;\n\t    }\n\t    if (c > 0)\n\t    {\n\t\tc = plain_vgetc();\n\t\tif (c != Ctrl_N && c != Ctrl_G)\n\t\t    vungetc(c);\n\t\telse\n\t\t{\n\t\t    cap->cmdchar = Ctrl_BSL;\n\t\t    cap->nchar = c;\n\t\t    idx = find_command(cap->cmdchar);\n\t\t}\n\t    }\n\t}\n\n\tif (enc_utf8 && lang)\n\t{\n\t    // When getting a text character and the next character is a\n\t    // multi-byte character, it could be a composing character.\n\t    // However, don't wait for it to arrive. Also, do enable mapping,\n\t    // because if it's put back with vungetc() it's too late to apply\n\t    // mapping.\n\t    --no_mapping;\n\t    while ((c = vpeekc()) > 0\n\t\t    && (c >= 0x100 || MB_BYTE2LEN(vpeekc()) > 1))\n\t    {\n\t\tc = plain_vgetc();\n\t\tif (!utf_iscomposing(c))\n\t\t{\n\t\t    vungetc(c);\t\t// it wasn't, put it back\n\t\t    break;\n\t\t}\n\t\telse if (cap->ncharC1 == 0)\n\t\t    cap->ncharC1 = c;\n\t\telse\n\t\t    cap->ncharC2 = c;\n\t    }\n\t    ++no_mapping;\n\t    // Vim may be in a different mode when the user types the next key,\n\t    // but when replaying a recording the next key is already in the\n\t    // typeahead buffer, so record a <Nop> before that to prevent the\n\t    // vpeekc() above from applying wrong mappings when replaying.\n\t    ++no_u_sync;\n\t    gotchars_nop();\n\t    --no_u_sync;\n\t}\n    }\n    --no_mapping;\n    --allow_keys;\n\n    return idx;\n}\n\n/*\n * Returns TRUE if after processing a normal mode command, need to wait for a\n * moment when a message is displayed that will be overwritten by the mode\n * message.\n */\n    static int\nnormal_cmd_need_to_wait_for_msg(cmdarg_T *cap, pos_T *old_pos)\n{\n    // In Visual mode and with \"^O\" in Insert mode, a short message will be\n    // overwritten by the mode message.  Wait a bit, until a key is hit.\n    // In Visual mode, it's more important to keep the Visual area updated\n    // than keeping a message (e.g. from a /pat search).\n    // Only do this if the command was typed, not from a mapping.\n    // Don't wait when emsg_silent is non-zero.\n    // Also wait a bit after an error message, e.g. for \"^O:\".\n    // Don't redraw the screen, it would remove the message.\n    return (       ((p_smd\n\t\t    && msg_silent == 0\n\t\t    && (restart_edit != 0\n\t\t\t|| (VIsual_active\n\t\t\t    && old_pos->lnum == curwin->w_cursor.lnum\n\t\t\t    && old_pos->col == curwin->w_cursor.col)\n\t\t       )\n\t\t    && (clear_cmdline\n\t\t\t|| redraw_cmdline)\n\t\t    && (msg_didout || (msg_didany && msg_scroll))\n\t\t    && !msg_nowait\n\t\t    && KeyTyped)\n\t\t|| (restart_edit != 0\n\t\t    && !VIsual_active\n\t\t    && (msg_scroll\n\t\t\t|| emsg_on_display)))\n\t    && cap->oap->regname == 0\n\t    && !(cap->retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && typebuf_typed()\n\t    && emsg_silent == 0\n\t    && !in_assert_fails\n\t    && !did_wait_return\n\t    && cap->oap->op_type == OP_NOP);\n}\n\n/*\n * After processing a normal mode command, wait for a moment when a message is\n * displayed that will be overwritten by the mode message.\n */\n    static void\nnormal_cmd_wait_for_msg(void)\n{\n    int\tsave_State = State;\n\n    // Draw the cursor with the right shape here\n    if (restart_edit != 0)\n\tState = MODE_INSERT;\n\n    // If need to redraw, and there is a \"keep_msg\", redraw before the\n    // delay\n    if (must_redraw && keep_msg != NULL && !emsg_on_display)\n    {\n\tchar_u\t*kmsg;\n\n\tkmsg = keep_msg;\n\tkeep_msg = NULL;\n\t// Showmode() will clear keep_msg, but we want to use it anyway.\n\t// First update w_topline.\n\tsetcursor();\n\tupdate_screen(0);\n\t// now reset it, otherwise it's put in the history again\n\tkeep_msg = kmsg;\n\n\tkmsg = vim_strsave(keep_msg);\n\tif (kmsg != NULL)\n\t{\n\t    msg_attr((char *)kmsg, keep_msg_attr);\n\t    vim_free(kmsg);\n\t}\n    }\n    setcursor();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    cursor_on();\n    out_flush();\n    if (msg_scroll || emsg_on_display)\n\tui_delay(1003L, TRUE);\t// wait at least one second\n    ui_delay(3003L, FALSE);\t\t// wait up to three seconds\n    State = save_State;\n\n    msg_scroll = FALSE;\n    emsg_on_display = FALSE;\n}\n\n/*\n * Execute a command in Normal mode.\n */\n    void\nnormal_cmd(\n    oparg_T\t*oap,\n    int\t\ttoplevel UNUSED)\t// TRUE when called from main()\n{\n    cmdarg_T\tca;\t\t\t// command arguments\n    int\t\tc;\n    int\t\tctrl_w = FALSE;\t\t// got CTRL-W command\n    int\t\told_col = curwin->w_curswant;\n    int\t\tneed_flushbuf = FALSE;\t// need to call out_flush()\n    pos_T\told_pos;\t\t// cursor position before command\n    int\t\tmapped_len;\n    static int\told_mapped_len = 0;\n    int\t\tidx;\n    int\t\tset_prevcount = FALSE;\n    int\t\tsave_did_cursorhold = did_cursorhold;\n\n    CLEAR_FIELD(ca);\t// also resets ca.retval\n    ca.oap = oap;\n\n    // Use a count remembered from before entering an operator.  After typing\n    // \"3d\" we return from normal_cmd() and come back here, the \"3\" is\n    // remembered in \"opcount\".\n    ca.opcount = opcount;\n\n    // If there is an operator pending, then the command we take this time\n    // will terminate it. Finish_op tells us to finish the operation before\n    // returning this time (unless the operation was cancelled).\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = (oap->op_type != OP_NOP);\n#ifdef CURSOR_SHAPE\n    if (finish_op != c)\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n    may_trigger_modechanged();\n\n    // When not finishing an operator and no register name typed, reset the\n    // count.\n    if (!finish_op && !oap->regname)\n    {\n\tca.opcount = 0;\n#ifdef FEAT_EVAL\n\tset_prevcount = TRUE;\n#endif\n    }\n\n    // Restore counts from before receiving K_CURSORHOLD.  This means after\n    // typing \"3\", handling K_CURSORHOLD and then typing \"2\" we get \"32\", not\n    // \"3 * 2\".\n    if (oap->prev_opcount > 0 || oap->prev_count0 > 0)\n    {\n\tca.opcount = oap->prev_opcount;\n\tca.count0 = oap->prev_count0;\n\toap->prev_opcount = 0;\n\toap->prev_count0 = 0;\n    }\n\n    mapped_len = typebuf_maplen();\n\n    State = MODE_NORMAL_BUSY;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = FALSE;\t// allow scrolling here\n#endif\n\n#ifdef FEAT_EVAL\n    // Set v:count here, when called from main() and not a stuffed\n    // command, so that v:count can be used in an expression mapping\n    // when there is no count. Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount_ca(&ca, &set_prevcount);\n#endif\n\n    /*\n     * Get the command character from the user.\n     */\n    c = safe_vgetc();\n    LANGMAP_ADJUST(c, get_real_state() != MODE_SELECT);\n\n    // If a mapping was started in Visual or Select mode, remember the length\n    // of the mapping.  This is used below to not return to Insert mode for as\n    // long as the mapping is being executed.\n    if (restart_edit == 0)\n\told_mapped_len = 0;\n    else if (old_mapped_len\n\t\t|| (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0))\n\told_mapped_len = typebuf_maplen();\n\n    if (c == NUL)\n\tc = K_ZERO;\n\n    // In Select mode, typed text replaces the selection.\n    if (VIsual_active\n\t    && VIsual_select\n\t    && (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER))\n    {\n\tint len;\n\n\t// Fake a \"c\"hange command.  When \"restart_edit\" is set (e.g., because\n\t// 'insertmode' is set) fake a \"d\"elete command, Insert mode will\n\t// restart automatically.\n\t// Insert the typed character in the typeahead buffer, so that it can\n\t// be mapped in Insert mode.  Required for \":lmap\" to work.\n\tlen = ins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\n\t// When recording and gotchars() was called the character will be\n\t// recorded again, remove the previous recording.\n\tif (KeyTyped)\n\t    ungetchars(len);\n\n\tif (restart_edit != 0)\n\t    c = 'd';\n\telse\n\t    c = 'c';\n\tmsg_nowait = TRUE;\t// don't delay going to insert mode\n\told_mapped_len = 0;\t// do go to Insert mode\n    }\n\n    // If the window was made so small that nothing shows, make it at least one\n    // line and one column when typing a command.\n    if (KeyTyped && !KeyStuffed)\n\twin_ensure_size();\n\n    need_flushbuf = add_to_showcmd(c);\n\n    // Get the command count\n    c = normal_cmd_get_count(&ca, c, toplevel, set_prevcount, &ctrl_w,\n\t\t\t\t\t\t\t&need_flushbuf);\n\n    // Find the command character in the table of commands.\n    // For CTRL-W we already got nchar when looking for a count.\n    if (ctrl_w)\n    {\n\tca.nchar = c;\n\tca.cmdchar = Ctrl_W;\n    }\n    else\n\tca.cmdchar = c;\n    idx = find_command(ca.cmdchar);\n    if (idx < 0)\n    {\n\t// Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if ((nv_cmds[idx].cmd_flags & NV_NCW) && check_text_or_curbuf_locked(oap))\n\t// this command is not allowed now\n\tgoto normal_end;\n\n    // In Visual/Select mode, a few keys are handled in a special way.\n    if (VIsual_active)\n    {\n\t// when 'keymodel' contains \"stopsel\" may stop Select/Visual mode\n\tif (km_stopsel\n\t\t&& (nv_cmds[idx].cmd_flags & NV_STS)\n\t\t&& !(mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    end_visual_mode();\n\t    redraw_curbuf_later(UPD_INVERTED);\n\t}\n\n\t// Keys that work different when 'keymodel' contains \"startsel\"\n\tif (km_startsel)\n\t{\n\t    if (nv_cmds[idx].cmd_flags & NV_SS)\n\t    {\n\t\tunshift_special(&ca);\n\t\tidx = find_command(ca.cmdchar);\n\t\tif (idx < 0)\n\t\t{\n\t\t    // Just in case\n\t\t    clearopbeep(oap);\n\t\t    goto normal_end;\n\t\t}\n\t    }\n\t    else if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t       && (mod_mask & MOD_MASK_SHIFT))\n\t\tmod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && KeyTyped && !KeyStuffed\n\t\t\t\t\t  && (nv_cmds[idx].cmd_flags & NV_RL))\n    {\n\t// Invert horizontal movements and operations.  Only when typed by the\n\t// user directly, not when the result of a mapping or \"x\" translated\n\t// to \"dl\".\n\tswitch (ca.cmdchar)\n\t{\n\t    case 'l':\t    ca.cmdchar = 'h'; break;\n\t    case K_RIGHT:   ca.cmdchar = K_LEFT; break;\n\t    case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break;\n\t    case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break;\n\t    case 'h':\t    ca.cmdchar = 'l'; break;\n\t    case K_LEFT:    ca.cmdchar = K_RIGHT; break;\n\t    case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break;\n\t    case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break;\n\t    case '>':\t    ca.cmdchar = '<'; break;\n\t    case '<':\t    ca.cmdchar = '>'; break;\n\t}\n\tidx = find_command(ca.cmdchar);\n    }\n#endif\n\n    // Get additional characters if we need them.\n    if (normal_cmd_needs_more_chars(&ca, nv_cmds[idx].cmd_flags))\n\tidx = normal_cmd_get_more_chars(idx, &ca, &need_flushbuf);\n\n    // Flush the showcmd characters onto the screen so we can see them while\n    // the command is being executed.  Only do this when the shown command was\n    // actually displayed, otherwise this will slow down a lot when executing\n    // mappings.\n    if (need_flushbuf)\n\tout_flush();\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tif (ex_normal_busy)\n\t    did_cursorhold = save_did_cursorhold;\n\telse\n\t    did_cursorhold = FALSE;\n    }\n\n    State = MODE_NORMAL;\n\n    if (ca.nchar == ESC || ca.extra_char == ESC)\n    {\n\tclearop(oap);\n\tif (restart_edit == 0 && goto_im())\n\t    restart_edit = 'a';\n\tgoto normal_end;\n    }\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tmsg_didout = FALSE;    // don't scroll screen up for normal command\n\tmsg_col = 0;\n    }\n\n    old_pos = curwin->w_cursor;\t\t// remember where the cursor was\n\n    // When 'keymodel' contains \"startsel\" some keys start Select/Visual\n    // mode.\n    if (!VIsual_active && km_startsel)\n    {\n\tif (nv_cmds[idx].cmd_flags & NV_SS)\n\t{\n\t    start_selection();\n\t    unshift_special(&ca);\n\t    idx = find_command(ca.cmdchar);\n\t}\n\telse if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t   && (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    start_selection();\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    // Execute the command!\n    // Call the command function found in the commands table.\n    ca.arg = nv_cmds[idx].cmd_arg;\n    (nv_cmds[idx].cmd_func)(&ca);\n\n    // If we didn't start or finish an operator, reset oap->regname, unless we\n    // need it later.\n    if (!finish_op\n\t    && !oap->op_type\n\t    && (idx < 0 || !(nv_cmds[idx].cmd_flags & NV_KEEPREG)))\n    {\n\tclearop(oap);\n#ifdef FEAT_EVAL\n\treset_reg_var();\n#endif\n    }\n\n    // Get the length of mapped chars again after typing a count, second\n    // character or \"z333<cr>\".\n    if (old_mapped_len > 0)\n\told_mapped_len = typebuf_maplen();\n\n    // If an operation is pending, handle it.  But not for K_IGNORE or\n    // K_MOUSEMOVE.\n    if (ca.cmdchar != K_IGNORE && ca.cmdchar != K_MOUSEMOVE)\n\tdo_pending_operator(&ca, old_col, FALSE);\n\n    // Wait for a moment when a message is displayed that will be overwritten\n    // by the mode message.\n    if (normal_cmd_need_to_wait_for_msg(&ca, &old_pos))\n\tnormal_cmd_wait_for_msg();\n\n    // Finish up after executing a Normal mode command.\nnormal_end:\n\n    msg_nowait = FALSE;\n\n#ifdef FEAT_EVAL\n    if (finish_op)\n\treset_reg_var();\n#endif\n\n#ifdef CURSOR_SHAPE\n    int prev_finish_op = finish_op;\n#endif\n    if (oap->op_type == OP_NOP)\n    {\n\t// Reset finish_op, in case it was set\n\tfinish_op = FALSE;\n\tmay_trigger_modechanged();\n    }\n#ifdef CURSOR_SHAPE\n    // Redraw the cursor with another shape, if we were in Operator-pending\n    // mode or did a replace command.\n    if (prev_finish_op || ca.cmdchar == 'r'\n\t\t\t\t     || (ca.cmdchar == 'g' && ca.nchar == 'r'))\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n\n    if (oap->op_type == OP_NOP && oap->regname == 0\n\t\t\t\t\t\t && ca.cmdchar != K_CURSORHOLD)\n\tclear_showcmd();\n\n    checkpcmark();\t\t// check if we moved since setting pcmark\n    vim_free(ca.searchbuf);\n\n    if (has_mbyte)\n\tmb_adjust_cursor();\n\n    if (curwin->w_p_scb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_scrollbind(TRUE);\n    }\n\n    if (curwin->w_p_crb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_cursorbind();\n    }\n\n#ifdef FEAT_TERMINAL\n    // don't go to Insert mode if a terminal has a running job\n    if (term_job_running(curbuf->b_term))\n\trestart_edit = 0;\n#endif\n\n    // May restart edit(), if we got here with CTRL-O in Insert mode (but not\n    // if still inside a mapping that started in Visual mode).\n    // May switch from Visual to Select mode after CTRL-O command.\n    if (       oap->op_type == OP_NOP\n\t    && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t\t|| restart_VIsual_select == 1)\n\t    && !(ca.retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && oap->regname == 0)\n    {\n\tif (restart_VIsual_select == 1)\n\t{\n\t    VIsual_select = TRUE;\n\t    may_trigger_modechanged();\n\t    showmode();\n\t    restart_VIsual_select = 0;\n\t    VIsual_select_reg = 0;\n\t}\n\tif (restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t    (void)edit(restart_edit, FALSE, 1L);\n    }\n\n    if (restart_VIsual_select == 2)\n\trestart_VIsual_select = 1;\n\n    // Save count before an operator for next time.\n    opcount = ca.opcount;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:count and v:count1 according to \"cap\".\n * Set v:prevcount only when \"set_prevcount\" is TRUE.\n */\n    static void\nset_vcount_ca(cmdarg_T *cap, int *set_prevcount)\n{\n    long count = cap->count0;\n\n    // multiply with cap->opcount the same way as above\n    if (cap->opcount != 0)\n\tcount = cap->opcount * (count == 0 ? 1 : count);\n    set_vcount(count, count == 0 ? 1 : count, *set_prevcount);\n    *set_prevcount = FALSE;  // only set v:prevcount once\n}\n#endif\n\n/*\n * Check if highlighting for Visual mode is possible, give a warning message\n * if not.\n */\n    void\ncheck_visual_highlight(void)\n{\n    static int\t    did_check = FALSE;\n\n    if (full_screen)\n    {\n\tif (!did_check && HL_ATTR(HLF_V) == 0)\n\t    msg(_(\"Warning: terminal cannot highlight\"));\n\tdid_check = TRUE;\n    }\n}\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_EVAL)\n/*\n * Call yank_do_autocmd() for \"regname\".\n */\n    static void\ncall_yank_do_autocmd(int regname)\n{\n    oparg_T\toa;\n    yankreg_T\t*reg;\n\n    clear_oparg(&oa);\n    oa.regname = regname;\n    oa.op_type = OP_YANK;\n    oa.is_VIsual = TRUE;\n    reg = get_register(regname, TRUE);\n    yank_do_autocmd(&oa, reg);\n    free_register(reg);\n}\n#endif\n\n/*\n * End Visual mode.\n * This function or the next should ALWAYS be called to end Visual mode, except\n * from do_pending_operator().\n */\n    void\nend_visual_mode(void)\n{\n    end_visual_mode_keep_button();\n    reset_held_button();\n}\n\n    void\nend_visual_mode_keep_button(void)\n{\n#ifdef FEAT_CLIPBOARD\n    // If we are using the clipboard, then remember what was selected in case\n    // we need to paste it somewhere while we still own the selection.\n    // Only do this when the clipboard is already owned.  Don't want to grab\n    // the selection when hitting ESC.\n    if (clip_star.available && clip_star.owned)\n\tclip_auto_select();\n\n# if defined(FEAT_EVAL)\n    // Emit a TextYankPost for the automatic copy of the selection into the\n    // star and/or plus register.\n    if (has_textyankpost())\n    {\n\tif (clip_isautosel_star())\n\t    call_yank_do_autocmd('*');\n\tif (clip_isautosel_plus())\n\t    call_yank_do_autocmd('+');\n    }\n# endif\n#endif\n\n    VIsual_active = FALSE;\n    setmouse();\n    mouse_dragging = 0;\n\n    // Save the current VIsual area for '< and '> marks, and \"gv\"\n    curbuf->b_visual.vi_mode = VIsual_mode;\n    curbuf->b_visual.vi_start = VIsual;\n    curbuf->b_visual.vi_end = curwin->w_cursor;\n    curbuf->b_visual.vi_curswant = curwin->w_curswant;\n#ifdef FEAT_EVAL\n    curbuf->b_visual_mode_eval = VIsual_mode;\n#endif\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    may_clear_cmdline();\n\n    adjust_cursor_eol();\n    may_trigger_modechanged();\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect.\n */\n    void\nreset_VIsual_and_resel(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(UPD_INVERTED);\t// delete the inversion later\n    }\n    VIsual_reselect = FALSE;\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect if it's set.\n */\n    void\nreset_VIsual(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(UPD_INVERTED);\t// delete the inversion later\n\tVIsual_reselect = FALSE;\n    }\n}\n\n    void\nrestore_visual_mode(void)\n{\n    if (VIsual_mode_orig != NUL)\n    {\n\tcurbuf->b_visual.vi_mode = VIsual_mode_orig;\n\tVIsual_mode_orig = NUL;\n    }\n}\n\n/*\n * Check for a balloon-eval special item to include when searching for an\n * identifier.  When \"dir\" is BACKWARD \"ptr[-1]\" must be valid!\n * Returns TRUE if the character at \"*ptr\" should be included.\n * \"dir\" is FORWARD or BACKWARD, the direction of searching.\n * \"*colp\" is in/decremented if \"ptr[-dir]\" should also be included.\n * \"bnp\" points to a counter for square brackets.\n */\n    static int\nfind_is_eval_item(\n    char_u\t*ptr,\n    int\t\t*colp,\n    int\t\t*bnp,\n    int\t\tdir)\n{\n    // Accept everything inside [].\n    if ((*ptr == ']' && dir == BACKWARD) || (*ptr == '[' && dir == FORWARD))\n\t++*bnp;\n    if (*bnp > 0)\n    {\n\tif ((*ptr == '[' && dir == BACKWARD) || (*ptr == ']' && dir == FORWARD))\n\t    --*bnp;\n\treturn TRUE;\n    }\n\n    // skip over \"s.var\"\n    if (*ptr == '.')\n\treturn TRUE;\n\n    // two-character item: s->var\n    if (ptr[dir == BACKWARD ? 0 : 1] == '>'\n\t    && ptr[dir == BACKWARD ? -1 : 0] == '-')\n    {\n\t*colp += dir;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Find the identifier under or to the right of the cursor.\n * \"find_type\" can have one of three values:\n * FIND_IDENT:   find an identifier (keyword)\n * FIND_STRING:  find any non-white text\n * FIND_IDENT + FIND_STRING: find any non-white text, identifier preferred.\n * FIND_EVAL:\t find text useful for C program debugging\n *\n * There are three steps:\n * 1. Search forward for the start of an identifier/text.  Doesn't move if\n *    already on one.\n * 2. Search backward for the start of this identifier/text.\n *    This doesn't match the real Vi but I like it a little better and it\n *    shouldn't bother anyone.\n * 3. Search forward to the end of this identifier/text.\n *    When FIND_IDENT isn't defined, we backup until a blank.\n *\n * Returns the length of the text, or zero if no text is found.\n * If text is found, a pointer to the text is put in \"*text\".  This\n * points into the current buffer line and is not always NUL terminated.\n */\n    int\nfind_ident_under_cursor(char_u **text, int find_type)\n{\n    return find_ident_at_pos(curwin, curwin->w_cursor.lnum,\n\t\t\t\tcurwin->w_cursor.col, text, NULL, find_type);\n}\n\n/*\n * Like find_ident_under_cursor(), but for any window and any position.\n * However: Uses 'iskeyword' from the current window!.\n */\n    int\nfind_ident_at_pos(\n    win_T\t*wp,\n    linenr_T\tlnum,\n    colnr_T\tstartcol,\n    char_u\t**text,\n    int\t\t*textcol,\t// column where \"text\" starts, can be NULL\n    int\t\tfind_type)\n{\n    char_u\t*ptr;\n    int\t\tcol = 0;\t// init to shut up GCC\n    int\t\ti;\n    int\t\tthis_class = 0;\n    int\t\tprev_class;\n    int\t\tprevcol;\n    int\t\tbn = 0;\t\t// bracket nesting\n\n    // if i == 0: try to find an identifier\n    // if i == 1: try to find any non-white text\n    ptr = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    for (i = (find_type & FIND_IDENT) ? 0 : 1;\ti < 2; ++i)\n    {\n\t/*\n\t * 1. skip to start of identifier/text\n\t */\n\tcol = startcol;\n\tif (has_mbyte)\n\t{\n\t    while (ptr[col] != NUL)\n\t    {\n\t\t// Stop at a ']' to evaluate \"a[x]\".\n\t\tif ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\t    break;\n\t\tthis_class = mb_get_class(ptr + col);\n\t\tif (this_class != 0 && (i == 1 || this_class != 1))\n\t\t    break;\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    }\n\t}\n\telse\n\t    while (ptr[col] != NUL\n\t\t    && (i == 0 ? !vim_iswordc(ptr[col]) : VIM_ISWHITE(ptr[col]))\n\t\t    && (!(find_type & FIND_EVAL) || ptr[col] != ']')\n\t\t    )\n\t\t++col;\n\n\t// When starting on a ']' count it, so that we include the '['.\n\tbn = ptr[col] == ']';\n\n\t/*\n\t * 2. Back up to start of identifier/text.\n\t */\n\tif (has_mbyte)\n\t{\n\t    // Remember class of character under cursor.\n\t    if ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\tthis_class = mb_get_class((char_u *)\"a\");\n\t    else\n\t\tthis_class = mb_get_class(ptr + col);\n\t    while (col > 0 && this_class != 0)\n\t    {\n\t\tprevcol = col - 1 - (*mb_head_off)(ptr, ptr + col - 1);\n\t\tprev_class = mb_get_class(ptr + prevcol);\n\t\tif (this_class != prev_class\n\t\t\t&& (i == 0\n\t\t\t    || prev_class == 0\n\t\t\t    || (find_type & FIND_IDENT))\n\t\t\t&& (!(find_type & FIND_EVAL)\n\t\t\t    || prevcol == 0\n\t\t\t    || !find_is_eval_item(ptr + prevcol, &prevcol,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t)\n\t\t    break;\n\t\tcol = prevcol;\n\t    }\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (this_class > 2)\n\t\tthis_class = 2;\n\t    if (!(find_type & FIND_STRING) || this_class == 2)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    while (col > 0\n\t\t    && ((i == 0\n\t\t\t    ? vim_iswordc(ptr[col - 1])\n\t\t\t    : (!VIM_ISWHITE(ptr[col - 1])\n\t\t\t\t&& (!(find_type & FIND_IDENT)\n\t\t\t\t    || !vim_iswordc(ptr[col - 1]))))\n\t\t\t|| ((find_type & FIND_EVAL)\n\t\t\t    && col > 1\n\t\t\t    && find_is_eval_item(ptr + col - 1, &col,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t))\n\t\t--col;\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (!(find_type & FIND_STRING) || vim_iswordc(ptr[col]))\n\t\tbreak;\n\t}\n    }\n\n    if (ptr[col] == NUL || (i == 0\n\t\t&& (has_mbyte ? this_class != 2 : !vim_iswordc(ptr[col]))))\n    {\n\t// didn't find an identifier or text\n\tif ((find_type & FIND_NOERROR) == 0)\n\t{\n\t    if (find_type & FIND_STRING)\n\t\temsg(_(e_no_string_under_cursor));\n\t    else\n\t\temsg(_(e_no_identifier_under_cursor));\n\t}\n\treturn 0;\n    }\n    ptr += col;\n    *text = ptr;\n    if (textcol != NULL)\n\t*textcol = col;\n\n    /*\n     * 3. Find the end if the identifier/text.\n     */\n    bn = 0;\n    startcol -= col;\n    col = 0;\n    if (has_mbyte)\n    {\n\t// Search for point of changing multibyte character class.\n\tthis_class = mb_get_class(ptr);\n\twhile (ptr[col] != NUL\n\t\t&& ((i == 0 ? mb_get_class(ptr + col) == this_class\n\t\t\t    : mb_get_class(ptr + col) != 0)\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t))\n\t    col += (*mb_ptr2len)(ptr + col);\n    }\n    else\n\twhile ((i == 0 ? vim_iswordc(ptr[col])\n\t\t       : (ptr[col] != NUL && !VIM_ISWHITE(ptr[col])))\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t)\n\t    ++col;\n\n    return col;\n}\n\n/*\n * Prepare for redo of a normal command.\n */\n    static void\nprep_redo_cmd(cmdarg_T *cap)\n{\n    prep_redo(cap->oap->regname, cap->count0,\n\t\t\t\t     NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n}\n\n/*\n * Prepare for redo of any command.\n * Note that only the last argument can be a multi-byte char.\n */\n    void\nprep_redo(\n    int\t    regname,\n    long    num,\n    int\t    cmd1,\n    int\t    cmd2,\n    int\t    cmd3,\n    int\t    cmd4,\n    int\t    cmd5)\n{\n    prep_redo_num2(regname, num, cmd1, cmd2, 0L, cmd3, cmd4, cmd5);\n}\n\n/*\n * Prepare for redo of any command with extra count after \"cmd2\".\n */\n    void\nprep_redo_num2(\n    int\t    regname,\n    long    num1,\n    int\t    cmd1,\n    int\t    cmd2,\n    long    num2,\n    int\t    cmd3,\n    int\t    cmd4,\n    int\t    cmd5)\n{\n    ResetRedobuff();\n\n#ifdef FEAT_EVAL\n    // Put info about a mapping in the redo buffer, so that \".\" will use the\n    // same script context.\n    may_add_last_used_map_to_redobuff();\n#endif\n\n    if (regname != 0)\t// yank from specified buffer\n    {\n\tAppendCharToRedobuff('\"');\n\tAppendCharToRedobuff(regname);\n    }\n    if (num1 != 0)\n\tAppendNumberToRedobuff(num1);\n    if (cmd1 != NUL)\n\tAppendCharToRedobuff(cmd1);\n    if (cmd2 != NUL)\n\tAppendCharToRedobuff(cmd2);\n    if (num2 != 0)\n\tAppendNumberToRedobuff(num2);\n    if (cmd3 != NUL)\n\tAppendCharToRedobuff(cmd3);\n    if (cmd4 != NUL)\n\tAppendCharToRedobuff(cmd4);\n    if (cmd5 != NUL)\n\tAppendCharToRedobuff(cmd5);\n}\n\n/*\n * Check for operator active and clear it.\n *\n * Beep and return TRUE if an operator was active.\n */\n    static int\ncheckclearop(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n/*\n * Check for operator or Visual active.  Clear active operator.\n *\n * Beep and return TRUE if an operator or Visual was active.\n */\n    static int\ncheckclearopq(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP && !VIsual_active)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n    void\nclearop(oparg_T *oap)\n{\n    oap->op_type = OP_NOP;\n    oap->regname = 0;\n    oap->motion_force = NUL;\n    oap->use_reg_one = FALSE;\n    motion_force = NUL;\n}\n\n    void\nclearopbeep(oparg_T *oap)\n{\n    clearop(oap);\n    beep_flush();\n}\n\n/*\n * Remove the shift modifier from a special key.\n */\n    static void\nunshift_special(cmdarg_T *cap)\n{\n    switch (cap->cmdchar)\n    {\n\tcase K_S_RIGHT:\tcap->cmdchar = K_RIGHT; break;\n\tcase K_S_LEFT:\tcap->cmdchar = K_LEFT; break;\n\tcase K_S_UP:\tcap->cmdchar = K_UP; break;\n\tcase K_S_DOWN:\tcap->cmdchar = K_DOWN; break;\n\tcase K_S_HOME:\tcap->cmdchar = K_HOME; break;\n\tcase K_S_END:\tcap->cmdchar = K_END; break;\n    }\n    cap->cmdchar = simplify_key(cap->cmdchar, &mod_mask);\n}\n\n/*\n * If the mode is currently displayed clear the command line or update the\n * command displayed.\n */\n    void\nmay_clear_cmdline(void)\n{\n    if (mode_displayed)\n\tclear_cmdline = TRUE;   // unshow visual mode later\n    else\n\tclear_showcmd();\n}\n\n/*\n * Routines for displaying a partly typed command\n */\n\nstatic char_u\told_showcmd_buf[SHOWCMD_BUFLEN];  // For push_showcmd()\nstatic int\tshowcmd_is_clear = TRUE;\nstatic int\tshowcmd_visual = FALSE;\n\nstatic void display_showcmd(void);\n\n    void\nclear_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    if (VIsual_active && !char_avail())\n    {\n\tint\t\tcursor_bot = LT_POS(VIsual, curwin->w_cursor);\n\tlong\t\tlines;\n\tcolnr_T\t\tleftcol, rightcol;\n\tlinenr_T\ttop, bot;\n\n\t// Show the size of the Visual area.\n\tif (cursor_bot)\n\t{\n\t    top = VIsual.lnum;\n\t    bot = curwin->w_cursor.lnum;\n\t}\n\telse\n\t{\n\t    top = curwin->w_cursor.lnum;\n\t    bot = VIsual.lnum;\n\t}\n# ifdef FEAT_FOLDING\n\t// Include closed folds as a whole.\n\t(void)hasFolding(top, &top, NULL);\n\t(void)hasFolding(bot, NULL, &bot);\n# endif\n\tlines = bot - top + 1;\n\n\tif (VIsual_mode == Ctrl_V)\n\t{\n# ifdef FEAT_LINEBREAK\n\t    char_u *saved_sbr = p_sbr;\n\t    char_u *saved_w_sbr = curwin->w_p_sbr;\n\n\t    // Make 'sbr' empty for a moment to get the correct size.\n\t    p_sbr = empty_option;\n\t    curwin->w_p_sbr = empty_option;\n# endif\n\t    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);\n# ifdef FEAT_LINEBREAK\n\t    p_sbr = saved_sbr;\n\t    curwin->w_p_sbr = saved_w_sbr;\n# endif\n\t    sprintf((char *)showcmd_buf, \"%ldx%ld\", lines,\n\t\t\t\t\t      (long)(rightcol - leftcol + 1));\n\t}\n\telse if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)\n\t    sprintf((char *)showcmd_buf, \"%ld\", lines);\n\telse\n\t{\n\t    char_u  *s, *e;\n\t    int\t    l;\n\t    int\t    bytes = 0;\n\t    int\t    chars = 0;\n\n\t    if (cursor_bot)\n\t    {\n\t\ts = ml_get_pos(&VIsual);\n\t\te = ml_get_cursor();\n\t    }\n\t    else\n\t    {\n\t\ts = ml_get_cursor();\n\t\te = ml_get_pos(&VIsual);\n\t    }\n\t    while ((*p_sel != 'e') ? s <= e : s < e)\n\t    {\n\t\tl = (*mb_ptr2len)(s);\n\t\tif (l == 0)\n\t\t{\n\t\t    ++bytes;\n\t\t    ++chars;\n\t\t    break;  // end of line\n\t\t}\n\t\tbytes += l;\n\t\t++chars;\n\t\ts += l;\n\t    }\n\t    if (bytes == chars)\n\t\tsprintf((char *)showcmd_buf, \"%d\", chars);\n\t    else\n\t\tsprintf((char *)showcmd_buf, \"%d-%d\", chars, bytes);\n\t}\n\tshowcmd_buf[SHOWCMD_COLS] = NUL;\t// truncate\n\tshowcmd_visual = TRUE;\n    }\n    else\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n\n\t// Don't actually display something if there is nothing to clear.\n\tif (showcmd_is_clear)\n\t    return;\n    }\n\n    display_showcmd();\n}\n\n/*\n * Add 'c' to string of shown command chars.\n * Return TRUE if output has been written (and setcursor() has been called).\n */\n    int\nadd_to_showcmd(int c)\n{\n    char_u\t*p;\n    int\t\told_len;\n    int\t\textra_len;\n    int\t\toverflow;\n    int\t\ti;\n    static int\tignore[] =\n    {\n#ifdef FEAT_GUI\n\tK_VER_SCROLLBAR, K_HOR_SCROLLBAR,\n\tK_LEFTMOUSE_NM, K_LEFTRELEASE_NM,\n#endif\n\tK_IGNORE, K_PS,\n\tK_LEFTMOUSE, K_LEFTDRAG, K_LEFTRELEASE, K_MOUSEMOVE,\n\tK_MIDDLEMOUSE, K_MIDDLEDRAG, K_MIDDLERELEASE,\n\tK_RIGHTMOUSE, K_RIGHTDRAG, K_RIGHTRELEASE,\n\tK_MOUSEDOWN, K_MOUSEUP, K_MOUSELEFT, K_MOUSERIGHT,\n\tK_X1MOUSE, K_X1DRAG, K_X1RELEASE, K_X2MOUSE, K_X2DRAG, K_X2RELEASE,\n\tK_CURSORHOLD,\n\t0\n    };\n\n    if (!p_sc || msg_silent != 0)\n\treturn FALSE;\n\n    if (showcmd_visual)\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n    }\n\n    // Ignore keys that are scrollbar updates and mouse clicks\n    if (IS_SPECIAL(c))\n\tfor (i = 0; ignore[i] != 0; ++i)\n\t    if (ignore[i] == c)\n\t\treturn FALSE;\n\n    p = transchar(c);\n    if (*p == ' ')\n\tSTRCPY(p, \"<20>\");\n    old_len = (int)STRLEN(showcmd_buf);\n    extra_len = (int)STRLEN(p);\n    overflow = old_len + extra_len - SHOWCMD_COLS;\n    if (overflow > 0)\n\tmch_memmove(showcmd_buf, showcmd_buf + overflow,\n\t\t\t\t\t\t      old_len - overflow + 1);\n    STRCAT(showcmd_buf, p);\n\n    if (char_avail())\n\treturn FALSE;\n\n    display_showcmd();\n\n    return TRUE;\n}\n\n    void\nadd_to_showcmd_c(int c)\n{\n    if (!add_to_showcmd(c))\n\tsetcursor();\n}\n\n/*\n * Delete 'len' characters from the end of the shown command.\n */\n    static void\ndel_from_showcmd(int len)\n{\n    int\t    old_len;\n\n    if (!p_sc)\n\treturn;\n\n    old_len = (int)STRLEN(showcmd_buf);\n    if (len > old_len)\n\tlen = old_len;\n    showcmd_buf[old_len - len] = NUL;\n\n    if (!char_avail())\n\tdisplay_showcmd();\n}\n\n/*\n * push_showcmd() and pop_showcmd() are used when waiting for the user to type\n * something and there is a partial mapping.\n */\n    void\npush_showcmd(void)\n{\n    if (p_sc)\n\tSTRCPY(old_showcmd_buf, showcmd_buf);\n}\n\n    void\npop_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    STRCPY(showcmd_buf, old_showcmd_buf);\n\n    display_showcmd();\n}\n\n    static void\ndisplay_showcmd(void)\n{\n    int\t    len = (int)STRLEN(showcmd_buf);\n\n    showcmd_is_clear = (len == 0);\n    cursor_off();\n\n    if (*p_sloc == 's')\n    {\n\tif (showcmd_is_clear)\n\t    curwin->w_redr_status = TRUE;\n\telse\n\t    win_redr_status(curwin, FALSE);\n    }\n    else if (*p_sloc == 't')\n    {\n\tif (showcmd_is_clear)\n\t    redraw_tabline = TRUE;\n\telse\n\t    draw_tabline();\n    }\n    else // 'showcmdloc' is \"last\" or empty\n    {\n\tif (!showcmd_is_clear)\n\t    screen_puts(showcmd_buf, (int)Rows - 1, sc_col, 0);\n\n\t// clear the rest of an old message by outputting up to SHOWCMD_COLS\n\t// spaces\n\tscreen_puts((char_u *)\"          \" + len,\n\t\t\t\t\t\t(int)Rows - 1, sc_col + len, 0);\n    }\n\n    setcursor();\t    // put cursor back where it belongs\n}\n\n/*\n * When \"check\" is FALSE, prepare for commands that scroll the window.\n * When \"check\" is TRUE, take care of scroll-binding after the window has\n * scrolled.  Called from normal_cmd() and edit().\n */\n    void\ndo_check_scrollbind(int check)\n{\n    static win_T\t*old_curwin = NULL;\n    static linenr_T\told_topline = 0;\n#ifdef FEAT_DIFF\n    static int\t\told_topfill = 0;\n#endif\n    static buf_T\t*old_buf = NULL;\n    static colnr_T\told_leftcol = 0;\n\n    if (check && curwin->w_p_scb)\n    {\n\t// If a \":syncbind\" command was just used, don't scroll, only reset\n\t// the values.\n\tif (did_syncbind)\n\t    did_syncbind = FALSE;\n\telse if (curwin == old_curwin)\n\t{\n\t    // Synchronize other windows, as necessary according to\n\t    // 'scrollbind'.  Don't do this after an \":edit\" command, except\n\t    // when 'diff' is set.\n\t    if ((curwin->w_buffer == old_buf\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_p_diff\n#endif\n\t\t)\n\t\t&& (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t\t|| curwin->w_leftcol != old_leftcol))\n\t    {\n\t\tcheck_scrollbind(curwin->w_topline - old_topline,\n\t\t\t(long)(curwin->w_leftcol - old_leftcol));\n\t    }\n\t}\n\telse if (vim_strchr(p_sbo, 'j')) // jump flag set in 'scrollopt'\n\t{\n\t    // When switching between windows, make sure that the relative\n\t    // vertical offset is valid for the new window.  The relative\n\t    // offset is invalid whenever another 'scrollbind' window has\n\t    // scrolled to a point that would force the current window to\n\t    // scroll past the beginning or end of its buffer.  When the\n\t    // resync is performed, some of the other 'scrollbind' windows may\n\t    // need to jump so that the current window's relative position is\n\t    // visible on-screen.\n\t    check_scrollbind(curwin->w_topline - curwin->w_scbind_pos, 0L);\n\t}\n\tcurwin->w_scbind_pos = curwin->w_topline;\n    }\n\n    old_curwin = curwin;\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n    old_buf = curwin->w_buffer;\n    old_leftcol = curwin->w_leftcol;\n}\n\n/*\n * Synchronize any windows that have \"scrollbind\" set, based on the\n * number of rows by which the current window has changed\n * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)\n */\n    void\ncheck_scrollbind(linenr_T topline_diff, long leftcol_diff)\n{\n    int\t\twant_ver;\n    int\t\twant_hor;\n    win_T\t*old_curwin = curwin;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\told_VIsual_select = VIsual_select;\n    int\t\told_VIsual_active = VIsual_active;\n    colnr_T\ttgt_leftcol = curwin->w_leftcol;\n    long\ttopline;\n    long\ty;\n\n    // check 'scrollopt' string for vertical and horizontal scroll options\n    want_ver = (vim_strchr(p_sbo, 'v') && topline_diff != 0);\n#ifdef FEAT_DIFF\n    want_ver |= old_curwin->w_p_diff;\n#endif\n    want_hor = (vim_strchr(p_sbo, 'h') && (leftcol_diff || topline_diff != 0));\n\n    // loop through the scrollbound windows and scroll accordingly\n    VIsual_select = VIsual_active = 0;\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tcurbuf = curwin->w_buffer;\n\t// skip original window and windows with 'noscrollbind'\n\tif (curwin == old_curwin || !curwin->w_p_scb)\n\t    continue;\n\n\t// do the vertical scroll\n\tif (want_ver)\n\t{\n#ifdef FEAT_DIFF\n\t    if (old_curwin->w_p_diff && curwin->w_p_diff)\n\t    {\n\t\tdiff_set_topline(old_curwin, curwin);\n\t    }\n\t    else\n#endif\n\t    {\n\t\tcurwin->w_scbind_pos += topline_diff;\n\t\ttopline = curwin->w_scbind_pos;\n\t\tif (topline > curbuf->b_ml.ml_line_count)\n\t\t    topline = curbuf->b_ml.ml_line_count;\n\t\tif (topline < 1)\n\t\t    topline = 1;\n\n\t\ty = topline - curwin->w_topline;\n\t\tif (y > 0)\n\t\t    scrollup(y, FALSE);\n\t\telse\n\t\t    scrolldown(-y, FALSE);\n\t    }\n\n\t    redraw_later(UPD_VALID);\n\t    cursor_correct();\n\t    curwin->w_redr_status = TRUE;\n\t}\n\n\t// do the horizontal scroll\n\tif (want_hor)\n\t    (void)set_leftcol(tgt_leftcol);\n    }\n\n    // reset current-window\n    VIsual_select = old_VIsual_select;\n    VIsual_active = old_VIsual_active;\n    curwin = old_curwin;\n    curbuf = old_curbuf;\n}\n\n/*\n * Command character that's ignored.\n * Used for CTRL-Q and CTRL-S to avoid problems with terminals that use\n * xon/xoff.\n */\n    static void\nnv_ignore(cmdarg_T *cap)\n{\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n\n/*\n * Command character that doesn't do anything, but unlike nv_ignore() does\n * start edit().  Used for \"startinsert\" executed while starting up.\n */\n    static void\nnv_nop(cmdarg_T *cap UNUSED)\n{\n}\n\n/*\n * Command character doesn't exist.\n */\n    static void\nnv_error(cmdarg_T *cap)\n{\n    clearopbeep(cap->oap);\n}\n\n/*\n * <Help> and <F1> commands.\n */\n    static void\nnv_help(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tex_help(NULL);\n}\n\n/*\n * CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.\n */\n    static void\nnv_addsub(cmdarg_T *cap)\n{\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n\tclearopbeep(cap->oap);\n    else\n#endif\n    if (!VIsual_active && cap->oap->op_type == OP_NOP)\n    {\n\tprep_redo_cmd(cap);\n\tcap->oap->op_type = cap->cmdchar == Ctrl_A ?  OP_NR_ADD : OP_NR_SUB;\n\top_addsub(cap->oap, cap->count1, cap->arg);\n\tcap->oap->op_type = OP_NOP;\n    }\n    else if (VIsual_active)\n\tnv_operator(cap);\n    else\n\tclearop(cap->oap);\n}\n\n/*\n * CTRL-F, CTRL-B, etc: Scroll page up or down.\n */\n    static void\nnv_page(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n\n    if (mod_mask & MOD_MASK_CTRL)\n    {\n\t// <C-PageUp>: tab page back; <C-PageDown>: tab page forward\n\tif (cap->arg == BACKWARD)\n\t    goto_tabpage(-(int)cap->count1);\n\telse\n\t    goto_tabpage((int)cap->count0);\n    }\n    else\n\t(void)onepage(cap->arg, cap->count1);\n}\n\n/*\n * Implementation of \"gd\" and \"gD\" command.\n */\n    static void\nnv_gd(\n    oparg_T\t*oap,\n    int\t\tnchar,\n    int\t\tthisblock)\t// 1 for \"1gd\" and \"1gD\"\n{\n    int\t\tlen;\n    char_u\t*ptr;\n\n    if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0\n\t    || find_decl(ptr, len, nchar == 'd', thisblock, SEARCH_START)\n\t\t\t\t\t\t\t\t       == FAIL)\n    {\n\tclearopbeep(oap);\n\treturn;\n    }\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_SEARCH) && KeyTyped && oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n    // clear any search statistics\n    if (messaging() && !msg_silent && !shortmess(SHM_SEARCHCOUNT))\n\tclear_cmdline = TRUE;\n}\n\n/*\n * Return TRUE if line[offset] is not inside a C-style comment or string, FALSE\n * otherwise.\n */\n    static int\nis_ident(char_u *line, int offset)\n{\n    int\ti;\n    int\tincomment = FALSE;\n    int\tinstring = 0;\n    int\tprev = 0;\n\n    for (i = 0; i < offset && line[i] != NUL; i++)\n    {\n\tif (instring != 0)\n\t{\n\t    if (prev != '\\\\' && line[i] == instring)\n\t\tinstring = 0;\n\t}\n\telse if ((line[i] == '\"' || line[i] == '\\'') && !incomment)\n\t{\n\t    instring = line[i];\n\t}\n\telse\n\t{\n\t    if (incomment)\n\t    {\n\t\tif (prev == '*' && line[i] == '/')\n\t\t    incomment = FALSE;\n\t    }\n\t    else if (prev == '/' && line[i] == '*')\n\t    {\n\t\tincomment = TRUE;\n\t    }\n\t    else if (prev == '/' && line[i] == '/')\n\t    {\n\t\treturn FALSE;\n\t    }\n\t}\n\n\tprev = line[i];\n    }\n\n    return incomment == FALSE && instring == 0;\n}\n\n/*\n * Search for variable declaration of \"ptr[len]\".\n * When \"locally\" is TRUE in the current function (\"gd\"), otherwise in the\n * current file (\"gD\").\n * When \"thisblock\" is TRUE check the {} block scope.\n * Return FAIL when not found.\n */\n    int\nfind_decl(\n    char_u\t*ptr,\n    int\t\tlen,\n    int\t\tlocally,\n    int\t\tthisblock,\n    int\t\tflags_arg)\t// flags passed to searchit()\n{\n    char_u\t*pat;\n    pos_T\told_pos;\n    pos_T\tpar_pos;\n    pos_T\tfound_pos;\n    int\t\tt;\n    int\t\tsave_p_ws;\n    int\t\tsave_p_scs;\n    int\t\tretval = OK;\n    int\t\tincll;\n    int\t\tsearchflags = flags_arg;\n    int\t\tvalid;\n\n    if ((pat = alloc(len + 7)) == NULL)\n\treturn FAIL;\n\n    // Put \"\\V\" before the pattern to avoid that the special meaning of \".\"\n    // and \"~\" causes trouble.\n    sprintf((char *)pat, vim_iswordp(ptr) ? \"\\\\V\\\\<%.*s\\\\>\" : \"\\\\V%.*s\",\n\t\t\t\t\t\t\t\t    len, ptr);\n    old_pos = curwin->w_cursor;\n    save_p_ws = p_ws;\n    save_p_scs = p_scs;\n    p_ws = FALSE;\t// don't wrap around end of file now\n    p_scs = FALSE;\t// don't switch ignorecase off now\n\n    // With \"gD\" go to line 1.\n    // With \"gd\" Search back for the start of the current function, then go\n    // back until a blank line.  If this fails go to line 1.\n    if (!locally || !findpar(&incll, BACKWARD, 1L, '{', FALSE))\n    {\n\tsetpcmark();\t\t\t// Set in findpar() otherwise\n\tcurwin->w_cursor.lnum = 1;\n\tpar_pos = curwin->w_cursor;\n    }\n    else\n    {\n\tpar_pos = curwin->w_cursor;\n\twhile (curwin->w_cursor.lnum > 1 && *skipwhite(ml_get_curline()) != NUL)\n\t    --curwin->w_cursor.lnum;\n    }\n    curwin->w_cursor.col = 0;\n\n    // Search forward for the identifier, ignore comment lines.\n    CLEAR_POS(&found_pos);\n    for (;;)\n    {\n\tt = searchit(curwin, curbuf, &curwin->w_cursor, NULL, FORWARD,\n\t\t\t\t\t  pat, 1L, searchflags, RE_LAST, NULL);\n\tif (curwin->w_cursor.lnum >= old_pos.lnum)\n\t    t = FAIL;\t// match after start is failure too\n\n\tif (thisblock && t != FAIL)\n\t{\n\t    pos_T\t*pos;\n\n\t    // Check that the block the match is in doesn't end before the\n\t    // position where we started the search from.\n\t    if ((pos = findmatchlimit(NULL, '}', FM_FORWARD,\n\t\t     (int)(old_pos.lnum - curwin->w_cursor.lnum + 1))) != NULL\n\t\t    && pos->lnum < old_pos.lnum)\n\t    {\n\t\t// There can't be a useful match before the end of this block.\n\t\t// Skip to the end.\n\t\tcurwin->w_cursor = *pos;\n\t\tcontinue;\n\t    }\n\t}\n\n\tif (t == FAIL)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t    {\n\t\tcurwin->w_cursor = found_pos;\n\t\tt = OK;\n\t    }\n\t    break;\n\t}\n\tif (get_leader_len(ml_get_curline(), NULL, FALSE, TRUE) > 0)\n\t{\n\t    // Ignore this line, continue at start of next line.\n\t    ++curwin->w_cursor.lnum;\n\t    curwin->w_cursor.col = 0;\n\t    continue;\n\t}\n\tvalid = is_ident(ml_get_curline(), curwin->w_cursor.col);\n\n\t// If the current position is not a valid identifier and a previous\n\t// match is present, favor that one instead.\n\tif (!valid && found_pos.lnum != 0)\n\t{\n\t    curwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// Global search: use first valid match found\n\tif (valid && !locally)\n\t    break;\n\tif (valid && curwin->w_cursor.lnum >= par_pos.lnum)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t\tcurwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// For finding a local variable and the match is before the \"{\" or\n\t// inside a comment, continue searching.  For K&R style function\n\t// declarations this skips the function header without types.\n\tif (!valid)\n\t    CLEAR_POS(&found_pos);\n\telse\n\t    found_pos = curwin->w_cursor;\n\t// Remove SEARCH_START from flags to avoid getting stuck at one\n\t// position.\n\tsearchflags &= ~SEARCH_START;\n    }\n\n    if (t == FAIL)\n    {\n\tretval = FAIL;\n\tcurwin->w_cursor = old_pos;\n    }\n    else\n    {\n\tcurwin->w_set_curswant = TRUE;\n\t// \"n\" searches forward now\n\treset_search_dir();\n    }\n\n    vim_free(pat);\n    p_ws = save_p_ws;\n    p_scs = save_p_scs;\n\n    return retval;\n}\n\n/*\n * Move 'dist' lines in direction 'dir', counting lines by *screen*\n * lines rather than lines in the file.\n * 'dist' must be positive.\n *\n * Return OK if able to move cursor, FAIL otherwise.\n */\n    static int\nnv_screengo(oparg_T *oap, int dir, long dist)\n{\n    int\t\tlinelen = linetabsize(curwin, curwin->w_cursor.lnum);\n    int\t\tretval = OK;\n    int\t\tatend = FALSE;\n    int\t\tn;\n    int\t\tcol_off1;\t// margin offset for first screen line\n    int\t\tcol_off2;\t// margin offset for wrapped screen line\n    int\t\twidth1;\t\t// text width for first screen line\n    int\t\twidth2;\t\t// text width for wrapped screen line\n\n    oap->motion_type = MCHAR;\n    oap->inclusive = (curwin->w_curswant == MAXCOL);\n\n    col_off1 = curwin_col_off();\n    col_off2 = col_off1 - curwin_col_off2();\n    width1 = curwin->w_width - col_off1;\n    width2 = curwin->w_width - col_off2;\n    if (width2 == 0)\n\twidth2 = 1; // avoid divide by zero\n\n    if (curwin->w_width != 0)\n    {\n      // Instead of sticking at the last character of the buffer line we\n      // try to stick in the last column of the screen.\n      if (curwin->w_curswant == MAXCOL)\n      {\n\tatend = TRUE;\n\tvalidate_virtcol();\n\tif (width1 <= 0)\n\t    curwin->w_curswant = 0;\n\telse\n\t{\n\t    curwin->w_curswant = width1 - 1;\n\t    if (curwin->w_virtcol > curwin->w_curswant)\n\t\tcurwin->w_curswant += ((curwin->w_virtcol\n\t\t\t     - curwin->w_curswant - 1) / width2 + 1) * width2;\n\t}\n      }\n      else\n      {\n\tif (linelen > width1)\n\t    n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\telse\n\t    n = width1;\n\tif (curwin->w_curswant >= (colnr_T)n)\n\t    curwin->w_curswant = n - 1;\n      }\n\n      while (dist--)\n      {\n\tif (dir == BACKWARD)\n\t{\n\t    if ((long)curwin->w_curswant >= width1\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t       )\n\t\t// Move back within the line. This can give a negative value\n\t\t// for w_curswant if width1 < width2 (with cpoptions+=n),\n\t\t// which will get clipped to column 0.\n\t\tcurwin->w_curswant -= width2;\n\t    else\n\t    {\n\t\t// to previous line\n\t\tif (curwin->w_cursor.lnum <= 1)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\tcursor_up_inner(curwin, 1);\n\n\t\tlinelen = linetabsize(curwin, curwin->w_cursor.lnum);\n\t\tif (linelen > width1)\n\t\t    curwin->w_curswant += (((linelen - width1 - 1) / width2)\n\t\t\t\t\t\t\t\t+ 1) * width2;\n\t    }\n\t}\n\telse // dir == FORWARD\n\t{\n\t    if (linelen > width1)\n\t\tn = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\t    else\n\t\tn = width1;\n\t    if (curwin->w_curswant + width2 < (colnr_T)n\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t\t    )\n\t\t// move forward within line\n\t\tcurwin->w_curswant += width2;\n\t    else\n\t    {\n\t\t// to next line\n\t\tif (curwin->w_cursor.lnum\n\t\t\t\t       >= curwin->w_buffer->b_ml.ml_line_count)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\tcursor_down_inner(curwin, 1);\n\t\tcurwin->w_curswant %= width2;\n\n\t\t// Check if the cursor has moved below the number display\n\t\t// when width1 < width2 (with cpoptions+=n). Subtract width2\n\t\t// to get a negative value for w_curswant, which will get\n\t\t// clipped to column 0.\n\t\tif (curwin->w_curswant >= width1)\n\t\t    curwin->w_curswant -= width2;\n\t\tlinelen = linetabsize(curwin, curwin->w_cursor.lnum);\n\t    }\n\t}\n      }\n    }\n\n    if (virtual_active() && atend)\n\tcoladvance(MAXCOL);\n    else\n\tcoladvance(curwin->w_curswant);\n\n    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n    {\n\tcolnr_T virtcol;\n\tint\tc;\n\n\t// Check for landing on a character that got split at the end of the\n\t// last line.  We want to advance a screenline, not end up in the same\n\t// screenline or move two screenlines.\n\tvalidate_virtcol();\n\tvirtcol = curwin->w_virtcol;\n#if defined(FEAT_LINEBREAK)\n\tif (virtcol > (colnr_T)width1 && *get_showbreak_value(curwin) != NUL)\n\t    virtcol -= vim_strsize(get_showbreak_value(curwin));\n#endif\n\n\tc = (*mb_ptr2char)(ml_get_cursor());\n\tif (dir == FORWARD && virtcol < curwin->w_curswant\n\t\t&& (curwin->w_curswant <= (colnr_T)width1)\n\t\t&& !vim_isprintc(c) && c > 255)\n\t    oneright();\n\n\tif (virtcol > curwin->w_curswant\n\t\t&& (curwin->w_curswant < (colnr_T)width1\n\t\t    ? (curwin->w_curswant > (colnr_T)width1 / 2)\n\t\t    : ((curwin->w_curswant - width1) % width2\n\t\t\t\t\t\t      > (colnr_T)width2 / 2)))\n\t    --curwin->w_cursor.col;\n    }\n\n    if (atend)\n\tcurwin->w_curswant = MAXCOL;\t    // stick in the last column\n    adjust_skipcol();\n\n    return retval;\n}\n\n/*\n * Handle CTRL-E and CTRL-Y commands: scroll a line up or down.\n * cap->arg must be TRUE for CTRL-E.\n */\n    void\nnv_scroll_line(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n\tscroll_redraw(cap->arg, cap->count1);\n}\n\n/*\n * Scroll \"count\" lines up or down, and redraw.\n */\n    void\nscroll_redraw(int up, long count)\n{\n    linenr_T\tprev_topline = curwin->w_topline;\n    int\t\tprev_skipcol = curwin->w_skipcol;\n#ifdef FEAT_DIFF\n    int\t\tprev_topfill = curwin->w_topfill;\n#endif\n    linenr_T\tprev_lnum = curwin->w_cursor.lnum;\n\n    if (up)\n\tscrollup(count, TRUE);\n    else\n\tscrolldown(count, TRUE);\n    if (get_scrolloff_value() > 0)\n    {\n\t// Adjust the cursor position for 'scrolloff'.  Mark w_topline as\n\t// valid, otherwise the screen jumps back at the end of the file.\n\tcursor_correct();\n\tcheck_cursor_moved(curwin);\n\tcurwin->w_valid |= VALID_TOPLINE;\n\n\t// If moved back to where we were, at least move the cursor, otherwise\n\t// we get stuck at one position.  Don't move the cursor up if the\n\t// first line of the buffer is already on the screen\n\twhile (curwin->w_topline == prev_topline\n\t\t&& curwin->w_skipcol == prev_skipcol\n#ifdef FEAT_DIFF\n\t\t&& curwin->w_topfill == prev_topfill\n#endif\n\t\t)\n\t{\n\t    if (up)\n\t    {\n\t\tif (curwin->w_cursor.lnum > prev_lnum\n\t\t\t|| cursor_down(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    else\n\t    {\n\t\tif (curwin->w_cursor.lnum < prev_lnum\n\t\t\t|| prev_topline == 1L\n\t\t\t|| cursor_up(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    // Mark w_topline as valid, otherwise the screen jumps back at the\n\t    // end of the file.\n\t    check_cursor_moved(curwin);\n\t    curwin->w_valid |= VALID_TOPLINE;\n\t}\n    }\n    if (curwin->w_cursor.lnum != prev_lnum)\n\tcoladvance(curwin->w_curswant);\n    redraw_later(UPD_VALID);\n}\n\n/*\n * Get the count specified after a 'z' command. Only the 'z<CR>', 'zl', 'zh',\n * 'z<Left>', and 'z<Right>' commands accept a count after 'z'.\n * Returns TRUE to process the 'z' command and FALSE to skip it.\n */\n    static int\nnv_z_get_count(cmdarg_T *cap, int *nchar_arg)\n{\n    int\t\tnchar = *nchar_arg;\n    long\tn;\n\n    // \"z123{nchar}\": edit the count before obtaining {nchar}\n    if (checkclearop(cap->oap))\n\treturn FALSE;\n    n = nchar - '0';\n\n    for (;;)\n    {\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t++no_mapping;\n\t++allow_keys;   // no mapping for nchar, but allow key codes\n\tnchar = plain_vgetc();\n\tLANGMAP_ADJUST(nchar, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\t(void)add_to_showcmd(nchar);\n\n\tif (nchar == K_DEL || nchar == K_KDEL)\n\t    n /= 10;\n\telse if (VIM_ISDIGIT(nchar))\n\t{\n\t    if (n > LONG_MAX / 10)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t    n = n * 10 + (nchar - '0');\n\t}\n\telse if (nchar == CAR)\n\t{\n#ifdef FEAT_GUI\n\t    need_mouse_correct = TRUE;\n#endif\n\t    win_setheight((int)n);\n\t    break;\n\t}\n\telse if (nchar == 'l'\n\t\t|| nchar == 'h'\n\t\t|| nchar == K_LEFT\n\t\t|| nchar == K_RIGHT)\n\t{\n\t    cap->count1 = n ? n * cap->count1 : cap->count1;\n\t    *nchar_arg = nchar;\n\t    return TRUE;\n\t}\n\telse\n\t{\n\t    clearopbeep(cap->oap);\n\t    break;\n\t}\n    }\n    cap->oap->op_type = OP_NOP;\n    return FALSE;\n}\n\n#ifdef FEAT_SPELL\n/*\n * \"zug\" and \"zuw\": undo \"zg\" and \"zw\"\n * \"zg\": add good word to word list\n * \"zw\": add wrong word to word list\n * \"zG\": add good word to temp word list\n * \"zW\": add wrong word to temp word list\n */\n    static int\nnv_zg_zw(cmdarg_T *cap, int nchar)\n{\n    char_u\t*ptr = NULL;\n    int\t\tlen;\n    int\t\tundo = FALSE;\n\n    if (nchar == 'u')\n    {\n\t++no_mapping;\n\t++allow_keys;   // no mapping for nchar, but allow key codes\n\tnchar = plain_vgetc();\n\tLANGMAP_ADJUST(nchar, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\t(void)add_to_showcmd(nchar);\n\n\tif (vim_strchr((char_u *)\"gGwW\", nchar) == NULL)\n\t{\n\t    clearopbeep(cap->oap);\n\t    return OK;\n\t}\n\tundo = TRUE;\n    }\n\n    if (checkclearop(cap->oap))\n\treturn OK;\n    if (VIsual_active && get_visual_text(cap, &ptr, &len) == FAIL)\n\treturn FAIL;\n    if (ptr == NULL)\n    {\n\tpos_T\tpos = curwin->w_cursor;\n\n\t// Find bad word under the cursor.  When 'spell' is\n\t// off this fails and find_ident_under_cursor() is\n\t// used below.\n\temsg_off++;\n\tlen = spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL);\n\temsg_off--;\n\tif (len != 0 && curwin->w_cursor.col <= pos.col)\n\t    ptr = ml_get_pos(&curwin->w_cursor);\n\tcurwin->w_cursor = pos;\n    }\n\n    if (ptr == NULL\n\t\t&& (len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\treturn FAIL;\n    spell_add_word(ptr, len, nchar == 'w' || nchar == 'W'\n\t    ? SPELL_ADD_BAD : SPELL_ADD_GOOD,\n\t    (nchar == 'G' || nchar == 'W') ? 0 : (int)cap->count1, undo);\n\n    return OK;\n}\n#endif\n\n/*\n * Commands that start with \"z\".\n */\n    static void\nnv_zet(cmdarg_T *cap)\n{\n    long\tn;\n    colnr_T\tcol;\n    int\t\tnchar = cap->nchar;\n#ifdef FEAT_FOLDING\n    long\told_fdl = curwin->w_p_fdl;\n    int\t\told_fen = curwin->w_p_fen;\n#endif\n    long\tsiso = get_sidescrolloff_value();\n\n    if (VIM_ISDIGIT(nchar) && !nv_z_get_count(cap, &nchar))\n\t    return;\n\n    if (\n#ifdef FEAT_FOLDING\n\t    // \"zf\" and \"zF\" are always an operator, \"zd\", \"zo\", \"zO\", \"zc\"\n\t    // and \"zC\" only in Visual mode.  \"zj\" and \"zk\" are motion\n\t    // commands.\n\t    cap->nchar != 'f' && cap->nchar != 'F'\n\t    && !(VIsual_active && vim_strchr((char_u *)\"dcCoO\", cap->nchar))\n\t    && cap->nchar != 'j' && cap->nchar != 'k'\n\t    &&\n#endif\n\t    checkclearop(cap->oap))\n\treturn;\n\n    // For \"z+\", \"z<CR>\", \"zt\", \"z.\", \"zz\", \"z^\", \"z-\", \"zb\":\n    // If line number given, set cursor.\n    if ((vim_strchr((char_u *)\"+\\r\\nt.z^-b\", nchar) != NULL)\n\t    && cap->count0\n\t    && cap->count0 != curwin->w_cursor.lnum)\n    {\n\tsetpcmark();\n\tif (cap->count0 > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\telse\n\t    curwin->w_cursor.lnum = cap->count0;\n\tcheck_cursor_col();\n    }\n\n    switch (nchar)\n    {\n\t\t// \"z+\", \"z<CR>\" and \"zt\": put cursor at top of screen\n    case '+':\n\t\tif (cap->count0 == 0)\n\t\t{\n\t\t    // No count given: put cursor at the line below screen\n\t\t    validate_botline();\t// make sure w_botline is valid\n\t\t    if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = curwin->w_botline;\n\t\t}\n\t\t// FALLTHROUGH\n    case NL:\n    case CAR:\n    case K_KENTER:\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 't':\tscroll_cursor_top(0, TRUE);\n\t\tredraw_later(UPD_VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z.\" and \"zz\": put cursor in middle of screen\n    case '.':\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'z':\tscroll_cursor_halfway(TRUE, FALSE);\n\t\tredraw_later(UPD_VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z^\", \"z-\" and \"zb\": put cursor at bottom of screen\n    case '^':\t// Strange Vi behavior: <count>z^ finds line at top of window\n\t\t// when <count> is at bottom of window, and puts that one at\n\t\t// bottom of window.\n\t\tif (cap->count0 != 0)\n\t\t{\n\t\t    scroll_cursor_bot(0, TRUE);\n\t\t    curwin->w_cursor.lnum = curwin->w_topline;\n\t\t}\n\t\telse if (curwin->w_topline == 1)\n\t\t    curwin->w_cursor.lnum = 1;\n\t\telse\n\t\t    curwin->w_cursor.lnum = curwin->w_topline - 1;\n\t\t// FALLTHROUGH\n    case '-':\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'b':\tscroll_cursor_bot(0, TRUE);\n\t\tredraw_later(UPD_VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"zH\" - scroll screen right half-page\n    case 'H':\n\t\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zh\" - scroll screen to the right\n    case 'h':\n    case K_LEFT:\n\t\tif (!curwin->w_p_wrap)\n\t\t    (void)set_leftcol((colnr_T)cap->count1 > curwin->w_leftcol\n\t\t\t       ? 0 : curwin->w_leftcol - (colnr_T)cap->count1);\n\t\tbreak;\n\n\t\t// \"zL\" - scroll window left half-page\n    case 'L':\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zl\" - scroll window to the left if not wrapping\n    case 'l':\n    case K_RIGHT:\n\t\tif (!curwin->w_p_wrap)\n\t\t    (void)set_leftcol(curwin->w_leftcol + (colnr_T)cap->count1);\n\t\tbreak;\n\n\t\t// \"zs\" - scroll screen, cursor at the start\n    case 's':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, NULL);\n\t\t    if ((long)col > siso)\n\t\t\tcol -= siso;\n\t\t    else\n\t\t\tcol = 0;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(UPD_NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"ze\" - scroll screen, cursor at the end\n    case 'e':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\t\t    n = curwin->w_width - curwin_col_off();\n\t\t    if ((long)col + siso < n)\n\t\t\tcol = 0;\n\t\t    else\n\t\t\tcol = col + siso - n + 1;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(UPD_NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"zp\", \"zP\" in block mode put without addind trailing spaces\n    case 'P':\n    case 'p':  nv_put(cap);\n\t       break;\n\t\t// \"zy\" Yank without trailing spaces\n    case 'y':  nv_operator(cap);\n\t       break;\n#ifdef FEAT_FOLDING\n\t\t// \"zF\": create fold command\n\t\t// \"zf\": create fold operator\n    case 'F':\n    case 'f':   if (foldManualAllowed(TRUE))\n\t\t{\n\t\t    cap->nchar = 'f';\n\t\t    nv_operator(cap);\n\t\t    curwin->w_p_fen = TRUE;\n\n\t\t    // \"zF\" is like \"zfzf\"\n\t\t    if (nchar == 'F' && cap->oap->op_type == OP_FOLD)\n\t\t    {\n\t\t\tnv_operator(cap);\n\t\t\tfinish_op = TRUE;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n\t\t// \"zd\": delete fold at cursor\n\t\t// \"zD\": delete fold at cursor recursively\n    case 'd':\n    case 'D':\tif (foldManualAllowed(FALSE))\n\t\t{\n\t\t    if (VIsual_active)\n\t\t\tnv_operator(cap);\n\t\t    else\n\t\t\tdeleteFold(curwin->w_cursor.lnum,\n\t\t\t\t  curwin->w_cursor.lnum, nchar == 'D', FALSE);\n\t\t}\n\t\tbreak;\n\n\t\t// \"zE\": erase all folds\n    case 'E':\tif (foldmethodIsManual(curwin))\n\t\t{\n\t\t    clearFolding(curwin);\n\t\t    changed_window_setting();\n\t\t}\n\t\telse if (foldmethodIsMarker(curwin))\n\t\t    deleteFold((linenr_T)1, curbuf->b_ml.ml_line_count,\n\t\t\t\t\t\t\t\t TRUE, FALSE);\n\t\telse\n\t\t    emsg(_(e_cannot_erase_folds_with_current_foldmethod));\n\t\tbreak;\n\n\t\t// \"zn\": fold none: reset 'foldenable'\n    case 'n':\tcurwin->w_p_fen = FALSE;\n\t\tbreak;\n\n\t\t// \"zN\": fold Normal: set 'foldenable'\n    case 'N':\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zi\": invert folding: toggle 'foldenable'\n    case 'i':\tcurwin->w_p_fen = !curwin->w_p_fen;\n\t\tbreak;\n\n\t\t// \"za\": open closed fold or close open fold at cursor\n    case 'a':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\telse\n\t\t{\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zA\": open fold at cursor recursively\n    case 'A':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\telse\n\t\t{\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zo\": open fold at cursor or Visual area\n    case 'o':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\tbreak;\n\n\t\t// \"zO\": open fold recursively\n    case 'O':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\tbreak;\n\n\t\t// \"zc\": close fold at cursor or Visual area\n    case 'c':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zC\": close fold recursively\n    case 'C':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zv\": open folds at the cursor\n    case 'v':\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zx\": re-apply 'foldlevel' and open folds at the cursor\n    case 'x':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\tnewFoldLevel();\t\t\t// update right now\n\t\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zX\": undo manual opens/closes, re-apply 'foldlevel'\n    case 'X':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\told_fdl = -1;\t\t\t// force an update\n\t\tbreak;\n\n\t\t// \"zm\": fold more\n    case 'm':\tif (curwin->w_p_fdl > 0)\n\t\t{\n\t\t    curwin->w_p_fdl -= cap->count1;\n\t\t    if (curwin->w_p_fdl < 0)\n\t\t\tcurwin->w_p_fdl = 0;\n\t\t}\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zM\": close all folds\n    case 'M':\tcurwin->w_p_fdl = 0;\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zr\": reduce folding\n    case 'r':\tcurwin->w_p_fdl += cap->count1;\n\t\t{\n\t\t    int d = getDeepestNesting();\n\n\t\t    if (curwin->w_p_fdl >= d)\n\t\t\tcurwin->w_p_fdl = d;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zR\": open all folds\n    case 'R':\tcurwin->w_p_fdl = getDeepestNesting();\n\t\told_fdl = -1;\t\t// force an update\n\t\tbreak;\n\n    case 'j':\t// \"zj\" move to next fold downwards\n    case 'k':\t// \"zk\" move to next fold upwards\n\t\tif (foldMoveTo(TRUE, nchar == 'j' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t  cap->count1) == FAIL)\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n#endif // FEAT_FOLDING\n\n#ifdef FEAT_SPELL\n    case 'u':\t// \"zug\" and \"zuw\": undo \"zg\" and \"zw\"\n    case 'g':\t// \"zg\": add good word to word list\n    case 'w':\t// \"zw\": add wrong word to word list\n    case 'G':\t// \"zG\": add good word to temp word list\n    case 'W':\t// \"zW\": add wrong word to temp word list\n\t\tif (nv_zg_zw(cap, nchar) == FAIL)\n\t\t    return;\n\t\tbreak;\n\n    case '=':\t// \"z=\": suggestions for a badly spelled word\n\t\tif (!checkclearop(cap->oap))\n\t\t    spell_suggest((int)cap->count0);\n\t\tbreak;\n#endif\n\n    default:\tclearopbeep(cap->oap);\n    }\n\n#ifdef FEAT_FOLDING\n    // Redraw when 'foldenable' changed\n    if (old_fen != curwin->w_p_fen)\n    {\n# ifdef FEAT_DIFF\n\twin_T\t    *wp;\n\n\tif (foldmethodIsDiff(curwin) && curwin->w_p_scb)\n\t{\n\t    // Adjust 'foldenable' in diff-synced windows.\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tif (wp != curwin && foldmethodIsDiff(wp) && wp->w_p_scb)\n\t\t{\n\t\t    wp->w_p_fen = curwin->w_p_fen;\n\t\t    changed_window_setting_win(wp);\n\t\t}\n\t    }\n\t}\n# endif\n\tchanged_window_setting();\n    }\n\n    // Redraw when 'foldlevel' changed.\n    if (old_fdl != curwin->w_p_fdl)\n\tnewFoldLevel();\n#endif\n}\n\n#ifdef FEAT_GUI\n/*\n * Vertical scrollbar movement.\n */\n    static void\nnv_ver_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    gui_do_scroll();\n}\n\n/*\n * Horizontal scrollbar movement.\n */\n    static void\nnv_hor_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    do_mousescroll_horiz(scrollbar_value);\n}\n#endif\n\n#if defined(FEAT_GUI_TABLINE) || defined(PROTO)\n/*\n * Click in GUI tab.\n */\n    static void\nnv_tabline(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    goto_tabpage(current_tab);\n}\n\n/*\n * Selected item in tab line menu.\n */\n    static void\nnv_tabmenu(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    handle_tabmenu();\n}\n\n/*\n * Handle selecting an item of the GUI tab line menu.\n * Used in Normal and Insert mode.\n */\n    void\nhandle_tabmenu(void)\n{\n    switch (current_tabmenu)\n    {\n\tcase TABLINE_MENU_CLOSE:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"tabclose\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"tabclose %d\",\n\t\t\t\t\t\t\t\t current_tab);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_NEW:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"$tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"%dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_OPEN:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"browse $tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"browse %dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n    }\n}\n#endif\n\n/*\n * \"Q\" command.\n */\n    static void\nnv_exmode(cmdarg_T *cap)\n{\n    // Ignore 'Q' in Visual mode, just give a beep.\n    if (VIsual_active)\n\tvim_beep(BO_EX);\n    else if (!checkclearop(cap->oap))\n\tdo_exmode(FALSE);\n}\n\n/*\n * Handle a \":\" command.\n */\n    static void\nnv_colon(cmdarg_T *cap)\n{\n    int\told_p_im;\n    int\tcmd_result;\n    int\tis_cmdkey = cap->cmdchar == K_COMMAND\n\t\t\t\t\t   || cap->cmdchar == K_SCRIPT_COMMAND;\n    int\tflags;\n\n    if (VIsual_active && !is_cmdkey)\n    {\n\tnv_operator(cap);\n\treturn;\n    }\n\n    if (cap->oap->op_type != OP_NOP)\n    {\n\t// Using \":\" as a movement is characterwise exclusive.\n\tcap->oap->motion_type = MCHAR;\n\tcap->oap->inclusive = FALSE;\n    }\n    else if (cap->count0 && !is_cmdkey)\n    {\n\t// translate \"count:\" into \":.,.+(count - 1)\"\n\tstuffcharReadbuff('.');\n\tif (cap->count0 > 1)\n\t{\n\t    stuffReadbuff((char_u *)\",.+\");\n\t    stuffnumReadbuff((long)cap->count0 - 1L);\n\t}\n    }\n\n    // When typing, don't type below an old message\n    if (KeyTyped)\n\tcompute_cmdrow();\n\n    old_p_im = p_im;\n\n    // get a command line and execute it\n    flags = cap->oap->op_type != OP_NOP ? DOCMD_KEEPLINE : 0;\n    if (is_cmdkey)\n\tcmd_result = do_cmdkey_command(cap->cmdchar, flags);\n    else\n\tcmd_result = do_cmdline(NULL, getexline, NULL, flags);\n\n    // If 'insertmode' changed, enter or exit Insert mode\n    if (p_im != old_p_im)\n    {\n\tif (p_im)\n\t    restart_edit = 'i';\n\telse\n\t    restart_edit = 0;\n    }\n\n    if (cmd_result == FAIL)\n\t// The Ex command failed, do not execute the operator.\n\tclearop(cap->oap);\n    else if (cap->oap->op_type != OP_NOP\n\t    && (cap->oap->start.lnum > curbuf->b_ml.ml_line_count\n\t\t|| cap->oap->start.col >\n\t\t\t\t  (colnr_T)STRLEN(ml_get(cap->oap->start.lnum))\n\t\t|| did_emsg\n\t       ))\n\t// The start of the operator has become invalid by the Ex command.\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle CTRL-G command.\n */\n    static void\nnv_ctrlg(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// toggle Selection/Visual mode\n    {\n\tVIsual_select = !VIsual_select;\n\tmay_trigger_modechanged();\n\tshowmode();\n    }\n    else if (!checkclearop(cap->oap))\n\t// print full name if count given or :cd used\n\tfileinfo((int)cap->count0, FALSE, TRUE);\n}\n\n/*\n * Handle CTRL-H <Backspace> command.\n */\n    static void\nnv_ctrlh(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tcap->cmdchar = 'x';\t// BS key behaves like 'x' in Select mode\n\tv_visop(cap);\n    }\n    else\n\tnv_left(cap);\n}\n\n/*\n * CTRL-L: clear screen and redraw.\n */\n    static void\nnv_clear(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n\n#ifdef FEAT_SYN_HL\n    // Clear all syntax states to force resyncing.\n    syn_stack_free_all(curwin->w_s);\n# ifdef FEAT_RELTIME\n    {\n\twin_T *wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    wp->w_s->b_syn_slow = FALSE;\n    }\n# endif\n#endif\n    redraw_later(UPD_CLEAR);\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!gui.in_use)\n# endif\n\tresize_console_buf();\n#endif\n}\n\n/*\n * CTRL-O: In Select mode: switch to Visual mode for one command.\n * Otherwise: Go to older pcmark.\n */\n    static void\nnv_ctrlo(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tVIsual_select = FALSE;\n\tmay_trigger_modechanged();\n\tshowmode();\n\trestart_VIsual_select = 2;\t// restart Select mode later\n    }\n    else\n    {\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n    }\n}\n\n/*\n * CTRL-^ command, short for \":e #\".  Works even when the alternate buffer is\n * not named.\n */\n    static void\nnv_hat(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\t(void)buflist_getfile((int)cap->count0, (linenr_T)0,\n\t\t\t\t\t\tGETF_SETMARK|GETF_ALT, FALSE);\n}\n\n/*\n * \"Z\" commands.\n */\n    static void\nnv_Zet(cmdarg_T *cap)\n{\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    switch (cap->nchar)\n    {\n\t// \"ZZ\": equivalent to \":x\".\n\tcase 'Z':\tdo_cmdline_cmd((char_u *)\"x\");\n\t\t\tbreak;\n\n\t\t\t// \"ZQ\": equivalent to \":q!\" (Elvis compatible).\n\tcase 'Q':\tdo_cmdline_cmd((char_u *)\"q!\");\n\t\t\tbreak;\n\n\tdefault:\tclearopbeep(cap->oap);\n    }\n}\n\n/*\n * Call nv_ident() as if \"c1\" was used, with \"c2\" as next character.\n */\n    void\ndo_nv_ident(int c1, int c2)\n{\n    oparg_T\toa;\n    cmdarg_T\tca;\n\n    clear_oparg(&oa);\n    CLEAR_FIELD(ca);\n    ca.oap = &oa;\n    ca.cmdchar = c1;\n    ca.nchar = c2;\n    nv_ident(&ca);\n}\n\n/*\n * 'K' normal-mode command. Get the command to lookup the keyword under the\n * cursor.\n */\n    static int\nnv_K_getcmd(\n\tcmdarg_T\t*cap,\n\tchar_u\t\t*kp,\n\tint\t\tkp_help,\n\tint\t\tkp_ex,\n\tchar_u\t\t**ptr_arg,\n\tint\t\tn,\n\tchar_u\t\t*buf,\n\tunsigned\tbuflen)\n{\n    char_u\t*ptr = *ptr_arg;\n    int\t\tisman;\n    int\t\tisman_s;\n\n    if (kp_help)\n    {\n\t// in the help buffer\n\tSTRCPY(buf, \"he! \");\n\treturn n;\n    }\n\n    if (kp_ex)\n    {\n\t// 'keywordprog' is an ex command\n\tif (cap->count0 != 0)\n\t    vim_snprintf((char *)buf, buflen, \"%s %ld\", kp, cap->count0);\n\telse\n\t    STRCPY(buf, kp);\n\tSTRCAT(buf, \" \");\n\treturn n;\n    }\n\n    // An external command will probably use an argument starting\n    // with \"-\" as an option.  To avoid trouble we skip the \"-\".\n    while (*ptr == '-' && n > 0)\n    {\n\t++ptr;\n\t--n;\n    }\n    if (n == 0)\n    {\n\t// found dashes only\n\temsg(_(e_no_identifier_under_cursor));\n\tvim_free(buf);\n\t*ptr_arg = ptr;\n\treturn 0;\n    }\n\n    // When a count is given, turn it into a range.  Is this\n    // really what we want?\n    isman = (STRCMP(kp, \"man\") == 0);\n    isman_s = (STRCMP(kp, \"man -s\") == 0);\n    if (cap->count0 != 0 && !(isman || isman_s))\n\tsprintf((char *)buf, \".,.+%ld\", cap->count0 - 1);\n\n    STRCAT(buf, \"! \");\n    if (cap->count0 == 0 && isman_s)\n\tSTRCAT(buf, \"man\");\n    else\n\tSTRCAT(buf, kp);\n    STRCAT(buf, \" \");\n    if (cap->count0 != 0 && (isman || isman_s))\n    {\n\tsprintf((char *)buf + STRLEN(buf), \"%ld\", cap->count0);\n\tSTRCAT(buf, \" \");\n    }\n\n    *ptr_arg = ptr;\n    return n;\n}\n\n/*\n * Handle the commands that use the word under the cursor.\n * [g] CTRL-]\t:ta to current identifier\n * [g] 'K'\trun program for current identifier\n * [g] '*'\t/ to current identifier or string\n * [g] '#'\t? to current identifier or string\n *  g  ']'\t:tselect for current identifier\n */\n    static void\nnv_ident(cmdarg_T *cap)\n{\n    char_u\t*ptr = NULL;\n    char_u\t*buf;\n    unsigned\tbuflen;\n    char_u\t*newbuf;\n    char_u\t*p;\n    char_u\t*kp;\t\t// value of 'keywordprg'\n    int\t\tkp_help;\t// 'keywordprg' is \":he\"\n    int\t\tkp_ex;\t\t// 'keywordprg' starts with \":\"\n    int\t\tn = 0;\t\t// init for GCC\n    int\t\tcmdchar;\n    int\t\tg_cmd;\t\t// \"g\" command\n    int\t\ttag_cmd = FALSE;\n    char_u\t*aux_ptr;\n\n    if (cap->cmdchar == 'g')\t// \"g*\", \"g#\", \"g]\" and \"gCTRL-]\"\n    {\n\tcmdchar = cap->nchar;\n\tg_cmd = TRUE;\n    }\n    else\n    {\n\tcmdchar = cap->cmdchar;\n\tg_cmd = FALSE;\n    }\n\n    if (cmdchar == POUND)\t// the pound sign, '#' for English keyboards\n\tcmdchar = '#';\n\n    // The \"]\", \"CTRL-]\" and \"K\" commands accept an argument in Visual mode.\n    if (cmdchar == ']' || cmdchar == Ctrl_RSB || cmdchar == 'K')\n    {\n\tif (VIsual_active && get_visual_text(cap, &ptr, &n) == FAIL)\n\t    return;\n\tif (checkclearopq(cap->oap))\n\t    return;\n    }\n\n    if (ptr == NULL && (n = find_ident_under_cursor(&ptr,\n\t\t    (cmdchar == '*' || cmdchar == '#')\n\t\t\t\t ? FIND_IDENT|FIND_STRING : FIND_IDENT)) == 0)\n    {\n\tclearop(cap->oap);\n\treturn;\n    }\n\n    // Allocate buffer to put the command in.  Inserting backslashes can\n    // double the length of the word.  p_kp / curbuf->b_p_kp could be added\n    // and some numbers.\n    kp = (*curbuf->b_p_kp == NUL ? p_kp : curbuf->b_p_kp);\n    kp_help = (*kp == NUL || STRCMP(kp, \":he\") == 0\n\t\t\t\t\t\t || STRCMP(kp, \":help\") == 0);\n    if (kp_help && *skipwhite(ptr) == NUL)\n    {\n\temsg(_(e_no_identifier_under_cursor));\t // found white space only\n\treturn;\n    }\n    kp_ex = (*kp == ':');\n    buflen = (unsigned)(n * 2 + 30 + STRLEN(kp));\n    buf = alloc(buflen);\n    if (buf == NULL)\n\treturn;\n    buf[0] = NUL;\n\n    switch (cmdchar)\n    {\n\tcase '*':\n\tcase '#':\n\t    // Put cursor at start of word, makes search skip the word\n\t    // under the cursor.\n\t    // Call setpcmark() first, so \"*``\" puts the cursor back where\n\t    // it was.\n\t    setpcmark();\n\t    curwin->w_cursor.col = (colnr_T) (ptr - ml_get_curline());\n\n\t    if (!g_cmd && vim_iswordp(ptr))\n\t\tSTRCPY(buf, \"\\\\<\");\n\t    no_smartcase = TRUE;\t// don't use 'smartcase' now\n\t    break;\n\n\tcase 'K':\n\t    n = nv_K_getcmd(cap, kp, kp_help, kp_ex, &ptr, n, buf, buflen);\n\t    if (n == 0)\n\t\treturn;\n\t    break;\n\n\tcase ']':\n\t    tag_cmd = TRUE;\n#ifdef FEAT_CSCOPE\n\t    if (p_cst)\n\t\tSTRCPY(buf, \"cstag \");\n\t    else\n#endif\n\t\tSTRCPY(buf, \"ts \");\n\t    break;\n\n\tdefault:\n\t    tag_cmd = TRUE;\n\t    if (curbuf->b_help)\n\t\tSTRCPY(buf, \"he! \");\n\t    else\n\t    {\n\t\tif (g_cmd)\n\t\t    STRCPY(buf, \"tj \");\n\t\telse if (cap->count0 == 0)\n\t\t    STRCPY(buf, \"ta \");\n\t\telse\n\t\t    sprintf((char *)buf, \":%ldta \", cap->count0);\n\t    }\n    }\n\n    // Now grab the chars in the identifier\n    if (cmdchar == 'K' && !kp_help)\n    {\n\tptr = vim_strnsave(ptr, n);\n\tif (kp_ex)\n\t    // Escape the argument properly for an Ex command\n\t    p = vim_strsave_fnameescape(ptr, VSE_NONE);\n\telse\n\t    // Escape the argument properly for a shell command\n\t    p = vim_strsave_shellescape(ptr, TRUE, TRUE);\n\tvim_free(ptr);\n\tif (p == NULL)\n\t{\n\t    vim_free(buf);\n\t    return;\n\t}\n\tnewbuf = vim_realloc(buf, STRLEN(buf) + STRLEN(p) + 1);\n\tif (newbuf == NULL)\n\t{\n\t    vim_free(buf);\n\t    vim_free(p);\n\t    return;\n\t}\n\tbuf = newbuf;\n\tSTRCAT(buf, p);\n\tvim_free(p);\n    }\n    else\n    {\n\tif (cmdchar == '*')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/.*~[^$\\\\\" : \"/^$\\\\\");\n\telse if (cmdchar == '#')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/?.*~[^$\\\\\" : \"/?^$\\\\\");\n\telse if (tag_cmd)\n\t{\n\t    if (curbuf->b_help)\n\t\t// \":help\" handles unescaped argument\n\t\taux_ptr = (char_u *)\"\";\n\t    else\n\t\taux_ptr = (char_u *)\"\\\\|\\\"\\n[\";\n\t}\n\telse\n\t    aux_ptr = (char_u *)\"\\\\|\\\"\\n*?[\";\n\n\tp = buf + STRLEN(buf);\n\twhile (n-- > 0)\n\t{\n\t    // put a backslash before \\ and some others\n\t    if (vim_strchr(aux_ptr, *ptr) != NULL)\n\t\t*p++ = '\\\\';\n\t    // When current byte is a part of multibyte character, copy all\n\t    // bytes of that character.\n\t    if (has_mbyte)\n\t    {\n\t\tint i;\n\t\tint len = (*mb_ptr2len)(ptr) - 1;\n\n\t\tfor (i = 0; i < len && n >= 1; ++i, --n)\n\t\t    *p++ = *ptr++;\n\t    }\n\t    *p++ = *ptr++;\n\t}\n\t*p = NUL;\n    }\n\n    // Execute the command.\n    if (cmdchar == '*' || cmdchar == '#')\n    {\n\tif (!g_cmd && (has_mbyte\n\t\t    ? vim_iswordp(mb_prevptr(ml_get_curline(), ptr))\n\t\t    : vim_iswordc(ptr[-1])))\n\t    STRCAT(buf, \"\\\\>\");\n\n\t// put pattern in search history\n\tinit_history();\n\tadd_to_history(HIST_SEARCH, buf, TRUE, NUL);\n\n\t(void)normal_search(cap, cmdchar == '*' ? '/' : '?', buf, 0, NULL);\n    }\n    else\n    {\n\tg_tag_at_cursor = TRUE;\n\tdo_cmdline_cmd(buf);\n\tg_tag_at_cursor = FALSE;\n    }\n\n    vim_free(buf);\n}\n\n/*\n * Get visually selected text, within one line only.\n * Returns FAIL if more than one line selected.\n */\n    int\nget_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    // return: start of selected text\n    int\t\t*lenp)\t    // return: length of selected text\n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (*lenp > 0)\n\t{\n\t    if (has_mbyte)\n\t\t// Correct the length to include all bytes of the last\n\t\t// character.\n\t\t*lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n\t    else if ((*pp)[*lenp - 1] == NUL)\n\t\t// Do not include a trailing NUL.\n\t\t*lenp -= 1;\n\t}\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}\n\n/*\n * CTRL-T: backwards in tag stack\n */\n    static void\nnv_tagpop(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tdo_tag((char_u *)\"\", DT_POP, (int)cap->count1, FALSE, TRUE);\n}\n\n/*\n * Handle scrolling command 'H', 'L' and 'M'.\n */\n    static void\nnv_scroll(cmdarg_T *cap)\n{\n    int\t\tused = 0;\n    long\tn;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\thalf;\n\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    if (cap->cmdchar == 'L')\n    {\n\tvalidate_botline();\t    // make sure curwin->w_botline is valid\n\tcurwin->w_cursor.lnum = curwin->w_botline - 1;\n\tif (cap->count1 - 1 >= curwin->w_cursor.lnum)\n\t    curwin->w_cursor.lnum = 1;\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tfor (n = cap->count1 - 1; n > 0\n\t\t\t    && curwin->w_cursor.lnum > curwin->w_topline; --n)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t    if (curwin->w_cursor.lnum > curwin->w_topline)\n\t\t\t--curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tcurwin->w_cursor.lnum -= cap->count1 - 1;\n\t}\n    }\n    else\n    {\n\tif (cap->cmdchar == 'M')\n\t{\n#ifdef FEAT_DIFF\n\t    // Don't count filler lines above the window.\n\t    used -= diff_check_fill(curwin, curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    validate_botline();\t    // make sure w_empty_rows is valid\n\t    half = (curwin->w_height - curwin->w_empty_rows + 1) / 2;\n\t    for (n = 0; curwin->w_topline + n < curbuf->b_ml.ml_line_count; ++n)\n\t    {\n#ifdef FEAT_DIFF\n\t\t// Count half he number of filler lines to be \"below this\n\t\t// line\" and half to be \"above the next line\".\n\t\tif (n > 0 && used + diff_check_fill(curwin, curwin->w_topline\n\t\t\t\t\t\t\t     + n) / 2 >= half)\n\t\t{\n\t\t    --n;\n\t\t    break;\n\t\t}\n#endif\n\t\tused += plines(curwin->w_topline + n);\n\t\tif (used >= half)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\tif (hasFolding(curwin->w_topline + n, NULL, &lnum))\n\t\t    n = lnum - curwin->w_topline;\n#endif\n\t    }\n\t    if (n > 0 && used > curwin->w_height)\n\t\t--n;\n\t}\n\telse // (cap->cmdchar == 'H')\n\t{\n\t    n = cap->count1 - 1;\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tlnum = curwin->w_topline;\n\t\twhile (n-- > 0 && lnum < curwin->w_botline - 1)\n\t\t{\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t    ++lnum;\n\t\t}\n\t\tn = lnum - curwin->w_topline;\n\t    }\n#endif\n\t}\n\tcurwin->w_cursor.lnum = curwin->w_topline + n;\n\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    }\n\n    // Correct for 'so', except when an operator is pending.\n    if (cap->oap->op_type == OP_NOP)\n\tcursor_correct();\n    beginline(BL_SOL | BL_FIX);\n}\n\n/*\n * Cursor right commands.\n */\n    static void\nnv_right(cmdarg_T *cap)\n{\n    long\tn;\n    int\t\tpast_line;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Right> and <S-Right> move a word or WORD right\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = TRUE;\n\tnv_wordcmd(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    past_line = (VIsual_active && *p_sel != 'o');\n\n    // In virtual edit mode, there's no such thing as \"past_line\", as lines\n    // are (theoretically) infinitely long.\n    if (virtual_active())\n\tpast_line = 0;\n\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif ((!past_line && oneright() == FAIL)\n\t\t|| (past_line && *ml_get_cursor() == NUL)\n\t\t)\n\t{\n\t    //\t  <Space> wraps to next line if 'whichwrap' has 's'.\n\t    //\t      'l' wraps to next line if 'whichwrap' has 'l'.\n\t    // CURS_RIGHT wraps to next line if 'whichwrap' has '>'.\n\t    if (       ((cap->cmdchar == ' '\n\t\t\t    && vim_strchr(p_ww, 's') != NULL)\n\t\t\t|| (cap->cmdchar == 'l'\n\t\t\t    && vim_strchr(p_ww, 'l') != NULL)\n\t\t\t|| (cap->cmdchar == K_RIGHT\n\t\t\t    && vim_strchr(p_ww, '>') != NULL))\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// When deleting we also count the NL as a character.\n\t\t// Set cap->oap->inclusive when last char in the line is\n\t\t// included, move to next line after that\n\t\tif (\t   cap->oap->op_type != OP_NOP\n\t\t\t&& !cap->oap->inclusive\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t\telse\n\t\t{\n\t\t    ++curwin->w_cursor.lnum;\n\t\t    curwin->w_cursor.col = 0;\n\t\t    curwin->w_cursor.coladd = 0;\n\t\t    curwin->w_set_curswant = TRUE;\n\t\t    cap->oap->inclusive = FALSE;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    if (cap->oap->op_type == OP_NOP)\n\t    {\n\t\t// Only beep and flush if not moved at all\n\t\tif (n == cap->count1)\n\t\t    beep_flush();\n\t    }\n\t    else\n\t    {\n\t\tif (!LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t    }\n\t    break;\n\t}\n\telse if (past_line)\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    if (virtual_active())\n\t\toneright();\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t    curwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t\telse\n\t\t    ++curwin->w_cursor.col;\n\t    }\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor left commands.\n *\n * Returns TRUE when operator end should not be adjusted.\n */\n    static void\nnv_left(cmdarg_T *cap)\n{\n    long\tn;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Left> and <S-Left> move a word or WORD left\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = 1;\n\tnv_bck_word(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif (oneleft() == FAIL)\n\t{\n\t    // <BS> and <Del> wrap to previous line if 'whichwrap' has 'b'.\n\t    //\t\t 'h' wraps to previous line if 'whichwrap' has 'h'.\n\t    //\t   CURS_LEFT wraps to previous line if 'whichwrap' has '<'.\n\t    if (       (((cap->cmdchar == K_BS\n\t\t\t\t|| cap->cmdchar == Ctrl_H)\n\t\t\t    && vim_strchr(p_ww, 'b') != NULL)\n\t\t\t|| (cap->cmdchar == 'h'\n\t\t\t    && vim_strchr(p_ww, 'h') != NULL)\n\t\t\t|| (cap->cmdchar == K_LEFT\n\t\t\t    && vim_strchr(p_ww, '<') != NULL))\n\t\t    && curwin->w_cursor.lnum > 1)\n\t    {\n\t\t--(curwin->w_cursor.lnum);\n\t\tcoladvance((colnr_T)MAXCOL);\n\t\tcurwin->w_set_curswant = TRUE;\n\n\t\t// When the NL before the first char has to be deleted we\n\t\t// put the cursor on the NUL after the previous line.\n\t\t// This is a very special case, be careful!\n\t\t// Don't adjust op_end now, otherwise it won't work.\n\t\tif (\t   (cap->oap->op_type == OP_DELETE\n\t\t\t    || cap->oap->op_type == OP_CHANGE)\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t{\n\t\t    char_u *cp = ml_get_cursor();\n\n\t\t    if (*cp != NUL)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    curwin->w_cursor.col += (*mb_ptr2len)(cp);\n\t\t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t    cap->retval |= CA_NO_ADJ_OP_END;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    // Only beep and flush if not moved at all\n\t    else if (cap->oap->op_type == OP_NOP && n == cap->count1)\n\t\tbeep_flush();\n\t    break;\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor up commands.\n * cap->arg is TRUE for \"-\": Move cursor to first non-blank.\n */\n    static void\nnv_up(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Up> is page up\n\tcap->arg = BACKWARD;\n\tnv_page(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MLINE;\n    if (cursor_up(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n    else if (cap->arg)\n\tbeginline(BL_WHITE | BL_FIX);\n}\n\n/*\n * Cursor down commands.\n * cap->arg is TRUE for CR and \"+\": Move cursor to first non-blank.\n */\n    static void\nnv_down(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Down> is page down\n\tcap->arg = FORWARD;\n\tnv_page(cap);\n    }\n#if defined(FEAT_QUICKFIX)\n    // Quickfix window only: view the result under the cursor.\n    else if (bt_quickfix(curbuf) && cap->cmdchar == CAR)\n\tqf_view_result(FALSE);\n#endif\n    else\n    {\n\t// In the cmdline window a <CR> executes the command.\n\tif (cmdwin_type != 0 && cap->cmdchar == CAR)\n\t    cmdwin_result = CAR;\n\telse\n#ifdef FEAT_JOB_CHANNEL\n\t// In a prompt buffer a <CR> in the last line invokes the callback.\n\tif (bt_prompt(curbuf) && cap->cmdchar == CAR\n\t\t       && curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t{\n\t    invoke_prompt_callback();\n\t    if (restart_edit == 0)\n\t\trestart_edit = 'a';\n\t}\n\telse\n#endif\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    if (cursor_down(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\t\tclearopbeep(cap->oap);\n\t    else if (cap->arg)\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t}\n    }\n}\n\n/*\n * Grab the file name under the cursor and edit it.\n */\n    static void\nnv_gotofile(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    linenr_T\tlnum = -1;\n\n    if (check_text_or_curbuf_locked(cap->oap))\n\treturn;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n\n    ptr = grab_file_name(cap->count1, &lnum);\n\n    if (ptr != NULL)\n    {\n\t// do autowrite if necessary\n\tif (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf))\n\t    (void)autowrite(curbuf, FALSE);\n\tsetpcmark();\n\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,\n\t\t\t\tbuf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK\n\t\t&& cap->nchar == 'F' && lnum >= 0)\n\t{\n\t    curwin->w_cursor.lnum = lnum;\n\t    check_cursor_lnum();\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n\tvim_free(ptr);\n    }\n    else\n\tclearop(cap->oap);\n}\n\n/*\n * <End> command: to end of current line or last line.\n */\n    static void\nnv_end(cmdarg_T *cap)\n{\n    if (cap->arg || (mod_mask & MOD_MASK_CTRL))\t// CTRL-END = goto last line\n    {\n\tcap->arg = TRUE;\n\tnv_goto(cap);\n\tcap->count1 = 1;\t\t// to end of current line\n    }\n    nv_dollar(cap);\n}\n\n/*\n * Handle the \"$\" command.\n */\n    static void\nnv_dollar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = TRUE;\n    // In virtual mode when off the edge of a line and an operator\n    // is pending (whew!) keep the cursor where it is.\n    // Otherwise, send it to the end of the line.\n    if (!virtual_active() || gchar_cursor() != NUL\n\t\t\t\t\t       || cap->oap->op_type == OP_NOP)\n\tcurwin->w_curswant = MAXCOL;\t// so we stay at the end\n    if (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\t cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Implementation of '?' and '/' commands.\n * If cap->arg is TRUE don't set PC mark.\n */\n    static void\nnv_search(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    pos_T\tsave_cursor = curwin->w_cursor;\n\n    if (cap->cmdchar == '?' && cap->oap->op_type == OP_ROT13)\n    {\n\t// Translate \"g??\" to \"g?g?\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = '?';\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // When using 'incsearch' the cursor may be moved to set a different search\n    // start position.\n    cap->searchbuf = getcmdline(cap->cmdchar, cap->count1, 0, 0);\n\n    if (cap->searchbuf == NULL)\n    {\n\tclearop(oap);\n\treturn;\n    }\n\n    (void)normal_search(cap, cap->cmdchar, cap->searchbuf,\n\t\t\t(cap->arg || !EQUAL_POS(save_cursor, curwin->w_cursor))\n\t\t\t\t\t\t      ? 0 : SEARCH_MARK, NULL);\n}\n\n\n/*\n * Handle \"N\" and \"n\" commands.\n * cap->arg is SEARCH_REV for \"N\", 0 for \"n\".\n */\n    static void\nnv_next(cmdarg_T *cap)\n{\n    pos_T   old = curwin->w_cursor;\n    int\t    wrapped = FALSE;\n    int\t    i = normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, &wrapped);\n\n    if (i == 1 && !wrapped && EQUAL_POS(old, curwin->w_cursor))\n    {\n\t// Avoid getting stuck on the current cursor position, which can\n\t// happen when an offset is given and the cursor is on the last char\n\t// in the buffer: Repeat with count + 1.\n\tcap->count1 += 1;\n\t(void)normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, NULL);\n\tcap->count1 -= 1;\n    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    // Redraw the window to refresh the highlighted matches.\n    if (i > 0 && p_hls && !no_hlsearch)\n\tredraw_later(UPD_SOME_VALID);\n#endif\n}\n\n/*\n * Search for \"pat\" in direction \"dir\" ('/' or '?', 0 for repeat).\n * Uses only cap->count1 and cap->oap from \"cap\".\n * Return 0 for failure, 1 for found, 2 for found and line offset added.\n */\n    static int\nnormal_search(\n    cmdarg_T\t*cap,\n    int\t\tdir,\n    char_u\t*pat,\n    int\t\topt,\t\t// extra flags for do_search()\n    int\t\t*wrapped)\n{\n    int\t\ti;\n    searchit_arg_T sia;\n#ifdef FEAT_SEARCH_EXTRA\n    pos_T\tprev_cursor = curwin->w_cursor;\n#endif\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n\n    CLEAR_FIELD(sia);\n    i = do_search(cap->oap, dir, dir, pat, cap->count1,\n\t\t\t    opt | SEARCH_OPT | SEARCH_ECHO | SEARCH_MSG, &sia);\n    if (wrapped != NULL)\n\t*wrapped = sia.sa_wrapped;\n    if (i == 0)\n\tclearop(cap->oap);\n    else\n    {\n\tif (i == 2)\n\t    cap->oap->motion_type = MLINE;\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n#endif\n    }\n#ifdef FEAT_SEARCH_EXTRA\n    // Redraw the window to refresh the highlighted matches.\n    if (!EQUAL_POS(curwin->w_cursor, prev_cursor) && p_hls && !no_hlsearch)\n\tredraw_later(UPD_SOME_VALID);\n#endif\n\n    // \"/$\" will put the cursor after the end of the line, may need to\n    // correct that here\n    check_cursor();\n    return i;\n}\n\n/*\n * Character search commands.\n * cap->arg is BACKWARD for 'F' and 'T', FORWARD for 'f' and 't', TRUE for\n * ',' and FALSE for ';'.\n * cap->nchar is NUL for ',' and ';' (repeat the search)\n */\n    static void\nnv_csearch(cmdarg_T *cap)\n{\n    int\t\tt_cmd;\n\n    if (cap->cmdchar == 't' || cap->cmdchar == 'T')\n\tt_cmd = TRUE;\n    else\n\tt_cmd = FALSE;\n\n    cap->oap->motion_type = MCHAR;\n    if (IS_SPECIAL(cap->nchar) || searchc(cap, t_cmd) == FAIL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    curwin->w_set_curswant = TRUE;\n    // Include a Tab for \"tx\" and for \"dfx\".\n    if (gchar_cursor() == TAB && virtual_active() && cap->arg == FORWARD\n\t    && (t_cmd || cap->oap->op_type != OP_NOP))\n    {\n\tcolnr_T\tscol, ecol;\n\n\tgetvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);\n\tcurwin->w_cursor.coladd = ecol - scol;\n    }\n    else\n\tcurwin->w_cursor.coladd = 0;\n    adjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n * \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n * \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n * \"[m\" or \"]m\" search for prev/next start of (Java) method.\n * \"[M\" or \"]M\" search for prev/next end of (Java) method.\n */\n    static void\nnv_bracket_block(cmdarg_T *cap, pos_T *old_pos)\n{\n    pos_T\tnew_pos = {0, 0, 0};\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\tprev_pos;\n    long\tn;\n    int\t\tfindc;\n    int\t\tc;\n\n    if (cap->nchar == '*')\n\tcap->nchar = '/';\n    prev_pos.lnum = 0;\n    if (cap->nchar == 'm' || cap->nchar == 'M')\n    {\n\tif (cap->cmdchar == '[')\n\t    findc = '{';\n\telse\n\t    findc = '}';\n\tn = 9999;\n    }\n    else\n    {\n\tfindc = cap->nchar;\n\tn = cap->count1;\n    }\n    for ( ; n > 0; --n)\n    {\n\tif ((pos = findmatchlimit(cap->oap, findc,\n\t\t\t(cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD, 0)) == NULL)\n\t{\n\t    if (new_pos.lnum == 0)\t// nothing found\n\t    {\n\t\tif (cap->nchar != 'm' && cap->nchar != 'M')\n\t\t    clearopbeep(cap->oap);\n\t    }\n\t    else\n\t\tpos = &new_pos;\t// use last one found\n\t    break;\n\t}\n\tprev_pos = new_pos;\n\tcurwin->w_cursor = *pos;\n\tnew_pos = *pos;\n    }\n    curwin->w_cursor = *old_pos;\n\n    // Handle \"[m\", \"]m\", \"[M\" and \"[M\".  The findmatchlimit() only\n    // brought us to the match for \"[m\" and \"]M\" when inside a method.\n    // Try finding the '{' or '}' we want to be at.\n    // Also repeat for the given count.\n    if (cap->nchar == 'm' || cap->nchar == 'M')\n    {\n\t// norm is TRUE for \"]M\" and \"[m\"\n\tint\t    norm = ((findc == '{') == (cap->nchar == 'm'));\n\n\tn = cap->count1;\n\t// found a match: we were inside a method\n\tif (prev_pos.lnum != 0)\n\t{\n\t    pos = &prev_pos;\n\t    curwin->w_cursor = prev_pos;\n\t    if (norm)\n\t\t--n;\n\t}\n\telse\n\t    pos = NULL;\n\twhile (n > 0)\n\t{\n\t    for (;;)\n\t    {\n\t\tif ((findc == '{' ? dec_cursor() : inc_cursor()) < 0)\n\t\t{\n\t\t    // if not found anything, that's an error\n\t\t    if (pos == NULL)\n\t\t\tclearopbeep(cap->oap);\n\t\t    n = 0;\n\t\t    break;\n\t\t}\n\t\tc = gchar_cursor();\n\t\tif (c == '{' || c == '}')\n\t\t{\n\t\t    // Must have found end/start of class: use it.\n\t\t    // Or found the place to be at.\n\t\t    if ((c == findc && norm) || (n == 1 && !norm))\n\t\t    {\n\t\t\tnew_pos = curwin->w_cursor;\n\t\t\tpos = &new_pos;\n\t\t\tn = 0;\n\t\t    }\n\t\t    // if no match found at all, we started outside of the\n\t\t    // class and we're inside now.  Just go on.\n\t\t    else if (new_pos.lnum == 0)\n\t\t    {\n\t\t\tnew_pos = curwin->w_cursor;\n\t\t\tpos = &new_pos;\n\t\t    }\n\t\t    // found start/end of other method: go to match\n\t\t    else if ((pos = findmatchlimit(cap->oap, findc,\n\t\t\t      (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,\n\t\t\t\t\t\t\t\t   0)) == NULL)\n\t\t\tn = 0;\n\t\t    else\n\t\t\tcurwin->w_cursor = *pos;\n\t\t    break;\n\t\t}\n\t    }\n\t    --n;\n\t}\n\tcurwin->w_cursor = *old_pos;\n\tif (pos == NULL && new_pos.lnum != 0)\n\t    clearopbeep(cap->oap);\n    }\n    if (pos != NULL)\n    {\n\tsetpcmark();\n\tcurwin->w_cursor = *pos;\n\tcurwin->w_set_curswant = TRUE;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped\n\t\t&& cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"[\" and \"]\" commands.\n * cap->arg is BACKWARD for \"[\" and FORWARD for \"]\".\n */\n    static void\nnv_brackets(cmdarg_T *cap)\n{\n    pos_T\tprev_pos;\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\told_pos;\t    // cursor position before command\n    int\t\tflag;\n    long\tn;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    old_pos = curwin->w_cursor;\n    curwin->w_cursor.coladd = 0;    // TODO: don't do this for an error.\n\n    // \"[f\" or \"]f\" : Edit file under the cursor (same as \"gf\")\n    if (cap->nchar == 'f')\n\tnv_gotofile(cap);\n    else\n\n#ifdef FEAT_FIND_ID\n    // Find the occurrence(s) of the identifier or define under cursor\n    // in current and included files or jump to the first occurrence.\n    //\n    //\t\t\tsearch\t     list\t    jump\n    //\t\t      fwd   bwd    fwd\t bwd\t fwd\tbwd\n    // identifier     \"]i\"  \"[i\"   \"]I\"  \"[I\"\t\"]^I\"  \"[^I\"\n    // define\t      \"]d\"  \"[d\"   \"]D\"  \"[D\"\t\"]^D\"  \"[^D\"\n    if (vim_strchr((char_u *)\"iI\\011dD\\004\", cap->nchar) != NULL)\n    {\n\tchar_u\t*ptr;\n\tint\tlen;\n\n\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t    clearop(cap->oap);\n\telse\n\t{\n\t    // Make a copy, if the line was changed it will be freed.\n\t    ptr = vim_strnsave(ptr, len);\n\t    if (ptr == NULL)\n\t\treturn;\n\n\t    find_pattern_in_path(ptr, 0, len, TRUE,\n\t\tcap->count0 == 0 ? !isupper(cap->nchar) : FALSE,\n\t\t((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,\n\t\tcap->count1,\n\t\tisupper(cap->nchar) ? ACTION_SHOW_ALL :\n\t\t\t    islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,\n\t\tcap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,\n\t\t(linenr_T)MAXLNUM);\n\t    vim_free(ptr);\n\t    curwin->w_set_curswant = TRUE;\n\t}\n    }\n    else\n#endif\n\n    // \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n    // \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n    // \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n    // \"[m\" or \"]m\" search for prev/next start of (Java) method.\n    // \"[M\" or \"]M\" search for prev/next end of (Java) method.\n    if (  (cap->cmdchar == '['\n\t\t&& vim_strchr((char_u *)\"{(*/#mM\", cap->nchar) != NULL)\n\t    || (cap->cmdchar == ']'\n\t\t&& vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL))\n\tnv_bracket_block(cap, &old_pos);\n\n    // \"[[\", \"[]\", \"]]\" and \"][\": move to start or end of function\n    else if (cap->nchar == '[' || cap->nchar == ']')\n    {\n\tif (cap->nchar == cap->cmdchar)\t\t    // \"]]\" or \"[[\"\n\t    flag = '{';\n\telse\n\t    flag = '}';\t\t    // \"][\" or \"[]\"\n\n\tcurwin->w_set_curswant = TRUE;\n\t// Imitate strange Vi behaviour: When using \"]]\" with an operator\n\t// we also stop at '}'.\n\tif (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,\n\t      (cap->oap->op_type != OP_NOP\n\t\t\t\t      && cap->arg == FORWARD && flag == '{')))\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    if (cap->oap->op_type == OP_NOP)\n\t\tbeginline(BL_WHITE | BL_FIX);\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t\tfoldOpenCursor();\n#endif\n\t}\n    }\n\n    // \"[p\", \"[P\", \"]P\" and \"]p\": put with indent adjustment\n    else if (cap->nchar == 'p' || cap->nchar == 'P')\n    {\n\tnv_put_opt(cap, TRUE);\n    }\n\n    // \"['\", \"[`\", \"]'\" and \"]`\": jump to next mark\n    else if (cap->nchar == '\\'' || cap->nchar == '`')\n    {\n\tpos = &curwin->w_cursor;\n\tfor (n = cap->count1; n > 0; --n)\n\t{\n\t    prev_pos = *pos;\n\t    pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,\n\t\t\t\t\t\t\t  cap->nchar == '\\'');\n\t    if (pos == NULL)\n\t\tbreak;\n\t}\n\tif (pos == NULL)\n\t    pos = &prev_pos;\n\tnv_cursormark(cap, cap->nchar == '\\'', pos);\n    }\n\n    // [ or ] followed by a middle mouse click: put selected text with\n    // indent adjustment.  Any other button just does as usual.\n    else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE)\n    {\n\t(void)do_mouse(cap->oap, cap->nchar,\n\t\t       (cap->cmdchar == ']') ? FORWARD : BACKWARD,\n\t\t       cap->count1, PUT_FIXINDENT);\n    }\n\n#ifdef FEAT_FOLDING\n    // \"[z\" and \"]z\": move to start or end of open fold.\n    else if (cap->nchar == 'z')\n    {\n\tif (foldMoveTo(FALSE, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    // \"[c\" and \"]c\": move to next or previous diff-change.\n    else if (cap->nchar == 'c')\n    {\n\tif (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // \"[s\", \"[S\", \"]s\" and \"]S\": move to next spell error.\n    else if (cap->nchar == 's' || cap->nchar == 'S')\n    {\n\tsetpcmark();\n\tfor (n = 0; n < cap->count1; ++n)\n\t    if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t  cap->nchar == 's' ? TRUE : FALSE, FALSE, NULL) == 0)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n#endif\n\n    // Not a valid cap->nchar.\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle Normal mode \"%\" command.\n */\n    static void\nnv_percent(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n#if defined(FEAT_FOLDING)\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n#endif\n\n    cap->oap->inclusive = TRUE;\n    if (cap->count0)\t    // {cnt}% : goto {cnt} percentage in file\n    {\n\tif (cap->count0 > 100)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    setpcmark();\n\t    // Round up, so 'normal 100%' always jumps at the line line.\n\t    // Beyond 21474836 lines, (ml_line_count * 100 + 99) would\n\t    // overflow on 32-bits, so use a formula with less accuracy\n\t    // to avoid overflows.\n\t    if (curbuf->b_ml.ml_line_count >= 21474836)\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count + 99L)\n\t\t\t\t\t\t\t / 100L * cap->count0;\n\t    else\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count *\n\t\t\t\t\t\t    cap->count0 + 99L) / 100L;\n\t    if (curwin->w_cursor.lnum < 1)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n    }\n    else\t\t    // \"%\" : go to matching paren\n    {\n\tcap->oap->motion_type = MCHAR;\n\tcap->oap->use_reg_one = TRUE;\n\tif ((pos = findmatch(cap->oap, NUL)) == NULL)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    setpcmark();\n\t    curwin->w_cursor = *pos;\n\t    curwin->w_set_curswant = TRUE;\n\t    curwin->w_cursor.coladd = 0;\n\t    adjust_for_sel(cap);\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && lnum != curwin->w_cursor.lnum\n\t    && (fdo_flags & FDO_PERCENT)\n\t    && KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle \"(\" and \")\" commands.\n * cap->arg is BACKWARD for \"(\" and FORWARD for \")\".\n */\n    static void\nnv_brace(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->use_reg_one = TRUE;\n    // The motion used to be inclusive for \"(\", but that is not what Vi does.\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n\n    if (findsent(cap->arg, cap->count1) == FAIL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Don't leave the cursor on the NUL past end of line.\n    adjust_cursor(cap->oap);\n    curwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * \"m\" command: Mark a position.\n */\n    static void\nnv_mark(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n\n    if (setmark(cap->nchar) == FAIL)\n\tclearopbeep(cap->oap);\n}\n\n/*\n * \"{\" and \"}\" commands.\n * cmd->arg is BACKWARD for \"{\" and FORWARD for \"}\".\n */\n    static void\nnv_findpar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n    if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, NUL, FALSE))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    curwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * \"u\" command: Undo or make lower case.\n */\n    static void\nnv_undo(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_LOWER || VIsual_active)\n    {\n\t// translate \"<Visual>u\" to \"<Visual>gu\" and \"guu\" to \"gugu\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'u';\n\tnv_operator(cap);\n    }\n    else\n\tnv_kundo(cap);\n}\n\n/*\n * <Undo> command.\n */\n    static void\nnv_kundo(cmdarg_T *cap)\n{\n    if (checkclearopq(cap->oap))\n\treturn;\n\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n    u_undo((int)cap->count1);\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * Handle the \"r\" command.\n */\n    static void\nnv_replace(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    int\t\thad_ctrl_v;\n    long\tn;\n\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    // get another character\n    if (cap->nchar == Ctrl_V || cap->nchar == Ctrl_Q)\n    {\n\thad_ctrl_v = Ctrl_V;\n\tcap->nchar = get_literal(FALSE);\n\t// Don't redo a multibyte character with CTRL-V.\n\tif (cap->nchar > DEL)\n\t    had_ctrl_v = NUL;\n    }\n    else\n\thad_ctrl_v = NUL;\n\n    // Abort if the character is a special key.\n    if (IS_SPECIAL(cap->nchar))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Visual mode \"r\"\n    if (VIsual_active)\n    {\n\tif (got_int)\n\t    got_int = FALSE;\n\tif (had_ctrl_v)\n\t{\n\t    // Use a special (negative) number to make a difference between a\n\t    // literal CR or NL and a line break.\n\t    if (cap->nchar == CAR)\n\t\tcap->nchar = REPLACE_CR_NCHAR;\n\t    else if (cap->nchar == NL)\n\t\tcap->nchar = REPLACE_NL_NCHAR;\n\t}\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // Break tabs, etc.\n    if (virtual_active())\n    {\n\tif (u_save_cursor() == FAIL)\n\t    return;\n\tif (gchar_cursor() == NUL)\n\t{\n\t    // Add extra space and put the cursor on the first one.\n\t    coladvance_force((colnr_T)(getviscol() + cap->count1));\n\t    curwin->w_cursor.col -= cap->count1;\n\t}\n\telse if (gchar_cursor() == TAB)\n\t    coladvance_force(getviscol());\n    }\n\n    // Abort if not enough characters to replace.\n    ptr = ml_get_cursor();\n    if (STRLEN(ptr) < (unsigned)cap->count1\n\t    || (has_mbyte && mb_charlen(ptr) < cap->count1))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Replacing with a TAB is done by edit() when it is complicated because\n    // 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.\n    // Other characters are done below to avoid problems with things like\n    // CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).\n    if (had_ctrl_v != Ctrl_V && cap->nchar == '\\t' && (curbuf->b_p_et || p_sta))\n    {\n\tstuffnumReadbuff(cap->count1);\n\tstuffcharReadbuff('R');\n\tstuffcharReadbuff('\\t');\n\tstuffcharReadbuff(ESC);\n\treturn;\n    }\n\n    // save line for undo\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    if (had_ctrl_v != Ctrl_V && (cap->nchar == '\\r' || cap->nchar == '\\n'))\n    {\n\t// Replace character(s) by a single newline.\n\t// Strange vi behaviour: Only one newline is inserted.\n\t// Delete the characters here.\n\t// Insert the newline with an insert command, takes care of\n\t// autoindent.\tThe insert command depends on being on the last\n\t// character of a line or not.\n\t(void)del_chars(cap->count1, FALSE);\t// delete the characters\n\tstuffcharReadbuff('\\r');\n\tstuffcharReadbuff(ESC);\n\n\t// Give 'r' to edit(), to get the redo command right.\n\tinvoke_edit(cap, TRUE, 'r', FALSE);\n    }\n    else\n    {\n\tprep_redo(cap->oap->regname, cap->count1,\n\t\t\t\t       NUL, 'r', NUL, had_ctrl_v, cap->nchar);\n\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tif (has_mbyte)\n\t{\n\t    int\t\told_State = State;\n\n\t    if (cap->ncharC1 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC1);\n\t    if (cap->ncharC2 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC2);\n\n\t    // This is slow, but it handles replacing a single-byte with a\n\t    // multi-byte and the other way around.  Also handles adding\n\t    // composing characters for utf-8.\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\tState = MODE_REPLACE;\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t    int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\t\t    if (c != NUL)\n\t\t\tins_char(c);\n\t\t    else\n\t\t\t// will be decremented further down\n\t\t\t++curwin->w_cursor.col;\n\t\t}\n\t\telse\n\t\t    ins_char(cap->nchar);\n\t\tState = old_State;\n\t\tif (cap->ncharC1 != 0)\n\t\t    ins_char(cap->ncharC1);\n\t\tif (cap->ncharC2 != 0)\n\t\t    ins_char(cap->ncharC2);\n\t    }\n\t}\n\telse\n\t{\n\t    // Replace the characters within one line.\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\t// Get ptr again, because u_save and/or showmatch() will have\n\t\t// released the line.  This may also happen in ins_copychar().\n\t\t// At the same time we let know that the line will be changed.\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t  int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\n\t\t  ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t  if (c != NUL)\n\t\t    ptr[curwin->w_cursor.col] = c;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t    ptr[curwin->w_cursor.col] = cap->nchar;\n\t\t}\n\t\tif (p_sm && msg_silent == 0)\n\t\t    showmatch(cap->nchar);\n\t\t++curwin->w_cursor.col;\n\t    }\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tcolnr_T  start = (colnr_T)(curwin->w_cursor.col - cap->count1);\n\n\t\tnetbeans_removed(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t\t\t   cap->count1);\n\t\tnetbeans_inserted(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t       &ptr[start], (int)cap->count1);\n\t    }\n#endif\n\n\t    // mark the buffer as changed and prepare for displaying\n\t    changed_bytes(curwin->w_cursor.lnum,\n\t\t\t       (colnr_T)(curwin->w_cursor.col - cap->count1));\n\t}\n\t--curwin->w_cursor.col;\t    // cursor on the last replaced char\n\t// if the character on the left of the current cursor is a multi-byte\n\t// character, move two characters left\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tcurwin->w_set_curswant = TRUE;\n\tset_last_insert(cap->nchar);\n    }\n}\n\n/*\n * 'o': Exchange start and end of Visual area.\n * 'O': same, but in block mode exchange left and right corners.\n */\n    static void\nv_swap_corners(int cmdchar)\n{\n    pos_T\told_cursor;\n    colnr_T\tleft, right;\n\n    if (cmdchar == 'O' && VIsual_mode == Ctrl_V)\n    {\n\told_cursor = curwin->w_cursor;\n\tgetvcols(curwin, &old_cursor, &VIsual, &left, &right);\n\tcurwin->w_cursor.lnum = VIsual.lnum;\n\tcoladvance(left);\n\tVIsual = curwin->w_cursor;\n\n\tcurwin->w_cursor.lnum = old_cursor.lnum;\n\tcurwin->w_curswant = right;\n\t// 'selection \"exclusive\" and cursor at right-bottom corner: move it\n\t// right one column\n\tif (old_cursor.lnum >= VIsual.lnum && *p_sel == 'e')\n\t    ++curwin->w_curswant;\n\tcoladvance(curwin->w_curswant);\n\tif (curwin->w_cursor.col == old_cursor.col\n\t\t&& (!virtual_active()\n\t\t    || curwin->w_cursor.coladd == old_cursor.coladd))\n\t{\n\t    curwin->w_cursor.lnum = VIsual.lnum;\n\t    if (old_cursor.lnum <= VIsual.lnum && *p_sel == 'e')\n\t\t++right;\n\t    coladvance(right);\n\t    VIsual = curwin->w_cursor;\n\n\t    curwin->w_cursor.lnum = old_cursor.lnum;\n\t    coladvance(left);\n\t    curwin->w_curswant = left;\n\t}\n    }\n    else\n    {\n\told_cursor = curwin->w_cursor;\n\tcurwin->w_cursor = VIsual;\n\tVIsual = old_cursor;\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * \"R\" (cap->arg is FALSE) and \"gR\" (cap->arg is TRUE).\n */\n    static void\nnv_Replace(cmdarg_T *cap)\n{\n    if (VIsual_active)\t\t// \"R\" is replace lines\n    {\n\tcap->cmdchar = 'c';\n\tcap->nchar = NUL;\n\tVIsual_mode_orig = VIsual_mode; // remember original area for gv\n\tVIsual_mode = 'V';\n\tnv_operator(cap);\n\treturn;\n    }\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    if (!curbuf->b_p_ma)\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n    else\n    {\n\tif (virtual_active())\n\t    coladvance(getviscol());\n\tinvoke_edit(cap, FALSE, cap->arg ? 'V' : 'R', FALSE);\n    }\n}\n\n/*\n * \"gr\".\n */\n    static void\nnv_vreplace(cmdarg_T *cap)\n{\n    if (VIsual_active)\n    {\n\tcap->cmdchar = 'r';\n\tcap->nchar = cap->extra_char;\n\tnv_replace(cap);\t// Do same as \"r\" in Visual mode for now\n\treturn;\n    }\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    if (!curbuf->b_p_ma)\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n    else\n    {\n\tif (cap->extra_char == Ctrl_V || cap->extra_char == Ctrl_Q)\n\t    // get another character\n\t    cap->extra_char = get_literal(FALSE);\n\tif (cap->extra_char < ' ')\n\t    // Prefix a control character with CTRL-V to avoid it being used as\n\t    // a command.\n\t    stuffcharReadbuff(Ctrl_V);\n\tstuffcharReadbuff(cap->extra_char);\n\tstuffcharReadbuff(ESC);\n\tif (virtual_active())\n\t    coladvance(getviscol());\n\tinvoke_edit(cap, TRUE, 'v', FALSE);\n    }\n}\n\n/*\n * Swap case for \"~\" command, when it does not work like an operator.\n */\n    static void\nn_swapchar(cmdarg_T *cap)\n{\n    long\tn;\n    pos_T\tstartpos;\n    int\t\tdid_change = 0;\n#ifdef FEAT_NETBEANS_INTG\n    pos_T\tpos;\n    char_u\t*ptr;\n    int\t\tcount;\n#endif\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    if (LINEEMPTY(curwin->w_cursor.lnum) && vim_strchr(p_ww, '~') == NULL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    prep_redo_cmd(cap);\n\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    startpos = curwin->w_cursor;\n#ifdef FEAT_NETBEANS_INTG\n    pos = startpos;\n#endif\n    for (n = cap->count1; n > 0; --n)\n    {\n\tdid_change |= swapchar(cap->oap->op_type, &curwin->w_cursor);\n\tinc_cursor();\n\tif (gchar_cursor() == NUL)\n\t{\n\t    if (vim_strchr(p_ww, '~') != NULL\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n#ifdef FEAT_NETBEANS_INTG\n\t\tif (netbeans_active())\n\t\t{\n\t\t    if (did_change)\n\t\t    {\n\t\t\tptr = ml_get(pos.lnum);\n\t\t\tcount = (int)STRLEN(ptr) - pos.col;\n\t\t\tnetbeans_removed(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t\t (long)count);\n\t\t\t// line may have been flushed, get it again\n\t\t\tptr = ml_get(pos.lnum);\n\t\t\tnetbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t&ptr[pos.col], count);\n\t\t    }\n\t\t    pos.col = 0;\n\t\t    pos.lnum++;\n\t\t}\n#endif\n\t\t++curwin->w_cursor.lnum;\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (n > 1)\n\t\t{\n\t\t    if (u_savesub(curwin->w_cursor.lnum) == FAIL)\n\t\t\tbreak;\n\t\t    u_clearline();\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n    }\n#ifdef FEAT_NETBEANS_INTG\n    if (did_change && netbeans_active())\n    {\n\tptr = ml_get(pos.lnum);\n\tcount = curwin->w_cursor.col - pos.col;\n\tnetbeans_removed(curbuf, pos.lnum, pos.col, (long)count);\n\tnetbeans_inserted(curbuf, pos.lnum, pos.col, &ptr[pos.col], count);\n    }\n#endif\n\n\n    check_cursor();\n    curwin->w_set_curswant = TRUE;\n    if (did_change)\n    {\n\tchanged_lines(startpos.lnum, startpos.col, curwin->w_cursor.lnum + 1,\n\t\t\t\t\t\t\t\t\t  0L);\n\tcurbuf->b_op_start = startpos;\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tif (curbuf->b_op_end.col > 0)\n\t    --curbuf->b_op_end.col;\n    }\n}\n\n/*\n * Move cursor to mark.\n */\n    static void\nnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos)\n{\n    if (check_mark(pos) == FAIL)\n\tclearop(cap->oap);\n    else\n    {\n\tif (cap->cmdchar == '\\''\n\t\t|| cap->cmdchar == '`'\n\t\t|| cap->cmdchar == '['\n\t\t|| cap->cmdchar == ']')\n\t    setpcmark();\n\tcurwin->w_cursor = *pos;\n\tif (flag)\n\t    beginline(BL_WHITE | BL_FIX);\n\telse\n\t    check_cursor();\n    }\n    cap->oap->motion_type = flag ? MLINE : MCHAR;\n    if (cap->cmdchar == '`')\n\tcap->oap->use_reg_one = TRUE;\n    cap->oap->inclusive = FALSE;\t\t// ignored if not MCHAR\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * Handle commands that are operators in Visual mode.\n */\n    static void\nv_visop(cmdarg_T *cap)\n{\n    static char_u trans[] = \"YyDdCcxdXdAAIIrr\";\n\n    // Uppercase means linewise, except in block mode, then \"D\" deletes till\n    // the end of the line, and \"C\" replaces till EOL\n    if (isupper(cap->cmdchar))\n    {\n\tif (VIsual_mode != Ctrl_V)\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\telse if (cap->cmdchar == 'C' || cap->cmdchar == 'D')\n\t    curwin->w_curswant = MAXCOL;\n    }\n    cap->cmdchar = *(vim_strchr(trans, cap->cmdchar) + 1);\n    nv_operator(cap);\n}\n\n/*\n * \"s\" and \"S\" commands.\n */\n    static void\nnv_subst(cmdarg_T *cap)\n{\n#ifdef FEAT_TERMINAL\n    // When showing output of term_dumpdiff() swap the top and bottom.\n    if (term_swap_diff() == OK)\n\treturn;\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n    if (VIsual_active)\t// \"vs\" and \"vS\" are the same as \"vc\"\n    {\n\tif (cap->cmdchar == 'S')\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\tcap->cmdchar = 'c';\n\tnv_operator(cap);\n    }\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Abbreviated commands.\n */\n    static void\nnv_abbrev(cmdarg_T *cap)\n{\n    if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)\n\tcap->cmdchar = 'x';\t\t// DEL key behaves like 'x'\n\n    // in Visual mode these commands are operators\n    if (VIsual_active)\n\tv_visop(cap);\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Translate a command into another command.\n */\n    static void\nnv_optrans(cmdarg_T *cap)\n{\n    static char_u *(ar[8]) = {(char_u *)\"dl\", (char_u *)\"dh\",\n\t\t\t      (char_u *)\"d$\", (char_u *)\"c$\",\n\t\t\t      (char_u *)\"cl\", (char_u *)\"cc\",\n\t\t\t      (char_u *)\"yy\", (char_u *)\":s\\r\"};\n    static char_u *str = (char_u *)\"xXDCsSY&\";\n\n    if (!checkclearopq(cap->oap))\n    {\n\t// In Vi \"2D\" doesn't delete the next line.  Can't translate it\n\t// either, because \"2.\" should also not use the count.\n\tif (cap->cmdchar == 'D' && vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t{\n\t    cap->oap->start = curwin->w_cursor;\n\t    cap->oap->op_type = OP_DELETE;\n#ifdef FEAT_EVAL\n\t    set_op_var(OP_DELETE);\n#endif\n\t    cap->count1 = 1;\n\t    nv_dollar(cap);\n\t    finish_op = TRUE;\n\t    ResetRedobuff();\n\t    AppendCharToRedobuff('D');\n\t}\n\telse\n\t{\n\t    if (cap->count0)\n\t\tstuffnumReadbuff(cap->count0);\n\t    stuffReadbuff(ar[(int)(vim_strchr(str, cap->cmdchar) - str)]);\n\t}\n    }\n    cap->opcount = 0;\n}\n\n/*\n * \"'\" and \"`\" commands.  Also for \"g'\" and \"g`\".\n * cap->arg is TRUE for \"'\" and \"g'\".\n */\n    static void\nnv_gomark(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n    int\t\tc;\n#ifdef FEAT_FOLDING\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n#endif\n\n    if (cap->cmdchar == 'g')\n\tc = cap->extra_char;\n    else\n\tc = cap->nchar;\n    pos = getmark(c, (cap->oap->op_type == OP_NOP));\n    if (pos == (pos_T *)-1)\t    // jumped to other file\n    {\n\tif (cap->arg)\n\t{\n\t    check_cursor_lnum();\n\t    beginline(BL_WHITE | BL_FIX);\n\t}\n\telse\n\t    check_cursor();\n    }\n    else\n\tnv_cursormark(cap, cap->arg, pos);\n\n    // May need to clear the coladd that a mark includes.\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    check_cursor_col();\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && pos != NULL\n\t    && (pos == (pos_T *)-1 || !EQUAL_POS(old_cursor, *pos))\n\t    && (fdo_flags & FDO_MARK)\n\t    && old_KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle CTRL-O, CTRL-I, \"g;\", \"g,\" and \"CTRL-Tab\" commands.\n */\n    static void\nnv_pcmark(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n#endif\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    if (cap->cmdchar == TAB && mod_mask == MOD_MASK_CTRL)\n    {\n\tif (goto_tabpage_lastused() == FAIL)\n\t    clearopbeep(cap->oap);\n\treturn;\n    }\n    if (cap->cmdchar == 'g')\n\tpos = movechangelist((int)cap->count1);\n    else\n\tpos = movemark((int)cap->count1);\n    if (pos == (pos_T *)-1)\t\t// jump to other file\n    {\n\tcurwin->w_set_curswant = TRUE;\n\tcheck_cursor();\n    }\n    else if (pos != NULL)\t\t    // can jump\n\tnv_cursormark(cap, FALSE, pos);\n    else if (cap->cmdchar == 'g')\n    {\n\tif (curbuf->b_changelistlen == 0)\n\t    emsg(_(e_changelist_is_empty));\n\telse if (cap->count1 < 0)\n\t    emsg(_(e_at_start_of_changelist));\n\telse\n\t    emsg(_(e_at_end_of_changelist));\n    }\n    else\n\tclearopbeep(cap->oap);\n# ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && (pos == (pos_T *)-1 || lnum != curwin->w_cursor.lnum)\n\t    && (fdo_flags & FDO_MARK)\n\t    && old_KeyTyped)\n\tfoldOpenCursor();\n# endif\n}\n\n/*\n * Handle '\"' command.\n */\n    static void\nnv_regname(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n\tcap->nchar = get_expr_register();\n#endif\n    if (cap->nchar != NUL && valid_yank_reg(cap->nchar, FALSE))\n    {\n\tcap->oap->regname = cap->nchar;\n\tcap->opcount = cap->count0;\t// remember count before '\"'\n#ifdef FEAT_EVAL\n\tset_reg_var(cap->oap->regname);\n#endif\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle \"v\", \"V\" and \"CTRL-V\" commands.\n * Also for \"gh\", \"gH\" and \"g^H\" commands: Always start Select mode, cap->arg\n * is TRUE.\n * Handle CTRL-Q just like CTRL-V.\n */\n    static void\nnv_visual(cmdarg_T *cap)\n{\n    if (cap->cmdchar == Ctrl_Q)\n\tcap->cmdchar = Ctrl_V;\n\n    // 'v', 'V' and CTRL-V can be used while an operator is pending to make it\n    // characterwise, linewise, or blockwise.\n    if (cap->oap->op_type != OP_NOP)\n    {\n\tmotion_force = cap->oap->motion_force = cap->cmdchar;\n\tfinish_op = FALSE;\t// operator doesn't finish now but later\n\treturn;\n    }\n\n    VIsual_select = cap->arg;\n    if (VIsual_active)\t    // change Visual mode\n    {\n\tif (VIsual_mode == cap->cmdchar)    // stop visual mode\n\t    end_visual_mode();\n\telse\t\t\t\t    // toggle char/block mode\n\t{\t\t\t\t    //\t   or char/line mode\n\t    VIsual_mode = cap->cmdchar;\n\t    showmode();\n\t    may_trigger_modechanged();\n\t}\n\tredraw_curbuf_later(UPD_INVERTED);\t    // update the inversion\n    }\n    else\t\t    // start Visual mode\n    {\n\tcheck_visual_highlight();\n\tif (cap->count0 > 0 && resel_VIsual_mode != NUL)\n\t{\n\t    // use previously selected part\n\t    VIsual = curwin->w_cursor;\n\n\t    VIsual_active = TRUE;\n\t    VIsual_reselect = TRUE;\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    setmouse();\n\t    if (p_smd && msg_silent == 0)\n\t\tredraw_cmdline = TRUE;\t    // show visual mode later\n\t    // For V and ^V, we multiply the number of lines even if there\n\t    // was only one -- webb\n\t    if (resel_VIsual_mode != 'v' || resel_VIsual_line_count > 1)\n\t    {\n\t\tcurwin->w_cursor.lnum +=\n\t\t\t\t    resel_VIsual_line_count * cap->count0 - 1;\n\t\tcheck_cursor();\n\t    }\n\t    VIsual_mode = resel_VIsual_mode;\n\t    if (VIsual_mode == 'v')\n\t    {\n\t\tif (resel_VIsual_line_count <= 1)\n\t\t{\n\t\t    update_curswant_force();\n\t\t    curwin->w_curswant += resel_VIsual_vcol * cap->count0;\n\t\t    if (*p_sel != 'e')\n\t\t\t--curwin->w_curswant;\n\t\t}\n\t\telse\n\t\t    curwin->w_curswant = resel_VIsual_vcol;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    if (resel_VIsual_vcol == MAXCOL)\n\t    {\n\t\tcurwin->w_curswant = MAXCOL;\n\t\tcoladvance((colnr_T)MAXCOL);\n\t    }\n\t    else if (VIsual_mode == Ctrl_V)\n\t    {\n\t\t// Update curswant on the original line, that is where \"col\" is\n\t\t// valid.\n\t\tlinenr_T lnum = curwin->w_cursor.lnum;\n\t\tcurwin->w_cursor.lnum = VIsual.lnum;\n\t\tupdate_curswant_force();\n\t\tcurwin->w_curswant += resel_VIsual_vcol * cap->count0 - 1;\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n\t    redraw_curbuf_later(UPD_INVERTED);\t// show the inversion\n\t}\n\telse\n\t{\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    n_start_visual_mode(cap->cmdchar);\n\t    if (VIsual_mode != 'V' && *p_sel == 'e')\n\t\t++cap->count1;  // include one more char\n\t    if (cap->count0 > 0 && --cap->count1 > 0)\n\t    {\n\t\t// With a count select that many characters or lines.\n\t\tif (VIsual_mode == 'v' || VIsual_mode == Ctrl_V)\n\t\t    nv_right(cap);\n\t\telse if (VIsual_mode == 'V')\n\t\t    nv_down(cap);\n\t    }\n\t}\n    }\n}\n\n/*\n * Start selection for Shift-movement keys.\n */\n    void\nstart_selection(void)\n{\n    // if 'selectmode' contains \"key\", start Select mode\n    may_start_select('k');\n    n_start_visual_mode('v');\n}\n\n/*\n * Start Select mode, if \"c\" is in 'selectmode' and not in a mapping or menu.\n * When \"c\" is 'o' (checking for \"mouse\") then also when mapped.\n */\n    void\nmay_start_select(int c)\n{\n    VIsual_select = (c == 'o' || (stuff_empty() && typebuf_typed()))\n\t\t    && vim_strchr(p_slm, c) != NULL;\n}\n\n/*\n * Start Visual mode \"c\".\n * Should set VIsual_select before calling this.\n */\n    static void\nn_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    // Corner case: the 0 position in a tab may change when going into\n    // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n\n    may_trigger_modechanged();\n    setmouse();\n#ifdef FEAT_CONCEAL\n    // Check if redraw is needed after changing the state.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t// show visual mode later\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end may still be the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n\n    // Only need to redraw this line, unless still need to redraw an old\n    // Visual area (when 'lazyredraw' is set).\n    if (curwin->w_redr_type < UPD_INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}\n\n\n/*\n * CTRL-W: Window commands\n */\n    static void\nnv_window(cmdarg_T *cap)\n{\n    if (cap->nchar == ':')\n    {\n\t// \"CTRL-W :\" is the same as typing \":\"; useful in a terminal window\n\tcap->cmdchar = ':';\n\tcap->nchar = NUL;\n\tnv_colon(cap);\n    }\n    else if (!checkclearop(cap->oap))\n\tdo_window(cap->nchar, cap->count0, NUL); // everything is in window.c\n}\n\n/*\n * CTRL-Z: Suspend\n */\n    static void\nnv_suspend(cmdarg_T *cap)\n{\n    clearop(cap->oap);\n    if (VIsual_active)\n\tend_visual_mode();\t\t// stop Visual mode\n    do_cmdline_cmd((char_u *)\"stop\");\n}\n\n/*\n * \"gv\": Reselect the previous Visual area.  If Visual already active,\n *       exchange previous and current Visual area.\n */\n    static void\nnv_gv_cmd(cmdarg_T *cap)\n{\n    pos_T\ttpos;\n    int\t\ti;\n\n    if (checkclearop(cap->oap))\n\treturn;\n\n    if (curbuf->b_visual.vi_start.lnum == 0\n\t    || curbuf->b_visual.vi_start.lnum > curbuf->b_ml.ml_line_count\n\t    || curbuf->b_visual.vi_end.lnum == 0)\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    // set w_cursor to the start of the Visual area, tpos to the end\n    if (VIsual_active)\n    {\n\ti = VIsual_mode;\n\tVIsual_mode = curbuf->b_visual.vi_mode;\n\tcurbuf->b_visual.vi_mode = i;\n# ifdef FEAT_EVAL\n\tcurbuf->b_visual_mode_eval = i;\n# endif\n\ti = curwin->w_curswant;\n\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\tcurbuf->b_visual.vi_curswant = i;\n\n\ttpos = curbuf->b_visual.vi_end;\n\tcurbuf->b_visual.vi_end = curwin->w_cursor;\n\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n\tcurbuf->b_visual.vi_start = VIsual;\n    }\n    else\n    {\n\tVIsual_mode = curbuf->b_visual.vi_mode;\n\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\ttpos = curbuf->b_visual.vi_end;\n\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n    }\n\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    // Set Visual to the start and w_cursor to the end of the Visual\n    // area.  Make sure they are on an existing character.\n    check_cursor();\n    VIsual = curwin->w_cursor;\n    curwin->w_cursor = tpos;\n    check_cursor();\n    update_topline();\n\n    // When called from normal \"g\" command: start Select mode when\n    // 'selectmode' contains \"cmd\".  When called for K_SELECT, always\n    // start Select mode.\n    if (cap->arg)\n    {\n\tVIsual_select = TRUE;\n\tVIsual_select_reg = 0;\n    }\n    else\n\tmay_start_select('c');\n    setmouse();\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end are still the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n    redraw_curbuf_later(UPD_INVERTED);\n    showmode();\n}\n\n/*\n * \"g0\", \"g^\" : Like \"0\" and \"^\" but for screen lines.\n * \"gm\": middle of \"g0\" and \"g$\".\n */\n    static void\nnv_g_home_m_cmd(cmdarg_T *cap)\n{\n    int\t\ti;\n    int\t\tflag = FALSE;\n\n    if (cap->nchar == '^')\n\tflag = TRUE;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tint\twidth1 = curwin->w_width - curwin_col_off();\n\tint\twidth2 = width1 + curwin_col_off2();\n\tint\tvirtcol;\n\n\tvalidate_virtcol();\n\tvirtcol = curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t    - curwin->w_virtcol_first_char\n#endif\n\t    ;\n\ti = 0;\n\tif (virtcol >= (colnr_T)width1 && width2 > 0)\n\t    i = (virtcol - width1) / width2 * width2 + width1;\n    }\n    else\n\ti = curwin->w_leftcol;\n    // Go to the middle of the screen line.  When 'number' or\n    // 'relativenumber' is on and lines are wrapping the middle can be more\n    // to the left.\n    if (cap->nchar == 'm')\n\ti += (curwin->w_width - curwin_col_off()\n\t\t+ ((curwin->w_p_wrap && i > 0)\n\t\t    ? curwin_col_off2() : 0)) / 2;\n    coladvance((colnr_T)i);\n    if (flag)\n    {\n\tdo\n\t    i = gchar_cursor();\n\twhile (VIM_ISWHITE(i) && oneright() == OK);\n\tcurwin->w_valid &= ~VALID_WCOL;\n    }\n    curwin->w_set_curswant = TRUE;\n    adjust_skipcol();\n}\n\n/*\n * \"g_\": to the last non-blank character in the line or <count> lines\n *       downward.\n */\n    static void\nnv_g_underscore_cmd(cmdarg_T *cap)\n{\n    char_u  *ptr;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = TRUE;\n    curwin->w_curswant = MAXCOL;\n    if (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\tcap->oap->op_type == OP_NOP) == FAIL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    ptr = ml_get_curline();\n\n    // In Visual mode we may end up after the line.\n    if (curwin->w_cursor.col > 0 && ptr[curwin->w_cursor.col] == NUL)\n\t--curwin->w_cursor.col;\n\n    // Decrease the cursor column until it's on a non-blank.\n    while (curwin->w_cursor.col > 0\n\t    && VIM_ISWHITE(ptr[curwin->w_cursor.col]))\n\t--curwin->w_cursor.col;\n    curwin->w_set_curswant = TRUE;\n    adjust_for_sel(cap);\n}\n\n/*\n * \"g$\" : Like \"$\" but for screen lines.\n */\n    static void\nnv_g_dollar_cmd(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    int\t\ti;\n    int\t\tcol_off = curwin_col_off();\n    int\t\tflag = FALSE;\n\n    if (cap->nchar == K_END || cap->nchar == K_KEND)\n\tflag = TRUE;\n\n    oap->motion_type = MCHAR;\n    oap->inclusive = TRUE;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tcurwin->w_curswant = MAXCOL;    // so we stay at the end\n\tif (cap->count1 == 1)\n\t{\n\t    int\t\twidth1 = curwin->w_width - col_off;\n\t    int\t\twidth2 = width1 + curwin_col_off2();\n\t    int\t\tvirtcol;\n\n\t    validate_virtcol();\n\t    virtcol = curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t\t- curwin->w_virtcol_first_char\n#endif\n\t\t;\n\t    i = width1 - 1;\n\t    if (virtcol >= (colnr_T)width1)\n\t\ti += ((virtcol - width1) / width2 + 1)\n\t\t    * width2;\n\t    coladvance((colnr_T)i);\n\n\t    // Make sure we stick in this column.\n\t    update_curswant_force();\n\t    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n\t    {\n\t\t// Check for landing on a character that got split at\n\t\t// the end of the line.  We do not want to advance to\n\t\t// the next screen line.\n\t\tif (curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t\t\t- curwin->w_virtcol_first_char\n#endif\n\t\t\t\t\t\t> (colnr_T)i)\n\t\t    --curwin->w_cursor.col;\n\t    }\n\t}\n\telse if (nv_screengo(oap, FORWARD, cap->count1 - 1) == FAIL)\n\t    clearopbeep(oap);\n    }\n    else\n    {\n\tif (cap->count1 > 1)\n\t    // if it fails, let the cursor still move to the last char\n\t    (void)cursor_down(cap->count1 - 1, FALSE);\n\n\ti = curwin->w_leftcol + curwin->w_width - col_off - 1;\n\tcoladvance((colnr_T)i);\n\n\t// if the character doesn't fit move one back\n\tif (curwin->w_cursor.col > 0\n\t\t&& (*mb_ptr2cells)(ml_get_cursor()) > 1)\n\t{\n\t    colnr_T vcol;\n\n\t    getvvcol(curwin, &curwin->w_cursor, NULL, NULL, &vcol);\n\t    if (vcol >= curwin->w_leftcol + curwin->w_width - col_off)\n\t\t--curwin->w_cursor.col;\n\t}\n\n\t// Make sure we stick in this column.\n\tupdate_curswant_force();\n    }\n    if (flag)\n    {\n\tdo\n\t    i = gchar_cursor();\n\twhile (VIM_ISWHITE(i) && oneleft() == OK);\n\tcurwin->w_valid &= ~VALID_WCOL;\n    }\n}\n\n/*\n * \"gi\": start Insert at the last position.\n */\n    static void\nnv_gi_cmd(cmdarg_T *cap)\n{\n    int\t\ti;\n\n    if (curbuf->b_last_insert.lnum != 0)\n    {\n\tcurwin->w_cursor = curbuf->b_last_insert;\n\tcheck_cursor_lnum();\n\ti = (int)STRLEN(ml_get_curline());\n\tif (curwin->w_cursor.col > (colnr_T)i)\n\t{\n\t    if (virtual_active())\n\t\tcurwin->w_cursor.coladd += curwin->w_cursor.col - i;\n\t    curwin->w_cursor.col = i;\n\t}\n    }\n    cap->cmdchar = 'i';\n    nv_edit(cap);\n}\n\n/*\n * Commands starting with \"g\".\n */\n    static void\nnv_g_cmd(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    int\t\ti;\n\n    switch (cap->nchar)\n    {\n    case Ctrl_A:\n    case Ctrl_X:\n#ifdef MEM_PROFILE\n    // \"g^A\": dump log of used memory.\n\tif (!VIsual_active && cap->nchar == Ctrl_A)\n\t    vim_mem_profile_dump();\n\telse\n#endif\n    // \"g^A/g^X\": sequentially increment visually selected region\n\tif (VIsual_active)\n\t{\n\t    cap->arg = TRUE;\n\t    cap->cmdchar = cap->nchar;\n\t    cap->nchar = NUL;\n\t    nv_addsub(cap);\n\t}\n\telse\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gR\": Enter virtual replace mode.\n    case 'R':\n\tcap->arg = TRUE;\n\tnv_Replace(cap);\n\tbreak;\n\n    case 'r':\n\tnv_vreplace(cap);\n\tbreak;\n\n    case '&':\n\tdo_cmdline_cmd((char_u *)\"%s//~/&\");\n\tbreak;\n\n    // \"gv\": Reselect the previous Visual area.  If Visual already active,\n    // exchange previous and current Visual area.\n    case 'v':\n\tnv_gv_cmd(cap);\n\tbreak;\n\n    // \"gV\": Don't reselect the previous Visual area after a Select mode\n    // mapping of menu.\n    case 'V':\n\tVIsual_reselect = FALSE;\n\tbreak;\n\n    // \"gh\":  start Select mode.\n    // \"gH\":  start Select line mode.\n    // \"g^H\": start Select block mode.\n    case K_BS:\n\tcap->nchar = Ctrl_H;\n\t// FALLTHROUGH\n    case 'h':\n    case 'H':\n    case Ctrl_H:\n\tcap->cmdchar = cap->nchar + ('v' - 'h');\n\tcap->arg = TRUE;\n\tnv_visual(cap);\n\tbreak;\n\n    // \"gn\", \"gN\" visually select next/previous search match\n    // \"gn\" selects next match\n    // \"gN\" selects previous match\n    case 'N':\n    case 'n':\n\tif (!current_search(cap->count1, cap->nchar == 'n'))\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gj\" and \"gk\" two new funny movement keys -- up and down\n    // movement based on *screen* line rather than *file* line.\n    case 'j':\n    case K_DOWN:\n\t// with 'nowrap' it works just like the normal \"j\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_down(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, FORWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case 'k':\n    case K_UP:\n\t// with 'nowrap' it works just like the normal \"k\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_up(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, BACKWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"gJ\": join two lines without inserting a space.\n    case 'J':\n\tnv_join(cap);\n\tbreak;\n\n    // \"g0\", \"g^\" : Like \"0\" and \"^\" but for screen lines.\n    // \"gm\": middle of \"g0\" and \"g$\".\n    case '^':\n    case '0':\n    case 'm':\n    case K_HOME:\n    case K_KHOME:\n\tnv_g_home_m_cmd(cap);\n\tbreak;\n\n    case 'M':\n\t{\n\t    oap->motion_type = MCHAR;\n\t    oap->inclusive = FALSE;\n\t    i = linetabsize(curwin, curwin->w_cursor.lnum);\n\t    if (cap->count0 > 0 && cap->count0 <= 100)\n\t\tcoladvance((colnr_T)(i * cap->count0 / 100));\n\t    else\n\t\tcoladvance((colnr_T)(i / 2));\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tbreak;\n\n    // \"g_\": to the last non-blank character in the line or <count> lines\n    // downward.\n    case '_':\n\tnv_g_underscore_cmd(cap);\n\tbreak;\n\n    // \"g$\" : Like \"$\" but for screen lines.\n    case '$':\n    case K_END:\n    case K_KEND:\n\tnv_g_dollar_cmd(cap);\n\tbreak;\n\n    // \"g*\" and \"g#\", like \"*\" and \"#\" but without using \"\\<\" and \"\\>\"\n    case '*':\n    case '#':\n#if POUND != '#'\n    case POUND:\t\t// pound sign (sometimes equal to '#')\n#endif\n    case Ctrl_RSB:\t\t// :tag or :tselect for current identifier\n    case ']':\t\t\t// :tselect for current identifier\n\tnv_ident(cap);\n\tbreak;\n\n    // ge and gE: go back to end of word\n    case 'e':\n    case 'E':\n\toap->motion_type = MCHAR;\n\tcurwin->w_set_curswant = TRUE;\n\toap->inclusive = TRUE;\n\tif (bckend_word(cap->count1, cap->nchar == 'E', FALSE) == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    // \"g CTRL-G\": display info about cursor position\n    case Ctrl_G:\n\tcursor_pos_info(NULL);\n\tbreak;\n\n    // \"gi\": start Insert at the last position.\n    case 'i':\n\tnv_gi_cmd(cap);\n\tbreak;\n\n    // \"gI\": Start insert in column 1.\n    case 'I':\n\tbeginline(0);\n\tif (!checkclearopq(oap))\n\t    invoke_edit(cap, FALSE, 'g', FALSE);\n\tbreak;\n\n    // \"gf\": goto file, edit file under cursor\n    // \"]f\" and \"[f\": can also be used.\n    case 'f':\n    case 'F':\n\tnv_gotofile(cap);\n\tbreak;\n\n    // \"g'm\" and \"g`m\": jump to mark without setting pcmark\n    case '\\'':\n\tcap->arg = TRUE;\n\t// FALLTHROUGH\n    case '`':\n\tnv_gomark(cap);\n\tbreak;\n\n    // \"gs\": Goto sleep.\n    case 's':\n\tdo_sleep(cap->count1 * 1000L, FALSE);\n\tbreak;\n\n    // \"ga\": Display the ascii value of the character under the\n    // cursor.\tIt is displayed in decimal, hex, and octal. -- webb\n    case 'a':\n\tdo_ascii(NULL);\n\tbreak;\n\n    // \"g8\": Display the bytes used for the UTF-8 character under the\n    // cursor.\tIt is displayed in hex.\n    // \"8g8\" finds illegal byte sequence.\n    case '8':\n\tif (cap->count0 == 8)\n\t    utf_find_illegal();\n\telse\n\t    show_utf8();\n\tbreak;\n\n    // \"g<\": show scrollback text\n    case '<':\n\tshow_sb_text();\n\tbreak;\n\n    // \"gg\": Goto the first line in file.  With a count it goes to\n    // that line number like for \"G\". -- webb\n    case 'g':\n\tcap->arg = FALSE;\n\tnv_goto(cap);\n\tbreak;\n\n    //\t Two-character operators:\n    //\t \"gq\"\t    Format text\n    //\t \"gw\"\t    Format text and keep cursor position\n    //\t \"g~\"\t    Toggle the case of the text.\n    //\t \"gu\"\t    Change text to lower case.\n    //\t \"gU\"\t    Change text to upper case.\n    //   \"g?\"\t    rot13 encoding\n    //   \"g@\"\t    call 'operatorfunc'\n    case 'q':\n    case 'w':\n\toap->cursor_start = curwin->w_cursor;\n\t// FALLTHROUGH\n    case '~':\n    case 'u':\n    case 'U':\n    case '?':\n    case '@':\n\tnv_operator(cap);\n\tbreak;\n\n    // \"gd\": Find first occurrence of pattern under the cursor in the\n    //\t current function\n    // \"gD\": idem, but in the current file.\n    case 'd':\n    case 'D':\n\tnv_gd(oap, cap->nchar, (int)cap->count0);\n\tbreak;\n\n    // g<*Mouse> : <C-*mouse>\n    case K_MIDDLEMOUSE:\n    case K_MIDDLEDRAG:\n    case K_MIDDLERELEASE:\n    case K_LEFTMOUSE:\n    case K_LEFTDRAG:\n    case K_LEFTRELEASE:\n    case K_MOUSEMOVE:\n    case K_RIGHTMOUSE:\n    case K_RIGHTDRAG:\n    case K_RIGHTRELEASE:\n    case K_X1MOUSE:\n    case K_X1DRAG:\n    case K_X1RELEASE:\n    case K_X2MOUSE:\n    case K_X2DRAG:\n    case K_X2RELEASE:\n\tmod_mask = MOD_MASK_CTRL;\n\t(void)do_mouse(oap, cap->nchar, BACKWARD, cap->count1, 0);\n\tbreak;\n\n    case K_IGNORE:\n\tbreak;\n\n    // \"gP\" and \"gp\": same as \"P\" and \"p\" but leave cursor just after new text\n    case 'p':\n    case 'P':\n\tnv_put(cap);\n\tbreak;\n\n#ifdef FEAT_BYTEOFF\n    // \"go\": goto byte count from start of buffer\n    case 'o':\n\tgoto_byte(cap->count0);\n\tbreak;\n#endif\n\n    // \"gQ\": improved Ex mode\n    case 'Q':\n\tif (!check_text_locked(cap->oap) && !checkclearopq(oap))\n\t    do_exmode(TRUE);\n\tbreak;\n\n    case ',':\n\tnv_pcmark(cap);\n\tbreak;\n\n    case ';':\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n\tbreak;\n\n    case 't':\n\tif (!checkclearop(oap))\n\t    goto_tabpage((int)cap->count0);\n\tbreak;\n    case 'T':\n\tif (!checkclearop(oap))\n\t    goto_tabpage(-(int)cap->count1);\n\tbreak;\n\n    case TAB:\n\tif (!checkclearop(oap) && goto_tabpage_lastused() == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case '+':\n    case '-': // \"g+\" and \"g-\": undo or redo along the timeline\n\tif (!checkclearopq(oap))\n\t    undo_time(cap->nchar == '-' ? -cap->count1 : cap->count1,\n\t\t\t\t\t\t\t FALSE, FALSE, FALSE);\n\tbreak;\n\n    default:\n\tclearopbeep(oap);\n\tbreak;\n    }\n}\n\n/*\n * Handle \"o\" and \"O\" commands.\n */\n    static void\nn_opencmd(cmdarg_T *cap)\n{\n#ifdef FEAT_CONCEAL\n    linenr_T\toldline = curwin->w_cursor.lnum;\n#endif\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n#ifdef FEAT_FOLDING\n    if (cap->cmdchar == 'O')\n\t// Open above the first line of a folded sequence of lines\n\t(void)hasFolding(curwin->w_cursor.lnum,\n\t\t&curwin->w_cursor.lnum, NULL);\n    else\n\t// Open below the last line of a folded sequence of lines\n\t(void)hasFolding(curwin->w_cursor.lnum,\n\t\tNULL, &curwin->w_cursor.lnum);\n#endif\n    // trigger TextChangedI for the 'o/O' command\n    curbuf->b_last_changedtick_i = CHANGEDTICK(curbuf);\n    if (u_save((linenr_T)(curwin->w_cursor.lnum -\n\t\t    (cap->cmdchar == 'O' ? 1 : 0)),\n\t\t(linenr_T)(curwin->w_cursor.lnum +\n\t\t    (cap->cmdchar == 'o' ? 1 : 0))\n\t      ) == OK\n\t    && open_line(cap->cmdchar == 'O' ? BACKWARD : FORWARD,\n\t\thas_format_option(FO_OPEN_COMS) ? OPENLINE_DO_COM : 0,\n\t\t0, NULL) == OK)\n    {\n#ifdef FEAT_CONCEAL\n\tif (curwin->w_p_cole > 0 && oldline != curwin->w_cursor.lnum)\n\t    redrawWinline(curwin, oldline);\n#endif\n#ifdef FEAT_SYN_HL\n\tif (curwin->w_p_cul)\n\t    // force redraw of cursorline\n\t    curwin->w_valid &= ~VALID_CROW;\n#endif\n\t// When '#' is in 'cpoptions' ignore the count.\n\tif (vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t    cap->count1 = 1;\n\tinvoke_edit(cap, FALSE, cap->cmdchar, TRUE);\n    }\n}\n\n/*\n * \".\" command: redo last change.\n */\n    static void\nnv_dot(cmdarg_T *cap)\n{\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    // If \"restart_edit\" is TRUE, the last but one command is repeated\n    // instead of the last command (inserting text). This is used for\n    // CTRL-O <.> in insert mode.\n    if (start_redo(cap->count0, restart_edit != 0 && !arrow_used) == FAIL)\n\tclearopbeep(cap->oap);\n}\n\n/*\n * CTRL-R: undo undo or specify register in select mode\n */\n    static void\nnv_redo_or_register(cmdarg_T *cap)\n{\n    if (VIsual_select && VIsual_active)\n    {\n\tint reg;\n\t// Get register name\n\t++no_mapping;\n\t++allow_keys;\n\treg = plain_vgetc();\n\tLANGMAP_ADJUST(reg, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\n\tif (reg == '\"')\n\t    // the unnamed register is 0\n\t    reg = 0;\n\n\tVIsual_select_reg = valid_yank_reg(reg, TRUE) ? reg : 0;\n\treturn;\n    }\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    u_redo((int)cap->count1);\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * Handle \"U\" command.\n */\n    static void\nnv_Undo(cmdarg_T *cap)\n{\n    // In Visual mode and typing \"gUU\" triggers an operator\n    if (cap->oap->op_type == OP_UPPER || VIsual_active)\n    {\n\t// translate \"gUU\" to \"gUgU\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'U';\n\tnv_operator(cap);\n\treturn;\n    }\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    u_undoline();\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * '~' command: If tilde is not an operator and Visual is off: swap case of a\n * single character.\n */\n    static void\nnv_tilde(cmdarg_T *cap)\n{\n    if (!p_to && !VIsual_active && cap->oap->op_type != OP_TILDE)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf) && !prompt_curpos_editable())\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n#endif\n\tn_swapchar(cap);\n    }\n    else\n\tnv_operator(cap);\n}\n\n/*\n * Handle an operator command.\n * The actual work is done by do_pending_operator().\n */\n    static void\nnv_operator(cmdarg_T *cap)\n{\n    int\t    op_type;\n\n    op_type = get_op_type(cap->cmdchar, cap->nchar);\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && op_is_change(op_type) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    if (op_type == cap->oap->op_type)\t    // double operator works on lines\n\tnv_lineop(cap);\n    else if (!checkclearop(cap->oap))\n    {\n\tcap->oap->start = curwin->w_cursor;\n\tcap->oap->op_type = op_type;\n#ifdef FEAT_EVAL\n\tset_op_var(op_type);\n#endif\n    }\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:operator to the characters for \"optype\".\n */\n    static void\nset_op_var(int optype)\n{\n    char_u\topchars[3];\n\n    if (optype == OP_NOP)\n\tset_vim_var_string(VV_OP, NULL, 0);\n    else\n    {\n\topchars[0] = get_op_char(optype);\n\topchars[1] = get_extra_op_char(optype);\n\topchars[2] = NUL;\n\tset_vim_var_string(VV_OP, opchars, -1);\n    }\n}\n#endif\n\n/*\n * Handle linewise operator \"dd\", \"yy\", etc.\n *\n * \"_\" is is a strange motion command that helps make operators more logical.\n * It is actually implemented, but not documented in the real Vi.  This motion\n * command actually refers to \"the current line\".  Commands like \"dd\" and \"yy\"\n * are really an alternate form of \"d_\" and \"y_\".  It does accept a count, so\n * \"d3_\" works to delete 3 lines.\n */\n    static void\nnv_lineop(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MLINE;\n    if (cursor_down(cap->count1 - 1L, cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n    else if (  (cap->oap->op_type == OP_DELETE // only with linewise motions\n\t\t&& cap->oap->motion_force != 'v'\n\t\t&& cap->oap->motion_force != Ctrl_V)\n\t    || cap->oap->op_type == OP_LSHIFT\n\t    || cap->oap->op_type == OP_RSHIFT)\n\tbeginline(BL_SOL | BL_FIX);\n    else if (cap->oap->op_type != OP_YANK)\t// 'Y' does not move cursor\n\tbeginline(BL_WHITE | BL_FIX);\n}\n\n/*\n * <Home> command.\n */\n    static void\nnv_home(cmdarg_T *cap)\n{\n    // CTRL-HOME is like \"gg\"\n    if (mod_mask & MOD_MASK_CTRL)\n\tnv_goto(cap);\n    else\n    {\n\tcap->count0 = 1;\n\tnv_pipe(cap);\n    }\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * \"|\" command.\n */\n    static void\nnv_pipe(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(0);\n    if (cap->count0 > 0)\n    {\n\tcoladvance((colnr_T)(cap->count0 - 1));\n\tcurwin->w_curswant = (colnr_T)(cap->count0 - 1);\n    }\n    else\n\tcurwin->w_curswant = 0;\n    // keep curswant at the column where we wanted to go, not where\n    // we ended; differs if line is too short\n    curwin->w_set_curswant = FALSE;\n}\n\n/*\n * Handle back-word command \"b\" and \"B\".\n * cap->arg is 1 for \"B\"\n */\n    static void\nnv_bck_word(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n    if (bck_word(cap->count1, cap->arg, FALSE) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle word motion commands \"e\", \"E\", \"w\" and \"W\".\n * cap->arg is TRUE for \"E\" and \"W\".\n */\n    static void\nnv_wordcmd(cmdarg_T *cap)\n{\n    int\t\tn;\n    int\t\tword_end;\n    int\t\tflag = FALSE;\n    pos_T\tstartpos = curwin->w_cursor;\n\n    // Set inclusive for the \"E\" and \"e\" command.\n    if (cap->cmdchar == 'e' || cap->cmdchar == 'E')\n\tword_end = TRUE;\n    else\n\tword_end = FALSE;\n    cap->oap->inclusive = word_end;\n\n    // \"cw\" and \"cW\" are a special case.\n    if (!word_end && cap->oap->op_type == OP_CHANGE)\n    {\n\tn = gchar_cursor();\n\tif (n != NUL)\t\t\t// not an empty line\n\t{\n\t    if (VIM_ISWHITE(n))\n\t    {\n\t\t// Reproduce a funny Vi behaviour: \"cw\" on a blank only\n\t\t// changes one character, not all blanks until the start of\n\t\t// the next word.  Only do this when the 'w' flag is included\n\t\t// in 'cpoptions'.\n\t\tif (cap->count1 == 1 && vim_strchr(p_cpo, CPO_CW) != NULL)\n\t\t{\n\t\t    cap->oap->inclusive = TRUE;\n\t\t    cap->oap->motion_type = MCHAR;\n\t\t    return;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// This is a little strange. To match what the real Vi does,\n\t\t// we effectively map 'cw' to 'ce', and 'cW' to 'cE', provided\n\t\t// that we are not on a space or a TAB.  This seems impolite\n\t\t// at first, but it's really more what we mean when we say\n\t\t// 'cw'.\n\t\t// Another strangeness: When standing on the end of a word\n\t\t// \"ce\" will change until the end of the next word, but \"cw\"\n\t\t// will change only one character! This is done by setting\n\t\t// flag.\n\t\tcap->oap->inclusive = TRUE;\n\t\tword_end = TRUE;\n\t\tflag = TRUE;\n\t    }\n\t}\n    }\n\n    cap->oap->motion_type = MCHAR;\n    curwin->w_set_curswant = TRUE;\n    if (word_end)\n\tn = end_word(cap->count1, cap->arg, flag, FALSE);\n    else\n\tn = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);\n\n    // Don't leave the cursor on the NUL past the end of line. Unless we\n    // didn't move it forward.\n    if (LT_POS(startpos, curwin->w_cursor))\n\tadjust_cursor(cap->oap);\n\n    if (n == FAIL && cap->oap->op_type == OP_NOP)\n\tclearopbeep(cap->oap);\n    else\n    {\n\tadjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * Used after a movement command: If the cursor ends up on the NUL after the\n * end of the line, may move it back to the last character and make the motion\n * inclusive.\n */\n    static void\nadjust_cursor(oparg_T *oap)\n{\n    // The cursor cannot remain on the NUL when:\n    // - the column is > 0\n    // - not in Visual mode or 'selection' is \"o\"\n    // - 'virtualedit' is not \"all\" and not \"onemore\".\n    if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL\n\t\t&& (!VIsual_active || *p_sel == 'o')\n\t\t&& !virtual_active() && (get_ve_flags() & VE_ONEMORE) == 0)\n    {\n\t--curwin->w_cursor.col;\n\t// prevent cursor from moving on the trail byte\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\toap->inclusive = TRUE;\n    }\n}\n\n/*\n * \"0\" and \"^\" commands.\n * cap->arg is the argument for beginline().\n */\n    static void\nnv_beginline(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(cap->arg);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * In exclusive Visual mode, may include the last character.\n */\n    static void\nadjust_for_sel(cmdarg_T *cap)\n{\n    if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'\n\t    && gchar_cursor() != NUL && LT_POS(VIsual, curwin->w_cursor))\n    {\n\tif (has_mbyte)\n\t    inc_cursor();\n\telse\n\t    ++curwin->w_cursor.col;\n\tcap->oap->inclusive = FALSE;\n    }\n}\n\n/*\n * Exclude last character at end of Visual area for 'selection' == \"exclusive\".\n * Should check VIsual_mode before calling this.\n * Returns TRUE when backed up to the previous line.\n */\n    int\nunadjust_for_sel(void)\n{\n    pos_T\t*pp;\n\n    if (*p_sel == 'e' && !EQUAL_POS(VIsual, curwin->w_cursor))\n    {\n\tif (LT_POS(VIsual, curwin->w_cursor))\n\t    pp = &curwin->w_cursor;\n\telse\n\t    pp = &VIsual;\n\tif (pp->coladd > 0)\n\t    --pp->coladd;\n\telse\n\tif (pp->col > 0)\n\t{\n\t    --pp->col;\n\t    mb_adjustpos(curbuf, pp);\n\t}\n\telse if (pp->lnum > 1)\n\t{\n\t    --pp->lnum;\n\t    pp->col = (colnr_T)STRLEN(ml_get(pp->lnum));\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * SELECT key in Normal or Visual mode: end of Select mode mapping.\n */\n    static void\nnv_select(cmdarg_T *cap)\n{\n    if (VIsual_active)\n    {\n\tVIsual_select = TRUE;\n\tVIsual_select_reg = 0;\n    }\n    else if (VIsual_reselect)\n    {\n\tcap->nchar = 'v';\t    // fake \"gv\" command\n\tcap->arg = TRUE;\n\tnv_g_cmd(cap);\n    }\n}\n\n\n/*\n * \"G\", \"gg\", CTRL-END, CTRL-HOME.\n * cap->arg is TRUE for \"G\".\n */\n    static void\nnv_goto(cmdarg_T *cap)\n{\n    linenr_T\tlnum;\n\n    if (cap->arg)\n\tlnum = curbuf->b_ml.ml_line_count;\n    else\n\tlnum = 1L;\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    // When a count is given, use it instead of the default lnum\n    if (cap->count0 != 0)\n\tlnum = cap->count0;\n    if (lnum < 1L)\n\tlnum = 1L;\n    else if (lnum > curbuf->b_ml.ml_line_count)\n\tlnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.lnum = lnum;\n    beginline(BL_SOL | BL_FIX);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_JUMP) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * CTRL-\\ in Normal mode.\n */\n    static void\nnv_normal(cmdarg_T *cap)\n{\n    if (cap->nchar == Ctrl_N || cap->nchar == Ctrl_G)\n    {\n\tclearop(cap->oap);\n\tif (restart_edit != 0 && mode_displayed)\n\t    clear_cmdline = TRUE;\t\t// unshow mode later\n\trestart_edit = 0;\n\tif (cmdwin_type != 0)\n\t    cmdwin_result = Ctrl_C;\n\tif (VIsual_active)\n\t{\n\t    end_visual_mode();\t\t// stop Visual\n\t    redraw_curbuf_later(UPD_INVERTED);\n\t}\n\t// CTRL-\\ CTRL-G restarts Insert mode when 'insertmode' is set.\n\tif (cap->nchar == Ctrl_G && p_im)\n\t    restart_edit = 'a';\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * ESC in Normal mode: beep, but don't flush buffers.\n * Don't even beep if we are canceling a command.\n */\n    static void\nnv_esc(cmdarg_T *cap)\n{\n    int\t\tno_reason;\n\n    no_reason = (cap->oap->op_type == OP_NOP\n\t\t&& cap->opcount == 0\n\t\t&& cap->count0 == 0\n\t\t&& cap->oap->regname == 0\n\t\t&& !p_im);\n\n    if (cap->arg)\t\t// TRUE for CTRL-C\n    {\n\tif (restart_edit == 0 && cmdwin_type == 0\n\t\t\t\t\t\t&& !VIsual_active && no_reason)\n\t{\n\t    int\tout_redir = !stdout_isatty && !is_not_a_term_or_gui();\n\n\t    // The user may accidentally do \"vim file | grep word\" and then\n\t    // CTRL-C doesn't show anything.  With a changed buffer give the\n\t    // message on stderr.  Without any changes might as well exit.\n\t    if (anyBufIsChanged())\n\t    {\n\t\tchar *ms = _(\"Type  :qa!  and press <Enter> to abandon all changes and exit Vim\");\n\n\t\tif (out_redir)\n\t\t    mch_errmsg(ms);\n\t\telse\n\t\t    msg(ms);\n\t    }\n\t    else\n\t    {\n\t\tif (out_redir)\n\t\t{\n\t\t    got_int = FALSE;\n\t\t    do_cmdline_cmd((char_u *)\"qa\");\n\t\t}\n\t\telse\n\t\t    msg(_(\"Type  :qa  and press <Enter> to exit Vim\"));\n\t    }\n\t}\n\n\tif (restart_edit != 0)\n\t    redraw_mode = TRUE;  // remove \"-- (insert) --\"\n\n\t// Don't reset \"restart_edit\" when 'insertmode' is set, it won't be\n\t// set again below when halfway a mapping.\n\tif (!p_im)\n\t    restart_edit = 0;\n\tif (cmdwin_type != 0)\n\t{\n\t    cmdwin_result = K_IGNORE;\n\t    got_int = FALSE;\t// don't stop executing autocommands et al.\n\t    return;\n\t}\n    }\n    else if (cmdwin_type != 0 && ex_normal_busy && typebuf_was_empty)\n    {\n\t// When :normal runs out of characters while in the command line window\n\t// vgetorpeek() will repeatedly return ESC.  Exit the cmdline window to\n\t// break the loop.\n\tcmdwin_result = K_IGNORE;\n\treturn;\n    }\n\n    if (VIsual_active)\n    {\n\tend_visual_mode();\t// stop Visual\n\tcheck_cursor_col();\t// make sure cursor is not beyond EOL\n\tcurwin->w_set_curswant = TRUE;\n\tredraw_curbuf_later(UPD_INVERTED);\n    }\n    else if (no_reason)\n    {\n#ifdef HAS_MESSAGE_WINDOW\n\tif (!cap->arg && popup_message_win_visible())\n\t    popup_hide_message_win();\n\telse\n#endif\n\t    vim_beep(BO_ESC);\n    }\n    clearop(cap->oap);\n\n    // A CTRL-C is often used at the start of a menu.  When 'insertmode' is\n    // set return to Insert mode afterwards.\n    if (restart_edit == 0 && goto_im() && ex_normal_busy == 0)\n\trestart_edit = 'a';\n}\n\n/*\n * Move the cursor for the \"A\" command.\n */\n    void\nset_cursor_for_append_to_line(void)\n{\n    curwin->w_set_curswant = TRUE;\n    if (get_ve_flags() == VE_ALL)\n    {\n\tint save_State = State;\n\n\t// Pretend Insert mode here to allow the cursor on the\n\t// character past the end of the line\n\tState = MODE_INSERT;\n\tcoladvance((colnr_T)MAXCOL);\n\tState = save_State;\n    }\n    else\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(ml_get_cursor());\n}\n\n/*\n * Handle \"A\", \"a\", \"I\", \"i\" and <Insert> commands.\n * Also handle K_PS, start bracketed paste.\n */\n    static void\nnv_edit(cmdarg_T *cap)\n{\n    // <Insert> is equal to \"i\"\n    if (cap->cmdchar == K_INS || cap->cmdchar == K_KINS)\n\tcap->cmdchar = 'i';\n\n    // in Visual mode \"A\" and \"I\" are an operator\n    if (VIsual_active && (cap->cmdchar == 'A' || cap->cmdchar == 'I'))\n    {\n#ifdef FEAT_TERMINAL\n\tif (term_in_normal_mode())\n\t{\n\t    end_visual_mode();\n\t    clearop(cap->oap);\n\t    term_enter_job_mode();\n\t    return;\n\t}\n#endif\n\tv_visop(cap);\n    }\n\n    // in Visual mode and after an operator \"a\" and \"i\" are for text objects\n    else if ((cap->cmdchar == 'a' || cap->cmdchar == 'i')\n\t    && (cap->oap->op_type != OP_NOP || VIsual_active))\n    {\n\tnv_object(cap);\n    }\n#ifdef FEAT_TERMINAL\n    else if (term_in_normal_mode())\n    {\n\tclearop(cap->oap);\n\tterm_enter_job_mode();\n\treturn;\n    }\n#endif\n    else if (!curbuf->b_p_ma && !p_im)\n    {\n\t// Only give this error when 'insertmode' is off.\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\tclearop(cap->oap);\n\tif (cap->cmdchar == K_PS)\n\t    // drop the pasted text\n\t    bracketed_paste(PASTE_INSERT, TRUE, NULL);\n    }\n    else if (cap->cmdchar == K_PS && VIsual_active)\n    {\n\tpos_T old_pos = curwin->w_cursor;\n\tpos_T old_visual = VIsual;\n\tint old_visual_mode = VIsual_mode;\n\n\t// In Visual mode the selected text is deleted.\n\tif (VIsual_mode == 'V' || curwin->w_cursor.lnum != VIsual.lnum)\n\t{\n\t    shift_delete_registers();\n\t    cap->oap->regname = '1';\n\t}\n\telse\n\t    cap->oap->regname = '-';\n\tcap->cmdchar = 'd';\n\tcap->nchar = NUL;\n\tnv_operator(cap);\n\tdo_pending_operator(cap, 0, FALSE);\n\tcap->cmdchar = K_PS;\n\n\tif (*ml_get_cursor() != NUL)\n\t{\n\t    if (old_visual_mode == 'V')\n\t    {\n\t\t// In linewise Visual mode insert before the beginning of the\n\t\t// next line.\n\t\t// When the last line in the buffer was deleted then create a\n\t\t// new line, otherwise there is not need to move cursor.\n\t\t// Detect this by checking if cursor moved above Visual area.\n\t\tif (curwin->w_cursor.lnum < old_pos.lnum\n\t\t\t\t&& curwin->w_cursor.lnum < old_visual.lnum)\n\t\t{\n\t\t    if (u_save_cursor() == OK)\n\t\t    {\n\t\t\tml_append(curwin->w_cursor.lnum, (char_u *)\"\", 0,\n\t\t\t\t\t\t\t\t\tFALSE);\n\t\t\tappended_lines(curwin->w_cursor.lnum++, 1L);\n\t\t    }\n\t\t}\n\t    }\n\t    // When the last char in the line was deleted then append.\n\t    // Detect this by checking if cursor moved before Visual area.\n\t    else if (curwin->w_cursor.col < old_pos.col\n\t\t\t\t&& curwin->w_cursor.col < old_visual.col)\n\t\tinc_cursor();\n\t}\n\n\t// Insert to replace the deleted text with the pasted text.\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tswitch (cap->cmdchar)\n\t{\n\t    case 'A':\t// \"A\"ppend after the line\n\t\tset_cursor_for_append_to_line();\n\t\tbreak;\n\n\t    case 'I':\t// \"I\"nsert before the first non-blank\n\t\tif (vim_strchr(p_cpo, CPO_INSEND) == NULL)\n\t\t    beginline(BL_WHITE);\n\t\telse\n\t\t    beginline(BL_WHITE|BL_FIX);\n\t\tbreak;\n\n\t    case K_PS:\n\t\t// Bracketed paste works like \"a\"ppend, unless the cursor is in\n\t\t// the first column, then it inserts.\n\t\tif (curwin->w_cursor.col == 0)\n\t\t    break;\n\t\t// FALLTHROUGH\n\n\t    case 'a':\t// \"a\"ppend is like \"i\"nsert on the next character.\n\t\t// increment coladd when in virtual space, increment the\n\t\t// column otherwise, also to append after an unprintable char\n\t\tif (virtual_active()\n\t\t\t&& (curwin->w_cursor.coladd > 0\n\t\t\t    || *ml_get_cursor() == NUL\n\t\t\t    || *ml_get_cursor() == TAB))\n\t\t    curwin->w_cursor.coladd++;\n\t\telse if (*ml_get_cursor() != NUL)\n\t\t    inc_cursor();\n\t\tbreak;\n\t}\n\n\tif (curwin->w_cursor.coladd && cap->cmdchar != 'A')\n\t{\n\t    int save_State = State;\n\n\t    // Pretend Insert mode here to allow the cursor on the\n\t    // character past the end of the line\n\t    State = MODE_INSERT;\n\t    coladvance(getviscol());\n\t    State = save_State;\n\t}\n\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (cap->cmdchar == K_PS)\n\t// drop the pasted text\n\tbracketed_paste(PASTE_INSERT, TRUE, NULL);\n}\n\n/*\n * Invoke edit() and take care of \"restart_edit\" and the return value.\n */\n    static void\ninvoke_edit(\n    cmdarg_T\t*cap,\n    int\t\trepl,\t\t// \"r\" or \"gr\" command\n    int\t\tcmd,\n    int\t\tstartln)\n{\n    int\t\trestart_edit_save = 0;\n\n    // Complicated: When the user types \"a<C-O>a\" we don't want to do Insert\n    // mode recursively.  But when doing \"a<C-O>.\" or \"a<C-O>rx\" we do allow\n    // it.\n    if (repl || !stuff_empty())\n\trestart_edit_save = restart_edit;\n    else\n\trestart_edit_save = 0;\n\n    // Always reset \"restart_edit\", this is not a restarted edit.\n    restart_edit = 0;\n\n    // Reset Changedtick_i, so that TextChangedI will only be triggered for stuff\n    // from insert mode, for 'o/O' this has already been done in n_opencmd\n    if (cap->cmdchar != 'O' && cap->cmdchar != 'o')\n\tcurbuf->b_last_changedtick_i = CHANGEDTICK(curbuf);\n    if (edit(cmd, startln, cap->count1))\n\tcap->retval |= CA_COMMAND_BUSY;\n\n    if (restart_edit == 0)\n\trestart_edit = restart_edit_save;\n}\n\n/*\n * \"a\" or \"i\" while an operator is pending or in Visual mode: object motion.\n */\n    static void\nnv_object(\n    cmdarg_T\t*cap)\n{\n    int\t\tflag;\n    int\t\tinclude;\n    char_u\t*mps_save;\n\n    if (cap->cmdchar == 'i')\n\tinclude = FALSE;    // \"ix\" = inner object: exclude white space\n    else\n\tinclude = TRUE;\t    // \"ax\" = an object: include white space\n\n    // Make sure (), [], {} and <> are in 'matchpairs'\n    mps_save = curbuf->b_p_mps;\n    curbuf->b_p_mps = (char_u *)\"(:),{:},[:],<:>\";\n\n    switch (cap->nchar)\n    {\n\tcase 'w': // \"aw\" = a word\n\t\tflag = current_word(cap->oap, cap->count1, include, FALSE);\n\t\tbreak;\n\tcase 'W': // \"aW\" = a WORD\n\t\tflag = current_word(cap->oap, cap->count1, include, TRUE);\n\t\tbreak;\n\tcase 'b': // \"ab\" = a braces block\n\tcase '(':\n\tcase ')':\n\t\tflag = current_block(cap->oap, cap->count1, include, '(', ')');\n\t\tbreak;\n\tcase 'B': // \"aB\" = a Brackets block\n\tcase '{':\n\tcase '}':\n\t\tflag = current_block(cap->oap, cap->count1, include, '{', '}');\n\t\tbreak;\n\tcase '[': // \"a[\" = a [] block\n\tcase ']':\n\t\tflag = current_block(cap->oap, cap->count1, include, '[', ']');\n\t\tbreak;\n\tcase '<': // \"a<\" = a <> block\n\tcase '>':\n\t\tflag = current_block(cap->oap, cap->count1, include, '<', '>');\n\t\tbreak;\n#ifdef FEAT_EVAL\n\tcase 't': // \"at\" = a tag block (xml and html)\n\t\t// Do not adjust oap->end in do_pending_operator()\n\t\t// otherwise there are different results for 'dit'\n\t\t// (note leading whitespace in last line):\n\t\t// 1) <b>      2) <b>\n\t\t//    foobar      foobar\n\t\t//    </b>            </b>\n\t\tcap->retval |= CA_NO_ADJ_OP_END;\n\t\tflag = current_tagblock(cap->oap, cap->count1, include);\n\t\tbreak;\n#endif\n\tcase 'p': // \"ap\" = a paragraph\n\t\tflag = current_par(cap->oap, cap->count1, include, 'p');\n\t\tbreak;\n\tcase 's': // \"as\" = a sentence\n\t\tflag = current_sent(cap->oap, cap->count1, include);\n\t\tbreak;\n\tcase '\"': // \"a\"\" = a double quoted string\n\tcase '\\'': // \"a'\" = a single quoted string\n\tcase '`': // \"a`\" = a backtick quoted string\n\t\tflag = current_quote(cap->oap, cap->count1, include,\n\t\t\t\t\t\t\t\t  cap->nchar);\n\t\tbreak;\n#if 0\t// TODO\n\tcase 'S': // \"aS\" = a section\n\tcase 'f': // \"af\" = a filename\n\tcase 'u': // \"au\" = a URL\n#endif\n\tdefault:\n\t\tflag = FAIL;\n\t\tbreak;\n    }\n\n    curbuf->b_p_mps = mps_save;\n    if (flag == FAIL)\n\tclearopbeep(cap->oap);\n    adjust_cursor_col();\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * \"q\" command: Start/stop recording.\n * \"q:\", \"q/\", \"q?\": edit command-line in command-line window.\n */\n    static void\nnv_record(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_FORMAT)\n    {\n\t// \"gqq\" is the same as \"gqgq\": format line\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'q';\n\tnv_operator(cap);\n\treturn;\n    }\n\n    if (checkclearop(cap->oap))\n\treturn;\n\n    if (cap->nchar == ':' || cap->nchar == '/' || cap->nchar == '?')\n    {\n\tif (cmdwin_type != 0)\n\t{\n\t    emsg(_(e_cmdline_window_already_open));\n\t    return;\n\t}\n\tstuffcharReadbuff(cap->nchar);\n\tstuffcharReadbuff(K_CMDWIN);\n    }\n    else\n\t// (stop) recording into a named register, unless executing a\n\t// register\n\tif (reg_executing == 0 && do_record(cap->nchar) == FAIL)\n\t    clearopbeep(cap->oap);\n}\n\n/*\n * Handle the \"@r\" command.\n */\n    static void\nnv_at(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n    {\n\tif (get_expr_register() == NUL)\n\t    return;\n    }\n#endif\n    while (cap->count1-- && !got_int)\n    {\n\tif (do_execreg(cap->nchar, FALSE, FALSE, FALSE) == FAIL)\n\t{\n\t    clearopbeep(cap->oap);\n\t    break;\n\t}\n\tline_breakcheck();\n    }\n}\n\n/*\n * Handle the CTRL-U and CTRL-D commands.\n */\n    static void\nnv_halfpage(cmdarg_T *cap)\n{\n    if ((cap->cmdchar == Ctrl_U && curwin->w_cursor.lnum == 1)\n\t    || (cap->cmdchar == Ctrl_D\n\t\t&& curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count))\n\tclearopbeep(cap->oap);\n    else if (!checkclearop(cap->oap))\n\thalfpage(cap->cmdchar == Ctrl_D, cap->count0);\n}\n\n/*\n * Handle \"J\" or \"gJ\" command.\n */\n    static void\nnv_join(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// join the visual lines\n    {\n\tnv_operator(cap);\n\treturn;\n    }\n\n    if (checkclearop(cap->oap))\n\treturn;\n\n    if (cap->count0 <= 1)\n\tcap->count0 = 2;\t    // default for join is two lines!\n    if (curwin->w_cursor.lnum + cap->count0 - 1 >\n\t    curbuf->b_ml.ml_line_count)\n    {\n\t// can't join when on the last line\n\tif (cap->count0 <= 2)\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n\tcap->count0 = curbuf->b_ml.ml_line_count\n\t    - curwin->w_cursor.lnum + 1;\n    }\n\n    prep_redo(cap->oap->regname, cap->count0,\n\t    NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n    (void)do_join(cap->count0, cap->nchar == NUL, TRUE, TRUE, TRUE);\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n */\n    static void\nnv_put(cmdarg_T *cap)\n{\n    nv_put_opt(cap, FALSE);\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n * \"fix_indent\" is TRUE for \"[p\", \"[P\", \"]p\" and \"]P\".\n */\n    static void\nnv_put_opt(cmdarg_T *cap, int fix_indent)\n{\n    int\t\tregname = 0;\n    void\t*reg1 = NULL, *reg2 = NULL;\n    int\t\tempty = FALSE;\n    int\t\twas_visual = FALSE;\n    int\t\tdir;\n    int\t\tflags = 0;\n    int\t\tkeep_registers = FALSE;\n\n    if (cap->oap->op_type != OP_NOP)\n    {\n#ifdef FEAT_DIFF\n\t// \"dp\" is \":diffput\"\n\tif (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'p')\n\t{\n\t    clearop(cap->oap);\n\t    nv_diffgetput(TRUE, cap->opcount);\n\t}\n\telse\n#endif\n\t    clearopbeep(cap->oap);\n\treturn;\n    }\n\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    if (fix_indent)\n    {\n\tdir = (cap->cmdchar == ']' && cap->nchar == 'p')\n\t    ? FORWARD : BACKWARD;\n\tflags |= PUT_FIXINDENT;\n    }\n    else\n\tdir = (cap->cmdchar == 'P'\n\t\t|| ((cap->cmdchar == 'g' || cap->cmdchar == 'z')\n\t\t    && cap->nchar == 'P')) ? BACKWARD : FORWARD;\n    prep_redo_cmd(cap);\n    if (cap->cmdchar == 'g')\n\tflags |= PUT_CURSEND;\n    else if (cap->cmdchar == 'z')\n\tflags |= PUT_BLOCK_INNER;\n\n    if (VIsual_active)\n    {\n\t// Putting in Visual mode: The put text replaces the selected\n\t// text.  First delete the selected text, then put the new text.\n\t// Need to save and restore the registers that the delete\n\t// overwrites if the old contents is being put.\n\twas_visual = TRUE;\n\tregname = cap->oap->regname;\n\tkeep_registers = cap->cmdchar == 'P';\n#ifdef FEAT_CLIPBOARD\n\tadjust_clip_reg(&regname);\n#endif\n\tif (regname == 0 || regname == '\"'\n\t\t|| VIM_ISDIGIT(regname) || regname == '-'\n#ifdef FEAT_CLIPBOARD\n\t\t|| (clip_unnamed && (regname == '*' || regname == '+'))\n#endif\n\n\t   )\n\t{\n\t    // The delete is going to overwrite the register we want to\n\t    // put, save it first.\n\t    reg1 = get_register(regname, TRUE);\n\t}\n\n\t// Now delete the selected text. Avoid messages here.\n\tcap->cmdchar = 'd';\n\tcap->nchar = NUL;\n\tcap->oap->regname = keep_registers ? '_' : NUL;\n\t++msg_silent;\n\tnv_operator(cap);\n\tdo_pending_operator(cap, 0, FALSE);\n\tempty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n\t--msg_silent;\n\n\t// delete PUT_LINE_BACKWARD;\n\tcap->oap->regname = regname;\n\n\tif (reg1 != NULL)\n\t{\n\t    // Delete probably changed the register we want to put, save\n\t    // it first. Then put back what was there before the delete.\n\t    reg2 = get_register(regname, FALSE);\n\t    put_register(regname, reg1);\n\t}\n\n\t// When deleted a linewise Visual area, put the register as\n\t// lines to avoid it joined with the next line.  When deletion was\n\t// characterwise, split a line when putting lines.\n\tif (VIsual_mode == 'V')\n\t    flags |= PUT_LINE;\n\telse if (VIsual_mode == 'v')\n\t    flags |= PUT_LINE_SPLIT;\n\tif (VIsual_mode == Ctrl_V && dir == FORWARD)\n\t    flags |= PUT_LINE_FORWARD;\n\tdir = BACKWARD;\n\tif ((VIsual_mode != 'V'\n\t\t    && curwin->w_cursor.col < curbuf->b_op_start.col)\n\t\t|| (VIsual_mode == 'V'\n\t\t    && curwin->w_cursor.lnum < curbuf->b_op_start.lnum))\n\t    // cursor is at the end of the line or end of file, put\n\t    // forward.\n\t    dir = FORWARD;\n\t// May have been reset in do_put().\n\tVIsual_active = TRUE;\n    }\n    do_put(cap->oap->regname, NULL, dir, cap->count1, flags);\n\n    // If a register was saved, put it back now.\n    if (reg2 != NULL)\n\tput_register(regname, reg2);\n\n    // What to reselect with \"gv\"?  Selecting the just put text seems to\n    // be the most useful, since the original text was removed.\n    if (was_visual)\n    {\n\tcurbuf->b_visual.vi_start = curbuf->b_op_start;\n\tcurbuf->b_visual.vi_end = curbuf->b_op_end;\n\t// need to adjust cursor position\n\tif (*p_sel == 'e')\n\t    inc(&curbuf->b_visual.vi_end);\n    }\n\n    // When all lines were selected and deleted do_put() leaves an empty\n    // line that needs to be deleted now.\n    if (empty && *ml_get(curbuf->b_ml.ml_line_count) == NUL)\n    {\n\tml_delete_flags(curbuf->b_ml.ml_line_count, ML_DEL_MESSAGE);\n\tdeleted_lines(curbuf->b_ml.ml_line_count + 1, 1);\n\n\t// If the cursor was in that line, move it to the end of the last\n\t// line.\n\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t{\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    coladvance((colnr_T)MAXCOL);\n\t}\n    }\n    auto_format(FALSE, TRUE);\n}\n\n/*\n * \"o\" and \"O\" commands.\n */\n    static void\nnv_open(cmdarg_T *cap)\n{\n#ifdef FEAT_DIFF\n    // \"do\" is \":diffget\"\n    if (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'o')\n    {\n\tclearop(cap->oap);\n\tnv_diffgetput(FALSE, cap->opcount);\n    }\n    else\n#endif\n    if (VIsual_active)  // switch start and end of visual\n\tv_swap_corners(cap->cmdchar);\n#ifdef FEAT_JOB_CHANNEL\n    else if (bt_prompt(curbuf))\n\tclearopbeep(cap->oap);\n#endif\n    else\n\tn_opencmd(cap);\n}\n\n#ifdef FEAT_NETBEANS_INTG\n    static void\nnv_nbcmd(cmdarg_T *cap)\n{\n    netbeans_keycommand(cap->nchar);\n}\n#endif\n\n#ifdef FEAT_DND\n    static void\nnv_drop(cmdarg_T *cap UNUSED)\n{\n    do_put('~', NULL, BACKWARD, 1L, PUT_CURSEND);\n}\n#endif\n\n/*\n * Trigger CursorHold event.\n * When waiting for a character for 'updatetime' K_CURSORHOLD is put in the\n * input buffer.  \"did_cursorhold\" is set to avoid retriggering.\n */\n    static void\nnv_cursorhold(cmdarg_T *cap)\n{\n    apply_autocmds(EVENT_CURSORHOLD, NULL, NULL, FALSE, curbuf);\n    did_cursorhold = TRUE;\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n", "\" Test for various Normal mode commands\n\nsource shared.vim\nsource check.vim\nsource view_util.vim\nimport './vim9.vim' as v9\nsource screendump.vim\n\nfunc Setup_NewWindow()\n  10new\n  call setline(1, range(1,100))\nendfunc\n\nfunc MyFormatExpr()\n  \" Adds '->$' at lines having numbers followed by trailing whitespace\n  for ln in range(v:lnum, v:lnum+v:count-1)\n    let line = getline(ln)\n    if getline(ln) =~# '\\d\\s\\+$'\n      call setline(ln, substitute(line, '\\s\\+$', '', '') . '->$')\n    endif\n  endfor\nendfunc\n\nfunc CountSpaces(type, ...)\n  \" for testing operatorfunc\n  \" will count the number of spaces\n  \" and return the result in g:a\n  let sel_save = &selection\n  let &selection = \"inclusive\"\n  let reg_save = @@\n\n  if a:0  \" Invoked from Visual mode, use gv command.\n    silent exe \"normal! gvy\"\n  elseif a:type == 'line'\n    silent exe \"normal! '[V']y\"\n  else\n    silent exe \"normal! `[v`]y\"\n  endif\n  let g:a = strlen(substitute(@@, '[^ ]', '', 'g'))\n  let &selection = sel_save\n  let @@ = reg_save\nendfunc\n\nfunc OpfuncDummy(type, ...)\n  \" for testing operatorfunc\n  let g:opt = &linebreak\n\n  if a:0  \" Invoked from Visual mode, use gv command.\n    silent exe \"normal! gvy\"\n  elseif a:type == 'line'\n    silent exe \"normal! '[V']y\"\n  else\n    silent exe \"normal! `[v`]y\"\n  endif\n  \" Create a new dummy window\n  new\n  let g:bufnr = bufnr('%')\nendfunc\n\nfunc Test_normal00_optrans()\n  new\n  call append(0, ['1 This is a simple test: abcd', '2 This is the second line', '3 this is the third line'])\n  1\n  exe \"norm! Sfoobar\\<esc>\"\n  call assert_equal(['foobar', '2 This is the second line', '3 this is the third line', ''], getline(1,'$'))\n  2\n  exe \"norm! $vbsone\"\n  call assert_equal(['foobar', '2 This is the second one', '3 this is the third line', ''], getline(1,'$'))\n  norm! VS Second line here\n  call assert_equal(['foobar', ' Second line here', '3 this is the third line', ''], getline(1, '$'))\n  %d\n  call append(0, ['4 This is a simple test: abcd', '5 This is the second line', '6 this is the third line'])\n  call append(0, ['1 This is a simple test: abcd', '2 This is the second line', '3 this is the third line'])\n\n  1\n  norm! 2D\n  call assert_equal(['3 this is the third line', '4 This is a simple test: abcd', '5 This is the second line', '6 this is the third line', ''], getline(1,'$'))\n  set cpo+=#\n  norm! 4D\n  call assert_equal(['', '4 This is a simple test: abcd', '5 This is the second line', '6 this is the third line', ''], getline(1,'$'))\n\n  \" clean up\n  set cpo-=#\n  bw!\nendfunc\n\nfunc Test_normal01_keymodel()\n  call Setup_NewWindow()\n  \" Test 1: depending on 'keymodel' <s-down> does something different\n  50\n  call feedkeys(\"V\\<S-Up>y\", 'tx')\n  call assert_equal(['47', '48', '49', '50'], getline(\"'<\", \"'>\"))\n  set keymodel=startsel\n  50\n  call feedkeys(\"V\\<S-Up>y\", 'tx')\n  call assert_equal(['49', '50'], getline(\"'<\", \"'>\"))\n  \" Start visual mode when keymodel = startsel\n  50\n  call feedkeys(\"\\<S-Up>y\", 'tx')\n  call assert_equal(['49', '5'], getreg(0, 0, 1))\n  \" Use the different Shift special keys\n  50\n  call feedkeys(\"\\<S-Right>\\<S-Left>\\<S-Up>\\<S-Down>\\<S-Home>\\<S-End>y\", 'tx')\n  call assert_equal(['50'], getline(\"'<\", \"'>\"))\n  call assert_equal(['50', ''], getreg(0, 0, 1))\n\n  \" Do not start visual mode when keymodel=\n  set keymodel=\n  50\n  call feedkeys(\"\\<S-Up>y$\", 'tx')\n  call assert_equal(['42'], getreg(0, 0, 1))\n  \" Stop visual mode when keymodel=stopsel\n  set keymodel=stopsel\n  50\n  call feedkeys(\"Vkk\\<Up>yy\", 'tx')\n  call assert_equal(['47'], getreg(0, 0, 1))\n\n  set keymodel=\n  50\n  call feedkeys(\"Vkk\\<Up>yy\", 'tx')\n  call assert_equal(['47', '48', '49', '50'], getreg(0, 0, 1))\n\n  \" Test for using special keys to start visual selection\n  %d\n  call setline(1, ['red fox tail', 'red fox tail', 'red fox tail'])\n  set keymodel=startsel\n  \" Test for <S-PageUp> and <S-PageDown>\n  call cursor(1, 1)\n  call feedkeys(\"\\<S-PageDown>y\", 'xt')\n  call assert_equal([0, 1, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 3, 1, 0], getpos(\"'>\"))\n  call feedkeys(\"Gz\\<CR>8|\\<S-PageUp>y\", 'xt')\n  call assert_equal([0, 2, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 3, 8, 0], getpos(\"'>\"))\n  \" Test for <S-C-Home> and <S-C-End>\n  call cursor(2, 12)\n  call feedkeys(\"\\<S-C-Home>y\", 'xt')\n  call assert_equal([0, 1, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 2, 12, 0], getpos(\"'>\"))\n  call cursor(1, 4)\n  call feedkeys(\"\\<S-C-End>y\", 'xt')\n  call assert_equal([0, 1, 4, 0], getpos(\"'<\"))\n  call assert_equal([0, 3, 13, 0], getpos(\"'>\"))\n  \" Test for <S-C-Left> and <S-C-Right>\n  call cursor(2, 5)\n  call feedkeys(\"\\<S-C-Right>y\", 'xt')\n  call assert_equal([0, 2, 5, 0], getpos(\"'<\"))\n  call assert_equal([0, 2, 9, 0], getpos(\"'>\"))\n  call cursor(2, 9)\n  call feedkeys(\"\\<S-C-Left>y\", 'xt')\n  call assert_equal([0, 2, 5, 0], getpos(\"'<\"))\n  call assert_equal([0, 2, 9, 0], getpos(\"'>\"))\n\n  set keymodel&\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal03_join()\n  \" basic join test\n  call Setup_NewWindow()\n  50\n  norm! VJ\n  call assert_equal('50 51', getline('.'))\n  $\n  norm! J\n  call assert_equal('100', getline('.'))\n  $\n  norm! V9-gJ\n  call assert_equal('919293949596979899100', getline('.'))\n  call setline(1, range(1,100))\n  $\n  :j 10\n  call assert_equal('100', getline('.'))\n  call assert_beeps('normal GVJ')\n  \" clean up\n  bw!\nendfunc\n\n\" basic filter test\nfunc Test_normal04_filter()\n  \" only test on non windows platform\n  CheckNotMSWindows\n  call Setup_NewWindow()\n  1\n  call feedkeys(\"!!sed -e 's/^/|    /'\\n\", 'tx')\n  call assert_equal('|    1', getline('.'))\n  90\n  :sil :!echo one\n  call feedkeys('.', 'tx')\n  call assert_equal('|    90', getline('.'))\n  95\n  set cpo+=!\n  \" 2 <CR>, 1: for executing the command,\n  \"         2: clear hit-enter-prompt\n  call feedkeys(\"!!\\n\", 'tx')\n  call feedkeys(\":!echo one\\n\\n\", 'tx')\n  call feedkeys(\".\", 'tx')\n  call assert_equal('one', getline('.'))\n  set cpo-=!\n  bw!\nendfunc\n\nfunc Test_normal05_formatexpr()\n  \" basic formatexpr test\n  call Setup_NewWindow()\n  %d_\n  call setline(1, ['here: 1   ', '2', 'here: 3   ', '4', 'not here:   '])\n  1\n  set formatexpr=MyFormatExpr()\n  norm! gqG\n  call assert_equal(['here: 1->$', '2', 'here: 3->$', '4', 'not here:   '], getline(1,'$'))\n  set formatexpr=\n  bw!\nendfunc\n\nfunc Test_normal05_formatexpr_newbuf()\n  \" Edit another buffer in the 'formatexpr' function\n  new\n  func! Format()\n    edit another\n  endfunc\n  set formatexpr=Format()\n  norm gqG\n  bw!\n  set formatexpr=\nendfunc\n\nfunc Test_normal05_formatexpr_setopt()\n  \" Change the 'formatexpr' value in the function\n  new\n  func! Format()\n    set formatexpr=\n  endfunc\n  set formatexpr=Format()\n  norm gqG\n  bw!\n  set formatexpr=\nendfunc\n\n\" When 'formatexpr' returns non-zero, internal formatting is used.\nfunc Test_normal_formatexpr_returns_nonzero()\n  new\n  call setline(1, ['one', 'two'])\n  func! Format()\n    return 1\n  endfunc\n  setlocal formatexpr=Format()\n  normal VGgq\n  call assert_equal(['one two'], getline(1, '$'))\n\n  setlocal formatexpr=\n  delfunc Format\n  bwipe!\nendfunc\n\n\" Test for using a script-local function for 'formatexpr'\nfunc Test_formatexpr_scriptlocal_func()\n  func! s:Format()\n    let g:FormatArgs = [v:lnum, v:count]\n  endfunc\n  set formatexpr=s:Format()\n  call assert_equal(expand('<SID>') .. 'Format()', &formatexpr)\n  call assert_equal(expand('<SID>') .. 'Format()', &g:formatexpr)\n  new | only\n  call setline(1, range(1, 40))\n  let g:FormatArgs = []\n  normal! 2GVjgq\n  call assert_equal([2, 2], g:FormatArgs)\n  bw!\n  set formatexpr=<SID>Format()\n  call assert_equal(expand('<SID>') .. 'Format()', &formatexpr)\n  call assert_equal(expand('<SID>') .. 'Format()', &g:formatexpr)\n  new | only\n  call setline(1, range(1, 40))\n  let g:FormatArgs = []\n  normal! 4GVjgq\n  call assert_equal([4, 2], g:FormatArgs)\n  bw!\n  let &formatexpr = 's:Format()'\n  call assert_equal(expand('<SID>') .. 'Format()', &g:formatexpr)\n  new | only\n  call setline(1, range(1, 40))\n  let g:FormatArgs = []\n  normal! 6GVjgq\n  call assert_equal([6, 2], g:FormatArgs)\n  bw!\n  let &formatexpr = '<SID>Format()'\n  call assert_equal(expand('<SID>') .. 'Format()', &g:formatexpr)\n  new | only\n  call setline(1, range(1, 40))\n  let g:FormatArgs = []\n  normal! 8GVjgq\n  call assert_equal([8, 2], g:FormatArgs)\n  bw!\n  setlocal formatexpr=\n  setglobal formatexpr=s:Format()\n  call assert_equal(expand('<SID>') .. 'Format()', &g:formatexpr)\n  call assert_equal('', &formatexpr)\n  new\n  call assert_equal(expand('<SID>') .. 'Format()', &formatexpr)\n  call setline(1, range(1, 40))\n  let g:FormatArgs = []\n  normal! 10GVjgq\n  call assert_equal([10, 2], g:FormatArgs)\n  bw!\n  setglobal formatexpr=<SID>Format()\n  call assert_equal(expand('<SID>') .. 'Format()', &g:formatexpr)\n  call assert_equal('', &formatexpr)\n  new\n  call assert_equal(expand('<SID>') .. 'Format()', &formatexpr)\n  call setline(1, range(1, 40))\n  let g:FormatArgs = []\n  normal! 12GVjgq\n  call assert_equal([12, 2], g:FormatArgs)\n  bw!\n  let &g:formatexpr = 's:Format()'\n  call assert_equal(expand('<SID>') .. 'Format()', &g:formatexpr)\n  call assert_equal('', &formatexpr)\n  new\n  call assert_equal(expand('<SID>') .. 'Format()', &formatexpr)\n  call setline(1, range(1, 40))\n  let g:FormatArgs = []\n  normal! 14GVjgq\n  call assert_equal([14, 2], g:FormatArgs)\n  bw!\n  let &g:formatexpr = '<SID>Format()'\n  call assert_equal(expand('<SID>') .. 'Format()', &g:formatexpr)\n  call assert_equal('', &formatexpr)\n  new\n  call assert_equal(expand('<SID>') .. 'Format()', &formatexpr)\n  call setline(1, range(1, 40))\n  let g:FormatArgs = []\n  normal! 16GVjgq\n  call assert_equal([16, 2], g:FormatArgs)\n  bw!\n  set formatexpr=\n  delfunc s:Format\n  bw!\nendfunc\n\n\" basic test for formatprg\nfunc Test_normal06_formatprg()\n  \" only test on non windows platform\n  CheckNotMSWindows\n\n  \" uses sed to number non-empty lines\n  call writefile(['#!/bin/sh', 'sed ''/./=''|sed ''/./{', 'N', 's/\\n/    /', '}'''], 'Xsed_format.sh', 'D')\n  call system('chmod +x ./Xsed_format.sh')\n  let text = ['a', '', 'c', '', ' ', 'd', 'e']\n  let expected = ['1    a', '', '3    c', '', '5     ', '6    d', '7    e']\n\n  10new\n  call setline(1, text)\n  set formatprg=./Xsed_format.sh\n  norm! gggqG\n  call assert_equal(expected, getline(1, '$'))\n  %d\n\n  call setline(1, text)\n  set formatprg=donothing\n  setlocal formatprg=./Xsed_format.sh\n  norm! gggqG\n  call assert_equal(expected, getline(1, '$'))\n  %d\n\n  \" Check for the command-line ranges added to 'formatprg'\n  set formatprg=cat\n  call setline(1, ['one', 'two', 'three', 'four', 'five'])\n  call feedkeys('gggqG', 'xt')\n  call assert_equal('.,$!cat', @:)\n  call feedkeys('2Ggq2j', 'xt')\n  call assert_equal('.,.+2!cat', @:)\n\n  bw!\n  \" clean up\n  set formatprg=\n  setlocal formatprg=\nendfunc\n\nfunc Test_normal07_internalfmt()\n  \" basic test for internal formatter to textwidth of 12\n  let list=range(1,11)\n  call map(list, 'v:val.\"    \"')\n  10new\n  call setline(1, list)\n  set tw=12\n  norm! ggVGgq\n  call assert_equal(['1    2    3', '4    5    6', '7    8    9', '10    11    '], getline(1, '$'))\n  \" clean up\n  set tw=0\n  bw!\nendfunc\n\n\" basic tests for foldopen/folddelete\nfunc Test_normal08_fold()\n  CheckFeature folding\n  call Setup_NewWindow()\n  50\n  setl foldenable fdm=marker\n  \" First fold\n  norm! V4jzf\n  \" check that folds have been created\n  call assert_equal(['50/*{{{*/', '51', '52', '53', '54/*}}}*/'], getline(50,54))\n  \" Second fold\n  46\n  norm! V10jzf\n  \" check that folds have been created\n  call assert_equal('46/*{{{*/', getline(46))\n  call assert_equal('60/*}}}*/', getline(60))\n  norm! k\n  call assert_equal('45', getline('.'))\n  norm! j\n  call assert_equal('46/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('61', getline('.'))\n  norm! k\n  \" open a fold\n  norm! Vzo\n  norm! k\n  call assert_equal('45', getline('.'))\n  norm! j\n  call assert_equal('46/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('47', getline('.'))\n  norm! k\n  norm! zcVzO\n  call assert_equal('46/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('47', getline('.'))\n  norm! j\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51', getline('.'))\n  \" delete folds\n  :46\n  \" collapse fold\n  norm! V14jzC\n  \" delete all folds recursively\n  norm! VzD\n  call assert_equal(['46', '47', '48', '49', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '60'], getline(46,60))\n\n  \" clean up\n  setl nofoldenable fdm=marker\n  bw!\nendfunc\n\nfunc Test_normal09a_operatorfunc()\n  \" Test operatorfunc\n  call Setup_NewWindow()\n  \" Add some spaces for counting\n  50,60s/$/  /\n  unlet! g:a\n  let g:a=0\n  nmap <buffer><silent> ,, :set opfunc=CountSpaces<CR>g@\n  vmap <buffer><silent> ,, :<C-U>call CountSpaces(visualmode(), 1)<CR>\n  50\n  norm V2j,,\n  call assert_equal(6, g:a)\n  norm V,,\n  call assert_equal(2, g:a)\n  norm ,,l\n  call assert_equal(0, g:a)\n  50\n  exe \"norm 0\\<c-v>10j2l,,\"\n  call assert_equal(11, g:a)\n  50\n  norm V10j,,\n  call assert_equal(22, g:a)\n\n  \" clean up\n  unmap <buffer> ,,\n  set opfunc=\n  unlet! g:a\n  bw!\nendfunc\n\nfunc Test_normal09b_operatorfunc()\n  \" Test operatorfunc\n  call Setup_NewWindow()\n  \" Add some spaces for counting\n  50,60s/$/  /\n  unlet! g:opt\n  set linebreak\n  nmap <buffer><silent> ,, :set opfunc=OpfuncDummy<CR>g@\n  50\n  norm ,,j\n  exe \"bd!\" g:bufnr\n  call assert_true(&linebreak)\n  call assert_equal(g:opt, &linebreak)\n  set nolinebreak\n  norm ,,j\n  exe \"bd!\" g:bufnr\n  call assert_false(&linebreak)\n  call assert_equal(g:opt, &linebreak)\n\n  \" clean up\n  unmap <buffer> ,,\n  set opfunc=\n  call assert_fails('normal Vg@', 'E774:')\n  bw!\n  unlet! g:opt\nendfunc\n\nfunc OperatorfuncRedo(_)\n  let g:opfunc_count = v:count\nendfunc\n\nfunc Underscorize(_)\n  normal! '[V']r_\nendfunc\n\nfunc Test_normal09c_operatorfunc()\n  \" Test redoing operatorfunc\n  new\n  call setline(1, 'some text')\n  set operatorfunc=OperatorfuncRedo\n  normal v3g@\n  call assert_equal(3, g:opfunc_count)\n  let g:opfunc_count = 0\n  normal .\n  call assert_equal(3, g:opfunc_count)\n\n  bw!\n  unlet g:opfunc_count\n\n  \" Test redoing Visual mode\n  set operatorfunc=Underscorize\n  new\n  call setline(1, ['first', 'first', 'third', 'third', 'second'])\n  normal! 1GVjg@\n  normal! 5G.\n  normal! 3G.\n  call assert_equal(['_____', '_____', '_____', '_____', '______'], getline(1, '$'))\n  bwipe!\n  set operatorfunc=\nendfunc\n\n\" Test for different ways of setting the 'operatorfunc' option\nfunc Test_opfunc_callback()\n  new\n  func OpFunc1(callnr, type)\n    let g:OpFunc1Args = [a:callnr, a:type]\n  endfunc\n  func OpFunc2(type)\n    let g:OpFunc2Args = [a:type]\n  endfunc\n\n  let lines =<< trim END\n    #\" Test for using a function name\n    LET &opfunc = 'g:OpFunc2'\n    LET g:OpFunc2Args = []\n    normal! g@l\n    call assert_equal(['char'], g:OpFunc2Args)\n\n    #\" Test for using a function()\n    set opfunc=function('g:OpFunc1',\\ [10])\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([10, 'char'], g:OpFunc1Args)\n\n    #\" Using a funcref variable to set 'operatorfunc'\n    VAR Fn = function('g:OpFunc1', [11])\n    LET &opfunc = Fn\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([11, 'char'], g:OpFunc1Args)\n\n    #\" Using a string(funcref_variable) to set 'operatorfunc'\n    LET Fn = function('g:OpFunc1', [12])\n    LET &operatorfunc = string(Fn)\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([12, 'char'], g:OpFunc1Args)\n\n    #\" Test for using a funcref()\n    set operatorfunc=funcref('g:OpFunc1',\\ [13])\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([13, 'char'], g:OpFunc1Args)\n\n    #\" Using a funcref variable to set 'operatorfunc'\n    LET Fn = funcref('g:OpFunc1', [14])\n    LET &opfunc = Fn\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([14, 'char'], g:OpFunc1Args)\n\n    #\" Using a string(funcref_variable) to set 'operatorfunc'\n    LET Fn = funcref('g:OpFunc1', [15])\n    LET &opfunc = string(Fn)\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([15, 'char'], g:OpFunc1Args)\n\n    #\" Test for using a lambda function using set\n    VAR optval = \"LSTART a LMIDDLE OpFunc1(16, a) LEND\"\n    LET optval = substitute(optval, ' ', '\\\\ ', 'g')\n    exe \"set opfunc=\" .. optval\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([16, 'char'], g:OpFunc1Args)\n\n    #\" Test for using a lambda function using LET\n    LET &opfunc = LSTART a LMIDDLE OpFunc1(17, a) LEND\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([17, 'char'], g:OpFunc1Args)\n\n    #\" Set 'operatorfunc' to a string(lambda expression)\n    LET &opfunc = 'LSTART a LMIDDLE OpFunc1(18, a) LEND'\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([18, 'char'], g:OpFunc1Args)\n\n    #\" Set 'operatorfunc' to a variable with a lambda expression\n    VAR Lambda = LSTART a LMIDDLE OpFunc1(19, a) LEND\n    LET &opfunc = Lambda\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([19, 'char'], g:OpFunc1Args)\n\n    #\" Set 'operatorfunc' to a string(variable with a lambda expression)\n    LET Lambda = LSTART a LMIDDLE OpFunc1(20, a) LEND\n    LET &opfunc = string(Lambda)\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([20, 'char'], g:OpFunc1Args)\n\n    #\" Try to use 'operatorfunc' after the function is deleted\n    func g:TmpOpFunc1(type)\n      let g:TmpOpFunc1Args = [21, a:type]\n    endfunc\n    LET &opfunc = function('g:TmpOpFunc1')\n    delfunc g:TmpOpFunc1\n    call test_garbagecollect_now()\n    LET g:TmpOpFunc1Args = []\n    call assert_fails('normal! g@l', 'E117:')\n    call assert_equal([], g:TmpOpFunc1Args)\n\n    #\" Try to use a function with two arguments for 'operatorfunc'\n    func g:TmpOpFunc2(x, y)\n      let g:TmpOpFunc2Args = [a:x, a:y]\n    endfunc\n    set opfunc=TmpOpFunc2\n    LET g:TmpOpFunc2Args = []\n    call assert_fails('normal! g@l', 'E119:')\n    call assert_equal([], g:TmpOpFunc2Args)\n    delfunc TmpOpFunc2\n\n    #\" Try to use a lambda function with two arguments for 'operatorfunc'\n    LET &opfunc = LSTART a, b LMIDDLE OpFunc1(22, b) LEND\n    LET g:OpFunc1Args = []\n    call assert_fails('normal! g@l', 'E119:')\n    call assert_equal([], g:OpFunc1Args)\n\n    #\" Test for clearing the 'operatorfunc' option\n    set opfunc=''\n    set opfunc&\n    call assert_fails(\"set opfunc=function('abc')\", \"E700:\")\n    call assert_fails(\"set opfunc=funcref('abc')\", \"E700:\")\n\n    #\" set 'operatorfunc' to a non-existing function\n    LET &opfunc = function('g:OpFunc1', [23])\n    call assert_fails(\"set opfunc=function('NonExistingFunc')\", 'E700:')\n    call assert_fails(\"LET &opfunc = function('NonExistingFunc')\", 'E700:')\n    LET g:OpFunc1Args = []\n    normal! g@l\n    call assert_equal([23, 'char'], g:OpFunc1Args)\n  END\n  call v9.CheckTransLegacySuccess(lines)\n\n  \" Test for using a script-local function name\n  func s:OpFunc3(type)\n    let g:OpFunc3Args = [a:type]\n  endfunc\n  set opfunc=s:OpFunc3\n  let g:OpFunc3Args = []\n  normal! g@l\n  call assert_equal(['char'], g:OpFunc3Args)\n\n  let &opfunc = 's:OpFunc3'\n  let g:OpFunc3Args = []\n  normal! g@l\n  call assert_equal(['char'], g:OpFunc3Args)\n  delfunc s:OpFunc3\n\n  \" Using Vim9 lambda expression in legacy context should fail\n  set opfunc=(a)\\ =>\\ OpFunc1(24,\\ a)\n  let g:OpFunc1Args = []\n  call assert_fails('normal! g@l', 'E117:')\n  call assert_equal([], g:OpFunc1Args)\n\n  \" set 'operatorfunc' to a partial with dict. This used to cause a crash.\n  func SetOpFunc()\n    let operator = {'execute': function('OperatorExecute')}\n    let &opfunc = operator.execute\n  endfunc\n  func OperatorExecute(_) dict\n  endfunc\n  call SetOpFunc()\n  call test_garbagecollect_now()\n  set operatorfunc=\n  delfunc SetOpFunc\n  delfunc OperatorExecute\n\n  \" Vim9 tests\n  let lines =<< trim END\n    vim9script\n\n    def g:Vim9opFunc(val: number, type: string): void\n      g:OpFunc1Args = [val, type]\n    enddef\n\n    # Test for using a def function with opfunc\n    set opfunc=function('g:Vim9opFunc',\\ [60])\n    g:OpFunc1Args = []\n    normal! g@l\n    assert_equal([60, 'char'], g:OpFunc1Args)\n\n    # Test for using a global function name\n    &opfunc = g:OpFunc2\n    g:OpFunc2Args = []\n    normal! g@l\n    assert_equal(['char'], g:OpFunc2Args)\n    bw!\n\n    # Test for using a script-local function name\n    def LocalOpFunc(type: string): void\n      g:LocalOpFuncArgs = [type]\n    enddef\n    &opfunc = LocalOpFunc\n    g:LocalOpFuncArgs = []\n    normal! g@l\n    assert_equal(['char'], g:LocalOpFuncArgs)\n    bw!\n  END\n  call v9.CheckScriptSuccess(lines)\n\n  \" setting 'opfunc' to a script local function outside of a script context\n  \" should fail\n  let cleanup =<< trim END\n    call writefile([execute('messages')], 'Xtest.out')\n    qall\n  END\n  call writefile(cleanup, 'Xverify.vim', 'D')\n  call RunVim([], [], \"-c \\\"set opfunc=s:abc\\\" -S Xverify.vim\")\n  call assert_match('E81: Using <SID> not in a', readfile('Xtest.out')[0])\n  call delete('Xtest.out')\n\n  \" cleanup\n  set opfunc&\n  delfunc OpFunc1\n  delfunc OpFunc2\n  unlet g:OpFunc1Args g:OpFunc2Args\n  %bw!\nendfunc\n\nfunc Test_normal10_expand()\n  \" Test for expand()\n  10new\n  call setline(1, ['1', 'ifooar,,cbar'])\n  2\n  norm! $\n  call assert_equal('cbar', expand('<cword>'))\n  call assert_equal('ifooar,,cbar', expand('<cWORD>'))\n\n  call setline(1, ['prx = list[idx];'])\n  1\n  let expected = ['', 'prx', 'prx', 'prx',\n\t\\ 'list', 'list', 'list', 'list', 'list', 'list', 'list',\n\t\\ 'idx', 'idx', 'idx', 'idx',\n\t\\ 'list[idx]',\n\t\\ '];',\n\t\\ ]\n  for i in range(1, 16)\n    exe 'norm ' . i . '|'\n    call assert_equal(expected[i], expand('<cexpr>'), 'i == ' . i)\n  endfor\n\n  \" Test for <cexpr> in state.val and ptr->val\n  call setline(1, 'x = state.val;')\n  call cursor(1, 10)\n  call assert_equal('state.val', expand('<cexpr>'))\n  call setline(1, 'x = ptr->val;')\n  call cursor(1, 9)\n  call assert_equal('ptr->val', expand('<cexpr>'))\n\n  if executable('echo')\n    \" Test expand(`...`) i.e. backticks command expansion.\n    call assert_equal('abcde', expand('`echo abcde`'))\n  endif\n\n  \" Test expand(`=...`) i.e. backticks expression expansion\n  call assert_equal('5', expand('`=2+3`'))\n  call assert_equal('3.14', expand('`=3.14`'))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for expand() in latin1 encoding\nfunc Test_normal_expand_latin1()\n  new\n  let save_enc = &encoding\n  set encoding=latin1\n  call setline(1, 'val = item->color;')\n  call cursor(1, 11)\n  call assert_equal('color', expand(\"<cword>\"))\n  call assert_equal('item->color', expand(\"<cexpr>\"))\n  let &encoding = save_enc\n  bw!\nendfunc\n\nfunc Test_normal11_showcmd()\n  \" test for 'showcmd'\n  10new\n  exe \"norm! ofoobar\\<esc>\"\n  call assert_equal(2, line('$'))\n  set showcmd\n  exe \"norm! ofoobar2\\<esc>\"\n  call assert_equal(3, line('$'))\n  exe \"norm! VAfoobar3\\<esc>\"\n  call assert_equal(3, line('$'))\n  exe \"norm! 0d3\\<del>2l\"\n  call assert_equal('obar2foobar3', getline('.'))\n  \" test for the visual block size displayed in the status line\n  call setline(1, ['aaaaa', 'bbbbb', 'ccccc'])\n  call feedkeys(\"ggl\\<C-V>lljj\", 'xt')\n  redraw!\n  call assert_match('3x3$', Screenline(&lines))\n  call feedkeys(\"\\<C-V>\", 'xt')\n  \" test for visually selecting a multi-byte character\n  call setline(1, [\"\\U2206\"])\n  call feedkeys(\"ggv\", 'xt')\n  redraw!\n  call assert_match('1-3$', Screenline(&lines))\n  call feedkeys(\"v\", 'xt')\n  \" test for visually selecting the end of line\n  call setline(1, [\"foobar\"])\n  call feedkeys(\"$vl\", 'xt')\n  redraw!\n  call assert_match('2$', Screenline(&lines))\n  call feedkeys(\"y\", 'xt')\n  call assert_equal(\"r\\n\", @\")\n  bw!\nendfunc\n\n\" Test for nv_error and normal command errors\nfunc Test_normal12_nv_error()\n  10new\n  call setline(1, range(1,5))\n  \" should not do anything, just beep\n  call assert_beeps('exe \"norm! <c-k>\"')\n  call assert_equal(map(range(1,5), 'string(v:val)'), getline(1,'$'))\n  call assert_beeps('normal! G2dd')\n  call assert_beeps(\"normal! g\\<C-A>\")\n  call assert_beeps(\"normal! g\\<C-X>\")\n  call assert_beeps(\"normal! g\\<C-B>\")\n  call assert_beeps(\"normal! vQ\\<Esc>\")\n  call assert_beeps(\"normal! 2[[\")\n  call assert_beeps(\"normal! 2]]\")\n  call assert_beeps(\"normal! 2[]\")\n  call assert_beeps(\"normal! 2][\")\n  call assert_beeps(\"normal! 4[z\")\n  call assert_beeps(\"normal! 4]z\")\n  call assert_beeps(\"normal! 4[c\")\n  call assert_beeps(\"normal! 4]c\")\n  call assert_beeps(\"normal! 200%\")\n  call assert_beeps(\"normal! %\")\n  call assert_beeps(\"normal! 2{\")\n  call assert_beeps(\"normal! 2}\")\n  call assert_beeps(\"normal! r\\<Right>\")\n  call assert_beeps(\"normal! 8ry\")\n  call assert_beeps('normal! \"@')\n  bw!\nendfunc\n\nfunc Test_normal13_help()\n  \" Test for F1\n  call assert_equal(1, winnr())\n  call feedkeys(\"\\<f1>\", 'txi')\n  call assert_match('help\\.txt', bufname('%'))\n  call assert_equal(2, winnr('$'))\n  bw!\nendfunc\n\nfunc Test_normal14_page()\n  \" basic test for Ctrl-F and Ctrl-B\n  call Setup_NewWindow()\n  exe \"norm! \\<c-f>\"\n  call assert_equal('9', getline('.'))\n  exe \"norm! 2\\<c-f>\"\n  call assert_equal('25', getline('.'))\n  exe \"norm! 2\\<c-b>\"\n  call assert_equal('18', getline('.'))\n  1\n  set scrolloff=5\n  exe \"norm! 2\\<c-f>\"\n  call assert_equal('21', getline('.'))\n  exe \"norm! \\<c-b>\"\n  call assert_equal('13', getline('.'))\n  1\n  set scrolloff=99\n  exe \"norm! \\<c-f>\"\n  call assert_equal('13', getline('.'))\n  set scrolloff=0\n  100\n  exe \"norm! $\\<c-b>\"\n  call assert_equal('92', getline('.'))\n  call assert_equal([0, 92, 1, 0, 1], getcurpos())\n  100\n  set nostartofline\n  exe \"norm! $\\<c-b>\"\n  call assert_equal('92', getline('.'))\n  call assert_equal([0, 92, 2, 0, v:maxcol], getcurpos())\n  \" cleanup\n  set startofline\n  bw!\nendfunc\n\nfunc Test_normal14_page_eol()\n  10new\n  norm oxxxxxxx\n  exe \"norm 2\\<c-f>\"\n  \" check with valgrind that cursor is put back in column 1\n  exe \"norm 2\\<c-b>\"\n  bw!\nendfunc\n\n\" Test for errors with z command\nfunc Test_normal_z_error()\n  call assert_beeps('normal! z2p')\n  call assert_beeps('normal! zq')\n  call assert_beeps('normal! cz1')\nendfunc\n\nfunc Test_normal15_z_scroll_vert()\n  \" basic test for z commands that scroll the window\n  call Setup_NewWindow()\n  100\n  norm! >>\n  \" Test for z<cr>\n  exe \"norm! z\\<cr>\"\n  call assert_equal('\t100', getline('.'))\n  call assert_equal(100, winsaveview()['topline'])\n  call assert_equal([0, 100, 2, 0, 9], getcurpos())\n\n  \" Test for zt\n  21\n  norm! >>0zt\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(21, winsaveview()['topline'])\n  call assert_equal([0, 21, 1, 0, 8], getcurpos())\n\n  \" Test for zb\n  30\n  norm! >>$ztzb\n  call assert_equal('\t30', getline('.'))\n  call assert_equal(30, winsaveview()['topline']+winheight(0)-1)\n  call assert_equal([0, 30, 3, 0, v:maxcol], getcurpos())\n\n  \" Test for z-\n  1\n  30\n  norm! 0z-\n  call assert_equal('\t30', getline('.'))\n  call assert_equal(30, winsaveview()['topline']+winheight(0)-1)\n  call assert_equal([0, 30, 2, 0, 9], getcurpos())\n\n  \" Test for z{height}<cr>\n  call assert_equal(10, winheight(0))\n  exe \"norm! z12\\<cr>\"\n  call assert_equal(12, winheight(0))\n  exe \"norm! z15\\<Del>0\\<cr>\"\n  call assert_equal(10, winheight(0))\n\n  \" Test for z.\n  1\n  21\n  norm! 0z.\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(17, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" Test for zz\n  1\n  21\n  norm! 0zz\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(17, winsaveview()['topline'])\n  call assert_equal([0, 21, 1, 0, 8], getcurpos())\n\n  \" Test for z+\n  11\n  norm! zt\n  norm! z+\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(21, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" Test for [count]z+\n  1\n  norm! 21z+\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(21, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" Test for z+ with [count] greater than buffer size\n  1\n  norm! 1000z+\n  call assert_equal('\t100', getline('.'))\n  call assert_equal(100, winsaveview()['topline'])\n  call assert_equal([0, 100, 2, 0, 9], getcurpos())\n\n  \" Test for z+ from the last buffer line\n  norm! Gz.z+\n  call assert_equal('\t100', getline('.'))\n  call assert_equal(100, winsaveview()['topline'])\n  call assert_equal([0, 100, 2, 0, 9], getcurpos())\n\n  \" Test for z^\n  norm! 22z+0\n  norm! z^\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(12, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" Test for z^ from first buffer line\n  norm! ggz^\n  call assert_equal('1', getline('.'))\n  call assert_equal(1, winsaveview()['topline'])\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n\n  \" Test for [count]z^\n  1\n  norm! 30z^\n  call assert_equal('\t21', getline('.'))\n  call assert_equal(12, winsaveview()['topline'])\n  call assert_equal([0, 21, 2, 0, 9], getcurpos())\n\n  \" cleanup\n  bw!\nendfunc\n\nfunc Test_normal16_z_scroll_hor()\n  \" basic test for z commands that scroll the window\n  10new\n  15vsp\n  set nowrap listchars=\n  let lineA='abcdefghijklmnopqrstuvwxyz'\n  let lineB='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  $put =lineA\n  $put =lineB\n  1d\n\n  \" Test for zl and zh with a count\n  norm! 0z10l\n  call assert_equal([11, 1], [col('.'), wincol()])\n  norm! z4h\n  call assert_equal([11, 5], [col('.'), wincol()])\n  normal! 2gg\n\n  \" Test for zl\n  1\n  norm! 5zl\n  call assert_equal(lineA, getline('.'))\n  call assert_equal(6, col('.'))\n  call assert_equal(5, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('f', @0)\n\n  \" Test for zh\n  norm! 2zh\n  call assert_equal(lineA, getline('.'))\n  call assert_equal(6, col('.'))\n  norm! yl\n  call assert_equal('f', @0)\n  call assert_equal(3, winsaveview()['leftcol'])\n\n  \" Test for zL\n  norm! zL\n  call assert_equal(11, col('.'))\n  norm! yl\n  call assert_equal('k', @0)\n  call assert_equal(10, winsaveview()['leftcol'])\n  norm! 2zL\n  call assert_equal(25, col('.'))\n  norm! yl\n  call assert_equal('y', @0)\n  call assert_equal(24, winsaveview()['leftcol'])\n\n  \" Test for zH\n  norm! 2zH\n  call assert_equal(25, col('.'))\n  call assert_equal(10, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('y', @0)\n\n  \" Test for zs\n  norm! $zs\n  call assert_equal(26, col('.'))\n  call assert_equal(25, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" Test for ze\n  norm! ze\n  call assert_equal(26, col('.'))\n  call assert_equal(11, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" Test for zs and ze with folds\n  %fold\n  norm! $zs\n  call assert_equal(26, col('.'))\n  call assert_equal(0, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n  norm! ze\n  call assert_equal(26, col('.'))\n  call assert_equal(0, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" cleanup\n  set wrap listchars=eol:$\n  bw!\nendfunc\n\nfunc Test_normal17_z_scroll_hor2()\n  \" basic test for z commands that scroll the window\n  \" using 'sidescrolloff' setting\n  10new\n  20vsp\n  set nowrap listchars= sidescrolloff=5\n  let lineA='abcdefghijklmnopqrstuvwxyz'\n  let lineB='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  $put =lineA\n  $put =lineB\n  1d\n\n  \" Test for zl\n  1\n  norm! 5zl\n  call assert_equal(lineA, getline('.'))\n  call assert_equal(11, col('.'))\n  call assert_equal(5, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('k', @0)\n\n  \" Test for zh\n  norm! 2zh\n  call assert_equal(lineA, getline('.'))\n  call assert_equal(11, col('.'))\n  norm! yl\n  call assert_equal('k', @0)\n  call assert_equal(3, winsaveview()['leftcol'])\n\n  \" Test for zL\n  norm! 0zL\n  call assert_equal(16, col('.'))\n  norm! yl\n  call assert_equal('p', @0)\n  call assert_equal(10, winsaveview()['leftcol'])\n  norm! 2zL\n  call assert_equal(26, col('.'))\n  norm! yl\n  call assert_equal('z', @0)\n  call assert_equal(15, winsaveview()['leftcol'])\n\n  \" Test for zH\n  norm! 2zH\n  call assert_equal(15, col('.'))\n  call assert_equal(0, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('o', @0)\n\n  \" Test for zs\n  norm! $zs\n  call assert_equal(26, col('.'))\n  call assert_equal(20, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" Test for ze\n  norm! ze\n  call assert_equal(26, col('.'))\n  call assert_equal(11, winsaveview()['leftcol'])\n  norm! yl\n  call assert_equal('z', @0)\n\n  \" cleanup\n  set wrap listchars=eol:$ sidescrolloff=0\n  bw!\nendfunc\n\n\" Test for commands that scroll the window horizontally. Test with folds.\n\"   H, M, L, CTRL-E, CTRL-Y, CTRL-U, CTRL-D, PageUp, PageDown commands\nfunc Test_vert_scroll_cmds()\n  15new\n  call setline(1, range(1, 100))\n  exe \"normal! 30ggz\\<CR>\"\n  set foldenable\n  33,36fold\n  40,43fold\n  46,49fold\n  let h = winheight(0)\n\n  \" Test for H, M and L commands\n  \" Top of the screen = 30\n  \" Folded lines = 9\n  \" Bottom of the screen = 30 + h + 9 - 1\n  normal! 4L\n  call assert_equal(35 + h, line('.'))\n  normal! 4H\n  call assert_equal(33, line('.'))\n\n  \" Test for using a large count value\n  %d\n  call setline(1, range(1, 4))\n  norm! 6H\n  call assert_equal(4, line('.'))\n\n  \" Test for 'M' with folded lines\n  %d\n  call setline(1, range(1, 20))\n  1,5fold\n  norm! LM\n  call assert_equal(12, line('.'))\n\n  \" Test for the CTRL-E and CTRL-Y commands with folds\n  %d\n  call setline(1, range(1, 10))\n  3,5fold\n  exe \"normal 6G3\\<C-E>\"\n  call assert_equal(6, line('w0'))\n  exe \"normal 2\\<C-Y>\"\n  call assert_equal(2, line('w0'))\n\n  \" Test for CTRL-Y on a folded line\n  %d\n  call setline(1, range(1, 100))\n  exe (h + 2) .. \",\" .. (h + 4) .. \"fold\"\n  exe h + 5\n  normal z-\n  exe \"normal \\<C-Y>\\<C-Y>\"\n  call assert_equal(h + 1, line('w$'))\n\n  \" Test for CTRL-Y from the first line and CTRL-E from the last line\n  %d\n  set scrolloff=2\n  call setline(1, range(1, 4))\n  exe \"normal gg\\<C-Y>\"\n  call assert_equal(1, line('w0'))\n  call assert_equal(1, line('.'))\n  exe \"normal G4\\<C-E>\\<C-E>\"\n  call assert_equal(4, line('w$'))\n  call assert_equal(4, line('.'))\n  set scrolloff&\n\n  \" Using <PageUp> and <PageDown> in an empty buffer should beep\n  %d\n  call assert_beeps('exe \"normal \\<PageUp>\"')\n  call assert_beeps('exe \"normal \\<C-B>\"')\n  call assert_beeps('exe \"normal \\<PageDown>\"')\n  call assert_beeps('exe \"normal \\<C-F>\"')\n\n  \" Test for <C-U> and <C-D> with fold\n  %d\n  call setline(1, range(1, 100))\n  10,35fold\n  set scroll=10\n  exe \"normal \\<C-D>\"\n  call assert_equal(36, line('.'))\n  exe \"normal \\<C-D>\"\n  call assert_equal(46, line('.'))\n  exe \"normal \\<C-U>\"\n  call assert_equal(36, line('.'))\n  exe \"normal \\<C-U>\"\n  call assert_equal(10, line('.'))\n  exe \"normal \\<C-U>\"\n  call assert_equal(1, line('.'))\n  set scroll&\n\n  \" Test for scrolling to the top of the file with <C-U> and a fold\n  10\n  normal ztL\n  exe \"normal \\<C-U>\\<C-U>\"\n  call assert_equal(1, line('w0'))\n\n  \" Test for CTRL-D on a folded line\n  %d\n  call setline(1, range(1, 100))\n  50,100fold\n  75\n  normal z-\n  exe \"normal \\<C-D>\"\n  call assert_equal(50, line('.'))\n  call assert_equal(100, line('w$'))\n  normal z.\n  let lnum = winline()\n  exe \"normal \\<C-D>\"\n  call assert_equal(lnum, winline())\n  call assert_equal(50, line('.'))\n  normal zt\n  exe \"normal \\<C-D>\"\n  call assert_equal(50, line('w0'))\n\n  \" Test for <S-CR>. Page down.\n  %d\n  call setline(1, range(1, 100))\n  call feedkeys(\"\\<S-CR>\", 'xt')\n  call assert_equal(14, line('w0'))\n  call assert_equal(28, line('w$'))\n\n  \" Test for <S-->. Page up.\n  call feedkeys(\"\\<S-->\", 'xt')\n  call assert_equal(1, line('w0'))\n  call assert_equal(15, line('w$'))\n\n  set foldenable&\n  bwipe!\nendfunc\n\nfunc Test_scroll_in_ex_mode()\n  \" This was using invalid memory because w_botline was invalid.\n  let lines =<< trim END\n      diffsplit\n      norm os0\u00030(\u0004\n      call writefile(['done'], 'Xdone')\n      qa!\n  END\n  call writefile(lines, 'Xscript', 'D')\n  call assert_equal(1, RunVim([], [], '--clean -X -Z -e -s -S Xscript'))\n  call assert_equal(['done'], readfile('Xdone'))\n\n  call delete('Xdone')\nendfunc\n\n\" Test for the 'sidescroll' option\nfunc Test_sidescroll_opt()\n  new\n  20vnew\n\n  \" scroll by 2 characters horizontally\n  set sidescroll=2 nowrap\n  call setline(1, repeat('a', 40))\n  normal g$l\n  call assert_equal(19, screenpos(0, 1, 21).col)\n  normal l\n  call assert_equal(20, screenpos(0, 1, 22).col)\n  normal g0h\n  call assert_equal(2, screenpos(0, 1, 2).col)\n  call assert_equal(20, screenpos(0, 1, 20).col)\n\n  \" when 'sidescroll' is 0, cursor positioned at the center\n  set sidescroll=0\n  normal g$l\n  call assert_equal(11, screenpos(0, 1, 21).col)\n  normal g0h\n  call assert_equal(10, screenpos(0, 1, 10).col)\n\n  %bw!\n  set wrap& sidescroll&\nendfunc\n\n\" basic tests for foldopen/folddelete\nfunc Test_normal18_z_fold()\n  CheckFeature folding\n  call Setup_NewWindow()\n  50\n  setl foldenable fdm=marker foldlevel=5\n\n  call assert_beeps('normal! zj')\n  call assert_beeps('normal! zk')\n\n  \" Test for zF\n  \" First fold\n  norm! 4zF\n  \" check that folds have been created\n  call assert_equal(['50/*{{{*/', '51', '52', '53/*}}}*/'], getline(50,53))\n\n  \" Test for zd\n  51\n  norm! 2zF\n  call assert_equal(2, foldlevel('.'))\n  norm! kzd\n  call assert_equal(['50', '51/*{{{*/', '52/*}}}*/', '53'], getline(50,53))\n  norm! j\n  call assert_equal(1, foldlevel('.'))\n\n  \" Test for zD\n  \" also deletes partially selected folds recursively\n  51\n  norm! zF\n  call assert_equal(2, foldlevel('.'))\n  norm! kV2jzD\n  call assert_equal(['50', '51', '52', '53'], getline(50,53))\n\n  \" Test for zE\n  85\n  norm! 4zF\n  86\n  norm! 2zF\n  90\n  norm! 4zF\n  call assert_equal(['85/*{{{*/', '86/*{{{*/', '87/*}}}*/', '88/*}}}*/', '89', '90/*{{{*/', '91', '92', '93/*}}}*/'], getline(85,93))\n  norm! zE\n  call assert_equal(['85', '86', '87', '88', '89', '90', '91', '92', '93'], getline(85,93))\n\n  \" Test for zn\n  50\n  set foldlevel=0\n  norm! 2zF\n  norm! zn\n  norm! k\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  call assert_equal(0, &foldenable)\n\n  \" Test for zN\n  49\n  norm! zN\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  call assert_equal(1, &foldenable)\n\n  \" Test for zi\n  norm! zi\n  call assert_equal(0, &foldenable)\n  norm! zi\n  call assert_equal(1, &foldenable)\n  norm! zi\n  call assert_equal(0, &foldenable)\n  norm! zi\n  call assert_equal(1, &foldenable)\n\n  \" Test for za\n  50\n  norm! za\n  norm! k\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  50\n  norm! za\n  norm! k\n  call assert_equal('49', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  49\n  norm! 5zF\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n  49\n  norm! za\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  set nofoldenable\n  \" close fold and set foldenable\n  norm! za\n  call assert_equal(1, &foldenable)\n\n  50\n  \" have to use {count}za to open all folds and make the cursor visible\n  norm! 2za\n  norm! 2k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  \" Test for zA\n  49\n  set foldlevel=0\n  50\n  norm! zA\n  norm! 2k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  \" zA on an opened fold when foldenable is not set\n  50\n  set nofoldenable\n  norm! zA\n  call assert_equal(1, &foldenable)\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zc\n  norm! zE\n  50\n  norm! 2zF\n  49\n  norm! 5zF\n  set nofoldenable\n  50\n  \" There most likely is a bug somewhere:\n  \" https://groups.google.com/d/msg/vim_dev/v2EkfJ_KQjI/u-Cvv94uCAAJ\n  \" TODO: Should this only close the inner most fold or both folds?\n  norm! zc\n  call assert_equal(1, &foldenable)\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n  set nofoldenable\n  50\n  norm! Vjzc\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zC\n  set nofoldenable\n  50\n  norm! zCk\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zx\n  \" 1) close folds at line 49-54\n  set nofoldenable\n  48\n  norm! zx\n  call assert_equal(1, &foldenable)\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" 2) do not close fold under cursor\n  51\n  set nofoldenable\n  norm! zx\n  call assert_equal(1, &foldenable)\n  norm! 3k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  norm! j\n  call assert_equal('53', getline('.'))\n  norm! j\n  call assert_equal('54/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" 3) close one level of folds\n  48\n  set nofoldenable\n  set foldlevel=1\n  norm! zx\n  call assert_equal(1, &foldenable)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  norm! j\n  call assert_equal('53', getline('.'))\n  norm! j\n  call assert_equal('54/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zX\n  \" Close all folds\n  set foldlevel=0 nofoldenable\n  50\n  norm! zX\n  call assert_equal(1, &foldenable)\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zm\n  50\n  set nofoldenable foldlevel=2\n  norm! zm\n  call assert_equal(1, &foldenable)\n  call assert_equal(1, &foldlevel)\n  norm! zm\n  call assert_equal(0, &foldlevel)\n  norm! zm\n  call assert_equal(0, &foldlevel)\n  norm! k\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zm with a count\n  50\n  set foldlevel=2\n  norm! 3zm\n  call assert_equal(0, &foldlevel)\n  call assert_equal(49, foldclosed(line('.')))\n\n  \" Test for zM\n  48\n  set nofoldenable foldlevel=99\n  norm! zM\n  call assert_equal(1, &foldenable)\n  call assert_equal(0, &foldlevel)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('55', getline('.'))\n\n  \" Test for zr\n  48\n  set nofoldenable foldlevel=0\n  norm! zr\n  call assert_equal(0, &foldenable)\n  call assert_equal(1, &foldlevel)\n  set foldlevel=0 foldenable\n  norm! zr\n  call assert_equal(1, &foldenable)\n  call assert_equal(1, &foldlevel)\n  norm! zr\n  call assert_equal(2, &foldlevel)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  \" Test for zR\n  48\n  set nofoldenable foldlevel=0\n  norm! zR\n  call assert_equal(0, &foldenable)\n  call assert_equal(2, &foldlevel)\n  set foldenable foldlevel=0\n  norm! zR\n  call assert_equal(1, &foldenable)\n  call assert_equal(2, &foldlevel)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  call append(50, ['a /*{{{*/', 'b /*}}}*/'])\n  48\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('a /*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n  48\n  norm! zR\n  call assert_equal(1, &foldenable)\n  call assert_equal(3, &foldlevel)\n  call assert_equal('48', getline('.'))\n  norm! j\n  call assert_equal('49/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('50/*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('a /*{{{*/', getline('.'))\n  norm! j\n  call assert_equal('b /*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('51/*}}}*/', getline('.'))\n  norm! j\n  call assert_equal('52', getline('.'))\n\n  \" clean up\n  setl nofoldenable fdm=marker foldlevel=0\n  bw!\nendfunc\n\nfunc Test_normal20_exmode()\n  \" Reading from redirected file doesn't work on MS-Windows\n  CheckNotMSWindows\n  call writefile(['1a', 'foo', 'bar', '.', 'w! Xn20file2', 'q!'], 'Xn20script', 'D')\n  call writefile(['1', '2'], 'Xn20file', 'D')\n  call system(GetVimCommand() .. ' -e -s < Xn20script Xn20file')\n  let a = readfile('Xn20file2')\n  call assert_equal(['1', 'foo', 'bar', '2'], a)\n\n  \" clean up\n  call delete('Xn20file2')\n  bw!\nendfunc\n\nfunc Test_normal21_nv_hat()\n\n  \" Edit a fresh file and wipe the buffer list so that there is no alternate\n  \" file present.  Next, check for the expected command failures.\n  edit Xfoo | %bw\n  call assert_fails(':buffer #', 'E86:')\n  call assert_fails(':execute \"normal! \\<C-^>\"', 'E23:')\n  call assert_fails(\"normal i\\<C-R>#\", 'E23:')\n\n  \" Test for the expected behavior when switching between two named buffers.\n  edit Xfoo | edit Xbar\n  call feedkeys(\"\\<C-^>\", 'tx')\n  call assert_equal('Xfoo', fnamemodify(bufname('%'), ':t'))\n  call feedkeys(\"\\<C-^>\", 'tx')\n  call assert_equal('Xbar', fnamemodify(bufname('%'), ':t'))\n\n  \" Test for the expected behavior when only one buffer is named.\n  enew | let l:nr = bufnr('%')\n  call feedkeys(\"\\<C-^>\", 'tx')\n  call assert_equal('Xbar', fnamemodify(bufname('%'), ':t'))\n  call feedkeys(\"\\<C-^>\", 'tx')\n  call assert_equal('', bufname('%'))\n  call assert_equal(l:nr, bufnr('%'))\n\n  \" Test that no action is taken by \"<C-^>\" when an operator is pending.\n  edit Xfoo\n  call feedkeys(\"ci\\<C-^>\", 'tx')\n  call assert_equal('Xfoo', fnamemodify(bufname('%'), ':t'))\n\n  %bw!\nendfunc\n\nfunc Test_normal22_zet()\n  \" Test for ZZ\n  \" let shell = &shell\n  \" let &shell = 'sh'\n  call writefile(['1', '2'], 'Xn22file', 'D')\n  let args = ' -N -i NONE --noplugins -X --not-a-term'\n  call system(GetVimCommand() .. args .. ' -c \"%d\" -c \":norm! ZZ\" Xn22file')\n  let a = readfile('Xn22file')\n  call assert_equal([], a)\n  \" Test for ZQ\n  call writefile(['1', '2'], 'Xn22file')\n  call system(GetVimCommand() . args . ' -c \"%d\" -c \":norm! ZQ\" Xn22file')\n  let a = readfile('Xn22file')\n  call assert_equal(['1', '2'], a)\n\n  \" Unsupported Z command\n  call assert_beeps('normal! ZW')\n\n  \" clean up\n  \" let &shell = shell\nendfunc\n\nfunc Test_normal23_K()\n  \" Test for K command\n  new\n  call append(0, ['version8.txt', 'man', 'aa%bb', 'cc|dd'])\n  let k = &keywordprg\n  set keywordprg=:help\n  1\n  norm! VK\n  call assert_equal('version8.txt', fnamemodify(bufname('%'), ':t'))\n  call assert_equal('help', &ft)\n  call assert_match('\\*version8.txt\\*', getline('.'))\n  helpclose\n  norm! 0K\n  call assert_equal('version8.txt', fnamemodify(bufname('%'), ':t'))\n  call assert_equal('help', &ft)\n  call assert_match('\\*version8\\.\\d\\*', getline('.'))\n  helpclose\n\n  set keywordprg=:new\n  set iskeyword+=%\n  set iskeyword+=\\|\n  2\n  norm! K\n  call assert_equal('man', fnamemodify(bufname('%'), ':t'))\n  bwipe!\n  3\n  norm! K\n  call assert_equal('aa%bb', fnamemodify(bufname('%'), ':t'))\n  bwipe!\n  if !has('win32')\n    4\n    norm! K\n    call assert_equal('cc|dd', fnamemodify(bufname('%'), ':t'))\n    bwipe!\n  endif\n  set iskeyword-=%\n  set iskeyword-=\\|\n\n  \" Test for specifying a count to K\n  1\n  com! -nargs=* Kprog let g:Kprog_Args = <q-args>\n  set keywordprg=:Kprog\n  norm! 3K\n  call assert_equal('3 version8', g:Kprog_Args)\n  delcom Kprog\n\n  \" Only expect \"man\" to work on Unix\n  if !has(\"unix\")\n    let &keywordprg = k\n    bw!\n    return\n  endif\n\n  let not_gnu_man = has('mac') || has('bsd')\n  if not_gnu_man\n    \" In macOS and BSD, the option for specifying a pager is different\n    set keywordprg=man\\ -P\\ cat\n  else\n    set keywordprg=man\\ --pager=cat\n  endif\n  \" Test for using man\n  2\n  let a = execute('unsilent norm! K')\n  if not_gnu_man\n    call assert_match(\"man -P cat 'man'\", a)\n  else\n    call assert_match(\"man --pager=cat 'man'\", a)\n  endif\n\n  \" Error cases\n  call setline(1, '#$#')\n  call assert_fails('normal! ggK', 'E349:')\n  call setline(1, '---')\n  call assert_fails('normal! ggv2lK', 'E349:')\n  call setline(1, ['abc', 'xyz'])\n  call assert_fails(\"normal! gg2lv2h\\<C-]>\", 'E433:')\n  call assert_beeps(\"normal! ggVjK\")\n  norm! V\n  call assert_beeps(\"norm! cK\")\n\n  \" clean up\n  let &keywordprg = k\n  bw!\nendfunc\n\nfunc Test_normal24_rot13()\n  \" Testing for g?? g?g?\n  new\n  call append(0, 'abcdefghijklmnopqrstuvwxyz\u00e4\u00fc\u00f6')\n  1\n  norm! g??\n  call assert_equal('nopqrstuvwxyzabcdefghijklm\u00e4\u00fc\u00f6', getline('.'))\n  norm! g?g?\n  call assert_equal('abcdefghijklmnopqrstuvwxyz\u00e4\u00fc\u00f6', getline('.'))\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal25_tag()\n  CheckFeature quickfix\n\n  \" Testing for CTRL-] g CTRL-] g]\n  \" CTRL-W g] CTRL-W CTRL-] CTRL-W g CTRL-]\n  h\n  \" Test for CTRL-]\n  call search('\\<x\\>$')\n  exe \"norm! \\<c-]>\"\n  call assert_equal(\"change.txt\", fnamemodify(bufname('%'), ':t'))\n  norm! yiW\n  call assert_equal(\"*x*\", @0)\n  exe \":norm \\<c-o>\"\n\n  \" Test for g_CTRL-]\n  call search('\\<v_u\\>$')\n  exe \"norm! g\\<c-]>\"\n  call assert_equal(\"change.txt\", fnamemodify(bufname('%'), ':t'))\n  norm! yiW\n  call assert_equal(\"*v_u*\", @0)\n  exe \":norm \\<c-o>\"\n\n  \" Test for g]\n  call search('\\<i_<Esc>$')\n  let a = execute(\":norm! g]\")\n  call assert_match('i_<Esc>.*insert.txt', a)\n\n  if !empty(exepath('cscope')) && has('cscope')\n    \" setting cscopetag changes how g] works\n    set cst\n    exe \"norm! g]\"\n    call assert_equal(\"insert.txt\", fnamemodify(bufname('%'), ':t'))\n    norm! yiW\n    call assert_equal(\"*i_<Esc>*\", @0)\n    exe \":norm \\<c-o>\"\n    \" Test for CTRL-W g]\n    exe \"norm! \\<C-W>g]\"\n    call assert_equal(\"insert.txt\", fnamemodify(bufname('%'), ':t'))\n    norm! yiW\n    call assert_equal(\"*i_<Esc>*\", @0)\n    call assert_equal(3, winnr('$'))\n    helpclose\n    set nocst\n  endif\n\n  \" Test for CTRL-W g]\n  let a = execute(\"norm! \\<C-W>g]\")\n  call assert_match('i_<Esc>.*insert.txt', a)\n\n  \" Test for CTRL-W CTRL-]\n  exe \"norm! \\<C-W>\\<C-]>\"\n  call assert_equal(\"insert.txt\", fnamemodify(bufname('%'), ':t'))\n  norm! yiW\n  call assert_equal(\"*i_<Esc>*\", @0)\n  call assert_equal(3, winnr('$'))\n  helpclose\n\n  \" Test for CTRL-W g CTRL-]\n  exe \"norm! \\<C-W>g\\<C-]>\"\n  call assert_equal(\"insert.txt\", fnamemodify(bufname('%'), ':t'))\n  norm! yiW\n  call assert_equal(\"*i_<Esc>*\", @0)\n  call assert_equal(3, winnr('$'))\n  helpclose\n\n  \" clean up\n  helpclose\nendfunc\n\nfunc Test_normal26_put()\n  \" Test for ]p ]P [p and [P\n  new\n  call append(0, ['while read LINE', 'do', '  ((count++))', '  if [ $? -ne 0 ]; then', \"    echo 'Error writing file'\", '  fi', 'done'])\n  1\n  /Error/y a\n  2\n  norm! \"a]pj\"a[p\n  call assert_equal(['do', \"echo 'Error writing file'\", \"  echo 'Error writing file'\", '  ((count++))'], getline(2,5))\n  1\n  /^\\s\\{4}/\n  exe \"norm!  \\\"a]P3Eldt'\"\n  exe \"norm! j\\\"a[P2Eldt'\"\n  call assert_equal(['  if [ $? -ne 0 ]; then', \"    echo 'Error writing'\", \"    echo 'Error'\", \"    echo 'Error writing file'\", '  fi'], getline(6,10))\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal27_bracket()\n  \" Test for [' [` ]' ]`\n  call Setup_NewWindow()\n  1,21s/.\\+/  &   b/\n  1\n  norm! $ma\n  5\n  norm! $mb\n  10\n  norm! $mc\n  15\n  norm! $md\n  20\n  norm! $me\n\n  \" Test for ['\n  9\n  norm! 2['\n  call assert_equal('  1   b', getline('.'))\n  call assert_equal(1, line('.'))\n  call assert_equal(3, col('.'))\n\n  \" Test for ]'\n  norm! ]'\n  call assert_equal('  5   b', getline('.'))\n  call assert_equal(5, line('.'))\n  call assert_equal(3, col('.'))\n\n  \" No mark before line 1, cursor moves to first non-blank on current line\n  1\n  norm! 5|['\n  call assert_equal('  1   b', getline('.'))\n  call assert_equal(1, line('.'))\n  call assert_equal(3, col('.'))\n\n  \" No mark after line 21, cursor moves to first non-blank on current line\n  21\n  norm! 5|]'\n  call assert_equal('  21   b', getline('.'))\n  call assert_equal(21, line('.'))\n  call assert_equal(3, col('.'))\n\n  \" Test for [`\n  norm! 2[`\n  call assert_equal('  15   b', getline('.'))\n  call assert_equal(15, line('.'))\n  call assert_equal(8, col('.'))\n\n  \" Test for ]`\n  norm! ]`\n  call assert_equal('  20   b', getline('.'))\n  call assert_equal(20, line('.'))\n  call assert_equal(8, col('.'))\n\n  \" No mark before line 1, cursor does not move\n  1\n  norm! 5|[`\n  call assert_equal('  1   b', getline('.'))\n  call assert_equal(1, line('.'))\n  call assert_equal(5, col('.'))\n\n  \" No mark after line 21, cursor does not move\n  21\n  norm! 5|]`\n  call assert_equal('  21   b', getline('.'))\n  call assert_equal(21, line('.'))\n  call assert_equal(5, col('.'))\n\n  \" Count too large for [`\n  \" cursor moves to first lowercase mark\n  norm! 99[`\n  call assert_equal('  1   b', getline('.'))\n  call assert_equal(1, line('.'))\n  call assert_equal(7, col('.'))\n\n  \" Count too large for ]`\n  \" cursor moves to last lowercase mark\n  norm! 99]`\n  call assert_equal('  20   b', getline('.'))\n  call assert_equal(20, line('.'))\n  call assert_equal(8, col('.'))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for ( and ) sentence movements\nfunc Test_normal28_parenthesis()\n  new\n  call append(0, ['This is a test. With some sentences!', '', 'Even with a question? And one more. And no sentence here'])\n\n  $\n  norm! d(\n  call assert_equal(['This is a test. With some sentences!', '', 'Even with a question? And one more. ', ''], getline(1, '$'))\n  norm! 2d(\n  call assert_equal(['This is a test. With some sentences!', '', ' ', ''], getline(1, '$'))\n  1\n  norm! 0d)\n  call assert_equal(['With some sentences!', '', ' ', ''], getline(1, '$'))\n\n  call append('$', ['This is a long sentence', '', 'spanning', 'over several lines. '])\n  $\n  norm! $d(\n  call assert_equal(['With some sentences!', '', ' ', '', 'This is a long sentence', ''], getline(1, '$'))\n\n  \" Move to the next sentence from a paragraph macro\n  %d\n  call setline(1, ['.LP', 'blue sky!. blue sky.', 'blue sky. blue sky.'])\n  call cursor(1, 1)\n  normal )\n  call assert_equal([2, 1], [line('.'), col('.')])\n  normal )\n  call assert_equal([2, 12], [line('.'), col('.')])\n  normal ((\n  call assert_equal([1, 1], [line('.'), col('.')])\n\n  \" It is an error if a next sentence is not found\n  %d\n  call setline(1, '.SH')\n  call assert_beeps('normal )')\n\n  \" If only dot is present, don't treat that as a sentence\n  call setline(1, '. This is a sentence.')\n  normal $((\n  call assert_equal(3, col('.'))\n\n  \" Jumping to a fold should open the fold\n  call setline(1, ['', '', 'one', 'two', 'three'])\n  set foldenable\n  2,$fold\n  call feedkeys(')', 'xt')\n  call assert_equal(3, line('.'))\n  call assert_equal(1, foldlevel('.'))\n  call assert_equal(-1, foldclosed('.'))\n  set foldenable&\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for { and } paragraph movements\nfunc Test_normal29_brace()\n  let text =<< trim [DATA]\n    A paragraph begins after each empty line, and also at each of a set of\n    paragraph macros, specified by the pairs of characters in the 'paragraphs'\n    option.  The default is \"IPLPPPQPP TPHPLIPpLpItpplpipbp\", which corresponds to\n    the macros \".IP\", \".LP\", etc.  (These are nroff macros, so the dot must be in\n    the first column).  A section boundary is also a paragraph boundary.\n    Note that a blank line (only containing white space) is NOT a paragraph\n    boundary.\n\n\n    Also note that this does not include a '{' or '}' in the first column.  When\n    the '{' flag is in 'cpoptions' then '{' in the first column is used as a\n    paragraph boundary |posix|.\n    {\n    This is no paragraph\n    unless the '{' is set\n    in 'cpoptions'\n    }\n    .IP\n    The nroff macros IP separates a paragraph\n    That means, it must be a '.'\n    followed by IP\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n  [DATA]\n\n  new\n  call append(0, text)\n  1\n  norm! 0d2}\n\n  let expected =<< trim [DATA]\n    .IP\n    The nroff macros IP separates a paragraph\n    That means, it must be a '.'\n    followed by IP\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  norm! 0d}\n\n  let expected =<< trim [DATA]\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  $\n  norm! d{\n\n  let expected =<< trim [DATA]\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  norm! d{\n\n  let expected =<< trim [DATA]\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test with { in cpooptions\n  %d\n  call append(0, text)\n  set cpo+={\n  1\n  norm! 0d2}\n\n  let expected =<< trim [DATA]\n    {\n    This is no paragraph\n    unless the '{' is set\n    in 'cpoptions'\n    }\n    .IP\n    The nroff macros IP separates a paragraph\n    That means, it must be a '.'\n    followed by IP\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  $\n  norm! d}\n\n  let expected =<< trim [DATA]\n    {\n    This is no paragraph\n    unless the '{' is set\n    in 'cpoptions'\n    }\n    .IP\n    The nroff macros IP separates a paragraph\n    That means, it must be a '.'\n    followed by IP\n    .LPIt does not matter, if afterwards some\n    more characters follow.\n    .SHAlso section boundaries from the nroff\n    macros terminate a paragraph. That means\n    a character like this:\n    .NH\n    End of text here\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  norm! gg}\n  norm! d5}\n\n  let expected =<< trim [DATA]\n    {\n    This is no paragraph\n    unless the '{' is set\n    in 'cpoptions'\n    }\n\n  [DATA]\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Jumping to a fold should open the fold\n  %d\n  call setline(1, ['', 'one', 'two', ''])\n  set foldenable\n  2,$fold\n  call feedkeys('}', 'xt')\n  call assert_equal(4, line('.'))\n  call assert_equal(1, foldlevel('.'))\n  call assert_equal(-1, foldclosed('.'))\n  set foldenable&\n\n  \" clean up\n  set cpo-={\n  bw!\nendfunc\n\n\" Test for section movements\nfunc Test_normal_section()\n  new\n  let lines =<< trim [END]\n    int foo()\n    {\n      if (1)\n      {\n        a = 1;\n      }\n    }\n  [END]\n  call setline(1, lines)\n\n  \" jumping to a folded line using [[ should open the fold\n  2,3fold\n  call cursor(5, 1)\n  call feedkeys(\"[[\", 'xt')\n  call assert_equal(2, line('.'))\n  call assert_equal(-1, foldclosedend(line('.')))\n\n  bwipe!\nendfunc\n\n\" Test for changing case using u, U, gu, gU and ~ (tilde) commands\nfunc Test_normal30_changecase()\n  new\n  call append(0, 'This is a simple test: \u00e4\u00fc\u00f6\u00df')\n  norm! 1ggVu\n  call assert_equal('this is a simple test: \u00e4\u00fc\u00f6\u00df', getline('.'))\n  norm! VU\n  call assert_equal('THIS IS A SIMPLE TEST: \u00c4\u00dc\u00d6SS', getline('.'))\n  norm! guu\n  call assert_equal('this is a simple test: \u00e4\u00fc\u00f6ss', getline('.'))\n  norm! gUgU\n  call assert_equal('THIS IS A SIMPLE TEST: \u00c4\u00dc\u00d6SS', getline('.'))\n  norm! gugu\n  call assert_equal('this is a simple test: \u00e4\u00fc\u00f6ss', getline('.'))\n  norm! gUU\n  call assert_equal('THIS IS A SIMPLE TEST: \u00c4\u00dc\u00d6SS', getline('.'))\n  norm! 010~\n  call assert_equal('this is a SIMPLE TEST: \u00c4\u00dc\u00d6SS', getline('.'))\n  norm! V~\n  call assert_equal('THIS IS A simple test: \u00e4\u00fc\u00f6ss', getline('.'))\n  call assert_beeps('norm! c~')\n  %d\n  call assert_beeps('norm! ~')\n\n  \" Test for changing case across lines using 'whichwrap'\n  call setline(1, ['aaaaaa', 'aaaaaa'])\n  normal! gg10~\n  call assert_equal(['AAAAAA', 'aaaaaa'], getline(1, 2))\n  set whichwrap+=~\n  normal! gg10~\n  call assert_equal(['aaaaaa', 'AAAAaa'], getline(1, 2))\n  set whichwrap&\n\n  \" try changing the case with a double byte encoding (DBCS)\n  %bw!\n  let enc = &enc\n  set encoding=cp932\n  call setline(1, \"\\u8470\")\n  normal ~\n  normal gU$gu$gUgUg~g~gugu\n  call assert_equal(\"\\u8470\", getline(1))\n  let &encoding = enc\n\n  \" clean up\n  bw!\nendfunc\n\n\" Turkish ASCII turns to multi-byte.  On some systems Turkish locale\n\" is available but toupper()/tolower() don't do the right thing.\nfunc Test_normal_changecase_turkish()\n  new\n  try\n    lang tr_TR.UTF-8\n    set casemap=\n    let iupper = toupper('i')\n    if iupper == \"\\u0130\"\n      call setline(1, 'iI')\n      1normal gUU\n      call assert_equal(\"\\u0130I\", getline(1))\n      call assert_equal(\"\\u0130I\", toupper(\"iI\"))\n\n      call setline(1, 'iI')\n      1normal guu\n      call assert_equal(\"i\\u0131\", getline(1))\n      call assert_equal(\"i\\u0131\", tolower(\"iI\"))\n    elseif iupper == \"I\"\n      call setline(1, 'iI')\n      1normal gUU\n      call assert_equal(\"II\", getline(1))\n      call assert_equal(\"II\", toupper(\"iI\"))\n\n      call setline(1, 'iI')\n      1normal guu\n      call assert_equal(\"ii\", getline(1))\n      call assert_equal(\"ii\", tolower(\"iI\"))\n    else\n      call assert_true(false, \"expected toupper('i') to be either 'I' or '\\u0130'\")\n    endif\n    set casemap&\n    call setline(1, 'iI')\n    1normal gUU\n    call assert_equal(\"II\", getline(1))\n    call assert_equal(\"II\", toupper(\"iI\"))\n\n    call setline(1, 'iI')\n    1normal guu\n    call assert_equal(\"ii\", getline(1))\n    call assert_equal(\"ii\", tolower(\"iI\"))\n\n    lang en_US.UTF-8\n  catch /E197:/\n    \" can't use Turkish locale\n    throw 'Skipped: Turkish locale not available'\n  endtry\n\n  bwipe!\nendfunc\n\n\" Test for r (replace) command\nfunc Test_normal31_r_cmd()\n  new\n  call append(0, 'This is a simple test: abcd')\n  exe \"norm! 1gg$r\\<cr>\"\n  call assert_equal(['This is a simple test: abc', '', ''], getline(1,'$'))\n  exe \"norm! 1gg2wlr\\<cr>\"\n  call assert_equal(['This is a', 'simple test: abc', '', ''], getline(1,'$'))\n  exe \"norm! 2gg0W5r\\<cr>\"\n  call assert_equal(['This is a', 'simple ', ' abc', '', ''], getline('1', '$'))\n  set autoindent\n  call setline(2, ['simple test: abc', ''])\n  exe \"norm! 2gg0W5r\\<cr>\"\n  call assert_equal(['This is a', 'simple ', 'abc', '', '', ''], getline('1', '$'))\n  exe \"norm! 1ggVr\\<cr>\"\n  call assert_equal('^M^M^M^M^M^M^M^M^M', strtrans(getline(1)))\n  call setline(1, 'This is a')\n  exe \"norm! 1gg05rf\"\n  call assert_equal('fffffis a', getline(1))\n\n  \" When replacing characters, copy characters from above and below lines\n  \" using CTRL-Y and CTRL-E.\n  \" Different code paths are used for utf-8 and latin1 encodings\n  set showmatch\n  for enc in ['latin1', 'utf-8']\n    enew!\n    let &encoding = enc\n    call setline(1, [' {a}', 'xxxxxxxxxx', '      [b]'])\n    exe \"norm! 2gg5r\\<C-Y>l5r\\<C-E>\"\n    call assert_equal(' {a}x [b]x', getline(2))\n  endfor\n  set showmatch&\n\n  \" r command should fail in operator pending mode\n  call assert_beeps('normal! cr')\n\n  \" replace a tab character in visual mode\n  %d\n  call setline(1, [\"a\\tb\", \"c\\td\", \"e\\tf\"])\n  normal gglvjjrx\n  call assert_equal(['axx', 'xxx', 'xxf'], getline(1, '$'))\n\n  \" replace with a multibyte character (with multiple composing characters)\n  %d\n  new\n  call setline(1, 'aaa')\n  exe \"normal $ra\\u0328\\u0301\"\n  call assert_equal(\"aaa\\u0328\\u0301\", getline(1))\n\n  \" clean up\n  set noautoindent\n  bw!\nendfunc\n\n\" Test for g*, g#\nfunc Test_normal32_g_cmd1()\n  new\n  call append(0, ['abc.x_foo', 'x_foobar.abc'])\n  1\n  norm! $g*\n  call assert_equal('x_foo', @/)\n  call assert_equal('x_foobar.abc', getline('.'))\n  norm! $g#\n  call assert_equal('abc', @/)\n  call assert_equal('abc.x_foo', getline('.'))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for g`, g;, g,, g&, gv, gk, gj, gJ, g0, g^, g_, gm, g$, gM, g CTRL-G,\n\" gi and gI commands\nfunc Test_normal33_g_cmd2()\n  call Setup_NewWindow()\n  \" Test for g`\n  clearjumps\n  norm! ma10j\n  let a=execute(':jumps')\n  \" empty jumplist\n  call assert_equal('>', a[-1:])\n  norm! g`a\n  call assert_equal('>', a[-1:])\n  call assert_equal(1, line('.'))\n  call assert_equal('1', getline('.'))\n  call cursor(10, 1)\n  norm! g'a\n  call assert_equal('>', a[-1:])\n  call assert_equal(1, line('.'))\n  let v:errmsg = ''\n  call assert_nobeep(\"normal! g`\\<Esc>\")\n  call assert_equal('', v:errmsg)\n  call assert_nobeep(\"normal! g'\\<Esc>\")\n  call assert_equal('', v:errmsg)\n\n  \" Test for g; and g,\n  norm! g;\n  \" there is only one change in the changelist\n  \" currently, when we setup the window\n  call assert_equal(2, line('.'))\n  call assert_fails(':norm! g;', 'E662:')\n  call assert_fails(':norm! g,', 'E663:')\n  let &ul = &ul\n  call append('$', ['a', 'b', 'c', 'd'])\n  let &ul = &ul\n  call append('$', ['Z', 'Y', 'X', 'W'])\n  let a = execute(':changes')\n  call assert_match('2\\s\\+0\\s\\+2', a)\n  call assert_match('101\\s\\+0\\s\\+a', a)\n  call assert_match('105\\s\\+0\\s\\+Z', a)\n  norm! 3g;\n  call assert_equal(2, line('.'))\n  norm! 2g,\n  call assert_equal(105, line('.'))\n\n  \" Test for g& - global substitute\n  %d\n  call setline(1, range(1,10))\n  call append('$', ['a', 'b', 'c', 'd'])\n  $s/\\w/&&/g\n  exe \"norm! /[1-8]\\<cr>\"\n  norm! g&\n  call assert_equal(['11', '22', '33', '44', '55', '66', '77', '88', '9', '110', 'a', 'b', 'c', 'dd'], getline(1, '$'))\n\n  \" Jumping to a fold using gg should open the fold\n  set foldenable\n  set foldopen+=jump\n  5,8fold\n  call feedkeys('6gg', 'xt')\n  call assert_equal(1, foldlevel('.'))\n  call assert_equal(-1, foldclosed('.'))\n  set foldopen-=jump\n  set foldenable&\n\n  \" Test for gv\n  %d\n  call append('$', repeat(['abcdefgh'], 8))\n  exe \"norm! 2gg02l\\<c-v>2j2ly\"\n  call assert_equal(['cde', 'cde', 'cde'], getreg(0, 1, 1))\n  \" in visual mode, gv swaps current and last selected region\n  exe \"norm! G0\\<c-v>4k4lgvd\"\n  call assert_equal(['', 'abfgh', 'abfgh', 'abfgh', 'abcdefgh', 'abcdefgh', 'abcdefgh', 'abcdefgh', 'abcdefgh'], getline(1,'$'))\n  exe \"norm! G0\\<c-v>4k4ly\"\n  exe \"norm! gvood\"\n  call assert_equal(['', 'abfgh', 'abfgh', 'abfgh', 'fgh', 'fgh', 'fgh', 'fgh', 'fgh'], getline(1,'$'))\n  \" gv cannot be used in operator pending mode\n  call assert_beeps('normal! cgv')\n  \" gv should beep without a previously selected visual area\n  new\n  call assert_beeps('normal! gv')\n  close\n\n  \" Test for gk/gj\n  %d\n  15vsp\n  set wrap listchars= sbr=\n  let lineA = 'abcdefghijklmnopqrstuvwxyz'\n  let lineB = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  let lineC = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'\n  $put =lineA\n  $put =lineB\n\n  norm! 3gg0dgk\n  call assert_equal(['', 'abcdefghijklmno', '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'], getline(1, '$'))\n  set nu\n  norm! 3gg0gjdgj\n  call assert_equal(['', 'abcdefghijklmno', '0123456789AMNOPQRSTUVWXYZ'], getline(1,'$'))\n\n  \" Test for gJ\n  norm! 2gggJ\n  call assert_equal(['', 'abcdefghijklmno0123456789AMNOPQRSTUVWXYZ'], getline(1,'$'))\n  call assert_equal(16, col('.'))\n  \" shouldn't do anything\n  norm! 10gJ\n  call assert_equal(1, col('.'))\n\n  \" Test for g0 g^ gm g$\n  exe \"norm! 2gg0gji   \"\n  call assert_equal(['', 'abcdefghijk   lmno0123456789AMNOPQRSTUVWXYZ'], getline(1,'$'))\n  norm! g0yl\n  call assert_equal(12, col('.'))\n  call assert_equal(' ', getreg(0))\n  norm! g$yl\n  call assert_equal(22, col('.'))\n  call assert_equal('3', getreg(0))\n  norm! gmyl\n  call assert_equal(17, col('.'))\n  call assert_equal('n', getreg(0))\n  norm! g^yl\n  call assert_equal(15, col('.'))\n  call assert_equal('l', getreg(0))\n  call assert_beeps('normal 5g$')\n\n  \" Test for g$ with double-width character half displayed\n  vsplit\n  9wincmd |\n  setlocal nowrap nonumber\n  call setline(2, 'asdfasdf\u30e8')\n  2\n  normal 0g$\n  call assert_equal(8, col('.'))\n  10wincmd |\n  normal 0g$\n  call assert_equal(9, col('.'))\n\n  setlocal signcolumn=yes\n  11wincmd |\n  normal 0g$\n  call assert_equal(8, col('.'))\n  12wincmd |\n  normal 0g$\n  call assert_equal(9, col('.'))\n\n  close\n\n  \" Test for g_\n  call assert_beeps('normal! 100g_')\n  call setline(2, ['  foo  ', '  foobar  '])\n  normal! 2ggg_\n  call assert_equal(5, col('.'))\n  normal! 2g_\n  call assert_equal(8, col('.'))\n\n  norm! 2ggdG\n  $put =lineC\n\n  \" Test for gM\n  norm! gMyl\n  call assert_equal(73, col('.'))\n  call assert_equal('0', getreg(0))\n  \" Test for 20gM\n  norm! 20gMyl\n  call assert_equal(29, col('.'))\n  call assert_equal('S', getreg(0))\n  \" Test for 60gM\n  norm! 60gMyl\n  call assert_equal(87, col('.'))\n  call assert_equal('E', getreg(0))\n\n  \" Test for gM with Tab characters\n  call setline('.', \"\\ta\\tb\\tc\\td\\te\\tf\")\n  norm! gMyl\n  call assert_equal(6, col('.'))\n  call assert_equal(\"c\", getreg(0))\n\n  \" Test for g Ctrl-G\n  call setline('.', lineC)\n  norm! 60gMyl\n  set ff=unix\n  let a=execute(\":norm! g\\<c-g>\")\n  call assert_match('Col 87 of 144; Line 2 of 2; Word 1 of 1; Byte 88 of 146', a)\n\n  \" Test for gI\n  norm! gIfoo\n  call assert_equal(['', 'foo0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'], getline(1,'$'))\n\n  \" Test for gi\n  wincmd c\n  %d\n  set tw=0\n  call setline(1, ['foobar', 'new line'])\n  norm! A next word\n  $put ='third line'\n  norm! gi another word\n  call assert_equal(['foobar next word another word', 'new line', 'third line'], getline(1,'$'))\n  call setline(1, 'foobar')\n  normal! Ggifirst line\n  call assert_equal('foobarfirst line', getline(1))\n  \" Test gi in 'virtualedit' mode with cursor after the end of the line\n  set virtualedit=all\n  call setline(1, 'foo')\n  exe \"normal! Abar\\<Right>\\<Right>\\<Right>\\<Right>\"\n  call setline(1, 'foo')\n  normal! Ggifirst line\n  call assert_equal('foo       first line', getline(1))\n  set virtualedit&\n\n  \" Test for aborting a g command using CTRL-\\ CTRL-G\n  exe \"normal! g\\<C-\\>\\<C-G>\"\n  call assert_equal('foo       first line', getline('.'))\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal_ex_substitute()\n  \" This was hanging on the substitute prompt.\n  new\n  call setline(1, 'a')\n  exe \"normal! gggQs/a/b/c\\<CR>\"\n  call assert_equal('a', getline(1))\n  bwipe!\nendfunc\n\n\" Test for g CTRL-G\nfunc Test_g_ctrl_g()\n  new\n\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\n--No lines in buffer--\", a)\n\n  \" Test for CTRL-G (same as :file)\n  let a = execute(\":norm! \\<c-g>\")\n  call assert_equal(\"\\n\\n\\\"[No Name]\\\" --No lines in buffer--\", a)\n\n  call setline(1, ['first line', 'second line'])\n\n  \" Test g CTRL-g with dos, mac and unix file type.\n  norm! gojll\n  set ff=dos\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 3 of 11; Line 2 of 2; Word 3 of 4; Byte 15 of 25\", a)\n\n  set ff=mac\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 3 of 11; Line 2 of 2; Word 3 of 4; Byte 14 of 23\", a)\n\n  set ff=unix\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 3 of 11; Line 2 of 2; Word 3 of 4; Byte 14 of 23\", a)\n\n  \" Test g CTRL-g in visual mode (v)\n  let a = execute(\":norm! gojllvlg\\<c-g>\")\n  call assert_equal(\"\\nSelected 1 of 2 Lines; 1 of 4 Words; 2 of 23 Bytes\", a)\n\n  \" Test g CTRL-g in visual mode (CTRL-V) with end col > start col\n  let a = execute(\":norm! \\<Esc>gojll\\<C-V>kllg\\<c-g>\")\n  call assert_equal(\"\\nSelected 3 Cols; 2 of 2 Lines; 2 of 4 Words; 6 of 23 Bytes\", a)\n\n  \" Test g_CTRL-g in visual mode (CTRL-V) with end col < start col\n  let a = execute(\":norm! \\<Esc>goll\\<C-V>jhhg\\<c-g>\")\n  call assert_equal(\"\\nSelected 3 Cols; 2 of 2 Lines; 2 of 4 Words; 6 of 23 Bytes\", a)\n\n  \" Test g CTRL-g in visual mode (CTRL-V) with end_vcol being MAXCOL\n  let a = execute(\":norm! \\<Esc>gojll\\<C-V>k$g\\<c-g>\")\n  call assert_equal(\"\\nSelected 2 of 2 Lines; 4 of 4 Words; 17 of 23 Bytes\", a)\n\n  \" There should be one byte less with noeol\n  set bin noeol\n  let a = execute(\":norm! \\<Esc>gog\\<c-g>\")\n  call assert_equal(\"\\nCol 1 of 10; Line 1 of 2; Word 1 of 4; Char 1 of 23; Byte 1 of 22\", a)\n  set bin & eol&\n\n  call setline(1, ['Fran\u00e7ais', '\u65e5\u672c\u8a9e'])\n\n  let a = execute(\":norm! \\<Esc>gojlg\\<c-g>\")\n  call assert_equal(\"\\nCol 4-3 of 9-6; Line 2 of 2; Word 2 of 2; Char 11 of 13; Byte 16 of 20\", a)\n\n  let a = execute(\":norm! \\<Esc>gojvlg\\<c-g>\")\n  call assert_equal(\"\\nSelected 1 of 2 Lines; 1 of 2 Words; 2 of 13 Chars; 6 of 20 Bytes\", a)\n\n  let a = execute(\":norm! \\<Esc>goll\\<c-v>jlg\\<c-g>\")\n  call assert_equal(\"\\nSelected 4 Cols; 2 of 2 Lines; 2 of 2 Words; 6 of 13 Chars; 11 of 20 Bytes\", a)\n\n  set fenc=utf8 bomb\n  let a = execute(\":norm! \\<Esc>gojlg\\<c-g>\")\n  call assert_equal(\"\\nCol 4-3 of 9-6; Line 2 of 2; Word 2 of 2; Char 11 of 13; Byte 16 of 20(+3 for BOM)\", a)\n\n  set fenc=utf16 bomb\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 4-3 of 9-6; Line 2 of 2; Word 2 of 2; Char 11 of 13; Byte 16 of 20(+2 for BOM)\", a)\n\n  set fenc=utf32 bomb\n  let a = execute(\":norm! g\\<c-g>\")\n  call assert_equal(\"\\nCol 4-3 of 9-6; Line 2 of 2; Word 2 of 2; Char 11 of 13; Byte 16 of 20(+4 for BOM)\", a)\n\n  set fenc& bomb&\n\n  set ff&\n  bwipe!\nendfunc\n\n\" Test for g8\nfunc Test_normal34_g_cmd3()\n  new\n  let a=execute(':norm! 1G0g8')\n  call assert_equal(\"\\nNUL\", a)\n\n  call setline(1, 'abcdefghijklmnopqrstuvwxyz\u00e4\u00fc\u00f6')\n  let a=execute(':norm! 1G$g8')\n  call assert_equal(\"\\nc3 b6 \", a)\n\n  call setline(1, \"a\\u0302\")\n  let a=execute(':norm! 1G0g8')\n  call assert_equal(\"\\n61 + cc 82 \", a)\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test 8g8 which finds invalid utf8 at or after the cursor.\nfunc Test_normal_8g8()\n  new\n\n  \" With invalid byte.\n  call setline(1, \"___\\xff___\")\n  norm! 1G08g8g\n  call assert_equal([0, 1, 4, 0, 1], getcurpos())\n\n  \" With invalid byte before the cursor.\n  call setline(1, \"___\\xff___\")\n  norm! 1G$h8g8g\n  call assert_equal([0, 1, 6, 0, 9], getcurpos())\n\n  \" With truncated sequence.\n  call setline(1, \"___\\xE2\\x82___\")\n  norm! 1G08g8g\n  call assert_equal([0, 1, 4, 0, 1], getcurpos())\n\n  \" With overlong sequence.\n  call setline(1, \"___\\xF0\\x82\\x82\\xAC___\")\n  norm! 1G08g8g\n  call assert_equal([0, 1, 4, 0, 1], getcurpos())\n\n  \" With valid utf8.\n  call setline(1, \"caf\u00e9\")\n  norm! 1G08g8\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n\n  bw!\nendfunc\n\n\" Test for g<\nfunc Test_normal35_g_cmd4()\n  \" Cannot capture its output,\n  \" probably a bug, therefore, test disabled:\n  throw \"Skipped: output of g< can't be tested currently\"\n  echo \"a\\nb\\nc\\nd\"\n  let b=execute(':norm! g<')\n  call assert_true(!empty(b), 'failed `execute(g<)`')\nendfunc\n\n\" Test for gp gP go\nfunc Test_normal36_g_cmd5()\n  new\n  call append(0, 'abcdefghijklmnopqrstuvwxyz')\n  set ff=unix\n  \" Test for gp gP\n  call append(1, range(1,10))\n  1\n  norm! 1yy\n  3\n  norm! gp\n  call assert_equal([0, 5, 1, 0, 1], getcurpos())\n  $\n  norm! gP\n  call assert_equal([0, 14, 1, 0, 1], getcurpos())\n\n  \" Test for go\n  norm! 26go\n  call assert_equal([0, 1, 26, 0, 26], getcurpos())\n  norm! 27go\n  call assert_equal([0, 1, 26, 0, 26], getcurpos())\n  norm! 28go\n  call assert_equal([0, 2, 1, 0, 1], getcurpos())\n  set ff=dos\n  norm! 29go\n  call assert_equal([0, 2, 1, 0, 1], getcurpos())\n  set ff=unix\n  norm! gg0\n  norm! 101go\n  call assert_equal([0, 13, 26, 0, 26], getcurpos())\n  norm! 103go\n  call assert_equal([0, 14, 1, 0, 1], getcurpos())\n  \" count > buffer content\n  norm! 120go\n  call assert_equal([0, 14, 1, 0, v:maxcol], getcurpos())\n  \" clean up\n  bw!\nendfunc\n\n\" Test for gt and gT\nfunc Test_normal37_g_cmd6()\n  tabnew 1.txt\n  tabnew 2.txt\n  tabnew 3.txt\n  norm! 1gt\n  call assert_equal(1, tabpagenr())\n  norm! 3gt\n  call assert_equal(3, tabpagenr())\n  norm! 1gT\n  \" count gT goes not to the absolute tabpagenumber\n  \" but, but goes to the count previous tabpagenumber\n  call assert_equal(2, tabpagenr())\n  \" wrap around\n  norm! 3gT\n  call assert_equal(3, tabpagenr())\n  \" gt does not wrap around\n  norm! 5gt\n  call assert_equal(3, tabpagenr())\n\n  for i in range(3)\n    tabclose\n  endfor\n  \" clean up\n  call assert_fails(':tabclose', 'E784:')\nendfunc\n\n\" Test for <Home> and <C-Home> key\nfunc Test_normal38_nvhome()\n  new\n  call setline(1, range(10))\n  $\n  setl et sw=2\n  norm! V10>$\n  \" count is ignored\n  exe \"norm! 10\\<home>\"\n  call assert_equal(1, col('.'))\n  exe \"norm! \\<home>\"\n  call assert_equal([0, 10, 1, 0, 1], getcurpos())\n  exe \"norm! 5\\<c-home>\"\n  call assert_equal([0, 5, 1, 0, 1], getcurpos())\n  exe \"norm! \\<c-home>\"\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n  exe \"norm! G\\<c-kHome>\"\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for <End> and <C-End> keys\nfunc Test_normal_nvend()\n  new\n  call setline(1, map(range(1, 10), '\"line\" .. v:val'))\n  exe \"normal! \\<End>\"\n  call assert_equal(5, col('.'))\n  exe \"normal! 4\\<End>\"\n  call assert_equal([4, 5], [line('.'), col('.')])\n  exe \"normal! \\<C-End>\"\n  call assert_equal([10, 6], [line('.'), col('.')])\n\n  bwipe!\nendfunc\n\n\" Test for cw cW ce\nfunc Test_normal39_cw()\n  \" Test for cw and cW on whitespace\n  new\n  set tw=0\n  call append(0, 'here      are   some words')\n  norm! 1gg0elcwZZZ\n  call assert_equal('hereZZZare   some words', getline('.'))\n  norm! 1gg0elcWYYY\n  call assert_equal('hereZZZareYYYsome words', getline('.'))\n  norm! 2gg0cwfoo\n  call assert_equal('foo', getline('.'))\n\n  call setline(1, 'one; two')\n  call cursor(1, 1)\n  call feedkeys('cwvim', 'xt')\n  call assert_equal('vim; two', getline(1))\n  call feedkeys('0cWone', 'xt')\n  call assert_equal('one two', getline(1))\n  \"When cursor is at the end of a word 'ce' will change until the end of the\n  \"next word, but 'cw' will change only one character\n  call setline(1, 'one two')\n  call feedkeys('0ecwce', 'xt')\n  call assert_equal('once two', getline(1))\n  call setline(1, 'one two')\n  call feedkeys('0ecely', 'xt')\n  call assert_equal('only', getline(1))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for CTRL-\\ commands\nfunc Test_normal40_ctrl_bsl()\n  new\n  call append(0, 'here      are   some words')\n  exe \"norm! 1gg0a\\<C-\\>\\<C-N>\"\n  call assert_equal('n', mode())\n  call assert_equal(1, col('.'))\n  call assert_equal('', visualmode())\n  exe \"norm! 1gg0viw\\<C-\\>\\<C-N>\"\n  call assert_equal('n', mode())\n  call assert_equal(4, col('.'))\n  exe \"norm! 1gg0a\\<C-\\>\\<C-G>\"\n  call assert_equal('n', mode())\n  call assert_equal(1, col('.'))\n  \"imap <buffer> , <c-\\><c-n>\n  set im\n  exe \":norm! \\<c-\\>\\<c-n>dw\"\n  set noim\n  call assert_equal('are   some words', getline(1))\n  call assert_false(&insertmode)\n  call assert_beeps(\"normal! \\<C-\\>\\<C-A>\")\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test for <c-r>=, <c-r><c-r>= and <c-r><c-o>= in insert mode\nfunc Test_normal41_insert_reg()\n  new\n  set sts=2 sw=2 ts=8 tw=0\n  call append(0, [\"aaa\\tbbb\\tccc\", '', '', ''])\n  let a=getline(1)\n  norm! 2gg0\n  exe \"norm! a\\<c-r>=a\\<cr>\"\n  norm! 3gg0\n  exe \"norm! a\\<c-r>\\<c-r>=a\\<cr>\"\n  norm! 4gg0\n  exe \"norm! a\\<c-r>\\<c-o>=a\\<cr>\"\n  call assert_equal(['aaa\tbbb\tccc', 'aaa bbb\tccc', 'aaa bbb\tccc', 'aaa\tbbb\tccc', ''], getline(1, '$'))\n\n  \" clean up\n  set sts=0 sw=8 ts=8\n  bw!\nendfunc\n\n\" Test for Ctrl-D and Ctrl-U\nfunc Test_normal42_halfpage()\n  call Setup_NewWindow()\n  call assert_equal(5, &scroll)\n  exe \"norm! \\<c-d>\"\n  call assert_equal('6', getline('.'))\n  exe \"norm! 2\\<c-d>\"\n  call assert_equal('8', getline('.'))\n  call assert_equal(2, &scroll)\n  set scroll=5\n  exe \"norm! \\<c-u>\"\n  call assert_equal('3', getline('.'))\n  1\n  set scrolloff=5\n  exe \"norm! \\<c-d>\"\n  call assert_equal('10', getline('.'))\n  exe \"norm! \\<c-u>\"\n  call assert_equal('5', getline('.'))\n  1\n  set scrolloff=99\n  exe \"norm! \\<c-d>\"\n  call assert_equal('10', getline('.'))\n  set scrolloff=0\n  100\n  exe \"norm! $\\<c-u>\"\n  call assert_equal('95', getline('.'))\n  call assert_equal([0, 95, 1, 0, 1], getcurpos())\n  100\n  set nostartofline\n  exe \"norm! $\\<c-u>\"\n  call assert_equal('95', getline('.'))\n  call assert_equal([0, 95, 2, 0, v:maxcol], getcurpos())\n  \" cleanup\n  set startofline\n  bw!\nendfunc\n\nfunc Test_normal45_drop()\n  if !has('dnd')\n    \" The ~ register does not exist\n    call assert_beeps('norm! \"~')\n    return\n  endif\n\n  \" basic test for drag-n-drop\n  \" unfortunately, without a gui, we can't really test much here,\n  \" so simply test that ~p fails (which uses the drop register)\n  new\n  call assert_fails(':norm! \"~p', 'E353:')\n  call assert_equal([],  getreg('~', 1, 1))\n  \" the ~ register is read only\n  call assert_fails(':let @~=\"1\"', 'E354:')\n  bw!\nendfunc\n\nfunc Test_normal46_ignore()\n  new\n  \" How to test this?\n  \" let's just for now test, that the buffer\n  \" does not change\n  call feedkeys(\"\\<c-s>\", 't')\n  call assert_equal([''], getline(1,'$'))\n\n  \" no valid commands\n  exe \"norm! \\<char-0x100>\"\n  call assert_equal([''], getline(1,'$'))\n\n  exe \"norm! \u00e4\"\n  call assert_equal([''], getline(1,'$'))\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal47_visual_buf_wipe()\n  \" This was causing a crash or ml_get error.\n  enew!\n  call setline(1,'xxx')\n  normal $\n  new\n  call setline(1, range(1,2))\n  2\n  exe \"norm \\<C-V>$\"\n  bw!\n  norm yp\n  set nomodified\nendfunc\n\nfunc Test_normal48_wincmd()\n  new\n  exe \"norm! \\<c-w>c\"\n  call assert_equal(1, winnr('$'))\n  call assert_fails(\":norm! \\<c-w>c\", 'E444:')\nendfunc\n\nfunc Test_normal49_counts()\n  new\n  call setline(1, 'one two three four five six seven eight nine ten')\n  1\n  norm! 3d2w\n  call assert_equal('seven eight nine ten', getline(1))\n  bw!\nendfunc\n\nfunc Test_normal50_commandline()\n  CheckFeature timers\n  CheckFeature cmdline_hist\n\n  func! DoTimerWork(id)\n    call assert_equal('[Command Line]', bufname(''))\n\n    \" should fail, with E11, but does fail with E23?\n    \"call feedkeys(\"\\<c-^>\", 'tm')\n\n    \" should fail with E11 - \"Invalid in command-line window\"\n    call assert_fails(\":wincmd p\", 'E11:')\n\n    \" Return from commandline window.\n    call feedkeys(\"\\<CR>\", 't')\n  endfunc\n\n  let oldlang=v:lang\n  lang C\n  set updatetime=20\n  call timer_start(100, 'DoTimerWork')\n  try\n    \" throws E23, for whatever reason...\n    call feedkeys('q:', 'x!')\n  catch /E23/\n    \" no-op\n  endtry\n\n  \" clean up\n  delfunc DoTimerWork\n  set updatetime=4000\n  exe \"lang\" oldlang\n  bw!\nendfunc\n\nfunc Test_normal51_FileChangedRO()\n  CheckFeature autocmd\n  \" Don't sleep after the warning message.\n  call test_settime(1)\n  call writefile(['foo'], 'Xreadonly.log', 'D')\n  new Xreadonly.log\n  setl ro\n  au FileChangedRO <buffer> :call feedkeys(\"\\<c-^>\", 'tix')\n  call assert_fails(\":norm! Af\", 'E788:')\n  call assert_equal(['foo'], getline(1,'$'))\n  call assert_equal('Xreadonly.log', bufname(''))\n\n  \" cleanup\n  call test_settime(0)\n  bw!\nendfunc\n\nfunc Test_normal52_rl()\n  CheckFeature rightleft\n  new\n  call setline(1, 'abcde fghij klmnopq')\n  norm! 1gg$\n  set rl\n  call assert_equal(19, col('.'))\n  call feedkeys('l', 'tx')\n  call assert_equal(18, col('.'))\n  call feedkeys('h', 'tx')\n  call assert_equal(19, col('.'))\n  call feedkeys(\"\\<right>\", 'tx')\n  call assert_equal(18, col('.'))\n  call feedkeys(\"\\<left>\", 'tx')\n  call assert_equal(19, col('.'))\n  call feedkeys(\"\\<s-right>\", 'tx')\n  call assert_equal(13, col('.'))\n  call feedkeys(\"\\<c-right>\", 'tx')\n  call assert_equal(7, col('.'))\n  call feedkeys(\"\\<c-left>\", 'tx')\n  call assert_equal(13, col('.'))\n  call feedkeys(\"\\<s-left>\", 'tx')\n  call assert_equal(19, col('.'))\n  call feedkeys(\"<<\", 'tx')\n  call assert_equal('\tabcde fghij klmnopq',getline(1))\n  call feedkeys(\">>\", 'tx')\n  call assert_equal('abcde fghij klmnopq',getline(1))\n\n  \" cleanup\n  set norl\n  bw!\nendfunc\n\nfunc Test_normal54_Ctrl_bsl()\n  new\n  call setline(1, 'abcdefghijklmn')\n  exe \"norm! df\\<c-\\>\\<c-n>\"\n  call assert_equal(['abcdefghijklmn'], getline(1,'$'))\n  exe \"norm! df\\<c-\\>\\<c-g>\"\n  call assert_equal(['abcdefghijklmn'], getline(1,'$'))\n  exe \"norm! df\\<c-\\>m\"\n  call assert_equal(['abcdefghijklmn'], getline(1,'$'))\n\n  call setline(2, 'abcdefghijklmn\u0101f')\n  norm! 2gg0\n  exe \"norm! df\\<Char-0x101>\"\n  call assert_equal(['abcdefghijklmn', 'f'], getline(1,'$'))\n  norm! 1gg0\n  exe \"norm! df\\<esc>\"\n  call assert_equal(['abcdefghijklmn', 'f'], getline(1,'$'))\n\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_normal_large_count()\n  \" This may fail with 32bit long, how do we detect that?\n  new\n  normal o\n  normal 6666666666dL\n  bwipe!\nendfunc\n\nfunc Test_delete_until_paragraph()\n  new\n  normal gr\u00e1dv}\n  call assert_equal('\u00e1', getline(1))\n  normal gr\u00e1d}\n  call assert_equal('', getline(1))\n  bwipe!\nendfunc\n\n\" Test for the gr (virtual replace) command\nfunc Test_gr_command()\n  enew!\n  \" Test for the bug fixed by 7.4.387\n  let save_cpo = &cpo\n  call append(0, ['First line', 'Second line', 'Third line'])\n  exe \"normal i\\<C-G>u\"\n  call cursor(2, 1)\n  set cpo-=X\n  normal 4gro\n  call assert_equal('oooond line', getline(2))\n  undo\n  set cpo+=X\n  normal 4gro\n  call assert_equal('ooooecond line', getline(2))\n  let &cpo = save_cpo\n\n  normal! ggvegrx\n  call assert_equal('xxxxx line', getline(1))\n  exe \"normal! gggr\\<C-V>122\"\n  call assert_equal('zxxxx line', getline(1))\n\n  set virtualedit=all\n  normal! 15|grl\n  call assert_equal('zxxxx line    l', getline(1))\n  set virtualedit&\n  set nomodifiable\n  call assert_fails('normal! grx', 'E21:')\n  call assert_fails('normal! gRx', 'E21:')\n  call assert_nobeep(\"normal! gr\\<Esc>\")\n  set modifiable&\n\n  call assert_nobeep(\"normal! gr\\<Esc>\")\n  call assert_nobeep(\"normal! cgr\\<Esc>\")\n  call assert_beeps(\"normal! cgrx\")\n\n  call assert_equal('zxxxx line    l', getline(1))\n  exe \"normal! 2|gr\\<C-V>\\<Esc>\"\n  call assert_equal(\"z\\<Esc>xx line    l\", getline(1))\n\n  call setline(1, 'abcdef')\n  exe \"normal! 0gr\\<C-O>lx\"\n  call assert_equal(\"\\<C-O>def\", getline(1))\n\n  call setline(1, 'abcdef')\n  exe \"normal! 0gr\\<C-G>lx\"\n  call assert_equal(\"\\<C-G>def\", getline(1))\n\n  bwipe!\nendfunc\n\nfunc Test_nv_hat_count()\n  %bwipeout!\n  let l:nr = bufnr('%') + 1\n  call assert_fails(':execute \"normal! ' . l:nr . '\\<C-^>\"', 'E92:')\n\n  edit Xfoo\n  let l:foo_nr = bufnr('Xfoo')\n\n  edit Xbar\n  let l:bar_nr = bufnr('Xbar')\n\n  \" Make sure we are not just using the alternate file.\n  edit Xbaz\n\n  call feedkeys(l:foo_nr . \"\\<C-^>\", 'tx')\n  call assert_equal('Xfoo', fnamemodify(bufname('%'), ':t'))\n\n  call feedkeys(l:bar_nr . \"\\<C-^>\", 'tx')\n  call assert_equal('Xbar', fnamemodify(bufname('%'), ':t'))\n\n  %bwipeout!\nendfunc\n\nfunc Test_message_when_using_ctrl_c()\n  \" Make sure no buffers are changed.\n  %bwipe!\n\n  exe \"normal \\<C-C>\"\n  call assert_match(\"Type  :qa  and press <Enter> to exit Vim\", Screenline(&lines))\n\n  new\n  cal setline(1, 'hi!')\n  exe \"normal \\<C-C>\"\n  call assert_match(\"Type  :qa!  and press <Enter> to abandon all changes and exit Vim\", Screenline(&lines))\n\n  bwipe!\nendfunc\n\nfunc Test_mode_updated_after_ctrl_c()\n  CheckScreendump\n\n  let buf = RunVimInTerminal('', {'rows': 5})\n  call term_sendkeys(buf, \"i\")\n  call term_sendkeys(buf, \"\\<C-O>\")\n  \" wait a moment so that the \"-- (insert) --\" message is displayed\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \"\\<C-C>\")\n  call VerifyScreenDump(buf, 'Test_mode_updated_1', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test for '[m', ']m', '[M' and ']M'\n\" Jumping to beginning and end of methods in Java-like languages\nfunc Test_java_motion()\n  new\n  call assert_beeps('normal! [m')\n  call assert_beeps('normal! ]m')\n  call assert_beeps('normal! [M')\n  call assert_beeps('normal! ]M')\n  let lines =<< trim [CODE]\n\tPiece of Java\n\t{\n\t\ttt m1 {\n\t\t\tt1;\n\t\t} e1\n\n\t\ttt m2 {\n\t\t\tt2;\n\t\t} e2\n\n\t\ttt m3 {\n\t\t\tif (x)\n\t\t\t{\n\t\t\t\tt3;\n\t\t\t}\n\t\t} e3\n\t}\n  [CODE]\n  call setline(1, lines)\n\n  normal gg\n\n  normal 2]maA\n  call assert_equal(\"\\ttt m1 {A\", getline('.'))\n  call assert_equal([3, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal j]maB\n  call assert_equal(\"\\ttt m2 {B\", getline('.'))\n  call assert_equal([7, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal ]maC\n  call assert_equal(\"\\ttt m3 {C\", getline('.'))\n  call assert_equal([11, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal [maD\n  call assert_equal(\"\\ttt m3 {DC\", getline('.'))\n  call assert_equal([11, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal k2[maE\n  call assert_equal(\"\\ttt m1 {EA\", getline('.'))\n  call assert_equal([3, 9, 16], [line('.'), col('.'), virtcol('.')])\n\n  normal 3[maF\n  call assert_equal(\"{F\", getline('.'))\n  call assert_equal([2, 2, 2], [line('.'), col('.'), virtcol('.')])\n\n  normal ]MaG\n  call assert_equal(\"\\t}G e1\", getline('.'))\n  call assert_equal([5, 3, 10], [line('.'), col('.'), virtcol('.')])\n\n  normal j2]MaH\n  call assert_equal(\"\\t}H e3\", getline('.'))\n  call assert_equal([16, 3, 10], [line('.'), col('.'), virtcol('.')])\n\n  normal ]M]M\n  normal aI\n  call assert_equal(\"}I\", getline('.'))\n  call assert_equal([17, 2, 2], [line('.'), col('.'), virtcol('.')])\n\n  normal 2[MaJ\n  call assert_equal(\"\\t}JH e3\", getline('.'))\n  call assert_equal([16, 3, 10], [line('.'), col('.'), virtcol('.')])\n\n  normal k[MaK\n  call assert_equal(\"\\t}K e2\", getline('.'))\n  call assert_equal([9, 3, 10], [line('.'), col('.'), virtcol('.')])\n\n  normal 3[MaL\n  call assert_equal(\"{LF\", getline('.'))\n  call assert_equal([2, 2, 2], [line('.'), col('.'), virtcol('.')])\n\n  call cursor(2, 1)\n  call assert_beeps('norm! 5]m')\n\n  \" jumping to a method in a fold should open the fold\n  6,10fold\n  call feedkeys(\"gg3]m\", 'xt')\n  call assert_equal([7, 8, 15], [line('.'), col('.'), virtcol('.')])\n  call assert_equal(-1, foldclosedend(7))\n\n  bwipe!\nendfunc\n\n\" Tests for g cmds\nfunc Test_normal_gdollar_cmd()\n  call Setup_NewWindow()\n  \" Make long lines that will wrap\n  %s/$/\\=repeat(' foobar', 10)/\n  20vsp\n  set wrap\n  \" Test for g$ with count\n  norm! gg\n  norm! 0vg$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('1 foobar foobar foob', getreg(0))\n  norm! gg\n  norm! 0v4g$y\n  call assert_equal(72, col(\"'>\"))\n  call assert_equal('1 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'..\"\\n\", getreg(0))\n  norm! gg\n  norm! 0v6g$y\n  call assert_equal(40, col(\"'>\"))\n  call assert_equal('1 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n\t\t  \\ '2 foobar foobar foobar foobar foobar foo', getreg(0))\n  set nowrap\n  \" clean up\n  norm! gg\n  norm! 0vg$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('1 foobar foobar foob', getreg(0))\n  norm! gg\n  norm! 0v4g$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('1 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '2 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '3 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '4 foobar foobar foob', getreg(0))\n  norm! gg\n  norm! 0v6g$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('1 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '2 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '3 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '4 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '5 foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar'.. \"\\n\"..\n                 \\  '6 foobar foobar foob', getreg(0))\n  \" Move to last line, also down movement is not possible, should still move\n  \" the cursor to the last visible char\n  norm! G\n  norm! 0v6g$y\n  call assert_equal(20, col(\"'>\"))\n  call assert_equal('100 foobar foobar fo', getreg(0))\n  bw!\nendfunc\n\nfunc Test_normal_gk_gj()\n  \" needs 80 column new window\n  new\n  vert 80new\n  call assert_beeps('normal gk')\n  put =[repeat('x',90)..' {{{1', 'x {{{1']\n  norm! gk\n  \" In a 80 column wide terminal the window will be only 78 char\n  \" (because Vim will leave space for the other window),\n  \" but if the terminal is larger, it will be 80 chars, so verify the\n  \" cursor column correctly.\n  call assert_equal(winwidth(0)+1, col('.'))\n  call assert_equal(winwidth(0)+1, virtcol('.'))\n  norm! j\n  call assert_equal(6, col('.'))\n  call assert_equal(6, virtcol('.'))\n  norm! gk\n  call assert_equal(95, col('.'))\n  call assert_equal(95, virtcol('.'))\n  %bw!\n\n  \" needs 80 column new window\n  new\n  vert 80new\n  call assert_beeps('normal gj')\n  set number\n  set numberwidth=10\n  set cpoptions+=n\n  put =[repeat('0',90), repeat('1',90)]\n  norm! 075l\n  call assert_equal(76, col('.'))\n  norm! gk\n  call assert_equal(1, col('.'))\n  norm! gk\n  call assert_equal(76, col('.'))\n  norm! gk\n  call assert_equal(1, col('.'))\n  norm! gj\n  call assert_equal(76, col('.'))\n  norm! gj\n  call assert_equal(1, col('.'))\n  norm! gj\n  call assert_equal(76, col('.'))\n  \" When 'nowrap' is set, gk and gj behave like k and j\n  set nowrap\n  normal! gk\n  call assert_equal([2, 76], [line('.'), col('.')])\n  normal! gj\n  call assert_equal([3, 76], [line('.'), col('.')])\n  %bw!\n  set cpoptions& number& numberwidth& wrap&\nendfunc\n\n\" Test for using : to run a multi-line Ex command in operator pending mode\nfunc Test_normal_yank_with_excmd()\n  new\n  call setline(1, ['foo', 'bar', 'baz'])\n  let @a = ''\n  call feedkeys(\"\\\"ay:if v:true\\<CR>normal l\\<CR>endif\\<CR>\", 'xt')\n  call assert_equal('f', @a)\n\n  bwipe!\nendfunc\n\n\" Test for supplying a count to a normal-mode command across a cursorhold call\nfunc Test_normal_cursorhold_with_count()\n  func s:cHold()\n    let g:cHold_Called += 1\n  endfunc\n  new\n  augroup normalcHoldTest\n    au!\n    au CursorHold <buffer> call s:cHold()\n  augroup END\n  let g:cHold_Called = 0\n  call feedkeys(\"3\\<CursorHold>2ix\", 'xt')\n  call assert_equal(1, g:cHold_Called)\n  call assert_equal(repeat('x', 32), getline(1))\n  augroup normalcHoldTest\n    au!\n  augroup END\n  au! normalcHoldTest\n\n  bwipe!\n  delfunc s:cHold\nendfunc\n\n\" Test for using a count and a command with CTRL-W\nfunc Test_wincmd_with_count()\n  call feedkeys(\"\\<C-W>12n\", 'xt')\n  call assert_equal(12, winheight(0))\nendfunc\n\n\" Test for 'b', 'B' 'ge' and 'gE' commands\nfunc Test_horiz_motion()\n  new\n  normal! gg\n  call assert_beeps('normal! b')\n  call assert_beeps('normal! B')\n  call assert_beeps('normal! gE')\n  call assert_beeps('normal! ge')\n  \" <S-Backspace> moves one word left and <C-Backspace> moves one WORD left\n  call setline(1, 'one ,two ,three')\n  exe \"normal! $\\<S-BS>\"\n  call assert_equal(11, col('.'))\n  exe \"normal! $\\<C-BS>\"\n  call assert_equal(10, col('.'))\n\n  bwipe!\nendfunc\n\n\" Test for using a \":\" command in operator pending mode\nfunc Test_normal_colon_op()\n  new\n  call setline(1, ['one', 'two'])\n  call assert_beeps(\"normal! Gc:d\\<CR>\")\n  call assert_equal(['one'], getline(1, '$'))\n\n  call setline(1, ['one\u2026two\u2026three!'])\n  normal! $\n  \" Using \":\" as a movement is characterwise exclusive\n  call feedkeys(\"d:normal! F\u2026\\<CR>\", 'xt')\n  call assert_equal(['one\u2026two!'], getline(1, '$'))\n  \" Check that redoing a command with 0x80 bytes works\n  call feedkeys('.', 'xt')\n  call assert_equal(['one!'], getline(1, '$'))\n\n  call setline(1, ['one', 'two', 'three', 'four', 'five'])\n  \" Add this to the command history\n  call feedkeys(\":normal! G0\\<CR>\", 'xt')\n  \" Use :normal! with control characters in operator pending mode\n  call feedkeys(\"d:normal! \\<C-V>\\<C-P>\\<C-V>\\<C-P>\\<CR>\", 'xt')\n  call assert_equal(['one', 'two', 'five'], getline(1, '$'))\n  \" Check that redoing a command with control characters works\n  call feedkeys('.', 'xt')\n  call assert_equal(['five'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Test for d and D commands\nfunc Test_normal_delete_cmd()\n  new\n  \" D in an empty line\n  call setline(1, '')\n  normal D\n  call assert_equal('', getline(1))\n  \" D in an empty line in virtualedit mode\n  set virtualedit=all\n  normal D\n  call assert_equal('', getline(1))\n  set virtualedit&\n  \" delete to a readonly register\n  call setline(1, ['abcd'])\n  call assert_beeps('normal \":d2l')\n\n  \" D and d with 'nomodifiable'\n  call setline(1, ['abcd'])\n  setlocal nomodifiable\n  call assert_fails('normal D', 'E21:')\n  call assert_fails('normal d$', 'E21:')\n\n  bwipe!\nendfunc\n\n\" Test for deleting or changing characters across lines with 'whichwrap'\n\" containing 's'. Should count <EOL> as one character.\nfunc Test_normal_op_across_lines()\n  new\n  set whichwrap&\n  call setline(1, ['one two', 'three four'])\n  exe \"norm! $3d\\<Space>\"\n  call assert_equal(['one twhree four'], getline(1, '$'))\n\n  call setline(1, ['one two', 'three four'])\n  exe \"norm! $3c\\<Space>x\"\n  call assert_equal(['one twxhree four'], getline(1, '$'))\n\n  set whichwrap+=l\n  call setline(1, ['one two', 'three four'])\n  exe \"norm! $3x\"\n  call assert_equal(['one twhree four'], getline(1, '$'))\n\n  bwipe!\n  set whichwrap&\nendfunc\n\n\" Test for 'w' and 'b' commands\nfunc Test_normal_word_move()\n  new\n  call setline(1, ['foo bar a', '', 'foo bar b'])\n  \" copy a single character word at the end of a line\n  normal 1G$yw\n  call assert_equal('a', @\")\n  \" copy a single character word at the end of a file\n  normal G$yw\n  call assert_equal('b', @\")\n  \" check for a word movement handling an empty line properly\n  normal 1G$vwy\n  call assert_equal(\"a\\n\\n\", @\")\n\n  \" copy using 'b' command\n  %d\n  \" non-empty blank line at the start of file\n  call setline(1, ['  ', 'foo bar'])\n  normal 2Gyb\n  call assert_equal(\"  \\n\", @\")\n  \" try to copy backwards from the start of the file\n  call setline(1, ['one two', 'foo bar'])\n  call assert_beeps('normal ggyb')\n  \" 'b' command should stop at an empty line\n  call setline(1, ['one two', '', 'foo bar'])\n  normal 3Gyb\n  call assert_equal(\"\\n\", @\")\n  normal 3Gy2b\n  call assert_equal(\"two\\n\", @\")\n  \" 'b' command should not stop at a non-empty blank line\n  call setline(1, ['one two', '  ', 'foo bar'])\n  normal 3Gyb\n  call assert_equal(\"two\\n  \", @\")\n\n  bwipe!\nendfunc\n\n\" Test for 'scrolloff' with a long line that doesn't fit in the screen\nfunc Test_normal_scrolloff()\n  10new\n  60vnew\n  call setline(1, ' 1 ' .. repeat('a', 57)\n             \\ .. ' 2 ' .. repeat('b', 57)\n             \\ .. ' 3 ' .. repeat('c', 57)\n             \\ .. ' 4 ' .. repeat('d', 57)\n             \\ .. ' 5 ' .. repeat('e', 57)\n             \\ .. ' 6 ' .. repeat('f', 57)\n             \\ .. ' 7 ' .. repeat('g', 57)\n             \\ .. ' 8 ' .. repeat('h', 57)\n             \\ .. ' 9 ' .. repeat('i', 57)\n             \\ .. '10 ' .. repeat('j', 57)\n             \\ .. '11 ' .. repeat('k', 57)\n             \\ .. '12 ' .. repeat('l', 57)\n             \\ .. '13 ' .. repeat('m', 57)\n             \\ .. '14 ' .. repeat('n', 57)\n             \\ .. '15 ' .. repeat('o', 57)\n             \\ .. '16 ' .. repeat('p', 57)\n             \\ .. '17 ' .. repeat('q', 57)\n             \\ .. '18 ' .. repeat('r', 57)\n             \\ .. '19 ' .. repeat('s', 57)\n             \\ .. '20 ' .. repeat('t', 57)\n             \\ .. '21 ' .. repeat('u', 57)\n             \\ .. '22 ' .. repeat('v', 57)\n             \\ .. '23 ' .. repeat('w', 57)\n             \\ .. '24 ' .. repeat('x', 57)\n             \\ .. '25 ' .. repeat('y', 57)\n             \\ .. '26 ' .. repeat('z', 57)\n             \\ )\n  set scrolloff=10\n  normal gg10gj\n  call assert_equal(6, winline())\n  normal 10gj\n  call assert_equal(6, winline())\n  normal 10gk\n  call assert_equal(6, winline())\n  normal 0\n  call assert_equal(1, winline())\n  normal $\n  call assert_equal(10, winline())\n\n  set scrolloff&\n  bwipe!\nendfunc\n\n\" Test for vertical scrolling with CTRL-F and CTRL-B with a long line\nfunc Test_normal_vert_scroll_longline()\n  10new\n  80vnew\n  call setline(1, range(1, 10))\n  call append(5, repeat('a', 1000))\n  exe \"normal gg\\<C-F>\"\n  call assert_equal(6, line('.'))\n  exe \"normal \\<C-F>\\<C-F>\"\n  call assert_equal(11, line('.'))\n  call assert_equal(1, winline())\n  exe \"normal \\<C-B>\"\n  call assert_equal(10, line('.'))\n  call assert_equal(3, winline())\n  exe \"normal \\<C-B>\\<C-B>\"\n  call assert_equal(5, line('.'))\n  call assert_equal(5, winline())\n\n  bwipe!\nendfunc\n\n\" Test for jumping in a file using %\nfunc Test_normal_percent_jump()\n  new\n  call setline(1, range(1, 100))\n\n  \" jumping to a folded line should open the fold\n  25,75fold\n  call feedkeys('50%', 'xt')\n  call assert_equal(50, line('.'))\n  call assert_equal(-1, foldclosedend(50))\n\n  bwipe!\nendfunc\n\n\" Test for << and >> commands to shift text by 'shiftwidth'\nfunc Test_normal_shift_rightleft()\n  new\n  call setline(1, ['one', '', \"\\t\", '  two', \"\\tthree\", '      four'])\n  set shiftwidth=2 tabstop=8\n  normal gg6>>\n  call assert_equal(['  one', '', \"\\t  \", '    two', \"\\t  three\", \"\\tfour\"],\n        \\ getline(1, '$'))\n  normal ggVG2>>\n  call assert_equal(['      one', '', \"\\t      \", \"\\ttwo\",\n        \\ \"\\t      three\", \"\\t    four\"], getline(1, '$'))\n  normal gg6<<\n  call assert_equal(['    one', '', \"\\t    \", '      two', \"\\t    three\",\n        \\ \"\\t  four\"], getline(1, '$'))\n  normal ggVG2<<\n  call assert_equal(['one', '', \"\\t\", '  two', \"\\tthree\", '      four'],\n        \\ getline(1, '$'))\n  set shiftwidth& tabstop&\n  bw!\nendfunc\n\n\" Some commands like yy, cc, dd, >>, << and !! accept a count after\n\" typing the first letter of the command.\nfunc Test_normal_count_after_operator()\n  new\n  setlocal shiftwidth=4 tabstop=8 autoindent\n  call setline(1, ['one', 'two', 'three', 'four', 'five'])\n  let @a = ''\n  normal! j\"ay4y\n  call assert_equal(\"two\\nthree\\nfour\\nfive\\n\", @a)\n  normal! 3G>2>\n  call assert_equal(['one', 'two', '    three', '    four', 'five'],\n        \\ getline(1, '$'))\n  exe \"normal! 3G0c2cred\\nblue\"\n  call assert_equal(['one', 'two', '    red', '    blue', 'five'],\n        \\ getline(1, '$'))\n  exe \"normal! gg<8<\"\n  call assert_equal(['one', 'two', 'red', 'blue', 'five'],\n        \\ getline(1, '$'))\n  exe \"normal! ggd3d\"\n  call assert_equal(['blue', 'five'], getline(1, '$'))\n  call setline(1, range(1, 4))\n  call feedkeys(\"gg!3!\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\".,.+2!', @:)\n  call feedkeys(\"gg!1!\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\".!', @:)\n  call feedkeys(\"gg!9!\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\".,$!', @:)\n  bw!\nendfunc\n\nfunc Test_normal_gj_on_extra_wide_char()\n  new | 25vsp\n  let text='1 foooooooo ar e  ins\u200dzwe1 foooooooo ins\u200dzwei' .\n         \\ ' i drei vier f\u00fcnf sechs sieben acht un zehn elf zw\u00f6fl' .\n         \\ ' dreizehn v ierzehn f\u00fcnfzehn'\n  put =text\n  call cursor(2,1)\n  norm! gj\n  call assert_equal([0,2,25,0], getpos('.'))\n  bw!\nendfunc\n\nfunc Test_normal_count_out_of_range()\n  new\n  call setline(1, 'text')\n  normal 44444444444|\n  call assert_equal(999999999, v:count)\n  normal 444444444444|\n  call assert_equal(999999999, v:count)\n  normal 4444444444444|\n  call assert_equal(999999999, v:count)\n  normal 4444444444444444444|\n  call assert_equal(999999999, v:count)\n\n  normal 9y99999999|\n  call assert_equal(899999991, v:count)\n  normal 10y99999999|\n  call assert_equal(999999999, v:count)\n  normal 44444444444y44444444444|\n  call assert_equal(999999999, v:count)\n  bwipe!\nendfunc\n\n\" Test that mouse shape is restored to Normal mode after failed \"c\" operation.\nfunc Test_mouse_shape_after_failed_change()\n  CheckFeature mouseshape\n  CheckCanRunGui\n\n  let lines =<< trim END\n    vim9script\n    set mouseshape+=o:busy\n    setlocal nomodifiable\n    var mouse_shapes = []\n\n    feedkeys('c')\n    timer_start(50, (_) => {\n      mouse_shapes += [getmouseshape()]\n      timer_start(50, (_) => {\n        feedkeys('c')\n        timer_start(50, (_) => {\n          mouse_shapes += [getmouseshape()]\n          timer_start(50, (_) => {\n            writefile(mouse_shapes, 'Xmouseshapes')\n            quit\n          })\n        })\n      })\n    })\n  END\n  call writefile(lines, 'Xmouseshape.vim', 'D')\n  call RunVim([], [], \"-g -S Xmouseshape.vim\")\n  sleep 300m\n  call assert_equal(['busy', 'arrow'], readfile('Xmouseshapes'))\n\n  call delete('Xmouseshapes')\nendfunc\n\n\" Test that mouse shape is restored to Normal mode after cancelling \"gr\".\nfunc Test_mouse_shape_after_cancelling_gr()\n  CheckFeature mouseshape\n  CheckCanRunGui\n\n  let lines =<< trim END\n    vim9script\n    var mouse_shapes = []\n\n    feedkeys('gr')\n    timer_start(50, (_) => {\n      mouse_shapes += [getmouseshape()]\n      timer_start(50, (_) => {\n        feedkeys(\"\\<Esc>\")\n        timer_start(50, (_) => {\n          mouse_shapes += [getmouseshape()]\n          timer_start(50, (_) => {\n            writefile(mouse_shapes, 'Xmouseshapes')\n            quit\n          })\n        })\n      })\n    })\n  END\n  call writefile(lines, 'Xmouseshape.vim', 'D')\n  call RunVim([], [], \"-g -S Xmouseshape.vim\")\n  sleep 300m\n  call assert_equal(['beam', 'arrow'], readfile('Xmouseshapes'))\n\n  call delete('Xmouseshapes')\nendfunc\n\n\" Test that \"j\" does not skip lines when scrolling below botline and\n\" 'foldmethod' is not \"manual\".\nfunc Test_normal_j_below_botline()\n  CheckScreendump\n\n  let lines =<< trim END\n    set number foldmethod=diff scrolloff=0\n    call setline(1, map(range(1, 9), 'repeat(v:val, 200)'))\n    norm Lj\n  END\n  call writefile(lines, 'XNormalJBelowBotline', 'D')\n  let buf = RunVimInTerminal('-S XNormalJBelowBotline', #{rows: 19, cols: 40})\n\n  call VerifyScreenDump(buf, 'Test_normal_j_below_botline', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test for r (replace) command with CTRL_V and CTRL_Q\nfunc Test_normal_r_ctrl_v_cmd()\n  new\n  call append(0, 'This is a simple test: abcd')\n  exe \"norm! 1gg$r\\<C-V>\\<C-V>\"\n  call assert_equal(['This is a simple test: abc\u0016', ''], getline(1,'$'))\n  exe \"norm! 1gg$hr\\<C-Q>\\<C-Q>\"\n  call assert_equal(['This is a simple test: ab\u0011\u0016', ''], getline(1,'$'))\n  exe \"norm! 1gg$2hr\\<C-V>x7e\"\n  call assert_equal(['This is a simple test: a~\u0011\u0016', ''], getline(1,'$'))\n  exe \"norm! 1gg$3hr\\<C-Q>x7e\"\n  call assert_equal(['This is a simple test: ~~\u0011\u0016', ''], getline(1,'$'))\n\n  if &encoding == 'utf-8'\n    exe \"norm! 1gg$4hr\\<C-V>u20ac\"\n    call assert_equal(['This is a simple test:\u20ac~~\u0011\u0016', ''], getline(1,'$'))\n    exe \"norm! 1gg$5hr\\<C-Q>u20ac\"\n    call assert_equal(['This is a simple test\u20ac\u20ac~~\u0011\u0016', ''], getline(1,'$'))\n    exe \"norm! 1gg0R\\<C-V>xff WAS  \\<esc>\"\n    call assert_equal(['\u00ff WAS   a simple test\u20ac\u20ac~~\u0011\u0016', ''], getline(1,'$'))\n    exe \"norm! 1gg0elR\\<C-Q>xffNOT\\<esc>\"\n    call assert_equal(['\u00ff WAS\u00ffNOT simple test\u20ac\u20ac~~\u0011\u0016', ''], getline(1,'$'))\n  endif\n\n  call setline(1, 'This is a simple test: abcd')\n  exe \"norm! 1gg$gr\\<C-V>\\<C-V>\"\n  call assert_equal(['This is a simple test: abc\u0016', ''], getline(1,'$'))\n  exe \"norm! 1gg$hgr\\<C-Q>\\<C-Q>\"\n  call assert_equal(['This is a simple test: ab\u0011 ', ''], getline(1,'$'))\n  exe \"norm! 1gg$2hgr\\<C-V>x7e\"\n  call assert_equal(['This is a simple test: a~\u0011 ', ''], getline(1,'$'))\n  exe \"norm! 1gg$3hgr\\<C-Q>x7e\"\n  call assert_equal(['This is a simple test: ~~\u0011 ', ''], getline(1,'$'))\n\n  \" clean up\n  bw!\nendfunc\n\n\" Test clicking on a TAB or an unprintable character in Normal mode\nfunc Test_normal_click_on_ctrl_char()\n  let save_mouse = &mouse\n  set mouse=a\n  new\n\n  call setline(1, \"a\\<Tab>b\\<C-K>c\")\n  redraw\n  call test_setmouse(1, 1)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n  call test_setmouse(1, 2)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 2, 0, 2], getcurpos())\n  call test_setmouse(1, 3)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 2, 0, 3], getcurpos())\n  call test_setmouse(1, 7)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 2, 0, 7], getcurpos())\n  call test_setmouse(1, 8)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 2, 0, 8], getcurpos())\n  call test_setmouse(1, 9)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 3, 0, 9], getcurpos())\n  call test_setmouse(1, 10)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 4, 0, 10], getcurpos())\n  call test_setmouse(1, 11)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 4, 0, 11], getcurpos())\n  call test_setmouse(1, 12)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 5, 0, 12], getcurpos())\n  call test_setmouse(1, 13)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 5, 0, 13], getcurpos())\n\n  bwipe!\n  let &mouse = save_mouse\nendfunc\n\n\" Test clicking on a double-width character in Normal mode\nfunc Test_normal_click_on_double_width_char()\n  let save_mouse = &mouse\n  set mouse=a\n  new\n\n  call setline(1, \"\u53e3\u53e3\")\n  redraw\n  call test_setmouse(1, 1)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n  call test_setmouse(1, 2)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 1, 0, 2], getcurpos())\n  call test_setmouse(1, 3)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 4, 0, 3], getcurpos())\n  call test_setmouse(1, 4)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 1, 4, 0, 4], getcurpos())\n\n  bwipe!\n  let &mouse = save_mouse\nendfunc\n\nfunc Test_normal_click_on_empty_line()\n  let save_mouse = &mouse\n  set mouse=a\n  botright new\n  call setline(1, ['', '', ''])\n  let row = win_screenpos(0)[0] + 2\n  20vsplit\n  redraw\n\n  call test_setmouse(row, 1)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 3, 1, 0, 1], getcurpos())\n  call test_setmouse(row, 2)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 3, 1, 0, 2], getcurpos())\n  call test_setmouse(row, 10)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 3, 1, 0, 10], getcurpos())\n\n  call test_setmouse(row, 21 + 1)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 3, 1, 0, 1], getcurpos())\n  call test_setmouse(row, 21 + 2)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 3, 1, 0, 2], getcurpos())\n  call test_setmouse(row, 21 + 10)\n  call feedkeys(\"\\<LeftMouse>\", 'xt')\n  call assert_equal([0, 3, 1, 0, 10], getcurpos())\n\n  bwipe!\n  let &mouse = save_mouse\nendfunc\n\nfunc Test_normal33_g_cmd_nonblank()\n  \" Test that g<End> goes to the last non-blank char and g$ to the last\n  \" visible column\n  20vnew\n  setlocal nowrap nonumber signcolumn=no\n  call setline(1, ['fooo   fooo         fooo   fooo         fooo   fooo         fooo   fooo        '])\n  exe \"normal 0g\\<End>\"\n  call assert_equal(11, col('.'))\n  normal 0g$\n  call assert_equal(20, col('.'))\n  exe \"normal 0g\\<kEnd>\"\n  call assert_equal(11, col('.'))\n  setlocal wrap\n  exe \"normal 0g\\<End>\"\n  call assert_equal(11, col('.'))\n  normal 0g$\n  call assert_equal(20, col('.'))\n  exe \"normal 0g\\<kEnd>\"\n  call assert_equal(11, col('.'))\n  bw!\nendfunc\n\nfunc Test_normal34_zet_large()\n  \" shouldn't cause overflow\n  norm! z9765405999999999999\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n#  ifdef DYNAMIC_PYTHON3_STABLE_ABI\n\t\"+python3/dyn-stable\",\n#  else\n\t\"+python3/dyn\",\n#  endif\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n# ifdef FEAT_XATTR\n\t\"+xattr\",\n# else\n\t\"-xattr\",\n# endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/normal.c", "src/testdir/test_normal.vim", "src/version.c"], "buggy_code_start_loc": [2564, 4161, 706], "buggy_code_end_loc": [2565, 4161, 706], "fixing_code_start_loc": [2565, 4162, 707], "fixing_code_end_loc": [2573, 4167, 709], "type": "CWE-190", "message": "Vim is an open source command line text editor. When getting the count for a normal mode z command, it may overflow for large counts given. Impact is low, user interaction is required and a crash may not even happen in all situations. This issue has been addressed in commit `58f9befca1` which has been included in release version 9.0.2109. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-48234", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-16T23:15:09.200", "lastModified": "2024-01-25T21:33:46.273", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Vim is an open source command line text editor. When getting the count for a normal mode z command, it may overflow for large counts given. Impact is low, user interaction is required and a crash may not even happen in all situations. This issue has been addressed in commit `58f9befca1` which has been included in release version 9.0.2109. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "Vim es un editor de texto de l\u00ednea de comandos de c\u00f3digo abierto. Al obtener el recuento para un comando z en modo normal, es posible que se desborde si se dan recuentos grandes. El impacto es bajo, se requiere la interacci\u00f3n del usuario y es posible que ni siquiera ocurra una falla en todas las situaciones. Este problema se solucion\u00f3 en el commit `58f9befca1` que se incluy\u00f3 en la versi\u00f3n 9.0.2109. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.8, "baseSeverity": "LOW"}, "exploitabilityScore": 1.3, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.2109", "matchCriteriaId": "BE128471-9EE5-48E3-A9C3-B261E1F24DE9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:39:*:*:*:*:*:*:*", "matchCriteriaId": "B8EDB836-4E6A-4B71-B9B2-AA3E03E0F646"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2023/11/16/1", "source": "security-advisories@github.com", "tags": ["Mailing List"]}, {"url": "https://github.com/vim/vim/commit/58f9befca1fa172068effad7f2ea5a9d6a7b0cca", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/vim/vim/security/advisories/GHSA-59gw-c949-6phq", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4UJAK2W5S7G75ETDAEM3BDUCVSXCEGRD/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/M3VQF7CL3V6FGSEW37WNDFBRRILR65AK/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VNRNYLWXZOGTYWE5HMFNQ5FVE3HBUHF6/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20231227-0004/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/58f9befca1fa172068effad7f2ea5a9d6a7b0cca"}}