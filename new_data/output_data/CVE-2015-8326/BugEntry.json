{"buggy_code": ["#\n##################################################################\n#\n# File: IPTables::Parse.pm\n#\n# Purpose: Perl interface to parse iptables and ip6tables rulesets.\n#\n# Author: Michael Rash (mbr@cipherdyne.org)\n#\n# Version: 1.5\n#\n##################################################################\n#\n\npackage IPTables::Parse;\n\nuse 5.006;\nuse POSIX \":sys_wait_h\";\nuse Carp;\nuse strict;\nuse warnings;\nuse vars qw($VERSION);\n\n$VERSION = '1.5';\n\nsub new() {\n    my $class = shift;\n    my %args  = @_;\n\n    my $ipt_bin  = '/sbin/iptables';\n    my $ipt6_bin = '/sbin/ip6tables';\n    my $fwc_bin  = '/usr/bin/firewall-cmd';\n\n    my $self = {\n        _iptables        => $args{'iptables'} || $args{'ip6tables'} || '',\n        _firewall_cmd    => $args{'firewall-cmd'} || '',\n        _fwd_args        => $args{'fwd_args'}     || '--direct --passthrough ipv4',\n        _ipv6            => $args{'use_ipv6'}     || 0,\n        _iptout          => $args{'iptout'}       || '/tmp/ipt.out' . $$,\n        _ipterr          => $args{'ipterr'}       || '/tmp/ipt.err' . $$,\n        _ipt_alarm       => $args{'ipt_alarm'}    || 30,\n        _debug           => $args{'debug'}        || 0,\n        _verbose         => $args{'verbose'}      || 0,\n        _ipt_rules_file  => $args{'ipt_rules_file'}  || '',\n        _ipt_exec_style  => $args{'ipt_exec_style'}  || 'waitpid',\n        _ipt_exec_sleep  => $args{'ipt_exec_sleep'}  || 0,\n        _sigchld_handler => $args{'sigchld_handler'} || \\&REAPER,\n        _skip_ipt_exec_check => $args{'skip_ipt_exec_check'} || 0\n    };\n\n    if ($self->{'_skip_ipt_exec_check'}) {\n        unless ($self->{'_firewall_cmd'} or $self->{'_iptables'}) {\n            ### default\n            $self->{'_iptables'} = $ipt_bin;\n        }\n    } else {\n        if ($self->{'_firewall_cmd'}) {\n            croak \"[*] $self->{'_firewall_cmd'} incorrect path.\\n\"\n                unless -e $self->{'_firewall_cmd'};\n            croak \"[*] $self->{'_firewall_cmd'} not executable.\\n\"\n                unless -x $self->{'_firewall_cmd'};\n        } elsif ($self->{'_iptables'}) {\n            croak \"[*] $self->{'_iptables'} incorrect path.\\n\"\n                unless -e $self->{'_iptables'};\n            croak \"[*] $self->{'_iptables'} not executable.\\n\"\n                unless -x $self->{'_iptables'};\n        } else {\n            ### check for firewall-cmd first since systems with it\n            ### will have iptables installed as well (but firewall-cmd\n            ### should be used instead if it exists)\n            if (-e $fwc_bin and -x $fwc_bin) {\n                $self->{'_firewall_cmd'} = $fwc_bin;\n            } elsif (-e $ipt_bin and -x $ipt_bin) {\n                $self->{'_iptables'} = $ipt_bin;\n            } elsif (-e $ipt6_bin and -x $ipt6_bin) {\n                $self->{'_iptables'} = $ipt6_bin;\n            } else {\n                croak \"[*] Could not find/execute iptables, \" .\n                    \"specify path via _iptables\\n\";\n            }\n        }\n    }\n\n    if ($self->{'_ipv6'} and $self->{'_iptables'} eq $ipt_bin) {\n        if (-e $ipt6_bin and -x $ipt6_bin) {\n            $self->{'_iptables'} = $ipt6_bin;\n        } else {\n            croak \"[*] Could not find/execute ip6tables, \" .\n                \"specify path via _iptables\\n\";\n        }\n    }\n\n    ### set the firewall binary name\n    $self->{'_ipt_bin_name'} = 'iptables';\n    if ($self->{'_firewall_cmd'}) {\n        $self->{'_ipt_bin_name'} = $1 if $self->{'_firewall_cmd'} =~ m|.*/(\\S+)|;\n    } else {\n        $self->{'_ipt_bin_name'} = $1 if $self->{'_iptables'} =~ m|.*/(\\S+)|;\n    }\n\n    ### handle ipv6\n    if ($self->{'_ipv6'}) {\n        if ($self->{'_firewall_cmd'}) {\n            if ($self->{'_fwd_args'} =~ /ipv4/i) {\n                $self->{'_fwd_args'} = '--direct --passthrough ipv6';\n            }\n        } else {\n            if ($self->{'_ipt_bin_name'} eq 'iptables') {\n                unless ($self->{'_skip_ipt_exec_check'}) {\n                    croak \"[*] use_ipv6 is true, \" .\n                        \"but $self->{'_iptables'} not ip6tables.\\n\";\n                }\n            }\n        }\n    }\n\n    $self->{'_ipv6'} = 1 if $self->{'_ipt_bin_name'} eq 'ip6tables';\n    if ($self->{'_firewall_cmd'}) {\n        $self->{'_ipv6'} = 1 if $self->{'_fwd_args'} =~ /ipv6/;\n    }\n\n    ### set the main command string to allow for iptables execution\n    ### via firewall-cmd if necessary\n    $self->{'_cmd'} = $self->{'_iptables'};\n    if ($self->{'_firewall_cmd'}) {\n        $self->{'_cmd'} = \"$self->{'_firewall_cmd'} $self->{'_fwd_args'}\";\n    }\n\n    $self->{'parse_keys'} = &parse_keys();\n\n    bless $self, $class;\n}\n\nsub DESTROY {\n    my $self = shift;\n\n    ### clean up tmp files\n    unless ($self->{'_debug'}) {\n        unlink $self->{'_iptout'};\n        unlink $self->{'_ipterr'};\n    }\n\n    return;\n}\n\nsub parse_keys() {\n    my $self = shift;\n\n    ### only used for IPv4 + NAT\n    my $ipv4_re = qr|(?:[0-2]?\\d{1,2}\\.){3}[0-2]?\\d{1,2}|;\n\n    my %keys = (\n        'regular' => {\n            'packets'  => {\n                'regex'     => '',\n                'ipt_match' => ''\n            },\n            'bytes'    => {\n                'regex'     => '',\n                'ipt_match' => ''\n            },\n            'target'   => {\n                'regex'     => '',\n                'ipt_match' => ''\n            },\n            'protocol' => {\n                'regex'     => '',\n                'ipt_match' => '-p'\n            },\n            'proto'    => {\n                'regex'     => '',\n                'ipt_match' => '-p'\n            },\n            'intf_in'  => {\n                'regex'     => '',\n                'ipt_match' => '-i'\n            },\n            'intf_out' => {\n                'regex'     => '',\n                'ipt_match' => '-o'\n            },\n            'src'      => {\n                'regex'     => '',\n                'ipt_match' => '-s'\n            },\n            'dst'      => {\n                'regex'     => '',\n                'ipt_match' => '-d'\n            }\n        },\n        'extended' => {\n            's_port' => {\n                'regex'     => qr/\\bspts?:(\\S+)/,\n                'ipt_match' => '--sport'\n            },\n            'sport' => {\n                'regex'     => qr/\\bspts?:(\\S+)/,\n                'ipt_match' => '--sport'\n            },\n            'd_port' => {\n                'regex'     => qr/\\bdpts?:(\\S+)/,\n                'ipt_match' => '--dport'\n            },\n            'dport' => {\n                'regex'     => qr/\\bdpts?:(\\S+)/,\n                'ipt_match' => '--dport'\n            },\n            'to_ip' => {\n                'regex'     => qr/\\bto:($ipv4_re):\\d+/,\n                'ipt_match' => ''\n            },\n            'to_port' => {\n                'regex'     => qr/\\bto:$ipv4_re:(\\d+)/,\n                'ipt_match' => ''\n            },\n            'mac_source' => {\n                'regex'     => qr/\\bMAC\\s+(\\S+)/,\n                'ipt_match' => '-m mac --mac-source'\n            },\n            'state' => {\n                'regex'     => qr/\\bstate\\s+(\\S+)/,\n                'ipt_match' => '-m state --state'\n            },\n            'ctstate' => {\n                'regex'     => qr/\\bctstate\\s+(\\S+)/,\n                'ipt_match' => '-m conntrack --ctstate'\n            },\n            'comment' => {\n                'regex'      => qr|\\/\\*\\s(.*?)\\s\\*\\/|,\n                'ipt_match'  => '-m comment --comment',\n                'use_quotes' => 1\n            },\n            'string' => {\n                'regex'      => qr|STRING\\s+match\\s+\\\"(.*?)\\\"|,\n                'ipt_match'  => '-m string --algo bm --string',\n                'use_quotes' => 1\n            },\n            'length' => {\n                'regex'      => qr|\\blength\\s(\\S+)|,\n                'ipt_match'  => '-m length --length',\n            },\n        },\n        'rule_num' => '',\n        'raw' => ''\n    );\n\n    return \\%keys;\n}\n\nsub list_table_chains() {\n    my $self   = shift;\n    my $table  = shift || croak '[*] Specify a table, e.g. \"nat\"';\n    my $file   = shift || '';\n\n    my @ipt_lines = ();\n    my @chains = ();\n\n    if ($self->{'_ipt_rules_file'} and not $file) {\n        $file = $self->{'_ipt_rules_file'};\n    }\n\n    if ($file) {\n        ### read the iptables rules out of $file instead of executing\n        ### the iptables command.\n        open F, \"< $file\" or croak \"[*] Could not open file $file: $!\";\n        @ipt_lines = <F>;\n        close F;\n    } else {\n        my ($rv, $out_ar, $err_ar) = $self->exec_iptables(\n                \"$self->{'_cmd'} -t $table -v -n -L\");\n        @ipt_lines = @$out_ar;\n    }\n\n    for (@ipt_lines) {\n        if (/^\\s*Chain\\s(.*?)\\s\\(/) {\n            push @chains, $1;\n        }\n    }\n    return \\@chains;\n}\n\nsub chain_policy() {\n    my $self   = shift;\n    my $table  = shift || croak '[*] Specify a table, e.g. \"nat\"';\n    my $chain  = shift || croak '[*] Specify a chain, e.g. \"OUTPUT\"';\n    my $file   = shift || '';\n\n    my @ipt_lines = ();\n\n    if ($self->{'_ipt_rules_file'} and not $file) {\n        $file = $self->{'_ipt_rules_file'};\n    }\n\n    if ($file) {\n        ### read the iptables rules out of $file instead of executing\n        ### the iptables command.\n        open F, \"< $file\" or croak \"[*] Could not open file $file: $!\";\n        @ipt_lines = <F>;\n        close F;\n    } else {\n        my ($rv, $out_ar, $err_ar) = $self->exec_iptables(\n                \"$self->{'_cmd'} -t $table -v -n -L $chain\");\n        @ipt_lines = @$out_ar;\n    }\n\n    my $policy = '';\n\n    for my $line (@ipt_lines) {\n        ### Chain INPUT (policy ACCEPT 16 packets, 800 bytes)\n        if ($line =~ /^\\s*Chain\\s+$chain\\s+\\(policy\\s+(\\w+)/) {\n            $policy = $1;\n            last;\n        }\n    }\n\n    return $policy;\n}\n\nsub chain_action_rules() {\n    return &chain_rules();\n}\n\nsub chain_rules() {\n    my $self   = shift;\n    my $table  = shift || croak '[*] Specify a table, e.g. \"nat\"';\n    my $chain  = shift || croak '[*] Specify a chain, e.g. \"OUTPUT\"';\n    my $file   = shift || '';\n\n    my $found_chain  = 0;\n    my @ipt_lines = ();\n\n    ### only used for IPv4 + NAT\n    my $ip_re = qr|(?:[0-2]?\\d{1,2}\\.){3}[0-2]?\\d{1,2}|;\n\n    ### array of hash refs\n    my @chain = ();\n    my @global_accept_state = ();\n\n    if ($self->{'_ipt_rules_file'} and not $file) {\n        $file = $self->{'_ipt_rules_file'};\n    }\n\n    if ($file) {\n        ### read the iptables rules out of $file instead of executing\n        ### the iptables command.\n        open F, \"< $file\" or croak \"[*] Could not open file $file: $!\";\n        @ipt_lines = <F>;\n        close F;\n    } else {\n        my ($rv, $out_ar, $err_ar) = $self->exec_iptables(\n                \"$self->{'_cmd'} -t $table -v -n -L $chain --line-numbers\");\n        @ipt_lines = @$out_ar;\n    }\n\n    ### determine the output style (e.g. \"-nL -v\" or just plain \"-nL\"; if the\n    ### policy data came from a file then -v might not have been used)\n    my $ipt_verbose = 0;\n    for my $line (@ipt_lines) {\n        if ($line =~ /\\spkts\\s+bytes\\s+target/) {\n            $ipt_verbose = 1;\n            last;\n        }\n    }\n    my $has_line_numbers = 0;\n    for my $line (@ipt_lines) {\n        if ($line =~ /^num\\s+pkts\\s+bytes\\s+target/) {\n            $has_line_numbers = 1;\n            last;\n        }\n    }\n\n    my $rule_num = 0;\n\n    LINE: for my $line (@ipt_lines) {\n        chomp $line;\n\n        last LINE if ($found_chain and $line =~ /^\\s*Chain\\s+/);\n\n        if ($line =~ /^\\s*Chain\\s\\Q$chain\\E\\s\\(/i) {\n            $found_chain = 1;\n            next LINE;\n        }\n        next LINE if $line =~ /\\starget\\s{2,}prot/i;\n        next LINE unless $found_chain;\n        next LINE unless $line;\n\n        ### track the rule number independently of --line-numbers,\n        ### but the values should always match\n        $rule_num++;\n\n        ### initialize hash\n        my %rule = (\n            'extended' => '',\n            'raw'      => $line,\n            'rule_num' => $rule_num\n        );\n        for my $key (keys %{$self->{'parse_keys'}->{'regular'}}) {\n            $rule{$key} = '';\n        }\n        for my $key (keys %{$self->{'parse_keys'}->{'extended'}}) {\n            $rule{$key} = '';\n        }\n\n        my $rule_body = '';\n        my $packets   = '';\n        my $bytes     = '';\n        my $rnum      = '';\n\n        if ($ipt_verbose) {\n            if ($has_line_numbers) {\n                if ($line =~ /^\\s*(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(.*)/) {\n                    $rnum      = $1;\n                    $packets   = $2;\n                    $bytes     = $3;\n                    $rule_body = $4;\n                }\n            } else {\n                if ($line =~ /^\\s*(\\d+)\\s+(\\d+)\\s+(.*)/) {\n                    $packets   = $1;\n                    $bytes     = $2;\n                    $rule_body = $3;\n                }\n            }\n        } else {\n            if ($has_line_numbers) {\n                if ($line =~ /^\\s*(\\d+)\\s+(\\d+)\\s+(.*)/) {\n                    $rnum      = $1;\n                    $rule_body = $2;\n                }\n            }\n        }\n\n        if ($rnum and $rnum ne $rule_num) {\n            croak \"[*] Rule number mis-match.\";\n        }\n\n        if ($ipt_verbose) {\n\n            ### iptables:\n            ### 0     0 ACCEPT  tcp  --  eth1 * 192.168.10.3  0.0.0.0/0  tcp dpt:80\n            ### 0     0 ACCEPT  tcp  --  eth1 * 192.168.10.15 0.0.0.0/0  tcp dpt:22\n            ### 33 2348 ACCEPT  tcp  --  eth1 * 192.168.10.2  0.0.0.0/0  tcp dpt:22\n            ### 0     0 ACCEPT  tcp  --  eth1 * 192.168.10.2  0.0.0.0/0  tcp dpt:80\n            ### 0     0 DNAT    tcp  --  *    * 123.123.123.123 0.0.0.0/0 tcp dpt:55000 to:192.168.12.12:80\n\n            ### ip6tables:\n            ### 0     0 ACCEPT  tcp   *   *   ::/0     fe80::aa:0:1/128    tcp dpt:12345\n            ### 0     0 LOG     all   *   *   ::/0     ::/0                LOG flags 0 level 4\n\n            my $match_re = qr/^(\\S+)\\s+(\\S+)\\s+\\-\\-\\s+\n                                (\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s*(.*)/x;\n\n            if ($self->{'_ipt_bin_name'} eq 'ip6tables'\n                    or ($self->{'_ipt_bin_name'} eq 'firewall-cmd'\n                    and $self->{'_fwd_args'} =~ /\\sipv6/)) {\n                $match_re = qr/^(\\S+)\\s+(\\S+)\\s+\n                                (\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s*(.*)/x;\n            }\n\n            if ($rule_body =~ $match_re) {\n                $rule{'packets'}  = $packets;\n                $rule{'bytes'}    = $bytes;\n                $rule{'target'}   = $1;\n                my $proto = $2;\n                $proto = 'all' if $proto eq '0';\n                $rule{'protocol'} = $rule{'proto'} = lc($proto);\n                $rule{'intf_in'}  = $3;\n                $rule{'intf_out'} = $4;\n                $rule{'src'}      = $5;\n                $rule{'dst'}      = $6;\n                $rule{'extended'} = $7 || '';\n\n                &parse_rule_extended(\\%rule, $self->{'parse_keys'}->{'extended'});\n            }\n        } else {\n\n            ### iptables:\n            ### ACCEPT tcp  -- 164.109.8.0/24  0.0.0.0/0  tcp dpt:22 flags:0x16/0x02\n            ### ACCEPT tcp  -- 216.109.125.67  0.0.0.0/0  tcp dpts:7000:7500\n            ### ACCEPT udp  -- 0.0.0.0/0       0.0.0.0/0  udp dpts:7000:7500\n            ### ACCEPT udp  -- 0.0.0.0/0       0.0.0.0/0  udp dpt:!7000\n            ### ACCEPT icmp --  0.0.0.0/0      0.0.0.0/0\n            ### ACCEPT tcp  --  0.0.0.0/0      0.0.0.0/0  tcp spt:35000 dpt:5000\n            ### ACCEPT tcp  --  10.1.1.1       0.0.0.0/0\n\n            ### LOG  all  --  0.0.0.0/0  0.0.0.0/0  LOG flags 0 level 4 prefix `DROP '\n            ### LOG  all  --  127.0.0.2  0.0.0.0/0  LOG flags 0 level 4\n            ### DNAT tcp  --  123.123.123.123  0.0.0.0/0  tcp dpt:55000 to:192.168.12.12:80\n\n            ### ip6tables:\n            ### ACCEPT     tcp   ::/0     fe80::aa:0:1/128    tcp dpt:12345\n            ### LOG        all   ::/0     ::/0                LOG flags 0 level 4\n\n            my $match_re = qr/^(\\S+)\\s+(\\S+)\\s+\\-\\-\\s+(\\S+)\\s+(\\S+)\\s*(.*)/;\n\n            if ($self->{'_ipt_bin_name'} eq 'ip6tables'\n                    or ($self->{'_ipt_bin_name'} eq 'firewall-cmd'\n                    and $self->{'_fwd_args'} =~ /\\sipv6/)) {\n                $match_re = qr/^(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s*(.*)/;\n            }\n\n            if ($rule_body =~ $match_re) {\n                $rule{'target'}   = $1;\n                my $proto = $2;\n                $proto = 'all' if $proto eq '0';\n                $rule{'protocol'} = $rule{'proto'} = lc($proto);\n                $rule{'src'}      = $3;\n                $rule{'dst'}      = $4;\n                $rule{'extended'} = $5 || '';\n\n                &parse_rule_extended(\\%rule, $self->{'parse_keys'}->{'extended'});\n            }\n        }\n        push @chain, \\%rule;\n    }\n    return \\@chain;\n}\n\nsub parse_rule_extended() {\n    my ($rule_hr, $ext_keys_hr) = @_;\n\n    for my $key (keys %$ext_keys_hr) {\n        if ($rule_hr->{'extended'}\n                =~ /$ext_keys_hr->{$key}->{'regex'}/) {\n            $rule_hr->{$key} = $1;\n        }\n    }\n\n    if ($rule_hr->{'protocol'} eq '0') {\n        $rule_hr->{'s_port'} = $rule_hr->{'sport'} = 0;\n        $rule_hr->{'d_port'} = $rule_hr->{'dport'} = 0;\n    } elsif ($rule_hr->{'protocol'} eq 'tcp'\n            or $rule_hr->{'protocol'} eq 'udp') {\n        $rule_hr->{'s_port'} = $rule_hr->{'sport'} = 0\n            if $rule_hr->{'s_port'} eq '';\n        $rule_hr->{'d_port'} = $rule_hr->{'dport'} = 0\n            if $rule_hr->{'d_port'} eq '';\n    }\n\n    return;\n}\n\nsub default_drop() {\n    my $self  = shift;\n    my $table = shift || croak \"[*] Specify a table, e.g. \\\"nat\\\"\";\n    my $chain = shift || croak \"[*] Specify a chain, e.g. \\\"OUTPUT\\\"\";\n    my $file  = shift || '';\n\n    my @ipt_lines = ();\n\n    if ($self->{'_ipt_rules_file'} and not $file) {\n        $file = $self->{'_ipt_rules_file'};\n    }\n\n    if ($file) {\n        ### read the iptables rules out of $file instead of executing\n        ### the iptables command.\n        open F, \"< $file\" or croak \"[*] Could not open file $file: $!\";\n        @ipt_lines = <F>;\n        close F;\n    } else {\n### FIXME -v for interfaces?\n        my ($rv, $out_ar, $err_ar) = $self->exec_iptables(\n                \"$self->{'_cmd'} -t $table -n -L $chain\");\n        @ipt_lines = @$out_ar;\n    }\n\n    return \"[-] Could not get $self->{'_ipt_bin_name'} output!\", 0\n        unless @ipt_lines;\n\n    my %protocols = ();\n    my $found_chain = 0;\n    my $found_default_drop = 0;\n    my $rule_ctr = 1;\n    my $prefix;\n    my $policy = 'ACCEPT';\n    my $any_ip_re = qr/(?:0\\.){3}0\\x2f0|\\x3a{2}\\x2f0/;\n\n    LINE: for my $line (@ipt_lines) {\n        chomp $line;\n\n        last if ($found_chain and $line =~ /^\\s*Chain\\s+/);\n\n        ### Chain INPUT (policy DROP)\n        ### Chain FORWARD (policy ACCEPT)\n        if ($line =~ /^\\s*Chain\\s+$chain\\s+\\(policy\\s+(\\w+)\\)/) {\n            $policy = $1;\n            $found_chain = 1;\n        }\n        next LINE if $line =~ /^\\s*target\\s/i;\n        next LINE unless $found_chain;\n\n        ### include ULOG target as well\n        my $log_re = qr/^\\s*U?LOG\\s+(\\w+)\\s+\\-\\-\\s+.*\n                $any_ip_re\\s+$any_ip_re\\s+(.*)/x;\n        my $drop_re = qr/^DROP\\s+(\\w+)\\s+\\-\\-\\s+.*\n            $any_ip_re\\s+$any_ip_re\\s*$/x;\n\n        if ($self->{'_ipt_bin_name'} eq 'ip6tables'\n                or ($self->{'_ipt_bin_name'} eq 'firewall-cmd'\n                and $self->{'_fwd_args'} =~ /ipv6/)) {\n            $log_re = qr/^\\s*U?LOG\\s+(\\w+)\\s+\n                    $any_ip_re\\s+$any_ip_re\\s+(.*)/x;\n            $drop_re = qr/^DROP\\s+(\\w+)\\s+\n                $any_ip_re\\s+$any_ip_re\\s*$/x;\n        }\n\n        ### might as well pick up any default logging rules as well\n        if ($line =~ $log_re) {\n            my $proto  = $1;\n            my $p_tmp  = $2;\n            my $prefix = 'NONE';\n\n            ### some recent iptables versions return \"0\" instead of \"all\"\n            ### for the protocol number\n            $proto = 'all' if $proto eq '0';\n            ### LOG flags 0 level 4 prefix `DROP '\n            if ($p_tmp && $p_tmp =~ m|LOG.*\\s+prefix\\s+\n                \\`\\s*(.+?)\\s*\\'|x) {\n                $prefix = $1;\n            }\n            ### $proto may equal \"all\" here\n            $protocols{$proto}{'LOG'}{'prefix'} = $prefix;\n            $protocols{$proto}{'LOG'}{'rulenum'} = $rule_ctr;\n        } elsif ($policy eq 'ACCEPT' and $line =~ $drop_re) {\n            my $proto = $1;\n            $proto = 'all' if $proto eq '0';\n            ### DROP    all  --  0.0.0.0/0     0.0.0.0/0\n            $protocols{$1}{'DROP'} = $rule_ctr;\n            $found_default_drop = 1;\n        }\n        $rule_ctr++;\n    }\n\n    ### if the policy in the chain is DROP, then we don't\n    ### necessarily need to find a default DROP rule.\n    if ($policy eq 'DROP') {\n        $protocols{'all'}{'DROP'} = 0;\n        $found_default_drop = 1;\n    }\n\n    return \"[-] There are no default drop rules in the \" .\n            \"$self->{'_ipt_bin_name'} policy!\", 0\n        unless %protocols and $found_default_drop;\n\n    return \\%protocols, 1;\n}\n\nsub default_log() {\n    my $self  = shift;\n    my $table = shift || croak \"[*] Specify a table, e.g. \\\"nat\\\"\";\n    my $chain = shift || croak \"[*] Specify a chain, e.g. \\\"OUTPUT\\\"\";\n    my $file  = shift || '';\n\n    my $any_ip_re  = qr/(?:0\\.){3}0\\x2f0|\\x3a{2}\\x2f0/;\n    my @ipt_lines  = ();\n    my %log_chains = ();\n    my %log_rules  = ();\n\n    if ($self->{'_ipt_rules_file'} and not $file) {\n        $file = $self->{'_ipt_rules_file'};\n    }\n\n    ### note that we are not restricting the view to the current chain\n    ### with the iptables -nL output; we are going to parse the given\n    ### chain and all chains to which packets are jumped from the given\n    ### chain.\n    if ($file) {\n        ### read the iptables rules out of $file instead of executing\n        ### the iptables command.\n        open F, \"< $file\" or croak \"[*] Could not open file $file: $!\";\n        @ipt_lines = <F>;\n        close F;\n    } else {\n        my ($rv, $out_ar, $err_ar) = $self->exec_iptables(\n                \"$self->{'_cmd'} -t $table -n -L $chain\");\n        @ipt_lines = @$out_ar;\n    }\n\n    ### determine the output style (e.g. \"-nL -v\" or just plain \"-nL\"; if the\n    ### policy data came from a file then -v might not have been used)\n    my $ipt_verbose = 0;\n    for my $line (@ipt_lines) {\n        if ($line =~ /^\\s*pkts\\s+bytes\\s+target/) {\n            $ipt_verbose = 1;\n            last;\n        }\n    }\n\n    return \"[-] Could not get $self->{'_ipt_bin_name'} output!\", 0\n        unless @ipt_lines;\n\n    ### first get all logging rules and associated chains\n    my $log_chain;\n\n    for my $line (@ipt_lines) {\n        chomp $line;\n\n        ### Chain INPUT (policy DROP)\n        ### Chain fwsnort_INPUT_eth1 (1 references)\n        if ($line =~ /^\\s*Chain\\s+(.*?)\\s+\\(/ and\n                $line !~ /0\\s+references/) {\n            $log_chain = $1;\n        }\n        $log_chain = '' unless $line =~ /\\S/;\n        next unless $log_chain;\n\n        my $proto = '';\n        my $found = 0;\n        if ($ipt_verbose) {\n            if ($self->{'_ipt_bin_name'} eq 'ip6tables'\n                    or ($self->{'_ipt_bin_name'} eq 'firewall-cmd'\n                    and $self->{'_fwd_args'} =~ /\\sipv6/)) {\n                if ($line =~ m|^\\s*\\d+\\s+\\d+\\s*U?LOG\\s+(\\w+)\\s+\n                        \\S+\\s+\\S+\\s+$any_ip_re\n                        \\s+$any_ip_re\\s+.*U?LOG|x) {\n                    $proto = $1;\n                    $found = 1;\n                }\n            } else {\n                if ($line =~ m|^\\s*\\d+\\s+\\d+\\s*U?LOG\\s+(\\w+)\\s+\\-\\-\\s+\n                        \\S+\\s+\\S+\\s+$any_ip_re\n                        \\s+$any_ip_re\\s+.*U?LOG|x) {\n                    $proto = $1;\n                    $found = 1;\n                }\n            }\n        } else {\n            if ($self->{'_ipt_bin_name'} eq 'ip6tables'\n                    or ($self->{'_ipt_bin_name'} eq 'firewall-cmd'\n                    and $self->{'_fwd_args'} =~ /\\sipv6/)) {\n                if ($line =~ m|^\\s*U?LOG\\s+(\\w+)\\s+$any_ip_re\n                        \\s+$any_ip_re\\s+.*U?LOG|x) {\n                    $proto = $1;\n                    $found = 1;\n                }\n            } else {\n                if ($line =~ m|^\\s*U?LOG\\s+(\\w+)\\s+\\-\\-\\s+$any_ip_re\n                        \\s+$any_ip_re\\s+.*U?LOG|x) {\n                    $proto = $1;\n                    $found = 1;\n                }\n            }\n        }\n\n        if ($found) {\n            $proto = 'all' if $proto eq '0';\n            ### the above regex allows the limit target to be used\n            $log_chains{$log_chain}{$proto} = '';  ### protocol\n            $log_rules{$proto} = '' if $log_chain eq $chain;\n        }\n    }\n\n    return \"[-] There are no default logging rules \" .\n        \"in the $self->{'_ipt_bin_name'} policy!\", 0 unless %log_chains;\n\n    my %sub_chains = ();\n\n    ### get all sub-chains of the main chain we passed into default_log()\n    &sub_chains($chain, \\%sub_chains, \\@ipt_lines);\n\n    ### see which (if any) logging rules can be mapped back to the\n    ### main chain we passed in.\n    for my $log_chain (keys %log_chains) {\n        if (defined $sub_chains{$log_chain}) {\n            ### the logging rule is in the main chain (e.g. INPUT)\n            for my $proto (keys %{$log_chains{$log_chain}}) {\n                $log_rules{$proto} = '';\n            }\n        }\n    }\n\n    return \\%log_rules, 1;\n}\n\nsub sub_chains() {\n    my ($start_chain, $chains_hr, $ipt_lines_ar) = @_;\n    my $found = 0;\n    for my $line (@$ipt_lines_ar) {\n        chomp $line;\n        ### Chain INPUT (policy DROP)\n        ### Chain fwsnort_INPUT_eth1 (1 references)\n        if ($line =~ /^\\s*Chain\\s+\\Q$start_chain\\E\\s+\\(/ and\n                $line !~ /0\\s+references/) {\n            $found = 1;\n            next;\n        }\n        next unless $found;\n        if ($found and $line =~ /^\\s*Chain\\s/) {\n            last;\n        }\n        if ($line =~ m|^\\s*(\\S+)\\s+\\S+\\s+|) {\n            my $new_chain = $1;\n            if ($new_chain ne 'LOG'\n                    and $new_chain ne 'DROP'\n                    and $new_chain ne 'REJECT'\n                    and $new_chain ne 'ACCEPT'\n                    and $new_chain ne 'RETURN'\n                    and $new_chain ne 'QUEUE'\n                    and $new_chain ne 'SNAT'\n                    and $new_chain ne 'DNAT'\n                    and $new_chain ne 'MASQUERADE'\n                    and $new_chain ne 'pkts'\n                    and $new_chain ne 'Chain'\n                    and $new_chain ne 'target') {\n                $chains_hr->{$new_chain} = '';\n                &sub_chains($new_chain, $chains_hr, $ipt_lines_ar);\n            }\n        }\n    }\n    return;\n}\n\nsub exec_iptables() {\n    my $self  = shift;\n    my $cmd = shift || croak \"[*] Must specify an \" .\n        \"$self->{'_ipt_bin_name'} command to run.\";\n    my $iptout    = $self->{'_iptout'};\n    my $ipterr    = $self->{'_ipterr'};\n    my $debug     = $self->{'_debug'};\n    my $ipt_alarm = $self->{'_ipt_alarm'};\n    my $verbose   = $self->{'_verbose'};\n    my $ipt_exec_style = $self->{'_ipt_exec_style'};\n    my $ipt_exec_sleep = $self->{'_ipt_exec_sleep'};\n    my $sigchld_handler = $self->{'_sigchld_handler'};\n\n    croak \"[*] $cmd does not look like an $self->{'_ipt_bin_name'} command.\"\n        unless $cmd =~ m|^\\s*iptables| or $cmd =~ m|^\\S+/iptables|\n            or $cmd =~ m|^\\s*ip6tables| or $cmd =~ m|^\\S+/ip6tables|\n            or $cmd =~ m|^\\s*firewall-cmd| or $cmd =~ m|^\\S+/firewall-cmd|;\n\n    ### sanitize $cmd - this is not bullet proof, but better than\n    ### nothing (especially for strange iptables chain names). Further,\n    ### quotemeta() is too aggressive since things like IPv6 addresses\n    ### contain \":\" chars, etc.\n    $cmd =~ s/([;<>\\$\\|`\\@&\\(\\)\\[\\]\\{\\}])/\\\\$1/g;\n\n    my $rv = 1;\n    my @stdout = ();\n    my @stderr = ();\n\n    my $fh = *STDERR;\n    $fh = *STDOUT if $verbose;\n\n    if ($debug or $verbose) {\n        print $fh localtime() . \" [+] IPTables::Parse::\",\n            \"exec_iptables(${ipt_exec_style}()) $cmd\\n\";\n        if ($ipt_exec_sleep > 0) {\n            print $fh localtime() . \" [+] IPTables::Parse::\",\n                \"exec_iptables() sleep seconds: $ipt_exec_sleep\\n\";\n        }\n    }\n\n    if ($ipt_exec_sleep > 0) {\n        if ($debug or $verbose) {\n            print $fh localtime() . \" [+] IPTables::Parse: \",\n                \"sleeping for $ipt_exec_sleep seconds before \",\n                \"executing $self->{'_ipt_bin_name'} command.\\n\";\n        }\n        sleep $ipt_exec_sleep;\n    }\n\n    if ($ipt_exec_style eq 'system') {\n        system qq{$cmd > $iptout 2> $ipterr};\n    } elsif ($ipt_exec_style eq 'popen') {\n        open CMD, \"$cmd 2> $ipterr |\" or croak \"[*] Could not execute $cmd: $!\";\n        @stdout = <CMD>;\n        close CMD;\n        open F, \"> $iptout\" or croak \"[*] Could not open $iptout: $!\";\n        print F for @stdout;\n        close F;\n    } else {\n        my $ipt_pid;\n\n        if ($debug or $verbose) {\n            print $fh localtime() . \" [+] IPTables::Parse: \" .\n                \"Setting SIGCHLD handler to: \" . $sigchld_handler . \"\\n\";\n        }\n\n        local $SIG{'CHLD'} = $sigchld_handler;\n        if ($ipt_pid = fork()) {\n            eval {\n                ### iptables should never take longer than 30 seconds to execute,\n                ### unless there is some absolutely enormous policy or the kernel\n                ### is exceedingly busy\n                local $SIG{'ALRM'} = sub {die \"[*] $self->{'_ipt_bin_name'} \" .\n                    \"command timeout.\\n\"};\n                alarm $ipt_alarm;\n                waitpid($ipt_pid, 0);\n                alarm 0;\n            };\n            if ($@) {\n                kill 9, $ipt_pid unless kill 15, $ipt_pid;\n            }\n        } else {\n            croak \"[*] Could not fork $self->{'_ipt_bin_name'}: $!\"\n                unless defined $ipt_pid;\n\n            ### exec the iptables command and preserve stdout and stderr\n            exec qq{$cmd > $iptout 2> $ipterr};\n        }\n    }\n\n    if (-e $iptout) {\n        open F, \"< $iptout\" or croak \"[*] Could not open $iptout\";\n        @stdout = <F>;\n        close F;\n    }\n    if (-e $ipterr) {\n        open F, \"< $ipterr\" or croak \"[*] Could not open $ipterr\";\n        @stderr = <F>;\n        close F;\n\n        $rv = 0 if @stderr;\n    }\n\n    if (@stdout) {\n        if ($stdout[$#stdout] =~ /^success/) {\n            pop @stdout;\n        }\n        if ($self->{'_ipt_bin_name'} eq 'firewall-cmd') {\n            for (@stdout) {\n                if (/COMMAND_FAILED/) {\n                    $rv = 0;\n                    last;\n                }\n            }\n        }\n    }\n\n    if ($debug or $verbose) {\n        print $fh localtime() . \"     $self->{'_ipt_bin_name'} \" .\n            \"command stdout:\\n\";\n        for my $line (@stdout) {\n            if ($line =~ /\\n$/) {\n                print $fh $line;\n            } else {\n                print $fh $line, \"\\n\";\n            }\n        }\n        print $fh localtime() . \"     $self->{'_ipt_bin_name'} \" .\n            \"command stderr:\\n\";\n        for my $line (@stderr) {\n            if ($line =~ /\\n$/) {\n                print $fh $line;\n            } else {\n                print $fh $line, \"\\n\";\n            }\n        }\n    }\n\n    if ($debug or $verbose) {\n        print $fh localtime() . \"     Return value: $rv\\n\";\n    }\n\n    return $rv, \\@stdout, \\@stderr;\n}\n\nsub REAPER {\n    my $stiff;\n    while(($stiff = waitpid(-1,WNOHANG))>0){\n        # do something with $stiff if you want\n    }\n    local $SIG{'CHLD'} = \\&REAPER;\n    return;\n}\n\n1;\n__END__\n\n=head1 NAME\n\nIPTables::Parse - Perl extension for parsing iptables and ip6tables policies\n\n=head1 SYNOPSIS\n\n  use IPTables::Parse;\n\n  my %opts = (\n      'use_ipv6' => 0,         # can set to 1 to force ip6tables usage\n      'ipt_rules_file' => '',  # optional file path from\n                               # which to read iptables rules\n      'iptout'   => '/tmp/iptables.out',\n      'ipterr'   => '/tmp/iptables.err',\n      'debug'    => 0,\n      'verbose'  => 0\n  );\n\n  my $ipt_obj = IPTables::Parse->new(%opts)\n      or die \"[*] Could not acquire IPTables::Parse object\";\n\n  my $rv = 0;\n\n  ### look for default DROP rules in the filter table INPUT chain\n  my ($ipt_hr, $rv) = $ipt_obj->default_drop('filter', 'INPUT');\n  if ($rv) {\n      if (defined $ipt_hr->{'all'}) {\n          print \"The INPUT chain has a default DROP rule for all protocols.\\n\";\n      } else {\n          my $found = 0;\n          for my $proto (qw/tcp udp icmp/) {\n              if (defined $ipt_hr->{$proto}) {\n                  print \"The INPUT chain drops $proto by default.\\n\";\n                  $found = 1;\n              }\n          }\n          unless ($found) {\n              print \"The INPUT chain does not have any default DROP rule.\\n\";\n          }\n      }\n  } else {\n      print \"[-] Could not parse $ipt_obj->{'_ipt_bin_name'} policy\\n\";\n  }\n\n  ### look for default LOG rules in the filter table INPUT chain\n  ($ipt_hr, $rv) = $ipt_obj->default_log('filter', 'INPUT');\n  if ($rv) {\n      if (defined $ipt_hr->{'all'}) {\n          print \"The INPUT chain has a default LOG rule for all protocols.\\n\";\n      } else {\n          my $found = 0;\n          for my $proto (qw/tcp udp icmp/) {\n              if (defined $ipt_hr->{$proto}) {\n                  print \"The INPUT chain logs $proto by default.\\n\";\n                  $found = 1;\n              }\n          }\n          unless ($found) {\n              print \"The INPUT chain does not have any default LOG rule.\\n\";\n          }\n      }\n  } else {\n      print \"[-] Could not parse $ipt_obj->{'_ipt_bin_name'} policy\\n\";\n  }\n\n  ### print all chains in the filter table\n  for my $chain (@{$ipt_obj->list_table_chains('filter')}) {\n      print $chain, \"\\n\";\n  }\n\n=head1 DESCRIPTION\n\nThe C<IPTables::Parse> package provides an interface to parse iptables or\nip6tables rules on Linux systems through the direct execution of\niptables/ip6tables commands, or from parsing a file that contains an\niptables/ip6tables policy listing. Note that the 'firewalld' infrastructure on\nFedora21 is also supported through execution of the 'firewall-cmd' binary.\nBy default, the path to iptables is assumed to be '/sbin/iptables', but if the\nfirewall is 'firewalld', then the '/usr/bin/firewall-cmd' is used.\n\nWith this module, you can get the current policy applied to a\ntable/chain, look for a specific user-defined chain, check for a default DROP\npolicy, or determine whether or not a default LOG rule exists. Also, you can\nget a listing of all rules in a chain with each rule parsed into its own hash.\n\nNote that if you initialize the IPTables::Parse object with the 'ipt_rules_file'\nkey, then all parsing routines will open the specified file for iptables rules\ndata. So, you can create this file with a command like\n'iptables -t filter -nL -v > ipt.rules', and then initialize the object with\nIPTables::Parse->new('ipt_rules_file' => 'ipt.rules'). Further, if you are\nrunning on a system without iptables installed, but you have an iptables policy\nwritten to the ipt.rules file, then you can pass in 'skip_ipt_exec_check=>1'\nin order to analyze the file without having IPTables::Parse check for the\niptables binary.\n\nIn summary, in addition to the hash keys mentioned above, optional keys that\ncan be passed to new() include '_iptables' (set path to iptables binary),\n'_firewall_cmd' (set path to 'firewall-cmd' binary for systems with\n'firewalld'), '_fwd_args' (set 'firewall-cmd' usage args; defaults to\n'--direct --passthrough ipv4'), '_ipv6' (set IPv6 mode for ip6tables),\n'_debug' and '_verbose'.\n\n=head1 FUNCTIONS\n\nThe IPTables::Parse extension provides an object interface to the following\nfunctions:\n\n=over 4\n\n=item chain_policy($table, $chain)\n\nThis function returns the policy (e.g. 'DROP', 'ACCEPT', etc.) for the specified\ntable and chain:\n\n  print \"INPUT policy: \",\n        $ipt_obj->chain_policy('filter', 'INPUT'), \"\\n\";\n\n=item chain_rules($table, $chain)\n\nThis function parses the specified chain and table and returns an array reference\nfor all rules in the chain.  Each element in the array reference is a hash with\nthe following keys (that contain values depending on the rule): C<src>, C<dst>,\nC<protocol>, C<s_port>, C<d_port>, C<target>, C<packets>, C<bytes>, C<intf_in>,\nC<intf_out>, C<to_ip>, C<to_port>, C<state>, C<raw>, and C<extended>.  The C<extended>\nelement contains the rule output past the protocol information, and the C<raw>\nelement contains the complete rule itself as reported by iptables or ip6tables.\nHere is an example of checking whether the second rule in the INPUT chain (array\nindex 1) allows traffic from any IP to TCP port 80:\n\n  $rules_ar = $ipt_obj->chain_rules('filter', 'INPUT);\n\n  if ($rules_ar->[1]->{'src'} eq '0.0.0.0/0'\n          and $rules_ar->[1]->{'protocol'} eq 'tcp'\n          and $rules_ar->[1]->{'d_port'}   eq '80'\n          and $rules_ar->[1]->{'target'}   eq 'ACCEPT') {\n\n      print \"traffic accepted to TCP port 80 from anywhere\\n\";\n  }\n\n=item default_drop($table, $chain)\n\nThis function parses the running iptables or ip6tables policy in order to\ndetermine if the specified chain contains a default DROP rule.  Two values\nare returned, a hash reference whose keys are the protocols that are dropped by\ndefault (if a global ACCEPT rule has not accepted matching packets first), along\nwith a return value that tells the caller if parsing the iptables or ip6tables\npolicy was successful.  Note that if all protocols are dropped by default, then\nthe hash key 'all' will be defined.\n\n  ($ipt_hr, $rv) = $ipt_obj->default_drop('filter', 'INPUT');\n\n=item default_log($table, $chain)\n\nThis function parses the running iptables or ip6tables policy in order to determine if\nthe specified chain contains a default LOG rule.  Two values are returned,\na hash reference whose keys are the protocols that are logged by default\n(if a global ACCEPT rule has not accepted matching packets first), along with\na return value that tells the caller if parsing the iptables or ip6tables policy was\nsuccessful.  Note that if all protocols are logged by default, then the\nhash key 'all' will be defined.  An example invocation is:\n\n  ($ipt_hr, $rv) = $ipt_obj->default_log('filter', 'INPUT');\n\n=item list_table_chains($table)\n\nThis function parses the specified table for all chains that are defined within\nthe table. Data is returned as an array reference. For example, if there are no\nuser-defined chains in the 'filter' table, then the returned array reference will\ncontain the strings 'INPUT', 'FORWARD', and 'OUTPUT'.\n\n  for my $chain (@{$ipt_obj->list_table_chains('filter')}) {\n      print $chain, \"\\n\";\n  }\n\n=back\n\n=head1 AUTHOR\n\nMichael Rash, E<lt>mbr@cipherdyne.orgE<gt>\n\n=head1 SEE ALSO\n\nThe IPTables::Parse module is used by the IPTables::ChainMgr extension in support of\nthe psad and fwsnort projects to parse iptables or ip6tables policies (see the psad(8),\nand fwsnort(8) man pages).  As always, the iptables(8) and ip6tables(8) man pages\nprovide the best information on command line execution and theory behind iptables\nand ip6tables.\n\nAlthough there is no mailing that is devoted specifically to the IPTables::Parse\nextension, questions about the extension will be answered on the following\nlists:\n\n  The psad mailing list: http://lists.sourceforge.net/lists/listinfo/psad-discuss\n  The fwsnort mailing list: http://lists.sourceforge.net/lists/listinfo/fwsnort-discuss\n\nThe latest version of the IPTables::Parse extension can be found on CPAN and\nalso here:\n\n  http://www.cipherdyne.org/modules/\n\nSource control is provided by git:\n\n  https://github.com/mrash/IPTables-Parse.git\n\n=head1 CREDITS\n\nThanks to the following people:\n\n  Franck Joncourt <franck.mail@dthconnex.com>\n  Stuart Schneider\n  Grant Ferley\n  Fabien Mazieres\n\n=head1 AUTHOR\n\nThe IPTables::Parse extension was written by Michael Rash F<E<lt>mbr@cipherdyne.orgE<gt>>\nto support the psad and fwsnort projects.  Please send email to\nthis address if there are any questions, comments, or bug reports.\n\n=head1 VERSION\n\nVersion 1.5 (Septebmer, 2015)\n\n=head1 COPYRIGHT AND LICENSE\n\nCopyright (C) 2005-2015 Michael Rash.  All rights reserved.\n\nThis module is free software.  You can redistribute it and/or\nmodify it under the terms of the Artistic License 2.0.  More information\ncan be found here: http://www.perl.com/perl/misc/Artistic.html\n\nThis program is distributed \"as is\" in the hope that it will be useful,\nbut without any warranty; without even the implied warranty of\nmerchantability or fitness for a particular purpose.\n\n=cut\n"], "fixing_code": ["#\n##################################################################\n#\n# File: IPTables::Parse.pm\n#\n# Purpose: Perl interface to parse iptables and ip6tables rulesets.\n#\n# Author: Michael Rash (mbr@cipherdyne.org)\n#\n# Version: 1.5\n#\n##################################################################\n#\n\npackage IPTables::Parse;\n\nuse 5.006;\nuse POSIX \":sys_wait_h\";\nuse Carp;\nuse File::Temp;\nuse strict;\nuse warnings;\nuse vars qw($VERSION);\n\n$VERSION = '1.5';\n\nsub new() {\n    my $class = shift;\n    my %args  = @_;\n\n    my $ipt_bin  = '/sbin/iptables';\n    my $ipt6_bin = '/sbin/ip6tables';\n    my $fwc_bin  = '/usr/bin/firewall-cmd';\n\n    my $self = {\n        _iptables        => $args{'iptables'} || $args{'ip6tables'} || '',\n        _firewall_cmd    => $args{'firewall-cmd'} || '',\n        _fwd_args        => $args{'fwd_args'}     || '--direct --passthrough ipv4',\n        _ipv6            => $args{'use_ipv6'}     || 0,\n        _iptout          => $args{'iptout'}       || mktemp('/tmp/ipt.out.XXXXXX'),\n        _ipterr          => $args{'ipterr'}       || mktemp('/tmp/ipt.err.XXXXXX'),\n        _ipt_alarm       => $args{'ipt_alarm'}    || 30,\n        _debug           => $args{'debug'}        || 0,\n        _verbose         => $args{'verbose'}      || 0,\n        _ipt_rules_file  => $args{'ipt_rules_file'}  || '',\n        _ipt_exec_style  => $args{'ipt_exec_style'}  || 'waitpid',\n        _ipt_exec_sleep  => $args{'ipt_exec_sleep'}  || 0,\n        _sigchld_handler => $args{'sigchld_handler'} || \\&REAPER,\n        _skip_ipt_exec_check => $args{'skip_ipt_exec_check'} || 0\n    };\n\n    if ($self->{'_skip_ipt_exec_check'}) {\n        unless ($self->{'_firewall_cmd'} or $self->{'_iptables'}) {\n            ### default\n            $self->{'_iptables'} = $ipt_bin;\n        }\n    } else {\n        if ($self->{'_firewall_cmd'}) {\n            croak \"[*] $self->{'_firewall_cmd'} incorrect path.\\n\"\n                unless -e $self->{'_firewall_cmd'};\n            croak \"[*] $self->{'_firewall_cmd'} not executable.\\n\"\n                unless -x $self->{'_firewall_cmd'};\n        } elsif ($self->{'_iptables'}) {\n            croak \"[*] $self->{'_iptables'} incorrect path.\\n\"\n                unless -e $self->{'_iptables'};\n            croak \"[*] $self->{'_iptables'} not executable.\\n\"\n                unless -x $self->{'_iptables'};\n        } else {\n            ### check for firewall-cmd first since systems with it\n            ### will have iptables installed as well (but firewall-cmd\n            ### should be used instead if it exists)\n            if (-e $fwc_bin and -x $fwc_bin) {\n                $self->{'_firewall_cmd'} = $fwc_bin;\n            } elsif (-e $ipt_bin and -x $ipt_bin) {\n                $self->{'_iptables'} = $ipt_bin;\n            } elsif (-e $ipt6_bin and -x $ipt6_bin) {\n                $self->{'_iptables'} = $ipt6_bin;\n            } else {\n                croak \"[*] Could not find/execute iptables, \" .\n                    \"specify path via _iptables\\n\";\n            }\n        }\n    }\n\n    if ($self->{'_ipv6'} and $self->{'_iptables'} eq $ipt_bin) {\n        if (-e $ipt6_bin and -x $ipt6_bin) {\n            $self->{'_iptables'} = $ipt6_bin;\n        } else {\n            croak \"[*] Could not find/execute ip6tables, \" .\n                \"specify path via _iptables\\n\";\n        }\n    }\n\n    ### set the firewall binary name\n    $self->{'_ipt_bin_name'} = 'iptables';\n    if ($self->{'_firewall_cmd'}) {\n        $self->{'_ipt_bin_name'} = $1 if $self->{'_firewall_cmd'} =~ m|.*/(\\S+)|;\n    } else {\n        $self->{'_ipt_bin_name'} = $1 if $self->{'_iptables'} =~ m|.*/(\\S+)|;\n    }\n\n    ### handle ipv6\n    if ($self->{'_ipv6'}) {\n        if ($self->{'_firewall_cmd'}) {\n            if ($self->{'_fwd_args'} =~ /ipv4/i) {\n                $self->{'_fwd_args'} = '--direct --passthrough ipv6';\n            }\n        } else {\n            if ($self->{'_ipt_bin_name'} eq 'iptables') {\n                unless ($self->{'_skip_ipt_exec_check'}) {\n                    croak \"[*] use_ipv6 is true, \" .\n                        \"but $self->{'_iptables'} not ip6tables.\\n\";\n                }\n            }\n        }\n    }\n\n    $self->{'_ipv6'} = 1 if $self->{'_ipt_bin_name'} eq 'ip6tables';\n    if ($self->{'_firewall_cmd'}) {\n        $self->{'_ipv6'} = 1 if $self->{'_fwd_args'} =~ /ipv6/;\n    }\n\n    ### set the main command string to allow for iptables execution\n    ### via firewall-cmd if necessary\n    $self->{'_cmd'} = $self->{'_iptables'};\n    if ($self->{'_firewall_cmd'}) {\n        $self->{'_cmd'} = \"$self->{'_firewall_cmd'} $self->{'_fwd_args'}\";\n    }\n\n    $self->{'parse_keys'} = &parse_keys();\n\n    bless $self, $class;\n}\n\nsub DESTROY {\n    my $self = shift;\n\n    ### clean up tmp files\n    unless ($self->{'_debug'}) {\n        unlink $self->{'_iptout'};\n        unlink $self->{'_ipterr'};\n    }\n\n    return;\n}\n\nsub parse_keys() {\n    my $self = shift;\n\n    ### only used for IPv4 + NAT\n    my $ipv4_re = qr|(?:[0-2]?\\d{1,2}\\.){3}[0-2]?\\d{1,2}|;\n\n    my %keys = (\n        'regular' => {\n            'packets'  => {\n                'regex'     => '',\n                'ipt_match' => ''\n            },\n            'bytes'    => {\n                'regex'     => '',\n                'ipt_match' => ''\n            },\n            'target'   => {\n                'regex'     => '',\n                'ipt_match' => ''\n            },\n            'protocol' => {\n                'regex'     => '',\n                'ipt_match' => '-p'\n            },\n            'proto'    => {\n                'regex'     => '',\n                'ipt_match' => '-p'\n            },\n            'intf_in'  => {\n                'regex'     => '',\n                'ipt_match' => '-i'\n            },\n            'intf_out' => {\n                'regex'     => '',\n                'ipt_match' => '-o'\n            },\n            'src'      => {\n                'regex'     => '',\n                'ipt_match' => '-s'\n            },\n            'dst'      => {\n                'regex'     => '',\n                'ipt_match' => '-d'\n            }\n        },\n        'extended' => {\n            's_port' => {\n                'regex'     => qr/\\bspts?:(\\S+)/,\n                'ipt_match' => '--sport'\n            },\n            'sport' => {\n                'regex'     => qr/\\bspts?:(\\S+)/,\n                'ipt_match' => '--sport'\n            },\n            'd_port' => {\n                'regex'     => qr/\\bdpts?:(\\S+)/,\n                'ipt_match' => '--dport'\n            },\n            'dport' => {\n                'regex'     => qr/\\bdpts?:(\\S+)/,\n                'ipt_match' => '--dport'\n            },\n            'to_ip' => {\n                'regex'     => qr/\\bto:($ipv4_re):\\d+/,\n                'ipt_match' => ''\n            },\n            'to_port' => {\n                'regex'     => qr/\\bto:$ipv4_re:(\\d+)/,\n                'ipt_match' => ''\n            },\n            'mac_source' => {\n                'regex'     => qr/\\bMAC\\s+(\\S+)/,\n                'ipt_match' => '-m mac --mac-source'\n            },\n            'state' => {\n                'regex'     => qr/\\bstate\\s+(\\S+)/,\n                'ipt_match' => '-m state --state'\n            },\n            'ctstate' => {\n                'regex'     => qr/\\bctstate\\s+(\\S+)/,\n                'ipt_match' => '-m conntrack --ctstate'\n            },\n            'comment' => {\n                'regex'      => qr|\\/\\*\\s(.*?)\\s\\*\\/|,\n                'ipt_match'  => '-m comment --comment',\n                'use_quotes' => 1\n            },\n            'string' => {\n                'regex'      => qr|STRING\\s+match\\s+\\\"(.*?)\\\"|,\n                'ipt_match'  => '-m string --algo bm --string',\n                'use_quotes' => 1\n            },\n            'length' => {\n                'regex'      => qr|\\blength\\s(\\S+)|,\n                'ipt_match'  => '-m length --length',\n            },\n        },\n        'rule_num' => '',\n        'raw' => ''\n    );\n\n    return \\%keys;\n}\n\nsub list_table_chains() {\n    my $self   = shift;\n    my $table  = shift || croak '[*] Specify a table, e.g. \"nat\"';\n    my $file   = shift || '';\n\n    my @ipt_lines = ();\n    my @chains = ();\n\n    if ($self->{'_ipt_rules_file'} and not $file) {\n        $file = $self->{'_ipt_rules_file'};\n    }\n\n    if ($file) {\n        ### read the iptables rules out of $file instead of executing\n        ### the iptables command.\n        open F, \"< $file\" or croak \"[*] Could not open file $file: $!\";\n        @ipt_lines = <F>;\n        close F;\n    } else {\n        my ($rv, $out_ar, $err_ar) = $self->exec_iptables(\n                \"$self->{'_cmd'} -t $table -v -n -L\");\n        @ipt_lines = @$out_ar;\n    }\n\n    for (@ipt_lines) {\n        if (/^\\s*Chain\\s(.*?)\\s\\(/) {\n            push @chains, $1;\n        }\n    }\n    return \\@chains;\n}\n\nsub chain_policy() {\n    my $self   = shift;\n    my $table  = shift || croak '[*] Specify a table, e.g. \"nat\"';\n    my $chain  = shift || croak '[*] Specify a chain, e.g. \"OUTPUT\"';\n    my $file   = shift || '';\n\n    my @ipt_lines = ();\n\n    if ($self->{'_ipt_rules_file'} and not $file) {\n        $file = $self->{'_ipt_rules_file'};\n    }\n\n    if ($file) {\n        ### read the iptables rules out of $file instead of executing\n        ### the iptables command.\n        open F, \"< $file\" or croak \"[*] Could not open file $file: $!\";\n        @ipt_lines = <F>;\n        close F;\n    } else {\n        my ($rv, $out_ar, $err_ar) = $self->exec_iptables(\n                \"$self->{'_cmd'} -t $table -v -n -L $chain\");\n        @ipt_lines = @$out_ar;\n    }\n\n    my $policy = '';\n\n    for my $line (@ipt_lines) {\n        ### Chain INPUT (policy ACCEPT 16 packets, 800 bytes)\n        if ($line =~ /^\\s*Chain\\s+$chain\\s+\\(policy\\s+(\\w+)/) {\n            $policy = $1;\n            last;\n        }\n    }\n\n    return $policy;\n}\n\nsub chain_action_rules() {\n    return &chain_rules();\n}\n\nsub chain_rules() {\n    my $self   = shift;\n    my $table  = shift || croak '[*] Specify a table, e.g. \"nat\"';\n    my $chain  = shift || croak '[*] Specify a chain, e.g. \"OUTPUT\"';\n    my $file   = shift || '';\n\n    my $found_chain  = 0;\n    my @ipt_lines = ();\n\n    ### only used for IPv4 + NAT\n    my $ip_re = qr|(?:[0-2]?\\d{1,2}\\.){3}[0-2]?\\d{1,2}|;\n\n    ### array of hash refs\n    my @chain = ();\n    my @global_accept_state = ();\n\n    if ($self->{'_ipt_rules_file'} and not $file) {\n        $file = $self->{'_ipt_rules_file'};\n    }\n\n    if ($file) {\n        ### read the iptables rules out of $file instead of executing\n        ### the iptables command.\n        open F, \"< $file\" or croak \"[*] Could not open file $file: $!\";\n        @ipt_lines = <F>;\n        close F;\n    } else {\n        my ($rv, $out_ar, $err_ar) = $self->exec_iptables(\n                \"$self->{'_cmd'} -t $table -v -n -L $chain --line-numbers\");\n        @ipt_lines = @$out_ar;\n    }\n\n    ### determine the output style (e.g. \"-nL -v\" or just plain \"-nL\"; if the\n    ### policy data came from a file then -v might not have been used)\n    my $ipt_verbose = 0;\n    for my $line (@ipt_lines) {\n        if ($line =~ /\\spkts\\s+bytes\\s+target/) {\n            $ipt_verbose = 1;\n            last;\n        }\n    }\n    my $has_line_numbers = 0;\n    for my $line (@ipt_lines) {\n        if ($line =~ /^num\\s+pkts\\s+bytes\\s+target/) {\n            $has_line_numbers = 1;\n            last;\n        }\n    }\n\n    my $rule_num = 0;\n\n    LINE: for my $line (@ipt_lines) {\n        chomp $line;\n\n        last LINE if ($found_chain and $line =~ /^\\s*Chain\\s+/);\n\n        if ($line =~ /^\\s*Chain\\s\\Q$chain\\E\\s\\(/i) {\n            $found_chain = 1;\n            next LINE;\n        }\n        next LINE if $line =~ /\\starget\\s{2,}prot/i;\n        next LINE unless $found_chain;\n        next LINE unless $line;\n\n        ### track the rule number independently of --line-numbers,\n        ### but the values should always match\n        $rule_num++;\n\n        ### initialize hash\n        my %rule = (\n            'extended' => '',\n            'raw'      => $line,\n            'rule_num' => $rule_num\n        );\n        for my $key (keys %{$self->{'parse_keys'}->{'regular'}}) {\n            $rule{$key} = '';\n        }\n        for my $key (keys %{$self->{'parse_keys'}->{'extended'}}) {\n            $rule{$key} = '';\n        }\n\n        my $rule_body = '';\n        my $packets   = '';\n        my $bytes     = '';\n        my $rnum      = '';\n\n        if ($ipt_verbose) {\n            if ($has_line_numbers) {\n                if ($line =~ /^\\s*(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(.*)/) {\n                    $rnum      = $1;\n                    $packets   = $2;\n                    $bytes     = $3;\n                    $rule_body = $4;\n                }\n            } else {\n                if ($line =~ /^\\s*(\\d+)\\s+(\\d+)\\s+(.*)/) {\n                    $packets   = $1;\n                    $bytes     = $2;\n                    $rule_body = $3;\n                }\n            }\n        } else {\n            if ($has_line_numbers) {\n                if ($line =~ /^\\s*(\\d+)\\s+(\\d+)\\s+(.*)/) {\n                    $rnum      = $1;\n                    $rule_body = $2;\n                }\n            }\n        }\n\n        if ($rnum and $rnum ne $rule_num) {\n            croak \"[*] Rule number mis-match.\";\n        }\n\n        if ($ipt_verbose) {\n\n            ### iptables:\n            ### 0     0 ACCEPT  tcp  --  eth1 * 192.168.10.3  0.0.0.0/0  tcp dpt:80\n            ### 0     0 ACCEPT  tcp  --  eth1 * 192.168.10.15 0.0.0.0/0  tcp dpt:22\n            ### 33 2348 ACCEPT  tcp  --  eth1 * 192.168.10.2  0.0.0.0/0  tcp dpt:22\n            ### 0     0 ACCEPT  tcp  --  eth1 * 192.168.10.2  0.0.0.0/0  tcp dpt:80\n            ### 0     0 DNAT    tcp  --  *    * 123.123.123.123 0.0.0.0/0 tcp dpt:55000 to:192.168.12.12:80\n\n            ### ip6tables:\n            ### 0     0 ACCEPT  tcp   *   *   ::/0     fe80::aa:0:1/128    tcp dpt:12345\n            ### 0     0 LOG     all   *   *   ::/0     ::/0                LOG flags 0 level 4\n\n            my $match_re = qr/^(\\S+)\\s+(\\S+)\\s+\\-\\-\\s+\n                                (\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s*(.*)/x;\n\n            if ($self->{'_ipt_bin_name'} eq 'ip6tables'\n                    or ($self->{'_ipt_bin_name'} eq 'firewall-cmd'\n                    and $self->{'_fwd_args'} =~ /\\sipv6/)) {\n                $match_re = qr/^(\\S+)\\s+(\\S+)\\s+\n                                (\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s*(.*)/x;\n            }\n\n            if ($rule_body =~ $match_re) {\n                $rule{'packets'}  = $packets;\n                $rule{'bytes'}    = $bytes;\n                $rule{'target'}   = $1;\n                my $proto = $2;\n                $proto = 'all' if $proto eq '0';\n                $rule{'protocol'} = $rule{'proto'} = lc($proto);\n                $rule{'intf_in'}  = $3;\n                $rule{'intf_out'} = $4;\n                $rule{'src'}      = $5;\n                $rule{'dst'}      = $6;\n                $rule{'extended'} = $7 || '';\n\n                &parse_rule_extended(\\%rule, $self->{'parse_keys'}->{'extended'});\n            }\n        } else {\n\n            ### iptables:\n            ### ACCEPT tcp  -- 164.109.8.0/24  0.0.0.0/0  tcp dpt:22 flags:0x16/0x02\n            ### ACCEPT tcp  -- 216.109.125.67  0.0.0.0/0  tcp dpts:7000:7500\n            ### ACCEPT udp  -- 0.0.0.0/0       0.0.0.0/0  udp dpts:7000:7500\n            ### ACCEPT udp  -- 0.0.0.0/0       0.0.0.0/0  udp dpt:!7000\n            ### ACCEPT icmp --  0.0.0.0/0      0.0.0.0/0\n            ### ACCEPT tcp  --  0.0.0.0/0      0.0.0.0/0  tcp spt:35000 dpt:5000\n            ### ACCEPT tcp  --  10.1.1.1       0.0.0.0/0\n\n            ### LOG  all  --  0.0.0.0/0  0.0.0.0/0  LOG flags 0 level 4 prefix `DROP '\n            ### LOG  all  --  127.0.0.2  0.0.0.0/0  LOG flags 0 level 4\n            ### DNAT tcp  --  123.123.123.123  0.0.0.0/0  tcp dpt:55000 to:192.168.12.12:80\n\n            ### ip6tables:\n            ### ACCEPT     tcp   ::/0     fe80::aa:0:1/128    tcp dpt:12345\n            ### LOG        all   ::/0     ::/0                LOG flags 0 level 4\n\n            my $match_re = qr/^(\\S+)\\s+(\\S+)\\s+\\-\\-\\s+(\\S+)\\s+(\\S+)\\s*(.*)/;\n\n            if ($self->{'_ipt_bin_name'} eq 'ip6tables'\n                    or ($self->{'_ipt_bin_name'} eq 'firewall-cmd'\n                    and $self->{'_fwd_args'} =~ /\\sipv6/)) {\n                $match_re = qr/^(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s*(.*)/;\n            }\n\n            if ($rule_body =~ $match_re) {\n                $rule{'target'}   = $1;\n                my $proto = $2;\n                $proto = 'all' if $proto eq '0';\n                $rule{'protocol'} = $rule{'proto'} = lc($proto);\n                $rule{'src'}      = $3;\n                $rule{'dst'}      = $4;\n                $rule{'extended'} = $5 || '';\n\n                &parse_rule_extended(\\%rule, $self->{'parse_keys'}->{'extended'});\n            }\n        }\n        push @chain, \\%rule;\n    }\n    return \\@chain;\n}\n\nsub parse_rule_extended() {\n    my ($rule_hr, $ext_keys_hr) = @_;\n\n    for my $key (keys %$ext_keys_hr) {\n        if ($rule_hr->{'extended'}\n                =~ /$ext_keys_hr->{$key}->{'regex'}/) {\n            $rule_hr->{$key} = $1;\n        }\n    }\n\n    if ($rule_hr->{'protocol'} eq '0') {\n        $rule_hr->{'s_port'} = $rule_hr->{'sport'} = 0;\n        $rule_hr->{'d_port'} = $rule_hr->{'dport'} = 0;\n    } elsif ($rule_hr->{'protocol'} eq 'tcp'\n            or $rule_hr->{'protocol'} eq 'udp') {\n        $rule_hr->{'s_port'} = $rule_hr->{'sport'} = 0\n            if $rule_hr->{'s_port'} eq '';\n        $rule_hr->{'d_port'} = $rule_hr->{'dport'} = 0\n            if $rule_hr->{'d_port'} eq '';\n    }\n\n    return;\n}\n\nsub default_drop() {\n    my $self  = shift;\n    my $table = shift || croak \"[*] Specify a table, e.g. \\\"nat\\\"\";\n    my $chain = shift || croak \"[*] Specify a chain, e.g. \\\"OUTPUT\\\"\";\n    my $file  = shift || '';\n\n    my @ipt_lines = ();\n\n    if ($self->{'_ipt_rules_file'} and not $file) {\n        $file = $self->{'_ipt_rules_file'};\n    }\n\n    if ($file) {\n        ### read the iptables rules out of $file instead of executing\n        ### the iptables command.\n        open F, \"< $file\" or croak \"[*] Could not open file $file: $!\";\n        @ipt_lines = <F>;\n        close F;\n    } else {\n### FIXME -v for interfaces?\n        my ($rv, $out_ar, $err_ar) = $self->exec_iptables(\n                \"$self->{'_cmd'} -t $table -n -L $chain\");\n        @ipt_lines = @$out_ar;\n    }\n\n    return \"[-] Could not get $self->{'_ipt_bin_name'} output!\", 0\n        unless @ipt_lines;\n\n    my %protocols = ();\n    my $found_chain = 0;\n    my $found_default_drop = 0;\n    my $rule_ctr = 1;\n    my $prefix;\n    my $policy = 'ACCEPT';\n    my $any_ip_re = qr/(?:0\\.){3}0\\x2f0|\\x3a{2}\\x2f0/;\n\n    LINE: for my $line (@ipt_lines) {\n        chomp $line;\n\n        last if ($found_chain and $line =~ /^\\s*Chain\\s+/);\n\n        ### Chain INPUT (policy DROP)\n        ### Chain FORWARD (policy ACCEPT)\n        if ($line =~ /^\\s*Chain\\s+$chain\\s+\\(policy\\s+(\\w+)\\)/) {\n            $policy = $1;\n            $found_chain = 1;\n        }\n        next LINE if $line =~ /^\\s*target\\s/i;\n        next LINE unless $found_chain;\n\n        ### include ULOG target as well\n        my $log_re = qr/^\\s*U?LOG\\s+(\\w+)\\s+\\-\\-\\s+.*\n                $any_ip_re\\s+$any_ip_re\\s+(.*)/x;\n        my $drop_re = qr/^DROP\\s+(\\w+)\\s+\\-\\-\\s+.*\n            $any_ip_re\\s+$any_ip_re\\s*$/x;\n\n        if ($self->{'_ipt_bin_name'} eq 'ip6tables'\n                or ($self->{'_ipt_bin_name'} eq 'firewall-cmd'\n                and $self->{'_fwd_args'} =~ /ipv6/)) {\n            $log_re = qr/^\\s*U?LOG\\s+(\\w+)\\s+\n                    $any_ip_re\\s+$any_ip_re\\s+(.*)/x;\n            $drop_re = qr/^DROP\\s+(\\w+)\\s+\n                $any_ip_re\\s+$any_ip_re\\s*$/x;\n        }\n\n        ### might as well pick up any default logging rules as well\n        if ($line =~ $log_re) {\n            my $proto  = $1;\n            my $p_tmp  = $2;\n            my $prefix = 'NONE';\n\n            ### some recent iptables versions return \"0\" instead of \"all\"\n            ### for the protocol number\n            $proto = 'all' if $proto eq '0';\n            ### LOG flags 0 level 4 prefix `DROP '\n            if ($p_tmp && $p_tmp =~ m|LOG.*\\s+prefix\\s+\n                \\`\\s*(.+?)\\s*\\'|x) {\n                $prefix = $1;\n            }\n            ### $proto may equal \"all\" here\n            $protocols{$proto}{'LOG'}{'prefix'} = $prefix;\n            $protocols{$proto}{'LOG'}{'rulenum'} = $rule_ctr;\n        } elsif ($policy eq 'ACCEPT' and $line =~ $drop_re) {\n            my $proto = $1;\n            $proto = 'all' if $proto eq '0';\n            ### DROP    all  --  0.0.0.0/0     0.0.0.0/0\n            $protocols{$1}{'DROP'} = $rule_ctr;\n            $found_default_drop = 1;\n        }\n        $rule_ctr++;\n    }\n\n    ### if the policy in the chain is DROP, then we don't\n    ### necessarily need to find a default DROP rule.\n    if ($policy eq 'DROP') {\n        $protocols{'all'}{'DROP'} = 0;\n        $found_default_drop = 1;\n    }\n\n    return \"[-] There are no default drop rules in the \" .\n            \"$self->{'_ipt_bin_name'} policy!\", 0\n        unless %protocols and $found_default_drop;\n\n    return \\%protocols, 1;\n}\n\nsub default_log() {\n    my $self  = shift;\n    my $table = shift || croak \"[*] Specify a table, e.g. \\\"nat\\\"\";\n    my $chain = shift || croak \"[*] Specify a chain, e.g. \\\"OUTPUT\\\"\";\n    my $file  = shift || '';\n\n    my $any_ip_re  = qr/(?:0\\.){3}0\\x2f0|\\x3a{2}\\x2f0/;\n    my @ipt_lines  = ();\n    my %log_chains = ();\n    my %log_rules  = ();\n\n    if ($self->{'_ipt_rules_file'} and not $file) {\n        $file = $self->{'_ipt_rules_file'};\n    }\n\n    ### note that we are not restricting the view to the current chain\n    ### with the iptables -nL output; we are going to parse the given\n    ### chain and all chains to which packets are jumped from the given\n    ### chain.\n    if ($file) {\n        ### read the iptables rules out of $file instead of executing\n        ### the iptables command.\n        open F, \"< $file\" or croak \"[*] Could not open file $file: $!\";\n        @ipt_lines = <F>;\n        close F;\n    } else {\n        my ($rv, $out_ar, $err_ar) = $self->exec_iptables(\n                \"$self->{'_cmd'} -t $table -n -L $chain\");\n        @ipt_lines = @$out_ar;\n    }\n\n    ### determine the output style (e.g. \"-nL -v\" or just plain \"-nL\"; if the\n    ### policy data came from a file then -v might not have been used)\n    my $ipt_verbose = 0;\n    for my $line (@ipt_lines) {\n        if ($line =~ /^\\s*pkts\\s+bytes\\s+target/) {\n            $ipt_verbose = 1;\n            last;\n        }\n    }\n\n    return \"[-] Could not get $self->{'_ipt_bin_name'} output!\", 0\n        unless @ipt_lines;\n\n    ### first get all logging rules and associated chains\n    my $log_chain;\n\n    for my $line (@ipt_lines) {\n        chomp $line;\n\n        ### Chain INPUT (policy DROP)\n        ### Chain fwsnort_INPUT_eth1 (1 references)\n        if ($line =~ /^\\s*Chain\\s+(.*?)\\s+\\(/ and\n                $line !~ /0\\s+references/) {\n            $log_chain = $1;\n        }\n        $log_chain = '' unless $line =~ /\\S/;\n        next unless $log_chain;\n\n        my $proto = '';\n        my $found = 0;\n        if ($ipt_verbose) {\n            if ($self->{'_ipt_bin_name'} eq 'ip6tables'\n                    or ($self->{'_ipt_bin_name'} eq 'firewall-cmd'\n                    and $self->{'_fwd_args'} =~ /\\sipv6/)) {\n                if ($line =~ m|^\\s*\\d+\\s+\\d+\\s*U?LOG\\s+(\\w+)\\s+\n                        \\S+\\s+\\S+\\s+$any_ip_re\n                        \\s+$any_ip_re\\s+.*U?LOG|x) {\n                    $proto = $1;\n                    $found = 1;\n                }\n            } else {\n                if ($line =~ m|^\\s*\\d+\\s+\\d+\\s*U?LOG\\s+(\\w+)\\s+\\-\\-\\s+\n                        \\S+\\s+\\S+\\s+$any_ip_re\n                        \\s+$any_ip_re\\s+.*U?LOG|x) {\n                    $proto = $1;\n                    $found = 1;\n                }\n            }\n        } else {\n            if ($self->{'_ipt_bin_name'} eq 'ip6tables'\n                    or ($self->{'_ipt_bin_name'} eq 'firewall-cmd'\n                    and $self->{'_fwd_args'} =~ /\\sipv6/)) {\n                if ($line =~ m|^\\s*U?LOG\\s+(\\w+)\\s+$any_ip_re\n                        \\s+$any_ip_re\\s+.*U?LOG|x) {\n                    $proto = $1;\n                    $found = 1;\n                }\n            } else {\n                if ($line =~ m|^\\s*U?LOG\\s+(\\w+)\\s+\\-\\-\\s+$any_ip_re\n                        \\s+$any_ip_re\\s+.*U?LOG|x) {\n                    $proto = $1;\n                    $found = 1;\n                }\n            }\n        }\n\n        if ($found) {\n            $proto = 'all' if $proto eq '0';\n            ### the above regex allows the limit target to be used\n            $log_chains{$log_chain}{$proto} = '';  ### protocol\n            $log_rules{$proto} = '' if $log_chain eq $chain;\n        }\n    }\n\n    return \"[-] There are no default logging rules \" .\n        \"in the $self->{'_ipt_bin_name'} policy!\", 0 unless %log_chains;\n\n    my %sub_chains = ();\n\n    ### get all sub-chains of the main chain we passed into default_log()\n    &sub_chains($chain, \\%sub_chains, \\@ipt_lines);\n\n    ### see which (if any) logging rules can be mapped back to the\n    ### main chain we passed in.\n    for my $log_chain (keys %log_chains) {\n        if (defined $sub_chains{$log_chain}) {\n            ### the logging rule is in the main chain (e.g. INPUT)\n            for my $proto (keys %{$log_chains{$log_chain}}) {\n                $log_rules{$proto} = '';\n            }\n        }\n    }\n\n    return \\%log_rules, 1;\n}\n\nsub sub_chains() {\n    my ($start_chain, $chains_hr, $ipt_lines_ar) = @_;\n    my $found = 0;\n    for my $line (@$ipt_lines_ar) {\n        chomp $line;\n        ### Chain INPUT (policy DROP)\n        ### Chain fwsnort_INPUT_eth1 (1 references)\n        if ($line =~ /^\\s*Chain\\s+\\Q$start_chain\\E\\s+\\(/ and\n                $line !~ /0\\s+references/) {\n            $found = 1;\n            next;\n        }\n        next unless $found;\n        if ($found and $line =~ /^\\s*Chain\\s/) {\n            last;\n        }\n        if ($line =~ m|^\\s*(\\S+)\\s+\\S+\\s+|) {\n            my $new_chain = $1;\n            if ($new_chain ne 'LOG'\n                    and $new_chain ne 'DROP'\n                    and $new_chain ne 'REJECT'\n                    and $new_chain ne 'ACCEPT'\n                    and $new_chain ne 'RETURN'\n                    and $new_chain ne 'QUEUE'\n                    and $new_chain ne 'SNAT'\n                    and $new_chain ne 'DNAT'\n                    and $new_chain ne 'MASQUERADE'\n                    and $new_chain ne 'pkts'\n                    and $new_chain ne 'Chain'\n                    and $new_chain ne 'target') {\n                $chains_hr->{$new_chain} = '';\n                &sub_chains($new_chain, $chains_hr, $ipt_lines_ar);\n            }\n        }\n    }\n    return;\n}\n\nsub exec_iptables() {\n    my $self  = shift;\n    my $cmd = shift || croak \"[*] Must specify an \" .\n        \"$self->{'_ipt_bin_name'} command to run.\";\n    my $iptout    = $self->{'_iptout'};\n    my $ipterr    = $self->{'_ipterr'};\n    my $debug     = $self->{'_debug'};\n    my $ipt_alarm = $self->{'_ipt_alarm'};\n    my $verbose   = $self->{'_verbose'};\n    my $ipt_exec_style = $self->{'_ipt_exec_style'};\n    my $ipt_exec_sleep = $self->{'_ipt_exec_sleep'};\n    my $sigchld_handler = $self->{'_sigchld_handler'};\n\n    croak \"[*] $cmd does not look like an $self->{'_ipt_bin_name'} command.\"\n        unless $cmd =~ m|^\\s*iptables| or $cmd =~ m|^\\S+/iptables|\n            or $cmd =~ m|^\\s*ip6tables| or $cmd =~ m|^\\S+/ip6tables|\n            or $cmd =~ m|^\\s*firewall-cmd| or $cmd =~ m|^\\S+/firewall-cmd|;\n\n    ### sanitize $cmd - this is not bullet proof, but better than\n    ### nothing (especially for strange iptables chain names). Further,\n    ### quotemeta() is too aggressive since things like IPv6 addresses\n    ### contain \":\" chars, etc.\n    $cmd =~ s/([;<>\\$\\|`\\@&\\(\\)\\[\\]\\{\\}])/\\\\$1/g;\n\n    my $rv = 1;\n    my @stdout = ();\n    my @stderr = ();\n\n    my $fh = *STDERR;\n    $fh = *STDOUT if $verbose;\n\n    if ($debug or $verbose) {\n        print $fh localtime() . \" [+] IPTables::Parse::\",\n            \"exec_iptables(${ipt_exec_style}()) $cmd\\n\";\n        if ($ipt_exec_sleep > 0) {\n            print $fh localtime() . \" [+] IPTables::Parse::\",\n                \"exec_iptables() sleep seconds: $ipt_exec_sleep\\n\";\n        }\n    }\n\n    if ($ipt_exec_sleep > 0) {\n        if ($debug or $verbose) {\n            print $fh localtime() . \" [+] IPTables::Parse: \",\n                \"sleeping for $ipt_exec_sleep seconds before \",\n                \"executing $self->{'_ipt_bin_name'} command.\\n\";\n        }\n        sleep $ipt_exec_sleep;\n    }\n\n    if ($ipt_exec_style eq 'system') {\n        system qq{$cmd > $iptout 2> $ipterr};\n    } elsif ($ipt_exec_style eq 'popen') {\n        open CMD, \"$cmd 2> $ipterr |\" or croak \"[*] Could not execute $cmd: $!\";\n        @stdout = <CMD>;\n        close CMD;\n        open F, \"> $iptout\" or croak \"[*] Could not open $iptout: $!\";\n        print F for @stdout;\n        close F;\n    } else {\n        my $ipt_pid;\n\n        if ($debug or $verbose) {\n            print $fh localtime() . \" [+] IPTables::Parse: \" .\n                \"Setting SIGCHLD handler to: \" . $sigchld_handler . \"\\n\";\n        }\n\n        local $SIG{'CHLD'} = $sigchld_handler;\n        if ($ipt_pid = fork()) {\n            eval {\n                ### iptables should never take longer than 30 seconds to execute,\n                ### unless there is some absolutely enormous policy or the kernel\n                ### is exceedingly busy\n                local $SIG{'ALRM'} = sub {die \"[*] $self->{'_ipt_bin_name'} \" .\n                    \"command timeout.\\n\"};\n                alarm $ipt_alarm;\n                waitpid($ipt_pid, 0);\n                alarm 0;\n            };\n            if ($@) {\n                kill 9, $ipt_pid unless kill 15, $ipt_pid;\n            }\n        } else {\n            croak \"[*] Could not fork $self->{'_ipt_bin_name'}: $!\"\n                unless defined $ipt_pid;\n\n            ### exec the iptables command and preserve stdout and stderr\n            exec qq{$cmd > $iptout 2> $ipterr};\n        }\n    }\n\n    if (-e $iptout) {\n        open F, \"< $iptout\" or croak \"[*] Could not open $iptout\";\n        @stdout = <F>;\n        close F;\n    }\n    if (-e $ipterr) {\n        open F, \"< $ipterr\" or croak \"[*] Could not open $ipterr\";\n        @stderr = <F>;\n        close F;\n\n        $rv = 0 if @stderr;\n    }\n\n    if (@stdout) {\n        if ($stdout[$#stdout] =~ /^success/) {\n            pop @stdout;\n        }\n        if ($self->{'_ipt_bin_name'} eq 'firewall-cmd') {\n            for (@stdout) {\n                if (/COMMAND_FAILED/) {\n                    $rv = 0;\n                    last;\n                }\n            }\n        }\n    }\n\n    if ($debug or $verbose) {\n        print $fh localtime() . \"     $self->{'_ipt_bin_name'} \" .\n            \"command stdout:\\n\";\n        for my $line (@stdout) {\n            if ($line =~ /\\n$/) {\n                print $fh $line;\n            } else {\n                print $fh $line, \"\\n\";\n            }\n        }\n        print $fh localtime() . \"     $self->{'_ipt_bin_name'} \" .\n            \"command stderr:\\n\";\n        for my $line (@stderr) {\n            if ($line =~ /\\n$/) {\n                print $fh $line;\n            } else {\n                print $fh $line, \"\\n\";\n            }\n        }\n    }\n\n    if ($debug or $verbose) {\n        print $fh localtime() . \"     Return value: $rv\\n\";\n    }\n\n    return $rv, \\@stdout, \\@stderr;\n}\n\nsub REAPER {\n    my $stiff;\n    while(($stiff = waitpid(-1,WNOHANG))>0){\n        # do something with $stiff if you want\n    }\n    local $SIG{'CHLD'} = \\&REAPER;\n    return;\n}\n\n1;\n__END__\n\n=head1 NAME\n\nIPTables::Parse - Perl extension for parsing iptables and ip6tables policies\n\n=head1 SYNOPSIS\n\n  use IPTables::Parse;\n\n  my %opts = (\n      'use_ipv6' => 0,         # can set to 1 to force ip6tables usage\n      'ipt_rules_file' => '',  # optional file path from\n                               # which to read iptables rules\n      'debug'    => 0,\n      'verbose'  => 0\n  );\n\n  my $ipt_obj = IPTables::Parse->new(%opts)\n      or die \"[*] Could not acquire IPTables::Parse object\";\n\n  my $rv = 0;\n\n  ### look for default DROP rules in the filter table INPUT chain\n  my ($ipt_hr, $rv) = $ipt_obj->default_drop('filter', 'INPUT');\n  if ($rv) {\n      if (defined $ipt_hr->{'all'}) {\n          print \"The INPUT chain has a default DROP rule for all protocols.\\n\";\n      } else {\n          my $found = 0;\n          for my $proto (qw/tcp udp icmp/) {\n              if (defined $ipt_hr->{$proto}) {\n                  print \"The INPUT chain drops $proto by default.\\n\";\n                  $found = 1;\n              }\n          }\n          unless ($found) {\n              print \"The INPUT chain does not have any default DROP rule.\\n\";\n          }\n      }\n  } else {\n      print \"[-] Could not parse $ipt_obj->{'_ipt_bin_name'} policy\\n\";\n  }\n\n  ### look for default LOG rules in the filter table INPUT chain\n  ($ipt_hr, $rv) = $ipt_obj->default_log('filter', 'INPUT');\n  if ($rv) {\n      if (defined $ipt_hr->{'all'}) {\n          print \"The INPUT chain has a default LOG rule for all protocols.\\n\";\n      } else {\n          my $found = 0;\n          for my $proto (qw/tcp udp icmp/) {\n              if (defined $ipt_hr->{$proto}) {\n                  print \"The INPUT chain logs $proto by default.\\n\";\n                  $found = 1;\n              }\n          }\n          unless ($found) {\n              print \"The INPUT chain does not have any default LOG rule.\\n\";\n          }\n      }\n  } else {\n      print \"[-] Could not parse $ipt_obj->{'_ipt_bin_name'} policy\\n\";\n  }\n\n  ### print all chains in the filter table\n  for my $chain (@{$ipt_obj->list_table_chains('filter')}) {\n      print $chain, \"\\n\";\n  }\n\n=head1 DESCRIPTION\n\nThe C<IPTables::Parse> package provides an interface to parse iptables or\nip6tables rules on Linux systems through the direct execution of\niptables/ip6tables commands, or from parsing a file that contains an\niptables/ip6tables policy listing. Note that the 'firewalld' infrastructure on\nFedora21 is also supported through execution of the 'firewall-cmd' binary.\nBy default, the path to iptables is assumed to be '/sbin/iptables', but if the\nfirewall is 'firewalld', then the '/usr/bin/firewall-cmd' is used.\n\nWith this module, you can get the current policy applied to a\ntable/chain, look for a specific user-defined chain, check for a default DROP\npolicy, or determine whether or not a default LOG rule exists. Also, you can\nget a listing of all rules in a chain with each rule parsed into its own hash.\n\nNote that if you initialize the IPTables::Parse object with the 'ipt_rules_file'\nkey, then all parsing routines will open the specified file for iptables rules\ndata. So, you can create this file with a command like\n'iptables -t filter -nL -v > ipt.rules', and then initialize the object with\nIPTables::Parse->new('ipt_rules_file' => 'ipt.rules'). Further, if you are\nrunning on a system without iptables installed, but you have an iptables policy\nwritten to the ipt.rules file, then you can pass in 'skip_ipt_exec_check=>1'\nin order to analyze the file without having IPTables::Parse check for the\niptables binary.\n\nIn summary, in addition to the hash keys mentioned above, optional keys that\ncan be passed to new() include '_iptables' (set path to iptables binary),\n'_firewall_cmd' (set path to 'firewall-cmd' binary for systems with\n'firewalld'), '_fwd_args' (set 'firewall-cmd' usage args; defaults to\n'--direct --passthrough ipv4'), '_ipv6' (set IPv6 mode for ip6tables),\n'_debug' and '_verbose'.\n\n=head1 FUNCTIONS\n\nThe IPTables::Parse extension provides an object interface to the following\nfunctions:\n\n=over 4\n\n=item chain_policy($table, $chain)\n\nThis function returns the policy (e.g. 'DROP', 'ACCEPT', etc.) for the specified\ntable and chain:\n\n  print \"INPUT policy: \",\n        $ipt_obj->chain_policy('filter', 'INPUT'), \"\\n\";\n\n=item chain_rules($table, $chain)\n\nThis function parses the specified chain and table and returns an array reference\nfor all rules in the chain.  Each element in the array reference is a hash with\nthe following keys (that contain values depending on the rule): C<src>, C<dst>,\nC<protocol>, C<s_port>, C<d_port>, C<target>, C<packets>, C<bytes>, C<intf_in>,\nC<intf_out>, C<to_ip>, C<to_port>, C<state>, C<raw>, and C<extended>.  The C<extended>\nelement contains the rule output past the protocol information, and the C<raw>\nelement contains the complete rule itself as reported by iptables or ip6tables.\nHere is an example of checking whether the second rule in the INPUT chain (array\nindex 1) allows traffic from any IP to TCP port 80:\n\n  $rules_ar = $ipt_obj->chain_rules('filter', 'INPUT);\n\n  if ($rules_ar->[1]->{'src'} eq '0.0.0.0/0'\n          and $rules_ar->[1]->{'protocol'} eq 'tcp'\n          and $rules_ar->[1]->{'d_port'}   eq '80'\n          and $rules_ar->[1]->{'target'}   eq 'ACCEPT') {\n\n      print \"traffic accepted to TCP port 80 from anywhere\\n\";\n  }\n\n=item default_drop($table, $chain)\n\nThis function parses the running iptables or ip6tables policy in order to\ndetermine if the specified chain contains a default DROP rule.  Two values\nare returned, a hash reference whose keys are the protocols that are dropped by\ndefault (if a global ACCEPT rule has not accepted matching packets first), along\nwith a return value that tells the caller if parsing the iptables or ip6tables\npolicy was successful.  Note that if all protocols are dropped by default, then\nthe hash key 'all' will be defined.\n\n  ($ipt_hr, $rv) = $ipt_obj->default_drop('filter', 'INPUT');\n\n=item default_log($table, $chain)\n\nThis function parses the running iptables or ip6tables policy in order to determine if\nthe specified chain contains a default LOG rule.  Two values are returned,\na hash reference whose keys are the protocols that are logged by default\n(if a global ACCEPT rule has not accepted matching packets first), along with\na return value that tells the caller if parsing the iptables or ip6tables policy was\nsuccessful.  Note that if all protocols are logged by default, then the\nhash key 'all' will be defined.  An example invocation is:\n\n  ($ipt_hr, $rv) = $ipt_obj->default_log('filter', 'INPUT');\n\n=item list_table_chains($table)\n\nThis function parses the specified table for all chains that are defined within\nthe table. Data is returned as an array reference. For example, if there are no\nuser-defined chains in the 'filter' table, then the returned array reference will\ncontain the strings 'INPUT', 'FORWARD', and 'OUTPUT'.\n\n  for my $chain (@{$ipt_obj->list_table_chains('filter')}) {\n      print $chain, \"\\n\";\n  }\n\n=back\n\n=head1 AUTHOR\n\nMichael Rash, E<lt>mbr@cipherdyne.orgE<gt>\n\n=head1 SEE ALSO\n\nThe IPTables::Parse module is used by the IPTables::ChainMgr extension in support of\nthe psad and fwsnort projects to parse iptables or ip6tables policies (see the psad(8),\nand fwsnort(8) man pages).  As always, the iptables(8) and ip6tables(8) man pages\nprovide the best information on command line execution and theory behind iptables\nand ip6tables.\n\nAlthough there is no mailing that is devoted specifically to the IPTables::Parse\nextension, questions about the extension will be answered on the following\nlists:\n\n  The psad mailing list: http://lists.sourceforge.net/lists/listinfo/psad-discuss\n  The fwsnort mailing list: http://lists.sourceforge.net/lists/listinfo/fwsnort-discuss\n\nThe latest version of the IPTables::Parse extension can be found on CPAN and\nalso here:\n\n  http://www.cipherdyne.org/modules/\n\nSource control is provided by git:\n\n  https://github.com/mrash/IPTables-Parse.git\n\n=head1 CREDITS\n\nThanks to the following people:\n\n  Franck Joncourt <franck.mail@dthconnex.com>\n  Stuart Schneider\n  Grant Ferley\n  Fabien Mazieres\n\n=head1 AUTHOR\n\nThe IPTables::Parse extension was written by Michael Rash F<E<lt>mbr@cipherdyne.orgE<gt>>\nto support the psad and fwsnort projects.  Please send email to\nthis address if there are any questions, comments, or bug reports.\n\n=head1 VERSION\n\nVersion 1.5 (Septebmer, 2015)\n\n=head1 COPYRIGHT AND LICENSE\n\nCopyright (C) 2005-2015 Michael Rash.  All rights reserved.\n\nThis module is free software.  You can redistribute it and/or\nmodify it under the terms of the Artistic License 2.0.  More information\ncan be found here: http://www.perl.com/perl/misc/Artistic.html\n\nThis program is distributed \"as is\" in the hope that it will be useful,\nbut without any warranty; without even the implied warranty of\nmerchantability or fitness for a particular purpose.\n\n=cut\n"], "filenames": ["lib/IPTables/Parse.pm"], "buggy_code_start_loc": [19], "buggy_code_end_loc": [985], "fixing_code_start_loc": [20], "fixing_code_end_loc": [983], "type": "CWE-59", "message": "The IPTables-Parse module before 1.6 for Perl allows local users to write to arbitrary files owned by the current user.", "other": {"cve": {"id": "CVE-2015-8326", "sourceIdentifier": "security@debian.org", "published": "2017-06-07T14:29:00.383", "lastModified": "2017-06-14T16:15:57.643", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The IPTables-Parse module before 1.6 for Perl allows local users to write to arbitrary files owned by the current user."}, {"lang": "es", "value": "El m\u00f3dulo IPTables-Parse anterior a la versi\u00f3n 1.6 para Perl permite a los usuarios locales escribir en archivos arbitrarios propiedad del usuario actual."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:iptables-parse_project:iptables-parse_module:0.5:*:*:*:*:perl:*:*", "matchCriteriaId": "C0392A3A-4BA5-48DD-A851-1A737F20C22B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:iptables-parse_project:iptables-parse_module:0.6:*:*:*:*:perl:*:*", "matchCriteriaId": "BB6FF281-9EAE-4240-8740-FE31E02D17F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:iptables-parse_project:iptables-parse_module:0.7:*:*:*:*:perl:*:*", "matchCriteriaId": "2904B020-4A02-4AB7-AD09-7DCAB048EAFE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:iptables-parse_project:iptables-parse_module:0.8:*:*:*:*:perl:*:*", "matchCriteriaId": "E4D7C1F2-21A7-4140-AAC5-D0400C259456"}, {"vulnerable": true, "criteria": "cpe:2.3:a:iptables-parse_project:iptables-parse_module:0.9:*:*:*:*:perl:*:*", "matchCriteriaId": "CF0DE2F1-EFD1-40B6-A27E-016F7DCE9314"}, {"vulnerable": true, "criteria": "cpe:2.3:a:iptables-parse_project:iptables-parse_module:1.0:*:*:*:*:perl:*:*", "matchCriteriaId": "4D9FFA74-56B3-4D40-B713-817ADC984B25"}, {"vulnerable": true, "criteria": "cpe:2.3:a:iptables-parse_project:iptables-parse_module:1.1:*:*:*:*:perl:*:*", "matchCriteriaId": "C85ABB2B-A89E-4EDF-801B-D53FB49D52AF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:iptables-parse_project:iptables-parse_module:1.3:*:*:*:*:perl:*:*", "matchCriteriaId": "5EAB55E5-A0F0-4D6E-8BF5-BD7BCA5AE827"}, {"vulnerable": true, "criteria": "cpe:2.3:a:iptables-parse_project:iptables-parse_module:1.3.1:*:*:*:*:perl:*:*", "matchCriteriaId": "6B39BE62-5935-4323-9AE4-0475BC9D685C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:iptables-parse_project:iptables-parse_module:1.4:*:*:*:*:perl:*:*", "matchCriteriaId": "3DD514E6-FC42-4FFD-B06D-B3E8E914BEB0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:iptables-parse_project:iptables-parse_module:1.5:*:*:*:*:perl:*:*", "matchCriteriaId": "913ECFB5-165D-41D5-960F-97E966A8C9CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:iptables-parse_project:iptables-parse_module:1.6:*:*:*:*:perl:*:*", "matchCriteriaId": "112A567E-2D69-4916-86E3-3CE9BEAE7558"}, {"vulnerable": true, "criteria": "cpe:2.3:a:iptables-parse_project:iptables-parse_module:1.6.1:*:*:*:*:perl:*:*", "matchCriteriaId": "685569AF-DA47-43D3-87B6-960D681DB39D"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2015/11/24/10", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1267962", "source": "security@debian.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/mtrmac/IPTables-Parse/commit/b400b976d81140f6971132e94eb7657b5b0a2b87", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://metacpan.org/source/MRASH/IPTables-Parse-1.6/Changes", "source": "security@debian.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mtrmac/IPTables-Parse/commit/b400b976d81140f6971132e94eb7657b5b0a2b87"}}