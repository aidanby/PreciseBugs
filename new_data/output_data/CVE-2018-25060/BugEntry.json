{"buggy_code": ["// Copyright 2013 Martini Authors\n// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\n// Package csrf is a middleware that generates and validates CSRF tokens for Macaron.\npackage csrf\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/Unknwon/com\"\n\t\"github.com/go-macaron/session\"\n\t\"gopkg.in/macaron.v1\"\n)\n\nconst _VERSION = \"0.1.0\"\n\nfunc Version() string {\n\treturn _VERSION\n}\n\n// CSRF represents a CSRF service and is used to get the current token and validate a suspect token.\ntype CSRF interface {\n\t// Return HTTP header to search for token.\n\tGetHeaderName() string\n\t// Return form value to search for token.\n\tGetFormName() string\n\t// Return cookie name to search for token.\n\tGetCookieName() string\n\t// Return cookie path\n\tGetCookiePath() string\n\t// Return the flag value used for the csrf token.\n\tGetCookieHttpOnly() bool\n\t// Return the token.\n\tGetToken() string\n\t// Validate by token.\n\tValidToken(t string) bool\n\t// Error replies to the request with a custom function when ValidToken fails.\n\tError(w http.ResponseWriter)\n}\n\ntype csrf struct {\n\t// Header name value for setting and getting csrf token.\n\tHeader string\n\t// Form name value for setting and getting csrf token.\n\tForm string\n\t// Cookie name value for setting and getting csrf token.\n\tCookie string\n\t//Cookie path\n\tCookiePath string\n\t// Cookie HttpOnly flag value used for the csrf token.\n\tCookieHttpOnly bool\n\t// Token generated to pass via header, cookie, or hidden form value.\n\tToken string\n\t// This value must be unique per user.\n\tID string\n\t// Secret used along with the unique id above to generate the Token.\n\tSecret string\n\t// ErrorFunc is the custom function that replies to the request when ValidToken fails.\n\tErrorFunc func(w http.ResponseWriter)\n}\n\n// GetHeaderName returns the name of the HTTP header for csrf token.\nfunc (c *csrf) GetHeaderName() string {\n\treturn c.Header\n}\n\n// GetFormName returns the name of the form value for csrf token.\nfunc (c *csrf) GetFormName() string {\n\treturn c.Form\n}\n\n// GetCookieName returns the name of the cookie for csrf token.\nfunc (c *csrf) GetCookieName() string {\n\treturn c.Cookie\n}\n\n// GetCookiePath returns the path of the cookie for csrf token.\nfunc (c *csrf) GetCookiePath() string {\n\treturn c.CookiePath\n}\n\n// GetCookieHttpOnly returns the flag value used for the csrf token.\nfunc (c *csrf) GetCookieHttpOnly() bool {\n\treturn c.CookieHttpOnly\n}\n\n// GetToken returns the current token. This is typically used\n// to populate a hidden form in an HTML template.\nfunc (c *csrf) GetToken() string {\n\treturn c.Token\n}\n\n// ValidToken validates the passed token against the existing Secret and ID.\nfunc (c *csrf) ValidToken(t string) bool {\n\treturn ValidToken(t, c.Secret, c.ID, \"POST\")\n}\n\n// Error replies to the request when ValidToken fails.\nfunc (c *csrf) Error(w http.ResponseWriter) {\n\tc.ErrorFunc(w)\n}\n\n// Options maintains options to manage behavior of Generate.\ntype Options struct {\n\t// The global secret value used to generate Tokens.\n\tSecret string\n\t// HTTP header used to set and get token.\n\tHeader string\n\t// Form value used to set and get token.\n\tForm string\n\t// Cookie value used to set and get token.\n\tCookie string\n\t// Cookie path.\n\tCookiePath string\n\tCookieHttpOnly bool\n\t// Key used for getting the unique ID per user.\n\tSessionKey string\n\t// oldSeesionKey saves old value corresponding to SessionKey.\n\toldSeesionKey string\n\t// If true, send token via X-CSRFToken header.\n\tSetHeader bool\n\t// If true, send token via _csrf cookie.\n\tSetCookie bool\n\t// Set the Secure flag to true on the cookie.\n\tSecure bool\n\t// Disallow Origin appear in request header.\n\tOrigin bool\n\t// The function called when Validate fails.\n\tErrorFunc func(w http.ResponseWriter)\n}\n\nfunc prepareOptions(options []Options) Options {\n\tvar opt Options\n\tif len(options) > 0 {\n\t\topt = options[0]\n\t}\n\n\t// Defaults.\n\tif len(opt.Secret) == 0 {\n\t\topt.Secret = string(com.RandomCreateBytes(10))\n\t}\n\tif len(opt.Header) == 0 {\n\t\topt.Header = \"X-CSRFToken\"\n\t}\n\tif len(opt.Form) == 0 {\n\t\topt.Form = \"_csrf\"\n\t}\n\tif len(opt.Cookie) == 0 {\n\t\topt.Cookie = \"_csrf\"\n\t}\n\tif len(opt.CookiePath) == 0 {\n\t\topt.CookiePath = \"/\"\n\t}\n\tif len(opt.SessionKey) == 0 {\n\t\topt.SessionKey = \"uid\"\n\t}\n\topt.oldSeesionKey = \"_old_\" + opt.SessionKey\n\tif opt.ErrorFunc == nil {\n\t\topt.ErrorFunc = func(w http.ResponseWriter) {\n\t\t\thttp.Error(w, \"Invalid csrf token.\", http.StatusBadRequest)\n\t\t}\n\t}\n\n\treturn opt\n}\n\n// Generate maps CSRF to each request. If this request is a Get request, it will generate a new token.\n// Additionally, depending on options set, generated tokens will be sent via Header and/or Cookie.\nfunc Generate(options ...Options) macaron.Handler {\n\topt := prepareOptions(options)\n\treturn func(ctx *macaron.Context, sess session.Store) {\n\t\tx := &csrf{\n\t\t\tSecret:         opt.Secret,\n\t\t\tHeader:         opt.Header,\n\t\t\tForm:           opt.Form,\n\t\t\tCookie:         opt.Cookie,\n\t\t\tCookiePath:     opt.CookiePath,\n\t\t\tCookieHttpOnly: opt.CookieHttpOnly,\n\t\t\tErrorFunc:      opt.ErrorFunc,\n\t\t}\n\t\tctx.MapTo(x, (*CSRF)(nil))\n\n\t\tif opt.Origin && len(ctx.Req.Header.Get(\"Origin\")) > 0 {\n\t\t\treturn\n\t\t}\n\n\t\tx.ID = \"0\"\n\t\tuid := sess.Get(opt.SessionKey)\n\t\tif uid != nil {\n\t\t\tx.ID = com.ToStr(uid)\n\t\t}\n\n\t\tneedsNew := false\n\t\toldUid := sess.Get(opt.oldSeesionKey)\n\t\tif oldUid == nil || oldUid.(string) != x.ID {\n\t\t\tneedsNew = true\n\t\t\tsess.Set(opt.oldSeesionKey, x.ID)\n\t\t} else {\n\t\t\t// If cookie present, map existing token, else generate a new one.\n\t\t\tif val := ctx.GetCookie(opt.Cookie); len(val) > 0 {\n\t\t\t\t// FIXME: test coverage.\n\t\t\t\tx.Token = val\n\t\t\t} else {\n\t\t\t\tneedsNew = true\n\t\t\t}\n\t\t}\n\n\t\tif needsNew {\n\t\t\t// FIXME: actionId.\n\t\t\tx.Token = GenerateToken(x.Secret, x.ID, \"POST\")\n\t\t\tif opt.SetCookie {\n\t\t\t\tctx.SetCookie(opt.Cookie, x.Token, 0, opt.CookiePath, \"\", false, opt.CookieHttpOnly, time.Now().AddDate(0, 0, 1))\n\t\t\t}\n\t\t}\n\n\t\tif opt.SetHeader {\n\t\t\tctx.Resp.Header().Add(opt.Header, x.Token)\n\t\t}\n\t}\n}\n\n// Csrfer maps CSRF to each request. If this request is a Get request, it will generate a new token.\n// Additionally, depending on options set, generated tokens will be sent via Header and/or Cookie.\nfunc Csrfer(options ...Options) macaron.Handler {\n\treturn Generate(options...)\n}\n\n// Validate should be used as a per route middleware. It attempts to get a token from a \"X-CSRFToken\"\n// HTTP header and then a \"_csrf\" form value. If one of these is found, the token will be validated\n// using ValidToken. If this validation fails, custom Error is sent in the reply.\n// If neither a header or form value is found, http.StatusBadRequest is sent.\nfunc Validate(ctx *macaron.Context, x CSRF) {\n\tif token := ctx.Req.Header.Get(x.GetHeaderName()); len(token) > 0 {\n\t\tif !x.ValidToken(token) {\n\t\t\tctx.SetCookie(x.GetCookieName(), \"\", -1, x.GetCookiePath())\n\t\t\tx.Error(ctx.Resp)\n\t\t}\n\t\treturn\n\t}\n\tif token := ctx.Req.FormValue(x.GetFormName()); len(token) > 0 {\n\t\tif !x.ValidToken(token) {\n\t\t\tctx.SetCookie(x.GetCookieName(), \"\", -1, x.GetCookiePath())\n\t\t\tx.Error(ctx.Resp)\n\t\t}\n\t\treturn\n\t}\n\n\thttp.Error(ctx.Resp, \"Bad Request: no CSRF token present\", http.StatusBadRequest)\n}\n"], "fixing_code": ["// Copyright 2013 Martini Authors\n// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\n// Package csrf is a middleware that generates and validates CSRF tokens for Macaron.\npackage csrf\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/Unknwon/com\"\n\t\"github.com/go-macaron/session\"\n\t\"gopkg.in/macaron.v1\"\n)\n\nconst _VERSION = \"0.1.0\"\n\nfunc Version() string {\n\treturn _VERSION\n}\n\n// CSRF represents a CSRF service and is used to get the current token and validate a suspect token.\ntype CSRF interface {\n\t// Return HTTP header to search for token.\n\tGetHeaderName() string\n\t// Return form value to search for token.\n\tGetFormName() string\n\t// Return cookie name to search for token.\n\tGetCookieName() string\n\t// Return cookie path\n\tGetCookiePath() string\n\t// Return the flag value used for the csrf token.\n\tGetCookieHttpOnly() bool\n\t// Return the token.\n\tGetToken() string\n\t// Validate by token.\n\tValidToken(t string) bool\n\t// Error replies to the request with a custom function when ValidToken fails.\n\tError(w http.ResponseWriter)\n}\n\ntype csrf struct {\n\t// Header name value for setting and getting csrf token.\n\tHeader string\n\t// Form name value for setting and getting csrf token.\n\tForm string\n\t// Cookie name value for setting and getting csrf token.\n\tCookie string\n\t//Cookie path\n\tCookiePath string\n\t// Cookie HttpOnly flag value used for the csrf token.\n\tCookieHttpOnly bool\n\t// Token generated to pass via header, cookie, or hidden form value.\n\tToken string\n\t// This value must be unique per user.\n\tID string\n\t// Secret used along with the unique id above to generate the Token.\n\tSecret string\n\t// ErrorFunc is the custom function that replies to the request when ValidToken fails.\n\tErrorFunc func(w http.ResponseWriter)\n}\n\n// GetHeaderName returns the name of the HTTP header for csrf token.\nfunc (c *csrf) GetHeaderName() string {\n\treturn c.Header\n}\n\n// GetFormName returns the name of the form value for csrf token.\nfunc (c *csrf) GetFormName() string {\n\treturn c.Form\n}\n\n// GetCookieName returns the name of the cookie for csrf token.\nfunc (c *csrf) GetCookieName() string {\n\treturn c.Cookie\n}\n\n// GetCookiePath returns the path of the cookie for csrf token.\nfunc (c *csrf) GetCookiePath() string {\n\treturn c.CookiePath\n}\n\n// GetCookieHttpOnly returns the flag value used for the csrf token.\nfunc (c *csrf) GetCookieHttpOnly() bool {\n\treturn c.CookieHttpOnly\n}\n\n// GetToken returns the current token. This is typically used\n// to populate a hidden form in an HTML template.\nfunc (c *csrf) GetToken() string {\n\treturn c.Token\n}\n\n// ValidToken validates the passed token against the existing Secret and ID.\nfunc (c *csrf) ValidToken(t string) bool {\n\treturn ValidToken(t, c.Secret, c.ID, \"POST\")\n}\n\n// Error replies to the request when ValidToken fails.\nfunc (c *csrf) Error(w http.ResponseWriter) {\n\tc.ErrorFunc(w)\n}\n\n// Options maintains options to manage behavior of Generate.\ntype Options struct {\n\t// The global secret value used to generate Tokens.\n\tSecret string\n\t// HTTP header used to set and get token.\n\tHeader string\n\t// Form value used to set and get token.\n\tForm string\n\t// Cookie value used to set and get token.\n\tCookie string\n\t// Cookie path.\n\tCookiePath string\n\tCookieHttpOnly bool\n\t// Key used for getting the unique ID per user.\n\tSessionKey string\n\t// oldSeesionKey saves old value corresponding to SessionKey.\n\toldSeesionKey string\n\t// If true, send token via X-CSRFToken header.\n\tSetHeader bool\n\t// If true, send token via _csrf cookie.\n\tSetCookie bool\n\t// Set the Secure flag to true on the cookie.\n\tSecure bool\n\t// Disallow Origin appear in request header.\n\tOrigin bool\n\t// The function called when Validate fails.\n\tErrorFunc func(w http.ResponseWriter)\n}\n\nfunc prepareOptions(options []Options) Options {\n\tvar opt Options\n\tif len(options) > 0 {\n\t\topt = options[0]\n\t}\n\n\t// Defaults.\n\tif len(opt.Secret) == 0 {\n\t\topt.Secret = string(com.RandomCreateBytes(10))\n\t}\n\tif len(opt.Header) == 0 {\n\t\topt.Header = \"X-CSRFToken\"\n\t}\n\tif len(opt.Form) == 0 {\n\t\topt.Form = \"_csrf\"\n\t}\n\tif len(opt.Cookie) == 0 {\n\t\topt.Cookie = \"_csrf\"\n\t}\n\tif len(opt.CookiePath) == 0 {\n\t\topt.CookiePath = \"/\"\n\t}\n\tif len(opt.SessionKey) == 0 {\n\t\topt.SessionKey = \"uid\"\n\t}\n\topt.oldSeesionKey = \"_old_\" + opt.SessionKey\n\tif opt.ErrorFunc == nil {\n\t\topt.ErrorFunc = func(w http.ResponseWriter) {\n\t\t\thttp.Error(w, \"Invalid csrf token.\", http.StatusBadRequest)\n\t\t}\n\t}\n\n\treturn opt\n}\n\n// Generate maps CSRF to each request. If this request is a Get request, it will generate a new token.\n// Additionally, depending on options set, generated tokens will be sent via Header and/or Cookie.\nfunc Generate(options ...Options) macaron.Handler {\n\topt := prepareOptions(options)\n\treturn func(ctx *macaron.Context, sess session.Store) {\n\t\tx := &csrf{\n\t\t\tSecret:         opt.Secret,\n\t\t\tHeader:         opt.Header,\n\t\t\tForm:           opt.Form,\n\t\t\tCookie:         opt.Cookie,\n\t\t\tCookiePath:     opt.CookiePath,\n\t\t\tCookieHttpOnly: opt.CookieHttpOnly,\n\t\t\tErrorFunc:      opt.ErrorFunc,\n\t\t}\n\t\tctx.MapTo(x, (*CSRF)(nil))\n\n\t\tif opt.Origin && len(ctx.Req.Header.Get(\"Origin\")) > 0 {\n\t\t\treturn\n\t\t}\n\n\t\tx.ID = \"0\"\n\t\tuid := sess.Get(opt.SessionKey)\n\t\tif uid != nil {\n\t\t\tx.ID = com.ToStr(uid)\n\t\t}\n\n\t\tneedsNew := false\n\t\toldUid := sess.Get(opt.oldSeesionKey)\n\t\tif oldUid == nil || oldUid.(string) != x.ID {\n\t\t\tneedsNew = true\n\t\t\tsess.Set(opt.oldSeesionKey, x.ID)\n\t\t} else {\n\t\t\t// If cookie present, map existing token, else generate a new one.\n\t\t\tif val := ctx.GetCookie(opt.Cookie); len(val) > 0 {\n\t\t\t\t// FIXME: test coverage.\n\t\t\t\tx.Token = val\n\t\t\t} else {\n\t\t\t\tneedsNew = true\n\t\t\t}\n\t\t}\n\n\t\tif needsNew {\n\t\t\t// FIXME: actionId.\n\t\t\tx.Token = GenerateToken(x.Secret, x.ID, \"POST\")\n\t\t\tif opt.SetCookie {\n\t\t\t\tctx.SetCookie(opt.Cookie, x.Token, 0, opt.CookiePath, \"\", opt.Secure, opt.CookieHttpOnly, time.Now().AddDate(0, 0, 1))\n\t\t\t}\n\t\t}\n\n\t\tif opt.SetHeader {\n\t\t\tctx.Resp.Header().Add(opt.Header, x.Token)\n\t\t}\n\t}\n}\n\n// Csrfer maps CSRF to each request. If this request is a Get request, it will generate a new token.\n// Additionally, depending on options set, generated tokens will be sent via Header and/or Cookie.\nfunc Csrfer(options ...Options) macaron.Handler {\n\treturn Generate(options...)\n}\n\n// Validate should be used as a per route middleware. It attempts to get a token from a \"X-CSRFToken\"\n// HTTP header and then a \"_csrf\" form value. If one of these is found, the token will be validated\n// using ValidToken. If this validation fails, custom Error is sent in the reply.\n// If neither a header or form value is found, http.StatusBadRequest is sent.\nfunc Validate(ctx *macaron.Context, x CSRF) {\n\tif token := ctx.Req.Header.Get(x.GetHeaderName()); len(token) > 0 {\n\t\tif !x.ValidToken(token) {\n\t\t\tctx.SetCookie(x.GetCookieName(), \"\", -1, x.GetCookiePath())\n\t\t\tx.Error(ctx.Resp)\n\t\t}\n\t\treturn\n\t}\n\tif token := ctx.Req.FormValue(x.GetFormName()); len(token) > 0 {\n\t\tif !x.ValidToken(token) {\n\t\t\tctx.SetCookie(x.GetCookieName(), \"\", -1, x.GetCookiePath())\n\t\t\tx.Error(ctx.Resp)\n\t\t}\n\t\treturn\n\t}\n\n\thttp.Error(ctx.Resp, \"Bad Request: no CSRF token present\", http.StatusBadRequest)\n}\n"], "filenames": ["csrf.go"], "buggy_code_start_loc": [225], "buggy_code_end_loc": [226], "fixing_code_start_loc": [225], "fixing_code_end_loc": [226], "type": "CWE-311", "message": "A vulnerability was found in Macaron csrf and classified as problematic. Affected by this issue is some unknown functionality of the file csrf.go. The manipulation of the argument Generate leads to sensitive cookie without secure attribute. The attack may be launched remotely. The name of the patch is dadd1711a617000b70e5e408a76531b73187031c. It is recommended to apply a patch to fix this issue. VDB-217058 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2018-25060", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-30T12:15:09.103", "lastModified": "2023-01-09T15:27:11.830", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Macaron csrf and classified as problematic. Affected by this issue is some unknown functionality of the file csrf.go. The manipulation of the argument Generate leads to sensitive cookie without secure attribute. The attack may be launched remotely. The name of the patch is dadd1711a617000b70e5e408a76531b73187031c. It is recommended to apply a patch to fix this issue. VDB-217058 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.6}, "baseSeverity": "LOW", "exploitabilityScore": 4.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-311"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-614"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:go-macaron:csrf:-:*:*:*:*:macaron:*:*", "matchCriteriaId": "DA5EDE88-EB9B-4482-B7AF-C5AFE9604957"}]}]}], "references": [{"url": "https://github.com/go-macaron/csrf/commit/dadd1711a617000b70e5e408a76531b73187031c", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/go-macaron/csrf/pull/7", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217058", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217058", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/go-macaron/csrf/commit/dadd1711a617000b70e5e408a76531b73187031c"}}