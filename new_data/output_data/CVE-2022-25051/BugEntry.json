{"buggy_code": ["/** @file\n    Clipsal CMR113 cent-a-meter power meter.\n\n    Copyright (C) 2021 Michael Neuling <mikey@neuling.org>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n*/\n\n#include \"decoder.h\"\n\n/**\nClipsal CMR113 cent-a-meter power meter.\n\nThe demodulation comes in a few stages:\n\nA) Firstly we look at the pulse lengths both high and low. These\n   are demodulated using OOK_PULSE_PIWM_DC before we hit this\n   driver. Any short pulse (high or low) is assigned a 1 and a\n   long pulse (high or low) is assigned a 0. ie every pulse is a\n   bit.\n\nB) We then look for two patterns in this new bitstream:\n    - 0b00 (ie long long from stream A)\n    - 0b011 (ie long short short from stream A)\n\nC) We start off with an output bit of '0'.  When we see a 0b00\n   (from B), the next output bit is the same as the last\n   bit. When we see a 0b011 (from B), the next output is\n   toggled. If we don't see ether of these patterns, we fail.\n\nD) The output from C represents the final bitstream. This is 83\n   bits repeated twice. There are some timestamps, transmitter\n   IDs and CRC but all we decode below are the 3 current values\n   which are 10 bits each representing AMPS/10. We do check the\n   two 83 bit are identical and fail if not.\n\nKudos to Jon Oxer for decoding this stream and putting it here:\nhttps://github.com/jonoxer/CentAReceiver\n\n*/\n\n#define COMPARE_BITS 83\n#define COMPARE_BYTES (COMPARE_BITS/8)\n\nstatic int cmr113_decode(r_device *decoder, bitbuffer_t *bitbuffer)\n{\n    int start, bit;\n    uint8_t buf[4];\n    uint8_t b1[COMPARE_BYTES], b2[COMPARE_BYTES];\n    bitbuffer_t b = {0};\n    double current[3];\n    data_t *data;\n\n    if ((bitbuffer->bits_per_row[0] < 350) || (bitbuffer->bits_per_row[0] > 450))\n        return DECODE_ABORT_LENGTH;\n\n    bitbuffer_extract_bytes(bitbuffer, 0, 0, buf, 32);\n    if ((buf[0] != 0xb0) || (buf[1] != 0x00) || (buf[2] != 0x00))\n        return DECODE_ABORT_EARLY;\n\n    start = 0;\n    bit = 0;\n    bitbuffer_clear(&b);\n    while ((start + 3) < bitbuffer->bits_per_row[0]) {\n        bitbuffer_extract_bytes(bitbuffer, 0, start, buf, 3);\n        if ((buf[0] >> 6) == 0x00) { // top two bits are 0b00 = no toggle\n            start += 2;\n            bitbuffer_add_bit(&b, bit);\n        } else if ((buf[0] >> 5) == 0x03) { // top two bits are 0b011 = toggle\n            start += 3;\n            bit = 1 - bit; // toggle\n            bitbuffer_add_bit(&b, bit);\n        } else if (start == 0)\n            start += 1; // first bit doesn't decode\n        else\n            // we don't have enough bits\n            return DECODE_ABORT_LENGTH;\n    }\n\n    if (b.bits_per_row[0] < 2 * COMPARE_BITS + 2)\n        return DECODE_ABORT_LENGTH;\n\n    // Compare the repeated section to ensure data integrity\n    bitbuffer_extract_bytes(&b, 0, 0, b1, COMPARE_BITS);\n    bitbuffer_extract_bytes(&b, 0, COMPARE_BITS + 2, b2, COMPARE_BITS);\n    if (memcmp(b1, b2, COMPARE_BYTES) != 0)\n        return DECODE_FAIL_MIC;\n\n    // Data is all good, so extract 3 phases of current\n    for (int i = 0; i < 3; i++) {\n        bitbuffer_extract_bytes(&b, 0, 36 + i * 10, buf, 10);\n        reflect_bytes(buf, 2);\n        current[i] = ((float)buf[0] + ((buf[1] & 0x3) << 8)) * 0.1;\n    }\n\n    /* clang-format off */\n    data = data_make(\n            \"model\",        \"\",             DATA_STRING, \"Clipsal-CMR113\",\n            \"current_1_A\",  \"Current 1\",    DATA_FORMAT, \"%.1f A\", DATA_DOUBLE, current[0],\n            \"current_2_A\",  \"Current 2\",    DATA_FORMAT, \"%.1f A\", DATA_DOUBLE, current[1],\n            \"current_3_A\",  \"Current 3\",    DATA_FORMAT, \"%.1f A\", DATA_DOUBLE, current[2],\n            NULL);\n    /* clang-format on */\n\n    decoder_output_data(decoder, data);\n    return 1;\n}\n\nstatic char *output_fields[] = {\n        \"model\",\n        \"current_1_A\",\n        \"current_2_A\",\n        \"current_3_A\",\n        NULL,\n};\n\n// Short high and low pulses are quite different in length so we have a high tolerance of 200\nr_device cmr113 = {\n        .name        = \"Clipsal CMR113 Cent-a-meter power meter\",\n        .modulation  = OOK_PULSE_PIWM_DC,\n        .short_width = 480,\n        .long_width  = 976,\n        .sync_width  = 2028,\n        .reset_limit = 2069,\n        .tolerance   = 200,\n        .decode_fn   = &cmr113_decode,\n        .fields      = output_fields,\n};\n", "/** @file\n    Somfy io-homecontrol.\n\n    Copyright (C) 2021 Christian W. Zuckschwerdt <zany@triq.net>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n*/\n\n/**\nSomfy io-homecontrol devices.\n\nE.g. Velux remote controller KI 313.\n\n    rtl_433 -c 0 -R 0 -g 40 -X \"n=uart,m=FSK_PCM,s=26,l=26,r=300,preamble={24}0x5555ff,decode_uart\" -f 868.89M\n\nProtocol description:\n\n- Preamble is 55..55.\n- The message, including the sync word is UART encoded, 8 data bits equal 10 packet bits.\n- 16 bit sync word of ff33, UART encoded: 0 ff 1 0 cc 1 = 7fd99.\n- 4+4 bit message type/length indicator byte.\n- 32 bit destination address (little endian presumably).\n- 32 bit source address (little endian presumably).\n- n bytes variable length message payload bytes\n- 16 bit MAC counter value\n- 48 bit MAC value\n- 16 bit CRC-16, poly 0x1021, init 0x0000, reflected.\n\nExample packets:\n\n    ff33 f6 2000003f dacdea00 016100000000     0bdd fd8ef56f15ad aa1e\n    ff33 f6 0000003f dacdea00 016100000000     0bdd fd8ef56f15ad 4f9c\n    ff33 f6 2000003f dacdea00 0161c8000000     0bbd 8aa3a9732e10 26d2\n    ff33 f6 0000003f dacdea00 0161c8000000     0bbd 8aa3a9732e10 c350\n    ff33 f6 2000003f dacdea00 0161d2000000     0b99 15decacf7e0e 8069\n    ff33 f6 0000003f dacdea00 0161d2000000     0b99 15decacf7e0e 65eb\n    ff33 f6 0000003f dacdea00 0161d2000000     0ba1 05175a82dfae 8bbf\n\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0d6c 2c3a3123e6ab 7f1e [UP RIGHT]\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0d6e e448de7d4e03 62d1 [UP RIGHT]\n    ff33 f8 0000007f c5896700 0161d40080c80000 0c63 04e867ed64ad f055 [UP LEFT]\n    ff33 f8 0000007f c5896700 0161d40080c80000 0c65 8414991e8b06 b82b [UP LEFT]\n    ff33 f8 0000007f 70875800 0161d40080c80000 3bd5 05526875499c 7e72 [UP PSA]\n    ff33 f6 0000003f e1f57300 0161d2000000     0d6f 708d89781e43 bc24 [STOP RIGHT]\n    ff33 f6 0000003f e1f57300 0161d2000000     0d71 d1b10f26e1c1 8a9d [STOP RIGHT]\n    ff33 f6 0000003f c5896700 0161d2000000     0c66 4fcf56fb1c72 d31e [STOP LEFT]\n    ff33 f6 0000003f c5896700 0161d2000000     0c68 2025e049f331 b64a [STOP LEFT]\n    ff33 f6 0000003f 70875800 0161d2000000     3bd2 e6b62cef54c8 a937 [STOP PSA]\n    ff33 f6 0000003f 70875800 0161d2000000     3bd6 630743f0530d dc24 [STOP PSA]\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0d74 9fb9a0665ff4 77a6 [DOWN RIGHT]\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0d76 71b81065a2e2 0616 [DOWN RIGHT]\n    ff33 f8 0000007f c5896700 0161d40080c80000 0c6b 56fcf691e6a9 2c74 [DOWN LEFT]\n    ff33 f8 0000007f c5896700 0161d40080c80000 0c6d daf020864668 8fad [DOWN LEFT]\n    ff33 f8 0000007f 70875800 0161d40080c80000 3bdf 1ee7a0e30448 7a6b [DOWN PSA]\n\n    ff33 f6 0000003f 17f52300 0147c8000000     18c4 38789cb680cc bc74\n    ff33 f8 0000003f 17f52320 02ff0143010e0000 18c5 045ee107363d 59b4\n    ff33 f8 0000003f 17f52320 02ff01430105ff00 18c6 a34715cbe012 4f7f\n    ^    ^  ^        ^        ^                ^    ^            ^CRC\n    ^    ^  ^        ^        ^                ^    ^MAC\n    ^    ^  ^        ^        ^                ^counter\n    ^    ^  ^        ^        ^payload\n    ^    ^  ^        ^source\n    ^    ^  ^destination\n    ^    ^length of payload\n    ^sync, not included in CRC\n\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0d9a 4c0e4a0e45aa 995d\n    ff33 f8 0000007f c5896700 0161d40080c80000 0d9a 87ac970b53d1 d80d\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0d9c ec44bf478a06 0cad\n    ff33 f8 0000007f c5896700 0161d40080c80000 0d9c f610e5e0eb9f 6ba1\n    ff33 f8 0000007f c5896700 0161d40080c80000 0d9e 10707b9a1f4a ed84\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0d9e de2cc3c1117a f8fd\n    ff33 f8 0000007f c5896700 0161d40080c80000 0da0 11280dad6fe7 b06a\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0da0 209550b7e353 0a35\n    ff33 f8 0000007f c5896700 0161d40080c80000 0da2 445f4c017d24 0cde\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0da2 877cc2f46a38 8a5c\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0da4 4412916d3fe6 42b8\n    ff33 f8 0000007f c5896700 0161d40080c80000 0da4 787e20402f19 6b43\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0da6 0eb34055b18f 1209\n    ff33 f8 0000007f c5896700 0161d40080c80000 0da6 33a9c2c0cc66 5e5d\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0da8 07c9a103761b 1f5b\n    ff33 f8 0000007f c5896700 0161d40080c80000 0da8 b3f7dd7a366f de5e\n    ff33 f8 0000007f c5896700 0161d40080c80000 0daa 80075cf2e7bc 6064\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0daa eb6adf4f8fad 3404\n\n*/\n\n#include \"decoder.h\"\n\nstatic int somfy_iohc_decode(r_device *decoder, bitbuffer_t *bitbuffer)\n{\n    uint8_t const preamble_pattern[] = {0x57, 0xfd, 0x99};\n\n    uint8_t b[19 + 15]; // 19 byte + up 15 byte payload\n\n    if (bitbuffer->num_rows != 1)\n        return DECODE_ABORT_EARLY;\n\n    int offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;\n    if (offset >= bitbuffer->bits_per_row[0] - 19 * 10)\n        return DECODE_ABORT_EARLY;\n\n    int num_bits = bitbuffer->bits_per_row[0] - offset;\n\n    int len = extract_bytes_uart(bitbuffer->bb[0], offset, num_bits, b);\n    if (len < 19)\n        return DECODE_ABORT_LENGTH;\n\n    if ((b[0] & 0xf0) != 0xf0)\n        return DECODE_ABORT_EARLY;\n\n    int msg_len = b[0] & 0xf; // should be 6 or 8\n    if (len < 19 + msg_len)\n        return DECODE_ABORT_LENGTH;\n\n    // calculate and verify checksum\n    if (crc16lsb(b, len, 0x8408, 0x0000) != 0) // unreflected poly 0x1021\n        return DECODE_FAIL_MIC;\n    bitrow_printf(b, len * 8, \"%s: offset %d, num_bits %d, len %d, msg_len %d\\n\", __func__, offset, num_bits, len, msg_len);\n\n    int msg_type = (b[0]);\n    int dst_id   = ((unsigned)b[4] << 24) | (b[3] << 16) | (b[2] << 8) | (b[1]); // assume Little-Endian\n    int src_id   = ((unsigned)b[8] << 24) | (b[7] << 16) | (b[6] << 8) | (b[5]); // assume Little-Endian\n    int counter  = (b[len - 10] << 8) | (b[len - 9]);\n    char msg_str[15 * 2 + 1];\n    bitrow_snprint(&b[9], msg_len * 8, msg_str, 15 * 2 + 1);\n    char mac_str[13];\n    bitrow_snprint(&b[len - 8], 6 * 8, mac_str, 13);\n\n    /* clang-format off */\n    data_t *data = data_make(\n            \"model\",            \"\",                 DATA_STRING, \"Somfy-IOHC\",\n            \"id\",               \"\",                 DATA_FORMAT, \"%08x\", DATA_INT, src_id,\n            \"dst_id\",           \"Dest ID\",          DATA_FORMAT, \"%08x\", DATA_INT, dst_id,\n            \"msg_type\",         \"Msg type\",         DATA_FORMAT, \"%02x\", DATA_INT, msg_type,\n            \"msg\",              \"Message\",          DATA_STRING, msg_str,\n            \"counter\",          \"Counter\",          DATA_INT,    counter,\n            \"mac\",              \"MAC\",              DATA_STRING, mac_str,\n            \"mic\",              \"Integrity\",        DATA_STRING, \"CRC\",\n            NULL);\n    /* clang-format on */\n\n    decoder_output_data(decoder, data);\n    return 1;\n}\n\nstatic char *output_fields[] = {\n        \"model\",\n        \"id\",\n        \"dst_id\",\n        \"msg_type\",\n        \"msg\",\n        \"counter\",\n        \"mac\",\n        \"mic\",\n        NULL,\n};\n\n// rtl_433 -c 0 -R 0 -g 40 -X \"n=uart,m=FSK_PCM,s=26,l=26,r=300,preamble={24}0x57fd99,decode_uart\" -f 868.89M\nr_device somfy_iohc = {\n        .name        = \"Somfy io-homecontrol\",\n        .modulation  = FSK_PULSE_PCM,\n        .short_width = 26,\n        .long_width  = 26,\n        .reset_limit = 300, // UART encoding has at most 9 0's, nominal 234 us.\n        .decode_fn   = &somfy_iohc_decode,\n        .fields      = output_fields,\n};\n"], "fixing_code": ["/** @file\n    Clipsal CMR113 cent-a-meter power meter.\n\n    Copyright (C) 2021 Michael Neuling <mikey@neuling.org>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n*/\n\n#include \"decoder.h\"\n\n/**\nClipsal CMR113 cent-a-meter power meter.\n\nThe demodulation comes in a few stages:\n\nA) Firstly we look at the pulse lengths both high and low. These\n   are demodulated using OOK_PULSE_PIWM_DC before we hit this\n   driver. Any short pulse (high or low) is assigned a 1 and a\n   long pulse (high or low) is assigned a 0. ie every pulse is a\n   bit.\n\nB) We then look for two patterns in this new bitstream:\n    - 0b00 (ie long long from stream A)\n    - 0b011 (ie long short short from stream A)\n\nC) We start off with an output bit of '0'.  When we see a 0b00\n   (from B), the next output bit is the same as the last\n   bit. When we see a 0b011 (from B), the next output is\n   toggled. If we don't see ether of these patterns, we fail.\n\nD) The output from C represents the final bitstream. This is 83\n   bits repeated twice. There are some timestamps, transmitter\n   IDs and CRC but all we decode below are the 3 current values\n   which are 10 bits each representing AMPS/10. We do check the\n   two 83 bit are identical and fail if not.\n\nKudos to Jon Oxer for decoding this stream and putting it here:\nhttps://github.com/jonoxer/CentAReceiver\n\n*/\n\n#define COMPARE_BITS  83\n#define COMPARE_BYTES ((COMPARE_BITS + 7) / 8)\n\nstatic int cmr113_decode(r_device *decoder, bitbuffer_t *bitbuffer)\n{\n    int start, bit;\n    uint8_t buf[4];\n    uint8_t b1[COMPARE_BYTES], b2[COMPARE_BYTES];\n    bitbuffer_t b = {0};\n    double current[3];\n    data_t *data;\n\n    if ((bitbuffer->bits_per_row[0] < 350) || (bitbuffer->bits_per_row[0] > 450))\n        return DECODE_ABORT_LENGTH;\n\n    bitbuffer_extract_bytes(bitbuffer, 0, 0, buf, 32);\n    if ((buf[0] != 0xb0) || (buf[1] != 0x00) || (buf[2] != 0x00))\n        return DECODE_ABORT_EARLY;\n\n    start = 0;\n    bit = 0;\n    bitbuffer_clear(&b);\n    while ((start + 3) < bitbuffer->bits_per_row[0]) {\n        bitbuffer_extract_bytes(bitbuffer, 0, start, buf, 3);\n        if ((buf[0] >> 6) == 0x00) { // top two bits are 0b00 = no toggle\n            start += 2;\n            bitbuffer_add_bit(&b, bit);\n        } else if ((buf[0] >> 5) == 0x03) { // top two bits are 0b011 = toggle\n            start += 3;\n            bit = 1 - bit; // toggle\n            bitbuffer_add_bit(&b, bit);\n        } else if (start == 0)\n            start += 1; // first bit doesn't decode\n        else\n            // we don't have enough bits\n            return DECODE_ABORT_LENGTH;\n    }\n\n    if (b.bits_per_row[0] < 2 * COMPARE_BITS + 2)\n        return DECODE_ABORT_LENGTH;\n\n    // Compare the repeated section to ensure data integrity\n    bitbuffer_extract_bytes(&b, 0, 0, b1, COMPARE_BITS);\n    bitbuffer_extract_bytes(&b, 0, COMPARE_BITS + 2, b2, COMPARE_BITS);\n    if (memcmp(b1, b2, COMPARE_BYTES) != 0)\n        return DECODE_FAIL_MIC;\n\n    // Data is all good, so extract 3 phases of current\n    for (int i = 0; i < 3; i++) {\n        bitbuffer_extract_bytes(&b, 0, 36 + i * 10, buf, 10);\n        reflect_bytes(buf, 2);\n        current[i] = ((float)buf[0] + ((buf[1] & 0x3) << 8)) * 0.1;\n    }\n\n    /* clang-format off */\n    data = data_make(\n            \"model\",        \"\",             DATA_STRING, \"Clipsal-CMR113\",\n            \"current_1_A\",  \"Current 1\",    DATA_FORMAT, \"%.1f A\", DATA_DOUBLE, current[0],\n            \"current_2_A\",  \"Current 2\",    DATA_FORMAT, \"%.1f A\", DATA_DOUBLE, current[1],\n            \"current_3_A\",  \"Current 3\",    DATA_FORMAT, \"%.1f A\", DATA_DOUBLE, current[2],\n            NULL);\n    /* clang-format on */\n\n    decoder_output_data(decoder, data);\n    return 1;\n}\n\nstatic char *output_fields[] = {\n        \"model\",\n        \"current_1_A\",\n        \"current_2_A\",\n        \"current_3_A\",\n        NULL,\n};\n\n// Short high and low pulses are quite different in length so we have a high tolerance of 200\nr_device cmr113 = {\n        .name        = \"Clipsal CMR113 Cent-a-meter power meter\",\n        .modulation  = OOK_PULSE_PIWM_DC,\n        .short_width = 480,\n        .long_width  = 976,\n        .sync_width  = 2028,\n        .reset_limit = 2069,\n        .tolerance   = 200,\n        .decode_fn   = &cmr113_decode,\n        .fields      = output_fields,\n};\n", "/** @file\n    Somfy io-homecontrol.\n\n    Copyright (C) 2021 Christian W. Zuckschwerdt <zany@triq.net>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n*/\n\n/**\nSomfy io-homecontrol devices.\n\nE.g. Velux remote controller KI 313.\n\n    rtl_433 -c 0 -R 0 -g 40 -X \"n=uart,m=FSK_PCM,s=26,l=26,r=300,preamble={24}0x5555ff,decode_uart\" -f 868.89M\n\nProtocol description:\n\n- Preamble is 55..55.\n- The message, including the sync word is UART encoded, 8 data bits equal 10 packet bits.\n- 16 bit sync word of ff33, UART encoded: 0 ff 1 0 cc 1 = 7fd99.\n- 4+4 bit message type/length indicator byte.\n- 32 bit destination address (little endian presumably).\n- 32 bit source address (little endian presumably).\n- n bytes variable length message payload bytes\n- 16 bit MAC counter value\n- 48 bit MAC value\n- 16 bit CRC-16, poly 0x1021, init 0x0000, reflected.\n\nExample packets:\n\n    ff33 f6 2000003f dacdea00 016100000000     0bdd fd8ef56f15ad aa1e\n    ff33 f6 0000003f dacdea00 016100000000     0bdd fd8ef56f15ad 4f9c\n    ff33 f6 2000003f dacdea00 0161c8000000     0bbd 8aa3a9732e10 26d2\n    ff33 f6 0000003f dacdea00 0161c8000000     0bbd 8aa3a9732e10 c350\n    ff33 f6 2000003f dacdea00 0161d2000000     0b99 15decacf7e0e 8069\n    ff33 f6 0000003f dacdea00 0161d2000000     0b99 15decacf7e0e 65eb\n    ff33 f6 0000003f dacdea00 0161d2000000     0ba1 05175a82dfae 8bbf\n\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0d6c 2c3a3123e6ab 7f1e [UP RIGHT]\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0d6e e448de7d4e03 62d1 [UP RIGHT]\n    ff33 f8 0000007f c5896700 0161d40080c80000 0c63 04e867ed64ad f055 [UP LEFT]\n    ff33 f8 0000007f c5896700 0161d40080c80000 0c65 8414991e8b06 b82b [UP LEFT]\n    ff33 f8 0000007f 70875800 0161d40080c80000 3bd5 05526875499c 7e72 [UP PSA]\n    ff33 f6 0000003f e1f57300 0161d2000000     0d6f 708d89781e43 bc24 [STOP RIGHT]\n    ff33 f6 0000003f e1f57300 0161d2000000     0d71 d1b10f26e1c1 8a9d [STOP RIGHT]\n    ff33 f6 0000003f c5896700 0161d2000000     0c66 4fcf56fb1c72 d31e [STOP LEFT]\n    ff33 f6 0000003f c5896700 0161d2000000     0c68 2025e049f331 b64a [STOP LEFT]\n    ff33 f6 0000003f 70875800 0161d2000000     3bd2 e6b62cef54c8 a937 [STOP PSA]\n    ff33 f6 0000003f 70875800 0161d2000000     3bd6 630743f0530d dc24 [STOP PSA]\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0d74 9fb9a0665ff4 77a6 [DOWN RIGHT]\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0d76 71b81065a2e2 0616 [DOWN RIGHT]\n    ff33 f8 0000007f c5896700 0161d40080c80000 0c6b 56fcf691e6a9 2c74 [DOWN LEFT]\n    ff33 f8 0000007f c5896700 0161d40080c80000 0c6d daf020864668 8fad [DOWN LEFT]\n    ff33 f8 0000007f 70875800 0161d40080c80000 3bdf 1ee7a0e30448 7a6b [DOWN PSA]\n\n    ff33 f6 0000003f 17f52300 0147c8000000     18c4 38789cb680cc bc74\n    ff33 f8 0000003f 17f52320 02ff0143010e0000 18c5 045ee107363d 59b4\n    ff33 f8 0000003f 17f52320 02ff01430105ff00 18c6 a34715cbe012 4f7f\n    ^    ^  ^        ^        ^                ^    ^            ^CRC\n    ^    ^  ^        ^        ^                ^    ^MAC\n    ^    ^  ^        ^        ^                ^counter\n    ^    ^  ^        ^        ^payload\n    ^    ^  ^        ^source\n    ^    ^  ^destination\n    ^    ^length of payload\n    ^sync, not included in CRC\n\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0d9a 4c0e4a0e45aa 995d\n    ff33 f8 0000007f c5896700 0161d40080c80000 0d9a 87ac970b53d1 d80d\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0d9c ec44bf478a06 0cad\n    ff33 f8 0000007f c5896700 0161d40080c80000 0d9c f610e5e0eb9f 6ba1\n    ff33 f8 0000007f c5896700 0161d40080c80000 0d9e 10707b9a1f4a ed84\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0d9e de2cc3c1117a f8fd\n    ff33 f8 0000007f c5896700 0161d40080c80000 0da0 11280dad6fe7 b06a\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0da0 209550b7e353 0a35\n    ff33 f8 0000007f c5896700 0161d40080c80000 0da2 445f4c017d24 0cde\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0da2 877cc2f46a38 8a5c\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0da4 4412916d3fe6 42b8\n    ff33 f8 0000007f c5896700 0161d40080c80000 0da4 787e20402f19 6b43\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0da6 0eb34055b18f 1209\n    ff33 f8 0000007f c5896700 0161d40080c80000 0da6 33a9c2c0cc66 5e5d\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0da8 07c9a103761b 1f5b\n    ff33 f8 0000007f c5896700 0161d40080c80000 0da8 b3f7dd7a366f de5e\n    ff33 f8 0000007f c5896700 0161d40080c80000 0daa 80075cf2e7bc 6064\n    ff33 f8 0000007f e1f57300 0161d40080c80000 0daa eb6adf4f8fad 3404\n\n*/\n\n#include \"decoder.h\"\n\nstatic int somfy_iohc_decode(r_device *decoder, bitbuffer_t *bitbuffer)\n{\n    uint8_t const preamble_pattern[] = {0x57, 0xfd, 0x99};\n\n    uint8_t b[19 + 15]; // 19 byte + up 15 byte payload\n\n    if (bitbuffer->num_rows != 1)\n        return DECODE_ABORT_EARLY;\n\n    unsigned offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;\n    if (offset + 19 * 10 >= bitbuffer->bits_per_row[0])\n        return DECODE_ABORT_EARLY;\n\n    unsigned num_bits = bitbuffer->bits_per_row[0] - offset;\n    num_bits = MIN(num_bits, sizeof (b) * 8);\n\n    int len = extract_bytes_uart(bitbuffer->bb[0], offset, num_bits, b);\n    if (len < 19)\n        return DECODE_ABORT_LENGTH;\n\n    if ((b[0] & 0xf0) != 0xf0)\n        return DECODE_ABORT_EARLY;\n\n    int msg_len = b[0] & 0xf; // should be 6 or 8\n    if (len < 19 + msg_len)\n        return DECODE_ABORT_LENGTH;\n\n    // calculate and verify checksum\n    if (crc16lsb(b, len, 0x8408, 0x0000) != 0) // unreflected poly 0x1021\n        return DECODE_FAIL_MIC;\n    bitrow_printf(b, len * 8, \"%s: offset %u, num_bits %u, len %d, msg_len %d\\n\", __func__, offset, num_bits, len, msg_len);\n\n    int msg_type = (b[0]);\n    int dst_id   = ((unsigned)b[4] << 24) | (b[3] << 16) | (b[2] << 8) | (b[1]); // assume Little-Endian\n    int src_id   = ((unsigned)b[8] << 24) | (b[7] << 16) | (b[6] << 8) | (b[5]); // assume Little-Endian\n    int counter  = (b[len - 10] << 8) | (b[len - 9]);\n    char msg_str[15 * 2 + 1];\n    bitrow_snprint(&b[9], msg_len * 8, msg_str, 15 * 2 + 1);\n    char mac_str[13];\n    bitrow_snprint(&b[len - 8], 6 * 8, mac_str, 13);\n\n    /* clang-format off */\n    data_t *data = data_make(\n            \"model\",            \"\",                 DATA_STRING, \"Somfy-IOHC\",\n            \"id\",               \"\",                 DATA_FORMAT, \"%08x\", DATA_INT, src_id,\n            \"dst_id\",           \"Dest ID\",          DATA_FORMAT, \"%08x\", DATA_INT, dst_id,\n            \"msg_type\",         \"Msg type\",         DATA_FORMAT, \"%02x\", DATA_INT, msg_type,\n            \"msg\",              \"Message\",          DATA_STRING, msg_str,\n            \"counter\",          \"Counter\",          DATA_INT,    counter,\n            \"mac\",              \"MAC\",              DATA_STRING, mac_str,\n            \"mic\",              \"Integrity\",        DATA_STRING, \"CRC\",\n            NULL);\n    /* clang-format on */\n\n    decoder_output_data(decoder, data);\n    return 1;\n}\n\nstatic char *output_fields[] = {\n        \"model\",\n        \"id\",\n        \"dst_id\",\n        \"msg_type\",\n        \"msg\",\n        \"counter\",\n        \"mac\",\n        \"mic\",\n        NULL,\n};\n\n// rtl_433 -c 0 -R 0 -g 40 -X \"n=uart,m=FSK_PCM,s=26,l=26,r=300,preamble={24}0x57fd99,decode_uart\" -f 868.89M\nr_device somfy_iohc = {\n        .name        = \"Somfy io-homecontrol\",\n        .modulation  = FSK_PULSE_PCM,\n        .short_width = 26,\n        .long_width  = 26,\n        .reset_limit = 300, // UART encoding has at most 9 0's, nominal 234 us.\n        .decode_fn   = &somfy_iohc_decode,\n        .fields      = output_fields,\n};\n"], "filenames": ["src/devices/cmr113.c", "src/devices/somfy_iohc.c"], "buggy_code_start_loc": [45, 103], "buggy_code_end_loc": [47, 124], "fixing_code_start_loc": [45, 103], "fixing_code_end_loc": [47, 125], "type": "CWE-193", "message": "An Off-by-one Error occurs in cmr113_decode of rtl_433 21.12 when decoding a crafted file.", "other": {"cve": {"id": "CVE-2022-25051", "sourceIdentifier": "cve@mitre.org", "published": "2022-03-02T00:15:08.293", "lastModified": "2022-03-14T14:07:42.347", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An Off-by-one Error occurs in cmr113_decode of rtl_433 21.12 when decoding a crafted file."}, {"lang": "es", "value": "Se produce un error fuera de lugar en la funci\u00f3n cmr113_decode de rtl_433 versi\u00f3n 21.12, cuando es descodificado un archivo dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-193"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rtl_433_project:rtl_433:21.12:*:*:*:*:*:*:*", "matchCriteriaId": "9A498702-4055-4160-A6A1-E2F893BF3C47"}]}]}], "references": [{"url": "https://github.com/merbanan/rtl_433/commit/2dad7b9fc67a1d0bfbe520fbd821678b8f8cc7a8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/merbanan/rtl_433/issues/1960", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/78eee103-bd61-4b4f-b054-04ad996b39e7/", "source": "cve@mitre.org", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/merbanan/rtl_433/commit/2dad7b9fc67a1d0bfbe520fbd821678b8f8cc7a8"}}