{"buggy_code": ["/*\n * Copyright (c) 2011-2020 Meltytech, LLC\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include \"scrubbar.h\"\n#include \"openotherdialog.h\"\n#include \"player.h\"\n\n#include \"widgets/alsawidget.h\"\n#include \"widgets/colorbarswidget.h\"\n#include \"widgets/colorproducerwidget.h\"\n#include \"widgets/countproducerwidget.h\"\n#include \"widgets/decklinkproducerwidget.h\"\n#include \"widgets/directshowvideowidget.h\"\n#include \"widgets/isingwidget.h\"\n#include \"widgets/jackproducerwidget.h\"\n#include \"widgets/toneproducerwidget.h\"\n#include \"widgets/lissajouswidget.h\"\n#include \"widgets/networkproducerwidget.h\"\n#include \"widgets/noisewidget.h\"\n#include \"widgets/plasmawidget.h\"\n#include \"widgets/pulseaudiowidget.h\"\n#include \"widgets/video4linuxwidget.h\"\n#include \"widgets/x11grabwidget.h\"\n#include \"widgets/avformatproducerwidget.h\"\n#include \"widgets/imageproducerwidget.h\"\n#include \"widgets/webvfxproducer.h\"\n#include \"widgets/blipproducerwidget.h\"\n#include \"widgets/newprojectfolder.h\"\n#include \"docks/recentdock.h\"\n#include \"docks/encodedock.h\"\n#include \"docks/jobsdock.h\"\n#include \"jobqueue.h\"\n#include \"docks/playlistdock.h\"\n#include \"glwidget.h\"\n#include \"controllers/filtercontroller.h\"\n#include \"controllers/scopecontroller.h\"\n#include \"docks/filtersdock.h\"\n#include \"dialogs/customprofiledialog.h\"\n#include \"htmleditor/htmleditor.h\"\n#include \"settings.h\"\n#include \"leapnetworklistener.h\"\n#include \"database.h\"\n#include \"widgets/gltestwidget.h\"\n#include \"docks/timelinedock.h\"\n#include \"widgets/lumamixtransition.h\"\n#include \"qmltypes/qmlutilities.h\"\n#include \"qmltypes/qmlapplication.h\"\n#include \"autosavefile.h\"\n#include \"commands/playlistcommands.h\"\n#include \"shotcut_mlt_properties.h\"\n#include \"widgets/avfoundationproducerwidget.h\"\n#include \"dialogs/textviewerdialog.h\"\n#include \"widgets/gdigrabwidget.h\"\n#include \"models/audiolevelstask.h\"\n#include \"widgets/trackpropertieswidget.h\"\n#include \"widgets/timelinepropertieswidget.h\"\n#include \"dialogs/unlinkedfilesdialog.h\"\n#include \"docks/keyframesdock.h\"\n#include \"util.h\"\n#include \"models/keyframesmodel.h\"\n#include \"dialogs/listselectiondialog.h\"\n#include \"widgets/textproducerwidget.h\"\n#include \"qmltypes/qmlprofile.h\"\n#include \"dialogs/longuitask.h\"\n#include \"dialogs/systemsyncdialog.h\"\n#include \"proxymanager.h\"\n\n#include <QtWidgets>\n#include <Logger.h>\n#include <QThreadPool>\n#include <QtConcurrent/QtConcurrentRun>\n#include <QMutexLocker>\n#include <QQuickItem>\n#include <QtNetwork>\n#include <QJsonDocument>\n#include <QJSEngine>\n#include <QDirIterator>\n#include <QQuickWindow>\n#include <QVersionNumber>\n#include <clocale>\n\nstatic bool eventDebugCallback(void **data)\n{\n    QEvent *event = reinterpret_cast<QEvent*>(data[1]);\n    if (event->type() == QEvent::KeyPress || event->type() == QEvent::KeyRelease) {\n        QObject *receiver = reinterpret_cast<QObject*>(data[0]);\n        LOG_DEBUG() << event << \"->\" << receiver;\n    }\n    else if (event->type() == QEvent::MouseButtonPress || event->type() == QEvent::MouseButtonRelease) {\n        QObject *receiver = reinterpret_cast<QObject*>(data[0]);\n        LOG_DEBUG() << event << \"->\" << receiver;\n    }\n    return false;\n}\n\nstatic const int AUTOSAVE_TIMEOUT_MS = 60000;\n\nMainWindow::MainWindow()\n    : QMainWindow(0)\n    , ui(new Ui::MainWindow)\n    , m_isKKeyPressed(false)\n    , m_keyerGroup(0)\n    , m_previewScaleGroup(0)\n    , m_keyerMenu(0)\n    , m_isPlaylistLoaded(false)\n    , m_exitCode(EXIT_SUCCESS)\n    , m_navigationPosition(0)\n    , m_upgradeUrl(\"https://www.shotcut.org/download/\")\n    , m_keyframesDock(0)\n{\n#if defined(Q_OS_UNIX) && !defined(Q_OS_MAC)\n    QLibrary libJack(\"libjack.so.0\");\n    if (!libJack.load()) {\n        QMessageBox::critical(this, qApp->applicationName(),\n            tr(\"Error: This program requires the JACK 1 library.\\n\\nPlease install it using your package manager. It may be named libjack0, jack-audio-connection-kit, jack, or similar.\"));\n        ::exit(EXIT_FAILURE);\n    } else {\n        libJack.unload();\n    }\n    QLibrary libSDL(\"libSDL2-2.0.so.0\");\n    if (!libSDL.load()) {\n        QMessageBox::critical(this, qApp->applicationName(),\n            tr(\"Error: This program requires the SDL 2 library.\\n\\nPlease install it using your package manager. It may be named libsdl2-2.0-0, SDL2, or similar.\"));\n        ::exit(EXIT_FAILURE);\n    } else {\n        libSDL.unload();\n    }\n#endif\n\n    if (!qgetenv(\"OBSERVE_FOCUS\").isEmpty()) {\n        connect(qApp, &QApplication::focusChanged,\n                this, &MainWindow::onFocusChanged);\n        connect(qApp, &QGuiApplication::focusObjectChanged,\n                this, &MainWindow::onFocusObjectChanged);\n        connect(qApp, &QGuiApplication::focusWindowChanged,\n                this, &MainWindow::onFocusWindowChanged);\n    }\n\n    if (!qgetenv(\"EVENT_DEBUG\").isEmpty())\n        QInternal::registerCallback(QInternal::EventNotifyCallback, eventDebugCallback);\n\n    LOG_DEBUG() << \"begin\";\n#ifndef Q_OS_WIN\n    new GLTestWidget(this);\n#endif\n    Database::singleton(this);\n    m_autosaveTimer.setSingleShot(true);\n    m_autosaveTimer.setInterval(AUTOSAVE_TIMEOUT_MS);\n    connect(&m_autosaveTimer, SIGNAL(timeout()), this, SLOT(onAutosaveTimeout()));\n\n    // Initialize all QML types\n    QmlUtilities::registerCommonTypes();\n\n    // Create the UI.\n    ui->setupUi(this);\n#ifdef Q_OS_MAC\n    // Qt 5 on OS X supports the standard Full Screen window widget.\n    ui->mainToolBar->removeAction(ui->actionFullscreen);\n    // OS X has a standard Full Screen shortcut we should use.\n    ui->actionEnter_Full_Screen->setShortcut(QKeySequence((Qt::CTRL + Qt::META + Qt::Key_F)));\n#endif\n    setDockNestingEnabled(true);\n    ui->statusBar->hide();\n\n    // Connect UI signals.\n    connect(ui->actionOpen, SIGNAL(triggered()), this, SLOT(openVideo()));\n    connect(ui->actionAbout_Qt, SIGNAL(triggered()), qApp, SLOT(aboutQt()));\n    connect(this, SIGNAL(producerOpened()), this, SLOT(onProducerOpened()));\n    if (ui->actionFullscreen)\n        connect(ui->actionFullscreen, SIGNAL(triggered()), this, SLOT(on_actionEnter_Full_Screen_triggered()));\n    connect(ui->mainToolBar, SIGNAL(visibilityChanged(bool)), SLOT(onToolbarVisibilityChanged(bool)));\n\n    // Accept drag-n-drop of files.\n    this->setAcceptDrops(true);\n\n    // Setup the undo stack.\n    m_undoStack = new QUndoStack(this);\n    m_undoStack->setUndoLimit(Settings.undoLimit());\n    QAction *undoAction = m_undoStack->createUndoAction(this);\n    QAction *redoAction = m_undoStack->createRedoAction(this);\n    undoAction->setIcon(QIcon::fromTheme(\"edit-undo\", QIcon(\":/icons/oxygen/32x32/actions/edit-undo.png\")));\n    redoAction->setIcon(QIcon::fromTheme(\"edit-redo\", QIcon(\":/icons/oxygen/32x32/actions/edit-redo.png\")));\n    undoAction->setShortcut(QApplication::translate(\"MainWindow\", \"Ctrl+Z\", 0));\n#ifdef Q_OS_WIN\n    redoAction->setShortcut(QApplication::translate(\"MainWindow\", \"Ctrl+Y\", 0));\n#else\n    redoAction->setShortcut(QApplication::translate(\"MainWindow\", \"Ctrl+Shift+Z\", 0));\n#endif\n    ui->menuEdit->insertAction(ui->actionCut, undoAction);\n    ui->menuEdit->insertAction(ui->actionCut, redoAction);\n    ui->menuEdit->insertSeparator(ui->actionCut);\n    ui->actionUndo->setIcon(undoAction->icon());\n    ui->actionRedo->setIcon(redoAction->icon());\n    ui->actionUndo->setToolTip(undoAction->toolTip());\n    ui->actionRedo->setToolTip(redoAction->toolTip());\n    connect(m_undoStack, SIGNAL(canUndoChanged(bool)), ui->actionUndo, SLOT(setEnabled(bool)));\n    connect(m_undoStack, SIGNAL(canRedoChanged(bool)), ui->actionRedo, SLOT(setEnabled(bool)));\n\n    // Add the player widget.\n    m_player = new Player;\n    MLT.videoWidget()->installEventFilter(this);\n    ui->centralWidget->layout()->addWidget(m_player);\n    connect(this, SIGNAL(producerOpened()), m_player, SLOT(onProducerOpened()));\n    connect(m_player, SIGNAL(showStatusMessage(QString)), this, SLOT(showStatusMessage(QString)));\n    connect(m_player, SIGNAL(inChanged(int)), this, SLOT(onCutModified()));\n    connect(m_player, SIGNAL(outChanged(int)), this, SLOT(onCutModified()));\n    connect(m_player, SIGNAL(tabIndexChanged(int)), SLOT(onPlayerTabIndexChanged(int)));\n    connect(MLT.videoWidget(), SIGNAL(started()), SLOT(processMultipleFiles()));\n    connect(MLT.videoWidget(), SIGNAL(paused()), m_player, SLOT(showPaused()));\n    connect(MLT.videoWidget(), SIGNAL(playing()), m_player, SLOT(showPlaying()));\n    connect(MLT.videoWidget(), SIGNAL(toggleZoom(bool)), m_player, SLOT(toggleZoom(bool)));\n\n    setupSettingsMenu();\n    setupOpenOtherMenu();\n    readPlayerSettings();\n    configureVideoWidget();\n\n#ifndef SHOTCUT_NOUPGRADE\n    if (Settings.noUpgrade() || qApp->property(\"noupgrade\").toBool())\n#endif\n        delete ui->actionUpgrade;\n\n    // Add the docks.\n    m_scopeController = new ScopeController(this, ui->menuView);\n    QDockWidget* audioMeterDock = findChild<QDockWidget*>(\"AudioPeakMeterDock\");\n    if (audioMeterDock) {\n        audioMeterDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_1));\n        connect(ui->actionAudioMeter, SIGNAL(triggered()), audioMeterDock->toggleViewAction(), SLOT(trigger()));\n    }\n\n    m_propertiesDock = new QDockWidget(tr(\"Properties\"), this);\n    m_propertiesDock->hide();\n    m_propertiesDock->setObjectName(\"propertiesDock\");\n    m_propertiesDock->setWindowIcon(ui->actionProperties->icon());\n    m_propertiesDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_2));\n    m_propertiesDock->toggleViewAction()->setIcon(ui->actionProperties->icon());\n    m_propertiesDock->setMinimumWidth(300);\n    QScrollArea* scroll = new QScrollArea;\n    scroll->setWidgetResizable(true);\n    m_propertiesDock->setWidget(scroll);\n    addDockWidget(Qt::LeftDockWidgetArea, m_propertiesDock);\n    ui->menuView->addAction(m_propertiesDock->toggleViewAction());\n    connect(m_propertiesDock->toggleViewAction(), SIGNAL(triggered(bool)), this, SLOT(onPropertiesDockTriggered(bool)));\n    connect(ui->actionProperties, SIGNAL(triggered()), this, SLOT(onPropertiesDockTriggered()));\n\n    m_recentDock = new RecentDock(this);\n    m_recentDock->hide();\n    addDockWidget(Qt::RightDockWidgetArea, m_recentDock);\n    m_recentDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_3));\n    ui->menuView->addAction(m_recentDock->toggleViewAction());\n    connect(m_recentDock, SIGNAL(itemActivated(QString)), this, SLOT(open(QString)));\n    connect(m_recentDock->toggleViewAction(), SIGNAL(triggered(bool)), this, SLOT(onRecentDockTriggered(bool)));\n    connect(ui->actionRecent, SIGNAL(triggered()), this, SLOT(onRecentDockTriggered()));\n    connect(this, SIGNAL(openFailed(QString)), m_recentDock, SLOT(remove(QString)));\n    connect(m_recentDock, &RecentDock::deleted, m_player->projectWidget(), &NewProjectFolder::updateRecentProjects);\n\n    m_playlistDock = new PlaylistDock(this);\n    m_playlistDock->hide();\n    addDockWidget(Qt::LeftDockWidgetArea, m_playlistDock);\n    m_playlistDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_4));\n    ui->menuView->addAction(m_playlistDock->toggleViewAction());\n    connect(m_playlistDock->toggleViewAction(), SIGNAL(triggered(bool)), this, SLOT(onPlaylistDockTriggered(bool)));\n    connect(ui->actionPlaylist, SIGNAL(triggered()), this, SLOT(onPlaylistDockTriggered()));\n    connect(m_playlistDock, SIGNAL(clipOpened(Mlt::Producer*, bool)), this, SLOT(openCut(Mlt::Producer*, bool)));\n    connect(m_playlistDock, SIGNAL(itemActivated(int)), this, SLOT(seekPlaylist(int)));\n    connect(m_playlistDock, SIGNAL(showStatusMessage(QString)), this, SLOT(showStatusMessage(QString)));\n    connect(m_playlistDock->model(), SIGNAL(created()), this, SLOT(onPlaylistCreated()));\n    connect(m_playlistDock->model(), SIGNAL(cleared()), this, SLOT(onPlaylistCleared()));\n    connect(m_playlistDock->model(), SIGNAL(cleared()), this, SLOT(updateAutoSave()));\n    connect(m_playlistDock->model(), SIGNAL(closed()), this, SLOT(onPlaylistClosed()));\n    connect(m_playlistDock->model(), SIGNAL(modified()), this, SLOT(onPlaylistModified()));\n    connect(m_playlistDock->model(), SIGNAL(modified()), this, SLOT(updateAutoSave()));\n    connect(m_playlistDock->model(), SIGNAL(loaded()), this, SLOT(onPlaylistLoaded()));\n    connect(this, SIGNAL(producerOpened()), m_playlistDock, SLOT(onProducerOpened()));\n    if (!Settings.playerGPU())\n        connect(m_playlistDock->model(), SIGNAL(loaded()), this, SLOT(updateThumbnails()));\n    connect(m_player, &Player::inChanged, m_playlistDock, &PlaylistDock::onInChanged);\n    connect(m_player, &Player::outChanged, m_playlistDock, &PlaylistDock::onOutChanged);\n    connect(m_playlistDock->model(), &PlaylistModel::inChanged, this, &MainWindow::onPlaylistInChanged);\n    connect(m_playlistDock->model(), &PlaylistModel::outChanged, this, &MainWindow::onPlaylistOutChanged);\n\n    m_timelineDock = new TimelineDock(this);\n    m_timelineDock->hide();\n    addDockWidget(Qt::BottomDockWidgetArea, m_timelineDock);\n    m_timelineDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_5));\n    ui->menuView->addAction(m_timelineDock->toggleViewAction());\n    connect(m_timelineDock->toggleViewAction(), SIGNAL(triggered(bool)), this, SLOT(onTimelineDockTriggered(bool)));\n    connect(ui->actionTimeline, SIGNAL(triggered()), SLOT(onTimelineDockTriggered()));\n    connect(m_player, SIGNAL(seeked(int)), m_timelineDock, SLOT(onSeeked(int)));\n    connect(m_timelineDock, SIGNAL(seeked(int)), SLOT(seekTimeline(int)));\n    connect(m_timelineDock, SIGNAL(clipClicked()), SLOT(onTimelineClipSelected()));\n    connect(m_timelineDock, SIGNAL(showStatusMessage(QString)), this, SLOT(showStatusMessage(QString)));\n    connect(m_timelineDock->model(), SIGNAL(showStatusMessage(QString)), this, SLOT(showStatusMessage(QString)));\n    connect(m_timelineDock->model(), SIGNAL(created()), SLOT(onMultitrackCreated()));\n    connect(m_timelineDock->model(), SIGNAL(closed()), SLOT(onMultitrackClosed()));\n    connect(m_timelineDock->model(), SIGNAL(modified()), SLOT(onMultitrackModified()));\n    connect(m_timelineDock->model(), SIGNAL(modified()), SLOT(updateAutoSave()));\n    connect(m_timelineDock->model(), SIGNAL(durationChanged()), SLOT(onMultitrackDurationChanged()));\n    connect(m_timelineDock, SIGNAL(clipOpened(Mlt::Producer*)), SLOT(openCut(Mlt::Producer*)));\n    connect(m_timelineDock->model(), &MultitrackModel::seeked, this, &MainWindow::seekTimeline);\n    connect(m_timelineDock->model(), SIGNAL(scaleFactorChanged()), m_player, SLOT(pause()));\n    connect(m_timelineDock, SIGNAL(selected(Mlt::Producer*)), SLOT(loadProducerWidget(Mlt::Producer*)));\n    connect(m_timelineDock, SIGNAL(selectionChanged()), SLOT(onTimelineSelectionChanged()));\n    connect(m_timelineDock, SIGNAL(clipCopied()), SLOT(onClipCopied()));\n    connect(m_timelineDock, SIGNAL(filteredClicked()), SLOT(onFiltersDockTriggered()));\n    connect(m_playlistDock, SIGNAL(addAllTimeline(Mlt::Playlist*)), SLOT(onTimelineDockTriggered()));\n    connect(m_playlistDock, SIGNAL(addAllTimeline(Mlt::Playlist*, bool)), SLOT(onAddAllToTimeline(Mlt::Playlist*, bool)));\n    connect(m_player, SIGNAL(previousSought()), m_timelineDock, SLOT(seekPreviousEdit()));\n    connect(m_player, SIGNAL(nextSought()), m_timelineDock, SLOT(seekNextEdit()));\n\n    m_filterController = new FilterController(this);\n    m_filtersDock = new FiltersDock(m_filterController->metadataModel(), m_filterController->attachedModel(), this);\n    m_filtersDock->setMinimumSize(400, 300);\n    m_filtersDock->hide();\n    addDockWidget(Qt::LeftDockWidgetArea, m_filtersDock);\n    m_filtersDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_6));\n    ui->menuView->addAction(m_filtersDock->toggleViewAction());\n    connect(m_filtersDock, SIGNAL(currentFilterRequested(int)), m_filterController, SLOT(setCurrentFilter(int)), Qt::QueuedConnection);\n    connect(m_filtersDock->toggleViewAction(), SIGNAL(triggered(bool)), this, SLOT(onFiltersDockTriggered(bool)));\n    connect(ui->actionFilters, SIGNAL(triggered()), this, SLOT(onFiltersDockTriggered()));\n    connect(m_filterController, SIGNAL(currentFilterChanged(QmlFilter*, QmlMetadata*, int)), m_filtersDock, SLOT(setCurrentFilter(QmlFilter*, QmlMetadata*, int)));\n    connect(this, SIGNAL(producerOpened()), m_filterController, SLOT(setProducer()));\n    connect(m_filterController->attachedModel(), SIGNAL(changed()), SLOT(onFilterModelChanged()));\n    connect(m_filtersDock, SIGNAL(changed()), SLOT(onFilterModelChanged()));\n    connect(m_filterController, SIGNAL(filterChanged(Mlt::Filter*)),\n            m_timelineDock->model(), SLOT(onFilterChanged(Mlt::Filter*)));\n    connect(m_filterController->attachedModel(), SIGNAL(addedOrRemoved(Mlt::Producer*)),\n            m_timelineDock->model(), SLOT(filterAddedOrRemoved(Mlt::Producer*)));\n    connect(&QmlApplication::singleton(), SIGNAL(filtersPasted(Mlt::Producer*)),\n            m_timelineDock->model(), SLOT(filterAddedOrRemoved(Mlt::Producer*)));\n    connect(&QmlApplication::singleton(), &QmlApplication::filtersPasted,\n            this, &MainWindow::onProducerModified);\n    connect(m_filterController, SIGNAL(statusChanged(QString)), this, SLOT(showStatusMessage(QString)));\n    connect(m_timelineDock, SIGNAL(fadeInChanged(int)), m_filterController, SLOT(onFadeInChanged()));\n    connect(m_timelineDock, SIGNAL(fadeOutChanged(int)), m_filterController, SLOT(onFadeOutChanged()));\n    connect(m_timelineDock, SIGNAL(selected(Mlt::Producer*)), m_filterController, SLOT(setProducer(Mlt::Producer*)));\n    connect(m_player, SIGNAL(seeked(int)), m_filtersDock, SLOT(onSeeked(int)), Qt::QueuedConnection);\n    connect(m_filtersDock, SIGNAL(seeked(int)), SLOT(seekKeyframes(int)));\n    connect(MLT.videoWidget(), SIGNAL(frameDisplayed(const SharedFrame&)), m_filtersDock, SLOT(onShowFrame(const SharedFrame&)));\n    connect(m_player, SIGNAL(inChanged(int)), m_filtersDock, SIGNAL(producerInChanged(int)));\n    connect(m_player, SIGNAL(outChanged(int)), m_filtersDock, SIGNAL(producerOutChanged(int)));\n    connect(m_player, SIGNAL(inChanged(int)), m_filterController, SLOT(onFilterInChanged(int)));\n    connect(m_player, SIGNAL(outChanged(int)), m_filterController, SLOT(onFilterOutChanged(int)));\n    connect(m_timelineDock->model(), SIGNAL(filterInChanged(int, Mlt::Filter*)), m_filterController, SLOT(onFilterInChanged(int, Mlt::Filter*)));\n    connect(m_timelineDock->model(), SIGNAL(filterOutChanged(int, Mlt::Filter*)), m_filterController, SLOT(onFilterOutChanged(int, Mlt::Filter*)));\n\n    m_keyframesDock = new KeyframesDock(m_filtersDock->qmlProducer(), this);\n    m_keyframesDock->hide();\n    addDockWidget(Qt::BottomDockWidgetArea, m_keyframesDock);\n    m_keyframesDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_7));\n    ui->menuView->addAction(m_keyframesDock->toggleViewAction());\n    connect(m_keyframesDock->toggleViewAction(), SIGNAL(triggered(bool)), this, SLOT(onKeyframesDockTriggered(bool)));\n    connect(ui->actionKeyframes, SIGNAL(triggered()), this, SLOT(onKeyframesDockTriggered()));\n    connect(m_filterController, SIGNAL(currentFilterChanged(QmlFilter*, QmlMetadata*, int)), m_keyframesDock, SLOT(setCurrentFilter(QmlFilter*, QmlMetadata*)));\n    connect(m_keyframesDock, SIGNAL(visibilityChanged(bool)), m_filtersDock->qmlProducer(), SLOT(remakeAudioLevels(bool)));\n\n    m_historyDock = new QDockWidget(tr(\"History\"), this);\n    m_historyDock->hide();\n    m_historyDock->setObjectName(\"historyDock\");\n    m_historyDock->setWindowIcon(ui->actionHistory->icon());\n    m_historyDock->toggleViewAction()->setIcon(ui->actionHistory->icon());\n    m_historyDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_8));\n    m_historyDock->setMinimumWidth(150);\n    addDockWidget(Qt::RightDockWidgetArea, m_historyDock);\n    ui->menuView->addAction(m_historyDock->toggleViewAction());\n    connect(m_historyDock->toggleViewAction(), SIGNAL(triggered(bool)), this, SLOT(onHistoryDockTriggered(bool)));\n    connect(ui->actionHistory, SIGNAL(triggered()), this, SLOT(onHistoryDockTriggered()));\n    QUndoView* undoView = new QUndoView(m_undoStack, m_historyDock);\n    undoView->setObjectName(\"historyView\");\n    undoView->setAlternatingRowColors(true);\n    undoView->setSpacing(2);\n    m_historyDock->setWidget(undoView);\n    ui->actionUndo->setDisabled(true);\n    ui->actionRedo->setDisabled(true);\n\n    m_encodeDock = new EncodeDock(this);\n    m_encodeDock->hide();\n    addDockWidget(Qt::LeftDockWidgetArea, m_encodeDock);\n    m_encodeDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_9));\n    ui->menuView->addAction(m_encodeDock->toggleViewAction());\n    connect(this, SIGNAL(producerOpened()), m_encodeDock, SLOT(onProducerOpened()));\n    connect(ui->actionEncode, SIGNAL(triggered()), this, SLOT(onEncodeTriggered()));\n    connect(ui->actionExportVideo, SIGNAL(triggered()), this, SLOT(onEncodeTriggered()));\n    connect(m_encodeDock->toggleViewAction(), SIGNAL(triggered(bool)), this, SLOT(onEncodeTriggered(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), m_player, SLOT(onCaptureStateChanged(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), m_propertiesDock, SLOT(setDisabled(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), m_recentDock, SLOT(setDisabled(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), m_filtersDock, SLOT(setDisabled(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), m_keyframesDock, SLOT(setDisabled(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), ui->actionOpen, SLOT(setDisabled(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), ui->actionOpenOther, SLOT(setDisabled(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), ui->actionExit, SLOT(setDisabled(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), this, SLOT(onCaptureStateChanged(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), m_historyDock, SLOT(setDisabled(bool)));\n    connect(this, SIGNAL(profileChanged()), m_encodeDock, SLOT(onProfileChanged()));\n    connect(this, SIGNAL(profileChanged()), SLOT(onProfileChanged()));\n    connect(this, SIGNAL(profileChanged()), &QmlProfile::singleton(), SIGNAL(profileChanged()));\n    connect(this, SIGNAL(audioChannelsChanged()), m_encodeDock, SLOT(onAudioChannelsChanged()));\n    connect(m_playlistDock->model(), SIGNAL(modified()), m_encodeDock, SLOT(onProducerOpened()));\n    connect(m_timelineDock, SIGNAL(clipCopied()), m_encodeDock, SLOT(onProducerOpened()));\n    m_encodeDock->onProfileChanged();\n\n    m_jobsDock = new JobsDock(this);\n    m_jobsDock->hide();\n    addDockWidget(Qt::RightDockWidgetArea, m_jobsDock);\n    m_jobsDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_0));\n    ui->menuView->addAction(m_jobsDock->toggleViewAction());\n    connect(&JOBS, SIGNAL(jobAdded()), m_jobsDock, SLOT(onJobAdded()));\n    connect(m_jobsDock->toggleViewAction(), SIGNAL(triggered(bool)), this, SLOT(onJobsDockTriggered(bool)));\n    connect(ui->actionJobs, SIGNAL(triggered()), this, SLOT(onJobsDockTriggered()));\n\n    tabifyDockWidget(m_propertiesDock, m_playlistDock);\n    tabifyDockWidget(m_playlistDock, m_filtersDock);\n    tabifyDockWidget(m_filtersDock, m_encodeDock);\n    QDockWidget* audioWaveformDock = findChild<QDockWidget*>(\"AudioWaveformDock\");\n    splitDockWidget(m_recentDock, audioWaveformDock, Qt::Vertical);\n    splitDockWidget(audioMeterDock, m_recentDock, Qt::Horizontal);\n    tabifyDockWidget(m_recentDock, m_historyDock);\n    tabifyDockWidget(m_historyDock, m_jobsDock);\n    tabifyDockWidget(m_keyframesDock, m_timelineDock);\n    m_recentDock->raise();\n\n    // Configure the View menu.\n    ui->menuView->addSeparator();\n    ui->menuView->addAction(ui->actionApplicationLog);\n\n    // connect video widget signals\n    Mlt::GLWidget* videoWidget = (Mlt::GLWidget*) &(MLT);\n    connect(videoWidget, SIGNAL(dragStarted()), m_playlistDock, SLOT(onPlayerDragStarted()));\n    connect(videoWidget, SIGNAL(seekTo(int)), m_player, SLOT(seek(int)));\n    connect(videoWidget, SIGNAL(gpuNotSupported()), this, SLOT(onGpuNotSupported()));\n    connect(videoWidget->quickWindow(), SIGNAL(sceneGraphInitialized()), SLOT(onSceneGraphInitialized()), Qt::QueuedConnection);\n    connect(videoWidget, SIGNAL(frameDisplayed(const SharedFrame&)), m_scopeController, SIGNAL(newFrame(const SharedFrame&)));\n    connect(m_filterController, SIGNAL(currentFilterChanged(QmlFilter*, QmlMetadata*, int)), videoWidget, SLOT(setCurrentFilter(QmlFilter*, QmlMetadata*)));\n\n    readWindowSettings();\n    setCorner(Qt::TopLeftCorner, Qt::LeftDockWidgetArea);\n    setCorner(Qt::TopRightCorner, Qt::RightDockWidgetArea);\n    setCorner(Qt::BottomLeftCorner, Qt::BottomDockWidgetArea);\n    setCorner(Qt::BottomRightCorner, Qt::BottomDockWidgetArea);\n    setDockNestingEnabled(true);\n\n    setFocus();\n    setCurrentFile(\"\");\n\n    LeapNetworkListener* leap = new LeapNetworkListener(this);\n    connect(leap, SIGNAL(shuttle(float)), SLOT(onShuttle(float)));\n    connect(leap, SIGNAL(jogRightFrame()), SLOT(stepRightOneFrame()));\n    connect(leap, SIGNAL(jogRightSecond()), SLOT(stepRightOneSecond()));\n    connect(leap, SIGNAL(jogLeftFrame()), SLOT(stepLeftOneFrame()));\n    connect(leap, SIGNAL(jogLeftSecond()), SLOT(stepLeftOneSecond()));\n\n    connect(&m_network, SIGNAL(finished(QNetworkReply*)), SLOT(onUpgradeCheckFinished(QNetworkReply*)));\n\n    QThreadPool::globalInstance()->setMaxThreadCount(qMin(4, QThreadPool::globalInstance()->maxThreadCount()));\n\n    ProxyManager::removePending();\n\n    LOG_DEBUG() << \"end\";\n}\n\nvoid MainWindow::onFocusWindowChanged(QWindow *) const\n{\n    LOG_DEBUG() << \"Focuswindow changed\";\n    LOG_DEBUG() << \"Current focusWidget:\" << QApplication::focusWidget();\n    LOG_DEBUG() << \"Current focusObject:\" << QApplication::focusObject();\n    LOG_DEBUG() << \"Current focusWindow:\" << QApplication::focusWindow();\n}\n\nvoid MainWindow::onFocusObjectChanged(QObject *) const\n{\n    LOG_DEBUG() << \"Focusobject changed\";\n    LOG_DEBUG() << \"Current focusWidget:\" << QApplication::focusWidget();\n    LOG_DEBUG() << \"Current focusObject:\" << QApplication::focusObject();\n    LOG_DEBUG() << \"Current focusWindow:\" << QApplication::focusWindow();\n}\n\nvoid MainWindow::onTimelineClipSelected()\n{\n    // Synchronize navigation position with timeline selection.\n    TimelineDock * t = m_timelineDock;\n\n    if (t->selection().isEmpty())\n        return;\n\n    m_navigationPosition = t->centerOfClip(t->selection().first().y(), t->selection().first().x());\n\n    // Switch to Project player.\n    if (m_player->tabIndex() != Player::ProjectTabIndex) {\n        t->saveAndClearSelection();\n        m_player->onTabBarClicked(Player::ProjectTabIndex);\n    }\n}\n\nvoid MainWindow::onAddAllToTimeline(Mlt::Playlist* playlist, bool skipProxy)\n{\n    // We stop the player because of a bug on Windows that results in some\n    // strange memory leak when using Add All To Timeline, more noticeable\n    // with (high res?) still image files.\n    if (MLT.isSeekable())\n        m_player->pause();\n    else\n        m_player->stop();\n    m_timelineDock->appendFromPlaylist(playlist, skipProxy);\n}\n\nMainWindow& MainWindow::singleton()\n{\n    static MainWindow* instance = new MainWindow;\n    return *instance;\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n    Mlt::Controller::destroy();\n}\n\nvoid MainWindow::setupSettingsMenu()\n{\n    LOG_DEBUG() << \"begin\";\n    QActionGroup* group = new QActionGroup(this);\n    group->addAction(ui->actionChannels1);\n    group->addAction(ui->actionChannels2);\n    group->addAction(ui->actionChannels6);\n    group = new QActionGroup(this);\n    group->addAction(ui->actionOneField);\n    group->addAction(ui->actionLinearBlend);\n\n#if LIBMLT_VERSION_INT >= MLT_VERSION_PREVIEW_SCALE\n    m_previewScaleGroup = new QActionGroup(this);\n    m_previewScaleGroup->addAction(ui->actionPreviewNone);\n    m_previewScaleGroup->addAction(ui->actionPreview360);\n    m_previewScaleGroup->addAction(ui->actionPreview540);\n    m_previewScaleGroup->addAction(ui->actionPreview720);\n#else\n    delete ui->menuPreviewScaling;\n#endif\n\n    //XXX workaround yadif crashing with mlt_transition\n//    group->addAction(ui->actionYadifTemporal);\n//    group->addAction(ui->actionYadifSpatial);\n    ui->actionYadifTemporal->setVisible(false);\n    ui->actionYadifSpatial->setVisible(false);\n\n    group = new QActionGroup(this);\n    group->addAction(ui->actionNearest);\n    group->addAction(ui->actionBilinear);\n    group->addAction(ui->actionBicubic);\n    group->addAction(ui->actionHyper);\n    if (Settings.playerGPU()) {\n        group = new QActionGroup(this);\n        group->addAction(ui->actionGammaRec709);\n        group->addAction(ui->actionGammaSRGB);\n    } else {\n        delete ui->menuGamma;\n    }\n    m_profileGroup = new QActionGroup(this);\n    m_profileGroup->addAction(ui->actionProfileAutomatic);\n    ui->actionProfileAutomatic->setData(QString());\n    buildVideoModeMenu(ui->menuProfile, m_customProfileMenu, m_profileGroup, ui->actionAddCustomProfile, ui->actionProfileRemove);\n\n    // Add the SDI and HDMI devices to the Settings menu.\n    m_externalGroup = new QActionGroup(this);\n    ui->actionExternalNone->setData(QString());\n    m_externalGroup->addAction(ui->actionExternalNone);\n\n    QList<QScreen*> screens = QGuiApplication::screens();\n    int n = screens.size();\n    for (int i = 0; n > 1 && i < n; i++) {\n        QAction* action = new QAction(tr(\"Screen %1 (%2 x %3 @ %4 Hz)\").arg(i)\n            .arg(screens[i]->size().width() * screens[i]->devicePixelRatio())\n            .arg(screens[i]->size().height() * screens[i]->devicePixelRatio())\n            .arg(screens[i]->refreshRate()), this);\n        action->setCheckable(true);\n        action->setData(i);\n        m_externalGroup->addAction(action);\n    }\n\n    Mlt::Profile profile;\n    Mlt::Consumer decklink(profile, \"decklink:\");\n    if (decklink.is_valid()) {\n        decklink.set(\"list_devices\", 1);\n        int n = decklink.get_int(\"devices\");\n        for (int i = 0; i < n; ++i) {\n            QString device(decklink.get(QString(\"device.%1\").arg(i).toLatin1().constData()));\n            if (!device.isEmpty()) {\n                QAction* action = new QAction(device, this);\n                action->setCheckable(true);\n                action->setData(QString(\"decklink:%1\").arg(i));\n                m_externalGroup->addAction(action);\n\n                if (!m_keyerGroup) {\n                    m_keyerGroup = new QActionGroup(this);\n                    action = new QAction(tr(\"Off\"), m_keyerGroup);\n                    action->setData(QVariant(0));\n                    action->setCheckable(true);\n                    action = new QAction(tr(\"Internal\"), m_keyerGroup);\n                    action->setData(QVariant(1));\n                    action->setCheckable(true);\n                    action = new QAction(tr(\"External\"), m_keyerGroup);\n                    action->setData(QVariant(2));\n                    action->setCheckable(true);\n                }\n            }\n        }\n    }\n    if (m_externalGroup->actions().count() > 1)\n        ui->menuExternal->addActions(m_externalGroup->actions());\n    else {\n        delete ui->menuExternal;\n        ui->menuExternal = 0;\n    }\n    if (m_keyerGroup) {\n        m_keyerMenu = ui->menuExternal->addMenu(tr(\"DeckLink Keyer\"));\n        m_keyerMenu->addActions(m_keyerGroup->actions());\n        m_keyerMenu->setDisabled(true);\n        connect(m_keyerGroup, SIGNAL(triggered(QAction*)), this, SLOT(onKeyerTriggered(QAction*)));\n    }\n    connect(m_externalGroup, SIGNAL(triggered(QAction*)), this, SLOT(onExternalTriggered(QAction*)));\n    connect(m_profileGroup, SIGNAL(triggered(QAction*)), this, SLOT(onProfileTriggered(QAction*)));\n\n    // Setup the language menu actions\n    m_languagesGroup = new QActionGroup(this);\n    QAction* a;\n    a = new QAction(QLocale::languageToString(QLocale::Arabic), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"ar\");\n    a = new QAction(QLocale::languageToString(QLocale::Catalan), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"ca\");\n    a = new QAction(QLocale::languageToString(QLocale::Chinese).append(\" (China)\"), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"zh_CN\");\n    a = new QAction(QLocale::languageToString(QLocale::Chinese).append(\" (Taiwan)\"), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"zh_TW\");\n    a = new QAction(QLocale::languageToString(QLocale::Czech), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"cs\");\n    a = new QAction(QLocale::languageToString(QLocale::Danish), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"da\");\n    a = new QAction(QLocale::languageToString(QLocale::Dutch), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"nl\");\n    a = new QAction(QLocale::languageToString(QLocale::English).append(\" (Great Britain)\"), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"en_GB\");\n    a = new QAction(QLocale::languageToString(QLocale::English).append(\" (United States)\"), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"en_US\");\n    a = new QAction(QLocale::languageToString(QLocale::Estonian), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"et\");\n    a = new QAction(QLocale::languageToString(QLocale::Finnish), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"fi\");\n    a = new QAction(QLocale::languageToString(QLocale::French), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"fr\");\n    a = new QAction(QLocale::languageToString(QLocale::Gaelic), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"gd\");\n    a = new QAction(QLocale::languageToString(QLocale::Galician), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"gl\");\n    a = new QAction(QLocale::languageToString(QLocale::German), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"de\");\n    a = new QAction(QLocale::languageToString(QLocale::Greek), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"el\");\n    a = new QAction(QLocale::languageToString(QLocale::Hungarian), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"hu\");\n    a = new QAction(QLocale::languageToString(QLocale::Italian), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"it\");\n    a = new QAction(QLocale::languageToString(QLocale::Japanese), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"ja\");\n    a = new QAction(QLocale::languageToString(QLocale::Korean), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"ko\");\n    a = new QAction(QLocale::languageToString(QLocale::Nepali), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"ne\");\n    a = new QAction(QLocale::languageToString(QLocale::NorwegianBokmal), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"nb\");\n    a = new QAction(QLocale::languageToString(QLocale::NorwegianNynorsk), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"nn\");\n    a = new QAction(QLocale::languageToString(QLocale::Occitan), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"oc\");\n    a = new QAction(QLocale::languageToString(QLocale::Polish), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"pl\");\n    a = new QAction(QLocale::languageToString(QLocale::Portuguese).append(\" (Brazil)\"), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"pt_BR\");\n    a = new QAction(QLocale::languageToString(QLocale::Portuguese).append(\" (Portugal)\"), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"pt_PT\");\n    a = new QAction(QLocale::languageToString(QLocale::Russian), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"ru\");\n    a = new QAction(QLocale::languageToString(QLocale::Slovak), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"sk\");\n    a = new QAction(QLocale::languageToString(QLocale::Slovenian), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"sl\");\n    a = new QAction(QLocale::languageToString(QLocale::Spanish), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"es\");\n    a = new QAction(QLocale::languageToString(QLocale::Swedish), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"sv\");\n    a = new QAction(QLocale::languageToString(QLocale::Thai), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"th\");\n    a = new QAction(QLocale::languageToString(QLocale::Turkish), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"tr\");\n    a = new QAction(QLocale::languageToString(QLocale::Ukrainian), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"uk\");\n    ui->menuLanguage->addActions(m_languagesGroup->actions());\n    const QString locale = Settings.language();\n    foreach (QAction* action, m_languagesGroup->actions()) {\n        if (action->data().toString().startsWith(locale)) {\n            action->setChecked(true);\n            break;\n        }\n    }\n    connect(m_languagesGroup, SIGNAL(triggered(QAction*)), this, SLOT(onLanguageTriggered(QAction*)));\n\n    // Setup the themes actions\n    group = new QActionGroup(this);\n    group->addAction(ui->actionSystemTheme);\n    group->addAction(ui->actionFusionDark);\n    group->addAction(ui->actionFusionLight);\n    if (Settings.theme() == \"dark\")\n        ui->actionFusionDark->setChecked(true);\n    else if (Settings.theme() == \"light\")\n        ui->actionFusionLight->setChecked(true);\n    else\n        ui->actionSystemTheme->setChecked(true);\n\n#ifdef Q_OS_WIN\n    // On Windows, if there is no JACK or it is not running\n    // then Shotcut crashes inside MLT's call to jack_client_open().\n    // Therefore, the JACK option for Shotcut is banned on Windows.\n    delete ui->actionJack;\n    ui->actionJack = 0;\n#endif\n#if !defined(Q_OS_MAC)\n    // Setup the display method actions.\n    if (!Settings.playerGPU()) {\n        group = new QActionGroup(this);\n#if defined(Q_OS_WIN)\n        ui->actionDrawingAutomatic->setData(0);\n        group->addAction(ui->actionDrawingAutomatic);\n        ui->actionDrawingDirectX->setData(Qt::AA_UseOpenGLES);\n        group->addAction(ui->actionDrawingDirectX);\n#else\n        delete ui->actionDrawingAutomatic;\n        delete ui->actionDrawingDirectX;\n#endif\n        ui->actionDrawingOpenGL->setData(Qt::AA_UseDesktopOpenGL);\n        group->addAction(ui->actionDrawingOpenGL);\n        ui->actionDrawingSoftware->setData(Qt::AA_UseSoftwareOpenGL);\n        group->addAction(ui->actionDrawingSoftware);\n        connect(group, SIGNAL(triggered(QAction*)), this, SLOT(onDrawingMethodTriggered(QAction*)));\n        switch (Settings.drawMethod()) {\n        case Qt::AA_UseDesktopOpenGL:\n            ui->actionDrawingOpenGL->setChecked(true);\n            break;\n#if defined(Q_OS_WIN)\n        case Qt::AA_UseOpenGLES:\n            ui->actionDrawingDirectX->setChecked(true);\n            break;\n#endif\n        case Qt::AA_UseSoftwareOpenGL:\n            ui->actionDrawingSoftware->setChecked(true);\n            break;\n#if defined(Q_OS_WIN)\n        default:\n            ui->actionDrawingAutomatic->setChecked(true);\n            break;\n#else\n        default:\n            ui->actionDrawingOpenGL->setChecked(true);\n            break;\n#endif\n        }\n    } else {\n        // GPU mode only works with OpenGL.\n        delete ui->menuDrawingMethod;\n        ui->menuDrawingMethod = 0;\n    }\n#else  // Q_OS_MAC\n    delete ui->menuDrawingMethod;\n    ui->menuDrawingMethod = 0;\n#endif\n\n    // Add custom layouts to View > Layout submenu.\n    m_layoutGroup = new QActionGroup(this);\n    connect(m_layoutGroup, SIGNAL(triggered(QAction*)), SLOT(onLayoutTriggered(QAction*)));\n    if (Settings.layouts().size() > 0) {\n        ui->menuLayout->addAction(ui->actionLayoutRemove);\n        ui->menuLayout->addSeparator();\n    }\n    foreach (QString name, Settings.layouts())\n        ui->menuLayout->addAction(addLayout(m_layoutGroup, name));\n\n    if (qApp->property(\"clearRecent\").toBool()) {\n        ui->actionClearRecentOnExit->setVisible(false);\n        Settings.setRecent(QStringList());\n        Settings.setClearRecent(true);\n    } else {\n        ui->actionClearRecentOnExit->setChecked(Settings.clearRecent());\n    }\n\n\n    // Initialze the proxy submenu\n    ui->actionUseProxy->setChecked(Settings.proxyEnabled());\n    ui->actionProxyUseProjectFolder->setChecked(Settings.proxyUseProjectFolder());\n    ui->actionProxyUseHardware->setChecked(Settings.proxyUseHardware());\n\n    LOG_DEBUG() << \"end\";\n}\n\nvoid MainWindow::setupOpenOtherMenu()\n{\n    // Open Other toolbar menu button\n    QScopedPointer<Mlt::Properties> mltProducers(MLT.repository()->producers());\n    QScopedPointer<Mlt::Properties> mltFilters(MLT.repository()->filters());\n    QMenu* otherMenu = new QMenu(this);\n    ui->actionOpenOther2->setMenu(otherMenu);\n\n    // populate the generators\n    if (mltProducers->get_data(\"color\")) {\n        otherMenu->addAction(tr(\"Color\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"color\");\n        if (!Settings.playerGPU() && mltProducers->get_data(\"qtext\") && mltFilters->get_data(\"dynamictext\"))\n            otherMenu->addAction(tr(\"Text\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"text\");\n    }\n    if (mltProducers->get_data(\"noise\"))\n        otherMenu->addAction(tr(\"Noise\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"noise\");\n    if (mltProducers->get_data(\"frei0r.ising0r\"))\n        otherMenu->addAction(tr(\"Ising\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"ising0r\");\n    if (mltProducers->get_data(\"frei0r.lissajous0r\"))\n        otherMenu->addAction(tr(\"Lissajous\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"lissajous0r\");\n    if (mltProducers->get_data(\"frei0r.plasma\"))\n        otherMenu->addAction(tr(\"Plasma\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"plasma\");\n    if (mltProducers->get_data(\"frei0r.test_pat_B\"))\n        otherMenu->addAction(tr(\"Color Bars\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"test_pat_B\");\n    if (mltProducers->get_data(\"tone\"))\n        otherMenu->addAction(tr(\"Audio Tone\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"tone\");\n    if (mltProducers->get_data(\"count\"))\n        otherMenu->addAction(tr(\"Count\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"count\");\n    if (mltProducers->get_data(\"blipflash\"))\n        otherMenu->addAction(tr(\"Blip Flash\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"blipflash\");\n\n#if defined(Q_OS_UNIX) && !defined(Q_OS_MAC)\n    otherMenu->addAction(tr(\"Video4Linux\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"v4l2\");\n    otherMenu->addAction(tr(\"PulseAudio\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"pulse\");\n    otherMenu->addAction(tr(\"JACK Audio\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"jack\");\n    otherMenu->addAction(tr(\"ALSA Audio\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"alsa\");\n#elif defined(Q_OS_WIN) || defined(Q_OS_MAC)\n    otherMenu->addAction(tr(\"Audio/Video Device\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"device\");\n#endif\n    if (mltProducers->get_data(\"decklink\"))\n        otherMenu->addAction(tr(\"SDI/HDMI\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"decklink\");\n}\n\nQAction* MainWindow::addProfile(QActionGroup* actionGroup, const QString& desc, const QString& name)\n{\n    QAction* action = new QAction(desc, this);\n    action->setCheckable(true);\n    action->setData(name);\n    actionGroup->addAction(action);\n    return action;\n}\n\nQAction*MainWindow::addLayout(QActionGroup* actionGroup, const QString& name)\n{\n    QAction* action = new QAction(name, this);\n    actionGroup->addAction(action);\n    return action;\n}\n\nvoid MainWindow::open(Mlt::Producer* producer)\n{\n    if (!producer->is_valid())\n        showStatusMessage(tr(\"Failed to open \"));\n    else if (producer->get_int(\"error\"))\n        showStatusMessage(tr(\"Failed to open \") + producer->get(\"resource\"));\n\n    bool ok = false;\n    int screen = Settings.playerExternal().toInt(&ok);\n    if (ok && screen != QApplication::desktop()->screenNumber(this))\n        m_player->moveVideoToScreen(screen);\n\n    // no else here because open() will delete the producer if open fails\n    if (!MLT.setProducer(producer)) {\n        emit producerOpened();\n        if (!MLT.profile().is_explicit() || MLT.URL().endsWith(\".mlt\") || MLT.URL().endsWith(\".xml\"))\n            emit profileChanged();\n    }\n    m_player->setFocus();\n    m_playlistDock->setUpdateButtonEnabled(false);\n\n    // Needed on Windows. Upon first file open, window is deactivated, perhaps OpenGL-related.\n    activateWindow();\n}\n\nbool MainWindow::isCompatibleWithGpuMode(MltXmlChecker& checker)\n{\n    if (checker.needsGPU() && !Settings.playerGPU() && Settings.playerWarnGPU()) {\n        LOG_INFO() << \"file uses GPU but GPU not enabled\";\n        QMessageBox dialog(QMessageBox::Warning,\n           qApp->applicationName(),\n           tr(\"The file you opened uses GPU effects, but GPU effects are not enabled.\\n\\n\"\n              \"GPU effects are EXPERIMENTAL, UNSTABLE and UNSUPPORTED! Unsupported means do not report bugs about it.\\n\\n\"\n              \"Do you want to enable GPU effects and restart?\"),\n           QMessageBox::No |\n           QMessageBox::Yes,\n           this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        int r = dialog.exec();\n        if (r == QMessageBox::Yes) {\n            ui->actionGPU->setChecked(true);\n            m_exitCode = EXIT_RESTART;\n            QApplication::closeAllWindows();\n        }\n        return false;\n    }\n    else if (checker.needsCPU() && Settings.playerGPU()) {\n        LOG_INFO() << \"file uses GPU incompatible filters but GPU is enabled\";\n        QMessageBox dialog(QMessageBox::Question,\n           qApp->applicationName(),\n           tr(\"The file you opened uses CPU effects that are incompatible with GPU effects, but GPU effects are enabled.\\n\"\n              \"Do you want to disable GPU effects and restart?\"),\n           QMessageBox::No |\n           QMessageBox::Yes,\n           this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        int r = dialog.exec();\n        if (r == QMessageBox::Yes) {\n            ui->actionGPU->setChecked(false);\n            m_exitCode = EXIT_RESTART;\n            QApplication::closeAllWindows();\n        }\n        return false;\n    }\n    return true;\n}\n\nbool MainWindow::saveRepairedXmlFile(MltXmlChecker& checker, QString& fileName)\n{\n    QFileInfo fi(fileName);\n    QFile repaired(QString(\"%1/%2 - %3.%4\").arg(fi.path())\n        .arg(fi.completeBaseName()).arg(tr(\"Repaired\")).arg(fi.suffix()));\n    repaired.open(QIODevice::WriteOnly);\n    LOG_INFO() << \"repaired MLT XML file name\" << repaired.fileName();\n    QFile temp(checker.tempFileName());\n    if (temp.exists() && repaired.exists()) {\n        temp.open(QIODevice::ReadOnly);\n        QByteArray xml = temp.readAll();\n        temp.close();\n\n        qint64 n = repaired.write(xml);\n        while (n > 0 && n < xml.size()) {\n            qint64 x = repaired.write(xml.right(xml.size() - n));\n            if (x > 0)\n                n += x;\n            else\n                n = x;\n        }\n        repaired.close();\n        if (n == xml.size()) {\n            fileName = repaired.fileName();\n            return true;\n        }\n    }\n    QMessageBox::warning(this, qApp->applicationName(), tr(\"Repairing the project failed.\"));\n    LOG_WARNING() << \"repairing failed\";\n    return false;\n}\n\nbool MainWindow::isXmlRepaired(MltXmlChecker& checker, QString& fileName)\n{\n    bool result = true;\n    if (checker.isCorrected()) {\n        LOG_WARNING() << fileName;\n        QMessageBox dialog(QMessageBox::Question,\n           qApp->applicationName(),\n           tr(\"Shotcut noticed some problems in your project.\\n\"\n              \"Do you want Shotcut to try to repair it?\\n\\n\"\n              \"If you choose Yes, Shotcut will create a copy of your project\\n\"\n              \"with \\\"- Repaired\\\" in the file name and open it.\"),\n           QMessageBox::No |\n           QMessageBox::Yes,\n           this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        int r = dialog.exec();\n        if (r == QMessageBox::Yes)\n            result = saveRepairedXmlFile(checker, fileName);\n    }\n    else if (checker.unlinkedFilesModel().rowCount() > 0) {\n        UnlinkedFilesDialog dialog(this);\n        dialog.setModel(checker.unlinkedFilesModel());\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        if (dialog.exec() == QDialog::Accepted) {\n            if (checker.check(fileName) && checker.isCorrected())\n                result = saveRepairedXmlFile(checker, fileName);\n        } else {\n            result = false;\n        }\n    }\n    return result;\n}\n\nbool MainWindow::checkAutoSave(QString &url)\n{\n    QMutexLocker locker(&m_autosaveMutex);\n\n    // check whether autosave files exist:\n    QSharedPointer<AutoSaveFile> stale(AutoSaveFile::getFile(url));\n    if (stale) {\n        QMessageBox dialog(QMessageBox::Question, qApp->applicationName(),\n           tr(\"Auto-saved files exist. Do you want to recover them now?\"),\n           QMessageBox::No | QMessageBox::Yes, this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        int r = dialog.exec();\n        if (r == QMessageBox::Yes) {\n            if (!stale->open(QIODevice::ReadWrite)) {\n                LOG_WARNING() << \"failed to recover autosave file\" << url;\n            } else {\n                m_autosaveFile = stale;\n                url = stale->fileName();\n                return true;\n            }\n        }\n    }\n\n    // create new autosave object\n    m_autosaveFile.reset(new AutoSaveFile(url));\n\n    return false;\n}\n\nvoid MainWindow::stepLeftBySeconds(int sec)\n{\n    m_player->seek(m_player->position() + sec * qRound(MLT.profile().fps()));\n}\n\nvoid MainWindow::doAutosave()\n{\n    QMutexLocker locker(&m_autosaveMutex);\n    if (m_autosaveFile) {\n        bool success = false;\n        if (m_autosaveFile->isOpen() || m_autosaveFile->open(QIODevice::ReadWrite)) {\n            m_autosaveFile->close();\n            success = saveXML(m_autosaveFile->fileName(), false /* without relative paths */);\n            m_autosaveFile->open(QIODevice::ReadWrite);\n        }\n        if (!success) {\n            LOG_ERROR() << \"failed to open autosave file for writing\" << m_autosaveFile->fileName();\n        }\n    }\n}\n\nvoid MainWindow::setFullScreen(bool isFullScreen)\n{\n    if (isFullScreen) {\n#ifdef Q_OS_WIN\n        showMaximized();\n#else\n        showFullScreen();\n#endif\n        ui->actionEnter_Full_Screen->setVisible(false);\n        ui->actionFullscreen->setVisible(false);\n    }\n}\n\nQString MainWindow::untitledFileName() const\n{\n    QDir dir = Settings.appDataLocation();\n    if (!dir.exists()) dir.mkpath(dir.path());\n    return dir.filePath(\"__untitled__.mlt\");\n}\n\nvoid MainWindow::setProfile(const QString &profile_name)\n{\n    LOG_DEBUG() << profile_name;\n    MLT.setProfile(profile_name);\n    emit profileChanged();\n}\n\nbool MainWindow::isSourceClipMyProject(QString resource)\n{\n    if (m_player->tabIndex() == Player::ProjectTabIndex && MLT.savedProducer() && MLT.savedProducer()->is_valid())\n        resource = QString::fromUtf8(MLT.savedProducer()->get(\"resource\"));\n    if (!resource.isEmpty() && QDir(resource) == QDir(fileName())) {\n        QMessageBox dialog(QMessageBox::Information,\n                           qApp->applicationName(),\n                           tr(\"You cannot add a project to itself!\"),\n                           QMessageBox::Ok,\n                           this);\n        dialog.setDefaultButton(QMessageBox::Ok);\n        dialog.setEscapeButton(QMessageBox::Ok);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.exec();\n        return true;\n    }\n    return false;\n}\n\nbool MainWindow::keyframesDockIsVisible() const\n{\n    return m_keyframesDock && m_keyframesDock->isVisible();\n}\n\nvoid MainWindow::setAudioChannels(int channels)\n{\n    LOG_DEBUG() << channels;\n    MLT.videoWidget()->setProperty(\"audio_channels\", channels);\n    MLT.setAudioChannels(channels);\n    if (channels == 1)\n        ui->actionChannels1->setChecked(true);\n    else if (channels == 2)\n        ui->actionChannels2->setChecked(true);\n    else if (channels == 6)\n        ui->actionChannels6->setChecked(true);\n    emit audioChannelsChanged();\n}\n\nvoid MainWindow::showSaveError()\n{\n    QMessageBox dialog(QMessageBox::Critical,\n                       qApp->applicationName(),\n                       tr(\"There was an error saving. Please try again.\"),\n                       QMessageBox::Ok,\n                       this);\n    dialog.setDefaultButton(QMessageBox::Ok);\n    dialog.setEscapeButton(QMessageBox::Ok);\n    dialog.setWindowModality(QmlApplication::dialogModality());\n    dialog.exec();\n}\n\nvoid MainWindow::setPreviewScale(int scale)\n{\n    LOG_DEBUG() << scale;\n    switch (scale) {\n    case 360:\n        ui->actionPreview360->setChecked(true);\n        break;\n    case 540:\n        ui->actionPreview540->setChecked(true);\n        break;\n    case 720:\n        ui->actionPreview720->setChecked(true);\n        break;\n    default:\n        ui->actionPreviewNone->setChecked(true);\n        break;\n    }\n    MLT.setPreviewScale(scale);\n    MLT.refreshConsumer();\n}\n\nvoid MainWindow::setVideoModeMenu()\n{\n    // Find a matching video mode\n    for (const auto action : m_profileGroup->actions()) {\n        auto s = action->data().toString();\n        Mlt::Profile profile(s.toUtf8().constData());\n        if (MLT.profile().width() == profile.width() &&\n                MLT.profile().height() == profile.height() &&\n                MLT.profile().sample_aspect_num() == profile.sample_aspect_num() &&\n                MLT.profile().sample_aspect_den() == profile.sample_aspect_den() &&\n                MLT.profile().frame_rate_num() == profile.frame_rate_num() &&\n                MLT.profile().frame_rate_den() == profile.frame_rate_den() &&\n                MLT.profile().colorspace() == profile.colorspace() &&\n                MLT.profile().progressive() == profile.progressive()) {\n            // Select it\n            action->setChecked(true);\n            return;\n        }\n    }\n    // Choose Automatic if nothing found\n    m_profileGroup->actions().first()->setChecked(true);\n}\n\nvoid MainWindow::resetVideoModeMenu()\n{\n    // Change selected Video Mode back to Settings\n    for (const auto action : m_profileGroup->actions()) {\n        if (action->data().toString() == Settings.playerProfile()) {\n            action->setChecked(true);\n            break;\n        }\n    }\n}\n\nstatic void autosaveTask(MainWindow* p)\n{\n    LOG_DEBUG_TIME();\n    p->doAutosave();\n}\n\nvoid MainWindow::onAutosaveTimeout()\n{\n    if (isWindowModified())\n        QtConcurrent::run(autosaveTask, this);\n}\n\nvoid MainWindow::updateAutoSave()\n{\n    if (!m_autosaveTimer.isActive())\n        m_autosaveTimer.start();\n}\n\nvoid MainWindow::open(QString url, const Mlt::Properties* properties, bool play)\n{\n    LOG_DEBUG() << url;\n    bool modified = false;\n    MltXmlChecker checker;\n    QFileInfo info(url);\n\n    if (info.isRelative()) {\n        QDir pwd(QDir::currentPath());\n        url = pwd.filePath(url);\n    }\n    if (url.endsWith(\".mlt\") || url.endsWith(\".xml\")) {\n        if (url != untitledFileName()) {\n            showStatusMessage(tr(\"Opening %1\").arg(url));\n            QCoreApplication::processEvents();\n        }\n    }\n    if (checker.check(url)) {\n        if (!isCompatibleWithGpuMode(checker))\n            return;\n    }\n    if (url.endsWith(\".mlt\") || url.endsWith(\".xml\")) {\n        // only check for a modified project when loading a project, not a simple producer\n        if (!continueModified())\n            return;\n        QCoreApplication::processEvents();\n        // close existing project\n        if (playlist())\n            m_playlistDock->model()->close();\n        if (multitrack())\n            m_timelineDock->model()->close();\n        MLT.purgeMemoryPool();\n        if (!isXmlRepaired(checker, url))\n            return;\n        modified = checkAutoSave(url);\n        if (modified) {\n            if (checker.check(url)) {\n                if (!isCompatibleWithGpuMode(checker))\n                    return;\n            }\n            if (!isXmlRepaired(checker, url))\n                return;\n        }\n        // let the new project change the profile\n        if (modified || QFile::exists(url)) {\n            MLT.profile().set_explicit(false);\n            setWindowModified(modified);\n        }\n    }\n    if (!playlist() && !multitrack()) {\n        if (!modified && !continueModified())\n            return;\n        setCurrentFile(\"\");\n        setWindowModified(modified);\n        MLT.resetURL();\n        // Return to automatic video mode if selected.\n        if (m_profileGroup->checkedAction() && m_profileGroup->checkedAction()->data().toString().isEmpty())\n            MLT.profile().set_explicit(false);\n    }\n    if (url.endsWith(\".mlt\") || url.endsWith(\".xml\")) {\n        checker.setLocale();\n        LOG_INFO() << \"decimal point\" << MLT.decimalPoint();\n    }\n    QString urlToOpen = checker.isUpdated()? checker.tempFileName() : url;\n    if (!MLT.open(QDir::fromNativeSeparators(urlToOpen), QDir::fromNativeSeparators(url))\n            && MLT.producer() && MLT.producer()->is_valid()) {\n        Mlt::Properties* props = const_cast<Mlt::Properties*>(properties);\n        if (props && props->is_valid())\n            mlt_properties_inherit(MLT.producer()->get_properties(), props->get_properties());\n        m_player->setPauseAfterOpen(!play || !MLT.isClip());\n\n        setAudioChannels(MLT.audioChannels());\n        if (url.endsWith(\".mlt\") || url.endsWith(\".xml\")) {\n            setVideoModeMenu();\n        }\n\n        open(MLT.producer());\n        if (url.startsWith(AutoSaveFile::path())) {\n            QMutexLocker locker(&m_autosaveMutex);\n            if (m_autosaveFile && m_autosaveFile->managedFileName() != untitledFileName()) {\n                m_recentDock->add(m_autosaveFile->managedFileName());\n                LOG_INFO() << m_autosaveFile->managedFileName();\n            }\n        } else {\n            m_recentDock->add(url);\n            LOG_INFO() << url;\n        }\n    }\n    else if (url != untitledFileName()) {\n        showStatusMessage(tr(\"Failed to open \") + url);\n        emit openFailed(url);\n    }\n}\n\nvoid MainWindow::openMultiple(const QStringList& paths)\n{\n    if (paths.size() > 1) {\n        QList<QUrl> urls;\n        foreach (const QString& s, paths)\n            urls << s;\n        openMultiple(urls);\n    } else if (!paths.isEmpty()) {\n        open(paths.first());\n    }\n}\n\nvoid MainWindow::openMultiple(const QList<QUrl>& urls)\n{\n    if (urls.size() > 1) {\n        m_multipleFiles = Util::sortedFileList(Util::expandDirectories(urls));\n        open(m_multipleFiles.first());\n    } else {\n        QUrl url = urls.first();\n        open(Util::removeFileScheme(url));\n    }\n}\n\nvoid MainWindow::openVideo()\n{\n    QString path = Settings.openPath();\n#ifdef Q_OS_MAC\n    path.append(\"/*\");\n#endif\n    QStringList filenames = QFileDialog::getOpenFileNames(this, tr(\"Open File\"), path,\n        tr(\"All Files (*);;MLT XML (*.mlt)\"));\n\n    if (filenames.length() > 0) {\n        Settings.setOpenPath(QFileInfo(filenames.first()).path());\n        activateWindow();\n        if (filenames.length() > 1)\n            m_multipleFiles = filenames;\n        open(filenames.first());\n    }\n    else {\n        // If file invalid, then on some platforms the dialog messes up SDL.\n        MLT.onWindowResize();\n        activateWindow();\n    }\n}\n\nvoid MainWindow::openCut(Mlt::Producer* producer, bool play)\n{\n    m_player->setPauseAfterOpen(!play);\n    open(producer);\n    MLT.seek(producer->get_in());\n}\n\nvoid MainWindow::hideProducer()\n{\n    // This is a hack to release references to the old producer, but it\n    // probably leaves a reference to the new color producer somewhere not\n    // yet identified (root cause).\n    openCut(new Mlt::Producer(MLT.profile(), \"color:_hide\"));\n    QCoreApplication::processEvents();\n    openCut(new Mlt::Producer(MLT.profile(), \"color:_hide\"));\n    QCoreApplication::processEvents();\n\n    QScrollArea* scrollArea = (QScrollArea*) m_propertiesDock->widget();\n    delete scrollArea->widget();\n    scrollArea->setWidget(nullptr);\n    m_player->reset();\n\n    QCoreApplication::processEvents();\n}\n\nvoid MainWindow::closeProducer()\n{\n    hideProducer();\n    MLT.stop();\n    MLT.close();\n    MLT.setSavedProducer(0);\n}\n\nvoid MainWindow::showStatusMessage(QAction* action, int timeoutSeconds)\n{\n    // This object takes ownership of the passed action.\n    // This version does not currently log its message.\n    m_statusBarAction.reset(action);\n    action->setParent(0);\n    m_player->setStatusLabel(action->text(), timeoutSeconds, action);\n}\n\nvoid MainWindow::showStatusMessage(const QString& message, int timeoutSeconds)\n{\n    LOG_INFO() << message;\n    m_player->setStatusLabel(message, timeoutSeconds, 0 /* QAction */);\n    m_statusBarAction.reset();\n}\n\nvoid MainWindow::seekPlaylist(int start)\n{\n    if (!playlist()) return;\n    // we bypass this->open() to prevent sending producerOpened signal to self, which causes to reload playlist\n    if (!MLT.producer() || (void*) MLT.producer()->get_producer() != (void*) playlist()->get_playlist())\n        MLT.setProducer(new Mlt::Producer(*playlist()));\n    m_player->setIn(-1);\n    m_player->setOut(-1);\n    // since we do not emit producerOpened, these components need updating\n    on_actionJack_triggered(ui->actionJack && ui->actionJack->isChecked());\n    m_player->onProducerOpened(false);\n    m_encodeDock->onProducerOpened();\n    m_filterController->setProducer();\n    updateMarkers();\n    MLT.seek(start);\n    m_player->setFocus();\n    m_player->switchToTab(Player::ProjectTabIndex);\n}\n\nvoid MainWindow::seekTimeline(int position, bool seekPlayer)\n{\n    if (!multitrack()) return;\n    // we bypass this->open() to prevent sending producerOpened signal to self, which causes to reload playlist\n    if (MLT.producer() && (void*) MLT.producer()->get_producer() != (void*) multitrack()->get_producer()) {\n        MLT.setProducer(new Mlt::Producer(*multitrack()));\n        m_player->setIn(-1);\n        m_player->setOut(-1);\n        // since we do not emit producerOpened, these components need updating\n        on_actionJack_triggered(ui->actionJack && ui->actionJack->isChecked());\n        m_player->onProducerOpened(false);\n        m_encodeDock->onProducerOpened();\n        m_filterController->setProducer();\n        updateMarkers();\n        m_player->setFocus();\n        m_player->switchToTab(Player::ProjectTabIndex);\n        m_timelineDock->emitSelectedFromSelection();\n    }\n    if (seekPlayer)\n        m_player->seek(position);\n    else\n        m_player->pause();\n}\n\nvoid MainWindow::seekKeyframes(int position)\n{\n    m_player->seek(position);\n}\n\nvoid MainWindow::readPlayerSettings()\n{\n    LOG_DEBUG() << \"begin\";\n    ui->actionRealtime->setChecked(Settings.playerRealtime());\n    ui->actionProgressive->setChecked(Settings.playerProgressive());\n    ui->actionScrubAudio->setChecked(Settings.playerScrubAudio());\n    if (ui->actionJack)\n        ui->actionJack->setChecked(Settings.playerJACK());\n    if (ui->actionGPU) {\n        MLT.videoWidget()->setProperty(\"gpu\", ui->actionGPU->isChecked());\n        ui->actionGPU->setChecked(Settings.playerGPU());\n    }\n\n    QString external = Settings.playerExternal();\n    bool ok = false;\n    external.toInt(&ok);\n    auto isExternalPeripheral = !external.isEmpty() && !ok;\n\n    setAudioChannels(Settings.playerAudioChannels());\n\n#if LIBMLT_VERSION_INT >= MLT_VERSION_PREVIEW_SCALE\n    if (isExternalPeripheral) {\n        setPreviewScale(0);\n        m_previewScaleGroup->setEnabled(false);\n    } else {\n        setPreviewScale(Settings.playerPreviewScale());\n        m_previewScaleGroup->setEnabled(true);\n    }\n#endif\n\n    QString deinterlacer = Settings.playerDeinterlacer();\n    QString interpolation = Settings.playerInterpolation();\n\n    if (deinterlacer == \"onefield\")\n        ui->actionOneField->setChecked(true);\n    else if (deinterlacer == \"linearblend\")\n        ui->actionLinearBlend->setChecked(true);\n    else if (deinterlacer == \"yadif-nospatial\")\n        ui->actionYadifTemporal->setChecked(true);\n    else\n        ui->actionYadifSpatial->setChecked(true);\n\n    if (interpolation == \"nearest\")\n        ui->actionNearest->setChecked(true);\n    else if (interpolation == \"bilinear\")\n        ui->actionBilinear->setChecked(true);\n    else if (interpolation == \"bicubic\")\n        ui->actionBicubic->setChecked(true);\n    else\n        ui->actionHyper->setChecked(true);\n\n    foreach (QAction* a, m_externalGroup->actions()) {\n        if (a->data() == external) {\n            a->setChecked(true);\n            if (a->data().toString().startsWith(\"decklink\") && m_keyerMenu)\n                m_keyerMenu->setEnabled(true);\n            break;\n        }\n    }\n\n    if (m_keyerGroup) {\n        int keyer = Settings.playerKeyerMode();\n        foreach (QAction* a, m_keyerGroup->actions()) {\n            if (a->data() == keyer) {\n                a->setChecked(true);\n                break;\n            }\n        }\n    }\n\n    QString profile = Settings.playerProfile();\n    // Automatic not permitted for SDI/HDMI\n    if (isExternalPeripheral && profile.isEmpty())\n        profile = \"atsc_720p_50\";\n    foreach (QAction* a, m_profileGroup->actions()) {\n        // Automatic not permitted for SDI/HDMI\n        if (a->data().toString().isEmpty() && !external.isEmpty() && !ok)\n            a->setDisabled(true);\n        if (a->data().toString() == profile) {\n            a->setChecked(true);\n            break;\n        }\n    }\n\n    QString gamma = Settings.playerGamma();\n    if (gamma == \"bt709\")\n        ui->actionGammaRec709->setChecked(true);\n    else\n        ui->actionGammaSRGB->setChecked(true);\n\n    LOG_DEBUG() << \"end\";\n}\n\nvoid MainWindow::readWindowSettings()\n{\n    LOG_DEBUG() << \"begin\";\n    Settings.setWindowGeometryDefault(saveGeometry());\n    Settings.setWindowStateDefault(saveState());\n    Settings.sync();\n    if (!Settings.windowGeometry().isEmpty()) {\n        restoreGeometry(Settings.windowGeometry());\n        restoreState(Settings.windowState());\n#ifdef Q_OS_MAC\n        m_filtersDock->setFloating(false);\n#endif\n    } else {\n        on_actionLayoutTimeline_triggered();\n    }\n    LOG_DEBUG() << \"end\";\n}\n\nvoid MainWindow::writeSettings()\n{\n#ifndef Q_OS_MAC\n    if (isFullScreen())\n        showNormal();\n#endif\n    Settings.setPlayerGPU(ui->actionGPU->isChecked());\n    Settings.setWindowGeometry(saveGeometry());\n    Settings.setWindowState(saveState());\n    Settings.sync();\n}\n\nvoid MainWindow::configureVideoWidget()\n{\n    LOG_DEBUG() << \"begin\";\n    if (m_profileGroup->checkedAction())\n        setProfile(m_profileGroup->checkedAction()->data().toString());\n    MLT.videoWidget()->setProperty(\"realtime\", ui->actionRealtime->isChecked());\n    bool ok = false;\n    m_externalGroup->checkedAction()->data().toInt(&ok);\n    if (!ui->menuExternal || m_externalGroup->checkedAction()->data().toString().isEmpty() || ok) {\n        MLT.videoWidget()->setProperty(\"progressive\", ui->actionProgressive->isChecked());\n    } else {\n        MLT.videoWidget()->setProperty(\"mlt_service\", m_externalGroup->checkedAction()->data());\n        MLT.videoWidget()->setProperty(\"progressive\", MLT.profile().progressive());\n        ui->actionProgressive->setEnabled(false);\n    }\n    if (ui->actionChannels1->isChecked())\n        setAudioChannels(1);\n    else if (ui->actionChannels2->isChecked())\n        setAudioChannels(2);\n    else\n        setAudioChannels(6);\n    if (ui->actionOneField->isChecked())\n        MLT.videoWidget()->setProperty(\"deinterlace_method\", \"onefield\");\n    else if (ui->actionLinearBlend->isChecked())\n        MLT.videoWidget()->setProperty(\"deinterlace_method\", \"linearblend\");\n    else if (ui->actionYadifTemporal->isChecked())\n        MLT.videoWidget()->setProperty(\"deinterlace_method\", \"yadif-nospatial\");\n    else\n        MLT.videoWidget()->setProperty(\"deinterlace_method\", \"yadif\");\n    if (ui->actionNearest->isChecked())\n        MLT.videoWidget()->setProperty(\"rescale\", \"nearest\");\n    else if (ui->actionBilinear->isChecked())\n        MLT.videoWidget()->setProperty(\"rescale\", \"bilinear\");\n    else if (ui->actionBicubic->isChecked())\n        MLT.videoWidget()->setProperty(\"rescale\", \"bicubic\");\n    else\n        MLT.videoWidget()->setProperty(\"rescale\", \"hyper\");\n    if (m_keyerGroup)\n        MLT.videoWidget()->setProperty(\"keyer\", m_keyerGroup->checkedAction()->data());\n    LOG_DEBUG() << \"end\";\n}\n\nvoid MainWindow::setCurrentFile(const QString &filename)\n{\n    QString shownName = tr(\"Untitled\");\n    if (filename == untitledFileName())\n        m_currentFile.clear();\n    else\n        m_currentFile = filename;\n    if (!m_currentFile.isEmpty())\n        shownName = QFileInfo(m_currentFile).fileName();\n#ifdef Q_OS_MAC\n    setWindowTitle(QString(\"%1 - %2\").arg(shownName).arg(qApp->applicationName()));\n#else\n    setWindowTitle(QString(\"%1[*] - %2\").arg(shownName).arg(qApp->applicationName()));\n#endif\n}\n\nvoid MainWindow::on_actionAbout_Shotcut_triggered()\n{\n    QMessageBox::about(this, tr(\"About Shotcut\"),\n             tr(\"<h1>Shotcut version %1</h1>\"\n                \"<p><a href=\\\"https://www.shotcut.org/\\\">Shotcut</a> is a free, open source, cross platform video editor.</p>\"\n                \"<small><p>Copyright &copy; 2011-2020 <a href=\\\"https://www.meltytech.com/\\\">Meltytech</a>, LLC</p>\"\n                \"<p>Licensed under the <a href=\\\"https://www.gnu.org/licenses/gpl.html\\\">GNU General Public License v3.0</a></p>\"\n                \"<p>This program proudly uses the following projects:<ul>\"\n                \"<li><a href=\\\"https://www.qt.io/\\\">Qt</a> application and UI framework</li>\"\n                \"<li><a href=\\\"https://www.mltframework.org/\\\">MLT</a> multimedia authoring framework</li>\"\n                \"<li><a href=\\\"https://www.ffmpeg.org/\\\">FFmpeg</a> multimedia format and codec libraries</li>\"\n                \"<li><a href=\\\"https://www.videolan.org/developers/x264.html\\\">x264</a> H.264 encoder</li>\"\n                \"<li><a href=\\\"https://www.webmproject.org/\\\">WebM</a> VP8 and VP9 encoders</li>\"\n                \"<li><a href=\\\"http://lame.sourceforge.net/\\\">LAME</a> MP3 encoder</li>\"\n                \"<li><a href=\\\"https://www.dyne.org/software/frei0r/\\\">Frei0r</a> video plugins</li>\"\n                \"<li><a href=\\\"https://www.ladspa.org/\\\">LADSPA</a> audio plugins</li>\"\n                \"<li><a href=\\\"http://www.defaulticon.com/\\\">DefaultIcon</a> icon collection by <a href=\\\"http://www.interactivemania.com/\\\">interactivemania</a></li>\"\n                \"<li><a href=\\\"http://www.oxygen-icons.org/\\\">Oxygen</a> icon collection</li>\"\n                \"</ul></p>\"\n                \"<p>The source code used to build this program can be downloaded from \"\n                \"<a href=\\\"https://www.shotcut.org/\\\">shotcut.org</a>.</p>\"\n                \"This program is distributed in the hope that it will be useful, \"\n                \"but WITHOUT ANY WARRANTY; without even the implied warranty of \"\n                \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</small>\"\n                ).arg(qApp->applicationVersion()));\n}\n\n\nvoid MainWindow::keyPressEvent(QKeyEvent* event)\n{\n    if (event->isAccepted() && event->key() != Qt::Key_F12) return;\n\n    bool handled = true;\n\n    switch (event->key()) {\n    case Qt::Key_Home:\n        m_player->seek(0);\n        break;\n    case Qt::Key_End:\n        if (MLT.producer())\n            m_player->seek(MLT.producer()->get_length() - 1);\n        break;\n    case Qt::Key_Left:\n        if ((event->modifiers() & Qt::ControlModifier) && m_timelineDock->isVisible()) {\n            if (m_timelineDock->selection().isEmpty()) {\n                m_timelineDock->selectClipUnderPlayhead();\n            } else if (m_timelineDock->selection().size() == 1) {\n                int newIndex = m_timelineDock->selection().first().x() - 1;\n                if (newIndex < 0)\n                    break;\n                m_timelineDock->setSelection(QList<QPoint>() << QPoint(newIndex, m_timelineDock->selection().first().y()));\n                m_navigationPosition = m_timelineDock->centerOfClip(m_timelineDock->currentTrack(), newIndex);\n            }\n        } else {\n            stepLeftOneFrame();\n        }\n        break;\n    case Qt::Key_Right:\n        if ((event->modifiers() & Qt::ControlModifier) && m_timelineDock->isVisible()) {\n            if (m_timelineDock->selection().isEmpty()) {\n                m_timelineDock->selectClipUnderPlayhead();\n            } else if (m_timelineDock->selection().size() == 1) {\n                int newIndex = m_timelineDock->selection().first().x() + 1;\n                if (newIndex >= m_timelineDock->clipCount(-1))\n                    break;\n                m_timelineDock->setSelection(QList<QPoint>() << QPoint(newIndex, m_timelineDock->selection().first().y()));\n                m_navigationPosition = m_timelineDock->centerOfClip(m_timelineDock->currentTrack(), newIndex);\n            }\n        } else {\n            stepRightOneFrame();\n        }\n        break;\n    case Qt::Key_PageUp:\n    case Qt::Key_PageDown:\n        {\n            int directionMultiplier = event->key() == Qt::Key_PageUp ? -1 : 1;\n            int seconds = 1;\n            if (event->modifiers() & Qt::ControlModifier)\n                seconds *= 5;\n            if (event->modifiers() & Qt::ShiftModifier)\n                seconds *= 2;\n            stepLeftBySeconds(seconds * directionMultiplier);\n        }\n        break;\n    case Qt::Key_Space:\n#ifdef Q_OS_MAC\n        // Spotlight defaults to Cmd+Space, so also accept Ctrl+Space.\n        if ((event->modifiers() == Qt::MetaModifier || (event->modifiers() & Qt::ControlModifier)) && m_timelineDock->isVisible())\n#else\n        if (event->modifiers() == Qt::ControlModifier && m_timelineDock->isVisible())\n#endif\n            m_timelineDock->selectClipUnderPlayhead();\n        else\n            handled = false;\n        break;\n    case Qt::Key_A:\n        if (event->modifiers() == Qt::ShiftModifier) {\n            m_playlistDock->show();\n            m_playlistDock->raise();\n            m_playlistDock->on_actionAppendCut_triggered();\n        } else if ((event->modifiers() & Qt::ControlModifier) && (event->modifiers() & Qt::ShiftModifier)) {\n            m_playlistDock->show();\n            m_playlistDock->raise();\n            m_playlistDock->on_actionSelectAll_triggered();\n        } else if (event->modifiers() == Qt::ControlModifier) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->selectAll();\n        } else if (event->modifiers() == Qt::NoModifier) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->append(-1);\n        }\n        break;\n    case Qt::Key_C:\n        if (event->modifiers() == Qt::ShiftModifier && m_playlistDock->model()->rowCount() > 0) {\n            m_playlistDock->show();\n            m_playlistDock->raise();\n            m_playlistDock->on_actionCopy_triggered();\n        } else if ((event->modifiers() & Qt::ControlModifier) && (event->modifiers() & Qt::AltModifier)) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->copyToSource();\n        } else if (isMultitrackValid()) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            if (m_timelineDock->selection().isEmpty()) {\n                m_timelineDock->copyClip(-1, -1);\n            } else {\n                auto& selected = m_timelineDock->selection().first();\n                m_timelineDock->copyClip(selected.y(), selected.x());\n            }\n        }\n        break;\n    case Qt::Key_D:\n        if (event->modifiers() == Qt::ControlModifier) {\n            m_timelineDock->setSelection();\n            m_timelineDock->model()->reload();\n        } else if ((event->modifiers() & Qt::ControlModifier) && (event->modifiers() & Qt::ShiftModifier)) {\n            m_playlistDock->show();\n            m_playlistDock->raise();\n            m_playlistDock->on_actionSelectNone_triggered();\n        } else {\n            handled = false;\n        }\n        break;\n    case Qt::Key_F:\n        if (event->modifiers() == Qt::NoModifier || event->modifiers() == Qt::ControlModifier) {\n            m_filtersDock->show();\n            m_filtersDock->raise();\n            m_filtersDock->widget()->setFocus();\n            m_filtersDock->openFilterMenu();\n        } else if (event->modifiers() == Qt::ShiftModifier) {\n            filterController()->removeCurrent();\n        } else {\n            handled = false;\n        }\n        break;\n    case Qt::Key_H:\n#ifdef Q_OS_MAC\n        // OS X uses Cmd+H to hide an app.\n        if (event->modifiers() & Qt::MetaModifier && isMultitrackValid())\n#else\n        if (event->modifiers() & Qt::ControlModifier && isMultitrackValid())\n#endif\n            m_timelineDock->toggleTrackHidden(m_timelineDock->currentTrack());\n        break;\n    case Qt::Key_J:\n        if (m_isKKeyPressed)\n            m_player->seek(m_player->position() - 1);\n        else\n            m_player->rewind(false);\n        break;\n    case Qt::Key_K:\n            m_player->pause();\n            m_isKKeyPressed = true;\n        break;\n    case Qt::Key_L:\n#ifdef Q_OS_MAC\n        // OS X uses Cmd+H to hide an app and Cmd+M to minimize. Therefore, we force\n        // it to be the apple keyboard control key aka meta. Therefore, to be\n        // consistent with all track header toggles, we make the lock toggle also use\n        // meta.\n        if (event->modifiers() & Qt::MetaModifier && isMultitrackValid())\n#else\n        if (event->modifiers() & Qt::ControlModifier && isMultitrackValid())\n#endif\n            m_timelineDock->setTrackLock(m_timelineDock->currentTrack(), !m_timelineDock->isTrackLocked(m_timelineDock->currentTrack()));\n        else if (m_isKKeyPressed)\n            m_player->seek(m_player->position() + 1);\n        else\n            m_player->fastForward(false);\n        break;\n    case Qt::Key_M:\n#ifdef Q_OS_MAC\n        // OS X uses Cmd+M to minimize an app.\n        if (event->modifiers() & Qt::MetaModifier && isMultitrackValid())\n#else\n        if (event->modifiers() & Qt::ControlModifier && isMultitrackValid())\n#endif\n            m_timelineDock->toggleTrackMute(m_timelineDock->currentTrack());\n        break;\n    case Qt::Key_I:\n        if (event->modifiers() == Qt::ControlModifier) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->addVideoTrack();\n        } else if ((event->modifiers() & Qt::ControlModifier) && (event->modifiers() & Qt::AltModifier)) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->insertTrack();\n        } else {\n            setInToCurrent(event->modifiers() & Qt::ShiftModifier);\n        }\n        break;\n    case Qt::Key_O:\n        setOutToCurrent(event->modifiers() & Qt::ShiftModifier);\n        break;\n    case Qt::Key_P:\n        if (event->modifiers() == Qt::ControlModifier) {\n            Settings.setTimelineSnap(!Settings.timelineSnap());\n        }\n        break;\n    case Qt::Key_R:\n        if (event->modifiers() & Qt::ControlModifier) {\n            if (event->modifiers() & Qt::AltModifier) {\n                Settings.setTimelineRippleAllTracks(!Settings.timelineRippleAllTracks());\n            } else if (event->modifiers() & Qt::ShiftModifier) {\n                Settings.setTimelineRippleAllTracks(!Settings.timelineRipple());\n                Settings.setTimelineRipple(!Settings.timelineRipple());\n            } else {\n                Settings.setTimelineRipple(!Settings.timelineRipple());\n            }\n        } else if (isMultitrackValid()) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            if (MLT.isClip() || m_timelineDock->selection().isEmpty()) {\n                m_timelineDock->replace(-1, -1);\n            } else {\n                auto& selected = m_timelineDock->selection().first();\n                m_timelineDock->replace(selected.y(), selected.x());\n            }\n        }\n        break;\n    case Qt::Key_S:\n        if (isMultitrackValid())\n            m_timelineDock->splitClip();\n        break;\n    case Qt::Key_U:\n        if (event->modifiers() == Qt::ControlModifier) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->addAudioTrack();\n        } else if ((event->modifiers() & Qt::ControlModifier) && (event->modifiers() & Qt::AltModifier)) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->removeTrack();\n        }\n        break;\n    case Qt::Key_V: // Avid Splice In\n        if (event->modifiers() == Qt::ShiftModifier) {\n            m_playlistDock->show();\n            m_playlistDock->raise();\n            m_playlistDock->on_actionInsertCut_triggered();\n        } else {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->insert(-1);\n        }\n        break;\n    case Qt::Key_B:\n        if (event->modifiers() & Qt::ControlModifier && event->modifiers() & Qt::AltModifier) {\n            // Toggle track blending.\n            int trackIndex = m_timelineDock->currentTrack();\n            bool isBottomVideo = m_timelineDock->model()->data(m_timelineDock->model()->index(trackIndex), MultitrackModel::IsBottomVideoRole).toBool();\n            if (!isBottomVideo) {\n                bool isComposite = m_timelineDock->model()->data(m_timelineDock->model()->index(trackIndex), MultitrackModel::IsCompositeRole).toBool();\n                m_timelineDock->setTrackComposite(trackIndex, !isComposite);\n            }\n        } else if (event->modifiers() == Qt::ShiftModifier) {\n            if (m_playlistDock->model()->rowCount() > 0) {\n                // Update playlist item.\n                m_playlistDock->show();\n                m_playlistDock->raise();\n                m_playlistDock->on_actionUpdate_triggered();\n            }\n        } else {\n            // Overwrite on timeline.\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->overwrite(-1);\n        }\n        break;\n    case Qt::Key_Escape: // Avid Toggle Active Monitor\n        if (MLT.isPlaylist()) {\n            if (isMultitrackValid())\n                m_player->onTabBarClicked(Player::ProjectTabIndex);\n            else if (MLT.savedProducer())\n                m_player->onTabBarClicked(Player::SourceTabIndex);\n            else\n                m_playlistDock->on_actionOpen_triggered();\n        } else if (MLT.isMultitrack()) {\n            if (MLT.savedProducer())\n                m_player->onTabBarClicked(Player::SourceTabIndex);\n            // TODO else open clip under playhead of current track if available\n        } else {\n            if (isMultitrackValid() || (playlist() && playlist()->count() > 0))\n                m_player->onTabBarClicked(Player::ProjectTabIndex);\n        }\n        break;\n    case Qt::Key_Up:\n        if (m_playlistDock->isVisible() && event->modifiers() & Qt::AltModifier && m_playlistDock->model()->rowCount() > 0) {\n            m_playlistDock->raise();\n            m_playlistDock->decrementIndex();\n            m_playlistDock->on_actionOpen_triggered();\n        } else if ((event->modifiers() & Qt::ControlModifier) && (event->modifiers() & Qt::ShiftModifier)) {\n            if (m_playlistDock->model()->rowCount() > 0) {\n                m_playlistDock->raise();\n                m_playlistDock->moveClipUp();\n                m_playlistDock->decrementIndex();\n            }\n        } else if (isMultitrackValid()) {\n            int newClipIndex = -1;\n            int trackIndex = m_timelineDock->currentTrack() - 1;\n            if ((event->modifiers() & Qt::ControlModifier) &&\n                    !m_timelineDock->selection().isEmpty() &&\n                    trackIndex > -1) {\n\n                newClipIndex = m_timelineDock->clipIndexAtPosition(trackIndex, m_navigationPosition);\n            }\n\n            m_timelineDock->incrementCurrentTrack(-1);\n\n            if (newClipIndex >= 0) {\n                newClipIndex = qMin(newClipIndex, m_timelineDock->clipCount(trackIndex) - 1);\n                m_timelineDock->setSelection(QList<QPoint>() << QPoint(newClipIndex, trackIndex));\n            }\n\n        }\n        break;\n    case Qt::Key_Down:\n        if (m_playlistDock->isVisible() && event->modifiers() & Qt::AltModifier && m_playlistDock->model()->rowCount() > 0) {\n            m_playlistDock->raise();\n            m_playlistDock->incrementIndex();\n            m_playlistDock->on_actionOpen_triggered();\n        } else if ((event->modifiers() & Qt::ControlModifier) && (event->modifiers() & Qt::ShiftModifier)) {\n            if (m_playlistDock->model()->rowCount() > 0) {\n                m_playlistDock->raise();\n                m_playlistDock->moveClipDown();\n                m_playlistDock->incrementIndex();\n            }\n        } else if (isMultitrackValid()) {\n            int newClipIndex = -1;\n            int trackIndex = m_timelineDock->currentTrack() + 1;\n            if ((event->modifiers() & Qt::ControlModifier) &&\n                    !m_timelineDock->selection().isEmpty() &&\n                    trackIndex < m_timelineDock->model()->trackList().count()) {\n\n                newClipIndex = m_timelineDock->clipIndexAtPosition(trackIndex, m_navigationPosition);\n            }\n\n            m_timelineDock->incrementCurrentTrack(1);\n\n            if (newClipIndex >= 0) {\n                newClipIndex = qMin(newClipIndex, m_timelineDock->clipCount(trackIndex) - 1);\n                m_timelineDock->setSelection(QList<QPoint>() << QPoint(newClipIndex, trackIndex));\n            }\n\n        }\n        break;\n    case Qt::Key_1:\n    case Qt::Key_2:\n    case Qt::Key_3:\n    case Qt::Key_4:\n    case Qt::Key_5:\n    case Qt::Key_6:\n    case Qt::Key_7:\n    case Qt::Key_8:\n    case Qt::Key_9:\n        if (!event->modifiers() && m_playlistDock->isVisible() && m_playlistDock->model()->rowCount() > 0) {\n            m_playlistDock->raise();\n            m_playlistDock->setIndex(event->key() - Qt::Key_1);\n        }\n        break;\n    case Qt::Key_0:\n        if (!event->modifiers() ) {\n            if (m_timelineDock->isVisible()) {\n                m_timelineDock->resetZoom();\n            } else if (m_playlistDock->isVisible() && m_playlistDock->model()->rowCount() > 0) {\n                m_playlistDock->raise();\n                m_playlistDock->setIndex(9);\n            }\n        }\n        if (m_keyframesDock->isVisible() && (event->modifiers() & Qt::AltModifier)) {\n            emit m_keyframesDock->resetZoom();\n        }\n        break;\n    case Qt::Key_X: // Avid Extract\n        if (event->modifiers() == Qt::ShiftModifier && m_playlistDock->model()->rowCount() > 0) {\n            m_playlistDock->show();\n            m_playlistDock->raise();\n            m_playlistDock->on_removeButton_clicked();\n        } else if (isMultitrackValid()) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->removeSelection();\n        }\n        break;\n    case Qt::Key_Backspace:\n    case Qt::Key_Delete:\n        if (isMultitrackValid()) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            if (event->modifiers() == Qt::ShiftModifier)\n                m_timelineDock->removeSelection();\n            else\n                m_timelineDock->liftSelection();\n        } else if (m_playlistDock->model()->rowCount() > 0) {\n            m_playlistDock->show();\n            m_playlistDock->raise();\n            m_playlistDock->on_removeButton_clicked();\n        }\n        break;\n    case Qt::Key_Z: // Avid Lift\n        if (event->modifiers() == Qt::ShiftModifier && m_playlistDock->model()->rowCount() > 0) {\n            m_playlistDock->show();\n            m_playlistDock->raise();\n            m_playlistDock->on_removeButton_clicked();\n        } else if (isMultitrackValid() && event->modifiers() == Qt::NoModifier) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->liftSelection();\n        }\n        break;\n    case Qt::Key_Minus:\n        if (m_timelineDock->isVisible() && !(event->modifiers() & Qt::AltModifier)) {\n            if (event->modifiers() & Qt::ControlModifier)\n                m_timelineDock->makeTracksShorter();\n            else\n                m_timelineDock->zoomOut();\n        }\n        if (m_keyframesDock->isVisible() && (event->modifiers() & Qt::AltModifier)) {\n            emit m_keyframesDock->zoomOut();\n        }\n        break;\n    case Qt::Key_Equal:\n    case Qt::Key_Plus:\n        if (m_timelineDock->isVisible() && !(event->modifiers() & Qt::AltModifier)) {\n            if (event->modifiers() & Qt::ControlModifier)\n                m_timelineDock->makeTracksTaller();\n            else\n                m_timelineDock->zoomIn();\n        }\n        if (m_keyframesDock->isVisible() && (event->modifiers() & Qt::AltModifier)) {\n            emit m_keyframesDock->zoomIn();\n        }\n        break;\n    case Qt::Key_Enter: // Seek to current playlist item\n    case Qt::Key_Return:\n        if (m_playlistDock->isVisible() && m_playlistDock->position() >= 0) {\n            if (event->modifiers() == Qt::ShiftModifier)\n                seekPlaylist(m_playlistDock->position());\n            else if (event->modifiers() == Qt::ControlModifier)\n                m_playlistDock->on_actionOpen_triggered();\n        }\n        break;\n    case Qt::Key_F2:\n        onPropertiesDockTriggered(true);\n        emit renameRequested();\n        break;\n    case Qt::Key_F3:\n        onRecentDockTriggered(true);\n        m_recentDock->find();\n        break;\n    case Qt::Key_F5:\n        m_timelineDock->model()->reload();\n        m_keyframesDock->model().reload();\n        break;\n    case Qt::Key_F12:\n        LOG_DEBUG() << \"event isAccepted:\" << event->isAccepted();\n        LOG_DEBUG() << \"Current focusWidget:\" << QApplication::focusWidget();\n        LOG_DEBUG() << \"Current focusObject:\" << QApplication::focusObject();\n        LOG_DEBUG() << \"Current focusWindow:\" << QApplication::focusWindow();\n        break;\n    case Qt::Key_BracketLeft:\n        if (filterController()->currentFilter() && m_filtersDock->qmlProducer()) {\n            if (event->modifiers() == Qt::AltModifier) {\n                emit m_keyframesDock->seekPreviousSimple();\n            } else {\n                int i = m_filtersDock->qmlProducer()->position() + m_filtersDock->qmlProducer()->in();\n                filterController()->currentFilter()->setIn(i);\n            }\n        }\n        break;\n    case Qt::Key_BracketRight:\n        if (filterController()->currentFilter() && m_filtersDock->qmlProducer()) {\n            if (event->modifiers() == Qt::AltModifier) {\n                emit m_keyframesDock->seekNextSimple();\n            } else {\n                int i = m_filtersDock->qmlProducer()->position() + m_filtersDock->qmlProducer()->in();\n                filterController()->currentFilter()->setOut(i);\n            }\n        }\n        break;\n    case Qt::Key_BraceLeft:\n        if (filterController()->currentFilter() && m_filtersDock->qmlProducer()) {\n            int i = m_filtersDock->qmlProducer()->position() + m_filtersDock->qmlProducer()->in() - filterController()->currentFilter()->in();\n            filterController()->currentFilter()->setAnimateIn(i);\n        }\n        break;\n    case Qt::Key_BraceRight:\n        if (filterController()->currentFilter() && m_filtersDock->qmlProducer()) {\n            int i = filterController()->currentFilter()->out() - (m_filtersDock->qmlProducer()->position() + m_filtersDock->qmlProducer()->in());\n            filterController()->currentFilter()->setAnimateOut(i);\n        }\n        break;\n    case Qt::Key_Semicolon:\n        if (filterController()->currentFilter() && m_filtersDock->qmlProducer() && m_keyframesDock->currentParameter() >= 0) {\n            auto position = m_filtersDock->qmlProducer()->position() - (filterController()->currentFilter()->in() - m_filtersDock->qmlProducer()->in());\n            auto parameterIndex = m_keyframesDock->currentParameter();\n            if (m_keyframesDock->model().isKeyframe(parameterIndex, position)) {\n                auto keyframeIndex = m_keyframesDock->model().keyframeIndex(parameterIndex, position);\n                m_keyframesDock->model().remove(parameterIndex, keyframeIndex);\n            } else {\n                m_keyframesDock->model().addKeyframe(parameterIndex, position);\n            }\n        }\n        break;\n    default:\n        handled = false;\n        break;\n    }\n\n    if (handled)\n        event->setAccepted(handled);\n    else\n        QMainWindow::keyPressEvent(event);\n}\n\nvoid MainWindow::keyReleaseEvent(QKeyEvent* event)\n{\n    if (event->key() == Qt::Key_K) {\n        m_isKKeyPressed = false;\n        event->setAccepted(true);\n    } else {\n        QMainWindow::keyReleaseEvent(event);\n    }\n}\n\nvoid MainWindow::hideSetDataDirectory()\n{\n    delete ui->actionAppDataSet;\n}\n\nQAction *MainWindow::actionAddCustomProfile() const\n{\n    return ui->actionAddCustomProfile;\n}\n\nQAction *MainWindow::actionProfileRemove() const\n{\n    return ui->actionProfileRemove;\n}\n\nvoid MainWindow::buildVideoModeMenu(QMenu* topMenu, QMenu*& customMenu, QActionGroup* group, QAction* addAction, QAction* removeAction)\n{\n    topMenu->addAction(addProfile(group, \"HD 720p 50 fps\", \"atsc_720p_50\"));\n    topMenu->addAction(addProfile(group, \"HD 720p 59.94 fps\", \"atsc_720p_5994\"));\n    topMenu->addAction(addProfile(group, \"HD 720p 60 fps\", \"atsc_720p_60\"));\n    topMenu->addAction(addProfile(group, \"HD 1080i 25 fps\", \"atsc_1080i_50\"));\n    topMenu->addAction(addProfile(group, \"HD 1080i 29.97 fps\", \"atsc_1080i_5994\"));\n    topMenu->addAction(addProfile(group, \"HD 1080p 23.98 fps\", \"atsc_1080p_2398\"));\n    topMenu->addAction(addProfile(group, \"HD 1080p 24 fps\", \"atsc_1080p_24\"));\n    topMenu->addAction(addProfile(group, \"HD 1080p 25 fps\", \"atsc_1080p_25\"));\n    topMenu->addAction(addProfile(group, \"HD 1080p 29.97 fps\", \"atsc_1080p_2997\"));\n    topMenu->addAction(addProfile(group, \"HD 1080p 30 fps\", \"atsc_1080p_30\"));\n    topMenu->addAction(addProfile(group, \"HD 1080p 59.94 fps\", \"atsc_1080p_5994\"));\n    topMenu->addAction(addProfile(group, \"HD 1080p 50 fps\", \"atsc_1080p_50\"));\n    topMenu->addAction(addProfile(group, \"HD 1080p 60 fps\", \"atsc_1080p_60\"));\n    topMenu->addAction(addProfile(group, \"SD NTSC\", \"dv_ntsc\"));\n    topMenu->addAction(addProfile(group, \"SD PAL\", \"dv_pal\"));\n    topMenu->addAction(addProfile(group, \"UHD 2160p 23.98 fps\", \"uhd_2160p_2398\"));\n    topMenu->addAction(addProfile(group, \"UHD 2160p 24 fps\", \"uhd_2160p_24\"));\n    topMenu->addAction(addProfile(group, \"UHD 2160p 25 fps\", \"uhd_2160p_25\"));\n    topMenu->addAction(addProfile(group, \"UHD 2160p 29.97 fps\", \"uhd_2160p_2997\"));\n    topMenu->addAction(addProfile(group, \"UHD 2160p 30 fps\", \"uhd_2160p_30\"));\n    topMenu->addAction(addProfile(group, \"UHD 2160p 50 fps\", \"uhd_2160p_50\"));\n    topMenu->addAction(addProfile(group, \"UHD 2160p 59.94 fps\", \"uhd_2160p_5994\"));\n    topMenu->addAction(addProfile(group, \"UHD 2160p 60 fps\", \"uhd_2160p_60\"));\n    QMenu* menu = topMenu->addMenu(tr(\"Non-Broadcast\"));\n    menu->addAction(addProfile(group, \"640x480 4:3 NTSC\", \"square_ntsc\"));\n    menu->addAction(addProfile(group, \"768x576 4:3 PAL\", \"square_pal\"));\n    menu->addAction(addProfile(group, \"854x480 16:9 NTSC\", \"square_ntsc_wide\"));\n    menu->addAction(addProfile(group, \"1024x576 16:9 PAL\", \"square_pal_wide\"));\n    menu->addAction(addProfile(group, tr(\"DVD Widescreen NTSC\"), \"dv_ntsc_wide\"));\n    menu->addAction(addProfile(group, tr(\"DVD Widescreen PAL\"), \"dv_pal_wide\"));\n    menu->addAction(addProfile(group, \"HD 720p 23.98 fps\", \"atsc_720p_2398\"));\n    menu->addAction(addProfile(group, \"HD 720p 24 fps\", \"atsc_720p_24\"));\n    menu->addAction(addProfile(group, \"HD 720p 25 fps\", \"atsc_720p_25\"));\n    menu->addAction(addProfile(group, \"HD 720p 29.97 fps\", \"atsc_720p_2997\"));\n    menu->addAction(addProfile(group, \"HD 720p 30 fps\", \"atsc_720p_30\"));\n    menu->addAction(addProfile(group, \"HD 1080i 60 fps\", \"atsc_1080i_60\"));\n    menu->addAction(addProfile(group, \"HDV 1080i 25 fps\", \"hdv_1080_50i\"));\n    menu->addAction(addProfile(group, \"HDV 1080i 29.97 fps\", \"hdv_1080_60i\"));\n    menu->addAction(addProfile(group, \"HDV 1080p 25 fps\", \"hdv_1080_25p\"));\n    menu->addAction(addProfile(group, \"HDV 1080p 29.97 fps\", \"hdv_1080_30p\"));\n    menu->addAction(addProfile(group, tr(\"Square 1080p 30 fps\"), \"square_1080p_30\"));\n    menu->addAction(addProfile(group, tr(\"Square 1080p 60 fps\"), \"square_1080p_60\"));\n    menu->addAction(addProfile(group, tr(\"Vertical HD 30 fps\"), \"vertical_hd_30\"));\n    menu->addAction(addProfile(group, tr(\"Vertical HD 60 fps\"), \"vertical_hd_60\"));\n    customMenu = topMenu->addMenu(tr(\"Custom\"));\n    customMenu->addAction(addAction);\n    // Load custom profiles\n    QDir dir(Settings.appDataLocation());\n    if (dir.cd(\"profiles\")) {\n        QStringList profiles = dir.entryList(QDir::Files | QDir::NoDotAndDotDot | QDir::Readable);\n        if (profiles.length() > 0) {\n            customMenu->addAction(removeAction);\n            customMenu->addSeparator();\n        }\n        foreach (QString name, profiles)\n            customMenu->addAction(addProfile(group, name, dir.filePath(name)));\n    }\n}\n\nvoid MainWindow::newProject(const QString &filename, bool isProjectFolder)\n{\n    if (isProjectFolder) {\n        QFileInfo info(filename);\n        MLT.setProjectFolder(info.absolutePath());\n    }\n    if (saveXML(filename)) {\n        QMutexLocker locker(&m_autosaveMutex);\n        if (m_autosaveFile)\n            m_autosaveFile->changeManagedFile(filename);\n        else\n            m_autosaveFile.reset(new AutoSaveFile(filename));\n        setCurrentFile(filename);\n        setWindowModified(false);\n        if (MLT.producer())\n            showStatusMessage(tr(\"Saved %1\").arg(m_currentFile));\n        m_undoStack->setClean();\n        m_recentDock->add(filename);\n    } else {\n        showSaveError();\n    }\n}\n\nvoid MainWindow::addCustomProfile(const QString &name, QMenu *menu, QAction *action, QActionGroup *group)\n{\n    // Add new profile to the menu.\n    QDir dir(Settings.appDataLocation());\n    if (dir.cd(\"profiles\")) {\n        QStringList profiles = dir.entryList(QDir::Files | QDir::NoDotAndDotDot | QDir::Readable);\n        if (profiles.length() == 1) {\n            menu->addAction(action);\n            menu->addSeparator();\n        }\n        action = addProfile(group, name, dir.filePath(name));\n        action->setChecked(true);\n        menu->addAction(action);\n        Settings.setPlayerProfile(dir.filePath(name));\n        Settings.sync();\n    }\n}\n\nvoid MainWindow::removeCustomProfiles(const QStringList &profiles, QDir& dir, QMenu *menu, QAction *action)\n{\n    foreach(const QString& profile, profiles) {\n        // Remove the file.\n        dir.remove(profile);\n        // Locate the menu item.\n        foreach (QAction* a, menu->actions()) {\n            if (a->text() == profile) {\n                // Remove the menu item.\n                delete a;\n                break;\n            }\n        }\n    }\n    // If no more custom video modes.\n    if (menu->actions().size() == 3) {\n        // Remove the Remove action and separator.\n        menu->removeAction(action);\n        foreach (QAction* a, menu->actions()) {\n            if (a->isSeparator()) {\n                delete a;\n                break;\n            }\n        }\n    }\n}\n\n// Drag-n-drop events\n\nbool MainWindow::eventFilter(QObject* target, QEvent* event)\n{\n    if (event->type() == QEvent::DragEnter && target == MLT.videoWidget()) {\n        dragEnterEvent(static_cast<QDragEnterEvent*>(event));\n        return true;\n    } else if (event->type() == QEvent::Drop && target == MLT.videoWidget()) {\n        dropEvent(static_cast<QDropEvent*>(event));\n        return true;\n    } else if (event->type() == QEvent::KeyPress || event->type() == QEvent::KeyRelease) {\n        if (QEvent::KeyPress == event->type()) {\n            // Let Shift+Escape be a global hook to defocus a widget (assign global player focus).\n            auto keyEvent = static_cast<QKeyEvent*>(event);\n            if (Qt::Key_Escape == keyEvent->key() && Qt::ShiftModifier == keyEvent->modifiers()) {\n                m_player->setFocus();\n                return true;\n            }\n        }\n        QQuickWidget * focusedQuickWidget = qobject_cast<QQuickWidget*>(qApp->focusWidget());\n        if (focusedQuickWidget && focusedQuickWidget->quickWindow()->activeFocusItem()) {\n            event->accept();\n            focusedQuickWidget->quickWindow()->sendEvent(focusedQuickWidget->quickWindow()->activeFocusItem(), event);\n            QWidget * w = focusedQuickWidget->parentWidget();\n            if (!event->isAccepted())\n                qApp->sendEvent(w, event);\n            return true;\n        }\n    }\n    return QMainWindow::eventFilter(target, event);\n}\n\nvoid MainWindow::dragEnterEvent(QDragEnterEvent *event)\n{\n    // Simulate the player firing a dragStarted even to make the playlist close\n    // its help text view. This lets one drop a clip directly into the playlist\n    // from a fresh start.\n    Mlt::GLWidget* videoWidget = (Mlt::GLWidget*) &Mlt::Controller::singleton();\n    emit videoWidget->dragStarted();\n\n    event->acceptProposedAction();\n}\n\nvoid MainWindow::dropEvent(QDropEvent *event)\n{\n    const QMimeData *mimeData = event->mimeData();\n    if (mimeData->hasFormat(\"application/x-qabstractitemmodeldatalist\")) {\n        QByteArray encoded = mimeData->data(\"application/x-qabstractitemmodeldatalist\");\n        QDataStream stream(&encoded, QIODevice::ReadOnly);\n        QMap<int,  QVariant> roleDataMap;\n        while (!stream.atEnd()) {\n            int row, col;\n            stream >> row >> col >> roleDataMap;\n        }\n        if (roleDataMap.contains(Qt::ToolTipRole)) {\n            // DisplayRole is just basename, ToolTipRole contains full path\n            open(roleDataMap[Qt::ToolTipRole].toString());\n            event->acceptProposedAction();\n        }\n    }\n    else if (mimeData->hasUrls()) {\n        openMultiple(mimeData->urls());\n        event->acceptProposedAction();\n    }\n    else if (mimeData->hasFormat(Mlt::XmlMimeType )) {\n        m_playlistDock->on_actionOpen_triggered();\n        event->acceptProposedAction();\n    }\n}\n\nvoid MainWindow::closeEvent(QCloseEvent* event)\n{\n    if (continueJobsRunning() && continueModified()) {\n        if (!m_htmlEditor || m_htmlEditor->close()) {\n            LOG_DEBUG() << \"begin\";\n            JOBS.cleanup();\n            writeSettings();\n            if (m_exitCode == EXIT_SUCCESS) {\n                MLT.stop();\n            } else {\n                if (multitrack())\n                    m_timelineDock->model()->close();\n                if (playlist())\n                    m_playlistDock->model()->close();\n                else\n                    onMultitrackClosed();\n            }\n            QThreadPool::globalInstance()->clear();\n            AudioLevelsTask::closeAll();\n            event->accept();\n            emit aboutToShutDown();\n            if (m_exitCode == EXIT_SUCCESS) {\n                QApplication::quit();\n                LOG_DEBUG() << \"end\";\n                ::_Exit(0);\n            } else {\n                QApplication::exit(m_exitCode);\n                LOG_DEBUG() << \"end\";\n            }\n            return;\n        }\n    }\n    event->ignore();\n}\n\nvoid MainWindow::showEvent(QShowEvent* event)\n{\n    // This is needed to prevent a crash on windows on startup when timeline\n    // is visible and dock title bars are hidden.\n    Q_UNUSED(event)\n    ui->actionShowTitleBars->setChecked(Settings.showTitleBars());\n    on_actionShowTitleBars_triggered(Settings.showTitleBars());\n    ui->actionShowToolbar->setChecked(Settings.showToolBar());\n    on_actionShowToolbar_triggered(Settings.showToolBar());\n    ui->actionShowTextUnderIcons->setChecked(Settings.textUnderIcons());\n    on_actionShowTextUnderIcons_toggled(Settings.textUnderIcons());\n    ui->actionShowSmallIcons->setChecked(Settings.smallIcons());\n    on_actionShowSmallIcons_toggled(Settings.smallIcons());\n\n    windowHandle()->installEventFilter(this);\n\n#ifndef SHOTCUT_NOUPGRADE\n    if (!Settings.noUpgrade() && !qApp->property(\"noupgrade\").toBool())\n        QTimer::singleShot(0, this, SLOT(showUpgradePrompt()));\n#endif\n}\n\nvoid MainWindow::on_actionOpenOther_triggered()\n{\n    // these static are used to open dialog with previous configuration\n    OpenOtherDialog dialog(this);\n\n    if (MLT.producer())\n        dialog.load(MLT.producer());\n    if (dialog.exec() == QDialog::Accepted) {\n        closeProducer();\n        open(dialog.newProducer(MLT.profile()));\n    }\n}\n\nvoid MainWindow::onProducerOpened(bool withReopen)\n{\n    QWidget* w = loadProducerWidget(MLT.producer());\n    if (withReopen && w && !MLT.producer()->get(kMultitrackItemProperty)) {\n        if (-1 != w->metaObject()->indexOfSignal(\"producerReopened()\"))\n            connect(w, SIGNAL(producerReopened()), m_player, SLOT(onProducerOpened()));\n    }\n    else if (MLT.isPlaylist()) {\n        m_playlistDock->model()->load();\n        if (playlist()) {\n            m_isPlaylistLoaded = true;\n            m_player->setIn(-1);\n            m_player->setOut(-1);\n            m_playlistDock->setVisible(true);\n            m_playlistDock->raise();\n            m_player->enableTab(Player::ProjectTabIndex);\n            m_player->switchToTab(Player::ProjectTabIndex);\n        }\n    }\n    else if (MLT.isMultitrack()) {\n        m_timelineDock->blockSelection(true);\n        m_timelineDock->model()->load();\n        m_timelineDock->blockSelection(false);\n        if (isMultitrackValid()) {\n            m_player->setIn(-1);\n            m_player->setOut(-1);\n            m_timelineDock->setVisible(true);\n            m_timelineDock->raise();\n            m_player->enableTab(Player::ProjectTabIndex);\n            m_player->switchToTab(Player::ProjectTabIndex);\n            m_timelineDock->selectMultitrack();\n            QTimer::singleShot(0, [=]() {\n                m_timelineDock->setSelection();\n            });\n        }\n    }\n    if (MLT.isClip()) {\n        m_player->enableTab(Player::SourceTabIndex);\n        m_player->switchToTab(Player::SourceTabIndex);\n        Util::getHash(*MLT.producer());\n        ui->actionPaste->setEnabled(true);\n    }\n    QMutexLocker locker(&m_autosaveMutex);\n    if (m_autosaveFile)\n        setCurrentFile(m_autosaveFile->managedFileName());\n    else if (!MLT.URL().isEmpty())\n        setCurrentFile(MLT.URL());\n    on_actionJack_triggered(ui->actionJack && ui->actionJack->isChecked());\n}\n\nvoid MainWindow::onProducerChanged()\n{\n    MLT.refreshConsumer();\n    if (playlist() && MLT.producer() && MLT.producer()->is_valid()\n        && MLT.producer()->get_int(kPlaylistIndexProperty))\n        m_playlistDock->setUpdateButtonEnabled(true);\n}\n\nbool MainWindow::on_actionSave_triggered()\n{\n    if (m_currentFile.isEmpty()) {\n        return on_actionSave_As_triggered();\n    } else {\n        if (Util::warnIfNotWritable(m_currentFile, this, tr(\"Save XML\")))\n            return false;\n        bool success = saveXML(m_currentFile);\n        QMutexLocker locker(&m_autosaveMutex);\n        m_autosaveFile.reset(new AutoSaveFile(m_currentFile));\n        setCurrentFile(m_currentFile);\n        setWindowModified(false);\n        if (success) {\n            showStatusMessage(tr(\"Saved %1\").arg(m_currentFile));\n        } else {\n            showSaveError();\n        }\n        m_undoStack->setClean();\n        return true;\n    }\n}\n\nbool MainWindow::on_actionSave_As_triggered()\n{\n    QString path = Settings.savePath();\n    if (!m_currentFile.isEmpty())\n        path = m_currentFile;\n    QString caption = tr(\"Save XML\");\n    QString filename = QFileDialog::getSaveFileName(this, caption, path, tr(\"MLT XML (*.mlt)\"));\n    if (!filename.isEmpty()) {\n        QFileInfo fi(filename);\n        Settings.setSavePath(fi.path());\n        if (fi.suffix() != \"mlt\")\n            filename += \".mlt\";\n\n        if (Util::warnIfNotWritable(filename, this, caption))\n            return false;\n        newProject(filename);\n    }\n    return !filename.isEmpty();\n}\n\nbool MainWindow::continueModified()\n{\n    if (isWindowModified()) {\n        QMessageBox dialog(QMessageBox::Warning,\n                                     qApp->applicationName(),\n                                     tr(\"The project has been modified.\\n\"\n                                        \"Do you want to save your changes?\"),\n                                     QMessageBox::No |\n                                     QMessageBox::Cancel |\n                                     QMessageBox::Yes,\n                                     this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::Cancel);\n        int r = dialog.exec();\n        if (r == QMessageBox::Yes || r == QMessageBox::No) {\n            if (r == QMessageBox::Yes) {\n                return on_actionSave_triggered();\n            } else {\n                QMutexLocker locker(&m_autosaveMutex);\n                m_autosaveFile.reset();\n            }\n        } else if (r == QMessageBox::Cancel) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool MainWindow::continueJobsRunning()\n{\n    if (JOBS.hasIncomplete()) {\n        QMessageBox dialog(QMessageBox::Warning,\n                                     qApp->applicationName(),\n                                     tr(\"There are incomplete jobs.\\n\"\n                                        \"Do you want to still want to exit?\"),\n                                     QMessageBox::No |\n                                     QMessageBox::Yes,\n                                     this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        return (dialog.exec() == QMessageBox::Yes);\n    }\n    if (m_encodeDock->isExportInProgress()) {\n        QMessageBox dialog(QMessageBox::Warning,\n                                     qApp->applicationName(),\n                                     tr(\"An export is in progress.\\n\"\n                                        \"Do you want to still want to exit?\"),\n                                     QMessageBox::No |\n                                     QMessageBox::Yes,\n                                     this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        return (dialog.exec() == QMessageBox::Yes);\n    }\n    return true;\n}\n\nQUndoStack* MainWindow::undoStack() const\n{\n    return m_undoStack;\n}\n\nvoid MainWindow::onEncodeTriggered(bool checked)\n{\n    if (checked) {\n        m_encodeDock->show();\n        m_encodeDock->raise();\n    }\n}\n\nvoid MainWindow::onCaptureStateChanged(bool started)\n{\n    if (started && (MLT.resource().startsWith(\"x11grab:\") ||\n                    MLT.resource().startsWith(\"gdigrab:\") ||\n                    MLT.resource().startsWith(\"avfoundation\"))\n                && !MLT.producer()->get_int(kBackgroundCaptureProperty))\n        showMinimized();\n}\n\nvoid MainWindow::onJobsDockTriggered(bool checked)\n{\n    if (checked) {\n        m_jobsDock->show();\n        m_jobsDock->raise();\n    }\n}\n\nvoid MainWindow::onRecentDockTriggered(bool checked)\n{\n    if (checked) {\n        m_recentDock->show();\n        m_recentDock->raise();\n    }\n}\n\nvoid MainWindow::onPropertiesDockTriggered(bool checked)\n{\n    if (checked) {\n        m_propertiesDock->show();\n        m_propertiesDock->raise();\n    }\n}\n\nvoid MainWindow::onPlaylistDockTriggered(bool checked)\n{\n    if (checked) {\n        m_playlistDock->show();\n        m_playlistDock->raise();\n    }\n}\n\nvoid MainWindow::onTimelineDockTriggered(bool checked)\n{\n    if (checked) {\n        m_timelineDock->show();\n        m_timelineDock->raise();\n    }\n}\n\nvoid MainWindow::onHistoryDockTriggered(bool checked)\n{\n    if (checked) {\n        m_historyDock->show();\n        m_historyDock->raise();\n    }\n}\n\nvoid MainWindow::onFiltersDockTriggered(bool checked)\n{\n    if (checked) {\n        m_filtersDock->show();\n        m_filtersDock->raise();\n    }\n}\n\nvoid MainWindow::onKeyframesDockTriggered(bool checked)\n{\n    if (checked) {\n        m_keyframesDock->show();\n        m_keyframesDock->raise();\n    }\n}\n\nvoid MainWindow::onPlaylistCreated()\n{\n    if (!playlist() || playlist()->count() == 0) return;\n    m_player->enableTab(Player::ProjectTabIndex, true);\n}\n\nvoid MainWindow::onPlaylistLoaded()\n{\n    updateMarkers();\n    m_player->enableTab(Player::ProjectTabIndex, true);\n}\n\nvoid MainWindow::onPlaylistCleared()\n{\n    m_player->onTabBarClicked(Player::SourceTabIndex);\n    setWindowModified(true);\n}\n\nvoid MainWindow::onPlaylistClosed()\n{\n    closeProducer();\n    setProfile(Settings.playerProfile());\n    resetVideoModeMenu();\n    setAudioChannels(Settings.playerAudioChannels());\n    setCurrentFile(\"\");\n    setWindowModified(false);\n    m_undoStack->clear();\n    MLT.resetURL();\n    QMutexLocker locker(&m_autosaveMutex);\n    m_autosaveFile.reset(new AutoSaveFile(untitledFileName()));\n    if (!isMultitrackValid())\n        m_player->enableTab(Player::ProjectTabIndex, false);\n}\n\nvoid MainWindow::onPlaylistModified()\n{\n    setWindowModified(true);\n    if (MLT.producer() && playlist() && (void*) MLT.producer()->get_producer() == (void*) playlist()->get_playlist())\n        m_player->onDurationChanged();\n    updateMarkers();\n    m_player->enableTab(Player::ProjectTabIndex, true);\n}\n\nvoid MainWindow::onMultitrackCreated()\n{\n    m_player->enableTab(Player::ProjectTabIndex, true);\n}\n\nvoid MainWindow::onMultitrackClosed()\n{\n    setAudioChannels(Settings.playerAudioChannels());\n    closeProducer();\n    setProfile(Settings.playerProfile());\n    resetVideoModeMenu();\n    setCurrentFile(\"\");\n    setWindowModified(false);\n    m_undoStack->clear();\n    MLT.resetURL();\n    QMutexLocker locker(&m_autosaveMutex);\n    m_autosaveFile.reset(new AutoSaveFile(untitledFileName()));\n    if (!playlist() || playlist()->count() == 0)\n        m_player->enableTab(Player::ProjectTabIndex, false);\n}\n\nvoid MainWindow::onMultitrackModified()\n{\n    setWindowModified(true);\n\n    // Reflect this playlist info onto the producer for keyframes dock.\n    if (!m_timelineDock->selection().isEmpty()) {\n        int trackIndex = m_timelineDock->selection().first().y();\n        int clipIndex = m_timelineDock->selection().first().x();\n        QScopedPointer<Mlt::ClipInfo> info(m_timelineDock->getClipInfo(trackIndex, clipIndex));\n        if (info && info->producer && info->producer->is_valid()) {\n            int expected = info->frame_in;\n            QScopedPointer<Mlt::ClipInfo> info2(m_timelineDock->getClipInfo(trackIndex, clipIndex - 1));\n            if (info2 && info2->producer && info2->producer->is_valid()\n                      && info2->producer->get(kShotcutTransitionProperty)) {\n                // Factor in a transition left of the clip.\n                expected -= info2->frame_count;\n                info->producer->set(kPlaylistStartProperty, info2->start);\n            } else {\n                info->producer->set(kPlaylistStartProperty, info->start);\n            }\n            if (expected != info->producer->get_int(kFilterInProperty)) {\n                int delta = expected - info->producer->get_int(kFilterInProperty);\n                info->producer->set(kFilterInProperty, expected);\n                emit m_filtersDock->producerInChanged(delta);\n            }\n            expected = info->frame_out;\n            info2.reset(m_timelineDock->getClipInfo(trackIndex, clipIndex + 1));\n            if (info2 && info2->producer && info2->producer->is_valid()\n                      && info2->producer->get(kShotcutTransitionProperty)) {\n                // Factor in a transition right of the clip.\n                expected += info2->frame_count;\n            }\n            if (expected != info->producer->get_int(kFilterOutProperty)) {\n                int delta = expected - info->producer->get_int(kFilterOutProperty);\n                info->producer->set(kFilterOutProperty, expected);\n                emit m_filtersDock->producerOutChanged(delta);\n            }\n        }\n    }\n}\n\nvoid MainWindow::onMultitrackDurationChanged()\n{\n    if (MLT.producer() && (void*) MLT.producer()->get_producer() == (void*) multitrack()->get_producer())\n        m_player->onDurationChanged();\n}\n\nvoid MainWindow::onCutModified()\n{\n    if (!playlist() && !multitrack()) {\n        setWindowModified(true);\n        updateAutoSave();\n    }\n    if (playlist())\n        m_playlistDock->setUpdateButtonEnabled(true);\n}\n\nvoid MainWindow::onProducerModified()\n{\n    setWindowModified(true);\n    updateAutoSave();\n}\n\nvoid MainWindow::onFilterModelChanged()\n{\n    MLT.refreshConsumer();\n    setWindowModified(true);\n    updateAutoSave();\n    if (playlist())\n        m_playlistDock->setUpdateButtonEnabled(true);\n}\n\nvoid MainWindow::updateMarkers()\n{\n    if (playlist() && MLT.isPlaylist()) {\n        QList<int> markers;\n        int n = playlist()->count();\n        for (int i = 0; i < n; i++)\n            markers.append(playlist()->clip_start(i));\n        m_player->setMarkers(markers);\n    }\n}\n\nvoid MainWindow::updateThumbnails()\n{\n    if (Settings.playlistThumbnails() != \"hidden\")\n        m_playlistDock->model()->refreshThumbnails();\n}\n\nvoid MainWindow::on_actionUndo_triggered()\n{\n    TimelineSelectionBlocker blocker(*m_timelineDock);\n    m_undoStack->undo();\n}\n\nvoid MainWindow::on_actionRedo_triggered()\n{\n    TimelineSelectionBlocker blocker(*m_timelineDock);\n    m_undoStack->redo();\n}\n\nvoid MainWindow::on_actionFAQ_triggered()\n{\n    QDesktopServices::openUrl(QUrl(\"https://www.shotcut.org/FAQ/\"));\n}\n\nvoid MainWindow::on_actionForum_triggered()\n{\n    QDesktopServices::openUrl(QUrl(\"https://forum.shotcut.org/\"));\n}\n\nbool MainWindow::saveXML(const QString &filename, bool withRelativePaths)\n{\n    bool result;\n    if (m_timelineDock->model()->rowCount() > 0) {\n        result = MLT.saveXML(filename, multitrack(), withRelativePaths);\n    } else if (m_playlistDock->model()->rowCount() > 0) {\n        int in = MLT.producer()->get_in();\n        int out = MLT.producer()->get_out();\n        MLT.producer()->set_in_and_out(0, MLT.producer()->get_length() - 1);\n        result = MLT.saveXML(filename, playlist(), withRelativePaths);\n        MLT.producer()->set_in_and_out(in, out);\n    } else if (MLT.producer()) {\n        result = MLT.saveXML(filename, (MLT.isMultitrack() || MLT.isPlaylist())? MLT.savedProducer() : 0, withRelativePaths);\n    } else {\n        // Save an empty playlist, which is accepted by both MLT and Shotcut.\n        Mlt::Playlist playlist(MLT.profile());\n        result = MLT.saveXML(filename, &playlist, withRelativePaths);\n    }\n    return result;\n}\n\nvoid MainWindow::changeTheme(const QString &theme)\n{\n    LOG_DEBUG() << \"begin\";\n    if (theme == \"dark\") {\n        QApplication::setStyle(\"Fusion\");\n        QPalette palette;\n        palette.setColor(QPalette::Window, QColor(50,50,50));\n        palette.setColor(QPalette::WindowText, QColor(220,220,220));\n        palette.setColor(QPalette::Base, QColor(30,30,30));\n        palette.setColor(QPalette::AlternateBase, QColor(40,40,40));\n        palette.setColor(QPalette::Highlight, QColor(23,92,118));\n        palette.setColor(QPalette::HighlightedText, Qt::white);\n        palette.setColor(QPalette::ToolTipBase, palette.color(QPalette::Highlight));\n        palette.setColor(QPalette::ToolTipText, palette.color(QPalette::WindowText));\n        palette.setColor(QPalette::Text, palette.color(QPalette::WindowText));\n        palette.setColor(QPalette::BrightText, Qt::red);\n        palette.setColor(QPalette::Button, palette.color(QPalette::Window));\n        palette.setColor(QPalette::ButtonText, palette.color(QPalette::WindowText));\n        palette.setColor(QPalette::Link, palette.color(QPalette::Highlight).lighter());\n        palette.setColor(QPalette::LinkVisited, palette.color(QPalette::Highlight));\n        palette.setColor(QPalette::Disabled, QPalette::Text, Qt::darkGray);\n        palette.setColor(QPalette::Disabled, QPalette::ButtonText, Qt::darkGray);\n        QApplication::setPalette(palette);\n        QIcon::setThemeName(\"dark\");\n    } else if (theme == \"light\") {\n        QStyle* style = QStyleFactory::create(\"Fusion\");\n        QApplication::setStyle(style);\n        QApplication::setPalette(style->standardPalette());\n        QIcon::setThemeName(\"light\");\n    } else {\n        QApplication::setStyle(qApp->property(\"system-style\").toString());\n        QIcon::setThemeName(\"oxygen\");\n    }\n    emit QmlApplication::singleton().paletteChanged();\n    LOG_DEBUG() << \"end\";\n}\n\nMlt::Playlist* MainWindow::playlist() const\n{\n    return m_playlistDock->model()->playlist();\n}\n\nbool MainWindow::isPlaylistValid() const\n{\n    return m_playlistDock->model()->playlist()\n        && m_playlistDock->model()->rowCount() > 0;\n}\n\nMlt::Producer *MainWindow::multitrack() const\n{\n    return m_timelineDock->model()->tractor();\n}\n\nbool MainWindow::isMultitrackValid() const\n{\n    return m_timelineDock->model()->tractor()\n       && !m_timelineDock->model()->trackList().empty();\n}\n\nQWidget *MainWindow::loadProducerWidget(Mlt::Producer* producer)\n{\n    QWidget* w = 0;\n    QScrollArea* scrollArea = (QScrollArea*) m_propertiesDock->widget();\n\n    if (!producer || !producer->is_valid()) {\n        if (scrollArea->widget())\n            scrollArea->widget()->deleteLater();\n        return  w;\n    } else {\n        scrollArea->show();\n    }\n\n    QString service(producer->get(\"mlt_service\"));\n    QString resource = QString::fromUtf8(producer->get(\"resource\"));\n    QString shotcutProducer(producer->get(kShotcutProducerProperty));\n\n    if (resource.startsWith(\"video4linux2:\") || QString::fromUtf8(producer->get(\"resource1\")).startsWith(\"video4linux2:\"))\n        w = new Video4LinuxWidget(this);\n    else if (resource.startsWith(\"pulse:\"))\n        w = new PulseAudioWidget(this);\n    else if (resource.startsWith(\"jack:\"))\n        w = new JackProducerWidget(this);\n    else if (resource.startsWith(\"alsa:\"))\n        w = new AlsaWidget(this);\n    else if (resource.startsWith(\"dshow:\") || QString::fromUtf8(producer->get(\"resource1\")).startsWith(\"dshow:\"))\n        w = new DirectShowVideoWidget(this);\n    else if (resource.startsWith(\"avfoundation:\"))\n        w = new AvfoundationProducerWidget(this);\n    else if (resource.startsWith(\"x11grab:\"))\n        w = new X11grabWidget(this);\n    else if (resource.startsWith(\"gdigrab:\"))\n        w = new GDIgrabWidget(this);\n    else if (service.startsWith(\"avformat\") || shotcutProducer == \"avformat\")\n        w = new AvformatProducerWidget(this);\n    else if (MLT.isImageProducer(producer)) {\n        w = new ImageProducerWidget(this);\n        connect(m_player, SIGNAL(outChanged(int)), w, SLOT(updateDuration()));\n    }\n    else if (service == \"decklink\" || resource.contains(\"decklink\"))\n        w = new DecklinkProducerWidget(this);\n    else if (service == \"color\")\n        w = new ColorProducerWidget(this);\n    else if (service == \"noise\")\n        w = new NoiseWidget(this);\n    else if (service == \"frei0r.ising0r\")\n        w = new IsingWidget(this);\n    else if (service == \"frei0r.lissajous0r\")\n        w = new LissajousWidget(this);\n    else if (service == \"frei0r.plasma\")\n        w = new PlasmaWidget(this);\n    else if (service == \"frei0r.test_pat_B\")\n        w = new ColorBarsWidget(this);\n    else if (service == \"webvfx\")\n        w = new WebvfxProducer(this);\n    else if (service == \"tone\")\n        w = new ToneProducerWidget(this);\n    else if (service == \"count\")\n        w = new CountProducerWidget(this);\n    else if (service == \"blipflash\")\n        w = new BlipProducerWidget(this);\n    else if (producer->parent().get(kShotcutTransitionProperty)) {\n        w = new LumaMixTransition(producer->parent(), this);\n        scrollArea->setWidget(w);\n        if (-1 != w->metaObject()->indexOfSignal(\"modified()\"))\n            connect(w, SIGNAL(modified()), SLOT(onProducerModified()));\n        return w;\n    } else if (playlist_type == producer->type()) {\n        int trackIndex = m_timelineDock->currentTrack();\n        bool isBottomVideo = m_timelineDock->model()->data(m_timelineDock->model()->index(trackIndex), MultitrackModel::IsBottomVideoRole).toBool();\n        if (!isBottomVideo) {\n            w = new TrackPropertiesWidget(*producer, this);\n            scrollArea->setWidget(w);\n            return w;\n        }\n    } else if (tractor_type == producer->type()) {\n        w = new TimelinePropertiesWidget(*producer, this);\n        scrollArea->setWidget(w);\n        return w;\n    }\n    if (w) {\n        dynamic_cast<AbstractProducerWidget*>(w)->setProducer(producer);\n        if (-1 != w->metaObject()->indexOfSignal(\"producerChanged(Mlt::Producer*)\")) {\n            connect(w, SIGNAL(producerChanged(Mlt::Producer*)), SLOT(onProducerChanged()));\n            connect(w, SIGNAL(producerChanged(Mlt::Producer*)), m_filterController, SLOT(setProducer(Mlt::Producer*)));\n            connect(w, SIGNAL(producerChanged(Mlt::Producer*)), m_playlistDock, SLOT(onProducerChanged(Mlt::Producer*)));\n            if (producer->get(kMultitrackItemProperty))\n                connect(w, SIGNAL(producerChanged(Mlt::Producer*)), m_timelineDock, SLOT(onProducerChanged(Mlt::Producer*)));\n        }\n        if (-1 != w->metaObject()->indexOfSignal(\"modified()\")) {\n            connect(w, SIGNAL(modified()), SLOT(onProducerModified()));\n            connect(w, SIGNAL(modified()), m_playlistDock, SLOT(onProducerModified()));\n            connect(w, SIGNAL(modified()), m_timelineDock, SLOT(onProducerModified()));\n            connect(w, SIGNAL(modified()), m_keyframesDock, SLOT(onProducerModified()));\n            connect(w, SIGNAL(modified()), m_filterController, SLOT(onProducerChanged()));\n        }\n        if (-1 != w->metaObject()->indexOfSlot(\"updateDuration()\")) {\n            connect(m_timelineDock, SIGNAL(durationChanged()), w, SLOT(updateDuration()));\n        }\n        if (-1 != w->metaObject()->indexOfSlot(\"rename()\")) {\n            connect(this, SIGNAL(renameRequested()), w, SLOT(rename()));\n        }\n        scrollArea->setWidget(w);\n        onProducerChanged();\n    } else if (scrollArea->widget()) {\n        scrollArea->widget()->deleteLater();\n    }\n    return w;\n}\n\nvoid MainWindow::on_actionEnter_Full_Screen_triggered()\n{\n#ifdef Q_OS_WIN\n    bool isFull = isMaximized();\n#else\n    bool isFull = isFullScreen();\n#endif\n    if (isFull) {\n        showNormal();\n        ui->actionEnter_Full_Screen->setText(tr(\"Enter Full Screen\"));\n    } else {\n#ifdef Q_OS_WIN\n        showMaximized();\n#else\n        showFullScreen();\n#endif\n        ui->actionEnter_Full_Screen->setText(tr(\"Enter Full Screen\"));\n    }\n}\n\nvoid MainWindow::onGpuNotSupported()\n{\n    Settings.setPlayerGPU(false);\n    if (ui->actionGPU) {\n        ui->actionGPU->setChecked(false);\n        ui->actionGPU->setDisabled(true);\n    }\n    LOG_WARNING() << \"\";\n    QMessageBox::critical(this, qApp->applicationName(),\n        tr(\"GPU effects are not supported\"));\n}\n\nvoid MainWindow::editHTML(const QString &fileName)\n{\n    bool isNew = !m_htmlEditor;\n    if (isNew) {\n        m_htmlEditor.reset(new HtmlEditor);\n        m_htmlEditor->setWindowIcon(windowIcon());\n    }\n    m_htmlEditor->load(fileName);\n    m_htmlEditor->show();\n    m_htmlEditor->raise();\n\n    bool isExternal = false;\n    int screen = Settings.playerExternal().toInt(&isExternal);\n    isExternal = isExternal && (screen != QApplication::desktop()->screenNumber(this));\n\n    if (!isExternal) {\n        if (Settings.playerZoom() >= 1.0f) {\n            m_htmlEditor->changeZoom(100 * m_player->videoSize().width() / MLT.profile().width());\n            m_htmlEditor->resizeWebView(m_player->videoSize().width(), m_player->videoSize().height());\n        } else {\n            m_htmlEditor->changeZoom(100 * MLT.displayWidth() / MLT.profile().width());\n            m_htmlEditor->resizeWebView(MLT.displayWidth(), MLT.displayHeight());\n        }\n    } else {\n        m_htmlEditor->changeZoom(100);\n    }\n    if (isNew) {\n        // Center the new window over the main window.\n        QPoint point = pos();\n        QPoint halfSize(width(), height());\n        halfSize /= 2;\n        point += halfSize;\n        halfSize = QPoint(m_htmlEditor->width(), m_htmlEditor->height());\n        halfSize /= 2;\n        point -= halfSize;\n        m_htmlEditor->move(point);\n    }\n}\n\nvoid MainWindow::stepLeftOneFrame()\n{\n    m_player->seek(m_player->position() - 1);\n}\n\nvoid MainWindow::stepRightOneFrame()\n{\n    m_player->seek(m_player->position() + 1);\n}\n\nvoid MainWindow::stepLeftOneSecond()\n{\n    stepLeftBySeconds(-1);\n}\n\nvoid MainWindow::stepRightOneSecond()\n{\n    stepLeftBySeconds(1);\n}\n\nvoid MainWindow::setInToCurrent(bool ripple)\n{\n    if (m_player->tabIndex() == Player::ProjectTabIndex && isMultitrackValid()) {\n        m_timelineDock->trimClipAtPlayhead(TimelineDock::TrimInPoint, ripple);\n    } else if (MLT.isSeekable() && MLT.isClip()) {\n        m_player->setIn(m_player->position());\n        int delta = m_player->position() - MLT.producer()->get_in();\n        emit m_player->inChanged(delta);\n    }\n}\n\nvoid MainWindow::setOutToCurrent(bool ripple)\n{\n    if (m_player->tabIndex() == Player::ProjectTabIndex && isMultitrackValid()) {\n        m_timelineDock->trimClipAtPlayhead(TimelineDock::TrimOutPoint, ripple);\n    } else if (MLT.isSeekable() && MLT.isClip()) {\n        m_player->setOut(m_player->position());\n        int delta = m_player->position() - MLT.producer()->get_out();\n        emit m_player->outChanged(delta);\n    }\n}\n\nvoid MainWindow::onShuttle(float x)\n{\n    if (x == 0) {\n        m_player->pause();\n    } else if (x > 0) {\n        m_player->play(10.0 * x);\n    } else {\n        m_player->play(20.0 * x);\n    }\n}\n\nvoid MainWindow::showUpgradePrompt()\n{\n    if (Settings.checkUpgradeAutomatic()) {\n        showStatusMessage(\"Checking for upgrade...\");\n        QNetworkRequest request(QUrl(\"https://check.shotcut.org/version.json\"));\n        QSslConfiguration sslConfig = request.sslConfiguration();\n        sslConfig.setPeerVerifyMode(QSslSocket::VerifyNone);\n        request.setSslConfiguration(sslConfig);\n        m_network.get(request);\n    } else {\n        m_network.setStrictTransportSecurityEnabled(false);\n        QAction* action = new QAction(tr(\"Click here to check for a new version of Shotcut.\"), 0);\n        connect(action, SIGNAL(triggered(bool)), SLOT(on_actionUpgrade_triggered()));\n        showStatusMessage(action, 15 /* seconds */);\n    }\n}\n\nvoid MainWindow::on_actionRealtime_triggered(bool checked)\n{\n    Settings.setPlayerRealtime(checked);\n    if (Settings.playerGPU())\n        MLT.pause();\n    if (MLT.consumer()) {\n        MLT.restart();\n    }\n\n}\n\nvoid MainWindow::on_actionProgressive_triggered(bool checked)\n{\n    MLT.videoWidget()->setProperty(\"progressive\", checked);\n    if (Settings.playerGPU())\n        MLT.pause();\n    if (MLT.consumer()) {\n        MLT.profile().set_progressive(checked);\n        MLT.updatePreviewProfile();\n        MLT.restart();\n    }\n    Settings.setPlayerProgressive(checked);\n}\n\nvoid MainWindow::changeAudioChannels(bool checked, int channels)\n{\n    if( checked ) {\n        Settings.setPlayerAudioChannels(channels);\n        setAudioChannels(Settings.playerAudioChannels());\n    }\n}\n\nvoid MainWindow::on_actionChannels1_triggered(bool checked)\n{\n    changeAudioChannels(checked, 1);\n}\n\nvoid MainWindow::on_actionChannels2_triggered(bool checked)\n{\n    changeAudioChannels(checked, 2);\n}\n\nvoid MainWindow::on_actionChannels6_triggered(bool checked)\n{\n    changeAudioChannels(checked, 6);\n}\n\nvoid MainWindow::changeDeinterlacer(bool checked, const char* method)\n{\n    if (checked) {\n        MLT.videoWidget()->setProperty(\"deinterlace_method\", method);\n        if (MLT.consumer()) {\n            MLT.consumer()->set(\"deinterlace_method\", method);\n            MLT.refreshConsumer();\n        }\n    }\n    Settings.setPlayerDeinterlacer(method);\n}\n\nvoid MainWindow::on_actionOneField_triggered(bool checked)\n{\n    changeDeinterlacer(checked, \"onefield\");\n}\n\nvoid MainWindow::on_actionLinearBlend_triggered(bool checked)\n{\n    changeDeinterlacer(checked, \"linearblend\");\n}\n\nvoid MainWindow::on_actionYadifTemporal_triggered(bool checked)\n{\n    changeDeinterlacer(checked, \"yadif-nospatial\");\n}\n\nvoid MainWindow::on_actionYadifSpatial_triggered(bool checked)\n{\n    changeDeinterlacer(checked, \"yadif\");\n}\n\nvoid MainWindow::changeInterpolation(bool checked, const char* method)\n{\n    if (checked) {\n        MLT.videoWidget()->setProperty(\"rescale\", method);\n        if (MLT.consumer()) {\n            MLT.consumer()->set(\"rescale\", method);\n            MLT.refreshConsumer();\n        }\n    }\n    Settings.setPlayerInterpolation(method);\n}\n\nvoid MainWindow::processMultipleFiles()\n{\n    if (m_multipleFiles.length() <= 0)\n        return;\n    QStringList multipleFiles = m_multipleFiles;\n    m_multipleFiles.clear();\n    int count = multipleFiles.length();\n    if (count > 1) {\n        LongUiTask longTask(tr(\"Open Files\"));\n        m_playlistDock->show();\n        m_playlistDock->raise();\n        for (int i = 0; i < count; i++) {\n            QString filename = multipleFiles.takeFirst();\n            LOG_DEBUG() << filename;\n            longTask.reportProgress(QFileInfo(filename).fileName(), i, count);\n            Mlt::Producer p(MLT.profile(), filename.toUtf8().constData());\n            if (p.is_valid()) {\n                // Convert avformat to avformat-novalidate so that XML loads faster.\n                if (!qstrcmp(p.get(\"mlt_service\"), \"avformat\")) {\n                    p.set(\"mlt_service\", \"avformat-novalidate\");\n                    p.set(\"mute_on_pause\", 0);\n                }\n                if (QDir::toNativeSeparators(filename) == QDir::toNativeSeparators(MAIN.fileName())) {\n                    MAIN.showStatusMessage(QObject::tr(\"You cannot add a project to itself!\"));\n                    continue;\n                }\n                MLT.setImageDurationFromDefault(&p);\n                MLT.lockCreationTime(&p);\n                p.get_length_time(mlt_time_clock);\n                Util::getHash(p);\n                ProxyManager::generateIfNotExists(p);\n                undoStack()->push(new Playlist::AppendCommand(*m_playlistDock->model(), MLT.XML(&p), false));\n                m_recentDock->add(filename.toUtf8().constData());\n            }\n        }\n        emit m_playlistDock->model()->modified();\n    }\n    if (m_isPlaylistLoaded && Settings.playerGPU()) {\n        updateThumbnails();\n        m_isPlaylistLoaded = false;\n    }\n}\n\nvoid MainWindow::onLanguageTriggered(QAction* action)\n{\n    Settings.setLanguage(action->data().toString());\n    QMessageBox dialog(QMessageBox::Information,\n                       qApp->applicationName(),\n                       tr(\"You must restart Shotcut to switch to the new language.\\n\"\n                          \"Do you want to restart now?\"),\n                       QMessageBox::No | QMessageBox::Yes,\n                       this);\n    dialog.setDefaultButton(QMessageBox::Yes);\n    dialog.setEscapeButton(QMessageBox::No);\n    dialog.setWindowModality(QmlApplication::dialogModality());\n    if (dialog.exec() == QMessageBox::Yes) {\n        m_exitCode = EXIT_RESTART;\n        QApplication::closeAllWindows();\n    }\n}\n\nvoid MainWindow::on_actionNearest_triggered(bool checked)\n{\n    changeInterpolation(checked, \"nearest\");\n}\n\nvoid MainWindow::on_actionBilinear_triggered(bool checked)\n{\n    changeInterpolation(checked, \"bilinear\");\n}\n\nvoid MainWindow::on_actionBicubic_triggered(bool checked)\n{\n    changeInterpolation(checked, \"bicubic\");\n}\n\nvoid MainWindow::on_actionHyper_triggered(bool checked)\n{\n    changeInterpolation(checked, \"hyper\");\n}\n\nvoid MainWindow::on_actionJack_triggered(bool checked)\n{\n    Settings.setPlayerJACK(checked);\n    if (!MLT.enableJack(checked)) {\n        if (ui->actionJack)\n            ui->actionJack->setChecked(false);\n        Settings.setPlayerJACK(false);\n        QMessageBox::warning(this, qApp->applicationName(),\n            tr(\"Failed to connect to JACK.\\nPlease verify that JACK is installed and running.\"));\n    }\n}\n\nvoid MainWindow::on_actionGPU_triggered(bool checked)\n{\n    if (checked) {\n        QMessageBox dialog(QMessageBox::Warning,\n                           qApp->applicationName(),\n                           tr(\"GPU effects are experimental and may cause instability on some systems. \"\n                              \"Some CPU effects are incompatible with GPU effects and will be disabled. \"\n                              \"A project created with GPU effects can not be converted to a CPU only project later.\"\n                              \"\\n\\n\"\n                              \"Do you want to enable GPU effects and restart Shotcut?\"),\n                           QMessageBox::No | QMessageBox::Yes,\n                           this);\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        if (dialog.exec() == QMessageBox::Yes) {\n            m_exitCode = EXIT_RESTART;\n            QApplication::closeAllWindows();\n        }\n        else {\n            ui->actionGPU->setChecked(false);\n        }\n    }\n    else\n    {\n        QMessageBox dialog(QMessageBox::Information,\n                           qApp->applicationName(),\n                           tr(\"Shotcut must restart to disable GPU effects.\"\n                              \"\\n\\n\"\n                              \"Disable GPU effects and restart?\"),\n                           QMessageBox::No | QMessageBox::Yes,\n                           this);\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        if (dialog.exec() == QMessageBox::Yes) {\n            m_exitCode = EXIT_RESTART;\n            QApplication::closeAllWindows();\n        }\n        else {\n            ui->actionGPU->setChecked(true);\n        }\n    }\n}\n\nvoid MainWindow::onExternalTriggered(QAction *action)\n{\n    LOG_DEBUG() << action->data().toString();\n    bool isExternal = !action->data().toString().isEmpty();\n    Settings.setPlayerExternal(action->data().toString());\n    MLT.stop();\n    bool ok = false;\n    int screen = action->data().toInt(&ok);\n    if (ok || action->data().toString().isEmpty()) {\n        m_player->moveVideoToScreen(ok? screen : -2);\n        isExternal = false;\n        MLT.videoWidget()->setProperty(\"mlt_service\", QVariant());\n    } else {\n        m_player->moveVideoToScreen(-2);\n        MLT.videoWidget()->setProperty(\"mlt_service\", action->data());\n    }\n\n    QString profile = Settings.playerProfile();\n    // Automatic not permitted for SDI/HDMI\n    if (isExternal && profile.isEmpty()) {\n        profile = \"atsc_720p_50\";\n        Settings.setPlayerProfile(profile);\n        setProfile(profile);\n        MLT.restart();\n        foreach (QAction* a, m_profileGroup->actions()) {\n            if (a->data() == profile) {\n                a->setChecked(true);\n                break;\n            }\n        }\n    }\n    else {\n        MLT.consumerChanged();\n    }\n    // Automatic not permitted for SDI/HDMI\n    m_profileGroup->actions().at(0)->setEnabled(!isExternal);\n\n    // Disable progressive option when SDI/HDMI\n    ui->actionProgressive->setEnabled(!isExternal);\n    bool isProgressive = isExternal\n            ? MLT.profile().progressive()\n            : ui->actionProgressive->isChecked();\n    MLT.videoWidget()->setProperty(\"progressive\", isProgressive);\n    if (MLT.consumer()) {\n        MLT.consumer()->set(\"progressive\", isProgressive);\n        MLT.restart();\n    }\n    if (m_keyerMenu)\n        m_keyerMenu->setEnabled(action->data().toString().startsWith(\"decklink\"));\n\n#if LIBMLT_VERSION_INT >= MLT_VERSION_PREVIEW_SCALE\n    // Preview scaling not permitted for SDI/HDMI\n    if (isExternal) {\n        setPreviewScale(0);\n        m_previewScaleGroup->setEnabled(false);\n    } else {\n        setPreviewScale(Settings.playerPreviewScale());\n        m_previewScaleGroup->setEnabled(true);\n    }\n#endif\n}\n\nvoid MainWindow::onKeyerTriggered(QAction *action)\n{\n    LOG_DEBUG() << action->data().toString();\n    MLT.videoWidget()->setProperty(\"keyer\", action->data());\n    MLT.consumerChanged();\n    Settings.setPlayerKeyerMode(action->data().toInt());\n}\n\nvoid MainWindow::onProfileTriggered(QAction *action)\n{\n    Settings.setPlayerProfile(action->data().toString());\n    if (MLT.producer() && MLT.producer()->is_valid()) {\n        // Save the XML to get correct in/out points before profile is changed.\n        QString xml = MLT.XML();\n        setProfile(action->data().toString());\n        MLT.restart(xml);\n        onProducerOpened(false);\n    } else {\n        setProfile(action->data().toString());\n    }\n}\n\nvoid MainWindow::onProfileChanged()\n{\n    if (multitrack() && MLT.isMultitrack() &&\n       (m_timelineDock->selection().isEmpty() || m_timelineDock->currentTrack() == -1)) {\n        emit m_timelineDock->selected(multitrack());\n    }\n}\n\nvoid MainWindow::on_actionAddCustomProfile_triggered()\n{\n    QString xml;\n    if (MLT.producer() && MLT.producer()->is_valid()) {\n        // Save the XML to get correct in/out points before profile is changed.\n        xml = MLT.XML();\n    }\n    CustomProfileDialog dialog(this);\n    dialog.setWindowModality(QmlApplication::dialogModality());\n    if (dialog.exec() == QDialog::Accepted) {\n        QString name = dialog.profileName();\n        if (!name.isEmpty()) {\n            addCustomProfile(name, customProfileMenu(), actionProfileRemove(), profileGroup());\n        } else if (m_profileGroup->checkedAction()) {\n            m_profileGroup->checkedAction()->setChecked(false);\n        }\n        // Use the new profile.\n        emit profileChanged();\n        if (!xml.isEmpty()) {\n            MLT.restart(xml);\n            onProducerOpened(false);\n        }\n    }\n}\n\nvoid MainWindow::on_actionSystemTheme_triggered()\n{\n    changeTheme(\"system\");\n    QApplication::setPalette(QApplication::style()->standardPalette());\n    Settings.setTheme(\"system\");\n}\n\nvoid MainWindow::on_actionFusionDark_triggered()\n{\n    changeTheme(\"dark\");\n    Settings.setTheme(\"dark\");\n    ui->mainToolBar->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);\n}\n\nvoid MainWindow::on_actionFusionLight_triggered()\n{\n    changeTheme(\"light\");\n    Settings.setTheme(\"light\");\n    ui->mainToolBar->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);\n}\n\nvoid MainWindow::on_actionTutorials_triggered()\n{\n    QDesktopServices::openUrl(QUrl(\"https://www.shotcut.org/tutorials/\"));\n}\n\nvoid MainWindow::on_actionRestoreLayout_triggered()\n{\n    restoreGeometry(Settings.windowGeometryDefault());\n    restoreState(Settings.windowStateDefault());\n    on_actionLayoutTimeline_triggered();\n    ui->actionShowTitleBars->setChecked(true);\n    on_actionShowTitleBars_triggered(true);\n    ui->actionShowTextUnderIcons->setChecked(true);\n    on_actionShowTextUnderIcons_toggled(true);\n    ui->actionShowSmallIcons->setChecked(false);\n    on_actionShowSmallIcons_toggled(false);\n}\n\nvoid MainWindow::on_actionShowTitleBars_triggered(bool checked)\n{\n    QList <QDockWidget *> docks = findChildren<QDockWidget *>();\n    for (int i = 0; i < docks.count(); i++) {\n        QDockWidget* dock = docks.at(i);\n        if (checked) {\n            dock->setTitleBarWidget(0);\n        } else {\n            if (!dock->isFloating()) {\n                dock->setTitleBarWidget(new QWidget);\n            }\n        }\n    }\n    Settings.setShowTitleBars(checked);\n}\n\nvoid MainWindow::on_actionShowToolbar_triggered(bool checked)\n{\n    ui->mainToolBar->setVisible(checked);\n}\n\nvoid MainWindow::onToolbarVisibilityChanged(bool visible)\n{\n    ui->actionShowToolbar->setChecked(visible);\n    Settings.setShowToolBar(visible);\n}\n\nvoid MainWindow::on_menuExternal_aboutToShow()\n{\n    foreach (QAction* action, m_externalGroup->actions()) {\n        bool ok = false;\n        int i = action->data().toInt(&ok);\n        if (ok) {\n            if (i == QApplication::desktop()->screenNumber(this)) {\n                if (action->isChecked()) {\n                    m_externalGroup->actions().first()->setChecked(true);\n                    Settings.setPlayerExternal(QString());\n                }\n                action->setDisabled(true);\n            }  else {\n                action->setEnabled(true);\n            }\n        }\n    }\n}\n\nvoid MainWindow::on_actionUpgrade_triggered()\n{\n    if (Settings.askUpgradeAutmatic()) {\n        QMessageBox dialog(QMessageBox::Question,\n           qApp->applicationName(),\n           tr(\"Do you want to automatically check for updates in the future?\"),\n           QMessageBox::No |\n           QMessageBox::Yes,\n           this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        dialog.setCheckBox(new QCheckBox(tr(\"Do not show this anymore.\", \"Automatic upgrade check dialog\")));\n        Settings.setCheckUpgradeAutomatic(dialog.exec() == QMessageBox::Yes);\n        if (dialog.checkBox()->isChecked())\n            Settings.setAskUpgradeAutomatic(false);\n    }\n    showStatusMessage(\"Checking for upgrade...\");\n    m_network.get(QNetworkRequest(QUrl(\"http://check.shotcut.org/version.json\")));\n}\n\nvoid MainWindow::on_actionOpenXML_triggered()\n{\n    QString path = Settings.openPath();\n#ifdef Q_OS_MAC\n    path.append(\"/*\");\n#endif\n    QStringList filenames = QFileDialog::getOpenFileNames(this, tr(\"Open File\"), path,\n        tr(\"MLT XML (*.mlt);;All Files (*)\"));\n    if (filenames.length() > 0) {\n        QString url = filenames.first();\n        MltXmlChecker checker;\n        if (checker.check(url)) {\n            if (!isCompatibleWithGpuMode(checker))\n                return;\n            isXmlRepaired(checker, url);\n            // Check if the locale usage differs.\n            // Get current locale.\n            QString localeName = QString(::setlocale(MLT_LC_CATEGORY, nullptr)).toUpper();\n            // Test if it is C or POSIX.\n            bool currentlyUsingLocale = (localeName != \"\" && localeName != \"C\" && localeName != \"POSIX\");\n            if (currentlyUsingLocale != checker.usesLocale()) {\n                // Show a warning dialog and cancel if requested.\n                QMessageBox dialog(QMessageBox::Question,\n                   qApp->applicationName(),\n                   tr(\"The decimal point of the MLT XML file\\nyou want to open is incompatible.\\n\\n\"\n                      \"Do you want to continue to open this MLT XML file?\"),\n                   QMessageBox::No |\n                   QMessageBox::Yes,\n                   this);\n                dialog.setWindowModality(QmlApplication::dialogModality());\n                dialog.setDefaultButton(QMessageBox::No);\n                dialog.setEscapeButton(QMessageBox::No);\n                if (dialog.exec() != QMessageBox::Yes)\n                    return;\n            }\n        }\n        Settings.setOpenPath(QFileInfo(url).path());\n        activateWindow();\n        if (filenames.length() > 1)\n            m_multipleFiles = filenames;\n        if (!MLT.openXML(url)) {\n            open(MLT.producer());\n            m_recentDock->add(url);\n            LOG_INFO() << url;\n        }\n        else {\n            showStatusMessage(tr(\"Failed to open \") + url);\n            emit openFailed(url);\n        }\n    }\n}\n\nvoid MainWindow::on_actionGammaSRGB_triggered(bool checked)\n{\n    Q_UNUSED(checked)\n    Settings.setPlayerGamma(\"iec61966_2_1\");\n    MLT.restart();\n    MLT.refreshConsumer();\n}\n\nvoid MainWindow::on_actionGammaRec709_triggered(bool checked)\n{\n    Q_UNUSED(checked)\n    Settings.setPlayerGamma(\"bt709\");\n    MLT.restart();\n    MLT.refreshConsumer();\n}\n\nvoid MainWindow::onFocusChanged(QWidget *, QWidget * ) const\n{\n    LOG_DEBUG() << \"Focuswidget changed\";\n    LOG_DEBUG() << \"Current focusWidget:\" << QApplication::focusWidget();\n    LOG_DEBUG() << \"Current focusObject:\" << QApplication::focusObject();\n    LOG_DEBUG() << \"Current focusWindow:\" << QApplication::focusWindow();\n}\n\nvoid MainWindow::on_actionScrubAudio_triggered(bool checked)\n{\n    Settings.setPlayerScrubAudio(checked);\n}\n\n#if !defined(Q_OS_MAC)\nvoid MainWindow::onDrawingMethodTriggered(QAction *action)\n{\n    Settings.setDrawMethod(action->data().toInt());\n    QMessageBox dialog(QMessageBox::Information,\n                       qApp->applicationName(),\n                       tr(\"You must restart Shotcut to change the display method.\\n\"\n                          \"Do you want to restart now?\"),\n                       QMessageBox::No | QMessageBox::Yes,\n                       this);\n    dialog.setDefaultButton(QMessageBox::Yes);\n    dialog.setEscapeButton(QMessageBox::No);\n    dialog.setWindowModality(QmlApplication::dialogModality());\n    if (dialog.exec() == QMessageBox::Yes) {\n        m_exitCode = EXIT_RESTART;\n        QApplication::closeAllWindows();\n    }\n}\n#endif\n\nvoid MainWindow::on_actionApplicationLog_triggered()\n{\n    TextViewerDialog dialog(this);\n    QDir dir = Settings.appDataLocation();\n    QFile logFile(dir.filePath(\"shotcut-log.txt\"));\n    logFile.open(QIODevice::ReadOnly | QIODevice::Text);\n    dialog.setText(logFile.readAll());\n    logFile.close();\n    dialog.setWindowTitle(tr(\"Application Log\"));\n    dialog.exec();\n}\n\nvoid MainWindow::on_actionClose_triggered()\n{\n    if (continueModified()) {\n        LOG_DEBUG() << \"\";\n        MLT.setProjectFolder(QString());\n        MLT.stop();\n        if (multitrack())\n            m_timelineDock->model()->close();\n        if (playlist())\n            m_playlistDock->model()->close();\n        else\n            onMultitrackClosed();\n        m_player->enableTab(Player::SourceTabIndex, false);\n        MLT.purgeMemoryPool();\n        MLT.resetLocale();\n    }\n}\n\nvoid MainWindow::onPlayerTabIndexChanged(int index)\n{\n    if (Player::SourceTabIndex == index)\n        m_timelineDock->saveAndClearSelection();\n    else\n        m_timelineDock->restoreSelection();\n}\n\nvoid MainWindow::onUpgradeCheckFinished(QNetworkReply* reply)\n{\n    if (!reply->error()) {\n        QByteArray response = reply->readAll();\n        LOG_DEBUG() << \"response: \" << response;\n        QJsonDocument json = QJsonDocument::fromJson(response);\n        QString current = qApp->applicationVersion();\n\n        if (!json.isNull() && json.object().value(\"version_string\").type() == QJsonValue::String) {\n            QString latest = json.object().value(\"version_string\").toString();\n            if (current != \"adhoc\" && QVersionNumber::fromString(current) < QVersionNumber::fromString(latest)) {\n                QAction* action = new QAction(tr(\"Shotcut version %1 is available! Click here to get it.\").arg(latest), 0);\n                connect(action, SIGNAL(triggered(bool)), SLOT(onUpgradeTriggered()));\n                if (!json.object().value(\"url\").isUndefined())\n                    m_upgradeUrl = json.object().value(\"url\").toString();\n                showStatusMessage(action, 15 /* seconds */);\n            } else {\n                showStatusMessage(tr(\"You are running the latest version of Shotcut.\"));\n            }\n            reply->deleteLater();\n            return;\n        } else {\n            LOG_WARNING() << \"failed to parse version.json\";\n        }\n    } else {\n        LOG_WARNING() << reply->errorString();\n    }\n    QAction* action = new QAction(tr(\"Failed to read version.json when checking. Click here to go to the Web site.\"), 0);\n    connect(action, SIGNAL(triggered(bool)), SLOT(onUpgradeTriggered()));\n    showStatusMessage(action);\n    reply->deleteLater();\n}\n\nvoid MainWindow::onUpgradeTriggered()\n{\n    QDesktopServices::openUrl(QUrl(m_upgradeUrl));\n}\n\nvoid MainWindow::onTimelineSelectionChanged()\n{\n    bool enable = (m_timelineDock->selection().size() > 0);\n    ui->actionCut->setEnabled(enable);\n    ui->actionCopy->setEnabled(enable);\n}\n\nvoid MainWindow::on_actionCut_triggered()\n{\n    m_timelineDock->show();\n    m_timelineDock->raise();\n    m_timelineDock->removeSelection(true);\n}\n\nvoid MainWindow::on_actionCopy_triggered()\n{\n    m_timelineDock->show();\n    m_timelineDock->raise();\n    if (!m_timelineDock->selection().isEmpty())\n        m_timelineDock->copyClip(m_timelineDock->selection().first().y(), m_timelineDock->selection().first().x());\n}\n\nvoid MainWindow::on_actionPaste_triggered()\n{\n    m_timelineDock->show();\n    m_timelineDock->raise();\n    m_timelineDock->insert(-1);\n}\n\nvoid MainWindow::onClipCopied()\n{\n    m_player->enableTab(Player::SourceTabIndex);\n}\n\nvoid MainWindow::on_actionExportEDL_triggered()\n{\n    // Dialog to get export file name.\n    QString path = Settings.savePath();\n    QString caption = tr(\"Export EDL\");\n    QString saveFileName = QFileDialog::getSaveFileName(this, caption, path, tr(\"EDL (*.edl);;All Files (*)\"));\n    if (!saveFileName.isEmpty()) {\n        QFileInfo fi(saveFileName);\n        if (fi.suffix() != \"edl\")\n            saveFileName += \".edl\";\n\n        if (Util::warnIfNotWritable(saveFileName, this, caption))\n            return;\n\n        // Locate the JavaScript file in the filesystem.\n        QDir qmlDir = QmlUtilities::qmlDir();\n        qmlDir.cd(\"export-edl\");\n        QString jsFileName = qmlDir.absoluteFilePath(\"export-edl.js\");\n        QFile scriptFile(jsFileName);\n        if (scriptFile.open(QIODevice::ReadOnly)) {\n            // Read JavaScript into a string.\n            QTextStream stream(&scriptFile);\n            stream.setCodec(\"UTF-8\");\n            stream.setAutoDetectUnicode(true);\n            QString contents = stream.readAll();\n            scriptFile.close();\n\n            // Evaluate JavaScript.\n            QJSEngine jsEngine;\n            QJSValue result = jsEngine.evaluate(contents, jsFileName);\n            if (!result.isError()) {\n                // Call the JavaScript main function.\n                QJSValue options = jsEngine.newObject();\n                options.setProperty(\"useBaseNameForReelName\", true);\n                options.setProperty(\"useBaseNameForClipComment\", true);\n                options.setProperty(\"channelsAV\", \"AA/V\");\n                QJSValueList args;\n                args << MLT.XML(0, true, true) << options;\n                result = result.call(args);\n                if (!result.isError()) {\n                    // Save the result with the export file name.\n                    QFile f(saveFileName);\n                    f.open(QIODevice::WriteOnly | QIODevice::Text);\n                    f.write(result.toString().toLatin1());\n                    f.close();\n                }\n            }\n            if (result.isError()) {\n                LOG_ERROR() << \"Uncaught exception at line\"\n                            << result.property(\"lineNumber\").toInt()\n                            << \":\" << result.toString();\n                showStatusMessage(tr(\"A JavaScript error occurred during export.\"));\n            }\n        } else {\n            showStatusMessage(tr(\"Failed to open export-edl.js\"));\n        }\n    }\n}\n\nvoid MainWindow::on_actionExportFrame_triggered()\n{\n    if (Settings.playerGPU() || Settings.playerPreviewScale()) {\n        Mlt::GLWidget* glw = qobject_cast<Mlt::GLWidget*>(MLT.videoWidget());\n        connect(glw, SIGNAL(imageReady()), SLOT(onGLWidgetImageReady()));\n        MLT.setPreviewScale(0);\n        glw->requestImage();\n        MLT.refreshConsumer();\n    } else {\n        onGLWidgetImageReady();\n    }\n}\n\nvoid MainWindow::onGLWidgetImageReady()\n{\n    Mlt::GLWidget* glw = qobject_cast<Mlt::GLWidget*>(MLT.videoWidget());\n    QImage image = glw->image();\n    if (Settings.playerGPU() || Settings.playerPreviewScale()) {\n        disconnect(glw, SIGNAL(imageReady()), this, 0);\n        MLT.setPreviewScale(Settings.playerPreviewScale());\n    }\n    if (!image.isNull()) {\n        QString path = Settings.savePath();\n        QString caption = tr(\"Export Frame\");\n        QString nameFilter = tr(\"PNG (*.png);;BMP (*.bmp);;JPEG (*.jpg *.jpeg);;PPM (*.ppm);;TIFF (*.tif *.tiff);;WebP (*.webp);;All Files (*)\");\n        QString saveFileName = QFileDialog::getSaveFileName(this, caption, path, nameFilter);\n        if (!saveFileName.isEmpty()) {\n            QFileInfo fi(saveFileName);\n            if (fi.suffix().isEmpty())\n                saveFileName += \".png\";\n            if (Util::warnIfNotWritable(saveFileName, this, caption))\n                return;\n            // Convert to square pixels if needed.\n            qreal aspectRatio = (qreal) image.width() / image.height();\n            if (qFloor(aspectRatio * 1000) != qFloor(MLT.profile().dar() * 1000)) {\n                image = image.scaled(qRound(image.height() * MLT.profile().dar()), image.height(),\n                                     Qt::IgnoreAspectRatio, Qt::SmoothTransformation);\n            }\n            image.save(saveFileName, Q_NULLPTR,\n                (QFileInfo(saveFileName).suffix() == \"webp\")? 80 : -1);\n            Settings.setSavePath(fi.path());\n            m_recentDock->add(saveFileName);\n        }\n    } else {\n        showStatusMessage(tr(\"Unable to export frame.\"));\n    }\n}\n\nvoid MainWindow::on_actionAppDataSet_triggered()\n{\n    QMessageBox dialog(QMessageBox::Information,\n                       qApp->applicationName(),\n                       tr(\"You must restart Shotcut to change the data directory.\\n\"\n                          \"Do you want to continue?\"),\n                       QMessageBox::No | QMessageBox::Yes,\n                       this);\n    dialog.setDefaultButton(QMessageBox::Yes);\n    dialog.setEscapeButton(QMessageBox::No);\n    dialog.setWindowModality(QmlApplication::dialogModality());\n    if (dialog.exec() != QMessageBox::Yes) return;\n\n    QString dirName = QFileDialog::getExistingDirectory(this, tr(\"Data Directory\"), Settings.appDataLocation());\n    if (!dirName.isEmpty()) {\n        // Move the data files.\n        QDirIterator it(Settings.appDataLocation());\n        while (it.hasNext()) {\n            if (!it.filePath().isEmpty() && it.fileName() != \".\" && it.fileName() != \"..\") {\n                if (!QFile::exists(dirName + \"/\" + it.fileName())) {\n                    if (it.fileInfo().isDir()) {\n                        if (!QFile::rename(it.filePath(), dirName + \"/\" + it.fileName()))\n                            LOG_WARNING() << \"Failed to move\" << it.filePath() << \"to\" << dirName + \"/\" + it.fileName();\n                    } else {\n                        if (!QFile::copy(it.filePath(), dirName + \"/\" + it.fileName()))\n                            LOG_WARNING() << \"Failed to copy\" << it.filePath() << \"to\" << dirName + \"/\" + it.fileName();\n                    }\n                }\n            }\n            it.next();\n        }\n        writeSettings();\n        Settings.setAppDataLocally(dirName);\n\n        m_exitCode = EXIT_RESTART;\n        QApplication::closeAllWindows();\n    }\n}\n\nvoid MainWindow::on_actionAppDataShow_triggered()\n{\n    Util::showInFolder(Settings.appDataLocation());\n}\n\nvoid MainWindow::on_actionNew_triggered()\n{\n    on_actionClose_triggered();\n}\n\nvoid MainWindow::on_actionKeyboardShortcuts_triggered()\n{\n    QDesktopServices::openUrl(QUrl(\"https://www.shotcut.org/howtos/keyboard-shortcuts/\"));\n}\n\nvoid MainWindow::on_actionLayoutPlayer_triggered()\n{\n    restoreState(Settings.windowStateDefault());\n}\n\nvoid MainWindow::on_actionLayoutPlaylist_triggered()\n{\n    restoreState(Settings.windowStateDefault());\n    m_recentDock->show();\n    m_recentDock->raise();\n    m_playlistDock->show();\n    m_playlistDock->raise();\n}\n\nvoid MainWindow::on_actionLayoutTimeline_triggered()\n{\n    restoreState(Settings.windowStateDefault());\n    QDockWidget* audioMeterDock = findChild<QDockWidget*>(\"AudioPeakMeterDock\");\n    if (audioMeterDock) {\n        audioMeterDock->show();\n        audioMeterDock->raise();\n    }\n    m_recentDock->show();\n    m_recentDock->raise();\n    m_filtersDock->show();\n    m_filtersDock->raise();\n    m_timelineDock->show();\n    m_timelineDock->raise();\n}\n\nvoid MainWindow::on_actionLayoutClip_triggered()\n{\n    restoreState(Settings.windowStateDefault());\n    m_recentDock->show();\n    m_recentDock->raise();\n    m_filtersDock->show();\n    m_filtersDock->raise();\n}\n\nvoid MainWindow::on_actionLayoutAdd_triggered()\n{\n    bool ok;\n    QString name = QInputDialog::getText(this, tr(\"Add Custom Layout\"),\n                                         tr(\"Name\"), QLineEdit::Normal,\n                                         \"\", &ok);\n    if (ok && !name.isEmpty()) {\n        if (Settings.setLayout(name, saveGeometry(), saveState())) {\n            Settings.sync();\n            if (Settings.layouts().size() == 1) {\n                ui->menuLayout->addAction(ui->actionLayoutRemove);\n                ui->menuLayout->addSeparator();\n            }\n            ui->menuLayout->addAction(addLayout(m_layoutGroup, name));\n        }\n    }\n}\n\nvoid MainWindow::onLayoutTriggered(QAction* action)\n{\n    restoreGeometry(Settings.layoutGeometry(action->text()));\n    restoreState(Settings.layoutState(action->text()));\n}\n\nvoid MainWindow::on_actionProfileRemove_triggered()\n{\n    QDir dir(Settings.appDataLocation());\n    if (dir.cd(\"profiles\")) {\n        // Setup the dialog.\n        QStringList profiles = dir.entryList(QDir::Files | QDir::NoDotAndDotDot | QDir::Readable);\n        ListSelectionDialog dialog(profiles, this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setWindowTitle(tr(\"Remove Video Mode\"));\n\n        // Show the dialog.\n        if (dialog.exec() == QDialog::Accepted) {\n            removeCustomProfiles(dialog.selection(), dir, customProfileMenu(), actionProfileRemove());\n        }\n    }\n}\n\nvoid MainWindow::on_actionLayoutRemove_triggered()\n{\n    // Setup the dialog.\n    ListSelectionDialog dialog(Settings.layouts(), this);\n    dialog.setWindowModality(QmlApplication::dialogModality());\n    dialog.setWindowTitle(tr(\"Remove Layout\"));\n\n    // Show the dialog.\n    if (dialog.exec() == QDialog::Accepted) {\n        foreach(const QString& layout, dialog.selection()) {\n            // Update the configuration.\n            if (Settings.removeLayout(layout))\n                Settings.sync();\n            // Locate the menu item.\n            foreach (QAction* action, ui->menuLayout->actions()) {\n                if (action->text() == layout) {\n                    // Remove the menu item.\n                    delete action;\n                    break;\n                }\n            }\n        }\n        // If no more custom layouts.\n        if (Settings.layouts().size() == 0) {\n            // Remove the Remove action and separator.\n            ui->menuLayout->removeAction(ui->actionLayoutRemove);\n            bool isSecondSeparator = false;\n            foreach (QAction* action, ui->menuLayout->actions()) {\n                if (action->isSeparator()) {\n                    if (isSecondSeparator) {\n                        delete action;\n                        break;\n                    } else {\n                        isSecondSeparator = true;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid MainWindow::on_actionOpenOther2_triggered()\n{\n    ui->actionOpenOther2->menu()->popup(mapToGlobal(ui->mainToolBar->geometry().bottomLeft()) + QPoint(64, 0));\n}\n\nvoid MainWindow::onOpenOtherTriggered(QWidget* widget)\n{\n    QDialog dialog(this);\n    dialog.resize(426, 288);\n    QVBoxLayout vlayout(&dialog);\n    vlayout.addWidget(widget);\n    QDialogButtonBox buttonBox(&dialog);\n    buttonBox.setOrientation(Qt::Horizontal);\n    buttonBox.setStandardButtons(QDialogButtonBox::Cancel | QDialogButtonBox::Ok);\n    vlayout.addWidget(&buttonBox);\n    connect(&buttonBox, SIGNAL(accepted()), &dialog, SLOT(accept()));\n    connect(&buttonBox, SIGNAL(rejected()), &dialog, SLOT(reject()));\n    QString name = widget->objectName();\n    if (name == \"NoiseWidget\" || dialog.exec() == QDialog::Accepted) {\n        open(dynamic_cast<AbstractProducerWidget*>(widget)->newProducer(MLT.profile()));\n        if (name == \"TextProducerWidget\") {\n            m_filtersDock->show();\n            m_filtersDock->raise();\n        } else {\n            m_propertiesDock->show();\n            m_propertiesDock->raise();\n        }\n    }\n    delete widget;\n}\n\nvoid MainWindow::onOpenOtherTriggered()\n{\n    if (sender()->objectName() == \"color\")\n        onOpenOtherTriggered(new ColorProducerWidget(this));\n    else if (sender()->objectName() == \"text\")\n        onOpenOtherTriggered(new TextProducerWidget(this));\n    else if (sender()->objectName() == \"noise\")\n        onOpenOtherTriggered(new NoiseWidget(this));\n    else if (sender()->objectName() == \"ising0r\")\n        onOpenOtherTriggered(new IsingWidget(this));\n    else if (sender()->objectName() == \"lissajous0r\")\n        onOpenOtherTriggered(new LissajousWidget(this));\n    else if (sender()->objectName() == \"plasma\")\n        onOpenOtherTriggered(new PlasmaWidget(this));\n    else if (sender()->objectName() == \"test_pat_B\")\n        onOpenOtherTriggered(new ColorBarsWidget(this));\n    else if (sender()->objectName() == \"tone\")\n        onOpenOtherTriggered(new ToneProducerWidget(this));\n    else if (sender()->objectName() == \"count\")\n        onOpenOtherTriggered(new CountProducerWidget(this));\n    else if (sender()->objectName() == \"blipflash\")\n        onOpenOtherTriggered(new BlipProducerWidget(this));\n    else if (sender()->objectName() == \"v4l2\")\n        onOpenOtherTriggered(new Video4LinuxWidget(this));\n    else if (sender()->objectName() == \"pulse\")\n        onOpenOtherTriggered(new PulseAudioWidget(this));\n    else if (sender()->objectName() == \"jack\")\n        onOpenOtherTriggered(new JackProducerWidget(this));\n    else if (sender()->objectName() == \"alsa\")\n        onOpenOtherTriggered(new AlsaWidget(this));\n#if defined(Q_OS_MAC)\n    else if (sender()->objectName() == \"device\")\n        onOpenOtherTriggered(new AvfoundationProducerWidget(this));\n#elif defined(Q_OS_WIN)\n    else if (sender()->objectName() == \"device\")\n        onOpenOtherTriggered(new DirectShowVideoWidget(this));\n#endif\n    else if (sender()->objectName() == \"decklink\")\n        onOpenOtherTriggered(new DecklinkProducerWidget(this));\n}\n\nvoid MainWindow::on_actionClearRecentOnExit_toggled(bool arg1)\n{\n    Settings.setClearRecent(arg1);\n    if (arg1)\n        Settings.setRecent(QStringList());\n}\n\nvoid MainWindow::onSceneGraphInitialized()\n{\n    if (Settings.playerGPU() && Settings.playerWarnGPU()) {\n        QMessageBox dialog(QMessageBox::Warning,\n                           qApp->applicationName(),\n                           tr(\"GPU effects are EXPERIMENTAL, UNSTABLE and UNSUPPORTED! Unsupported means do not report bugs about it.\\n\\n\"\n                              \"Do you want to disable GPU effects and restart Shotcut?\"),\n                           QMessageBox::No | QMessageBox::Yes,\n                           this);\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        if (dialog.exec() == QMessageBox::Yes) {\n            ui->actionGPU->setChecked(false);\n            m_exitCode = EXIT_RESTART;\n            QApplication::closeAllWindows();\n        } else {\n            ui->actionGPU->setVisible(true);\n        }\n    } else if (Settings.playerGPU()) {\n        ui->actionGPU->setVisible(true);\n    }\n}\n\nvoid MainWindow::on_actionShowTextUnderIcons_toggled(bool b)\n{\n    ui->mainToolBar->setToolButtonStyle(b? Qt::ToolButtonTextUnderIcon : Qt::ToolButtonIconOnly);\n    Settings.setTextUnderIcons(b);\n}\n\nvoid MainWindow::on_actionShowSmallIcons_toggled(bool b)\n{\n    ui->mainToolBar->setIconSize(b? QSize(16, 16) : QSize());\n    Settings.setSmallIcons(b);\n}\n\nvoid MainWindow::onPlaylistInChanged(int in)\n{\n    m_player->blockSignals(true);\n    m_player->setIn(in);\n    m_player->blockSignals(false);\n}\n\nvoid MainWindow::onPlaylistOutChanged(int out)\n{\n    m_player->blockSignals(true);\n    m_player->setOut(out);\n    m_player->blockSignals(false);\n}\n\nvoid MainWindow::on_actionPreviewNone_triggered(bool checked)\n{\n    if (checked) {\n        Settings.setPlayerPreviewScale(0);\n        setPreviewScale(0);\n        m_player->showIdleStatus();\n    }\n}\n\nvoid MainWindow::on_actionPreview360_triggered(bool checked)\n{\n    if (checked) {\n        Settings.setPlayerPreviewScale(360);\n        setPreviewScale(360);\n        m_player->showIdleStatus();\n    }\n}\n\nvoid MainWindow::on_actionPreview540_triggered(bool checked)\n{\n    if (checked) {\n        Settings.setPlayerPreviewScale(540);\n        setPreviewScale(540);\n        m_player->showIdleStatus();\n    }\n}\n\nvoid MainWindow::on_actionPreview720_triggered(bool checked)\n{\n    if (checked) {\n        Settings.setPlayerPreviewScale(720);\n        setPreviewScale(720);\n        m_player->showIdleStatus();\n    }\n}\n\nQUuid MainWindow::timelineClipUuid(int trackIndex, int clipIndex)\n{\n    QScopedPointer<Mlt::ClipInfo> info(m_timelineDock->getClipInfo(trackIndex, clipIndex));\n    if (info && info->cut && info->cut->is_valid())\n        return MLT.ensureHasUuid(*info->cut);\n    return QUuid();\n}\n\nvoid MainWindow::replaceInTimeline(const QUuid& uuid, Mlt::Producer& producer)\n{\n    int trackIndex = -1;\n    int clipIndex = -1;\n    // lookup the current track and clip index by UUID\n    QScopedPointer<Mlt::ClipInfo> info(MAIN.timelineClipInfoByUuid(uuid, trackIndex, clipIndex));\n\n    if (trackIndex >= 0 && clipIndex >= 0) {\n        Util::getHash(producer);\n        Util::applyCustomProperties(producer, *info->producer, producer.get_in(), producer.get_out());\n        m_timelineDock->replace(trackIndex, clipIndex, MLT.XML(&producer));\n    }\n}\n\nMlt::ClipInfo* MainWindow::timelineClipInfoByUuid(const QUuid& uuid, int& trackIndex, int& clipIndex)\n{\n    return m_timelineDock->model()->findClipByUuid(uuid, trackIndex, clipIndex);\n}\n\nvoid MainWindow::replaceAllByHash(const QString& hash, Mlt::Producer& producer, bool isProxy)\n{\n    Util::getHash(producer);\n    if (!isProxy)\n        m_recentDock->add(producer.get(\"resource\"));\n    if (MLT.isClip() && MLT.producer() && Util::getHash(*MLT.producer()) == hash) {\n        Util::applyCustomProperties(producer, *MLT.producer(), MLT.producer()->get_in(), MLT.producer()->get_out());\n        MLT.copyFilters(*MLT.producer(), producer);\n        MLT.close();\n        m_player->setPauseAfterOpen(true);\n        open(new Mlt::Producer(MLT.profile(), \"xml-string\", MLT.XML(&producer).toUtf8().constData()));\n    } else if (MLT.savedProducer() && Util::getHash(*MLT.savedProducer()) == hash) {\n        Util::applyCustomProperties(producer, *MLT.savedProducer(), MLT.savedProducer()->get_in(), MLT.savedProducer()->get_out());\n        MLT.copyFilters(*MLT.savedProducer(), producer);\n        MLT.setSavedProducer(&producer);\n    }\n    if (playlist()) {\n        if (isProxy) {\n            m_playlistDock->replaceClipsWithHash(hash, producer);\n        } else {\n            // Append to playlist\n            producer.set(kPlaylistIndexProperty, playlist()->count());\n            MAIN.undoStack()->push(\n                new Playlist::AppendCommand(*m_playlistDock->model(), MLT.XML(&producer)));\n        }\n    }\n    if (isMultitrackValid()) {\n        m_timelineDock->replaceClipsWithHash(hash, producer);\n    }\n}\n\nvoid MainWindow::on_actionTopics_triggered()\n{\n    QDesktopServices::openUrl(QUrl(\"https://www.shotcut.org/howtos/\"));\n}\n\nvoid MainWindow::on_actionSync_triggered()\n{\n    auto dialog = new SystemSyncDialog(this);\n    dialog->show();\n    dialog->raise();\n    dialog->activateWindow();\n}\n\nvoid MainWindow::on_actionUseProxy_triggered(bool checked)\n{\n    if (MLT.producer()) {\n        QDir dir(m_currentFile.isEmpty()? QDir::tempPath() : QFileInfo(m_currentFile).dir());\n        QScopedPointer<QTemporaryFile> tmp(new QTemporaryFile(dir.filePath(\"shotcut-XXXXXX.mlt\")));\n        tmp->open();\n        tmp->close();\n        QString fileName = tmp->fileName();\n        tmp->remove();\n        tmp.reset();\n        LOG_DEBUG() << fileName;\n\n        if (saveXML(fileName)) {\n            MltXmlChecker checker;\n\n            Settings.setProxyEnabled(checked);\n            checker.check(fileName);\n            if (!isXmlRepaired(checker, fileName)) {\n                QFile::remove(fileName);\n                return;\n            }\n            if (checker.isUpdated()) {\n                QFile::remove(fileName);\n                fileName = checker.tempFileName();\n            }\n\n            // Open the temporary file\n            int result = 0;\n            {\n                LongUiTask longTask(checked? tr(\"Turn Proxy On\") : tr(\"Turn Proxy Off\"));\n                QFuture<int> future = QtConcurrent::run([=]() {\n                    return MLT.open(QDir::fromNativeSeparators(fileName), QDir::fromNativeSeparators(m_currentFile));\n                });\n                result = longTask.wait<int>(tr(\"Converting\"), future);\n            }\n            if (!result) {\n                auto position = m_player->position();\n                m_undoStack->clear();\n                m_player->stop();\n                m_player->setPauseAfterOpen(true);\n                open(MLT.producer());\n                MLT.seek(m_player->position());\n                m_player->seek(position);\n\n                if (checked && (isPlaylistValid() || isMultitrackValid())) {\n                    // Prompt user if they want to create missing proxies\n                    QMessageBox dialog(QMessageBox::Question, qApp->applicationName(),\n                       tr(\"Do you want to create missing proxies for every file in this project?\\n\\n\"\n                          \"You must reopen your project after all proxy jobs are finished.\"),\n                       QMessageBox::No | QMessageBox::Yes, this);\n                    dialog.setWindowModality(QmlApplication::dialogModality());\n                    dialog.setDefaultButton(QMessageBox::Yes);\n                    dialog.setEscapeButton(QMessageBox::No);\n                    if (dialog.exec() == QMessageBox::Yes) {\n                        Mlt::Producer producer(playlist());\n                        if (producer.is_valid()) {\n                            ProxyManager::generateIfNotExistsAll(producer);\n                        }\n                        producer = multitrack();\n                        if (producer.is_valid()) {\n                            ProxyManager::generateIfNotExistsAll(producer);\n                        }\n                    }\n                }\n            } else if (fileName != untitledFileName()) {\n                showStatusMessage(tr(\"Failed to open \") + fileName);\n                emit openFailed(fileName);\n            }\n        } else {\n            ui->actionUseProxy->setChecked(!checked);\n            showSaveError();\n        }\n        QFile::remove(fileName);\n    } else {\n        Settings.setProxyEnabled(checked);\n    }\n    m_player->showIdleStatus();\n}\n\nvoid MainWindow::on_actionProxyStorageSet_triggered()\n{\n    // Present folder dialog just like App Data Directory\n    QString dirName = QFileDialog::getExistingDirectory(this, tr(\"Proxy Folder\"), Settings.proxyFolder());\n    if (!dirName.isEmpty() && dirName != Settings.proxyFolder()) {\n        auto oldFolder = Settings.proxyFolder();\n        Settings.setProxyFolder(dirName);\n        Settings.sync();\n\n        // Get a count for the progress dialog\n        auto oldDir = QDir(oldFolder);\n        auto dirList = oldDir.entryList(QDir::Dirs | QDir::Files | QDir::NoDotAndDotDot);\n        auto count = dirList.size();\n\n        if (count > 0) {\n            // Prompt user if they want to create missing proxies\n            QMessageBox dialog(QMessageBox::Question, qApp->applicationName(),\n               tr(\"Do you want to move all files from the old folder to the new folder?\"),\n               QMessageBox::No | QMessageBox::Yes, this);\n            dialog.setWindowModality(QmlApplication::dialogModality());\n            dialog.setDefaultButton(QMessageBox::Yes);\n            dialog.setEscapeButton(QMessageBox::No);\n            if (dialog.exec() == QMessageBox::Yes) {\n                // Move the existing files\n                LongUiTask longTask(tr(\"Moving Files\"));\n                int i = 0;\n                for (const auto& fileName : dirList) {\n                    if (!fileName.isEmpty() && !QFile::exists(dirName + \"/\" + fileName)) {\n                        LOG_DEBUG() << \"moving\" << oldDir.filePath(fileName) << \"to\" << dirName + \"/\" + fileName;\n                        longTask.reportProgress(fileName, i++, count);\n                        if (!QFile::rename(oldDir.filePath(fileName), dirName + \"/\" + fileName))\n                            LOG_WARNING() << \"Failed to move\" << oldDir.filePath(fileName);\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid MainWindow::on_actionProxyStorageShow_triggered()\n{\n    Util::showInFolder(ProxyManager::dir().path());\n}\n\nvoid MainWindow::on_actionProxyUseProjectFolder_triggered(bool checked)\n{\n    Settings.setProxyUseProjectFolder(checked);\n}\n\nvoid MainWindow::on_actionProxyUseHardware_triggered(bool checked)\n{\n    if (checked && Settings.encodeHardware().isEmpty()) {\n        if (!m_encodeDock->detectHardwareEncoders())\n            ui->actionProxyUseHardware->setChecked(false);\n    }\n    Settings.setProxyUseHardware(ui->actionProxyUseHardware->isChecked());\n}\n\nvoid MainWindow::on_actionProxyConfigureHardware_triggered()\n{\n    m_encodeDock->on_hwencodeButton_clicked();\n    if (Settings.encodeHardware().isEmpty()) {\n        ui->actionProxyUseHardware->setChecked(false);\n        Settings.setProxyUseHardware(false);\n    }\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2011-2020 Meltytech, LLC\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include \"scrubbar.h\"\n#include \"openotherdialog.h\"\n#include \"player.h\"\n\n#include \"widgets/alsawidget.h\"\n#include \"widgets/colorbarswidget.h\"\n#include \"widgets/colorproducerwidget.h\"\n#include \"widgets/countproducerwidget.h\"\n#include \"widgets/decklinkproducerwidget.h\"\n#include \"widgets/directshowvideowidget.h\"\n#include \"widgets/isingwidget.h\"\n#include \"widgets/jackproducerwidget.h\"\n#include \"widgets/toneproducerwidget.h\"\n#include \"widgets/lissajouswidget.h\"\n#include \"widgets/networkproducerwidget.h\"\n#include \"widgets/noisewidget.h\"\n#include \"widgets/plasmawidget.h\"\n#include \"widgets/pulseaudiowidget.h\"\n#include \"widgets/video4linuxwidget.h\"\n#include \"widgets/x11grabwidget.h\"\n#include \"widgets/avformatproducerwidget.h\"\n#include \"widgets/imageproducerwidget.h\"\n#include \"widgets/webvfxproducer.h\"\n#include \"widgets/blipproducerwidget.h\"\n#include \"widgets/newprojectfolder.h\"\n#include \"docks/recentdock.h\"\n#include \"docks/encodedock.h\"\n#include \"docks/jobsdock.h\"\n#include \"jobqueue.h\"\n#include \"docks/playlistdock.h\"\n#include \"glwidget.h\"\n#include \"controllers/filtercontroller.h\"\n#include \"controllers/scopecontroller.h\"\n#include \"docks/filtersdock.h\"\n#include \"dialogs/customprofiledialog.h\"\n#include \"htmleditor/htmleditor.h\"\n#include \"settings.h\"\n#include \"leapnetworklistener.h\"\n#include \"database.h\"\n#include \"widgets/gltestwidget.h\"\n#include \"docks/timelinedock.h\"\n#include \"widgets/lumamixtransition.h\"\n#include \"qmltypes/qmlutilities.h\"\n#include \"qmltypes/qmlapplication.h\"\n#include \"autosavefile.h\"\n#include \"commands/playlistcommands.h\"\n#include \"shotcut_mlt_properties.h\"\n#include \"widgets/avfoundationproducerwidget.h\"\n#include \"dialogs/textviewerdialog.h\"\n#include \"widgets/gdigrabwidget.h\"\n#include \"models/audiolevelstask.h\"\n#include \"widgets/trackpropertieswidget.h\"\n#include \"widgets/timelinepropertieswidget.h\"\n#include \"dialogs/unlinkedfilesdialog.h\"\n#include \"docks/keyframesdock.h\"\n#include \"util.h\"\n#include \"models/keyframesmodel.h\"\n#include \"dialogs/listselectiondialog.h\"\n#include \"widgets/textproducerwidget.h\"\n#include \"qmltypes/qmlprofile.h\"\n#include \"dialogs/longuitask.h\"\n#include \"dialogs/systemsyncdialog.h\"\n#include \"proxymanager.h\"\n\n#include <QtWidgets>\n#include <Logger.h>\n#include <QThreadPool>\n#include <QtConcurrent/QtConcurrentRun>\n#include <QMutexLocker>\n#include <QQuickItem>\n#include <QtNetwork>\n#include <QJsonDocument>\n#include <QJSEngine>\n#include <QDirIterator>\n#include <QQuickWindow>\n#include <QVersionNumber>\n#include <clocale>\n\nstatic bool eventDebugCallback(void **data)\n{\n    QEvent *event = reinterpret_cast<QEvent*>(data[1]);\n    if (event->type() == QEvent::KeyPress || event->type() == QEvent::KeyRelease) {\n        QObject *receiver = reinterpret_cast<QObject*>(data[0]);\n        LOG_DEBUG() << event << \"->\" << receiver;\n    }\n    else if (event->type() == QEvent::MouseButtonPress || event->type() == QEvent::MouseButtonRelease) {\n        QObject *receiver = reinterpret_cast<QObject*>(data[0]);\n        LOG_DEBUG() << event << \"->\" << receiver;\n    }\n    return false;\n}\n\nstatic const int AUTOSAVE_TIMEOUT_MS = 60000;\n\nMainWindow::MainWindow()\n    : QMainWindow(0)\n    , ui(new Ui::MainWindow)\n    , m_isKKeyPressed(false)\n    , m_keyerGroup(0)\n    , m_previewScaleGroup(0)\n    , m_keyerMenu(0)\n    , m_isPlaylistLoaded(false)\n    , m_exitCode(EXIT_SUCCESS)\n    , m_navigationPosition(0)\n    , m_upgradeUrl(\"https://www.shotcut.org/download/\")\n    , m_keyframesDock(0)\n{\n#if defined(Q_OS_UNIX) && !defined(Q_OS_MAC)\n    QLibrary libJack(\"libjack.so.0\");\n    if (!libJack.load()) {\n        QMessageBox::critical(this, qApp->applicationName(),\n            tr(\"Error: This program requires the JACK 1 library.\\n\\nPlease install it using your package manager. It may be named libjack0, jack-audio-connection-kit, jack, or similar.\"));\n        ::exit(EXIT_FAILURE);\n    } else {\n        libJack.unload();\n    }\n    QLibrary libSDL(\"libSDL2-2.0.so.0\");\n    if (!libSDL.load()) {\n        QMessageBox::critical(this, qApp->applicationName(),\n            tr(\"Error: This program requires the SDL 2 library.\\n\\nPlease install it using your package manager. It may be named libsdl2-2.0-0, SDL2, or similar.\"));\n        ::exit(EXIT_FAILURE);\n    } else {\n        libSDL.unload();\n    }\n#endif\n\n    if (!qgetenv(\"OBSERVE_FOCUS\").isEmpty()) {\n        connect(qApp, &QApplication::focusChanged,\n                this, &MainWindow::onFocusChanged);\n        connect(qApp, &QGuiApplication::focusObjectChanged,\n                this, &MainWindow::onFocusObjectChanged);\n        connect(qApp, &QGuiApplication::focusWindowChanged,\n                this, &MainWindow::onFocusWindowChanged);\n    }\n\n    if (!qgetenv(\"EVENT_DEBUG\").isEmpty())\n        QInternal::registerCallback(QInternal::EventNotifyCallback, eventDebugCallback);\n\n    LOG_DEBUG() << \"begin\";\n#ifndef Q_OS_WIN\n    new GLTestWidget(this);\n#endif\n    Database::singleton(this);\n    m_autosaveTimer.setSingleShot(true);\n    m_autosaveTimer.setInterval(AUTOSAVE_TIMEOUT_MS);\n    connect(&m_autosaveTimer, SIGNAL(timeout()), this, SLOT(onAutosaveTimeout()));\n\n    // Initialize all QML types\n    QmlUtilities::registerCommonTypes();\n\n    // Create the UI.\n    ui->setupUi(this);\n#ifdef Q_OS_MAC\n    // Qt 5 on OS X supports the standard Full Screen window widget.\n    ui->mainToolBar->removeAction(ui->actionFullscreen);\n    // OS X has a standard Full Screen shortcut we should use.\n    ui->actionEnter_Full_Screen->setShortcut(QKeySequence((Qt::CTRL + Qt::META + Qt::Key_F)));\n#endif\n    setDockNestingEnabled(true);\n    ui->statusBar->hide();\n\n    // Connect UI signals.\n    connect(ui->actionOpen, SIGNAL(triggered()), this, SLOT(openVideo()));\n    connect(ui->actionAbout_Qt, SIGNAL(triggered()), qApp, SLOT(aboutQt()));\n    connect(this, SIGNAL(producerOpened()), this, SLOT(onProducerOpened()));\n    if (ui->actionFullscreen)\n        connect(ui->actionFullscreen, SIGNAL(triggered()), this, SLOT(on_actionEnter_Full_Screen_triggered()));\n    connect(ui->mainToolBar, SIGNAL(visibilityChanged(bool)), SLOT(onToolbarVisibilityChanged(bool)));\n\n    // Accept drag-n-drop of files.\n    this->setAcceptDrops(true);\n\n    // Setup the undo stack.\n    m_undoStack = new QUndoStack(this);\n    m_undoStack->setUndoLimit(Settings.undoLimit());\n    QAction *undoAction = m_undoStack->createUndoAction(this);\n    QAction *redoAction = m_undoStack->createRedoAction(this);\n    undoAction->setIcon(QIcon::fromTheme(\"edit-undo\", QIcon(\":/icons/oxygen/32x32/actions/edit-undo.png\")));\n    redoAction->setIcon(QIcon::fromTheme(\"edit-redo\", QIcon(\":/icons/oxygen/32x32/actions/edit-redo.png\")));\n    undoAction->setShortcut(QApplication::translate(\"MainWindow\", \"Ctrl+Z\", 0));\n#ifdef Q_OS_WIN\n    redoAction->setShortcut(QApplication::translate(\"MainWindow\", \"Ctrl+Y\", 0));\n#else\n    redoAction->setShortcut(QApplication::translate(\"MainWindow\", \"Ctrl+Shift+Z\", 0));\n#endif\n    ui->menuEdit->insertAction(ui->actionCut, undoAction);\n    ui->menuEdit->insertAction(ui->actionCut, redoAction);\n    ui->menuEdit->insertSeparator(ui->actionCut);\n    ui->actionUndo->setIcon(undoAction->icon());\n    ui->actionRedo->setIcon(redoAction->icon());\n    ui->actionUndo->setToolTip(undoAction->toolTip());\n    ui->actionRedo->setToolTip(redoAction->toolTip());\n    connect(m_undoStack, SIGNAL(canUndoChanged(bool)), ui->actionUndo, SLOT(setEnabled(bool)));\n    connect(m_undoStack, SIGNAL(canRedoChanged(bool)), ui->actionRedo, SLOT(setEnabled(bool)));\n\n    // Add the player widget.\n    m_player = new Player;\n    MLT.videoWidget()->installEventFilter(this);\n    ui->centralWidget->layout()->addWidget(m_player);\n    connect(this, SIGNAL(producerOpened()), m_player, SLOT(onProducerOpened()));\n    connect(m_player, SIGNAL(showStatusMessage(QString)), this, SLOT(showStatusMessage(QString)));\n    connect(m_player, SIGNAL(inChanged(int)), this, SLOT(onCutModified()));\n    connect(m_player, SIGNAL(outChanged(int)), this, SLOT(onCutModified()));\n    connect(m_player, SIGNAL(tabIndexChanged(int)), SLOT(onPlayerTabIndexChanged(int)));\n    connect(MLT.videoWidget(), SIGNAL(started()), SLOT(processMultipleFiles()));\n    connect(MLT.videoWidget(), SIGNAL(paused()), m_player, SLOT(showPaused()));\n    connect(MLT.videoWidget(), SIGNAL(playing()), m_player, SLOT(showPlaying()));\n    connect(MLT.videoWidget(), SIGNAL(toggleZoom(bool)), m_player, SLOT(toggleZoom(bool)));\n\n    setupSettingsMenu();\n    setupOpenOtherMenu();\n    readPlayerSettings();\n    configureVideoWidget();\n\n#ifndef SHOTCUT_NOUPGRADE\n    if (Settings.noUpgrade() || qApp->property(\"noupgrade\").toBool())\n#endif\n        delete ui->actionUpgrade;\n\n    // Add the docks.\n    m_scopeController = new ScopeController(this, ui->menuView);\n    QDockWidget* audioMeterDock = findChild<QDockWidget*>(\"AudioPeakMeterDock\");\n    if (audioMeterDock) {\n        audioMeterDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_1));\n        connect(ui->actionAudioMeter, SIGNAL(triggered()), audioMeterDock->toggleViewAction(), SLOT(trigger()));\n    }\n\n    m_propertiesDock = new QDockWidget(tr(\"Properties\"), this);\n    m_propertiesDock->hide();\n    m_propertiesDock->setObjectName(\"propertiesDock\");\n    m_propertiesDock->setWindowIcon(ui->actionProperties->icon());\n    m_propertiesDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_2));\n    m_propertiesDock->toggleViewAction()->setIcon(ui->actionProperties->icon());\n    m_propertiesDock->setMinimumWidth(300);\n    QScrollArea* scroll = new QScrollArea;\n    scroll->setWidgetResizable(true);\n    m_propertiesDock->setWidget(scroll);\n    addDockWidget(Qt::LeftDockWidgetArea, m_propertiesDock);\n    ui->menuView->addAction(m_propertiesDock->toggleViewAction());\n    connect(m_propertiesDock->toggleViewAction(), SIGNAL(triggered(bool)), this, SLOT(onPropertiesDockTriggered(bool)));\n    connect(ui->actionProperties, SIGNAL(triggered()), this, SLOT(onPropertiesDockTriggered()));\n\n    m_recentDock = new RecentDock(this);\n    m_recentDock->hide();\n    addDockWidget(Qt::RightDockWidgetArea, m_recentDock);\n    m_recentDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_3));\n    ui->menuView->addAction(m_recentDock->toggleViewAction());\n    connect(m_recentDock, SIGNAL(itemActivated(QString)), this, SLOT(open(QString)));\n    connect(m_recentDock->toggleViewAction(), SIGNAL(triggered(bool)), this, SLOT(onRecentDockTriggered(bool)));\n    connect(ui->actionRecent, SIGNAL(triggered()), this, SLOT(onRecentDockTriggered()));\n    connect(this, SIGNAL(openFailed(QString)), m_recentDock, SLOT(remove(QString)));\n    connect(m_recentDock, &RecentDock::deleted, m_player->projectWidget(), &NewProjectFolder::updateRecentProjects);\n\n    m_playlistDock = new PlaylistDock(this);\n    m_playlistDock->hide();\n    addDockWidget(Qt::LeftDockWidgetArea, m_playlistDock);\n    m_playlistDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_4));\n    ui->menuView->addAction(m_playlistDock->toggleViewAction());\n    connect(m_playlistDock->toggleViewAction(), SIGNAL(triggered(bool)), this, SLOT(onPlaylistDockTriggered(bool)));\n    connect(ui->actionPlaylist, SIGNAL(triggered()), this, SLOT(onPlaylistDockTriggered()));\n    connect(m_playlistDock, SIGNAL(clipOpened(Mlt::Producer*, bool)), this, SLOT(openCut(Mlt::Producer*, bool)));\n    connect(m_playlistDock, SIGNAL(itemActivated(int)), this, SLOT(seekPlaylist(int)));\n    connect(m_playlistDock, SIGNAL(showStatusMessage(QString)), this, SLOT(showStatusMessage(QString)));\n    connect(m_playlistDock->model(), SIGNAL(created()), this, SLOT(onPlaylistCreated()));\n    connect(m_playlistDock->model(), SIGNAL(cleared()), this, SLOT(onPlaylistCleared()));\n    connect(m_playlistDock->model(), SIGNAL(cleared()), this, SLOT(updateAutoSave()));\n    connect(m_playlistDock->model(), SIGNAL(closed()), this, SLOT(onPlaylistClosed()));\n    connect(m_playlistDock->model(), SIGNAL(modified()), this, SLOT(onPlaylistModified()));\n    connect(m_playlistDock->model(), SIGNAL(modified()), this, SLOT(updateAutoSave()));\n    connect(m_playlistDock->model(), SIGNAL(loaded()), this, SLOT(onPlaylistLoaded()));\n    connect(this, SIGNAL(producerOpened()), m_playlistDock, SLOT(onProducerOpened()));\n    if (!Settings.playerGPU())\n        connect(m_playlistDock->model(), SIGNAL(loaded()), this, SLOT(updateThumbnails()));\n    connect(m_player, &Player::inChanged, m_playlistDock, &PlaylistDock::onInChanged);\n    connect(m_player, &Player::outChanged, m_playlistDock, &PlaylistDock::onOutChanged);\n    connect(m_playlistDock->model(), &PlaylistModel::inChanged, this, &MainWindow::onPlaylistInChanged);\n    connect(m_playlistDock->model(), &PlaylistModel::outChanged, this, &MainWindow::onPlaylistOutChanged);\n\n    m_timelineDock = new TimelineDock(this);\n    m_timelineDock->hide();\n    addDockWidget(Qt::BottomDockWidgetArea, m_timelineDock);\n    m_timelineDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_5));\n    ui->menuView->addAction(m_timelineDock->toggleViewAction());\n    connect(m_timelineDock->toggleViewAction(), SIGNAL(triggered(bool)), this, SLOT(onTimelineDockTriggered(bool)));\n    connect(ui->actionTimeline, SIGNAL(triggered()), SLOT(onTimelineDockTriggered()));\n    connect(m_player, SIGNAL(seeked(int)), m_timelineDock, SLOT(onSeeked(int)));\n    connect(m_timelineDock, SIGNAL(seeked(int)), SLOT(seekTimeline(int)));\n    connect(m_timelineDock, SIGNAL(clipClicked()), SLOT(onTimelineClipSelected()));\n    connect(m_timelineDock, SIGNAL(showStatusMessage(QString)), this, SLOT(showStatusMessage(QString)));\n    connect(m_timelineDock->model(), SIGNAL(showStatusMessage(QString)), this, SLOT(showStatusMessage(QString)));\n    connect(m_timelineDock->model(), SIGNAL(created()), SLOT(onMultitrackCreated()));\n    connect(m_timelineDock->model(), SIGNAL(closed()), SLOT(onMultitrackClosed()));\n    connect(m_timelineDock->model(), SIGNAL(modified()), SLOT(onMultitrackModified()));\n    connect(m_timelineDock->model(), SIGNAL(modified()), SLOT(updateAutoSave()));\n    connect(m_timelineDock->model(), SIGNAL(durationChanged()), SLOT(onMultitrackDurationChanged()));\n    connect(m_timelineDock, SIGNAL(clipOpened(Mlt::Producer*)), SLOT(openCut(Mlt::Producer*)));\n    connect(m_timelineDock->model(), &MultitrackModel::seeked, this, &MainWindow::seekTimeline);\n    connect(m_timelineDock->model(), SIGNAL(scaleFactorChanged()), m_player, SLOT(pause()));\n    connect(m_timelineDock, SIGNAL(selected(Mlt::Producer*)), SLOT(loadProducerWidget(Mlt::Producer*)));\n    connect(m_timelineDock, SIGNAL(selectionChanged()), SLOT(onTimelineSelectionChanged()));\n    connect(m_timelineDock, SIGNAL(clipCopied()), SLOT(onClipCopied()));\n    connect(m_timelineDock, SIGNAL(filteredClicked()), SLOT(onFiltersDockTriggered()));\n    connect(m_playlistDock, SIGNAL(addAllTimeline(Mlt::Playlist*)), SLOT(onTimelineDockTriggered()));\n    connect(m_playlistDock, SIGNAL(addAllTimeline(Mlt::Playlist*, bool)), SLOT(onAddAllToTimeline(Mlt::Playlist*, bool)));\n    connect(m_player, SIGNAL(previousSought()), m_timelineDock, SLOT(seekPreviousEdit()));\n    connect(m_player, SIGNAL(nextSought()), m_timelineDock, SLOT(seekNextEdit()));\n\n    m_filterController = new FilterController(this);\n    m_filtersDock = new FiltersDock(m_filterController->metadataModel(), m_filterController->attachedModel(), this);\n    m_filtersDock->setMinimumSize(400, 300);\n    m_filtersDock->hide();\n    addDockWidget(Qt::LeftDockWidgetArea, m_filtersDock);\n    m_filtersDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_6));\n    ui->menuView->addAction(m_filtersDock->toggleViewAction());\n    connect(m_filtersDock, SIGNAL(currentFilterRequested(int)), m_filterController, SLOT(setCurrentFilter(int)), Qt::QueuedConnection);\n    connect(m_filtersDock->toggleViewAction(), SIGNAL(triggered(bool)), this, SLOT(onFiltersDockTriggered(bool)));\n    connect(ui->actionFilters, SIGNAL(triggered()), this, SLOT(onFiltersDockTriggered()));\n    connect(m_filterController, SIGNAL(currentFilterChanged(QmlFilter*, QmlMetadata*, int)), m_filtersDock, SLOT(setCurrentFilter(QmlFilter*, QmlMetadata*, int)));\n    connect(this, SIGNAL(producerOpened()), m_filterController, SLOT(setProducer()));\n    connect(m_filterController->attachedModel(), SIGNAL(changed()), SLOT(onFilterModelChanged()));\n    connect(m_filtersDock, SIGNAL(changed()), SLOT(onFilterModelChanged()));\n    connect(m_filterController, SIGNAL(filterChanged(Mlt::Filter*)),\n            m_timelineDock->model(), SLOT(onFilterChanged(Mlt::Filter*)));\n    connect(m_filterController->attachedModel(), SIGNAL(addedOrRemoved(Mlt::Producer*)),\n            m_timelineDock->model(), SLOT(filterAddedOrRemoved(Mlt::Producer*)));\n    connect(&QmlApplication::singleton(), SIGNAL(filtersPasted(Mlt::Producer*)),\n            m_timelineDock->model(), SLOT(filterAddedOrRemoved(Mlt::Producer*)));\n    connect(&QmlApplication::singleton(), &QmlApplication::filtersPasted,\n            this, &MainWindow::onProducerModified);\n    connect(m_filterController, SIGNAL(statusChanged(QString)), this, SLOT(showStatusMessage(QString)));\n    connect(m_timelineDock, SIGNAL(fadeInChanged(int)), m_filterController, SLOT(onFadeInChanged()));\n    connect(m_timelineDock, SIGNAL(fadeOutChanged(int)), m_filterController, SLOT(onFadeOutChanged()));\n    connect(m_timelineDock, SIGNAL(selected(Mlt::Producer*)), m_filterController, SLOT(setProducer(Mlt::Producer*)));\n    connect(m_player, SIGNAL(seeked(int)), m_filtersDock, SLOT(onSeeked(int)), Qt::QueuedConnection);\n    connect(m_filtersDock, SIGNAL(seeked(int)), SLOT(seekKeyframes(int)));\n    connect(MLT.videoWidget(), SIGNAL(frameDisplayed(const SharedFrame&)), m_filtersDock, SLOT(onShowFrame(const SharedFrame&)));\n    connect(m_player, SIGNAL(inChanged(int)), m_filtersDock, SIGNAL(producerInChanged(int)));\n    connect(m_player, SIGNAL(outChanged(int)), m_filtersDock, SIGNAL(producerOutChanged(int)));\n    connect(m_player, SIGNAL(inChanged(int)), m_filterController, SLOT(onFilterInChanged(int)));\n    connect(m_player, SIGNAL(outChanged(int)), m_filterController, SLOT(onFilterOutChanged(int)));\n    connect(m_timelineDock->model(), SIGNAL(filterInChanged(int, Mlt::Filter*)), m_filterController, SLOT(onFilterInChanged(int, Mlt::Filter*)));\n    connect(m_timelineDock->model(), SIGNAL(filterOutChanged(int, Mlt::Filter*)), m_filterController, SLOT(onFilterOutChanged(int, Mlt::Filter*)));\n\n    m_keyframesDock = new KeyframesDock(m_filtersDock->qmlProducer(), this);\n    m_keyframesDock->hide();\n    addDockWidget(Qt::BottomDockWidgetArea, m_keyframesDock);\n    m_keyframesDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_7));\n    ui->menuView->addAction(m_keyframesDock->toggleViewAction());\n    connect(m_keyframesDock->toggleViewAction(), SIGNAL(triggered(bool)), this, SLOT(onKeyframesDockTriggered(bool)));\n    connect(ui->actionKeyframes, SIGNAL(triggered()), this, SLOT(onKeyframesDockTriggered()));\n    connect(m_filterController, SIGNAL(currentFilterChanged(QmlFilter*, QmlMetadata*, int)), m_keyframesDock, SLOT(setCurrentFilter(QmlFilter*, QmlMetadata*)));\n    connect(m_keyframesDock, SIGNAL(visibilityChanged(bool)), m_filtersDock->qmlProducer(), SLOT(remakeAudioLevels(bool)));\n\n    m_historyDock = new QDockWidget(tr(\"History\"), this);\n    m_historyDock->hide();\n    m_historyDock->setObjectName(\"historyDock\");\n    m_historyDock->setWindowIcon(ui->actionHistory->icon());\n    m_historyDock->toggleViewAction()->setIcon(ui->actionHistory->icon());\n    m_historyDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_8));\n    m_historyDock->setMinimumWidth(150);\n    addDockWidget(Qt::RightDockWidgetArea, m_historyDock);\n    ui->menuView->addAction(m_historyDock->toggleViewAction());\n    connect(m_historyDock->toggleViewAction(), SIGNAL(triggered(bool)), this, SLOT(onHistoryDockTriggered(bool)));\n    connect(ui->actionHistory, SIGNAL(triggered()), this, SLOT(onHistoryDockTriggered()));\n    QUndoView* undoView = new QUndoView(m_undoStack, m_historyDock);\n    undoView->setObjectName(\"historyView\");\n    undoView->setAlternatingRowColors(true);\n    undoView->setSpacing(2);\n    m_historyDock->setWidget(undoView);\n    ui->actionUndo->setDisabled(true);\n    ui->actionRedo->setDisabled(true);\n\n    m_encodeDock = new EncodeDock(this);\n    m_encodeDock->hide();\n    addDockWidget(Qt::LeftDockWidgetArea, m_encodeDock);\n    m_encodeDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_9));\n    ui->menuView->addAction(m_encodeDock->toggleViewAction());\n    connect(this, SIGNAL(producerOpened()), m_encodeDock, SLOT(onProducerOpened()));\n    connect(ui->actionEncode, SIGNAL(triggered()), this, SLOT(onEncodeTriggered()));\n    connect(ui->actionExportVideo, SIGNAL(triggered()), this, SLOT(onEncodeTriggered()));\n    connect(m_encodeDock->toggleViewAction(), SIGNAL(triggered(bool)), this, SLOT(onEncodeTriggered(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), m_player, SLOT(onCaptureStateChanged(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), m_propertiesDock, SLOT(setDisabled(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), m_recentDock, SLOT(setDisabled(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), m_filtersDock, SLOT(setDisabled(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), m_keyframesDock, SLOT(setDisabled(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), ui->actionOpen, SLOT(setDisabled(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), ui->actionOpenOther, SLOT(setDisabled(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), ui->actionExit, SLOT(setDisabled(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), this, SLOT(onCaptureStateChanged(bool)));\n    connect(m_encodeDock, SIGNAL(captureStateChanged(bool)), m_historyDock, SLOT(setDisabled(bool)));\n    connect(this, SIGNAL(profileChanged()), m_encodeDock, SLOT(onProfileChanged()));\n    connect(this, SIGNAL(profileChanged()), SLOT(onProfileChanged()));\n    connect(this, SIGNAL(profileChanged()), &QmlProfile::singleton(), SIGNAL(profileChanged()));\n    connect(this, SIGNAL(audioChannelsChanged()), m_encodeDock, SLOT(onAudioChannelsChanged()));\n    connect(m_playlistDock->model(), SIGNAL(modified()), m_encodeDock, SLOT(onProducerOpened()));\n    connect(m_timelineDock, SIGNAL(clipCopied()), m_encodeDock, SLOT(onProducerOpened()));\n    m_encodeDock->onProfileChanged();\n\n    m_jobsDock = new JobsDock(this);\n    m_jobsDock->hide();\n    addDockWidget(Qt::RightDockWidgetArea, m_jobsDock);\n    m_jobsDock->toggleViewAction()->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_0));\n    ui->menuView->addAction(m_jobsDock->toggleViewAction());\n    connect(&JOBS, SIGNAL(jobAdded()), m_jobsDock, SLOT(onJobAdded()));\n    connect(m_jobsDock->toggleViewAction(), SIGNAL(triggered(bool)), this, SLOT(onJobsDockTriggered(bool)));\n    connect(ui->actionJobs, SIGNAL(triggered()), this, SLOT(onJobsDockTriggered()));\n\n    tabifyDockWidget(m_propertiesDock, m_playlistDock);\n    tabifyDockWidget(m_playlistDock, m_filtersDock);\n    tabifyDockWidget(m_filtersDock, m_encodeDock);\n    QDockWidget* audioWaveformDock = findChild<QDockWidget*>(\"AudioWaveformDock\");\n    splitDockWidget(m_recentDock, audioWaveformDock, Qt::Vertical);\n    splitDockWidget(audioMeterDock, m_recentDock, Qt::Horizontal);\n    tabifyDockWidget(m_recentDock, m_historyDock);\n    tabifyDockWidget(m_historyDock, m_jobsDock);\n    tabifyDockWidget(m_keyframesDock, m_timelineDock);\n    m_recentDock->raise();\n\n    // Configure the View menu.\n    ui->menuView->addSeparator();\n    ui->menuView->addAction(ui->actionApplicationLog);\n\n    // connect video widget signals\n    Mlt::GLWidget* videoWidget = (Mlt::GLWidget*) &(MLT);\n    connect(videoWidget, SIGNAL(dragStarted()), m_playlistDock, SLOT(onPlayerDragStarted()));\n    connect(videoWidget, SIGNAL(seekTo(int)), m_player, SLOT(seek(int)));\n    connect(videoWidget, SIGNAL(gpuNotSupported()), this, SLOT(onGpuNotSupported()));\n    connect(videoWidget->quickWindow(), SIGNAL(sceneGraphInitialized()), SLOT(onSceneGraphInitialized()), Qt::QueuedConnection);\n    connect(videoWidget, SIGNAL(frameDisplayed(const SharedFrame&)), m_scopeController, SIGNAL(newFrame(const SharedFrame&)));\n    connect(m_filterController, SIGNAL(currentFilterChanged(QmlFilter*, QmlMetadata*, int)), videoWidget, SLOT(setCurrentFilter(QmlFilter*, QmlMetadata*)));\n\n    readWindowSettings();\n    setCorner(Qt::TopLeftCorner, Qt::LeftDockWidgetArea);\n    setCorner(Qt::TopRightCorner, Qt::RightDockWidgetArea);\n    setCorner(Qt::BottomLeftCorner, Qt::BottomDockWidgetArea);\n    setCorner(Qt::BottomRightCorner, Qt::BottomDockWidgetArea);\n    setDockNestingEnabled(true);\n\n    setFocus();\n    setCurrentFile(\"\");\n\n    LeapNetworkListener* leap = new LeapNetworkListener(this);\n    connect(leap, SIGNAL(shuttle(float)), SLOT(onShuttle(float)));\n    connect(leap, SIGNAL(jogRightFrame()), SLOT(stepRightOneFrame()));\n    connect(leap, SIGNAL(jogRightSecond()), SLOT(stepRightOneSecond()));\n    connect(leap, SIGNAL(jogLeftFrame()), SLOT(stepLeftOneFrame()));\n    connect(leap, SIGNAL(jogLeftSecond()), SLOT(stepLeftOneSecond()));\n\n    connect(&m_network, SIGNAL(finished(QNetworkReply*)), SLOT(onUpgradeCheckFinished(QNetworkReply*)));\n\n    QThreadPool::globalInstance()->setMaxThreadCount(qMin(4, QThreadPool::globalInstance()->maxThreadCount()));\n\n    ProxyManager::removePending();\n\n    LOG_DEBUG() << \"end\";\n}\n\nvoid MainWindow::onFocusWindowChanged(QWindow *) const\n{\n    LOG_DEBUG() << \"Focuswindow changed\";\n    LOG_DEBUG() << \"Current focusWidget:\" << QApplication::focusWidget();\n    LOG_DEBUG() << \"Current focusObject:\" << QApplication::focusObject();\n    LOG_DEBUG() << \"Current focusWindow:\" << QApplication::focusWindow();\n}\n\nvoid MainWindow::onFocusObjectChanged(QObject *) const\n{\n    LOG_DEBUG() << \"Focusobject changed\";\n    LOG_DEBUG() << \"Current focusWidget:\" << QApplication::focusWidget();\n    LOG_DEBUG() << \"Current focusObject:\" << QApplication::focusObject();\n    LOG_DEBUG() << \"Current focusWindow:\" << QApplication::focusWindow();\n}\n\nvoid MainWindow::onTimelineClipSelected()\n{\n    // Synchronize navigation position with timeline selection.\n    TimelineDock * t = m_timelineDock;\n\n    if (t->selection().isEmpty())\n        return;\n\n    m_navigationPosition = t->centerOfClip(t->selection().first().y(), t->selection().first().x());\n\n    // Switch to Project player.\n    if (m_player->tabIndex() != Player::ProjectTabIndex) {\n        t->saveAndClearSelection();\n        m_player->onTabBarClicked(Player::ProjectTabIndex);\n    }\n}\n\nvoid MainWindow::onAddAllToTimeline(Mlt::Playlist* playlist, bool skipProxy)\n{\n    // We stop the player because of a bug on Windows that results in some\n    // strange memory leak when using Add All To Timeline, more noticeable\n    // with (high res?) still image files.\n    if (MLT.isSeekable())\n        m_player->pause();\n    else\n        m_player->stop();\n    m_timelineDock->appendFromPlaylist(playlist, skipProxy);\n}\n\nMainWindow& MainWindow::singleton()\n{\n    static MainWindow* instance = new MainWindow;\n    return *instance;\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n    Mlt::Controller::destroy();\n}\n\nvoid MainWindow::setupSettingsMenu()\n{\n    LOG_DEBUG() << \"begin\";\n    QActionGroup* group = new QActionGroup(this);\n    group->addAction(ui->actionChannels1);\n    group->addAction(ui->actionChannels2);\n    group->addAction(ui->actionChannels6);\n    group = new QActionGroup(this);\n    group->addAction(ui->actionOneField);\n    group->addAction(ui->actionLinearBlend);\n\n#if LIBMLT_VERSION_INT >= MLT_VERSION_PREVIEW_SCALE\n    m_previewScaleGroup = new QActionGroup(this);\n    m_previewScaleGroup->addAction(ui->actionPreviewNone);\n    m_previewScaleGroup->addAction(ui->actionPreview360);\n    m_previewScaleGroup->addAction(ui->actionPreview540);\n    m_previewScaleGroup->addAction(ui->actionPreview720);\n#else\n    delete ui->menuPreviewScaling;\n#endif\n\n    //XXX workaround yadif crashing with mlt_transition\n//    group->addAction(ui->actionYadifTemporal);\n//    group->addAction(ui->actionYadifSpatial);\n    ui->actionYadifTemporal->setVisible(false);\n    ui->actionYadifSpatial->setVisible(false);\n\n    group = new QActionGroup(this);\n    group->addAction(ui->actionNearest);\n    group->addAction(ui->actionBilinear);\n    group->addAction(ui->actionBicubic);\n    group->addAction(ui->actionHyper);\n    if (Settings.playerGPU()) {\n        group = new QActionGroup(this);\n        group->addAction(ui->actionGammaRec709);\n        group->addAction(ui->actionGammaSRGB);\n    } else {\n        delete ui->menuGamma;\n    }\n    m_profileGroup = new QActionGroup(this);\n    m_profileGroup->addAction(ui->actionProfileAutomatic);\n    ui->actionProfileAutomatic->setData(QString());\n    buildVideoModeMenu(ui->menuProfile, m_customProfileMenu, m_profileGroup, ui->actionAddCustomProfile, ui->actionProfileRemove);\n\n    // Add the SDI and HDMI devices to the Settings menu.\n    m_externalGroup = new QActionGroup(this);\n    ui->actionExternalNone->setData(QString());\n    m_externalGroup->addAction(ui->actionExternalNone);\n\n    QList<QScreen*> screens = QGuiApplication::screens();\n    int n = screens.size();\n    for (int i = 0; n > 1 && i < n; i++) {\n        QAction* action = new QAction(tr(\"Screen %1 (%2 x %3 @ %4 Hz)\").arg(i)\n            .arg(screens[i]->size().width() * screens[i]->devicePixelRatio())\n            .arg(screens[i]->size().height() * screens[i]->devicePixelRatio())\n            .arg(screens[i]->refreshRate()), this);\n        action->setCheckable(true);\n        action->setData(i);\n        m_externalGroup->addAction(action);\n    }\n\n    Mlt::Profile profile;\n    Mlt::Consumer decklink(profile, \"decklink:\");\n    if (decklink.is_valid()) {\n        decklink.set(\"list_devices\", 1);\n        int n = decklink.get_int(\"devices\");\n        for (int i = 0; i < n; ++i) {\n            QString device(decklink.get(QString(\"device.%1\").arg(i).toLatin1().constData()));\n            if (!device.isEmpty()) {\n                QAction* action = new QAction(device, this);\n                action->setCheckable(true);\n                action->setData(QString(\"decklink:%1\").arg(i));\n                m_externalGroup->addAction(action);\n\n                if (!m_keyerGroup) {\n                    m_keyerGroup = new QActionGroup(this);\n                    action = new QAction(tr(\"Off\"), m_keyerGroup);\n                    action->setData(QVariant(0));\n                    action->setCheckable(true);\n                    action = new QAction(tr(\"Internal\"), m_keyerGroup);\n                    action->setData(QVariant(1));\n                    action->setCheckable(true);\n                    action = new QAction(tr(\"External\"), m_keyerGroup);\n                    action->setData(QVariant(2));\n                    action->setCheckable(true);\n                }\n            }\n        }\n    }\n    if (m_externalGroup->actions().count() > 1)\n        ui->menuExternal->addActions(m_externalGroup->actions());\n    else {\n        delete ui->menuExternal;\n        ui->menuExternal = 0;\n    }\n    if (m_keyerGroup) {\n        m_keyerMenu = ui->menuExternal->addMenu(tr(\"DeckLink Keyer\"));\n        m_keyerMenu->addActions(m_keyerGroup->actions());\n        m_keyerMenu->setDisabled(true);\n        connect(m_keyerGroup, SIGNAL(triggered(QAction*)), this, SLOT(onKeyerTriggered(QAction*)));\n    }\n    connect(m_externalGroup, SIGNAL(triggered(QAction*)), this, SLOT(onExternalTriggered(QAction*)));\n    connect(m_profileGroup, SIGNAL(triggered(QAction*)), this, SLOT(onProfileTriggered(QAction*)));\n\n    // Setup the language menu actions\n    m_languagesGroup = new QActionGroup(this);\n    QAction* a;\n    a = new QAction(QLocale::languageToString(QLocale::Arabic), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"ar\");\n    a = new QAction(QLocale::languageToString(QLocale::Catalan), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"ca\");\n    a = new QAction(QLocale::languageToString(QLocale::Chinese).append(\" (China)\"), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"zh_CN\");\n    a = new QAction(QLocale::languageToString(QLocale::Chinese).append(\" (Taiwan)\"), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"zh_TW\");\n    a = new QAction(QLocale::languageToString(QLocale::Czech), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"cs\");\n    a = new QAction(QLocale::languageToString(QLocale::Danish), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"da\");\n    a = new QAction(QLocale::languageToString(QLocale::Dutch), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"nl\");\n    a = new QAction(QLocale::languageToString(QLocale::English).append(\" (Great Britain)\"), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"en_GB\");\n    a = new QAction(QLocale::languageToString(QLocale::English).append(\" (United States)\"), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"en_US\");\n    a = new QAction(QLocale::languageToString(QLocale::Estonian), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"et\");\n    a = new QAction(QLocale::languageToString(QLocale::Finnish), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"fi\");\n    a = new QAction(QLocale::languageToString(QLocale::French), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"fr\");\n    a = new QAction(QLocale::languageToString(QLocale::Gaelic), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"gd\");\n    a = new QAction(QLocale::languageToString(QLocale::Galician), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"gl\");\n    a = new QAction(QLocale::languageToString(QLocale::German), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"de\");\n    a = new QAction(QLocale::languageToString(QLocale::Greek), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"el\");\n    a = new QAction(QLocale::languageToString(QLocale::Hungarian), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"hu\");\n    a = new QAction(QLocale::languageToString(QLocale::Italian), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"it\");\n    a = new QAction(QLocale::languageToString(QLocale::Japanese), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"ja\");\n    a = new QAction(QLocale::languageToString(QLocale::Korean), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"ko\");\n    a = new QAction(QLocale::languageToString(QLocale::Nepali), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"ne\");\n    a = new QAction(QLocale::languageToString(QLocale::NorwegianBokmal), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"nb\");\n    a = new QAction(QLocale::languageToString(QLocale::NorwegianNynorsk), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"nn\");\n    a = new QAction(QLocale::languageToString(QLocale::Occitan), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"oc\");\n    a = new QAction(QLocale::languageToString(QLocale::Polish), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"pl\");\n    a = new QAction(QLocale::languageToString(QLocale::Portuguese).append(\" (Brazil)\"), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"pt_BR\");\n    a = new QAction(QLocale::languageToString(QLocale::Portuguese).append(\" (Portugal)\"), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"pt_PT\");\n    a = new QAction(QLocale::languageToString(QLocale::Russian), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"ru\");\n    a = new QAction(QLocale::languageToString(QLocale::Slovak), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"sk\");\n    a = new QAction(QLocale::languageToString(QLocale::Slovenian), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"sl\");\n    a = new QAction(QLocale::languageToString(QLocale::Spanish), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"es\");\n    a = new QAction(QLocale::languageToString(QLocale::Swedish), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"sv\");\n    a = new QAction(QLocale::languageToString(QLocale::Thai), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"th\");\n    a = new QAction(QLocale::languageToString(QLocale::Turkish), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"tr\");\n    a = new QAction(QLocale::languageToString(QLocale::Ukrainian), m_languagesGroup);\n    a->setCheckable(true);\n    a->setData(\"uk\");\n    ui->menuLanguage->addActions(m_languagesGroup->actions());\n    const QString locale = Settings.language();\n    foreach (QAction* action, m_languagesGroup->actions()) {\n        if (action->data().toString().startsWith(locale)) {\n            action->setChecked(true);\n            break;\n        }\n    }\n    connect(m_languagesGroup, SIGNAL(triggered(QAction*)), this, SLOT(onLanguageTriggered(QAction*)));\n\n    // Setup the themes actions\n    group = new QActionGroup(this);\n    group->addAction(ui->actionSystemTheme);\n    group->addAction(ui->actionFusionDark);\n    group->addAction(ui->actionFusionLight);\n    if (Settings.theme() == \"dark\")\n        ui->actionFusionDark->setChecked(true);\n    else if (Settings.theme() == \"light\")\n        ui->actionFusionLight->setChecked(true);\n    else\n        ui->actionSystemTheme->setChecked(true);\n\n#ifdef Q_OS_WIN\n    // On Windows, if there is no JACK or it is not running\n    // then Shotcut crashes inside MLT's call to jack_client_open().\n    // Therefore, the JACK option for Shotcut is banned on Windows.\n    delete ui->actionJack;\n    ui->actionJack = 0;\n#endif\n#if !defined(Q_OS_MAC)\n    // Setup the display method actions.\n    if (!Settings.playerGPU()) {\n        group = new QActionGroup(this);\n#if defined(Q_OS_WIN)\n        ui->actionDrawingAutomatic->setData(0);\n        group->addAction(ui->actionDrawingAutomatic);\n        ui->actionDrawingDirectX->setData(Qt::AA_UseOpenGLES);\n        group->addAction(ui->actionDrawingDirectX);\n#else\n        delete ui->actionDrawingAutomatic;\n        delete ui->actionDrawingDirectX;\n#endif\n        ui->actionDrawingOpenGL->setData(Qt::AA_UseDesktopOpenGL);\n        group->addAction(ui->actionDrawingOpenGL);\n        ui->actionDrawingSoftware->setData(Qt::AA_UseSoftwareOpenGL);\n        group->addAction(ui->actionDrawingSoftware);\n        connect(group, SIGNAL(triggered(QAction*)), this, SLOT(onDrawingMethodTriggered(QAction*)));\n        switch (Settings.drawMethod()) {\n        case Qt::AA_UseDesktopOpenGL:\n            ui->actionDrawingOpenGL->setChecked(true);\n            break;\n#if defined(Q_OS_WIN)\n        case Qt::AA_UseOpenGLES:\n            ui->actionDrawingDirectX->setChecked(true);\n            break;\n#endif\n        case Qt::AA_UseSoftwareOpenGL:\n            ui->actionDrawingSoftware->setChecked(true);\n            break;\n#if defined(Q_OS_WIN)\n        default:\n            ui->actionDrawingAutomatic->setChecked(true);\n            break;\n#else\n        default:\n            ui->actionDrawingOpenGL->setChecked(true);\n            break;\n#endif\n        }\n    } else {\n        // GPU mode only works with OpenGL.\n        delete ui->menuDrawingMethod;\n        ui->menuDrawingMethod = 0;\n    }\n#else  // Q_OS_MAC\n    delete ui->menuDrawingMethod;\n    ui->menuDrawingMethod = 0;\n#endif\n\n    // Add custom layouts to View > Layout submenu.\n    m_layoutGroup = new QActionGroup(this);\n    connect(m_layoutGroup, SIGNAL(triggered(QAction*)), SLOT(onLayoutTriggered(QAction*)));\n    if (Settings.layouts().size() > 0) {\n        ui->menuLayout->addAction(ui->actionLayoutRemove);\n        ui->menuLayout->addSeparator();\n    }\n    foreach (QString name, Settings.layouts())\n        ui->menuLayout->addAction(addLayout(m_layoutGroup, name));\n\n    if (qApp->property(\"clearRecent\").toBool()) {\n        ui->actionClearRecentOnExit->setVisible(false);\n        Settings.setRecent(QStringList());\n        Settings.setClearRecent(true);\n    } else {\n        ui->actionClearRecentOnExit->setChecked(Settings.clearRecent());\n    }\n\n\n    // Initialze the proxy submenu\n    ui->actionUseProxy->setChecked(Settings.proxyEnabled());\n    ui->actionProxyUseProjectFolder->setChecked(Settings.proxyUseProjectFolder());\n    ui->actionProxyUseHardware->setChecked(Settings.proxyUseHardware());\n\n    LOG_DEBUG() << \"end\";\n}\n\nvoid MainWindow::setupOpenOtherMenu()\n{\n    // Open Other toolbar menu button\n    QScopedPointer<Mlt::Properties> mltProducers(MLT.repository()->producers());\n    QScopedPointer<Mlt::Properties> mltFilters(MLT.repository()->filters());\n    QMenu* otherMenu = new QMenu(this);\n    ui->actionOpenOther2->setMenu(otherMenu);\n\n    // populate the generators\n    if (mltProducers->get_data(\"color\")) {\n        otherMenu->addAction(tr(\"Color\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"color\");\n        if (!Settings.playerGPU() && mltProducers->get_data(\"qtext\") && mltFilters->get_data(\"dynamictext\"))\n            otherMenu->addAction(tr(\"Text\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"text\");\n    }\n    if (mltProducers->get_data(\"noise\"))\n        otherMenu->addAction(tr(\"Noise\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"noise\");\n    if (mltProducers->get_data(\"frei0r.ising0r\"))\n        otherMenu->addAction(tr(\"Ising\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"ising0r\");\n    if (mltProducers->get_data(\"frei0r.lissajous0r\"))\n        otherMenu->addAction(tr(\"Lissajous\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"lissajous0r\");\n    if (mltProducers->get_data(\"frei0r.plasma\"))\n        otherMenu->addAction(tr(\"Plasma\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"plasma\");\n    if (mltProducers->get_data(\"frei0r.test_pat_B\"))\n        otherMenu->addAction(tr(\"Color Bars\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"test_pat_B\");\n    if (mltProducers->get_data(\"tone\"))\n        otherMenu->addAction(tr(\"Audio Tone\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"tone\");\n    if (mltProducers->get_data(\"count\"))\n        otherMenu->addAction(tr(\"Count\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"count\");\n    if (mltProducers->get_data(\"blipflash\"))\n        otherMenu->addAction(tr(\"Blip Flash\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"blipflash\");\n\n#if defined(Q_OS_UNIX) && !defined(Q_OS_MAC)\n    otherMenu->addAction(tr(\"Video4Linux\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"v4l2\");\n    otherMenu->addAction(tr(\"PulseAudio\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"pulse\");\n    otherMenu->addAction(tr(\"JACK Audio\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"jack\");\n    otherMenu->addAction(tr(\"ALSA Audio\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"alsa\");\n#elif defined(Q_OS_WIN) || defined(Q_OS_MAC)\n    otherMenu->addAction(tr(\"Audio/Video Device\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"device\");\n#endif\n    if (mltProducers->get_data(\"decklink\"))\n        otherMenu->addAction(tr(\"SDI/HDMI\"), this, SLOT(onOpenOtherTriggered()))->setObjectName(\"decklink\");\n}\n\nQAction* MainWindow::addProfile(QActionGroup* actionGroup, const QString& desc, const QString& name)\n{\n    QAction* action = new QAction(desc, this);\n    action->setCheckable(true);\n    action->setData(name);\n    actionGroup->addAction(action);\n    return action;\n}\n\nQAction*MainWindow::addLayout(QActionGroup* actionGroup, const QString& name)\n{\n    QAction* action = new QAction(name, this);\n    actionGroup->addAction(action);\n    return action;\n}\n\nvoid MainWindow::open(Mlt::Producer* producer)\n{\n    if (!producer->is_valid())\n        showStatusMessage(tr(\"Failed to open \"));\n    else if (producer->get_int(\"error\"))\n        showStatusMessage(tr(\"Failed to open \") + producer->get(\"resource\"));\n\n    bool ok = false;\n    int screen = Settings.playerExternal().toInt(&ok);\n    if (ok && screen != QApplication::desktop()->screenNumber(this))\n        m_player->moveVideoToScreen(screen);\n\n    // no else here because open() will delete the producer if open fails\n    if (!MLT.setProducer(producer)) {\n        emit producerOpened();\n        if (!MLT.profile().is_explicit() || MLT.URL().endsWith(\".mlt\") || MLT.URL().endsWith(\".xml\"))\n            emit profileChanged();\n    }\n    m_player->setFocus();\n    m_playlistDock->setUpdateButtonEnabled(false);\n\n    // Needed on Windows. Upon first file open, window is deactivated, perhaps OpenGL-related.\n    activateWindow();\n}\n\nbool MainWindow::isCompatibleWithGpuMode(MltXmlChecker& checker)\n{\n    if (checker.needsGPU() && !Settings.playerGPU() && Settings.playerWarnGPU()) {\n        LOG_INFO() << \"file uses GPU but GPU not enabled\";\n        QMessageBox dialog(QMessageBox::Warning,\n           qApp->applicationName(),\n           tr(\"The file you opened uses GPU effects, but GPU effects are not enabled.\\n\\n\"\n              \"GPU effects are EXPERIMENTAL, UNSTABLE and UNSUPPORTED! Unsupported means do not report bugs about it.\\n\\n\"\n              \"Do you want to enable GPU effects and restart?\"),\n           QMessageBox::No |\n           QMessageBox::Yes,\n           this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        int r = dialog.exec();\n        if (r == QMessageBox::Yes) {\n            ui->actionGPU->setChecked(true);\n            m_exitCode = EXIT_RESTART;\n            QApplication::closeAllWindows();\n        }\n        return false;\n    }\n    else if (checker.needsCPU() && Settings.playerGPU()) {\n        LOG_INFO() << \"file uses GPU incompatible filters but GPU is enabled\";\n        QMessageBox dialog(QMessageBox::Question,\n           qApp->applicationName(),\n           tr(\"The file you opened uses CPU effects that are incompatible with GPU effects, but GPU effects are enabled.\\n\"\n              \"Do you want to disable GPU effects and restart?\"),\n           QMessageBox::No |\n           QMessageBox::Yes,\n           this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        int r = dialog.exec();\n        if (r == QMessageBox::Yes) {\n            ui->actionGPU->setChecked(false);\n            m_exitCode = EXIT_RESTART;\n            QApplication::closeAllWindows();\n        }\n        return false;\n    }\n    return true;\n}\n\nbool MainWindow::saveRepairedXmlFile(MltXmlChecker& checker, QString& fileName)\n{\n    QFileInfo fi(fileName);\n    QFile repaired(QString(\"%1/%2 - %3.%4\").arg(fi.path())\n        .arg(fi.completeBaseName()).arg(tr(\"Repaired\")).arg(fi.suffix()));\n    repaired.open(QIODevice::WriteOnly);\n    LOG_INFO() << \"repaired MLT XML file name\" << repaired.fileName();\n    QFile temp(checker.tempFileName());\n    if (temp.exists() && repaired.exists()) {\n        temp.open(QIODevice::ReadOnly);\n        QByteArray xml = temp.readAll();\n        temp.close();\n\n        qint64 n = repaired.write(xml);\n        while (n > 0 && n < xml.size()) {\n            qint64 x = repaired.write(xml.right(xml.size() - n));\n            if (x > 0)\n                n += x;\n            else\n                n = x;\n        }\n        repaired.close();\n        if (n == xml.size()) {\n            fileName = repaired.fileName();\n            return true;\n        }\n    }\n    QMessageBox::warning(this, qApp->applicationName(), tr(\"Repairing the project failed.\"));\n    LOG_WARNING() << \"repairing failed\";\n    return false;\n}\n\nbool MainWindow::isXmlRepaired(MltXmlChecker& checker, QString& fileName)\n{\n    bool result = true;\n    if (checker.isCorrected()) {\n        LOG_WARNING() << fileName;\n        QMessageBox dialog(QMessageBox::Question,\n           qApp->applicationName(),\n           tr(\"Shotcut noticed some problems in your project.\\n\"\n              \"Do you want Shotcut to try to repair it?\\n\\n\"\n              \"If you choose Yes, Shotcut will create a copy of your project\\n\"\n              \"with \\\"- Repaired\\\" in the file name and open it.\"),\n           QMessageBox::No |\n           QMessageBox::Yes,\n           this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        int r = dialog.exec();\n        if (r == QMessageBox::Yes)\n            result = saveRepairedXmlFile(checker, fileName);\n    }\n    else if (checker.unlinkedFilesModel().rowCount() > 0) {\n        UnlinkedFilesDialog dialog(this);\n        dialog.setModel(checker.unlinkedFilesModel());\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        if (dialog.exec() == QDialog::Accepted) {\n            if (checker.check(fileName) && checker.isCorrected())\n                result = saveRepairedXmlFile(checker, fileName);\n        } else {\n            result = false;\n        }\n    }\n    return result;\n}\n\nbool MainWindow::checkAutoSave(QString &url)\n{\n    QMutexLocker locker(&m_autosaveMutex);\n\n    // check whether autosave files exist:\n    QSharedPointer<AutoSaveFile> stale(AutoSaveFile::getFile(url));\n    if (stale) {\n        QMessageBox dialog(QMessageBox::Question, qApp->applicationName(),\n           tr(\"Auto-saved files exist. Do you want to recover them now?\"),\n           QMessageBox::No | QMessageBox::Yes, this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        int r = dialog.exec();\n        if (r == QMessageBox::Yes) {\n            if (!stale->open(QIODevice::ReadWrite)) {\n                LOG_WARNING() << \"failed to recover autosave file\" << url;\n            } else {\n                m_autosaveFile = stale;\n                url = stale->fileName();\n                return true;\n            }\n        }\n    }\n\n    // create new autosave object\n    m_autosaveFile.reset(new AutoSaveFile(url));\n\n    return false;\n}\n\nvoid MainWindow::stepLeftBySeconds(int sec)\n{\n    m_player->seek(m_player->position() + sec * qRound(MLT.profile().fps()));\n}\n\nvoid MainWindow::doAutosave()\n{\n    QMutexLocker locker(&m_autosaveMutex);\n    if (m_autosaveFile) {\n        bool success = false;\n        if (m_autosaveFile->isOpen() || m_autosaveFile->open(QIODevice::ReadWrite)) {\n            m_autosaveFile->close();\n            success = saveXML(m_autosaveFile->fileName(), false /* without relative paths */);\n            m_autosaveFile->open(QIODevice::ReadWrite);\n        }\n        if (!success) {\n            LOG_ERROR() << \"failed to open autosave file for writing\" << m_autosaveFile->fileName();\n        }\n    }\n}\n\nvoid MainWindow::setFullScreen(bool isFullScreen)\n{\n    if (isFullScreen) {\n#ifdef Q_OS_WIN\n        showMaximized();\n#else\n        showFullScreen();\n#endif\n        ui->actionEnter_Full_Screen->setVisible(false);\n        ui->actionFullscreen->setVisible(false);\n    }\n}\n\nQString MainWindow::untitledFileName() const\n{\n    QDir dir = Settings.appDataLocation();\n    if (!dir.exists()) dir.mkpath(dir.path());\n    return dir.filePath(\"__untitled__.mlt\");\n}\n\nvoid MainWindow::setProfile(const QString &profile_name)\n{\n    LOG_DEBUG() << profile_name;\n    MLT.setProfile(profile_name);\n    emit profileChanged();\n}\n\nbool MainWindow::isSourceClipMyProject(QString resource)\n{\n    if (m_player->tabIndex() == Player::ProjectTabIndex && MLT.savedProducer() && MLT.savedProducer()->is_valid())\n        resource = QString::fromUtf8(MLT.savedProducer()->get(\"resource\"));\n    if (!resource.isEmpty() && QDir(resource) == QDir(fileName())) {\n        QMessageBox dialog(QMessageBox::Information,\n                           qApp->applicationName(),\n                           tr(\"You cannot add a project to itself!\"),\n                           QMessageBox::Ok,\n                           this);\n        dialog.setDefaultButton(QMessageBox::Ok);\n        dialog.setEscapeButton(QMessageBox::Ok);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.exec();\n        return true;\n    }\n    return false;\n}\n\nbool MainWindow::keyframesDockIsVisible() const\n{\n    return m_keyframesDock && m_keyframesDock->isVisible();\n}\n\nvoid MainWindow::setAudioChannels(int channels)\n{\n    LOG_DEBUG() << channels;\n    MLT.videoWidget()->setProperty(\"audio_channels\", channels);\n    MLT.setAudioChannels(channels);\n    if (channels == 1)\n        ui->actionChannels1->setChecked(true);\n    else if (channels == 2)\n        ui->actionChannels2->setChecked(true);\n    else if (channels == 6)\n        ui->actionChannels6->setChecked(true);\n    emit audioChannelsChanged();\n}\n\nvoid MainWindow::showSaveError()\n{\n    QMessageBox dialog(QMessageBox::Critical,\n                       qApp->applicationName(),\n                       tr(\"There was an error saving. Please try again.\"),\n                       QMessageBox::Ok,\n                       this);\n    dialog.setDefaultButton(QMessageBox::Ok);\n    dialog.setEscapeButton(QMessageBox::Ok);\n    dialog.setWindowModality(QmlApplication::dialogModality());\n    dialog.exec();\n}\n\nvoid MainWindow::setPreviewScale(int scale)\n{\n    LOG_DEBUG() << scale;\n    switch (scale) {\n    case 360:\n        ui->actionPreview360->setChecked(true);\n        break;\n    case 540:\n        ui->actionPreview540->setChecked(true);\n        break;\n    case 720:\n        ui->actionPreview720->setChecked(true);\n        break;\n    default:\n        ui->actionPreviewNone->setChecked(true);\n        break;\n    }\n    MLT.setPreviewScale(scale);\n    MLT.refreshConsumer();\n}\n\nvoid MainWindow::setVideoModeMenu()\n{\n    // Find a matching video mode\n    for (const auto action : m_profileGroup->actions()) {\n        auto s = action->data().toString();\n        Mlt::Profile profile(s.toUtf8().constData());\n        if (MLT.profile().width() == profile.width() &&\n                MLT.profile().height() == profile.height() &&\n                MLT.profile().sample_aspect_num() == profile.sample_aspect_num() &&\n                MLT.profile().sample_aspect_den() == profile.sample_aspect_den() &&\n                MLT.profile().frame_rate_num() == profile.frame_rate_num() &&\n                MLT.profile().frame_rate_den() == profile.frame_rate_den() &&\n                MLT.profile().colorspace() == profile.colorspace() &&\n                MLT.profile().progressive() == profile.progressive()) {\n            // Select it\n            action->setChecked(true);\n            return;\n        }\n    }\n    // Choose Automatic if nothing found\n    m_profileGroup->actions().first()->setChecked(true);\n}\n\nvoid MainWindow::resetVideoModeMenu()\n{\n    // Change selected Video Mode back to Settings\n    for (const auto action : m_profileGroup->actions()) {\n        if (action->data().toString() == Settings.playerProfile()) {\n            action->setChecked(true);\n            break;\n        }\n    }\n}\n\nstatic void autosaveTask(MainWindow* p)\n{\n    LOG_DEBUG_TIME();\n    p->doAutosave();\n}\n\nvoid MainWindow::onAutosaveTimeout()\n{\n    if (isWindowModified())\n        QtConcurrent::run(autosaveTask, this);\n}\n\nvoid MainWindow::updateAutoSave()\n{\n    if (!m_autosaveTimer.isActive())\n        m_autosaveTimer.start();\n}\n\nvoid MainWindow::open(QString url, const Mlt::Properties* properties, bool play)\n{\n    LOG_DEBUG() << url;\n    bool modified = false;\n    MltXmlChecker checker;\n    QFileInfo info(url);\n\n    if (info.isRelative()) {\n        QDir pwd(QDir::currentPath());\n        url = pwd.filePath(url);\n    }\n    if (url.endsWith(\".mlt\") || url.endsWith(\".xml\")) {\n        if (url != untitledFileName()) {\n            showStatusMessage(tr(\"Opening %1\").arg(url));\n            QCoreApplication::processEvents();\n        }\n    }\n    if (checker.check(url)) {\n        if (!isCompatibleWithGpuMode(checker))\n            return;\n    }\n    if (url.endsWith(\".mlt\") || url.endsWith(\".xml\")) {\n        // only check for a modified project when loading a project, not a simple producer\n        if (!continueModified())\n            return;\n        QCoreApplication::processEvents();\n        // close existing project\n        if (playlist())\n            m_playlistDock->model()->close();\n        if (multitrack())\n            m_timelineDock->model()->close();\n        MLT.purgeMemoryPool();\n        if (!isXmlRepaired(checker, url))\n            return;\n        modified = checkAutoSave(url);\n        if (modified) {\n            if (checker.check(url)) {\n                if (!isCompatibleWithGpuMode(checker))\n                    return;\n            }\n            if (!isXmlRepaired(checker, url))\n                return;\n        }\n        // let the new project change the profile\n        if (modified || QFile::exists(url)) {\n            MLT.profile().set_explicit(false);\n            setWindowModified(modified);\n        }\n    }\n    if (!playlist() && !multitrack()) {\n        if (!modified && !continueModified())\n            return;\n        setCurrentFile(\"\");\n        setWindowModified(modified);\n        MLT.resetURL();\n        // Return to automatic video mode if selected.\n        if (m_profileGroup->checkedAction() && m_profileGroup->checkedAction()->data().toString().isEmpty())\n            MLT.profile().set_explicit(false);\n    }\n    if (url.endsWith(\".mlt\") || url.endsWith(\".xml\")) {\n        checker.setLocale();\n        LOG_INFO() << \"decimal point\" << MLT.decimalPoint();\n    }\n    QString urlToOpen = checker.isUpdated()? checker.tempFileName() : url;\n    if (!MLT.open(QDir::fromNativeSeparators(urlToOpen), QDir::fromNativeSeparators(url))\n            && MLT.producer() && MLT.producer()->is_valid()) {\n        Mlt::Properties* props = const_cast<Mlt::Properties*>(properties);\n        if (props && props->is_valid())\n            mlt_properties_inherit(MLT.producer()->get_properties(), props->get_properties());\n        m_player->setPauseAfterOpen(!play || !MLT.isClip());\n\n        setAudioChannels(MLT.audioChannels());\n        if (url.endsWith(\".mlt\") || url.endsWith(\".xml\")) {\n            setVideoModeMenu();\n        }\n\n        open(MLT.producer());\n        if (url.startsWith(AutoSaveFile::path())) {\n            QMutexLocker locker(&m_autosaveMutex);\n            if (m_autosaveFile && m_autosaveFile->managedFileName() != untitledFileName()) {\n                m_recentDock->add(m_autosaveFile->managedFileName());\n                LOG_INFO() << m_autosaveFile->managedFileName();\n            }\n        } else {\n            m_recentDock->add(url);\n            LOG_INFO() << url;\n        }\n    }\n    else if (url != untitledFileName()) {\n        showStatusMessage(tr(\"Failed to open \") + url);\n        emit openFailed(url);\n    }\n}\n\nvoid MainWindow::openMultiple(const QStringList& paths)\n{\n    if (paths.size() > 1) {\n        QList<QUrl> urls;\n        foreach (const QString& s, paths)\n            urls << s;\n        openMultiple(urls);\n    } else if (!paths.isEmpty()) {\n        open(paths.first());\n    }\n}\n\nvoid MainWindow::openMultiple(const QList<QUrl>& urls)\n{\n    if (urls.size() > 1) {\n        m_multipleFiles = Util::sortedFileList(Util::expandDirectories(urls));\n        open(m_multipleFiles.first());\n    } else {\n        QUrl url = urls.first();\n        open(Util::removeFileScheme(url));\n    }\n}\n\nvoid MainWindow::openVideo()\n{\n    QString path = Settings.openPath();\n#ifdef Q_OS_MAC\n    path.append(\"/*\");\n#endif\n    QStringList filenames = QFileDialog::getOpenFileNames(this, tr(\"Open File\"), path,\n        tr(\"All Files (*);;MLT XML (*.mlt)\"));\n\n    if (filenames.length() > 0) {\n        Settings.setOpenPath(QFileInfo(filenames.first()).path());\n        activateWindow();\n        if (filenames.length() > 1)\n            m_multipleFiles = filenames;\n        open(filenames.first());\n    }\n    else {\n        // If file invalid, then on some platforms the dialog messes up SDL.\n        MLT.onWindowResize();\n        activateWindow();\n    }\n}\n\nvoid MainWindow::openCut(Mlt::Producer* producer, bool play)\n{\n    m_player->setPauseAfterOpen(!play);\n    open(producer);\n    MLT.seek(producer->get_in());\n}\n\nvoid MainWindow::hideProducer()\n{\n    // This is a hack to release references to the old producer, but it\n    // probably leaves a reference to the new color producer somewhere not\n    // yet identified (root cause).\n    openCut(new Mlt::Producer(MLT.profile(), \"color:_hide\"));\n    QCoreApplication::processEvents();\n    openCut(new Mlt::Producer(MLT.profile(), \"color:_hide\"));\n    QCoreApplication::processEvents();\n\n    QScrollArea* scrollArea = (QScrollArea*) m_propertiesDock->widget();\n    delete scrollArea->widget();\n    scrollArea->setWidget(nullptr);\n    m_player->reset();\n\n    QCoreApplication::processEvents();\n}\n\nvoid MainWindow::closeProducer()\n{\n    hideProducer();\n    MLT.stop();\n    MLT.close();\n    MLT.setSavedProducer(0);\n}\n\nvoid MainWindow::showStatusMessage(QAction* action, int timeoutSeconds)\n{\n    // This object takes ownership of the passed action.\n    // This version does not currently log its message.\n    m_statusBarAction.reset(action);\n    action->setParent(0);\n    m_player->setStatusLabel(action->text(), timeoutSeconds, action);\n}\n\nvoid MainWindow::showStatusMessage(const QString& message, int timeoutSeconds)\n{\n    LOG_INFO() << message;\n    m_player->setStatusLabel(message, timeoutSeconds, 0 /* QAction */);\n    m_statusBarAction.reset();\n}\n\nvoid MainWindow::seekPlaylist(int start)\n{\n    if (!playlist()) return;\n    // we bypass this->open() to prevent sending producerOpened signal to self, which causes to reload playlist\n    if (!MLT.producer() || (void*) MLT.producer()->get_producer() != (void*) playlist()->get_playlist())\n        MLT.setProducer(new Mlt::Producer(*playlist()));\n    m_player->setIn(-1);\n    m_player->setOut(-1);\n    // since we do not emit producerOpened, these components need updating\n    on_actionJack_triggered(ui->actionJack && ui->actionJack->isChecked());\n    m_player->onProducerOpened(false);\n    m_encodeDock->onProducerOpened();\n    m_filterController->setProducer();\n    updateMarkers();\n    MLT.seek(start);\n    m_player->setFocus();\n    m_player->switchToTab(Player::ProjectTabIndex);\n}\n\nvoid MainWindow::seekTimeline(int position, bool seekPlayer)\n{\n    if (!multitrack()) return;\n    // we bypass this->open() to prevent sending producerOpened signal to self, which causes to reload playlist\n    if (MLT.producer() && (void*) MLT.producer()->get_producer() != (void*) multitrack()->get_producer()) {\n        MLT.setProducer(new Mlt::Producer(*multitrack()));\n        m_player->setIn(-1);\n        m_player->setOut(-1);\n        // since we do not emit producerOpened, these components need updating\n        on_actionJack_triggered(ui->actionJack && ui->actionJack->isChecked());\n        m_player->onProducerOpened(false);\n        m_encodeDock->onProducerOpened();\n        m_filterController->setProducer();\n        updateMarkers();\n        m_player->setFocus();\n        m_player->switchToTab(Player::ProjectTabIndex);\n        m_timelineDock->emitSelectedFromSelection();\n    }\n    if (seekPlayer)\n        m_player->seek(position);\n    else\n        m_player->pause();\n}\n\nvoid MainWindow::seekKeyframes(int position)\n{\n    m_player->seek(position);\n}\n\nvoid MainWindow::readPlayerSettings()\n{\n    LOG_DEBUG() << \"begin\";\n    ui->actionRealtime->setChecked(Settings.playerRealtime());\n    ui->actionProgressive->setChecked(Settings.playerProgressive());\n    ui->actionScrubAudio->setChecked(Settings.playerScrubAudio());\n    if (ui->actionJack)\n        ui->actionJack->setChecked(Settings.playerJACK());\n    if (ui->actionGPU) {\n        MLT.videoWidget()->setProperty(\"gpu\", ui->actionGPU->isChecked());\n        ui->actionGPU->setChecked(Settings.playerGPU());\n    }\n\n    QString external = Settings.playerExternal();\n    bool ok = false;\n    external.toInt(&ok);\n    auto isExternalPeripheral = !external.isEmpty() && !ok;\n\n    setAudioChannels(Settings.playerAudioChannels());\n\n#if LIBMLT_VERSION_INT >= MLT_VERSION_PREVIEW_SCALE\n    if (isExternalPeripheral) {\n        setPreviewScale(0);\n        m_previewScaleGroup->setEnabled(false);\n    } else {\n        setPreviewScale(Settings.playerPreviewScale());\n        m_previewScaleGroup->setEnabled(true);\n    }\n#endif\n\n    QString deinterlacer = Settings.playerDeinterlacer();\n    QString interpolation = Settings.playerInterpolation();\n\n    if (deinterlacer == \"onefield\")\n        ui->actionOneField->setChecked(true);\n    else if (deinterlacer == \"linearblend\")\n        ui->actionLinearBlend->setChecked(true);\n    else if (deinterlacer == \"yadif-nospatial\")\n        ui->actionYadifTemporal->setChecked(true);\n    else\n        ui->actionYadifSpatial->setChecked(true);\n\n    if (interpolation == \"nearest\")\n        ui->actionNearest->setChecked(true);\n    else if (interpolation == \"bilinear\")\n        ui->actionBilinear->setChecked(true);\n    else if (interpolation == \"bicubic\")\n        ui->actionBicubic->setChecked(true);\n    else\n        ui->actionHyper->setChecked(true);\n\n    foreach (QAction* a, m_externalGroup->actions()) {\n        if (a->data() == external) {\n            a->setChecked(true);\n            if (a->data().toString().startsWith(\"decklink\") && m_keyerMenu)\n                m_keyerMenu->setEnabled(true);\n            break;\n        }\n    }\n\n    if (m_keyerGroup) {\n        int keyer = Settings.playerKeyerMode();\n        foreach (QAction* a, m_keyerGroup->actions()) {\n            if (a->data() == keyer) {\n                a->setChecked(true);\n                break;\n            }\n        }\n    }\n\n    QString profile = Settings.playerProfile();\n    // Automatic not permitted for SDI/HDMI\n    if (isExternalPeripheral && profile.isEmpty())\n        profile = \"atsc_720p_50\";\n    foreach (QAction* a, m_profileGroup->actions()) {\n        // Automatic not permitted for SDI/HDMI\n        if (a->data().toString().isEmpty() && !external.isEmpty() && !ok)\n            a->setDisabled(true);\n        if (a->data().toString() == profile) {\n            a->setChecked(true);\n            break;\n        }\n    }\n\n    QString gamma = Settings.playerGamma();\n    if (gamma == \"bt709\")\n        ui->actionGammaRec709->setChecked(true);\n    else\n        ui->actionGammaSRGB->setChecked(true);\n\n    LOG_DEBUG() << \"end\";\n}\n\nvoid MainWindow::readWindowSettings()\n{\n    LOG_DEBUG() << \"begin\";\n    Settings.setWindowGeometryDefault(saveGeometry());\n    Settings.setWindowStateDefault(saveState());\n    Settings.sync();\n    if (!Settings.windowGeometry().isEmpty()) {\n        restoreGeometry(Settings.windowGeometry());\n        restoreState(Settings.windowState());\n#ifdef Q_OS_MAC\n        m_filtersDock->setFloating(false);\n#endif\n    } else {\n        on_actionLayoutTimeline_triggered();\n    }\n    LOG_DEBUG() << \"end\";\n}\n\nvoid MainWindow::writeSettings()\n{\n#ifndef Q_OS_MAC\n    if (isFullScreen())\n        showNormal();\n#endif\n    Settings.setPlayerGPU(ui->actionGPU->isChecked());\n    Settings.setWindowGeometry(saveGeometry());\n    Settings.setWindowState(saveState());\n    Settings.sync();\n}\n\nvoid MainWindow::configureVideoWidget()\n{\n    LOG_DEBUG() << \"begin\";\n    if (m_profileGroup->checkedAction())\n        setProfile(m_profileGroup->checkedAction()->data().toString());\n    MLT.videoWidget()->setProperty(\"realtime\", ui->actionRealtime->isChecked());\n    bool ok = false;\n    m_externalGroup->checkedAction()->data().toInt(&ok);\n    if (!ui->menuExternal || m_externalGroup->checkedAction()->data().toString().isEmpty() || ok) {\n        MLT.videoWidget()->setProperty(\"progressive\", ui->actionProgressive->isChecked());\n    } else {\n        MLT.videoWidget()->setProperty(\"mlt_service\", m_externalGroup->checkedAction()->data());\n        MLT.videoWidget()->setProperty(\"progressive\", MLT.profile().progressive());\n        ui->actionProgressive->setEnabled(false);\n    }\n    if (ui->actionChannels1->isChecked())\n        setAudioChannels(1);\n    else if (ui->actionChannels2->isChecked())\n        setAudioChannels(2);\n    else\n        setAudioChannels(6);\n    if (ui->actionOneField->isChecked())\n        MLT.videoWidget()->setProperty(\"deinterlace_method\", \"onefield\");\n    else if (ui->actionLinearBlend->isChecked())\n        MLT.videoWidget()->setProperty(\"deinterlace_method\", \"linearblend\");\n    else if (ui->actionYadifTemporal->isChecked())\n        MLT.videoWidget()->setProperty(\"deinterlace_method\", \"yadif-nospatial\");\n    else\n        MLT.videoWidget()->setProperty(\"deinterlace_method\", \"yadif\");\n    if (ui->actionNearest->isChecked())\n        MLT.videoWidget()->setProperty(\"rescale\", \"nearest\");\n    else if (ui->actionBilinear->isChecked())\n        MLT.videoWidget()->setProperty(\"rescale\", \"bilinear\");\n    else if (ui->actionBicubic->isChecked())\n        MLT.videoWidget()->setProperty(\"rescale\", \"bicubic\");\n    else\n        MLT.videoWidget()->setProperty(\"rescale\", \"hyper\");\n    if (m_keyerGroup)\n        MLT.videoWidget()->setProperty(\"keyer\", m_keyerGroup->checkedAction()->data());\n    LOG_DEBUG() << \"end\";\n}\n\nvoid MainWindow::setCurrentFile(const QString &filename)\n{\n    QString shownName = tr(\"Untitled\");\n    if (filename == untitledFileName())\n        m_currentFile.clear();\n    else\n        m_currentFile = filename;\n    if (!m_currentFile.isEmpty())\n        shownName = QFileInfo(m_currentFile).fileName();\n#ifdef Q_OS_MAC\n    setWindowTitle(QString(\"%1 - %2\").arg(shownName).arg(qApp->applicationName()));\n#else\n    setWindowTitle(QString(\"%1[*] - %2\").arg(shownName).arg(qApp->applicationName()));\n#endif\n}\n\nvoid MainWindow::on_actionAbout_Shotcut_triggered()\n{\n    QMessageBox::about(this, tr(\"About Shotcut\"),\n             tr(\"<h1>Shotcut version %1</h1>\"\n                \"<p><a href=\\\"https://www.shotcut.org/\\\">Shotcut</a> is a free, open source, cross platform video editor.</p>\"\n                \"<small><p>Copyright &copy; 2011-2020 <a href=\\\"https://www.meltytech.com/\\\">Meltytech</a>, LLC</p>\"\n                \"<p>Licensed under the <a href=\\\"https://www.gnu.org/licenses/gpl.html\\\">GNU General Public License v3.0</a></p>\"\n                \"<p>This program proudly uses the following projects:<ul>\"\n                \"<li><a href=\\\"https://www.qt.io/\\\">Qt</a> application and UI framework</li>\"\n                \"<li><a href=\\\"https://www.mltframework.org/\\\">MLT</a> multimedia authoring framework</li>\"\n                \"<li><a href=\\\"https://www.ffmpeg.org/\\\">FFmpeg</a> multimedia format and codec libraries</li>\"\n                \"<li><a href=\\\"https://www.videolan.org/developers/x264.html\\\">x264</a> H.264 encoder</li>\"\n                \"<li><a href=\\\"https://www.webmproject.org/\\\">WebM</a> VP8 and VP9 encoders</li>\"\n                \"<li><a href=\\\"http://lame.sourceforge.net/\\\">LAME</a> MP3 encoder</li>\"\n                \"<li><a href=\\\"https://www.dyne.org/software/frei0r/\\\">Frei0r</a> video plugins</li>\"\n                \"<li><a href=\\\"https://www.ladspa.org/\\\">LADSPA</a> audio plugins</li>\"\n                \"<li><a href=\\\"http://www.defaulticon.com/\\\">DefaultIcon</a> icon collection by <a href=\\\"http://www.interactivemania.com/\\\">interactivemania</a></li>\"\n                \"<li><a href=\\\"http://www.oxygen-icons.org/\\\">Oxygen</a> icon collection</li>\"\n                \"</ul></p>\"\n                \"<p>The source code used to build this program can be downloaded from \"\n                \"<a href=\\\"https://www.shotcut.org/\\\">shotcut.org</a>.</p>\"\n                \"This program is distributed in the hope that it will be useful, \"\n                \"but WITHOUT ANY WARRANTY; without even the implied warranty of \"\n                \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</small>\"\n                ).arg(qApp->applicationVersion()));\n}\n\n\nvoid MainWindow::keyPressEvent(QKeyEvent* event)\n{\n    if (event->isAccepted() && event->key() != Qt::Key_F12) return;\n\n    bool handled = true;\n\n    switch (event->key()) {\n    case Qt::Key_Home:\n        m_player->seek(0);\n        break;\n    case Qt::Key_End:\n        if (MLT.producer())\n            m_player->seek(MLT.producer()->get_length() - 1);\n        break;\n    case Qt::Key_Left:\n        if ((event->modifiers() & Qt::ControlModifier) && m_timelineDock->isVisible()) {\n            if (m_timelineDock->selection().isEmpty()) {\n                m_timelineDock->selectClipUnderPlayhead();\n            } else if (m_timelineDock->selection().size() == 1) {\n                int newIndex = m_timelineDock->selection().first().x() - 1;\n                if (newIndex < 0)\n                    break;\n                m_timelineDock->setSelection(QList<QPoint>() << QPoint(newIndex, m_timelineDock->selection().first().y()));\n                m_navigationPosition = m_timelineDock->centerOfClip(m_timelineDock->currentTrack(), newIndex);\n            }\n        } else {\n            stepLeftOneFrame();\n        }\n        break;\n    case Qt::Key_Right:\n        if ((event->modifiers() & Qt::ControlModifier) && m_timelineDock->isVisible()) {\n            if (m_timelineDock->selection().isEmpty()) {\n                m_timelineDock->selectClipUnderPlayhead();\n            } else if (m_timelineDock->selection().size() == 1) {\n                int newIndex = m_timelineDock->selection().first().x() + 1;\n                if (newIndex >= m_timelineDock->clipCount(-1))\n                    break;\n                m_timelineDock->setSelection(QList<QPoint>() << QPoint(newIndex, m_timelineDock->selection().first().y()));\n                m_navigationPosition = m_timelineDock->centerOfClip(m_timelineDock->currentTrack(), newIndex);\n            }\n        } else {\n            stepRightOneFrame();\n        }\n        break;\n    case Qt::Key_PageUp:\n    case Qt::Key_PageDown:\n        {\n            int directionMultiplier = event->key() == Qt::Key_PageUp ? -1 : 1;\n            int seconds = 1;\n            if (event->modifiers() & Qt::ControlModifier)\n                seconds *= 5;\n            if (event->modifiers() & Qt::ShiftModifier)\n                seconds *= 2;\n            stepLeftBySeconds(seconds * directionMultiplier);\n        }\n        break;\n    case Qt::Key_Space:\n#ifdef Q_OS_MAC\n        // Spotlight defaults to Cmd+Space, so also accept Ctrl+Space.\n        if ((event->modifiers() == Qt::MetaModifier || (event->modifiers() & Qt::ControlModifier)) && m_timelineDock->isVisible())\n#else\n        if (event->modifiers() == Qt::ControlModifier && m_timelineDock->isVisible())\n#endif\n            m_timelineDock->selectClipUnderPlayhead();\n        else\n            handled = false;\n        break;\n    case Qt::Key_A:\n        if (event->modifiers() == Qt::ShiftModifier) {\n            m_playlistDock->show();\n            m_playlistDock->raise();\n            m_playlistDock->on_actionAppendCut_triggered();\n        } else if ((event->modifiers() & Qt::ControlModifier) && (event->modifiers() & Qt::ShiftModifier)) {\n            m_playlistDock->show();\n            m_playlistDock->raise();\n            m_playlistDock->on_actionSelectAll_triggered();\n        } else if (event->modifiers() == Qt::ControlModifier) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->selectAll();\n        } else if (event->modifiers() == Qt::NoModifier) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->append(-1);\n        }\n        break;\n    case Qt::Key_C:\n        if (event->modifiers() == Qt::ShiftModifier && m_playlistDock->model()->rowCount() > 0) {\n            m_playlistDock->show();\n            m_playlistDock->raise();\n            m_playlistDock->on_actionCopy_triggered();\n        } else if ((event->modifiers() & Qt::ControlModifier) && (event->modifiers() & Qt::AltModifier)) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->copyToSource();\n        } else if (isMultitrackValid()) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            if (m_timelineDock->selection().isEmpty()) {\n                m_timelineDock->copyClip(-1, -1);\n            } else {\n                auto& selected = m_timelineDock->selection().first();\n                m_timelineDock->copyClip(selected.y(), selected.x());\n            }\n        }\n        break;\n    case Qt::Key_D:\n        if (event->modifiers() == Qt::ControlModifier) {\n            m_timelineDock->setSelection();\n            m_timelineDock->model()->reload();\n        } else if ((event->modifiers() & Qt::ControlModifier) && (event->modifiers() & Qt::ShiftModifier)) {\n            m_playlistDock->show();\n            m_playlistDock->raise();\n            m_playlistDock->on_actionSelectNone_triggered();\n        } else {\n            handled = false;\n        }\n        break;\n    case Qt::Key_F:\n        if (event->modifiers() == Qt::NoModifier || event->modifiers() == Qt::ControlModifier) {\n            m_filtersDock->show();\n            m_filtersDock->raise();\n            m_filtersDock->widget()->setFocus();\n            m_filtersDock->openFilterMenu();\n        } else if (event->modifiers() == Qt::ShiftModifier) {\n            filterController()->removeCurrent();\n        } else {\n            handled = false;\n        }\n        break;\n    case Qt::Key_H:\n#ifdef Q_OS_MAC\n        // OS X uses Cmd+H to hide an app.\n        if (event->modifiers() & Qt::MetaModifier && isMultitrackValid())\n#else\n        if (event->modifiers() & Qt::ControlModifier && isMultitrackValid())\n#endif\n            m_timelineDock->toggleTrackHidden(m_timelineDock->currentTrack());\n        break;\n    case Qt::Key_J:\n        if (m_isKKeyPressed)\n            m_player->seek(m_player->position() - 1);\n        else\n            m_player->rewind(false);\n        break;\n    case Qt::Key_K:\n            m_player->pause();\n            m_isKKeyPressed = true;\n        break;\n    case Qt::Key_L:\n#ifdef Q_OS_MAC\n        // OS X uses Cmd+H to hide an app and Cmd+M to minimize. Therefore, we force\n        // it to be the apple keyboard control key aka meta. Therefore, to be\n        // consistent with all track header toggles, we make the lock toggle also use\n        // meta.\n        if (event->modifiers() & Qt::MetaModifier && isMultitrackValid())\n#else\n        if (event->modifiers() & Qt::ControlModifier && isMultitrackValid())\n#endif\n            m_timelineDock->setTrackLock(m_timelineDock->currentTrack(), !m_timelineDock->isTrackLocked(m_timelineDock->currentTrack()));\n        else if (m_isKKeyPressed)\n            m_player->seek(m_player->position() + 1);\n        else\n            m_player->fastForward(false);\n        break;\n    case Qt::Key_M:\n#ifdef Q_OS_MAC\n        // OS X uses Cmd+M to minimize an app.\n        if (event->modifiers() & Qt::MetaModifier && isMultitrackValid())\n#else\n        if (event->modifiers() & Qt::ControlModifier && isMultitrackValid())\n#endif\n            m_timelineDock->toggleTrackMute(m_timelineDock->currentTrack());\n        break;\n    case Qt::Key_I:\n        if (event->modifiers() == Qt::ControlModifier) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->addVideoTrack();\n        } else if ((event->modifiers() & Qt::ControlModifier) && (event->modifiers() & Qt::AltModifier)) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->insertTrack();\n        } else {\n            setInToCurrent(event->modifiers() & Qt::ShiftModifier);\n        }\n        break;\n    case Qt::Key_O:\n        setOutToCurrent(event->modifiers() & Qt::ShiftModifier);\n        break;\n    case Qt::Key_P:\n        if (event->modifiers() == Qt::ControlModifier) {\n            Settings.setTimelineSnap(!Settings.timelineSnap());\n        }\n        break;\n    case Qt::Key_R:\n        if (event->modifiers() & Qt::ControlModifier) {\n            if (event->modifiers() & Qt::AltModifier) {\n                Settings.setTimelineRippleAllTracks(!Settings.timelineRippleAllTracks());\n            } else if (event->modifiers() & Qt::ShiftModifier) {\n                Settings.setTimelineRippleAllTracks(!Settings.timelineRipple());\n                Settings.setTimelineRipple(!Settings.timelineRipple());\n            } else {\n                Settings.setTimelineRipple(!Settings.timelineRipple());\n            }\n        } else if (isMultitrackValid()) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            if (MLT.isClip() || m_timelineDock->selection().isEmpty()) {\n                m_timelineDock->replace(-1, -1);\n            } else {\n                auto& selected = m_timelineDock->selection().first();\n                m_timelineDock->replace(selected.y(), selected.x());\n            }\n        }\n        break;\n    case Qt::Key_S:\n        if (isMultitrackValid())\n            m_timelineDock->splitClip();\n        break;\n    case Qt::Key_U:\n        if (event->modifiers() == Qt::ControlModifier) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->addAudioTrack();\n        } else if ((event->modifiers() & Qt::ControlModifier) && (event->modifiers() & Qt::AltModifier)) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->removeTrack();\n        }\n        break;\n    case Qt::Key_V: // Avid Splice In\n        if (event->modifiers() == Qt::ShiftModifier) {\n            m_playlistDock->show();\n            m_playlistDock->raise();\n            m_playlistDock->on_actionInsertCut_triggered();\n        } else {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->insert(-1);\n        }\n        break;\n    case Qt::Key_B:\n        if (event->modifiers() & Qt::ControlModifier && event->modifiers() & Qt::AltModifier) {\n            // Toggle track blending.\n            int trackIndex = m_timelineDock->currentTrack();\n            bool isBottomVideo = m_timelineDock->model()->data(m_timelineDock->model()->index(trackIndex), MultitrackModel::IsBottomVideoRole).toBool();\n            if (!isBottomVideo) {\n                bool isComposite = m_timelineDock->model()->data(m_timelineDock->model()->index(trackIndex), MultitrackModel::IsCompositeRole).toBool();\n                m_timelineDock->setTrackComposite(trackIndex, !isComposite);\n            }\n        } else if (event->modifiers() == Qt::ShiftModifier) {\n            if (m_playlistDock->model()->rowCount() > 0) {\n                // Update playlist item.\n                m_playlistDock->show();\n                m_playlistDock->raise();\n                m_playlistDock->on_actionUpdate_triggered();\n            }\n        } else {\n            // Overwrite on timeline.\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->overwrite(-1);\n        }\n        break;\n    case Qt::Key_Escape: // Avid Toggle Active Monitor\n        if (MLT.isPlaylist()) {\n            if (isMultitrackValid())\n                m_player->onTabBarClicked(Player::ProjectTabIndex);\n            else if (MLT.savedProducer())\n                m_player->onTabBarClicked(Player::SourceTabIndex);\n            else\n                m_playlistDock->on_actionOpen_triggered();\n        } else if (MLT.isMultitrack()) {\n            if (MLT.savedProducer())\n                m_player->onTabBarClicked(Player::SourceTabIndex);\n            // TODO else open clip under playhead of current track if available\n        } else {\n            if (isMultitrackValid() || (playlist() && playlist()->count() > 0))\n                m_player->onTabBarClicked(Player::ProjectTabIndex);\n        }\n        break;\n    case Qt::Key_Up:\n        if (m_playlistDock->isVisible() && event->modifiers() & Qt::AltModifier && m_playlistDock->model()->rowCount() > 0) {\n            m_playlistDock->raise();\n            m_playlistDock->decrementIndex();\n            m_playlistDock->on_actionOpen_triggered();\n        } else if ((event->modifiers() & Qt::ControlModifier) && (event->modifiers() & Qt::ShiftModifier)) {\n            if (m_playlistDock->model()->rowCount() > 0) {\n                m_playlistDock->raise();\n                m_playlistDock->moveClipUp();\n                m_playlistDock->decrementIndex();\n            }\n        } else if (isMultitrackValid()) {\n            int newClipIndex = -1;\n            int trackIndex = m_timelineDock->currentTrack() - 1;\n            if ((event->modifiers() & Qt::ControlModifier) &&\n                    !m_timelineDock->selection().isEmpty() &&\n                    trackIndex > -1) {\n\n                newClipIndex = m_timelineDock->clipIndexAtPosition(trackIndex, m_navigationPosition);\n            }\n\n            m_timelineDock->incrementCurrentTrack(-1);\n\n            if (newClipIndex >= 0) {\n                newClipIndex = qMin(newClipIndex, m_timelineDock->clipCount(trackIndex) - 1);\n                m_timelineDock->setSelection(QList<QPoint>() << QPoint(newClipIndex, trackIndex));\n            }\n\n        }\n        break;\n    case Qt::Key_Down:\n        if (m_playlistDock->isVisible() && event->modifiers() & Qt::AltModifier && m_playlistDock->model()->rowCount() > 0) {\n            m_playlistDock->raise();\n            m_playlistDock->incrementIndex();\n            m_playlistDock->on_actionOpen_triggered();\n        } else if ((event->modifiers() & Qt::ControlModifier) && (event->modifiers() & Qt::ShiftModifier)) {\n            if (m_playlistDock->model()->rowCount() > 0) {\n                m_playlistDock->raise();\n                m_playlistDock->moveClipDown();\n                m_playlistDock->incrementIndex();\n            }\n        } else if (isMultitrackValid()) {\n            int newClipIndex = -1;\n            int trackIndex = m_timelineDock->currentTrack() + 1;\n            if ((event->modifiers() & Qt::ControlModifier) &&\n                    !m_timelineDock->selection().isEmpty() &&\n                    trackIndex < m_timelineDock->model()->trackList().count()) {\n\n                newClipIndex = m_timelineDock->clipIndexAtPosition(trackIndex, m_navigationPosition);\n            }\n\n            m_timelineDock->incrementCurrentTrack(1);\n\n            if (newClipIndex >= 0) {\n                newClipIndex = qMin(newClipIndex, m_timelineDock->clipCount(trackIndex) - 1);\n                m_timelineDock->setSelection(QList<QPoint>() << QPoint(newClipIndex, trackIndex));\n            }\n\n        }\n        break;\n    case Qt::Key_1:\n    case Qt::Key_2:\n    case Qt::Key_3:\n    case Qt::Key_4:\n    case Qt::Key_5:\n    case Qt::Key_6:\n    case Qt::Key_7:\n    case Qt::Key_8:\n    case Qt::Key_9:\n        if (!event->modifiers() && m_playlistDock->isVisible() && m_playlistDock->model()->rowCount() > 0) {\n            m_playlistDock->raise();\n            m_playlistDock->setIndex(event->key() - Qt::Key_1);\n        }\n        break;\n    case Qt::Key_0:\n        if (!event->modifiers() ) {\n            if (m_timelineDock->isVisible()) {\n                m_timelineDock->resetZoom();\n            } else if (m_playlistDock->isVisible() && m_playlistDock->model()->rowCount() > 0) {\n                m_playlistDock->raise();\n                m_playlistDock->setIndex(9);\n            }\n        }\n        if (m_keyframesDock->isVisible() && (event->modifiers() & Qt::AltModifier)) {\n            emit m_keyframesDock->resetZoom();\n        }\n        break;\n    case Qt::Key_X: // Avid Extract\n        if (event->modifiers() == Qt::ShiftModifier && m_playlistDock->model()->rowCount() > 0) {\n            m_playlistDock->show();\n            m_playlistDock->raise();\n            m_playlistDock->on_removeButton_clicked();\n        } else if (isMultitrackValid()) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->removeSelection();\n        }\n        break;\n    case Qt::Key_Backspace:\n    case Qt::Key_Delete:\n        if (isMultitrackValid()) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            if (event->modifiers() == Qt::ShiftModifier)\n                m_timelineDock->removeSelection();\n            else\n                m_timelineDock->liftSelection();\n        } else if (m_playlistDock->model()->rowCount() > 0) {\n            m_playlistDock->show();\n            m_playlistDock->raise();\n            m_playlistDock->on_removeButton_clicked();\n        }\n        break;\n    case Qt::Key_Z: // Avid Lift\n        if (event->modifiers() == Qt::ShiftModifier && m_playlistDock->model()->rowCount() > 0) {\n            m_playlistDock->show();\n            m_playlistDock->raise();\n            m_playlistDock->on_removeButton_clicked();\n        } else if (isMultitrackValid() && event->modifiers() == Qt::NoModifier) {\n            m_timelineDock->show();\n            m_timelineDock->raise();\n            m_timelineDock->liftSelection();\n        }\n        break;\n    case Qt::Key_Minus:\n        if (m_timelineDock->isVisible() && !(event->modifiers() & Qt::AltModifier)) {\n            if (event->modifiers() & Qt::ControlModifier)\n                m_timelineDock->makeTracksShorter();\n            else\n                m_timelineDock->zoomOut();\n        }\n        if (m_keyframesDock->isVisible() && (event->modifiers() & Qt::AltModifier)) {\n            emit m_keyframesDock->zoomOut();\n        }\n        break;\n    case Qt::Key_Equal:\n    case Qt::Key_Plus:\n        if (m_timelineDock->isVisible() && !(event->modifiers() & Qt::AltModifier)) {\n            if (event->modifiers() & Qt::ControlModifier)\n                m_timelineDock->makeTracksTaller();\n            else\n                m_timelineDock->zoomIn();\n        }\n        if (m_keyframesDock->isVisible() && (event->modifiers() & Qt::AltModifier)) {\n            emit m_keyframesDock->zoomIn();\n        }\n        break;\n    case Qt::Key_Enter: // Seek to current playlist item\n    case Qt::Key_Return:\n        if (m_playlistDock->isVisible() && m_playlistDock->position() >= 0) {\n            if (event->modifiers() == Qt::ShiftModifier)\n                seekPlaylist(m_playlistDock->position());\n            else if (event->modifiers() == Qt::ControlModifier)\n                m_playlistDock->on_actionOpen_triggered();\n        }\n        break;\n    case Qt::Key_F2:\n        onPropertiesDockTriggered(true);\n        emit renameRequested();\n        break;\n    case Qt::Key_F3:\n        onRecentDockTriggered(true);\n        m_recentDock->find();\n        break;\n    case Qt::Key_F5:\n        m_timelineDock->model()->reload();\n        m_keyframesDock->model().reload();\n        break;\n    case Qt::Key_F12:\n        LOG_DEBUG() << \"event isAccepted:\" << event->isAccepted();\n        LOG_DEBUG() << \"Current focusWidget:\" << QApplication::focusWidget();\n        LOG_DEBUG() << \"Current focusObject:\" << QApplication::focusObject();\n        LOG_DEBUG() << \"Current focusWindow:\" << QApplication::focusWindow();\n        break;\n    case Qt::Key_BracketLeft:\n        if (filterController()->currentFilter() && m_filtersDock->qmlProducer()) {\n            if (event->modifiers() == Qt::AltModifier) {\n                emit m_keyframesDock->seekPreviousSimple();\n            } else {\n                int i = m_filtersDock->qmlProducer()->position() + m_filtersDock->qmlProducer()->in();\n                filterController()->currentFilter()->setIn(i);\n            }\n        }\n        break;\n    case Qt::Key_BracketRight:\n        if (filterController()->currentFilter() && m_filtersDock->qmlProducer()) {\n            if (event->modifiers() == Qt::AltModifier) {\n                emit m_keyframesDock->seekNextSimple();\n            } else {\n                int i = m_filtersDock->qmlProducer()->position() + m_filtersDock->qmlProducer()->in();\n                filterController()->currentFilter()->setOut(i);\n            }\n        }\n        break;\n    case Qt::Key_BraceLeft:\n        if (filterController()->currentFilter() && m_filtersDock->qmlProducer()) {\n            int i = m_filtersDock->qmlProducer()->position() + m_filtersDock->qmlProducer()->in() - filterController()->currentFilter()->in();\n            filterController()->currentFilter()->setAnimateIn(i);\n        }\n        break;\n    case Qt::Key_BraceRight:\n        if (filterController()->currentFilter() && m_filtersDock->qmlProducer()) {\n            int i = filterController()->currentFilter()->out() - (m_filtersDock->qmlProducer()->position() + m_filtersDock->qmlProducer()->in());\n            filterController()->currentFilter()->setAnimateOut(i);\n        }\n        break;\n    case Qt::Key_Semicolon:\n        if (filterController()->currentFilter() && m_filtersDock->qmlProducer() && m_keyframesDock->currentParameter() >= 0) {\n            auto position = m_filtersDock->qmlProducer()->position() - (filterController()->currentFilter()->in() - m_filtersDock->qmlProducer()->in());\n            auto parameterIndex = m_keyframesDock->currentParameter();\n            if (m_keyframesDock->model().isKeyframe(parameterIndex, position)) {\n                auto keyframeIndex = m_keyframesDock->model().keyframeIndex(parameterIndex, position);\n                m_keyframesDock->model().remove(parameterIndex, keyframeIndex);\n            } else {\n                m_keyframesDock->model().addKeyframe(parameterIndex, position);\n            }\n        }\n        break;\n    default:\n        handled = false;\n        break;\n    }\n\n    if (handled)\n        event->setAccepted(handled);\n    else\n        QMainWindow::keyPressEvent(event);\n}\n\nvoid MainWindow::keyReleaseEvent(QKeyEvent* event)\n{\n    if (event->key() == Qt::Key_K) {\n        m_isKKeyPressed = false;\n        event->setAccepted(true);\n    } else {\n        QMainWindow::keyReleaseEvent(event);\n    }\n}\n\nvoid MainWindow::hideSetDataDirectory()\n{\n    delete ui->actionAppDataSet;\n}\n\nQAction *MainWindow::actionAddCustomProfile() const\n{\n    return ui->actionAddCustomProfile;\n}\n\nQAction *MainWindow::actionProfileRemove() const\n{\n    return ui->actionProfileRemove;\n}\n\nvoid MainWindow::buildVideoModeMenu(QMenu* topMenu, QMenu*& customMenu, QActionGroup* group, QAction* addAction, QAction* removeAction)\n{\n    topMenu->addAction(addProfile(group, \"HD 720p 50 fps\", \"atsc_720p_50\"));\n    topMenu->addAction(addProfile(group, \"HD 720p 59.94 fps\", \"atsc_720p_5994\"));\n    topMenu->addAction(addProfile(group, \"HD 720p 60 fps\", \"atsc_720p_60\"));\n    topMenu->addAction(addProfile(group, \"HD 1080i 25 fps\", \"atsc_1080i_50\"));\n    topMenu->addAction(addProfile(group, \"HD 1080i 29.97 fps\", \"atsc_1080i_5994\"));\n    topMenu->addAction(addProfile(group, \"HD 1080p 23.98 fps\", \"atsc_1080p_2398\"));\n    topMenu->addAction(addProfile(group, \"HD 1080p 24 fps\", \"atsc_1080p_24\"));\n    topMenu->addAction(addProfile(group, \"HD 1080p 25 fps\", \"atsc_1080p_25\"));\n    topMenu->addAction(addProfile(group, \"HD 1080p 29.97 fps\", \"atsc_1080p_2997\"));\n    topMenu->addAction(addProfile(group, \"HD 1080p 30 fps\", \"atsc_1080p_30\"));\n    topMenu->addAction(addProfile(group, \"HD 1080p 59.94 fps\", \"atsc_1080p_5994\"));\n    topMenu->addAction(addProfile(group, \"HD 1080p 50 fps\", \"atsc_1080p_50\"));\n    topMenu->addAction(addProfile(group, \"HD 1080p 60 fps\", \"atsc_1080p_60\"));\n    topMenu->addAction(addProfile(group, \"SD NTSC\", \"dv_ntsc\"));\n    topMenu->addAction(addProfile(group, \"SD PAL\", \"dv_pal\"));\n    topMenu->addAction(addProfile(group, \"UHD 2160p 23.98 fps\", \"uhd_2160p_2398\"));\n    topMenu->addAction(addProfile(group, \"UHD 2160p 24 fps\", \"uhd_2160p_24\"));\n    topMenu->addAction(addProfile(group, \"UHD 2160p 25 fps\", \"uhd_2160p_25\"));\n    topMenu->addAction(addProfile(group, \"UHD 2160p 29.97 fps\", \"uhd_2160p_2997\"));\n    topMenu->addAction(addProfile(group, \"UHD 2160p 30 fps\", \"uhd_2160p_30\"));\n    topMenu->addAction(addProfile(group, \"UHD 2160p 50 fps\", \"uhd_2160p_50\"));\n    topMenu->addAction(addProfile(group, \"UHD 2160p 59.94 fps\", \"uhd_2160p_5994\"));\n    topMenu->addAction(addProfile(group, \"UHD 2160p 60 fps\", \"uhd_2160p_60\"));\n    QMenu* menu = topMenu->addMenu(tr(\"Non-Broadcast\"));\n    menu->addAction(addProfile(group, \"640x480 4:3 NTSC\", \"square_ntsc\"));\n    menu->addAction(addProfile(group, \"768x576 4:3 PAL\", \"square_pal\"));\n    menu->addAction(addProfile(group, \"854x480 16:9 NTSC\", \"square_ntsc_wide\"));\n    menu->addAction(addProfile(group, \"1024x576 16:9 PAL\", \"square_pal_wide\"));\n    menu->addAction(addProfile(group, tr(\"DVD Widescreen NTSC\"), \"dv_ntsc_wide\"));\n    menu->addAction(addProfile(group, tr(\"DVD Widescreen PAL\"), \"dv_pal_wide\"));\n    menu->addAction(addProfile(group, \"HD 720p 23.98 fps\", \"atsc_720p_2398\"));\n    menu->addAction(addProfile(group, \"HD 720p 24 fps\", \"atsc_720p_24\"));\n    menu->addAction(addProfile(group, \"HD 720p 25 fps\", \"atsc_720p_25\"));\n    menu->addAction(addProfile(group, \"HD 720p 29.97 fps\", \"atsc_720p_2997\"));\n    menu->addAction(addProfile(group, \"HD 720p 30 fps\", \"atsc_720p_30\"));\n    menu->addAction(addProfile(group, \"HD 1080i 60 fps\", \"atsc_1080i_60\"));\n    menu->addAction(addProfile(group, \"HDV 1080i 25 fps\", \"hdv_1080_50i\"));\n    menu->addAction(addProfile(group, \"HDV 1080i 29.97 fps\", \"hdv_1080_60i\"));\n    menu->addAction(addProfile(group, \"HDV 1080p 25 fps\", \"hdv_1080_25p\"));\n    menu->addAction(addProfile(group, \"HDV 1080p 29.97 fps\", \"hdv_1080_30p\"));\n    menu->addAction(addProfile(group, tr(\"Square 1080p 30 fps\"), \"square_1080p_30\"));\n    menu->addAction(addProfile(group, tr(\"Square 1080p 60 fps\"), \"square_1080p_60\"));\n    menu->addAction(addProfile(group, tr(\"Vertical HD 30 fps\"), \"vertical_hd_30\"));\n    menu->addAction(addProfile(group, tr(\"Vertical HD 60 fps\"), \"vertical_hd_60\"));\n    customMenu = topMenu->addMenu(tr(\"Custom\"));\n    customMenu->addAction(addAction);\n    // Load custom profiles\n    QDir dir(Settings.appDataLocation());\n    if (dir.cd(\"profiles\")) {\n        QStringList profiles = dir.entryList(QDir::Files | QDir::NoDotAndDotDot | QDir::Readable);\n        if (profiles.length() > 0) {\n            customMenu->addAction(removeAction);\n            customMenu->addSeparator();\n        }\n        foreach (QString name, profiles)\n            customMenu->addAction(addProfile(group, name, dir.filePath(name)));\n    }\n}\n\nvoid MainWindow::newProject(const QString &filename, bool isProjectFolder)\n{\n    if (isProjectFolder) {\n        QFileInfo info(filename);\n        MLT.setProjectFolder(info.absolutePath());\n    }\n    if (saveXML(filename)) {\n        QMutexLocker locker(&m_autosaveMutex);\n        if (m_autosaveFile)\n            m_autosaveFile->changeManagedFile(filename);\n        else\n            m_autosaveFile.reset(new AutoSaveFile(filename));\n        setCurrentFile(filename);\n        setWindowModified(false);\n        if (MLT.producer())\n            showStatusMessage(tr(\"Saved %1\").arg(m_currentFile));\n        m_undoStack->setClean();\n        m_recentDock->add(filename);\n    } else {\n        showSaveError();\n    }\n}\n\nvoid MainWindow::addCustomProfile(const QString &name, QMenu *menu, QAction *action, QActionGroup *group)\n{\n    // Add new profile to the menu.\n    QDir dir(Settings.appDataLocation());\n    if (dir.cd(\"profiles\")) {\n        QStringList profiles = dir.entryList(QDir::Files | QDir::NoDotAndDotDot | QDir::Readable);\n        if (profiles.length() == 1) {\n            menu->addAction(action);\n            menu->addSeparator();\n        }\n        action = addProfile(group, name, dir.filePath(name));\n        action->setChecked(true);\n        menu->addAction(action);\n        Settings.setPlayerProfile(dir.filePath(name));\n        Settings.sync();\n    }\n}\n\nvoid MainWindow::removeCustomProfiles(const QStringList &profiles, QDir& dir, QMenu *menu, QAction *action)\n{\n    foreach(const QString& profile, profiles) {\n        // Remove the file.\n        dir.remove(profile);\n        // Locate the menu item.\n        foreach (QAction* a, menu->actions()) {\n            if (a->text() == profile) {\n                // Remove the menu item.\n                delete a;\n                break;\n            }\n        }\n    }\n    // If no more custom video modes.\n    if (menu->actions().size() == 3) {\n        // Remove the Remove action and separator.\n        menu->removeAction(action);\n        foreach (QAction* a, menu->actions()) {\n            if (a->isSeparator()) {\n                delete a;\n                break;\n            }\n        }\n    }\n}\n\n// Drag-n-drop events\n\nbool MainWindow::eventFilter(QObject* target, QEvent* event)\n{\n    if (event->type() == QEvent::DragEnter && target == MLT.videoWidget()) {\n        dragEnterEvent(static_cast<QDragEnterEvent*>(event));\n        return true;\n    } else if (event->type() == QEvent::Drop && target == MLT.videoWidget()) {\n        dropEvent(static_cast<QDropEvent*>(event));\n        return true;\n    } else if (event->type() == QEvent::KeyPress || event->type() == QEvent::KeyRelease) {\n        if (QEvent::KeyPress == event->type()) {\n            // Let Shift+Escape be a global hook to defocus a widget (assign global player focus).\n            auto keyEvent = static_cast<QKeyEvent*>(event);\n            if (Qt::Key_Escape == keyEvent->key() && Qt::ShiftModifier == keyEvent->modifiers()) {\n                m_player->setFocus();\n                return true;\n            }\n        }\n        QQuickWidget * focusedQuickWidget = qobject_cast<QQuickWidget*>(qApp->focusWidget());\n        if (focusedQuickWidget && focusedQuickWidget->quickWindow()->activeFocusItem()) {\n            event->accept();\n            focusedQuickWidget->quickWindow()->sendEvent(focusedQuickWidget->quickWindow()->activeFocusItem(), event);\n            QWidget * w = focusedQuickWidget->parentWidget();\n            if (!event->isAccepted())\n                qApp->sendEvent(w, event);\n            return true;\n        }\n    }\n    return QMainWindow::eventFilter(target, event);\n}\n\nvoid MainWindow::dragEnterEvent(QDragEnterEvent *event)\n{\n    // Simulate the player firing a dragStarted even to make the playlist close\n    // its help text view. This lets one drop a clip directly into the playlist\n    // from a fresh start.\n    Mlt::GLWidget* videoWidget = (Mlt::GLWidget*) &Mlt::Controller::singleton();\n    emit videoWidget->dragStarted();\n\n    event->acceptProposedAction();\n}\n\nvoid MainWindow::dropEvent(QDropEvent *event)\n{\n    const QMimeData *mimeData = event->mimeData();\n    if (mimeData->hasFormat(\"application/x-qabstractitemmodeldatalist\")) {\n        QByteArray encoded = mimeData->data(\"application/x-qabstractitemmodeldatalist\");\n        QDataStream stream(&encoded, QIODevice::ReadOnly);\n        QMap<int,  QVariant> roleDataMap;\n        while (!stream.atEnd()) {\n            int row, col;\n            stream >> row >> col >> roleDataMap;\n        }\n        if (roleDataMap.contains(Qt::ToolTipRole)) {\n            // DisplayRole is just basename, ToolTipRole contains full path\n            open(roleDataMap[Qt::ToolTipRole].toString());\n            event->acceptProposedAction();\n        }\n    }\n    else if (mimeData->hasUrls()) {\n        openMultiple(mimeData->urls());\n        event->acceptProposedAction();\n    }\n    else if (mimeData->hasFormat(Mlt::XmlMimeType )) {\n        m_playlistDock->on_actionOpen_triggered();\n        event->acceptProposedAction();\n    }\n}\n\nvoid MainWindow::closeEvent(QCloseEvent* event)\n{\n    if (continueJobsRunning() && continueModified()) {\n        if (!m_htmlEditor || m_htmlEditor->close()) {\n            LOG_DEBUG() << \"begin\";\n            JOBS.cleanup();\n            writeSettings();\n            if (m_exitCode == EXIT_SUCCESS) {\n                MLT.stop();\n            } else {\n                if (multitrack())\n                    m_timelineDock->model()->close();\n                if (playlist())\n                    m_playlistDock->model()->close();\n                else\n                    onMultitrackClosed();\n            }\n            QThreadPool::globalInstance()->clear();\n            AudioLevelsTask::closeAll();\n            event->accept();\n            emit aboutToShutDown();\n            if (m_exitCode == EXIT_SUCCESS) {\n                QApplication::quit();\n                LOG_DEBUG() << \"end\";\n                ::_Exit(0);\n            } else {\n                QApplication::exit(m_exitCode);\n                LOG_DEBUG() << \"end\";\n            }\n            return;\n        }\n    }\n    event->ignore();\n}\n\nvoid MainWindow::showEvent(QShowEvent* event)\n{\n    // This is needed to prevent a crash on windows on startup when timeline\n    // is visible and dock title bars are hidden.\n    Q_UNUSED(event)\n    ui->actionShowTitleBars->setChecked(Settings.showTitleBars());\n    on_actionShowTitleBars_triggered(Settings.showTitleBars());\n    ui->actionShowToolbar->setChecked(Settings.showToolBar());\n    on_actionShowToolbar_triggered(Settings.showToolBar());\n    ui->actionShowTextUnderIcons->setChecked(Settings.textUnderIcons());\n    on_actionShowTextUnderIcons_toggled(Settings.textUnderIcons());\n    ui->actionShowSmallIcons->setChecked(Settings.smallIcons());\n    on_actionShowSmallIcons_toggled(Settings.smallIcons());\n\n    windowHandle()->installEventFilter(this);\n\n#ifndef SHOTCUT_NOUPGRADE\n    if (!Settings.noUpgrade() && !qApp->property(\"noupgrade\").toBool())\n        QTimer::singleShot(0, this, SLOT(showUpgradePrompt()));\n#endif\n}\n\nvoid MainWindow::on_actionOpenOther_triggered()\n{\n    // these static are used to open dialog with previous configuration\n    OpenOtherDialog dialog(this);\n\n    if (MLT.producer())\n        dialog.load(MLT.producer());\n    if (dialog.exec() == QDialog::Accepted) {\n        closeProducer();\n        open(dialog.newProducer(MLT.profile()));\n    }\n}\n\nvoid MainWindow::onProducerOpened(bool withReopen)\n{\n    QWidget* w = loadProducerWidget(MLT.producer());\n    if (withReopen && w && !MLT.producer()->get(kMultitrackItemProperty)) {\n        if (-1 != w->metaObject()->indexOfSignal(\"producerReopened()\"))\n            connect(w, SIGNAL(producerReopened()), m_player, SLOT(onProducerOpened()));\n    }\n    else if (MLT.isPlaylist()) {\n        m_playlistDock->model()->load();\n        if (playlist()) {\n            m_isPlaylistLoaded = true;\n            m_player->setIn(-1);\n            m_player->setOut(-1);\n            m_playlistDock->setVisible(true);\n            m_playlistDock->raise();\n            m_player->enableTab(Player::ProjectTabIndex);\n            m_player->switchToTab(Player::ProjectTabIndex);\n        }\n    }\n    else if (MLT.isMultitrack()) {\n        m_timelineDock->blockSelection(true);\n        m_timelineDock->model()->load();\n        m_timelineDock->blockSelection(false);\n        if (isMultitrackValid()) {\n            m_player->setIn(-1);\n            m_player->setOut(-1);\n            m_timelineDock->setVisible(true);\n            m_timelineDock->raise();\n            m_player->enableTab(Player::ProjectTabIndex);\n            m_player->switchToTab(Player::ProjectTabIndex);\n            m_timelineDock->selectMultitrack();\n            QTimer::singleShot(0, [=]() {\n                m_timelineDock->setSelection();\n            });\n        }\n    }\n    if (MLT.isClip()) {\n        m_player->enableTab(Player::SourceTabIndex);\n        m_player->switchToTab(Player::SourceTabIndex);\n        Util::getHash(*MLT.producer());\n        ui->actionPaste->setEnabled(true);\n    }\n    QMutexLocker locker(&m_autosaveMutex);\n    if (m_autosaveFile)\n        setCurrentFile(m_autosaveFile->managedFileName());\n    else if (!MLT.URL().isEmpty())\n        setCurrentFile(MLT.URL());\n    on_actionJack_triggered(ui->actionJack && ui->actionJack->isChecked());\n}\n\nvoid MainWindow::onProducerChanged()\n{\n    MLT.refreshConsumer();\n    if (playlist() && MLT.producer() && MLT.producer()->is_valid()\n        && MLT.producer()->get_int(kPlaylistIndexProperty))\n        m_playlistDock->setUpdateButtonEnabled(true);\n}\n\nbool MainWindow::on_actionSave_triggered()\n{\n    if (m_currentFile.isEmpty()) {\n        return on_actionSave_As_triggered();\n    } else {\n        if (Util::warnIfNotWritable(m_currentFile, this, tr(\"Save XML\")))\n            return false;\n        bool success = saveXML(m_currentFile);\n        QMutexLocker locker(&m_autosaveMutex);\n        m_autosaveFile.reset(new AutoSaveFile(m_currentFile));\n        setCurrentFile(m_currentFile);\n        setWindowModified(false);\n        if (success) {\n            showStatusMessage(tr(\"Saved %1\").arg(m_currentFile));\n        } else {\n            showSaveError();\n        }\n        m_undoStack->setClean();\n        return true;\n    }\n}\n\nbool MainWindow::on_actionSave_As_triggered()\n{\n    QString path = Settings.savePath();\n    if (!m_currentFile.isEmpty())\n        path = m_currentFile;\n    QString caption = tr(\"Save XML\");\n    QString filename = QFileDialog::getSaveFileName(this, caption, path, tr(\"MLT XML (*.mlt)\"));\n    if (!filename.isEmpty()) {\n        QFileInfo fi(filename);\n        Settings.setSavePath(fi.path());\n        if (fi.suffix() != \"mlt\")\n            filename += \".mlt\";\n\n        if (Util::warnIfNotWritable(filename, this, caption))\n            return false;\n        newProject(filename);\n    }\n    return !filename.isEmpty();\n}\n\nbool MainWindow::continueModified()\n{\n    if (isWindowModified()) {\n        QMessageBox dialog(QMessageBox::Warning,\n                                     qApp->applicationName(),\n                                     tr(\"The project has been modified.\\n\"\n                                        \"Do you want to save your changes?\"),\n                                     QMessageBox::No |\n                                     QMessageBox::Cancel |\n                                     QMessageBox::Yes,\n                                     this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::Cancel);\n        int r = dialog.exec();\n        if (r == QMessageBox::Yes || r == QMessageBox::No) {\n            if (r == QMessageBox::Yes) {\n                return on_actionSave_triggered();\n            } else {\n                QMutexLocker locker(&m_autosaveMutex);\n                m_autosaveFile.reset();\n            }\n        } else if (r == QMessageBox::Cancel) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool MainWindow::continueJobsRunning()\n{\n    if (JOBS.hasIncomplete()) {\n        QMessageBox dialog(QMessageBox::Warning,\n                                     qApp->applicationName(),\n                                     tr(\"There are incomplete jobs.\\n\"\n                                        \"Do you want to still want to exit?\"),\n                                     QMessageBox::No |\n                                     QMessageBox::Yes,\n                                     this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        return (dialog.exec() == QMessageBox::Yes);\n    }\n    if (m_encodeDock->isExportInProgress()) {\n        QMessageBox dialog(QMessageBox::Warning,\n                                     qApp->applicationName(),\n                                     tr(\"An export is in progress.\\n\"\n                                        \"Do you want to still want to exit?\"),\n                                     QMessageBox::No |\n                                     QMessageBox::Yes,\n                                     this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        return (dialog.exec() == QMessageBox::Yes);\n    }\n    return true;\n}\n\nQUndoStack* MainWindow::undoStack() const\n{\n    return m_undoStack;\n}\n\nvoid MainWindow::onEncodeTriggered(bool checked)\n{\n    if (checked) {\n        m_encodeDock->show();\n        m_encodeDock->raise();\n    }\n}\n\nvoid MainWindow::onCaptureStateChanged(bool started)\n{\n    if (started && (MLT.resource().startsWith(\"x11grab:\") ||\n                    MLT.resource().startsWith(\"gdigrab:\") ||\n                    MLT.resource().startsWith(\"avfoundation\"))\n                && !MLT.producer()->get_int(kBackgroundCaptureProperty))\n        showMinimized();\n}\n\nvoid MainWindow::onJobsDockTriggered(bool checked)\n{\n    if (checked) {\n        m_jobsDock->show();\n        m_jobsDock->raise();\n    }\n}\n\nvoid MainWindow::onRecentDockTriggered(bool checked)\n{\n    if (checked) {\n        m_recentDock->show();\n        m_recentDock->raise();\n    }\n}\n\nvoid MainWindow::onPropertiesDockTriggered(bool checked)\n{\n    if (checked) {\n        m_propertiesDock->show();\n        m_propertiesDock->raise();\n    }\n}\n\nvoid MainWindow::onPlaylistDockTriggered(bool checked)\n{\n    if (checked) {\n        m_playlistDock->show();\n        m_playlistDock->raise();\n    }\n}\n\nvoid MainWindow::onTimelineDockTriggered(bool checked)\n{\n    if (checked) {\n        m_timelineDock->show();\n        m_timelineDock->raise();\n    }\n}\n\nvoid MainWindow::onHistoryDockTriggered(bool checked)\n{\n    if (checked) {\n        m_historyDock->show();\n        m_historyDock->raise();\n    }\n}\n\nvoid MainWindow::onFiltersDockTriggered(bool checked)\n{\n    if (checked) {\n        m_filtersDock->show();\n        m_filtersDock->raise();\n    }\n}\n\nvoid MainWindow::onKeyframesDockTriggered(bool checked)\n{\n    if (checked) {\n        m_keyframesDock->show();\n        m_keyframesDock->raise();\n    }\n}\n\nvoid MainWindow::onPlaylistCreated()\n{\n    if (!playlist() || playlist()->count() == 0) return;\n    m_player->enableTab(Player::ProjectTabIndex, true);\n}\n\nvoid MainWindow::onPlaylistLoaded()\n{\n    updateMarkers();\n    m_player->enableTab(Player::ProjectTabIndex, true);\n}\n\nvoid MainWindow::onPlaylistCleared()\n{\n    m_player->onTabBarClicked(Player::SourceTabIndex);\n    setWindowModified(true);\n}\n\nvoid MainWindow::onPlaylistClosed()\n{\n    closeProducer();\n    setProfile(Settings.playerProfile());\n    resetVideoModeMenu();\n    setAudioChannels(Settings.playerAudioChannels());\n    setCurrentFile(\"\");\n    setWindowModified(false);\n    m_undoStack->clear();\n    MLT.resetURL();\n    QMutexLocker locker(&m_autosaveMutex);\n    m_autosaveFile.reset(new AutoSaveFile(untitledFileName()));\n    if (!isMultitrackValid())\n        m_player->enableTab(Player::ProjectTabIndex, false);\n}\n\nvoid MainWindow::onPlaylistModified()\n{\n    setWindowModified(true);\n    if (MLT.producer() && playlist() && (void*) MLT.producer()->get_producer() == (void*) playlist()->get_playlist())\n        m_player->onDurationChanged();\n    updateMarkers();\n    m_player->enableTab(Player::ProjectTabIndex, true);\n}\n\nvoid MainWindow::onMultitrackCreated()\n{\n    m_player->enableTab(Player::ProjectTabIndex, true);\n}\n\nvoid MainWindow::onMultitrackClosed()\n{\n    setAudioChannels(Settings.playerAudioChannels());\n    closeProducer();\n    setProfile(Settings.playerProfile());\n    resetVideoModeMenu();\n    setCurrentFile(\"\");\n    setWindowModified(false);\n    m_undoStack->clear();\n    MLT.resetURL();\n    QMutexLocker locker(&m_autosaveMutex);\n    m_autosaveFile.reset(new AutoSaveFile(untitledFileName()));\n    if (!playlist() || playlist()->count() == 0)\n        m_player->enableTab(Player::ProjectTabIndex, false);\n}\n\nvoid MainWindow::onMultitrackModified()\n{\n    setWindowModified(true);\n\n    // Reflect this playlist info onto the producer for keyframes dock.\n    if (!m_timelineDock->selection().isEmpty()) {\n        int trackIndex = m_timelineDock->selection().first().y();\n        int clipIndex = m_timelineDock->selection().first().x();\n        QScopedPointer<Mlt::ClipInfo> info(m_timelineDock->getClipInfo(trackIndex, clipIndex));\n        if (info && info->producer && info->producer->is_valid()) {\n            int expected = info->frame_in;\n            QScopedPointer<Mlt::ClipInfo> info2(m_timelineDock->getClipInfo(trackIndex, clipIndex - 1));\n            if (info2 && info2->producer && info2->producer->is_valid()\n                      && info2->producer->get(kShotcutTransitionProperty)) {\n                // Factor in a transition left of the clip.\n                expected -= info2->frame_count;\n                info->producer->set(kPlaylistStartProperty, info2->start);\n            } else {\n                info->producer->set(kPlaylistStartProperty, info->start);\n            }\n            if (expected != info->producer->get_int(kFilterInProperty)) {\n                int delta = expected - info->producer->get_int(kFilterInProperty);\n                info->producer->set(kFilterInProperty, expected);\n                emit m_filtersDock->producerInChanged(delta);\n            }\n            expected = info->frame_out;\n            info2.reset(m_timelineDock->getClipInfo(trackIndex, clipIndex + 1));\n            if (info2 && info2->producer && info2->producer->is_valid()\n                      && info2->producer->get(kShotcutTransitionProperty)) {\n                // Factor in a transition right of the clip.\n                expected += info2->frame_count;\n            }\n            if (expected != info->producer->get_int(kFilterOutProperty)) {\n                int delta = expected - info->producer->get_int(kFilterOutProperty);\n                info->producer->set(kFilterOutProperty, expected);\n                emit m_filtersDock->producerOutChanged(delta);\n            }\n        }\n    }\n}\n\nvoid MainWindow::onMultitrackDurationChanged()\n{\n    if (MLT.producer() && (void*) MLT.producer()->get_producer() == (void*) multitrack()->get_producer())\n        m_player->onDurationChanged();\n}\n\nvoid MainWindow::onCutModified()\n{\n    if (!playlist() && !multitrack()) {\n        setWindowModified(true);\n        updateAutoSave();\n    }\n    if (playlist())\n        m_playlistDock->setUpdateButtonEnabled(true);\n}\n\nvoid MainWindow::onProducerModified()\n{\n    setWindowModified(true);\n    updateAutoSave();\n}\n\nvoid MainWindow::onFilterModelChanged()\n{\n    MLT.refreshConsumer();\n    setWindowModified(true);\n    updateAutoSave();\n    if (playlist())\n        m_playlistDock->setUpdateButtonEnabled(true);\n}\n\nvoid MainWindow::updateMarkers()\n{\n    if (playlist() && MLT.isPlaylist()) {\n        QList<int> markers;\n        int n = playlist()->count();\n        for (int i = 0; i < n; i++)\n            markers.append(playlist()->clip_start(i));\n        m_player->setMarkers(markers);\n    }\n}\n\nvoid MainWindow::updateThumbnails()\n{\n    if (Settings.playlistThumbnails() != \"hidden\")\n        m_playlistDock->model()->refreshThumbnails();\n}\n\nvoid MainWindow::on_actionUndo_triggered()\n{\n    TimelineSelectionBlocker blocker(*m_timelineDock);\n    m_undoStack->undo();\n}\n\nvoid MainWindow::on_actionRedo_triggered()\n{\n    TimelineSelectionBlocker blocker(*m_timelineDock);\n    m_undoStack->redo();\n}\n\nvoid MainWindow::on_actionFAQ_triggered()\n{\n    QDesktopServices::openUrl(QUrl(\"https://www.shotcut.org/FAQ/\"));\n}\n\nvoid MainWindow::on_actionForum_triggered()\n{\n    QDesktopServices::openUrl(QUrl(\"https://forum.shotcut.org/\"));\n}\n\nbool MainWindow::saveXML(const QString &filename, bool withRelativePaths)\n{\n    bool result;\n    if (m_timelineDock->model()->rowCount() > 0) {\n        result = MLT.saveXML(filename, multitrack(), withRelativePaths);\n    } else if (m_playlistDock->model()->rowCount() > 0) {\n        int in = MLT.producer()->get_in();\n        int out = MLT.producer()->get_out();\n        MLT.producer()->set_in_and_out(0, MLT.producer()->get_length() - 1);\n        result = MLT.saveXML(filename, playlist(), withRelativePaths);\n        MLT.producer()->set_in_and_out(in, out);\n    } else if (MLT.producer()) {\n        result = MLT.saveXML(filename, (MLT.isMultitrack() || MLT.isPlaylist())? MLT.savedProducer() : 0, withRelativePaths);\n    } else {\n        // Save an empty playlist, which is accepted by both MLT and Shotcut.\n        Mlt::Playlist playlist(MLT.profile());\n        result = MLT.saveXML(filename, &playlist, withRelativePaths);\n    }\n    return result;\n}\n\nvoid MainWindow::changeTheme(const QString &theme)\n{\n    LOG_DEBUG() << \"begin\";\n    if (theme == \"dark\") {\n        QApplication::setStyle(\"Fusion\");\n        QPalette palette;\n        palette.setColor(QPalette::Window, QColor(50,50,50));\n        palette.setColor(QPalette::WindowText, QColor(220,220,220));\n        palette.setColor(QPalette::Base, QColor(30,30,30));\n        palette.setColor(QPalette::AlternateBase, QColor(40,40,40));\n        palette.setColor(QPalette::Highlight, QColor(23,92,118));\n        palette.setColor(QPalette::HighlightedText, Qt::white);\n        palette.setColor(QPalette::ToolTipBase, palette.color(QPalette::Highlight));\n        palette.setColor(QPalette::ToolTipText, palette.color(QPalette::WindowText));\n        palette.setColor(QPalette::Text, palette.color(QPalette::WindowText));\n        palette.setColor(QPalette::BrightText, Qt::red);\n        palette.setColor(QPalette::Button, palette.color(QPalette::Window));\n        palette.setColor(QPalette::ButtonText, palette.color(QPalette::WindowText));\n        palette.setColor(QPalette::Link, palette.color(QPalette::Highlight).lighter());\n        palette.setColor(QPalette::LinkVisited, palette.color(QPalette::Highlight));\n        palette.setColor(QPalette::Disabled, QPalette::Text, Qt::darkGray);\n        palette.setColor(QPalette::Disabled, QPalette::ButtonText, Qt::darkGray);\n        QApplication::setPalette(palette);\n        QIcon::setThemeName(\"dark\");\n    } else if (theme == \"light\") {\n        QStyle* style = QStyleFactory::create(\"Fusion\");\n        QApplication::setStyle(style);\n        QApplication::setPalette(style->standardPalette());\n        QIcon::setThemeName(\"light\");\n    } else {\n        QApplication::setStyle(qApp->property(\"system-style\").toString());\n        QIcon::setThemeName(\"oxygen\");\n    }\n    emit QmlApplication::singleton().paletteChanged();\n    LOG_DEBUG() << \"end\";\n}\n\nMlt::Playlist* MainWindow::playlist() const\n{\n    return m_playlistDock->model()->playlist();\n}\n\nbool MainWindow::isPlaylistValid() const\n{\n    return m_playlistDock->model()->playlist()\n        && m_playlistDock->model()->rowCount() > 0;\n}\n\nMlt::Producer *MainWindow::multitrack() const\n{\n    return m_timelineDock->model()->tractor();\n}\n\nbool MainWindow::isMultitrackValid() const\n{\n    return m_timelineDock->model()->tractor()\n       && !m_timelineDock->model()->trackList().empty();\n}\n\nQWidget *MainWindow::loadProducerWidget(Mlt::Producer* producer)\n{\n    QWidget* w = 0;\n    QScrollArea* scrollArea = (QScrollArea*) m_propertiesDock->widget();\n\n    if (!producer || !producer->is_valid()) {\n        if (scrollArea->widget())\n            scrollArea->widget()->deleteLater();\n        return  w;\n    } else {\n        scrollArea->show();\n    }\n\n    QString service(producer->get(\"mlt_service\"));\n    QString resource = QString::fromUtf8(producer->get(\"resource\"));\n    QString shotcutProducer(producer->get(kShotcutProducerProperty));\n\n    if (resource.startsWith(\"video4linux2:\") || QString::fromUtf8(producer->get(\"resource1\")).startsWith(\"video4linux2:\"))\n        w = new Video4LinuxWidget(this);\n    else if (resource.startsWith(\"pulse:\"))\n        w = new PulseAudioWidget(this);\n    else if (resource.startsWith(\"jack:\"))\n        w = new JackProducerWidget(this);\n    else if (resource.startsWith(\"alsa:\"))\n        w = new AlsaWidget(this);\n    else if (resource.startsWith(\"dshow:\") || QString::fromUtf8(producer->get(\"resource1\")).startsWith(\"dshow:\"))\n        w = new DirectShowVideoWidget(this);\n    else if (resource.startsWith(\"avfoundation:\"))\n        w = new AvfoundationProducerWidget(this);\n    else if (resource.startsWith(\"x11grab:\"))\n        w = new X11grabWidget(this);\n    else if (resource.startsWith(\"gdigrab:\"))\n        w = new GDIgrabWidget(this);\n    else if (service.startsWith(\"avformat\") || shotcutProducer == \"avformat\")\n        w = new AvformatProducerWidget(this);\n    else if (MLT.isImageProducer(producer)) {\n        w = new ImageProducerWidget(this);\n        connect(m_player, SIGNAL(outChanged(int)), w, SLOT(updateDuration()));\n    }\n    else if (service == \"decklink\" || resource.contains(\"decklink\"))\n        w = new DecklinkProducerWidget(this);\n    else if (service == \"color\")\n        w = new ColorProducerWidget(this);\n    else if (service == \"noise\")\n        w = new NoiseWidget(this);\n    else if (service == \"frei0r.ising0r\")\n        w = new IsingWidget(this);\n    else if (service == \"frei0r.lissajous0r\")\n        w = new LissajousWidget(this);\n    else if (service == \"frei0r.plasma\")\n        w = new PlasmaWidget(this);\n    else if (service == \"frei0r.test_pat_B\")\n        w = new ColorBarsWidget(this);\n    else if (service == \"webvfx\")\n        w = new WebvfxProducer(this);\n    else if (service == \"tone\")\n        w = new ToneProducerWidget(this);\n    else if (service == \"count\")\n        w = new CountProducerWidget(this);\n    else if (service == \"blipflash\")\n        w = new BlipProducerWidget(this);\n    else if (producer->parent().get(kShotcutTransitionProperty)) {\n        w = new LumaMixTransition(producer->parent(), this);\n        scrollArea->setWidget(w);\n        if (-1 != w->metaObject()->indexOfSignal(\"modified()\"))\n            connect(w, SIGNAL(modified()), SLOT(onProducerModified()));\n        return w;\n    } else if (playlist_type == producer->type()) {\n        int trackIndex = m_timelineDock->currentTrack();\n        bool isBottomVideo = m_timelineDock->model()->data(m_timelineDock->model()->index(trackIndex), MultitrackModel::IsBottomVideoRole).toBool();\n        if (!isBottomVideo) {\n            w = new TrackPropertiesWidget(*producer, this);\n            scrollArea->setWidget(w);\n            return w;\n        }\n    } else if (tractor_type == producer->type()) {\n        w = new TimelinePropertiesWidget(*producer, this);\n        scrollArea->setWidget(w);\n        return w;\n    }\n    if (w) {\n        dynamic_cast<AbstractProducerWidget*>(w)->setProducer(producer);\n        if (-1 != w->metaObject()->indexOfSignal(\"producerChanged(Mlt::Producer*)\")) {\n            connect(w, SIGNAL(producerChanged(Mlt::Producer*)), SLOT(onProducerChanged()));\n            connect(w, SIGNAL(producerChanged(Mlt::Producer*)), m_filterController, SLOT(setProducer(Mlt::Producer*)));\n            connect(w, SIGNAL(producerChanged(Mlt::Producer*)), m_playlistDock, SLOT(onProducerChanged(Mlt::Producer*)));\n            if (producer->get(kMultitrackItemProperty))\n                connect(w, SIGNAL(producerChanged(Mlt::Producer*)), m_timelineDock, SLOT(onProducerChanged(Mlt::Producer*)));\n        }\n        if (-1 != w->metaObject()->indexOfSignal(\"modified()\")) {\n            connect(w, SIGNAL(modified()), SLOT(onProducerModified()));\n            connect(w, SIGNAL(modified()), m_playlistDock, SLOT(onProducerModified()));\n            connect(w, SIGNAL(modified()), m_timelineDock, SLOT(onProducerModified()));\n            connect(w, SIGNAL(modified()), m_keyframesDock, SLOT(onProducerModified()));\n            connect(w, SIGNAL(modified()), m_filterController, SLOT(onProducerChanged()));\n        }\n        if (-1 != w->metaObject()->indexOfSlot(\"updateDuration()\")) {\n            connect(m_timelineDock, SIGNAL(durationChanged()), w, SLOT(updateDuration()));\n        }\n        if (-1 != w->metaObject()->indexOfSlot(\"rename()\")) {\n            connect(this, SIGNAL(renameRequested()), w, SLOT(rename()));\n        }\n        scrollArea->setWidget(w);\n        onProducerChanged();\n    } else if (scrollArea->widget()) {\n        scrollArea->widget()->deleteLater();\n    }\n    return w;\n}\n\nvoid MainWindow::on_actionEnter_Full_Screen_triggered()\n{\n#ifdef Q_OS_WIN\n    bool isFull = isMaximized();\n#else\n    bool isFull = isFullScreen();\n#endif\n    if (isFull) {\n        showNormal();\n        ui->actionEnter_Full_Screen->setText(tr(\"Enter Full Screen\"));\n    } else {\n#ifdef Q_OS_WIN\n        showMaximized();\n#else\n        showFullScreen();\n#endif\n        ui->actionEnter_Full_Screen->setText(tr(\"Enter Full Screen\"));\n    }\n}\n\nvoid MainWindow::onGpuNotSupported()\n{\n    Settings.setPlayerGPU(false);\n    if (ui->actionGPU) {\n        ui->actionGPU->setChecked(false);\n        ui->actionGPU->setDisabled(true);\n    }\n    LOG_WARNING() << \"\";\n    QMessageBox::critical(this, qApp->applicationName(),\n        tr(\"GPU effects are not supported\"));\n}\n\nvoid MainWindow::editHTML(const QString &fileName)\n{\n    bool isNew = !m_htmlEditor;\n    if (isNew) {\n        m_htmlEditor.reset(new HtmlEditor);\n        m_htmlEditor->setWindowIcon(windowIcon());\n    }\n    m_htmlEditor->load(fileName);\n    m_htmlEditor->show();\n    m_htmlEditor->raise();\n\n    bool isExternal = false;\n    int screen = Settings.playerExternal().toInt(&isExternal);\n    isExternal = isExternal && (screen != QApplication::desktop()->screenNumber(this));\n\n    if (!isExternal) {\n        if (Settings.playerZoom() >= 1.0f) {\n            m_htmlEditor->changeZoom(100 * m_player->videoSize().width() / MLT.profile().width());\n            m_htmlEditor->resizeWebView(m_player->videoSize().width(), m_player->videoSize().height());\n        } else {\n            m_htmlEditor->changeZoom(100 * MLT.displayWidth() / MLT.profile().width());\n            m_htmlEditor->resizeWebView(MLT.displayWidth(), MLT.displayHeight());\n        }\n    } else {\n        m_htmlEditor->changeZoom(100);\n    }\n    if (isNew) {\n        // Center the new window over the main window.\n        QPoint point = pos();\n        QPoint halfSize(width(), height());\n        halfSize /= 2;\n        point += halfSize;\n        halfSize = QPoint(m_htmlEditor->width(), m_htmlEditor->height());\n        halfSize /= 2;\n        point -= halfSize;\n        m_htmlEditor->move(point);\n    }\n}\n\nvoid MainWindow::stepLeftOneFrame()\n{\n    m_player->seek(m_player->position() - 1);\n}\n\nvoid MainWindow::stepRightOneFrame()\n{\n    m_player->seek(m_player->position() + 1);\n}\n\nvoid MainWindow::stepLeftOneSecond()\n{\n    stepLeftBySeconds(-1);\n}\n\nvoid MainWindow::stepRightOneSecond()\n{\n    stepLeftBySeconds(1);\n}\n\nvoid MainWindow::setInToCurrent(bool ripple)\n{\n    if (m_player->tabIndex() == Player::ProjectTabIndex && isMultitrackValid()) {\n        m_timelineDock->trimClipAtPlayhead(TimelineDock::TrimInPoint, ripple);\n    } else if (MLT.isSeekable() && MLT.isClip()) {\n        m_player->setIn(m_player->position());\n        int delta = m_player->position() - MLT.producer()->get_in();\n        emit m_player->inChanged(delta);\n    }\n}\n\nvoid MainWindow::setOutToCurrent(bool ripple)\n{\n    if (m_player->tabIndex() == Player::ProjectTabIndex && isMultitrackValid()) {\n        m_timelineDock->trimClipAtPlayhead(TimelineDock::TrimOutPoint, ripple);\n    } else if (MLT.isSeekable() && MLT.isClip()) {\n        m_player->setOut(m_player->position());\n        int delta = m_player->position() - MLT.producer()->get_out();\n        emit m_player->outChanged(delta);\n    }\n}\n\nvoid MainWindow::onShuttle(float x)\n{\n    if (x == 0) {\n        m_player->pause();\n    } else if (x > 0) {\n        m_player->play(10.0 * x);\n    } else {\n        m_player->play(20.0 * x);\n    }\n}\n\nvoid MainWindow::showUpgradePrompt()\n{\n    if (Settings.checkUpgradeAutomatic()) {\n        showStatusMessage(\"Checking for upgrade...\");\n        m_network.get(QNetworkRequest(QUrl(\"https://check.shotcut.org/version.json\")));\n    } else {\n        QAction* action = new QAction(tr(\"Click here to check for a new version of Shotcut.\"), 0);\n        connect(action, SIGNAL(triggered(bool)), SLOT(on_actionUpgrade_triggered()));\n        showStatusMessage(action, 15 /* seconds */);\n    }\n}\n\nvoid MainWindow::on_actionRealtime_triggered(bool checked)\n{\n    Settings.setPlayerRealtime(checked);\n    if (Settings.playerGPU())\n        MLT.pause();\n    if (MLT.consumer()) {\n        MLT.restart();\n    }\n\n}\n\nvoid MainWindow::on_actionProgressive_triggered(bool checked)\n{\n    MLT.videoWidget()->setProperty(\"progressive\", checked);\n    if (Settings.playerGPU())\n        MLT.pause();\n    if (MLT.consumer()) {\n        MLT.profile().set_progressive(checked);\n        MLT.updatePreviewProfile();\n        MLT.restart();\n    }\n    Settings.setPlayerProgressive(checked);\n}\n\nvoid MainWindow::changeAudioChannels(bool checked, int channels)\n{\n    if( checked ) {\n        Settings.setPlayerAudioChannels(channels);\n        setAudioChannels(Settings.playerAudioChannels());\n    }\n}\n\nvoid MainWindow::on_actionChannels1_triggered(bool checked)\n{\n    changeAudioChannels(checked, 1);\n}\n\nvoid MainWindow::on_actionChannels2_triggered(bool checked)\n{\n    changeAudioChannels(checked, 2);\n}\n\nvoid MainWindow::on_actionChannels6_triggered(bool checked)\n{\n    changeAudioChannels(checked, 6);\n}\n\nvoid MainWindow::changeDeinterlacer(bool checked, const char* method)\n{\n    if (checked) {\n        MLT.videoWidget()->setProperty(\"deinterlace_method\", method);\n        if (MLT.consumer()) {\n            MLT.consumer()->set(\"deinterlace_method\", method);\n            MLT.refreshConsumer();\n        }\n    }\n    Settings.setPlayerDeinterlacer(method);\n}\n\nvoid MainWindow::on_actionOneField_triggered(bool checked)\n{\n    changeDeinterlacer(checked, \"onefield\");\n}\n\nvoid MainWindow::on_actionLinearBlend_triggered(bool checked)\n{\n    changeDeinterlacer(checked, \"linearblend\");\n}\n\nvoid MainWindow::on_actionYadifTemporal_triggered(bool checked)\n{\n    changeDeinterlacer(checked, \"yadif-nospatial\");\n}\n\nvoid MainWindow::on_actionYadifSpatial_triggered(bool checked)\n{\n    changeDeinterlacer(checked, \"yadif\");\n}\n\nvoid MainWindow::changeInterpolation(bool checked, const char* method)\n{\n    if (checked) {\n        MLT.videoWidget()->setProperty(\"rescale\", method);\n        if (MLT.consumer()) {\n            MLT.consumer()->set(\"rescale\", method);\n            MLT.refreshConsumer();\n        }\n    }\n    Settings.setPlayerInterpolation(method);\n}\n\nvoid MainWindow::processMultipleFiles()\n{\n    if (m_multipleFiles.length() <= 0)\n        return;\n    QStringList multipleFiles = m_multipleFiles;\n    m_multipleFiles.clear();\n    int count = multipleFiles.length();\n    if (count > 1) {\n        LongUiTask longTask(tr(\"Open Files\"));\n        m_playlistDock->show();\n        m_playlistDock->raise();\n        for (int i = 0; i < count; i++) {\n            QString filename = multipleFiles.takeFirst();\n            LOG_DEBUG() << filename;\n            longTask.reportProgress(QFileInfo(filename).fileName(), i, count);\n            Mlt::Producer p(MLT.profile(), filename.toUtf8().constData());\n            if (p.is_valid()) {\n                // Convert avformat to avformat-novalidate so that XML loads faster.\n                if (!qstrcmp(p.get(\"mlt_service\"), \"avformat\")) {\n                    p.set(\"mlt_service\", \"avformat-novalidate\");\n                    p.set(\"mute_on_pause\", 0);\n                }\n                if (QDir::toNativeSeparators(filename) == QDir::toNativeSeparators(MAIN.fileName())) {\n                    MAIN.showStatusMessage(QObject::tr(\"You cannot add a project to itself!\"));\n                    continue;\n                }\n                MLT.setImageDurationFromDefault(&p);\n                MLT.lockCreationTime(&p);\n                p.get_length_time(mlt_time_clock);\n                Util::getHash(p);\n                ProxyManager::generateIfNotExists(p);\n                undoStack()->push(new Playlist::AppendCommand(*m_playlistDock->model(), MLT.XML(&p), false));\n                m_recentDock->add(filename.toUtf8().constData());\n            }\n        }\n        emit m_playlistDock->model()->modified();\n    }\n    if (m_isPlaylistLoaded && Settings.playerGPU()) {\n        updateThumbnails();\n        m_isPlaylistLoaded = false;\n    }\n}\n\nvoid MainWindow::onLanguageTriggered(QAction* action)\n{\n    Settings.setLanguage(action->data().toString());\n    QMessageBox dialog(QMessageBox::Information,\n                       qApp->applicationName(),\n                       tr(\"You must restart Shotcut to switch to the new language.\\n\"\n                          \"Do you want to restart now?\"),\n                       QMessageBox::No | QMessageBox::Yes,\n                       this);\n    dialog.setDefaultButton(QMessageBox::Yes);\n    dialog.setEscapeButton(QMessageBox::No);\n    dialog.setWindowModality(QmlApplication::dialogModality());\n    if (dialog.exec() == QMessageBox::Yes) {\n        m_exitCode = EXIT_RESTART;\n        QApplication::closeAllWindows();\n    }\n}\n\nvoid MainWindow::on_actionNearest_triggered(bool checked)\n{\n    changeInterpolation(checked, \"nearest\");\n}\n\nvoid MainWindow::on_actionBilinear_triggered(bool checked)\n{\n    changeInterpolation(checked, \"bilinear\");\n}\n\nvoid MainWindow::on_actionBicubic_triggered(bool checked)\n{\n    changeInterpolation(checked, \"bicubic\");\n}\n\nvoid MainWindow::on_actionHyper_triggered(bool checked)\n{\n    changeInterpolation(checked, \"hyper\");\n}\n\nvoid MainWindow::on_actionJack_triggered(bool checked)\n{\n    Settings.setPlayerJACK(checked);\n    if (!MLT.enableJack(checked)) {\n        if (ui->actionJack)\n            ui->actionJack->setChecked(false);\n        Settings.setPlayerJACK(false);\n        QMessageBox::warning(this, qApp->applicationName(),\n            tr(\"Failed to connect to JACK.\\nPlease verify that JACK is installed and running.\"));\n    }\n}\n\nvoid MainWindow::on_actionGPU_triggered(bool checked)\n{\n    if (checked) {\n        QMessageBox dialog(QMessageBox::Warning,\n                           qApp->applicationName(),\n                           tr(\"GPU effects are experimental and may cause instability on some systems. \"\n                              \"Some CPU effects are incompatible with GPU effects and will be disabled. \"\n                              \"A project created with GPU effects can not be converted to a CPU only project later.\"\n                              \"\\n\\n\"\n                              \"Do you want to enable GPU effects and restart Shotcut?\"),\n                           QMessageBox::No | QMessageBox::Yes,\n                           this);\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        if (dialog.exec() == QMessageBox::Yes) {\n            m_exitCode = EXIT_RESTART;\n            QApplication::closeAllWindows();\n        }\n        else {\n            ui->actionGPU->setChecked(false);\n        }\n    }\n    else\n    {\n        QMessageBox dialog(QMessageBox::Information,\n                           qApp->applicationName(),\n                           tr(\"Shotcut must restart to disable GPU effects.\"\n                              \"\\n\\n\"\n                              \"Disable GPU effects and restart?\"),\n                           QMessageBox::No | QMessageBox::Yes,\n                           this);\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        if (dialog.exec() == QMessageBox::Yes) {\n            m_exitCode = EXIT_RESTART;\n            QApplication::closeAllWindows();\n        }\n        else {\n            ui->actionGPU->setChecked(true);\n        }\n    }\n}\n\nvoid MainWindow::onExternalTriggered(QAction *action)\n{\n    LOG_DEBUG() << action->data().toString();\n    bool isExternal = !action->data().toString().isEmpty();\n    Settings.setPlayerExternal(action->data().toString());\n    MLT.stop();\n    bool ok = false;\n    int screen = action->data().toInt(&ok);\n    if (ok || action->data().toString().isEmpty()) {\n        m_player->moveVideoToScreen(ok? screen : -2);\n        isExternal = false;\n        MLT.videoWidget()->setProperty(\"mlt_service\", QVariant());\n    } else {\n        m_player->moveVideoToScreen(-2);\n        MLT.videoWidget()->setProperty(\"mlt_service\", action->data());\n    }\n\n    QString profile = Settings.playerProfile();\n    // Automatic not permitted for SDI/HDMI\n    if (isExternal && profile.isEmpty()) {\n        profile = \"atsc_720p_50\";\n        Settings.setPlayerProfile(profile);\n        setProfile(profile);\n        MLT.restart();\n        foreach (QAction* a, m_profileGroup->actions()) {\n            if (a->data() == profile) {\n                a->setChecked(true);\n                break;\n            }\n        }\n    }\n    else {\n        MLT.consumerChanged();\n    }\n    // Automatic not permitted for SDI/HDMI\n    m_profileGroup->actions().at(0)->setEnabled(!isExternal);\n\n    // Disable progressive option when SDI/HDMI\n    ui->actionProgressive->setEnabled(!isExternal);\n    bool isProgressive = isExternal\n            ? MLT.profile().progressive()\n            : ui->actionProgressive->isChecked();\n    MLT.videoWidget()->setProperty(\"progressive\", isProgressive);\n    if (MLT.consumer()) {\n        MLT.consumer()->set(\"progressive\", isProgressive);\n        MLT.restart();\n    }\n    if (m_keyerMenu)\n        m_keyerMenu->setEnabled(action->data().toString().startsWith(\"decklink\"));\n\n#if LIBMLT_VERSION_INT >= MLT_VERSION_PREVIEW_SCALE\n    // Preview scaling not permitted for SDI/HDMI\n    if (isExternal) {\n        setPreviewScale(0);\n        m_previewScaleGroup->setEnabled(false);\n    } else {\n        setPreviewScale(Settings.playerPreviewScale());\n        m_previewScaleGroup->setEnabled(true);\n    }\n#endif\n}\n\nvoid MainWindow::onKeyerTriggered(QAction *action)\n{\n    LOG_DEBUG() << action->data().toString();\n    MLT.videoWidget()->setProperty(\"keyer\", action->data());\n    MLT.consumerChanged();\n    Settings.setPlayerKeyerMode(action->data().toInt());\n}\n\nvoid MainWindow::onProfileTriggered(QAction *action)\n{\n    Settings.setPlayerProfile(action->data().toString());\n    if (MLT.producer() && MLT.producer()->is_valid()) {\n        // Save the XML to get correct in/out points before profile is changed.\n        QString xml = MLT.XML();\n        setProfile(action->data().toString());\n        MLT.restart(xml);\n        onProducerOpened(false);\n    } else {\n        setProfile(action->data().toString());\n    }\n}\n\nvoid MainWindow::onProfileChanged()\n{\n    if (multitrack() && MLT.isMultitrack() &&\n       (m_timelineDock->selection().isEmpty() || m_timelineDock->currentTrack() == -1)) {\n        emit m_timelineDock->selected(multitrack());\n    }\n}\n\nvoid MainWindow::on_actionAddCustomProfile_triggered()\n{\n    QString xml;\n    if (MLT.producer() && MLT.producer()->is_valid()) {\n        // Save the XML to get correct in/out points before profile is changed.\n        xml = MLT.XML();\n    }\n    CustomProfileDialog dialog(this);\n    dialog.setWindowModality(QmlApplication::dialogModality());\n    if (dialog.exec() == QDialog::Accepted) {\n        QString name = dialog.profileName();\n        if (!name.isEmpty()) {\n            addCustomProfile(name, customProfileMenu(), actionProfileRemove(), profileGroup());\n        } else if (m_profileGroup->checkedAction()) {\n            m_profileGroup->checkedAction()->setChecked(false);\n        }\n        // Use the new profile.\n        emit profileChanged();\n        if (!xml.isEmpty()) {\n            MLT.restart(xml);\n            onProducerOpened(false);\n        }\n    }\n}\n\nvoid MainWindow::on_actionSystemTheme_triggered()\n{\n    changeTheme(\"system\");\n    QApplication::setPalette(QApplication::style()->standardPalette());\n    Settings.setTheme(\"system\");\n}\n\nvoid MainWindow::on_actionFusionDark_triggered()\n{\n    changeTheme(\"dark\");\n    Settings.setTheme(\"dark\");\n    ui->mainToolBar->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);\n}\n\nvoid MainWindow::on_actionFusionLight_triggered()\n{\n    changeTheme(\"light\");\n    Settings.setTheme(\"light\");\n    ui->mainToolBar->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);\n}\n\nvoid MainWindow::on_actionTutorials_triggered()\n{\n    QDesktopServices::openUrl(QUrl(\"https://www.shotcut.org/tutorials/\"));\n}\n\nvoid MainWindow::on_actionRestoreLayout_triggered()\n{\n    restoreGeometry(Settings.windowGeometryDefault());\n    restoreState(Settings.windowStateDefault());\n    on_actionLayoutTimeline_triggered();\n    ui->actionShowTitleBars->setChecked(true);\n    on_actionShowTitleBars_triggered(true);\n    ui->actionShowTextUnderIcons->setChecked(true);\n    on_actionShowTextUnderIcons_toggled(true);\n    ui->actionShowSmallIcons->setChecked(false);\n    on_actionShowSmallIcons_toggled(false);\n}\n\nvoid MainWindow::on_actionShowTitleBars_triggered(bool checked)\n{\n    QList <QDockWidget *> docks = findChildren<QDockWidget *>();\n    for (int i = 0; i < docks.count(); i++) {\n        QDockWidget* dock = docks.at(i);\n        if (checked) {\n            dock->setTitleBarWidget(0);\n        } else {\n            if (!dock->isFloating()) {\n                dock->setTitleBarWidget(new QWidget);\n            }\n        }\n    }\n    Settings.setShowTitleBars(checked);\n}\n\nvoid MainWindow::on_actionShowToolbar_triggered(bool checked)\n{\n    ui->mainToolBar->setVisible(checked);\n}\n\nvoid MainWindow::onToolbarVisibilityChanged(bool visible)\n{\n    ui->actionShowToolbar->setChecked(visible);\n    Settings.setShowToolBar(visible);\n}\n\nvoid MainWindow::on_menuExternal_aboutToShow()\n{\n    foreach (QAction* action, m_externalGroup->actions()) {\n        bool ok = false;\n        int i = action->data().toInt(&ok);\n        if (ok) {\n            if (i == QApplication::desktop()->screenNumber(this)) {\n                if (action->isChecked()) {\n                    m_externalGroup->actions().first()->setChecked(true);\n                    Settings.setPlayerExternal(QString());\n                }\n                action->setDisabled(true);\n            }  else {\n                action->setEnabled(true);\n            }\n        }\n    }\n}\n\nvoid MainWindow::on_actionUpgrade_triggered()\n{\n    if (Settings.askUpgradeAutmatic()) {\n        QMessageBox dialog(QMessageBox::Question,\n           qApp->applicationName(),\n           tr(\"Do you want to automatically check for updates in the future?\"),\n           QMessageBox::No |\n           QMessageBox::Yes,\n           this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        dialog.setCheckBox(new QCheckBox(tr(\"Do not show this anymore.\", \"Automatic upgrade check dialog\")));\n        Settings.setCheckUpgradeAutomatic(dialog.exec() == QMessageBox::Yes);\n        if (dialog.checkBox()->isChecked())\n            Settings.setAskUpgradeAutomatic(false);\n    }\n    showStatusMessage(\"Checking for upgrade...\");\n    m_network.get(QNetworkRequest(QUrl(\"https://check.shotcut.org/version.json\")));\n}\n\nvoid MainWindow::on_actionOpenXML_triggered()\n{\n    QString path = Settings.openPath();\n#ifdef Q_OS_MAC\n    path.append(\"/*\");\n#endif\n    QStringList filenames = QFileDialog::getOpenFileNames(this, tr(\"Open File\"), path,\n        tr(\"MLT XML (*.mlt);;All Files (*)\"));\n    if (filenames.length() > 0) {\n        QString url = filenames.first();\n        MltXmlChecker checker;\n        if (checker.check(url)) {\n            if (!isCompatibleWithGpuMode(checker))\n                return;\n            isXmlRepaired(checker, url);\n            // Check if the locale usage differs.\n            // Get current locale.\n            QString localeName = QString(::setlocale(MLT_LC_CATEGORY, nullptr)).toUpper();\n            // Test if it is C or POSIX.\n            bool currentlyUsingLocale = (localeName != \"\" && localeName != \"C\" && localeName != \"POSIX\");\n            if (currentlyUsingLocale != checker.usesLocale()) {\n                // Show a warning dialog and cancel if requested.\n                QMessageBox dialog(QMessageBox::Question,\n                   qApp->applicationName(),\n                   tr(\"The decimal point of the MLT XML file\\nyou want to open is incompatible.\\n\\n\"\n                      \"Do you want to continue to open this MLT XML file?\"),\n                   QMessageBox::No |\n                   QMessageBox::Yes,\n                   this);\n                dialog.setWindowModality(QmlApplication::dialogModality());\n                dialog.setDefaultButton(QMessageBox::No);\n                dialog.setEscapeButton(QMessageBox::No);\n                if (dialog.exec() != QMessageBox::Yes)\n                    return;\n            }\n        }\n        Settings.setOpenPath(QFileInfo(url).path());\n        activateWindow();\n        if (filenames.length() > 1)\n            m_multipleFiles = filenames;\n        if (!MLT.openXML(url)) {\n            open(MLT.producer());\n            m_recentDock->add(url);\n            LOG_INFO() << url;\n        }\n        else {\n            showStatusMessage(tr(\"Failed to open \") + url);\n            emit openFailed(url);\n        }\n    }\n}\n\nvoid MainWindow::on_actionGammaSRGB_triggered(bool checked)\n{\n    Q_UNUSED(checked)\n    Settings.setPlayerGamma(\"iec61966_2_1\");\n    MLT.restart();\n    MLT.refreshConsumer();\n}\n\nvoid MainWindow::on_actionGammaRec709_triggered(bool checked)\n{\n    Q_UNUSED(checked)\n    Settings.setPlayerGamma(\"bt709\");\n    MLT.restart();\n    MLT.refreshConsumer();\n}\n\nvoid MainWindow::onFocusChanged(QWidget *, QWidget * ) const\n{\n    LOG_DEBUG() << \"Focuswidget changed\";\n    LOG_DEBUG() << \"Current focusWidget:\" << QApplication::focusWidget();\n    LOG_DEBUG() << \"Current focusObject:\" << QApplication::focusObject();\n    LOG_DEBUG() << \"Current focusWindow:\" << QApplication::focusWindow();\n}\n\nvoid MainWindow::on_actionScrubAudio_triggered(bool checked)\n{\n    Settings.setPlayerScrubAudio(checked);\n}\n\n#if !defined(Q_OS_MAC)\nvoid MainWindow::onDrawingMethodTriggered(QAction *action)\n{\n    Settings.setDrawMethod(action->data().toInt());\n    QMessageBox dialog(QMessageBox::Information,\n                       qApp->applicationName(),\n                       tr(\"You must restart Shotcut to change the display method.\\n\"\n                          \"Do you want to restart now?\"),\n                       QMessageBox::No | QMessageBox::Yes,\n                       this);\n    dialog.setDefaultButton(QMessageBox::Yes);\n    dialog.setEscapeButton(QMessageBox::No);\n    dialog.setWindowModality(QmlApplication::dialogModality());\n    if (dialog.exec() == QMessageBox::Yes) {\n        m_exitCode = EXIT_RESTART;\n        QApplication::closeAllWindows();\n    }\n}\n#endif\n\nvoid MainWindow::on_actionApplicationLog_triggered()\n{\n    TextViewerDialog dialog(this);\n    QDir dir = Settings.appDataLocation();\n    QFile logFile(dir.filePath(\"shotcut-log.txt\"));\n    logFile.open(QIODevice::ReadOnly | QIODevice::Text);\n    dialog.setText(logFile.readAll());\n    logFile.close();\n    dialog.setWindowTitle(tr(\"Application Log\"));\n    dialog.exec();\n}\n\nvoid MainWindow::on_actionClose_triggered()\n{\n    if (continueModified()) {\n        LOG_DEBUG() << \"\";\n        MLT.setProjectFolder(QString());\n        MLT.stop();\n        if (multitrack())\n            m_timelineDock->model()->close();\n        if (playlist())\n            m_playlistDock->model()->close();\n        else\n            onMultitrackClosed();\n        m_player->enableTab(Player::SourceTabIndex, false);\n        MLT.purgeMemoryPool();\n        MLT.resetLocale();\n    }\n}\n\nvoid MainWindow::onPlayerTabIndexChanged(int index)\n{\n    if (Player::SourceTabIndex == index)\n        m_timelineDock->saveAndClearSelection();\n    else\n        m_timelineDock->restoreSelection();\n}\n\nvoid MainWindow::onUpgradeCheckFinished(QNetworkReply* reply)\n{\n    if (!reply->error()) {\n        QByteArray response = reply->readAll();\n        LOG_DEBUG() << \"response: \" << response;\n        QJsonDocument json = QJsonDocument::fromJson(response);\n        QString current = qApp->applicationVersion();\n\n        if (!json.isNull() && json.object().value(\"version_string\").type() == QJsonValue::String) {\n            QString latest = json.object().value(\"version_string\").toString();\n            if (current != \"adhoc\" && QVersionNumber::fromString(current) < QVersionNumber::fromString(latest)) {\n                QAction* action = new QAction(tr(\"Shotcut version %1 is available! Click here to get it.\").arg(latest), 0);\n                connect(action, SIGNAL(triggered(bool)), SLOT(onUpgradeTriggered()));\n                if (!json.object().value(\"url\").isUndefined())\n                    m_upgradeUrl = json.object().value(\"url\").toString();\n                showStatusMessage(action, 15 /* seconds */);\n            } else {\n                showStatusMessage(tr(\"You are running the latest version of Shotcut.\"));\n            }\n            reply->deleteLater();\n            return;\n        } else {\n            LOG_WARNING() << \"failed to parse version.json\";\n        }\n    } else {\n        LOG_WARNING() << reply->errorString();\n    }\n    QAction* action = new QAction(tr(\"Failed to read version.json when checking. Click here to go to the Web site.\"), 0);\n    connect(action, SIGNAL(triggered(bool)), SLOT(onUpgradeTriggered()));\n    showStatusMessage(action);\n    reply->deleteLater();\n}\n\nvoid MainWindow::onUpgradeTriggered()\n{\n    QDesktopServices::openUrl(QUrl(m_upgradeUrl));\n}\n\nvoid MainWindow::onTimelineSelectionChanged()\n{\n    bool enable = (m_timelineDock->selection().size() > 0);\n    ui->actionCut->setEnabled(enable);\n    ui->actionCopy->setEnabled(enable);\n}\n\nvoid MainWindow::on_actionCut_triggered()\n{\n    m_timelineDock->show();\n    m_timelineDock->raise();\n    m_timelineDock->removeSelection(true);\n}\n\nvoid MainWindow::on_actionCopy_triggered()\n{\n    m_timelineDock->show();\n    m_timelineDock->raise();\n    if (!m_timelineDock->selection().isEmpty())\n        m_timelineDock->copyClip(m_timelineDock->selection().first().y(), m_timelineDock->selection().first().x());\n}\n\nvoid MainWindow::on_actionPaste_triggered()\n{\n    m_timelineDock->show();\n    m_timelineDock->raise();\n    m_timelineDock->insert(-1);\n}\n\nvoid MainWindow::onClipCopied()\n{\n    m_player->enableTab(Player::SourceTabIndex);\n}\n\nvoid MainWindow::on_actionExportEDL_triggered()\n{\n    // Dialog to get export file name.\n    QString path = Settings.savePath();\n    QString caption = tr(\"Export EDL\");\n    QString saveFileName = QFileDialog::getSaveFileName(this, caption, path, tr(\"EDL (*.edl);;All Files (*)\"));\n    if (!saveFileName.isEmpty()) {\n        QFileInfo fi(saveFileName);\n        if (fi.suffix() != \"edl\")\n            saveFileName += \".edl\";\n\n        if (Util::warnIfNotWritable(saveFileName, this, caption))\n            return;\n\n        // Locate the JavaScript file in the filesystem.\n        QDir qmlDir = QmlUtilities::qmlDir();\n        qmlDir.cd(\"export-edl\");\n        QString jsFileName = qmlDir.absoluteFilePath(\"export-edl.js\");\n        QFile scriptFile(jsFileName);\n        if (scriptFile.open(QIODevice::ReadOnly)) {\n            // Read JavaScript into a string.\n            QTextStream stream(&scriptFile);\n            stream.setCodec(\"UTF-8\");\n            stream.setAutoDetectUnicode(true);\n            QString contents = stream.readAll();\n            scriptFile.close();\n\n            // Evaluate JavaScript.\n            QJSEngine jsEngine;\n            QJSValue result = jsEngine.evaluate(contents, jsFileName);\n            if (!result.isError()) {\n                // Call the JavaScript main function.\n                QJSValue options = jsEngine.newObject();\n                options.setProperty(\"useBaseNameForReelName\", true);\n                options.setProperty(\"useBaseNameForClipComment\", true);\n                options.setProperty(\"channelsAV\", \"AA/V\");\n                QJSValueList args;\n                args << MLT.XML(0, true, true) << options;\n                result = result.call(args);\n                if (!result.isError()) {\n                    // Save the result with the export file name.\n                    QFile f(saveFileName);\n                    f.open(QIODevice::WriteOnly | QIODevice::Text);\n                    f.write(result.toString().toLatin1());\n                    f.close();\n                }\n            }\n            if (result.isError()) {\n                LOG_ERROR() << \"Uncaught exception at line\"\n                            << result.property(\"lineNumber\").toInt()\n                            << \":\" << result.toString();\n                showStatusMessage(tr(\"A JavaScript error occurred during export.\"));\n            }\n        } else {\n            showStatusMessage(tr(\"Failed to open export-edl.js\"));\n        }\n    }\n}\n\nvoid MainWindow::on_actionExportFrame_triggered()\n{\n    if (Settings.playerGPU() || Settings.playerPreviewScale()) {\n        Mlt::GLWidget* glw = qobject_cast<Mlt::GLWidget*>(MLT.videoWidget());\n        connect(glw, SIGNAL(imageReady()), SLOT(onGLWidgetImageReady()));\n        MLT.setPreviewScale(0);\n        glw->requestImage();\n        MLT.refreshConsumer();\n    } else {\n        onGLWidgetImageReady();\n    }\n}\n\nvoid MainWindow::onGLWidgetImageReady()\n{\n    Mlt::GLWidget* glw = qobject_cast<Mlt::GLWidget*>(MLT.videoWidget());\n    QImage image = glw->image();\n    if (Settings.playerGPU() || Settings.playerPreviewScale()) {\n        disconnect(glw, SIGNAL(imageReady()), this, 0);\n        MLT.setPreviewScale(Settings.playerPreviewScale());\n    }\n    if (!image.isNull()) {\n        QString path = Settings.savePath();\n        QString caption = tr(\"Export Frame\");\n        QString nameFilter = tr(\"PNG (*.png);;BMP (*.bmp);;JPEG (*.jpg *.jpeg);;PPM (*.ppm);;TIFF (*.tif *.tiff);;WebP (*.webp);;All Files (*)\");\n        QString saveFileName = QFileDialog::getSaveFileName(this, caption, path, nameFilter);\n        if (!saveFileName.isEmpty()) {\n            QFileInfo fi(saveFileName);\n            if (fi.suffix().isEmpty())\n                saveFileName += \".png\";\n            if (Util::warnIfNotWritable(saveFileName, this, caption))\n                return;\n            // Convert to square pixels if needed.\n            qreal aspectRatio = (qreal) image.width() / image.height();\n            if (qFloor(aspectRatio * 1000) != qFloor(MLT.profile().dar() * 1000)) {\n                image = image.scaled(qRound(image.height() * MLT.profile().dar()), image.height(),\n                                     Qt::IgnoreAspectRatio, Qt::SmoothTransformation);\n            }\n            image.save(saveFileName, Q_NULLPTR,\n                (QFileInfo(saveFileName).suffix() == \"webp\")? 80 : -1);\n            Settings.setSavePath(fi.path());\n            m_recentDock->add(saveFileName);\n        }\n    } else {\n        showStatusMessage(tr(\"Unable to export frame.\"));\n    }\n}\n\nvoid MainWindow::on_actionAppDataSet_triggered()\n{\n    QMessageBox dialog(QMessageBox::Information,\n                       qApp->applicationName(),\n                       tr(\"You must restart Shotcut to change the data directory.\\n\"\n                          \"Do you want to continue?\"),\n                       QMessageBox::No | QMessageBox::Yes,\n                       this);\n    dialog.setDefaultButton(QMessageBox::Yes);\n    dialog.setEscapeButton(QMessageBox::No);\n    dialog.setWindowModality(QmlApplication::dialogModality());\n    if (dialog.exec() != QMessageBox::Yes) return;\n\n    QString dirName = QFileDialog::getExistingDirectory(this, tr(\"Data Directory\"), Settings.appDataLocation());\n    if (!dirName.isEmpty()) {\n        // Move the data files.\n        QDirIterator it(Settings.appDataLocation());\n        while (it.hasNext()) {\n            if (!it.filePath().isEmpty() && it.fileName() != \".\" && it.fileName() != \"..\") {\n                if (!QFile::exists(dirName + \"/\" + it.fileName())) {\n                    if (it.fileInfo().isDir()) {\n                        if (!QFile::rename(it.filePath(), dirName + \"/\" + it.fileName()))\n                            LOG_WARNING() << \"Failed to move\" << it.filePath() << \"to\" << dirName + \"/\" + it.fileName();\n                    } else {\n                        if (!QFile::copy(it.filePath(), dirName + \"/\" + it.fileName()))\n                            LOG_WARNING() << \"Failed to copy\" << it.filePath() << \"to\" << dirName + \"/\" + it.fileName();\n                    }\n                }\n            }\n            it.next();\n        }\n        writeSettings();\n        Settings.setAppDataLocally(dirName);\n\n        m_exitCode = EXIT_RESTART;\n        QApplication::closeAllWindows();\n    }\n}\n\nvoid MainWindow::on_actionAppDataShow_triggered()\n{\n    Util::showInFolder(Settings.appDataLocation());\n}\n\nvoid MainWindow::on_actionNew_triggered()\n{\n    on_actionClose_triggered();\n}\n\nvoid MainWindow::on_actionKeyboardShortcuts_triggered()\n{\n    QDesktopServices::openUrl(QUrl(\"https://www.shotcut.org/howtos/keyboard-shortcuts/\"));\n}\n\nvoid MainWindow::on_actionLayoutPlayer_triggered()\n{\n    restoreState(Settings.windowStateDefault());\n}\n\nvoid MainWindow::on_actionLayoutPlaylist_triggered()\n{\n    restoreState(Settings.windowStateDefault());\n    m_recentDock->show();\n    m_recentDock->raise();\n    m_playlistDock->show();\n    m_playlistDock->raise();\n}\n\nvoid MainWindow::on_actionLayoutTimeline_triggered()\n{\n    restoreState(Settings.windowStateDefault());\n    QDockWidget* audioMeterDock = findChild<QDockWidget*>(\"AudioPeakMeterDock\");\n    if (audioMeterDock) {\n        audioMeterDock->show();\n        audioMeterDock->raise();\n    }\n    m_recentDock->show();\n    m_recentDock->raise();\n    m_filtersDock->show();\n    m_filtersDock->raise();\n    m_timelineDock->show();\n    m_timelineDock->raise();\n}\n\nvoid MainWindow::on_actionLayoutClip_triggered()\n{\n    restoreState(Settings.windowStateDefault());\n    m_recentDock->show();\n    m_recentDock->raise();\n    m_filtersDock->show();\n    m_filtersDock->raise();\n}\n\nvoid MainWindow::on_actionLayoutAdd_triggered()\n{\n    bool ok;\n    QString name = QInputDialog::getText(this, tr(\"Add Custom Layout\"),\n                                         tr(\"Name\"), QLineEdit::Normal,\n                                         \"\", &ok);\n    if (ok && !name.isEmpty()) {\n        if (Settings.setLayout(name, saveGeometry(), saveState())) {\n            Settings.sync();\n            if (Settings.layouts().size() == 1) {\n                ui->menuLayout->addAction(ui->actionLayoutRemove);\n                ui->menuLayout->addSeparator();\n            }\n            ui->menuLayout->addAction(addLayout(m_layoutGroup, name));\n        }\n    }\n}\n\nvoid MainWindow::onLayoutTriggered(QAction* action)\n{\n    restoreGeometry(Settings.layoutGeometry(action->text()));\n    restoreState(Settings.layoutState(action->text()));\n}\n\nvoid MainWindow::on_actionProfileRemove_triggered()\n{\n    QDir dir(Settings.appDataLocation());\n    if (dir.cd(\"profiles\")) {\n        // Setup the dialog.\n        QStringList profiles = dir.entryList(QDir::Files | QDir::NoDotAndDotDot | QDir::Readable);\n        ListSelectionDialog dialog(profiles, this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setWindowTitle(tr(\"Remove Video Mode\"));\n\n        // Show the dialog.\n        if (dialog.exec() == QDialog::Accepted) {\n            removeCustomProfiles(dialog.selection(), dir, customProfileMenu(), actionProfileRemove());\n        }\n    }\n}\n\nvoid MainWindow::on_actionLayoutRemove_triggered()\n{\n    // Setup the dialog.\n    ListSelectionDialog dialog(Settings.layouts(), this);\n    dialog.setWindowModality(QmlApplication::dialogModality());\n    dialog.setWindowTitle(tr(\"Remove Layout\"));\n\n    // Show the dialog.\n    if (dialog.exec() == QDialog::Accepted) {\n        foreach(const QString& layout, dialog.selection()) {\n            // Update the configuration.\n            if (Settings.removeLayout(layout))\n                Settings.sync();\n            // Locate the menu item.\n            foreach (QAction* action, ui->menuLayout->actions()) {\n                if (action->text() == layout) {\n                    // Remove the menu item.\n                    delete action;\n                    break;\n                }\n            }\n        }\n        // If no more custom layouts.\n        if (Settings.layouts().size() == 0) {\n            // Remove the Remove action and separator.\n            ui->menuLayout->removeAction(ui->actionLayoutRemove);\n            bool isSecondSeparator = false;\n            foreach (QAction* action, ui->menuLayout->actions()) {\n                if (action->isSeparator()) {\n                    if (isSecondSeparator) {\n                        delete action;\n                        break;\n                    } else {\n                        isSecondSeparator = true;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid MainWindow::on_actionOpenOther2_triggered()\n{\n    ui->actionOpenOther2->menu()->popup(mapToGlobal(ui->mainToolBar->geometry().bottomLeft()) + QPoint(64, 0));\n}\n\nvoid MainWindow::onOpenOtherTriggered(QWidget* widget)\n{\n    QDialog dialog(this);\n    dialog.resize(426, 288);\n    QVBoxLayout vlayout(&dialog);\n    vlayout.addWidget(widget);\n    QDialogButtonBox buttonBox(&dialog);\n    buttonBox.setOrientation(Qt::Horizontal);\n    buttonBox.setStandardButtons(QDialogButtonBox::Cancel | QDialogButtonBox::Ok);\n    vlayout.addWidget(&buttonBox);\n    connect(&buttonBox, SIGNAL(accepted()), &dialog, SLOT(accept()));\n    connect(&buttonBox, SIGNAL(rejected()), &dialog, SLOT(reject()));\n    QString name = widget->objectName();\n    if (name == \"NoiseWidget\" || dialog.exec() == QDialog::Accepted) {\n        open(dynamic_cast<AbstractProducerWidget*>(widget)->newProducer(MLT.profile()));\n        if (name == \"TextProducerWidget\") {\n            m_filtersDock->show();\n            m_filtersDock->raise();\n        } else {\n            m_propertiesDock->show();\n            m_propertiesDock->raise();\n        }\n    }\n    delete widget;\n}\n\nvoid MainWindow::onOpenOtherTriggered()\n{\n    if (sender()->objectName() == \"color\")\n        onOpenOtherTriggered(new ColorProducerWidget(this));\n    else if (sender()->objectName() == \"text\")\n        onOpenOtherTriggered(new TextProducerWidget(this));\n    else if (sender()->objectName() == \"noise\")\n        onOpenOtherTriggered(new NoiseWidget(this));\n    else if (sender()->objectName() == \"ising0r\")\n        onOpenOtherTriggered(new IsingWidget(this));\n    else if (sender()->objectName() == \"lissajous0r\")\n        onOpenOtherTriggered(new LissajousWidget(this));\n    else if (sender()->objectName() == \"plasma\")\n        onOpenOtherTriggered(new PlasmaWidget(this));\n    else if (sender()->objectName() == \"test_pat_B\")\n        onOpenOtherTriggered(new ColorBarsWidget(this));\n    else if (sender()->objectName() == \"tone\")\n        onOpenOtherTriggered(new ToneProducerWidget(this));\n    else if (sender()->objectName() == \"count\")\n        onOpenOtherTriggered(new CountProducerWidget(this));\n    else if (sender()->objectName() == \"blipflash\")\n        onOpenOtherTriggered(new BlipProducerWidget(this));\n    else if (sender()->objectName() == \"v4l2\")\n        onOpenOtherTriggered(new Video4LinuxWidget(this));\n    else if (sender()->objectName() == \"pulse\")\n        onOpenOtherTriggered(new PulseAudioWidget(this));\n    else if (sender()->objectName() == \"jack\")\n        onOpenOtherTriggered(new JackProducerWidget(this));\n    else if (sender()->objectName() == \"alsa\")\n        onOpenOtherTriggered(new AlsaWidget(this));\n#if defined(Q_OS_MAC)\n    else if (sender()->objectName() == \"device\")\n        onOpenOtherTriggered(new AvfoundationProducerWidget(this));\n#elif defined(Q_OS_WIN)\n    else if (sender()->objectName() == \"device\")\n        onOpenOtherTriggered(new DirectShowVideoWidget(this));\n#endif\n    else if (sender()->objectName() == \"decklink\")\n        onOpenOtherTriggered(new DecklinkProducerWidget(this));\n}\n\nvoid MainWindow::on_actionClearRecentOnExit_toggled(bool arg1)\n{\n    Settings.setClearRecent(arg1);\n    if (arg1)\n        Settings.setRecent(QStringList());\n}\n\nvoid MainWindow::onSceneGraphInitialized()\n{\n    if (Settings.playerGPU() && Settings.playerWarnGPU()) {\n        QMessageBox dialog(QMessageBox::Warning,\n                           qApp->applicationName(),\n                           tr(\"GPU effects are EXPERIMENTAL, UNSTABLE and UNSUPPORTED! Unsupported means do not report bugs about it.\\n\\n\"\n                              \"Do you want to disable GPU effects and restart Shotcut?\"),\n                           QMessageBox::No | QMessageBox::Yes,\n                           this);\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        if (dialog.exec() == QMessageBox::Yes) {\n            ui->actionGPU->setChecked(false);\n            m_exitCode = EXIT_RESTART;\n            QApplication::closeAllWindows();\n        } else {\n            ui->actionGPU->setVisible(true);\n        }\n    } else if (Settings.playerGPU()) {\n        ui->actionGPU->setVisible(true);\n    }\n}\n\nvoid MainWindow::on_actionShowTextUnderIcons_toggled(bool b)\n{\n    ui->mainToolBar->setToolButtonStyle(b? Qt::ToolButtonTextUnderIcon : Qt::ToolButtonIconOnly);\n    Settings.setTextUnderIcons(b);\n}\n\nvoid MainWindow::on_actionShowSmallIcons_toggled(bool b)\n{\n    ui->mainToolBar->setIconSize(b? QSize(16, 16) : QSize());\n    Settings.setSmallIcons(b);\n}\n\nvoid MainWindow::onPlaylistInChanged(int in)\n{\n    m_player->blockSignals(true);\n    m_player->setIn(in);\n    m_player->blockSignals(false);\n}\n\nvoid MainWindow::onPlaylistOutChanged(int out)\n{\n    m_player->blockSignals(true);\n    m_player->setOut(out);\n    m_player->blockSignals(false);\n}\n\nvoid MainWindow::on_actionPreviewNone_triggered(bool checked)\n{\n    if (checked) {\n        Settings.setPlayerPreviewScale(0);\n        setPreviewScale(0);\n        m_player->showIdleStatus();\n    }\n}\n\nvoid MainWindow::on_actionPreview360_triggered(bool checked)\n{\n    if (checked) {\n        Settings.setPlayerPreviewScale(360);\n        setPreviewScale(360);\n        m_player->showIdleStatus();\n    }\n}\n\nvoid MainWindow::on_actionPreview540_triggered(bool checked)\n{\n    if (checked) {\n        Settings.setPlayerPreviewScale(540);\n        setPreviewScale(540);\n        m_player->showIdleStatus();\n    }\n}\n\nvoid MainWindow::on_actionPreview720_triggered(bool checked)\n{\n    if (checked) {\n        Settings.setPlayerPreviewScale(720);\n        setPreviewScale(720);\n        m_player->showIdleStatus();\n    }\n}\n\nQUuid MainWindow::timelineClipUuid(int trackIndex, int clipIndex)\n{\n    QScopedPointer<Mlt::ClipInfo> info(m_timelineDock->getClipInfo(trackIndex, clipIndex));\n    if (info && info->cut && info->cut->is_valid())\n        return MLT.ensureHasUuid(*info->cut);\n    return QUuid();\n}\n\nvoid MainWindow::replaceInTimeline(const QUuid& uuid, Mlt::Producer& producer)\n{\n    int trackIndex = -1;\n    int clipIndex = -1;\n    // lookup the current track and clip index by UUID\n    QScopedPointer<Mlt::ClipInfo> info(MAIN.timelineClipInfoByUuid(uuid, trackIndex, clipIndex));\n\n    if (trackIndex >= 0 && clipIndex >= 0) {\n        Util::getHash(producer);\n        Util::applyCustomProperties(producer, *info->producer, producer.get_in(), producer.get_out());\n        m_timelineDock->replace(trackIndex, clipIndex, MLT.XML(&producer));\n    }\n}\n\nMlt::ClipInfo* MainWindow::timelineClipInfoByUuid(const QUuid& uuid, int& trackIndex, int& clipIndex)\n{\n    return m_timelineDock->model()->findClipByUuid(uuid, trackIndex, clipIndex);\n}\n\nvoid MainWindow::replaceAllByHash(const QString& hash, Mlt::Producer& producer, bool isProxy)\n{\n    Util::getHash(producer);\n    if (!isProxy)\n        m_recentDock->add(producer.get(\"resource\"));\n    if (MLT.isClip() && MLT.producer() && Util::getHash(*MLT.producer()) == hash) {\n        Util::applyCustomProperties(producer, *MLT.producer(), MLT.producer()->get_in(), MLT.producer()->get_out());\n        MLT.copyFilters(*MLT.producer(), producer);\n        MLT.close();\n        m_player->setPauseAfterOpen(true);\n        open(new Mlt::Producer(MLT.profile(), \"xml-string\", MLT.XML(&producer).toUtf8().constData()));\n    } else if (MLT.savedProducer() && Util::getHash(*MLT.savedProducer()) == hash) {\n        Util::applyCustomProperties(producer, *MLT.savedProducer(), MLT.savedProducer()->get_in(), MLT.savedProducer()->get_out());\n        MLT.copyFilters(*MLT.savedProducer(), producer);\n        MLT.setSavedProducer(&producer);\n    }\n    if (playlist()) {\n        if (isProxy) {\n            m_playlistDock->replaceClipsWithHash(hash, producer);\n        } else {\n            // Append to playlist\n            producer.set(kPlaylistIndexProperty, playlist()->count());\n            MAIN.undoStack()->push(\n                new Playlist::AppendCommand(*m_playlistDock->model(), MLT.XML(&producer)));\n        }\n    }\n    if (isMultitrackValid()) {\n        m_timelineDock->replaceClipsWithHash(hash, producer);\n    }\n}\n\nvoid MainWindow::on_actionTopics_triggered()\n{\n    QDesktopServices::openUrl(QUrl(\"https://www.shotcut.org/howtos/\"));\n}\n\nvoid MainWindow::on_actionSync_triggered()\n{\n    auto dialog = new SystemSyncDialog(this);\n    dialog->show();\n    dialog->raise();\n    dialog->activateWindow();\n}\n\nvoid MainWindow::on_actionUseProxy_triggered(bool checked)\n{\n    if (MLT.producer()) {\n        QDir dir(m_currentFile.isEmpty()? QDir::tempPath() : QFileInfo(m_currentFile).dir());\n        QScopedPointer<QTemporaryFile> tmp(new QTemporaryFile(dir.filePath(\"shotcut-XXXXXX.mlt\")));\n        tmp->open();\n        tmp->close();\n        QString fileName = tmp->fileName();\n        tmp->remove();\n        tmp.reset();\n        LOG_DEBUG() << fileName;\n\n        if (saveXML(fileName)) {\n            MltXmlChecker checker;\n\n            Settings.setProxyEnabled(checked);\n            checker.check(fileName);\n            if (!isXmlRepaired(checker, fileName)) {\n                QFile::remove(fileName);\n                return;\n            }\n            if (checker.isUpdated()) {\n                QFile::remove(fileName);\n                fileName = checker.tempFileName();\n            }\n\n            // Open the temporary file\n            int result = 0;\n            {\n                LongUiTask longTask(checked? tr(\"Turn Proxy On\") : tr(\"Turn Proxy Off\"));\n                QFuture<int> future = QtConcurrent::run([=]() {\n                    return MLT.open(QDir::fromNativeSeparators(fileName), QDir::fromNativeSeparators(m_currentFile));\n                });\n                result = longTask.wait<int>(tr(\"Converting\"), future);\n            }\n            if (!result) {\n                auto position = m_player->position();\n                m_undoStack->clear();\n                m_player->stop();\n                m_player->setPauseAfterOpen(true);\n                open(MLT.producer());\n                MLT.seek(m_player->position());\n                m_player->seek(position);\n\n                if (checked && (isPlaylistValid() || isMultitrackValid())) {\n                    // Prompt user if they want to create missing proxies\n                    QMessageBox dialog(QMessageBox::Question, qApp->applicationName(),\n                       tr(\"Do you want to create missing proxies for every file in this project?\\n\\n\"\n                          \"You must reopen your project after all proxy jobs are finished.\"),\n                       QMessageBox::No | QMessageBox::Yes, this);\n                    dialog.setWindowModality(QmlApplication::dialogModality());\n                    dialog.setDefaultButton(QMessageBox::Yes);\n                    dialog.setEscapeButton(QMessageBox::No);\n                    if (dialog.exec() == QMessageBox::Yes) {\n                        Mlt::Producer producer(playlist());\n                        if (producer.is_valid()) {\n                            ProxyManager::generateIfNotExistsAll(producer);\n                        }\n                        producer = multitrack();\n                        if (producer.is_valid()) {\n                            ProxyManager::generateIfNotExistsAll(producer);\n                        }\n                    }\n                }\n            } else if (fileName != untitledFileName()) {\n                showStatusMessage(tr(\"Failed to open \") + fileName);\n                emit openFailed(fileName);\n            }\n        } else {\n            ui->actionUseProxy->setChecked(!checked);\n            showSaveError();\n        }\n        QFile::remove(fileName);\n    } else {\n        Settings.setProxyEnabled(checked);\n    }\n    m_player->showIdleStatus();\n}\n\nvoid MainWindow::on_actionProxyStorageSet_triggered()\n{\n    // Present folder dialog just like App Data Directory\n    QString dirName = QFileDialog::getExistingDirectory(this, tr(\"Proxy Folder\"), Settings.proxyFolder());\n    if (!dirName.isEmpty() && dirName != Settings.proxyFolder()) {\n        auto oldFolder = Settings.proxyFolder();\n        Settings.setProxyFolder(dirName);\n        Settings.sync();\n\n        // Get a count for the progress dialog\n        auto oldDir = QDir(oldFolder);\n        auto dirList = oldDir.entryList(QDir::Dirs | QDir::Files | QDir::NoDotAndDotDot);\n        auto count = dirList.size();\n\n        if (count > 0) {\n            // Prompt user if they want to create missing proxies\n            QMessageBox dialog(QMessageBox::Question, qApp->applicationName(),\n               tr(\"Do you want to move all files from the old folder to the new folder?\"),\n               QMessageBox::No | QMessageBox::Yes, this);\n            dialog.setWindowModality(QmlApplication::dialogModality());\n            dialog.setDefaultButton(QMessageBox::Yes);\n            dialog.setEscapeButton(QMessageBox::No);\n            if (dialog.exec() == QMessageBox::Yes) {\n                // Move the existing files\n                LongUiTask longTask(tr(\"Moving Files\"));\n                int i = 0;\n                for (const auto& fileName : dirList) {\n                    if (!fileName.isEmpty() && !QFile::exists(dirName + \"/\" + fileName)) {\n                        LOG_DEBUG() << \"moving\" << oldDir.filePath(fileName) << \"to\" << dirName + \"/\" + fileName;\n                        longTask.reportProgress(fileName, i++, count);\n                        if (!QFile::rename(oldDir.filePath(fileName), dirName + \"/\" + fileName))\n                            LOG_WARNING() << \"Failed to move\" << oldDir.filePath(fileName);\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid MainWindow::on_actionProxyStorageShow_triggered()\n{\n    Util::showInFolder(ProxyManager::dir().path());\n}\n\nvoid MainWindow::on_actionProxyUseProjectFolder_triggered(bool checked)\n{\n    Settings.setProxyUseProjectFolder(checked);\n}\n\nvoid MainWindow::on_actionProxyUseHardware_triggered(bool checked)\n{\n    if (checked && Settings.encodeHardware().isEmpty()) {\n        if (!m_encodeDock->detectHardwareEncoders())\n            ui->actionProxyUseHardware->setChecked(false);\n    }\n    Settings.setProxyUseHardware(ui->actionProxyUseHardware->isChecked());\n}\n\nvoid MainWindow::on_actionProxyConfigureHardware_triggered()\n{\n    m_encodeDock->on_hwencodeButton_clicked();\n    if (Settings.encodeHardware().isEmpty()) {\n        ui->actionProxyUseHardware->setChecked(false);\n        Settings.setProxyUseHardware(false);\n    }\n}\n"], "filenames": ["src/mainwindow.cpp"], "buggy_code_start_loc": [3243], "buggy_code_end_loc": [3706], "fixing_code_start_loc": [3243], "fixing_code_end_loc": [3701], "type": "CWE-295", "message": "In mainwindow.cpp in Shotcut before 20.09.13, the upgrade check misuses TLS because of setPeerVerifyMode(QSslSocket::VerifyNone). A man-in-the-middle attacker could offer a spoofed download resource.", "other": {"cve": {"id": "CVE-2020-24619", "sourceIdentifier": "cve@mitre.org", "published": "2020-09-22T12:15:12.253", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In mainwindow.cpp in Shotcut before 20.09.13, the upgrade check misuses TLS because of setPeerVerifyMode(QSslSocket::VerifyNone). A man-in-the-middle attacker could offer a spoofed download resource."}, {"lang": "es", "value": "En el archivo mainwindow.cpp en Shotcut versiones anteriores a 20.09.13, la comprobaci\u00f3n de actualizaci\u00f3n utiliza incorrectamente TLS debido a la funci\u00f3n setPeerVerifyMode(QSslSocket::VerifyNone).&#xa0;Un atacante de tipo man-in-the-middle podr\u00eda ofrecer un recurso de descarga falsificado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:meltytech:shotcut:*:*:*:*:*:*:*:*", "versionEndExcluding": "20.09.13", "matchCriteriaId": "4D2D6D03-296A-4352-9CB0-7FF13B2CA9FE"}]}]}], "references": [{"url": "https://github.com/mltframework/shotcut/commit/f008adc039642307f6ee3378d378cdb842e52c1d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://shotcut.org/blog/new-release-200913/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/mltframework/shotcut/commit/f008adc039642307f6ee3378d378cdb842e52c1d"}}