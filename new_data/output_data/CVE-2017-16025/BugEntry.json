{"buggy_code": ["'use strict';\n\n// Load modules\n\nconst Boom = require('boom');\nconst Cryptiles = require('cryptiles');\nconst Hoek = require('hoek');\nconst Iron = require('iron');\nconst Items = require('items');\n\n\n// Declare internals\n\nconst internals = {\n    version: '2'\n};\n\n\nexports = module.exports = internals.Socket = function (ws, listener) {\n\n    this._ws = ws;\n    this._listener = listener;\n    this._helloed = false;\n    this._pinged = false;\n    this._processingCount = 0;\n    this._subscriptions = {};\n    this._packets = [];\n    this._sending = false;\n\n    this.connection = this._listener._connection;\n    this.server = this.connection.server;\n    this.id = this._listener._generateId();\n    this.app = {};\n    this.auth = {\n        isAuthenticated: false,\n        credentials: null,\n        artifacts: null,\n        _error: null,\n        _timeout: null\n    };\n\n    ws.on('message', (message) => this._onMessage(message));\n    this._authenticate();\n};\n\n\ninternals.Socket.prototype.disconnect = function (callback) {\n\n    clearTimeout(this.auth._timeout);\n    this.auth._timeout = null;\n\n    if (callback) {\n        this._ws.once('nes-removed', callback);\n    }\n\n    this._ws.close();\n};\n\n\ninternals.Socket.prototype.send = function (message, next) {\n\n    next = next || Hoek.ignore;\n\n    const response = {\n        type: 'update',\n        message\n    };\n\n    return this._send(response, null, next);\n};\n\n\ninternals.Socket.prototype.publish = function (path, update, next) {\n\n    next = next || Hoek.ignore;\n\n    const message = {\n        type: 'pub',\n        path,\n        message: update\n    };\n\n    return this._send(message, null, next);\n};\n\n\ninternals.Socket.prototype.revoke = function (path, update, next) {\n\n    next = next || Hoek.ignore;\n\n    this._unsubscribe(path, () => {\n\n        const message = {\n            type: 'revoke',\n            path\n        };\n\n        if (update !== null) {                  // Allow sending falsy values\n            message.message = update;\n        }\n\n        return this._send(message, null, next);\n    });\n};\n\n\ninternals.Socket.prototype._send = function (message, options, next) {\n\n    options = options || {};\n\n    if (this._ws.readyState !== 1) {                            // Open\n        return next(Boom.internal('Socket not open'));\n    }\n\n    internals.stringify(message, options, (err, string) => {\n\n        if (err) {\n            this._listener._connection.server.log(['nes', 'serialization', 'error'], message.type);\n\n            if (message.id) {\n                return this._error(Boom.internal('Failed serializing message'), message, next);\n            }\n\n            return next(err);\n        }\n\n        this._packets.push({ message: string, type: message.type, next });\n        this._flush();\n    });\n};\n\n\ninternals.Socket.prototype._flush = function () {\n\n    if (this._sending ||\n        !this._packets.length) {\n\n        return;\n    }\n\n    this._sending = true;\n\n    const packet = this._packets.shift();\n    let messages = [packet.message];\n\n    // Break message into smaller chunks\n\n    const maxChunkChars = this._listener._settings.payload.maxChunkChars;\n    if (maxChunkChars &&\n        packet.message.length > maxChunkChars) {\n\n        messages = [];\n        const parts = Math.ceil(packet.message.length / maxChunkChars);\n        for (let i = 0; i < parts; ++i) {\n            const last = (i === parts - 1);\n            const prefix = (last ? '!' : '+');\n            messages.push(prefix + packet.message.slice(i * maxChunkChars, (i + 1) * maxChunkChars));\n        }\n    }\n\n    const each = (message, nextMessage) => {\n\n        this._ws.send(message, (err) => {\n\n            if (packet.type !== 'ping') {\n                this._pinged = true;                        // Consider the connection valid if send() was successful\n            }\n\n            return nextMessage(err);\n        });\n    };\n\n    Items.serial(messages, each, (err) => {\n\n        this._sending = false;\n        process.nextTick(() => {\n\n            return packet.next(err);\n        });\n\n        this._flush();\n    });\n};\n\n\ninternals.Socket.prototype._active = function () {\n\n    return (this._pinged || this._sending || this._processingCount);\n};\n\n\ninternals.Socket.prototype._error = function (err, request, next) {\n\n    err = Boom.wrap(err);\n\n    const message = Hoek.clone(err.output);\n    delete message.payload.statusCode;\n    message.headers = this._filterHeaders(message.headers);\n\n    if (request) {\n        message.type = request.type;\n        message.id = request.id;\n        message.path = request.path;\n    }\n\n    return this._send(message, null, next);\n};\n\n\ninternals.Socket.prototype._onMessage = function (message) {\n\n    this._pinged = true;\n    ++this._processingCount;\n\n    const finalize = (ignoreErr) => {\n\n        --this._processingCount;\n    };\n\n    internals.parse(message, (err, request) => {\n\n        if (err ||\n            !request.type) {\n\n            return this._error(Boom.badRequest('Cannot parse message'), request, finalize);\n        }\n\n        if (!request.id) {\n            return this._error(Boom.badRequest('Message missing id'), request, finalize);\n        }\n\n        // Initialization and Authentication\n\n        if (request.type === 'ping') {\n            return finalize();\n        }\n\n        if (request.type === 'hello') {\n            return this._processHello(request, finalize);\n        }\n\n        if (!this._helloed) {\n            return this._error(Boom.badRequest('Connection is not initialized'), request, finalize);\n        }\n\n        // Endpoint request\n\n        if (request.type === 'request') {\n            return this._processRequest(request, finalize);\n        }\n\n        // Custom message request\n\n        if (request.type === 'message') {\n            return this._processMessage(request, finalize);\n        }\n\n        // Subscriptions\n\n        if (request.type === 'sub') {\n            return this._processSubscription(request, finalize);\n        }\n\n        if (request.type === 'unsub') {\n            return this._unsubscribe(request.path, () => {\n\n                const response = {\n                    type: 'unsub',\n                    id: request.id\n                };\n\n                return this._send(response, null, finalize);\n            });\n        }\n\n        // Unknown\n\n        return this._error(Boom.badRequest('Unknown message type'), request, finalize);\n    });\n};\n\n\ninternals.Socket.prototype._processHello = function (request, next) {\n\n    if (this._helloed) {\n        return this._error(Boom.badRequest('Connection already initialized'), request, next);\n    }\n\n    if (request.version !== internals.version) {\n        return this._error(Boom.badRequest('Incorrect protocol version (expected ' + internals.version + ' but received ' + (request.version || 'none') + ')'), request, next);\n    }\n\n    if (this.auth._error) {\n        const error = this.auth._error;\n        this.auth._error = null;\n        return this._error(error, request, next);\n    }\n\n    if (!request.auth &&\n        !this.auth.isAuthenticated &&\n        this._listener._authRequired()) {\n\n        return this._error(Boom.unauthorized('Connection requires authentication'), request, next);\n    }\n\n    if (request.auth &&\n        this.auth.isAuthenticated) {        // Authenticated using a cookie during upgrade\n\n        return this._error(Boom.badRequest('Connection already authenticated'), request, next);\n    }\n\n    this._helloed = true;                   // Prevents the client from reusing the socket if erred (leaves socket open to ensure client gets the error response)\n    clearTimeout(this.auth._timeout);\n    this.auth._timeout = null;\n\n    const response = {\n        type: 'hello',\n        id: request.id,\n        heartbeat: this._listener._settings.heartbeat,\n        socket: this.id\n    };\n\n    if (!request.auth) {\n        return this._processHelloSubscriptions(request, response, next);\n    }\n\n    const process = (credentials, artifacts) => {\n\n        const error = this._setCredentials(credentials, artifacts);\n        if (error) {\n            return this._error(error, request, next);\n        }\n\n        return this._processHelloSubscriptions(request, response, next);\n    };\n\n    const config = this._listener._settings.auth;\n    if (config.type === 'direct') {\n        const route = this._listener._connection.lookup(config.id);\n        this._listener._connection.inject({ url: route.path, method: 'auth', headers: request.auth.headers, allowInternals: true, validate: false }, (res) => {\n\n            if (res.statusCode !== 200) {\n                return this._error(Boom.unauthorized(res.result.message), request, next);\n            }\n\n            return process(res.result.credentials, res.result.artifacts);\n        });\n\n        return;\n    }\n\n    Iron.unseal(request.auth, config.password, config.iron || Iron.defaults, (err, credentials) => {\n\n        if (err) {\n            return this._error(Boom.unauthorized('Invalid token'), request, next);\n        }\n\n        return process(credentials, null);\n    });\n};\n\n\ninternals.Socket.prototype._processHelloSubscriptions = function (request, response, next) {\n\n    if (this._listener._settings.onConnection) {\n        this._listener._settings.onConnection(this);\n    }\n\n    const each = (path, nextPath) => {\n\n        this._listener._subscribe(path, this, (err) => {\n\n            if (err) {\n                err.path = path;\n            }\n\n            return nextPath(err);\n        });\n    };\n\n    Items.serial(request.subs || [], each, (err) => {\n\n        if (err) {\n            return this._error(err, { type: 'hello', id: request.id, path: err.path }, next);\n        }\n\n        return this._send(response, null, next);\n    });\n};\n\n\ninternals.Socket.prototype._processRequest = function (request, next) {\n\n    let method = request.method;\n    if (!method) {\n        return this._error(Boom.badRequest('Message missing method'), request, next);\n    }\n\n    let path = request.path;\n    if (!path) {\n        return this._error(Boom.badRequest('Message missing path'), request, next);\n    }\n\n    if (request.headers &&\n        internals.caseInsensitiveKey(request.headers, 'authorization')) {\n\n        return this._error(Boom.badRequest('Cannot include an Authorization header'), request, next);\n    }\n\n    if (path[0] !== '/') {              // Route id\n        const route = this._listener._connection.lookup(path);\n        if (!route) {\n            return this._error(Boom.notFound(), request, next);\n        }\n\n        path = route.path;\n        method = route.method;\n\n        if (method === '*') {\n            return this._error(Boom.badRequest('Cannot use route id with wildcard method route config'), request, next);\n        }\n    }\n\n    if (this._listener._settings.auth &&\n        path === this._listener._settings.auth.endpoint) {\n\n        return this._error(Boom.notFound(), request, next);\n    }\n\n    const shot = {\n        method,\n        url: path,\n        payload: request.payload,\n        headers: request.headers,\n        credentials: this.auth.credentials,\n        artifacts: this.auth.artifacts,\n        validate: false,\n        plugins: {\n            nes: {\n                socket: this\n            }\n        }\n    };\n\n    this._listener._connection.inject(shot, (res) => {\n\n        const response = {\n            type: 'request',\n            id: request.id,\n            statusCode: res.statusCode,\n            payload: res.result,\n            headers: this._filterHeaders(res.headers)\n        };\n\n        const options = {};\n        if (typeof res.result === 'string' &&\n            res.headers['content-type'] &&\n            res.headers['content-type'].match(/^application\\/json/)) {\n\n            const token = Cryptiles.randomString(32);\n            options.replace = { [token]: res.result };\n            response.payload = token;\n        }\n\n        return this._send(response, options, next);\n    });\n};\n\n\ninternals.Socket.prototype._processMessage = function (request, next) {\n\n    if (!this._listener._settings.onMessage) {\n        return this._error(Boom.notImplemented(), request, next);\n    }\n\n    this._listener._settings.onMessage(this, request.message, (message) => {\n\n        if (message instanceof Error) {\n            return this._error(message, request, next);\n        }\n\n        const response = {\n            type: 'message',\n            id: request.id,\n            message\n        };\n\n        return this._send(response, null, next);\n    });\n};\n\n\ninternals.Socket.prototype._processSubscription = function (request, next) {\n\n    this._listener._subscribe(request.path, this, (err) => {\n\n        if (err) {\n            return this._error(err, request, next);\n        }\n\n        const response = {\n            type: 'sub',\n            id: request.id,\n            path: request.path\n        };\n\n        return this._send(response, null, next);\n    });\n};\n\n\ninternals.Socket.prototype._unsubscribe = function (path, next) {\n\n    const sub = this._subscriptions[path];\n    if (!sub) {\n        return next();\n    }\n\n    delete this._subscriptions[path];\n    sub.remove(this, path, next);\n};\n\n\ninternals.Socket.prototype._authenticate = function () {\n\n    const config = this._listener._settings.auth;\n    if (!config) {\n        return;\n    }\n\n    if (config.timeout) {\n        this.auth._timeout = setTimeout(() => this.disconnect(), config.timeout);\n    }\n\n    const cookies = this._ws.upgradeReq.headers.cookie;\n    if (!cookies) {\n        return;\n    }\n\n    this._listener._connection.states.parse(cookies, (ignoreErr, state, failed) => {\n\n        const auth = state[config.cookie];\n        if (auth) {\n            this.auth._error = this._setCredentials(auth.credentials, auth.artifacts);\n        }\n    });\n};\n\n\ninternals.Socket.prototype._setCredentials = function (credentials, artifacts) {\n\n    this.auth.isAuthenticated = true;\n    this.auth.credentials = credentials;\n    this.auth.artifacts = artifacts;\n\n    return this._listener._sockets.auth(this);\n};\n\n\ninternals.Socket.prototype._filterHeaders = function (headers) {\n\n    const filter = this._listener._settings.headers;\n    if (!filter) {\n        return undefined;\n    }\n\n    if (filter === '*') {\n        return headers;\n    }\n\n    const filtered = {};\n    const fields = Object.keys(headers);\n    for (let i = 0; i < fields.length; ++i) {\n        const field = fields[i];\n        if (filter.indexOf(field.toLowerCase()) !== -1) {\n            filtered[field] = headers[field];\n        }\n    }\n\n    return filtered;\n};\n\n\ninternals.parse = function (message, next) {\n\n    let obj = null;\n    let error = null;\n\n    try {\n        obj = JSON.parse(message);\n    }\n    catch (err) {\n        error = err;\n    }\n\n    return next(error, obj);\n};\n\n\ninternals.stringify = function (message, options, next) {\n\n    let string = null;\n    let error = null;\n\n    try {\n        string = JSON.stringify(message);\n    }\n    catch (err) {\n        error = err;\n    }\n\n    if (options.replace) {\n        Object.keys(options.replace).forEach((token) => {\n\n            string = string.replace(`\"${token}\"`, options.replace[token]);\n        });\n    }\n\n    return next(error, string);\n};\n\n\ninternals.caseInsensitiveKey = function (object, key) {\n\n    const keys = Object.keys(object);\n    for (let i = 0; i < keys.length; ++i) {\n        const current = keys[i];\n        if (key === current.toLowerCase()) {\n            return object[current];\n        }\n    }\n\n    return undefined;\n};\n", "{\n  \"name\": \"nes\",\n  \"description\": \"WebSocket adapter plugin for hapi routes\",\n  \"version\": \"6.4.0\",\n  \"repository\": \"git://github.com/hapijs/nes\",\n  \"main\": \"lib/index.js\",\n  \"browser\": \"dist/client.js\",\n  \"keywords\": [\n    \"hapi\",\n    \"plugin\",\n    \"websocket\"\n  ],\n  \"engines\": {\n    \"node\": \">=4.5.0\"\n  },\n  \"dependencies\": {\n    \"boom\": \"4.x.x\",\n    \"call\": \"3.x.x\",\n    \"cryptiles\": \"3.x.x\",\n    \"hoek\": \"4.x.x\",\n    \"iron\": \"4.x.x\",\n    \"items\": \"^2.1.x\",\n    \"joi\": \"10.x.x\",\n    \"ws\": \"1.x.x\"\n  },\n  \"peerDependencies\": {\n    \"hapi\": \">=13.0.0\"\n  },\n  \"devDependencies\": {\n    \"babel-cli\": \"^6.1.2\",\n    \"babel-preset-es2015\": \"^6.1.2\",\n    \"code\": \"4.x.x\",\n    \"hapi\": \"16.x.x\",\n    \"lab\": \"11.x.x\"\n  },\n  \"babel\": {\n    \"presets\": [\"es2015\"]\n  },\n  \"scripts\": {\n    \"build-client\": \"mkdir -p dist; babel lib/client.js --out-file dist/client.js\",\n    \"test\": \"npm run-script build-client && node node_modules/lab/bin/lab -a code -t 100 -L\",\n    \"prepublish\": \"npm run-script build-client\",\n    \"test-cov-html\": \"node node_modules/lab/bin/lab -a code -r html -o coverage.html\"\n  },\n  \"license\": \"BSD-3-Clause\"\n}\n", "'use strict';\n\n// Load modules\n\nconst Boom = require('boom');\nconst Code = require('code');\nconst Hapi = require('hapi');\nconst Hoek = require('hoek');\nconst Iron = require('iron');\nconst Lab = require('lab');\nconst Nes = require('../');\n\n\n// Declare internals\n\nconst internals = {};\n\n\n// Test shortcuts\n\nconst lab = exports.lab = Lab.script();\nconst describe = lab.describe;\nconst it = lab.it;\nconst expect = Code.expect;\n\n\ndescribe('authentication', () => {\n\n    const password = 'some_not_random_password_that_is_also_long_enough';\n\n    it('times out when hello is delayed', (done) => {\n\n        const server = new Hapi.Server();\n        server.connection();\n\n        server.auth.scheme('custom', internals.implementation);\n        server.auth.strategy('default', 'custom', true);\n\n        server.register({ register: Nes, options: { auth: { timeout: 100 } } }, (err) => {\n\n            expect(err).to.not.exist();\n\n            server.route({\n                method: 'GET',\n                path: '/',\n                handler: function (request, reply) {\n\n                    return reply('hello');\n                }\n            });\n\n            server.start((err) => {\n\n                expect(err).to.not.exist();\n                const client = new Nes.Client('http://localhost:' + server.info.port);\n                client._hello = Hoek.ignore;\n                client.onError = Hoek.ignore;\n                client.onDisconnect = () => {\n\n                    server.stop(done);\n                };\n\n                client.connect({ auth: { headers: { authorization: 'Custom john' } } }, Hoek.ignore);\n            });\n        });\n    });\n\n    it('disables timeout when hello is delayed', (done) => {\n\n        const server = new Hapi.Server();\n        server.connection();\n\n        server.auth.scheme('custom', internals.implementation);\n        server.auth.strategy('default', 'custom', true);\n\n        server.register({ register: Nes, options: { auth: { timeout: false } } }, (err) => {\n\n            expect(err).to.not.exist();\n\n            server.route({\n                method: 'GET',\n                path: '/',\n                handler: function (request, reply) {\n\n                    return reply('hello');\n                }\n            });\n\n            server.start((err) => {\n\n                expect(err).to.not.exist();\n                const client = new Nes.Client('http://localhost:' + server.info.port);\n                client._hello = Hoek.ignore;\n                client.onError = Hoek.ignore;\n                setTimeout(() => server.stop(done), 100);\n                client.connect({ auth: { headers: { authorization: 'Custom john' } } }, Hoek.ignore);\n            });\n        });\n    });\n\n    describe('cookie', () => {\n\n        it('protects an endpoint', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.register({ register: Nes, options: { auth: { type: 'cookie' } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.auth.scheme('custom', internals.implementation);\n                server.auth.strategy('default', 'custom', true);\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    server.inject({ url: '/nes/auth', headers: { authorization: 'Custom john' } }, (res) => {\n\n                        expect(res.result.status).to.equal('authenticated');\n\n                        const header = res.headers['set-cookie'][0];\n                        const cookie = header.match(/(?:[^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)\\s*=\\s*(?:([^\\x00-\\x20\\\"\\,\\;\\\\\\x7F]*))/);\n\n                        const client = new Nes.Client('http://localhost:' + server.info.port, { ws: { headers: { cookie: 'nes=' + cookie[1] } } });\n                        client.connect((err) => {\n\n                            expect(err).to.not.exist();\n                            client.request('/', (err, payload, statusCode, headers) => {\n\n                                expect(err).to.not.exist();\n                                expect(payload).to.equal('hello');\n                                expect(statusCode).to.equal(200);\n\n                                client.disconnect();\n                                server.stop(done);\n                            });\n                        });\n                    });\n                });\n            });\n        });\n\n        it('limits connections per user', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.register({ register: Nes, options: { auth: { type: 'cookie', maxConnectionsPerUser: 1, index: true } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.auth.scheme('custom', internals.implementation);\n                server.auth.strategy('default', 'custom', true);\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    server.inject({ url: '/nes/auth', headers: { authorization: 'Custom john' } }, (res) => {\n\n                        expect(res.result.status).to.equal('authenticated');\n\n                        const header = res.headers['set-cookie'][0];\n                        const cookie = header.match(/(?:[^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)\\s*=\\s*(?:([^\\x00-\\x20\\\"\\,\\;\\\\\\x7F]*))/);\n\n                        const client = new Nes.Client('http://localhost:' + server.info.port, { ws: { headers: { cookie: 'nes=' + cookie[1] } } });\n                        client.connect((err) => {\n\n                            expect(err).to.not.exist();\n                            const client2 = new Nes.Client('http://localhost:' + server.info.port, { ws: { headers: { cookie: 'nes=' + cookie[1] } } });\n                            client2.connect((err) => {\n\n                                expect(err).to.be.an.error('Too many connections for the authenticated user');\n\n                                client.disconnect();\n                                client2.disconnect();\n                                server.stop(done);\n                            });\n                        });\n                    });\n                });\n            });\n        });\n\n        it('protects an endpoint (no default auth)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom');\n\n            server.register({ register: Nes, options: { auth: { type: 'cookie', route: 'default' } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    config: {\n                        auth: 'default',\n                        handler: function (request, reply) {\n\n                            return reply('hello');\n                        }\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    server.inject({ url: '/nes/auth', headers: { authorization: 'Custom john' } }, (res) => {\n\n                        expect(res.result.status).to.equal('authenticated');\n\n                        const header = res.headers['set-cookie'][0];\n                        const cookie = header.match(/(?:[^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)\\s*=\\s*(?:([^\\x00-\\x20\\\"\\,\\;\\\\\\x7F]*))/);\n\n                        const client = new Nes.Client('http://localhost:' + server.info.port, { ws: { headers: { cookie: 'nes=' + cookie[1] } } });\n                        client.connect((err) => {\n\n                            expect(err).to.not.exist();\n                            client.request('/', (err, payload, statusCode, headers) => {\n\n                                expect(err).to.not.exist();\n                                expect(payload).to.equal('hello');\n                                expect(statusCode).to.equal(200);\n\n                                client.disconnect();\n                                server.stop(done);\n                            });\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on missing auth on an authentication endpoint', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'cookie', password, route: { mode: 'optional' } } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    server.inject('/nes/auth', (res) => {\n\n                        expect(res.result.status).to.equal('unauthenticated');\n\n                        const client = new Nes.Client('http://localhost:' + server.info.port);\n                        client.connect((err) => {\n\n                            expect(err).to.not.exist();\n                            client.request('/', (err, payload, statusCode, headers) => {\n\n                                expect(err).to.exist();\n                                expect(err.message).to.equal('Missing authentication');\n                                expect(err.statusCode).to.equal(401);\n\n                                client.disconnect();\n                                server.stop(done);\n                            });\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on missing auth on an authentication endpoint (other cookies)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'cookie', password, route: { mode: 'optional' } } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    server.inject('/nes/auth', (res) => {\n\n                        expect(res.result.status).to.equal('unauthenticated');\n\n                        const client = new Nes.Client('http://localhost:' + server.info.port, { ws: { headers: { cookie: 'xnes=123' } } });\n                        client.connect((err) => {\n\n                            expect(err).to.not.exist();\n                            client.request('/', (err, payload, statusCode, headers) => {\n\n                                expect(err).to.exist();\n                                expect(err.message).to.equal('Missing authentication');\n                                expect(err.statusCode).to.equal(401);\n\n                                client.disconnect();\n                                server.stop(done);\n                            });\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on double auth', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.register({ register: Nes, options: { auth: { type: 'cookie' } } }, (err) => {\n\n                expect(err).to.not.exist();\n                server.auth.scheme('custom', internals.implementation);\n                server.auth.strategy('default', 'custom', true);\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    server.inject({ url: '/nes/auth', headers: { authorization: 'Custom john' } }, (res) => {\n\n                        expect(res.result.status).to.equal('authenticated');\n\n                        const header = res.headers['set-cookie'][0];\n                        const cookie = header.match(/(?:[^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)\\s*=\\s*(?:([^\\x00-\\x20\\\"\\,\\;\\\\\\x7F]*))/);\n\n                        const client = new Nes.Client('http://localhost:' + server.info.port, { ws: { headers: { cookie: 'nes=' + cookie[1] } } });\n                        client.connect({ auth: 'something' }, (err) => {\n\n                            expect(err).to.exist();\n                            expect(err.message).to.equal('Connection already authenticated');\n                            expect(err.statusCode).to.equal(400);\n\n                            client.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('overrides cookie path', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'cookie', password, path: '/nes/xyz' } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.inject({ url: '/nes/auth', headers: { authorization: 'Custom john' } }, (res) => {\n\n                    expect(res.result.status).to.equal('authenticated');\n\n                    const header = res.headers['set-cookie'][0];\n                    expect(header).to.contain('Path=/nes/xyz');\n                    done();\n                });\n            });\n        });\n    });\n\n    describe('token', () => {\n\n        it('protects an endpoint', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'token', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    server.inject({ url: '/nes/auth', headers: { authorization: 'Custom john' } }, (res) => {\n\n                        expect(res.result.status).to.equal('authenticated');\n                        expect(res.result.token).to.exist();\n\n                        const client = new Nes.Client('http://localhost:' + server.info.port);\n                        client.connect({ auth: res.result.token }, (err) => {\n\n                            expect(err).to.not.exist();\n                            client.request('/', (err, payload, statusCode, headers) => {\n\n                                expect(err).to.not.exist();\n                                expect(payload).to.equal('hello');\n                                expect(statusCode).to.equal(200);\n\n                                client.disconnect();\n                                server.stop(done);\n                            });\n                        });\n                    });\n                });\n            });\n        });\n\n        it('protects an endpoint (token with iron settings)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'token', password, iron: Iron.defaults } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    server.inject({ url: '/nes/auth', headers: { authorization: 'Custom john' } }, (res) => {\n\n                        expect(res.result.status).to.equal('authenticated');\n                        expect(res.result.token).to.exist();\n\n                        const client = new Nes.Client('http://localhost:' + server.info.port);\n                        client.connect({ auth: res.result.token }, (err) => {\n\n                            expect(err).to.not.exist();\n                            client.request('/', (err, payload, statusCode, headers) => {\n\n                                expect(err).to.not.exist();\n                                expect(payload).to.equal('hello');\n                                expect(statusCode).to.equal(200);\n\n                                client.disconnect();\n                                server.stop(done);\n                            });\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on invalid token', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'token', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: 'abc' }, (err) => {\n\n                        expect(err).to.exist();\n                        expect(err.message).to.equal('Invalid token');\n                        expect(err.statusCode).to.equal(401);\n\n                        client.disconnect();\n                        server.stop(done);\n                    });\n                });\n            });\n        });\n\n        it('errors on missing token', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'token', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: '' }, (err) => {\n\n                        expect(err).to.exist();\n                        expect(err.message).to.equal('Connection requires authentication');\n                        expect(err.statusCode).to.equal(401);\n\n                        client.disconnect();\n                        server.stop(done);\n                    });\n                });\n            });\n        });\n\n        it('errors on invalid iron password', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'token', password: new Buffer('') } } }, (err) => {\n\n                expect(err).to.not.exist();\n                server.inject({ url: '/nes/auth', headers: { authorization: 'Custom john' } }, (res) => {\n\n                    expect(res.statusCode).to.equal(500);\n                    done();\n                });\n            });\n        });\n\n        it('errors on double authentication', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'token', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    server.inject({ url: '/nes/auth', headers: { authorization: 'Custom john' } }, (res) => {\n\n                        expect(res.result.status).to.equal('authenticated');\n                        expect(res.result.token).to.exist();\n\n                        const client = new Nes.Client('http://localhost:' + server.info.port);\n                        client.connect({ auth: res.result.token }, (err) => {\n\n                            expect(err).to.not.exist();\n                            client._hello(res.result.token, (err) => {\n\n                                expect(err).to.exist();\n                                expect(err.message).to.equal('Connection already initialized');\n                                expect(err.statusCode).to.equal(400);\n\n                                client.disconnect();\n                                server.stop(done);\n                            });\n                        });\n                    });\n                });\n            });\n        });\n    });\n\n    describe('direct', () => {\n\n        it('protects an endpoint', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register(Nes, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        client.request('/', (err, payload, statusCode, headers) => {\n\n                            expect(err).to.not.exist();\n                            expect(payload).to.equal('hello');\n                            expect(statusCode).to.equal(200);\n\n                            client.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('limits number of connections per user', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { index: true, maxConnectionsPerUser: 1 } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const client2 = new Nes.Client('http://localhost:' + server.info.port);\n                        client2.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                            expect(err).to.be.an.error('Too many connections for the authenticated user');\n\n                            client.disconnect();\n                            client2.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('protects an endpoint with prefix', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register(Nes, { routes: { prefix: '/foo' } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        client.request('/', (err, payload, statusCode, headers) => {\n\n                            expect(err).to.not.exist();\n                            expect(payload).to.equal('hello');\n                            expect(statusCode).to.equal(200);\n\n                            client.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('reconnects automatically', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n\n                    let e = 0;\n                    client.onError = function (err) {\n\n                        expect(err).to.exist();\n                        ++e;\n                    };\n\n                    let c = 0;\n                    client.onConnect = function () {\n\n                        ++c;\n                    };\n\n                    expect(c).to.equal(0);\n                    expect(e).to.equal(0);\n                    client.connect({ delay: 10, auth: { headers: { authorization: 'Custom john' } } }, () => {\n\n                        expect(c).to.equal(1);\n                        expect(e).to.equal(0);\n\n                        client._ws.close();\n                        setTimeout(() => {\n\n                            expect(c).to.equal(2);\n                            expect(e).to.equal(0);\n\n                            client.request('/', (err, payload, statusCode, headers) => {\n\n                                expect(err).to.not.exist();\n                                expect(payload).to.equal('hello');\n                                expect(statusCode).to.equal(200);\n\n                                client.disconnect();\n                                server.stop(done);\n                            });\n                        }, 40);\n                    });\n                });\n            });\n        });\n\n        it('does not reconnect when auth fails', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n\n                    let c = 0;\n                    client.onConnect = function () {\n\n                        ++c;\n                    };\n\n                    expect(c).to.equal(0);\n                    client.connect({ delay: 10, auth: { headers: { authorization: 'Custom steve' } } }, (err) => {\n\n                        expect(err).to.exist();\n                        expect(c).to.equal(0);\n\n                        setTimeout(() => {\n\n                            expect(c).to.equal(0);\n\n                            client.disconnect();\n                            server.stop(done);\n                        }, 20);\n                    });\n                });\n            });\n        });\n\n        it('fails authentication', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom steve' } } }, (err) => {\n\n                        expect(err).to.exist();\n                        expect(err.message).to.equal('Unknown user');\n                        client.disconnect();\n                        server.stop(done);\n                    });\n                });\n            });\n        });\n\n        it('fails authentication', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: '' }, (err) => {\n\n                        expect(err).to.exist();\n                        expect(err.message).to.equal('Connection requires authentication');\n                        client.disconnect();\n                        server.stop(done);\n                    });\n                });\n            });\n        });\n\n        it('subscribes to a path', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/');\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(client.subscriptions()).to.equal(['/']);\n                            expect(update).to.equal('heya');\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('subscribes to a path with filter', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                const filter = function (path, update, options, next) {\n\n                    return next(options.credentials.user === update);\n                };\n\n                server.subscription('/', { filter });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('john');\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n\n                            server.publish('/', 'steve');\n                            server.publish('/', 'john');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on missing auth to subscribe (config)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom');\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { mode: 'required' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect((err) => {\n\n                        expect(err).to.not.exist();\n\n                        client.subscribe('/', Hoek.ignore, (err) => {\n\n                            expect(err).to.exist();\n                            expect(err.message).to.equal('Authentication required to subscribe');\n                            expect(client.subscriptions()).to.equal([]);\n\n                            client.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('does not require auth to subscribe without a default', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom');\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/');\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect((err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('heya');\n                            expect(client.subscriptions()).to.equal(['/']);\n\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('does not require auth to subscribe with optional auth', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', 'optional');\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/');\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect((err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('heya');\n                            expect(client.subscriptions()).to.equal(['/']);\n\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('matches entity (user)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password, index: true } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { entity: 'user' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('heya');\n                            expect(client.subscriptions()).to.equal(['/']);\n\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('matches entity (app)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password, index: true } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { entity: 'app' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom app' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('heya');\n                            expect(client.subscriptions()).to.equal(['/']);\n\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on wrong entity (user)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { entity: 'app' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n\n                        client.subscribe('/', Hoek.ignore, (err) => {\n\n                            expect(err).to.exist();\n                            expect(err.message).to.equal('User credentials cannot be used on an application subscription');\n                            expect(client.subscriptions()).to.equal([]);\n\n                            client.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on wrong entity (app)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { entity: 'user' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom app' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n\n                        client.subscribe('/', Hoek.ignore, (err) => {\n\n                            expect(err).to.exist();\n                            expect(err.message).to.equal('Application credentials cannot be used on a user subscription');\n                            expect(client.subscriptions()).to.equal([]);\n\n                            client.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('matches scope (string/string)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { scope: 'a' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('heya');\n                            expect(client.subscriptions()).to.equal(['/']);\n\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('matches scope (array/string)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { scope: ['x', 'a'] } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('heya');\n                            expect(client.subscriptions()).to.equal(['/']);\n\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('matches scope (string/array)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { scope: 'a' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom ed' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('heya');\n                            expect(client.subscriptions()).to.equal(['/']);\n\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('matches scope (array/array)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { scope: ['b', 'a'] } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom ed' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('heya');\n                            expect(client.subscriptions()).to.equal(['/']);\n\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('matches scope (dynamic)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/{id}', { auth: { scope: ['b', '{id}'] } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom ed' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('heya');\n                            expect(client.subscriptions()).to.equal(['/5']);\n\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/5', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/5', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on wrong scope (string/string)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { scope: 'b' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        client.subscribe('/', Hoek.ignore, (err) => {\n\n                            expect(err).to.exist();\n                            expect(err.message).to.equal('Insufficient scope to subscribe, expected any of: b');\n                            expect(client.subscriptions()).to.equal([]);\n\n                            client.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on wrong scope (string/array)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { scope: 'x' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom ed' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        client.subscribe('/', Hoek.ignore, (err) => {\n\n                            expect(err).to.exist();\n                            expect(err.message).to.equal('Insufficient scope to subscribe, expected any of: x');\n                            expect(client.subscriptions()).to.equal([]);\n\n                            client.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on wrong scope (string/none)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { scope: 'x' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom app' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        client.subscribe('/', Hoek.ignore, (err) => {\n\n                            expect(err).to.exist();\n                            expect(err.message).to.equal('Insufficient scope to subscribe, expected any of: x');\n                            expect(client.subscriptions()).to.equal([]);\n\n                            client.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n    });\n});\n\n\ninternals.implementation = function (server, options) {\n\n    const users = {\n        john: {\n            user: 'john',\n            scope: 'a'\n        },\n        ed: {\n            user: 'ed',\n            scope: ['a', 'b', 5]\n        },\n        app: {\n            app: 'app'\n        }\n    };\n\n    const scheme = {\n        authenticate: function (request, reply) {\n\n            const authorization = request.headers.authorization;\n            if (!authorization) {\n                return reply(Boom.unauthorized(null, 'Custom'));\n            }\n\n            const parts = authorization.split(/\\s+/);\n            const user = users[parts[1]];\n            if (!user) {\n                return reply(Boom.unauthorized('Unknown user', 'Custom'));\n            }\n\n            return reply.continue({ credentials: user });\n        }\n    };\n\n    return scheme;\n};\n"], "fixing_code": ["'use strict';\n\n// Load modules\n\nconst Boom = require('boom');\nconst Cryptiles = require('cryptiles');\nconst Hoek = require('hoek');\nconst Iron = require('iron');\nconst Items = require('items');\n\n\n// Declare internals\n\nconst internals = {\n    version: '2'\n};\n\n\nexports = module.exports = internals.Socket = function (ws, listener) {\n\n    this._ws = ws;\n    this._listener = listener;\n    this._helloed = false;\n    this._pinged = false;\n    this._processingCount = 0;\n    this._subscriptions = {};\n    this._packets = [];\n    this._sending = false;\n\n    this.connection = this._listener._connection;\n    this.server = this.connection.server;\n    this.id = this._listener._generateId();\n    this.app = {};\n    this.auth = {\n        isAuthenticated: false,\n        credentials: null,\n        artifacts: null,\n        _error: null,\n        _timeout: null\n    };\n\n    ws.on('message', (message) => this._onMessage(message));\n    this._authenticate();\n};\n\n\ninternals.Socket.prototype.disconnect = function (callback) {\n\n    clearTimeout(this.auth._timeout);\n    this.auth._timeout = null;\n\n    if (callback) {\n        this._ws.once('nes-removed', callback);\n    }\n\n    this._ws.close();\n};\n\n\ninternals.Socket.prototype.send = function (message, next) {\n\n    next = next || Hoek.ignore;\n\n    const response = {\n        type: 'update',\n        message\n    };\n\n    return this._send(response, null, next);\n};\n\n\ninternals.Socket.prototype.publish = function (path, update, next) {\n\n    next = next || Hoek.ignore;\n\n    const message = {\n        type: 'pub',\n        path,\n        message: update\n    };\n\n    return this._send(message, null, next);\n};\n\n\ninternals.Socket.prototype.revoke = function (path, update, next) {\n\n    next = next || Hoek.ignore;\n\n    this._unsubscribe(path, () => {\n\n        const message = {\n            type: 'revoke',\n            path\n        };\n\n        if (update !== null) {                  // Allow sending falsy values\n            message.message = update;\n        }\n\n        return this._send(message, null, next);\n    });\n};\n\n\ninternals.Socket.prototype._send = function (message, options, next) {\n\n    options = options || {};\n\n    if (this._ws.readyState !== 1) {                            // Open\n        return next(Boom.internal('Socket not open'));\n    }\n\n    internals.stringify(message, options, (err, string) => {\n\n        if (err) {\n            this._listener._connection.server.log(['nes', 'serialization', 'error'], message.type);\n\n            if (message.id) {\n                return this._error(Boom.internal('Failed serializing message'), message, next);\n            }\n\n            return next(err);\n        }\n\n        this._packets.push({ message: string, type: message.type, next });\n        this._flush();\n    });\n};\n\n\ninternals.Socket.prototype._flush = function () {\n\n    if (this._sending ||\n        !this._packets.length) {\n\n        return;\n    }\n\n    this._sending = true;\n\n    const packet = this._packets.shift();\n    let messages = [packet.message];\n\n    // Break message into smaller chunks\n\n    const maxChunkChars = this._listener._settings.payload.maxChunkChars;\n    if (maxChunkChars &&\n        packet.message.length > maxChunkChars) {\n\n        messages = [];\n        const parts = Math.ceil(packet.message.length / maxChunkChars);\n        for (let i = 0; i < parts; ++i) {\n            const last = (i === parts - 1);\n            const prefix = (last ? '!' : '+');\n            messages.push(prefix + packet.message.slice(i * maxChunkChars, (i + 1) * maxChunkChars));\n        }\n    }\n\n    const each = (message, nextMessage) => {\n\n        this._ws.send(message, (err) => {\n\n            if (packet.type !== 'ping') {\n                this._pinged = true;                        // Consider the connection valid if send() was successful\n            }\n\n            return nextMessage(err);\n        });\n    };\n\n    Items.serial(messages, each, (err) => {\n\n        this._sending = false;\n        process.nextTick(() => {\n\n            return packet.next(err);\n        });\n\n        this._flush();\n    });\n};\n\n\ninternals.Socket.prototype._active = function () {\n\n    return (this._pinged || this._sending || this._processingCount);\n};\n\n\ninternals.Socket.prototype._error = function (err, request, next) {\n\n    err = Boom.wrap(err);\n\n    const message = Hoek.clone(err.output);\n    delete message.payload.statusCode;\n    message.headers = this._filterHeaders(message.headers);\n\n    if (request) {\n        message.type = request.type;\n        message.id = request.id;\n        message.path = request.path;\n    }\n\n    return this._send(message, null, next);\n};\n\n\ninternals.Socket.prototype._onMessage = function (message) {\n\n    this._pinged = true;\n    ++this._processingCount;\n\n    const finalize = (ignoreErr) => {\n\n        --this._processingCount;\n    };\n\n    internals.parse(message, (err, request) => {\n\n        if (err ||\n            !request.type) {\n\n            return this._error(Boom.badRequest('Cannot parse message'), request, finalize);\n        }\n\n        if (!request.id) {\n            return this._error(Boom.badRequest('Message missing id'), request, finalize);\n        }\n\n        // Initialization and Authentication\n\n        if (request.type === 'ping') {\n            return finalize();\n        }\n\n        if (request.type === 'hello') {\n            return this._processHello(request, finalize);\n        }\n\n        if (!this._helloed) {\n            return this._error(Boom.badRequest('Connection is not initialized'), request, finalize);\n        }\n\n        // Endpoint request\n\n        if (request.type === 'request') {\n            return this._processRequest(request, finalize);\n        }\n\n        // Custom message request\n\n        if (request.type === 'message') {\n            return this._processMessage(request, finalize);\n        }\n\n        // Subscriptions\n\n        if (request.type === 'sub') {\n            return this._processSubscription(request, finalize);\n        }\n\n        if (request.type === 'unsub') {\n            return this._unsubscribe(request.path, () => {\n\n                const response = {\n                    type: 'unsub',\n                    id: request.id\n                };\n\n                return this._send(response, null, finalize);\n            });\n        }\n\n        // Unknown\n\n        return this._error(Boom.badRequest('Unknown message type'), request, finalize);\n    });\n};\n\n\ninternals.Socket.prototype._processHello = function (request, next) {\n\n    if (this._helloed) {\n        return this._error(Boom.badRequest('Connection already initialized'), request, next);\n    }\n\n    if (request.version !== internals.version) {\n        return this._error(Boom.badRequest('Incorrect protocol version (expected ' + internals.version + ' but received ' + (request.version || 'none') + ')'), request, next);\n    }\n\n    if (this.auth._error) {\n        const error = this.auth._error;\n        this.auth._error = null;\n        return this._error(error, request, next);\n    }\n\n    if (!request.auth &&\n        !this.auth.isAuthenticated &&\n        this._listener._authRequired()) {\n\n        return this._error(Boom.unauthorized('Connection requires authentication'), request, next);\n    }\n\n    if (request.auth &&\n        this.auth.isAuthenticated) {        // Authenticated using a cookie during upgrade\n\n        return this._error(Boom.badRequest('Connection already authenticated'), request, next);\n    }\n\n    this._helloed = true;                   // Prevents the client from reusing the socket if erred (leaves socket open to ensure client gets the error response)\n    clearTimeout(this.auth._timeout);\n    this.auth._timeout = null;\n\n    const response = {\n        type: 'hello',\n        id: request.id,\n        heartbeat: this._listener._settings.heartbeat,\n        socket: this.id\n    };\n\n    if (!request.auth) {\n        return this._processHelloSubscriptions(request, response, next);\n    }\n\n    const process = (credentials, artifacts) => {\n\n        const error = this._setCredentials(credentials, artifacts);\n        if (error) {\n            return this._error(error, request, next);\n        }\n\n        return this._processHelloSubscriptions(request, response, next);\n    };\n\n    const config = this._listener._settings.auth;\n    if (config.type === 'direct') {\n        const route = this._listener._connection.lookup(config.id);\n        this._listener._connection.inject({ url: route.path, method: 'auth', headers: request.auth.headers, allowInternals: true, validate: false }, (res) => {\n\n            if (res.statusCode !== 200) {\n                return this._error(Boom.unauthorized(res.result.message), request, next);\n            }\n\n            return process(res.result.credentials, res.result.artifacts);\n        });\n\n        return;\n    }\n\n    Iron.unseal(request.auth, config.password, config.iron || Iron.defaults, (err, credentials) => {\n\n        if (err) {\n            return this._error(Boom.unauthorized('Invalid token'), request, next);\n        }\n\n        return process(credentials, null);\n    });\n};\n\n\ninternals.Socket.prototype._processHelloSubscriptions = function (request, response, next) {\n\n    if (this._listener._settings.onConnection) {\n        this._listener._settings.onConnection(this);\n    }\n\n    const each = (path, nextPath) => {\n\n        this._listener._subscribe(path, this, (err) => {\n\n            if (err) {\n                err.path = path;\n            }\n\n            return nextPath(err);\n        });\n    };\n\n    Items.serial(request.subs || [], each, (err) => {\n\n        if (err) {\n            return this._error(err, { type: 'hello', id: request.id, path: err.path }, next);\n        }\n\n        return this._send(response, null, next);\n    });\n};\n\n\ninternals.Socket.prototype._processRequest = function (request, next) {\n\n    let method = request.method;\n    if (!method) {\n        return this._error(Boom.badRequest('Message missing method'), request, next);\n    }\n\n    let path = request.path;\n    if (!path) {\n        return this._error(Boom.badRequest('Message missing path'), request, next);\n    }\n\n    if (request.headers &&\n        internals.caseInsensitiveKey(request.headers, 'authorization')) {\n\n        return this._error(Boom.badRequest('Cannot include an Authorization header'), request, next);\n    }\n\n    if (path[0] !== '/') {              // Route id\n        const route = this._listener._connection.lookup(path);\n        if (!route) {\n            return this._error(Boom.notFound(), request, next);\n        }\n\n        path = route.path;\n        method = route.method;\n\n        if (method === '*') {\n            return this._error(Boom.badRequest('Cannot use route id with wildcard method route config'), request, next);\n        }\n    }\n\n    if (this._listener._settings.auth &&\n        path === this._listener._settings.auth.endpoint) {\n\n        return this._error(Boom.notFound(), request, next);\n    }\n\n    const shot = {\n        method,\n        url: path,\n        payload: request.payload,\n        headers: request.headers,\n        credentials: this.auth.credentials,\n        artifacts: this.auth.artifacts,\n        validate: false,\n        plugins: {\n            nes: {\n                socket: this\n            }\n        }\n    };\n\n    this._listener._connection.inject(shot, (res) => {\n\n        const response = {\n            type: 'request',\n            id: request.id,\n            statusCode: res.statusCode,\n            payload: res.result,\n            headers: this._filterHeaders(res.headers)\n        };\n\n        const options = {};\n        if (typeof res.result === 'string' &&\n            res.headers['content-type'] &&\n            res.headers['content-type'].match(/^application\\/json/)) {\n\n            const token = Cryptiles.randomString(32);\n            options.replace = { [token]: res.result };\n            response.payload = token;\n        }\n\n        return this._send(response, options, next);\n    });\n};\n\n\ninternals.Socket.prototype._processMessage = function (request, next) {\n\n    if (!this._listener._settings.onMessage) {\n        return this._error(Boom.notImplemented(), request, next);\n    }\n\n    this._listener._settings.onMessage(this, request.message, (message) => {\n\n        if (message instanceof Error) {\n            return this._error(message, request, next);\n        }\n\n        const response = {\n            type: 'message',\n            id: request.id,\n            message\n        };\n\n        return this._send(response, null, next);\n    });\n};\n\n\ninternals.Socket.prototype._processSubscription = function (request, next) {\n\n    this._listener._subscribe(request.path, this, (err) => {\n\n        if (err) {\n            return this._error(err, request, next);\n        }\n\n        const response = {\n            type: 'sub',\n            id: request.id,\n            path: request.path\n        };\n\n        return this._send(response, null, next);\n    });\n};\n\n\ninternals.Socket.prototype._unsubscribe = function (path, next) {\n\n    const sub = this._subscriptions[path];\n    if (!sub) {\n        return next();\n    }\n\n    delete this._subscriptions[path];\n    sub.remove(this, path, next);\n};\n\n\ninternals.Socket.prototype._authenticate = function () {\n\n    const config = this._listener._settings.auth;\n    if (!config) {\n        return;\n    }\n\n    if (config.timeout) {\n        this.auth._timeout = setTimeout(() => this.disconnect(), config.timeout);\n    }\n\n    const cookies = this._ws.upgradeReq.headers.cookie;\n    if (!cookies) {\n        return;\n    }\n\n    this._listener._connection.states.parse(cookies, (err, state, failed) => {\n\n        if (err) {\n            this.auth._error = Boom.unauthorized('Invalid nes authentication cookie');\n            return;\n        }\n\n        const auth = state[config.cookie];\n        if (auth) {\n            this.auth._error = this._setCredentials(auth.credentials, auth.artifacts);\n        }\n    });\n};\n\n\ninternals.Socket.prototype._setCredentials = function (credentials, artifacts) {\n\n    this.auth.isAuthenticated = true;\n    this.auth.credentials = credentials;\n    this.auth.artifacts = artifacts;\n\n    return this._listener._sockets.auth(this);\n};\n\n\ninternals.Socket.prototype._filterHeaders = function (headers) {\n\n    const filter = this._listener._settings.headers;\n    if (!filter) {\n        return undefined;\n    }\n\n    if (filter === '*') {\n        return headers;\n    }\n\n    const filtered = {};\n    const fields = Object.keys(headers);\n    for (let i = 0; i < fields.length; ++i) {\n        const field = fields[i];\n        if (filter.indexOf(field.toLowerCase()) !== -1) {\n            filtered[field] = headers[field];\n        }\n    }\n\n    return filtered;\n};\n\n\ninternals.parse = function (message, next) {\n\n    let obj = null;\n    let error = null;\n\n    try {\n        obj = JSON.parse(message);\n    }\n    catch (err) {\n        error = err;\n    }\n\n    return next(error, obj);\n};\n\n\ninternals.stringify = function (message, options, next) {\n\n    let string = null;\n    let error = null;\n\n    try {\n        string = JSON.stringify(message);\n    }\n    catch (err) {\n        error = err;\n    }\n\n    if (options.replace) {\n        Object.keys(options.replace).forEach((token) => {\n\n            string = string.replace(`\"${token}\"`, options.replace[token]);\n        });\n    }\n\n    return next(error, string);\n};\n\n\ninternals.caseInsensitiveKey = function (object, key) {\n\n    const keys = Object.keys(object);\n    for (let i = 0; i < keys.length; ++i) {\n        const current = keys[i];\n        if (key === current.toLowerCase()) {\n            return object[current];\n        }\n    }\n\n    return undefined;\n};\n", "{\n  \"name\": \"nes\",\n  \"description\": \"WebSocket adapter plugin for hapi routes\",\n  \"version\": \"6.4.1\",\n  \"repository\": \"git://github.com/hapijs/nes\",\n  \"main\": \"lib/index.js\",\n  \"browser\": \"dist/client.js\",\n  \"keywords\": [\n    \"hapi\",\n    \"plugin\",\n    \"websocket\"\n  ],\n  \"engines\": {\n    \"node\": \">=4.5.0\"\n  },\n  \"dependencies\": {\n    \"boom\": \"4.x.x\",\n    \"call\": \"3.x.x\",\n    \"cryptiles\": \"3.x.x\",\n    \"hoek\": \"4.x.x\",\n    \"iron\": \"4.x.x\",\n    \"items\": \"^2.1.x\",\n    \"joi\": \"10.x.x\",\n    \"ws\": \"1.x.x\"\n  },\n  \"peerDependencies\": {\n    \"hapi\": \">=13.0.0\"\n  },\n  \"devDependencies\": {\n    \"babel-cli\": \"^6.1.2\",\n    \"babel-preset-es2015\": \"^6.1.2\",\n    \"code\": \"4.x.x\",\n    \"hapi\": \"16.x.x\",\n    \"lab\": \"13.x.x\"\n  },\n  \"babel\": {\n    \"presets\": [\"es2015\"]\n  },\n  \"scripts\": {\n    \"build-client\": \"mkdir -p dist; babel lib/client.js --out-file dist/client.js\",\n    \"test\": \"npm run-script build-client && node node_modules/lab/bin/lab -a code -t 100 -L\",\n    \"prepublish\": \"npm run-script build-client\",\n    \"test-cov-html\": \"node node_modules/lab/bin/lab -a code -r html -o coverage.html\"\n  },\n  \"license\": \"BSD-3-Clause\"\n}\n", "'use strict';\n\n// Load modules\n\nconst Boom = require('boom');\nconst Code = require('code');\nconst Hapi = require('hapi');\nconst Hoek = require('hoek');\nconst Iron = require('iron');\nconst Lab = require('lab');\nconst Nes = require('../');\n\n\n// Declare internals\n\nconst internals = {};\n\n\n// Test shortcuts\n\nconst lab = exports.lab = Lab.script();\nconst describe = lab.describe;\nconst it = lab.it;\nconst expect = Code.expect;\n\n\ndescribe('authentication', () => {\n\n    const password = 'some_not_random_password_that_is_also_long_enough';\n\n    it('times out when hello is delayed', (done) => {\n\n        const server = new Hapi.Server();\n        server.connection();\n\n        server.auth.scheme('custom', internals.implementation);\n        server.auth.strategy('default', 'custom', true);\n\n        server.register({ register: Nes, options: { auth: { timeout: 100 } } }, (err) => {\n\n            expect(err).to.not.exist();\n\n            server.route({\n                method: 'GET',\n                path: '/',\n                handler: function (request, reply) {\n\n                    return reply('hello');\n                }\n            });\n\n            server.start((err) => {\n\n                expect(err).to.not.exist();\n                const client = new Nes.Client('http://localhost:' + server.info.port);\n                client._hello = Hoek.ignore;\n                client.onError = Hoek.ignore;\n                client.onDisconnect = () => {\n\n                    server.stop(done);\n                };\n\n                client.connect({ auth: { headers: { authorization: 'Custom john' } } }, Hoek.ignore);\n            });\n        });\n    });\n\n    it('disables timeout when hello is delayed', (done) => {\n\n        const server = new Hapi.Server();\n        server.connection();\n\n        server.auth.scheme('custom', internals.implementation);\n        server.auth.strategy('default', 'custom', true);\n\n        server.register({ register: Nes, options: { auth: { timeout: false } } }, (err) => {\n\n            expect(err).to.not.exist();\n\n            server.route({\n                method: 'GET',\n                path: '/',\n                handler: function (request, reply) {\n\n                    return reply('hello');\n                }\n            });\n\n            server.start((err) => {\n\n                expect(err).to.not.exist();\n                const client = new Nes.Client('http://localhost:' + server.info.port);\n                client._hello = Hoek.ignore;\n                client.onError = Hoek.ignore;\n                setTimeout(() => server.stop(done), 100);\n                client.connect({ auth: { headers: { authorization: 'Custom john' } } }, Hoek.ignore);\n            });\n        });\n    });\n\n    describe('cookie', () => {\n\n        it('protects an endpoint', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.register({ register: Nes, options: { auth: { type: 'cookie' } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.auth.scheme('custom', internals.implementation);\n                server.auth.strategy('default', 'custom', true);\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    server.inject({ url: '/nes/auth', headers: { authorization: 'Custom john' } }, (res) => {\n\n                        expect(res.result.status).to.equal('authenticated');\n\n                        const header = res.headers['set-cookie'][0];\n                        const cookie = header.match(/(?:[^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)\\s*=\\s*(?:([^\\x00-\\x20\\\"\\,\\;\\\\\\x7F]*))/);\n\n                        const client = new Nes.Client('http://localhost:' + server.info.port, { ws: { headers: { cookie: 'nes=' + cookie[1] } } });\n                        client.connect((err) => {\n\n                            expect(err).to.not.exist();\n                            client.request('/', (err, payload, statusCode, headers) => {\n\n                                expect(err).to.not.exist();\n                                expect(payload).to.equal('hello');\n                                expect(statusCode).to.equal(200);\n\n                                client.disconnect();\n                                server.stop(done);\n                            });\n                        });\n                    });\n                });\n            });\n        });\n\n        it('limits connections per user', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.register({ register: Nes, options: { auth: { type: 'cookie', maxConnectionsPerUser: 1, index: true } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.auth.scheme('custom', internals.implementation);\n                server.auth.strategy('default', 'custom', true);\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    server.inject({ url: '/nes/auth', headers: { authorization: 'Custom john' } }, (res) => {\n\n                        expect(res.result.status).to.equal('authenticated');\n\n                        const header = res.headers['set-cookie'][0];\n                        const cookie = header.match(/(?:[^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)\\s*=\\s*(?:([^\\x00-\\x20\\\"\\,\\;\\\\\\x7F]*))/);\n\n                        const client = new Nes.Client('http://localhost:' + server.info.port, { ws: { headers: { cookie: 'nes=' + cookie[1] } } });\n                        client.connect((err) => {\n\n                            expect(err).to.not.exist();\n                            const client2 = new Nes.Client('http://localhost:' + server.info.port, { ws: { headers: { cookie: 'nes=' + cookie[1] } } });\n                            client2.connect((err) => {\n\n                                expect(err).to.be.an.error('Too many connections for the authenticated user');\n\n                                client.disconnect();\n                                client2.disconnect();\n                                server.stop(done);\n                            });\n                        });\n                    });\n                });\n            });\n        });\n\n        it('protects an endpoint (no default auth)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom');\n\n            server.register({ register: Nes, options: { auth: { type: 'cookie', route: 'default' } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    config: {\n                        auth: 'default',\n                        handler: function (request, reply) {\n\n                            return reply('hello');\n                        }\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    server.inject({ url: '/nes/auth', headers: { authorization: 'Custom john' } }, (res) => {\n\n                        expect(res.result.status).to.equal('authenticated');\n\n                        const header = res.headers['set-cookie'][0];\n                        const cookie = header.match(/(?:[^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)\\s*=\\s*(?:([^\\x00-\\x20\\\"\\,\\;\\\\\\x7F]*))/);\n\n                        const client = new Nes.Client('http://localhost:' + server.info.port, { ws: { headers: { cookie: 'nes=' + cookie[1] } } });\n                        client.connect((err) => {\n\n                            expect(err).to.not.exist();\n                            client.request('/', (err, payload, statusCode, headers) => {\n\n                                expect(err).to.not.exist();\n                                expect(payload).to.equal('hello');\n                                expect(statusCode).to.equal(200);\n\n                                client.disconnect();\n                                server.stop(done);\n                            });\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on missing auth on an authentication endpoint', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'cookie', password, route: { mode: 'optional' } } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    server.inject('/nes/auth', (res) => {\n\n                        expect(res.result.status).to.equal('unauthenticated');\n\n                        const client = new Nes.Client('http://localhost:' + server.info.port);\n                        client.connect((err) => {\n\n                            expect(err).to.not.exist();\n                            client.request('/', (err, payload, statusCode, headers) => {\n\n                                expect(err).to.exist();\n                                expect(err.message).to.equal('Missing authentication');\n                                expect(err.statusCode).to.equal(401);\n\n                                client.disconnect();\n                                server.stop(done);\n                            });\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on missing auth on an authentication endpoint (other cookies)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'cookie', password, route: { mode: 'optional' } } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    server.inject('/nes/auth', (res) => {\n\n                        expect(res.result.status).to.equal('unauthenticated');\n\n                        const client = new Nes.Client('http://localhost:' + server.info.port, { ws: { headers: { cookie: 'xnes=123' } } });\n                        client.connect((err) => {\n\n                            expect(err).to.not.exist();\n                            client.request('/', (err, payload, statusCode, headers) => {\n\n                                expect(err).to.exist();\n                                expect(err.message).to.equal('Missing authentication');\n                                expect(err.statusCode).to.equal(401);\n\n                                client.disconnect();\n                                server.stop(done);\n                            });\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on double auth', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.register({ register: Nes, options: { auth: { type: 'cookie' } } }, (err) => {\n\n                expect(err).to.not.exist();\n                server.auth.scheme('custom', internals.implementation);\n                server.auth.strategy('default', 'custom', true);\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    server.inject({ url: '/nes/auth', headers: { authorization: 'Custom john' } }, (res) => {\n\n                        expect(res.result.status).to.equal('authenticated');\n\n                        const header = res.headers['set-cookie'][0];\n                        const cookie = header.match(/(?:[^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)\\s*=\\s*(?:([^\\x00-\\x20\\\"\\,\\;\\\\\\x7F]*))/);\n\n                        const client = new Nes.Client('http://localhost:' + server.info.port, { ws: { headers: { cookie: 'nes=' + cookie[1] } } });\n                        client.connect({ auth: 'something' }, (err) => {\n\n                            expect(err).to.exist();\n                            expect(err.message).to.equal('Connection already authenticated');\n                            expect(err.statusCode).to.equal(400);\n\n                            client.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on invalid cookie', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.register({ register: Nes, options: { auth: { type: 'cookie' } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.auth.scheme('custom', internals.implementation);\n                server.auth.strategy('default', 'custom', true);\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port, { ws: { headers: { cookie: '\"' } } });\n                    client.connect((err) => {\n\n                        expect(err).to.be.an.error('Invalid nes authentication cookie');\n                        client.disconnect();\n                        server.stop(done);\n                    });\n                });\n            });\n        });\n\n        it('overrides cookie path', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'cookie', password, path: '/nes/xyz' } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.inject({ url: '/nes/auth', headers: { authorization: 'Custom john' } }, (res) => {\n\n                    expect(res.result.status).to.equal('authenticated');\n\n                    const header = res.headers['set-cookie'][0];\n                    expect(header).to.contain('Path=/nes/xyz');\n                    done();\n                });\n            });\n        });\n    });\n\n    describe('token', () => {\n\n        it('protects an endpoint', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'token', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    server.inject({ url: '/nes/auth', headers: { authorization: 'Custom john' } }, (res) => {\n\n                        expect(res.result.status).to.equal('authenticated');\n                        expect(res.result.token).to.exist();\n\n                        const client = new Nes.Client('http://localhost:' + server.info.port);\n                        client.connect({ auth: res.result.token }, (err) => {\n\n                            expect(err).to.not.exist();\n                            client.request('/', (err, payload, statusCode, headers) => {\n\n                                expect(err).to.not.exist();\n                                expect(payload).to.equal('hello');\n                                expect(statusCode).to.equal(200);\n\n                                client.disconnect();\n                                server.stop(done);\n                            });\n                        });\n                    });\n                });\n            });\n        });\n\n        it('protects an endpoint (token with iron settings)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'token', password, iron: Iron.defaults } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    server.inject({ url: '/nes/auth', headers: { authorization: 'Custom john' } }, (res) => {\n\n                        expect(res.result.status).to.equal('authenticated');\n                        expect(res.result.token).to.exist();\n\n                        const client = new Nes.Client('http://localhost:' + server.info.port);\n                        client.connect({ auth: res.result.token }, (err) => {\n\n                            expect(err).to.not.exist();\n                            client.request('/', (err, payload, statusCode, headers) => {\n\n                                expect(err).to.not.exist();\n                                expect(payload).to.equal('hello');\n                                expect(statusCode).to.equal(200);\n\n                                client.disconnect();\n                                server.stop(done);\n                            });\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on invalid token', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'token', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: 'abc' }, (err) => {\n\n                        expect(err).to.exist();\n                        expect(err.message).to.equal('Invalid token');\n                        expect(err.statusCode).to.equal(401);\n\n                        client.disconnect();\n                        server.stop(done);\n                    });\n                });\n            });\n        });\n\n        it('errors on missing token', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'token', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: '' }, (err) => {\n\n                        expect(err).to.exist();\n                        expect(err.message).to.equal('Connection requires authentication');\n                        expect(err.statusCode).to.equal(401);\n\n                        client.disconnect();\n                        server.stop(done);\n                    });\n                });\n            });\n        });\n\n        it('errors on invalid iron password', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'token', password: new Buffer('') } } }, (err) => {\n\n                expect(err).to.not.exist();\n                server.inject({ url: '/nes/auth', headers: { authorization: 'Custom john' } }, (res) => {\n\n                    expect(res.statusCode).to.equal(500);\n                    done();\n                });\n            });\n        });\n\n        it('errors on double authentication', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'token', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    server.inject({ url: '/nes/auth', headers: { authorization: 'Custom john' } }, (res) => {\n\n                        expect(res.result.status).to.equal('authenticated');\n                        expect(res.result.token).to.exist();\n\n                        const client = new Nes.Client('http://localhost:' + server.info.port);\n                        client.connect({ auth: res.result.token }, (err) => {\n\n                            expect(err).to.not.exist();\n                            client._hello(res.result.token, (err) => {\n\n                                expect(err).to.exist();\n                                expect(err.message).to.equal('Connection already initialized');\n                                expect(err.statusCode).to.equal(400);\n\n                                client.disconnect();\n                                server.stop(done);\n                            });\n                        });\n                    });\n                });\n            });\n        });\n    });\n\n    describe('direct', () => {\n\n        it('protects an endpoint', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register(Nes, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        client.request('/', (err, payload, statusCode, headers) => {\n\n                            expect(err).to.not.exist();\n                            expect(payload).to.equal('hello');\n                            expect(statusCode).to.equal(200);\n\n                            client.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('limits number of connections per user', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { index: true, maxConnectionsPerUser: 1 } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const client2 = new Nes.Client('http://localhost:' + server.info.port);\n                        client2.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                            expect(err).to.be.an.error('Too many connections for the authenticated user');\n\n                            client.disconnect();\n                            client2.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('protects an endpoint with prefix', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register(Nes, { routes: { prefix: '/foo' } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        client.request('/', (err, payload, statusCode, headers) => {\n\n                            expect(err).to.not.exist();\n                            expect(payload).to.equal('hello');\n                            expect(statusCode).to.equal(200);\n\n                            client.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('reconnects automatically', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.route({\n                    method: 'GET',\n                    path: '/',\n                    handler: function (request, reply) {\n\n                        return reply('hello');\n                    }\n                });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n\n                    let e = 0;\n                    client.onError = function (err) {\n\n                        expect(err).to.exist();\n                        ++e;\n                    };\n\n                    let c = 0;\n                    client.onConnect = function () {\n\n                        ++c;\n                    };\n\n                    expect(c).to.equal(0);\n                    expect(e).to.equal(0);\n                    client.connect({ delay: 10, auth: { headers: { authorization: 'Custom john' } } }, () => {\n\n                        expect(c).to.equal(1);\n                        expect(e).to.equal(0);\n\n                        client._ws.close();\n                        setTimeout(() => {\n\n                            expect(c).to.equal(2);\n                            expect(e).to.equal(0);\n\n                            client.request('/', (err, payload, statusCode, headers) => {\n\n                                expect(err).to.not.exist();\n                                expect(payload).to.equal('hello');\n                                expect(statusCode).to.equal(200);\n\n                                client.disconnect();\n                                server.stop(done);\n                            });\n                        }, 40);\n                    });\n                });\n            });\n        });\n\n        it('does not reconnect when auth fails', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n\n                    let c = 0;\n                    client.onConnect = function () {\n\n                        ++c;\n                    };\n\n                    expect(c).to.equal(0);\n                    client.connect({ delay: 10, auth: { headers: { authorization: 'Custom steve' } } }, (err) => {\n\n                        expect(err).to.exist();\n                        expect(c).to.equal(0);\n\n                        setTimeout(() => {\n\n                            expect(c).to.equal(0);\n\n                            client.disconnect();\n                            server.stop(done);\n                        }, 20);\n                    });\n                });\n            });\n        });\n\n        it('fails authentication', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom steve' } } }, (err) => {\n\n                        expect(err).to.exist();\n                        expect(err.message).to.equal('Unknown user');\n                        client.disconnect();\n                        server.stop(done);\n                    });\n                });\n            });\n        });\n\n        it('fails authentication', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: '' }, (err) => {\n\n                        expect(err).to.exist();\n                        expect(err.message).to.equal('Connection requires authentication');\n                        client.disconnect();\n                        server.stop(done);\n                    });\n                });\n            });\n        });\n\n        it('subscribes to a path', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/');\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(client.subscriptions()).to.equal(['/']);\n                            expect(update).to.equal('heya');\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('subscribes to a path with filter', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                const filter = function (path, update, options, next) {\n\n                    return next(options.credentials.user === update);\n                };\n\n                server.subscription('/', { filter });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('john');\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n\n                            server.publish('/', 'steve');\n                            server.publish('/', 'john');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on missing auth to subscribe (config)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom');\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { mode: 'required' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect((err) => {\n\n                        expect(err).to.not.exist();\n\n                        client.subscribe('/', Hoek.ignore, (err) => {\n\n                            expect(err).to.exist();\n                            expect(err.message).to.equal('Authentication required to subscribe');\n                            expect(client.subscriptions()).to.equal([]);\n\n                            client.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('does not require auth to subscribe without a default', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom');\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/');\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect((err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('heya');\n                            expect(client.subscriptions()).to.equal(['/']);\n\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('does not require auth to subscribe with optional auth', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', 'optional');\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/');\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect((err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('heya');\n                            expect(client.subscriptions()).to.equal(['/']);\n\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('matches entity (user)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password, index: true } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { entity: 'user' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('heya');\n                            expect(client.subscriptions()).to.equal(['/']);\n\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('matches entity (app)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password, index: true } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { entity: 'app' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom app' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('heya');\n                            expect(client.subscriptions()).to.equal(['/']);\n\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on wrong entity (user)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { entity: 'app' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n\n                        client.subscribe('/', Hoek.ignore, (err) => {\n\n                            expect(err).to.exist();\n                            expect(err.message).to.equal('User credentials cannot be used on an application subscription');\n                            expect(client.subscriptions()).to.equal([]);\n\n                            client.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on wrong entity (app)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { entity: 'user' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom app' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n\n                        client.subscribe('/', Hoek.ignore, (err) => {\n\n                            expect(err).to.exist();\n                            expect(err.message).to.equal('Application credentials cannot be used on a user subscription');\n                            expect(client.subscriptions()).to.equal([]);\n\n                            client.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('matches scope (string/string)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { scope: 'a' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('heya');\n                            expect(client.subscriptions()).to.equal(['/']);\n\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('matches scope (array/string)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { scope: ['x', 'a'] } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('heya');\n                            expect(client.subscriptions()).to.equal(['/']);\n\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('matches scope (string/array)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { scope: 'a' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom ed' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('heya');\n                            expect(client.subscriptions()).to.equal(['/']);\n\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('matches scope (array/array)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { scope: ['b', 'a'] } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom ed' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('heya');\n                            expect(client.subscriptions()).to.equal(['/']);\n\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('matches scope (dynamic)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/{id}', { auth: { scope: ['b', '{id}'] } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom ed' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        const handler = (update) => {\n\n                            expect(update).to.equal('heya');\n                            expect(client.subscriptions()).to.equal(['/5']);\n\n                            client.disconnect();\n                            server.stop(done);\n                        };\n\n                        client.subscribe('/5', handler, (err) => {\n\n                            expect(err).to.not.exist();\n                            server.publish('/5', 'heya');\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on wrong scope (string/string)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { scope: 'b' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom john' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        client.subscribe('/', Hoek.ignore, (err) => {\n\n                            expect(err).to.exist();\n                            expect(err.message).to.equal('Insufficient scope to subscribe, expected any of: b');\n                            expect(client.subscriptions()).to.equal([]);\n\n                            client.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on wrong scope (string/array)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { scope: 'x' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom ed' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        client.subscribe('/', Hoek.ignore, (err) => {\n\n                            expect(err).to.exist();\n                            expect(err.message).to.equal('Insufficient scope to subscribe, expected any of: x');\n                            expect(client.subscriptions()).to.equal([]);\n\n                            client.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n\n        it('errors on wrong scope (string/none)', (done) => {\n\n            const server = new Hapi.Server();\n            server.connection();\n\n            server.auth.scheme('custom', internals.implementation);\n            server.auth.strategy('default', 'custom', true);\n\n            server.register({ register: Nes, options: { auth: { type: 'direct', password } } }, (err) => {\n\n                expect(err).to.not.exist();\n\n                server.subscription('/', { auth: { scope: 'x' } });\n\n                server.start((err) => {\n\n                    expect(err).to.not.exist();\n                    const client = new Nes.Client('http://localhost:' + server.info.port);\n                    client.connect({ auth: { headers: { authorization: 'Custom app' } } }, (err) => {\n\n                        expect(err).to.not.exist();\n                        client.subscribe('/', Hoek.ignore, (err) => {\n\n                            expect(err).to.exist();\n                            expect(err.message).to.equal('Insufficient scope to subscribe, expected any of: x');\n                            expect(client.subscriptions()).to.equal([]);\n\n                            client.disconnect();\n                            server.stop(done);\n                        });\n                    });\n                });\n            });\n        });\n    });\n});\n\n\ninternals.implementation = function (server, options) {\n\n    const users = {\n        john: {\n            user: 'john',\n            scope: 'a'\n        },\n        ed: {\n            user: 'ed',\n            scope: ['a', 'b', 5]\n        },\n        app: {\n            app: 'app'\n        }\n    };\n\n    const scheme = {\n        authenticate: function (request, reply) {\n\n            const authorization = request.headers.authorization;\n            if (!authorization) {\n                return reply(Boom.unauthorized(null, 'Custom'));\n            }\n\n            const parts = authorization.split(/\\s+/);\n            const user = users[parts[1]];\n            if (!user) {\n                return reply(Boom.unauthorized('Unknown user', 'Custom'));\n            }\n\n            return reply.continue({ credentials: user });\n        }\n    };\n\n    return scheme;\n};\n"], "filenames": ["lib/socket.js", "package.json", "test/auth.js"], "buggy_code_start_loc": [540, 4, 389], "buggy_code_end_loc": [541, 35, 389], "fixing_code_start_loc": [540, 4, 390], "fixing_code_end_loc": [546, 35, 425], "type": "CWE-287", "message": "Nes is a websocket extension library for hapi. Hapi is a webserver framework. Versions below and including 6.4.0 have a denial of service vulnerability via an invalid Cookie header. This is only present when websocket authentication is set to `cookie`. Submitting an invalid cookie on the websocket upgrade request will cause the node process to error out.", "other": {"cve": {"id": "CVE-2017-16025", "sourceIdentifier": "support@hackerone.com", "published": "2018-06-04T19:29:01.490", "lastModified": "2019-10-09T23:24:37.657", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Nes is a websocket extension library for hapi. Hapi is a webserver framework. Versions below and including 6.4.0 have a denial of service vulnerability via an invalid Cookie header. This is only present when websocket authentication is set to `cookie`. Submitting an invalid cookie on the websocket upgrade request will cause the node process to error out."}, {"lang": "es", "value": "Nes es una biblioteca de extensiones websocket para hapi. Hapi es un framework de servidores web. Las versiones anteriores a, e incluyendo, la 6.4.0, tienen una vulnerabilidad de denegaci\u00f3n de servicio (DoS) mediante una cabecera Cookie inv\u00e1lida. Esto solo est\u00e1 presente cuando la autenticaci\u00f3n websocket est\u00e1 establecida en \"cookie\". El env\u00edo de una cookie inv\u00e1lida en la petici\u00f3n de actualizaci\u00f3n de websocket provocar\u00e1 que el proceso node genere un error."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:hapijs:nes:*:*:*:*:*:node.js:*:*", "versionEndIncluding": "6.4.0", "matchCriteriaId": "160C670F-52B7-46F7-BA0A-B24372E55CBA"}]}]}], "references": [{"url": "https://github.com/hapijs/nes/commit/249ba1755ed6977fbc208463c87364bf884ad655", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/hapijs/nes/issues/171", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://nodesecurity.io/advisories/331", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hapijs/nes/commit/249ba1755ed6977fbc208463c87364bf884ad655"}}