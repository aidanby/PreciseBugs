{"buggy_code": ["/* SCTP kernel implementation\n * (C) Copyright IBM Corp. 2001, 2004\n * Copyright (c) 1999 Cisco, Inc.\n * Copyright (c) 1999-2001 Motorola, Inc.\n *\n * This file is part of the SCTP kernel implementation\n *\n * These functions work with the state functions in sctp_sm_statefuns.c\n * to implement that state operations.  These functions implement the\n * steps which require modifying existing data structures.\n *\n * This SCTP implementation is free software;\n * you can redistribute it and/or modify it under the terms of\n * the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This SCTP implementation is distributed in the hope that it\n * will be useful, but WITHOUT ANY WARRANTY; without even the implied\n *                 ************************\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GNU CC; see the file COPYING.  If not, see\n * <http://www.gnu.org/licenses/>.\n *\n * Please send any bug reports or fixes you make to the\n * email address(es):\n *    lksctp developers <linux-sctp@vger.kernel.org>\n *\n * Written or modified by:\n *    La Monte H.P. Yarroll <piggy@acm.org>\n *    Karl Knutson          <karl@athena.chicago.il.us>\n *    Jon Grimm             <jgrimm@austin.ibm.com>\n *    Hui Huang\t\t    <hui.huang@nokia.com>\n *    Dajiang Zhang\t    <dajiang.zhang@nokia.com>\n *    Daisy Chang\t    <daisyc@us.ibm.com>\n *    Sridhar Samudrala\t    <sri@us.ibm.com>\n *    Ardelle Fan\t    <ardelle.fan@intel.com>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/skbuff.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <net/sock.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n\nstatic int sctp_cmd_interpreter(sctp_event_t event_type,\n\t\t\t\tsctp_subtype_t subtype,\n\t\t\t\tsctp_state_t state,\n\t\t\t\tstruct sctp_endpoint *ep,\n\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\tvoid *event_arg,\n\t\t\t\tsctp_disposition_t status,\n\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\tgfp_t gfp);\nstatic int sctp_side_effects(sctp_event_t event_type, sctp_subtype_t subtype,\n\t\t\t     sctp_state_t state,\n\t\t\t     struct sctp_endpoint *ep,\n\t\t\t     struct sctp_association *asoc,\n\t\t\t     void *event_arg,\n\t\t\t     sctp_disposition_t status,\n\t\t\t     sctp_cmd_seq_t *commands,\n\t\t\t     gfp_t gfp);\n\nstatic void sctp_cmd_hb_timer_update(sctp_cmd_seq_t *cmds,\n\t\t\t\t     struct sctp_transport *t);\n/********************************************************************\n * Helper functions\n ********************************************************************/\n\n/* A helper function for delayed processing of INET ECN CE bit. */\nstatic void sctp_do_ecn_ce_work(struct sctp_association *asoc,\n\t\t\t\t__u32 lowest_tsn)\n{\n\t/* Save the TSN away for comparison when we receive CWR */\n\n\tasoc->last_ecne_tsn = lowest_tsn;\n\tasoc->need_ecne = 1;\n}\n\n/* Helper function for delayed processing of SCTP ECNE chunk.  */\n/* RFC 2960 Appendix A\n *\n * RFC 2481 details a specific bit for a sender to send in\n * the header of its next outbound TCP segment to indicate to\n * its peer that it has reduced its congestion window.  This\n * is termed the CWR bit.  For SCTP the same indication is made\n * by including the CWR chunk.  This chunk contains one data\n * element, i.e. the TSN number that was sent in the ECNE chunk.\n * This element represents the lowest TSN number in the datagram\n * that was originally marked with the CE bit.\n */\nstatic struct sctp_chunk *sctp_do_ecn_ecne_work(struct sctp_association *asoc,\n\t\t\t\t\t   __u32 lowest_tsn,\n\t\t\t\t\t   struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *repl;\n\n\t/* Our previously transmitted packet ran into some congestion\n\t * so we should take action by reducing cwnd and ssthresh\n\t * and then ACK our peer that we we've done so by\n\t * sending a CWR.\n\t */\n\n\t/* First, try to determine if we want to actually lower\n\t * our cwnd variables.  Only lower them if the ECNE looks more\n\t * recent than the last response.\n\t */\n\tif (TSN_lt(asoc->last_cwr_tsn, lowest_tsn)) {\n\t\tstruct sctp_transport *transport;\n\n\t\t/* Find which transport's congestion variables\n\t\t * need to be adjusted.\n\t\t */\n\t\ttransport = sctp_assoc_lookup_tsn(asoc, lowest_tsn);\n\n\t\t/* Update the congestion variables. */\n\t\tif (transport)\n\t\t\tsctp_transport_lower_cwnd(transport,\n\t\t\t\t\t\t  SCTP_LOWER_CWND_ECNE);\n\t\tasoc->last_cwr_tsn = lowest_tsn;\n\t}\n\n\t/* Always try to quiet the other end.  In case of lost CWR,\n\t * resend last_cwr_tsn.\n\t */\n\trepl = sctp_make_cwr(asoc, asoc->last_cwr_tsn, chunk);\n\n\t/* If we run out of memory, it will look like a lost CWR.  We'll\n\t * get back in sync eventually.\n\t */\n\treturn repl;\n}\n\n/* Helper function to do delayed processing of ECN CWR chunk.  */\nstatic void sctp_do_ecn_cwr_work(struct sctp_association *asoc,\n\t\t\t\t __u32 lowest_tsn)\n{\n\t/* Turn off ECNE getting auto-prepended to every outgoing\n\t * packet\n\t */\n\tasoc->need_ecne = 0;\n}\n\n/* Generate SACK if necessary.  We call this at the end of a packet.  */\nstatic int sctp_gen_sack(struct sctp_association *asoc, int force,\n\t\t\t sctp_cmd_seq_t *commands)\n{\n\t__u32 ctsn, max_tsn_seen;\n\tstruct sctp_chunk *sack;\n\tstruct sctp_transport *trans = asoc->peer.last_data_from;\n\tint error = 0;\n\n\tif (force ||\n\t    (!trans && (asoc->param_flags & SPP_SACKDELAY_DISABLE)) ||\n\t    (trans && (trans->param_flags & SPP_SACKDELAY_DISABLE)))\n\t\tasoc->peer.sack_needed = 1;\n\n\tctsn = sctp_tsnmap_get_ctsn(&asoc->peer.tsn_map);\n\tmax_tsn_seen = sctp_tsnmap_get_max_tsn_seen(&asoc->peer.tsn_map);\n\n\t/* From 12.2 Parameters necessary per association (i.e. the TCB):\n\t *\n\t * Ack State : This flag indicates if the next received packet\n\t * \t     : is to be responded to with a SACK. ...\n\t *\t     : When DATA chunks are out of order, SACK's\n\t *           : are not delayed (see Section 6).\n\t *\n\t * [This is actually not mentioned in Section 6, but we\n\t * implement it here anyway. --piggy]\n\t */\n\tif (max_tsn_seen != ctsn)\n\t\tasoc->peer.sack_needed = 1;\n\n\t/* From 6.2  Acknowledgement on Reception of DATA Chunks:\n\t *\n\t * Section 4.2 of [RFC2581] SHOULD be followed. Specifically,\n\t * an acknowledgement SHOULD be generated for at least every\n\t * second packet (not every second DATA chunk) received, and\n\t * SHOULD be generated within 200 ms of the arrival of any\n\t * unacknowledged DATA chunk. ...\n\t */\n\tif (!asoc->peer.sack_needed) {\n\t\tasoc->peer.sack_cnt++;\n\n\t\t/* Set the SACK delay timeout based on the\n\t\t * SACK delay for the last transport\n\t\t * data was received from, or the default\n\t\t * for the association.\n\t\t */\n\t\tif (trans) {\n\t\t\t/* We will need a SACK for the next packet.  */\n\t\t\tif (asoc->peer.sack_cnt >= trans->sackfreq - 1)\n\t\t\t\tasoc->peer.sack_needed = 1;\n\n\t\t\tasoc->timeouts[SCTP_EVENT_TIMEOUT_SACK] =\n\t\t\t\ttrans->sackdelay;\n\t\t} else {\n\t\t\t/* We will need a SACK for the next packet.  */\n\t\t\tif (asoc->peer.sack_cnt >= asoc->sackfreq - 1)\n\t\t\t\tasoc->peer.sack_needed = 1;\n\n\t\t\tasoc->timeouts[SCTP_EVENT_TIMEOUT_SACK] =\n\t\t\t\tasoc->sackdelay;\n\t\t}\n\n\t\t/* Restart the SACK timer. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_SACK));\n\t} else {\n\t\tasoc->a_rwnd = asoc->rwnd;\n\t\tsack = sctp_make_sack(asoc);\n\t\tif (!sack)\n\t\t\tgoto nomem;\n\n\t\tasoc->peer.sack_needed = 0;\n\t\tasoc->peer.sack_cnt = 0;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(sack));\n\n\t\t/* Stop the SACK timer.  */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_SACK));\n\t}\n\n\treturn error;\nnomem:\n\terror = -ENOMEM;\n\treturn error;\n}\n\n/* When the T3-RTX timer expires, it calls this function to create the\n * relevant state machine event.\n */\nvoid sctp_generate_t3_rtx_event(unsigned long peer)\n{\n\tint error;\n\tstruct sctp_transport *transport = (struct sctp_transport *) peer;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\n\t/* Check whether a task is in the sock.  */\n\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\t/* Try again later.  */\n\t\tif (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Is this transport really dead and just waiting around for\n\t * the timer to let go of the reference?\n\t */\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\n\t/* Run through the state machine.  */\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),\n\t\t\t   asoc->state,\n\t\t\t   asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}\n\n/* This is a sa interface for producing timeout events.  It works\n * for timeouts which use the association as their parameter.\n */\nstatic void sctp_generate_timeout_event(struct sctp_association *asoc,\n\t\t\t\t\tsctp_event_timeout_t timeout_type)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tint error = 0;\n\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy: timer %d\\n\", __func__,\n\t\t\t timeout_type);\n\n\t\t/* Try again later.  */\n\t\tif (!mod_timer(&asoc->timers[timeout_type], jiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Is this association really dead and just waiting around for\n\t * the timer to let go of the reference?\n\t */\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\n\t/* Run through the state machine.  */\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(timeout_type),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   (void *)timeout_type, GFP_ATOMIC);\n\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_association_put(asoc);\n}\n\nstatic void sctp_generate_t1_cookie_event(unsigned long data)\n{\n\tstruct sctp_association *asoc = (struct sctp_association *) data;\n\tsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_T1_COOKIE);\n}\n\nstatic void sctp_generate_t1_init_event(unsigned long data)\n{\n\tstruct sctp_association *asoc = (struct sctp_association *) data;\n\tsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_T1_INIT);\n}\n\nstatic void sctp_generate_t2_shutdown_event(unsigned long data)\n{\n\tstruct sctp_association *asoc = (struct sctp_association *) data;\n\tsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_T2_SHUTDOWN);\n}\n\nstatic void sctp_generate_t4_rto_event(unsigned long data)\n{\n\tstruct sctp_association *asoc = (struct sctp_association *) data;\n\tsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_T4_RTO);\n}\n\nstatic void sctp_generate_t5_shutdown_guard_event(unsigned long data)\n{\n\tstruct sctp_association *asoc = (struct sctp_association *)data;\n\tsctp_generate_timeout_event(asoc,\n\t\t\t\t    SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD);\n\n} /* sctp_generate_t5_shutdown_guard_event() */\n\nstatic void sctp_generate_autoclose_event(unsigned long data)\n{\n\tstruct sctp_association *asoc = (struct sctp_association *) data;\n\tsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_AUTOCLOSE);\n}\n\n/* Generate a heart beat event.  If the sock is busy, reschedule.   Make\n * sure that the transport is still valid.\n */\nvoid sctp_generate_heartbeat_event(unsigned long data)\n{\n\tint error = 0;\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\t/* Try again later.  */\n\t\tif (!mod_timer(&transport->hb_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Is this structure just waiting around for us to actually\n\t * get destroyed?\n\t */\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_HEARTBEAT),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}\n\n/* Handle the timeout of the ICMP protocol unreachable timer.  Trigger\n * the correct state machine transition that will close the association.\n */\nvoid sctp_generate_proto_unreach_event(unsigned long data)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\t/* Try again later.  */\n\t\tif (!mod_timer(&transport->proto_unreach_timer,\n\t\t\t\tjiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Is this structure just waiting around for us to actually\n\t * get destroyed?\n\t */\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\n\tsctp_do_sm(net, SCTP_EVENT_T_OTHER,\n\t\t   SCTP_ST_OTHER(SCTP_EVENT_ICMP_PROTO_UNREACH),\n\t\t   asoc->state, asoc->ep, asoc, transport, GFP_ATOMIC);\n\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_association_put(asoc);\n}\n\n\n/* Inject a SACK Timeout event into the state machine.  */\nstatic void sctp_generate_sack_event(unsigned long data)\n{\n\tstruct sctp_association *asoc = (struct sctp_association *) data;\n\tsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_SACK);\n}\n\nsctp_timer_event_t *sctp_timer_events[SCTP_NUM_TIMEOUT_TYPES] = {\n\tNULL,\n\tsctp_generate_t1_cookie_event,\n\tsctp_generate_t1_init_event,\n\tsctp_generate_t2_shutdown_event,\n\tNULL,\n\tsctp_generate_t4_rto_event,\n\tsctp_generate_t5_shutdown_guard_event,\n\tNULL,\n\tsctp_generate_sack_event,\n\tsctp_generate_autoclose_event,\n};\n\n\n/* RFC 2960 8.2 Path Failure Detection\n *\n * When its peer endpoint is multi-homed, an endpoint should keep a\n * error counter for each of the destination transport addresses of the\n * peer endpoint.\n *\n * Each time the T3-rtx timer expires on any address, or when a\n * HEARTBEAT sent to an idle address is not acknowledged within a RTO,\n * the error counter of that destination address will be incremented.\n * When the value in the error counter exceeds the protocol parameter\n * 'Path.Max.Retrans' of that destination address, the endpoint should\n * mark the destination transport address as inactive, and a\n * notification SHOULD be sent to the upper layer.\n *\n */\nstatic void sctp_do_8_2_transport_strike(sctp_cmd_seq_t *commands,\n\t\t\t\t\t struct sctp_association *asoc,\n\t\t\t\t\t struct sctp_transport *transport,\n\t\t\t\t\t int is_hb)\n{\n\t/* The check for association's overall error counter exceeding the\n\t * threshold is done in the state function.\n\t */\n\t/* We are here due to a timer expiration.  If the timer was\n\t * not a HEARTBEAT, then normal error tracking is done.\n\t * If the timer was a heartbeat, we only increment error counts\n\t * when we already have an outstanding HEARTBEAT that has not\n\t * been acknowledged.\n\t * Additionally, some tranport states inhibit error increments.\n\t */\n\tif (!is_hb) {\n\t\tasoc->overall_error_count++;\n\t\tif (transport->state != SCTP_INACTIVE)\n\t\t\ttransport->error_count++;\n\t } else if (transport->hb_sent) {\n\t\tif (transport->state != SCTP_UNCONFIRMED)\n\t\t\tasoc->overall_error_count++;\n\t\tif (transport->state != SCTP_INACTIVE)\n\t\t\ttransport->error_count++;\n\t}\n\n\t/* If the transport error count is greater than the pf_retrans\n\t * threshold, and less than pathmaxrtx, and if the current state\n\t * is SCTP_ACTIVE, then mark this transport as Partially Failed,\n\t * see SCTP Quick Failover Draft, section 5.1\n\t */\n\tif ((transport->state == SCTP_ACTIVE) &&\n\t   (asoc->pf_retrans < transport->pathmaxrxt) &&\n\t   (transport->error_count > asoc->pf_retrans)) {\n\n\t\tsctp_assoc_control_transport(asoc, transport,\n\t\t\t\t\t     SCTP_TRANSPORT_PF,\n\t\t\t\t\t     0);\n\n\t\t/* Update the hb timer to resend a heartbeat every rto */\n\t\tsctp_cmd_hb_timer_update(commands, transport);\n\t}\n\n\tif (transport->state != SCTP_INACTIVE &&\n\t    (transport->error_count > transport->pathmaxrxt)) {\n\t\tpr_debug(\"%s: association:%p transport addr:%pISpc failed\\n\",\n\t\t\t __func__, asoc, &transport->ipaddr.sa);\n\n\t\tsctp_assoc_control_transport(asoc, transport,\n\t\t\t\t\t     SCTP_TRANSPORT_DOWN,\n\t\t\t\t\t     SCTP_FAILED_THRESHOLD);\n\t}\n\n\t/* E2) For the destination address for which the timer\n\t * expires, set RTO <- RTO * 2 (\"back off the timer\").  The\n\t * maximum value discussed in rule C7 above (RTO.max) may be\n\t * used to provide an upper bound to this doubling operation.\n\t *\n\t * Special Case:  the first HB doesn't trigger exponential backoff.\n\t * The first unacknowledged HB triggers it.  We do this with a flag\n\t * that indicates that we have an outstanding HB.\n\t */\n\tif (!is_hb || transport->hb_sent) {\n\t\ttransport->rto = min((transport->rto * 2), transport->asoc->rto_max);\n\t\tsctp_max_rto(asoc, transport);\n\t}\n}\n\n/* Worker routine to handle INIT command failure.  */\nstatic void sctp_cmd_init_failed(sctp_cmd_seq_t *commands,\n\t\t\t\t struct sctp_association *asoc,\n\t\t\t\t unsigned int error)\n{\n\tstruct sctp_ulpevent *event;\n\n\tevent = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_CANT_STR_ASSOC,\n\t\t\t\t\t\t(__u16)error, 0, 0, NULL,\n\t\t\t\t\t\tGFP_ATOMIC);\n\n\tif (event)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(event));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\t/* SEND_FAILED sent later when cleaning up the association. */\n\tasoc->outqueue.error = error;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n}\n\n/* Worker routine to handle SCTP_CMD_ASSOC_FAILED.  */\nstatic void sctp_cmd_assoc_failed(sctp_cmd_seq_t *commands,\n\t\t\t\t  struct sctp_association *asoc,\n\t\t\t\t  sctp_event_t event_type,\n\t\t\t\t  sctp_subtype_t subtype,\n\t\t\t\t  struct sctp_chunk *chunk,\n\t\t\t\t  unsigned int error)\n{\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_chunk *abort;\n\t/* Cancel any partial delivery in progress. */\n\tsctp_ulpq_abort_pd(&asoc->ulpq, GFP_ATOMIC);\n\n\tif (event_type == SCTP_EVENT_T_CHUNK && subtype.chunk == SCTP_CID_ABORT)\n\t\tevent = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_COMM_LOST,\n\t\t\t\t\t\t(__u16)error, 0, 0, chunk,\n\t\t\t\t\t\tGFP_ATOMIC);\n\telse\n\t\tevent = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_COMM_LOST,\n\t\t\t\t\t\t(__u16)error, 0, 0, NULL,\n\t\t\t\t\t\tGFP_ATOMIC);\n\tif (event)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(event));\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tabort = sctp_make_violation_max_retrans(asoc, chunk);\n\t\tif (abort)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\t/* SEND_FAILED sent later when cleaning up the association. */\n\tasoc->outqueue.error = error;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n}\n\n/* Process an init chunk (may be real INIT/INIT-ACK or an embedded INIT\n * inside the cookie.  In reality, this is only used for INIT-ACK processing\n * since all other cases use \"temporary\" associations and can do all\n * their work in statefuns directly.\n */\nstatic int sctp_cmd_process_init(sctp_cmd_seq_t *commands,\n\t\t\t\t struct sctp_association *asoc,\n\t\t\t\t struct sctp_chunk *chunk,\n\t\t\t\t sctp_init_chunk_t *peer_init,\n\t\t\t\t gfp_t gfp)\n{\n\tint error;\n\n\t/* We only process the init as a sideeffect in a single\n\t * case.   This is when we process the INIT-ACK.   If we\n\t * fail during INIT processing (due to malloc problems),\n\t * just return the error and stop processing the stack.\n\t */\n\tif (!sctp_process_init(asoc, chunk, sctp_source(chunk), peer_init, gfp))\n\t\terror = -ENOMEM;\n\telse\n\t\terror = 0;\n\n\treturn error;\n}\n\n/* Helper function to break out starting up of heartbeat timers.  */\nstatic void sctp_cmd_hb_timers_start(sctp_cmd_seq_t *cmds,\n\t\t\t\t     struct sctp_association *asoc)\n{\n\tstruct sctp_transport *t;\n\n\t/* Start a heartbeat timer for each transport on the association.\n\t * hold a reference on the transport to make sure none of\n\t * the needed data structures go away.\n\t */\n\tlist_for_each_entry(t, &asoc->peer.transport_addr_list, transports) {\n\n\t\tif (!mod_timer(&t->hb_timer, sctp_transport_timeout(t)))\n\t\t\tsctp_transport_hold(t);\n\t}\n}\n\nstatic void sctp_cmd_hb_timers_stop(sctp_cmd_seq_t *cmds,\n\t\t\t\t    struct sctp_association *asoc)\n{\n\tstruct sctp_transport *t;\n\n\t/* Stop all heartbeat timers. */\n\n\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\ttransports) {\n\t\tif (del_timer(&t->hb_timer))\n\t\t\tsctp_transport_put(t);\n\t}\n}\n\n/* Helper function to stop any pending T3-RTX timers */\nstatic void sctp_cmd_t3_rtx_timers_stop(sctp_cmd_seq_t *cmds,\n\t\t\t\t\tstruct sctp_association *asoc)\n{\n\tstruct sctp_transport *t;\n\n\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\ttransports) {\n\t\tif (del_timer(&t->T3_rtx_timer))\n\t\t\tsctp_transport_put(t);\n\t}\n}\n\n\n/* Helper function to update the heartbeat timer. */\nstatic void sctp_cmd_hb_timer_update(sctp_cmd_seq_t *cmds,\n\t\t\t\t     struct sctp_transport *t)\n{\n\t/* Update the heartbeat timer.  */\n\tif (!mod_timer(&t->hb_timer, sctp_transport_timeout(t)))\n\t\tsctp_transport_hold(t);\n}\n\n/* Helper function to handle the reception of an HEARTBEAT ACK.  */\nstatic void sctp_cmd_transport_on(sctp_cmd_seq_t *cmds,\n\t\t\t\t  struct sctp_association *asoc,\n\t\t\t\t  struct sctp_transport *t,\n\t\t\t\t  struct sctp_chunk *chunk)\n{\n\tsctp_sender_hb_info_t *hbinfo;\n\tint was_unconfirmed = 0;\n\n\t/* 8.3 Upon the receipt of the HEARTBEAT ACK, the sender of the\n\t * HEARTBEAT should clear the error counter of the destination\n\t * transport address to which the HEARTBEAT was sent.\n\t */\n\tt->error_count = 0;\n\n\t/*\n\t * Although RFC4960 specifies that the overall error count must\n\t * be cleared when a HEARTBEAT ACK is received, we make an\n\t * exception while in SHUTDOWN PENDING. If the peer keeps its\n\t * window shut forever, we may never be able to transmit our\n\t * outstanding data and rely on the retransmission limit be reached\n\t * to shutdown the association.\n\t */\n\tif (t->asoc->state < SCTP_STATE_SHUTDOWN_PENDING)\n\t\tt->asoc->overall_error_count = 0;\n\n\t/* Clear the hb_sent flag to signal that we had a good\n\t * acknowledgement.\n\t */\n\tt->hb_sent = 0;\n\n\t/* Mark the destination transport address as active if it is not so\n\t * marked.\n\t */\n\tif ((t->state == SCTP_INACTIVE) || (t->state == SCTP_UNCONFIRMED)) {\n\t\twas_unconfirmed = 1;\n\t\tsctp_assoc_control_transport(asoc, t, SCTP_TRANSPORT_UP,\n\t\t\t\t\t     SCTP_HEARTBEAT_SUCCESS);\n\t}\n\n\tif (t->state == SCTP_PF)\n\t\tsctp_assoc_control_transport(asoc, t, SCTP_TRANSPORT_UP,\n\t\t\t\t\t     SCTP_HEARTBEAT_SUCCESS);\n\n\t/* HB-ACK was received for a the proper HB.  Consider this\n\t * forward progress.\n\t */\n\tif (t->dst)\n\t\tdst_confirm(t->dst);\n\n\t/* The receiver of the HEARTBEAT ACK should also perform an\n\t * RTT measurement for that destination transport address\n\t * using the time value carried in the HEARTBEAT ACK chunk.\n\t * If the transport's rto_pending variable has been cleared,\n\t * it was most likely due to a retransmit.  However, we want\n\t * to re-enable it to properly update the rto.\n\t */\n\tif (t->rto_pending == 0)\n\t\tt->rto_pending = 1;\n\n\thbinfo = (sctp_sender_hb_info_t *) chunk->skb->data;\n\tsctp_transport_update_rto(t, (jiffies - hbinfo->sent_at));\n\n\t/* Update the heartbeat timer.  */\n\tif (!mod_timer(&t->hb_timer, sctp_transport_timeout(t)))\n\t\tsctp_transport_hold(t);\n\n\tif (was_unconfirmed && asoc->peer.transport_count == 1)\n\t\tsctp_transport_immediate_rtx(t);\n}\n\n\n/* Helper function to process the process SACK command.  */\nstatic int sctp_cmd_process_sack(sctp_cmd_seq_t *cmds,\n\t\t\t\t struct sctp_association *asoc,\n\t\t\t\t struct sctp_chunk *chunk)\n{\n\tint err = 0;\n\n\tif (sctp_outq_sack(&asoc->outqueue, chunk)) {\n\t\tstruct net *net = sock_net(asoc->base.sk);\n\n\t\t/* There are no more TSNs awaiting SACK.  */\n\t\terr = sctp_do_sm(net, SCTP_EVENT_T_OTHER,\n\t\t\t\t SCTP_ST_OTHER(SCTP_EVENT_NO_PENDING_TSN),\n\t\t\t\t asoc->state, asoc->ep, asoc, NULL,\n\t\t\t\t GFP_ATOMIC);\n\t}\n\n\treturn err;\n}\n\n/* Helper function to set the timeout value for T2-SHUTDOWN timer and to set\n * the transport for a shutdown chunk.\n */\nstatic void sctp_cmd_setup_t2(sctp_cmd_seq_t *cmds,\n\t\t\t      struct sctp_association *asoc,\n\t\t\t      struct sctp_chunk *chunk)\n{\n\tstruct sctp_transport *t;\n\n\tif (chunk->transport)\n\t\tt = chunk->transport;\n\telse {\n\t\tt = sctp_assoc_choose_alter_transport(asoc,\n\t\t\t\t\t      asoc->shutdown_last_sent_to);\n\t\tchunk->transport = t;\n\t}\n\tasoc->shutdown_last_sent_to = t;\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T2_SHUTDOWN] = t->rto;\n}\n\n/* Helper function to change the state of an association. */\nstatic void sctp_cmd_new_state(sctp_cmd_seq_t *cmds,\n\t\t\t       struct sctp_association *asoc,\n\t\t\t       sctp_state_t state)\n{\n\tstruct sock *sk = asoc->base.sk;\n\n\tasoc->state = state;\n\n\tpr_debug(\"%s: asoc:%p[%s]\\n\", __func__, asoc, sctp_state_tbl[state]);\n\n\tif (sctp_style(sk, TCP)) {\n\t\t/* Change the sk->sk_state of a TCP-style socket that has\n\t\t * successfully completed a connect() call.\n\t\t */\n\t\tif (sctp_state(asoc, ESTABLISHED) && sctp_sstate(sk, CLOSED))\n\t\t\tsk->sk_state = SCTP_SS_ESTABLISHED;\n\n\t\t/* Set the RCV_SHUTDOWN flag when a SHUTDOWN is received. */\n\t\tif (sctp_state(asoc, SHUTDOWN_RECEIVED) &&\n\t\t    sctp_sstate(sk, ESTABLISHED))\n\t\t\tsk->sk_shutdown |= RCV_SHUTDOWN;\n\t}\n\n\tif (sctp_state(asoc, COOKIE_WAIT)) {\n\t\t/* Reset init timeouts since they may have been\n\t\t * increased due to timer expirations.\n\t\t */\n\t\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T1_INIT] =\n\t\t\t\t\t\tasoc->rto_initial;\n\t\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T1_COOKIE] =\n\t\t\t\t\t\tasoc->rto_initial;\n\t}\n\n\tif (sctp_state(asoc, ESTABLISHED) ||\n\t    sctp_state(asoc, CLOSED) ||\n\t    sctp_state(asoc, SHUTDOWN_RECEIVED)) {\n\t\t/* Wake up any processes waiting in the asoc's wait queue in\n\t\t * sctp_wait_for_connect() or sctp_wait_for_sndbuf().\n\t\t */\n\t\tif (waitqueue_active(&asoc->wait))\n\t\t\twake_up_interruptible(&asoc->wait);\n\n\t\t/* Wake up any processes waiting in the sk's sleep queue of\n\t\t * a TCP-style or UDP-style peeled-off socket in\n\t\t * sctp_wait_for_accept() or sctp_wait_for_packet().\n\t\t * For a UDP-style socket, the waiters are woken up by the\n\t\t * notifications.\n\t\t */\n\t\tif (!sctp_style(sk, UDP))\n\t\t\tsk->sk_state_change(sk);\n\t}\n}\n\n/* Helper function to delete an association. */\nstatic void sctp_cmd_delete_tcb(sctp_cmd_seq_t *cmds,\n\t\t\t\tstruct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\n\t/* If it is a non-temporary association belonging to a TCP-style\n\t * listening socket that is not closed, do not free it so that accept()\n\t * can pick it up later.\n\t */\n\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING) &&\n\t    (!asoc->temp) && (sk->sk_shutdown != SHUTDOWN_MASK))\n\t\treturn;\n\n\tsctp_unhash_established(asoc);\n\tsctp_association_free(asoc);\n}\n\n/*\n * ADDIP Section 4.1 ASCONF Chunk Procedures\n * A4) Start a T-4 RTO timer, using the RTO value of the selected\n * destination address (we use active path instead of primary path just\n * because primary path may be inactive.\n */\nstatic void sctp_cmd_setup_t4(sctp_cmd_seq_t *cmds,\n\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\tstruct sctp_chunk *chunk)\n{\n\tstruct sctp_transport *t;\n\n\tt = sctp_assoc_choose_alter_transport(asoc, chunk->transport);\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T4_RTO] = t->rto;\n\tchunk->transport = t;\n}\n\n/* Process an incoming Operation Error Chunk. */\nstatic void sctp_cmd_process_operr(sctp_cmd_seq_t *cmds,\n\t\t\t\t   struct sctp_association *asoc,\n\t\t\t\t   struct sctp_chunk *chunk)\n{\n\tstruct sctp_errhdr *err_hdr;\n\tstruct sctp_ulpevent *ev;\n\n\twhile (chunk->chunk_end > chunk->skb->data) {\n\t\terr_hdr = (struct sctp_errhdr *)(chunk->skb->data);\n\n\t\tev = sctp_ulpevent_make_remote_error(asoc, chunk, 0,\n\t\t\t\t\t\t     GFP_ATOMIC);\n\t\tif (!ev)\n\t\t\treturn;\n\n\t\tsctp_ulpq_tail_event(&asoc->ulpq, ev);\n\n\t\tswitch (err_hdr->cause) {\n\t\tcase SCTP_ERROR_UNKNOWN_CHUNK:\n\t\t{\n\t\t\tsctp_chunkhdr_t *unk_chunk_hdr;\n\n\t\t\tunk_chunk_hdr = (sctp_chunkhdr_t *)err_hdr->variable;\n\t\t\tswitch (unk_chunk_hdr->type) {\n\t\t\t/* ADDIP 4.1 A9) If the peer responds to an ASCONF with\n\t\t\t * an ERROR chunk reporting that it did not recognized\n\t\t\t * the ASCONF chunk type, the sender of the ASCONF MUST\n\t\t\t * NOT send any further ASCONF chunks and MUST stop its\n\t\t\t * T-4 timer.\n\t\t\t */\n\t\t\tcase SCTP_CID_ASCONF:\n\t\t\t\tif (asoc->peer.asconf_capable == 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tasoc->peer.asconf_capable = 0;\n\t\t\t\tsctp_add_cmd_sf(cmds, SCTP_CMD_TIMER_STOP,\n\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Process variable FWDTSN chunk information. */\nstatic void sctp_cmd_process_fwdtsn(struct sctp_ulpq *ulpq,\n\t\t\t\t    struct sctp_chunk *chunk)\n{\n\tstruct sctp_fwdtsn_skip *skip;\n\t/* Walk through all the skipped SSNs */\n\tsctp_walk_fwdtsn(skip, chunk) {\n\t\tsctp_ulpq_skip(ulpq, ntohs(skip->stream), ntohs(skip->ssn));\n\t}\n}\n\n/* Helper function to remove the association non-primary peer\n * transports.\n */\nstatic void sctp_cmd_del_non_primary(struct sctp_association *asoc)\n{\n\tstruct sctp_transport *t;\n\tstruct list_head *pos;\n\tstruct list_head *temp;\n\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\tt = list_entry(pos, struct sctp_transport, transports);\n\t\tif (!sctp_cmp_addr_exact(&t->ipaddr,\n\t\t\t\t\t &asoc->peer.primary_addr)) {\n\t\t\tsctp_assoc_rm_peer(asoc, t);\n\t\t}\n\t}\n}\n\n/* Helper function to set sk_err on a 1-1 style socket. */\nstatic void sctp_cmd_set_sk_err(struct sctp_association *asoc, int error)\n{\n\tstruct sock *sk = asoc->base.sk;\n\n\tif (!sctp_style(sk, UDP))\n\t\tsk->sk_err = error;\n}\n\n/* Helper function to generate an association change event */\nstatic void sctp_cmd_assoc_change(sctp_cmd_seq_t *commands,\n\t\t\t\t struct sctp_association *asoc,\n\t\t\t\t u8 state)\n{\n\tstruct sctp_ulpevent *ev;\n\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, state, 0,\n\t\t\t\t\t    asoc->c.sinit_num_ostreams,\n\t\t\t\t\t    asoc->c.sinit_max_instreams,\n\t\t\t\t\t    NULL, GFP_ATOMIC);\n\tif (ev)\n\t\tsctp_ulpq_tail_event(&asoc->ulpq, ev);\n}\n\n/* Helper function to generate an adaptation indication event */\nstatic void sctp_cmd_adaptation_ind(sctp_cmd_seq_t *commands,\n\t\t\t\t    struct sctp_association *asoc)\n{\n\tstruct sctp_ulpevent *ev;\n\n\tev = sctp_ulpevent_make_adaptation_indication(asoc, GFP_ATOMIC);\n\n\tif (ev)\n\t\tsctp_ulpq_tail_event(&asoc->ulpq, ev);\n}\n\n\nstatic void sctp_cmd_t1_timer_update(struct sctp_association *asoc,\n\t\t\t\t    sctp_event_timeout_t timer,\n\t\t\t\t    char *name)\n{\n\tstruct sctp_transport *t;\n\n\tt = asoc->init_last_sent_to;\n\tasoc->init_err_counter++;\n\n\tif (t->init_sent_count > (asoc->init_cycle + 1)) {\n\t\tasoc->timeouts[timer] *= 2;\n\t\tif (asoc->timeouts[timer] > asoc->max_init_timeo) {\n\t\t\tasoc->timeouts[timer] = asoc->max_init_timeo;\n\t\t}\n\t\tasoc->init_cycle++;\n\n\t\tpr_debug(\"%s: T1[%s] timeout adjustment init_err_counter:%d\"\n\t\t\t \" cycle:%d timeout:%ld\\n\", __func__, name,\n\t\t\t asoc->init_err_counter, asoc->init_cycle,\n\t\t\t asoc->timeouts[timer]);\n\t}\n\n}\n\n/* Send the whole message, chunk by chunk, to the outqueue.\n * This way the whole message is queued up and bundling if\n * encouraged for small fragments.\n */\nstatic int sctp_cmd_send_msg(struct sctp_association *asoc,\n\t\t\t\tstruct sctp_datamsg *msg)\n{\n\tstruct sctp_chunk *chunk;\n\tint error = 0;\n\n\tlist_for_each_entry(chunk, &msg->chunks, frag_list) {\n\t\terror = sctp_outq_tail(&asoc->outqueue, chunk);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}\n\n\n/* Sent the next ASCONF packet currently stored in the association.\n * This happens after the ASCONF_ACK was succeffully processed.\n */\nstatic void sctp_cmd_send_asconf(struct sctp_association *asoc)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\n\t/* Send the next asconf chunk from the addip chunk\n\t * queue.\n\t */\n\tif (!list_empty(&asoc->addip_chunk_list)) {\n\t\tstruct list_head *entry = asoc->addip_chunk_list.next;\n\t\tstruct sctp_chunk *asconf = list_entry(entry,\n\t\t\t\t\t\tstruct sctp_chunk, list);\n\t\tlist_del_init(entry);\n\n\t\t/* Hold the chunk until an ASCONF_ACK is received. */\n\t\tsctp_chunk_hold(asconf);\n\t\tif (sctp_primitive_ASCONF(net, asoc, asconf))\n\t\t\tsctp_chunk_free(asconf);\n\t\telse\n\t\t\tasoc->addip_last_asconf = asconf;\n\t}\n}\n\n\n/* These three macros allow us to pull the debugging code out of the\n * main flow of sctp_do_sm() to keep attention focused on the real\n * functionality there.\n */\n#define debug_pre_sfn() \\\n\tpr_debug(\"%s[pre-fn]: ep:%p, %s, %s, asoc:%p[%s], %s\\n\", __func__, \\\n\t\t ep, sctp_evttype_tbl[event_type], (*debug_fn)(subtype),   \\\n\t\t asoc, sctp_state_tbl[state], state_fn->name)\n\n#define debug_post_sfn() \\\n\tpr_debug(\"%s[post-fn]: asoc:%p, status:%s\\n\", __func__, asoc, \\\n\t\t sctp_status_tbl[status])\n\n#define debug_post_sfx() \\\n\tpr_debug(\"%s[post-sfx]: error:%d, asoc:%p[%s]\\n\", __func__, error, \\\n\t\t asoc, sctp_state_tbl[(asoc && sctp_id2assoc(ep->base.sk, \\\n\t\t sctp_assoc2id(asoc))) ? asoc->state : SCTP_STATE_CLOSED])\n\n/*\n * This is the master state machine processing function.\n *\n * If you want to understand all of lksctp, this is a\n * good place to start.\n */\nint sctp_do_sm(struct net *net, sctp_event_t event_type, sctp_subtype_t subtype,\n\t       sctp_state_t state,\n\t       struct sctp_endpoint *ep,\n\t       struct sctp_association *asoc,\n\t       void *event_arg,\n\t       gfp_t gfp)\n{\n\tsctp_cmd_seq_t commands;\n\tconst sctp_sm_table_entry_t *state_fn;\n\tsctp_disposition_t status;\n\tint error = 0;\n\ttypedef const char *(printfn_t)(sctp_subtype_t);\n\tstatic printfn_t *table[] = {\n\t\tNULL, sctp_cname, sctp_tname, sctp_oname, sctp_pname,\n\t};\n\tprintfn_t *debug_fn  __attribute__ ((unused)) = table[event_type];\n\n\t/* Look up the state function, run it, and then process the\n\t * side effects.  These three steps are the heart of lksctp.\n\t */\n\tstate_fn = sctp_sm_lookup_event(net, event_type, state, subtype);\n\n\tsctp_init_cmd_seq(&commands);\n\n\tdebug_pre_sfn();\n\tstatus = state_fn->fn(net, ep, asoc, subtype, event_arg, &commands);\n\tdebug_post_sfn();\n\n\terror = sctp_side_effects(event_type, subtype, state,\n\t\t\t\t  ep, asoc, event_arg, status,\n\t\t\t\t  &commands, gfp);\n\tdebug_post_sfx();\n\n\treturn error;\n}\n\n/*****************************************************************\n * This the master state function side effect processing function.\n *****************************************************************/\nstatic int sctp_side_effects(sctp_event_t event_type, sctp_subtype_t subtype,\n\t\t\t     sctp_state_t state,\n\t\t\t     struct sctp_endpoint *ep,\n\t\t\t     struct sctp_association *asoc,\n\t\t\t     void *event_arg,\n\t\t\t     sctp_disposition_t status,\n\t\t\t     sctp_cmd_seq_t *commands,\n\t\t\t     gfp_t gfp)\n{\n\tint error;\n\n\t/* FIXME - Most of the dispositions left today would be categorized\n\t * as \"exceptional\" dispositions.  For those dispositions, it\n\t * may not be proper to run through any of the commands at all.\n\t * For example, the command interpreter might be run only with\n\t * disposition SCTP_DISPOSITION_CONSUME.\n\t */\n\tif (0 != (error = sctp_cmd_interpreter(event_type, subtype, state,\n\t\t\t\t\t       ep, asoc,\n\t\t\t\t\t       event_arg, status,\n\t\t\t\t\t       commands, gfp)))\n\t\tgoto bail;\n\n\tswitch (status) {\n\tcase SCTP_DISPOSITION_DISCARD:\n\t\tpr_debug(\"%s: ignored sctp protocol event - state:%d, \"\n\t\t\t \"event_type:%d, event_id:%d\\n\", __func__, state,\n\t\t\t event_type, subtype.chunk);\n\t\tbreak;\n\n\tcase SCTP_DISPOSITION_NOMEM:\n\t\t/* We ran out of memory, so we need to discard this\n\t\t * packet.\n\t\t */\n\t\t/* BUG--we should now recover some memory, probably by\n\t\t * reneging...\n\t\t */\n\t\terror = -ENOMEM;\n\t\tbreak;\n\n\tcase SCTP_DISPOSITION_DELETE_TCB:\n\t\t/* This should now be a command. */\n\t\tbreak;\n\n\tcase SCTP_DISPOSITION_CONSUME:\n\tcase SCTP_DISPOSITION_ABORT:\n\t\t/*\n\t\t * We should no longer have much work to do here as the\n\t\t * real work has been done as explicit commands above.\n\t\t */\n\t\tbreak;\n\n\tcase SCTP_DISPOSITION_VIOLATION:\n\t\tnet_err_ratelimited(\"protocol violation state %d chunkid %d\\n\",\n\t\t\t\t    state, subtype.chunk);\n\t\tbreak;\n\n\tcase SCTP_DISPOSITION_NOT_IMPL:\n\t\tpr_warn(\"unimplemented feature in state %d, event_type %d, event_id %d\\n\",\n\t\t\tstate, event_type, subtype.chunk);\n\t\tbreak;\n\n\tcase SCTP_DISPOSITION_BUG:\n\t\tpr_err(\"bug in state %d, event_type %d, event_id %d\\n\",\n\t\t       state, event_type, subtype.chunk);\n\t\tBUG();\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"impossible disposition %d in state %d, event_type %d, event_id %d\\n\",\n\t\t       status, state, event_type, subtype.chunk);\n\t\tBUG();\n\t\tbreak;\n\t}\n\nbail:\n\treturn error;\n}\n\n/********************************************************************\n * 2nd Level Abstractions\n ********************************************************************/\n\n/* This is the side-effect interpreter.  */\nstatic int sctp_cmd_interpreter(sctp_event_t event_type,\n\t\t\t\tsctp_subtype_t subtype,\n\t\t\t\tsctp_state_t state,\n\t\t\t\tstruct sctp_endpoint *ep,\n\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\tvoid *event_arg,\n\t\t\t\tsctp_disposition_t status,\n\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\tgfp_t gfp)\n{\n\tint error = 0;\n\tint force;\n\tsctp_cmd_t *cmd;\n\tstruct sctp_chunk *new_obj;\n\tstruct sctp_chunk *chunk = NULL;\n\tstruct sctp_packet *packet;\n\tstruct timer_list *timer;\n\tunsigned long timeout;\n\tstruct sctp_transport *t;\n\tstruct sctp_sackhdr sackh;\n\tint local_cork = 0;\n\n\tif (SCTP_EVENT_T_TIMEOUT != event_type)\n\t\tchunk = event_arg;\n\n\t/* Note:  This whole file is a huge candidate for rework.\n\t * For example, each command could either have its own handler, so\n\t * the loop would look like:\n\t *     while (cmds)\n\t *         cmd->handle(x, y, z)\n\t * --jgrimm\n\t */\n\twhile (NULL != (cmd = sctp_next_cmd(commands))) {\n\t\tswitch (cmd->verb) {\n\t\tcase SCTP_CMD_NOP:\n\t\t\t/* Do nothing. */\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_NEW_ASOC:\n\t\t\t/* Register a new association.  */\n\t\t\tif (local_cork) {\n\t\t\t\tsctp_outq_uncork(&asoc->outqueue);\n\t\t\t\tlocal_cork = 0;\n\t\t\t}\n\n\t\t\t/* Register with the endpoint.  */\n\t\t\tasoc = cmd->obj.asoc;\n\t\t\tBUG_ON(asoc->peer.primary_path == NULL);\n\t\t\tsctp_endpoint_add_asoc(ep, asoc);\n\t\t\tsctp_hash_established(asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_UPDATE_ASSOC:\n\t\t       sctp_assoc_update(asoc, cmd->obj.asoc);\n\t\t       break;\n\n\t\tcase SCTP_CMD_PURGE_OUTQUEUE:\n\t\t       sctp_outq_teardown(&asoc->outqueue);\n\t\t       break;\n\n\t\tcase SCTP_CMD_DELETE_TCB:\n\t\t\tif (local_cork) {\n\t\t\t\tsctp_outq_uncork(&asoc->outqueue);\n\t\t\t\tlocal_cork = 0;\n\t\t\t}\n\t\t\t/* Delete the current association.  */\n\t\t\tsctp_cmd_delete_tcb(commands, asoc);\n\t\t\tasoc = NULL;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_NEW_STATE:\n\t\t\t/* Enter a new state.  */\n\t\t\tsctp_cmd_new_state(commands, asoc, cmd->obj.state);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_TSN:\n\t\t\t/* Record the arrival of a TSN.  */\n\t\t\terror = sctp_tsnmap_mark(&asoc->peer.tsn_map,\n\t\t\t\t\t\t cmd->obj.u32, NULL);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_FWDTSN:\n\t\t\t/* Move the Cumulattive TSN Ack ahead. */\n\t\t\tsctp_tsnmap_skip(&asoc->peer.tsn_map, cmd->obj.u32);\n\n\t\t\t/* purge the fragmentation queue */\n\t\t\tsctp_ulpq_reasm_flushtsn(&asoc->ulpq, cmd->obj.u32);\n\n\t\t\t/* Abort any in progress partial delivery. */\n\t\t\tsctp_ulpq_abort_pd(&asoc->ulpq, GFP_ATOMIC);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PROCESS_FWDTSN:\n\t\t\tsctp_cmd_process_fwdtsn(&asoc->ulpq, cmd->obj.chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_GEN_SACK:\n\t\t\t/* Generate a Selective ACK.\n\t\t\t * The argument tells us whether to just count\n\t\t\t * the packet and MAYBE generate a SACK, or\n\t\t\t * force a SACK out.\n\t\t\t */\n\t\t\tforce = cmd->obj.i32;\n\t\t\terror = sctp_gen_sack(asoc, force, commands);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PROCESS_SACK:\n\t\t\t/* Process an inbound SACK.  */\n\t\t\terror = sctp_cmd_process_sack(commands, asoc,\n\t\t\t\t\t\t      cmd->obj.chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_GEN_INIT_ACK:\n\t\t\t/* Generate an INIT ACK chunk.  */\n\t\t\tnew_obj = sctp_make_init_ack(asoc, chunk, GFP_ATOMIC,\n\t\t\t\t\t\t     0);\n\t\t\tif (!new_obj)\n\t\t\t\tgoto nomem;\n\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(new_obj));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PEER_INIT:\n\t\t\t/* Process a unified INIT from the peer.\n\t\t\t * Note: Only used during INIT-ACK processing.  If\n\t\t\t * there is an error just return to the outter\n\t\t\t * layer which will bail.\n\t\t\t */\n\t\t\terror = sctp_cmd_process_init(commands, asoc, chunk,\n\t\t\t\t\t\t      cmd->obj.init, gfp);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_GEN_COOKIE_ECHO:\n\t\t\t/* Generate a COOKIE ECHO chunk.  */\n\t\t\tnew_obj = sctp_make_cookie_echo(asoc, chunk);\n\t\t\tif (!new_obj) {\n\t\t\t\tif (cmd->obj.chunk)\n\t\t\t\t\tsctp_chunk_free(cmd->obj.chunk);\n\t\t\t\tgoto nomem;\n\t\t\t}\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(new_obj));\n\n\t\t\t/* If there is an ERROR chunk to be sent along with\n\t\t\t * the COOKIE_ECHO, send it, too.\n\t\t\t */\n\t\t\tif (cmd->obj.chunk)\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\t\tSCTP_CHUNK(cmd->obj.chunk));\n\n\t\t\tif (new_obj->transport) {\n\t\t\t\tnew_obj->transport->init_sent_count++;\n\t\t\t\tasoc->init_last_sent_to = new_obj->transport;\n\t\t\t}\n\n\t\t\t/* FIXME - Eventually come up with a cleaner way to\n\t\t\t * enabling COOKIE-ECHO + DATA bundling during\n\t\t\t * multihoming stale cookie scenarios, the following\n\t\t\t * command plays with asoc->peer.retran_path to\n\t\t\t * avoid the problem of sending the COOKIE-ECHO and\n\t\t\t * DATA in different paths, which could result\n\t\t\t * in the association being ABORTed if the DATA chunk\n\t\t\t * is processed first by the server.  Checking the\n\t\t\t * init error counter simply causes this command\n\t\t\t * to be executed only during failed attempts of\n\t\t\t * association establishment.\n\t\t\t */\n\t\t\tif ((asoc->peer.retran_path !=\n\t\t\t     asoc->peer.primary_path) &&\n\t\t\t    (asoc->init_err_counter > 0)) {\n\t\t\t\tsctp_add_cmd_sf(commands,\n\t\t\t\t\t\tSCTP_CMD_FORCE_PRIM_RETRAN,\n\t\t\t\t\t\tSCTP_NULL());\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_GEN_SHUTDOWN:\n\t\t\t/* Generate SHUTDOWN when in SHUTDOWN_SENT state.\n\t\t\t * Reset error counts.\n\t\t\t */\n\t\t\tasoc->overall_error_count = 0;\n\n\t\t\t/* Generate a SHUTDOWN chunk.  */\n\t\t\tnew_obj = sctp_make_shutdown(asoc, chunk);\n\t\t\tif (!new_obj)\n\t\t\t\tgoto nomem;\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(new_obj));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_CHUNK_ULP:\n\t\t\t/* Send a chunk to the sockets layer.  */\n\t\t\tpr_debug(\"%s: sm_sideff: chunk_up:%p, ulpq:%p\\n\",\n\t\t\t\t __func__, cmd->obj.chunk, &asoc->ulpq);\n\n\t\t\tsctp_ulpq_tail_data(&asoc->ulpq, cmd->obj.chunk,\n\t\t\t\t\t    GFP_ATOMIC);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_EVENT_ULP:\n\t\t\t/* Send a notification to the sockets layer.  */\n\t\t\tpr_debug(\"%s: sm_sideff: event_up:%p, ulpq:%p\\n\",\n\t\t\t\t __func__, cmd->obj.ulpevent, &asoc->ulpq);\n\n\t\t\tsctp_ulpq_tail_event(&asoc->ulpq, cmd->obj.ulpevent);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPLY:\n\t\t\t/* If an caller has not already corked, do cork. */\n\t\t\tif (!asoc->outqueue.cork) {\n\t\t\t\tsctp_outq_cork(&asoc->outqueue);\n\t\t\t\tlocal_cork = 1;\n\t\t\t}\n\t\t\t/* Send a chunk to our peer.  */\n\t\t\terror = sctp_outq_tail(&asoc->outqueue, cmd->obj.chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_SEND_PKT:\n\t\t\t/* Send a full packet to our peer.  */\n\t\t\tpacket = cmd->obj.packet;\n\t\t\tsctp_packet_transmit(packet);\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_T1_RETRAN:\n\t\t\t/* Mark a transport for retransmission.  */\n\t\t\tsctp_retransmit(&asoc->outqueue, cmd->obj.transport,\n\t\t\t\t\tSCTP_RTXR_T1_RTX);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_RETRAN:\n\t\t\t/* Mark a transport for retransmission.  */\n\t\t\tsctp_retransmit(&asoc->outqueue, cmd->obj.transport,\n\t\t\t\t\tSCTP_RTXR_T3_RTX);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ECN_CE:\n\t\t\t/* Do delayed CE processing.   */\n\t\t\tsctp_do_ecn_ce_work(asoc, cmd->obj.u32);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ECN_ECNE:\n\t\t\t/* Do delayed ECNE processing. */\n\t\t\tnew_obj = sctp_do_ecn_ecne_work(asoc, cmd->obj.u32,\n\t\t\t\t\t\t\tchunk);\n\t\t\tif (new_obj)\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\t\tSCTP_CHUNK(new_obj));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ECN_CWR:\n\t\t\t/* Do delayed CWR processing.  */\n\t\t\tsctp_do_ecn_cwr_work(asoc, cmd->obj.u32);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_SETUP_T2:\n\t\t\tsctp_cmd_setup_t2(commands, asoc, cmd->obj.chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TIMER_START_ONCE:\n\t\t\ttimer = &asoc->timers[cmd->obj.to];\n\n\t\t\tif (timer_pending(timer))\n\t\t\t\tbreak;\n\t\t\t/* fall through */\n\n\t\tcase SCTP_CMD_TIMER_START:\n\t\t\ttimer = &asoc->timers[cmd->obj.to];\n\t\t\ttimeout = asoc->timeouts[cmd->obj.to];\n\t\t\tBUG_ON(!timeout);\n\n\t\t\ttimer->expires = jiffies + timeout;\n\t\t\tsctp_association_hold(asoc);\n\t\t\tadd_timer(timer);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TIMER_RESTART:\n\t\t\ttimer = &asoc->timers[cmd->obj.to];\n\t\t\ttimeout = asoc->timeouts[cmd->obj.to];\n\t\t\tif (!mod_timer(timer, jiffies + timeout))\n\t\t\t\tsctp_association_hold(asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TIMER_STOP:\n\t\t\ttimer = &asoc->timers[cmd->obj.to];\n\t\t\tif (del_timer(timer))\n\t\t\t\tsctp_association_put(asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_CHOOSE_TRANSPORT:\n\t\t\tchunk = cmd->obj.chunk;\n\t\t\tt = sctp_assoc_choose_alter_transport(asoc,\n\t\t\t\t\t\tasoc->init_last_sent_to);\n\t\t\tasoc->init_last_sent_to = t;\n\t\t\tchunk->transport = t;\n\t\t\tt->init_sent_count++;\n\t\t\t/* Set the new transport as primary */\n\t\t\tsctp_assoc_set_primary(asoc, t);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_RESTART:\n\t\t\t/* Do the needed accounting and updates\n\t\t\t * associated with restarting an initialization\n\t\t\t * timer. Only multiply the timeout by two if\n\t\t\t * all transports have been tried at the current\n\t\t\t * timeout.\n\t\t\t */\n\t\t\tsctp_cmd_t1_timer_update(asoc,\n\t\t\t\t\t\tSCTP_EVENT_TIMEOUT_T1_INIT,\n\t\t\t\t\t\t\"INIT\");\n\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_COOKIEECHO_RESTART:\n\t\t\t/* Do the needed accounting and updates\n\t\t\t * associated with restarting an initialization\n\t\t\t * timer. Only multiply the timeout by two if\n\t\t\t * all transports have been tried at the current\n\t\t\t * timeout.\n\t\t\t */\n\t\t\tsctp_cmd_t1_timer_update(asoc,\n\t\t\t\t\t\tSCTP_EVENT_TIMEOUT_T1_COOKIE,\n\t\t\t\t\t\t\"COOKIE\");\n\n\t\t\t/* If we've sent any data bundled with\n\t\t\t * COOKIE-ECHO we need to resend.\n\t\t\t */\n\t\t\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\t\t\ttransports) {\n\t\t\t\tsctp_retransmit_mark(&asoc->outqueue, t,\n\t\t\t\t\t    SCTP_RTXR_T1_RTX);\n\t\t\t}\n\n\t\t\tsctp_add_cmd_sf(commands,\n\t\t\t\t\tSCTP_CMD_TIMER_RESTART,\n\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_FAILED:\n\t\t\tsctp_cmd_init_failed(commands, asoc, cmd->obj.err);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ASSOC_FAILED:\n\t\t\tsctp_cmd_assoc_failed(commands, asoc, event_type,\n\t\t\t\t\t      subtype, chunk, cmd->obj.err);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_COUNTER_INC:\n\t\t\tasoc->init_err_counter++;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_COUNTER_RESET:\n\t\t\tasoc->init_err_counter = 0;\n\t\t\tasoc->init_cycle = 0;\n\t\t\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\t\t\t    transports) {\n\t\t\t\tt->init_sent_count = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_DUP:\n\t\t\tsctp_tsnmap_mark_dup(&asoc->peer.tsn_map,\n\t\t\t\t\t     cmd->obj.u32);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_BAD_TAG:\n\t\t\tpr_debug(\"%s: vtag mismatch!\\n\", __func__);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_STRIKE:\n\t\t\t/* Mark one strike against a transport.  */\n\t\t\tsctp_do_8_2_transport_strike(commands, asoc,\n\t\t\t\t\t\t    cmd->obj.transport, 0);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TRANSPORT_IDLE:\n\t\t\tt = cmd->obj.transport;\n\t\t\tsctp_transport_lower_cwnd(t, SCTP_LOWER_CWND_INACTIVE);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TRANSPORT_HB_SENT:\n\t\t\tt = cmd->obj.transport;\n\t\t\tsctp_do_8_2_transport_strike(commands, asoc,\n\t\t\t\t\t\t     t, 1);\n\t\t\tt->hb_sent = 1;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TRANSPORT_ON:\n\t\t\tt = cmd->obj.transport;\n\t\t\tsctp_cmd_transport_on(commands, asoc, t, chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_HB_TIMERS_START:\n\t\t\tsctp_cmd_hb_timers_start(commands, asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_HB_TIMER_UPDATE:\n\t\t\tt = cmd->obj.transport;\n\t\t\tsctp_cmd_hb_timer_update(commands, t);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_HB_TIMERS_STOP:\n\t\t\tsctp_cmd_hb_timers_stop(commands, asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_ERROR:\n\t\t\terror = cmd->obj.error;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PROCESS_CTSN:\n\t\t\t/* Dummy up a SACK for processing. */\n\t\t\tsackh.cum_tsn_ack = cmd->obj.be32;\n\t\t\tsackh.a_rwnd = asoc->peer.rwnd +\n\t\t\t\t\tasoc->outqueue.outstanding_bytes;\n\t\t\tsackh.num_gap_ack_blocks = 0;\n\t\t\tsackh.num_dup_tsns = 0;\n\t\t\tchunk->subh.sack_hdr = &sackh;\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_SACK,\n\t\t\t\t\tSCTP_CHUNK(chunk));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_DISCARD_PACKET:\n\t\t\t/* We need to discard the whole packet.\n\t\t\t * Uncork the queue since there might be\n\t\t\t * responses pending\n\t\t\t */\n\t\t\tchunk->pdiscard = 1;\n\t\t\tif (asoc) {\n\t\t\t\tsctp_outq_uncork(&asoc->outqueue);\n\t\t\t\tlocal_cork = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_RTO_PENDING:\n\t\t\tt = cmd->obj.transport;\n\t\t\tt->rto_pending = 1;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PART_DELIVER:\n\t\t\tsctp_ulpq_partial_delivery(&asoc->ulpq, GFP_ATOMIC);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_RENEGE:\n\t\t\tsctp_ulpq_renege(&asoc->ulpq, cmd->obj.chunk,\n\t\t\t\t\t GFP_ATOMIC);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_SETUP_T4:\n\t\t\tsctp_cmd_setup_t4(commands, asoc, cmd->obj.chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PROCESS_OPERR:\n\t\t\tsctp_cmd_process_operr(commands, asoc, chunk);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_CLEAR_INIT_TAG:\n\t\t\tasoc->peer.i.init_tag = 0;\n\t\t\tbreak;\n\t\tcase SCTP_CMD_DEL_NON_PRIMARY:\n\t\t\tsctp_cmd_del_non_primary(asoc);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_T3_RTX_TIMERS_STOP:\n\t\t\tsctp_cmd_t3_rtx_timers_stop(commands, asoc);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_FORCE_PRIM_RETRAN:\n\t\t\tt = asoc->peer.retran_path;\n\t\t\tasoc->peer.retran_path = asoc->peer.primary_path;\n\t\t\terror = sctp_outq_uncork(&asoc->outqueue);\n\t\t\tlocal_cork = 0;\n\t\t\tasoc->peer.retran_path = t;\n\t\t\tbreak;\n\t\tcase SCTP_CMD_SET_SK_ERR:\n\t\t\tsctp_cmd_set_sk_err(asoc, cmd->obj.error);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_ASSOC_CHANGE:\n\t\t\tsctp_cmd_assoc_change(commands, asoc,\n\t\t\t\t\t      cmd->obj.u8);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_ADAPTATION_IND:\n\t\t\tsctp_cmd_adaptation_ind(commands, asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ASSOC_SHKEY:\n\t\t\terror = sctp_auth_asoc_init_active_key(asoc,\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_UPDATE_INITTAG:\n\t\t\tasoc->peer.i.init_tag = cmd->obj.u32;\n\t\t\tbreak;\n\t\tcase SCTP_CMD_SEND_MSG:\n\t\t\tif (!asoc->outqueue.cork) {\n\t\t\t\tsctp_outq_cork(&asoc->outqueue);\n\t\t\t\tlocal_cork = 1;\n\t\t\t}\n\t\t\terror = sctp_cmd_send_msg(asoc, cmd->obj.msg);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_SEND_NEXT_ASCONF:\n\t\t\tsctp_cmd_send_asconf(asoc);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_PURGE_ASCONF_QUEUE:\n\t\t\tsctp_asconf_queue_teardown(asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_SET_ASOC:\n\t\t\tasoc = cmd->obj.asoc;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_warn(\"Impossible command: %u\\n\",\n\t\t\t\tcmd->verb);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\nout:\n\t/* If this is in response to a received chunk, wait until\n\t * we are done with the packet to open the queue so that we don't\n\t * send multiple packets in response to a single request.\n\t */\n\tif (asoc && SCTP_EVENT_T_CHUNK == event_type && chunk) {\n\t\tif (chunk->end_of_packet || chunk->singleton)\n\t\t\terror = sctp_outq_uncork(&asoc->outqueue);\n\t} else if (local_cork)\n\t\terror = sctp_outq_uncork(&asoc->outqueue);\n\treturn error;\nnomem:\n\terror = -ENOMEM;\n\tgoto out;\n}\n\n"], "fixing_code": ["/* SCTP kernel implementation\n * (C) Copyright IBM Corp. 2001, 2004\n * Copyright (c) 1999 Cisco, Inc.\n * Copyright (c) 1999-2001 Motorola, Inc.\n *\n * This file is part of the SCTP kernel implementation\n *\n * These functions work with the state functions in sctp_sm_statefuns.c\n * to implement that state operations.  These functions implement the\n * steps which require modifying existing data structures.\n *\n * This SCTP implementation is free software;\n * you can redistribute it and/or modify it under the terms of\n * the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This SCTP implementation is distributed in the hope that it\n * will be useful, but WITHOUT ANY WARRANTY; without even the implied\n *                 ************************\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GNU CC; see the file COPYING.  If not, see\n * <http://www.gnu.org/licenses/>.\n *\n * Please send any bug reports or fixes you make to the\n * email address(es):\n *    lksctp developers <linux-sctp@vger.kernel.org>\n *\n * Written or modified by:\n *    La Monte H.P. Yarroll <piggy@acm.org>\n *    Karl Knutson          <karl@athena.chicago.il.us>\n *    Jon Grimm             <jgrimm@austin.ibm.com>\n *    Hui Huang\t\t    <hui.huang@nokia.com>\n *    Dajiang Zhang\t    <dajiang.zhang@nokia.com>\n *    Daisy Chang\t    <daisyc@us.ibm.com>\n *    Sridhar Samudrala\t    <sri@us.ibm.com>\n *    Ardelle Fan\t    <ardelle.fan@intel.com>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/skbuff.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <net/sock.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n\nstatic int sctp_cmd_interpreter(sctp_event_t event_type,\n\t\t\t\tsctp_subtype_t subtype,\n\t\t\t\tsctp_state_t state,\n\t\t\t\tstruct sctp_endpoint *ep,\n\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\tvoid *event_arg,\n\t\t\t\tsctp_disposition_t status,\n\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\tgfp_t gfp);\nstatic int sctp_side_effects(sctp_event_t event_type, sctp_subtype_t subtype,\n\t\t\t     sctp_state_t state,\n\t\t\t     struct sctp_endpoint *ep,\n\t\t\t     struct sctp_association *asoc,\n\t\t\t     void *event_arg,\n\t\t\t     sctp_disposition_t status,\n\t\t\t     sctp_cmd_seq_t *commands,\n\t\t\t     gfp_t gfp);\n\nstatic void sctp_cmd_hb_timer_update(sctp_cmd_seq_t *cmds,\n\t\t\t\t     struct sctp_transport *t);\n/********************************************************************\n * Helper functions\n ********************************************************************/\n\n/* A helper function for delayed processing of INET ECN CE bit. */\nstatic void sctp_do_ecn_ce_work(struct sctp_association *asoc,\n\t\t\t\t__u32 lowest_tsn)\n{\n\t/* Save the TSN away for comparison when we receive CWR */\n\n\tasoc->last_ecne_tsn = lowest_tsn;\n\tasoc->need_ecne = 1;\n}\n\n/* Helper function for delayed processing of SCTP ECNE chunk.  */\n/* RFC 2960 Appendix A\n *\n * RFC 2481 details a specific bit for a sender to send in\n * the header of its next outbound TCP segment to indicate to\n * its peer that it has reduced its congestion window.  This\n * is termed the CWR bit.  For SCTP the same indication is made\n * by including the CWR chunk.  This chunk contains one data\n * element, i.e. the TSN number that was sent in the ECNE chunk.\n * This element represents the lowest TSN number in the datagram\n * that was originally marked with the CE bit.\n */\nstatic struct sctp_chunk *sctp_do_ecn_ecne_work(struct sctp_association *asoc,\n\t\t\t\t\t   __u32 lowest_tsn,\n\t\t\t\t\t   struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *repl;\n\n\t/* Our previously transmitted packet ran into some congestion\n\t * so we should take action by reducing cwnd and ssthresh\n\t * and then ACK our peer that we we've done so by\n\t * sending a CWR.\n\t */\n\n\t/* First, try to determine if we want to actually lower\n\t * our cwnd variables.  Only lower them if the ECNE looks more\n\t * recent than the last response.\n\t */\n\tif (TSN_lt(asoc->last_cwr_tsn, lowest_tsn)) {\n\t\tstruct sctp_transport *transport;\n\n\t\t/* Find which transport's congestion variables\n\t\t * need to be adjusted.\n\t\t */\n\t\ttransport = sctp_assoc_lookup_tsn(asoc, lowest_tsn);\n\n\t\t/* Update the congestion variables. */\n\t\tif (transport)\n\t\t\tsctp_transport_lower_cwnd(transport,\n\t\t\t\t\t\t  SCTP_LOWER_CWND_ECNE);\n\t\tasoc->last_cwr_tsn = lowest_tsn;\n\t}\n\n\t/* Always try to quiet the other end.  In case of lost CWR,\n\t * resend last_cwr_tsn.\n\t */\n\trepl = sctp_make_cwr(asoc, asoc->last_cwr_tsn, chunk);\n\n\t/* If we run out of memory, it will look like a lost CWR.  We'll\n\t * get back in sync eventually.\n\t */\n\treturn repl;\n}\n\n/* Helper function to do delayed processing of ECN CWR chunk.  */\nstatic void sctp_do_ecn_cwr_work(struct sctp_association *asoc,\n\t\t\t\t __u32 lowest_tsn)\n{\n\t/* Turn off ECNE getting auto-prepended to every outgoing\n\t * packet\n\t */\n\tasoc->need_ecne = 0;\n}\n\n/* Generate SACK if necessary.  We call this at the end of a packet.  */\nstatic int sctp_gen_sack(struct sctp_association *asoc, int force,\n\t\t\t sctp_cmd_seq_t *commands)\n{\n\t__u32 ctsn, max_tsn_seen;\n\tstruct sctp_chunk *sack;\n\tstruct sctp_transport *trans = asoc->peer.last_data_from;\n\tint error = 0;\n\n\tif (force ||\n\t    (!trans && (asoc->param_flags & SPP_SACKDELAY_DISABLE)) ||\n\t    (trans && (trans->param_flags & SPP_SACKDELAY_DISABLE)))\n\t\tasoc->peer.sack_needed = 1;\n\n\tctsn = sctp_tsnmap_get_ctsn(&asoc->peer.tsn_map);\n\tmax_tsn_seen = sctp_tsnmap_get_max_tsn_seen(&asoc->peer.tsn_map);\n\n\t/* From 12.2 Parameters necessary per association (i.e. the TCB):\n\t *\n\t * Ack State : This flag indicates if the next received packet\n\t * \t     : is to be responded to with a SACK. ...\n\t *\t     : When DATA chunks are out of order, SACK's\n\t *           : are not delayed (see Section 6).\n\t *\n\t * [This is actually not mentioned in Section 6, but we\n\t * implement it here anyway. --piggy]\n\t */\n\tif (max_tsn_seen != ctsn)\n\t\tasoc->peer.sack_needed = 1;\n\n\t/* From 6.2  Acknowledgement on Reception of DATA Chunks:\n\t *\n\t * Section 4.2 of [RFC2581] SHOULD be followed. Specifically,\n\t * an acknowledgement SHOULD be generated for at least every\n\t * second packet (not every second DATA chunk) received, and\n\t * SHOULD be generated within 200 ms of the arrival of any\n\t * unacknowledged DATA chunk. ...\n\t */\n\tif (!asoc->peer.sack_needed) {\n\t\tasoc->peer.sack_cnt++;\n\n\t\t/* Set the SACK delay timeout based on the\n\t\t * SACK delay for the last transport\n\t\t * data was received from, or the default\n\t\t * for the association.\n\t\t */\n\t\tif (trans) {\n\t\t\t/* We will need a SACK for the next packet.  */\n\t\t\tif (asoc->peer.sack_cnt >= trans->sackfreq - 1)\n\t\t\t\tasoc->peer.sack_needed = 1;\n\n\t\t\tasoc->timeouts[SCTP_EVENT_TIMEOUT_SACK] =\n\t\t\t\ttrans->sackdelay;\n\t\t} else {\n\t\t\t/* We will need a SACK for the next packet.  */\n\t\t\tif (asoc->peer.sack_cnt >= asoc->sackfreq - 1)\n\t\t\t\tasoc->peer.sack_needed = 1;\n\n\t\t\tasoc->timeouts[SCTP_EVENT_TIMEOUT_SACK] =\n\t\t\t\tasoc->sackdelay;\n\t\t}\n\n\t\t/* Restart the SACK timer. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_SACK));\n\t} else {\n\t\tasoc->a_rwnd = asoc->rwnd;\n\t\tsack = sctp_make_sack(asoc);\n\t\tif (!sack)\n\t\t\tgoto nomem;\n\n\t\tasoc->peer.sack_needed = 0;\n\t\tasoc->peer.sack_cnt = 0;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(sack));\n\n\t\t/* Stop the SACK timer.  */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_SACK));\n\t}\n\n\treturn error;\nnomem:\n\terror = -ENOMEM;\n\treturn error;\n}\n\n/* When the T3-RTX timer expires, it calls this function to create the\n * relevant state machine event.\n */\nvoid sctp_generate_t3_rtx_event(unsigned long peer)\n{\n\tint error;\n\tstruct sctp_transport *transport = (struct sctp_transport *) peer;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\n\t/* Check whether a task is in the sock.  */\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\t/* Try again later.  */\n\t\tif (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Is this transport really dead and just waiting around for\n\t * the timer to let go of the reference?\n\t */\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\n\t/* Run through the state machine.  */\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),\n\t\t\t   asoc->state,\n\t\t\t   asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\n\tif (error)\n\t\tsk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(sk);\n\tsctp_transport_put(transport);\n}\n\n/* This is a sa interface for producing timeout events.  It works\n * for timeouts which use the association as their parameter.\n */\nstatic void sctp_generate_timeout_event(struct sctp_association *asoc,\n\t\t\t\t\tsctp_event_timeout_t timeout_type)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\tint error = 0;\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\tpr_debug(\"%s: sock is busy: timer %d\\n\", __func__,\n\t\t\t timeout_type);\n\n\t\t/* Try again later.  */\n\t\tif (!mod_timer(&asoc->timers[timeout_type], jiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Is this association really dead and just waiting around for\n\t * the timer to let go of the reference?\n\t */\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\n\t/* Run through the state machine.  */\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(timeout_type),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   (void *)timeout_type, GFP_ATOMIC);\n\n\tif (error)\n\t\tsk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(sk);\n\tsctp_association_put(asoc);\n}\n\nstatic void sctp_generate_t1_cookie_event(unsigned long data)\n{\n\tstruct sctp_association *asoc = (struct sctp_association *) data;\n\tsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_T1_COOKIE);\n}\n\nstatic void sctp_generate_t1_init_event(unsigned long data)\n{\n\tstruct sctp_association *asoc = (struct sctp_association *) data;\n\tsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_T1_INIT);\n}\n\nstatic void sctp_generate_t2_shutdown_event(unsigned long data)\n{\n\tstruct sctp_association *asoc = (struct sctp_association *) data;\n\tsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_T2_SHUTDOWN);\n}\n\nstatic void sctp_generate_t4_rto_event(unsigned long data)\n{\n\tstruct sctp_association *asoc = (struct sctp_association *) data;\n\tsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_T4_RTO);\n}\n\nstatic void sctp_generate_t5_shutdown_guard_event(unsigned long data)\n{\n\tstruct sctp_association *asoc = (struct sctp_association *)data;\n\tsctp_generate_timeout_event(asoc,\n\t\t\t\t    SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD);\n\n} /* sctp_generate_t5_shutdown_guard_event() */\n\nstatic void sctp_generate_autoclose_event(unsigned long data)\n{\n\tstruct sctp_association *asoc = (struct sctp_association *) data;\n\tsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_AUTOCLOSE);\n}\n\n/* Generate a heart beat event.  If the sock is busy, reschedule.   Make\n * sure that the transport is still valid.\n */\nvoid sctp_generate_heartbeat_event(unsigned long data)\n{\n\tint error = 0;\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\t/* Try again later.  */\n\t\tif (!mod_timer(&transport->hb_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Is this structure just waiting around for us to actually\n\t * get destroyed?\n\t */\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_HEARTBEAT),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\n\tif (error)\n\t\tsk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(sk);\n\tsctp_transport_put(transport);\n}\n\n/* Handle the timeout of the ICMP protocol unreachable timer.  Trigger\n * the correct state machine transition that will close the association.\n */\nvoid sctp_generate_proto_unreach_event(unsigned long data)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\t/* Try again later.  */\n\t\tif (!mod_timer(&transport->proto_unreach_timer,\n\t\t\t\tjiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Is this structure just waiting around for us to actually\n\t * get destroyed?\n\t */\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\n\tsctp_do_sm(net, SCTP_EVENT_T_OTHER,\n\t\t   SCTP_ST_OTHER(SCTP_EVENT_ICMP_PROTO_UNREACH),\n\t\t   asoc->state, asoc->ep, asoc, transport, GFP_ATOMIC);\n\nout_unlock:\n\tbh_unlock_sock(sk);\n\tsctp_association_put(asoc);\n}\n\n\n/* Inject a SACK Timeout event into the state machine.  */\nstatic void sctp_generate_sack_event(unsigned long data)\n{\n\tstruct sctp_association *asoc = (struct sctp_association *) data;\n\tsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_SACK);\n}\n\nsctp_timer_event_t *sctp_timer_events[SCTP_NUM_TIMEOUT_TYPES] = {\n\tNULL,\n\tsctp_generate_t1_cookie_event,\n\tsctp_generate_t1_init_event,\n\tsctp_generate_t2_shutdown_event,\n\tNULL,\n\tsctp_generate_t4_rto_event,\n\tsctp_generate_t5_shutdown_guard_event,\n\tNULL,\n\tsctp_generate_sack_event,\n\tsctp_generate_autoclose_event,\n};\n\n\n/* RFC 2960 8.2 Path Failure Detection\n *\n * When its peer endpoint is multi-homed, an endpoint should keep a\n * error counter for each of the destination transport addresses of the\n * peer endpoint.\n *\n * Each time the T3-rtx timer expires on any address, or when a\n * HEARTBEAT sent to an idle address is not acknowledged within a RTO,\n * the error counter of that destination address will be incremented.\n * When the value in the error counter exceeds the protocol parameter\n * 'Path.Max.Retrans' of that destination address, the endpoint should\n * mark the destination transport address as inactive, and a\n * notification SHOULD be sent to the upper layer.\n *\n */\nstatic void sctp_do_8_2_transport_strike(sctp_cmd_seq_t *commands,\n\t\t\t\t\t struct sctp_association *asoc,\n\t\t\t\t\t struct sctp_transport *transport,\n\t\t\t\t\t int is_hb)\n{\n\t/* The check for association's overall error counter exceeding the\n\t * threshold is done in the state function.\n\t */\n\t/* We are here due to a timer expiration.  If the timer was\n\t * not a HEARTBEAT, then normal error tracking is done.\n\t * If the timer was a heartbeat, we only increment error counts\n\t * when we already have an outstanding HEARTBEAT that has not\n\t * been acknowledged.\n\t * Additionally, some tranport states inhibit error increments.\n\t */\n\tif (!is_hb) {\n\t\tasoc->overall_error_count++;\n\t\tif (transport->state != SCTP_INACTIVE)\n\t\t\ttransport->error_count++;\n\t } else if (transport->hb_sent) {\n\t\tif (transport->state != SCTP_UNCONFIRMED)\n\t\t\tasoc->overall_error_count++;\n\t\tif (transport->state != SCTP_INACTIVE)\n\t\t\ttransport->error_count++;\n\t}\n\n\t/* If the transport error count is greater than the pf_retrans\n\t * threshold, and less than pathmaxrtx, and if the current state\n\t * is SCTP_ACTIVE, then mark this transport as Partially Failed,\n\t * see SCTP Quick Failover Draft, section 5.1\n\t */\n\tif ((transport->state == SCTP_ACTIVE) &&\n\t   (asoc->pf_retrans < transport->pathmaxrxt) &&\n\t   (transport->error_count > asoc->pf_retrans)) {\n\n\t\tsctp_assoc_control_transport(asoc, transport,\n\t\t\t\t\t     SCTP_TRANSPORT_PF,\n\t\t\t\t\t     0);\n\n\t\t/* Update the hb timer to resend a heartbeat every rto */\n\t\tsctp_cmd_hb_timer_update(commands, transport);\n\t}\n\n\tif (transport->state != SCTP_INACTIVE &&\n\t    (transport->error_count > transport->pathmaxrxt)) {\n\t\tpr_debug(\"%s: association:%p transport addr:%pISpc failed\\n\",\n\t\t\t __func__, asoc, &transport->ipaddr.sa);\n\n\t\tsctp_assoc_control_transport(asoc, transport,\n\t\t\t\t\t     SCTP_TRANSPORT_DOWN,\n\t\t\t\t\t     SCTP_FAILED_THRESHOLD);\n\t}\n\n\t/* E2) For the destination address for which the timer\n\t * expires, set RTO <- RTO * 2 (\"back off the timer\").  The\n\t * maximum value discussed in rule C7 above (RTO.max) may be\n\t * used to provide an upper bound to this doubling operation.\n\t *\n\t * Special Case:  the first HB doesn't trigger exponential backoff.\n\t * The first unacknowledged HB triggers it.  We do this with a flag\n\t * that indicates that we have an outstanding HB.\n\t */\n\tif (!is_hb || transport->hb_sent) {\n\t\ttransport->rto = min((transport->rto * 2), transport->asoc->rto_max);\n\t\tsctp_max_rto(asoc, transport);\n\t}\n}\n\n/* Worker routine to handle INIT command failure.  */\nstatic void sctp_cmd_init_failed(sctp_cmd_seq_t *commands,\n\t\t\t\t struct sctp_association *asoc,\n\t\t\t\t unsigned int error)\n{\n\tstruct sctp_ulpevent *event;\n\n\tevent = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_CANT_STR_ASSOC,\n\t\t\t\t\t\t(__u16)error, 0, 0, NULL,\n\t\t\t\t\t\tGFP_ATOMIC);\n\n\tif (event)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(event));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\t/* SEND_FAILED sent later when cleaning up the association. */\n\tasoc->outqueue.error = error;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n}\n\n/* Worker routine to handle SCTP_CMD_ASSOC_FAILED.  */\nstatic void sctp_cmd_assoc_failed(sctp_cmd_seq_t *commands,\n\t\t\t\t  struct sctp_association *asoc,\n\t\t\t\t  sctp_event_t event_type,\n\t\t\t\t  sctp_subtype_t subtype,\n\t\t\t\t  struct sctp_chunk *chunk,\n\t\t\t\t  unsigned int error)\n{\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_chunk *abort;\n\t/* Cancel any partial delivery in progress. */\n\tsctp_ulpq_abort_pd(&asoc->ulpq, GFP_ATOMIC);\n\n\tif (event_type == SCTP_EVENT_T_CHUNK && subtype.chunk == SCTP_CID_ABORT)\n\t\tevent = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_COMM_LOST,\n\t\t\t\t\t\t(__u16)error, 0, 0, chunk,\n\t\t\t\t\t\tGFP_ATOMIC);\n\telse\n\t\tevent = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_COMM_LOST,\n\t\t\t\t\t\t(__u16)error, 0, 0, NULL,\n\t\t\t\t\t\tGFP_ATOMIC);\n\tif (event)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(event));\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tabort = sctp_make_violation_max_retrans(asoc, chunk);\n\t\tif (abort)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\t/* SEND_FAILED sent later when cleaning up the association. */\n\tasoc->outqueue.error = error;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n}\n\n/* Process an init chunk (may be real INIT/INIT-ACK or an embedded INIT\n * inside the cookie.  In reality, this is only used for INIT-ACK processing\n * since all other cases use \"temporary\" associations and can do all\n * their work in statefuns directly.\n */\nstatic int sctp_cmd_process_init(sctp_cmd_seq_t *commands,\n\t\t\t\t struct sctp_association *asoc,\n\t\t\t\t struct sctp_chunk *chunk,\n\t\t\t\t sctp_init_chunk_t *peer_init,\n\t\t\t\t gfp_t gfp)\n{\n\tint error;\n\n\t/* We only process the init as a sideeffect in a single\n\t * case.   This is when we process the INIT-ACK.   If we\n\t * fail during INIT processing (due to malloc problems),\n\t * just return the error and stop processing the stack.\n\t */\n\tif (!sctp_process_init(asoc, chunk, sctp_source(chunk), peer_init, gfp))\n\t\terror = -ENOMEM;\n\telse\n\t\terror = 0;\n\n\treturn error;\n}\n\n/* Helper function to break out starting up of heartbeat timers.  */\nstatic void sctp_cmd_hb_timers_start(sctp_cmd_seq_t *cmds,\n\t\t\t\t     struct sctp_association *asoc)\n{\n\tstruct sctp_transport *t;\n\n\t/* Start a heartbeat timer for each transport on the association.\n\t * hold a reference on the transport to make sure none of\n\t * the needed data structures go away.\n\t */\n\tlist_for_each_entry(t, &asoc->peer.transport_addr_list, transports) {\n\n\t\tif (!mod_timer(&t->hb_timer, sctp_transport_timeout(t)))\n\t\t\tsctp_transport_hold(t);\n\t}\n}\n\nstatic void sctp_cmd_hb_timers_stop(sctp_cmd_seq_t *cmds,\n\t\t\t\t    struct sctp_association *asoc)\n{\n\tstruct sctp_transport *t;\n\n\t/* Stop all heartbeat timers. */\n\n\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\ttransports) {\n\t\tif (del_timer(&t->hb_timer))\n\t\t\tsctp_transport_put(t);\n\t}\n}\n\n/* Helper function to stop any pending T3-RTX timers */\nstatic void sctp_cmd_t3_rtx_timers_stop(sctp_cmd_seq_t *cmds,\n\t\t\t\t\tstruct sctp_association *asoc)\n{\n\tstruct sctp_transport *t;\n\n\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\ttransports) {\n\t\tif (del_timer(&t->T3_rtx_timer))\n\t\t\tsctp_transport_put(t);\n\t}\n}\n\n\n/* Helper function to update the heartbeat timer. */\nstatic void sctp_cmd_hb_timer_update(sctp_cmd_seq_t *cmds,\n\t\t\t\t     struct sctp_transport *t)\n{\n\t/* Update the heartbeat timer.  */\n\tif (!mod_timer(&t->hb_timer, sctp_transport_timeout(t)))\n\t\tsctp_transport_hold(t);\n}\n\n/* Helper function to handle the reception of an HEARTBEAT ACK.  */\nstatic void sctp_cmd_transport_on(sctp_cmd_seq_t *cmds,\n\t\t\t\t  struct sctp_association *asoc,\n\t\t\t\t  struct sctp_transport *t,\n\t\t\t\t  struct sctp_chunk *chunk)\n{\n\tsctp_sender_hb_info_t *hbinfo;\n\tint was_unconfirmed = 0;\n\n\t/* 8.3 Upon the receipt of the HEARTBEAT ACK, the sender of the\n\t * HEARTBEAT should clear the error counter of the destination\n\t * transport address to which the HEARTBEAT was sent.\n\t */\n\tt->error_count = 0;\n\n\t/*\n\t * Although RFC4960 specifies that the overall error count must\n\t * be cleared when a HEARTBEAT ACK is received, we make an\n\t * exception while in SHUTDOWN PENDING. If the peer keeps its\n\t * window shut forever, we may never be able to transmit our\n\t * outstanding data and rely on the retransmission limit be reached\n\t * to shutdown the association.\n\t */\n\tif (t->asoc->state < SCTP_STATE_SHUTDOWN_PENDING)\n\t\tt->asoc->overall_error_count = 0;\n\n\t/* Clear the hb_sent flag to signal that we had a good\n\t * acknowledgement.\n\t */\n\tt->hb_sent = 0;\n\n\t/* Mark the destination transport address as active if it is not so\n\t * marked.\n\t */\n\tif ((t->state == SCTP_INACTIVE) || (t->state == SCTP_UNCONFIRMED)) {\n\t\twas_unconfirmed = 1;\n\t\tsctp_assoc_control_transport(asoc, t, SCTP_TRANSPORT_UP,\n\t\t\t\t\t     SCTP_HEARTBEAT_SUCCESS);\n\t}\n\n\tif (t->state == SCTP_PF)\n\t\tsctp_assoc_control_transport(asoc, t, SCTP_TRANSPORT_UP,\n\t\t\t\t\t     SCTP_HEARTBEAT_SUCCESS);\n\n\t/* HB-ACK was received for a the proper HB.  Consider this\n\t * forward progress.\n\t */\n\tif (t->dst)\n\t\tdst_confirm(t->dst);\n\n\t/* The receiver of the HEARTBEAT ACK should also perform an\n\t * RTT measurement for that destination transport address\n\t * using the time value carried in the HEARTBEAT ACK chunk.\n\t * If the transport's rto_pending variable has been cleared,\n\t * it was most likely due to a retransmit.  However, we want\n\t * to re-enable it to properly update the rto.\n\t */\n\tif (t->rto_pending == 0)\n\t\tt->rto_pending = 1;\n\n\thbinfo = (sctp_sender_hb_info_t *) chunk->skb->data;\n\tsctp_transport_update_rto(t, (jiffies - hbinfo->sent_at));\n\n\t/* Update the heartbeat timer.  */\n\tif (!mod_timer(&t->hb_timer, sctp_transport_timeout(t)))\n\t\tsctp_transport_hold(t);\n\n\tif (was_unconfirmed && asoc->peer.transport_count == 1)\n\t\tsctp_transport_immediate_rtx(t);\n}\n\n\n/* Helper function to process the process SACK command.  */\nstatic int sctp_cmd_process_sack(sctp_cmd_seq_t *cmds,\n\t\t\t\t struct sctp_association *asoc,\n\t\t\t\t struct sctp_chunk *chunk)\n{\n\tint err = 0;\n\n\tif (sctp_outq_sack(&asoc->outqueue, chunk)) {\n\t\tstruct net *net = sock_net(asoc->base.sk);\n\n\t\t/* There are no more TSNs awaiting SACK.  */\n\t\terr = sctp_do_sm(net, SCTP_EVENT_T_OTHER,\n\t\t\t\t SCTP_ST_OTHER(SCTP_EVENT_NO_PENDING_TSN),\n\t\t\t\t asoc->state, asoc->ep, asoc, NULL,\n\t\t\t\t GFP_ATOMIC);\n\t}\n\n\treturn err;\n}\n\n/* Helper function to set the timeout value for T2-SHUTDOWN timer and to set\n * the transport for a shutdown chunk.\n */\nstatic void sctp_cmd_setup_t2(sctp_cmd_seq_t *cmds,\n\t\t\t      struct sctp_association *asoc,\n\t\t\t      struct sctp_chunk *chunk)\n{\n\tstruct sctp_transport *t;\n\n\tif (chunk->transport)\n\t\tt = chunk->transport;\n\telse {\n\t\tt = sctp_assoc_choose_alter_transport(asoc,\n\t\t\t\t\t      asoc->shutdown_last_sent_to);\n\t\tchunk->transport = t;\n\t}\n\tasoc->shutdown_last_sent_to = t;\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T2_SHUTDOWN] = t->rto;\n}\n\n/* Helper function to change the state of an association. */\nstatic void sctp_cmd_new_state(sctp_cmd_seq_t *cmds,\n\t\t\t       struct sctp_association *asoc,\n\t\t\t       sctp_state_t state)\n{\n\tstruct sock *sk = asoc->base.sk;\n\n\tasoc->state = state;\n\n\tpr_debug(\"%s: asoc:%p[%s]\\n\", __func__, asoc, sctp_state_tbl[state]);\n\n\tif (sctp_style(sk, TCP)) {\n\t\t/* Change the sk->sk_state of a TCP-style socket that has\n\t\t * successfully completed a connect() call.\n\t\t */\n\t\tif (sctp_state(asoc, ESTABLISHED) && sctp_sstate(sk, CLOSED))\n\t\t\tsk->sk_state = SCTP_SS_ESTABLISHED;\n\n\t\t/* Set the RCV_SHUTDOWN flag when a SHUTDOWN is received. */\n\t\tif (sctp_state(asoc, SHUTDOWN_RECEIVED) &&\n\t\t    sctp_sstate(sk, ESTABLISHED))\n\t\t\tsk->sk_shutdown |= RCV_SHUTDOWN;\n\t}\n\n\tif (sctp_state(asoc, COOKIE_WAIT)) {\n\t\t/* Reset init timeouts since they may have been\n\t\t * increased due to timer expirations.\n\t\t */\n\t\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T1_INIT] =\n\t\t\t\t\t\tasoc->rto_initial;\n\t\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T1_COOKIE] =\n\t\t\t\t\t\tasoc->rto_initial;\n\t}\n\n\tif (sctp_state(asoc, ESTABLISHED) ||\n\t    sctp_state(asoc, CLOSED) ||\n\t    sctp_state(asoc, SHUTDOWN_RECEIVED)) {\n\t\t/* Wake up any processes waiting in the asoc's wait queue in\n\t\t * sctp_wait_for_connect() or sctp_wait_for_sndbuf().\n\t\t */\n\t\tif (waitqueue_active(&asoc->wait))\n\t\t\twake_up_interruptible(&asoc->wait);\n\n\t\t/* Wake up any processes waiting in the sk's sleep queue of\n\t\t * a TCP-style or UDP-style peeled-off socket in\n\t\t * sctp_wait_for_accept() or sctp_wait_for_packet().\n\t\t * For a UDP-style socket, the waiters are woken up by the\n\t\t * notifications.\n\t\t */\n\t\tif (!sctp_style(sk, UDP))\n\t\t\tsk->sk_state_change(sk);\n\t}\n}\n\n/* Helper function to delete an association. */\nstatic void sctp_cmd_delete_tcb(sctp_cmd_seq_t *cmds,\n\t\t\t\tstruct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\n\t/* If it is a non-temporary association belonging to a TCP-style\n\t * listening socket that is not closed, do not free it so that accept()\n\t * can pick it up later.\n\t */\n\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING) &&\n\t    (!asoc->temp) && (sk->sk_shutdown != SHUTDOWN_MASK))\n\t\treturn;\n\n\tsctp_unhash_established(asoc);\n\tsctp_association_free(asoc);\n}\n\n/*\n * ADDIP Section 4.1 ASCONF Chunk Procedures\n * A4) Start a T-4 RTO timer, using the RTO value of the selected\n * destination address (we use active path instead of primary path just\n * because primary path may be inactive.\n */\nstatic void sctp_cmd_setup_t4(sctp_cmd_seq_t *cmds,\n\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\tstruct sctp_chunk *chunk)\n{\n\tstruct sctp_transport *t;\n\n\tt = sctp_assoc_choose_alter_transport(asoc, chunk->transport);\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T4_RTO] = t->rto;\n\tchunk->transport = t;\n}\n\n/* Process an incoming Operation Error Chunk. */\nstatic void sctp_cmd_process_operr(sctp_cmd_seq_t *cmds,\n\t\t\t\t   struct sctp_association *asoc,\n\t\t\t\t   struct sctp_chunk *chunk)\n{\n\tstruct sctp_errhdr *err_hdr;\n\tstruct sctp_ulpevent *ev;\n\n\twhile (chunk->chunk_end > chunk->skb->data) {\n\t\terr_hdr = (struct sctp_errhdr *)(chunk->skb->data);\n\n\t\tev = sctp_ulpevent_make_remote_error(asoc, chunk, 0,\n\t\t\t\t\t\t     GFP_ATOMIC);\n\t\tif (!ev)\n\t\t\treturn;\n\n\t\tsctp_ulpq_tail_event(&asoc->ulpq, ev);\n\n\t\tswitch (err_hdr->cause) {\n\t\tcase SCTP_ERROR_UNKNOWN_CHUNK:\n\t\t{\n\t\t\tsctp_chunkhdr_t *unk_chunk_hdr;\n\n\t\t\tunk_chunk_hdr = (sctp_chunkhdr_t *)err_hdr->variable;\n\t\t\tswitch (unk_chunk_hdr->type) {\n\t\t\t/* ADDIP 4.1 A9) If the peer responds to an ASCONF with\n\t\t\t * an ERROR chunk reporting that it did not recognized\n\t\t\t * the ASCONF chunk type, the sender of the ASCONF MUST\n\t\t\t * NOT send any further ASCONF chunks and MUST stop its\n\t\t\t * T-4 timer.\n\t\t\t */\n\t\t\tcase SCTP_CID_ASCONF:\n\t\t\t\tif (asoc->peer.asconf_capable == 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tasoc->peer.asconf_capable = 0;\n\t\t\t\tsctp_add_cmd_sf(cmds, SCTP_CMD_TIMER_STOP,\n\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Process variable FWDTSN chunk information. */\nstatic void sctp_cmd_process_fwdtsn(struct sctp_ulpq *ulpq,\n\t\t\t\t    struct sctp_chunk *chunk)\n{\n\tstruct sctp_fwdtsn_skip *skip;\n\t/* Walk through all the skipped SSNs */\n\tsctp_walk_fwdtsn(skip, chunk) {\n\t\tsctp_ulpq_skip(ulpq, ntohs(skip->stream), ntohs(skip->ssn));\n\t}\n}\n\n/* Helper function to remove the association non-primary peer\n * transports.\n */\nstatic void sctp_cmd_del_non_primary(struct sctp_association *asoc)\n{\n\tstruct sctp_transport *t;\n\tstruct list_head *pos;\n\tstruct list_head *temp;\n\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\tt = list_entry(pos, struct sctp_transport, transports);\n\t\tif (!sctp_cmp_addr_exact(&t->ipaddr,\n\t\t\t\t\t &asoc->peer.primary_addr)) {\n\t\t\tsctp_assoc_rm_peer(asoc, t);\n\t\t}\n\t}\n}\n\n/* Helper function to set sk_err on a 1-1 style socket. */\nstatic void sctp_cmd_set_sk_err(struct sctp_association *asoc, int error)\n{\n\tstruct sock *sk = asoc->base.sk;\n\n\tif (!sctp_style(sk, UDP))\n\t\tsk->sk_err = error;\n}\n\n/* Helper function to generate an association change event */\nstatic void sctp_cmd_assoc_change(sctp_cmd_seq_t *commands,\n\t\t\t\t struct sctp_association *asoc,\n\t\t\t\t u8 state)\n{\n\tstruct sctp_ulpevent *ev;\n\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, state, 0,\n\t\t\t\t\t    asoc->c.sinit_num_ostreams,\n\t\t\t\t\t    asoc->c.sinit_max_instreams,\n\t\t\t\t\t    NULL, GFP_ATOMIC);\n\tif (ev)\n\t\tsctp_ulpq_tail_event(&asoc->ulpq, ev);\n}\n\n/* Helper function to generate an adaptation indication event */\nstatic void sctp_cmd_adaptation_ind(sctp_cmd_seq_t *commands,\n\t\t\t\t    struct sctp_association *asoc)\n{\n\tstruct sctp_ulpevent *ev;\n\n\tev = sctp_ulpevent_make_adaptation_indication(asoc, GFP_ATOMIC);\n\n\tif (ev)\n\t\tsctp_ulpq_tail_event(&asoc->ulpq, ev);\n}\n\n\nstatic void sctp_cmd_t1_timer_update(struct sctp_association *asoc,\n\t\t\t\t    sctp_event_timeout_t timer,\n\t\t\t\t    char *name)\n{\n\tstruct sctp_transport *t;\n\n\tt = asoc->init_last_sent_to;\n\tasoc->init_err_counter++;\n\n\tif (t->init_sent_count > (asoc->init_cycle + 1)) {\n\t\tasoc->timeouts[timer] *= 2;\n\t\tif (asoc->timeouts[timer] > asoc->max_init_timeo) {\n\t\t\tasoc->timeouts[timer] = asoc->max_init_timeo;\n\t\t}\n\t\tasoc->init_cycle++;\n\n\t\tpr_debug(\"%s: T1[%s] timeout adjustment init_err_counter:%d\"\n\t\t\t \" cycle:%d timeout:%ld\\n\", __func__, name,\n\t\t\t asoc->init_err_counter, asoc->init_cycle,\n\t\t\t asoc->timeouts[timer]);\n\t}\n\n}\n\n/* Send the whole message, chunk by chunk, to the outqueue.\n * This way the whole message is queued up and bundling if\n * encouraged for small fragments.\n */\nstatic int sctp_cmd_send_msg(struct sctp_association *asoc,\n\t\t\t\tstruct sctp_datamsg *msg)\n{\n\tstruct sctp_chunk *chunk;\n\tint error = 0;\n\n\tlist_for_each_entry(chunk, &msg->chunks, frag_list) {\n\t\terror = sctp_outq_tail(&asoc->outqueue, chunk);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}\n\n\n/* Sent the next ASCONF packet currently stored in the association.\n * This happens after the ASCONF_ACK was succeffully processed.\n */\nstatic void sctp_cmd_send_asconf(struct sctp_association *asoc)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\n\t/* Send the next asconf chunk from the addip chunk\n\t * queue.\n\t */\n\tif (!list_empty(&asoc->addip_chunk_list)) {\n\t\tstruct list_head *entry = asoc->addip_chunk_list.next;\n\t\tstruct sctp_chunk *asconf = list_entry(entry,\n\t\t\t\t\t\tstruct sctp_chunk, list);\n\t\tlist_del_init(entry);\n\n\t\t/* Hold the chunk until an ASCONF_ACK is received. */\n\t\tsctp_chunk_hold(asconf);\n\t\tif (sctp_primitive_ASCONF(net, asoc, asconf))\n\t\t\tsctp_chunk_free(asconf);\n\t\telse\n\t\t\tasoc->addip_last_asconf = asconf;\n\t}\n}\n\n\n/* These three macros allow us to pull the debugging code out of the\n * main flow of sctp_do_sm() to keep attention focused on the real\n * functionality there.\n */\n#define debug_pre_sfn() \\\n\tpr_debug(\"%s[pre-fn]: ep:%p, %s, %s, asoc:%p[%s], %s\\n\", __func__, \\\n\t\t ep, sctp_evttype_tbl[event_type], (*debug_fn)(subtype),   \\\n\t\t asoc, sctp_state_tbl[state], state_fn->name)\n\n#define debug_post_sfn() \\\n\tpr_debug(\"%s[post-fn]: asoc:%p, status:%s\\n\", __func__, asoc, \\\n\t\t sctp_status_tbl[status])\n\n#define debug_post_sfx() \\\n\tpr_debug(\"%s[post-sfx]: error:%d, asoc:%p[%s]\\n\", __func__, error, \\\n\t\t asoc, sctp_state_tbl[(asoc && sctp_id2assoc(ep->base.sk, \\\n\t\t sctp_assoc2id(asoc))) ? asoc->state : SCTP_STATE_CLOSED])\n\n/*\n * This is the master state machine processing function.\n *\n * If you want to understand all of lksctp, this is a\n * good place to start.\n */\nint sctp_do_sm(struct net *net, sctp_event_t event_type, sctp_subtype_t subtype,\n\t       sctp_state_t state,\n\t       struct sctp_endpoint *ep,\n\t       struct sctp_association *asoc,\n\t       void *event_arg,\n\t       gfp_t gfp)\n{\n\tsctp_cmd_seq_t commands;\n\tconst sctp_sm_table_entry_t *state_fn;\n\tsctp_disposition_t status;\n\tint error = 0;\n\ttypedef const char *(printfn_t)(sctp_subtype_t);\n\tstatic printfn_t *table[] = {\n\t\tNULL, sctp_cname, sctp_tname, sctp_oname, sctp_pname,\n\t};\n\tprintfn_t *debug_fn  __attribute__ ((unused)) = table[event_type];\n\n\t/* Look up the state function, run it, and then process the\n\t * side effects.  These three steps are the heart of lksctp.\n\t */\n\tstate_fn = sctp_sm_lookup_event(net, event_type, state, subtype);\n\n\tsctp_init_cmd_seq(&commands);\n\n\tdebug_pre_sfn();\n\tstatus = state_fn->fn(net, ep, asoc, subtype, event_arg, &commands);\n\tdebug_post_sfn();\n\n\terror = sctp_side_effects(event_type, subtype, state,\n\t\t\t\t  ep, asoc, event_arg, status,\n\t\t\t\t  &commands, gfp);\n\tdebug_post_sfx();\n\n\treturn error;\n}\n\n/*****************************************************************\n * This the master state function side effect processing function.\n *****************************************************************/\nstatic int sctp_side_effects(sctp_event_t event_type, sctp_subtype_t subtype,\n\t\t\t     sctp_state_t state,\n\t\t\t     struct sctp_endpoint *ep,\n\t\t\t     struct sctp_association *asoc,\n\t\t\t     void *event_arg,\n\t\t\t     sctp_disposition_t status,\n\t\t\t     sctp_cmd_seq_t *commands,\n\t\t\t     gfp_t gfp)\n{\n\tint error;\n\n\t/* FIXME - Most of the dispositions left today would be categorized\n\t * as \"exceptional\" dispositions.  For those dispositions, it\n\t * may not be proper to run through any of the commands at all.\n\t * For example, the command interpreter might be run only with\n\t * disposition SCTP_DISPOSITION_CONSUME.\n\t */\n\tif (0 != (error = sctp_cmd_interpreter(event_type, subtype, state,\n\t\t\t\t\t       ep, asoc,\n\t\t\t\t\t       event_arg, status,\n\t\t\t\t\t       commands, gfp)))\n\t\tgoto bail;\n\n\tswitch (status) {\n\tcase SCTP_DISPOSITION_DISCARD:\n\t\tpr_debug(\"%s: ignored sctp protocol event - state:%d, \"\n\t\t\t \"event_type:%d, event_id:%d\\n\", __func__, state,\n\t\t\t event_type, subtype.chunk);\n\t\tbreak;\n\n\tcase SCTP_DISPOSITION_NOMEM:\n\t\t/* We ran out of memory, so we need to discard this\n\t\t * packet.\n\t\t */\n\t\t/* BUG--we should now recover some memory, probably by\n\t\t * reneging...\n\t\t */\n\t\terror = -ENOMEM;\n\t\tbreak;\n\n\tcase SCTP_DISPOSITION_DELETE_TCB:\n\t\t/* This should now be a command. */\n\t\tbreak;\n\n\tcase SCTP_DISPOSITION_CONSUME:\n\tcase SCTP_DISPOSITION_ABORT:\n\t\t/*\n\t\t * We should no longer have much work to do here as the\n\t\t * real work has been done as explicit commands above.\n\t\t */\n\t\tbreak;\n\n\tcase SCTP_DISPOSITION_VIOLATION:\n\t\tnet_err_ratelimited(\"protocol violation state %d chunkid %d\\n\",\n\t\t\t\t    state, subtype.chunk);\n\t\tbreak;\n\n\tcase SCTP_DISPOSITION_NOT_IMPL:\n\t\tpr_warn(\"unimplemented feature in state %d, event_type %d, event_id %d\\n\",\n\t\t\tstate, event_type, subtype.chunk);\n\t\tbreak;\n\n\tcase SCTP_DISPOSITION_BUG:\n\t\tpr_err(\"bug in state %d, event_type %d, event_id %d\\n\",\n\t\t       state, event_type, subtype.chunk);\n\t\tBUG();\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"impossible disposition %d in state %d, event_type %d, event_id %d\\n\",\n\t\t       status, state, event_type, subtype.chunk);\n\t\tBUG();\n\t\tbreak;\n\t}\n\nbail:\n\treturn error;\n}\n\n/********************************************************************\n * 2nd Level Abstractions\n ********************************************************************/\n\n/* This is the side-effect interpreter.  */\nstatic int sctp_cmd_interpreter(sctp_event_t event_type,\n\t\t\t\tsctp_subtype_t subtype,\n\t\t\t\tsctp_state_t state,\n\t\t\t\tstruct sctp_endpoint *ep,\n\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\tvoid *event_arg,\n\t\t\t\tsctp_disposition_t status,\n\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\tgfp_t gfp)\n{\n\tint error = 0;\n\tint force;\n\tsctp_cmd_t *cmd;\n\tstruct sctp_chunk *new_obj;\n\tstruct sctp_chunk *chunk = NULL;\n\tstruct sctp_packet *packet;\n\tstruct timer_list *timer;\n\tunsigned long timeout;\n\tstruct sctp_transport *t;\n\tstruct sctp_sackhdr sackh;\n\tint local_cork = 0;\n\n\tif (SCTP_EVENT_T_TIMEOUT != event_type)\n\t\tchunk = event_arg;\n\n\t/* Note:  This whole file is a huge candidate for rework.\n\t * For example, each command could either have its own handler, so\n\t * the loop would look like:\n\t *     while (cmds)\n\t *         cmd->handle(x, y, z)\n\t * --jgrimm\n\t */\n\twhile (NULL != (cmd = sctp_next_cmd(commands))) {\n\t\tswitch (cmd->verb) {\n\t\tcase SCTP_CMD_NOP:\n\t\t\t/* Do nothing. */\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_NEW_ASOC:\n\t\t\t/* Register a new association.  */\n\t\t\tif (local_cork) {\n\t\t\t\tsctp_outq_uncork(&asoc->outqueue);\n\t\t\t\tlocal_cork = 0;\n\t\t\t}\n\n\t\t\t/* Register with the endpoint.  */\n\t\t\tasoc = cmd->obj.asoc;\n\t\t\tBUG_ON(asoc->peer.primary_path == NULL);\n\t\t\tsctp_endpoint_add_asoc(ep, asoc);\n\t\t\tsctp_hash_established(asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_UPDATE_ASSOC:\n\t\t       sctp_assoc_update(asoc, cmd->obj.asoc);\n\t\t       break;\n\n\t\tcase SCTP_CMD_PURGE_OUTQUEUE:\n\t\t       sctp_outq_teardown(&asoc->outqueue);\n\t\t       break;\n\n\t\tcase SCTP_CMD_DELETE_TCB:\n\t\t\tif (local_cork) {\n\t\t\t\tsctp_outq_uncork(&asoc->outqueue);\n\t\t\t\tlocal_cork = 0;\n\t\t\t}\n\t\t\t/* Delete the current association.  */\n\t\t\tsctp_cmd_delete_tcb(commands, asoc);\n\t\t\tasoc = NULL;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_NEW_STATE:\n\t\t\t/* Enter a new state.  */\n\t\t\tsctp_cmd_new_state(commands, asoc, cmd->obj.state);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_TSN:\n\t\t\t/* Record the arrival of a TSN.  */\n\t\t\terror = sctp_tsnmap_mark(&asoc->peer.tsn_map,\n\t\t\t\t\t\t cmd->obj.u32, NULL);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_FWDTSN:\n\t\t\t/* Move the Cumulattive TSN Ack ahead. */\n\t\t\tsctp_tsnmap_skip(&asoc->peer.tsn_map, cmd->obj.u32);\n\n\t\t\t/* purge the fragmentation queue */\n\t\t\tsctp_ulpq_reasm_flushtsn(&asoc->ulpq, cmd->obj.u32);\n\n\t\t\t/* Abort any in progress partial delivery. */\n\t\t\tsctp_ulpq_abort_pd(&asoc->ulpq, GFP_ATOMIC);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PROCESS_FWDTSN:\n\t\t\tsctp_cmd_process_fwdtsn(&asoc->ulpq, cmd->obj.chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_GEN_SACK:\n\t\t\t/* Generate a Selective ACK.\n\t\t\t * The argument tells us whether to just count\n\t\t\t * the packet and MAYBE generate a SACK, or\n\t\t\t * force a SACK out.\n\t\t\t */\n\t\t\tforce = cmd->obj.i32;\n\t\t\terror = sctp_gen_sack(asoc, force, commands);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PROCESS_SACK:\n\t\t\t/* Process an inbound SACK.  */\n\t\t\terror = sctp_cmd_process_sack(commands, asoc,\n\t\t\t\t\t\t      cmd->obj.chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_GEN_INIT_ACK:\n\t\t\t/* Generate an INIT ACK chunk.  */\n\t\t\tnew_obj = sctp_make_init_ack(asoc, chunk, GFP_ATOMIC,\n\t\t\t\t\t\t     0);\n\t\t\tif (!new_obj)\n\t\t\t\tgoto nomem;\n\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(new_obj));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PEER_INIT:\n\t\t\t/* Process a unified INIT from the peer.\n\t\t\t * Note: Only used during INIT-ACK processing.  If\n\t\t\t * there is an error just return to the outter\n\t\t\t * layer which will bail.\n\t\t\t */\n\t\t\terror = sctp_cmd_process_init(commands, asoc, chunk,\n\t\t\t\t\t\t      cmd->obj.init, gfp);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_GEN_COOKIE_ECHO:\n\t\t\t/* Generate a COOKIE ECHO chunk.  */\n\t\t\tnew_obj = sctp_make_cookie_echo(asoc, chunk);\n\t\t\tif (!new_obj) {\n\t\t\t\tif (cmd->obj.chunk)\n\t\t\t\t\tsctp_chunk_free(cmd->obj.chunk);\n\t\t\t\tgoto nomem;\n\t\t\t}\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(new_obj));\n\n\t\t\t/* If there is an ERROR chunk to be sent along with\n\t\t\t * the COOKIE_ECHO, send it, too.\n\t\t\t */\n\t\t\tif (cmd->obj.chunk)\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\t\tSCTP_CHUNK(cmd->obj.chunk));\n\n\t\t\tif (new_obj->transport) {\n\t\t\t\tnew_obj->transport->init_sent_count++;\n\t\t\t\tasoc->init_last_sent_to = new_obj->transport;\n\t\t\t}\n\n\t\t\t/* FIXME - Eventually come up with a cleaner way to\n\t\t\t * enabling COOKIE-ECHO + DATA bundling during\n\t\t\t * multihoming stale cookie scenarios, the following\n\t\t\t * command plays with asoc->peer.retran_path to\n\t\t\t * avoid the problem of sending the COOKIE-ECHO and\n\t\t\t * DATA in different paths, which could result\n\t\t\t * in the association being ABORTed if the DATA chunk\n\t\t\t * is processed first by the server.  Checking the\n\t\t\t * init error counter simply causes this command\n\t\t\t * to be executed only during failed attempts of\n\t\t\t * association establishment.\n\t\t\t */\n\t\t\tif ((asoc->peer.retran_path !=\n\t\t\t     asoc->peer.primary_path) &&\n\t\t\t    (asoc->init_err_counter > 0)) {\n\t\t\t\tsctp_add_cmd_sf(commands,\n\t\t\t\t\t\tSCTP_CMD_FORCE_PRIM_RETRAN,\n\t\t\t\t\t\tSCTP_NULL());\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_GEN_SHUTDOWN:\n\t\t\t/* Generate SHUTDOWN when in SHUTDOWN_SENT state.\n\t\t\t * Reset error counts.\n\t\t\t */\n\t\t\tasoc->overall_error_count = 0;\n\n\t\t\t/* Generate a SHUTDOWN chunk.  */\n\t\t\tnew_obj = sctp_make_shutdown(asoc, chunk);\n\t\t\tif (!new_obj)\n\t\t\t\tgoto nomem;\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(new_obj));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_CHUNK_ULP:\n\t\t\t/* Send a chunk to the sockets layer.  */\n\t\t\tpr_debug(\"%s: sm_sideff: chunk_up:%p, ulpq:%p\\n\",\n\t\t\t\t __func__, cmd->obj.chunk, &asoc->ulpq);\n\n\t\t\tsctp_ulpq_tail_data(&asoc->ulpq, cmd->obj.chunk,\n\t\t\t\t\t    GFP_ATOMIC);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_EVENT_ULP:\n\t\t\t/* Send a notification to the sockets layer.  */\n\t\t\tpr_debug(\"%s: sm_sideff: event_up:%p, ulpq:%p\\n\",\n\t\t\t\t __func__, cmd->obj.ulpevent, &asoc->ulpq);\n\n\t\t\tsctp_ulpq_tail_event(&asoc->ulpq, cmd->obj.ulpevent);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPLY:\n\t\t\t/* If an caller has not already corked, do cork. */\n\t\t\tif (!asoc->outqueue.cork) {\n\t\t\t\tsctp_outq_cork(&asoc->outqueue);\n\t\t\t\tlocal_cork = 1;\n\t\t\t}\n\t\t\t/* Send a chunk to our peer.  */\n\t\t\terror = sctp_outq_tail(&asoc->outqueue, cmd->obj.chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_SEND_PKT:\n\t\t\t/* Send a full packet to our peer.  */\n\t\t\tpacket = cmd->obj.packet;\n\t\t\tsctp_packet_transmit(packet);\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_T1_RETRAN:\n\t\t\t/* Mark a transport for retransmission.  */\n\t\t\tsctp_retransmit(&asoc->outqueue, cmd->obj.transport,\n\t\t\t\t\tSCTP_RTXR_T1_RTX);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_RETRAN:\n\t\t\t/* Mark a transport for retransmission.  */\n\t\t\tsctp_retransmit(&asoc->outqueue, cmd->obj.transport,\n\t\t\t\t\tSCTP_RTXR_T3_RTX);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ECN_CE:\n\t\t\t/* Do delayed CE processing.   */\n\t\t\tsctp_do_ecn_ce_work(asoc, cmd->obj.u32);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ECN_ECNE:\n\t\t\t/* Do delayed ECNE processing. */\n\t\t\tnew_obj = sctp_do_ecn_ecne_work(asoc, cmd->obj.u32,\n\t\t\t\t\t\t\tchunk);\n\t\t\tif (new_obj)\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\t\tSCTP_CHUNK(new_obj));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ECN_CWR:\n\t\t\t/* Do delayed CWR processing.  */\n\t\t\tsctp_do_ecn_cwr_work(asoc, cmd->obj.u32);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_SETUP_T2:\n\t\t\tsctp_cmd_setup_t2(commands, asoc, cmd->obj.chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TIMER_START_ONCE:\n\t\t\ttimer = &asoc->timers[cmd->obj.to];\n\n\t\t\tif (timer_pending(timer))\n\t\t\t\tbreak;\n\t\t\t/* fall through */\n\n\t\tcase SCTP_CMD_TIMER_START:\n\t\t\ttimer = &asoc->timers[cmd->obj.to];\n\t\t\ttimeout = asoc->timeouts[cmd->obj.to];\n\t\t\tBUG_ON(!timeout);\n\n\t\t\ttimer->expires = jiffies + timeout;\n\t\t\tsctp_association_hold(asoc);\n\t\t\tadd_timer(timer);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TIMER_RESTART:\n\t\t\ttimer = &asoc->timers[cmd->obj.to];\n\t\t\ttimeout = asoc->timeouts[cmd->obj.to];\n\t\t\tif (!mod_timer(timer, jiffies + timeout))\n\t\t\t\tsctp_association_hold(asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TIMER_STOP:\n\t\t\ttimer = &asoc->timers[cmd->obj.to];\n\t\t\tif (del_timer(timer))\n\t\t\t\tsctp_association_put(asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_CHOOSE_TRANSPORT:\n\t\t\tchunk = cmd->obj.chunk;\n\t\t\tt = sctp_assoc_choose_alter_transport(asoc,\n\t\t\t\t\t\tasoc->init_last_sent_to);\n\t\t\tasoc->init_last_sent_to = t;\n\t\t\tchunk->transport = t;\n\t\t\tt->init_sent_count++;\n\t\t\t/* Set the new transport as primary */\n\t\t\tsctp_assoc_set_primary(asoc, t);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_RESTART:\n\t\t\t/* Do the needed accounting and updates\n\t\t\t * associated with restarting an initialization\n\t\t\t * timer. Only multiply the timeout by two if\n\t\t\t * all transports have been tried at the current\n\t\t\t * timeout.\n\t\t\t */\n\t\t\tsctp_cmd_t1_timer_update(asoc,\n\t\t\t\t\t\tSCTP_EVENT_TIMEOUT_T1_INIT,\n\t\t\t\t\t\t\"INIT\");\n\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_COOKIEECHO_RESTART:\n\t\t\t/* Do the needed accounting and updates\n\t\t\t * associated with restarting an initialization\n\t\t\t * timer. Only multiply the timeout by two if\n\t\t\t * all transports have been tried at the current\n\t\t\t * timeout.\n\t\t\t */\n\t\t\tsctp_cmd_t1_timer_update(asoc,\n\t\t\t\t\t\tSCTP_EVENT_TIMEOUT_T1_COOKIE,\n\t\t\t\t\t\t\"COOKIE\");\n\n\t\t\t/* If we've sent any data bundled with\n\t\t\t * COOKIE-ECHO we need to resend.\n\t\t\t */\n\t\t\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\t\t\ttransports) {\n\t\t\t\tsctp_retransmit_mark(&asoc->outqueue, t,\n\t\t\t\t\t    SCTP_RTXR_T1_RTX);\n\t\t\t}\n\n\t\t\tsctp_add_cmd_sf(commands,\n\t\t\t\t\tSCTP_CMD_TIMER_RESTART,\n\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_FAILED:\n\t\t\tsctp_cmd_init_failed(commands, asoc, cmd->obj.err);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ASSOC_FAILED:\n\t\t\tsctp_cmd_assoc_failed(commands, asoc, event_type,\n\t\t\t\t\t      subtype, chunk, cmd->obj.err);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_COUNTER_INC:\n\t\t\tasoc->init_err_counter++;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_COUNTER_RESET:\n\t\t\tasoc->init_err_counter = 0;\n\t\t\tasoc->init_cycle = 0;\n\t\t\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\t\t\t    transports) {\n\t\t\t\tt->init_sent_count = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_DUP:\n\t\t\tsctp_tsnmap_mark_dup(&asoc->peer.tsn_map,\n\t\t\t\t\t     cmd->obj.u32);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_BAD_TAG:\n\t\t\tpr_debug(\"%s: vtag mismatch!\\n\", __func__);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_STRIKE:\n\t\t\t/* Mark one strike against a transport.  */\n\t\t\tsctp_do_8_2_transport_strike(commands, asoc,\n\t\t\t\t\t\t    cmd->obj.transport, 0);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TRANSPORT_IDLE:\n\t\t\tt = cmd->obj.transport;\n\t\t\tsctp_transport_lower_cwnd(t, SCTP_LOWER_CWND_INACTIVE);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TRANSPORT_HB_SENT:\n\t\t\tt = cmd->obj.transport;\n\t\t\tsctp_do_8_2_transport_strike(commands, asoc,\n\t\t\t\t\t\t     t, 1);\n\t\t\tt->hb_sent = 1;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TRANSPORT_ON:\n\t\t\tt = cmd->obj.transport;\n\t\t\tsctp_cmd_transport_on(commands, asoc, t, chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_HB_TIMERS_START:\n\t\t\tsctp_cmd_hb_timers_start(commands, asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_HB_TIMER_UPDATE:\n\t\t\tt = cmd->obj.transport;\n\t\t\tsctp_cmd_hb_timer_update(commands, t);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_HB_TIMERS_STOP:\n\t\t\tsctp_cmd_hb_timers_stop(commands, asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_ERROR:\n\t\t\terror = cmd->obj.error;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PROCESS_CTSN:\n\t\t\t/* Dummy up a SACK for processing. */\n\t\t\tsackh.cum_tsn_ack = cmd->obj.be32;\n\t\t\tsackh.a_rwnd = asoc->peer.rwnd +\n\t\t\t\t\tasoc->outqueue.outstanding_bytes;\n\t\t\tsackh.num_gap_ack_blocks = 0;\n\t\t\tsackh.num_dup_tsns = 0;\n\t\t\tchunk->subh.sack_hdr = &sackh;\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_SACK,\n\t\t\t\t\tSCTP_CHUNK(chunk));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_DISCARD_PACKET:\n\t\t\t/* We need to discard the whole packet.\n\t\t\t * Uncork the queue since there might be\n\t\t\t * responses pending\n\t\t\t */\n\t\t\tchunk->pdiscard = 1;\n\t\t\tif (asoc) {\n\t\t\t\tsctp_outq_uncork(&asoc->outqueue);\n\t\t\t\tlocal_cork = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_RTO_PENDING:\n\t\t\tt = cmd->obj.transport;\n\t\t\tt->rto_pending = 1;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PART_DELIVER:\n\t\t\tsctp_ulpq_partial_delivery(&asoc->ulpq, GFP_ATOMIC);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_RENEGE:\n\t\t\tsctp_ulpq_renege(&asoc->ulpq, cmd->obj.chunk,\n\t\t\t\t\t GFP_ATOMIC);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_SETUP_T4:\n\t\t\tsctp_cmd_setup_t4(commands, asoc, cmd->obj.chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PROCESS_OPERR:\n\t\t\tsctp_cmd_process_operr(commands, asoc, chunk);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_CLEAR_INIT_TAG:\n\t\t\tasoc->peer.i.init_tag = 0;\n\t\t\tbreak;\n\t\tcase SCTP_CMD_DEL_NON_PRIMARY:\n\t\t\tsctp_cmd_del_non_primary(asoc);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_T3_RTX_TIMERS_STOP:\n\t\t\tsctp_cmd_t3_rtx_timers_stop(commands, asoc);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_FORCE_PRIM_RETRAN:\n\t\t\tt = asoc->peer.retran_path;\n\t\t\tasoc->peer.retran_path = asoc->peer.primary_path;\n\t\t\terror = sctp_outq_uncork(&asoc->outqueue);\n\t\t\tlocal_cork = 0;\n\t\t\tasoc->peer.retran_path = t;\n\t\t\tbreak;\n\t\tcase SCTP_CMD_SET_SK_ERR:\n\t\t\tsctp_cmd_set_sk_err(asoc, cmd->obj.error);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_ASSOC_CHANGE:\n\t\t\tsctp_cmd_assoc_change(commands, asoc,\n\t\t\t\t\t      cmd->obj.u8);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_ADAPTATION_IND:\n\t\t\tsctp_cmd_adaptation_ind(commands, asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ASSOC_SHKEY:\n\t\t\terror = sctp_auth_asoc_init_active_key(asoc,\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_UPDATE_INITTAG:\n\t\t\tasoc->peer.i.init_tag = cmd->obj.u32;\n\t\t\tbreak;\n\t\tcase SCTP_CMD_SEND_MSG:\n\t\t\tif (!asoc->outqueue.cork) {\n\t\t\t\tsctp_outq_cork(&asoc->outqueue);\n\t\t\t\tlocal_cork = 1;\n\t\t\t}\n\t\t\terror = sctp_cmd_send_msg(asoc, cmd->obj.msg);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_SEND_NEXT_ASCONF:\n\t\t\tsctp_cmd_send_asconf(asoc);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_PURGE_ASCONF_QUEUE:\n\t\t\tsctp_asconf_queue_teardown(asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_SET_ASOC:\n\t\t\tasoc = cmd->obj.asoc;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_warn(\"Impossible command: %u\\n\",\n\t\t\t\tcmd->verb);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\nout:\n\t/* If this is in response to a received chunk, wait until\n\t * we are done with the packet to open the queue so that we don't\n\t * send multiple packets in response to a single request.\n\t */\n\tif (asoc && SCTP_EVENT_T_CHUNK == event_type && chunk) {\n\t\tif (chunk->end_of_packet || chunk->singleton)\n\t\t\terror = sctp_outq_uncork(&asoc->outqueue);\n\t} else if (local_cork)\n\t\terror = sctp_outq_uncork(&asoc->outqueue);\n\treturn error;\nnomem:\n\terror = -ENOMEM;\n\tgoto out;\n}\n\n"], "filenames": ["net/sctp/sm_sideeffect.c"], "buggy_code_start_loc": [247], "buggy_code_end_loc": [431], "fixing_code_start_loc": [247], "fixing_code_end_loc": [435], "type": "CWE-362", "message": "net/sctp/sm_sideeffect.c in the Linux kernel before 4.3 does not properly manage the relationship between a lock and a socket, which allows local users to cause a denial of service (deadlock) via a crafted sctp_accept call.", "other": {"cve": {"id": "CVE-2015-8767", "sourceIdentifier": "cve@mitre.org", "published": "2016-02-08T03:59:06.793", "lastModified": "2018-08-30T16:53:05.867", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "net/sctp/sm_sideeffect.c in the Linux kernel before 4.3 does not properly manage the relationship between a lock and a socket, which allows local users to cause a denial of service (deadlock) via a crafted sctp_accept call."}, {"lang": "es", "value": "net/sctp/sm_sideeffect.c en el kernel de Linux en versiones anteriores a 4.3 no maneja adecuadamente la relaci\u00f3n entre un bloqueo y un socket, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (interbloqueo) a trav\u00e9s de una llamada sctp_accept manipulada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.3", "matchCriteriaId": "24716AE4-6BBB-4E20-B9CC-8D2D43014BBD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B6B7CAD7-9D4E-4FDB-88E3-1E583210A01F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:15.10:*:*:*:*:*:*:*", "matchCriteriaId": "E88A537F-F4D0-46B9-9E37-965233C2A355"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=635682a14427d241bab7bbdeebb48a7d7b91638e", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2016-February/176484.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-03/msg00094.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00015.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00045.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00038.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-0715.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2016/dsa-3448", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2016/dsa-3503", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/01/11/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinapr2016-2952096.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinjul2016-3090544.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/80268", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2930-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2930-2", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2930-3", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2931-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2932-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2967-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2967-2", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2016:1277", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2016:1301", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2016:1341", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1297389", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/635682a14427d241bab7bbdeebb48a7d7b91638e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/635682a14427d241bab7bbdeebb48a7d7b91638e"}}