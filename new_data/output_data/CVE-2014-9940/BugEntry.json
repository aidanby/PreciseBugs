{"buggy_code": ["/*\n * core.c  --  Voltage/Current Regulator framework.\n *\n * Copyright 2007, 2008 Wolfson Microelectronics PLC.\n * Copyright 2008 SlimLogic Ltd.\n *\n * Author: Liam Girdwood <lrg@slimlogic.co.uk>\n *\n *  This program is free software; you can redistribute  it and/or modify it\n *  under  the terms of  the GNU General  Public License as published by the\n *  Free Software Foundation;  either version 2 of the  License, or (at your\n *  option) any later version.\n *\n */\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/async.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/suspend.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/module.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/regulator.h>\n\n#include \"dummy.h\"\n#include \"internal.h\"\n\n#define rdev_crit(rdev, fmt, ...)\t\t\t\t\t\\\n\tpr_crit(\"%s: \" fmt, rdev_get_name(rdev), ##__VA_ARGS__)\n#define rdev_err(rdev, fmt, ...)\t\t\t\t\t\\\n\tpr_err(\"%s: \" fmt, rdev_get_name(rdev), ##__VA_ARGS__)\n#define rdev_warn(rdev, fmt, ...)\t\t\t\t\t\\\n\tpr_warn(\"%s: \" fmt, rdev_get_name(rdev), ##__VA_ARGS__)\n#define rdev_info(rdev, fmt, ...)\t\t\t\t\t\\\n\tpr_info(\"%s: \" fmt, rdev_get_name(rdev), ##__VA_ARGS__)\n#define rdev_dbg(rdev, fmt, ...)\t\t\t\t\t\\\n\tpr_debug(\"%s: \" fmt, rdev_get_name(rdev), ##__VA_ARGS__)\n\nstatic DEFINE_MUTEX(regulator_list_mutex);\nstatic LIST_HEAD(regulator_list);\nstatic LIST_HEAD(regulator_map_list);\nstatic LIST_HEAD(regulator_ena_gpio_list);\nstatic LIST_HEAD(regulator_supply_alias_list);\nstatic bool has_full_constraints;\n\nstatic struct dentry *debugfs_root;\n\n/*\n * struct regulator_map\n *\n * Used to provide symbolic supply names to devices.\n */\nstruct regulator_map {\n\tstruct list_head list;\n\tconst char *dev_name;   /* The dev_name() for the consumer */\n\tconst char *supply;\n\tstruct regulator_dev *regulator;\n};\n\n/*\n * struct regulator_enable_gpio\n *\n * Management for shared enable GPIO pin\n */\nstruct regulator_enable_gpio {\n\tstruct list_head list;\n\tstruct gpio_desc *gpiod;\n\tu32 enable_count;\t/* a number of enabled shared GPIO */\n\tu32 request_count;\t/* a number of requested shared GPIO */\n\tunsigned int ena_gpio_invert:1;\n};\n\n/*\n * struct regulator_supply_alias\n *\n * Used to map lookups for a supply onto an alternative device.\n */\nstruct regulator_supply_alias {\n\tstruct list_head list;\n\tstruct device *src_dev;\n\tconst char *src_supply;\n\tstruct device *alias_dev;\n\tconst char *alias_supply;\n};\n\nstatic int _regulator_is_enabled(struct regulator_dev *rdev);\nstatic int _regulator_disable(struct regulator_dev *rdev);\nstatic int _regulator_get_voltage(struct regulator_dev *rdev);\nstatic int _regulator_get_current_limit(struct regulator_dev *rdev);\nstatic unsigned int _regulator_get_mode(struct regulator_dev *rdev);\nstatic int _notifier_call_chain(struct regulator_dev *rdev,\n\t\t\t\t  unsigned long event, void *data);\nstatic int _regulator_do_set_voltage(struct regulator_dev *rdev,\n\t\t\t\t     int min_uV, int max_uV);\nstatic struct regulator *create_regulator(struct regulator_dev *rdev,\n\t\t\t\t\t  struct device *dev,\n\t\t\t\t\t  const char *supply_name);\n\nstatic const char *rdev_get_name(struct regulator_dev *rdev)\n{\n\tif (rdev->constraints && rdev->constraints->name)\n\t\treturn rdev->constraints->name;\n\telse if (rdev->desc->name)\n\t\treturn rdev->desc->name;\n\telse\n\t\treturn \"\";\n}\n\nstatic bool have_full_constraints(void)\n{\n\treturn has_full_constraints || of_have_populated_dt();\n}\n\n/**\n * of_get_regulator - get a regulator device node based on supply name\n * @dev: Device pointer for the consumer (of regulator) device\n * @supply: regulator supply name\n *\n * Extract the regulator device node corresponding to the supply name.\n * returns the device node corresponding to the regulator if found, else\n * returns NULL.\n */\nstatic struct device_node *of_get_regulator(struct device *dev, const char *supply)\n{\n\tstruct device_node *regnode = NULL;\n\tchar prop_name[32]; /* 32 is max size of property name */\n\n\tdev_dbg(dev, \"Looking up %s-supply from device tree\\n\", supply);\n\n\tsnprintf(prop_name, 32, \"%s-supply\", supply);\n\tregnode = of_parse_phandle(dev->of_node, prop_name, 0);\n\n\tif (!regnode) {\n\t\tdev_dbg(dev, \"Looking up %s property in node %s failed\",\n\t\t\t\tprop_name, dev->of_node->full_name);\n\t\treturn NULL;\n\t}\n\treturn regnode;\n}\n\nstatic int _regulator_can_change_status(struct regulator_dev *rdev)\n{\n\tif (!rdev->constraints)\n\t\treturn 0;\n\n\tif (rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_STATUS)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n/* Platform voltage constraint check */\nstatic int regulator_check_voltage(struct regulator_dev *rdev,\n\t\t\t\t   int *min_uV, int *max_uV)\n{\n\tBUG_ON(*min_uV > *max_uV);\n\n\tif (!rdev->constraints) {\n\t\trdev_err(rdev, \"no constraints\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {\n\t\trdev_err(rdev, \"operation not allowed\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (*max_uV > rdev->constraints->max_uV)\n\t\t*max_uV = rdev->constraints->max_uV;\n\tif (*min_uV < rdev->constraints->min_uV)\n\t\t*min_uV = rdev->constraints->min_uV;\n\n\tif (*min_uV > *max_uV) {\n\t\trdev_err(rdev, \"unsupportable voltage range: %d-%duV\\n\",\n\t\t\t *min_uV, *max_uV);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* Make sure we select a voltage that suits the needs of all\n * regulator consumers\n */\nstatic int regulator_check_consumers(struct regulator_dev *rdev,\n\t\t\t\t     int *min_uV, int *max_uV)\n{\n\tstruct regulator *regulator;\n\n\tlist_for_each_entry(regulator, &rdev->consumer_list, list) {\n\t\t/*\n\t\t * Assume consumers that didn't say anything are OK\n\t\t * with anything in the constraint range.\n\t\t */\n\t\tif (!regulator->min_uV && !regulator->max_uV)\n\t\t\tcontinue;\n\n\t\tif (*max_uV > regulator->max_uV)\n\t\t\t*max_uV = regulator->max_uV;\n\t\tif (*min_uV < regulator->min_uV)\n\t\t\t*min_uV = regulator->min_uV;\n\t}\n\n\tif (*min_uV > *max_uV) {\n\t\trdev_err(rdev, \"Restricting voltage, %u-%uuV\\n\",\n\t\t\t*min_uV, *max_uV);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* current constraint check */\nstatic int regulator_check_current_limit(struct regulator_dev *rdev,\n\t\t\t\t\tint *min_uA, int *max_uA)\n{\n\tBUG_ON(*min_uA > *max_uA);\n\n\tif (!rdev->constraints) {\n\t\trdev_err(rdev, \"no constraints\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_CURRENT)) {\n\t\trdev_err(rdev, \"operation not allowed\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (*max_uA > rdev->constraints->max_uA)\n\t\t*max_uA = rdev->constraints->max_uA;\n\tif (*min_uA < rdev->constraints->min_uA)\n\t\t*min_uA = rdev->constraints->min_uA;\n\n\tif (*min_uA > *max_uA) {\n\t\trdev_err(rdev, \"unsupportable current range: %d-%duA\\n\",\n\t\t\t *min_uA, *max_uA);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* operating mode constraint check */\nstatic int regulator_mode_constrain(struct regulator_dev *rdev, int *mode)\n{\n\tswitch (*mode) {\n\tcase REGULATOR_MODE_FAST:\n\tcase REGULATOR_MODE_NORMAL:\n\tcase REGULATOR_MODE_IDLE:\n\tcase REGULATOR_MODE_STANDBY:\n\t\tbreak;\n\tdefault:\n\t\trdev_err(rdev, \"invalid mode %x specified\\n\", *mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->constraints) {\n\t\trdev_err(rdev, \"no constraints\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_MODE)) {\n\t\trdev_err(rdev, \"operation not allowed\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The modes are bitmasks, the most power hungry modes having\n\t * the lowest values. If the requested mode isn't supported\n\t * try higher modes. */\n\twhile (*mode) {\n\t\tif (rdev->constraints->valid_modes_mask & *mode)\n\t\t\treturn 0;\n\t\t*mode /= 2;\n\t}\n\n\treturn -EINVAL;\n}\n\n/* dynamic regulator mode switching constraint check */\nstatic int regulator_check_drms(struct regulator_dev *rdev)\n{\n\tif (!rdev->constraints) {\n\t\trdev_err(rdev, \"no constraints\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_DRMS)) {\n\t\trdev_err(rdev, \"operation not allowed\\n\");\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t regulator_uV_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\tssize_t ret;\n\n\tmutex_lock(&rdev->mutex);\n\tret = sprintf(buf, \"%d\\n\", _regulator_get_voltage(rdev));\n\tmutex_unlock(&rdev->mutex);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR(microvolts, 0444, regulator_uV_show, NULL);\n\nstatic ssize_t regulator_uA_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", _regulator_get_current_limit(rdev));\n}\nstatic DEVICE_ATTR(microamps, 0444, regulator_uA_show, NULL);\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", rdev_get_name(rdev));\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t regulator_print_opmode(char *buf, int mode)\n{\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\treturn sprintf(buf, \"fast\\n\");\n\tcase REGULATOR_MODE_NORMAL:\n\t\treturn sprintf(buf, \"normal\\n\");\n\tcase REGULATOR_MODE_IDLE:\n\t\treturn sprintf(buf, \"idle\\n\");\n\tcase REGULATOR_MODE_STANDBY:\n\t\treturn sprintf(buf, \"standby\\n\");\n\t}\n\treturn sprintf(buf, \"unknown\\n\");\n}\n\nstatic ssize_t regulator_opmode_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_opmode(buf, _regulator_get_mode(rdev));\n}\nstatic DEVICE_ATTR(opmode, 0444, regulator_opmode_show, NULL);\n\nstatic ssize_t regulator_print_state(char *buf, int state)\n{\n\tif (state > 0)\n\t\treturn sprintf(buf, \"enabled\\n\");\n\telse if (state == 0)\n\t\treturn sprintf(buf, \"disabled\\n\");\n\telse\n\t\treturn sprintf(buf, \"unknown\\n\");\n}\n\nstatic ssize_t regulator_state_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\tssize_t ret;\n\n\tmutex_lock(&rdev->mutex);\n\tret = regulator_print_state(buf, _regulator_is_enabled(rdev));\n\tmutex_unlock(&rdev->mutex);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR(state, 0444, regulator_state_show, NULL);\n\nstatic ssize_t regulator_status_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\tint status;\n\tchar *label;\n\n\tstatus = rdev->desc->ops->get_status(rdev);\n\tif (status < 0)\n\t\treturn status;\n\n\tswitch (status) {\n\tcase REGULATOR_STATUS_OFF:\n\t\tlabel = \"off\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_ON:\n\t\tlabel = \"on\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_ERROR:\n\t\tlabel = \"error\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_FAST:\n\t\tlabel = \"fast\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_NORMAL:\n\t\tlabel = \"normal\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_IDLE:\n\t\tlabel = \"idle\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_STANDBY:\n\t\tlabel = \"standby\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_BYPASS:\n\t\tlabel = \"bypass\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_UNDEFINED:\n\t\tlabel = \"undefined\";\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\treturn sprintf(buf, \"%s\\n\", label);\n}\nstatic DEVICE_ATTR(status, 0444, regulator_status_show, NULL);\n\nstatic ssize_t regulator_min_uA_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tif (!rdev->constraints)\n\t\treturn sprintf(buf, \"constraint not defined\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->min_uA);\n}\nstatic DEVICE_ATTR(min_microamps, 0444, regulator_min_uA_show, NULL);\n\nstatic ssize_t regulator_max_uA_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tif (!rdev->constraints)\n\t\treturn sprintf(buf, \"constraint not defined\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->max_uA);\n}\nstatic DEVICE_ATTR(max_microamps, 0444, regulator_max_uA_show, NULL);\n\nstatic ssize_t regulator_min_uV_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tif (!rdev->constraints)\n\t\treturn sprintf(buf, \"constraint not defined\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->min_uV);\n}\nstatic DEVICE_ATTR(min_microvolts, 0444, regulator_min_uV_show, NULL);\n\nstatic ssize_t regulator_max_uV_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tif (!rdev->constraints)\n\t\treturn sprintf(buf, \"constraint not defined\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->max_uV);\n}\nstatic DEVICE_ATTR(max_microvolts, 0444, regulator_max_uV_show, NULL);\n\nstatic ssize_t regulator_total_uA_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\tstruct regulator *regulator;\n\tint uA = 0;\n\n\tmutex_lock(&rdev->mutex);\n\tlist_for_each_entry(regulator, &rdev->consumer_list, list)\n\t\tuA += regulator->uA_load;\n\tmutex_unlock(&rdev->mutex);\n\treturn sprintf(buf, \"%d\\n\", uA);\n}\nstatic DEVICE_ATTR(requested_microamps, 0444, regulator_total_uA_show, NULL);\n\nstatic ssize_t num_users_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", rdev->use_count);\n}\nstatic DEVICE_ATTR_RO(num_users);\n\nstatic ssize_t type_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tswitch (rdev->desc->type) {\n\tcase REGULATOR_VOLTAGE:\n\t\treturn sprintf(buf, \"voltage\\n\");\n\tcase REGULATOR_CURRENT:\n\t\treturn sprintf(buf, \"current\\n\");\n\t}\n\treturn sprintf(buf, \"unknown\\n\");\n}\nstatic DEVICE_ATTR_RO(type);\n\nstatic ssize_t regulator_suspend_mem_uV_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->state_mem.uV);\n}\nstatic DEVICE_ATTR(suspend_mem_microvolts, 0444,\n\t\tregulator_suspend_mem_uV_show, NULL);\n\nstatic ssize_t regulator_suspend_disk_uV_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->state_disk.uV);\n}\nstatic DEVICE_ATTR(suspend_disk_microvolts, 0444,\n\t\tregulator_suspend_disk_uV_show, NULL);\n\nstatic ssize_t regulator_suspend_standby_uV_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->state_standby.uV);\n}\nstatic DEVICE_ATTR(suspend_standby_microvolts, 0444,\n\t\tregulator_suspend_standby_uV_show, NULL);\n\nstatic ssize_t regulator_suspend_mem_mode_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_opmode(buf,\n\t\trdev->constraints->state_mem.mode);\n}\nstatic DEVICE_ATTR(suspend_mem_mode, 0444,\n\t\tregulator_suspend_mem_mode_show, NULL);\n\nstatic ssize_t regulator_suspend_disk_mode_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_opmode(buf,\n\t\trdev->constraints->state_disk.mode);\n}\nstatic DEVICE_ATTR(suspend_disk_mode, 0444,\n\t\tregulator_suspend_disk_mode_show, NULL);\n\nstatic ssize_t regulator_suspend_standby_mode_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_opmode(buf,\n\t\trdev->constraints->state_standby.mode);\n}\nstatic DEVICE_ATTR(suspend_standby_mode, 0444,\n\t\tregulator_suspend_standby_mode_show, NULL);\n\nstatic ssize_t regulator_suspend_mem_state_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_state(buf,\n\t\t\trdev->constraints->state_mem.enabled);\n}\nstatic DEVICE_ATTR(suspend_mem_state, 0444,\n\t\tregulator_suspend_mem_state_show, NULL);\n\nstatic ssize_t regulator_suspend_disk_state_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_state(buf,\n\t\t\trdev->constraints->state_disk.enabled);\n}\nstatic DEVICE_ATTR(suspend_disk_state, 0444,\n\t\tregulator_suspend_disk_state_show, NULL);\n\nstatic ssize_t regulator_suspend_standby_state_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_state(buf,\n\t\t\trdev->constraints->state_standby.enabled);\n}\nstatic DEVICE_ATTR(suspend_standby_state, 0444,\n\t\tregulator_suspend_standby_state_show, NULL);\n\nstatic ssize_t regulator_bypass_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\tconst char *report;\n\tbool bypass;\n\tint ret;\n\n\tret = rdev->desc->ops->get_bypass(rdev, &bypass);\n\n\tif (ret != 0)\n\t\treport = \"unknown\";\n\telse if (bypass)\n\t\treport = \"enabled\";\n\telse\n\t\treport = \"disabled\";\n\n\treturn sprintf(buf, \"%s\\n\", report);\n}\nstatic DEVICE_ATTR(bypass, 0444,\n\t\t   regulator_bypass_show, NULL);\n\n/*\n * These are the only attributes are present for all regulators.\n * Other attributes are a function of regulator functionality.\n */\nstatic struct attribute *regulator_dev_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_num_users.attr,\n\t&dev_attr_type.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(regulator_dev);\n\nstatic void regulator_dev_release(struct device *dev)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\tkfree(rdev);\n}\n\nstatic struct class regulator_class = {\n\t.name = \"regulator\",\n\t.dev_release = regulator_dev_release,\n\t.dev_groups = regulator_dev_groups,\n};\n\n/* Calculate the new optimum regulator operating mode based on the new total\n * consumer load. All locks held by caller */\nstatic void drms_uA_update(struct regulator_dev *rdev)\n{\n\tstruct regulator *sibling;\n\tint current_uA = 0, output_uV, input_uV, err;\n\tunsigned int mode;\n\n\terr = regulator_check_drms(rdev);\n\tif (err < 0 || !rdev->desc->ops->get_optimum_mode ||\n\t    (!rdev->desc->ops->get_voltage &&\n\t     !rdev->desc->ops->get_voltage_sel) ||\n\t    !rdev->desc->ops->set_mode)\n\t\treturn;\n\n\t/* get output voltage */\n\toutput_uV = _regulator_get_voltage(rdev);\n\tif (output_uV <= 0)\n\t\treturn;\n\n\t/* get input voltage */\n\tinput_uV = 0;\n\tif (rdev->supply)\n\t\tinput_uV = regulator_get_voltage(rdev->supply);\n\tif (input_uV <= 0)\n\t\tinput_uV = rdev->constraints->input_uV;\n\tif (input_uV <= 0)\n\t\treturn;\n\n\t/* calc total requested load */\n\tlist_for_each_entry(sibling, &rdev->consumer_list, list)\n\t\tcurrent_uA += sibling->uA_load;\n\n\t/* now get the optimum mode for our new total regulator load */\n\tmode = rdev->desc->ops->get_optimum_mode(rdev, input_uV,\n\t\t\t\t\t\t  output_uV, current_uA);\n\n\t/* check the new mode is allowed */\n\terr = regulator_mode_constrain(rdev, &mode);\n\tif (err == 0)\n\t\trdev->desc->ops->set_mode(rdev, mode);\n}\n\nstatic int suspend_set_state(struct regulator_dev *rdev,\n\tstruct regulator_state *rstate)\n{\n\tint ret = 0;\n\n\t/* If we have no suspend mode configration don't set anything;\n\t * only warn if the driver implements set_suspend_voltage or\n\t * set_suspend_mode callback.\n\t */\n\tif (!rstate->enabled && !rstate->disabled) {\n\t\tif (rdev->desc->ops->set_suspend_voltage ||\n\t\t    rdev->desc->ops->set_suspend_mode)\n\t\t\trdev_warn(rdev, \"No configuration\\n\");\n\t\treturn 0;\n\t}\n\n\tif (rstate->enabled && rstate->disabled) {\n\t\trdev_err(rdev, \"invalid configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rstate->enabled && rdev->desc->ops->set_suspend_enable)\n\t\tret = rdev->desc->ops->set_suspend_enable(rdev);\n\telse if (rstate->disabled && rdev->desc->ops->set_suspend_disable)\n\t\tret = rdev->desc->ops->set_suspend_disable(rdev);\n\telse /* OK if set_suspend_enable or set_suspend_disable is NULL */\n\t\tret = 0;\n\n\tif (ret < 0) {\n\t\trdev_err(rdev, \"failed to enabled/disable\\n\");\n\t\treturn ret;\n\t}\n\n\tif (rdev->desc->ops->set_suspend_voltage && rstate->uV > 0) {\n\t\tret = rdev->desc->ops->set_suspend_voltage(rdev, rstate->uV);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set voltage\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (rdev->desc->ops->set_suspend_mode && rstate->mode > 0) {\n\t\tret = rdev->desc->ops->set_suspend_mode(rdev, rstate->mode);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set mode\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn ret;\n}\n\n/* locks held by caller */\nstatic int suspend_prepare(struct regulator_dev *rdev, suspend_state_t state)\n{\n\tif (!rdev->constraints)\n\t\treturn -EINVAL;\n\n\tswitch (state) {\n\tcase PM_SUSPEND_STANDBY:\n\t\treturn suspend_set_state(rdev,\n\t\t\t&rdev->constraints->state_standby);\n\tcase PM_SUSPEND_MEM:\n\t\treturn suspend_set_state(rdev,\n\t\t\t&rdev->constraints->state_mem);\n\tcase PM_SUSPEND_MAX:\n\t\treturn suspend_set_state(rdev,\n\t\t\t&rdev->constraints->state_disk);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void print_constraints(struct regulator_dev *rdev)\n{\n\tstruct regulation_constraints *constraints = rdev->constraints;\n\tchar buf[80] = \"\";\n\tint count = 0;\n\tint ret;\n\n\tif (constraints->min_uV && constraints->max_uV) {\n\t\tif (constraints->min_uV == constraints->max_uV)\n\t\t\tcount += sprintf(buf + count, \"%d mV \",\n\t\t\t\t\t constraints->min_uV / 1000);\n\t\telse\n\t\t\tcount += sprintf(buf + count, \"%d <--> %d mV \",\n\t\t\t\t\t constraints->min_uV / 1000,\n\t\t\t\t\t constraints->max_uV / 1000);\n\t}\n\n\tif (!constraints->min_uV ||\n\t    constraints->min_uV != constraints->max_uV) {\n\t\tret = _regulator_get_voltage(rdev);\n\t\tif (ret > 0)\n\t\t\tcount += sprintf(buf + count, \"at %d mV \", ret / 1000);\n\t}\n\n\tif (constraints->uV_offset)\n\t\tcount += sprintf(buf, \"%dmV offset \",\n\t\t\t\t constraints->uV_offset / 1000);\n\n\tif (constraints->min_uA && constraints->max_uA) {\n\t\tif (constraints->min_uA == constraints->max_uA)\n\t\t\tcount += sprintf(buf + count, \"%d mA \",\n\t\t\t\t\t constraints->min_uA / 1000);\n\t\telse\n\t\t\tcount += sprintf(buf + count, \"%d <--> %d mA \",\n\t\t\t\t\t constraints->min_uA / 1000,\n\t\t\t\t\t constraints->max_uA / 1000);\n\t}\n\n\tif (!constraints->min_uA ||\n\t    constraints->min_uA != constraints->max_uA) {\n\t\tret = _regulator_get_current_limit(rdev);\n\t\tif (ret > 0)\n\t\t\tcount += sprintf(buf + count, \"at %d mA \", ret / 1000);\n\t}\n\n\tif (constraints->valid_modes_mask & REGULATOR_MODE_FAST)\n\t\tcount += sprintf(buf + count, \"fast \");\n\tif (constraints->valid_modes_mask & REGULATOR_MODE_NORMAL)\n\t\tcount += sprintf(buf + count, \"normal \");\n\tif (constraints->valid_modes_mask & REGULATOR_MODE_IDLE)\n\t\tcount += sprintf(buf + count, \"idle \");\n\tif (constraints->valid_modes_mask & REGULATOR_MODE_STANDBY)\n\t\tcount += sprintf(buf + count, \"standby\");\n\n\tif (!count)\n\t\tsprintf(buf, \"no parameters\");\n\n\trdev_dbg(rdev, \"%s\\n\", buf);\n\n\tif ((constraints->min_uV != constraints->max_uV) &&\n\t    !(constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE))\n\t\trdev_warn(rdev,\n\t\t\t  \"Voltage range but no REGULATOR_CHANGE_VOLTAGE\\n\");\n}\n\nstatic int machine_constraints_voltage(struct regulator_dev *rdev,\n\tstruct regulation_constraints *constraints)\n{\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\tint ret;\n\n\t/* do we need to apply the constraint voltage */\n\tif (rdev->constraints->apply_uV &&\n\t    rdev->constraints->min_uV == rdev->constraints->max_uV) {\n\t\tint current_uV = _regulator_get_voltage(rdev);\n\t\tif (current_uV < 0) {\n\t\t\trdev_err(rdev,\n\t\t\t\t \"failed to get the current voltage(%d)\\n\",\n\t\t\t\t current_uV);\n\t\t\treturn current_uV;\n\t\t}\n\t\tif (current_uV < rdev->constraints->min_uV ||\n\t\t    current_uV > rdev->constraints->max_uV) {\n\t\t\tret = _regulator_do_set_voltage(\n\t\t\t\trdev, rdev->constraints->min_uV,\n\t\t\t\trdev->constraints->max_uV);\n\t\t\tif (ret < 0) {\n\t\t\t\trdev_err(rdev,\n\t\t\t\t\t\"failed to apply %duV constraint(%d)\\n\",\n\t\t\t\t\trdev->constraints->min_uV, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* constrain machine-level voltage specs to fit\n\t * the actual range supported by this regulator.\n\t */\n\tif (ops->list_voltage && rdev->desc->n_voltages) {\n\t\tint\tcount = rdev->desc->n_voltages;\n\t\tint\ti;\n\t\tint\tmin_uV = INT_MAX;\n\t\tint\tmax_uV = INT_MIN;\n\t\tint\tcmin = constraints->min_uV;\n\t\tint\tcmax = constraints->max_uV;\n\n\t\t/* it's safe to autoconfigure fixed-voltage supplies\n\t\t   and the constraints are used by list_voltage. */\n\t\tif (count == 1 && !cmin) {\n\t\t\tcmin = 1;\n\t\t\tcmax = INT_MAX;\n\t\t\tconstraints->min_uV = cmin;\n\t\t\tconstraints->max_uV = cmax;\n\t\t}\n\n\t\t/* voltage constraints are optional */\n\t\tif ((cmin == 0) && (cmax == 0))\n\t\t\treturn 0;\n\n\t\t/* else require explicit machine-level constraints */\n\t\tif (cmin <= 0 || cmax <= 0 || cmax < cmin) {\n\t\t\trdev_err(rdev, \"invalid voltage constraints\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* initial: [cmin..cmax] valid, [min_uV..max_uV] not */\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tint\tvalue;\n\n\t\t\tvalue = ops->list_voltage(rdev, i);\n\t\t\tif (value <= 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* maybe adjust [min_uV..max_uV] */\n\t\t\tif (value >= cmin && value < min_uV)\n\t\t\t\tmin_uV = value;\n\t\t\tif (value <= cmax && value > max_uV)\n\t\t\t\tmax_uV = value;\n\t\t}\n\n\t\t/* final: [min_uV..max_uV] valid iff constraints valid */\n\t\tif (max_uV < min_uV) {\n\t\t\trdev_err(rdev,\n\t\t\t\t \"unsupportable voltage constraints %u-%uuV\\n\",\n\t\t\t\t min_uV, max_uV);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* use regulator's subset of machine constraints */\n\t\tif (constraints->min_uV < min_uV) {\n\t\t\trdev_dbg(rdev, \"override min_uV, %d -> %d\\n\",\n\t\t\t\t constraints->min_uV, min_uV);\n\t\t\tconstraints->min_uV = min_uV;\n\t\t}\n\t\tif (constraints->max_uV > max_uV) {\n\t\t\trdev_dbg(rdev, \"override max_uV, %d -> %d\\n\",\n\t\t\t\t constraints->max_uV, max_uV);\n\t\t\tconstraints->max_uV = max_uV;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int machine_constraints_current(struct regulator_dev *rdev,\n\tstruct regulation_constraints *constraints)\n{\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\tint ret;\n\n\tif (!constraints->min_uA && !constraints->max_uA)\n\t\treturn 0;\n\n\tif (constraints->min_uA > constraints->max_uA) {\n\t\trdev_err(rdev, \"Invalid current constraints\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ops->set_current_limit || !ops->get_current_limit) {\n\t\trdev_warn(rdev, \"Operation of current configuration missing\\n\");\n\t\treturn 0;\n\t}\n\n\t/* Set regulator current in constraints range */\n\tret = ops->set_current_limit(rdev, constraints->min_uA,\n\t\t\tconstraints->max_uA);\n\tif (ret < 0) {\n\t\trdev_err(rdev, \"Failed to set current constraint, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int _regulator_do_enable(struct regulator_dev *rdev);\n\n/**\n * set_machine_constraints - sets regulator constraints\n * @rdev: regulator source\n * @constraints: constraints to apply\n *\n * Allows platform initialisation code to define and constrain\n * regulator circuits e.g. valid voltage/current ranges, etc.  NOTE:\n * Constraints *must* be set by platform code in order for some\n * regulator operations to proceed i.e. set_voltage, set_current_limit,\n * set_mode.\n */\nstatic int set_machine_constraints(struct regulator_dev *rdev,\n\tconst struct regulation_constraints *constraints)\n{\n\tint ret = 0;\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\n\tif (constraints)\n\t\trdev->constraints = kmemdup(constraints, sizeof(*constraints),\n\t\t\t\t\t    GFP_KERNEL);\n\telse\n\t\trdev->constraints = kzalloc(sizeof(*constraints),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!rdev->constraints)\n\t\treturn -ENOMEM;\n\n\tret = machine_constraints_voltage(rdev, rdev->constraints);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tret = machine_constraints_current(rdev, rdev->constraints);\n\tif (ret != 0)\n\t\tgoto out;\n\n\t/* do we need to setup our suspend state */\n\tif (rdev->constraints->initial_state) {\n\t\tret = suspend_prepare(rdev, rdev->constraints->initial_state);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set suspend state\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (rdev->constraints->initial_mode) {\n\t\tif (!ops->set_mode) {\n\t\t\trdev_err(rdev, \"no set_mode operation\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ops->set_mode(rdev, rdev->constraints->initial_mode);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set initial mode: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* If the constraints say the regulator should be on at this point\n\t * and we have control then make sure it is enabled.\n\t */\n\tif (rdev->constraints->always_on || rdev->constraints->boot_on) {\n\t\tret = _regulator_do_enable(rdev);\n\t\tif (ret < 0 && ret != -EINVAL) {\n\t\t\trdev_err(rdev, \"failed to enable\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif ((rdev->constraints->ramp_delay || rdev->constraints->ramp_disable)\n\t\t&& ops->set_ramp_delay) {\n\t\tret = ops->set_ramp_delay(rdev, rdev->constraints->ramp_delay);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set ramp_delay\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tprint_constraints(rdev);\n\treturn 0;\nout:\n\tkfree(rdev->constraints);\n\trdev->constraints = NULL;\n\treturn ret;\n}\n\n/**\n * set_supply - set regulator supply regulator\n * @rdev: regulator name\n * @supply_rdev: supply regulator name\n *\n * Called by platform initialisation code to set the supply regulator for this\n * regulator. This ensures that a regulators supply will also be enabled by the\n * core if it's child is enabled.\n */\nstatic int set_supply(struct regulator_dev *rdev,\n\t\t      struct regulator_dev *supply_rdev)\n{\n\tint err;\n\n\trdev_info(rdev, \"supplied by %s\\n\", rdev_get_name(supply_rdev));\n\n\trdev->supply = create_regulator(supply_rdev, &rdev->dev, \"SUPPLY\");\n\tif (rdev->supply == NULL) {\n\t\terr = -ENOMEM;\n\t\treturn err;\n\t}\n\tsupply_rdev->open_count++;\n\n\treturn 0;\n}\n\n/**\n * set_consumer_device_supply - Bind a regulator to a symbolic supply\n * @rdev:         regulator source\n * @consumer_dev_name: dev_name() string for device supply applies to\n * @supply:       symbolic name for supply\n *\n * Allows platform initialisation code to map physical regulator\n * sources to symbolic names for supplies for use by devices.  Devices\n * should use these symbolic names to request regulators, avoiding the\n * need to provide board-specific regulator names as platform data.\n */\nstatic int set_consumer_device_supply(struct regulator_dev *rdev,\n\t\t\t\t      const char *consumer_dev_name,\n\t\t\t\t      const char *supply)\n{\n\tstruct regulator_map *node;\n\tint has_dev;\n\n\tif (supply == NULL)\n\t\treturn -EINVAL;\n\n\tif (consumer_dev_name != NULL)\n\t\thas_dev = 1;\n\telse\n\t\thas_dev = 0;\n\n\tlist_for_each_entry(node, &regulator_map_list, list) {\n\t\tif (node->dev_name && consumer_dev_name) {\n\t\t\tif (strcmp(node->dev_name, consumer_dev_name) != 0)\n\t\t\t\tcontinue;\n\t\t} else if (node->dev_name || consumer_dev_name) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(node->supply, supply) != 0)\n\t\t\tcontinue;\n\n\t\tpr_debug(\"%s: %s/%s is '%s' supply; fail %s/%s\\n\",\n\t\t\t consumer_dev_name,\n\t\t\t dev_name(&node->regulator->dev),\n\t\t\t node->regulator->desc->name,\n\t\t\t supply,\n\t\t\t dev_name(&rdev->dev), rdev_get_name(rdev));\n\t\treturn -EBUSY;\n\t}\n\n\tnode = kzalloc(sizeof(struct regulator_map), GFP_KERNEL);\n\tif (node == NULL)\n\t\treturn -ENOMEM;\n\n\tnode->regulator = rdev;\n\tnode->supply = supply;\n\n\tif (has_dev) {\n\t\tnode->dev_name = kstrdup(consumer_dev_name, GFP_KERNEL);\n\t\tif (node->dev_name == NULL) {\n\t\t\tkfree(node);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tlist_add(&node->list, &regulator_map_list);\n\treturn 0;\n}\n\nstatic void unset_regulator_supplies(struct regulator_dev *rdev)\n{\n\tstruct regulator_map *node, *n;\n\n\tlist_for_each_entry_safe(node, n, &regulator_map_list, list) {\n\t\tif (rdev == node->regulator) {\n\t\t\tlist_del(&node->list);\n\t\t\tkfree(node->dev_name);\n\t\t\tkfree(node);\n\t\t}\n\t}\n}\n\n#define REG_STR_SIZE\t64\n\nstatic struct regulator *create_regulator(struct regulator_dev *rdev,\n\t\t\t\t\t  struct device *dev,\n\t\t\t\t\t  const char *supply_name)\n{\n\tstruct regulator *regulator;\n\tchar buf[REG_STR_SIZE];\n\tint err, size;\n\n\tregulator = kzalloc(sizeof(*regulator), GFP_KERNEL);\n\tif (regulator == NULL)\n\t\treturn NULL;\n\n\tmutex_lock(&rdev->mutex);\n\tregulator->rdev = rdev;\n\tlist_add(&regulator->list, &rdev->consumer_list);\n\n\tif (dev) {\n\t\tregulator->dev = dev;\n\n\t\t/* Add a link to the device sysfs entry */\n\t\tsize = scnprintf(buf, REG_STR_SIZE, \"%s-%s\",\n\t\t\t\t dev->kobj.name, supply_name);\n\t\tif (size >= REG_STR_SIZE)\n\t\t\tgoto overflow_err;\n\n\t\tregulator->supply_name = kstrdup(buf, GFP_KERNEL);\n\t\tif (regulator->supply_name == NULL)\n\t\t\tgoto overflow_err;\n\n\t\terr = sysfs_create_link(&rdev->dev.kobj, &dev->kobj,\n\t\t\t\t\tbuf);\n\t\tif (err) {\n\t\t\trdev_warn(rdev, \"could not add device link %s err %d\\n\",\n\t\t\t\t  dev->kobj.name, err);\n\t\t\t/* non-fatal */\n\t\t}\n\t} else {\n\t\tregulator->supply_name = kstrdup(supply_name, GFP_KERNEL);\n\t\tif (regulator->supply_name == NULL)\n\t\t\tgoto overflow_err;\n\t}\n\n\tregulator->debugfs = debugfs_create_dir(regulator->supply_name,\n\t\t\t\t\t\trdev->debugfs);\n\tif (!regulator->debugfs) {\n\t\trdev_warn(rdev, \"Failed to create debugfs directory\\n\");\n\t} else {\n\t\tdebugfs_create_u32(\"uA_load\", 0444, regulator->debugfs,\n\t\t\t\t   &regulator->uA_load);\n\t\tdebugfs_create_u32(\"min_uV\", 0444, regulator->debugfs,\n\t\t\t\t   &regulator->min_uV);\n\t\tdebugfs_create_u32(\"max_uV\", 0444, regulator->debugfs,\n\t\t\t\t   &regulator->max_uV);\n\t}\n\n\t/*\n\t * Check now if the regulator is an always on regulator - if\n\t * it is then we don't need to do nearly so much work for\n\t * enable/disable calls.\n\t */\n\tif (!_regulator_can_change_status(rdev) &&\n\t    _regulator_is_enabled(rdev))\n\t\tregulator->always_on = true;\n\n\tmutex_unlock(&rdev->mutex);\n\treturn regulator;\noverflow_err:\n\tlist_del(&regulator->list);\n\tkfree(regulator);\n\tmutex_unlock(&rdev->mutex);\n\treturn NULL;\n}\n\nstatic int _regulator_get_enable_time(struct regulator_dev *rdev)\n{\n\tif (rdev->constraints && rdev->constraints->enable_time)\n\t\treturn rdev->constraints->enable_time;\n\tif (!rdev->desc->ops->enable_time)\n\t\treturn rdev->desc->enable_time;\n\treturn rdev->desc->ops->enable_time(rdev);\n}\n\nstatic struct regulator_supply_alias *regulator_find_supply_alias(\n\t\tstruct device *dev, const char *supply)\n{\n\tstruct regulator_supply_alias *map;\n\n\tlist_for_each_entry(map, &regulator_supply_alias_list, list)\n\t\tif (map->src_dev == dev && strcmp(map->src_supply, supply) == 0)\n\t\t\treturn map;\n\n\treturn NULL;\n}\n\nstatic void regulator_supply_alias(struct device **dev, const char **supply)\n{\n\tstruct regulator_supply_alias *map;\n\n\tmap = regulator_find_supply_alias(*dev, *supply);\n\tif (map) {\n\t\tdev_dbg(*dev, \"Mapping supply %s to %s,%s\\n\",\n\t\t\t\t*supply, map->alias_supply,\n\t\t\t\tdev_name(map->alias_dev));\n\t\t*dev = map->alias_dev;\n\t\t*supply = map->alias_supply;\n\t}\n}\n\nstatic struct regulator_dev *regulator_dev_lookup(struct device *dev,\n\t\t\t\t\t\t  const char *supply,\n\t\t\t\t\t\t  int *ret)\n{\n\tstruct regulator_dev *r;\n\tstruct device_node *node;\n\tstruct regulator_map *map;\n\tconst char *devname = NULL;\n\n\tregulator_supply_alias(&dev, &supply);\n\n\t/* first do a dt based lookup */\n\tif (dev && dev->of_node) {\n\t\tnode = of_get_regulator(dev, supply);\n\t\tif (node) {\n\t\t\tlist_for_each_entry(r, &regulator_list, list)\n\t\t\t\tif (r->dev.parent &&\n\t\t\t\t\tnode == r->dev.of_node)\n\t\t\t\t\treturn r;\n\t\t\t*ret = -EPROBE_DEFER;\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If we couldn't even get the node then it's\n\t\t\t * not just that the device didn't register\n\t\t\t * yet, there's no node and we'll never\n\t\t\t * succeed.\n\t\t\t */\n\t\t\t*ret = -ENODEV;\n\t\t}\n\t}\n\n\t/* if not found, try doing it non-dt way */\n\tif (dev)\n\t\tdevname = dev_name(dev);\n\n\tlist_for_each_entry(r, &regulator_list, list)\n\t\tif (strcmp(rdev_get_name(r), supply) == 0)\n\t\t\treturn r;\n\n\tlist_for_each_entry(map, &regulator_map_list, list) {\n\t\t/* If the mapping has a device set up it must match */\n\t\tif (map->dev_name &&\n\t\t    (!devname || strcmp(map->dev_name, devname)))\n\t\t\tcontinue;\n\n\t\tif (strcmp(map->supply, supply) == 0)\n\t\t\treturn map->regulator;\n\t}\n\n\n\treturn NULL;\n}\n\n/* Internal regulator request function */\nstatic struct regulator *_regulator_get(struct device *dev, const char *id,\n\t\t\t\t\tbool exclusive, bool allow_dummy)\n{\n\tstruct regulator_dev *rdev;\n\tstruct regulator *regulator = ERR_PTR(-EPROBE_DEFER);\n\tconst char *devname = NULL;\n\tint ret;\n\n\tif (id == NULL) {\n\t\tpr_err(\"get() with no identifier\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (dev)\n\t\tdevname = dev_name(dev);\n\n\tif (have_full_constraints())\n\t\tret = -ENODEV;\n\telse\n\t\tret = -EPROBE_DEFER;\n\n\tmutex_lock(&regulator_list_mutex);\n\n\trdev = regulator_dev_lookup(dev, id, &ret);\n\tif (rdev)\n\t\tgoto found;\n\n\tregulator = ERR_PTR(ret);\n\n\t/*\n\t * If we have return value from dev_lookup fail, we do not expect to\n\t * succeed, so, quit with appropriate error value\n\t */\n\tif (ret && ret != -ENODEV)\n\t\tgoto out;\n\n\tif (!devname)\n\t\tdevname = \"deviceless\";\n\n\t/*\n\t * Assume that a regulator is physically present and enabled\n\t * even if it isn't hooked up and just provide a dummy.\n\t */\n\tif (have_full_constraints() && allow_dummy) {\n\t\tpr_warn(\"%s supply %s not found, using dummy regulator\\n\",\n\t\t\tdevname, id);\n\n\t\trdev = dummy_regulator_rdev;\n\t\tgoto found;\n\t/* Don't log an error when called from regulator_get_optional() */\n\t} else if (!have_full_constraints() || exclusive) {\n\t\tdev_warn(dev, \"dummy supplies not allowed\\n\");\n\t}\n\n\tmutex_unlock(&regulator_list_mutex);\n\treturn regulator;\n\nfound:\n\tif (rdev->exclusive) {\n\t\tregulator = ERR_PTR(-EPERM);\n\t\tgoto out;\n\t}\n\n\tif (exclusive && rdev->open_count) {\n\t\tregulator = ERR_PTR(-EBUSY);\n\t\tgoto out;\n\t}\n\n\tif (!try_module_get(rdev->owner))\n\t\tgoto out;\n\n\tregulator = create_regulator(rdev, dev, id);\n\tif (regulator == NULL) {\n\t\tregulator = ERR_PTR(-ENOMEM);\n\t\tmodule_put(rdev->owner);\n\t\tgoto out;\n\t}\n\n\trdev->open_count++;\n\tif (exclusive) {\n\t\trdev->exclusive = 1;\n\n\t\tret = _regulator_is_enabled(rdev);\n\t\tif (ret > 0)\n\t\t\trdev->use_count = 1;\n\t\telse\n\t\t\trdev->use_count = 0;\n\t}\n\nout:\n\tmutex_unlock(&regulator_list_mutex);\n\n\treturn regulator;\n}\n\n/**\n * regulator_get - lookup and obtain a reference to a regulator.\n * @dev: device for regulator \"consumer\"\n * @id: Supply name or regulator ID.\n *\n * Returns a struct regulator corresponding to the regulator producer,\n * or IS_ERR() condition containing errno.\n *\n * Use of supply names configured via regulator_set_device_supply() is\n * strongly encouraged.  It is recommended that the supply name used\n * should match the name used for the supply and/or the relevant\n * device pins in the datasheet.\n */\nstruct regulator *regulator_get(struct device *dev, const char *id)\n{\n\treturn _regulator_get(dev, id, false, true);\n}\nEXPORT_SYMBOL_GPL(regulator_get);\n\n/**\n * regulator_get_exclusive - obtain exclusive access to a regulator.\n * @dev: device for regulator \"consumer\"\n * @id: Supply name or regulator ID.\n *\n * Returns a struct regulator corresponding to the regulator producer,\n * or IS_ERR() condition containing errno.  Other consumers will be\n * unable to obtain this regulator while this reference is held and the\n * use count for the regulator will be initialised to reflect the current\n * state of the regulator.\n *\n * This is intended for use by consumers which cannot tolerate shared\n * use of the regulator such as those which need to force the\n * regulator off for correct operation of the hardware they are\n * controlling.\n *\n * Use of supply names configured via regulator_set_device_supply() is\n * strongly encouraged.  It is recommended that the supply name used\n * should match the name used for the supply and/or the relevant\n * device pins in the datasheet.\n */\nstruct regulator *regulator_get_exclusive(struct device *dev, const char *id)\n{\n\treturn _regulator_get(dev, id, true, false);\n}\nEXPORT_SYMBOL_GPL(regulator_get_exclusive);\n\n/**\n * regulator_get_optional - obtain optional access to a regulator.\n * @dev: device for regulator \"consumer\"\n * @id: Supply name or regulator ID.\n *\n * Returns a struct regulator corresponding to the regulator producer,\n * or IS_ERR() condition containing errno.\n *\n * This is intended for use by consumers for devices which can have\n * some supplies unconnected in normal use, such as some MMC devices.\n * It can allow the regulator core to provide stub supplies for other\n * supplies requested using normal regulator_get() calls without\n * disrupting the operation of drivers that can handle absent\n * supplies.\n *\n * Use of supply names configured via regulator_set_device_supply() is\n * strongly encouraged.  It is recommended that the supply name used\n * should match the name used for the supply and/or the relevant\n * device pins in the datasheet.\n */\nstruct regulator *regulator_get_optional(struct device *dev, const char *id)\n{\n\treturn _regulator_get(dev, id, false, false);\n}\nEXPORT_SYMBOL_GPL(regulator_get_optional);\n\n/* Locks held by regulator_put() */\nstatic void _regulator_put(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev;\n\n\tif (regulator == NULL || IS_ERR(regulator))\n\t\treturn;\n\n\trdev = regulator->rdev;\n\n\tdebugfs_remove_recursive(regulator->debugfs);\n\n\t/* remove any sysfs entries */\n\tif (regulator->dev)\n\t\tsysfs_remove_link(&rdev->dev.kobj, regulator->supply_name);\n\tkfree(regulator->supply_name);\n\tlist_del(&regulator->list);\n\tkfree(regulator);\n\n\trdev->open_count--;\n\trdev->exclusive = 0;\n\n\tmodule_put(rdev->owner);\n}\n\n/**\n * regulator_put - \"free\" the regulator source\n * @regulator: regulator source\n *\n * Note: drivers must ensure that all regulator_enable calls made on this\n * regulator source are balanced by regulator_disable calls prior to calling\n * this function.\n */\nvoid regulator_put(struct regulator *regulator)\n{\n\tmutex_lock(&regulator_list_mutex);\n\t_regulator_put(regulator);\n\tmutex_unlock(&regulator_list_mutex);\n}\nEXPORT_SYMBOL_GPL(regulator_put);\n\n/**\n * regulator_register_supply_alias - Provide device alias for supply lookup\n *\n * @dev: device that will be given as the regulator \"consumer\"\n * @id: Supply name or regulator ID\n * @alias_dev: device that should be used to lookup the supply\n * @alias_id: Supply name or regulator ID that should be used to lookup the\n * supply\n *\n * All lookups for id on dev will instead be conducted for alias_id on\n * alias_dev.\n */\nint regulator_register_supply_alias(struct device *dev, const char *id,\n\t\t\t\t    struct device *alias_dev,\n\t\t\t\t    const char *alias_id)\n{\n\tstruct regulator_supply_alias *map;\n\n\tmap = regulator_find_supply_alias(dev, id);\n\tif (map)\n\t\treturn -EEXIST;\n\n\tmap = kzalloc(sizeof(struct regulator_supply_alias), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmap->src_dev = dev;\n\tmap->src_supply = id;\n\tmap->alias_dev = alias_dev;\n\tmap->alias_supply = alias_id;\n\n\tlist_add(&map->list, &regulator_supply_alias_list);\n\n\tpr_info(\"Adding alias for supply %s,%s -> %s,%s\\n\",\n\t\tid, dev_name(dev), alias_id, dev_name(alias_dev));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(regulator_register_supply_alias);\n\n/**\n * regulator_unregister_supply_alias - Remove device alias\n *\n * @dev: device that will be given as the regulator \"consumer\"\n * @id: Supply name or regulator ID\n *\n * Remove a lookup alias if one exists for id on dev.\n */\nvoid regulator_unregister_supply_alias(struct device *dev, const char *id)\n{\n\tstruct regulator_supply_alias *map;\n\n\tmap = regulator_find_supply_alias(dev, id);\n\tif (map) {\n\t\tlist_del(&map->list);\n\t\tkfree(map);\n\t}\n}\nEXPORT_SYMBOL_GPL(regulator_unregister_supply_alias);\n\n/**\n * regulator_bulk_register_supply_alias - register multiple aliases\n *\n * @dev: device that will be given as the regulator \"consumer\"\n * @id: List of supply names or regulator IDs\n * @alias_dev: device that should be used to lookup the supply\n * @alias_id: List of supply names or regulator IDs that should be used to\n * lookup the supply\n * @num_id: Number of aliases to register\n *\n * @return 0 on success, an errno on failure.\n *\n * This helper function allows drivers to register several supply\n * aliases in one operation.  If any of the aliases cannot be\n * registered any aliases that were registered will be removed\n * before returning to the caller.\n */\nint regulator_bulk_register_supply_alias(struct device *dev,\n\t\t\t\t\t const char *const *id,\n\t\t\t\t\t struct device *alias_dev,\n\t\t\t\t\t const char *const *alias_id,\n\t\t\t\t\t int num_id)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < num_id; ++i) {\n\t\tret = regulator_register_supply_alias(dev, id[i], alias_dev,\n\t\t\t\t\t\t      alias_id[i]);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tdev_err(dev,\n\t\t\"Failed to create supply alias %s,%s -> %s,%s\\n\",\n\t\tid[i], dev_name(dev), alias_id[i], dev_name(alias_dev));\n\n\twhile (--i >= 0)\n\t\tregulator_unregister_supply_alias(dev, id[i]);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_register_supply_alias);\n\n/**\n * regulator_bulk_unregister_supply_alias - unregister multiple aliases\n *\n * @dev: device that will be given as the regulator \"consumer\"\n * @id: List of supply names or regulator IDs\n * @num_id: Number of aliases to unregister\n *\n * This helper function allows drivers to unregister several supply\n * aliases in one operation.\n */\nvoid regulator_bulk_unregister_supply_alias(struct device *dev,\n\t\t\t\t\t    const char *const *id,\n\t\t\t\t\t    int num_id)\n{\n\tint i;\n\n\tfor (i = 0; i < num_id; ++i)\n\t\tregulator_unregister_supply_alias(dev, id[i]);\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_unregister_supply_alias);\n\n\n/* Manage enable GPIO list. Same GPIO pin can be shared among regulators */\nstatic int regulator_ena_gpio_request(struct regulator_dev *rdev,\n\t\t\t\tconst struct regulator_config *config)\n{\n\tstruct regulator_enable_gpio *pin;\n\tstruct gpio_desc *gpiod;\n\tint ret;\n\n\tgpiod = gpio_to_desc(config->ena_gpio);\n\n\tlist_for_each_entry(pin, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == gpiod) {\n\t\t\trdev_dbg(rdev, \"GPIO %d is already used\\n\",\n\t\t\t\tconfig->ena_gpio);\n\t\t\tgoto update_ena_gpio_to_rdev;\n\t\t}\n\t}\n\n\tret = gpio_request_one(config->ena_gpio,\n\t\t\t\tGPIOF_DIR_OUT | config->ena_gpio_flags,\n\t\t\t\trdev_get_name(rdev));\n\tif (ret)\n\t\treturn ret;\n\n\tpin = kzalloc(sizeof(struct regulator_enable_gpio), GFP_KERNEL);\n\tif (pin == NULL) {\n\t\tgpio_free(config->ena_gpio);\n\t\treturn -ENOMEM;\n\t}\n\n\tpin->gpiod = gpiod;\n\tpin->ena_gpio_invert = config->ena_gpio_invert;\n\tlist_add(&pin->list, &regulator_ena_gpio_list);\n\nupdate_ena_gpio_to_rdev:\n\tpin->request_count++;\n\trdev->ena_pin = pin;\n\treturn 0;\n}\n\nstatic void regulator_ena_gpio_free(struct regulator_dev *rdev)\n{\n\tstruct regulator_enable_gpio *pin, *n;\n\n\tif (!rdev->ena_pin)\n\t\treturn;\n\n\t/* Free the GPIO only in case of no use */\n\tlist_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == rdev->ena_pin->gpiod) {\n\t\t\tif (pin->request_count <= 1) {\n\t\t\t\tpin->request_count = 0;\n\t\t\t\tgpiod_put(pin->gpiod);\n\t\t\t\tlist_del(&pin->list);\n\t\t\t\tkfree(pin);\n\t\t\t} else {\n\t\t\t\tpin->request_count--;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * regulator_ena_gpio_ctrl - balance enable_count of each GPIO and actual GPIO pin control\n * @rdev: regulator_dev structure\n * @enable: enable GPIO at initial use?\n *\n * GPIO is enabled in case of initial use. (enable_count is 0)\n * GPIO is disabled when it is not shared any more. (enable_count <= 1)\n */\nstatic int regulator_ena_gpio_ctrl(struct regulator_dev *rdev, bool enable)\n{\n\tstruct regulator_enable_gpio *pin = rdev->ena_pin;\n\n\tif (!pin)\n\t\treturn -EINVAL;\n\n\tif (enable) {\n\t\t/* Enable GPIO at initial use */\n\t\tif (pin->enable_count == 0)\n\t\t\tgpiod_set_value_cansleep(pin->gpiod,\n\t\t\t\t\t\t !pin->ena_gpio_invert);\n\n\t\tpin->enable_count++;\n\t} else {\n\t\tif (pin->enable_count > 1) {\n\t\t\tpin->enable_count--;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Disable GPIO if not used */\n\t\tif (pin->enable_count <= 1) {\n\t\t\tgpiod_set_value_cansleep(pin->gpiod,\n\t\t\t\t\t\t pin->ena_gpio_invert);\n\t\t\tpin->enable_count = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * _regulator_enable_delay - a delay helper function\n * @delay: time to delay in microseconds\n *\n * Delay for the requested amount of time as per the guidelines in:\n *\n *     Documentation/timers/timers-howto.txt\n *\n * The assumption here is that regulators will never be enabled in\n * atomic context and therefore sleeping functions can be used.\n */\nstatic void _regulator_enable_delay(unsigned int delay)\n{\n\tunsigned int ms = delay / 1000;\n\tunsigned int us = delay % 1000;\n\n\tif (ms > 0) {\n\t\t/*\n\t\t * For small enough values, handle super-millisecond\n\t\t * delays in the usleep_range() call below.\n\t\t */\n\t\tif (ms < 20)\n\t\t\tus += ms * 1000;\n\t\telse\n\t\t\tmsleep(ms);\n\t}\n\n\t/*\n\t * Give the scheduler some room to coalesce with any other\n\t * wakeup sources. For delays shorter than 10 us, don't even\n\t * bother setting up high-resolution timers and just busy-\n\t * loop.\n\t */\n\tif (us >= 10)\n\t\tusleep_range(us, us + 100);\n\telse\n\t\tudelay(us);\n}\n\nstatic int _regulator_do_enable(struct regulator_dev *rdev)\n{\n\tint ret, delay;\n\n\t/* Query before enabling in case configuration dependent.  */\n\tret = _regulator_get_enable_time(rdev);\n\tif (ret >= 0) {\n\t\tdelay = ret;\n\t} else {\n\t\trdev_warn(rdev, \"enable_time() failed: %d\\n\", ret);\n\t\tdelay = 0;\n\t}\n\n\ttrace_regulator_enable(rdev_get_name(rdev));\n\n\tif (rdev->desc->off_on_delay) {\n\t\t/* if needed, keep a distance of off_on_delay from last time\n\t\t * this regulator was disabled.\n\t\t */\n\t\tunsigned long start_jiffy = jiffies;\n\t\tunsigned long intended, max_delay, remaining;\n\n\t\tmax_delay = usecs_to_jiffies(rdev->desc->off_on_delay);\n\t\tintended = rdev->last_off_jiffy + max_delay;\n\n\t\tif (time_before(start_jiffy, intended)) {\n\t\t\t/* calc remaining jiffies to deal with one-time\n\t\t\t * timer wrapping.\n\t\t\t * in case of multiple timer wrapping, either it can be\n\t\t\t * detected by out-of-range remaining, or it cannot be\n\t\t\t * detected and we gets a panelty of\n\t\t\t * _regulator_enable_delay().\n\t\t\t */\n\t\t\tremaining = intended - start_jiffy;\n\t\t\tif (remaining <= max_delay)\n\t\t\t\t_regulator_enable_delay(\n\t\t\t\t\t\tjiffies_to_usecs(remaining));\n\t\t}\n\t}\n\n\tif (rdev->ena_pin) {\n\t\tret = regulator_ena_gpio_ctrl(rdev, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\trdev->ena_gpio_state = 1;\n\t} else if (rdev->desc->ops->enable) {\n\t\tret = rdev->desc->ops->enable(rdev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Allow the regulator to ramp; it would be useful to extend\n\t * this for bulk operations so that the regulators can ramp\n\t * together.  */\n\ttrace_regulator_enable_delay(rdev_get_name(rdev));\n\n\t_regulator_enable_delay(delay);\n\n\ttrace_regulator_enable_complete(rdev_get_name(rdev));\n\n\treturn 0;\n}\n\n/* locks held by regulator_enable() */\nstatic int _regulator_enable(struct regulator_dev *rdev)\n{\n\tint ret;\n\n\t/* check voltage and requested load before enabling */\n\tif (rdev->constraints &&\n\t    (rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_DRMS))\n\t\tdrms_uA_update(rdev);\n\n\tif (rdev->use_count == 0) {\n\t\t/* The regulator may on if it's not switchable or left on */\n\t\tret = _regulator_is_enabled(rdev);\n\t\tif (ret == -EINVAL || ret == 0) {\n\t\t\tif (!_regulator_can_change_status(rdev))\n\t\t\t\treturn -EPERM;\n\n\t\t\tret = _regulator_do_enable(rdev);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t} else if (ret < 0) {\n\t\t\trdev_err(rdev, \"is_enabled() failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\t/* Fallthrough on positive return values - already enabled */\n\t}\n\n\trdev->use_count++;\n\n\treturn 0;\n}\n\n/**\n * regulator_enable - enable regulator output\n * @regulator: regulator source\n *\n * Request that the regulator be enabled with the regulator output at\n * the predefined voltage or current value.  Calls to regulator_enable()\n * must be balanced with calls to regulator_disable().\n *\n * NOTE: the output value can be set by other drivers, boot loader or may be\n * hardwired in the regulator.\n */\nint regulator_enable(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret = 0;\n\n\tif (regulator->always_on)\n\t\treturn 0;\n\n\tif (rdev->supply) {\n\t\tret = regulator_enable(rdev->supply);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&rdev->mutex);\n\tret = _regulator_enable(rdev);\n\tmutex_unlock(&rdev->mutex);\n\n\tif (ret != 0 && rdev->supply)\n\t\tregulator_disable(rdev->supply);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_enable);\n\nstatic int _regulator_do_disable(struct regulator_dev *rdev)\n{\n\tint ret;\n\n\ttrace_regulator_disable(rdev_get_name(rdev));\n\n\tif (rdev->ena_pin) {\n\t\tret = regulator_ena_gpio_ctrl(rdev, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\trdev->ena_gpio_state = 0;\n\n\t} else if (rdev->desc->ops->disable) {\n\t\tret = rdev->desc->ops->disable(rdev);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* cares about last_off_jiffy only if off_on_delay is required by\n\t * device.\n\t */\n\tif (rdev->desc->off_on_delay)\n\t\trdev->last_off_jiffy = jiffies;\n\n\ttrace_regulator_disable_complete(rdev_get_name(rdev));\n\n\treturn 0;\n}\n\n/* locks held by regulator_disable() */\nstatic int _regulator_disable(struct regulator_dev *rdev)\n{\n\tint ret = 0;\n\n\tif (WARN(rdev->use_count <= 0,\n\t\t \"unbalanced disables for %s\\n\", rdev_get_name(rdev)))\n\t\treturn -EIO;\n\n\t/* are we the last user and permitted to disable ? */\n\tif (rdev->use_count == 1 &&\n\t    (rdev->constraints && !rdev->constraints->always_on)) {\n\n\t\t/* we are last user */\n\t\tif (_regulator_can_change_status(rdev)) {\n\t\t\tret = _regulator_do_disable(rdev);\n\t\t\tif (ret < 0) {\n\t\t\t\trdev_err(rdev, \"failed to disable\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t_notifier_call_chain(rdev, REGULATOR_EVENT_DISABLE,\n\t\t\t\t\tNULL);\n\t\t}\n\n\t\trdev->use_count = 0;\n\t} else if (rdev->use_count > 1) {\n\n\t\tif (rdev->constraints &&\n\t\t\t(rdev->constraints->valid_ops_mask &\n\t\t\tREGULATOR_CHANGE_DRMS))\n\t\t\tdrms_uA_update(rdev);\n\n\t\trdev->use_count--;\n\t}\n\n\treturn ret;\n}\n\n/**\n * regulator_disable - disable regulator output\n * @regulator: regulator source\n *\n * Disable the regulator output voltage or current.  Calls to\n * regulator_enable() must be balanced with calls to\n * regulator_disable().\n *\n * NOTE: this will only disable the regulator output if no other consumer\n * devices have it enabled, the regulator device supports disabling and\n * machine constraints permit this operation.\n */\nint regulator_disable(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret = 0;\n\n\tif (regulator->always_on)\n\t\treturn 0;\n\n\tmutex_lock(&rdev->mutex);\n\tret = _regulator_disable(rdev);\n\tmutex_unlock(&rdev->mutex);\n\n\tif (ret == 0 && rdev->supply)\n\t\tregulator_disable(rdev->supply);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_disable);\n\n/* locks held by regulator_force_disable() */\nstatic int _regulator_force_disable(struct regulator_dev *rdev)\n{\n\tint ret = 0;\n\n\tret = _regulator_do_disable(rdev);\n\tif (ret < 0) {\n\t\trdev_err(rdev, \"failed to force disable\\n\");\n\t\treturn ret;\n\t}\n\n\t_notifier_call_chain(rdev, REGULATOR_EVENT_FORCE_DISABLE |\n\t\t\tREGULATOR_EVENT_DISABLE, NULL);\n\n\treturn 0;\n}\n\n/**\n * regulator_force_disable - force disable regulator output\n * @regulator: regulator source\n *\n * Forcibly disable the regulator output voltage or current.\n * NOTE: this *will* disable the regulator output even if other consumer\n * devices have it enabled. This should be used for situations when device\n * damage will likely occur if the regulator is not disabled (e.g. over temp).\n */\nint regulator_force_disable(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret;\n\n\tmutex_lock(&rdev->mutex);\n\tregulator->uA_load = 0;\n\tret = _regulator_force_disable(regulator->rdev);\n\tmutex_unlock(&rdev->mutex);\n\n\tif (rdev->supply)\n\t\twhile (rdev->open_count--)\n\t\t\tregulator_disable(rdev->supply);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_force_disable);\n\nstatic void regulator_disable_work(struct work_struct *work)\n{\n\tstruct regulator_dev *rdev = container_of(work, struct regulator_dev,\n\t\t\t\t\t\t  disable_work.work);\n\tint count, i, ret;\n\n\tmutex_lock(&rdev->mutex);\n\n\tBUG_ON(!rdev->deferred_disables);\n\n\tcount = rdev->deferred_disables;\n\trdev->deferred_disables = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tret = _regulator_disable(rdev);\n\t\tif (ret != 0)\n\t\t\trdev_err(rdev, \"Deferred disable failed: %d\\n\", ret);\n\t}\n\n\tmutex_unlock(&rdev->mutex);\n\n\tif (rdev->supply) {\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tret = regulator_disable(rdev->supply);\n\t\t\tif (ret != 0) {\n\t\t\t\trdev_err(rdev,\n\t\t\t\t\t \"Supply disable failed: %d\\n\", ret);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * regulator_disable_deferred - disable regulator output with delay\n * @regulator: regulator source\n * @ms: miliseconds until the regulator is disabled\n *\n * Execute regulator_disable() on the regulator after a delay.  This\n * is intended for use with devices that require some time to quiesce.\n *\n * NOTE: this will only disable the regulator output if no other consumer\n * devices have it enabled, the regulator device supports disabling and\n * machine constraints permit this operation.\n */\nint regulator_disable_deferred(struct regulator *regulator, int ms)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret;\n\n\tif (regulator->always_on)\n\t\treturn 0;\n\n\tif (!ms)\n\t\treturn regulator_disable(regulator);\n\n\tmutex_lock(&rdev->mutex);\n\trdev->deferred_disables++;\n\tmutex_unlock(&rdev->mutex);\n\n\tret = queue_delayed_work(system_power_efficient_wq,\n\t\t\t\t &rdev->disable_work,\n\t\t\t\t msecs_to_jiffies(ms));\n\tif (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn 0;\n}\nEXPORT_SYMBOL_GPL(regulator_disable_deferred);\n\nstatic int _regulator_is_enabled(struct regulator_dev *rdev)\n{\n\t/* A GPIO control always takes precedence */\n\tif (rdev->ena_pin)\n\t\treturn rdev->ena_gpio_state;\n\n\t/* If we don't know then assume that the regulator is always on */\n\tif (!rdev->desc->ops->is_enabled)\n\t\treturn 1;\n\n\treturn rdev->desc->ops->is_enabled(rdev);\n}\n\n/**\n * regulator_is_enabled - is the regulator output enabled\n * @regulator: regulator source\n *\n * Returns positive if the regulator driver backing the source/client\n * has requested that the device be enabled, zero if it hasn't, else a\n * negative errno code.\n *\n * Note that the device backing this regulator handle can have multiple\n * users, so it might be enabled even if regulator_enable() was never\n * called for this particular source.\n */\nint regulator_is_enabled(struct regulator *regulator)\n{\n\tint ret;\n\n\tif (regulator->always_on)\n\t\treturn 1;\n\n\tmutex_lock(&regulator->rdev->mutex);\n\tret = _regulator_is_enabled(regulator->rdev);\n\tmutex_unlock(&regulator->rdev->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_is_enabled);\n\n/**\n * regulator_can_change_voltage - check if regulator can change voltage\n * @regulator: regulator source\n *\n * Returns positive if the regulator driver backing the source/client\n * can change its voltage, false otherwise. Useful for detecting fixed\n * or dummy regulators and disabling voltage change logic in the client\n * driver.\n */\nint regulator_can_change_voltage(struct regulator *regulator)\n{\n\tstruct regulator_dev\t*rdev = regulator->rdev;\n\n\tif (rdev->constraints &&\n\t    (rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {\n\t\tif (rdev->desc->n_voltages - rdev->desc->linear_min_sel > 1)\n\t\t\treturn 1;\n\n\t\tif (rdev->desc->continuous_voltage_range &&\n\t\t    rdev->constraints->min_uV && rdev->constraints->max_uV &&\n\t\t    rdev->constraints->min_uV != rdev->constraints->max_uV)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(regulator_can_change_voltage);\n\n/**\n * regulator_count_voltages - count regulator_list_voltage() selectors\n * @regulator: regulator source\n *\n * Returns number of selectors, or negative errno.  Selectors are\n * numbered starting at zero, and typically correspond to bitfields\n * in hardware registers.\n */\nint regulator_count_voltages(struct regulator *regulator)\n{\n\tstruct regulator_dev\t*rdev = regulator->rdev;\n\n\tif (rdev->desc->n_voltages)\n\t\treturn rdev->desc->n_voltages;\n\n\tif (!rdev->supply)\n\t\treturn -EINVAL;\n\n\treturn regulator_count_voltages(rdev->supply);\n}\nEXPORT_SYMBOL_GPL(regulator_count_voltages);\n\n/**\n * regulator_list_voltage - enumerate supported voltages\n * @regulator: regulator source\n * @selector: identify voltage to list\n * Context: can sleep\n *\n * Returns a voltage that can be passed to @regulator_set_voltage(),\n * zero if this selector code can't be used on this system, or a\n * negative errno.\n */\nint regulator_list_voltage(struct regulator *regulator, unsigned selector)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\tint ret;\n\n\tif (rdev->desc->fixed_uV && rdev->desc->n_voltages == 1 && !selector)\n\t\treturn rdev->desc->fixed_uV;\n\n\tif (ops->list_voltage) {\n\t\tif (selector >= rdev->desc->n_voltages)\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&rdev->mutex);\n\t\tret = ops->list_voltage(rdev, selector);\n\t\tmutex_unlock(&rdev->mutex);\n\t} else if (rdev->supply) {\n\t\tret = regulator_list_voltage(rdev->supply, selector);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret > 0) {\n\t\tif (ret < rdev->constraints->min_uV)\n\t\t\tret = 0;\n\t\telse if (ret > rdev->constraints->max_uV)\n\t\t\tret = 0;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_list_voltage);\n\n/**\n * regulator_get_regmap - get the regulator's register map\n * @regulator: regulator source\n *\n * Returns the register map for the given regulator, or an ERR_PTR value\n * if the regulator doesn't use regmap.\n */\nstruct regmap *regulator_get_regmap(struct regulator *regulator)\n{\n\tstruct regmap *map = regulator->rdev->regmap;\n\n\treturn map ? map : ERR_PTR(-EOPNOTSUPP);\n}\n\n/**\n * regulator_get_hardware_vsel_register - get the HW voltage selector register\n * @regulator: regulator source\n * @vsel_reg: voltage selector register, output parameter\n * @vsel_mask: mask for voltage selector bitfield, output parameter\n *\n * Returns the hardware register offset and bitmask used for setting the\n * regulator voltage. This might be useful when configuring voltage-scaling\n * hardware or firmware that can make I2C requests behind the kernel's back,\n * for example.\n *\n * On success, the output parameters @vsel_reg and @vsel_mask are filled in\n * and 0 is returned, otherwise a negative errno is returned.\n */\nint regulator_get_hardware_vsel_register(struct regulator *regulator,\n\t\t\t\t\t unsigned *vsel_reg,\n\t\t\t\t\t unsigned *vsel_mask)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\n\tif (ops->set_voltage_sel != regulator_set_voltage_sel_regmap)\n\t\treturn -EOPNOTSUPP;\n\n\t *vsel_reg = rdev->desc->vsel_reg;\n\t *vsel_mask = rdev->desc->vsel_mask;\n\n\t return 0;\n}\nEXPORT_SYMBOL_GPL(regulator_get_hardware_vsel_register);\n\n/**\n * regulator_list_hardware_vsel - get the HW-specific register value for a selector\n * @regulator: regulator source\n * @selector: identify voltage to list\n *\n * Converts the selector to a hardware-specific voltage selector that can be\n * directly written to the regulator registers. The address of the voltage\n * register can be determined by calling @regulator_get_hardware_vsel_register.\n *\n * On error a negative errno is returned.\n */\nint regulator_list_hardware_vsel(struct regulator *regulator,\n\t\t\t\t unsigned selector)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\n\tif (selector >= rdev->desc->n_voltages)\n\t\treturn -EINVAL;\n\tif (ops->set_voltage_sel != regulator_set_voltage_sel_regmap)\n\t\treturn -EOPNOTSUPP;\n\n\treturn selector;\n}\nEXPORT_SYMBOL_GPL(regulator_list_hardware_vsel);\n\n/**\n * regulator_get_linear_step - return the voltage step size between VSEL values\n * @regulator: regulator source\n *\n * Returns the voltage step size between VSEL values for linear\n * regulators, or return 0 if the regulator isn't a linear regulator.\n */\nunsigned int regulator_get_linear_step(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\n\treturn rdev->desc->uV_step;\n}\nEXPORT_SYMBOL_GPL(regulator_get_linear_step);\n\n/**\n * regulator_is_supported_voltage - check if a voltage range can be supported\n *\n * @regulator: Regulator to check.\n * @min_uV: Minimum required voltage in uV.\n * @max_uV: Maximum required voltage in uV.\n *\n * Returns a boolean or a negative error code.\n */\nint regulator_is_supported_voltage(struct regulator *regulator,\n\t\t\t\t   int min_uV, int max_uV)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint i, voltages, ret;\n\n\t/* If we can't change voltage check the current voltage */\n\tif (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {\n\t\tret = regulator_get_voltage(regulator);\n\t\tif (ret >= 0)\n\t\t\treturn min_uV <= ret && ret <= max_uV;\n\t\telse\n\t\t\treturn ret;\n\t}\n\n\t/* Any voltage within constrains range is fine? */\n\tif (rdev->desc->continuous_voltage_range)\n\t\treturn min_uV >= rdev->constraints->min_uV &&\n\t\t\t\tmax_uV <= rdev->constraints->max_uV;\n\n\tret = regulator_count_voltages(regulator);\n\tif (ret < 0)\n\t\treturn ret;\n\tvoltages = ret;\n\n\tfor (i = 0; i < voltages; i++) {\n\t\tret = regulator_list_voltage(regulator, i);\n\n\t\tif (ret >= min_uV && ret <= max_uV)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(regulator_is_supported_voltage);\n\nstatic int _regulator_call_set_voltage(struct regulator_dev *rdev,\n\t\t\t\t       int min_uV, int max_uV,\n\t\t\t\t       unsigned *selector)\n{\n\tstruct pre_voltage_change_data data;\n\tint ret;\n\n\tdata.old_uV = _regulator_get_voltage(rdev);\n\tdata.min_uV = min_uV;\n\tdata.max_uV = max_uV;\n\tret = _notifier_call_chain(rdev, REGULATOR_EVENT_PRE_VOLTAGE_CHANGE,\n\t\t\t\t   &data);\n\tif (ret & NOTIFY_STOP_MASK)\n\t\treturn -EINVAL;\n\n\tret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV, selector);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\t_notifier_call_chain(rdev, REGULATOR_EVENT_ABORT_VOLTAGE_CHANGE,\n\t\t\t     (void *)data.old_uV);\n\n\treturn ret;\n}\n\nstatic int _regulator_call_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t\t   int uV, unsigned selector)\n{\n\tstruct pre_voltage_change_data data;\n\tint ret;\n\n\tdata.old_uV = _regulator_get_voltage(rdev);\n\tdata.min_uV = uV;\n\tdata.max_uV = uV;\n\tret = _notifier_call_chain(rdev, REGULATOR_EVENT_PRE_VOLTAGE_CHANGE,\n\t\t\t\t   &data);\n\tif (ret & NOTIFY_STOP_MASK)\n\t\treturn -EINVAL;\n\n\tret = rdev->desc->ops->set_voltage_sel(rdev, selector);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\t_notifier_call_chain(rdev, REGULATOR_EVENT_ABORT_VOLTAGE_CHANGE,\n\t\t\t     (void *)data.old_uV);\n\n\treturn ret;\n}\n\nstatic int _regulator_do_set_voltage(struct regulator_dev *rdev,\n\t\t\t\t     int min_uV, int max_uV)\n{\n\tint ret;\n\tint delay = 0;\n\tint best_val = 0;\n\tunsigned int selector;\n\tint old_selector = -1;\n\n\ttrace_regulator_set_voltage(rdev_get_name(rdev), min_uV, max_uV);\n\n\tmin_uV += rdev->constraints->uV_offset;\n\tmax_uV += rdev->constraints->uV_offset;\n\n\t/*\n\t * If we can't obtain the old selector there is not enough\n\t * info to call set_voltage_time_sel().\n\t */\n\tif (_regulator_is_enabled(rdev) &&\n\t    rdev->desc->ops->set_voltage_time_sel &&\n\t    rdev->desc->ops->get_voltage_sel) {\n\t\told_selector = rdev->desc->ops->get_voltage_sel(rdev);\n\t\tif (old_selector < 0)\n\t\t\treturn old_selector;\n\t}\n\n\tif (rdev->desc->ops->set_voltage) {\n\t\tret = _regulator_call_set_voltage(rdev, min_uV, max_uV,\n\t\t\t\t\t\t  &selector);\n\n\t\tif (ret >= 0) {\n\t\t\tif (rdev->desc->ops->list_voltage)\n\t\t\t\tbest_val = rdev->desc->ops->list_voltage(rdev,\n\t\t\t\t\t\t\t\t\t selector);\n\t\t\telse\n\t\t\t\tbest_val = _regulator_get_voltage(rdev);\n\t\t}\n\n\t} else if (rdev->desc->ops->set_voltage_sel) {\n\t\tif (rdev->desc->ops->map_voltage) {\n\t\t\tret = rdev->desc->ops->map_voltage(rdev, min_uV,\n\t\t\t\t\t\t\t   max_uV);\n\t\t} else {\n\t\t\tif (rdev->desc->ops->list_voltage ==\n\t\t\t    regulator_list_voltage_linear)\n\t\t\t\tret = regulator_map_voltage_linear(rdev,\n\t\t\t\t\t\t\t\tmin_uV, max_uV);\n\t\t\telse if (rdev->desc->ops->list_voltage ==\n\t\t\t\t regulator_list_voltage_linear_range)\n\t\t\t\tret = regulator_map_voltage_linear_range(rdev,\n\t\t\t\t\t\t\t\tmin_uV, max_uV);\n\t\t\telse\n\t\t\t\tret = regulator_map_voltage_iterate(rdev,\n\t\t\t\t\t\t\t\tmin_uV, max_uV);\n\t\t}\n\n\t\tif (ret >= 0) {\n\t\t\tbest_val = rdev->desc->ops->list_voltage(rdev, ret);\n\t\t\tif (min_uV <= best_val && max_uV >= best_val) {\n\t\t\t\tselector = ret;\n\t\t\t\tif (old_selector == selector)\n\t\t\t\t\tret = 0;\n\t\t\t\telse\n\t\t\t\t\tret = _regulator_call_set_voltage_sel(\n\t\t\t\t\t\trdev, best_val, selector);\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\t/* Call set_voltage_time_sel if successfully obtained old_selector */\n\tif (ret == 0 && !rdev->constraints->ramp_disable && old_selector >= 0\n\t\t&& old_selector != selector) {\n\n\t\tdelay = rdev->desc->ops->set_voltage_time_sel(rdev,\n\t\t\t\t\t\told_selector, selector);\n\t\tif (delay < 0) {\n\t\t\trdev_warn(rdev, \"set_voltage_time_sel() failed: %d\\n\",\n\t\t\t\t  delay);\n\t\t\tdelay = 0;\n\t\t}\n\n\t\t/* Insert any necessary delays */\n\t\tif (delay >= 1000) {\n\t\t\tmdelay(delay / 1000);\n\t\t\tudelay(delay % 1000);\n\t\t} else if (delay) {\n\t\t\tudelay(delay);\n\t\t}\n\t}\n\n\tif (ret == 0 && best_val >= 0) {\n\t\tunsigned long data = best_val;\n\n\t\t_notifier_call_chain(rdev, REGULATOR_EVENT_VOLTAGE_CHANGE,\n\t\t\t\t     (void *)data);\n\t}\n\n\ttrace_regulator_set_voltage_complete(rdev_get_name(rdev), best_val);\n\n\treturn ret;\n}\n\n/**\n * regulator_set_voltage - set regulator output voltage\n * @regulator: regulator source\n * @min_uV: Minimum required voltage in uV\n * @max_uV: Maximum acceptable voltage in uV\n *\n * Sets a voltage regulator to the desired output voltage. This can be set\n * during any regulator state. IOW, regulator can be disabled or enabled.\n *\n * If the regulator is enabled then the voltage will change to the new value\n * immediately otherwise if the regulator is disabled the regulator will\n * output at the new voltage when enabled.\n *\n * NOTE: If the regulator is shared between several devices then the lowest\n * request voltage that meets the system constraints will be used.\n * Regulator system constraints must be set for this regulator before\n * calling this function otherwise this call will fail.\n */\nint regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret = 0;\n\tint old_min_uV, old_max_uV;\n\tint current_uV;\n\n\tmutex_lock(&rdev->mutex);\n\n\t/* If we're setting the same range as last time the change\n\t * should be a noop (some cpufreq implementations use the same\n\t * voltage for multiple frequencies, for example).\n\t */\n\tif (regulator->min_uV == min_uV && regulator->max_uV == max_uV)\n\t\tgoto out;\n\n\t/* If we're trying to set a range that overlaps the current voltage,\n\t * return succesfully even though the regulator does not support\n\t * changing the voltage.\n\t */\n\tif (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {\n\t\tcurrent_uV = _regulator_get_voltage(rdev);\n\t\tif (min_uV <= current_uV && current_uV <= max_uV) {\n\t\t\tregulator->min_uV = min_uV;\n\t\t\tregulator->max_uV = max_uV;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* sanity check */\n\tif (!rdev->desc->ops->set_voltage &&\n\t    !rdev->desc->ops->set_voltage_sel) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* constraints check */\n\tret = regulator_check_voltage(rdev, &min_uV, &max_uV);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* restore original values in case of error */\n\told_min_uV = regulator->min_uV;\n\told_max_uV = regulator->max_uV;\n\tregulator->min_uV = min_uV;\n\tregulator->max_uV = max_uV;\n\n\tret = regulator_check_consumers(rdev, &min_uV, &max_uV);\n\tif (ret < 0)\n\t\tgoto out2;\n\n\tret = _regulator_do_set_voltage(rdev, min_uV, max_uV);\n\tif (ret < 0)\n\t\tgoto out2;\n\nout:\n\tmutex_unlock(&rdev->mutex);\n\treturn ret;\nout2:\n\tregulator->min_uV = old_min_uV;\n\tregulator->max_uV = old_max_uV;\n\tmutex_unlock(&rdev->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_set_voltage);\n\n/**\n * regulator_set_voltage_time - get raise/fall time\n * @regulator: regulator source\n * @old_uV: starting voltage in microvolts\n * @new_uV: target voltage in microvolts\n *\n * Provided with the starting and ending voltage, this function attempts to\n * calculate the time in microseconds required to rise or fall to this new\n * voltage.\n */\nint regulator_set_voltage_time(struct regulator *regulator,\n\t\t\t       int old_uV, int new_uV)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\tint old_sel = -1;\n\tint new_sel = -1;\n\tint voltage;\n\tint i;\n\n\t/* Currently requires operations to do this */\n\tif (!ops->list_voltage || !ops->set_voltage_time_sel\n\t    || !rdev->desc->n_voltages)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < rdev->desc->n_voltages; i++) {\n\t\t/* We only look for exact voltage matches here */\n\t\tvoltage = regulator_list_voltage(regulator, i);\n\t\tif (voltage < 0)\n\t\t\treturn -EINVAL;\n\t\tif (voltage == 0)\n\t\t\tcontinue;\n\t\tif (voltage == old_uV)\n\t\t\told_sel = i;\n\t\tif (voltage == new_uV)\n\t\t\tnew_sel = i;\n\t}\n\n\tif (old_sel < 0 || new_sel < 0)\n\t\treturn -EINVAL;\n\n\treturn ops->set_voltage_time_sel(rdev, old_sel, new_sel);\n}\nEXPORT_SYMBOL_GPL(regulator_set_voltage_time);\n\n/**\n * regulator_set_voltage_time_sel - get raise/fall time\n * @rdev: regulator source device\n * @old_selector: selector for starting voltage\n * @new_selector: selector for target voltage\n *\n * Provided with the starting and target voltage selectors, this function\n * returns time in microseconds required to rise or fall to this new voltage\n *\n * Drivers providing ramp_delay in regulation_constraints can use this as their\n * set_voltage_time_sel() operation.\n */\nint regulator_set_voltage_time_sel(struct regulator_dev *rdev,\n\t\t\t\t   unsigned int old_selector,\n\t\t\t\t   unsigned int new_selector)\n{\n\tunsigned int ramp_delay = 0;\n\tint old_volt, new_volt;\n\n\tif (rdev->constraints->ramp_delay)\n\t\tramp_delay = rdev->constraints->ramp_delay;\n\telse if (rdev->desc->ramp_delay)\n\t\tramp_delay = rdev->desc->ramp_delay;\n\n\tif (ramp_delay == 0) {\n\t\trdev_warn(rdev, \"ramp_delay not set\\n\");\n\t\treturn 0;\n\t}\n\n\t/* sanity check */\n\tif (!rdev->desc->ops->list_voltage)\n\t\treturn -EINVAL;\n\n\told_volt = rdev->desc->ops->list_voltage(rdev, old_selector);\n\tnew_volt = rdev->desc->ops->list_voltage(rdev, new_selector);\n\n\treturn DIV_ROUND_UP(abs(new_volt - old_volt), ramp_delay);\n}\nEXPORT_SYMBOL_GPL(regulator_set_voltage_time_sel);\n\n/**\n * regulator_sync_voltage - re-apply last regulator output voltage\n * @regulator: regulator source\n *\n * Re-apply the last configured voltage.  This is intended to be used\n * where some external control source the consumer is cooperating with\n * has caused the configured voltage to change.\n */\nint regulator_sync_voltage(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret, min_uV, max_uV;\n\n\tmutex_lock(&rdev->mutex);\n\n\tif (!rdev->desc->ops->set_voltage &&\n\t    !rdev->desc->ops->set_voltage_sel) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* This is only going to work if we've had a voltage configured. */\n\tif (!regulator->min_uV && !regulator->max_uV) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmin_uV = regulator->min_uV;\n\tmax_uV = regulator->max_uV;\n\n\t/* This should be a paranoia check... */\n\tret = regulator_check_voltage(rdev, &min_uV, &max_uV);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = regulator_check_consumers(rdev, &min_uV, &max_uV);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = _regulator_do_set_voltage(rdev, min_uV, max_uV);\n\nout:\n\tmutex_unlock(&rdev->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_sync_voltage);\n\nstatic int _regulator_get_voltage(struct regulator_dev *rdev)\n{\n\tint sel, ret;\n\n\tif (rdev->desc->ops->get_voltage_sel) {\n\t\tsel = rdev->desc->ops->get_voltage_sel(rdev);\n\t\tif (sel < 0)\n\t\t\treturn sel;\n\t\tret = rdev->desc->ops->list_voltage(rdev, sel);\n\t} else if (rdev->desc->ops->get_voltage) {\n\t\tret = rdev->desc->ops->get_voltage(rdev);\n\t} else if (rdev->desc->ops->list_voltage) {\n\t\tret = rdev->desc->ops->list_voltage(rdev, 0);\n\t} else if (rdev->desc->fixed_uV && (rdev->desc->n_voltages == 1)) {\n\t\tret = rdev->desc->fixed_uV;\n\t} else if (rdev->supply) {\n\t\tret = regulator_get_voltage(rdev->supply);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn ret - rdev->constraints->uV_offset;\n}\n\n/**\n * regulator_get_voltage - get regulator output voltage\n * @regulator: regulator source\n *\n * This returns the current regulator voltage in uV.\n *\n * NOTE: If the regulator is disabled it will return the voltage value. This\n * function should not be used to determine regulator state.\n */\nint regulator_get_voltage(struct regulator *regulator)\n{\n\tint ret;\n\n\tmutex_lock(&regulator->rdev->mutex);\n\n\tret = _regulator_get_voltage(regulator->rdev);\n\n\tmutex_unlock(&regulator->rdev->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_get_voltage);\n\n/**\n * regulator_set_current_limit - set regulator output current limit\n * @regulator: regulator source\n * @min_uA: Minimum supported current in uA\n * @max_uA: Maximum supported current in uA\n *\n * Sets current sink to the desired output current. This can be set during\n * any regulator state. IOW, regulator can be disabled or enabled.\n *\n * If the regulator is enabled then the current will change to the new value\n * immediately otherwise if the regulator is disabled the regulator will\n * output at the new current when enabled.\n *\n * NOTE: Regulator system constraints must be set for this regulator before\n * calling this function otherwise this call will fail.\n */\nint regulator_set_current_limit(struct regulator *regulator,\n\t\t\t       int min_uA, int max_uA)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret;\n\n\tmutex_lock(&rdev->mutex);\n\n\t/* sanity check */\n\tif (!rdev->desc->ops->set_current_limit) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* constraints check */\n\tret = regulator_check_current_limit(rdev, &min_uA, &max_uA);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = rdev->desc->ops->set_current_limit(rdev, min_uA, max_uA);\nout:\n\tmutex_unlock(&rdev->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_set_current_limit);\n\nstatic int _regulator_get_current_limit(struct regulator_dev *rdev)\n{\n\tint ret;\n\n\tmutex_lock(&rdev->mutex);\n\n\t/* sanity check */\n\tif (!rdev->desc->ops->get_current_limit) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = rdev->desc->ops->get_current_limit(rdev);\nout:\n\tmutex_unlock(&rdev->mutex);\n\treturn ret;\n}\n\n/**\n * regulator_get_current_limit - get regulator output current\n * @regulator: regulator source\n *\n * This returns the current supplied by the specified current sink in uA.\n *\n * NOTE: If the regulator is disabled it will return the current value. This\n * function should not be used to determine regulator state.\n */\nint regulator_get_current_limit(struct regulator *regulator)\n{\n\treturn _regulator_get_current_limit(regulator->rdev);\n}\nEXPORT_SYMBOL_GPL(regulator_get_current_limit);\n\n/**\n * regulator_set_mode - set regulator operating mode\n * @regulator: regulator source\n * @mode: operating mode - one of the REGULATOR_MODE constants\n *\n * Set regulator operating mode to increase regulator efficiency or improve\n * regulation performance.\n *\n * NOTE: Regulator system constraints must be set for this regulator before\n * calling this function otherwise this call will fail.\n */\nint regulator_set_mode(struct regulator *regulator, unsigned int mode)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret;\n\tint regulator_curr_mode;\n\n\tmutex_lock(&rdev->mutex);\n\n\t/* sanity check */\n\tif (!rdev->desc->ops->set_mode) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* return if the same mode is requested */\n\tif (rdev->desc->ops->get_mode) {\n\t\tregulator_curr_mode = rdev->desc->ops->get_mode(rdev);\n\t\tif (regulator_curr_mode == mode) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* constraints check */\n\tret = regulator_mode_constrain(rdev, &mode);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = rdev->desc->ops->set_mode(rdev, mode);\nout:\n\tmutex_unlock(&rdev->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_set_mode);\n\nstatic unsigned int _regulator_get_mode(struct regulator_dev *rdev)\n{\n\tint ret;\n\n\tmutex_lock(&rdev->mutex);\n\n\t/* sanity check */\n\tif (!rdev->desc->ops->get_mode) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = rdev->desc->ops->get_mode(rdev);\nout:\n\tmutex_unlock(&rdev->mutex);\n\treturn ret;\n}\n\n/**\n * regulator_get_mode - get regulator operating mode\n * @regulator: regulator source\n *\n * Get the current regulator operating mode.\n */\nunsigned int regulator_get_mode(struct regulator *regulator)\n{\n\treturn _regulator_get_mode(regulator->rdev);\n}\nEXPORT_SYMBOL_GPL(regulator_get_mode);\n\n/**\n * regulator_set_optimum_mode - set regulator optimum operating mode\n * @regulator: regulator source\n * @uA_load: load current\n *\n * Notifies the regulator core of a new device load. This is then used by\n * DRMS (if enabled by constraints) to set the most efficient regulator\n * operating mode for the new regulator loading.\n *\n * Consumer devices notify their supply regulator of the maximum power\n * they will require (can be taken from device datasheet in the power\n * consumption tables) when they change operational status and hence power\n * state. Examples of operational state changes that can affect power\n * consumption are :-\n *\n *    o Device is opened / closed.\n *    o Device I/O is about to begin or has just finished.\n *    o Device is idling in between work.\n *\n * This information is also exported via sysfs to userspace.\n *\n * DRMS will sum the total requested load on the regulator and change\n * to the most efficient operating mode if platform constraints allow.\n *\n * Returns the new regulator mode or error.\n */\nint regulator_set_optimum_mode(struct regulator *regulator, int uA_load)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tstruct regulator *consumer;\n\tint ret, output_uV, input_uV = 0, total_uA_load = 0;\n\tunsigned int mode;\n\n\tif (rdev->supply)\n\t\tinput_uV = regulator_get_voltage(rdev->supply);\n\n\tmutex_lock(&rdev->mutex);\n\n\t/*\n\t * first check to see if we can set modes at all, otherwise just\n\t * tell the consumer everything is OK.\n\t */\n\tregulator->uA_load = uA_load;\n\tret = regulator_check_drms(rdev);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (!rdev->desc->ops->get_optimum_mode)\n\t\tgoto out;\n\n\t/*\n\t * we can actually do this so any errors are indicators of\n\t * potential real failure.\n\t */\n\tret = -EINVAL;\n\n\tif (!rdev->desc->ops->set_mode)\n\t\tgoto out;\n\n\t/* get output voltage */\n\toutput_uV = _regulator_get_voltage(rdev);\n\tif (output_uV <= 0) {\n\t\trdev_err(rdev, \"invalid output voltage found\\n\");\n\t\tgoto out;\n\t}\n\n\t/* No supply? Use constraint voltage */\n\tif (input_uV <= 0)\n\t\tinput_uV = rdev->constraints->input_uV;\n\tif (input_uV <= 0) {\n\t\trdev_err(rdev, \"invalid input voltage found\\n\");\n\t\tgoto out;\n\t}\n\n\t/* calc total requested load for this regulator */\n\tlist_for_each_entry(consumer, &rdev->consumer_list, list)\n\t\ttotal_uA_load += consumer->uA_load;\n\n\tmode = rdev->desc->ops->get_optimum_mode(rdev,\n\t\t\t\t\t\t input_uV, output_uV,\n\t\t\t\t\t\t total_uA_load);\n\tret = regulator_mode_constrain(rdev, &mode);\n\tif (ret < 0) {\n\t\trdev_err(rdev, \"failed to get optimum mode @ %d uA %d -> %d uV\\n\",\n\t\t\t total_uA_load, input_uV, output_uV);\n\t\tgoto out;\n\t}\n\n\tret = rdev->desc->ops->set_mode(rdev, mode);\n\tif (ret < 0) {\n\t\trdev_err(rdev, \"failed to set optimum mode %x\\n\", mode);\n\t\tgoto out;\n\t}\n\tret = mode;\nout:\n\tmutex_unlock(&rdev->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_set_optimum_mode);\n\n/**\n * regulator_allow_bypass - allow the regulator to go into bypass mode\n *\n * @regulator: Regulator to configure\n * @enable: enable or disable bypass mode\n *\n * Allow the regulator to go into bypass mode if all other consumers\n * for the regulator also enable bypass mode and the machine\n * constraints allow this.  Bypass mode means that the regulator is\n * simply passing the input directly to the output with no regulation.\n */\nint regulator_allow_bypass(struct regulator *regulator, bool enable)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret = 0;\n\n\tif (!rdev->desc->ops->set_bypass)\n\t\treturn 0;\n\n\tif (rdev->constraints &&\n\t    !(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_BYPASS))\n\t\treturn 0;\n\n\tmutex_lock(&rdev->mutex);\n\n\tif (enable && !regulator->bypass) {\n\t\trdev->bypass_count++;\n\n\t\tif (rdev->bypass_count == rdev->open_count) {\n\t\t\tret = rdev->desc->ops->set_bypass(rdev, enable);\n\t\t\tif (ret != 0)\n\t\t\t\trdev->bypass_count--;\n\t\t}\n\n\t} else if (!enable && regulator->bypass) {\n\t\trdev->bypass_count--;\n\n\t\tif (rdev->bypass_count != rdev->open_count) {\n\t\t\tret = rdev->desc->ops->set_bypass(rdev, enable);\n\t\t\tif (ret != 0)\n\t\t\t\trdev->bypass_count++;\n\t\t}\n\t}\n\n\tif (ret == 0)\n\t\tregulator->bypass = enable;\n\n\tmutex_unlock(&rdev->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_allow_bypass);\n\n/**\n * regulator_register_notifier - register regulator event notifier\n * @regulator: regulator source\n * @nb: notifier block\n *\n * Register notifier block to receive regulator events.\n */\nint regulator_register_notifier(struct regulator *regulator,\n\t\t\t      struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&regulator->rdev->notifier,\n\t\t\t\t\t\tnb);\n}\nEXPORT_SYMBOL_GPL(regulator_register_notifier);\n\n/**\n * regulator_unregister_notifier - unregister regulator event notifier\n * @regulator: regulator source\n * @nb: notifier block\n *\n * Unregister regulator event notifier block.\n */\nint regulator_unregister_notifier(struct regulator *regulator,\n\t\t\t\tstruct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&regulator->rdev->notifier,\n\t\t\t\t\t\t  nb);\n}\nEXPORT_SYMBOL_GPL(regulator_unregister_notifier);\n\n/* notify regulator consumers and downstream regulator consumers.\n * Note mutex must be held by caller.\n */\nstatic int _notifier_call_chain(struct regulator_dev *rdev,\n\t\t\t\t  unsigned long event, void *data)\n{\n\t/* call rdev chain first */\n\treturn blocking_notifier_call_chain(&rdev->notifier, event, data);\n}\n\n/**\n * regulator_bulk_get - get multiple regulator consumers\n *\n * @dev:           Device to supply\n * @num_consumers: Number of consumers to register\n * @consumers:     Configuration of consumers; clients are stored here.\n *\n * @return 0 on success, an errno on failure.\n *\n * This helper function allows drivers to get several regulator\n * consumers in one operation.  If any of the regulators cannot be\n * acquired then any regulators that were allocated will be freed\n * before returning to the caller.\n */\nint regulator_bulk_get(struct device *dev, int num_consumers,\n\t\t       struct regulator_bulk_data *consumers)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < num_consumers; i++)\n\t\tconsumers[i].consumer = NULL;\n\n\tfor (i = 0; i < num_consumers; i++) {\n\t\tconsumers[i].consumer = regulator_get(dev,\n\t\t\t\t\t\t      consumers[i].supply);\n\t\tif (IS_ERR(consumers[i].consumer)) {\n\t\t\tret = PTR_ERR(consumers[i].consumer);\n\t\t\tdev_err(dev, \"Failed to get supply '%s': %d\\n\",\n\t\t\t\tconsumers[i].supply, ret);\n\t\t\tconsumers[i].consumer = NULL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (--i >= 0)\n\t\tregulator_put(consumers[i].consumer);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_get);\n\nstatic void regulator_bulk_enable_async(void *data, async_cookie_t cookie)\n{\n\tstruct regulator_bulk_data *bulk = data;\n\n\tbulk->ret = regulator_enable(bulk->consumer);\n}\n\n/**\n * regulator_bulk_enable - enable multiple regulator consumers\n *\n * @num_consumers: Number of consumers\n * @consumers:     Consumer data; clients are stored here.\n * @return         0 on success, an errno on failure\n *\n * This convenience API allows consumers to enable multiple regulator\n * clients in a single API call.  If any consumers cannot be enabled\n * then any others that were enabled will be disabled again prior to\n * return.\n */\nint regulator_bulk_enable(int num_consumers,\n\t\t\t  struct regulator_bulk_data *consumers)\n{\n\tASYNC_DOMAIN_EXCLUSIVE(async_domain);\n\tint i;\n\tint ret = 0;\n\n\tfor (i = 0; i < num_consumers; i++) {\n\t\tif (consumers[i].consumer->always_on)\n\t\t\tconsumers[i].ret = 0;\n\t\telse\n\t\t\tasync_schedule_domain(regulator_bulk_enable_async,\n\t\t\t\t\t      &consumers[i], &async_domain);\n\t}\n\n\tasync_synchronize_full_domain(&async_domain);\n\n\t/* If any consumer failed we need to unwind any that succeeded */\n\tfor (i = 0; i < num_consumers; i++) {\n\t\tif (consumers[i].ret != 0) {\n\t\t\tret = consumers[i].ret;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (i = 0; i < num_consumers; i++) {\n\t\tif (consumers[i].ret < 0)\n\t\t\tpr_err(\"Failed to enable %s: %d\\n\", consumers[i].supply,\n\t\t\t       consumers[i].ret);\n\t\telse\n\t\t\tregulator_disable(consumers[i].consumer);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_enable);\n\n/**\n * regulator_bulk_disable - disable multiple regulator consumers\n *\n * @num_consumers: Number of consumers\n * @consumers:     Consumer data; clients are stored here.\n * @return         0 on success, an errno on failure\n *\n * This convenience API allows consumers to disable multiple regulator\n * clients in a single API call.  If any consumers cannot be disabled\n * then any others that were disabled will be enabled again prior to\n * return.\n */\nint regulator_bulk_disable(int num_consumers,\n\t\t\t   struct regulator_bulk_data *consumers)\n{\n\tint i;\n\tint ret, r;\n\n\tfor (i = num_consumers - 1; i >= 0; --i) {\n\t\tret = regulator_disable(consumers[i].consumer);\n\t\tif (ret != 0)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tpr_err(\"Failed to disable %s: %d\\n\", consumers[i].supply, ret);\n\tfor (++i; i < num_consumers; ++i) {\n\t\tr = regulator_enable(consumers[i].consumer);\n\t\tif (r != 0)\n\t\t\tpr_err(\"Failed to reename %s: %d\\n\",\n\t\t\t       consumers[i].supply, r);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_disable);\n\n/**\n * regulator_bulk_force_disable - force disable multiple regulator consumers\n *\n * @num_consumers: Number of consumers\n * @consumers:     Consumer data; clients are stored here.\n * @return         0 on success, an errno on failure\n *\n * This convenience API allows consumers to forcibly disable multiple regulator\n * clients in a single API call.\n * NOTE: This should be used for situations when device damage will\n * likely occur if the regulators are not disabled (e.g. over temp).\n * Although regulator_force_disable function call for some consumers can\n * return error numbers, the function is called for all consumers.\n */\nint regulator_bulk_force_disable(int num_consumers,\n\t\t\t   struct regulator_bulk_data *consumers)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < num_consumers; i++)\n\t\tconsumers[i].ret =\n\t\t\t    regulator_force_disable(consumers[i].consumer);\n\n\tfor (i = 0; i < num_consumers; i++) {\n\t\tif (consumers[i].ret != 0) {\n\t\t\tret = consumers[i].ret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\treturn 0;\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_force_disable);\n\n/**\n * regulator_bulk_free - free multiple regulator consumers\n *\n * @num_consumers: Number of consumers\n * @consumers:     Consumer data; clients are stored here.\n *\n * This convenience API allows consumers to free multiple regulator\n * clients in a single API call.\n */\nvoid regulator_bulk_free(int num_consumers,\n\t\t\t struct regulator_bulk_data *consumers)\n{\n\tint i;\n\n\tfor (i = 0; i < num_consumers; i++) {\n\t\tregulator_put(consumers[i].consumer);\n\t\tconsumers[i].consumer = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_free);\n\n/**\n * regulator_notifier_call_chain - call regulator event notifier\n * @rdev: regulator source\n * @event: notifier block\n * @data: callback-specific data.\n *\n * Called by regulator drivers to notify clients a regulator event has\n * occurred. We also notify regulator clients downstream.\n * Note lock must be held by caller.\n */\nint regulator_notifier_call_chain(struct regulator_dev *rdev,\n\t\t\t\t  unsigned long event, void *data)\n{\n\t_notifier_call_chain(rdev, event, data);\n\treturn NOTIFY_DONE;\n\n}\nEXPORT_SYMBOL_GPL(regulator_notifier_call_chain);\n\n/**\n * regulator_mode_to_status - convert a regulator mode into a status\n *\n * @mode: Mode to convert\n *\n * Convert a regulator mode into a status.\n */\nint regulator_mode_to_status(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\treturn REGULATOR_STATUS_FAST;\n\tcase REGULATOR_MODE_NORMAL:\n\t\treturn REGULATOR_STATUS_NORMAL;\n\tcase REGULATOR_MODE_IDLE:\n\t\treturn REGULATOR_STATUS_IDLE;\n\tcase REGULATOR_MODE_STANDBY:\n\t\treturn REGULATOR_STATUS_STANDBY;\n\tdefault:\n\t\treturn REGULATOR_STATUS_UNDEFINED;\n\t}\n}\nEXPORT_SYMBOL_GPL(regulator_mode_to_status);\n\n/*\n * To avoid cluttering sysfs (and memory) with useless state, only\n * create attributes that can be meaningfully displayed.\n */\nstatic int add_regulator_attributes(struct regulator_dev *rdev)\n{\n\tstruct device *dev = &rdev->dev;\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\tint status = 0;\n\n\t/* some attributes need specific methods to be displayed */\n\tif ((ops->get_voltage && ops->get_voltage(rdev) >= 0) ||\n\t    (ops->get_voltage_sel && ops->get_voltage_sel(rdev) >= 0) ||\n\t    (ops->list_voltage && ops->list_voltage(rdev, 0) >= 0) ||\n\t\t(rdev->desc->fixed_uV && (rdev->desc->n_voltages == 1))) {\n\t\tstatus = device_create_file(dev, &dev_attr_microvolts);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\tif (ops->get_current_limit) {\n\t\tstatus = device_create_file(dev, &dev_attr_microamps);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\tif (ops->get_mode) {\n\t\tstatus = device_create_file(dev, &dev_attr_opmode);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\tif (rdev->ena_pin || ops->is_enabled) {\n\t\tstatus = device_create_file(dev, &dev_attr_state);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\tif (ops->get_status) {\n\t\tstatus = device_create_file(dev, &dev_attr_status);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\tif (ops->get_bypass) {\n\t\tstatus = device_create_file(dev, &dev_attr_bypass);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\t/* some attributes are type-specific */\n\tif (rdev->desc->type == REGULATOR_CURRENT) {\n\t\tstatus = device_create_file(dev, &dev_attr_requested_microamps);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\t/* all the other attributes exist to support constraints;\n\t * don't show them if there are no constraints, or if the\n\t * relevant supporting methods are missing.\n\t */\n\tif (!rdev->constraints)\n\t\treturn status;\n\n\t/* constraints need specific supporting methods */\n\tif (ops->set_voltage || ops->set_voltage_sel) {\n\t\tstatus = device_create_file(dev, &dev_attr_min_microvolts);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tstatus = device_create_file(dev, &dev_attr_max_microvolts);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\tif (ops->set_current_limit) {\n\t\tstatus = device_create_file(dev, &dev_attr_min_microamps);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tstatus = device_create_file(dev, &dev_attr_max_microamps);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\tstatus = device_create_file(dev, &dev_attr_suspend_standby_state);\n\tif (status < 0)\n\t\treturn status;\n\tstatus = device_create_file(dev, &dev_attr_suspend_mem_state);\n\tif (status < 0)\n\t\treturn status;\n\tstatus = device_create_file(dev, &dev_attr_suspend_disk_state);\n\tif (status < 0)\n\t\treturn status;\n\n\tif (ops->set_suspend_voltage) {\n\t\tstatus = device_create_file(dev,\n\t\t\t\t&dev_attr_suspend_standby_microvolts);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tstatus = device_create_file(dev,\n\t\t\t\t&dev_attr_suspend_mem_microvolts);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tstatus = device_create_file(dev,\n\t\t\t\t&dev_attr_suspend_disk_microvolts);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\tif (ops->set_suspend_mode) {\n\t\tstatus = device_create_file(dev,\n\t\t\t\t&dev_attr_suspend_standby_mode);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tstatus = device_create_file(dev,\n\t\t\t\t&dev_attr_suspend_mem_mode);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tstatus = device_create_file(dev,\n\t\t\t\t&dev_attr_suspend_disk_mode);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\treturn status;\n}\n\nstatic void rdev_init_debugfs(struct regulator_dev *rdev)\n{\n\trdev->debugfs = debugfs_create_dir(rdev_get_name(rdev), debugfs_root);\n\tif (!rdev->debugfs) {\n\t\trdev_warn(rdev, \"Failed to create debugfs directory\\n\");\n\t\treturn;\n\t}\n\n\tdebugfs_create_u32(\"use_count\", 0444, rdev->debugfs,\n\t\t\t   &rdev->use_count);\n\tdebugfs_create_u32(\"open_count\", 0444, rdev->debugfs,\n\t\t\t   &rdev->open_count);\n\tdebugfs_create_u32(\"bypass_count\", 0444, rdev->debugfs,\n\t\t\t   &rdev->bypass_count);\n}\n\n/**\n * regulator_register - register regulator\n * @regulator_desc: regulator to register\n * @config: runtime configuration for regulator\n *\n * Called by regulator drivers to register a regulator.\n * Returns a valid pointer to struct regulator_dev on success\n * or an ERR_PTR() on error.\n */\nstruct regulator_dev *\nregulator_register(const struct regulator_desc *regulator_desc,\n\t\t   const struct regulator_config *config)\n{\n\tconst struct regulation_constraints *constraints = NULL;\n\tconst struct regulator_init_data *init_data;\n\tstatic atomic_t regulator_no = ATOMIC_INIT(0);\n\tstruct regulator_dev *rdev;\n\tstruct device *dev;\n\tint ret, i;\n\tconst char *supply = NULL;\n\n\tif (regulator_desc == NULL || config == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = config->dev;\n\tWARN_ON(!dev);\n\n\tif (regulator_desc->name == NULL || regulator_desc->ops == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (regulator_desc->type != REGULATOR_VOLTAGE &&\n\t    regulator_desc->type != REGULATOR_CURRENT)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Only one of each should be implemented */\n\tWARN_ON(regulator_desc->ops->get_voltage &&\n\t\tregulator_desc->ops->get_voltage_sel);\n\tWARN_ON(regulator_desc->ops->set_voltage &&\n\t\tregulator_desc->ops->set_voltage_sel);\n\n\t/* If we're using selectors we must implement list_voltage. */\n\tif (regulator_desc->ops->get_voltage_sel &&\n\t    !regulator_desc->ops->list_voltage) {\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (regulator_desc->ops->set_voltage_sel &&\n\t    !regulator_desc->ops->list_voltage) {\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\trdev = kzalloc(sizeof(struct regulator_dev), GFP_KERNEL);\n\tif (rdev == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit_data = regulator_of_get_init_data(dev, regulator_desc,\n\t\t\t\t\t       &rdev->dev.of_node);\n\tif (!init_data) {\n\t\tinit_data = config->init_data;\n\t\trdev->dev.of_node = of_node_get(config->of_node);\n\t}\n\n\tmutex_lock(&regulator_list_mutex);\n\n\tmutex_init(&rdev->mutex);\n\trdev->reg_data = config->driver_data;\n\trdev->owner = regulator_desc->owner;\n\trdev->desc = regulator_desc;\n\tif (config->regmap)\n\t\trdev->regmap = config->regmap;\n\telse if (dev_get_regmap(dev, NULL))\n\t\trdev->regmap = dev_get_regmap(dev, NULL);\n\telse if (dev->parent)\n\t\trdev->regmap = dev_get_regmap(dev->parent, NULL);\n\tINIT_LIST_HEAD(&rdev->consumer_list);\n\tINIT_LIST_HEAD(&rdev->list);\n\tBLOCKING_INIT_NOTIFIER_HEAD(&rdev->notifier);\n\tINIT_DELAYED_WORK(&rdev->disable_work, regulator_disable_work);\n\n\t/* preform any regulator specific init */\n\tif (init_data && init_data->regulator_init) {\n\t\tret = init_data->regulator_init(rdev->reg_data);\n\t\tif (ret < 0)\n\t\t\tgoto clean;\n\t}\n\n\t/* register with sysfs */\n\trdev->dev.class = &regulator_class;\n\trdev->dev.parent = dev;\n\tdev_set_name(&rdev->dev, \"regulator.%d\",\n\t\t     atomic_inc_return(&regulator_no) - 1);\n\tret = device_register(&rdev->dev);\n\tif (ret != 0) {\n\t\tput_device(&rdev->dev);\n\t\tgoto clean;\n\t}\n\n\tdev_set_drvdata(&rdev->dev, rdev);\n\n\tif (config->ena_gpio && gpio_is_valid(config->ena_gpio)) {\n\t\tret = regulator_ena_gpio_request(rdev, config);\n\t\tif (ret != 0) {\n\t\t\trdev_err(rdev, \"Failed to request enable GPIO%d: %d\\n\",\n\t\t\t\t config->ena_gpio, ret);\n\t\t\tgoto wash;\n\t\t}\n\n\t\tif (config->ena_gpio_flags & GPIOF_OUT_INIT_HIGH)\n\t\t\trdev->ena_gpio_state = 1;\n\n\t\tif (config->ena_gpio_invert)\n\t\t\trdev->ena_gpio_state = !rdev->ena_gpio_state;\n\t}\n\n\t/* set regulator constraints */\n\tif (init_data)\n\t\tconstraints = &init_data->constraints;\n\n\tret = set_machine_constraints(rdev, constraints);\n\tif (ret < 0)\n\t\tgoto scrub;\n\n\t/* add attributes supported by this regulator */\n\tret = add_regulator_attributes(rdev);\n\tif (ret < 0)\n\t\tgoto scrub;\n\n\tif (init_data && init_data->supply_regulator)\n\t\tsupply = init_data->supply_regulator;\n\telse if (regulator_desc->supply_name)\n\t\tsupply = regulator_desc->supply_name;\n\n\tif (supply) {\n\t\tstruct regulator_dev *r;\n\n\t\tr = regulator_dev_lookup(dev, supply, &ret);\n\n\t\tif (ret == -ENODEV) {\n\t\t\t/*\n\t\t\t * No supply was specified for this regulator and\n\t\t\t * there will never be one.\n\t\t\t */\n\t\t\tret = 0;\n\t\t\tgoto add_dev;\n\t\t} else if (!r) {\n\t\t\tdev_err(dev, \"Failed to find supply %s\\n\", supply);\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto scrub;\n\t\t}\n\n\t\tret = set_supply(rdev, r);\n\t\tif (ret < 0)\n\t\t\tgoto scrub;\n\n\t\t/* Enable supply if rail is enabled */\n\t\tif (_regulator_is_enabled(rdev)) {\n\t\t\tret = regulator_enable(rdev->supply);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto scrub;\n\t\t}\n\t}\n\nadd_dev:\n\t/* add consumers devices */\n\tif (init_data) {\n\t\tfor (i = 0; i < init_data->num_consumer_supplies; i++) {\n\t\t\tret = set_consumer_device_supply(rdev,\n\t\t\t\tinit_data->consumer_supplies[i].dev_name,\n\t\t\t\tinit_data->consumer_supplies[i].supply);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"Failed to set supply %s\\n\",\n\t\t\t\t\tinit_data->consumer_supplies[i].supply);\n\t\t\t\tgoto unset_supplies;\n\t\t\t}\n\t\t}\n\t}\n\n\tlist_add(&rdev->list, &regulator_list);\n\n\trdev_init_debugfs(rdev);\nout:\n\tmutex_unlock(&regulator_list_mutex);\n\treturn rdev;\n\nunset_supplies:\n\tunset_regulator_supplies(rdev);\n\nscrub:\n\tif (rdev->supply)\n\t\t_regulator_put(rdev->supply);\n\tregulator_ena_gpio_free(rdev);\n\tkfree(rdev->constraints);\nwash:\n\tdevice_unregister(&rdev->dev);\n\t/* device core frees rdev */\n\trdev = ERR_PTR(ret);\n\tgoto out;\n\nclean:\n\tkfree(rdev);\n\trdev = ERR_PTR(ret);\n\tgoto out;\n}\nEXPORT_SYMBOL_GPL(regulator_register);\n\n/**\n * regulator_unregister - unregister regulator\n * @rdev: regulator to unregister\n *\n * Called by regulator drivers to unregister a regulator.\n */\nvoid regulator_unregister(struct regulator_dev *rdev)\n{\n\tif (rdev == NULL)\n\t\treturn;\n\n\tif (rdev->supply) {\n\t\twhile (rdev->use_count--)\n\t\t\tregulator_disable(rdev->supply);\n\t\tregulator_put(rdev->supply);\n\t}\n\tmutex_lock(&regulator_list_mutex);\n\tdebugfs_remove_recursive(rdev->debugfs);\n\tflush_work(&rdev->disable_work.work);\n\tWARN_ON(rdev->open_count);\n\tunset_regulator_supplies(rdev);\n\tlist_del(&rdev->list);\n\tkfree(rdev->constraints);\n\tregulator_ena_gpio_free(rdev);\n\tof_node_put(rdev->dev.of_node);\n\tdevice_unregister(&rdev->dev);\n\tmutex_unlock(&regulator_list_mutex);\n}\nEXPORT_SYMBOL_GPL(regulator_unregister);\n\n/**\n * regulator_suspend_prepare - prepare regulators for system wide suspend\n * @state: system suspend state\n *\n * Configure each regulator with it's suspend operating parameters for state.\n * This will usually be called by machine suspend code prior to supending.\n */\nint regulator_suspend_prepare(suspend_state_t state)\n{\n\tstruct regulator_dev *rdev;\n\tint ret = 0;\n\n\t/* ON is handled by regulator active state */\n\tif (state == PM_SUSPEND_ON)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&regulator_list_mutex);\n\tlist_for_each_entry(rdev, &regulator_list, list) {\n\n\t\tmutex_lock(&rdev->mutex);\n\t\tret = suspend_prepare(rdev, state);\n\t\tmutex_unlock(&rdev->mutex);\n\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to prepare\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&regulator_list_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_suspend_prepare);\n\n/**\n * regulator_suspend_finish - resume regulators from system wide suspend\n *\n * Turn on regulators that might be turned off by regulator_suspend_prepare\n * and that should be turned on according to the regulators properties.\n */\nint regulator_suspend_finish(void)\n{\n\tstruct regulator_dev *rdev;\n\tint ret = 0, error;\n\n\tmutex_lock(&regulator_list_mutex);\n\tlist_for_each_entry(rdev, &regulator_list, list) {\n\t\tmutex_lock(&rdev->mutex);\n\t\tif (rdev->use_count > 0  || rdev->constraints->always_on) {\n\t\t\terror = _regulator_do_enable(rdev);\n\t\t\tif (error)\n\t\t\t\tret = error;\n\t\t} else {\n\t\t\tif (!have_full_constraints())\n\t\t\t\tgoto unlock;\n\t\t\tif (!_regulator_is_enabled(rdev))\n\t\t\t\tgoto unlock;\n\n\t\t\terror = _regulator_do_disable(rdev);\n\t\t\tif (error)\n\t\t\t\tret = error;\n\t\t}\nunlock:\n\t\tmutex_unlock(&rdev->mutex);\n\t}\n\tmutex_unlock(&regulator_list_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_suspend_finish);\n\n/**\n * regulator_has_full_constraints - the system has fully specified constraints\n *\n * Calling this function will cause the regulator API to disable all\n * regulators which have a zero use count and don't have an always_on\n * constraint in a late_initcall.\n *\n * The intention is that this will become the default behaviour in a\n * future kernel release so users are encouraged to use this facility\n * now.\n */\nvoid regulator_has_full_constraints(void)\n{\n\thas_full_constraints = 1;\n}\nEXPORT_SYMBOL_GPL(regulator_has_full_constraints);\n\n/**\n * rdev_get_drvdata - get rdev regulator driver data\n * @rdev: regulator\n *\n * Get rdev regulator driver private data. This call can be used in the\n * regulator driver context.\n */\nvoid *rdev_get_drvdata(struct regulator_dev *rdev)\n{\n\treturn rdev->reg_data;\n}\nEXPORT_SYMBOL_GPL(rdev_get_drvdata);\n\n/**\n * regulator_get_drvdata - get regulator driver data\n * @regulator: regulator\n *\n * Get regulator driver private data. This call can be used in the consumer\n * driver context when non API regulator specific functions need to be called.\n */\nvoid *regulator_get_drvdata(struct regulator *regulator)\n{\n\treturn regulator->rdev->reg_data;\n}\nEXPORT_SYMBOL_GPL(regulator_get_drvdata);\n\n/**\n * regulator_set_drvdata - set regulator driver data\n * @regulator: regulator\n * @data: data\n */\nvoid regulator_set_drvdata(struct regulator *regulator, void *data)\n{\n\tregulator->rdev->reg_data = data;\n}\nEXPORT_SYMBOL_GPL(regulator_set_drvdata);\n\n/**\n * regulator_get_id - get regulator ID\n * @rdev: regulator\n */\nint rdev_get_id(struct regulator_dev *rdev)\n{\n\treturn rdev->desc->id;\n}\nEXPORT_SYMBOL_GPL(rdev_get_id);\n\nstruct device *rdev_get_dev(struct regulator_dev *rdev)\n{\n\treturn &rdev->dev;\n}\nEXPORT_SYMBOL_GPL(rdev_get_dev);\n\nvoid *regulator_get_init_drvdata(struct regulator_init_data *reg_init_data)\n{\n\treturn reg_init_data->driver_data;\n}\nEXPORT_SYMBOL_GPL(regulator_get_init_drvdata);\n\n#ifdef CONFIG_DEBUG_FS\nstatic ssize_t supply_map_read_file(struct file *file, char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tchar *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tssize_t len, ret = 0;\n\tstruct regulator_map *map;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(map, &regulator_map_list, list) {\n\t\tlen = snprintf(buf + ret, PAGE_SIZE - ret,\n\t\t\t       \"%s -> %s.%s\\n\",\n\t\t\t       rdev_get_name(map->regulator), map->dev_name,\n\t\t\t       map->supply);\n\t\tif (len >= 0)\n\t\t\tret += len;\n\t\tif (ret > PAGE_SIZE) {\n\t\t\tret = PAGE_SIZE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);\n\n\tkfree(buf);\n\n\treturn ret;\n}\n#endif\n\nstatic const struct file_operations supply_map_fops = {\n#ifdef CONFIG_DEBUG_FS\n\t.read = supply_map_read_file,\n\t.llseek = default_llseek,\n#endif\n};\n\nstatic int __init regulator_init(void)\n{\n\tint ret;\n\n\tret = class_register(&regulator_class);\n\n\tdebugfs_root = debugfs_create_dir(\"regulator\", NULL);\n\tif (!debugfs_root)\n\t\tpr_warn(\"regulator: Failed to create debugfs directory\\n\");\n\n\tdebugfs_create_file(\"supply_map\", 0444, debugfs_root, NULL,\n\t\t\t    &supply_map_fops);\n\n\tregulator_dummy_init();\n\n\treturn ret;\n}\n\n/* init early to allow our consumers to complete system booting */\ncore_initcall(regulator_init);\n\nstatic int __init regulator_init_complete(void)\n{\n\tstruct regulator_dev *rdev;\n\tconst struct regulator_ops *ops;\n\tstruct regulation_constraints *c;\n\tint enabled, ret;\n\n\t/*\n\t * Since DT doesn't provide an idiomatic mechanism for\n\t * enabling full constraints and since it's much more natural\n\t * with DT to provide them just assume that a DT enabled\n\t * system has full constraints.\n\t */\n\tif (of_have_populated_dt())\n\t\thas_full_constraints = true;\n\n\tmutex_lock(&regulator_list_mutex);\n\n\t/* If we have a full configuration then disable any regulators\n\t * we have permission to change the status for and which are\n\t * not in use or always_on.  This is effectively the default\n\t * for DT and ACPI as they have full constraints.\n\t */\n\tlist_for_each_entry(rdev, &regulator_list, list) {\n\t\tops = rdev->desc->ops;\n\t\tc = rdev->constraints;\n\n\t\tif (c && c->always_on)\n\t\t\tcontinue;\n\n\t\tif (c && !(c->valid_ops_mask & REGULATOR_CHANGE_STATUS))\n\t\t\tcontinue;\n\n\t\tmutex_lock(&rdev->mutex);\n\n\t\tif (rdev->use_count)\n\t\t\tgoto unlock;\n\n\t\t/* If we can't read the status assume it's on. */\n\t\tif (ops->is_enabled)\n\t\t\tenabled = ops->is_enabled(rdev);\n\t\telse\n\t\t\tenabled = 1;\n\n\t\tif (!enabled)\n\t\t\tgoto unlock;\n\n\t\tif (have_full_constraints()) {\n\t\t\t/* We log since this may kill the system if it\n\t\t\t * goes wrong. */\n\t\t\trdev_info(rdev, \"disabling\\n\");\n\t\t\tret = _regulator_do_disable(rdev);\n\t\t\tif (ret != 0)\n\t\t\t\trdev_err(rdev, \"couldn't disable: %d\\n\", ret);\n\t\t} else {\n\t\t\t/* The intention is that in future we will\n\t\t\t * assume that full constraints are provided\n\t\t\t * so warn even if we aren't going to do\n\t\t\t * anything here.\n\t\t\t */\n\t\t\trdev_warn(rdev, \"incomplete constraints, leaving on\\n\");\n\t\t}\n\nunlock:\n\t\tmutex_unlock(&rdev->mutex);\n\t}\n\n\tmutex_unlock(&regulator_list_mutex);\n\n\treturn 0;\n}\nlate_initcall_sync(regulator_init_complete);\n"], "fixing_code": ["/*\n * core.c  --  Voltage/Current Regulator framework.\n *\n * Copyright 2007, 2008 Wolfson Microelectronics PLC.\n * Copyright 2008 SlimLogic Ltd.\n *\n * Author: Liam Girdwood <lrg@slimlogic.co.uk>\n *\n *  This program is free software; you can redistribute  it and/or modify it\n *  under  the terms of  the GNU General  Public License as published by the\n *  Free Software Foundation;  either version 2 of the  License, or (at your\n *  option) any later version.\n *\n */\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/async.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/suspend.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/module.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/regulator.h>\n\n#include \"dummy.h\"\n#include \"internal.h\"\n\n#define rdev_crit(rdev, fmt, ...)\t\t\t\t\t\\\n\tpr_crit(\"%s: \" fmt, rdev_get_name(rdev), ##__VA_ARGS__)\n#define rdev_err(rdev, fmt, ...)\t\t\t\t\t\\\n\tpr_err(\"%s: \" fmt, rdev_get_name(rdev), ##__VA_ARGS__)\n#define rdev_warn(rdev, fmt, ...)\t\t\t\t\t\\\n\tpr_warn(\"%s: \" fmt, rdev_get_name(rdev), ##__VA_ARGS__)\n#define rdev_info(rdev, fmt, ...)\t\t\t\t\t\\\n\tpr_info(\"%s: \" fmt, rdev_get_name(rdev), ##__VA_ARGS__)\n#define rdev_dbg(rdev, fmt, ...)\t\t\t\t\t\\\n\tpr_debug(\"%s: \" fmt, rdev_get_name(rdev), ##__VA_ARGS__)\n\nstatic DEFINE_MUTEX(regulator_list_mutex);\nstatic LIST_HEAD(regulator_list);\nstatic LIST_HEAD(regulator_map_list);\nstatic LIST_HEAD(regulator_ena_gpio_list);\nstatic LIST_HEAD(regulator_supply_alias_list);\nstatic bool has_full_constraints;\n\nstatic struct dentry *debugfs_root;\n\n/*\n * struct regulator_map\n *\n * Used to provide symbolic supply names to devices.\n */\nstruct regulator_map {\n\tstruct list_head list;\n\tconst char *dev_name;   /* The dev_name() for the consumer */\n\tconst char *supply;\n\tstruct regulator_dev *regulator;\n};\n\n/*\n * struct regulator_enable_gpio\n *\n * Management for shared enable GPIO pin\n */\nstruct regulator_enable_gpio {\n\tstruct list_head list;\n\tstruct gpio_desc *gpiod;\n\tu32 enable_count;\t/* a number of enabled shared GPIO */\n\tu32 request_count;\t/* a number of requested shared GPIO */\n\tunsigned int ena_gpio_invert:1;\n};\n\n/*\n * struct regulator_supply_alias\n *\n * Used to map lookups for a supply onto an alternative device.\n */\nstruct regulator_supply_alias {\n\tstruct list_head list;\n\tstruct device *src_dev;\n\tconst char *src_supply;\n\tstruct device *alias_dev;\n\tconst char *alias_supply;\n};\n\nstatic int _regulator_is_enabled(struct regulator_dev *rdev);\nstatic int _regulator_disable(struct regulator_dev *rdev);\nstatic int _regulator_get_voltage(struct regulator_dev *rdev);\nstatic int _regulator_get_current_limit(struct regulator_dev *rdev);\nstatic unsigned int _regulator_get_mode(struct regulator_dev *rdev);\nstatic int _notifier_call_chain(struct regulator_dev *rdev,\n\t\t\t\t  unsigned long event, void *data);\nstatic int _regulator_do_set_voltage(struct regulator_dev *rdev,\n\t\t\t\t     int min_uV, int max_uV);\nstatic struct regulator *create_regulator(struct regulator_dev *rdev,\n\t\t\t\t\t  struct device *dev,\n\t\t\t\t\t  const char *supply_name);\n\nstatic const char *rdev_get_name(struct regulator_dev *rdev)\n{\n\tif (rdev->constraints && rdev->constraints->name)\n\t\treturn rdev->constraints->name;\n\telse if (rdev->desc->name)\n\t\treturn rdev->desc->name;\n\telse\n\t\treturn \"\";\n}\n\nstatic bool have_full_constraints(void)\n{\n\treturn has_full_constraints || of_have_populated_dt();\n}\n\n/**\n * of_get_regulator - get a regulator device node based on supply name\n * @dev: Device pointer for the consumer (of regulator) device\n * @supply: regulator supply name\n *\n * Extract the regulator device node corresponding to the supply name.\n * returns the device node corresponding to the regulator if found, else\n * returns NULL.\n */\nstatic struct device_node *of_get_regulator(struct device *dev, const char *supply)\n{\n\tstruct device_node *regnode = NULL;\n\tchar prop_name[32]; /* 32 is max size of property name */\n\n\tdev_dbg(dev, \"Looking up %s-supply from device tree\\n\", supply);\n\n\tsnprintf(prop_name, 32, \"%s-supply\", supply);\n\tregnode = of_parse_phandle(dev->of_node, prop_name, 0);\n\n\tif (!regnode) {\n\t\tdev_dbg(dev, \"Looking up %s property in node %s failed\",\n\t\t\t\tprop_name, dev->of_node->full_name);\n\t\treturn NULL;\n\t}\n\treturn regnode;\n}\n\nstatic int _regulator_can_change_status(struct regulator_dev *rdev)\n{\n\tif (!rdev->constraints)\n\t\treturn 0;\n\n\tif (rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_STATUS)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n/* Platform voltage constraint check */\nstatic int regulator_check_voltage(struct regulator_dev *rdev,\n\t\t\t\t   int *min_uV, int *max_uV)\n{\n\tBUG_ON(*min_uV > *max_uV);\n\n\tif (!rdev->constraints) {\n\t\trdev_err(rdev, \"no constraints\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {\n\t\trdev_err(rdev, \"operation not allowed\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (*max_uV > rdev->constraints->max_uV)\n\t\t*max_uV = rdev->constraints->max_uV;\n\tif (*min_uV < rdev->constraints->min_uV)\n\t\t*min_uV = rdev->constraints->min_uV;\n\n\tif (*min_uV > *max_uV) {\n\t\trdev_err(rdev, \"unsupportable voltage range: %d-%duV\\n\",\n\t\t\t *min_uV, *max_uV);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* Make sure we select a voltage that suits the needs of all\n * regulator consumers\n */\nstatic int regulator_check_consumers(struct regulator_dev *rdev,\n\t\t\t\t     int *min_uV, int *max_uV)\n{\n\tstruct regulator *regulator;\n\n\tlist_for_each_entry(regulator, &rdev->consumer_list, list) {\n\t\t/*\n\t\t * Assume consumers that didn't say anything are OK\n\t\t * with anything in the constraint range.\n\t\t */\n\t\tif (!regulator->min_uV && !regulator->max_uV)\n\t\t\tcontinue;\n\n\t\tif (*max_uV > regulator->max_uV)\n\t\t\t*max_uV = regulator->max_uV;\n\t\tif (*min_uV < regulator->min_uV)\n\t\t\t*min_uV = regulator->min_uV;\n\t}\n\n\tif (*min_uV > *max_uV) {\n\t\trdev_err(rdev, \"Restricting voltage, %u-%uuV\\n\",\n\t\t\t*min_uV, *max_uV);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* current constraint check */\nstatic int regulator_check_current_limit(struct regulator_dev *rdev,\n\t\t\t\t\tint *min_uA, int *max_uA)\n{\n\tBUG_ON(*min_uA > *max_uA);\n\n\tif (!rdev->constraints) {\n\t\trdev_err(rdev, \"no constraints\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_CURRENT)) {\n\t\trdev_err(rdev, \"operation not allowed\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (*max_uA > rdev->constraints->max_uA)\n\t\t*max_uA = rdev->constraints->max_uA;\n\tif (*min_uA < rdev->constraints->min_uA)\n\t\t*min_uA = rdev->constraints->min_uA;\n\n\tif (*min_uA > *max_uA) {\n\t\trdev_err(rdev, \"unsupportable current range: %d-%duA\\n\",\n\t\t\t *min_uA, *max_uA);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* operating mode constraint check */\nstatic int regulator_mode_constrain(struct regulator_dev *rdev, int *mode)\n{\n\tswitch (*mode) {\n\tcase REGULATOR_MODE_FAST:\n\tcase REGULATOR_MODE_NORMAL:\n\tcase REGULATOR_MODE_IDLE:\n\tcase REGULATOR_MODE_STANDBY:\n\t\tbreak;\n\tdefault:\n\t\trdev_err(rdev, \"invalid mode %x specified\\n\", *mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->constraints) {\n\t\trdev_err(rdev, \"no constraints\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_MODE)) {\n\t\trdev_err(rdev, \"operation not allowed\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The modes are bitmasks, the most power hungry modes having\n\t * the lowest values. If the requested mode isn't supported\n\t * try higher modes. */\n\twhile (*mode) {\n\t\tif (rdev->constraints->valid_modes_mask & *mode)\n\t\t\treturn 0;\n\t\t*mode /= 2;\n\t}\n\n\treturn -EINVAL;\n}\n\n/* dynamic regulator mode switching constraint check */\nstatic int regulator_check_drms(struct regulator_dev *rdev)\n{\n\tif (!rdev->constraints) {\n\t\trdev_err(rdev, \"no constraints\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_DRMS)) {\n\t\trdev_err(rdev, \"operation not allowed\\n\");\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t regulator_uV_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\tssize_t ret;\n\n\tmutex_lock(&rdev->mutex);\n\tret = sprintf(buf, \"%d\\n\", _regulator_get_voltage(rdev));\n\tmutex_unlock(&rdev->mutex);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR(microvolts, 0444, regulator_uV_show, NULL);\n\nstatic ssize_t regulator_uA_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", _regulator_get_current_limit(rdev));\n}\nstatic DEVICE_ATTR(microamps, 0444, regulator_uA_show, NULL);\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", rdev_get_name(rdev));\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t regulator_print_opmode(char *buf, int mode)\n{\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\treturn sprintf(buf, \"fast\\n\");\n\tcase REGULATOR_MODE_NORMAL:\n\t\treturn sprintf(buf, \"normal\\n\");\n\tcase REGULATOR_MODE_IDLE:\n\t\treturn sprintf(buf, \"idle\\n\");\n\tcase REGULATOR_MODE_STANDBY:\n\t\treturn sprintf(buf, \"standby\\n\");\n\t}\n\treturn sprintf(buf, \"unknown\\n\");\n}\n\nstatic ssize_t regulator_opmode_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_opmode(buf, _regulator_get_mode(rdev));\n}\nstatic DEVICE_ATTR(opmode, 0444, regulator_opmode_show, NULL);\n\nstatic ssize_t regulator_print_state(char *buf, int state)\n{\n\tif (state > 0)\n\t\treturn sprintf(buf, \"enabled\\n\");\n\telse if (state == 0)\n\t\treturn sprintf(buf, \"disabled\\n\");\n\telse\n\t\treturn sprintf(buf, \"unknown\\n\");\n}\n\nstatic ssize_t regulator_state_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\tssize_t ret;\n\n\tmutex_lock(&rdev->mutex);\n\tret = regulator_print_state(buf, _regulator_is_enabled(rdev));\n\tmutex_unlock(&rdev->mutex);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR(state, 0444, regulator_state_show, NULL);\n\nstatic ssize_t regulator_status_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\tint status;\n\tchar *label;\n\n\tstatus = rdev->desc->ops->get_status(rdev);\n\tif (status < 0)\n\t\treturn status;\n\n\tswitch (status) {\n\tcase REGULATOR_STATUS_OFF:\n\t\tlabel = \"off\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_ON:\n\t\tlabel = \"on\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_ERROR:\n\t\tlabel = \"error\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_FAST:\n\t\tlabel = \"fast\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_NORMAL:\n\t\tlabel = \"normal\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_IDLE:\n\t\tlabel = \"idle\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_STANDBY:\n\t\tlabel = \"standby\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_BYPASS:\n\t\tlabel = \"bypass\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_UNDEFINED:\n\t\tlabel = \"undefined\";\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\treturn sprintf(buf, \"%s\\n\", label);\n}\nstatic DEVICE_ATTR(status, 0444, regulator_status_show, NULL);\n\nstatic ssize_t regulator_min_uA_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tif (!rdev->constraints)\n\t\treturn sprintf(buf, \"constraint not defined\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->min_uA);\n}\nstatic DEVICE_ATTR(min_microamps, 0444, regulator_min_uA_show, NULL);\n\nstatic ssize_t regulator_max_uA_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tif (!rdev->constraints)\n\t\treturn sprintf(buf, \"constraint not defined\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->max_uA);\n}\nstatic DEVICE_ATTR(max_microamps, 0444, regulator_max_uA_show, NULL);\n\nstatic ssize_t regulator_min_uV_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tif (!rdev->constraints)\n\t\treturn sprintf(buf, \"constraint not defined\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->min_uV);\n}\nstatic DEVICE_ATTR(min_microvolts, 0444, regulator_min_uV_show, NULL);\n\nstatic ssize_t regulator_max_uV_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tif (!rdev->constraints)\n\t\treturn sprintf(buf, \"constraint not defined\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->max_uV);\n}\nstatic DEVICE_ATTR(max_microvolts, 0444, regulator_max_uV_show, NULL);\n\nstatic ssize_t regulator_total_uA_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\tstruct regulator *regulator;\n\tint uA = 0;\n\n\tmutex_lock(&rdev->mutex);\n\tlist_for_each_entry(regulator, &rdev->consumer_list, list)\n\t\tuA += regulator->uA_load;\n\tmutex_unlock(&rdev->mutex);\n\treturn sprintf(buf, \"%d\\n\", uA);\n}\nstatic DEVICE_ATTR(requested_microamps, 0444, regulator_total_uA_show, NULL);\n\nstatic ssize_t num_users_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", rdev->use_count);\n}\nstatic DEVICE_ATTR_RO(num_users);\n\nstatic ssize_t type_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tswitch (rdev->desc->type) {\n\tcase REGULATOR_VOLTAGE:\n\t\treturn sprintf(buf, \"voltage\\n\");\n\tcase REGULATOR_CURRENT:\n\t\treturn sprintf(buf, \"current\\n\");\n\t}\n\treturn sprintf(buf, \"unknown\\n\");\n}\nstatic DEVICE_ATTR_RO(type);\n\nstatic ssize_t regulator_suspend_mem_uV_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->state_mem.uV);\n}\nstatic DEVICE_ATTR(suspend_mem_microvolts, 0444,\n\t\tregulator_suspend_mem_uV_show, NULL);\n\nstatic ssize_t regulator_suspend_disk_uV_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->state_disk.uV);\n}\nstatic DEVICE_ATTR(suspend_disk_microvolts, 0444,\n\t\tregulator_suspend_disk_uV_show, NULL);\n\nstatic ssize_t regulator_suspend_standby_uV_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->state_standby.uV);\n}\nstatic DEVICE_ATTR(suspend_standby_microvolts, 0444,\n\t\tregulator_suspend_standby_uV_show, NULL);\n\nstatic ssize_t regulator_suspend_mem_mode_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_opmode(buf,\n\t\trdev->constraints->state_mem.mode);\n}\nstatic DEVICE_ATTR(suspend_mem_mode, 0444,\n\t\tregulator_suspend_mem_mode_show, NULL);\n\nstatic ssize_t regulator_suspend_disk_mode_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_opmode(buf,\n\t\trdev->constraints->state_disk.mode);\n}\nstatic DEVICE_ATTR(suspend_disk_mode, 0444,\n\t\tregulator_suspend_disk_mode_show, NULL);\n\nstatic ssize_t regulator_suspend_standby_mode_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_opmode(buf,\n\t\trdev->constraints->state_standby.mode);\n}\nstatic DEVICE_ATTR(suspend_standby_mode, 0444,\n\t\tregulator_suspend_standby_mode_show, NULL);\n\nstatic ssize_t regulator_suspend_mem_state_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_state(buf,\n\t\t\trdev->constraints->state_mem.enabled);\n}\nstatic DEVICE_ATTR(suspend_mem_state, 0444,\n\t\tregulator_suspend_mem_state_show, NULL);\n\nstatic ssize_t regulator_suspend_disk_state_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_state(buf,\n\t\t\trdev->constraints->state_disk.enabled);\n}\nstatic DEVICE_ATTR(suspend_disk_state, 0444,\n\t\tregulator_suspend_disk_state_show, NULL);\n\nstatic ssize_t regulator_suspend_standby_state_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_state(buf,\n\t\t\trdev->constraints->state_standby.enabled);\n}\nstatic DEVICE_ATTR(suspend_standby_state, 0444,\n\t\tregulator_suspend_standby_state_show, NULL);\n\nstatic ssize_t regulator_bypass_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\tconst char *report;\n\tbool bypass;\n\tint ret;\n\n\tret = rdev->desc->ops->get_bypass(rdev, &bypass);\n\n\tif (ret != 0)\n\t\treport = \"unknown\";\n\telse if (bypass)\n\t\treport = \"enabled\";\n\telse\n\t\treport = \"disabled\";\n\n\treturn sprintf(buf, \"%s\\n\", report);\n}\nstatic DEVICE_ATTR(bypass, 0444,\n\t\t   regulator_bypass_show, NULL);\n\n/*\n * These are the only attributes are present for all regulators.\n * Other attributes are a function of regulator functionality.\n */\nstatic struct attribute *regulator_dev_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_num_users.attr,\n\t&dev_attr_type.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(regulator_dev);\n\nstatic void regulator_dev_release(struct device *dev)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\tkfree(rdev);\n}\n\nstatic struct class regulator_class = {\n\t.name = \"regulator\",\n\t.dev_release = regulator_dev_release,\n\t.dev_groups = regulator_dev_groups,\n};\n\n/* Calculate the new optimum regulator operating mode based on the new total\n * consumer load. All locks held by caller */\nstatic void drms_uA_update(struct regulator_dev *rdev)\n{\n\tstruct regulator *sibling;\n\tint current_uA = 0, output_uV, input_uV, err;\n\tunsigned int mode;\n\n\terr = regulator_check_drms(rdev);\n\tif (err < 0 || !rdev->desc->ops->get_optimum_mode ||\n\t    (!rdev->desc->ops->get_voltage &&\n\t     !rdev->desc->ops->get_voltage_sel) ||\n\t    !rdev->desc->ops->set_mode)\n\t\treturn;\n\n\t/* get output voltage */\n\toutput_uV = _regulator_get_voltage(rdev);\n\tif (output_uV <= 0)\n\t\treturn;\n\n\t/* get input voltage */\n\tinput_uV = 0;\n\tif (rdev->supply)\n\t\tinput_uV = regulator_get_voltage(rdev->supply);\n\tif (input_uV <= 0)\n\t\tinput_uV = rdev->constraints->input_uV;\n\tif (input_uV <= 0)\n\t\treturn;\n\n\t/* calc total requested load */\n\tlist_for_each_entry(sibling, &rdev->consumer_list, list)\n\t\tcurrent_uA += sibling->uA_load;\n\n\t/* now get the optimum mode for our new total regulator load */\n\tmode = rdev->desc->ops->get_optimum_mode(rdev, input_uV,\n\t\t\t\t\t\t  output_uV, current_uA);\n\n\t/* check the new mode is allowed */\n\terr = regulator_mode_constrain(rdev, &mode);\n\tif (err == 0)\n\t\trdev->desc->ops->set_mode(rdev, mode);\n}\n\nstatic int suspend_set_state(struct regulator_dev *rdev,\n\tstruct regulator_state *rstate)\n{\n\tint ret = 0;\n\n\t/* If we have no suspend mode configration don't set anything;\n\t * only warn if the driver implements set_suspend_voltage or\n\t * set_suspend_mode callback.\n\t */\n\tif (!rstate->enabled && !rstate->disabled) {\n\t\tif (rdev->desc->ops->set_suspend_voltage ||\n\t\t    rdev->desc->ops->set_suspend_mode)\n\t\t\trdev_warn(rdev, \"No configuration\\n\");\n\t\treturn 0;\n\t}\n\n\tif (rstate->enabled && rstate->disabled) {\n\t\trdev_err(rdev, \"invalid configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rstate->enabled && rdev->desc->ops->set_suspend_enable)\n\t\tret = rdev->desc->ops->set_suspend_enable(rdev);\n\telse if (rstate->disabled && rdev->desc->ops->set_suspend_disable)\n\t\tret = rdev->desc->ops->set_suspend_disable(rdev);\n\telse /* OK if set_suspend_enable or set_suspend_disable is NULL */\n\t\tret = 0;\n\n\tif (ret < 0) {\n\t\trdev_err(rdev, \"failed to enabled/disable\\n\");\n\t\treturn ret;\n\t}\n\n\tif (rdev->desc->ops->set_suspend_voltage && rstate->uV > 0) {\n\t\tret = rdev->desc->ops->set_suspend_voltage(rdev, rstate->uV);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set voltage\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (rdev->desc->ops->set_suspend_mode && rstate->mode > 0) {\n\t\tret = rdev->desc->ops->set_suspend_mode(rdev, rstate->mode);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set mode\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn ret;\n}\n\n/* locks held by caller */\nstatic int suspend_prepare(struct regulator_dev *rdev, suspend_state_t state)\n{\n\tif (!rdev->constraints)\n\t\treturn -EINVAL;\n\n\tswitch (state) {\n\tcase PM_SUSPEND_STANDBY:\n\t\treturn suspend_set_state(rdev,\n\t\t\t&rdev->constraints->state_standby);\n\tcase PM_SUSPEND_MEM:\n\t\treturn suspend_set_state(rdev,\n\t\t\t&rdev->constraints->state_mem);\n\tcase PM_SUSPEND_MAX:\n\t\treturn suspend_set_state(rdev,\n\t\t\t&rdev->constraints->state_disk);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void print_constraints(struct regulator_dev *rdev)\n{\n\tstruct regulation_constraints *constraints = rdev->constraints;\n\tchar buf[80] = \"\";\n\tint count = 0;\n\tint ret;\n\n\tif (constraints->min_uV && constraints->max_uV) {\n\t\tif (constraints->min_uV == constraints->max_uV)\n\t\t\tcount += sprintf(buf + count, \"%d mV \",\n\t\t\t\t\t constraints->min_uV / 1000);\n\t\telse\n\t\t\tcount += sprintf(buf + count, \"%d <--> %d mV \",\n\t\t\t\t\t constraints->min_uV / 1000,\n\t\t\t\t\t constraints->max_uV / 1000);\n\t}\n\n\tif (!constraints->min_uV ||\n\t    constraints->min_uV != constraints->max_uV) {\n\t\tret = _regulator_get_voltage(rdev);\n\t\tif (ret > 0)\n\t\t\tcount += sprintf(buf + count, \"at %d mV \", ret / 1000);\n\t}\n\n\tif (constraints->uV_offset)\n\t\tcount += sprintf(buf, \"%dmV offset \",\n\t\t\t\t constraints->uV_offset / 1000);\n\n\tif (constraints->min_uA && constraints->max_uA) {\n\t\tif (constraints->min_uA == constraints->max_uA)\n\t\t\tcount += sprintf(buf + count, \"%d mA \",\n\t\t\t\t\t constraints->min_uA / 1000);\n\t\telse\n\t\t\tcount += sprintf(buf + count, \"%d <--> %d mA \",\n\t\t\t\t\t constraints->min_uA / 1000,\n\t\t\t\t\t constraints->max_uA / 1000);\n\t}\n\n\tif (!constraints->min_uA ||\n\t    constraints->min_uA != constraints->max_uA) {\n\t\tret = _regulator_get_current_limit(rdev);\n\t\tif (ret > 0)\n\t\t\tcount += sprintf(buf + count, \"at %d mA \", ret / 1000);\n\t}\n\n\tif (constraints->valid_modes_mask & REGULATOR_MODE_FAST)\n\t\tcount += sprintf(buf + count, \"fast \");\n\tif (constraints->valid_modes_mask & REGULATOR_MODE_NORMAL)\n\t\tcount += sprintf(buf + count, \"normal \");\n\tif (constraints->valid_modes_mask & REGULATOR_MODE_IDLE)\n\t\tcount += sprintf(buf + count, \"idle \");\n\tif (constraints->valid_modes_mask & REGULATOR_MODE_STANDBY)\n\t\tcount += sprintf(buf + count, \"standby\");\n\n\tif (!count)\n\t\tsprintf(buf, \"no parameters\");\n\n\trdev_dbg(rdev, \"%s\\n\", buf);\n\n\tif ((constraints->min_uV != constraints->max_uV) &&\n\t    !(constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE))\n\t\trdev_warn(rdev,\n\t\t\t  \"Voltage range but no REGULATOR_CHANGE_VOLTAGE\\n\");\n}\n\nstatic int machine_constraints_voltage(struct regulator_dev *rdev,\n\tstruct regulation_constraints *constraints)\n{\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\tint ret;\n\n\t/* do we need to apply the constraint voltage */\n\tif (rdev->constraints->apply_uV &&\n\t    rdev->constraints->min_uV == rdev->constraints->max_uV) {\n\t\tint current_uV = _regulator_get_voltage(rdev);\n\t\tif (current_uV < 0) {\n\t\t\trdev_err(rdev,\n\t\t\t\t \"failed to get the current voltage(%d)\\n\",\n\t\t\t\t current_uV);\n\t\t\treturn current_uV;\n\t\t}\n\t\tif (current_uV < rdev->constraints->min_uV ||\n\t\t    current_uV > rdev->constraints->max_uV) {\n\t\t\tret = _regulator_do_set_voltage(\n\t\t\t\trdev, rdev->constraints->min_uV,\n\t\t\t\trdev->constraints->max_uV);\n\t\t\tif (ret < 0) {\n\t\t\t\trdev_err(rdev,\n\t\t\t\t\t\"failed to apply %duV constraint(%d)\\n\",\n\t\t\t\t\trdev->constraints->min_uV, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* constrain machine-level voltage specs to fit\n\t * the actual range supported by this regulator.\n\t */\n\tif (ops->list_voltage && rdev->desc->n_voltages) {\n\t\tint\tcount = rdev->desc->n_voltages;\n\t\tint\ti;\n\t\tint\tmin_uV = INT_MAX;\n\t\tint\tmax_uV = INT_MIN;\n\t\tint\tcmin = constraints->min_uV;\n\t\tint\tcmax = constraints->max_uV;\n\n\t\t/* it's safe to autoconfigure fixed-voltage supplies\n\t\t   and the constraints are used by list_voltage. */\n\t\tif (count == 1 && !cmin) {\n\t\t\tcmin = 1;\n\t\t\tcmax = INT_MAX;\n\t\t\tconstraints->min_uV = cmin;\n\t\t\tconstraints->max_uV = cmax;\n\t\t}\n\n\t\t/* voltage constraints are optional */\n\t\tif ((cmin == 0) && (cmax == 0))\n\t\t\treturn 0;\n\n\t\t/* else require explicit machine-level constraints */\n\t\tif (cmin <= 0 || cmax <= 0 || cmax < cmin) {\n\t\t\trdev_err(rdev, \"invalid voltage constraints\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* initial: [cmin..cmax] valid, [min_uV..max_uV] not */\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tint\tvalue;\n\n\t\t\tvalue = ops->list_voltage(rdev, i);\n\t\t\tif (value <= 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* maybe adjust [min_uV..max_uV] */\n\t\t\tif (value >= cmin && value < min_uV)\n\t\t\t\tmin_uV = value;\n\t\t\tif (value <= cmax && value > max_uV)\n\t\t\t\tmax_uV = value;\n\t\t}\n\n\t\t/* final: [min_uV..max_uV] valid iff constraints valid */\n\t\tif (max_uV < min_uV) {\n\t\t\trdev_err(rdev,\n\t\t\t\t \"unsupportable voltage constraints %u-%uuV\\n\",\n\t\t\t\t min_uV, max_uV);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* use regulator's subset of machine constraints */\n\t\tif (constraints->min_uV < min_uV) {\n\t\t\trdev_dbg(rdev, \"override min_uV, %d -> %d\\n\",\n\t\t\t\t constraints->min_uV, min_uV);\n\t\t\tconstraints->min_uV = min_uV;\n\t\t}\n\t\tif (constraints->max_uV > max_uV) {\n\t\t\trdev_dbg(rdev, \"override max_uV, %d -> %d\\n\",\n\t\t\t\t constraints->max_uV, max_uV);\n\t\t\tconstraints->max_uV = max_uV;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int machine_constraints_current(struct regulator_dev *rdev,\n\tstruct regulation_constraints *constraints)\n{\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\tint ret;\n\n\tif (!constraints->min_uA && !constraints->max_uA)\n\t\treturn 0;\n\n\tif (constraints->min_uA > constraints->max_uA) {\n\t\trdev_err(rdev, \"Invalid current constraints\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ops->set_current_limit || !ops->get_current_limit) {\n\t\trdev_warn(rdev, \"Operation of current configuration missing\\n\");\n\t\treturn 0;\n\t}\n\n\t/* Set regulator current in constraints range */\n\tret = ops->set_current_limit(rdev, constraints->min_uA,\n\t\t\tconstraints->max_uA);\n\tif (ret < 0) {\n\t\trdev_err(rdev, \"Failed to set current constraint, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int _regulator_do_enable(struct regulator_dev *rdev);\n\n/**\n * set_machine_constraints - sets regulator constraints\n * @rdev: regulator source\n * @constraints: constraints to apply\n *\n * Allows platform initialisation code to define and constrain\n * regulator circuits e.g. valid voltage/current ranges, etc.  NOTE:\n * Constraints *must* be set by platform code in order for some\n * regulator operations to proceed i.e. set_voltage, set_current_limit,\n * set_mode.\n */\nstatic int set_machine_constraints(struct regulator_dev *rdev,\n\tconst struct regulation_constraints *constraints)\n{\n\tint ret = 0;\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\n\tif (constraints)\n\t\trdev->constraints = kmemdup(constraints, sizeof(*constraints),\n\t\t\t\t\t    GFP_KERNEL);\n\telse\n\t\trdev->constraints = kzalloc(sizeof(*constraints),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!rdev->constraints)\n\t\treturn -ENOMEM;\n\n\tret = machine_constraints_voltage(rdev, rdev->constraints);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tret = machine_constraints_current(rdev, rdev->constraints);\n\tif (ret != 0)\n\t\tgoto out;\n\n\t/* do we need to setup our suspend state */\n\tif (rdev->constraints->initial_state) {\n\t\tret = suspend_prepare(rdev, rdev->constraints->initial_state);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set suspend state\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (rdev->constraints->initial_mode) {\n\t\tif (!ops->set_mode) {\n\t\t\trdev_err(rdev, \"no set_mode operation\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ops->set_mode(rdev, rdev->constraints->initial_mode);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set initial mode: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* If the constraints say the regulator should be on at this point\n\t * and we have control then make sure it is enabled.\n\t */\n\tif (rdev->constraints->always_on || rdev->constraints->boot_on) {\n\t\tret = _regulator_do_enable(rdev);\n\t\tif (ret < 0 && ret != -EINVAL) {\n\t\t\trdev_err(rdev, \"failed to enable\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif ((rdev->constraints->ramp_delay || rdev->constraints->ramp_disable)\n\t\t&& ops->set_ramp_delay) {\n\t\tret = ops->set_ramp_delay(rdev, rdev->constraints->ramp_delay);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set ramp_delay\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tprint_constraints(rdev);\n\treturn 0;\nout:\n\tkfree(rdev->constraints);\n\trdev->constraints = NULL;\n\treturn ret;\n}\n\n/**\n * set_supply - set regulator supply regulator\n * @rdev: regulator name\n * @supply_rdev: supply regulator name\n *\n * Called by platform initialisation code to set the supply regulator for this\n * regulator. This ensures that a regulators supply will also be enabled by the\n * core if it's child is enabled.\n */\nstatic int set_supply(struct regulator_dev *rdev,\n\t\t      struct regulator_dev *supply_rdev)\n{\n\tint err;\n\n\trdev_info(rdev, \"supplied by %s\\n\", rdev_get_name(supply_rdev));\n\n\trdev->supply = create_regulator(supply_rdev, &rdev->dev, \"SUPPLY\");\n\tif (rdev->supply == NULL) {\n\t\terr = -ENOMEM;\n\t\treturn err;\n\t}\n\tsupply_rdev->open_count++;\n\n\treturn 0;\n}\n\n/**\n * set_consumer_device_supply - Bind a regulator to a symbolic supply\n * @rdev:         regulator source\n * @consumer_dev_name: dev_name() string for device supply applies to\n * @supply:       symbolic name for supply\n *\n * Allows platform initialisation code to map physical regulator\n * sources to symbolic names for supplies for use by devices.  Devices\n * should use these symbolic names to request regulators, avoiding the\n * need to provide board-specific regulator names as platform data.\n */\nstatic int set_consumer_device_supply(struct regulator_dev *rdev,\n\t\t\t\t      const char *consumer_dev_name,\n\t\t\t\t      const char *supply)\n{\n\tstruct regulator_map *node;\n\tint has_dev;\n\n\tif (supply == NULL)\n\t\treturn -EINVAL;\n\n\tif (consumer_dev_name != NULL)\n\t\thas_dev = 1;\n\telse\n\t\thas_dev = 0;\n\n\tlist_for_each_entry(node, &regulator_map_list, list) {\n\t\tif (node->dev_name && consumer_dev_name) {\n\t\t\tif (strcmp(node->dev_name, consumer_dev_name) != 0)\n\t\t\t\tcontinue;\n\t\t} else if (node->dev_name || consumer_dev_name) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(node->supply, supply) != 0)\n\t\t\tcontinue;\n\n\t\tpr_debug(\"%s: %s/%s is '%s' supply; fail %s/%s\\n\",\n\t\t\t consumer_dev_name,\n\t\t\t dev_name(&node->regulator->dev),\n\t\t\t node->regulator->desc->name,\n\t\t\t supply,\n\t\t\t dev_name(&rdev->dev), rdev_get_name(rdev));\n\t\treturn -EBUSY;\n\t}\n\n\tnode = kzalloc(sizeof(struct regulator_map), GFP_KERNEL);\n\tif (node == NULL)\n\t\treturn -ENOMEM;\n\n\tnode->regulator = rdev;\n\tnode->supply = supply;\n\n\tif (has_dev) {\n\t\tnode->dev_name = kstrdup(consumer_dev_name, GFP_KERNEL);\n\t\tif (node->dev_name == NULL) {\n\t\t\tkfree(node);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tlist_add(&node->list, &regulator_map_list);\n\treturn 0;\n}\n\nstatic void unset_regulator_supplies(struct regulator_dev *rdev)\n{\n\tstruct regulator_map *node, *n;\n\n\tlist_for_each_entry_safe(node, n, &regulator_map_list, list) {\n\t\tif (rdev == node->regulator) {\n\t\t\tlist_del(&node->list);\n\t\t\tkfree(node->dev_name);\n\t\t\tkfree(node);\n\t\t}\n\t}\n}\n\n#define REG_STR_SIZE\t64\n\nstatic struct regulator *create_regulator(struct regulator_dev *rdev,\n\t\t\t\t\t  struct device *dev,\n\t\t\t\t\t  const char *supply_name)\n{\n\tstruct regulator *regulator;\n\tchar buf[REG_STR_SIZE];\n\tint err, size;\n\n\tregulator = kzalloc(sizeof(*regulator), GFP_KERNEL);\n\tif (regulator == NULL)\n\t\treturn NULL;\n\n\tmutex_lock(&rdev->mutex);\n\tregulator->rdev = rdev;\n\tlist_add(&regulator->list, &rdev->consumer_list);\n\n\tif (dev) {\n\t\tregulator->dev = dev;\n\n\t\t/* Add a link to the device sysfs entry */\n\t\tsize = scnprintf(buf, REG_STR_SIZE, \"%s-%s\",\n\t\t\t\t dev->kobj.name, supply_name);\n\t\tif (size >= REG_STR_SIZE)\n\t\t\tgoto overflow_err;\n\n\t\tregulator->supply_name = kstrdup(buf, GFP_KERNEL);\n\t\tif (regulator->supply_name == NULL)\n\t\t\tgoto overflow_err;\n\n\t\terr = sysfs_create_link(&rdev->dev.kobj, &dev->kobj,\n\t\t\t\t\tbuf);\n\t\tif (err) {\n\t\t\trdev_warn(rdev, \"could not add device link %s err %d\\n\",\n\t\t\t\t  dev->kobj.name, err);\n\t\t\t/* non-fatal */\n\t\t}\n\t} else {\n\t\tregulator->supply_name = kstrdup(supply_name, GFP_KERNEL);\n\t\tif (regulator->supply_name == NULL)\n\t\t\tgoto overflow_err;\n\t}\n\n\tregulator->debugfs = debugfs_create_dir(regulator->supply_name,\n\t\t\t\t\t\trdev->debugfs);\n\tif (!regulator->debugfs) {\n\t\trdev_warn(rdev, \"Failed to create debugfs directory\\n\");\n\t} else {\n\t\tdebugfs_create_u32(\"uA_load\", 0444, regulator->debugfs,\n\t\t\t\t   &regulator->uA_load);\n\t\tdebugfs_create_u32(\"min_uV\", 0444, regulator->debugfs,\n\t\t\t\t   &regulator->min_uV);\n\t\tdebugfs_create_u32(\"max_uV\", 0444, regulator->debugfs,\n\t\t\t\t   &regulator->max_uV);\n\t}\n\n\t/*\n\t * Check now if the regulator is an always on regulator - if\n\t * it is then we don't need to do nearly so much work for\n\t * enable/disable calls.\n\t */\n\tif (!_regulator_can_change_status(rdev) &&\n\t    _regulator_is_enabled(rdev))\n\t\tregulator->always_on = true;\n\n\tmutex_unlock(&rdev->mutex);\n\treturn regulator;\noverflow_err:\n\tlist_del(&regulator->list);\n\tkfree(regulator);\n\tmutex_unlock(&rdev->mutex);\n\treturn NULL;\n}\n\nstatic int _regulator_get_enable_time(struct regulator_dev *rdev)\n{\n\tif (rdev->constraints && rdev->constraints->enable_time)\n\t\treturn rdev->constraints->enable_time;\n\tif (!rdev->desc->ops->enable_time)\n\t\treturn rdev->desc->enable_time;\n\treturn rdev->desc->ops->enable_time(rdev);\n}\n\nstatic struct regulator_supply_alias *regulator_find_supply_alias(\n\t\tstruct device *dev, const char *supply)\n{\n\tstruct regulator_supply_alias *map;\n\n\tlist_for_each_entry(map, &regulator_supply_alias_list, list)\n\t\tif (map->src_dev == dev && strcmp(map->src_supply, supply) == 0)\n\t\t\treturn map;\n\n\treturn NULL;\n}\n\nstatic void regulator_supply_alias(struct device **dev, const char **supply)\n{\n\tstruct regulator_supply_alias *map;\n\n\tmap = regulator_find_supply_alias(*dev, *supply);\n\tif (map) {\n\t\tdev_dbg(*dev, \"Mapping supply %s to %s,%s\\n\",\n\t\t\t\t*supply, map->alias_supply,\n\t\t\t\tdev_name(map->alias_dev));\n\t\t*dev = map->alias_dev;\n\t\t*supply = map->alias_supply;\n\t}\n}\n\nstatic struct regulator_dev *regulator_dev_lookup(struct device *dev,\n\t\t\t\t\t\t  const char *supply,\n\t\t\t\t\t\t  int *ret)\n{\n\tstruct regulator_dev *r;\n\tstruct device_node *node;\n\tstruct regulator_map *map;\n\tconst char *devname = NULL;\n\n\tregulator_supply_alias(&dev, &supply);\n\n\t/* first do a dt based lookup */\n\tif (dev && dev->of_node) {\n\t\tnode = of_get_regulator(dev, supply);\n\t\tif (node) {\n\t\t\tlist_for_each_entry(r, &regulator_list, list)\n\t\t\t\tif (r->dev.parent &&\n\t\t\t\t\tnode == r->dev.of_node)\n\t\t\t\t\treturn r;\n\t\t\t*ret = -EPROBE_DEFER;\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If we couldn't even get the node then it's\n\t\t\t * not just that the device didn't register\n\t\t\t * yet, there's no node and we'll never\n\t\t\t * succeed.\n\t\t\t */\n\t\t\t*ret = -ENODEV;\n\t\t}\n\t}\n\n\t/* if not found, try doing it non-dt way */\n\tif (dev)\n\t\tdevname = dev_name(dev);\n\n\tlist_for_each_entry(r, &regulator_list, list)\n\t\tif (strcmp(rdev_get_name(r), supply) == 0)\n\t\t\treturn r;\n\n\tlist_for_each_entry(map, &regulator_map_list, list) {\n\t\t/* If the mapping has a device set up it must match */\n\t\tif (map->dev_name &&\n\t\t    (!devname || strcmp(map->dev_name, devname)))\n\t\t\tcontinue;\n\n\t\tif (strcmp(map->supply, supply) == 0)\n\t\t\treturn map->regulator;\n\t}\n\n\n\treturn NULL;\n}\n\n/* Internal regulator request function */\nstatic struct regulator *_regulator_get(struct device *dev, const char *id,\n\t\t\t\t\tbool exclusive, bool allow_dummy)\n{\n\tstruct regulator_dev *rdev;\n\tstruct regulator *regulator = ERR_PTR(-EPROBE_DEFER);\n\tconst char *devname = NULL;\n\tint ret;\n\n\tif (id == NULL) {\n\t\tpr_err(\"get() with no identifier\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (dev)\n\t\tdevname = dev_name(dev);\n\n\tif (have_full_constraints())\n\t\tret = -ENODEV;\n\telse\n\t\tret = -EPROBE_DEFER;\n\n\tmutex_lock(&regulator_list_mutex);\n\n\trdev = regulator_dev_lookup(dev, id, &ret);\n\tif (rdev)\n\t\tgoto found;\n\n\tregulator = ERR_PTR(ret);\n\n\t/*\n\t * If we have return value from dev_lookup fail, we do not expect to\n\t * succeed, so, quit with appropriate error value\n\t */\n\tif (ret && ret != -ENODEV)\n\t\tgoto out;\n\n\tif (!devname)\n\t\tdevname = \"deviceless\";\n\n\t/*\n\t * Assume that a regulator is physically present and enabled\n\t * even if it isn't hooked up and just provide a dummy.\n\t */\n\tif (have_full_constraints() && allow_dummy) {\n\t\tpr_warn(\"%s supply %s not found, using dummy regulator\\n\",\n\t\t\tdevname, id);\n\n\t\trdev = dummy_regulator_rdev;\n\t\tgoto found;\n\t/* Don't log an error when called from regulator_get_optional() */\n\t} else if (!have_full_constraints() || exclusive) {\n\t\tdev_warn(dev, \"dummy supplies not allowed\\n\");\n\t}\n\n\tmutex_unlock(&regulator_list_mutex);\n\treturn regulator;\n\nfound:\n\tif (rdev->exclusive) {\n\t\tregulator = ERR_PTR(-EPERM);\n\t\tgoto out;\n\t}\n\n\tif (exclusive && rdev->open_count) {\n\t\tregulator = ERR_PTR(-EBUSY);\n\t\tgoto out;\n\t}\n\n\tif (!try_module_get(rdev->owner))\n\t\tgoto out;\n\n\tregulator = create_regulator(rdev, dev, id);\n\tif (regulator == NULL) {\n\t\tregulator = ERR_PTR(-ENOMEM);\n\t\tmodule_put(rdev->owner);\n\t\tgoto out;\n\t}\n\n\trdev->open_count++;\n\tif (exclusive) {\n\t\trdev->exclusive = 1;\n\n\t\tret = _regulator_is_enabled(rdev);\n\t\tif (ret > 0)\n\t\t\trdev->use_count = 1;\n\t\telse\n\t\t\trdev->use_count = 0;\n\t}\n\nout:\n\tmutex_unlock(&regulator_list_mutex);\n\n\treturn regulator;\n}\n\n/**\n * regulator_get - lookup and obtain a reference to a regulator.\n * @dev: device for regulator \"consumer\"\n * @id: Supply name or regulator ID.\n *\n * Returns a struct regulator corresponding to the regulator producer,\n * or IS_ERR() condition containing errno.\n *\n * Use of supply names configured via regulator_set_device_supply() is\n * strongly encouraged.  It is recommended that the supply name used\n * should match the name used for the supply and/or the relevant\n * device pins in the datasheet.\n */\nstruct regulator *regulator_get(struct device *dev, const char *id)\n{\n\treturn _regulator_get(dev, id, false, true);\n}\nEXPORT_SYMBOL_GPL(regulator_get);\n\n/**\n * regulator_get_exclusive - obtain exclusive access to a regulator.\n * @dev: device for regulator \"consumer\"\n * @id: Supply name or regulator ID.\n *\n * Returns a struct regulator corresponding to the regulator producer,\n * or IS_ERR() condition containing errno.  Other consumers will be\n * unable to obtain this regulator while this reference is held and the\n * use count for the regulator will be initialised to reflect the current\n * state of the regulator.\n *\n * This is intended for use by consumers which cannot tolerate shared\n * use of the regulator such as those which need to force the\n * regulator off for correct operation of the hardware they are\n * controlling.\n *\n * Use of supply names configured via regulator_set_device_supply() is\n * strongly encouraged.  It is recommended that the supply name used\n * should match the name used for the supply and/or the relevant\n * device pins in the datasheet.\n */\nstruct regulator *regulator_get_exclusive(struct device *dev, const char *id)\n{\n\treturn _regulator_get(dev, id, true, false);\n}\nEXPORT_SYMBOL_GPL(regulator_get_exclusive);\n\n/**\n * regulator_get_optional - obtain optional access to a regulator.\n * @dev: device for regulator \"consumer\"\n * @id: Supply name or regulator ID.\n *\n * Returns a struct regulator corresponding to the regulator producer,\n * or IS_ERR() condition containing errno.\n *\n * This is intended for use by consumers for devices which can have\n * some supplies unconnected in normal use, such as some MMC devices.\n * It can allow the regulator core to provide stub supplies for other\n * supplies requested using normal regulator_get() calls without\n * disrupting the operation of drivers that can handle absent\n * supplies.\n *\n * Use of supply names configured via regulator_set_device_supply() is\n * strongly encouraged.  It is recommended that the supply name used\n * should match the name used for the supply and/or the relevant\n * device pins in the datasheet.\n */\nstruct regulator *regulator_get_optional(struct device *dev, const char *id)\n{\n\treturn _regulator_get(dev, id, false, false);\n}\nEXPORT_SYMBOL_GPL(regulator_get_optional);\n\n/* Locks held by regulator_put() */\nstatic void _regulator_put(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev;\n\n\tif (regulator == NULL || IS_ERR(regulator))\n\t\treturn;\n\n\trdev = regulator->rdev;\n\n\tdebugfs_remove_recursive(regulator->debugfs);\n\n\t/* remove any sysfs entries */\n\tif (regulator->dev)\n\t\tsysfs_remove_link(&rdev->dev.kobj, regulator->supply_name);\n\tkfree(regulator->supply_name);\n\tlist_del(&regulator->list);\n\tkfree(regulator);\n\n\trdev->open_count--;\n\trdev->exclusive = 0;\n\n\tmodule_put(rdev->owner);\n}\n\n/**\n * regulator_put - \"free\" the regulator source\n * @regulator: regulator source\n *\n * Note: drivers must ensure that all regulator_enable calls made on this\n * regulator source are balanced by regulator_disable calls prior to calling\n * this function.\n */\nvoid regulator_put(struct regulator *regulator)\n{\n\tmutex_lock(&regulator_list_mutex);\n\t_regulator_put(regulator);\n\tmutex_unlock(&regulator_list_mutex);\n}\nEXPORT_SYMBOL_GPL(regulator_put);\n\n/**\n * regulator_register_supply_alias - Provide device alias for supply lookup\n *\n * @dev: device that will be given as the regulator \"consumer\"\n * @id: Supply name or regulator ID\n * @alias_dev: device that should be used to lookup the supply\n * @alias_id: Supply name or regulator ID that should be used to lookup the\n * supply\n *\n * All lookups for id on dev will instead be conducted for alias_id on\n * alias_dev.\n */\nint regulator_register_supply_alias(struct device *dev, const char *id,\n\t\t\t\t    struct device *alias_dev,\n\t\t\t\t    const char *alias_id)\n{\n\tstruct regulator_supply_alias *map;\n\n\tmap = regulator_find_supply_alias(dev, id);\n\tif (map)\n\t\treturn -EEXIST;\n\n\tmap = kzalloc(sizeof(struct regulator_supply_alias), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmap->src_dev = dev;\n\tmap->src_supply = id;\n\tmap->alias_dev = alias_dev;\n\tmap->alias_supply = alias_id;\n\n\tlist_add(&map->list, &regulator_supply_alias_list);\n\n\tpr_info(\"Adding alias for supply %s,%s -> %s,%s\\n\",\n\t\tid, dev_name(dev), alias_id, dev_name(alias_dev));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(regulator_register_supply_alias);\n\n/**\n * regulator_unregister_supply_alias - Remove device alias\n *\n * @dev: device that will be given as the regulator \"consumer\"\n * @id: Supply name or regulator ID\n *\n * Remove a lookup alias if one exists for id on dev.\n */\nvoid regulator_unregister_supply_alias(struct device *dev, const char *id)\n{\n\tstruct regulator_supply_alias *map;\n\n\tmap = regulator_find_supply_alias(dev, id);\n\tif (map) {\n\t\tlist_del(&map->list);\n\t\tkfree(map);\n\t}\n}\nEXPORT_SYMBOL_GPL(regulator_unregister_supply_alias);\n\n/**\n * regulator_bulk_register_supply_alias - register multiple aliases\n *\n * @dev: device that will be given as the regulator \"consumer\"\n * @id: List of supply names or regulator IDs\n * @alias_dev: device that should be used to lookup the supply\n * @alias_id: List of supply names or regulator IDs that should be used to\n * lookup the supply\n * @num_id: Number of aliases to register\n *\n * @return 0 on success, an errno on failure.\n *\n * This helper function allows drivers to register several supply\n * aliases in one operation.  If any of the aliases cannot be\n * registered any aliases that were registered will be removed\n * before returning to the caller.\n */\nint regulator_bulk_register_supply_alias(struct device *dev,\n\t\t\t\t\t const char *const *id,\n\t\t\t\t\t struct device *alias_dev,\n\t\t\t\t\t const char *const *alias_id,\n\t\t\t\t\t int num_id)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < num_id; ++i) {\n\t\tret = regulator_register_supply_alias(dev, id[i], alias_dev,\n\t\t\t\t\t\t      alias_id[i]);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tdev_err(dev,\n\t\t\"Failed to create supply alias %s,%s -> %s,%s\\n\",\n\t\tid[i], dev_name(dev), alias_id[i], dev_name(alias_dev));\n\n\twhile (--i >= 0)\n\t\tregulator_unregister_supply_alias(dev, id[i]);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_register_supply_alias);\n\n/**\n * regulator_bulk_unregister_supply_alias - unregister multiple aliases\n *\n * @dev: device that will be given as the regulator \"consumer\"\n * @id: List of supply names or regulator IDs\n * @num_id: Number of aliases to unregister\n *\n * This helper function allows drivers to unregister several supply\n * aliases in one operation.\n */\nvoid regulator_bulk_unregister_supply_alias(struct device *dev,\n\t\t\t\t\t    const char *const *id,\n\t\t\t\t\t    int num_id)\n{\n\tint i;\n\n\tfor (i = 0; i < num_id; ++i)\n\t\tregulator_unregister_supply_alias(dev, id[i]);\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_unregister_supply_alias);\n\n\n/* Manage enable GPIO list. Same GPIO pin can be shared among regulators */\nstatic int regulator_ena_gpio_request(struct regulator_dev *rdev,\n\t\t\t\tconst struct regulator_config *config)\n{\n\tstruct regulator_enable_gpio *pin;\n\tstruct gpio_desc *gpiod;\n\tint ret;\n\n\tgpiod = gpio_to_desc(config->ena_gpio);\n\n\tlist_for_each_entry(pin, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == gpiod) {\n\t\t\trdev_dbg(rdev, \"GPIO %d is already used\\n\",\n\t\t\t\tconfig->ena_gpio);\n\t\t\tgoto update_ena_gpio_to_rdev;\n\t\t}\n\t}\n\n\tret = gpio_request_one(config->ena_gpio,\n\t\t\t\tGPIOF_DIR_OUT | config->ena_gpio_flags,\n\t\t\t\trdev_get_name(rdev));\n\tif (ret)\n\t\treturn ret;\n\n\tpin = kzalloc(sizeof(struct regulator_enable_gpio), GFP_KERNEL);\n\tif (pin == NULL) {\n\t\tgpio_free(config->ena_gpio);\n\t\treturn -ENOMEM;\n\t}\n\n\tpin->gpiod = gpiod;\n\tpin->ena_gpio_invert = config->ena_gpio_invert;\n\tlist_add(&pin->list, &regulator_ena_gpio_list);\n\nupdate_ena_gpio_to_rdev:\n\tpin->request_count++;\n\trdev->ena_pin = pin;\n\treturn 0;\n}\n\nstatic void regulator_ena_gpio_free(struct regulator_dev *rdev)\n{\n\tstruct regulator_enable_gpio *pin, *n;\n\n\tif (!rdev->ena_pin)\n\t\treturn;\n\n\t/* Free the GPIO only in case of no use */\n\tlist_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == rdev->ena_pin->gpiod) {\n\t\t\tif (pin->request_count <= 1) {\n\t\t\t\tpin->request_count = 0;\n\t\t\t\tgpiod_put(pin->gpiod);\n\t\t\t\tlist_del(&pin->list);\n\t\t\t\tkfree(pin);\n\t\t\t\trdev->ena_pin = NULL;\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpin->request_count--;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * regulator_ena_gpio_ctrl - balance enable_count of each GPIO and actual GPIO pin control\n * @rdev: regulator_dev structure\n * @enable: enable GPIO at initial use?\n *\n * GPIO is enabled in case of initial use. (enable_count is 0)\n * GPIO is disabled when it is not shared any more. (enable_count <= 1)\n */\nstatic int regulator_ena_gpio_ctrl(struct regulator_dev *rdev, bool enable)\n{\n\tstruct regulator_enable_gpio *pin = rdev->ena_pin;\n\n\tif (!pin)\n\t\treturn -EINVAL;\n\n\tif (enable) {\n\t\t/* Enable GPIO at initial use */\n\t\tif (pin->enable_count == 0)\n\t\t\tgpiod_set_value_cansleep(pin->gpiod,\n\t\t\t\t\t\t !pin->ena_gpio_invert);\n\n\t\tpin->enable_count++;\n\t} else {\n\t\tif (pin->enable_count > 1) {\n\t\t\tpin->enable_count--;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Disable GPIO if not used */\n\t\tif (pin->enable_count <= 1) {\n\t\t\tgpiod_set_value_cansleep(pin->gpiod,\n\t\t\t\t\t\t pin->ena_gpio_invert);\n\t\t\tpin->enable_count = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * _regulator_enable_delay - a delay helper function\n * @delay: time to delay in microseconds\n *\n * Delay for the requested amount of time as per the guidelines in:\n *\n *     Documentation/timers/timers-howto.txt\n *\n * The assumption here is that regulators will never be enabled in\n * atomic context and therefore sleeping functions can be used.\n */\nstatic void _regulator_enable_delay(unsigned int delay)\n{\n\tunsigned int ms = delay / 1000;\n\tunsigned int us = delay % 1000;\n\n\tif (ms > 0) {\n\t\t/*\n\t\t * For small enough values, handle super-millisecond\n\t\t * delays in the usleep_range() call below.\n\t\t */\n\t\tif (ms < 20)\n\t\t\tus += ms * 1000;\n\t\telse\n\t\t\tmsleep(ms);\n\t}\n\n\t/*\n\t * Give the scheduler some room to coalesce with any other\n\t * wakeup sources. For delays shorter than 10 us, don't even\n\t * bother setting up high-resolution timers and just busy-\n\t * loop.\n\t */\n\tif (us >= 10)\n\t\tusleep_range(us, us + 100);\n\telse\n\t\tudelay(us);\n}\n\nstatic int _regulator_do_enable(struct regulator_dev *rdev)\n{\n\tint ret, delay;\n\n\t/* Query before enabling in case configuration dependent.  */\n\tret = _regulator_get_enable_time(rdev);\n\tif (ret >= 0) {\n\t\tdelay = ret;\n\t} else {\n\t\trdev_warn(rdev, \"enable_time() failed: %d\\n\", ret);\n\t\tdelay = 0;\n\t}\n\n\ttrace_regulator_enable(rdev_get_name(rdev));\n\n\tif (rdev->desc->off_on_delay) {\n\t\t/* if needed, keep a distance of off_on_delay from last time\n\t\t * this regulator was disabled.\n\t\t */\n\t\tunsigned long start_jiffy = jiffies;\n\t\tunsigned long intended, max_delay, remaining;\n\n\t\tmax_delay = usecs_to_jiffies(rdev->desc->off_on_delay);\n\t\tintended = rdev->last_off_jiffy + max_delay;\n\n\t\tif (time_before(start_jiffy, intended)) {\n\t\t\t/* calc remaining jiffies to deal with one-time\n\t\t\t * timer wrapping.\n\t\t\t * in case of multiple timer wrapping, either it can be\n\t\t\t * detected by out-of-range remaining, or it cannot be\n\t\t\t * detected and we gets a panelty of\n\t\t\t * _regulator_enable_delay().\n\t\t\t */\n\t\t\tremaining = intended - start_jiffy;\n\t\t\tif (remaining <= max_delay)\n\t\t\t\t_regulator_enable_delay(\n\t\t\t\t\t\tjiffies_to_usecs(remaining));\n\t\t}\n\t}\n\n\tif (rdev->ena_pin) {\n\t\tret = regulator_ena_gpio_ctrl(rdev, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\trdev->ena_gpio_state = 1;\n\t} else if (rdev->desc->ops->enable) {\n\t\tret = rdev->desc->ops->enable(rdev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Allow the regulator to ramp; it would be useful to extend\n\t * this for bulk operations so that the regulators can ramp\n\t * together.  */\n\ttrace_regulator_enable_delay(rdev_get_name(rdev));\n\n\t_regulator_enable_delay(delay);\n\n\ttrace_regulator_enable_complete(rdev_get_name(rdev));\n\n\treturn 0;\n}\n\n/* locks held by regulator_enable() */\nstatic int _regulator_enable(struct regulator_dev *rdev)\n{\n\tint ret;\n\n\t/* check voltage and requested load before enabling */\n\tif (rdev->constraints &&\n\t    (rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_DRMS))\n\t\tdrms_uA_update(rdev);\n\n\tif (rdev->use_count == 0) {\n\t\t/* The regulator may on if it's not switchable or left on */\n\t\tret = _regulator_is_enabled(rdev);\n\t\tif (ret == -EINVAL || ret == 0) {\n\t\t\tif (!_regulator_can_change_status(rdev))\n\t\t\t\treturn -EPERM;\n\n\t\t\tret = _regulator_do_enable(rdev);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t} else if (ret < 0) {\n\t\t\trdev_err(rdev, \"is_enabled() failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\t/* Fallthrough on positive return values - already enabled */\n\t}\n\n\trdev->use_count++;\n\n\treturn 0;\n}\n\n/**\n * regulator_enable - enable regulator output\n * @regulator: regulator source\n *\n * Request that the regulator be enabled with the regulator output at\n * the predefined voltage or current value.  Calls to regulator_enable()\n * must be balanced with calls to regulator_disable().\n *\n * NOTE: the output value can be set by other drivers, boot loader or may be\n * hardwired in the regulator.\n */\nint regulator_enable(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret = 0;\n\n\tif (regulator->always_on)\n\t\treturn 0;\n\n\tif (rdev->supply) {\n\t\tret = regulator_enable(rdev->supply);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&rdev->mutex);\n\tret = _regulator_enable(rdev);\n\tmutex_unlock(&rdev->mutex);\n\n\tif (ret != 0 && rdev->supply)\n\t\tregulator_disable(rdev->supply);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_enable);\n\nstatic int _regulator_do_disable(struct regulator_dev *rdev)\n{\n\tint ret;\n\n\ttrace_regulator_disable(rdev_get_name(rdev));\n\n\tif (rdev->ena_pin) {\n\t\tret = regulator_ena_gpio_ctrl(rdev, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\trdev->ena_gpio_state = 0;\n\n\t} else if (rdev->desc->ops->disable) {\n\t\tret = rdev->desc->ops->disable(rdev);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* cares about last_off_jiffy only if off_on_delay is required by\n\t * device.\n\t */\n\tif (rdev->desc->off_on_delay)\n\t\trdev->last_off_jiffy = jiffies;\n\n\ttrace_regulator_disable_complete(rdev_get_name(rdev));\n\n\treturn 0;\n}\n\n/* locks held by regulator_disable() */\nstatic int _regulator_disable(struct regulator_dev *rdev)\n{\n\tint ret = 0;\n\n\tif (WARN(rdev->use_count <= 0,\n\t\t \"unbalanced disables for %s\\n\", rdev_get_name(rdev)))\n\t\treturn -EIO;\n\n\t/* are we the last user and permitted to disable ? */\n\tif (rdev->use_count == 1 &&\n\t    (rdev->constraints && !rdev->constraints->always_on)) {\n\n\t\t/* we are last user */\n\t\tif (_regulator_can_change_status(rdev)) {\n\t\t\tret = _regulator_do_disable(rdev);\n\t\t\tif (ret < 0) {\n\t\t\t\trdev_err(rdev, \"failed to disable\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t_notifier_call_chain(rdev, REGULATOR_EVENT_DISABLE,\n\t\t\t\t\tNULL);\n\t\t}\n\n\t\trdev->use_count = 0;\n\t} else if (rdev->use_count > 1) {\n\n\t\tif (rdev->constraints &&\n\t\t\t(rdev->constraints->valid_ops_mask &\n\t\t\tREGULATOR_CHANGE_DRMS))\n\t\t\tdrms_uA_update(rdev);\n\n\t\trdev->use_count--;\n\t}\n\n\treturn ret;\n}\n\n/**\n * regulator_disable - disable regulator output\n * @regulator: regulator source\n *\n * Disable the regulator output voltage or current.  Calls to\n * regulator_enable() must be balanced with calls to\n * regulator_disable().\n *\n * NOTE: this will only disable the regulator output if no other consumer\n * devices have it enabled, the regulator device supports disabling and\n * machine constraints permit this operation.\n */\nint regulator_disable(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret = 0;\n\n\tif (regulator->always_on)\n\t\treturn 0;\n\n\tmutex_lock(&rdev->mutex);\n\tret = _regulator_disable(rdev);\n\tmutex_unlock(&rdev->mutex);\n\n\tif (ret == 0 && rdev->supply)\n\t\tregulator_disable(rdev->supply);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_disable);\n\n/* locks held by regulator_force_disable() */\nstatic int _regulator_force_disable(struct regulator_dev *rdev)\n{\n\tint ret = 0;\n\n\tret = _regulator_do_disable(rdev);\n\tif (ret < 0) {\n\t\trdev_err(rdev, \"failed to force disable\\n\");\n\t\treturn ret;\n\t}\n\n\t_notifier_call_chain(rdev, REGULATOR_EVENT_FORCE_DISABLE |\n\t\t\tREGULATOR_EVENT_DISABLE, NULL);\n\n\treturn 0;\n}\n\n/**\n * regulator_force_disable - force disable regulator output\n * @regulator: regulator source\n *\n * Forcibly disable the regulator output voltage or current.\n * NOTE: this *will* disable the regulator output even if other consumer\n * devices have it enabled. This should be used for situations when device\n * damage will likely occur if the regulator is not disabled (e.g. over temp).\n */\nint regulator_force_disable(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret;\n\n\tmutex_lock(&rdev->mutex);\n\tregulator->uA_load = 0;\n\tret = _regulator_force_disable(regulator->rdev);\n\tmutex_unlock(&rdev->mutex);\n\n\tif (rdev->supply)\n\t\twhile (rdev->open_count--)\n\t\t\tregulator_disable(rdev->supply);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_force_disable);\n\nstatic void regulator_disable_work(struct work_struct *work)\n{\n\tstruct regulator_dev *rdev = container_of(work, struct regulator_dev,\n\t\t\t\t\t\t  disable_work.work);\n\tint count, i, ret;\n\n\tmutex_lock(&rdev->mutex);\n\n\tBUG_ON(!rdev->deferred_disables);\n\n\tcount = rdev->deferred_disables;\n\trdev->deferred_disables = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tret = _regulator_disable(rdev);\n\t\tif (ret != 0)\n\t\t\trdev_err(rdev, \"Deferred disable failed: %d\\n\", ret);\n\t}\n\n\tmutex_unlock(&rdev->mutex);\n\n\tif (rdev->supply) {\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tret = regulator_disable(rdev->supply);\n\t\t\tif (ret != 0) {\n\t\t\t\trdev_err(rdev,\n\t\t\t\t\t \"Supply disable failed: %d\\n\", ret);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * regulator_disable_deferred - disable regulator output with delay\n * @regulator: regulator source\n * @ms: miliseconds until the regulator is disabled\n *\n * Execute regulator_disable() on the regulator after a delay.  This\n * is intended for use with devices that require some time to quiesce.\n *\n * NOTE: this will only disable the regulator output if no other consumer\n * devices have it enabled, the regulator device supports disabling and\n * machine constraints permit this operation.\n */\nint regulator_disable_deferred(struct regulator *regulator, int ms)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret;\n\n\tif (regulator->always_on)\n\t\treturn 0;\n\n\tif (!ms)\n\t\treturn regulator_disable(regulator);\n\n\tmutex_lock(&rdev->mutex);\n\trdev->deferred_disables++;\n\tmutex_unlock(&rdev->mutex);\n\n\tret = queue_delayed_work(system_power_efficient_wq,\n\t\t\t\t &rdev->disable_work,\n\t\t\t\t msecs_to_jiffies(ms));\n\tif (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn 0;\n}\nEXPORT_SYMBOL_GPL(regulator_disable_deferred);\n\nstatic int _regulator_is_enabled(struct regulator_dev *rdev)\n{\n\t/* A GPIO control always takes precedence */\n\tif (rdev->ena_pin)\n\t\treturn rdev->ena_gpio_state;\n\n\t/* If we don't know then assume that the regulator is always on */\n\tif (!rdev->desc->ops->is_enabled)\n\t\treturn 1;\n\n\treturn rdev->desc->ops->is_enabled(rdev);\n}\n\n/**\n * regulator_is_enabled - is the regulator output enabled\n * @regulator: regulator source\n *\n * Returns positive if the regulator driver backing the source/client\n * has requested that the device be enabled, zero if it hasn't, else a\n * negative errno code.\n *\n * Note that the device backing this regulator handle can have multiple\n * users, so it might be enabled even if regulator_enable() was never\n * called for this particular source.\n */\nint regulator_is_enabled(struct regulator *regulator)\n{\n\tint ret;\n\n\tif (regulator->always_on)\n\t\treturn 1;\n\n\tmutex_lock(&regulator->rdev->mutex);\n\tret = _regulator_is_enabled(regulator->rdev);\n\tmutex_unlock(&regulator->rdev->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_is_enabled);\n\n/**\n * regulator_can_change_voltage - check if regulator can change voltage\n * @regulator: regulator source\n *\n * Returns positive if the regulator driver backing the source/client\n * can change its voltage, false otherwise. Useful for detecting fixed\n * or dummy regulators and disabling voltage change logic in the client\n * driver.\n */\nint regulator_can_change_voltage(struct regulator *regulator)\n{\n\tstruct regulator_dev\t*rdev = regulator->rdev;\n\n\tif (rdev->constraints &&\n\t    (rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {\n\t\tif (rdev->desc->n_voltages - rdev->desc->linear_min_sel > 1)\n\t\t\treturn 1;\n\n\t\tif (rdev->desc->continuous_voltage_range &&\n\t\t    rdev->constraints->min_uV && rdev->constraints->max_uV &&\n\t\t    rdev->constraints->min_uV != rdev->constraints->max_uV)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(regulator_can_change_voltage);\n\n/**\n * regulator_count_voltages - count regulator_list_voltage() selectors\n * @regulator: regulator source\n *\n * Returns number of selectors, or negative errno.  Selectors are\n * numbered starting at zero, and typically correspond to bitfields\n * in hardware registers.\n */\nint regulator_count_voltages(struct regulator *regulator)\n{\n\tstruct regulator_dev\t*rdev = regulator->rdev;\n\n\tif (rdev->desc->n_voltages)\n\t\treturn rdev->desc->n_voltages;\n\n\tif (!rdev->supply)\n\t\treturn -EINVAL;\n\n\treturn regulator_count_voltages(rdev->supply);\n}\nEXPORT_SYMBOL_GPL(regulator_count_voltages);\n\n/**\n * regulator_list_voltage - enumerate supported voltages\n * @regulator: regulator source\n * @selector: identify voltage to list\n * Context: can sleep\n *\n * Returns a voltage that can be passed to @regulator_set_voltage(),\n * zero if this selector code can't be used on this system, or a\n * negative errno.\n */\nint regulator_list_voltage(struct regulator *regulator, unsigned selector)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\tint ret;\n\n\tif (rdev->desc->fixed_uV && rdev->desc->n_voltages == 1 && !selector)\n\t\treturn rdev->desc->fixed_uV;\n\n\tif (ops->list_voltage) {\n\t\tif (selector >= rdev->desc->n_voltages)\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&rdev->mutex);\n\t\tret = ops->list_voltage(rdev, selector);\n\t\tmutex_unlock(&rdev->mutex);\n\t} else if (rdev->supply) {\n\t\tret = regulator_list_voltage(rdev->supply, selector);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret > 0) {\n\t\tif (ret < rdev->constraints->min_uV)\n\t\t\tret = 0;\n\t\telse if (ret > rdev->constraints->max_uV)\n\t\t\tret = 0;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_list_voltage);\n\n/**\n * regulator_get_regmap - get the regulator's register map\n * @regulator: regulator source\n *\n * Returns the register map for the given regulator, or an ERR_PTR value\n * if the regulator doesn't use regmap.\n */\nstruct regmap *regulator_get_regmap(struct regulator *regulator)\n{\n\tstruct regmap *map = regulator->rdev->regmap;\n\n\treturn map ? map : ERR_PTR(-EOPNOTSUPP);\n}\n\n/**\n * regulator_get_hardware_vsel_register - get the HW voltage selector register\n * @regulator: regulator source\n * @vsel_reg: voltage selector register, output parameter\n * @vsel_mask: mask for voltage selector bitfield, output parameter\n *\n * Returns the hardware register offset and bitmask used for setting the\n * regulator voltage. This might be useful when configuring voltage-scaling\n * hardware or firmware that can make I2C requests behind the kernel's back,\n * for example.\n *\n * On success, the output parameters @vsel_reg and @vsel_mask are filled in\n * and 0 is returned, otherwise a negative errno is returned.\n */\nint regulator_get_hardware_vsel_register(struct regulator *regulator,\n\t\t\t\t\t unsigned *vsel_reg,\n\t\t\t\t\t unsigned *vsel_mask)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\n\tif (ops->set_voltage_sel != regulator_set_voltage_sel_regmap)\n\t\treturn -EOPNOTSUPP;\n\n\t *vsel_reg = rdev->desc->vsel_reg;\n\t *vsel_mask = rdev->desc->vsel_mask;\n\n\t return 0;\n}\nEXPORT_SYMBOL_GPL(regulator_get_hardware_vsel_register);\n\n/**\n * regulator_list_hardware_vsel - get the HW-specific register value for a selector\n * @regulator: regulator source\n * @selector: identify voltage to list\n *\n * Converts the selector to a hardware-specific voltage selector that can be\n * directly written to the regulator registers. The address of the voltage\n * register can be determined by calling @regulator_get_hardware_vsel_register.\n *\n * On error a negative errno is returned.\n */\nint regulator_list_hardware_vsel(struct regulator *regulator,\n\t\t\t\t unsigned selector)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\n\tif (selector >= rdev->desc->n_voltages)\n\t\treturn -EINVAL;\n\tif (ops->set_voltage_sel != regulator_set_voltage_sel_regmap)\n\t\treturn -EOPNOTSUPP;\n\n\treturn selector;\n}\nEXPORT_SYMBOL_GPL(regulator_list_hardware_vsel);\n\n/**\n * regulator_get_linear_step - return the voltage step size between VSEL values\n * @regulator: regulator source\n *\n * Returns the voltage step size between VSEL values for linear\n * regulators, or return 0 if the regulator isn't a linear regulator.\n */\nunsigned int regulator_get_linear_step(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\n\treturn rdev->desc->uV_step;\n}\nEXPORT_SYMBOL_GPL(regulator_get_linear_step);\n\n/**\n * regulator_is_supported_voltage - check if a voltage range can be supported\n *\n * @regulator: Regulator to check.\n * @min_uV: Minimum required voltage in uV.\n * @max_uV: Maximum required voltage in uV.\n *\n * Returns a boolean or a negative error code.\n */\nint regulator_is_supported_voltage(struct regulator *regulator,\n\t\t\t\t   int min_uV, int max_uV)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint i, voltages, ret;\n\n\t/* If we can't change voltage check the current voltage */\n\tif (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {\n\t\tret = regulator_get_voltage(regulator);\n\t\tif (ret >= 0)\n\t\t\treturn min_uV <= ret && ret <= max_uV;\n\t\telse\n\t\t\treturn ret;\n\t}\n\n\t/* Any voltage within constrains range is fine? */\n\tif (rdev->desc->continuous_voltage_range)\n\t\treturn min_uV >= rdev->constraints->min_uV &&\n\t\t\t\tmax_uV <= rdev->constraints->max_uV;\n\n\tret = regulator_count_voltages(regulator);\n\tif (ret < 0)\n\t\treturn ret;\n\tvoltages = ret;\n\n\tfor (i = 0; i < voltages; i++) {\n\t\tret = regulator_list_voltage(regulator, i);\n\n\t\tif (ret >= min_uV && ret <= max_uV)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(regulator_is_supported_voltage);\n\nstatic int _regulator_call_set_voltage(struct regulator_dev *rdev,\n\t\t\t\t       int min_uV, int max_uV,\n\t\t\t\t       unsigned *selector)\n{\n\tstruct pre_voltage_change_data data;\n\tint ret;\n\n\tdata.old_uV = _regulator_get_voltage(rdev);\n\tdata.min_uV = min_uV;\n\tdata.max_uV = max_uV;\n\tret = _notifier_call_chain(rdev, REGULATOR_EVENT_PRE_VOLTAGE_CHANGE,\n\t\t\t\t   &data);\n\tif (ret & NOTIFY_STOP_MASK)\n\t\treturn -EINVAL;\n\n\tret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV, selector);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\t_notifier_call_chain(rdev, REGULATOR_EVENT_ABORT_VOLTAGE_CHANGE,\n\t\t\t     (void *)data.old_uV);\n\n\treturn ret;\n}\n\nstatic int _regulator_call_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t\t   int uV, unsigned selector)\n{\n\tstruct pre_voltage_change_data data;\n\tint ret;\n\n\tdata.old_uV = _regulator_get_voltage(rdev);\n\tdata.min_uV = uV;\n\tdata.max_uV = uV;\n\tret = _notifier_call_chain(rdev, REGULATOR_EVENT_PRE_VOLTAGE_CHANGE,\n\t\t\t\t   &data);\n\tif (ret & NOTIFY_STOP_MASK)\n\t\treturn -EINVAL;\n\n\tret = rdev->desc->ops->set_voltage_sel(rdev, selector);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\t_notifier_call_chain(rdev, REGULATOR_EVENT_ABORT_VOLTAGE_CHANGE,\n\t\t\t     (void *)data.old_uV);\n\n\treturn ret;\n}\n\nstatic int _regulator_do_set_voltage(struct regulator_dev *rdev,\n\t\t\t\t     int min_uV, int max_uV)\n{\n\tint ret;\n\tint delay = 0;\n\tint best_val = 0;\n\tunsigned int selector;\n\tint old_selector = -1;\n\n\ttrace_regulator_set_voltage(rdev_get_name(rdev), min_uV, max_uV);\n\n\tmin_uV += rdev->constraints->uV_offset;\n\tmax_uV += rdev->constraints->uV_offset;\n\n\t/*\n\t * If we can't obtain the old selector there is not enough\n\t * info to call set_voltage_time_sel().\n\t */\n\tif (_regulator_is_enabled(rdev) &&\n\t    rdev->desc->ops->set_voltage_time_sel &&\n\t    rdev->desc->ops->get_voltage_sel) {\n\t\told_selector = rdev->desc->ops->get_voltage_sel(rdev);\n\t\tif (old_selector < 0)\n\t\t\treturn old_selector;\n\t}\n\n\tif (rdev->desc->ops->set_voltage) {\n\t\tret = _regulator_call_set_voltage(rdev, min_uV, max_uV,\n\t\t\t\t\t\t  &selector);\n\n\t\tif (ret >= 0) {\n\t\t\tif (rdev->desc->ops->list_voltage)\n\t\t\t\tbest_val = rdev->desc->ops->list_voltage(rdev,\n\t\t\t\t\t\t\t\t\t selector);\n\t\t\telse\n\t\t\t\tbest_val = _regulator_get_voltage(rdev);\n\t\t}\n\n\t} else if (rdev->desc->ops->set_voltage_sel) {\n\t\tif (rdev->desc->ops->map_voltage) {\n\t\t\tret = rdev->desc->ops->map_voltage(rdev, min_uV,\n\t\t\t\t\t\t\t   max_uV);\n\t\t} else {\n\t\t\tif (rdev->desc->ops->list_voltage ==\n\t\t\t    regulator_list_voltage_linear)\n\t\t\t\tret = regulator_map_voltage_linear(rdev,\n\t\t\t\t\t\t\t\tmin_uV, max_uV);\n\t\t\telse if (rdev->desc->ops->list_voltage ==\n\t\t\t\t regulator_list_voltage_linear_range)\n\t\t\t\tret = regulator_map_voltage_linear_range(rdev,\n\t\t\t\t\t\t\t\tmin_uV, max_uV);\n\t\t\telse\n\t\t\t\tret = regulator_map_voltage_iterate(rdev,\n\t\t\t\t\t\t\t\tmin_uV, max_uV);\n\t\t}\n\n\t\tif (ret >= 0) {\n\t\t\tbest_val = rdev->desc->ops->list_voltage(rdev, ret);\n\t\t\tif (min_uV <= best_val && max_uV >= best_val) {\n\t\t\t\tselector = ret;\n\t\t\t\tif (old_selector == selector)\n\t\t\t\t\tret = 0;\n\t\t\t\telse\n\t\t\t\t\tret = _regulator_call_set_voltage_sel(\n\t\t\t\t\t\trdev, best_val, selector);\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\t/* Call set_voltage_time_sel if successfully obtained old_selector */\n\tif (ret == 0 && !rdev->constraints->ramp_disable && old_selector >= 0\n\t\t&& old_selector != selector) {\n\n\t\tdelay = rdev->desc->ops->set_voltage_time_sel(rdev,\n\t\t\t\t\t\told_selector, selector);\n\t\tif (delay < 0) {\n\t\t\trdev_warn(rdev, \"set_voltage_time_sel() failed: %d\\n\",\n\t\t\t\t  delay);\n\t\t\tdelay = 0;\n\t\t}\n\n\t\t/* Insert any necessary delays */\n\t\tif (delay >= 1000) {\n\t\t\tmdelay(delay / 1000);\n\t\t\tudelay(delay % 1000);\n\t\t} else if (delay) {\n\t\t\tudelay(delay);\n\t\t}\n\t}\n\n\tif (ret == 0 && best_val >= 0) {\n\t\tunsigned long data = best_val;\n\n\t\t_notifier_call_chain(rdev, REGULATOR_EVENT_VOLTAGE_CHANGE,\n\t\t\t\t     (void *)data);\n\t}\n\n\ttrace_regulator_set_voltage_complete(rdev_get_name(rdev), best_val);\n\n\treturn ret;\n}\n\n/**\n * regulator_set_voltage - set regulator output voltage\n * @regulator: regulator source\n * @min_uV: Minimum required voltage in uV\n * @max_uV: Maximum acceptable voltage in uV\n *\n * Sets a voltage regulator to the desired output voltage. This can be set\n * during any regulator state. IOW, regulator can be disabled or enabled.\n *\n * If the regulator is enabled then the voltage will change to the new value\n * immediately otherwise if the regulator is disabled the regulator will\n * output at the new voltage when enabled.\n *\n * NOTE: If the regulator is shared between several devices then the lowest\n * request voltage that meets the system constraints will be used.\n * Regulator system constraints must be set for this regulator before\n * calling this function otherwise this call will fail.\n */\nint regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret = 0;\n\tint old_min_uV, old_max_uV;\n\tint current_uV;\n\n\tmutex_lock(&rdev->mutex);\n\n\t/* If we're setting the same range as last time the change\n\t * should be a noop (some cpufreq implementations use the same\n\t * voltage for multiple frequencies, for example).\n\t */\n\tif (regulator->min_uV == min_uV && regulator->max_uV == max_uV)\n\t\tgoto out;\n\n\t/* If we're trying to set a range that overlaps the current voltage,\n\t * return succesfully even though the regulator does not support\n\t * changing the voltage.\n\t */\n\tif (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {\n\t\tcurrent_uV = _regulator_get_voltage(rdev);\n\t\tif (min_uV <= current_uV && current_uV <= max_uV) {\n\t\t\tregulator->min_uV = min_uV;\n\t\t\tregulator->max_uV = max_uV;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* sanity check */\n\tif (!rdev->desc->ops->set_voltage &&\n\t    !rdev->desc->ops->set_voltage_sel) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* constraints check */\n\tret = regulator_check_voltage(rdev, &min_uV, &max_uV);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* restore original values in case of error */\n\told_min_uV = regulator->min_uV;\n\told_max_uV = regulator->max_uV;\n\tregulator->min_uV = min_uV;\n\tregulator->max_uV = max_uV;\n\n\tret = regulator_check_consumers(rdev, &min_uV, &max_uV);\n\tif (ret < 0)\n\t\tgoto out2;\n\n\tret = _regulator_do_set_voltage(rdev, min_uV, max_uV);\n\tif (ret < 0)\n\t\tgoto out2;\n\nout:\n\tmutex_unlock(&rdev->mutex);\n\treturn ret;\nout2:\n\tregulator->min_uV = old_min_uV;\n\tregulator->max_uV = old_max_uV;\n\tmutex_unlock(&rdev->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_set_voltage);\n\n/**\n * regulator_set_voltage_time - get raise/fall time\n * @regulator: regulator source\n * @old_uV: starting voltage in microvolts\n * @new_uV: target voltage in microvolts\n *\n * Provided with the starting and ending voltage, this function attempts to\n * calculate the time in microseconds required to rise or fall to this new\n * voltage.\n */\nint regulator_set_voltage_time(struct regulator *regulator,\n\t\t\t       int old_uV, int new_uV)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\tint old_sel = -1;\n\tint new_sel = -1;\n\tint voltage;\n\tint i;\n\n\t/* Currently requires operations to do this */\n\tif (!ops->list_voltage || !ops->set_voltage_time_sel\n\t    || !rdev->desc->n_voltages)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < rdev->desc->n_voltages; i++) {\n\t\t/* We only look for exact voltage matches here */\n\t\tvoltage = regulator_list_voltage(regulator, i);\n\t\tif (voltage < 0)\n\t\t\treturn -EINVAL;\n\t\tif (voltage == 0)\n\t\t\tcontinue;\n\t\tif (voltage == old_uV)\n\t\t\told_sel = i;\n\t\tif (voltage == new_uV)\n\t\t\tnew_sel = i;\n\t}\n\n\tif (old_sel < 0 || new_sel < 0)\n\t\treturn -EINVAL;\n\n\treturn ops->set_voltage_time_sel(rdev, old_sel, new_sel);\n}\nEXPORT_SYMBOL_GPL(regulator_set_voltage_time);\n\n/**\n * regulator_set_voltage_time_sel - get raise/fall time\n * @rdev: regulator source device\n * @old_selector: selector for starting voltage\n * @new_selector: selector for target voltage\n *\n * Provided with the starting and target voltage selectors, this function\n * returns time in microseconds required to rise or fall to this new voltage\n *\n * Drivers providing ramp_delay in regulation_constraints can use this as their\n * set_voltage_time_sel() operation.\n */\nint regulator_set_voltage_time_sel(struct regulator_dev *rdev,\n\t\t\t\t   unsigned int old_selector,\n\t\t\t\t   unsigned int new_selector)\n{\n\tunsigned int ramp_delay = 0;\n\tint old_volt, new_volt;\n\n\tif (rdev->constraints->ramp_delay)\n\t\tramp_delay = rdev->constraints->ramp_delay;\n\telse if (rdev->desc->ramp_delay)\n\t\tramp_delay = rdev->desc->ramp_delay;\n\n\tif (ramp_delay == 0) {\n\t\trdev_warn(rdev, \"ramp_delay not set\\n\");\n\t\treturn 0;\n\t}\n\n\t/* sanity check */\n\tif (!rdev->desc->ops->list_voltage)\n\t\treturn -EINVAL;\n\n\told_volt = rdev->desc->ops->list_voltage(rdev, old_selector);\n\tnew_volt = rdev->desc->ops->list_voltage(rdev, new_selector);\n\n\treturn DIV_ROUND_UP(abs(new_volt - old_volt), ramp_delay);\n}\nEXPORT_SYMBOL_GPL(regulator_set_voltage_time_sel);\n\n/**\n * regulator_sync_voltage - re-apply last regulator output voltage\n * @regulator: regulator source\n *\n * Re-apply the last configured voltage.  This is intended to be used\n * where some external control source the consumer is cooperating with\n * has caused the configured voltage to change.\n */\nint regulator_sync_voltage(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret, min_uV, max_uV;\n\n\tmutex_lock(&rdev->mutex);\n\n\tif (!rdev->desc->ops->set_voltage &&\n\t    !rdev->desc->ops->set_voltage_sel) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* This is only going to work if we've had a voltage configured. */\n\tif (!regulator->min_uV && !regulator->max_uV) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmin_uV = regulator->min_uV;\n\tmax_uV = regulator->max_uV;\n\n\t/* This should be a paranoia check... */\n\tret = regulator_check_voltage(rdev, &min_uV, &max_uV);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = regulator_check_consumers(rdev, &min_uV, &max_uV);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = _regulator_do_set_voltage(rdev, min_uV, max_uV);\n\nout:\n\tmutex_unlock(&rdev->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_sync_voltage);\n\nstatic int _regulator_get_voltage(struct regulator_dev *rdev)\n{\n\tint sel, ret;\n\n\tif (rdev->desc->ops->get_voltage_sel) {\n\t\tsel = rdev->desc->ops->get_voltage_sel(rdev);\n\t\tif (sel < 0)\n\t\t\treturn sel;\n\t\tret = rdev->desc->ops->list_voltage(rdev, sel);\n\t} else if (rdev->desc->ops->get_voltage) {\n\t\tret = rdev->desc->ops->get_voltage(rdev);\n\t} else if (rdev->desc->ops->list_voltage) {\n\t\tret = rdev->desc->ops->list_voltage(rdev, 0);\n\t} else if (rdev->desc->fixed_uV && (rdev->desc->n_voltages == 1)) {\n\t\tret = rdev->desc->fixed_uV;\n\t} else if (rdev->supply) {\n\t\tret = regulator_get_voltage(rdev->supply);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn ret - rdev->constraints->uV_offset;\n}\n\n/**\n * regulator_get_voltage - get regulator output voltage\n * @regulator: regulator source\n *\n * This returns the current regulator voltage in uV.\n *\n * NOTE: If the regulator is disabled it will return the voltage value. This\n * function should not be used to determine regulator state.\n */\nint regulator_get_voltage(struct regulator *regulator)\n{\n\tint ret;\n\n\tmutex_lock(&regulator->rdev->mutex);\n\n\tret = _regulator_get_voltage(regulator->rdev);\n\n\tmutex_unlock(&regulator->rdev->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_get_voltage);\n\n/**\n * regulator_set_current_limit - set regulator output current limit\n * @regulator: regulator source\n * @min_uA: Minimum supported current in uA\n * @max_uA: Maximum supported current in uA\n *\n * Sets current sink to the desired output current. This can be set during\n * any regulator state. IOW, regulator can be disabled or enabled.\n *\n * If the regulator is enabled then the current will change to the new value\n * immediately otherwise if the regulator is disabled the regulator will\n * output at the new current when enabled.\n *\n * NOTE: Regulator system constraints must be set for this regulator before\n * calling this function otherwise this call will fail.\n */\nint regulator_set_current_limit(struct regulator *regulator,\n\t\t\t       int min_uA, int max_uA)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret;\n\n\tmutex_lock(&rdev->mutex);\n\n\t/* sanity check */\n\tif (!rdev->desc->ops->set_current_limit) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* constraints check */\n\tret = regulator_check_current_limit(rdev, &min_uA, &max_uA);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = rdev->desc->ops->set_current_limit(rdev, min_uA, max_uA);\nout:\n\tmutex_unlock(&rdev->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_set_current_limit);\n\nstatic int _regulator_get_current_limit(struct regulator_dev *rdev)\n{\n\tint ret;\n\n\tmutex_lock(&rdev->mutex);\n\n\t/* sanity check */\n\tif (!rdev->desc->ops->get_current_limit) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = rdev->desc->ops->get_current_limit(rdev);\nout:\n\tmutex_unlock(&rdev->mutex);\n\treturn ret;\n}\n\n/**\n * regulator_get_current_limit - get regulator output current\n * @regulator: regulator source\n *\n * This returns the current supplied by the specified current sink in uA.\n *\n * NOTE: If the regulator is disabled it will return the current value. This\n * function should not be used to determine regulator state.\n */\nint regulator_get_current_limit(struct regulator *regulator)\n{\n\treturn _regulator_get_current_limit(regulator->rdev);\n}\nEXPORT_SYMBOL_GPL(regulator_get_current_limit);\n\n/**\n * regulator_set_mode - set regulator operating mode\n * @regulator: regulator source\n * @mode: operating mode - one of the REGULATOR_MODE constants\n *\n * Set regulator operating mode to increase regulator efficiency or improve\n * regulation performance.\n *\n * NOTE: Regulator system constraints must be set for this regulator before\n * calling this function otherwise this call will fail.\n */\nint regulator_set_mode(struct regulator *regulator, unsigned int mode)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret;\n\tint regulator_curr_mode;\n\n\tmutex_lock(&rdev->mutex);\n\n\t/* sanity check */\n\tif (!rdev->desc->ops->set_mode) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* return if the same mode is requested */\n\tif (rdev->desc->ops->get_mode) {\n\t\tregulator_curr_mode = rdev->desc->ops->get_mode(rdev);\n\t\tif (regulator_curr_mode == mode) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* constraints check */\n\tret = regulator_mode_constrain(rdev, &mode);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = rdev->desc->ops->set_mode(rdev, mode);\nout:\n\tmutex_unlock(&rdev->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_set_mode);\n\nstatic unsigned int _regulator_get_mode(struct regulator_dev *rdev)\n{\n\tint ret;\n\n\tmutex_lock(&rdev->mutex);\n\n\t/* sanity check */\n\tif (!rdev->desc->ops->get_mode) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = rdev->desc->ops->get_mode(rdev);\nout:\n\tmutex_unlock(&rdev->mutex);\n\treturn ret;\n}\n\n/**\n * regulator_get_mode - get regulator operating mode\n * @regulator: regulator source\n *\n * Get the current regulator operating mode.\n */\nunsigned int regulator_get_mode(struct regulator *regulator)\n{\n\treturn _regulator_get_mode(regulator->rdev);\n}\nEXPORT_SYMBOL_GPL(regulator_get_mode);\n\n/**\n * regulator_set_optimum_mode - set regulator optimum operating mode\n * @regulator: regulator source\n * @uA_load: load current\n *\n * Notifies the regulator core of a new device load. This is then used by\n * DRMS (if enabled by constraints) to set the most efficient regulator\n * operating mode for the new regulator loading.\n *\n * Consumer devices notify their supply regulator of the maximum power\n * they will require (can be taken from device datasheet in the power\n * consumption tables) when they change operational status and hence power\n * state. Examples of operational state changes that can affect power\n * consumption are :-\n *\n *    o Device is opened / closed.\n *    o Device I/O is about to begin or has just finished.\n *    o Device is idling in between work.\n *\n * This information is also exported via sysfs to userspace.\n *\n * DRMS will sum the total requested load on the regulator and change\n * to the most efficient operating mode if platform constraints allow.\n *\n * Returns the new regulator mode or error.\n */\nint regulator_set_optimum_mode(struct regulator *regulator, int uA_load)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tstruct regulator *consumer;\n\tint ret, output_uV, input_uV = 0, total_uA_load = 0;\n\tunsigned int mode;\n\n\tif (rdev->supply)\n\t\tinput_uV = regulator_get_voltage(rdev->supply);\n\n\tmutex_lock(&rdev->mutex);\n\n\t/*\n\t * first check to see if we can set modes at all, otherwise just\n\t * tell the consumer everything is OK.\n\t */\n\tregulator->uA_load = uA_load;\n\tret = regulator_check_drms(rdev);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (!rdev->desc->ops->get_optimum_mode)\n\t\tgoto out;\n\n\t/*\n\t * we can actually do this so any errors are indicators of\n\t * potential real failure.\n\t */\n\tret = -EINVAL;\n\n\tif (!rdev->desc->ops->set_mode)\n\t\tgoto out;\n\n\t/* get output voltage */\n\toutput_uV = _regulator_get_voltage(rdev);\n\tif (output_uV <= 0) {\n\t\trdev_err(rdev, \"invalid output voltage found\\n\");\n\t\tgoto out;\n\t}\n\n\t/* No supply? Use constraint voltage */\n\tif (input_uV <= 0)\n\t\tinput_uV = rdev->constraints->input_uV;\n\tif (input_uV <= 0) {\n\t\trdev_err(rdev, \"invalid input voltage found\\n\");\n\t\tgoto out;\n\t}\n\n\t/* calc total requested load for this regulator */\n\tlist_for_each_entry(consumer, &rdev->consumer_list, list)\n\t\ttotal_uA_load += consumer->uA_load;\n\n\tmode = rdev->desc->ops->get_optimum_mode(rdev,\n\t\t\t\t\t\t input_uV, output_uV,\n\t\t\t\t\t\t total_uA_load);\n\tret = regulator_mode_constrain(rdev, &mode);\n\tif (ret < 0) {\n\t\trdev_err(rdev, \"failed to get optimum mode @ %d uA %d -> %d uV\\n\",\n\t\t\t total_uA_load, input_uV, output_uV);\n\t\tgoto out;\n\t}\n\n\tret = rdev->desc->ops->set_mode(rdev, mode);\n\tif (ret < 0) {\n\t\trdev_err(rdev, \"failed to set optimum mode %x\\n\", mode);\n\t\tgoto out;\n\t}\n\tret = mode;\nout:\n\tmutex_unlock(&rdev->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_set_optimum_mode);\n\n/**\n * regulator_allow_bypass - allow the regulator to go into bypass mode\n *\n * @regulator: Regulator to configure\n * @enable: enable or disable bypass mode\n *\n * Allow the regulator to go into bypass mode if all other consumers\n * for the regulator also enable bypass mode and the machine\n * constraints allow this.  Bypass mode means that the regulator is\n * simply passing the input directly to the output with no regulation.\n */\nint regulator_allow_bypass(struct regulator *regulator, bool enable)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret = 0;\n\n\tif (!rdev->desc->ops->set_bypass)\n\t\treturn 0;\n\n\tif (rdev->constraints &&\n\t    !(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_BYPASS))\n\t\treturn 0;\n\n\tmutex_lock(&rdev->mutex);\n\n\tif (enable && !regulator->bypass) {\n\t\trdev->bypass_count++;\n\n\t\tif (rdev->bypass_count == rdev->open_count) {\n\t\t\tret = rdev->desc->ops->set_bypass(rdev, enable);\n\t\t\tif (ret != 0)\n\t\t\t\trdev->bypass_count--;\n\t\t}\n\n\t} else if (!enable && regulator->bypass) {\n\t\trdev->bypass_count--;\n\n\t\tif (rdev->bypass_count != rdev->open_count) {\n\t\t\tret = rdev->desc->ops->set_bypass(rdev, enable);\n\t\t\tif (ret != 0)\n\t\t\t\trdev->bypass_count++;\n\t\t}\n\t}\n\n\tif (ret == 0)\n\t\tregulator->bypass = enable;\n\n\tmutex_unlock(&rdev->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_allow_bypass);\n\n/**\n * regulator_register_notifier - register regulator event notifier\n * @regulator: regulator source\n * @nb: notifier block\n *\n * Register notifier block to receive regulator events.\n */\nint regulator_register_notifier(struct regulator *regulator,\n\t\t\t      struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&regulator->rdev->notifier,\n\t\t\t\t\t\tnb);\n}\nEXPORT_SYMBOL_GPL(regulator_register_notifier);\n\n/**\n * regulator_unregister_notifier - unregister regulator event notifier\n * @regulator: regulator source\n * @nb: notifier block\n *\n * Unregister regulator event notifier block.\n */\nint regulator_unregister_notifier(struct regulator *regulator,\n\t\t\t\tstruct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&regulator->rdev->notifier,\n\t\t\t\t\t\t  nb);\n}\nEXPORT_SYMBOL_GPL(regulator_unregister_notifier);\n\n/* notify regulator consumers and downstream regulator consumers.\n * Note mutex must be held by caller.\n */\nstatic int _notifier_call_chain(struct regulator_dev *rdev,\n\t\t\t\t  unsigned long event, void *data)\n{\n\t/* call rdev chain first */\n\treturn blocking_notifier_call_chain(&rdev->notifier, event, data);\n}\n\n/**\n * regulator_bulk_get - get multiple regulator consumers\n *\n * @dev:           Device to supply\n * @num_consumers: Number of consumers to register\n * @consumers:     Configuration of consumers; clients are stored here.\n *\n * @return 0 on success, an errno on failure.\n *\n * This helper function allows drivers to get several regulator\n * consumers in one operation.  If any of the regulators cannot be\n * acquired then any regulators that were allocated will be freed\n * before returning to the caller.\n */\nint regulator_bulk_get(struct device *dev, int num_consumers,\n\t\t       struct regulator_bulk_data *consumers)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < num_consumers; i++)\n\t\tconsumers[i].consumer = NULL;\n\n\tfor (i = 0; i < num_consumers; i++) {\n\t\tconsumers[i].consumer = regulator_get(dev,\n\t\t\t\t\t\t      consumers[i].supply);\n\t\tif (IS_ERR(consumers[i].consumer)) {\n\t\t\tret = PTR_ERR(consumers[i].consumer);\n\t\t\tdev_err(dev, \"Failed to get supply '%s': %d\\n\",\n\t\t\t\tconsumers[i].supply, ret);\n\t\t\tconsumers[i].consumer = NULL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (--i >= 0)\n\t\tregulator_put(consumers[i].consumer);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_get);\n\nstatic void regulator_bulk_enable_async(void *data, async_cookie_t cookie)\n{\n\tstruct regulator_bulk_data *bulk = data;\n\n\tbulk->ret = regulator_enable(bulk->consumer);\n}\n\n/**\n * regulator_bulk_enable - enable multiple regulator consumers\n *\n * @num_consumers: Number of consumers\n * @consumers:     Consumer data; clients are stored here.\n * @return         0 on success, an errno on failure\n *\n * This convenience API allows consumers to enable multiple regulator\n * clients in a single API call.  If any consumers cannot be enabled\n * then any others that were enabled will be disabled again prior to\n * return.\n */\nint regulator_bulk_enable(int num_consumers,\n\t\t\t  struct regulator_bulk_data *consumers)\n{\n\tASYNC_DOMAIN_EXCLUSIVE(async_domain);\n\tint i;\n\tint ret = 0;\n\n\tfor (i = 0; i < num_consumers; i++) {\n\t\tif (consumers[i].consumer->always_on)\n\t\t\tconsumers[i].ret = 0;\n\t\telse\n\t\t\tasync_schedule_domain(regulator_bulk_enable_async,\n\t\t\t\t\t      &consumers[i], &async_domain);\n\t}\n\n\tasync_synchronize_full_domain(&async_domain);\n\n\t/* If any consumer failed we need to unwind any that succeeded */\n\tfor (i = 0; i < num_consumers; i++) {\n\t\tif (consumers[i].ret != 0) {\n\t\t\tret = consumers[i].ret;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (i = 0; i < num_consumers; i++) {\n\t\tif (consumers[i].ret < 0)\n\t\t\tpr_err(\"Failed to enable %s: %d\\n\", consumers[i].supply,\n\t\t\t       consumers[i].ret);\n\t\telse\n\t\t\tregulator_disable(consumers[i].consumer);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_enable);\n\n/**\n * regulator_bulk_disable - disable multiple regulator consumers\n *\n * @num_consumers: Number of consumers\n * @consumers:     Consumer data; clients are stored here.\n * @return         0 on success, an errno on failure\n *\n * This convenience API allows consumers to disable multiple regulator\n * clients in a single API call.  If any consumers cannot be disabled\n * then any others that were disabled will be enabled again prior to\n * return.\n */\nint regulator_bulk_disable(int num_consumers,\n\t\t\t   struct regulator_bulk_data *consumers)\n{\n\tint i;\n\tint ret, r;\n\n\tfor (i = num_consumers - 1; i >= 0; --i) {\n\t\tret = regulator_disable(consumers[i].consumer);\n\t\tif (ret != 0)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tpr_err(\"Failed to disable %s: %d\\n\", consumers[i].supply, ret);\n\tfor (++i; i < num_consumers; ++i) {\n\t\tr = regulator_enable(consumers[i].consumer);\n\t\tif (r != 0)\n\t\t\tpr_err(\"Failed to reename %s: %d\\n\",\n\t\t\t       consumers[i].supply, r);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_disable);\n\n/**\n * regulator_bulk_force_disable - force disable multiple regulator consumers\n *\n * @num_consumers: Number of consumers\n * @consumers:     Consumer data; clients are stored here.\n * @return         0 on success, an errno on failure\n *\n * This convenience API allows consumers to forcibly disable multiple regulator\n * clients in a single API call.\n * NOTE: This should be used for situations when device damage will\n * likely occur if the regulators are not disabled (e.g. over temp).\n * Although regulator_force_disable function call for some consumers can\n * return error numbers, the function is called for all consumers.\n */\nint regulator_bulk_force_disable(int num_consumers,\n\t\t\t   struct regulator_bulk_data *consumers)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < num_consumers; i++)\n\t\tconsumers[i].ret =\n\t\t\t    regulator_force_disable(consumers[i].consumer);\n\n\tfor (i = 0; i < num_consumers; i++) {\n\t\tif (consumers[i].ret != 0) {\n\t\t\tret = consumers[i].ret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\treturn 0;\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_force_disable);\n\n/**\n * regulator_bulk_free - free multiple regulator consumers\n *\n * @num_consumers: Number of consumers\n * @consumers:     Consumer data; clients are stored here.\n *\n * This convenience API allows consumers to free multiple regulator\n * clients in a single API call.\n */\nvoid regulator_bulk_free(int num_consumers,\n\t\t\t struct regulator_bulk_data *consumers)\n{\n\tint i;\n\n\tfor (i = 0; i < num_consumers; i++) {\n\t\tregulator_put(consumers[i].consumer);\n\t\tconsumers[i].consumer = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_free);\n\n/**\n * regulator_notifier_call_chain - call regulator event notifier\n * @rdev: regulator source\n * @event: notifier block\n * @data: callback-specific data.\n *\n * Called by regulator drivers to notify clients a regulator event has\n * occurred. We also notify regulator clients downstream.\n * Note lock must be held by caller.\n */\nint regulator_notifier_call_chain(struct regulator_dev *rdev,\n\t\t\t\t  unsigned long event, void *data)\n{\n\t_notifier_call_chain(rdev, event, data);\n\treturn NOTIFY_DONE;\n\n}\nEXPORT_SYMBOL_GPL(regulator_notifier_call_chain);\n\n/**\n * regulator_mode_to_status - convert a regulator mode into a status\n *\n * @mode: Mode to convert\n *\n * Convert a regulator mode into a status.\n */\nint regulator_mode_to_status(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\treturn REGULATOR_STATUS_FAST;\n\tcase REGULATOR_MODE_NORMAL:\n\t\treturn REGULATOR_STATUS_NORMAL;\n\tcase REGULATOR_MODE_IDLE:\n\t\treturn REGULATOR_STATUS_IDLE;\n\tcase REGULATOR_MODE_STANDBY:\n\t\treturn REGULATOR_STATUS_STANDBY;\n\tdefault:\n\t\treturn REGULATOR_STATUS_UNDEFINED;\n\t}\n}\nEXPORT_SYMBOL_GPL(regulator_mode_to_status);\n\n/*\n * To avoid cluttering sysfs (and memory) with useless state, only\n * create attributes that can be meaningfully displayed.\n */\nstatic int add_regulator_attributes(struct regulator_dev *rdev)\n{\n\tstruct device *dev = &rdev->dev;\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\tint status = 0;\n\n\t/* some attributes need specific methods to be displayed */\n\tif ((ops->get_voltage && ops->get_voltage(rdev) >= 0) ||\n\t    (ops->get_voltage_sel && ops->get_voltage_sel(rdev) >= 0) ||\n\t    (ops->list_voltage && ops->list_voltage(rdev, 0) >= 0) ||\n\t\t(rdev->desc->fixed_uV && (rdev->desc->n_voltages == 1))) {\n\t\tstatus = device_create_file(dev, &dev_attr_microvolts);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\tif (ops->get_current_limit) {\n\t\tstatus = device_create_file(dev, &dev_attr_microamps);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\tif (ops->get_mode) {\n\t\tstatus = device_create_file(dev, &dev_attr_opmode);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\tif (rdev->ena_pin || ops->is_enabled) {\n\t\tstatus = device_create_file(dev, &dev_attr_state);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\tif (ops->get_status) {\n\t\tstatus = device_create_file(dev, &dev_attr_status);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\tif (ops->get_bypass) {\n\t\tstatus = device_create_file(dev, &dev_attr_bypass);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\t/* some attributes are type-specific */\n\tif (rdev->desc->type == REGULATOR_CURRENT) {\n\t\tstatus = device_create_file(dev, &dev_attr_requested_microamps);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\t/* all the other attributes exist to support constraints;\n\t * don't show them if there are no constraints, or if the\n\t * relevant supporting methods are missing.\n\t */\n\tif (!rdev->constraints)\n\t\treturn status;\n\n\t/* constraints need specific supporting methods */\n\tif (ops->set_voltage || ops->set_voltage_sel) {\n\t\tstatus = device_create_file(dev, &dev_attr_min_microvolts);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tstatus = device_create_file(dev, &dev_attr_max_microvolts);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\tif (ops->set_current_limit) {\n\t\tstatus = device_create_file(dev, &dev_attr_min_microamps);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tstatus = device_create_file(dev, &dev_attr_max_microamps);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\tstatus = device_create_file(dev, &dev_attr_suspend_standby_state);\n\tif (status < 0)\n\t\treturn status;\n\tstatus = device_create_file(dev, &dev_attr_suspend_mem_state);\n\tif (status < 0)\n\t\treturn status;\n\tstatus = device_create_file(dev, &dev_attr_suspend_disk_state);\n\tif (status < 0)\n\t\treturn status;\n\n\tif (ops->set_suspend_voltage) {\n\t\tstatus = device_create_file(dev,\n\t\t\t\t&dev_attr_suspend_standby_microvolts);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tstatus = device_create_file(dev,\n\t\t\t\t&dev_attr_suspend_mem_microvolts);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tstatus = device_create_file(dev,\n\t\t\t\t&dev_attr_suspend_disk_microvolts);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\tif (ops->set_suspend_mode) {\n\t\tstatus = device_create_file(dev,\n\t\t\t\t&dev_attr_suspend_standby_mode);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tstatus = device_create_file(dev,\n\t\t\t\t&dev_attr_suspend_mem_mode);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tstatus = device_create_file(dev,\n\t\t\t\t&dev_attr_suspend_disk_mode);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\treturn status;\n}\n\nstatic void rdev_init_debugfs(struct regulator_dev *rdev)\n{\n\trdev->debugfs = debugfs_create_dir(rdev_get_name(rdev), debugfs_root);\n\tif (!rdev->debugfs) {\n\t\trdev_warn(rdev, \"Failed to create debugfs directory\\n\");\n\t\treturn;\n\t}\n\n\tdebugfs_create_u32(\"use_count\", 0444, rdev->debugfs,\n\t\t\t   &rdev->use_count);\n\tdebugfs_create_u32(\"open_count\", 0444, rdev->debugfs,\n\t\t\t   &rdev->open_count);\n\tdebugfs_create_u32(\"bypass_count\", 0444, rdev->debugfs,\n\t\t\t   &rdev->bypass_count);\n}\n\n/**\n * regulator_register - register regulator\n * @regulator_desc: regulator to register\n * @config: runtime configuration for regulator\n *\n * Called by regulator drivers to register a regulator.\n * Returns a valid pointer to struct regulator_dev on success\n * or an ERR_PTR() on error.\n */\nstruct regulator_dev *\nregulator_register(const struct regulator_desc *regulator_desc,\n\t\t   const struct regulator_config *config)\n{\n\tconst struct regulation_constraints *constraints = NULL;\n\tconst struct regulator_init_data *init_data;\n\tstatic atomic_t regulator_no = ATOMIC_INIT(0);\n\tstruct regulator_dev *rdev;\n\tstruct device *dev;\n\tint ret, i;\n\tconst char *supply = NULL;\n\n\tif (regulator_desc == NULL || config == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = config->dev;\n\tWARN_ON(!dev);\n\n\tif (regulator_desc->name == NULL || regulator_desc->ops == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (regulator_desc->type != REGULATOR_VOLTAGE &&\n\t    regulator_desc->type != REGULATOR_CURRENT)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Only one of each should be implemented */\n\tWARN_ON(regulator_desc->ops->get_voltage &&\n\t\tregulator_desc->ops->get_voltage_sel);\n\tWARN_ON(regulator_desc->ops->set_voltage &&\n\t\tregulator_desc->ops->set_voltage_sel);\n\n\t/* If we're using selectors we must implement list_voltage. */\n\tif (regulator_desc->ops->get_voltage_sel &&\n\t    !regulator_desc->ops->list_voltage) {\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (regulator_desc->ops->set_voltage_sel &&\n\t    !regulator_desc->ops->list_voltage) {\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\trdev = kzalloc(sizeof(struct regulator_dev), GFP_KERNEL);\n\tif (rdev == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit_data = regulator_of_get_init_data(dev, regulator_desc,\n\t\t\t\t\t       &rdev->dev.of_node);\n\tif (!init_data) {\n\t\tinit_data = config->init_data;\n\t\trdev->dev.of_node = of_node_get(config->of_node);\n\t}\n\n\tmutex_lock(&regulator_list_mutex);\n\n\tmutex_init(&rdev->mutex);\n\trdev->reg_data = config->driver_data;\n\trdev->owner = regulator_desc->owner;\n\trdev->desc = regulator_desc;\n\tif (config->regmap)\n\t\trdev->regmap = config->regmap;\n\telse if (dev_get_regmap(dev, NULL))\n\t\trdev->regmap = dev_get_regmap(dev, NULL);\n\telse if (dev->parent)\n\t\trdev->regmap = dev_get_regmap(dev->parent, NULL);\n\tINIT_LIST_HEAD(&rdev->consumer_list);\n\tINIT_LIST_HEAD(&rdev->list);\n\tBLOCKING_INIT_NOTIFIER_HEAD(&rdev->notifier);\n\tINIT_DELAYED_WORK(&rdev->disable_work, regulator_disable_work);\n\n\t/* preform any regulator specific init */\n\tif (init_data && init_data->regulator_init) {\n\t\tret = init_data->regulator_init(rdev->reg_data);\n\t\tif (ret < 0)\n\t\t\tgoto clean;\n\t}\n\n\t/* register with sysfs */\n\trdev->dev.class = &regulator_class;\n\trdev->dev.parent = dev;\n\tdev_set_name(&rdev->dev, \"regulator.%d\",\n\t\t     atomic_inc_return(&regulator_no) - 1);\n\tret = device_register(&rdev->dev);\n\tif (ret != 0) {\n\t\tput_device(&rdev->dev);\n\t\tgoto clean;\n\t}\n\n\tdev_set_drvdata(&rdev->dev, rdev);\n\n\tif (config->ena_gpio && gpio_is_valid(config->ena_gpio)) {\n\t\tret = regulator_ena_gpio_request(rdev, config);\n\t\tif (ret != 0) {\n\t\t\trdev_err(rdev, \"Failed to request enable GPIO%d: %d\\n\",\n\t\t\t\t config->ena_gpio, ret);\n\t\t\tgoto wash;\n\t\t}\n\n\t\tif (config->ena_gpio_flags & GPIOF_OUT_INIT_HIGH)\n\t\t\trdev->ena_gpio_state = 1;\n\n\t\tif (config->ena_gpio_invert)\n\t\t\trdev->ena_gpio_state = !rdev->ena_gpio_state;\n\t}\n\n\t/* set regulator constraints */\n\tif (init_data)\n\t\tconstraints = &init_data->constraints;\n\n\tret = set_machine_constraints(rdev, constraints);\n\tif (ret < 0)\n\t\tgoto scrub;\n\n\t/* add attributes supported by this regulator */\n\tret = add_regulator_attributes(rdev);\n\tif (ret < 0)\n\t\tgoto scrub;\n\n\tif (init_data && init_data->supply_regulator)\n\t\tsupply = init_data->supply_regulator;\n\telse if (regulator_desc->supply_name)\n\t\tsupply = regulator_desc->supply_name;\n\n\tif (supply) {\n\t\tstruct regulator_dev *r;\n\n\t\tr = regulator_dev_lookup(dev, supply, &ret);\n\n\t\tif (ret == -ENODEV) {\n\t\t\t/*\n\t\t\t * No supply was specified for this regulator and\n\t\t\t * there will never be one.\n\t\t\t */\n\t\t\tret = 0;\n\t\t\tgoto add_dev;\n\t\t} else if (!r) {\n\t\t\tdev_err(dev, \"Failed to find supply %s\\n\", supply);\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto scrub;\n\t\t}\n\n\t\tret = set_supply(rdev, r);\n\t\tif (ret < 0)\n\t\t\tgoto scrub;\n\n\t\t/* Enable supply if rail is enabled */\n\t\tif (_regulator_is_enabled(rdev)) {\n\t\t\tret = regulator_enable(rdev->supply);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto scrub;\n\t\t}\n\t}\n\nadd_dev:\n\t/* add consumers devices */\n\tif (init_data) {\n\t\tfor (i = 0; i < init_data->num_consumer_supplies; i++) {\n\t\t\tret = set_consumer_device_supply(rdev,\n\t\t\t\tinit_data->consumer_supplies[i].dev_name,\n\t\t\t\tinit_data->consumer_supplies[i].supply);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"Failed to set supply %s\\n\",\n\t\t\t\t\tinit_data->consumer_supplies[i].supply);\n\t\t\t\tgoto unset_supplies;\n\t\t\t}\n\t\t}\n\t}\n\n\tlist_add(&rdev->list, &regulator_list);\n\n\trdev_init_debugfs(rdev);\nout:\n\tmutex_unlock(&regulator_list_mutex);\n\treturn rdev;\n\nunset_supplies:\n\tunset_regulator_supplies(rdev);\n\nscrub:\n\tif (rdev->supply)\n\t\t_regulator_put(rdev->supply);\n\tregulator_ena_gpio_free(rdev);\n\tkfree(rdev->constraints);\nwash:\n\tdevice_unregister(&rdev->dev);\n\t/* device core frees rdev */\n\trdev = ERR_PTR(ret);\n\tgoto out;\n\nclean:\n\tkfree(rdev);\n\trdev = ERR_PTR(ret);\n\tgoto out;\n}\nEXPORT_SYMBOL_GPL(regulator_register);\n\n/**\n * regulator_unregister - unregister regulator\n * @rdev: regulator to unregister\n *\n * Called by regulator drivers to unregister a regulator.\n */\nvoid regulator_unregister(struct regulator_dev *rdev)\n{\n\tif (rdev == NULL)\n\t\treturn;\n\n\tif (rdev->supply) {\n\t\twhile (rdev->use_count--)\n\t\t\tregulator_disable(rdev->supply);\n\t\tregulator_put(rdev->supply);\n\t}\n\tmutex_lock(&regulator_list_mutex);\n\tdebugfs_remove_recursive(rdev->debugfs);\n\tflush_work(&rdev->disable_work.work);\n\tWARN_ON(rdev->open_count);\n\tunset_regulator_supplies(rdev);\n\tlist_del(&rdev->list);\n\tkfree(rdev->constraints);\n\tregulator_ena_gpio_free(rdev);\n\tof_node_put(rdev->dev.of_node);\n\tdevice_unregister(&rdev->dev);\n\tmutex_unlock(&regulator_list_mutex);\n}\nEXPORT_SYMBOL_GPL(regulator_unregister);\n\n/**\n * regulator_suspend_prepare - prepare regulators for system wide suspend\n * @state: system suspend state\n *\n * Configure each regulator with it's suspend operating parameters for state.\n * This will usually be called by machine suspend code prior to supending.\n */\nint regulator_suspend_prepare(suspend_state_t state)\n{\n\tstruct regulator_dev *rdev;\n\tint ret = 0;\n\n\t/* ON is handled by regulator active state */\n\tif (state == PM_SUSPEND_ON)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&regulator_list_mutex);\n\tlist_for_each_entry(rdev, &regulator_list, list) {\n\n\t\tmutex_lock(&rdev->mutex);\n\t\tret = suspend_prepare(rdev, state);\n\t\tmutex_unlock(&rdev->mutex);\n\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to prepare\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&regulator_list_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_suspend_prepare);\n\n/**\n * regulator_suspend_finish - resume regulators from system wide suspend\n *\n * Turn on regulators that might be turned off by regulator_suspend_prepare\n * and that should be turned on according to the regulators properties.\n */\nint regulator_suspend_finish(void)\n{\n\tstruct regulator_dev *rdev;\n\tint ret = 0, error;\n\n\tmutex_lock(&regulator_list_mutex);\n\tlist_for_each_entry(rdev, &regulator_list, list) {\n\t\tmutex_lock(&rdev->mutex);\n\t\tif (rdev->use_count > 0  || rdev->constraints->always_on) {\n\t\t\terror = _regulator_do_enable(rdev);\n\t\t\tif (error)\n\t\t\t\tret = error;\n\t\t} else {\n\t\t\tif (!have_full_constraints())\n\t\t\t\tgoto unlock;\n\t\t\tif (!_regulator_is_enabled(rdev))\n\t\t\t\tgoto unlock;\n\n\t\t\terror = _regulator_do_disable(rdev);\n\t\t\tif (error)\n\t\t\t\tret = error;\n\t\t}\nunlock:\n\t\tmutex_unlock(&rdev->mutex);\n\t}\n\tmutex_unlock(&regulator_list_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_suspend_finish);\n\n/**\n * regulator_has_full_constraints - the system has fully specified constraints\n *\n * Calling this function will cause the regulator API to disable all\n * regulators which have a zero use count and don't have an always_on\n * constraint in a late_initcall.\n *\n * The intention is that this will become the default behaviour in a\n * future kernel release so users are encouraged to use this facility\n * now.\n */\nvoid regulator_has_full_constraints(void)\n{\n\thas_full_constraints = 1;\n}\nEXPORT_SYMBOL_GPL(regulator_has_full_constraints);\n\n/**\n * rdev_get_drvdata - get rdev regulator driver data\n * @rdev: regulator\n *\n * Get rdev regulator driver private data. This call can be used in the\n * regulator driver context.\n */\nvoid *rdev_get_drvdata(struct regulator_dev *rdev)\n{\n\treturn rdev->reg_data;\n}\nEXPORT_SYMBOL_GPL(rdev_get_drvdata);\n\n/**\n * regulator_get_drvdata - get regulator driver data\n * @regulator: regulator\n *\n * Get regulator driver private data. This call can be used in the consumer\n * driver context when non API regulator specific functions need to be called.\n */\nvoid *regulator_get_drvdata(struct regulator *regulator)\n{\n\treturn regulator->rdev->reg_data;\n}\nEXPORT_SYMBOL_GPL(regulator_get_drvdata);\n\n/**\n * regulator_set_drvdata - set regulator driver data\n * @regulator: regulator\n * @data: data\n */\nvoid regulator_set_drvdata(struct regulator *regulator, void *data)\n{\n\tregulator->rdev->reg_data = data;\n}\nEXPORT_SYMBOL_GPL(regulator_set_drvdata);\n\n/**\n * regulator_get_id - get regulator ID\n * @rdev: regulator\n */\nint rdev_get_id(struct regulator_dev *rdev)\n{\n\treturn rdev->desc->id;\n}\nEXPORT_SYMBOL_GPL(rdev_get_id);\n\nstruct device *rdev_get_dev(struct regulator_dev *rdev)\n{\n\treturn &rdev->dev;\n}\nEXPORT_SYMBOL_GPL(rdev_get_dev);\n\nvoid *regulator_get_init_drvdata(struct regulator_init_data *reg_init_data)\n{\n\treturn reg_init_data->driver_data;\n}\nEXPORT_SYMBOL_GPL(regulator_get_init_drvdata);\n\n#ifdef CONFIG_DEBUG_FS\nstatic ssize_t supply_map_read_file(struct file *file, char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tchar *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tssize_t len, ret = 0;\n\tstruct regulator_map *map;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(map, &regulator_map_list, list) {\n\t\tlen = snprintf(buf + ret, PAGE_SIZE - ret,\n\t\t\t       \"%s -> %s.%s\\n\",\n\t\t\t       rdev_get_name(map->regulator), map->dev_name,\n\t\t\t       map->supply);\n\t\tif (len >= 0)\n\t\t\tret += len;\n\t\tif (ret > PAGE_SIZE) {\n\t\t\tret = PAGE_SIZE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);\n\n\tkfree(buf);\n\n\treturn ret;\n}\n#endif\n\nstatic const struct file_operations supply_map_fops = {\n#ifdef CONFIG_DEBUG_FS\n\t.read = supply_map_read_file,\n\t.llseek = default_llseek,\n#endif\n};\n\nstatic int __init regulator_init(void)\n{\n\tint ret;\n\n\tret = class_register(&regulator_class);\n\n\tdebugfs_root = debugfs_create_dir(\"regulator\", NULL);\n\tif (!debugfs_root)\n\t\tpr_warn(\"regulator: Failed to create debugfs directory\\n\");\n\n\tdebugfs_create_file(\"supply_map\", 0444, debugfs_root, NULL,\n\t\t\t    &supply_map_fops);\n\n\tregulator_dummy_init();\n\n\treturn ret;\n}\n\n/* init early to allow our consumers to complete system booting */\ncore_initcall(regulator_init);\n\nstatic int __init regulator_init_complete(void)\n{\n\tstruct regulator_dev *rdev;\n\tconst struct regulator_ops *ops;\n\tstruct regulation_constraints *c;\n\tint enabled, ret;\n\n\t/*\n\t * Since DT doesn't provide an idiomatic mechanism for\n\t * enabling full constraints and since it's much more natural\n\t * with DT to provide them just assume that a DT enabled\n\t * system has full constraints.\n\t */\n\tif (of_have_populated_dt())\n\t\thas_full_constraints = true;\n\n\tmutex_lock(&regulator_list_mutex);\n\n\t/* If we have a full configuration then disable any regulators\n\t * we have permission to change the status for and which are\n\t * not in use or always_on.  This is effectively the default\n\t * for DT and ACPI as they have full constraints.\n\t */\n\tlist_for_each_entry(rdev, &regulator_list, list) {\n\t\tops = rdev->desc->ops;\n\t\tc = rdev->constraints;\n\n\t\tif (c && c->always_on)\n\t\t\tcontinue;\n\n\t\tif (c && !(c->valid_ops_mask & REGULATOR_CHANGE_STATUS))\n\t\t\tcontinue;\n\n\t\tmutex_lock(&rdev->mutex);\n\n\t\tif (rdev->use_count)\n\t\t\tgoto unlock;\n\n\t\t/* If we can't read the status assume it's on. */\n\t\tif (ops->is_enabled)\n\t\t\tenabled = ops->is_enabled(rdev);\n\t\telse\n\t\t\tenabled = 1;\n\n\t\tif (!enabled)\n\t\t\tgoto unlock;\n\n\t\tif (have_full_constraints()) {\n\t\t\t/* We log since this may kill the system if it\n\t\t\t * goes wrong. */\n\t\t\trdev_info(rdev, \"disabling\\n\");\n\t\t\tret = _regulator_do_disable(rdev);\n\t\t\tif (ret != 0)\n\t\t\t\trdev_err(rdev, \"couldn't disable: %d\\n\", ret);\n\t\t} else {\n\t\t\t/* The intention is that in future we will\n\t\t\t * assume that full constraints are provided\n\t\t\t * so warn even if we aren't going to do\n\t\t\t * anything here.\n\t\t\t */\n\t\t\trdev_warn(rdev, \"incomplete constraints, leaving on\\n\");\n\t\t}\n\nunlock:\n\t\tmutex_unlock(&rdev->mutex);\n\t}\n\n\tmutex_unlock(&regulator_list_mutex);\n\n\treturn 0;\n}\nlate_initcall_sync(regulator_init_complete);\n"], "filenames": ["drivers/regulator/core.c"], "buggy_code_start_loc": [1715], "buggy_code_end_loc": [1715], "fixing_code_start_loc": [1716], "fixing_code_end_loc": [1718], "type": "CWE-416", "message": "The regulator_ena_gpio_free function in drivers/regulator/core.c in the Linux kernel before 3.19 allows local users to gain privileges or cause a denial of service (use-after-free) via a crafted application.", "other": {"cve": {"id": "CVE-2014-9940", "sourceIdentifier": "security@android.com", "published": "2017-05-02T21:59:00.167", "lastModified": "2017-11-04T01:29:01.850", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The regulator_ena_gpio_free function in drivers/regulator/core.c in the Linux kernel before 3.19 allows local users to gain privileges or cause a denial of service (use-after-free) via a crafted application."}, {"lang": "es", "value": "La funci\u00f3n regulator_ena_gpio_free en drivers/regulator/core.c en el kernel de Linux anterior a la versi\u00f3n 3.19 permite a usuarios locales elevar sus privilegios o provocar una denegaci\u00f3n de servicio (uso despu\u00e9s de liberaci\u00f3n) a trav\u00e9s de una aplicaci\u00f3n especialmente dise\u00f1ada para aprovechar el fallo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.6}, "baseSeverity": "HIGH", "exploitabilityScore": 4.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.18.52", "matchCriteriaId": "0FE5C1F1-9EA7-4AED-94B1-E79323289E94"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:google:android:*:*:*:*:*:*:*:*", "versionEndIncluding": "7.1.1", "matchCriteriaId": "0F11609D-D1B4-4DD6-8CC7-A224344E1E67"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=60a2362f769cf549dc466134efe71c8bf9fbaaba", "source": "security@android.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3945", "source": "security@android.com"}, {"url": "http://www.securityfocus.com/bid/98195", "source": "security@android.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/60a2362f769cf549dc466134efe71c8bf9fbaaba", "source": "security@android.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/2017-05-01", "source": "security@android.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/60a2362f769cf549dc466134efe71c8bf9fbaaba"}}