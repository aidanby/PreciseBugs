{"buggy_code": ["use super::*;\nuse std::ffi::{CStr, CString};\nuse std::mem::size_of;\nuse std::ptr;\nuse vm::VMRange;\n\n/// Memory utilities that deals with primitive types passed from user process\n/// running inside enclave\npub mod from_user {\n    use super::*;\n\n    /// Check the user pointer is within the readable memory range of the user process\n    pub fn check_ptr<T>(user_ptr: *const T) -> Result<()> {\n        if !is_inside_user_space(user_ptr as *const u8, size_of::<T>()) {\n            return_errno!(EFAULT, \"pointer is not in the user space\");\n        }\n        Ok(())\n    }\n\n    /// Check the mutable user pointer is within the writable memory of the user process\n    pub fn check_mut_ptr<T>(user_ptr: *mut T) -> Result<()> {\n        // The user space is both readable and writable on SGX1.\n        // TODO: Fine-tune the checking on SGX2.\n        check_ptr(user_ptr)\n    }\n\n    /// Check the readonly array is within the readable memory of the user process\n    pub fn check_array<T>(user_buf: *const T, count: usize) -> Result<()> {\n        let checked_len = count\n            .checked_mul(size_of::<T>())\n            .ok_or_else(|| errno!(EINVAL, \"the array is too long\"))?;\n        if !is_inside_user_space(user_buf as *const u8, checked_len) {\n            return_errno!(EFAULT, \"the whole buffer is not in the user space\");\n        }\n        Ok(())\n    }\n\n    /// Check the mutable array is within the writable memory of the user process\n    pub fn check_mut_array<T>(user_buf: *mut T, count: usize) -> Result<()> {\n        // The user space is both readable and writable on SGX1.\n        // TODO: Fine-tune the checking on SGX2.\n        check_array(user_buf, count)\n    }\n\n    /// Clone a C-string from the user process safely\n    pub fn clone_cstring_safely(out_ptr: *const c_char) -> Result<CString> {\n        if out_ptr.is_null() {\n            return_errno!(EINVAL, \"NULL address is invalid\");\n        }\n\n        let cstr = unsafe { CStr::from_ptr(out_ptr) };\n        let cstring = CString::from(cstr);\n        if !is_inside_user_space(out_ptr as *const u8, cstring.as_bytes().len()) {\n            return_errno!(EFAULT, \"the whole buffer is not in the user space\");\n        }\n        Ok(cstring)\n    }\n\n    /// Clone a C-string array (const char*[]) from the user process safely\n    ///\n    /// This array must be ended with a NULL pointer.\n    pub fn clone_cstrings_safely(user_ptr: *const *const c_char) -> Result<Vec<CString>> {\n        let mut cstrings = Vec::new();\n        if user_ptr == ptr::null() {\n            return Ok(cstrings);\n        }\n\n        let mut user_ptr = user_ptr;\n        loop {\n            check_ptr(user_ptr)?;\n\n            let cstr_ptr = {\n                let cstr_ptr = unsafe { *user_ptr };\n                if cstr_ptr == ptr::null() {\n                    break;\n                }\n                cstr_ptr\n            };\n            let cstring = clone_cstring_safely(cstr_ptr)?;\n            cstrings.push(cstring);\n\n            user_ptr = unsafe { user_ptr.offset(1) };\n        }\n        Ok(cstrings)\n    }\n\n    /// Check if the provided buffer is within the current user space\n    ///\n    /// addr: the start address\n    /// len: the length in byte\n    fn is_inside_user_space(addr: *const u8, len: usize) -> bool {\n        let current = current!();\n        let user_range = current.vm().get_process_range();\n        let ur_start = user_range.start();\n        let ur_end = user_range.end();\n        let addr_start = addr as usize;\n        addr_start >= ur_start && addr_start < ur_end && ur_end - addr_start >= len\n    }\n}\n\n/// Memory utilities that deals with primitive types passed from outside the enclave\npub mod from_untrusted {\n    use super::*;\n\n    /// Check the untrusted pointer is outside the enclave\n    pub fn check_ptr<T>(out_ptr: *const T) -> Result<()> {\n        if !sgx_trts::trts::rsgx_raw_is_outside_enclave(out_ptr as *const u8, size_of::<T>()) {\n            return_errno!(EFAULT, \"the pointer is not outside enclave\");\n        }\n        Ok(())\n    }\n\n    /// Check the untrusted array is outside the enclave\n    pub fn check_array<T>(out_ptr: *const T, count: usize) -> Result<()> {\n        let checked_len = count\n            .checked_mul(size_of::<T>())\n            .ok_or_else(|| errno!(EINVAL, \"the array is too long\"))?;\n        if !sgx_trts::trts::rsgx_raw_is_outside_enclave(out_ptr as *const u8, checked_len) {\n            return_errno!(EFAULT, \"the whole buffer is not outside enclave\");\n        }\n        Ok(())\n    }\n\n    /// Clone a C-string from outside the enclave\n    pub fn clone_cstring_safely(out_ptr: *const c_char) -> Result<CString> {\n        if out_ptr.is_null() {\n            return_errno!(EINVAL, \"NULL address is invalid\");\n        }\n\n        let cstr = unsafe { CStr::from_ptr(out_ptr) };\n        let cstring = CString::from(cstr);\n        if !sgx_trts::trts::rsgx_raw_is_outside_enclave(\n            out_ptr as *const u8,\n            cstring.as_bytes().len(),\n        ) {\n            return_errno!(EFAULT, \"the string is not outside enclave\");\n        }\n        Ok(cstring)\n    }\n\n    /// Clone a C-string array (const char*[]) from outside the enclave\n    ///\n    /// This array must be ended with a NULL pointer.\n    pub fn clone_cstrings_safely(out_ptr: *const *const c_char) -> Result<Vec<CString>> {\n        let mut cstrings = Vec::new();\n        if out_ptr == ptr::null() {\n            return Ok(cstrings);\n        }\n\n        let mut out_ptr = out_ptr;\n        loop {\n            check_ptr(out_ptr)?;\n\n            let cstr_ptr = {\n                let cstr_ptr = unsafe { *out_ptr };\n                if cstr_ptr == ptr::null() {\n                    break;\n                }\n                cstr_ptr\n            };\n            let cstring = clone_cstring_safely(cstr_ptr)?;\n            cstrings.push(cstring);\n\n            out_ptr = unsafe { out_ptr.offset(1) };\n        }\n        Ok(cstrings)\n    }\n}\n"], "fixing_code": ["use super::*;\nuse std::ffi::{CStr, CString};\nuse std::mem::size_of;\nuse std::ptr;\nuse vm::VMRange;\n\n/// Memory utilities that deals with primitive types passed from user process\n/// running inside enclave\npub mod from_user {\n    use super::*;\n\n    /// Check the user pointer is within the readable memory range of the user process\n    pub fn check_ptr<T>(user_ptr: *const T) -> Result<()> {\n        if !is_inside_user_space(user_ptr as *const u8, size_of::<T>()) {\n            return_errno!(EFAULT, \"pointer is not in the user space\");\n        }\n        Ok(())\n    }\n\n    /// Check the mutable user pointer is within the writable memory of the user process\n    pub fn check_mut_ptr<T>(user_ptr: *mut T) -> Result<()> {\n        // The user space is both readable and writable on SGX1.\n        // TODO: Fine-tune the checking on SGX2.\n        check_ptr(user_ptr)\n    }\n\n    /// Check the readonly array is within the readable memory of the user process\n    pub fn check_array<T>(user_buf: *const T, count: usize) -> Result<()> {\n        let checked_len = count\n            .checked_mul(size_of::<T>())\n            .ok_or_else(|| errno!(EINVAL, \"the array is too long\"))?;\n        if !is_inside_user_space(user_buf as *const u8, checked_len) {\n            return_errno!(EFAULT, \"the whole buffer is not in the user space\");\n        }\n        Ok(())\n    }\n\n    /// Check the mutable array is within the writable memory of the user process\n    pub fn check_mut_array<T>(user_buf: *mut T, count: usize) -> Result<()> {\n        // The user space is both readable and writable on SGX1.\n        // TODO: Fine-tune the checking on SGX2.\n        check_array(user_buf, count)\n    }\n\n    /// Clone a C-string from the user process safely\n    pub fn clone_cstring_safely(out_ptr: *const c_char) -> Result<CString> {\n        if out_ptr.is_null() {\n            return_errno!(EINVAL, \"NULL address is invalid\");\n        }\n\n        // confirm that at least the fisrt byte of the string is from user\n        check_ptr(out_ptr)?;\n\n        let cstr = unsafe { CStr::from_ptr(out_ptr) };\n        let cstring = CString::from(cstr);\n        if !is_inside_user_space(out_ptr as *const u8, cstring.as_bytes_with_nul().len()) {\n            return_errno!(EFAULT, \"the whole buffer is not in the user space\");\n        }\n        Ok(cstring)\n    }\n\n    /// Clone a C-string array (const char*[]) from the user process safely\n    ///\n    /// This array must be ended with a NULL pointer.\n    pub fn clone_cstrings_safely(user_ptr: *const *const c_char) -> Result<Vec<CString>> {\n        let mut cstrings = Vec::new();\n        if user_ptr == ptr::null() {\n            return Ok(cstrings);\n        }\n\n        let mut user_ptr = user_ptr;\n        loop {\n            check_ptr(user_ptr)?;\n\n            let cstr_ptr = {\n                let cstr_ptr = unsafe { *user_ptr };\n                if cstr_ptr == ptr::null() {\n                    break;\n                }\n                cstr_ptr\n            };\n            let cstring = clone_cstring_safely(cstr_ptr)?;\n            cstrings.push(cstring);\n\n            user_ptr = unsafe { user_ptr.offset(1) };\n        }\n        Ok(cstrings)\n    }\n\n    /// Check if the provided buffer is within the current user space\n    ///\n    /// addr: the start address\n    /// len: the length in byte\n    fn is_inside_user_space(addr: *const u8, len: usize) -> bool {\n        let current = current!();\n        let user_range = current.vm().get_process_range();\n        let ur_start = user_range.start();\n        let ur_end = user_range.end();\n        let addr_start = addr as usize;\n        addr_start >= ur_start && addr_start < ur_end && ur_end - addr_start >= len\n    }\n}\n\n/// Memory utilities that deals with primitive types passed from outside the enclave\npub mod from_untrusted {\n    use super::*;\n\n    /// Check the untrusted pointer is outside the enclave\n    pub fn check_ptr<T>(out_ptr: *const T) -> Result<()> {\n        if !sgx_trts::trts::rsgx_raw_is_outside_enclave(out_ptr as *const u8, size_of::<T>()) {\n            return_errno!(EFAULT, \"the pointer is not outside enclave\");\n        }\n        Ok(())\n    }\n\n    /// Check the untrusted array is outside the enclave\n    pub fn check_array<T>(out_ptr: *const T, count: usize) -> Result<()> {\n        let checked_len = count\n            .checked_mul(size_of::<T>())\n            .ok_or_else(|| errno!(EINVAL, \"the array is too long\"))?;\n        if !sgx_trts::trts::rsgx_raw_is_outside_enclave(out_ptr as *const u8, checked_len) {\n            return_errno!(EFAULT, \"the whole buffer is not outside enclave\");\n        }\n        Ok(())\n    }\n\n    /// Clone a C-string from outside the enclave\n    pub fn clone_cstring_safely(out_ptr: *const c_char) -> Result<CString> {\n        if out_ptr.is_null() {\n            return_errno!(EINVAL, \"NULL address is invalid\");\n        }\n\n        // confirm that at least the fisrt byte of the string is out side of enclave\n        check_ptr(out_ptr)?;\n\n        let cstr = unsafe { CStr::from_ptr(out_ptr) };\n        let cstring = CString::from(cstr);\n        if !sgx_trts::trts::rsgx_raw_is_outside_enclave(\n            out_ptr as *const u8,\n            cstring.as_bytes_with_nul().len(),\n        ) {\n            return_errno!(EFAULT, \"the string is not outside enclave\");\n        }\n        Ok(cstring)\n    }\n\n    /// Clone a C-string array (const char*[]) from outside the enclave\n    ///\n    /// This array must be ended with a NULL pointer.\n    pub fn clone_cstrings_safely(out_ptr: *const *const c_char) -> Result<Vec<CString>> {\n        let mut cstrings = Vec::new();\n        if out_ptr == ptr::null() {\n            return Ok(cstrings);\n        }\n\n        let mut out_ptr = out_ptr;\n        loop {\n            check_ptr(out_ptr)?;\n\n            let cstr_ptr = {\n                let cstr_ptr = unsafe { *out_ptr };\n                if cstr_ptr == ptr::null() {\n                    break;\n                }\n                cstr_ptr\n            };\n            let cstring = clone_cstring_safely(cstr_ptr)?;\n            cstrings.push(cstring);\n\n            out_ptr = unsafe { out_ptr.offset(1) };\n        }\n        Ok(cstrings)\n    }\n}\n"], "filenames": ["src/libos/src/util/mem_util.rs"], "buggy_code_start_loc": [50], "buggy_code_end_loc": [135], "fixing_code_start_loc": [51], "fixing_code_end_loc": [141], "type": "CWE-203", "message": "The pointer-validation logic in util/mem_util.rs in Occlum before 0.26.0 for Intel SGX acts as a confused deputy that allows a local attacker to access unauthorized information via side-channel analysis.", "other": {"cve": {"id": "CVE-2021-44421", "sourceIdentifier": "cve@mitre.org", "published": "2022-03-10T17:44:15.447", "lastModified": "2022-03-15T15:22:28.337", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The pointer-validation logic in util/mem_util.rs in Occlum before 0.26.0 for Intel SGX acts as a confused deputy that allows a local attacker to access unauthorized information via side-channel analysis."}, {"lang": "es", "value": "La l\u00f3gica de comprobaci\u00f3n de punteros en el archivo util/mem_util.rs en Occlum versiones anteriores a 0.26.0 para Intel SGX act\u00faa como una vulnerabilidad de tipo \"confused deputy\" que permite a un atacante local acceder a informaci\u00f3n no autorizada por medio de un an\u00e1lisis de canal lateral"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:occlum_project:occlum:*:*:*:*:*:software_guard_extensions:*:*", "versionEndExcluding": "0.26.0", "matchCriteriaId": "5D98E9BC-3716-4728-A0E9-8B1D69CF6A97"}]}]}], "references": [{"url": "https://github.com/occlum/occlum/blob/821ea843ae21037e6cff5268306d2da1fb131552/src/libos/src/util/mem_util.rs#L130", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/occlum/occlum/blob/821ea843ae21037e6cff5268306d2da1fb131552/src/libos/src/util/mem_util.rs#L51", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/occlum/occlum/commit/36918e42bf6732c4d3996bc99eb013eb6b90b249", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/occlum/occlum/compare/0.25.0...v0.26.0", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/occlum/occlum/commit/36918e42bf6732c4d3996bc99eb013eb6b90b249"}}