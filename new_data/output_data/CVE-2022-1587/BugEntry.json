{"buggy_code": ["Change Log for PCRE2\n--------------------\n\n\nVersion 10.40-RC1 xx-xxx-2021\n-----------------------------\n\n1. Merged patch from @carenas (GitHub #35, 7db87842) to fix pcre2grep incorrect\nhandling of multiple passes.\n\n2. Merged patch from @carenas (GitHub #36, dae47509) to fix portability issue\nin pcre2grep with buffered fseek(stdin).\n\n3. Merged patch from @carenas (GitHub #37, acc520924) to fix tests when -S is\nnot supported.\n\n4. Revert an unintended change in JIT repeat detection.\n\n5. Merged patch from @carenas (GitHub #52, b037bfa1) to fix build on GNU Hurd.\n\n6. Merged documentation and comments patches from @carenas (GitHub #47).\n\n7. Merged patch from @carenas (GitHub #49) to remove obsolete JFriedl test code\nfrom pcre2grep.\n\n8. Merged patch from @carenas (GitHub #48) to fix CMake install issue #46.\n\n9. Merged patch from @carenas (GitHub #53) fixing NULL checks in matching and\nsubstituting.\n\n10. Add null_subject and null_replacement modifiers to pcre2test.\n\n11. Add check for NULL subject to POSIX regexec() function.\n\n12. Add check for NULL replacement to pcre2_substitute().\n\n13. For the subject arguments of pcre2_match(), pcre2_dfa_match(), and\npcre2_substitute(), and the replacement argument of the latter, if the pointer\nis NULL and the length is zero, treat as an empty string. Apparently a number\nof applications treat NULL/0 in this way.\n\n14. Added support for Bidi_Class and a number of binary Unicode properties, \nincluding Bidi_Control. \n\n15. Fix some minor issues raised by clang sanitize.\n\n16. Very minor code speed up for maximizing character property matches.\n\n17. A number of changes to script matching for \\p and \\P:\n\n    (a) Script extensions for a character are now coded as a bitmap instead of\n        a list of script numbers, which should be faster and does not need a\n        loop.\n\n    (b) Added the syntax \\p{script:xxx} and \\p{script_extensions:xxx} (synonyms\n        sc and scx).\n\n    (c) Changed \\p{scriptname} from being the same as \\p{sc:scriptname} to being\n        the same as \\p{scx:scriptname} because this change happened in Perl at\n        release 5.26.\n        \n    (d) The standard Unicode 4-letter abbreviations for script names are now \n        recognized.\n        \n    (e) In accordance with Unicode and Perl's \"loose matching\" rules, spaces,\n        hyphens, and underscores are ignored in property names, which are then \n        matched independent of case. \n\n18. The Python scripts in the maint directory have been refactored. There are\nnow three scripts that generate pcre2_ucd.c, pcre2_ucp.h, and pcre2_ucptables.c\n(which is #included by pcre2_tables.c). The data lists that used to be\nduplicated are now held in a single common Python module.\n\n19. On CHERI, and thus Arm's Morello prototype, pointers are represented as\nhardware capabilities, which consist of both an integer address and additional\nmetadata, meaning they are twice the size of the platform's size_t type, i.e.\n16 bytes on a 64-bit system. The ovector member of heapframe happens to only be\n8 byte aligned, and so computing frame_size ended up with a multiple of 8 but\nnot 16. Whilst the first frame was always suitably aligned, this then\nmisaligned the frame that follows, resulting in an alignment fault when storing\na pointer to Fecode at the start of match. Patch to fix this issue by Jessica\nClarke PR#72.\n\n20. Added -LP and -LS listing options to pcre2test.\n\n21. A user discovered that the library names in CMakeLists.txt for MSVC \ndebugger (PDB) files were incorrect - perhaps never tried for PCRE2?\n\n22. An item such as [Aa] is optimized into a caseless single character match.\nWhen this was quantified (e.g. [Aa]{2}) and was also the last literal item in a\npattern, the optimizing \"must be present for a match\" character check was not\nbeing flagged as caseless, causing some matches that should have succeeded to\nfail.\n\n23. Fixed a unicode properrty matching issue in JIT. The character was not\nfully read in caseless matching.\n\n\nVersion 10.39 29-October-2021\n-----------------------------\n\n1. Fix incorrect detection of alternatives in first character search in JIT.\n\n2. Merged patch from @carenas (GitHub #28):\n\n  Visual Studio 2013 includes support for %zu and %td, so let newer\n  versions of it avoid the fallback, and while at it, make sure that\n  the first check is for DISABLE_PERCENT_ZT so it will be always\n  honoured if chosen.\n\n  prtdiff_t is signed, so use a signed type instead, and make sure\n  that an appropiate width is chosen if pointers are 64bit wide and\n  long is not (ex: Windows 64bit).\n\n  IMHO removing the cast (and therefore the positibilty of truncation)\n  make the code cleaner and the fallback is likely portable enough\n  with all 64-bit POSIX systems doing LP64 except for Windows.\n\n3. Merged patch from @carenas (GitHub #29) to update to Unicode 14.0.0.\n\n4. Merged patch from @carenas (GitHub #30):\n\n  * Cleanup: remove references to no longer used stdint.h\n\n  Since 19c50b9d (Unconditionally use inttypes.h instead of trying for stdint.h\n  (simplification) and remove the now unnecessary inclusion in\n  pcre2_internal.h., 2018-11-14), stdint.h is no longer used.\n\n  Remove checks for it in autotools and CMake and document better the expected\n  build failures for systems that might have stdint.h (C99) and not inttypes.h\n  (from POSIX), like old Windows.\n\n  * Cleanup: remove detection for inttypes.h which is a hard dependency\n\n  CMake checks for standard headers are not meant to be used for hard\n  dependencies, so will prevent a possible fallback to work.\n\n  Alternatively, the header could be checked to make the configuration fail\n  instead of breaking the build, but that was punted, as it was missing anyway\n  from autotools.\n\n5. Merged patch from @carenas (GitHub #32):\n\n  * jit: allow building with ancient MSVC versions\n\n  Visual Studio older than 2013 fails to build with JIT enabled, because it is\n  unable to parse non C89 compatible syntax, with mixed declarations and code.\n  While most recent compilers wouldn't even report this as a warning since it\n  is valid C99, it could be also made visible by adding to gcc/clang the\n  -Wdeclaration-after-statement flag at build time.\n\n  Move the code below the affected definitions.\n\n  * pcre2grep: avoid mixing declarations with code\n\n  Since d5a61ee8 (Patch to detect (and ignore) symlink loops in pcre2grep,\n  2021-08-28), code will fail to build in a strict C89 compiler.\n\n  Reformat slightly to make it C89 compatible again.\n\n\nVersion 10.38 01-October-2021\n-----------------------------\n\n1. Fix invalid single character repetition issues in JIT when the repetition\nis inside a capturing bracket and the bracket is preceeded by character\nliterals.\n\n2. Installed revised CMake configuration files provided by Jan-Willem Blokland.\nThis extends the CMake build system to build both static and shared libraries\nin one go, builds the static library with PIC, and exposes PCRE2 libraries\nusing the CMake config files. JWB provided these notes:\n\n- Introduced CMake variable BUILD_STATIC_LIBS to build the static library.\n\n- Make a small modification to config-cmake.h.in by removing the PCRE2_STATIC\n  variable. Added PCRE2_STATIC variable to the static build using the\n  target_compile_definitions() function.\n\n- Extended the CMake config files.\n\n  - Introduced CMake variable PCRE2_USE_STATIC_LIBS to easily switch between\n    the static and shared libraries.\n\n  - Added the PCRE_STATIC variable to the target compile definitions for the\n    import of the static library.\n\nBuilding static and shared libraries using MSVC results in a name clash of\nthe libraries. Both static and shared library builds create, for example, the\nfile pcre2-8.lib. Therefore, I decided to change the static library names by\nadding \"-static\". For example, pcre2-8.lib has become pcre2-8-static.lib.\n[Comment by PH: this is MSVC-specific. It doesn't happen on Linux.]\n\n3. Increased the minimum release number for CMake to 3.0.0 because older than\n2.8.12 is deprecated (it was set to 2.8.5) and causes warnings. Even 3.0.0 is\nquite old; it was released in 2014.\n\n4. Implemented a modified version of Thomas Tempelmann's pcre2grep patch for\ndetecting symlink loops. This is dependent on the availability of realpath(),\nwhich is now tested for in ./configure and CMakeLists.txt.\n\n5. Implemented a modified version of Thomas Tempelmann's patch for faster\ncase-independent \"first code unit\" searches for unanchored patterns in 8-bit\nmode in the interpreters. Instead of just remembering whether one case matched\nor not, it remembers the position of a previous match so as to avoid\nunnecessary repeated searching.\n\n6. Perl now locks out \\K in lookarounds, so PCRE2 now does the same by default.\nHowever, just in case anybody was relying on the old behaviour, there is an\noption called PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK that enables the old behaviour.\nAn option has also been added to pcre2grep to enable this.\n\n7. Re-enable a JIT optimization which was unintentionally disabled in 10.35.\n\n8. There is a loop counter to catch excessively crazy patterns when checking\nthe lengths of lookbehinds at compile time. This was incorrectly getting reset\nwhenever a lookahead was processed, leading to some fuzzer-generated patterns\ntaking a very long time to compile when (?|) was present in the pattern,\nbecause (?|) disables caching of group lengths.\n\n\nVersion 10.37 26-May-2021\n-------------------------\n\n1. Change RunGrepTest to use tr instead of sed when testing with binary\nzero bytes, because sed varies a lot from system to system and has problems\nwith binary zeros. This is from Bugzilla #2681. Patch from Jeremie\nCourreges-Anglas via Nam Nguyen. This fixes RunGrepTest for OpenBSD. Later:\nit broke it for at least one version of Solaris, where tr can't handle binary\nzeros. However, that system had /usr/xpg4/bin/tr installed, which works OK, so\nRunGrepTest now checks for that command and uses it if found.\n\n2. Compiling with gcc 10.2's -fanalyzer option showed up a hypothetical problem\nwith a NULL dereference. I don't think this case could ever occur in practice,\nbut I have put in a check in order to get rid of the compiler error.\n\n3. An alternative patch for CMakeLists.txt because 10.36 #4 breaks CMake on\nWindows. Patch from email@cs-ware.de fixes bugzilla #2688.\n\n4. Two bugs related to over-large numbers have been fixed so the behaviour is\nnow the same as Perl.\n\n  (a) A pattern such as /\\214748364/ gave an overflow error instead of being\n  treated as the octal number \\214 followed by literal digits.\n\n  (b) A sequence such as {65536 that has no terminating } so is not a\n  quantifier was nevertheless complaining that a quantifier number was too big.\n\n5. A run of autoconf suggested that configure.ac was out-of-date with respect\nto the lastest autoconf. Running autoupdate made some valid changes, some valid\nsuggestions, and also some invalid changes, which were fixed by hand. Autoconf\nnow runs clean and the resulting \"configure\" seems to work, so I hope nothing\nis broken. Later: the requirement for autoconf 2.70 broke some automatic test\nrobots. It doesn't seem to be necessary: trying a reduction to 2.60.\n\n6. The pattern /a\\K.(?0)*/ when matched against \"abac\" by the interpreter gave\nthe answer \"bac\", whereas Perl and JIT both yield \"c\". This was because the\neffect of \\K was not propagating back from the full pattern recursion. Other\nrecursions such as /(a\\K.(?1)*)/ did not have this problem.\n\n7. Restore single character repetition optimization in JIT. Currently fewer\ncharacter repetitions are optimized than in 10.34.\n\n8. When the names of the functions in the POSIX wrapper were changed to\npcre2_regcomp() etc. (see change 10.33 #4 below), functions with the original\nnames were left in the library so that pre-compiled programs would still work.\nHowever, this has proved troublesome when programs link with several libraries,\nsome of which use PCRE2 via the POSIX interface while others use a native POSIX\nlibrary. For this reason, the POSIX function names are removed in this release.\nThe macros in pcre2posix.h should ensure that re-compiling fixes any programs\nthat haven't been compiled since before 10.33.\n\n\nVersion 10.36 04-December-2020\n------------------------------\n\n1. Add CET_CFLAGS so that when Intel CET is enabled, pass -mshstk to\ncompiler. This fixes https://bugs.exim.org/show_bug.cgi?id=2578. Patch for\nMakefile.am and configure.ac by H.J. Lu. Equivalent patch for CMakeLists.txt\ninvented by PH.\n\n2. Fix inifinite loop when a single byte newline is searched in JIT when\ninvalid utf8 mode is enabled.\n\n3. Updated CMakeLists.txt with patch from Wolfgang St\u00f6ggl (Bugzilla #2584):\n\n  - Include GNUInstallDirs and use ${CMAKE_INSTALL_LIBDIR} instead of hardcoded\n    lib. This allows differentiation between lib and lib64.\n    CMAKE_INSTALL_LIBDIR is used for installation of libraries and also for\n    pkgconfig file generation.\n\n  - Add the version of PCRE2 to the configuration summary like ./configure\n    does.\n\n  - Fix typo: MACTHED_STRING->MATCHED_STRING\n\n4. Updated CMakeLists.txt with another patch from Wolfgang St\u00f6ggl (Bugzilla\n#2588):\n\n  - Add escaped double quotes around include directory in CMakeLists.txt to\n    allow spaces in directory names.\n\n  - This fixes a cmake error, if the path of the pcre2 source contains a space.\n\n5. Updated CMakeLists.txt with a patch from B. Scott Michel: CMake's\ndocumentation suggests using CHECK_SYMBOL_EXISTS over CHECK_FUNCTION_EXIST.\nMoreover, these functions come from specific header files, which need to be\nspecified (and, thankfully, are the same on both the Linux and WinXX\nplatforms.)\n\n6. Added a (uint32_t) cast to prevent a compiler warning in pcre2_compile.c.\n\n7. Applied a patch from Wolfgang St\u00f6ggl (Bugzilla #2600) to fix postfix for\ndebug Windows builds using CMake. This also updated configure so that it\ngenerates *.pc files and pcre2-config with the same content, as in the past.\n\n8. If a pattern ended with (?(VERSION=n.d where n is any number but d is just a\nsingle digit, the code unit beyond d was being read (i.e. there was a read\nbuffer overflow). Fixes ClusterFuzz 23779.\n\n9. After the rework in r1235, certain character ranges were incorrectly\nhandled by an optimization in JIT. Furthermore a wrong offset was used to\nread a value from a buffer which could lead to memory overread.\n\n10. Unnoticed for many years was the fact that delimiters other than / in the\ntestinput1 and testinput4 files could cause incorrect behaviour when these\nfiles were processed by perltest.sh. There were several tests that used quotes\nas delimiters, and it was just luck that they didn't go wrong with perltest.sh.\nAll the patterns in testinput1 and testinput4 now use / as their delimiter.\nThis fixes Bugzilla #2641.\n\n11. Perl has started to give an error for \\K within lookarounds (though there\nare cases where it doesn't). PCRE2 still allows this, so the tests that include\nthis case have been moved from test 1 to test 2.\n\n12. Further to 10 above, pcre2test has been updated to detect and grumble if a\ndelimiter other than / is used after #perltest.\n\n13. Fixed a bug with PCRE2_MATCH_INVALID_UTF in 8-bit mode when PCRE2_CASELESS\nwas set and PCRE2_NO_START_OPTIMIZE was not set. The optimization for finding\nthe start of a match was not resetting correctly after a failed match on the\nfirst valid fragment of the subject, possibly causing incorrect \"no match\"\nreturns on subsequent fragments. For example, the pattern /A/ failed to match\nthe subject \\xe5A. Fixes Bugzilla #2642.\n\n14. Fixed a bug in character set matching when JIT is enabled and both unicode\nscripts and unicode classes are present at the same time.\n\n15. Added GNU grep's -m (aka --max-count) option to pcre2grep.\n\n16. Refactored substitution processing in pcre2grep strings, both for the -O\noption and when dealing with callouts. There is now a single function that\nhandles $ expansion in all cases (instead of multiple copies of almost\nidentical code). This means that the same escape sequences are available\neverywhere, which was not previously the case. At the same time, the escape\nsequences $x{...} and $o{...} have been introduced, to allow for characters\nwhose code points are greater than 255 in Unicode mode.\n\n17. Applied the patch from Bugzilla #2628 to RunGrepTest. This does an explicit\ntest for a version of sed that can handle binary zero, instead of assuming that\nany Linux version will work. Later: replaced $(...) by `...` because not all\nshells recognize the former.\n\n18. Fixed a word boundary check bug in JIT when partial matching is enabled.\n\n19. Fix ARM64 compilation warning in JIT. Patch by Carlo.\n\n20. A bug in the RunTest script meant that if the first part of test 2 failed,\nthe failure was not reported.\n\n21. Test 2 was failing when run from a directory other than the source\ndirectory. This failure was previously missed in RunTest because of 20 above.\nFixes added to both RunTest and RunTest.bat.\n\n22. Patch to CMakeLists.txt from Daniel to fix problem with testing under\nWindows.\n\n\nVersion 10.35 09-May-2020\n---------------------------\n\n1. Use PCRE2_MATCH_EMPTY flag to detect empty matches in JIT.\n\n2. Fix ARMv5 JIT improper handling of labels right after a constant pool.\n\n3. A JIT bug is fixed which allowed to read the fields of the compiled\npattern before its existence is checked.\n\n4. Back in the PCRE1 day, capturing groups that contained recursive back\nreferences to themselves were made atomic (version 8.01, change 18) because\nafter the end a repeated group, the captured substrings had their values from\nthe final repetition, not from an earlier repetition that might be the\ndestination of a backtrack. This feature was documented, and was carried over\ninto PCRE2. However, it has now been realized that the major refactoring that\nwas done for 10.30 has made this atomicizing unnecessary, and it is confusing\nwhen users are unaware of it, making some patterns appear not to be working as\nexpected. Capture values of recursive back references in repeated groups are\nnow correctly backtracked, so this unnecessary restriction has been removed.\n\n5. Added PCRE2_SUBSTITUTE_LITERAL.\n\n6. Avoid some VS compiler warnings.\n\n7. Added PCRE2_SUBSTITUTE_MATCHED.\n\n8. Added (?* and (?<* as synonms for (*napla: and (*naplb: to match another\nregex engine. The Perl regex folks are aware of this usage and have made a note\nabout it.\n\n9. When an assertion is repeated, PCRE2 used to limit the maximum repetition to\n1, believing that repeating an assertion is pointless. However, if a positive\nassertion contains capturing groups, repetition can be useful. In any case, an\nassertion could always be wrapped in a repeated group. The only restriction\nthat is now imposed is that an unlimited maximum is changed to one more than\nthe minimum.\n\n10. Fix *THEN verbs in lookahead assertions in JIT.\n\n11. Added PCRE2_SUBSTITUTE_REPLACEMENT_ONLY.\n\n12. The JIT stack should be freed when the low-level stack allocation fails.\n\n13. In pcre2grep, if the final line in a scanned file is output but does not\nend with a newline sequence, add a newline according to the --newline setting.\n\n14. (?(DEFINE)...) groups were not being handled correctly when checking for\nthe fixed length of a lookbehind assertion. Such a group within a lookbehind\nshould be skipped, as it does not contribute to the length of the group.\nInstead, the (DEFINE) group was being processed, and if at the end of the\nlookbehind, that end was not correctly recognized. Errors such as \"lookbehind\nassertion is not fixed length\" and also \"internal error: bad code value in\nparsed_skip()\" could result.\n\n15. Put a limit of 1000 on recursive calls in pcre2_study() when searching\nnested groups for starting code units, in order to avoid stack overflow issues.\nIf the limit is reached, it just gives up trying for this optimization.\n\n16. The control verb chain list must always be restored when exiting from a\nrecurse function in JIT.\n\n17. Fix a crash which occurs when the character type of an invalid UTF\ncharacter is decoded in JIT.\n\n18. Changes in many areas of the code so that when Unicode is supported and\nPCRE2_UCP is set without PCRE2_UTF, Unicode character properties are used for\nupper/lower case computations on characters whose code points are greater than\n127.\n\n19. The function for checking UTF-16 validity was returning an incorrect offset\nfor the start of the error when a high surrogate was not followed by a valid\nlow surrogate. This caused incorrect behaviour, for example when\nPCRE2_MATCH_INVALID_UTF was set and a match started immediately following the\ninvalid high surrogate, such as /aa/ matching \"\\x{d800}aa\".\n\n20. If a DEFINE group immediately preceded a lookbehind assertion, the pattern\ncould be mis-compiled and therefore not match correctly. This is the example\nthat found this: /(?(DEFINE)(?<foo>bar))(?<![-a-z0-9])word/ which failed to\nmatch \"word\" because the \"move back\" value was set to zero.\n\n21. Following a request from a user, some extensions and tidies to the\ncharacter tables handling have been done:\n\n  (a) The dftables auxiliary program is renamed pcre2_dftables, but it is still\n  not installed for public use.\n\n  (b) There is now a -b option for pcre2_dftables, which causes the tables to\n  be written in binary. There is also a -help option.\n\n  (c) PCRE2_CONFIG_TABLES_LENGTH is added to pcre2_config() so that an\n  application that wants to save tables in binary knows how long they are.\n\n22. Changed setting of CMAKE_MODULE_PATH in CMakeLists.txt from SET to\nLIST(APPEND...) to allow a setting from the command line to be included.\n\n23. Updated to Unicode 13.0.0.\n\n24. CMake build now checks for secure_getenv() and strerror(). Patch by Carlo.\n\n25. Avoid using [-1] as a suffix in pcre2test because it can provoke a compiler\nwarning.\n\n26. Added tests for __attribute__((uninitialized)) to both the configure and\nCMake build files, and then applied this attribute to the variable called\nstack_frames_vector[] in pcre2_match(). When implemented, this disables\nautomatic initialization (a facility in clang), which can take time on big\nvariables.\n\n27. Updated CMakeLists.txt (patches by Uwe Korn) to add support for\npcre2-config, the libpcre*.pc files, SOVERSION, VERSION and the\nMACHO_*_VERSIONS settings for CMake builds.\n\n28. Another patch to CMakeLists.txt to check for mkostemp (configure already\ndoes). Patch by Carlo Marcelo Arenas Belon.\n\n29. Check for the existence of memfd_create in both CMake and configure\nconfigurations. Patch by Carlo Marcelo Arenas Belon.\n\n30. Restrict the configuration setting for the SELinux compatible execmem\nallocator (change 10.30/44) to Linux and NetBSD.\n\n\nVersion 10.34 21-November-2019\n------------------------------\n\n1. The maximum number of capturing subpatterns is 65535 (documented), but no\ncheck on this was ever implemented. This omission has been rectified; it fixes\nClusterFuzz 14376.\n\n2. Improved the invalid utf32 support of the JIT compiler. Now it correctly\ndetects invalid characters in the 0xd800-0xdfff range.\n\n3. Fix minor typo bug in JIT compile when \\X is used in a non-UTF string.\n\n4. Add support for matching in invalid UTF strings to the pcre2_match()\ninterpreter, and integrate with the existing JIT support via the new\nPCRE2_MATCH_INVALID_UTF compile-time option.\n\n5. Give more error detail for invalid UTF-8 when detected in pcre2grep.\n\n6. Add support for invalid UTF-8 to pcre2grep.\n\n7. Adjust the limit for \"must have\" code unit searching, in particular,\nincrease it substantially for non-anchored patterns.\n\n8. Allow (*ACCEPT) to be quantified, because an ungreedy quantifier with a zero\nminimum is potentially useful.\n\n9. Some changes to the way the minimum subject length is handled:\n\n   * When PCRE2_NO_START_OPTIMIZE is set, no minimum length is computed;\n     pcre2test now omits this item instead of showing a value of zero.\n\n   * An incorrect minimum length could be calculated for a pattern that\n     contained (*ACCEPT) inside a qualified group whose minimum repetition was\n     zero, for example /A(?:(*ACCEPT))?B/, which incorrectly computed a minimum\n     of 2. The minimum length scan no longer happens for a pattern that\n     contains (*ACCEPT).\n\n   * When no minimum length is set by the normal scan, but a first and/or last\n     code unit is recorded, set the minimum to 1 or 2 as appropriate.\n\n   * When a pattern contains multiple groups with the same number, a back\n     reference cannot know which one to scan for a minimum length. This used to\n     cause the minimum length finder to give up with no result. Now it treats\n     such references as not adding to the minimum length (which it should have\n     done all along).\n\n   * Furthermore, the above action now happens only if the back reference is to\n     a group that exists more than once in a pattern instead of any back\n     reference in a pattern with duplicate numbers.\n\n10. A (*MARK) value inside a successful condition was not being returned by the\ninterpretive matcher (it was returned by JIT). This bug has been mended.\n\n11. A bug in pcre2grep meant that -o without an argument (or -o0) didn't work\nif the pattern had more than 32 capturing parentheses. This is fixed. In\naddition (a) the default limit for groups requested by -o<n> has been raised to\n50, (b) the new --om-capture option changes the limit, (c) an error is raised\nif -o asks for a group that is above the limit.\n\n12. The quantifier {1} was always being ignored, but this is incorrect when it\nis made possessive and applied to an item in parentheses, because a\nparenthesized item may contain multiple branches or other backtracking points,\nfor example /(a|ab){1}+c/ or /(a+){1}+a/.\n\n13. For partial matches, pcre2test was always showing the maximum lookbehind\ncharacters, flagged with \"<\", which is misleading when the lookbehind didn't\nactually look behind the start (because it was later in the pattern). Showing\nall consulted preceding characters for partial matches is now controlled by the\nexisting \"allusedtext\" modifier and, as for complete matches, this facility is\navailable only for non-JIT matching, because JIT does not maintain the first\nand last consulted characters.\n\n14. DFA matching (using pcre2_dfa_match()) was not recognising a partial match\nif the end of the subject was encountered in a lookahead (conditional or\notherwise), an atomic group, or a recursion.\n\n15. Give error if pcre2test -t, -T, -tm or -TM is given an argument of zero.\n\n16. Check for integer overflow when computing lookbehind lengths. Fixes\nClusterfuzz issue 15636.\n\n17. Implemented non-atomic positive lookaround assertions.\n\n18. If a lookbehind contained a lookahead that contained another lookbehind\nwithin it, the nested lookbehind was not correctly processed. For example, if\n/(?<=(?=(?<=a)))b/ was matched to \"ab\" it gave no match instead of matching\n\"b\".\n\n19. Implemented pcre2_get_match_data_size().\n\n20. Two alterations to partial matching:\n\n    (a) The definition of a partial match is slightly changed: if a pattern\n    contains any lookbehinds, an empty partial match may be given, because this\n    is another situation where adding characters to the current subject can\n    lead to a full match. Example: /c*+(?<=[bc])/ with subject \"ab\".\n\n    (b) Similarly, if a pattern could match an empty string, an empty partial\n    match may be given. Example: /(?![ab]).*/ with subject \"ab\". This case\n    applies only to PCRE2_PARTIAL_HARD.\n\n    (c) An empty string partial hard match can be returned for \\z and \\Z as it\n    is documented that they shouldn't match.\n\n21. A branch that started with (*ACCEPT) was not being recognized as one that\ncould match an empty string.\n\n22. Corrected pcre2_set_character_tables() tables data type: was const unsigned\nchar * instead of const uint8_t *, as generated by pcre2_maketables().\n\n23. Upgraded to Unicode 12.1.0.\n\n24. Add -jitfast command line option to pcre2test (to make all the jit options\navailable directly).\n\n25. Make pcre2test -C show if libreadline or libedit is supported.\n\n26. If the length of one branch of a group exceeded 65535 (the maximum value\nthat is remembered as a minimum length), the whole group's length was\nincorrectly recorded as 65535, leading to incorrect \"no match\" when start-up\noptimizations were in force.\n\n27. The \"rightmost consulted character\" value was not always correct; in\nparticular, if a pattern ended with a negative lookahead, characters that were\ninspected in that lookahead were not included.\n\n28. Add the pcre2_maketables_free() function.\n\n29. The start-up optimization that looks for a unique initial matching\ncode unit in the interpretive engines uses memchr() in 8-bit mode. When the\nsearch is caseless, it was doing so inefficiently, which ended up slowing down\nthe match drastically when the subject was very long. The revised code (a)\nremembers if one case is not found, so it never repeats the search for that\ncase after a bumpalong and (b) when one case has been found, it searches only\nup to that position for an earlier occurrence of the other case. This fix\napplies to both interpretive pcre2_match() and to pcre2_dfa_match().\n\n30. While scanning to find the minimum length of a group, if any branch has\nminimum length zero, there is no need to scan any subsequent branches (a small\ncompile-time performance improvement).\n\n31. Installed a .gitignore file on a user's suggestion. When using the svn\nrepository with git (through git svn) this helps keep it tidy.\n\n32. Add underflow check in JIT which may occur when the value of subject\nstring pointer is close to 0.\n\n33. Arrange for classes such as [Aa] which contain just the two cases of the\nsame character, to be treated as a single caseless character. This causes the\nfirst and required code unit optimizations to kick in where relevant.\n\n34. Improve the bitmap of starting bytes for positive classes that include wide\ncharacters, but no property types, in UTF-8 mode. Previously, on encountering\nsuch a class, the bits for all bytes greater than \\xc4 were set, thus\nspecifying any character with codepoint >= 0x100. Now the only bits that are\nset are for the relevant bytes that start the wide characters. This can give a\nnoticeable performance improvement.\n\n35. If the bitmap of starting code units contains only 1 or 2 bits, replace it\nwith a single starting code unit (1 bit) or a caseless single starting code\nunit if the two relevant characters are case-partners. This is particularly\nrelevant to the 8-bit library, though it applies to all. It can give a\nperformance boost for patterns such as [Ww]ord and (word|WORD). However, this\noptimization doesn't happen if there is a \"required\" code unit of the same\nvalue (because the search for a \"required\" code unit starts at the match start\nfor non-unique first code unit patterns, but after a unique first code unit,\nand patterns such as a*a need the former action).\n\n36. Small patch to pcre2posix.c to set the erroroffset field to -1 immediately\nafter a successful compile, instead of at the start of matching to avoid a\nsanitizer complaint (regexec is supposed to be thread safe).\n\n37. Add NEON vectorization to JIT to speed up matching of first character and\npairs of characters on ARM64 CPUs.\n\n38. If a non-ASCII character was the first in a starting assertion in a\ncaseless match, the \"first code unit\" optimization did not get the casing\nright, and the assertion failed to match a character in the other case if it\ndid not start with the same code unit.\n\n39. Fixed the incorrect computation of jump sizes on x86 CPUs in JIT. A masking\noperation was incorrectly removed in r1136. Reported by Ralf Junker.\n\n\nVersion 10.33 16-April-2019\n---------------------------\n\n1. Added \"allvector\" to pcre2test to make it easy to check the part of the\novector that shouldn't be changed, in particular after substitute and failed or\npartial matches.\n\n2. Fix subject buffer overread in JIT when UTF is disabled and \\X or \\R has\na greater than 1 fixed quantifier. This issue was found by Yunho Kim.\n\n3. Added support for callouts from pcre2_substitute(). After 10.33-RC1, but\nprior to release, fixed a bug that caused a crash if pcre2_substitute() was\ncalled with a NULL match context.\n\n4. The POSIX functions are now all called pcre2_regcomp() etc., with wrapper\nfunctions that use the standard POSIX names. However, in pcre2posix.h the POSIX\nnames are defined as macros. This should help avoid linking with the wrong\nlibrary in some environments while still exporting the POSIX names for\npre-existing programs that use them. (The Debian alternative names are also\ndefined as macros, but not documented.)\n\n5. Fix an xclass matching issue in JIT.\n\n6. Implement PCRE2_EXTRA_ESCAPED_CR_IS_LF (see Bugzilla 2315).\n\n7. Implement the Perl 5.28 experimental alphabetic names for atomic groups and\nlookaround assertions, for example, (*pla:...) and (*atomic:...). These are\ncharacterized by a lower case letter following (* and to simplify coding for\nthis, the character tables created by pcre2_maketables() were updated to add a\nnew \"is lower case letter\" bit. At the same time, the now unused \"is\nhexadecimal digit\" bit was removed. The default tables in\nsrc/pcre2_chartables.c.dist are updated.\n\n8. Implement the new Perl \"script run\" features (*script_run:...) and\n(*atomic_script_run:...) aka (*sr:...) and (*asr:...).\n\n9. Fixed two typos in change 22 for 10.21, which added special handling for\nranges such as a-z in EBCDIC environments. The original code probably never\nworked, though there were no bug reports.\n\n10. Implement PCRE2_COPY_MATCHED_SUBJECT for pcre2_match() (including JIT via\npcre2_match()) and pcre2_dfa_match(), but *not* the pcre2_jit_match() fast\npath. Also, when a match fails, set the subject field in the match data to NULL\nfor tidiness - none of the substring extractors should reference this after\nmatch failure.\n\n11. If a pattern started with a subroutine call that had a quantifier with a\nminimum of zero, an incorrect \"match must start with this character\" could be\nrecorded. Example: /(?&xxx)*ABC(?<xxx>XYZ)/ would (incorrectly) expect 'A' to\nbe the first character of a match.\n\n12. The heap limit checking code in pcre2_dfa_match() could suffer from\noverflow if the heap limit was set very large. This could cause incorrect \"heap\nlimit exceeded\" errors.\n\n13. Add \"kibibytes\" to the heap limit output from pcre2test -C to make the\nunits clear.\n\n14. Add a call to pcre2_jit_free_unused_memory() in pcre2grep, for tidiness.\n\n15. Updated the VMS-specific code in pcre2test on the advice of a VMS user.\n\n16. Removed the unnecessary inclusion of stdint.h (or inttypes.h) from\npcre2_internal.h as it is now included by pcre2.h. Also, change 17 for 10.32\nbelow was unnecessarily complicated, as inttypes.h is a Standard C header,\nwhich is defined to be a superset of stdint.h. Instead of conditionally\nincluding stdint.h or inttypes.h, pcre2.h now unconditionally includes\ninttypes.h. This supports environments that do not have stdint.h but do have\ninttypes.h, which are known to exist. A note in the autotools documentation\nsays (November 2018) that there are none known that are the other way round.\n\n17. Added --disable-percent-zt to \"configure\" (and equivalent to CMake) to\nforcibly disable the use of %zu and %td in formatting strings because there is\nat least one version of VMS that claims to be C99 but does not support these\nmodifiers.\n\n18. Added --disable-pcre2grep-callout-fork, which restricts the callout support\nin pcre2grep to the inbuilt echo facility. This may be useful in environments\nthat do not support fork().\n\n19. Fix two instances of <= 0 being applied to unsigned integers (the VMS\ncompiler complains).\n\n20. Added \"fork\" support for VMS to pcre2grep, for running an external program\nvia a string callout.\n\n21. Improve MAP_JIT flag usage on MacOS. Patch by Rich Siegel.\n\n22. If a pattern started with (*MARK), (*COMMIT), (*PRUNE), (*SKIP), or (*THEN)\nfollowed by ^ it was not recognized as anchored.\n\n23. The RunGrepTest script used to cut out the test of NUL characters for\nSolaris and MacOS as printf and sed can't handle them. It seems that the *BSD\nsystems can't either. I've inverted the test so that only those OS that are\nknown to work (currently only Linux) try to run this test.\n\n24. Some tests in RunGrepTest appended to testtrygrep from two different file\ndescriptors instead of redirecting stderr to stdout. This worked on Linux, but\nit was reported not to on other systems, causing the tests to fail.\n\n25. In the RunTest script, make the test for stack setting use the same value\nfor the stack as it needs for -bigstack.\n\n26. Insert a cast in pcre2_dfa_match.c to suppress a compiler warning.\n\n26. With PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL set, escape sequences such as \\s\nwhich are valid in character classes, but not as the end of ranges, were being\ntreated as literals. An example is [_-\\s] (but not [\\s-_] because that gave an\nerror at the *start* of a range). Now an \"invalid range\" error is given\nindependently of PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL.\n\n27. Related to 26 above, PCRE2_BAD_ESCAPE_IS_LITERAL was affecting known escape\nsequences such as \\eX when they appeared invalidly in a character class. Now\nthe option applies only to unrecognized or malformed escape sequences.\n\n28. Fix word boundary in JIT compiler. Patch by Mike Munday.\n\n29. The pcre2_dfa_match() function was incorrectly handling conditional version\ntests such as (?(VERSION>=0)...) when the version test was true. Incorrect\nprocessing or a crash could result.\n\n30. When PCRE2_UTF is set, allow non-ASCII letters and decimal digits in group\nnames, as Perl does. There was a small bug in this new code, found by\nClusterFuzz 12950, fixed before release.\n\n31. Implemented PCRE2_EXTRA_ALT_BSUX to support ECMAScript 6's \\u{hhh}\nconstruct.\n\n32. Compile \\p{Any} to be the same as . in DOTALL mode, so that it benefits\nfrom auto-anchoring if \\p{Any}* starts a pattern.\n\n33. Compile invalid UTF check in JIT test when only pcre32 is enabled.\n\n34. For some time now, CMake has been warning about the setting of policy\nCMP0026 to \"OLD\" in CmakeLists.txt, and hinting that the feature might be\nremoved in a future version. A request for CMake expertise on the list produced\nno result, so I have now hacked CMakeLists.txt along the lines of some changes\nI found on the Internet. The new code no longer needs the policy setting, and\nit appears to work fine on Linux.\n\n35. Setting --enable-jit=auto for an out-of-tree build failed because the\nsource directory wasn't in the search path for AC_TRY_COMPILE always. Patch\nfrom Ross Burton.\n\n36. Disable SSE2 JIT optimizations in x86 CPUs when SSE2 is not available.\nPatch by Guillem Jover.\n\n37. Changed expressions such as 1<<10 to 1u<<10 in many places because compiler\nwarnings were reported.\n\n38. Using the clang compiler with sanitizing options causes runtime complaints\nabout truncation for statments such as x = ~x when x is an 8-bit value; it\nseems to compute ~x as a 32-bit value. Changing such statements to x = 255 ^ x\ngets rid of the warnings. There were also two missing casts in pcre2test.\n\n\nVersion 10.32 10-September-2018\n-------------------------------\n\n1. When matching using the the REG_STARTEND feature of the POSIX API with a\nnon-zero starting offset, unset capturing groups with lower numbers than a\ngroup that did capture something were not being correctly returned as \"unset\"\n(that is, with offset values of -1).\n\n2. When matching using the POSIX API, pcre2test used to omit listing unset\ngroups altogether. Now it shows those that come before any actual captures as\n\"<unset>\", as happens for non-POSIX matching.\n\n3. Running \"pcre2test -C\" always stated \"\\R matches CR, LF, or CRLF only\",\nwhatever the build configuration was. It now correctly says \"\\R matches all\nUnicode newlines\" in the default case when --enable-bsr-anycrlf has not been\nspecified. Similarly, running \"pcre2test -C bsr\" never produced the result\nANY.\n\n4. Matching the pattern /(*UTF)\\C[^\\v]+\\x80/ against an 8-bit string containing\nmulti-code-unit characters caused bad behaviour and possibly a crash. This\nissue was fixed for other kinds of repeat in release 10.20 by change 19, but\nrepeating character classes were overlooked.\n\n5. pcre2grep now supports the inclusion of binary zeros in patterns that are\nread from files via the -f option.\n\n6. A small fix to pcre2grep to avoid compiler warnings for -Wformat-overflow=2.\n\n7. Added --enable-jit=auto support to configure.ac.\n\n8. Added some dummy variables to the heapframe structure in 16-bit and 32-bit\nmodes for the benefit of m68k, where pointers can be 16-bit aligned. The\ndummies force 32-bit alignment and this ensures that the structure is a\nmultiple of PCRE2_SIZE, a requirement that is tested at compile time. In other\narchitectures, alignment requirements take care of this automatically.\n\n9. When returning an error from pcre2_pattern_convert(), ensure the error\noffset is set zero for early errors.\n\n10. A number of patches for Windows support from Daniel Richard G:\n\n  (a) List of error numbers in Runtest.bat corrected (it was not the same as in\n      Runtest).\n\n  (b) pcre2grep snprintf() workaround as used elsewhere in the tree.\n\n  (c) Support for non-C99 snprintf() that returns -1 in the overflow case.\n\n11. Minor tidy of pcre2_dfa_match() code.\n\n12. Refactored pcre2_dfa_match() so that the internal recursive calls no longer\nuse the stack for local workspace and local ovectors. Instead, an initial block\nof stack is reserved, but if this is insufficient, heap memory is used. The\nheap limit parameter now applies to pcre2_dfa_match().\n\n13. If a \"find limits\" test of DFA matching in pcre2test resulted in too many\nmatches for the ovector, no matches were displayed.\n\n14. Removed an occurrence of ctrl/Z from test 6 because Windows treats it as\nEOF. The test looks to have come from a fuzzer.\n\n15. If PCRE2 was built with a default match limit a lot greater than the\ndefault default of 10 000 000, some JIT tests of the match limit no longer\nfailed. All such tests now set 10 000 000 as the upper limit.\n\n16. Another Windows related patch for pcregrep to ensure that WIN32 is\nundefined under Cygwin.\n\n17. Test for the presence of stdint.h and inttypes.h in configure and CMake and\ninclude whichever exists (stdint preferred) instead of unconditionally\nincluding stdint. This makes life easier for old and non-standard systems.\n\n18. Further changes to improve portability, especially to old and or non-\nstandard systems:\n\n  (a) Put all printf arguments in RunGrepTest into single, not double, quotes,\n      and use \\0 not \\x00 for binary zero.\n\n  (b) Avoid the use of C++ (i.e. BCPL) // comments.\n\n  (c) Parameterize the use of %zu in pcre2test to make it like %td. For both of\n      these now, if using MSVC or a standard C before C99, %lu is used with a\n      cast if necessary.\n\n19. Applied a contributed patch to CMakeLists.txt to increase the stack size\nwhen linking pcre2test with MSVC. This gets rid of a stack overflow error in\nthe standard set of tests.\n\n20. Output a warning in pcre2test when ignoring the \"altglobal\" modifier when\nit is given with the \"replace\" modifier.\n\n21. In both pcre2test and pcre2_substitute(), with global matching, a pattern\nthat matched an empty string, but never at the starting match offset, was not\nhandled in a Perl-compatible way. The pattern /(<?=\\G.)/ is an example of such\na pattern. Because \\G is in a lookbehind assertion, there has to be a\n\"bumpalong\" before there can be a match. The automatic \"advance by one\ncharacter after an empty string match\" rule is therefore inappropriate. A more\ncomplicated algorithm has now been implemented.\n\n22. When checking to see if a lookbehind is of fixed length, lookaheads were\ncorrectly ignored, but qualifiers on lookaheads were not being ignored, leading\nto an incorrect \"lookbehind assertion is not fixed length\" error.\n\n23. The VERSION condition test was reading fractional PCRE2 version numbers\nsuch as the 04 in 10.04 incorrectly and hence giving wrong results.\n\n24. Updated to Unicode version 11.0.0. As well as the usual addition of new\nscripts and characters, this involved re-jigging the grapheme break property\nalgorithm because Unicode has changed the way emojis are handled.\n\n25. Fixed an obscure bug that struck when there were two atomic groups not\nseparated by something with a backtracking point. There could be an incorrect\nbacktrack into the first of the atomic groups. A complicated example is\n/(?>a(*:1))(?>b)(*SKIP:1)x|.*/ matched against \"abc\", where the *SKIP\nshouldn't find a MARK (because is in an atomic group), but it did.\n\n26. Upgraded the perltest.sh script: (1) #pattern lines can now be used to set\na list of modifiers for all subsequent patterns - only those that the script\nrecognizes are meaningful; (2) #subject lines can be used to set or unset a\ndefault \"mark\" modifier; (3) Unsupported #command lines give a warning when\nthey are ignored; (4) Mark data is output only if the \"mark\" modifier is\npresent.\n\n27. (*ACCEPT:ARG), (*FAIL:ARG), and (*COMMIT:ARG) are now supported.\n\n28. A (*MARK) name was not being passed back for positive assertions that were\nterminated by (*ACCEPT).\n\n29. Add support for \\N{U+dddd}, but only in Unicode mode.\n\n30. Add support for (?^) for unsetting all imnsx options.\n\n31. The PCRE2_EXTENDED (/x) option only ever discarded space characters whose\ncode point was less than 256 and that were recognized by the lookup table\ngenerated by pcre2_maketables(), which uses isspace() to identify white space.\nNow, when Unicode support is compiled, PCRE2_EXTENDED also discards U+0085,\nU+200E, U+200F, U+2028, and U+2029, which are additional characters defined by\nUnicode as \"Pattern White Space\". This makes PCRE2 compatible with Perl.\n\n32. In certain circumstances, option settings within patterns were not being\ncorrectly processed. For example, the pattern /((?i)A)(?m)B/ incorrectly\nmatched \"ab\". (The (?m) setting lost the fact that (?i) should be reset at the\nend of its group during the parse process, but without another setting such as\n(?m) the compile phase got it right.) This bug was introduced by the\nrefactoring in release 10.23.\n\n33. PCRE2 uses bcopy() if available when memmove() is not, and it used just to\ndefine memmove() as function call to bcopy(). This hasn't been tested for a\nlong time because in pcre2test the result of memmove() was being used, whereas\nbcopy() doesn't return a result. This feature is now refactored always to call\nan emulation function when there is no memmove(). The emulation makes use of\nbcopy() when available.\n\n34. When serializing a pattern, set the memctl, executable_jit, and tables\nfields (that is, all the fields that contain pointers) to zeros so that the\nresult of serializing is always the same. These fields are re-set when the\npattern is deserialized.\n\n35. In a pattern such as /[^\\x{100}-\\x{ffff}]*[\\x80-\\xff]/ which has a repeated\nnegative class with no characters less than 0x100 followed by a positive class\nwith only characters less than 0x100, the first class was incorrectly being\nauto-possessified, causing incorrect match failures.\n\n36. Removed the character type bit ctype_meta, which dates from PCRE1 and is\nnot used in PCRE2.\n\n37. Tidied up unnecessarily complicated macros used in the escapes table.\n\n38. Since 10.21, the new testoutput8-16-4 file has accidentally been omitted\nfrom distribution tarballs, owing to a typo in Makefile.am which had\ntestoutput8-16-3 twice. Now fixed.\n\n39. If the only branch in a conditional subpattern was anchored, the whole\nsubpattern was treated as anchored, when it should not have been, since the\nassumed empty second branch cannot be anchored. Demonstrated by test patterns\nsuch as /(?(1)^())b/ or /(?(?=^))b/.\n\n40. A repeated conditional subpattern that could match an empty string was\nalways assumed to be unanchored. Now it it checked just like any other\nrepeated conditional subpattern, and can be found to be anchored if the minimum\nquantifier is one or more. I can't see much use for a repeated anchored\npattern, but the behaviour is now consistent.\n\n41. Minor addition to pcre2_jit_compile.c to avoid static analyzer complaint\n(for an event that could never occur but you had to have external information\nto know that).\n\n42. If before the first match in a file that was being searched by pcre2grep\nthere was a line that was sufficiently long to cause the input buffer to be\nexpanded, the variable holding the location of the end of the previous match\nwas being adjusted incorrectly, and could cause an overflow warning from a code\nsanitizer. However, as the value is used only to print pending \"after\" lines\nwhen the next match is reached (and there are no such lines in this case) this\nbug could do no damage.\n\n\nVersion 10.31 12-February-2018\n------------------------------\n\n1. Fix typo (missing ]) in VMS code in pcre2test.c.\n\n2. Replace the replicated code for matching extended Unicode grapheme sequences\n(which got a lot more complicated by change 10.30/49) by a single subroutine\nthat is called by both pcre2_match() and pcre2_dfa_match().\n\n3. Add idempotent guard to pcre2_internal.h.\n\n4. Add new pcre2_config() options: PCRE2_CONFIG_NEVER_BACKSLASH_C and\nPCRE2_CONFIG_COMPILED_WIDTHS.\n\n5. Cut out \\C tests in the JIT regression tests when NEVER_BACKSLASH_C is\ndefined (e.g. by --enable-never-backslash-C).\n\n6. Defined public names for all the pcre2_compile() error numbers, and used\nthe public names in pcre2_convert.c.\n\n7. Fixed a small memory leak in pcre2test (convert contexts).\n\n8. Added two casts to compile.c and one to match.c to avoid compiler warnings.\n\n9. Added code to pcre2grep when compiled under VMS to set the symbol\nPCRE2GREP_RC to the exit status, because VMS does not distinguish between\nexit(0) and exit(1).\n\n10. Added the -LM (list modifiers) option to pcre2test. Also made -C complain\nabout a bad option only if the following argument item does not start with a\nhyphen.\n\n11. pcre2grep was truncating components of file names to 128 characters when\nprocessing files with the -r option, and also (some very odd code) truncating\npath names to 512 characters. There is now a check on the absolute length of\nfull path file names, which may be up to 2047 characters long.\n\n12. When an assertion contained (*ACCEPT) it caused all open capturing groups\nto be closed (as for a non-assertion ACCEPT), which was wrong and could lead to\nmisbehaviour for subsequent references to groups that started outside the\nassertion. ACCEPT in an assertion now closes only those groups that were\nstarted within that assertion. Fixes oss-fuzz issues 3852 and 3891.\n\n13. Multiline matching in pcre2grep was misbehaving if the pattern matched\nwithin a line, and then matched again at the end of the line and over into\nsubsequent lines. Behaviour was different with and without colouring, and\nsometimes context lines were incorrectly printed and/or line endings were lost.\nAll these issues should now be fixed.\n\n14. If --line-buffered was specified for pcre2grep when input was from a\ncompressed file (.gz or .bz2) a segfault occurred. (Line buffering should be\nignored for compressed files.)\n\n15. Although pcre2_jit_match checks whether the pattern is compiled\nin a given mode, it was also expected that at least one mode is available.\nThis is fixed and pcre2_jit_match returns with PCRE2_ERROR_JIT_BADOPTION\nwhen the pattern is not optimized by JIT at all.\n\n16. The line number and related variables such as match counts in pcre2grep\nwere all int variables, causing overflow when files with more than 2147483647\nlines were processed (assuming 32-bit ints). They have all been changed to\nunsigned long ints.\n\n17. If a backreference with a minimum repeat count of zero was first in a\npattern, apart from assertions, an incorrect first matching character could be\nrecorded. For example, for the pattern /(?=(a))\\1?b/, \"b\" was incorrectly set\nas the first character of a match.\n\n18. Characters in a leading positive assertion are considered for recording a\nfirst character of a match when the rest of the pattern does not provide one.\nHowever, a character in a non-assertive group within a leading assertion such\nas in the pattern /(?=(a))\\1?b/ caused this process to fail. This was an\ninfelicity rather than an outright bug, because it did not affect the result of\na match, just its speed. (In fact, in this case, the starting 'a' was\nsubsequently picked up in the study.)\n\n19. A minor tidy in pcre2_match(): making all PCRE2_ERROR_ returns use \"return\"\ninstead of \"RRETURN\" saves unwinding the backtracks in these cases (only one\ndidn't).\n\n20. Allocate a single callout block on the stack at the start of pcre2_match()\nand set its never-changing fields once only. Do the same for pcre2_dfa_match().\n\n21. Save the extra compile options (set in the compile context) with the\ncompiled pattern (they were not previously saved), add PCRE2_INFO_EXTRAOPTIONS\nto retrieve them, and update pcre2test to show them.\n\n22. Added PCRE2_CALLOUT_STARTMATCH and PCRE2_CALLOUT_BACKTRACK bits to a new\nfield callout_flags in callout blocks. The bits are set by pcre2_match(), but\nnot by JIT or pcre2_dfa_match(). Their settings are shown in pcre2test callouts\nif the callout_extra subject modifier is set. These bits are provided to help\nwith tracking how a backtracking match is proceeding.\n\n23. Updated the pcre2demo.c demonstration program, which was missing the extra\ncode for -g that handles the case when \\K in an assertion causes the match to\nend at the original start point. Also arranged for it to detect when \\K causes\nthe end of a match to be before its start.\n\n24. Similar to 23 above, strange things (including loops) could happen in\npcre2grep when \\K was used in an assertion when --colour was used or in\nmultiline mode. The \"end at original start point\" bug is fixed, and if the end\npoint is found to be before the start point, they are swapped.\n\n25. When PCRE2_FIRSTLINE without PCRE2_NO_START_OPTIMIZE was used in non-JIT\nmatching (both pcre2_match() and pcre2_dfa_match()) and the matched string\nstarted with the first code unit of a newline sequence, matching failed because\nit was not tried at the newline.\n\n26. Code for giving up a non-partial match after failing to find a starting\ncode unit anywhere in the subject was missing when searching for one of a\nnumber of code units (the bitmap case) in both pcre2_match() and\npcre2_dfa_match(). This was a missing optimization rather than a bug.\n\n27. Tidied up the ACROSSCHAR macro to be like FORWARDCHAR and BACKCHAR, using a\npointer argument rather than a code unit value. This should not have affected\nthe generated code.\n\n28. The JIT compiler has been updated.\n\n29. Avoid pointer overflow for unset captures in pcre2_substring_list_get().\nThis could not actually cause a crash because it was always used in a memcpy()\ncall with zero length.\n\n30. Some internal structures have a variable-length ovector[] as their last\nelement. Their actual memory is obtained dynamically, giving an ovector of\nappropriate length. However, they are defined in the structure as\novector[NUMBER], where NUMBER is large so that array bound checkers don't\ngrumble. The value of NUMBER was 10000, but a fuzzer exceeded 5000 capturing\ngroups, making the ovector larger than this. The number has been increased to\n131072, which allows for the maximum number of captures (65535) plus the\noverall match. This fixes oss-fuzz issue 5415.\n\n31. Auto-possessification at the end of a capturing group was dependent on what\nfollows the group (e.g. /(a+)b/ would auto-possessify the a+) but this caused\nincorrect behaviour when the group was called recursively from elsewhere in the\npattern where something different might follow. This bug is an unforseen\nconsequence of change #1 for 10.30 - the implementation of backtracking into\nrecursions. Iterators at the ends of capturing groups are no longer considered\nfor auto-possessification if the pattern contains any recursions. Fixes\nBugzilla #2232.\n\n\nVersion 10.30 14-August-2017\n----------------------------\n\n1. The main interpreter, pcre2_match(), has been refactored into a new version\nthat does not use recursive function calls (and therefore the stack) for\nremembering backtracking positions. This makes --disable-stack-for-recursion a\nNOOP. The new implementation allows backtracking into recursive group calls in\npatterns, making it more compatible with Perl, and also fixes some other\nhard-to-do issues such as #1887 in Bugzilla. The code is also cleaner because\nthe old code had a number of fudges to try to reduce stack usage. It seems to\nrun no slower than the old code.\n\nA number of bugs in the refactored code were subsequently fixed during testing\nbefore release, but after the code was made available in the repository. These\nbugs were never in fully released code, but are noted here for the record.\n\n  (a) If a pattern had fewer capturing parentheses than the ovector supplied in\n      the match data block, a memory error (detectable by ASAN) occurred after\n      a match, because the external block was being set from non-existent\n      internal ovector fields. Fixes oss-fuzz issue 781.\n\n  (b) A pattern with very many capturing parentheses (when the internal frame\n      size was greater than the initial frame vector on the stack) caused a\n      crash. A vector on the heap is now set up at the start of matching if the\n      vector on the stack is not big enough to handle at least 10 frames.\n      Fixes oss-fuzz issue 783.\n\n  (c) Handling of (*VERB)s in recursions was wrong in some cases.\n\n  (d) Captures in negative assertions that were used as conditions were not\n      happening if the assertion matched via (*ACCEPT).\n\n  (e) Mark values were not being passed out of recursions.\n\n  (f) Refactor some code in do_callout() to avoid picky compiler warnings about\n      negative indices. Fixes oss-fuzz issue 1454.\n\n  (g) Similarly refactor the way the variable length ovector is addressed for\n      similar reasons. Fixes oss-fuzz issue 1465.\n\n2. Now that pcre2_match() no longer uses recursive function calls (see above),\nthe \"match limit recursion\" value seems misnamed. It still exists, and limits\nthe depth of tree that is searched. To avoid future confusion, it has been\nrenamed as \"depth limit\" in all relevant places (--with-depth-limit,\n(*LIMIT_DEPTH), pcre2_set_depth_limit(), etc) but the old names are still\navailable for backwards compatibility.\n\n3. Hardened pcre2test so as to reduce the number of bugs reported by fuzzers:\n\n  (a) Check for malloc failures when getting memory for the ovector (POSIX) or\n      the match data block (non-POSIX).\n\n4. In the 32-bit library in non-UTF mode, an attempt to find a Unicode property\nfor a character with a code point greater than 0x10ffff (the Unicode maximum)\ncaused a crash.\n\n5. If a lookbehind assertion that contained a back reference to a group\nappearing later in the pattern was compiled with the PCRE2_ANCHORED option,\nundefined actions (often a segmentation fault) could occur, depending on what\nother options were set. An example assertion is (?<!\\1(abc)) where the\nreference \\1 precedes the group (abc). This fixes oss-fuzz issue 865.\n\n6. Added the PCRE2_INFO_FRAMESIZE item to pcre2_pattern_info() and arranged for\npcre2test to use it to output the frame size when the \"framesize\" modifier is\ngiven.\n\n7. Reworked the recursive pattern matching in the JIT compiler to follow the\ninterpreter changes.\n\n8. When the zero_terminate modifier was specified on a pcre2test subject line\nfor global matching, unpredictable things could happen. For example, in UTF-8\nmode, the pattern //g,zero_terminate read random memory when matched against an\nempty string with zero_terminate. This was a bug in pcre2test, not the library.\n\n9. Moved some Windows-specific code in pcre2grep (introduced in 10.23/13) out\nof the section that is compiled when Unix-style directory scanning is\navailable, and into a new section that is always compiled for Windows.\n\n10. In pcre2test, explicitly close the file after an error during serialization\nor deserialization (the \"load\" or \"save\" commands).\n\n11. Fix memory leak in pcre2_serialize_decode() when the input is invalid.\n\n12. Fix potential NULL dereference in pcre2_callout_enumerate() if called with\na NULL pattern pointer when Unicode support is available.\n\n13. When the 32-bit library was being tested by pcre2test, error messages that\nwere longer than 64 code units could cause a buffer overflow. This was a bug in\npcre2test.\n\n14. The alternative matching function, pcre2_dfa_match() misbehaved if it\nencountered a character class with a possessive repeat, for example [a-f]{3}+.\n\n15. The depth (formerly recursion) limit now applies to DFA matching (as\nof 10.23/36); pcre2test has been upgraded so that \\=find_limits works with DFA\nmatching to find the minimum value for this limit.\n\n16. Since 10.21, if pcre2_match() was called with a null context, default\nmemory allocation functions were used instead of whatever was used when the\npattern was compiled.\n\n17. Changes to the pcre2test \"memory\" modifier on a subject line. These apply\nonly to pcre2_match():\n\n  (a) Warn if null_context is set on both pattern and subject, because the\n      memory details cannot then be shown.\n\n  (b) Remember (up to a certain number of) memory allocations and their\n      lengths, and list only the lengths, so as to be system-independent.\n      (In practice, the new interpreter never has more than 2 blocks allocated\n      simultaneously.)\n\n18. Make pcre2test detect an error return from pcre2_get_error_message(), give\na message, and abandon the run (this would have detected #13 above).\n\n19. Implemented PCRE2_ENDANCHORED.\n\n20. Applied Jason Hood's patches (slightly modified) to pcre2grep, to implement\nthe --output=text (-O) option and the inbuilt callout echo.\n\n21. Extend auto-anchoring etc. to ignore groups with a zero qualifier and\nsingle-branch conditions with a false condition (e.g. DEFINE) at the start of a\nbranch. For example, /(?(DEFINE)...)^A/ and /(...){0}^B/ are now flagged as\nanchored.\n\n22. Added an explicit limit on the amount of heap used by pcre2_match(), set by\npcre2_set_heap_limit() or (*LIMIT_HEAP=xxx). Upgraded pcre2test to show the\nheap limit along with other pattern information, and to find the minimum when\nthe find_limits modifier is set.\n\n23. Write to the last 8 bytes of the pcre2_real_code structure when a compiled\npattern is set up so as to initialize any padding the compiler might have\nincluded. This avoids valgrind warnings when a compiled pattern is copied, in\nparticular when it is serialized.\n\n24. Remove a redundant line of code left in accidentally a long time ago.\n\n25. Remove a duplication typo in pcre2_tables.c\n\n26. Correct an incorrect cast in pcre2_valid_utf.c\n\n27. Update pcre2test, remove some unused code in pcre2_match(), and upgrade the\ntests to improve coverage.\n\n28. Some fixes/tidies as a result of looking at Coverity Scan output:\n\n    (a) Typo: \">\" should be \">=\" in opcode check in pcre2_auto_possess.c.\n    (b) Added some casts to avoid \"suspicious implicit sign extension\".\n    (c) Resource leaks in pcre2test in rare error cases.\n    (d) Avoid warning for never-use case OP_TABLE_LENGTH which is just a fudge\n        for checking at compile time that tables are the right size.\n    (e) Add missing \"fall through\" comment.\n\n29. Implemented PCRE2_EXTENDED_MORE and related /xx and (?xx) features.\n\n30. Implement (?n: for PCRE2_NO_AUTO_CAPTURE, because Perl now has this.\n\n31. If more than one of \"push\", \"pushcopy\", or \"pushtablescopy\" were set in\npcre2test, a crash could occur.\n\n32. Make -bigstack in RunTest allocate a 64MiB stack (instead of 16MiB) so\nthat all the tests can run with clang's sanitizing options.\n\n33. Implement extra compile options in the compile context and add the first\none: PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES.\n\n34. Implement newline type PCRE2_NEWLINE_NUL.\n\n35. A lookbehind assertion that had a zero-length branch caused undefined\nbehaviour when processed by pcre2_dfa_match(). This is oss-fuzz issue 1859.\n\n36. The match limit value now also applies to pcre2_dfa_match() as there are\npatterns that can use up a lot of resources without necessarily recursing very\ndeeply. (Compare item 10.23/36.) This should fix oss-fuzz #1761.\n\n37. Implement PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL.\n\n38. Fix returned offsets from regexec() when REG_STARTEND is used with a\nstarting offset greater than zero.\n\n39. Implement REG_PEND (GNU extension) for the POSIX wrapper.\n\n40. Implement the subject_literal modifier in pcre2test, and allow jitstack on\npattern lines.\n\n41. Implement PCRE2_LITERAL and use it to support REG_NOSPEC.\n\n42. Implement PCRE2_EXTRA_MATCH_LINE and PCRE2_EXTRA_MATCH_WORD for the benefit\nof pcre2grep.\n\n43. Re-implement pcre2grep's -F, -w, and -x options using PCRE2_LITERAL,\nPCRE2_EXTRA_MATCH_WORD, and PCRE2_EXTRA_MATCH_LINE. This fixes two bugs:\n\n    (a) The -F option did not work for fixed strings containing \\E.\n    (b) The -w option did not work for patterns with multiple branches.\n\n44. Added configuration options for the SELinux compatible execmem allocator in\nJIT.\n\n45. Increased the limit for searching for a \"must be present\" code unit in\nsubjects from 1000 to 2000 for 8-bit searches, since they use memchr() and are\nmuch faster.\n\n46. Arrange for anchored patterns to record and use \"first code unit\" data,\nbecause this can give a fast \"no match\" without searching for a \"required code\nunit\". Previously only non-anchored patterns did this.\n\n47. Upgraded the Unicode tables from Unicode 8.0.0 to Unicode 10.0.0.\n\n48. Add the callout_no_where modifier to pcre2test.\n\n49. Update extended grapheme breaking rules to the latest set that are in\nUnicode Standard Annex #29.\n\n50. Added experimental foreign pattern conversion facilities\n(pcre2_pattern_convert() and friends).\n\n51. Change the macro FWRITE, used in pcre2grep, to FWRITE_IGNORE because FWRITE\nis defined in a system header in cygwin. Also modified some of the #ifdefs in\npcre2grep related to Windows and Cygwin support.\n\n52. Change 3(g) for 10.23 was a bit too zealous. If a hyphen that follows a\ncharacter class is the last character in the class, Perl does not give a\nwarning. PCRE2 now also treats this as a literal.\n\n53. Related to 52, though PCRE2 was throwing an error for [[:digit:]-X] it was\nnot doing so for [\\d-X] (and similar escapes), as is documented.\n\n54. Fixed a MIPS issue in the JIT compiler reported by Joshua Kinard.\n\n55. Fixed a \"maybe uninitialized\" warning for class_uchardata in \\p handling in\npcre2_compile() which could never actually trigger (code should have been cut\nout when Unicode support is disabled).\n\n\nVersion 10.23 14-February-2017\n------------------------------\n\n1. Extended pcre2test with the utf8_input modifier so that it is able to\ngenerate all possible 16-bit and 32-bit code unit values in non-UTF modes.\n\n2. In any wide-character mode (8-bit UTF or any 16-bit or 32-bit mode), without\nPCRE2_UCP set, a negative character type such as \\D in a positive class should\ncause all characters greater than 255 to match, whatever else is in the class.\nThere was a bug that caused this not to happen if a Unicode property item was\nadded to such a class, for example [\\D\\P{Nd}] or [\\W\\pL].\n\n3. There has been a major re-factoring of the pcre2_compile.c file. Most syntax\nchecking is now done in the pre-pass that identifies capturing groups. This has\nreduced the amount of duplication and made the code tidier. While doing this,\nsome minor bugs and Perl incompatibilities were fixed, including:\n\n  (a) \\Q\\E in the middle of a quantifier such as A+\\Q\\E+ is now ignored instead\n      of giving an invalid quantifier error.\n\n  (b) {0} can now be used after a group in a lookbehind assertion; previously\n      this caused an \"assertion is not fixed length\" error.\n\n  (c) Perl always treats (?(DEFINE) as a \"define\" group, even if a group with\n      the name \"DEFINE\" exists. PCRE2 now does likewise.\n\n  (d) A recursion condition test such as (?(R2)...) must now refer to an\n      existing subpattern.\n\n  (e) A conditional recursion test such as (?(R)...) misbehaved if there was a\n      group whose name began with \"R\".\n\n  (f) When testing zero-terminated patterns under valgrind, the terminating\n      zero is now marked \"no access\". This catches bugs that would otherwise\n      show up only with non-zero-terminated patterns.\n\n  (g) A hyphen appearing immediately after a POSIX character class (for example\n      /[[:ascii:]-z]/) now generates an error. Perl does accept this as a\n      literal, but gives a warning, so it seems best to fail it in PCRE.\n\n  (h) An empty \\Q\\E sequence may appear after a callout that precedes an\n      assertion condition (it is, of course, ignored).\n\nOne effect of the refactoring is that some error numbers and messages have\nchanged, and the pattern offset given for compiling errors is not always the\nright-most character that has been read. In particular, for a variable-length\nlookbehind assertion it now points to the start of the assertion. Another\nchange is that when a callout appears before a group, the \"length of next\npattern item\" that is passed now just gives the length of the opening\nparenthesis item, not the length of the whole group. A length of zero is now\ngiven only for a callout at the end of the pattern. Automatic callouts are no\nlonger inserted before and after explicit callouts in the pattern.\n\nA number of bugs in the refactored code were subsequently fixed during testing\nbefore release, but after the code was made available in the repository. Many\nof the bugs were discovered by fuzzing testing. Several of them were related to\nthe change from assuming a zero-terminated pattern (which previously had\nrequired non-zero terminated strings to be copied). These bugs were never in\nfully released code, but are noted here for the record.\n\n  (a) An overall recursion such as (?0) inside a lookbehind assertion was not\n      being diagnosed as an error.\n\n  (b) In utf mode, the length of a *MARK (or other verb) name was being checked\n      in characters instead of code units, which could lead to bad code being\n      compiled, leading to unpredictable behaviour.\n\n  (c) In extended /x mode, characters whose code was greater than 255 caused\n      a lookup outside one of the global tables. A similar bug existed for wide\n      characters in *VERB names.\n\n  (d) The amount of memory needed for a compiled pattern was miscalculated if a\n      lookbehind contained more than one toplevel branch and the first branch\n      was of length zero.\n\n  (e) In UTF-8 or UTF-16 modes with PCRE2_EXTENDED (/x) set and a non-zero-\n      terminated pattern, if a # comment ran on to the end of the pattern, one\n      or more code units past the end were being read.\n\n  (f) An unterminated repeat at the end of a non-zero-terminated pattern (e.g.\n      \"{2,2\") could cause reading beyond the pattern.\n\n  (g) When reading a callout string, if the end delimiter was at the end of the\n      pattern one further code unit was read.\n\n  (h) An unterminated number after \\g' could cause reading beyond the pattern.\n\n  (i) An insufficient memory size was being computed for compiling with\n      PCRE2_AUTO_CALLOUT.\n\n  (j) A conditional group with an assertion condition used more memory than was\n      allowed for it during parsing, so too many of them could therefore\n      overrun a buffer.\n\n  (k) If parsing a pattern exactly filled the buffer, the internal test for\n      overrun did not check when the final META_END item was added.\n\n  (l) If a lookbehind contained a subroutine call, and the called group\n      contained an option setting such as (?s), and the PCRE2_ANCHORED option\n      was set, unpredictable behaviour could occur. The underlying bug was\n      incorrect code and insufficient checking while searching for the end of\n      the called subroutine in the parsed pattern.\n\n  (m) Quantifiers following (*VERB)s were not being diagnosed as errors.\n\n  (n) The use of \\Q...\\E in a (*VERB) name when PCRE2_ALT_VERBNAMES and\n      PCRE2_AUTO_CALLOUT were both specified caused undetermined behaviour.\n\n  (o) If \\Q was preceded by a quantified item, and the following \\E was\n      followed by '?' or '+', and there was at least one literal character\n      between them, an internal error \"unexpected repeat\" occurred (example:\n      /.+\\QX\\E+/).\n\n  (p) A buffer overflow could occur while sorting the names in the group name\n      list (depending on the order in which the names were seen).\n\n  (q) A conditional group that started with a callout was not doing the right\n      check for a following assertion, leading to compiling bad code. Example:\n      /(?(C'XX))?!XX/\n\n  (r) If a character whose code point was greater than 0xffff appeared within\n      a lookbehind that was within another lookbehind, the calculation of the\n      lookbehind length went wrong and could provoke an internal error.\n\n  (t) The sequence \\E- or \\Q\\E- after a POSIX class in a character class caused\n      an internal error. Now the hyphen is treated as a literal.\n\n4. Back references are now permitted in lookbehind assertions when there are\nno duplicated group numbers (that is, (?| has not been used), and, if the\nreference is by name, there is only one group of that name. The referenced\ngroup must, of course be of fixed length.\n\n5. pcre2test has been upgraded so that, when run under valgrind with valgrind\nsupport enabled, reading past the end of the pattern is detected, both when\ncompiling and during callout processing.\n\n6. \\g{+<number>} (e.g. \\g{+2} ) is now supported. It is a \"forward back\nreference\" and can be useful in repetitions (compare \\g{-<number>} ). Perl does\nnot recognize this syntax.\n\n7. Automatic callouts are no longer generated before and after callouts in the\npattern.\n\n8. When pcre2test was outputing information from a callout, the caret indicator\nfor the current position in the subject line was incorrect if it was after an\nescape sequence for a character whose code point was greater than \\x{ff}.\n\n9. Change 19 for 10.22 had a typo (PCRE_STATIC_RUNTIME should be\nPCRE2_STATIC_RUNTIME). Fix from David Gaussmann.\n\n10. Added --max-buffer-size to pcre2grep, to allow for automatic buffer\nexpansion when long lines are encountered. Original patch by Dmitry\nCherniachenko.\n\n11. If pcre2grep was compiled with JIT support, but the library was compiled\nwithout it (something that neither ./configure nor CMake allow, but it can be\ndone by editing config.h), pcre2grep was giving a JIT error. Now it detects\nthis situation and does not try to use JIT.\n\n12. Added some \"const\" qualifiers to variables in pcre2grep.\n\n13. Added Dmitry Cherniachenko's patch for colouring output in Windows\n(untested by me). Also, look for GREP_COLOUR or GREP_COLOR if the environment\nvariables PCRE2GREP_COLOUR and PCRE2GREP_COLOR are not found.\n\n14. Add the -t (grand total) option to pcre2grep.\n\n15. A number of bugs have been mended relating to match start-up optimizations\nwhen the first thing in a pattern is a positive lookahead. These all applied\nonly when PCRE2_NO_START_OPTIMIZE was *not* set:\n\n    (a) A pattern such as (?=.*X)X$ was incorrectly optimized as if it needed\n        both an initial 'X' and a following 'X'.\n    (b) Some patterns starting with an assertion that started with .* were\n        incorrectly optimized as having to match at the start of the subject or\n        after a newline. There are cases where this is not true, for example,\n        (?=.*[A-Z])(?=.{8,16})(?!.*[\\s]) matches after the start in lines that\n        start with spaces. Starting .* in an assertion is no longer taken as an\n        indication of matching at the start (or after a newline).\n\n16. The \"offset\" modifier in pcre2test was not being ignored (as documented)\nwhen the POSIX API was in use.\n\n17. Added --enable-fuzz-support to \"configure\", causing an non-installed\nlibrary containing a test function that can be called by fuzzers to be\ncompiled. A non-installed  binary to run the test function locally, called\npcre2fuzzcheck is also compiled.\n\n18. A pattern with PCRE2_DOTALL (/s) set but not PCRE2_NO_DOTSTAR_ANCHOR, and\nwhich started with .* inside a positive lookahead was incorrectly being\ncompiled as implicitly anchored.\n\n19. Removed all instances of \"register\" declarations, as they are considered\nobsolete these days and in any case had become very haphazard.\n\n20. Add strerror() to pcre2test for failed file opening.\n\n21. Make pcre2test -C list valgrind support when it is enabled.\n\n22. Add the use_length modifier to pcre2test.\n\n23. Fix an off-by-one bug in pcre2test for the list of names for 'get' and\n'copy' modifiers.\n\n24. Add PCRE2_CALL_CONVENTION into the prototype declarations in pcre2.h as it\nis apparently needed there as well as in the function definitions. (Why did\nnobody ask for this in PCRE1?)\n\n25. Change the _PCRE2_H and _PCRE2_UCP_H guard macros in the header files to\nPCRE2_H_IDEMPOTENT_GUARD and PCRE2_UCP_H_IDEMPOTENT_GUARD to be more standard\ncompliant and unique.\n\n26. pcre2-config --libs-posix was listing -lpcre2posix instead of\n-lpcre2-posix. Also, the CMake build process was building the library with the\nwrong name.\n\n27. In pcre2test, give some offset information for errors in hex patterns.\nThis uses the C99 formatting sequence %td, except for MSVC which doesn't\nsupport it - %lu is used instead.\n\n28. Implemented pcre2_code_copy_with_tables(), and added pushtablescopy to\npcre2test for testing it.\n\n29. Fix small memory leak in pcre2test.\n\n30. Fix out-of-bounds read for partial matching of /./ against an empty string\nwhen the newline type is CRLF.\n\n31. Fix a bug in pcre2test that caused a crash when a locale was set either in\nthe current pattern or a previous one and a wide character was matched.\n\n32. The appearance of \\p, \\P, or \\X in a substitution string when\nPCRE2_SUBSTITUTE_EXTENDED was set caused a segmentation fault (NULL\ndereference).\n\n33. If the starting offset was specified as greater than the subject length in\na call to pcre2_substitute() an out-of-bounds memory reference could occur.\n\n34. When PCRE2 was compiled to use the heap instead of the stack for recursive\ncalls to match(), a repeated minimizing caseless back reference, or a\nmaximizing one where the two cases had different numbers of code units,\nfollowed by a caseful back reference, could lose the caselessness of the first\nrepeated back reference (example: /(Z)(a)\\2{1,2}?(?-i)\\1X/i should match ZaAAZX\nbut didn't).\n\n35. When a pattern is too complicated, PCRE2 gives up trying to find a minimum\nmatching length and just records zero. Typically this happens when there are\ntoo many nested or recursive back references. If the limit was reached in\ncertain recursive cases it failed to be triggered and an internal error could\nbe the result.\n\n36. The pcre2_dfa_match() function now takes note of the recursion limit for\nthe internal recursive calls that are used for lookrounds and recursions within\nthe pattern.\n\n37. More refactoring has got rid of the internal could_be_empty_branch()\nfunction (around 400 lines of code, including comments) by keeping track of\ncould-be-emptiness as the pattern is compiled instead of scanning compiled\ngroups. (This would have been much harder before the refactoring of #3 above.)\nThis lifts a restriction on the number of branches in a group (more than about\n1100 would give \"pattern is too complicated\").\n\n38. Add the \"-ac\" command line option to pcre2test as a synonym for \"-pattern\nauto_callout\".\n\n39. In a library with Unicode support, incorrect data was compiled for a\npattern with PCRE2_UCP set without PCRE2_UTF if a class required all wide\ncharacters to match (for example, /[\\s[:^ascii:]]/).\n\n40. The callout_error modifier has been added to pcre2test to make it possible\nto return PCRE2_ERROR_CALLOUT from a callout.\n\n41. A minor change to pcre2grep: colour reset is now \"<esc>[0m\" instead of\n\"<esc>[00m\".\n\n42. The limit in the auto-possessification code that was intended to catch\noverly-complicated patterns and not spend too much time auto-possessifying was\nbeing reset too often, resulting in very long compile times for some patterns.\nNow such patterns are no longer completely auto-possessified.\n\n43. Applied Jason Hood's revised patch for RunTest.bat.\n\n44. Added a new Windows script RunGrepTest.bat, courtesy of Jason Hood.\n\n45. Minor cosmetic fix to pcre2test: move a variable that is not used under\nWindows into the \"not Windows\" code.\n\n46. Applied Jason Hood's patches to upgrade pcre2grep under Windows and tidy\nsome of the code:\n\n  * normalised the Windows condition by ensuring WIN32 is defined;\n  * enables the callout feature under Windows;\n  * adds globbing (Microsoft's implementation expands quoted args),\n    using a tweaked opendirectory;\n  * implements the is_*_tty functions for Windows;\n  * --color=always will write the ANSI sequences to file;\n  * add sequences 4 (underline works on Win10) and 5 (blink as bright\n    background, relatively standard on DOS/Win);\n  * remove the (char *) casts for the now-const strings;\n  * remove GREP_COLOUR (grep's command line allowed the 'u', but not\n    the environment), parsing GREP_COLORS instead;\n  * uses the current colour if not set, rather than black;\n  * add print_match for the undefined case;\n  * fixes a typo.\n\nIn addition, colour settings containing anything other than digits and\nsemicolon are ignored, and the colour controls are no longer output for empty\nstrings.\n\n47. Detecting patterns that are too large inside the length-measuring loop\nsaves processing ridiculously long patterns to their end.\n\n48. Ignore PCRE2_CASELESS when processing \\h, \\H, \\v, and \\V in classes as it\njust wastes time. In the UTF case it can also produce redundant entries in\nXCLASS lists caused by characters with multiple other cases and pairs of\ncharacters in the same \"not-x\" sublists.\n\n49. A pattern such as /(?=(a\\K))/ can report the end of the match being before\nits start; pcre2test was not handling this correctly when using the POSIX\ninterface (it was OK with the native interface).\n\n50. In pcre2grep, ignore all JIT compile errors. This means that pcre2grep will\ncontinue to work, falling back to interpretation if anything goes wrong with\nJIT.\n\n51. Applied patches from Christian Persch to configure.ac to make use of the\nAC_USE_SYSTEM_EXTENSIONS macro and to test for functions used by the JIT\nmodules.\n\n52. Minor fixes to pcre2grep from Jason Hood:\n    * fixed some spacing;\n    * Windows doesn't usually use single quotes, so I've added a define\n      to use appropriate quotes [in an example];\n    * LC_ALL was displayed as \"LCC_ALL\";\n    * numbers 11, 12 & 13 should end in \"th\";\n    * use double quotes in usage message.\n\n53. When autopossessifying, skip empty branches without recursion, to reduce\nstack usage for the benefit of clang with -fsanitize-address, which uses huge\nstack frames. Example pattern: /X?(R||){3335}/. Fixes oss-fuzz issue 553.\n\n54. A pattern with very many explicit back references to a group that is a long\nway from the start of the pattern could take a long time to compile because\nsearching for the referenced group in order to find the minimum length was\nbeing done repeatedly. Now up to 128 group minimum lengths are cached and the\nattempt to find a minimum length is abandoned if there is a back reference to a\ngroup whose number is greater than 128. (In that case, the pattern is so\ncomplicated that this optimization probably isn't worth it.) This fixes\noss-fuzz issue 557.\n\n55. Issue 32 for 10.22 below was not correctly fixed. If pcre2grep in multiline\nmode with --only-matching matched several lines, it restarted scanning at the\nnext line instead of moving on to the end of the matched string, which can be\nseveral lines after the start.\n\n56. Applied Jason Hood's new patch for RunGrepTest.bat that updates it in line\nwith updates to the non-Windows version.\n\n\n\nVersion 10.22 29-July-2016\n--------------------------\n\n1. Applied Jason Hood's patches to RunTest.bat and testdata/wintestoutput3\nto fix problems with running the tests under Windows.\n\n2. Implemented a facility for quoting literal characters within hexadecimal\npatterns in pcre2test, to make it easier to create patterns with just a few\nnon-printing characters.\n\n3. Binary zeros are not supported in pcre2test input files. It now detects them\nand gives an error.\n\n4. Updated the valgrind parameters in RunTest: (a) changed smc-check=all to\nsmc-check=all-non-file; (b) changed obj:* in the suppression file to obj:??? so\nthat it matches only unknown objects.\n\n5. Updated the maintenance script maint/ManyConfigTests to make it easier to\nselect individual groups of tests.\n\n6. When the POSIX wrapper function regcomp() is called, the REG_NOSUB option\nused to set PCRE2_NO_AUTO_CAPTURE when calling pcre2_compile(). However, this\ndisables the use of back references (and subroutine calls), which are supported\nby other implementations of regcomp() with RE_NOSUB. Therefore, REG_NOSUB no\nlonger causes PCRE2_NO_AUTO_CAPTURE to be set, though it still ignores nmatch\nand pmatch when regexec() is called.\n\n7. Because of 6 above, pcre2test has been modified with a new modifier called\nposix_nosub, to call regcomp() with REG_NOSUB. Previously the no_auto_capture\nmodifier had this effect. That option is now ignored when the POSIX API is in\nuse.\n\n8. Minor tidies to the pcre2demo.c sample program, including more comments\nabout its 8-bit-ness.\n\n9. Detect unmatched closing parentheses and give the error in the pre-scan\ninstead of later. Previously the pre-scan carried on and could give a\nmisleading incorrect error message. For example, /(?J)(?'a'))(?'a')/ gave a\nmessage about invalid duplicate group names.\n\n10. It has happened that pcre2test was accidentally linked with another POSIX\nregex library instead of libpcre2-posix. In this situation, a call to regcomp()\n(in the other library) may succeed, returning zero, but of course putting its\nown data into the regex_t block. In one example the re_pcre2_code field was\nleft as NULL, which made pcre2test think it had not got a compiled POSIX regex,\nso it treated the next line as another pattern line, resulting in a confusing\nerror message. A check has been added to pcre2test to see if the data returned\nfrom a successful call of regcomp() are valid for PCRE2's regcomp(). If they\nare not, an error message is output and the pcre2test run is abandoned. The\nmessage points out the possibility of a mis-linking. Hopefully this will avoid\nsome head-scratching the next time this happens.\n\n11. A pattern such as /(?<=((?C)0))/, which has a callout inside a lookbehind\nassertion, caused pcre2test to output a very large number of spaces when the\ncallout was taken, making the program appearing to loop.\n\n12. A pattern that included (*ACCEPT) in the middle of a sufficiently deeply\nnested set of parentheses of sufficient size caused an overflow of the\ncompiling workspace (which was diagnosed, but of course is not desirable).\n\n13. Detect missing closing parentheses during the pre-pass for group\nidentification.\n\n14. Changed some integer variable types and put in a number of casts, following\na report of compiler warnings from Visual Studio 2013 and a few tests with\ngcc's -Wconversion (which still throws up a lot).\n\n15. Implemented pcre2_code_copy(), and added pushcopy and #popcopy to pcre2test\nfor testing it.\n\n16. Change 66 for 10.21 introduced the use of snprintf() in PCRE2's version of\nregerror(). When the error buffer is too small, my version of snprintf() puts a\nbinary zero in the final byte. Bug #1801 seems to show that other versions do\nnot do this, leading to bad output from pcre2test when it was checking for\nbuffer overflow. It no longer assumes a binary zero at the end of a too-small\nregerror() buffer.\n\n17. Fixed typo (\"&&\" for \"&\") in pcre2_study(). Fortunately, this could not\nactually affect anything, by sheer luck.\n\n18. Two minor fixes for MSVC compilation: (a) removal of apparently incorrect\n\"const\" qualifiers in pcre2test and (b) defining snprintf as _snprintf for\nolder MSVC compilers. This has been done both in src/pcre2_internal.h for most\nof the library, and also in src/pcre2posix.c, which no longer includes\npcre2_internal.h (see 24 below).\n\n19. Applied Chris Wilson's patch (Bugzilla #1681) to CMakeLists.txt for MSVC\nstatic compilation. Subsequently applied Chris Wilson's second patch, putting\nthe first patch under a new option instead of being unconditional when\nPCRE_STATIC is set.\n\n20. Updated pcre2grep to set stdout as binary when run under Windows, so as not\nto convert \\r\\n at the ends of reflected lines into \\r\\r\\n. This required\nensuring that other output that is written to stdout (e.g. file names) uses the\nappropriate line terminator: \\r\\n for Windows, \\n otherwise.\n\n21. When a line is too long for pcre2grep's internal buffer, show the maximum\nlength in the error message.\n\n22. Added support for string callouts to pcre2grep (Zoltan's patch with PH\nadditions).\n\n23. RunTest.bat was missing a \"set type\" line for test 22.\n\n24. The pcre2posix.c file was including pcre2_internal.h, and using some\n\"private\" knowledge of the data structures. This is unnecessary; the code has\nbeen re-factored and no longer includes pcre2_internal.h.\n\n25. A racing condition is fixed in JIT reported by Mozilla.\n\n26. Minor code refactor to avoid \"array subscript is below array bounds\"\ncompiler warning.\n\n27. Minor code refactor to avoid \"left shift of negative number\" warning.\n\n28. Add a bit more sanity checking to pcre2_serialize_decode() and document\nthat it expects trusted data.\n\n29. Fix typo in pcre2_jit_test.c\n\n30. Due to an oversight, pcre2grep was not making use of JIT when available.\nThis is now fixed.\n\n31. The RunGrepTest script is updated to use the valgrind suppressions file\nwhen testing with JIT under valgrind (compare 10.21/51 below). The suppressions\nfile is updated so that is now the same as for PCRE1: it suppresses the\nMemcheck warnings Addr16 and Cond in unknown objects (that is, JIT-compiled\ncode). Also changed smc-check=all to smc-check=all-non-file as was done for\nRunTest (see 4 above).\n\n32. Implemented the PCRE2_NO_JIT option for pcre2_match().\n\n33. Fix typo that gave a compiler error when JIT not supported.\n\n34. Fix comment describing the returns from find_fixedlength().\n\n35. Fix potential negative index in pcre2test.\n\n36. Calls to pcre2_get_error_message() with error numbers that are never\nreturned by PCRE2 functions were returning empty strings. Now the error code\nPCRE2_ERROR_BADDATA is returned. A facility has been added to pcre2test to\nshow the texts for given error numbers (i.e. to call pcre2_get_error_message()\nand display what it returns) and a few representative error codes are now\nchecked in RunTest.\n\n37. Added \"&& !defined(__INTEL_COMPILER)\" to the test for __GNUC__ in\npcre2_match.c, in anticipation that this is needed for the same reason it was\nrecently added to pcrecpp.cc in PCRE1.\n\n38. Using -o with -M in pcre2grep could cause unnecessary repeated output when\nthe match extended over a line boundary, as it tried to find more matches \"on\nthe same line\" - but it was already over the end.\n\n39. Allow \\C in lookbehinds and DFA matching in UTF-32 mode (by converting it\nto the same code as '.' when PCRE2_DOTALL is set).\n\n40. Fix two clang compiler warnings in pcre2test when only one code unit width\nis supported.\n\n41. Upgrade RunTest to automatically re-run test 2 with a large (64MiB) stack\nif it fails when running the interpreter with a 16MiB stack (and if changing\nthe stack size via pcre2test is possible). This avoids having to manually set a\nlarge stack size when testing with clang.\n\n42. Fix register overwite in JIT when SSE2 acceleration is enabled.\n\n43. Detect integer overflow in pcre2test pattern and data repetition counts.\n\n44. In pcre2test, ignore \"allcaptures\" after DFA matching.\n\n45. Fix unaligned accesses on x86. Patch by Marc Mutz.\n\n46. Fix some more clang compiler warnings.\n\n\nVersion 10.21 12-January-2016\n-----------------------------\n\n1. Improve matching speed of patterns starting with + or * in JIT.\n\n2. Use memchr() to find the first character in an unanchored match in 8-bit\nmode in the interpreter. This gives a significant speed improvement.\n\n3. Removed a redundant copy of the opcode_possessify table in the\npcre2_auto_possessify.c source.\n\n4. Fix typos in dftables.c for z/OS.\n\n5. Change 36 for 10.20 broke the handling of [[:>:]] and [[:<:]] in that\nprocessing them could involve a buffer overflow if the following character was\nan opening parenthesis.\n\n6. Change 36 for 10.20 also introduced a bug in processing this pattern:\n/((?x)(*:0))#(?'/. Specifically: if a setting of (?x) was followed by a (*MARK)\nsetting (which (*:0) is), then (?x) did not get unset at the end of its group\nduring the scan for named groups, and hence the external # was incorrectly\ntreated as a comment and the invalid (?' at the end of the pattern was not\ndiagnosed. This caused a buffer overflow during the real compile. This bug was\ndiscovered by Karl Skomski with the LLVM fuzzer.\n\n7. Moved the pcre2_find_bracket() function from src/pcre2_compile.c into its\nown source module to avoid a circular dependency between src/pcre2_compile.c\nand src/pcre2_study.c\n\n8. A callout with a string argument containing an opening square bracket, for\nexample /(?C$[$)(?<]/, was incorrectly processed and could provoke a buffer\noverflow. This bug was discovered by Karl Skomski with the LLVM fuzzer.\n\n9. The handling of callouts during the pre-pass for named group identification\nhas been tightened up.\n\n10. The quantifier {1} can be ignored, whether greedy, non-greedy, or\npossessive. This is a very minor optimization.\n\n11. A possessively repeated conditional group that could match an empty string,\nfor example, /(?(R))*+/, was incorrectly compiled.\n\n12. The Unicode tables have been updated to Unicode 8.0.0 (thanks to Christian\nPersch).\n\n13. An empty comment (?#) in a pattern was incorrectly processed and could\nprovoke a buffer overflow. This bug was discovered by Karl Skomski with the\nLLVM fuzzer.\n\n14. Fix infinite recursion in the JIT compiler when certain patterns such as\n/(?:|a|){100}x/ are analysed.\n\n15. Some patterns with character classes involving [: and \\\\ were incorrectly\ncompiled and could cause reading from uninitialized memory or an incorrect\nerror diagnosis. Examples are: /[[:\\\\](?<[::]/ and /[[:\\\\](?'abc')[a:]. The\nfirst of these bugs was discovered by Karl Skomski with the LLVM fuzzer.\n\n16. Pathological patterns containing many nested occurrences of [: caused\npcre2_compile() to run for a very long time. This bug was found by the LLVM\nfuzzer.\n\n17. A missing closing parenthesis for a callout with a string argument was not\nbeing diagnosed, possibly leading to a buffer overflow. This bug was found by\nthe LLVM fuzzer.\n\n18. A conditional group with only one branch has an implicit empty alternative\nbranch and must therefore be treated as potentially matching an empty string.\n\n19. If (?R was followed by - or + incorrect behaviour happened instead of a\ndiagnostic. This bug was discovered by Karl Skomski with the LLVM fuzzer.\n\n20. Another bug that was introduced by change 36 for 10.20: conditional groups\nwhose condition was an assertion preceded by an explicit callout with a string\nargument might be incorrectly processed, especially if the string contained \\Q.\nThis bug was discovered by Karl Skomski with the LLVM fuzzer.\n\n21. Compiling PCRE2 with the sanitize options of clang showed up a number of\nvery pedantic coding infelicities and a buffer overflow while checking a UTF-8\nstring if the final multi-byte UTF-8 character was truncated.\n\n22. For Perl compatibility in EBCDIC environments, ranges such as a-z in a\nclass, where both values are literal letters in the same case, omit the\nnon-letter EBCDIC code points within the range.\n\n23. Finding the minimum matching length of complex patterns with back\nreferences and/or recursions can take a long time. There is now a cut-off that\ngives up trying to find a minimum length when things get too complex.\n\n24. An optimization has been added that speeds up finding the minimum matching\nlength for patterns containing repeated capturing groups or recursions.\n\n25. If a pattern contained a back reference to a group whose number was\nduplicated as a result of appearing in a (?|...) group, the computation of the\nminimum matching length gave a wrong result, which could cause incorrect \"no\nmatch\" errors. For such patterns, a minimum matching length cannot at present\nbe computed.\n\n26. Added a check for integer overflow in conditions (?(<digits>) and\n(?(R<digits>). This omission was discovered by Karl Skomski with the LLVM\nfuzzer.\n\n27. Fixed an issue when \\p{Any} inside an xclass did not read the current\ncharacter.\n\n28. If pcre2grep was given the -q option with -c or -l, or when handling a\nbinary file, it incorrectly wrote output to stdout.\n\n29. The JIT compiler did not restore the control verb head in case of *THEN\ncontrol verbs. This issue was found by Karl Skomski with a custom LLVM fuzzer.\n\n30. The way recursive references such as (?3) are compiled has been re-written\nbecause the old way was the cause of many issues. Now, conversion of the group\nnumber into a pattern offset does not happen until the pattern has been\ncompletely compiled. This does mean that detection of all infinitely looping\nrecursions is postponed till match time. In the past, some easy ones were\ndetected at compile time. This re-writing was done in response to yet another\nbug found by the LLVM fuzzer.\n\n31. A test for a back reference to a non-existent group was missing for items\nsuch as \\987. This caused incorrect code to be compiled. This issue was found\nby Karl Skomski with a custom LLVM fuzzer.\n\n32. Error messages for syntax errors following \\g and \\k were giving inaccurate\noffsets in the pattern.\n\n33. Improve the performance of starting single character repetitions in JIT.\n\n34. (*LIMIT_MATCH=) now gives an error instead of setting the value to 0.\n\n35. Error messages for syntax errors in *LIMIT_MATCH and *LIMIT_RECURSION now\ngive the right offset instead of zero.\n\n36. The JIT compiler should not check repeats after a {0,1} repeat byte code.\nThis issue was found by Karl Skomski with a custom LLVM fuzzer.\n\n37. The JIT compiler should restore the control chain for empty possessive\nrepeats. This issue was found by Karl Skomski with a custom LLVM fuzzer.\n\n38. A bug which was introduced by the single character repetition optimization\nwas fixed.\n\n39. Match limit check added to recursion. This issue was found by Karl Skomski\nwith a custom LLVM fuzzer.\n\n40. Arrange for the UTF check in pcre2_match() and pcre2_dfa_match() to look\nonly at the part of the subject that is relevant when the starting offset is\nnon-zero.\n\n41. Improve first character match in JIT with SSE2 on x86.\n\n42. Fix two assertion fails in JIT. These issues were found by Karl Skomski\nwith a custom LLVM fuzzer.\n\n43. Correct the setting of CMAKE_C_FLAGS in CMakeLists.txt (patch from Roy Ivy\nIII).\n\n44. Fix bug in RunTest.bat for new test 14, and adjust the script for the added\ntest (there are now 20 in total).\n\n45. Fixed a corner case of range optimization in JIT.\n\n46. Add the ${*MARK} facility to pcre2_substitute().\n\n47. Modifier lists in pcre2test were splitting at spaces without the required\ncommas.\n\n48. Implemented PCRE2_ALT_VERBNAMES.\n\n49. Fixed two issues in JIT. These were found by Karl Skomski with a custom\nLLVM fuzzer.\n\n50. The pcre2test program has been extended by adding the #newline_default\ncommand. This has made it possible to run the standard tests when PCRE2 is\ncompiled with either CR or CRLF as the default newline convention. As part of\nthis work, the new command was added to several test files and the testing\nscripts were modified. The pcre2grep tests can now also be run when there is no\nLF in the default newline convention.\n\n51. The RunTest script has been modified so that, when JIT is used and valgrind\nis specified, a valgrind suppressions file is set up to ignore \"Invalid read of\nsize 16\" errors because these are false positives when the hardware supports\nthe SSE2 instruction set.\n\n52. It is now possible to have comment lines amid the subject strings in\npcre2test (and perltest.sh) input.\n\n53. Implemented PCRE2_USE_OFFSET_LIMIT and pcre2_set_offset_limit().\n\n54. Add the null_context modifier to pcre2test so that calling pcre2_compile()\nand the matching functions with NULL contexts can be tested.\n\n55. Implemented PCRE2_SUBSTITUTE_EXTENDED.\n\n56. In a character class such as [\\W\\p{Any}] where both a negative-type escape\n(\"not a word character\") and a property escape were present, the property\nescape was being ignored.\n\n57. Fixed integer overflow for patterns whose minimum matching length is very,\nvery large.\n\n58. Implemented --never-backslash-C.\n\n59. Change 55 above introduced a bug by which certain patterns provoked the\nerroneous error \"\\ at end of pattern\".\n\n60. The special sequences [[:<:]] and [[:>:]] gave rise to incorrect compiling\nerrors or other strange effects if compiled in UCP mode. Found with libFuzzer\nand AddressSanitizer.\n\n61. Whitespace at the end of a pcre2test pattern line caused a spurious error\nmessage if there were only single-character modifiers. It should be ignored.\n\n62. The use of PCRE2_NO_AUTO_CAPTURE could cause incorrect compilation results\nor segmentation errors for some patterns. Found with libFuzzer and\nAddressSanitizer.\n\n63. Very long names in (*MARK) or (*THEN) etc. items could provoke a buffer\noverflow.\n\n64. Improve error message for overly-complicated patterns.\n\n65. Implemented an optional replication feature for patterns in pcre2test, to\nmake it easier to test long repetitive patterns. The tests for 63 above are\nconverted to use the new feature.\n\n66. In the POSIX wrapper, if regerror() was given too small a buffer, it could\nmisbehave.\n\n67. In pcre2_substitute() in UTF mode, the UTF validity check on the\nreplacement string was happening before the length setting when the replacement\nstring was zero-terminated.\n\n68. In pcre2_substitute() in UTF mode, PCRE2_NO_UTF_CHECK can be set for the\nsecond and subsequent calls to pcre2_match().\n\n69. There was no check for integer overflow for a replacement group number in\npcre2_substitute(). An added check for a number greater than the largest group\nnumber in the pattern means this is not now needed.\n\n70. The PCRE2-specific VERSION condition didn't work correctly if only one\ndigit was given after the decimal point, or if more than two digits were given.\nIt now works with one or two digits, and gives a compile time error if more are\ngiven.\n\n71. In pcre2_substitute() there was the possibility of reading one code unit\nbeyond the end of the replacement string.\n\n72. The code for checking a subject's UTF-32 validity for a pattern with a\nlookbehind involved an out-of-bounds pointer, which could potentially cause\ntrouble in some environments.\n\n73. The maximum lookbehind length was incorrectly calculated for patterns such\nas /(?<=(a)(?-1))x/ which have a recursion within a backreference.\n\n74. Give an error if a lookbehind assertion is longer than 65535 code units.\n\n75. Give an error in pcre2_substitute() if a match ends before it starts (as a\nresult of the use of \\K).\n\n76. Check the length of subpattern names and the names in (*MARK:xx) etc.\ndynamically to avoid the possibility of integer overflow.\n\n77. Implement pcre2_set_max_pattern_length() so that programs can restrict the\nsize of patterns that they are prepared to handle.\n\n78. (*NO_AUTO_POSSESS) was not working.\n\n79. Adding group information caching improves the speed of compiling when\nchecking whether a group has a fixed length and/or could match an empty string,\nespecially when recursion or subroutine calls are involved. However, this\ncannot be used when (?| is present in the pattern because the same number may\nbe used for groups of different sizes. To catch runaway patterns in this\nsituation, counts have been introduced to the functions that scan for empty\nbranches or compute fixed lengths.\n\n80. Allow for the possibility of the size of the nest_save structure not being\na factor of the size of the compiling workspace (it currently is).\n\n81. Check for integer overflow in minimum length calculation and cap it at\n65535.\n\n82. Small optimizations in code for finding the minimum matching length.\n\n83. Lock out configuring for EBCDIC with non-8-bit libraries.\n\n84. Test for error code <= 0 in regerror().\n\n85. Check for too many replacements (more than INT_MAX) in pcre2_substitute().\n\n86. Avoid the possibility of computing with an out-of-bounds pointer (though\nnot dereferencing it) while handling lookbehind assertions.\n\n87. Failure to get memory for the match data in regcomp() is now given as a\nregcomp() error instead of waiting for regexec() to pick it up.\n\n88. In pcre2_substitute(), ensure that CRLF is not split when it is a valid\nnewline sequence.\n\n89. Paranoid check in regcomp() for bad error code from pcre2_compile().\n\n90. Run test 8 (internal offsets and code sizes) for link sizes 3 and 4 as well\nas for link size 2.\n\n91. Document that JIT has a limit on pattern size, and give more information\nabout JIT compile failures in pcre2test.\n\n92. Implement PCRE2_INFO_HASBACKSLASHC.\n\n93. Re-arrange valgrind support code in pcre2test to avoid spurious reports\nwith JIT (possibly caused by SSE2?).\n\n94. Support offset_limit in JIT.\n\n95. A sequence such as [[:punct:]b] that is, a POSIX character class followed\nby a single ASCII character in a class item, was incorrectly compiled in UCP\nmode. The POSIX class got lost, but only if the single character followed it.\n\n96. [:punct:] in UCP mode was matching some characters in the range 128-255\nthat should not have been matched.\n\n97. If [:^ascii:] or [:^xdigit:] are present in a non-negated class, all\ncharacters with code points greater than 255 are in the class. When a Unicode\nproperty was also in the class (if PCRE2_UCP is set, escapes such as \\w are\nturned into Unicode properties), wide characters were not correctly handled,\nand could fail to match.\n\n98. In pcre2test, make the \"startoffset\" modifier a synonym of \"offset\",\nbecause it sets the \"startoffset\" parameter for pcre2_match().\n\n99. If PCRE2_AUTO_CALLOUT was set on a pattern that had a (?# comment between\nan item and its qualifier (for example, A(?#comment)?B) pcre2_compile()\nmisbehaved. This bug was found by the LLVM fuzzer.\n\n100. The error for an invalid UTF pattern string always gave the code unit\noffset as zero instead of where the invalidity was found.\n\n101. Further to 97 above, negated classes such as [^[:^ascii:]\\d] were also not\nworking correctly in UCP mode.\n\n102. Similar to 99 above, if an isolated \\E was present between an item and its\nqualifier when PCRE2_AUTO_CALLOUT was set, pcre2_compile() misbehaved. This bug\nwas found by the LLVM fuzzer.\n\n103. The POSIX wrapper function regexec() crashed if the option REG_STARTEND\nwas set when the pmatch argument was NULL. It now returns REG_INVARG.\n\n104. Allow for up to 32-bit numbers in the ordin() function in pcre2grep.\n\n105. An empty \\Q\\E sequence between an item and its qualifier caused\npcre2_compile() to misbehave when auto callouts were enabled. This bug\nwas found by the LLVM fuzzer.\n\n106. If both PCRE2_ALT_VERBNAMES and PCRE2_EXTENDED were set, and a (*MARK) or\nother verb \"name\" ended with whitespace immediately before the closing\nparenthesis, pcre2_compile() misbehaved. Example: /(*:abc )/, but only when\nboth those options were set.\n\n107. In a number of places pcre2_compile() was not handling NULL characters\ncorrectly, and pcre2test with the \"bincode\" modifier was not always correctly\ndisplaying fields containing NULLS:\n\n   (a) Within /x extended #-comments\n   (b) Within the \"name\" part of (*MARK) and other *verbs\n   (c) Within the text argument of a callout\n\n108. If a pattern that was compiled with PCRE2_EXTENDED started with white\nspace or a #-type comment that was followed by (?-x), which turns off\nPCRE2_EXTENDED, and there was no subsequent (?x) to turn it on again,\npcre2_compile() assumed that (?-x) applied to the whole pattern and\nconsequently mis-compiled it. This bug was found by the LLVM fuzzer. The fix\nfor this bug means that a setting of any of the (?imsxJU) options at the start\nof a pattern is no longer transferred to the options that are returned by\nPCRE2_INFO_ALLOPTIONS. In fact, this was an anachronism that should have\nchanged when the effects of those options were all moved to compile time.\n\n109. An escaped closing parenthesis in the \"name\" part of a (*verb) when\nPCRE2_ALT_VERBNAMES was set caused pcre2_compile() to malfunction. This bug\nwas found by the LLVM fuzzer.\n\n110. Implemented PCRE2_SUBSTITUTE_UNSET_EMPTY, and updated pcre2test to make it\npossible to test it.\n\n111. \"Harden\" pcre2test against ridiculously large values in modifiers and\ncommand line arguments.\n\n112. Implemented PCRE2_SUBSTITUTE_UNKNOWN_UNSET and PCRE2_SUBSTITUTE_OVERFLOW_\nLENGTH.\n\n113. Fix printing of *MARK names that contain binary zeroes in pcre2test.\n\n\nVersion 10.20 30-June-2015\n--------------------------\n\n1. Callouts with string arguments have been added.\n\n2. Assertion code generator in JIT has been optimized.\n\n3. The invalid pattern (?(?C) has a missing assertion condition at the end. The\npcre2_compile() function read past the end of the input before diagnosing an\nerror. This bug was discovered by the LLVM fuzzer.\n\n4. Implemented pcre2_callout_enumerate().\n\n5. Fix JIT compilation of conditional blocks whose assertion is converted to\n(*FAIL). E.g: /(?(?!))/.\n\n6. The pattern /(?(?!)^)/ caused references to random memory. This bug was\ndiscovered by the LLVM fuzzer.\n\n7. The assertion (?!) is optimized to (*FAIL). This was not handled correctly\nwhen this assertion was used as a condition, for example (?(?!)a|b). In\npcre2_match() it worked by luck; in pcre2_dfa_match() it gave an incorrect\nerror about an unsupported item.\n\n8. For some types of pattern, for example /Z*(|d*){216}/, the auto-\npossessification code could take exponential time to complete. A recursion\ndepth limit of 1000 has been imposed to limit the resources used by this\noptimization. This infelicity was discovered by the LLVM fuzzer.\n\n9. A pattern such as /(*UTF)[\\S\\V\\H]/, which contains a negated special class\nsuch as \\S in non-UCP mode, explicit wide characters (> 255) can be ignored\nbecause \\S ensures they are all in the class. The code for doing this was\ninteracting badly with the code for computing the amount of space needed to\ncompile the pattern, leading to a buffer overflow. This bug was discovered by\nthe LLVM fuzzer.\n\n10. A pattern such as /((?2)+)((?1))/ which has mutual recursion nested inside\nother kinds of group caused stack overflow at compile time. This bug was\ndiscovered by the LLVM fuzzer.\n\n11. A pattern such as /(?1)(?#?'){8}(a)/ which had a parenthesized comment\nbetween a subroutine call and its quantifier was incorrectly compiled, leading\nto buffer overflow or other errors. This bug was discovered by the LLVM fuzzer.\n\n12. The illegal pattern /(?(?<E>.*!.*)?)/ was not being diagnosed as missing an\nassertion after (?(. The code was failing to check the character after (?(?<\nfor the ! or = that would indicate a lookbehind assertion. This bug was\ndiscovered by the LLVM fuzzer.\n\n13. A pattern such as /X((?2)()*+){2}+/ which has a possessive quantifier with\na fixed maximum following a group that contains a subroutine reference was\nincorrectly compiled and could trigger buffer overflow. This bug was discovered\nby the LLVM fuzzer.\n\n14. Negative relative recursive references such as (?-7) to non-existent\nsubpatterns were not being diagnosed and could lead to unpredictable behaviour.\nThis bug was discovered by the LLVM fuzzer.\n\n15. The bug fixed in 14 was due to an integer variable that was unsigned when\nit should have been signed. Some other \"int\" variables, having been checked,\nhave either been changed to uint32_t or commented as \"must be signed\".\n\n16. A mutual recursion within a lookbehind assertion such as (?<=((?2))((?1)))\ncaused a stack overflow instead of the diagnosis of a non-fixed length\nlookbehind assertion. This bug was discovered by the LLVM fuzzer.\n\n17. The use of \\K in a positive lookbehind assertion in a non-anchored pattern\n(e.g. /(?<=\\Ka)/) could make pcre2grep loop.\n\n18. There was a similar problem to 17 in pcre2test for global matches, though\nthe code there did catch the loop.\n\n19. If a greedy quantified \\X was preceded by \\C in UTF mode (e.g. \\C\\X*),\nand a subsequent item in the pattern caused a non-match, backtracking over the\nrepeated \\X did not stop, but carried on past the start of the subject, causing\nreference to random memory and/or a segfault. There were also some other cases\nwhere backtracking after \\C could crash. This set of bugs was discovered by the\nLLVM fuzzer.\n\n20. The function for finding the minimum length of a matching string could take\na very long time if mutual recursion was present many times in a pattern, for\nexample, /((?2){73}(?2))((?1))/. A better mutual recursion detection method has\nbeen implemented. This infelicity was discovered by the LLVM fuzzer.\n\n21. Implemented PCRE2_NEVER_BACKSLASH_C.\n\n22. The feature for string replication in pcre2test could read from freed\nmemory if the replication required a buffer to be extended, and it was not\nworking properly in 16-bit and 32-bit modes. This issue was discovered by a\nfuzzer: see http://lcamtuf.coredump.cx/afl/.\n\n23. Added the PCRE2_ALT_CIRCUMFLEX option.\n\n24. Adjust the treatment of \\8 and \\9 to be the same as the current Perl\nbehaviour.\n\n25. Static linking against the PCRE2 library using the pkg-config module was\nfailing on missing pthread symbols.\n\n26. If a group that contained a recursive back reference also contained a\nforward reference subroutine call followed by a non-forward-reference\nsubroutine call, for example /.((?2)(?R)\\1)()/, pcre2_compile() failed to\ncompile correct code, leading to undefined behaviour or an internally detected\nerror. This bug was discovered by the LLVM fuzzer.\n\n27. Quantification of certain items (e.g. atomic back references) could cause\nincorrect code to be compiled when recursive forward references were involved.\nFor example, in this pattern: /(?1)()((((((\\1++))\\x85)+)|))/. This bug was\ndiscovered by the LLVM fuzzer.\n\n28. A repeated conditional group whose condition was a reference by name caused\na buffer overflow if there was more than one group with the given name. This\nbug was discovered by the LLVM fuzzer.\n\n29. A recursive back reference by name within a group that had the same name as\nanother group caused a buffer overflow. For example: /(?J)(?'d'(?'d'\\g{d}))/.\nThis bug was discovered by the LLVM fuzzer.\n\n30. A forward reference by name to a group whose number is the same as the\ncurrent group, for example in this pattern: /(?|(\\k'Pm')|(?'Pm'))/, caused a\nbuffer overflow at compile time. This bug was discovered by the LLVM fuzzer.\n\n31. Fix -fsanitize=undefined warnings for left shifts of 1 by 31 (it treats 1\nas an int; fixed by writing it as 1u).\n\n32. Fix pcre2grep compile when -std=c99 is used with gcc, though it still gives\na warning for \"fileno\" unless -std=gnu99 us used.\n\n33. A lookbehind assertion within a set of mutually recursive subpatterns could\nprovoke a buffer overflow. This bug was discovered by the LLVM fuzzer.\n\n34. Give an error for an empty subpattern name such as (?'').\n\n35. Make pcre2test give an error if a pattern that follows #forbud_utf contains\n\\P, \\p, or \\X.\n\n36. The way named subpatterns are handled has been refactored. There is now a\npre-pass over the regex which does nothing other than identify named\nsubpatterns and count the total captures. This means that information about\nnamed patterns is known before the rest of the compile. In particular, it means\nthat forward references can be checked as they are encountered. Previously, the\ncode for handling forward references was contorted and led to several errors in\ncomputing the memory requirements for some patterns, leading to buffer\noverflows.\n\n37. There was no check for integer overflow in subroutine calls such as (?123).\n\n38. The table entry for \\l in EBCDIC environments was incorrect, leading to its\nbeing treated as a literal 'l' instead of causing an error.\n\n39. If a non-capturing group containing a conditional group that could match\nan empty string was repeated, it was not identified as matching an empty string\nitself. For example: /^(?:(?(1)x|)+)+$()/.\n\n40. In an EBCDIC environment, pcretest was mishandling the escape sequences\n\\a and \\e in test subject lines.\n\n41. In an EBCDIC environment, \\a in a pattern was converted to the ASCII\ninstead of the EBCDIC value.\n\n42. The handling of \\c in an EBCDIC environment has been revised so that it is\nnow compatible with the specification in Perl's perlebcdic page.\n\n43. Single character repetition in JIT has been improved. 20-30% speedup\nwas achieved on certain patterns.\n\n44. The EBCDIC character 0x41 is a non-breaking space, equivalent to 0xa0 in\nASCII/Unicode. This has now been added to the list of characters that are\nrecognized as white space in EBCDIC.\n\n45. When PCRE2 was compiled without Unicode support, the use of \\p and \\P gave\nan error (correctly) when used outside a class, but did not give an error\nwithin a class.\n\n46. \\h within a class was incorrectly compiled in EBCDIC environments.\n\n47. JIT should return with error when the compiled pattern requires\nmore stack space than the maximum.\n\n48. Fixed a memory leak in pcre2grep when a locale is set.\n\n\nVersion 10.10 06-March-2015\n---------------------------\n\n1. When a pattern is compiled, it remembers the highest back reference so that\nwhen matching, if the ovector is too small, extra memory can be obtained to\nuse instead. A conditional subpattern whose condition is a check on a capture\nhaving happened, such as, for example in the pattern /^(?:(a)|b)(?(1)A|B)/, is\nanother kind of back reference, but it was not setting the highest\nbackreference number. This mattered only if pcre2_match() was called with an\novector that was too small to hold the capture, and there was no other kind of\nback reference (a situation which is probably quite rare). The effect of the\nbug was that the condition was always treated as FALSE when the capture could\nnot be consulted, leading to a incorrect behaviour by pcre2_match(). This bug\nhas been fixed.\n\n2. Functions for serialization and deserialization of sets of compiled patterns\nhave been added.\n\n3. The value that is returned by PCRE2_INFO_SIZE has been corrected to remove\nexcess code units at the end of the data block that may occasionally occur if\nthe code for calculating the size over-estimates. This change stops the\nserialization code copying uninitialized data, to which valgrind objects. The\ndocumentation of PCRE2_INFO_SIZE was incorrect in stating that the size did not\ninclude the general overhead. This has been corrected.\n\n4. All code units in every slot in the table of group names are now set, again\nin order to avoid accessing uninitialized data when serializing.\n\n5. The (*NO_JIT) feature is implemented.\n\n6. If a bug that caused pcre2_compile() to use more memory than allocated was\ntriggered when using valgrind, the code in (3) above passed a stupidly large\nvalue to valgrind. This caused a crash instead of an \"internal error\" return.\n\n7. A reference to a duplicated named group (either a back reference or a test\nfor being set in a conditional) that occurred in a part of the pattern where\nPCRE2_DUPNAMES was not set caused the amount of memory needed for the pattern\nto be incorrectly calculated, leading to overwriting.\n\n8. A mutually recursive set of back references such as (\\2)(\\1) caused a\nsegfault at compile time (while trying to find the minimum matching length).\nThe infinite loop is now broken (with the minimum length unset, that is, zero).\n\n9. If an assertion that was used as a condition was quantified with a minimum\nof zero, matching went wrong. In particular, if the whole group had unlimited\nrepetition and could match an empty string, a segfault was likely. The pattern\n(?(?=0)?)+ is an example that caused this. Perl allows assertions to be\nquantified, but not if they are being used as conditions, so the above pattern\nis faulted by Perl. PCRE2 has now been changed so that it also rejects such\npatterns.\n\n10. The error message for an invalid quantifier has been changed from \"nothing\nto repeat\" to \"quantifier does not follow a repeatable item\".\n\n11. If a bad UTF string is compiled with NO_UTF_CHECK, it may succeed, but\nscanning the compiled pattern in subsequent auto-possessification can get out\nof step and lead to an unknown opcode. Previously this could have caused an\ninfinite loop. Now it generates an \"internal error\" error. This is a tidyup,\nnot a bug fix; passing bad UTF with NO_UTF_CHECK is documented as having an\nundefined outcome.\n\n12. A UTF pattern containing a \"not\" match of a non-ASCII character and a\nsubroutine reference could loop at compile time. Example: /[^\\xff]((?1))/.\n\n13. The locale test (RunTest 3) has been upgraded. It now checks that a locale\nthat is found in the output of \"locale -a\" can actually be set by pcre2test\nbefore it is accepted. Previously, in an environment where a locale was listed\nbut would not set (an example does exist), the test would \"pass\" without\nactually doing anything. Also the fr_CA locale has been added to the list of\nlocales that can be used.\n\n14. Fixed a bug in pcre2_substitute(). If a replacement string ended in a\ncapturing group number without parentheses, the last character was incorrectly\nliterally included at the end of the replacement string.\n\n15. A possessive capturing group such as (a)*+ with a minimum repeat of zero\nfailed to allow the zero-repeat case if pcre2_match() was called with an\novector too small to capture the group.\n\n16. Improved error message in pcre2test when setting the stack size (-S) fails.\n\n17. Fixed two bugs in CMakeLists.txt: (1) Some lines had got lost in the\ntransfer from PCRE1, meaning that CMake configuration failed if \"build tests\"\nwas selected. (2) The file src/pcre2_serialize.c had not been added to the list\nof PCRE2 sources, which caused a failure to build pcre2test.\n\n18. Fixed typo in pcre2_serialize.c (DECL instead of DEFN) that causes problems\nonly on Windows.\n\n19. Use binary input when reading back saved serialized patterns in pcre2test.\n\n20. Added RunTest.bat for running the tests under Windows.\n\n21. \"make distclean\" was not removing config.h, a file that may be created for\nuse with CMake.\n\n22. A pattern such as \"((?2){0,1999}())?\", which has a group containing a\nforward reference repeated a large (but limited) number of times within a\nrepeated outer group that has a zero minimum quantifier, caused incorrect code\nto be compiled, leading to the error \"internal error: previously-checked\nreferenced subpattern not found\" when an incorrect memory address was read.\nThis bug was reported as \"heap overflow\", discovered by Kai Lu of Fortinet's\nFortiGuard Labs. (Added 24-March-2015: CVE-2015-2325 was given to this.)\n\n23. A pattern such as \"((?+1)(\\1))/\" containing a forward reference subroutine\ncall within a group that also contained a recursive back reference caused\nincorrect code to be compiled. This bug was reported as \"heap overflow\",\ndiscovered by Kai Lu of Fortinet's FortiGuard Labs. (Added 24-March-2015:\nCVE-2015-2326 was given to this.)\n\n24. Computing the size of the JIT read-only data in advance has been a source\nof various issues, and new ones are still appear unfortunately. To fix\nexisting and future issues, size computation is eliminated from the code,\nand replaced by on-demand memory allocation.\n\n25. A pattern such as /(?i)[A-`]/, where characters in the other case are\nadjacent to the end of the range, and the range contained characters with more\nthan one other case, caused incorrect behaviour when compiled in UTF mode. In\nthat example, the range a-j was left out of the class.\n\n\nVersion 10.00 05-January-2015\n-----------------------------\n\nVersion 10.00 is the first release of PCRE2, a revised API for the PCRE\nlibrary. Changes prior to 10.00 are logged in the ChangeLog file for the old\nAPI, up to item 20 for release 8.36.\n\nThe code of the library was heavily revised as part of the new API\nimplementation. Details of each and every modification were not individually\nlogged. In addition to the API changes, the following changes were made. They\nare either new functionality, or bug fixes and other noticeable changes of\nbehaviour that were implemented after the code had been forked.\n\n1. Including Unicode support at build time is now enabled by default, but it\ncan optionally be disabled. It is not enabled by default at run time (no\nchange).\n\n2. The test program, now called pcre2test, was re-specified and almost\ncompletely re-written. Its input is not compatible with input for pcretest.\n\n3. Patterns may start with (*NOTEMPTY) or (*NOTEMPTY_ATSTART) to set the\nPCRE2_NOTEMPTY or PCRE2_NOTEMPTY_ATSTART options for every subject line that is\nmatched by that pattern.\n\n4. For the benefit of those who use PCRE2 via some other application, that is,\nnot writing the function calls themselves, it is possible to check the PCRE2\nversion by matching a pattern such as /(?(VERSION>=10)yes|no)/ against a\nstring such as \"yesno\".\n\n5. There are case-equivalent Unicode characters whose encodings use different\nnumbers of code units in UTF-8. U+023A and U+2C65 are one example. (It is\ntheoretically possible for this to happen in UTF-16 too.) If a backreference to\na group containing one of these characters was greedily repeated, and during\nthe match a backtrack occurred, the subject might be backtracked by the wrong\nnumber of code units. For example, if /^(\\x{23a})\\1*(.)/ is matched caselessly\n(and in UTF-8 mode) against \"\\x{23a}\\x{2c65}\\x{2c65}\\x{2c65}\", group 2 should\ncapture the final character, which is the three bytes E2, B1, and A5 in UTF-8.\nIncorrect backtracking meant that group 2 captured only the last two bytes.\nThis bug has been fixed; the new code is slower, but it is used only when the\nstrings matched by the repetition are not all the same length.\n\n6. A pattern such as /()a/ was not setting the \"first character must be 'a'\"\ninformation. This applied to any pattern with a group that matched no\ncharacters, for example: /(?:(?=.)|(?<!x))a/.\n\n7. When an (*ACCEPT) is triggered inside capturing parentheses, it arranges for\nthose parentheses to be closed with whatever has been captured so far. However,\nit was failing to mark any other groups between the highest capture so far and\nthe currrent group as \"unset\". Thus, the ovector for those groups contained\nwhatever was previously there. An example is the pattern /(x)|((*ACCEPT))/ when\nmatched against \"abcd\".\n\n8. The pcre2_substitute() function has been implemented.\n\n9. If an assertion used as a condition was quantified with a minimum of zero\n(an odd thing to do, but it happened), SIGSEGV or other misbehaviour could\noccur.\n\n10. The PCRE2_NO_DOTSTAR_ANCHOR option has been implemented.\n\n****\n", "/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n                    This module by Zoltan Herczeg\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2021 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"pcre2_internal.h\"\n\n#ifdef SUPPORT_JIT\n\n/* All-in-one: Since we use the JIT compiler only from here,\nwe just include it. This way we don't need to touch the build\nsystem files. */\n\n#define SLJIT_CONFIG_AUTO 1\n#define SLJIT_CONFIG_STATIC 1\n#define SLJIT_VERBOSE 0\n\n#ifdef PCRE2_DEBUG\n#define SLJIT_DEBUG 1\n#else\n#define SLJIT_DEBUG 0\n#endif\n\n#define SLJIT_MALLOC(size, allocator_data) pcre2_jit_malloc(size, allocator_data)\n#define SLJIT_FREE(ptr, allocator_data) pcre2_jit_free(ptr, allocator_data)\n\nstatic void * pcre2_jit_malloc(size_t size, void *allocator_data)\n{\npcre2_memctl *allocator = ((pcre2_memctl*)allocator_data);\nreturn allocator->malloc(size, allocator->memory_data);\n}\n\nstatic void pcre2_jit_free(void *ptr, void *allocator_data)\n{\npcre2_memctl *allocator = ((pcre2_memctl*)allocator_data);\nallocator->free(ptr, allocator->memory_data);\n}\n\n#include \"sljit/sljitLir.c\"\n\n#if defined SLJIT_CONFIG_UNSUPPORTED && SLJIT_CONFIG_UNSUPPORTED\n#error Unsupported architecture\n#endif\n\n/* Defines for debugging purposes. */\n\n/* 1 - Use unoptimized capturing brackets.\n   2 - Enable capture_last_ptr (includes option 1). */\n/* #define DEBUG_FORCE_UNOPTIMIZED_CBRAS 2 */\n\n/* 1 - Always have a control head. */\n/* #define DEBUG_FORCE_CONTROL_HEAD 1 */\n\n/* Allocate memory for the regex stack on the real machine stack.\nFast, but limited size. */\n#define MACHINE_STACK_SIZE 32768\n\n/* Growth rate for stack allocated by the OS. Should be the multiply\nof page size. */\n#define STACK_GROWTH_RATE 8192\n\n/* Enable to check that the allocation could destroy temporaries. */\n#if defined SLJIT_DEBUG && SLJIT_DEBUG\n#define DESTROY_REGISTERS 1\n#endif\n\n/*\nShort summary about the backtracking mechanism empolyed by the jit code generator:\n\nThe code generator follows the recursive nature of the PERL compatible regular\nexpressions. The basic blocks of regular expressions are condition checkers\nwhose execute different commands depending on the result of the condition check.\nThe relationship between the operators can be horizontal (concatenation) and\nvertical (sub-expression) (See struct backtrack_common for more details).\n\n  'ab' - 'a' and 'b' regexps are concatenated\n  'a+' - 'a' is the sub-expression of the '+' operator\n\nThe condition checkers are boolean (true/false) checkers. Machine code is generated\nfor the checker itself and for the actions depending on the result of the checker.\nThe 'true' case is called as the matching path (expected path), and the other is called as\nthe 'backtrack' path. Branch instructions are expesive for all CPUs, so we avoid taken\nbranches on the matching path.\n\n Greedy star operator (*) :\n   Matching path: match happens.\n   Backtrack path: match failed.\n Non-greedy star operator (*?) :\n   Matching path: no need to perform a match.\n   Backtrack path: match is required.\n\nThe following example shows how the code generated for a capturing bracket\nwith two alternatives. Let A, B, C, D are arbirary regular expressions, and\nwe have the following regular expression:\n\n   A(B|C)D\n\nThe generated code will be the following:\n\n A matching path\n '(' matching path (pushing arguments to the stack)\n B matching path\n ')' matching path (pushing arguments to the stack)\n D matching path\n return with successful match\n\n D backtrack path\n ')' backtrack path (If we arrived from \"C\" jump to the backtrack of \"C\")\n B backtrack path\n C expected path\n jump to D matching path\n C backtrack path\n A backtrack path\n\n Notice, that the order of backtrack code paths are the opposite of the fast\n code paths. In this way the topmost value on the stack is always belong\n to the current backtrack code path. The backtrack path must check\n whether there is a next alternative. If so, it needs to jump back to\n the matching path eventually. Otherwise it needs to clear out its own stack\n frame and continue the execution on the backtrack code paths.\n*/\n\n/*\nSaved stack frames:\n\nAtomic blocks and asserts require reloading the values of private data\nwhen the backtrack mechanism performed. Because of OP_RECURSE, the data\nare not necessarly known in compile time, thus we need a dynamic restore\nmechanism.\n\nThe stack frames are stored in a chain list, and have the following format:\n([ capturing bracket offset ][ start value ][ end value ])+ ... [ 0 ] [ previous head ]\n\nThus we can restore the private data to a particular point in the stack.\n*/\n\ntypedef struct jit_arguments {\n  /* Pointers first. */\n  struct sljit_stack *stack;\n  PCRE2_SPTR str;\n  PCRE2_SPTR begin;\n  PCRE2_SPTR end;\n  pcre2_match_data *match_data;\n  PCRE2_SPTR startchar_ptr;\n  PCRE2_UCHAR *mark_ptr;\n  int (*callout)(pcre2_callout_block *, void *);\n  void *callout_data;\n  /* Everything else after. */\n  sljit_uw offset_limit;\n  sljit_u32 limit_match;\n  sljit_u32 oveccount;\n  sljit_u32 options;\n} jit_arguments;\n\n#define JIT_NUMBER_OF_COMPILE_MODES 3\n\ntypedef struct executable_functions {\n  void *executable_funcs[JIT_NUMBER_OF_COMPILE_MODES];\n  void *read_only_data_heads[JIT_NUMBER_OF_COMPILE_MODES];\n  sljit_uw executable_sizes[JIT_NUMBER_OF_COMPILE_MODES];\n  sljit_u32 top_bracket;\n  sljit_u32 limit_match;\n} executable_functions;\n\ntypedef struct jump_list {\n  struct sljit_jump *jump;\n  struct jump_list *next;\n} jump_list;\n\ntypedef struct stub_list {\n  struct sljit_jump *start;\n  struct sljit_label *quit;\n  struct stub_list *next;\n} stub_list;\n\nenum frame_types {\n  no_frame = -1,\n  no_stack = -2\n};\n\nenum control_types {\n  type_mark = 0,\n  type_then_trap = 1\n};\n\nenum  early_fail_types {\n  type_skip = 0,\n  type_fail = 1,\n  type_fail_range = 2\n};\n\ntypedef int (SLJIT_FUNC *jit_function)(jit_arguments *args);\n\n/* The following structure is the key data type for the recursive\ncode generator. It is allocated by compile_matchingpath, and contains\nthe arguments for compile_backtrackingpath. Must be the first member\nof its descendants. */\ntypedef struct backtrack_common {\n  /* Concatenation stack. */\n  struct backtrack_common *prev;\n  jump_list *nextbacktracks;\n  /* Internal stack (for component operators). */\n  struct backtrack_common *top;\n  jump_list *topbacktracks;\n  /* Opcode pointer. */\n  PCRE2_SPTR cc;\n} backtrack_common;\n\ntypedef struct assert_backtrack {\n  backtrack_common common;\n  jump_list *condfailed;\n  /* Less than 0 if a frame is not needed. */\n  int framesize;\n  /* Points to our private memory word on the stack. */\n  int private_data_ptr;\n  /* For iterators. */\n  struct sljit_label *matchingpath;\n} assert_backtrack;\n\ntypedef struct bracket_backtrack {\n  backtrack_common common;\n  /* Where to coninue if an alternative is successfully matched. */\n  struct sljit_label *alternative_matchingpath;\n  /* For rmin and rmax iterators. */\n  struct sljit_label *recursive_matchingpath;\n  /* For greedy ? operator. */\n  struct sljit_label *zero_matchingpath;\n  /* Contains the branches of a failed condition. */\n  union {\n    /* Both for OP_COND, OP_SCOND. */\n    jump_list *condfailed;\n    assert_backtrack *assert;\n    /* For OP_ONCE. Less than 0 if not needed. */\n    int framesize;\n    /* For brackets with >3 alternatives. */\n    struct sljit_put_label *matching_put_label;\n  } u;\n  /* Points to our private memory word on the stack. */\n  int private_data_ptr;\n} bracket_backtrack;\n\ntypedef struct bracketpos_backtrack {\n  backtrack_common common;\n  /* Points to our private memory word on the stack. */\n  int private_data_ptr;\n  /* Reverting stack is needed. */\n  int framesize;\n  /* Allocated stack size. */\n  int stacksize;\n} bracketpos_backtrack;\n\ntypedef struct braminzero_backtrack {\n  backtrack_common common;\n  struct sljit_label *matchingpath;\n} braminzero_backtrack;\n\ntypedef struct char_iterator_backtrack {\n  backtrack_common common;\n  /* Next iteration. */\n  struct sljit_label *matchingpath;\n  union {\n    jump_list *backtracks;\n    struct {\n      unsigned int othercasebit;\n      PCRE2_UCHAR chr;\n      BOOL enabled;\n    } charpos;\n  } u;\n} char_iterator_backtrack;\n\ntypedef struct ref_iterator_backtrack {\n  backtrack_common common;\n  /* Next iteration. */\n  struct sljit_label *matchingpath;\n} ref_iterator_backtrack;\n\ntypedef struct recurse_entry {\n  struct recurse_entry *next;\n  /* Contains the function entry label. */\n  struct sljit_label *entry_label;\n  /* Contains the function entry label. */\n  struct sljit_label *backtrack_label;\n  /* Collects the entry calls until the function is not created. */\n  jump_list *entry_calls;\n  /* Collects the backtrack calls until the function is not created. */\n  jump_list *backtrack_calls;\n  /* Points to the starting opcode. */\n  sljit_sw start;\n} recurse_entry;\n\ntypedef struct recurse_backtrack {\n  backtrack_common common;\n  /* Return to the matching path. */\n  struct sljit_label *matchingpath;\n  /* Recursive pattern. */\n  recurse_entry *entry;\n  /* Pattern is inlined. */\n  BOOL inlined_pattern;\n} recurse_backtrack;\n\n#define OP_THEN_TRAP OP_TABLE_LENGTH\n\ntypedef struct then_trap_backtrack {\n  backtrack_common common;\n  /* If then_trap is not NULL, this structure contains the real\n  then_trap for the backtracking path. */\n  struct then_trap_backtrack *then_trap;\n  /* Points to the starting opcode. */\n  sljit_sw start;\n  /* Exit point for the then opcodes of this alternative. */\n  jump_list *quit;\n  /* Frame size of the current alternative. */\n  int framesize;\n} then_trap_backtrack;\n\n#define MAX_N_CHARS 12\n#define MAX_DIFF_CHARS 5\n\ntypedef struct fast_forward_char_data {\n  /* Number of characters in the chars array, 255 for any character. */\n  sljit_u8 count;\n  /* Number of last UTF-8 characters in the chars array. */\n  sljit_u8 last_count;\n  /* Available characters in the current position. */\n  PCRE2_UCHAR chars[MAX_DIFF_CHARS];\n} fast_forward_char_data;\n\n#define MAX_CLASS_RANGE_SIZE 4\n#define MAX_CLASS_CHARS_SIZE 3\n\ntypedef struct compiler_common {\n  /* The sljit ceneric compiler. */\n  struct sljit_compiler *compiler;\n  /* Compiled regular expression. */\n  pcre2_real_code *re;\n  /* First byte code. */\n  PCRE2_SPTR start;\n  /* Maps private data offset to each opcode. */\n  sljit_s32 *private_data_ptrs;\n  /* Chain list of read-only data ptrs. */\n  void *read_only_data_head;\n  /* Tells whether the capturing bracket is optimized. */\n  sljit_u8 *optimized_cbracket;\n  /* Tells whether the starting offset is a target of then. */\n  sljit_u8 *then_offsets;\n  /* Current position where a THEN must jump. */\n  then_trap_backtrack *then_trap;\n  /* Starting offset of private data for capturing brackets. */\n  sljit_s32 cbra_ptr;\n  /* Output vector starting point. Must be divisible by 2. */\n  sljit_s32 ovector_start;\n  /* Points to the starting character of the current match. */\n  sljit_s32 start_ptr;\n  /* Last known position of the requested byte. */\n  sljit_s32 req_char_ptr;\n  /* Head of the last recursion. */\n  sljit_s32 recursive_head_ptr;\n  /* First inspected character for partial matching.\n     (Needed for avoiding zero length partial matches.) */\n  sljit_s32 start_used_ptr;\n  /* Starting pointer for partial soft matches. */\n  sljit_s32 hit_start;\n  /* Pointer of the match end position. */\n  sljit_s32 match_end_ptr;\n  /* Points to the marked string. */\n  sljit_s32 mark_ptr;\n  /* Recursive control verb management chain. */\n  sljit_s32 control_head_ptr;\n  /* Points to the last matched capture block index. */\n  sljit_s32 capture_last_ptr;\n  /* Fast forward skipping byte code pointer. */\n  PCRE2_SPTR fast_forward_bc_ptr;\n  /* Locals used by fast fail optimization. */\n  sljit_s32 early_fail_start_ptr;\n  sljit_s32 early_fail_end_ptr;\n\n  /* Flipped and lower case tables. */\n  const sljit_u8 *fcc;\n  sljit_sw lcc;\n  /* Mode can be PCRE2_JIT_COMPLETE and others. */\n  int mode;\n  /* TRUE, when empty match is accepted for partial matching. */\n  BOOL allow_empty_partial;\n  /* TRUE, when minlength is greater than 0. */\n  BOOL might_be_empty;\n  /* \\K is found in the pattern. */\n  BOOL has_set_som;\n  /* (*SKIP:arg) is found in the pattern. */\n  BOOL has_skip_arg;\n  /* (*THEN) is found in the pattern. */\n  BOOL has_then;\n  /* (*SKIP) or (*SKIP:arg) is found in lookbehind assertion. */\n  BOOL has_skip_in_assert_back;\n  /* Quit is redirected by recurse, negative assertion, or positive assertion in conditional block. */\n  BOOL local_quit_available;\n  /* Currently in a positive assertion. */\n  BOOL in_positive_assertion;\n  /* Newline control. */\n  int nltype;\n  sljit_u32 nlmax;\n  sljit_u32 nlmin;\n  int newline;\n  int bsr_nltype;\n  sljit_u32 bsr_nlmax;\n  sljit_u32 bsr_nlmin;\n  /* Dollar endonly. */\n  int endonly;\n  /* Tables. */\n  sljit_sw ctypes;\n  /* Named capturing brackets. */\n  PCRE2_SPTR name_table;\n  sljit_sw name_count;\n  sljit_sw name_entry_size;\n\n  /* Labels and jump lists. */\n  struct sljit_label *partialmatchlabel;\n  struct sljit_label *quit_label;\n  struct sljit_label *abort_label;\n  struct sljit_label *accept_label;\n  struct sljit_label *ff_newline_shortcut;\n  stub_list *stubs;\n  recurse_entry *entries;\n  recurse_entry *currententry;\n  jump_list *partialmatch;\n  jump_list *quit;\n  jump_list *positive_assertion_quit;\n  jump_list *abort;\n  jump_list *failed_match;\n  jump_list *accept;\n  jump_list *calllimit;\n  jump_list *stackalloc;\n  jump_list *revertframes;\n  jump_list *wordboundary;\n  jump_list *anynewline;\n  jump_list *hspace;\n  jump_list *vspace;\n  jump_list *casefulcmp;\n  jump_list *caselesscmp;\n  jump_list *reset_match;\n  BOOL unset_backref;\n  BOOL alt_circumflex;\n#ifdef SUPPORT_UNICODE\n  BOOL utf;\n  BOOL invalid_utf;\n  BOOL ucp;\n  /* Points to saving area for iref. */\n  sljit_s32 iref_ptr;\n  jump_list *getucd;\n  jump_list *getucdtype;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  jump_list *utfreadchar;\n  jump_list *utfreadtype8;\n  jump_list *utfpeakcharback;\n#endif\n#if PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16\n  jump_list *utfreadchar_invalid;\n  jump_list *utfreadnewline_invalid;\n  jump_list *utfmoveback_invalid;\n  jump_list *utfpeakcharback_invalid;\n#endif\n#endif /* SUPPORT_UNICODE */\n} compiler_common;\n\n/* For byte_sequence_compare. */\n\ntypedef struct compare_context {\n  int length;\n  int sourcereg;\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  int ucharptr;\n  union {\n    sljit_s32 asint;\n    sljit_u16 asushort;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    sljit_u8 asbyte;\n    sljit_u8 asuchars[4];\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n    sljit_u16 asuchars[2];\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n    sljit_u32 asuchars[1];\n#endif\n  } c;\n  union {\n    sljit_s32 asint;\n    sljit_u16 asushort;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    sljit_u8 asbyte;\n    sljit_u8 asuchars[4];\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n    sljit_u16 asuchars[2];\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n    sljit_u32 asuchars[1];\n#endif\n  } oc;\n#endif\n} compare_context;\n\n/* Undefine sljit macros. */\n#undef CMP\n\n/* Used for accessing the elements of the stack. */\n#define STACK(i)      ((i) * (int)sizeof(sljit_sw))\n\n#ifdef SLJIT_PREF_SHIFT_REG\n#if SLJIT_PREF_SHIFT_REG == SLJIT_R2\n/* Nothing. */\n#elif SLJIT_PREF_SHIFT_REG == SLJIT_R3\n#define SHIFT_REG_IS_R3\n#else\n#error \"Unsupported shift register\"\n#endif\n#endif\n\n#define TMP1          SLJIT_R0\n#ifdef SHIFT_REG_IS_R3\n#define TMP2          SLJIT_R3\n#define TMP3          SLJIT_R2\n#else\n#define TMP2          SLJIT_R2\n#define TMP3          SLJIT_R3\n#endif\n#define STR_PTR       SLJIT_R1\n#define STR_END       SLJIT_S0\n#define STACK_TOP     SLJIT_S1\n#define STACK_LIMIT   SLJIT_S2\n#define COUNT_MATCH   SLJIT_S3\n#define ARGUMENTS     SLJIT_S4\n#define RETURN_ADDR   SLJIT_R4\n\n#if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)\n#define HAS_VIRTUAL_REGISTERS 1\n#else\n#define HAS_VIRTUAL_REGISTERS 0\n#endif\n\n/* Local space layout. */\n/* These two locals can be used by the current opcode. */\n#define LOCALS0          (0 * sizeof(sljit_sw))\n#define LOCALS1          (1 * sizeof(sljit_sw))\n/* Two local variables for possessive quantifiers (char1 cannot use them). */\n#define POSSESSIVE0      (2 * sizeof(sljit_sw))\n#define POSSESSIVE1      (3 * sizeof(sljit_sw))\n/* Max limit of recursions. */\n#define LIMIT_MATCH      (4 * sizeof(sljit_sw))\n/* The output vector is stored on the stack, and contains pointers\nto characters. The vector data is divided into two groups: the first\ngroup contains the start / end character pointers, and the second is\nthe start pointers when the end of the capturing group has not yet reached. */\n#define OVECTOR_START    (common->ovector_start)\n#define OVECTOR(i)       (OVECTOR_START + (i) * (sljit_sw)sizeof(sljit_sw))\n#define OVECTOR_PRIV(i)  (common->cbra_ptr + (i) * (sljit_sw)sizeof(sljit_sw))\n#define PRIVATE_DATA(cc) (common->private_data_ptrs[(cc) - common->start])\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n#define MOV_UCHAR  SLJIT_MOV_U8\n#define IN_UCHARS(x) (x)\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n#define MOV_UCHAR  SLJIT_MOV_U16\n#define UCHAR_SHIFT (1)\n#define IN_UCHARS(x) ((x) * 2)\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n#define MOV_UCHAR  SLJIT_MOV_U32\n#define UCHAR_SHIFT (2)\n#define IN_UCHARS(x) ((x) * 4)\n#else\n#error Unsupported compiling mode\n#endif\n\n/* Shortcuts. */\n#define DEFINE_COMPILER \\\n  struct sljit_compiler *compiler = common->compiler\n#define OP1(op, dst, dstw, src, srcw) \\\n  sljit_emit_op1(compiler, (op), (dst), (dstw), (src), (srcw))\n#define OP2(op, dst, dstw, src1, src1w, src2, src2w) \\\n  sljit_emit_op2(compiler, (op), (dst), (dstw), (src1), (src1w), (src2), (src2w))\n#define OP2U(op, src1, src1w, src2, src2w) \\\n  sljit_emit_op2u(compiler, (op), (src1), (src1w), (src2), (src2w))\n#define OP_SRC(op, src, srcw) \\\n  sljit_emit_op_src(compiler, (op), (src), (srcw))\n#define LABEL() \\\n  sljit_emit_label(compiler)\n#define JUMP(type) \\\n  sljit_emit_jump(compiler, (type))\n#define JUMPTO(type, label) \\\n  sljit_set_label(sljit_emit_jump(compiler, (type)), (label))\n#define JUMPHERE(jump) \\\n  sljit_set_label((jump), sljit_emit_label(compiler))\n#define SET_LABEL(jump, label) \\\n  sljit_set_label((jump), (label))\n#define CMP(type, src1, src1w, src2, src2w) \\\n  sljit_emit_cmp(compiler, (type), (src1), (src1w), (src2), (src2w))\n#define CMPTO(type, src1, src1w, src2, src2w, label) \\\n  sljit_set_label(sljit_emit_cmp(compiler, (type), (src1), (src1w), (src2), (src2w)), (label))\n#define OP_FLAGS(op, dst, dstw, type) \\\n  sljit_emit_op_flags(compiler, (op), (dst), (dstw), (type))\n#define CMOV(type, dst_reg, src, srcw) \\\n  sljit_emit_cmov(compiler, (type), (dst_reg), (src), (srcw))\n#define GET_LOCAL_BASE(dst, dstw, offset) \\\n  sljit_get_local_base(compiler, (dst), (dstw), (offset))\n\n#define READ_CHAR_MAX 0x7fffffff\n\n#define INVALID_UTF_CHAR -1\n#define UNASSIGNED_UTF_CHAR 888\n\n#if defined SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\n\n#define GETCHARINC_INVALID(c, ptr, end, invalid_action) \\\n  { \\\n  if (ptr[0] <= 0x7f) \\\n    c = *ptr++; \\\n  else if (ptr + 1 < end && ptr[1] >= 0x80 && ptr[1] < 0xc0) \\\n    { \\\n    c = ptr[1] - 0x80; \\\n    \\\n    if (ptr[0] >= 0xc2 && ptr[0] <= 0xdf) \\\n      { \\\n      c |= (ptr[0] - 0xc0) << 6; \\\n      ptr += 2; \\\n      } \\\n    else if (ptr + 2 < end && ptr[2] >= 0x80 && ptr[2] < 0xc0) \\\n      { \\\n      c = c << 6 | (ptr[2] - 0x80); \\\n      \\\n      if (ptr[0] >= 0xe0 && ptr[0] <= 0xef) \\\n        { \\\n        c |= (ptr[0] - 0xe0) << 12; \\\n        ptr += 3; \\\n        \\\n        if (c < 0x800 || (c >= 0xd800 && c < 0xe000)) \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else if (ptr + 3 < end && ptr[3] >= 0x80 && ptr[3] < 0xc0) \\\n        { \\\n        c = c << 6 | (ptr[3] - 0x80); \\\n        \\\n        if (ptr[0] >= 0xf0 && ptr[0] <= 0xf4) \\\n          { \\\n          c |= (ptr[0] - 0xf0) << 18; \\\n          ptr += 4; \\\n          \\\n          if (c >= 0x110000 || c < 0x10000) \\\n            { \\\n            invalid_action; \\\n            } \\\n          } \\\n        else \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else \\\n        { \\\n        invalid_action; \\\n        } \\\n      } \\\n    else \\\n      { \\\n      invalid_action; \\\n      } \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#define GETCHARBACK_INVALID(c, ptr, start, invalid_action) \\\n  { \\\n  c = ptr[-1]; \\\n  if (c <= 0x7f) \\\n    ptr--; \\\n  else if (ptr - 1 > start && ptr[-1] >= 0x80 && ptr[-1] < 0xc0) \\\n    { \\\n    c -= 0x80; \\\n    \\\n    if (ptr[-2] >= 0xc2 && ptr[-2] <= 0xdf) \\\n      { \\\n      c |= (ptr[-2] - 0xc0) << 6; \\\n      ptr -= 2; \\\n      } \\\n    else if (ptr - 2 > start && ptr[-2] >= 0x80 && ptr[-2] < 0xc0) \\\n      { \\\n      c = c << 6 | (ptr[-2] - 0x80); \\\n      \\\n      if (ptr[-3] >= 0xe0 && ptr[-3] <= 0xef) \\\n        { \\\n        c |= (ptr[-3] - 0xe0) << 12; \\\n        ptr -= 3; \\\n        \\\n        if (c < 0x800 || (c >= 0xd800 && c < 0xe000)) \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else if (ptr - 3 > start && ptr[-3] >= 0x80 && ptr[-3] < 0xc0) \\\n        { \\\n        c = c << 6 | (ptr[-3] - 0x80); \\\n        \\\n        if (ptr[-4] >= 0xf0 && ptr[-4] <= 0xf4) \\\n          { \\\n          c |= (ptr[-4] - 0xf0) << 18; \\\n          ptr -= 4; \\\n          \\\n          if (c >= 0x110000 || c < 0x10000) \\\n            { \\\n            invalid_action; \\\n            } \\\n          } \\\n        else \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else \\\n        { \\\n        invalid_action; \\\n        } \\\n      } \\\n    else \\\n      { \\\n      invalid_action; \\\n      } \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n\n#define GETCHARINC_INVALID(c, ptr, end, invalid_action) \\\n  { \\\n  if (ptr[0] < 0xd800 || ptr[0] >= 0xe000) \\\n    c = *ptr++; \\\n  else if (ptr[0] < 0xdc00 && ptr + 1 < end && ptr[1] >= 0xdc00 && ptr[1] < 0xe000) \\\n    { \\\n    c = (((ptr[0] - 0xd800) << 10) | (ptr[1] - 0xdc00)) + 0x10000; \\\n    ptr += 2; \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#define GETCHARBACK_INVALID(c, ptr, start, invalid_action) \\\n  { \\\n  c = ptr[-1]; \\\n  if (c < 0xd800 || c >= 0xe000) \\\n    ptr--; \\\n  else if (c >= 0xdc00 && ptr - 1 > start && ptr[-2] >= 0xd800 && ptr[-2] < 0xdc00) \\\n    { \\\n    c = (((ptr[-2] - 0xd800) << 10) | (c - 0xdc00)) + 0x10000; \\\n    ptr -= 2; \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n\n#define GETCHARINC_INVALID(c, ptr, end, invalid_action) \\\n  { \\\n  if (ptr[0] < 0xd800 || (ptr[0] >= 0xe000 && ptr[0] < 0x110000)) \\\n    c = *ptr++; \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#define GETCHARBACK_INVALID(c, ptr, start, invalid_action) \\\n  { \\\n  c = ptr[-1]; \\\n  if (ptr[-1] < 0xd800 || (ptr[-1] >= 0xe000 && ptr[-1] < 0x110000)) \\\n    ptr--; \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n\nstatic PCRE2_SPTR bracketend(PCRE2_SPTR cc)\n{\nSLJIT_ASSERT((*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA) || (*cc >= OP_ONCE && *cc <= OP_SCOND));\ndo cc += GET(cc, 1); while (*cc == OP_ALT);\nSLJIT_ASSERT(*cc >= OP_KET && *cc <= OP_KETRPOS);\ncc += 1 + LINK_SIZE;\nreturn cc;\n}\n\nstatic int no_alternatives(PCRE2_SPTR cc)\n{\nint count = 0;\nSLJIT_ASSERT((*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA) || (*cc >= OP_ONCE && *cc <= OP_SCOND));\ndo\n  {\n  cc += GET(cc, 1);\n  count++;\n  }\nwhile (*cc == OP_ALT);\nSLJIT_ASSERT(*cc >= OP_KET && *cc <= OP_KETRPOS);\nreturn count;\n}\n\n/* Functions whose might need modification for all new supported opcodes:\n next_opcode\n check_opcode_types\n set_private_data_ptrs\n get_framesize\n init_frame\n get_recurse_data_length\n copy_recurse_data\n compile_matchingpath\n compile_backtrackingpath\n*/\n\nstatic PCRE2_SPTR next_opcode(compiler_common *common, PCRE2_SPTR cc)\n{\nSLJIT_UNUSED_ARG(common);\nswitch(*cc)\n  {\n  case OP_SOD:\n  case OP_SOM:\n  case OP_SET_SOM:\n  case OP_NOT_WORD_BOUNDARY:\n  case OP_WORD_BOUNDARY:\n  case OP_NOT_DIGIT:\n  case OP_DIGIT:\n  case OP_NOT_WHITESPACE:\n  case OP_WHITESPACE:\n  case OP_NOT_WORDCHAR:\n  case OP_WORDCHAR:\n  case OP_ANY:\n  case OP_ALLANY:\n  case OP_NOTPROP:\n  case OP_PROP:\n  case OP_ANYNL:\n  case OP_NOT_HSPACE:\n  case OP_HSPACE:\n  case OP_NOT_VSPACE:\n  case OP_VSPACE:\n  case OP_EXTUNI:\n  case OP_EODN:\n  case OP_EOD:\n  case OP_CIRC:\n  case OP_CIRCM:\n  case OP_DOLL:\n  case OP_DOLLM:\n  case OP_CRSTAR:\n  case OP_CRMINSTAR:\n  case OP_CRPLUS:\n  case OP_CRMINPLUS:\n  case OP_CRQUERY:\n  case OP_CRMINQUERY:\n  case OP_CRRANGE:\n  case OP_CRMINRANGE:\n  case OP_CRPOSSTAR:\n  case OP_CRPOSPLUS:\n  case OP_CRPOSQUERY:\n  case OP_CRPOSRANGE:\n  case OP_CLASS:\n  case OP_NCLASS:\n  case OP_REF:\n  case OP_REFI:\n  case OP_DNREF:\n  case OP_DNREFI:\n  case OP_RECURSE:\n  case OP_CALLOUT:\n  case OP_ALT:\n  case OP_KET:\n  case OP_KETRMAX:\n  case OP_KETRMIN:\n  case OP_KETRPOS:\n  case OP_REVERSE:\n  case OP_ASSERT:\n  case OP_ASSERT_NOT:\n  case OP_ASSERTBACK:\n  case OP_ASSERTBACK_NOT:\n  case OP_ASSERT_NA:\n  case OP_ASSERTBACK_NA:\n  case OP_ONCE:\n  case OP_SCRIPT_RUN:\n  case OP_BRA:\n  case OP_BRAPOS:\n  case OP_CBRA:\n  case OP_CBRAPOS:\n  case OP_COND:\n  case OP_SBRA:\n  case OP_SBRAPOS:\n  case OP_SCBRA:\n  case OP_SCBRAPOS:\n  case OP_SCOND:\n  case OP_CREF:\n  case OP_DNCREF:\n  case OP_RREF:\n  case OP_DNRREF:\n  case OP_FALSE:\n  case OP_TRUE:\n  case OP_BRAZERO:\n  case OP_BRAMINZERO:\n  case OP_BRAPOSZERO:\n  case OP_PRUNE:\n  case OP_SKIP:\n  case OP_THEN:\n  case OP_COMMIT:\n  case OP_FAIL:\n  case OP_ACCEPT:\n  case OP_ASSERT_ACCEPT:\n  case OP_CLOSE:\n  case OP_SKIPZERO:\n  return cc + PRIV(OP_lengths)[*cc];\n\n  case OP_CHAR:\n  case OP_CHARI:\n  case OP_NOT:\n  case OP_NOTI:\n  case OP_STAR:\n  case OP_MINSTAR:\n  case OP_PLUS:\n  case OP_MINPLUS:\n  case OP_QUERY:\n  case OP_MINQUERY:\n  case OP_UPTO:\n  case OP_MINUPTO:\n  case OP_EXACT:\n  case OP_POSSTAR:\n  case OP_POSPLUS:\n  case OP_POSQUERY:\n  case OP_POSUPTO:\n  case OP_STARI:\n  case OP_MINSTARI:\n  case OP_PLUSI:\n  case OP_MINPLUSI:\n  case OP_QUERYI:\n  case OP_MINQUERYI:\n  case OP_UPTOI:\n  case OP_MINUPTOI:\n  case OP_EXACTI:\n  case OP_POSSTARI:\n  case OP_POSPLUSI:\n  case OP_POSQUERYI:\n  case OP_POSUPTOI:\n  case OP_NOTSTAR:\n  case OP_NOTMINSTAR:\n  case OP_NOTPLUS:\n  case OP_NOTMINPLUS:\n  case OP_NOTQUERY:\n  case OP_NOTMINQUERY:\n  case OP_NOTUPTO:\n  case OP_NOTMINUPTO:\n  case OP_NOTEXACT:\n  case OP_NOTPOSSTAR:\n  case OP_NOTPOSPLUS:\n  case OP_NOTPOSQUERY:\n  case OP_NOTPOSUPTO:\n  case OP_NOTSTARI:\n  case OP_NOTMINSTARI:\n  case OP_NOTPLUSI:\n  case OP_NOTMINPLUSI:\n  case OP_NOTQUERYI:\n  case OP_NOTMINQUERYI:\n  case OP_NOTUPTOI:\n  case OP_NOTMINUPTOI:\n  case OP_NOTEXACTI:\n  case OP_NOTPOSSTARI:\n  case OP_NOTPOSPLUSI:\n  case OP_NOTPOSQUERYI:\n  case OP_NOTPOSUPTOI:\n  cc += PRIV(OP_lengths)[*cc];\n#ifdef SUPPORT_UNICODE\n  if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n  return cc;\n\n  /* Special cases. */\n  case OP_TYPESTAR:\n  case OP_TYPEMINSTAR:\n  case OP_TYPEPLUS:\n  case OP_TYPEMINPLUS:\n  case OP_TYPEQUERY:\n  case OP_TYPEMINQUERY:\n  case OP_TYPEUPTO:\n  case OP_TYPEMINUPTO:\n  case OP_TYPEEXACT:\n  case OP_TYPEPOSSTAR:\n  case OP_TYPEPOSPLUS:\n  case OP_TYPEPOSQUERY:\n  case OP_TYPEPOSUPTO:\n  return cc + PRIV(OP_lengths)[*cc] - 1;\n\n  case OP_ANYBYTE:\n#ifdef SUPPORT_UNICODE\n  if (common->utf) return NULL;\n#endif\n  return cc + 1;\n\n  case OP_CALLOUT_STR:\n  return cc + GET(cc, 1 + 2*LINK_SIZE);\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n  case OP_XCLASS:\n  return cc + GET(cc, 1);\n#endif\n\n  case OP_MARK:\n  case OP_COMMIT_ARG:\n  case OP_PRUNE_ARG:\n  case OP_SKIP_ARG:\n  case OP_THEN_ARG:\n  return cc + 1 + 2 + cc[1];\n\n  default:\n  SLJIT_UNREACHABLE();\n  return NULL;\n  }\n}\n\nstatic BOOL check_opcode_types(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend)\n{\nint count;\nPCRE2_SPTR slot;\nPCRE2_SPTR assert_back_end = cc - 1;\nPCRE2_SPTR assert_na_end = cc - 1;\n\n/* Calculate important variables (like stack size) and checks whether all opcodes are supported. */\nwhile (cc < ccend)\n  {\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    common->has_set_som = TRUE;\n    common->might_be_empty = TRUE;\n    cc += 1;\n    break;\n\n    case OP_REFI:\n#ifdef SUPPORT_UNICODE\n    if (common->iref_ptr == 0)\n      {\n      common->iref_ptr = common->ovector_start;\n      common->ovector_start += 3 * sizeof(sljit_sw);\n      }\n#endif /* SUPPORT_UNICODE */\n    /* Fall through. */\n    case OP_REF:\n    common->optimized_cbracket[GET2(cc, 1)] = 0;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    slot = bracketend(cc);\n    if (slot > assert_na_end)\n      assert_na_end = slot;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] = 0;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    case OP_SCOND:\n    /* Only AUTO_CALLOUT can insert this opcode. We do\n       not intend to support this case. */\n    if (cc[1 + LINK_SIZE] == OP_CALLOUT || cc[1 + LINK_SIZE] == OP_CALLOUT_STR)\n      return FALSE;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CREF:\n    common->optimized_cbracket[GET2(cc, 1)] = 0;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_DNREF:\n    case OP_DNREFI:\n    case OP_DNCREF:\n    count = GET2(cc, 1 + IMM2_SIZE);\n    slot = common->name_table + GET2(cc, 1) * common->name_entry_size;\n    while (count-- > 0)\n      {\n      common->optimized_cbracket[GET2(slot, 0)] = 0;\n      slot += common->name_entry_size;\n      }\n    cc += 1 + 2 * IMM2_SIZE;\n    break;\n\n    case OP_RECURSE:\n    /* Set its value only once. */\n    if (common->recursive_head_ptr == 0)\n      {\n      common->recursive_head_ptr = common->ovector_start;\n      common->ovector_start += sizeof(sljit_sw);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n    if (common->capture_last_ptr == 0)\n      {\n      common->capture_last_ptr = common->ovector_start;\n      common->ovector_start += sizeof(sljit_sw);\n      }\n    cc += (*cc == OP_CALLOUT) ? PRIV(OP_lengths)[OP_CALLOUT] : GET(cc, 1 + 2*LINK_SIZE);\n    break;\n\n    case OP_ASSERTBACK:\n    slot = bracketend(cc);\n    if (slot > assert_back_end)\n      assert_back_end = slot;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_THEN_ARG:\n    common->has_then = TRUE;\n    common->control_head_ptr = 1;\n    /* Fall through. */\n\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    if (cc < assert_na_end)\n      return FALSE;\n    /* Fall through */\n    case OP_MARK:\n    if (common->mark_ptr == 0)\n      {\n      common->mark_ptr = common->ovector_start;\n      common->ovector_start += sizeof(sljit_sw);\n      }\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_THEN:\n    common->has_then = TRUE;\n    common->control_head_ptr = 1;\n    cc += 1;\n    break;\n\n    case OP_SKIP:\n    if (cc < assert_back_end)\n      common->has_skip_in_assert_back = TRUE;\n    if (cc < assert_na_end)\n      return FALSE;\n    cc += 1;\n    break;\n\n    case OP_SKIP_ARG:\n    common->control_head_ptr = 1;\n    common->has_skip_arg = TRUE;\n    if (cc < assert_back_end)\n      common->has_skip_in_assert_back = TRUE;\n    if (cc < assert_na_end)\n      return FALSE;\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_PRUNE:\n    case OP_COMMIT:\n    case OP_ASSERT_ACCEPT:\n    if (cc < assert_na_end)\n      return FALSE;\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    if (cc == NULL)\n      return FALSE;\n    break;\n    }\n  }\nreturn TRUE;\n}\n\n#define EARLY_FAIL_ENHANCE_MAX (1 + 3)\n\n/*\nstart:\n  0 - skip / early fail allowed\n  1 - only early fail with range allowed\n  >1 - (start - 1) early fail is processed\n\nreturn: current number of iterators enhanced with fast fail\n*/\nstatic int detect_early_fail(compiler_common *common, PCRE2_SPTR cc, int *private_data_start,\n   sljit_s32 depth, int start, BOOL fast_forward_allowed)\n{\nPCRE2_SPTR begin = cc;\nPCRE2_SPTR next_alt;\nPCRE2_SPTR end;\nPCRE2_SPTR accelerated_start;\nBOOL prev_fast_forward_allowed;\nint result = 0;\nint count;\n\nSLJIT_ASSERT(*cc == OP_ONCE || *cc == OP_BRA || *cc == OP_CBRA);\nSLJIT_ASSERT(*cc != OP_CBRA || common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] != 0);\nSLJIT_ASSERT(start < EARLY_FAIL_ENHANCE_MAX);\n\nnext_alt = cc + GET(cc, 1);\nif (*next_alt == OP_ALT)\n  fast_forward_allowed = FALSE;\n\ndo\n  {\n  count = start;\n  cc += 1 + LINK_SIZE + ((*cc == OP_CBRA) ? IMM2_SIZE : 0);\n\n  while (TRUE)\n    {\n    accelerated_start = NULL;\n\n    switch(*cc)\n      {\n      case OP_SOD:\n      case OP_SOM:\n      case OP_SET_SOM:\n      case OP_NOT_WORD_BOUNDARY:\n      case OP_WORD_BOUNDARY:\n      case OP_EODN:\n      case OP_EOD:\n      case OP_CIRC:\n      case OP_CIRCM:\n      case OP_DOLL:\n      case OP_DOLLM:\n      /* Zero width assertions. */\n      cc++;\n      continue;\n\n      case OP_NOT_DIGIT:\n      case OP_DIGIT:\n      case OP_NOT_WHITESPACE:\n      case OP_WHITESPACE:\n      case OP_NOT_WORDCHAR:\n      case OP_WORDCHAR:\n      case OP_ANY:\n      case OP_ALLANY:\n      case OP_ANYBYTE:\n      case OP_NOT_HSPACE:\n      case OP_HSPACE:\n      case OP_NOT_VSPACE:\n      case OP_VSPACE:\n      fast_forward_allowed = FALSE;\n      cc++;\n      continue;\n\n      case OP_ANYNL:\n      case OP_EXTUNI:\n      fast_forward_allowed = FALSE;\n      if (count == 0)\n        count = 1;\n      cc++;\n      continue;\n\n      case OP_NOTPROP:\n      case OP_PROP:\n      fast_forward_allowed = FALSE;\n      cc += 1 + 2;\n      continue;\n\n      case OP_CHAR:\n      case OP_CHARI:\n      case OP_NOT:\n      case OP_NOTI:\n      fast_forward_allowed = FALSE;\n      cc += 2;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n      continue;\n\n      case OP_TYPESTAR:\n      case OP_TYPEMINSTAR:\n      case OP_TYPEPLUS:\n      case OP_TYPEMINPLUS:\n      case OP_TYPEPOSSTAR:\n      case OP_TYPEPOSPLUS:\n      /* The type or prop opcode is skipped in the next iteration. */\n      cc += 1;\n\n      if (cc[0] != OP_ANYNL && cc[0] != OP_EXTUNI)\n        {\n        accelerated_start = cc - 1;\n        break;\n        }\n\n      if (count == 0)\n        count = 1;\n      fast_forward_allowed = FALSE;\n      continue;\n\n      case OP_TYPEUPTO:\n      case OP_TYPEMINUPTO:\n      case OP_TYPEEXACT:\n      case OP_TYPEPOSUPTO:\n      cc += IMM2_SIZE;\n      /* Fall through */\n\n      case OP_TYPEQUERY:\n      case OP_TYPEMINQUERY:\n      case OP_TYPEPOSQUERY:\n      /* The type or prop opcode is skipped in the next iteration. */\n      fast_forward_allowed = FALSE;\n      if (count == 0)\n        count = 1;\n      cc += 1;\n      continue;\n\n      case OP_STAR:\n      case OP_MINSTAR:\n      case OP_PLUS:\n      case OP_MINPLUS:\n      case OP_POSSTAR:\n      case OP_POSPLUS:\n\n      case OP_STARI:\n      case OP_MINSTARI:\n      case OP_PLUSI:\n      case OP_MINPLUSI:\n      case OP_POSSTARI:\n      case OP_POSPLUSI:\n\n      case OP_NOTSTAR:\n      case OP_NOTMINSTAR:\n      case OP_NOTPLUS:\n      case OP_NOTMINPLUS:\n      case OP_NOTPOSSTAR:\n      case OP_NOTPOSPLUS:\n\n      case OP_NOTSTARI:\n      case OP_NOTMINSTARI:\n      case OP_NOTPLUSI:\n      case OP_NOTMINPLUSI:\n      case OP_NOTPOSSTARI:\n      case OP_NOTPOSPLUSI:\n      accelerated_start = cc;\n      cc += 2;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n      break;\n\n      case OP_UPTO:\n      case OP_MINUPTO:\n      case OP_EXACT:\n      case OP_POSUPTO:\n      case OP_UPTOI:\n      case OP_MINUPTOI:\n      case OP_EXACTI:\n      case OP_POSUPTOI:\n      case OP_NOTUPTO:\n      case OP_NOTMINUPTO:\n      case OP_NOTEXACT:\n      case OP_NOTPOSUPTO:\n      case OP_NOTUPTOI:\n      case OP_NOTMINUPTOI:\n      case OP_NOTEXACTI:\n      case OP_NOTPOSUPTOI:\n      cc += IMM2_SIZE;\n      /* Fall through */\n\n      case OP_QUERY:\n      case OP_MINQUERY:\n      case OP_POSQUERY:\n      case OP_QUERYI:\n      case OP_MINQUERYI:\n      case OP_POSQUERYI:\n      case OP_NOTQUERY:\n      case OP_NOTMINQUERY:\n      case OP_NOTPOSQUERY:\n      case OP_NOTQUERYI:\n      case OP_NOTMINQUERYI:\n      case OP_NOTPOSQUERYI:\n      fast_forward_allowed = FALSE;\n      if (count == 0)\n        count = 1;\n      cc += 2;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n      continue;\n\n      case OP_CLASS:\n      case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n      case OP_XCLASS:\n      accelerated_start = cc;\n      cc += ((*cc == OP_XCLASS) ? GET(cc, 1) : (unsigned int)(1 + (32 / sizeof(PCRE2_UCHAR))));\n#else\n      accelerated_start = cc;\n      cc += (1 + (32 / sizeof(PCRE2_UCHAR)));\n#endif\n\n      switch (*cc)\n        {\n        case OP_CRSTAR:\n        case OP_CRMINSTAR:\n        case OP_CRPLUS:\n        case OP_CRMINPLUS:\n        case OP_CRPOSSTAR:\n        case OP_CRPOSPLUS:\n        cc++;\n        break;\n\n        case OP_CRRANGE:\n        case OP_CRMINRANGE:\n        case OP_CRPOSRANGE:\n        cc += 2 * IMM2_SIZE;\n        /* Fall through */\n        case OP_CRQUERY:\n        case OP_CRMINQUERY:\n        case OP_CRPOSQUERY:\n        cc++;\n        if (count == 0)\n          count = 1;\n        /* Fall through */\n        default:\n        accelerated_start = NULL;\n        fast_forward_allowed = FALSE;\n        continue;\n        }\n      break;\n\n      case OP_ONCE:\n      case OP_BRA:\n      case OP_CBRA:\n      end = cc + GET(cc, 1);\n\n      prev_fast_forward_allowed = fast_forward_allowed;\n      fast_forward_allowed = FALSE;\n      if (depth >= 4)\n        break;\n\n      end = bracketend(cc) - (1 + LINK_SIZE);\n      if (*end != OP_KET || (*cc == OP_CBRA && common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] == 0))\n        break;\n\n      count = detect_early_fail(common, cc, private_data_start, depth + 1, count, prev_fast_forward_allowed);\n\n      if (PRIVATE_DATA(cc) != 0)\n        common->private_data_ptrs[begin - common->start] = 1;\n\n      if (count < EARLY_FAIL_ENHANCE_MAX)\n        {\n        cc = end + (1 + LINK_SIZE);\n        continue;\n        }\n      break;\n\n      case OP_KET:\n      SLJIT_ASSERT(PRIVATE_DATA(cc) == 0);\n      if (cc >= next_alt)\n        break;\n      cc += 1 + LINK_SIZE;\n      continue;\n      }\n\n    if (accelerated_start != NULL)\n      {\n      if (count == 0)\n        {\n        count++;\n\n        if (fast_forward_allowed)\n          {\n          common->fast_forward_bc_ptr = accelerated_start;\n          common->private_data_ptrs[(accelerated_start + 1) - common->start] = ((*private_data_start) << 3) | type_skip;\n          *private_data_start += sizeof(sljit_sw);\n          }\n        else\n          {\n          common->private_data_ptrs[(accelerated_start + 1) - common->start] = ((*private_data_start) << 3) | type_fail;\n\n          if (common->early_fail_start_ptr == 0)\n            common->early_fail_start_ptr = *private_data_start;\n\n          *private_data_start += sizeof(sljit_sw);\n          common->early_fail_end_ptr = *private_data_start;\n\n          if (*private_data_start > SLJIT_MAX_LOCAL_SIZE)\n            return EARLY_FAIL_ENHANCE_MAX;\n          }\n        }\n      else\n        {\n        common->private_data_ptrs[(accelerated_start + 1) - common->start] = ((*private_data_start) << 3) | type_fail_range;\n\n        if (common->early_fail_start_ptr == 0)\n          common->early_fail_start_ptr = *private_data_start;\n\n        *private_data_start += 2 * sizeof(sljit_sw);\n        common->early_fail_end_ptr = *private_data_start;\n\n        if (*private_data_start > SLJIT_MAX_LOCAL_SIZE)\n          return EARLY_FAIL_ENHANCE_MAX;\n        }\n\n      /* Cannot be part of a repeat. */\n      common->private_data_ptrs[begin - common->start] = 1;\n      count++;\n\n      if (count < EARLY_FAIL_ENHANCE_MAX)\n        continue;\n      }\n\n    break;\n    }\n\n  if (*cc != OP_ALT && *cc != OP_KET)\n    result = EARLY_FAIL_ENHANCE_MAX;\n  else if (result < count)\n    result = count;\n\n  cc = next_alt;\n  next_alt = cc + GET(cc, 1);\n  }\nwhile (*cc == OP_ALT);\n\nreturn result;\n}\n\nstatic int get_class_iterator_size(PCRE2_SPTR cc)\n{\nsljit_u32 min;\nsljit_u32 max;\nswitch(*cc)\n  {\n  case OP_CRSTAR:\n  case OP_CRPLUS:\n  return 2;\n\n  case OP_CRMINSTAR:\n  case OP_CRMINPLUS:\n  case OP_CRQUERY:\n  case OP_CRMINQUERY:\n  return 1;\n\n  case OP_CRRANGE:\n  case OP_CRMINRANGE:\n  min = GET2(cc, 1);\n  max = GET2(cc, 1 + IMM2_SIZE);\n  if (max == 0)\n    return (*cc == OP_CRRANGE) ? 2 : 1;\n  max -= min;\n  if (max > 2)\n    max = 2;\n  return max;\n\n  default:\n  return 0;\n  }\n}\n\nstatic BOOL detect_repeat(compiler_common *common, PCRE2_SPTR begin)\n{\nPCRE2_SPTR end = bracketend(begin);\nPCRE2_SPTR next;\nPCRE2_SPTR next_end;\nPCRE2_SPTR max_end;\nPCRE2_UCHAR type;\nsljit_sw length = end - begin;\nsljit_s32 min, max, i;\n\n/* Detect fixed iterations first. */\nif (end[-(1 + LINK_SIZE)] != OP_KET || PRIVATE_DATA(begin) != 0)\n  return FALSE;\n\n/* /(?:AB){4,6}/ is currently converted to /(?:AB){3}(?AB){1,3}/\n * Skip the check of the second part. */\nif (PRIVATE_DATA(end - LINK_SIZE) != 0)\n  return TRUE;\n\nnext = end;\nmin = 1;\nwhile (1)\n  {\n  if (*next != *begin)\n    break;\n  next_end = bracketend(next);\n  if (next_end - next != length || memcmp(begin, next, IN_UCHARS(length)) != 0)\n    break;\n  next = next_end;\n  min++;\n  }\n\nif (min == 2)\n  return FALSE;\n\nmax = 0;\nmax_end = next;\nif (*next == OP_BRAZERO || *next == OP_BRAMINZERO)\n  {\n  type = *next;\n  while (1)\n    {\n    if (next[0] != type || next[1] != OP_BRA || next[2 + LINK_SIZE] != *begin)\n      break;\n    next_end = bracketend(next + 2 + LINK_SIZE);\n    if (next_end - next != (length + 2 + LINK_SIZE) || memcmp(begin, next + 2 + LINK_SIZE, IN_UCHARS(length)) != 0)\n      break;\n    next = next_end;\n    max++;\n    }\n\n  if (next[0] == type && next[1] == *begin && max >= 1)\n    {\n    next_end = bracketend(next + 1);\n    if (next_end - next == (length + 1) && memcmp(begin, next + 1, IN_UCHARS(length)) == 0)\n      {\n      for (i = 0; i < max; i++, next_end += 1 + LINK_SIZE)\n        if (*next_end != OP_KET)\n          break;\n\n      if (i == max)\n        {\n        common->private_data_ptrs[max_end - common->start - LINK_SIZE] = next_end - max_end;\n        common->private_data_ptrs[max_end - common->start - LINK_SIZE + 1] = (type == OP_BRAZERO) ? OP_UPTO : OP_MINUPTO;\n        /* +2 the original and the last. */\n        common->private_data_ptrs[max_end - common->start - LINK_SIZE + 2] = max + 2;\n        if (min == 1)\n          return TRUE;\n        min--;\n        max_end -= (1 + LINK_SIZE) + GET(max_end, -LINK_SIZE);\n        }\n      }\n    }\n  }\n\nif (min >= 3)\n  {\n  common->private_data_ptrs[end - common->start - LINK_SIZE] = max_end - end;\n  common->private_data_ptrs[end - common->start - LINK_SIZE + 1] = OP_EXACT;\n  common->private_data_ptrs[end - common->start - LINK_SIZE + 2] = min;\n  return TRUE;\n  }\n\nreturn FALSE;\n}\n\n#define CASE_ITERATOR_PRIVATE_DATA_1 \\\n    case OP_MINSTAR: \\\n    case OP_MINPLUS: \\\n    case OP_QUERY: \\\n    case OP_MINQUERY: \\\n    case OP_MINSTARI: \\\n    case OP_MINPLUSI: \\\n    case OP_QUERYI: \\\n    case OP_MINQUERYI: \\\n    case OP_NOTMINSTAR: \\\n    case OP_NOTMINPLUS: \\\n    case OP_NOTQUERY: \\\n    case OP_NOTMINQUERY: \\\n    case OP_NOTMINSTARI: \\\n    case OP_NOTMINPLUSI: \\\n    case OP_NOTQUERYI: \\\n    case OP_NOTMINQUERYI:\n\n#define CASE_ITERATOR_PRIVATE_DATA_2A \\\n    case OP_STAR: \\\n    case OP_PLUS: \\\n    case OP_STARI: \\\n    case OP_PLUSI: \\\n    case OP_NOTSTAR: \\\n    case OP_NOTPLUS: \\\n    case OP_NOTSTARI: \\\n    case OP_NOTPLUSI:\n\n#define CASE_ITERATOR_PRIVATE_DATA_2B \\\n    case OP_UPTO: \\\n    case OP_MINUPTO: \\\n    case OP_UPTOI: \\\n    case OP_MINUPTOI: \\\n    case OP_NOTUPTO: \\\n    case OP_NOTMINUPTO: \\\n    case OP_NOTUPTOI: \\\n    case OP_NOTMINUPTOI:\n\n#define CASE_ITERATOR_TYPE_PRIVATE_DATA_1 \\\n    case OP_TYPEMINSTAR: \\\n    case OP_TYPEMINPLUS: \\\n    case OP_TYPEQUERY: \\\n    case OP_TYPEMINQUERY:\n\n#define CASE_ITERATOR_TYPE_PRIVATE_DATA_2A \\\n    case OP_TYPESTAR: \\\n    case OP_TYPEPLUS:\n\n#define CASE_ITERATOR_TYPE_PRIVATE_DATA_2B \\\n    case OP_TYPEUPTO: \\\n    case OP_TYPEMINUPTO:\n\nstatic void set_private_data_ptrs(compiler_common *common, int *private_data_start, PCRE2_SPTR ccend)\n{\nPCRE2_SPTR cc = common->start;\nPCRE2_SPTR alternative;\nPCRE2_SPTR end = NULL;\nint private_data_ptr = *private_data_start;\nint space, size, bracketlen;\nBOOL repeat_check = TRUE;\n\nwhile (cc < ccend)\n  {\n  space = 0;\n  size = 0;\n  bracketlen = 0;\n  if (private_data_ptr > SLJIT_MAX_LOCAL_SIZE)\n    break;\n\n  /* When the bracket is prefixed by a zero iteration, skip the repeat check (at this point). */\n  if (repeat_check && (*cc == OP_ONCE || *cc == OP_BRA || *cc == OP_CBRA || *cc == OP_COND))\n    {\n    if (detect_repeat(common, cc))\n      {\n      /* These brackets are converted to repeats, so no global\n      based single character repeat is allowed. */\n      if (cc >= end)\n        end = bracketend(cc);\n      }\n    }\n  repeat_check = TRUE;\n\n  switch(*cc)\n    {\n    case OP_KET:\n    if (common->private_data_ptrs[cc + 1 - common->start] != 0)\n      {\n      common->private_data_ptrs[cc - common->start] = private_data_ptr;\n      private_data_ptr += sizeof(sljit_sw);\n      cc += common->private_data_ptrs[cc + 1 - common->start];\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    common->private_data_ptrs[cc - common->start] = private_data_ptr;\n    private_data_ptr += sizeof(sljit_sw);\n    bracketlen = 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    common->private_data_ptrs[cc - common->start] = private_data_ptr;\n    private_data_ptr += sizeof(sljit_sw);\n    bracketlen = 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    common->private_data_ptrs[cc - common->start] = 0;\n    alternative = cc + GET(cc, 1);\n    if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n      {\n      common->private_data_ptrs[cc - common->start] = private_data_ptr;\n      private_data_ptr += sizeof(sljit_sw);\n      }\n    bracketlen = 1 + LINK_SIZE;\n    break;\n\n    case OP_BRA:\n    bracketlen = 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    bracketlen = 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_BRAZERO:\n    case OP_BRAMINZERO:\n    case OP_BRAPOSZERO:\n    size = 1;\n    repeat_check = FALSE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    size = -2;\n    space = 1;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    size = -2;\n    space = 2;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    size = -(2 + IMM2_SIZE);\n    space = 2;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    size = 1;\n    space = 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    size = 1;\n    if (cc[1] != OP_ANYNL && cc[1] != OP_EXTUNI)\n      space = 2;\n    break;\n\n    case OP_TYPEUPTO:\n    size = 1 + IMM2_SIZE;\n    if (cc[1 + IMM2_SIZE] != OP_ANYNL && cc[1 + IMM2_SIZE] != OP_EXTUNI)\n      space = 2;\n    break;\n\n    case OP_TYPEMINUPTO:\n    size = 1 + IMM2_SIZE;\n    space = 2;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    size = 1 + 32 / sizeof(PCRE2_UCHAR);\n    space = get_class_iterator_size(cc + size);\n    break;\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    size = GET(cc, 1);\n    space = get_class_iterator_size(cc + size);\n    break;\n#endif\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\n  /* Character iterators, which are not inside a repeated bracket,\n     gets a private slot instead of allocating it on the stack. */\n  if (space > 0 && cc >= end)\n    {\n    common->private_data_ptrs[cc - common->start] = private_data_ptr;\n    private_data_ptr += sizeof(sljit_sw) * space;\n    }\n\n  if (size != 0)\n    {\n    if (size < 0)\n      {\n      cc += -size;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n      }\n    else\n      cc += size;\n    }\n\n  if (bracketlen > 0)\n    {\n    if (cc >= end)\n      {\n      end = bracketend(cc);\n      if (end[-1 - LINK_SIZE] == OP_KET)\n        end = NULL;\n      }\n    cc += bracketlen;\n    }\n  }\n*private_data_start = private_data_ptr;\n}\n\n/* Returns with a frame_types (always < 0) if no need for frame. */\nstatic int get_framesize(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, BOOL recursive, BOOL *needs_control_head)\n{\nint length = 0;\nint possessive = 0;\nBOOL stack_restore = FALSE;\nBOOL setsom_found = recursive;\nBOOL setmark_found = recursive;\n/* The last capture is a local variable even for recursions. */\nBOOL capture_last_found = FALSE;\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\n*needs_control_head = TRUE;\n#else\n*needs_control_head = FALSE;\n#endif\n\nif (ccend == NULL)\n  {\n  ccend = bracketend(cc) - (1 + LINK_SIZE);\n  if (!recursive && (*cc == OP_CBRAPOS || *cc == OP_SCBRAPOS))\n    {\n    possessive = length = (common->capture_last_ptr != 0) ? 5 : 3;\n    /* This is correct regardless of common->capture_last_ptr. */\n    capture_last_found = TRUE;\n    }\n  cc = next_opcode(common, cc);\n  }\n\nSLJIT_ASSERT(cc != NULL);\nwhile (cc < ccend)\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    stack_restore = TRUE;\n    if (!setsom_found)\n      {\n      length += 2;\n      setsom_found = TRUE;\n      }\n    cc += 1;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    stack_restore = TRUE;\n    if (!setmark_found)\n      {\n      length += 2;\n      setmark_found = TRUE;\n      }\n    if (common->control_head_ptr != 0)\n      *needs_control_head = TRUE;\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_RECURSE:\n    stack_restore = TRUE;\n    if (common->has_set_som && !setsom_found)\n      {\n      length += 2;\n      setsom_found = TRUE;\n      }\n    if (common->mark_ptr != 0 && !setmark_found)\n      {\n      length += 2;\n      setmark_found = TRUE;\n      }\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      length += 2;\n      capture_last_found = TRUE;\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_CBRAPOS:\n    case OP_SCBRA:\n    case OP_SCBRAPOS:\n    stack_restore = TRUE;\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      length += 2;\n      capture_last_found = TRUE;\n      }\n    length += 3;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_THEN:\n    stack_restore = TRUE;\n    if (common->control_head_ptr != 0)\n      *needs_control_head = TRUE;\n    cc ++;\n    break;\n\n    default:\n    stack_restore = TRUE;\n    /* Fall through. */\n\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_NOT_DIGIT:\n    case OP_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_WORDCHAR:\n    case OP_ANY:\n    case OP_ALLANY:\n    case OP_ANYBYTE:\n    case OP_NOTPROP:\n    case OP_PROP:\n    case OP_ANYNL:\n    case OP_NOT_HSPACE:\n    case OP_HSPACE:\n    case OP_NOT_VSPACE:\n    case OP_VSPACE:\n    case OP_EXTUNI:\n    case OP_EODN:\n    case OP_EOD:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_DOLL:\n    case OP_DOLLM:\n    case OP_CHAR:\n    case OP_CHARI:\n    case OP_NOT:\n    case OP_NOTI:\n\n    case OP_EXACT:\n    case OP_POSSTAR:\n    case OP_POSPLUS:\n    case OP_POSQUERY:\n    case OP_POSUPTO:\n\n    case OP_EXACTI:\n    case OP_POSSTARI:\n    case OP_POSPLUSI:\n    case OP_POSQUERYI:\n    case OP_POSUPTOI:\n\n    case OP_NOTEXACT:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSUPTO:\n\n    case OP_NOTEXACTI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTPOSQUERYI:\n    case OP_NOTPOSUPTOI:\n\n    case OP_TYPEEXACT:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEPOSQUERY:\n    case OP_TYPEPOSUPTO:\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    case OP_XCLASS:\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\n/* Possessive quantifiers can use a special case. */\nif (SLJIT_UNLIKELY(possessive == length))\n  return stack_restore ? no_frame : no_stack;\n\nif (length > 0)\n  return length + 1;\nreturn stack_restore ? no_frame : no_stack;\n}\n\nstatic void init_frame(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, int stackpos, int stacktop)\n{\nDEFINE_COMPILER;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\n/* The last capture is a local variable even for recursions. */\nBOOL capture_last_found = FALSE;\nint offset;\n\n/* >= 1 + shortest item size (2) */\nSLJIT_UNUSED_ARG(stacktop);\nSLJIT_ASSERT(stackpos >= stacktop + 2);\n\nstackpos = STACK(stackpos);\nif (ccend == NULL)\n  {\n  ccend = bracketend(cc) - (1 + LINK_SIZE);\n  if (*cc != OP_CBRAPOS && *cc != OP_SCBRAPOS)\n    cc = next_opcode(common, cc);\n  }\n\nSLJIT_ASSERT(cc != NULL);\nwhile (cc < ccend)\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    if (!setsom_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -OVECTOR(0));\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setsom_found = TRUE;\n      }\n    cc += 1;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (!setmark_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->mark_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setmark_found = TRUE;\n      }\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_RECURSE:\n    if (common->has_set_som && !setsom_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -OVECTOR(0));\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setsom_found = TRUE;\n      }\n    if (common->mark_ptr != 0 && !setmark_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->mark_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setmark_found = TRUE;\n      }\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->capture_last_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      capture_last_found = TRUE;\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_CBRAPOS:\n    case OP_SCBRA:\n    case OP_SCBRAPOS:\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->capture_last_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      capture_last_found = TRUE;\n      }\n    offset = (GET2(cc, 1 + LINK_SIZE)) << 1;\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, OVECTOR(offset));\n    stackpos -= (int)sizeof(sljit_sw);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n    stackpos -= (int)sizeof(sljit_sw);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP2, 0);\n    stackpos -= (int)sizeof(sljit_sw);\n\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, 0);\nSLJIT_ASSERT(stackpos == STACK(stacktop));\n}\n\n#define RECURSE_TMP_REG_COUNT 3\n\ntypedef struct delayed_mem_copy_status {\n  struct sljit_compiler *compiler;\n  int store_bases[RECURSE_TMP_REG_COUNT];\n  int store_offsets[RECURSE_TMP_REG_COUNT];\n  int tmp_regs[RECURSE_TMP_REG_COUNT];\n  int saved_tmp_regs[RECURSE_TMP_REG_COUNT];\n  int next_tmp_reg;\n} delayed_mem_copy_status;\n\nstatic void delayed_mem_copy_init(delayed_mem_copy_status *status, compiler_common *common)\n{\nint i;\n\nfor (i = 0; i < RECURSE_TMP_REG_COUNT; i++)\n  {\n  SLJIT_ASSERT(status->tmp_regs[i] >= 0);\n  SLJIT_ASSERT(sljit_get_register_index(status->saved_tmp_regs[i]) < 0 || status->tmp_regs[i] == status->saved_tmp_regs[i]);\n\n  status->store_bases[i] = -1;\n  }\nstatus->next_tmp_reg = 0;\nstatus->compiler = common->compiler;\n}\n\nstatic void delayed_mem_copy_move(delayed_mem_copy_status *status, int load_base, sljit_sw load_offset,\n  int store_base, sljit_sw store_offset)\n{\nstruct sljit_compiler *compiler = status->compiler;\nint next_tmp_reg = status->next_tmp_reg;\nint tmp_reg = status->tmp_regs[next_tmp_reg];\n\nSLJIT_ASSERT(load_base > 0 && store_base > 0);\n\nif (status->store_bases[next_tmp_reg] == -1)\n  {\n  /* Preserve virtual registers. */\n  if (sljit_get_register_index(status->saved_tmp_regs[next_tmp_reg]) < 0)\n    OP1(SLJIT_MOV, status->saved_tmp_regs[next_tmp_reg], 0, tmp_reg, 0);\n  }\nelse\n  OP1(SLJIT_MOV, SLJIT_MEM1(status->store_bases[next_tmp_reg]), status->store_offsets[next_tmp_reg], tmp_reg, 0);\n\nOP1(SLJIT_MOV, tmp_reg, 0, SLJIT_MEM1(load_base), load_offset);\nstatus->store_bases[next_tmp_reg] = store_base;\nstatus->store_offsets[next_tmp_reg] = store_offset;\n\nstatus->next_tmp_reg = (next_tmp_reg + 1) % RECURSE_TMP_REG_COUNT;\n}\n\nstatic void delayed_mem_copy_finish(delayed_mem_copy_status *status)\n{\nstruct sljit_compiler *compiler = status->compiler;\nint next_tmp_reg = status->next_tmp_reg;\nint tmp_reg, saved_tmp_reg, i;\n\nfor (i = 0; i < RECURSE_TMP_REG_COUNT; i++)\n  {\n  if (status->store_bases[next_tmp_reg] != -1)\n    {\n    tmp_reg = status->tmp_regs[next_tmp_reg];\n    saved_tmp_reg = status->saved_tmp_regs[next_tmp_reg];\n\n    OP1(SLJIT_MOV, SLJIT_MEM1(status->store_bases[next_tmp_reg]), status->store_offsets[next_tmp_reg], tmp_reg, 0);\n\n    /* Restore virtual registers. */\n    if (sljit_get_register_index(saved_tmp_reg) < 0)\n      OP1(SLJIT_MOV, tmp_reg, 0, saved_tmp_reg, 0);\n    }\n\n  next_tmp_reg = (next_tmp_reg + 1) % RECURSE_TMP_REG_COUNT;\n  }\n}\n\n#undef RECURSE_TMP_REG_COUNT\n\nstatic int get_recurse_data_length(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend,\n  BOOL *needs_control_head, BOOL *has_quit, BOOL *has_accept)\n{\nint length = 1;\nint size;\nPCRE2_SPTR alternative;\nBOOL quit_found = FALSE;\nBOOL accept_found = FALSE;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\nBOOL capture_last_found = FALSE;\nBOOL control_head_found = FALSE;\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\ncontrol_head_found = TRUE;\n#endif\n\n/* Calculate the sum of the private machine words. */\nwhile (cc < ccend)\n  {\n  size = 0;\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    setsom_found = TRUE;\n    cc += 1;\n    break;\n\n    case OP_RECURSE:\n    if (common->has_set_som)\n      setsom_found = TRUE;\n    if (common->mark_ptr != 0)\n      setmark_found = TRUE;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_KET:\n    if (PRIVATE_DATA(cc) != 0)\n      {\n      length++;\n      SLJIT_ASSERT(PRIVATE_DATA(cc + 1) != 0);\n      cc += PRIVATE_DATA(cc + 1);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    length++;\n    SLJIT_ASSERT(PRIVATE_DATA(cc) != 0);\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    length += 2;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    if (common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] == 0)\n      length++;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    length += 2 + 2;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    alternative = cc + GET(cc, 1);\n    if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n      length++;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc) != 0)\n      length++;\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 2 + IMM2_SIZE;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc) != 0)\n      length++;\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    size = (*cc == OP_XCLASS) ? GET(cc, 1) : 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#else\n    size = 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#endif\n    if (PRIVATE_DATA(cc) != 0)\n      length += get_class_iterator_size(cc + size);\n    cc += size;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (!setmark_found)\n      setmark_found = TRUE;\n    if (common->control_head_ptr != 0)\n      control_head_found = TRUE;\n    if (*cc != OP_MARK)\n      quit_found = TRUE;\n\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_PRUNE:\n    case OP_SKIP:\n    case OP_COMMIT:\n    quit_found = TRUE;\n    cc++;\n    break;\n\n    case OP_SKIP_ARG:\n    quit_found = TRUE;\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_THEN:\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n    quit_found = TRUE;\n    if (!control_head_found)\n      control_head_found = TRUE;\n    cc++;\n    break;\n\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    accept_found = TRUE;\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n  }\nSLJIT_ASSERT(cc == ccend);\n\nif (control_head_found)\n  length++;\nif (capture_last_found)\n  length++;\nif (quit_found)\n  {\n  if (setsom_found)\n    length++;\n  if (setmark_found)\n    length++;\n  }\n\n*needs_control_head = control_head_found;\n*has_quit = quit_found;\n*has_accept = accept_found;\nreturn length;\n}\n\nenum copy_recurse_data_types {\n  recurse_copy_from_global,\n  recurse_copy_private_to_global,\n  recurse_copy_shared_to_global,\n  recurse_copy_kept_shared_to_global,\n  recurse_swap_global\n};\n\nstatic void copy_recurse_data(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend,\n  int type, int stackptr, int stacktop, BOOL has_quit)\n{\ndelayed_mem_copy_status status;\nPCRE2_SPTR alternative;\nsljit_sw private_srcw[2];\nsljit_sw shared_srcw[3];\nsljit_sw kept_shared_srcw[2];\nint private_count, shared_count, kept_shared_count;\nint from_sp, base_reg, offset, i;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\nBOOL capture_last_found = FALSE;\nBOOL control_head_found = FALSE;\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\ncontrol_head_found = TRUE;\n#endif\n\nswitch (type)\n  {\n  case recurse_copy_from_global:\n  from_sp = TRUE;\n  base_reg = STACK_TOP;\n  break;\n\n  case recurse_copy_private_to_global:\n  case recurse_copy_shared_to_global:\n  case recurse_copy_kept_shared_to_global:\n  from_sp = FALSE;\n  base_reg = STACK_TOP;\n  break;\n\n  default:\n  SLJIT_ASSERT(type == recurse_swap_global);\n  from_sp = FALSE;\n  base_reg = TMP2;\n  break;\n  }\n\nstackptr = STACK(stackptr);\nstacktop = STACK(stacktop);\n\nstatus.tmp_regs[0] = TMP1;\nstatus.saved_tmp_regs[0] = TMP1;\n\nif (base_reg != TMP2)\n  {\n  status.tmp_regs[1] = TMP2;\n  status.saved_tmp_regs[1] = TMP2;\n  }\nelse\n  {\n  status.saved_tmp_regs[1] = RETURN_ADDR;\n  if (HAS_VIRTUAL_REGISTERS)\n    status.tmp_regs[1] = STR_PTR;\n  else\n    status.tmp_regs[1] = RETURN_ADDR;\n  }\n\nstatus.saved_tmp_regs[2] = TMP3;\nif (HAS_VIRTUAL_REGISTERS)\n  status.tmp_regs[2] = STR_END;\nelse\n  status.tmp_regs[2] = TMP3;\n\ndelayed_mem_copy_init(&status, common);\n\nif (type != recurse_copy_shared_to_global && type != recurse_copy_kept_shared_to_global)\n  {\n  SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_private_to_global || type == recurse_swap_global);\n\n  if (!from_sp)\n    delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, common->recursive_head_ptr);\n\n  if (from_sp || type == recurse_swap_global)\n    delayed_mem_copy_move(&status, SLJIT_SP, common->recursive_head_ptr, base_reg, stackptr);\n  }\n\nstackptr += sizeof(sljit_sw);\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nif (type != recurse_copy_shared_to_global)\n  {\n  if (!from_sp)\n    delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, common->control_head_ptr);\n\n  if (from_sp || type == recurse_swap_global)\n    delayed_mem_copy_move(&status, SLJIT_SP, common->control_head_ptr, base_reg, stackptr);\n  }\n\nstackptr += sizeof(sljit_sw);\n#endif\n\nwhile (cc < ccend)\n  {\n  private_count = 0;\n  shared_count = 0;\n  kept_shared_count = 0;\n\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    if (has_quit && !setsom_found)\n      {\n      kept_shared_srcw[0] = OVECTOR(0);\n      kept_shared_count = 1;\n      setsom_found = TRUE;\n      }\n    cc += 1;\n    break;\n\n    case OP_RECURSE:\n    if (has_quit)\n      {\n      if (common->has_set_som && !setsom_found)\n        {\n        kept_shared_srcw[0] = OVECTOR(0);\n        kept_shared_count = 1;\n        setsom_found = TRUE;\n        }\n      if (common->mark_ptr != 0 && !setmark_found)\n        {\n        kept_shared_srcw[kept_shared_count] = common->mark_ptr;\n        kept_shared_count++;\n        setmark_found = TRUE;\n        }\n      }\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      shared_srcw[0] = common->capture_last_ptr;\n      shared_count = 1;\n      capture_last_found = TRUE;\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_KET:\n    if (PRIVATE_DATA(cc) != 0)\n      {\n      private_count = 1;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      SLJIT_ASSERT(PRIVATE_DATA(cc + 1) != 0);\n      cc += PRIVATE_DATA(cc + 1);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    private_count = 1;\n    private_srcw[0] = PRIVATE_DATA(cc);\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    offset = (GET2(cc, 1 + LINK_SIZE)) << 1;\n    shared_srcw[0] = OVECTOR(offset);\n    shared_srcw[1] = OVECTOR(offset + 1);\n    shared_count = 2;\n\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      shared_srcw[2] = common->capture_last_ptr;\n      shared_count = 3;\n      capture_last_found = TRUE;\n      }\n\n    if (common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] == 0)\n      {\n      private_count = 1;\n      private_srcw[0] = OVECTOR_PRIV(GET2(cc, 1 + LINK_SIZE));\n      }\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    offset = (GET2(cc, 1 + LINK_SIZE)) << 1;\n    shared_srcw[0] = OVECTOR(offset);\n    shared_srcw[1] = OVECTOR(offset + 1);\n    shared_count = 2;\n\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      shared_srcw[2] = common->capture_last_ptr;\n      shared_count = 3;\n      capture_last_found = TRUE;\n      }\n\n    private_count = 2;\n    private_srcw[0] = PRIVATE_DATA(cc);\n    private_srcw[1] = OVECTOR_PRIV(GET2(cc, 1 + LINK_SIZE));\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    alternative = cc + GET(cc, 1);\n    if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n      {\n      private_count = 1;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 1;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      }\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      private_srcw[1] = PRIVATE_DATA(cc) + sizeof(sljit_sw);\n      }\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      private_srcw[1] = PRIVATE_DATA(cc) + sizeof(sljit_sw);\n      }\n    cc += 2 + IMM2_SIZE;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 1;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      }\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n      }\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc))\n      {\n      private_count = 2;\n      private_srcw[0] = PRIVATE_DATA(cc);\n      private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n      }\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    i = (*cc == OP_XCLASS) ? GET(cc, 1) : 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#else\n    i = 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#endif\n    if (PRIVATE_DATA(cc) != 0)\n      switch(get_class_iterator_size(cc + i))\n        {\n        case 1:\n        private_count = 1;\n        private_srcw[0] = PRIVATE_DATA(cc);\n        break;\n\n        case 2:\n        private_count = 2;\n        private_srcw[0] = PRIVATE_DATA(cc);\n        private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n        break;\n\n        default:\n        SLJIT_UNREACHABLE();\n        break;\n        }\n    cc += i;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (has_quit && !setmark_found)\n      {\n      kept_shared_srcw[0] = common->mark_ptr;\n      kept_shared_count = 1;\n      setmark_found = TRUE;\n      }\n    if (common->control_head_ptr != 0 && !control_head_found)\n      {\n      private_srcw[0] = common->control_head_ptr;\n      private_count = 1;\n      control_head_found = TRUE;\n      }\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_THEN:\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n    if (!control_head_found)\n      {\n      private_srcw[0] = common->control_head_ptr;\n      private_count = 1;\n      control_head_found = TRUE;\n      }\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\n  if (type != recurse_copy_shared_to_global && type != recurse_copy_kept_shared_to_global)\n    {\n    SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_private_to_global || type == recurse_swap_global);\n\n    for (i = 0; i < private_count; i++)\n      {\n      SLJIT_ASSERT(private_srcw[i] != 0);\n\n      if (!from_sp)\n        delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, private_srcw[i]);\n\n      if (from_sp || type == recurse_swap_global)\n        delayed_mem_copy_move(&status, SLJIT_SP, private_srcw[i], base_reg, stackptr);\n\n      stackptr += sizeof(sljit_sw);\n      }\n    }\n  else\n    stackptr += sizeof(sljit_sw) * private_count;\n\n  if (type != recurse_copy_private_to_global && type != recurse_copy_kept_shared_to_global)\n    {\n    SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_shared_to_global || type == recurse_swap_global);\n\n    for (i = 0; i < shared_count; i++)\n      {\n      SLJIT_ASSERT(shared_srcw[i] != 0);\n\n      if (!from_sp)\n        delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, shared_srcw[i]);\n\n      if (from_sp || type == recurse_swap_global)\n        delayed_mem_copy_move(&status, SLJIT_SP, shared_srcw[i], base_reg, stackptr);\n\n      stackptr += sizeof(sljit_sw);\n      }\n    }\n  else\n    stackptr += sizeof(sljit_sw) * shared_count;\n\n  if (type != recurse_copy_private_to_global && type != recurse_swap_global)\n    {\n    SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_shared_to_global || type == recurse_copy_kept_shared_to_global);\n\n    for (i = 0; i < kept_shared_count; i++)\n      {\n      SLJIT_ASSERT(kept_shared_srcw[i] != 0);\n\n      if (!from_sp)\n        delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, kept_shared_srcw[i]);\n\n      if (from_sp || type == recurse_swap_global)\n        delayed_mem_copy_move(&status, SLJIT_SP, kept_shared_srcw[i], base_reg, stackptr);\n\n      stackptr += sizeof(sljit_sw);\n      }\n    }\n  else\n    stackptr += sizeof(sljit_sw) * kept_shared_count;\n  }\n\nSLJIT_ASSERT(cc == ccend && stackptr == stacktop);\n\ndelayed_mem_copy_finish(&status);\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR set_then_offsets(compiler_common *common, PCRE2_SPTR cc, sljit_u8 *current_offset)\n{\nPCRE2_SPTR end = bracketend(cc);\nBOOL has_alternatives = cc[GET(cc, 1)] == OP_ALT;\n\n/* Assert captures then. */\nif (*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA)\n  current_offset = NULL;\n/* Conditional block does not. */\nif (*cc == OP_COND || *cc == OP_SCOND)\n  has_alternatives = FALSE;\n\ncc = next_opcode(common, cc);\nif (has_alternatives)\n  current_offset = common->then_offsets + (cc - common->start);\n\nwhile (cc < end)\n  {\n  if ((*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA) || (*cc >= OP_ONCE && *cc <= OP_SCOND))\n    cc = set_then_offsets(common, cc, current_offset);\n  else\n    {\n    if (*cc == OP_ALT && has_alternatives)\n      current_offset = common->then_offsets + (cc + 1 + LINK_SIZE - common->start);\n    if (*cc >= OP_THEN && *cc <= OP_THEN_ARG && current_offset != NULL)\n      *current_offset = 1;\n    cc = next_opcode(common, cc);\n    }\n  }\n\nreturn end;\n}\n\n#undef CASE_ITERATOR_PRIVATE_DATA_1\n#undef CASE_ITERATOR_PRIVATE_DATA_2A\n#undef CASE_ITERATOR_PRIVATE_DATA_2B\n#undef CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n#undef CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n#undef CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n\nstatic SLJIT_INLINE BOOL is_powerof2(unsigned int value)\n{\nreturn (value & (value - 1)) == 0;\n}\n\nstatic SLJIT_INLINE void set_jumps(jump_list *list, struct sljit_label *label)\n{\nwhile (list)\n  {\n  /* sljit_set_label is clever enough to do nothing\n  if either the jump or the label is NULL. */\n  SET_LABEL(list->jump, label);\n  list = list->next;\n  }\n}\n\nstatic SLJIT_INLINE void add_jump(struct sljit_compiler *compiler, jump_list **list, struct sljit_jump *jump)\n{\njump_list *list_item = sljit_alloc_memory(compiler, sizeof(jump_list));\nif (list_item)\n  {\n  list_item->next = *list;\n  list_item->jump = jump;\n  *list = list_item;\n  }\n}\n\nstatic void add_stub(compiler_common *common, struct sljit_jump *start)\n{\nDEFINE_COMPILER;\nstub_list *list_item = sljit_alloc_memory(compiler, sizeof(stub_list));\n\nif (list_item)\n  {\n  list_item->start = start;\n  list_item->quit = LABEL();\n  list_item->next = common->stubs;\n  common->stubs = list_item;\n  }\n}\n\nstatic void flush_stubs(compiler_common *common)\n{\nDEFINE_COMPILER;\nstub_list *list_item = common->stubs;\n\nwhile (list_item)\n  {\n  JUMPHERE(list_item->start);\n  add_jump(compiler, &common->stackalloc, JUMP(SLJIT_FAST_CALL));\n  JUMPTO(SLJIT_JUMP, list_item->quit);\n  list_item = list_item->next;\n  }\ncommon->stubs = NULL;\n}\n\nstatic SLJIT_INLINE void count_match(compiler_common *common)\n{\nDEFINE_COMPILER;\n\nOP2(SLJIT_SUB | SLJIT_SET_Z, COUNT_MATCH, 0, COUNT_MATCH, 0, SLJIT_IMM, 1);\nadd_jump(compiler, &common->calllimit, JUMP(SLJIT_ZERO));\n}\n\nstatic SLJIT_INLINE void allocate_stack(compiler_common *common, int size)\n{\n/* May destroy all locals and registers except TMP2. */\nDEFINE_COMPILER;\n\nSLJIT_ASSERT(size > 0);\nOP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, size * sizeof(sljit_sw));\n#ifdef DESTROY_REGISTERS\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 12345);\nOP1(SLJIT_MOV, TMP3, 0, TMP1, 0);\nOP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP1, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS1, TMP1, 0);\n#endif\nadd_stub(common, CMP(SLJIT_LESS, STACK_TOP, 0, STACK_LIMIT, 0));\n}\n\nstatic SLJIT_INLINE void free_stack(compiler_common *common, int size)\n{\nDEFINE_COMPILER;\n\nSLJIT_ASSERT(size > 0);\nOP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, size * sizeof(sljit_sw));\n}\n\nstatic sljit_uw * allocate_read_only_data(compiler_common *common, sljit_uw size)\n{\nDEFINE_COMPILER;\nsljit_uw *result;\n\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  return NULL;\n\nresult = (sljit_uw *)SLJIT_MALLOC(size + sizeof(sljit_uw), compiler->allocator_data);\nif (SLJIT_UNLIKELY(result == NULL))\n  {\n  sljit_set_compiler_memory_error(compiler);\n  return NULL;\n  }\n\n*(void**)result = common->read_only_data_head;\ncommon->read_only_data_head = (void *)result;\nreturn result + 1;\n}\n\nstatic SLJIT_INLINE void reset_ovector(compiler_common *common, int length)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nsljit_s32 i;\n\n/* At this point we can freely use all temporary registers. */\nSLJIT_ASSERT(length > 1);\n/* TMP1 returns with begin - 1. */\nOP2(SLJIT_SUB, SLJIT_R0, 0, SLJIT_MEM1(SLJIT_S0), SLJIT_OFFSETOF(jit_arguments, begin), SLJIT_IMM, IN_UCHARS(1));\nif (length < 8)\n  {\n  for (i = 1; i < length; i++)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(i), SLJIT_R0, 0);\n  }\nelse\n  {\n  if (sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_STORE | SLJIT_MEM_PRE, SLJIT_R0, SLJIT_MEM1(SLJIT_R1), sizeof(sljit_sw)) == SLJIT_SUCCESS)\n    {\n    GET_LOCAL_BASE(SLJIT_R1, 0, OVECTOR_START);\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_IMM, length - 1);\n    loop = LABEL();\n    sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_STORE | SLJIT_MEM_PRE, SLJIT_R0, SLJIT_MEM1(SLJIT_R1), sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  else\n    {\n    GET_LOCAL_BASE(SLJIT_R1, 0, OVECTOR_START + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_IMM, length - 1);\n    loop = LABEL();\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_R1), 0, SLJIT_R0, 0);\n    OP2(SLJIT_ADD, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  }\n}\n\nstatic SLJIT_INLINE void reset_early_fail(compiler_common *common)\n{\nDEFINE_COMPILER;\nsljit_u32 size = (sljit_u32)(common->early_fail_end_ptr - common->early_fail_start_ptr);\nsljit_u32 uncleared_size;\nsljit_s32 src = SLJIT_IMM;\nsljit_s32 i;\nstruct sljit_label *loop;\n\nSLJIT_ASSERT(common->early_fail_start_ptr < common->early_fail_end_ptr);\n\nif (size == sizeof(sljit_sw))\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->early_fail_start_ptr, SLJIT_IMM, 0);\n  return;\n  }\n\nif (sljit_get_register_index(TMP3) >= 0 && !sljit_has_cpu_feature(SLJIT_HAS_ZERO_REGISTER))\n  {\n  OP1(SLJIT_MOV, TMP3, 0, SLJIT_IMM, 0);\n  src = TMP3;\n  }\n\nif (size <= 6 * sizeof(sljit_sw))\n  {\n  for (i = common->early_fail_start_ptr; i < common->early_fail_end_ptr; i += sizeof(sljit_sw))\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), i, src, 0);\n  return;\n  }\n\nGET_LOCAL_BASE(TMP1, 0, common->early_fail_start_ptr);\n\nuncleared_size = ((size / sizeof(sljit_sw)) % 3) * sizeof(sljit_sw);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, size - uncleared_size);\n\nloop = LABEL();\nOP1(SLJIT_MOV, SLJIT_MEM1(TMP1), 0, src, 0);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 3 * sizeof(sljit_sw));\nOP1(SLJIT_MOV, SLJIT_MEM1(TMP1), -2 * (sljit_sw)sizeof(sljit_sw), src, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(TMP1), -1 * (sljit_sw)sizeof(sljit_sw), src, 0);\nCMPTO(SLJIT_LESS, TMP1, 0, TMP2, 0, loop);\n\nif (uncleared_size >= sizeof(sljit_sw))\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP1), 0, src, 0);\n\nif (uncleared_size >= 2 * sizeof(sljit_sw))\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP1), sizeof(sljit_sw), src, 0);\n}\n\nstatic SLJIT_INLINE void do_reset_match(compiler_common *common, int length)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nint i;\n\nSLJIT_ASSERT(length > 1);\n/* OVECTOR(1) contains the \"string begin - 1\" constant. */\nif (length > 2)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\nif (length < 8)\n  {\n  for (i = 2; i < length; i++)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(i), TMP1, 0);\n  }\nelse\n  {\n  if (sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_STORE | SLJIT_MEM_PRE, TMP1, SLJIT_MEM1(TMP2), sizeof(sljit_sw)) == SLJIT_SUCCESS)\n    {\n    GET_LOCAL_BASE(TMP2, 0, OVECTOR_START + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_IMM, length - 2);\n    loop = LABEL();\n    sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_STORE | SLJIT_MEM_PRE, TMP1, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  else\n    {\n    GET_LOCAL_BASE(TMP2, 0, OVECTOR_START + 2 * sizeof(sljit_sw));\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_IMM, length - 2);\n    loop = LABEL();\n    OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, TMP1, 0);\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  }\n\nif (!HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, stack));\nelse\n  OP1(SLJIT_MOV, STACK_TOP, 0, ARGUMENTS, 0);\n\nif (common->mark_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, SLJIT_IMM, 0);\nif (common->control_head_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\nif (HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(STACK_TOP), SLJIT_OFFSETOF(jit_arguments, stack));\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\nOP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(STACK_TOP), SLJIT_OFFSETOF(struct sljit_stack, end));\n}\n\nstatic sljit_sw SLJIT_FUNC do_search_mark(sljit_sw *current, PCRE2_SPTR skip_arg)\n{\nwhile (current != NULL)\n  {\n  switch (current[1])\n    {\n    case type_then_trap:\n    break;\n\n    case type_mark:\n    if (PRIV(strcmp)(skip_arg, (PCRE2_SPTR)current[2]) == 0)\n      return current[3];\n    break;\n\n    default:\n    SLJIT_UNREACHABLE();\n    break;\n    }\n  SLJIT_ASSERT(current[0] == 0 || current < (sljit_sw*)current[0]);\n  current = (sljit_sw*)current[0];\n  }\nreturn 0;\n}\n\nstatic SLJIT_INLINE void copy_ovector(compiler_common *common, int topbracket)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nBOOL has_pre;\n\n/* At this point we can freely use all registers. */\nOP1(SLJIT_MOV, SLJIT_S2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(1), STR_PTR, 0);\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, SLJIT_R0, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV, SLJIT_S0, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n  OP1(SLJIT_MOV_U32, SLJIT_R1, 0, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, oveccount));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, startchar_ptr), SLJIT_S0, 0);\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, mark_ptr), SLJIT_R2, 0);\n  OP2(SLJIT_ADD, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, match_data),\n    SLJIT_IMM, SLJIT_OFFSETOF(pcre2_match_data, ovector) - sizeof(PCRE2_SIZE));\n  }\nelse\n  {\n  OP1(SLJIT_MOV, SLJIT_S0, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\n  OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, match_data));\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_R0, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n  OP1(SLJIT_MOV_U32, SLJIT_R1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, oveccount));\n  OP1(SLJIT_MOV, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, startchar_ptr), SLJIT_S0, 0);\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, mark_ptr), SLJIT_R0, 0);\n  OP2(SLJIT_ADD, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, SLJIT_OFFSETOF(pcre2_match_data, ovector) - sizeof(PCRE2_SIZE));\n  }\n\nhas_pre = sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, SLJIT_S1, SLJIT_MEM1(SLJIT_S0), sizeof(sljit_sw)) == SLJIT_SUCCESS;\n\nGET_LOCAL_BASE(SLJIT_S0, 0, OVECTOR_START - (has_pre ? sizeof(sljit_sw) : 0));\nOP1(SLJIT_MOV, SLJIT_R0, 0, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? SLJIT_R0 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n\nloop = LABEL();\n\nif (has_pre)\n  sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_PRE, SLJIT_S1, SLJIT_MEM1(SLJIT_S0), sizeof(sljit_sw));\nelse\n  {\n  OP1(SLJIT_MOV, SLJIT_S1, 0, SLJIT_MEM1(SLJIT_S0), 0);\n  OP2(SLJIT_ADD, SLJIT_S0, 0, SLJIT_S0, 0, SLJIT_IMM, sizeof(sljit_sw));\n  }\n\nOP2(SLJIT_ADD, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, sizeof(PCRE2_SIZE));\nOP2(SLJIT_SUB, SLJIT_S1, 0, SLJIT_S1, 0, SLJIT_R0, 0);\n/* Copy the integer value to the output buffer */\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\nOP2(SLJIT_ASHR, SLJIT_S1, 0, SLJIT_S1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\n\nSLJIT_ASSERT(sizeof(PCRE2_SIZE) == 4 || sizeof(PCRE2_SIZE) == 8);\nOP1(((sizeof(PCRE2_SIZE) == 4) ? SLJIT_MOV_U32 : SLJIT_MOV), SLJIT_MEM1(SLJIT_R2), 0, SLJIT_S1, 0);\n\nOP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, 1);\nJUMPTO(SLJIT_NOT_ZERO, loop);\n\n/* Calculate the return value, which is the maximum ovector value. */\nif (topbracket > 1)\n  {\n  if (sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, SLJIT_R2, SLJIT_MEM1(SLJIT_R0), -(2 * (sljit_sw)sizeof(sljit_sw))) == SLJIT_SUCCESS)\n    {\n    GET_LOCAL_BASE(SLJIT_R0, 0, OVECTOR_START + topbracket * 2 * sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_IMM, topbracket + 1);\n\n    /* OVECTOR(0) is never equal to SLJIT_S2. */\n    loop = LABEL();\n    sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_PRE, SLJIT_R2, SLJIT_MEM1(SLJIT_R0), -(2 * (sljit_sw)sizeof(sljit_sw)));\n    OP2(SLJIT_SUB, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, 1);\n    CMPTO(SLJIT_EQUAL, SLJIT_R2, 0, SLJIT_S2, 0, loop);\n    OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_R1, 0);\n    }\n  else\n    {\n    GET_LOCAL_BASE(SLJIT_R0, 0, OVECTOR_START + (topbracket - 1) * 2 * sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_IMM, topbracket + 1);\n\n    /* OVECTOR(0) is never equal to SLJIT_S2. */\n    loop = LABEL();\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_R0), 0);\n    OP2(SLJIT_SUB, SLJIT_R0, 0, SLJIT_R0, 0, SLJIT_IMM, 2 * (sljit_sw)sizeof(sljit_sw));\n    OP2(SLJIT_SUB, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, 1);\n    CMPTO(SLJIT_EQUAL, SLJIT_R2, 0, SLJIT_S2, 0, loop);\n    OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_R1, 0);\n    }\n  }\nelse\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, 1);\n}\n\nstatic SLJIT_INLINE void return_with_partial_match(compiler_common *common, struct sljit_label *quit)\n{\nDEFINE_COMPILER;\nsljit_s32 mov_opcode;\nsljit_s32 arguments_reg = !HAS_VIRTUAL_REGISTERS ? ARGUMENTS : SLJIT_R1;\n\nSLJIT_COMPILE_ASSERT(STR_END == SLJIT_S0, str_end_must_be_saved_reg0);\nSLJIT_ASSERT(common->start_used_ptr != 0 && common->start_ptr != 0\n  && (common->mode == PCRE2_JIT_PARTIAL_SOFT ? common->hit_start != 0 : common->hit_start == 0));\n\nif (arguments_reg != ARGUMENTS)\n  OP1(SLJIT_MOV, arguments_reg, 0, ARGUMENTS, 0);\nOP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP),\n  common->mode == PCRE2_JIT_PARTIAL_SOFT ? common->hit_start : common->start_ptr);\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_PARTIAL);\n\n/* Store match begin and end. */\nOP1(SLJIT_MOV, SLJIT_S1, 0, SLJIT_MEM1(arguments_reg), SLJIT_OFFSETOF(jit_arguments, begin));\nOP1(SLJIT_MOV, SLJIT_MEM1(arguments_reg), SLJIT_OFFSETOF(jit_arguments, startchar_ptr), SLJIT_R2, 0);\nOP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_MEM1(arguments_reg), SLJIT_OFFSETOF(jit_arguments, match_data));\n\nmov_opcode = (sizeof(PCRE2_SIZE) == 4) ? SLJIT_MOV_U32 : SLJIT_MOV;\n\nOP2(SLJIT_SUB, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_S1, 0);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\nOP2(SLJIT_ASHR, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\nOP1(mov_opcode, SLJIT_MEM1(SLJIT_R1), SLJIT_OFFSETOF(pcre2_match_data, ovector), SLJIT_R2, 0);\n\nOP2(SLJIT_SUB, STR_END, 0, STR_END, 0, SLJIT_S1, 0);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\nOP2(SLJIT_ASHR, STR_END, 0, STR_END, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\nOP1(mov_opcode, SLJIT_MEM1(SLJIT_R1), SLJIT_OFFSETOF(pcre2_match_data, ovector) + sizeof(PCRE2_SIZE), STR_END, 0);\n\nJUMPTO(SLJIT_JUMP, quit);\n}\n\nstatic SLJIT_INLINE void check_start_used_ptr(compiler_common *common)\n{\n/* May destroy TMP1. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  /* The value of -1 must be kept for start_used_ptr! */\n  OP2(SLJIT_ADD, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, 1);\n  /* Jumps if start_used_ptr < STR_PTR, or start_used_ptr == -1. Although overwriting\n  is not necessary if start_used_ptr == STR_PTR, it does not hurt as well. */\n  jump = CMP(SLJIT_LESS_EQUAL, TMP1, 0, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  JUMPHERE(jump);\n  }\nelse if (common->mode == PCRE2_JIT_PARTIAL_HARD)\n  {\n  jump = CMP(SLJIT_LESS_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  JUMPHERE(jump);\n  }\n}\n\nstatic SLJIT_INLINE BOOL char_has_othercase(compiler_common *common, PCRE2_SPTR cc)\n{\n/* Detects if the character has an othercase. */\nunsigned int c;\n\n#ifdef SUPPORT_UNICODE\nif (common->utf || common->ucp)\n  {\n  if (common->utf)\n    {\n    GETCHAR(c, cc);\n    }\n  else\n    c = *cc;\n\n  if (c > 127)\n    return c != UCD_OTHERCASE(c);\n\n  return common->fcc[c] != c;\n  }\nelse\n#endif\n  c = *cc;\nreturn MAX_255(c) ? common->fcc[c] != c : FALSE;\n}\n\nstatic SLJIT_INLINE unsigned int char_othercase(compiler_common *common, unsigned int c)\n{\n/* Returns with the othercase. */\n#ifdef SUPPORT_UNICODE\nif ((common->utf || common->ucp) && c > 127)\n  return UCD_OTHERCASE(c);\n#endif\nreturn TABLE_GET(c, common->fcc, c);\n}\n\nstatic unsigned int char_get_othercase_bit(compiler_common *common, PCRE2_SPTR cc)\n{\n/* Detects if the character and its othercase has only 1 bit difference. */\nunsigned int c, oc, bit;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nint n;\n#endif\n\n#ifdef SUPPORT_UNICODE\nif (common->utf || common->ucp)\n  {\n  if (common->utf)\n    {\n    GETCHAR(c, cc);\n    }\n  else\n    c = *cc;\n\n  if (c <= 127)\n    oc = common->fcc[c];\n  else\n    oc = UCD_OTHERCASE(c);\n  }\nelse\n  {\n  c = *cc;\n  oc = TABLE_GET(c, common->fcc, c);\n  }\n#else\nc = *cc;\noc = TABLE_GET(c, common->fcc, c);\n#endif\n\nSLJIT_ASSERT(c != oc);\n\nbit = c ^ oc;\n/* Optimized for English alphabet. */\nif (c <= 127 && bit == 0x20)\n  return (0 << 8) | 0x20;\n\n/* Since c != oc, they must have at least 1 bit difference. */\nif (!is_powerof2(bit))\n  return 0;\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n\n#ifdef SUPPORT_UNICODE\nif (common->utf && c > 127)\n  {\n  n = GET_EXTRALEN(*cc);\n  while ((bit & 0x3f) == 0)\n    {\n    n--;\n    bit >>= 6;\n    }\n  return (n << 8) | bit;\n  }\n#endif /* SUPPORT_UNICODE */\nreturn (0 << 8) | bit;\n\n#elif PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n\n#ifdef SUPPORT_UNICODE\nif (common->utf && c > 65535)\n  {\n  if (bit >= (1u << 10))\n    bit >>= 10;\n  else\n    return (bit < 256) ? ((2 << 8) | bit) : ((3 << 8) | (bit >> 8));\n  }\n#endif /* SUPPORT_UNICODE */\nreturn (bit < 256) ? ((0u << 8) | bit) : ((1u << 8) | (bit >> 8));\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n}\n\nstatic void check_partial(compiler_common *common, BOOL force)\n{\n/* Checks whether a partial matching is occurred. Does not modify registers. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump = NULL;\n\nSLJIT_ASSERT(!force || common->mode != PCRE2_JIT_COMPLETE);\n\nif (common->mode == PCRE2_JIT_COMPLETE)\n  return;\n\nif (!force && !common->allow_empty_partial)\n  jump = CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\nelse if (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  jump = CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, -1);\n\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\nelse\n  {\n  if (common->partialmatchlabel != NULL)\n    JUMPTO(SLJIT_JUMP, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, JUMP(SLJIT_JUMP));\n  }\n\nif (jump != NULL)\n  JUMPHERE(jump);\n}\n\nstatic void check_str_end(compiler_common *common, jump_list **end_reached)\n{\n/* Does not affect registers. Usually used in a tight spot. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (common->mode == PCRE2_JIT_COMPLETE)\n  {\n  add_jump(compiler, end_reached, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n  return;\n  }\n\njump = CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0);\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  add_jump(compiler, end_reached, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  add_jump(compiler, end_reached, JUMP(SLJIT_JUMP));\n  }\nelse\n  {\n  add_jump(compiler, end_reached, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\n  if (common->partialmatchlabel != NULL)\n    JUMPTO(SLJIT_JUMP, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, JUMP(SLJIT_JUMP));\n  }\nJUMPHERE(jump);\n}\n\nstatic void detect_partial_match(compiler_common *common, jump_list **backtracks)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (common->mode == PCRE2_JIT_COMPLETE)\n  {\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n  return;\n  }\n\n/* Partial matching mode. */\njump = CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0);\nif (!common->allow_empty_partial)\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\nelse if (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, -1));\n\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n  }\nelse\n  {\n  if (common->partialmatchlabel != NULL)\n    JUMPTO(SLJIT_JUMP, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, JUMP(SLJIT_JUMP));\n  }\nJUMPHERE(jump);\n}\n\nstatic void process_partial_match(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\n/* Partial matching mode. */\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  jump = CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  JUMPHERE(jump);\n  }\nelse if (common->mode == PCRE2_JIT_PARTIAL_HARD)\n  {\n  if (common->partialmatchlabel != NULL)\n    CMPTO(SLJIT_LESS, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, CMP(SLJIT_LESS, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\n  }\n}\n\nstatic void detect_partial_match_to(compiler_common *common, struct sljit_label *label)\n{\nDEFINE_COMPILER;\n\nCMPTO(SLJIT_LESS, STR_PTR, 0, STR_END, 0, label);\nprocess_partial_match(common);\n}\n\nstatic void peek_char(compiler_common *common, sljit_u32 max, sljit_s32 dst, sljit_sw dstw, jump_list **backtracks)\n{\n/* Reads the character into TMP1, keeps STR_PTR.\nDoes not check STR_END. TMP2, dst, RETURN_ADDR Destroyed. */\nDEFINE_COMPILER;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\n\nSLJIT_UNUSED_ARG(max);\nSLJIT_UNUSED_ARG(dst);\nSLJIT_UNUSED_ARG(dstw);\nSLJIT_UNUSED_ARG(backtracks);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  if (max < 128) return;\n\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n  OP1(SLJIT_MOV, dst, dstw, STR_PTR, 0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  add_jump(compiler, common->invalid_utf ? &common->utfreadchar_invalid : &common->utfreadchar, JUMP(SLJIT_FAST_CALL));\n  OP1(SLJIT_MOV, STR_PTR, 0, dst, dstw);\n  if (backtracks && common->invalid_utf)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  if (max < 0xd800) return;\n\n  OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n\n  if (common->invalid_utf)\n    {\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    OP1(SLJIT_MOV, dst, dstw, STR_PTR, 0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n    OP1(SLJIT_MOV, STR_PTR, 0, dst, dstw);\n    if (backtracks && common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    }\n  else\n    {\n    /* TMP2 contains the high surrogate. */\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xdc00 - 0xd800);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000 - 0xdc00);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n    }\n\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf)\n  {\n  if (max < 0xd800) return;\n\n  if (backtracks != NULL)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800));\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000);\n    CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    }\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n}\n\nstatic void peek_char_back(compiler_common *common, sljit_u32 max, jump_list **backtracks)\n{\n/* Reads one character back without moving STR_PTR. TMP2 must\ncontain the start of the subject buffer. Affects TMP1, TMP2, and RETURN_ADDR. */\nDEFINE_COMPILER;\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\n\nSLJIT_UNUSED_ARG(max);\nSLJIT_UNUSED_ARG(backtracks);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  if (max < 128) return;\n\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n  if (common->invalid_utf)\n    {\n    add_jump(compiler, &common->utfpeakcharback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    }\n  else\n    add_jump(compiler, &common->utfpeakcharback, JUMP(SLJIT_FAST_CALL));\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  if (max < 0xd800) return;\n\n  if (common->invalid_utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xd800);\n    add_jump(compiler, &common->utfpeakcharback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xdc00);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xdc00);\n    /* TMP2 contains the low surrogate. */\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x10000);\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 10);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n    }\n    JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf)\n  {\n  OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n  add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800));\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n}\n\n#define READ_CHAR_UPDATE_STR_PTR 0x1\n#define READ_CHAR_UTF8_NEWLINE 0x2\n#define READ_CHAR_NEWLINE (READ_CHAR_UPDATE_STR_PTR | READ_CHAR_UTF8_NEWLINE)\n#define READ_CHAR_VALID_UTF 0x4\n\nstatic void read_char(compiler_common *common, sljit_u32 min, sljit_u32 max,\n  jump_list **backtracks, sljit_u32 options)\n{\n/* Reads the precise value of a character into TMP1, if the character is\nbetween min and max (c >= min && c <= max). Otherwise it returns with a value\noutside the range. Does not check STR_END. */\nDEFINE_COMPILER;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nstruct sljit_jump *jump2;\n#endif\n\nSLJIT_UNUSED_ARG(min);\nSLJIT_UNUSED_ARG(max);\nSLJIT_UNUSED_ARG(backtracks);\nSLJIT_UNUSED_ARG(options);\nSLJIT_ASSERT(min <= max);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  if (max < 128 && !(options & READ_CHAR_UPDATE_STR_PTR)) return;\n\n  if (common->invalid_utf && !(options & READ_CHAR_VALID_UTF))\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n\n    if (options & READ_CHAR_UTF8_NEWLINE)\n      add_jump(compiler, &common->utfreadnewline_invalid, JUMP(SLJIT_FAST_CALL));\n    else\n      add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    JUMPHERE(jump);\n    return;\n    }\n\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n  if (min >= 0x10000)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xf0);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP1(SLJIT_MOV_U8, RETURN_ADDR, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(2));\n    if (!(options & READ_CHAR_UPDATE_STR_PTR))\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    JUMPHERE(jump2);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, RETURN_ADDR, 0);\n    }\n  else if (min >= 0x800 && max <= 0xffff)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xe0);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP1(SLJIT_MOV_U8, RETURN_ADDR, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 0xf);\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    if (!(options & READ_CHAR_UPDATE_STR_PTR))\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    JUMPHERE(jump2);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, RETURN_ADDR, 0);\n    }\n  else if (max >= 0x800)\n    {\n    add_jump(compiler, &common->utfreadchar, JUMP(SLJIT_FAST_CALL));\n    }\n  else if (max < 128)\n    {\n    OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n    }\n  else\n    {\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (!(options & READ_CHAR_UPDATE_STR_PTR))\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    else\n      OP1(SLJIT_MOV_U8, RETURN_ADDR, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, RETURN_ADDR, 0);\n    }\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  if (max < 0xd800 && !(options & READ_CHAR_UPDATE_STR_PTR)) return;\n\n  if (common->invalid_utf && !(options & READ_CHAR_VALID_UTF))\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n\n    if (options & READ_CHAR_UTF8_NEWLINE)\n      add_jump(compiler, &common->utfreadnewline_invalid, JUMP(SLJIT_FAST_CALL));\n    else\n      add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    JUMPHERE(jump);\n    return;\n    }\n\n  if (max >= 0x10000)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xdc00 - 0xd800);\n    /* TMP2 contains the high surrogate. */\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000 - 0xdc00);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n    JUMPHERE(jump);\n    return;\n    }\n\n  /* Skip low surrogate if necessary. */\n  OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n\n  if (sljit_has_cpu_feature(SLJIT_HAS_CMOV) && !HAS_VIRTUAL_REGISTERS)\n    {\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, RETURN_ADDR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0x400);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      CMOV(SLJIT_LESS, STR_PTR, RETURN_ADDR, 0);\n    if (max >= 0xd800)\n      CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, 0x10000);\n    }\n  else\n    {\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    if (max >= 0xd800)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0x10000);\n    JUMPHERE(jump);\n    }\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf)\n  {\n  if (backtracks != NULL)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800));\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000);\n    CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    }\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n}\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n\nstatic BOOL is_char7_bitset(const sljit_u8 *bitset, BOOL nclass)\n{\n/* Tells whether the character codes below 128 are enough\nto determine a match. */\nconst sljit_u8 value = nclass ? 0xff : 0;\nconst sljit_u8 *end = bitset + 32;\n\nbitset += 16;\ndo\n  {\n  if (*bitset++ != value)\n    return FALSE;\n  }\nwhile (bitset < end);\nreturn TRUE;\n}\n\nstatic void read_char7_type(compiler_common *common, jump_list **backtracks, BOOL negated)\n{\n/* Reads the precise character type of a character into TMP1, if the character\nis less than 128. Otherwise it returns with zero. Does not check STR_END. The\nfull_read argument tells whether characters above max are accepted or not. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nSLJIT_ASSERT(common->utf);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n/* All values > 127 are zero in ctypes. */\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n\nif (negated)\n  {\n  jump = CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x80);\n\n  if (common->invalid_utf)\n    {\n    add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n    }\n  else\n    {\n    OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n    }\n  JUMPHERE(jump);\n  }\n}\n\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8 */\n\nstatic void read_char8_type(compiler_common *common, jump_list **backtracks, BOOL negated)\n{\n/* Reads the character type into TMP1, updates STR_PTR. Does not check STR_END. */\nDEFINE_COMPILER;\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\nstruct sljit_jump *jump;\n#endif\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nstruct sljit_jump *jump2;\n#endif\n\nSLJIT_UNUSED_ARG(backtracks);\nSLJIT_UNUSED_ARG(negated);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  /* The result of this read may be unused, but saves an \"else\" part. */\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n  jump = CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x80);\n\n  if (!negated)\n    {\n    if (common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\n    if (common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe0 - 0xc2));\n\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\n    if (common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40));\n\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 255);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n    JUMPHERE(jump2);\n    }\n  else if (common->invalid_utf)\n    {\n    add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n    OP1(SLJIT_MOV, TMP2, 0, TMP1, 0);\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 255);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n    JUMPHERE(jump2);\n    }\n  else\n    add_jump(compiler, &common->utfreadtype8, JUMP(SLJIT_FAST_CALL));\n\n  JUMPHERE(jump);\n  return;\n  }\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8 */\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf && negated)\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x110000));\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 32 */\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\n/* The ctypes array contains only 256 values. */\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\njump = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 255);\n#endif /* PCRE2_CODE_UNIT_WIDTH != 8 */\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n#if PCRE2_CODE_UNIT_WIDTH != 8\nJUMPHERE(jump);\n#endif /* PCRE2_CODE_UNIT_WIDTH != 8 */\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf && negated)\n  {\n  /* Skip low surrogate if necessary. */\n  if (!common->invalid_utf)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xd800);\n\n    if (sljit_has_cpu_feature(SLJIT_HAS_CMOV) && !HAS_VIRTUAL_REGISTERS)\n      {\n      OP2(SLJIT_ADD, RETURN_ADDR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0x400);\n      CMOV(SLJIT_LESS, STR_PTR, RETURN_ADDR, 0);\n      }\n    else\n      {\n      jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400);\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      JUMPHERE(jump);\n      }\n    return;\n    }\n\n  OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xd800);\n  jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400));\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n  OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xdc00);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400));\n\n  JUMPHERE(jump);\n  return;\n  }\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 16 */\n}\n\nstatic void move_back(compiler_common *common, jump_list **backtracks, BOOL must_be_valid)\n{\n/* Goes one character back. Affects STR_PTR and TMP1. If must_be_valid is TRUE,\nTMP2 is not used. Otherwise TMP2 must contain the start of the subject buffer,\nand it is destroyed. Does not modify STR_PTR for invalid character sequences. */\nDEFINE_COMPILER;\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nstruct sljit_label *label;\n\nif (common->utf)\n  {\n  if (!must_be_valid && common->invalid_utf)\n    {\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n    add_jump(compiler, &common->utfmoveback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0));\n    JUMPHERE(jump);\n    return;\n    }\n\n  label = LABEL();\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\n  CMPTO(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0x80, label);\n  return;\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  if (!must_be_valid && common->invalid_utf)\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    add_jump(compiler, &common->utfmoveback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0));\n    JUMPHERE(jump);\n    return;\n    }\n\n  /* Skip low surrogate if necessary. */\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xfc00);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0xdc00);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  return;\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf && !must_be_valid)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n  if (backtracks != NULL)\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    return;\n    }\n\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x110000);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_LESS);\n  OP2(SLJIT_SHL,  TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  return;\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n\nSLJIT_UNUSED_ARG(backtracks);\nSLJIT_UNUSED_ARG(must_be_valid);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n}\n\nstatic void check_newlinechar(compiler_common *common, int nltype, jump_list **backtracks, BOOL jumpifmatch)\n{\n/* Character comes in TMP1. Checks if it is a newline. TMP2 may be destroyed. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (nltype == NLTYPE_ANY)\n  {\n  add_jump(compiler, &common->anynewline, JUMP(SLJIT_FAST_CALL));\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(jumpifmatch ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  }\nelse if (nltype == NLTYPE_ANYCRLF)\n  {\n  if (jumpifmatch)\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR));\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL));\n    }\n  else\n    {\n    jump = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL));\n    JUMPHERE(jump);\n    }\n  }\nelse\n  {\n  SLJIT_ASSERT(nltype == NLTYPE_FIXED && common->newline < 256);\n  add_jump(compiler, backtracks, CMP(jumpifmatch ? SLJIT_EQUAL : SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, common->newline));\n  }\n}\n\n#ifdef SUPPORT_UNICODE\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\nstatic void do_utfreadchar(compiler_common *common)\n{\n/* Fast decoding a UTF-8 character. TMP1 contains the first byte\nof the character (>= 0xc0). Return char value in TMP1. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Searching for the first zero. */\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x800);\njump = JUMP(SLJIT_NOT_ZERO);\n/* Two byte sequence. */\nOP2(SLJIT_XOR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3000);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x10000);\njump = JUMP(SLJIT_NOT_ZERO);\n/* Three byte sequence. */\nOP2(SLJIT_XOR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0000);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Four byte sequence. */\nJUMPHERE(jump);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(2));\nOP2(SLJIT_XOR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xf0000);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadtype8(compiler_common *common)\n{\n/* Fast decoding a UTF-8 character type. TMP2 contains the first byte\nof the character (>= 0xc0). Return value in TMP1. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_jump *compare;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, 0x20);\njump = JUMP(SLJIT_NOT_ZERO);\n/* Two byte sequence. */\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x1f);\n/* The upper 5 bits are known at this point. */\ncompare = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 0x3);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP2, 0, TMP2, 0, TMP1, 0);\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(compare);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* We only have types for characters less than 256. */\nJUMPHERE(jump);\nOP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(utf8_table4) - 0xc0);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadchar_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-8 character. TMP1 contains the first byte\nof the character (>= 0xc0). Return char value in TMP1. STR_PTR is\nundefined for invalid characters. */\nDEFINE_COMPILER;\nsljit_s32 i;\nsljit_s32 has_cmov = sljit_has_cpu_feature(SLJIT_HAS_CMOV);\nstruct sljit_jump *jump;\nstruct sljit_jump *buffer_end_close;\nstruct sljit_label *three_byte_entry;\nstruct sljit_label *exit_invalid_label;\nstruct sljit_jump *exit_invalid[11];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc2);\n\n/* Usually more than 3 characters remained in the subject buffer. */\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\n\n/* Not a valid start of a multi-byte sequence, no more bytes read. */\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xf5 - 0xc2);\n\nbuffer_end_close = CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n/* If TMP2 is in 0x80-0xbf range, TMP1 is also increased by (0x2 << 6). */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x800);\njump = JUMP(SLJIT_NOT_ZERO);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\n\n/* Three-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, 0x20000);\n  exit_invalid[2] = NULL;\n  }\nelse\n  exit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x10000);\njump = JUMP(SLJIT_NOT_ZERO);\n\nthree_byte_entry = LABEL();\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x2d800);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR - 0xd800);\n  exit_invalid[3] = NULL;\n  }\nelse\n  exit_invalid[3] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n  exit_invalid[4] = NULL;\n  }\nelse\n  exit_invalid[4] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\n\n/* Four-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, 0);\n  exit_invalid[5] = NULL;\n  }\nelse\n  exit_invalid[5] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc10000);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x100000);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR - 0x10000);\n  exit_invalid[6] = NULL;\n  }\nelse\n  exit_invalid[6] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x100000);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(buffer_end_close);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nexit_invalid[7] = CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n/* If TMP2 is in 0x80-0xbf range, TMP1 is also increased by (0x2 << 6). */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nexit_invalid[8] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x800);\njump = JUMP(SLJIT_NOT_ZERO);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Three-byte sequence. */\nJUMPHERE(jump);\nexit_invalid[9] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n  exit_invalid[10] = NULL;\n  }\nelse\n  exit_invalid[10] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\n/* One will be substracted from STR_PTR later. */\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n\n/* Four byte sequences are not possible. */\nCMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x30000, three_byte_entry);\n\nexit_invalid_label = LABEL();\nfor (i = 0; i < 11; i++)\n  sljit_set_label(exit_invalid[i], exit_invalid_label);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadnewline_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-8 character, specialized for newlines.\nTMP1 contains the first byte of the character (>= 0xc0). Return\nchar value in TMP1. */\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nstruct sljit_label *skip_start;\nstruct sljit_label *three_byte_exit;\nstruct sljit_jump *jump[5];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nif (common->nltype != NLTYPE_ANY)\n  {\n  SLJIT_ASSERT(common->nltype != NLTYPE_FIXED || common->newline < 128);\n\n  /* All newlines are ascii, just skip intermediate octets. */\n  jump[0] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  loop = LABEL();\n  if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, TMP2, SLJIT_MEM1(STR_PTR), IN_UCHARS(1)) == SLJIT_SUCCESS)\n    sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, TMP2, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  else\n    {\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    }\n\n  OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc0);\n  CMPTO(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80, loop);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  JUMPHERE(jump[0]);\n\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\n  OP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n  return;\n  }\n\njump[0] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\njump[1] = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0xc2);\njump[2] = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0xe2);\n\nskip_start = LABEL();\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc0);\njump[3] = CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80);\n\n/* Skip intermediate octets. */\nloop = LABEL();\njump[4] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc0);\nCMPTO(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80, loop);\n\nJUMPHERE(jump[3]);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nthree_byte_exit = LABEL();\nJUMPHERE(jump[0]);\nJUMPHERE(jump[4]);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Two byte long newline: 0x85. */\nJUMPHERE(jump[1]);\nCMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0x85, skip_start);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0x85);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Three byte long newlines: 0x2028 and 0x2029. */\nJUMPHERE(jump[2]);\nCMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80, skip_start);\nCMPTO(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0, three_byte_exit);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP2, 0, SLJIT_IMM, 0x80);\nCMPTO(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x40, skip_start);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0x2000);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfmoveback_invalid(compiler_common *common)\n{\n/* Goes one character back. */\nDEFINE_COMPILER;\nsljit_s32 i;\nstruct sljit_jump *jump;\nstruct sljit_jump *buffer_start_close;\nstruct sljit_label *exit_ok_label;\nstruct sljit_label *exit_invalid_label;\nstruct sljit_jump *exit_invalid[7];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xc0);\n\n/* Two-byte sequence. */\nbuffer_start_close = CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(2));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\njump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x20);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Three-byte sequence. */\nJUMPHERE(jump);\nexit_invalid[1] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, -0x40);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0);\njump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x10);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Four-byte sequence. */\nJUMPHERE(jump);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0 - 0x80);\nexit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x40);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xf0);\nexit_invalid[3] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x05);\n\nexit_ok_label = LABEL();\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Two-byte sequence. */\nJUMPHERE(buffer_start_close);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n\nexit_invalid[4] = CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\nCMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x20, exit_ok_label);\n\n/* Three-byte sequence. */\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nexit_invalid[5] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, -0x40);\nexit_invalid[6] = CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0);\nCMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x10, exit_ok_label);\n\n/* Four-byte sequences are not possible. */\n\nexit_invalid_label = LABEL();\nsljit_set_label(exit_invalid[5], exit_invalid_label);\nsljit_set_label(exit_invalid[6], exit_invalid_label);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[4]);\n/* -2 + 4 = 2 */\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n\nexit_invalid_label = LABEL();\nfor (i = 0; i < 4; i++)\n  sljit_set_label(exit_invalid[i], exit_invalid_label);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(4));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfpeakcharback(compiler_common *common)\n{\n/* Peak a character back. Does not modify STR_PTR. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump[2];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\njump[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x20);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0);\njump[1] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x10);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-4));\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0 - 0x80);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xf0);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nJUMPHERE(jump[1]);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nJUMPHERE(jump[0]);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfpeakcharback_invalid(compiler_common *common)\n{\n/* Peak a character back. Does not modify STR_PTR. */\nDEFINE_COMPILER;\nsljit_s32 i;\nsljit_s32 has_cmov = sljit_has_cpu_feature(SLJIT_HAS_CMOV);\nstruct sljit_jump *jump[2];\nstruct sljit_label *two_byte_entry;\nstruct sljit_label *three_byte_entry;\nstruct sljit_label *exit_invalid_label;\nstruct sljit_jump *exit_invalid[8];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(3));\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xc0);\njump[0] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\njump[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x1e);\n\ntwo_byte_entry = LABEL();\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n/* If TMP1 is in 0x80-0xbf range, TMP1 is also increased by (0x2 << 6). */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump[1]);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2 - 0x80);\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Three-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xe0);\njump[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x10);\n\nthree_byte_entry = LABEL();\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 12);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, -0xd800);\n  exit_invalid[2] = NULL;\n  }\nelse\n  exit_invalid[2] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n  exit_invalid[3] = NULL;\n  }\nelse\n  exit_invalid[3] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump[1]);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xe0 - 0x80);\nexit_invalid[4] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 12);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Four-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-4));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xf0);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 18);\n/* ADD is used instead of OR because of the SUB 0x10000 above. */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x100000);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR - 0x10000);\n  exit_invalid[5] = NULL;\n  }\nelse\n  exit_invalid[5] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x100000);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump[0]);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\njump[0] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\nCMPTO(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x1e, two_byte_entry);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2 - 0x80);\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\nexit_invalid[6] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Three-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xe0);\nCMPTO(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x10, three_byte_entry);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump[0]);\nexit_invalid[7] = CMP(SLJIT_GREATER, TMP2, 0, STR_PTR, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\nCMPTO(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x1e, two_byte_entry);\n\nexit_invalid_label = LABEL();\nfor (i = 0; i < 8; i++)\n  sljit_set_label(exit_invalid[i], exit_invalid_label);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n\n#if PCRE2_CODE_UNIT_WIDTH == 16\n\nstatic void do_utfreadchar_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-16 character. TMP1 contains the first half\nof the character (>= 0xd800). Return char value in TMP1. STR_PTR is\nundefined for invalid characters. */\nDEFINE_COMPILER;\nstruct sljit_jump *exit_invalid[3];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n/* TMP2 contains the high surrogate. */\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xdc00);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xdc00);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x10000);\nexit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x400);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[0]);\nJUMPHERE(exit_invalid[1]);\nJUMPHERE(exit_invalid[2]);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadnewline_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-16 character, specialized for newlines.\nTMP1 contains the first half of the character (>= 0xd800). Return\nchar value in TMP1. */\n\nDEFINE_COMPILER;\nstruct sljit_jump *exit_invalid[2];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n/* TMP2 contains the high surrogate. */\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xdc00);\n\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xdc00);\nOP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0x400);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0x10000);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCHAR_SHIFT);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[0]);\nJUMPHERE(exit_invalid[1]);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfmoveback_invalid(compiler_common *common)\n{\n/* Goes one character back. */\nDEFINE_COMPILER;\nstruct sljit_jump *exit_invalid[3];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nexit_invalid[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x400);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nexit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x400);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[0]);\nJUMPHERE(exit_invalid[1]);\nJUMPHERE(exit_invalid[2]);\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfpeakcharback_invalid(compiler_common *common)\n{\n/* Peak a character back. Does not modify STR_PTR. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_jump *exit_invalid[3];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\njump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\nexit_invalid[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xdc00);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000 - 0xdc00);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xd800);\nexit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n\nJUMPHERE(jump);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[0]);\nJUMPHERE(exit_invalid[1]);\nJUMPHERE(exit_invalid[2]);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == 16 */\n\n/* UCD_BLOCK_SIZE must be 128 (see the assert below). */\n#define UCD_BLOCK_MASK 127\n#define UCD_BLOCK_SHIFT 7\n\nstatic void do_getucd(compiler_common *common)\n{\n/* Search the UCD record for the character comes in TMP1.\nReturns chartype in TMP1 and UCD offset in TMP2. */\nDEFINE_COMPILER;\n#if PCRE2_CODE_UNIT_WIDTH == 32\nstruct sljit_jump *jump;\n#endif\n\n#if defined SLJIT_DEBUG && SLJIT_DEBUG\n/* dummy_ucd_record */\nconst ucd_record *record = GET_UCD(UNASSIGNED_UTF_CHAR);\nSLJIT_ASSERT(record->script == ucp_Unknown && record->chartype == ucp_Cn && record->gbprop == ucp_gbOther);\nSLJIT_ASSERT(record->caseset == 0 && record->other_case == 0);\n#endif\n\nSLJIT_ASSERT(UCD_BLOCK_SIZE == 128 && sizeof(ucd_record) == 12);\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\nif (!common->utf)\n  {\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n  JUMPHERE(jump);\n  }\n#endif\n\nOP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\nOP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_getucdtype(compiler_common *common)\n{\n/* Search the UCD record for the character comes in TMP1.\nReturns chartype in TMP1 and UCD offset in TMP2. */\nDEFINE_COMPILER;\n#if PCRE2_CODE_UNIT_WIDTH == 32\nstruct sljit_jump *jump;\n#endif\n\n#if defined SLJIT_DEBUG && SLJIT_DEBUG\n/* dummy_ucd_record */\nconst ucd_record *record = GET_UCD(UNASSIGNED_UTF_CHAR);\nSLJIT_ASSERT(record->script == ucp_Unknown && record->chartype == ucp_Cn && record->gbprop == ucp_gbOther);\nSLJIT_ASSERT(record->caseset == 0 && record->other_case == 0);\n#endif\n\nSLJIT_ASSERT(UCD_BLOCK_SIZE == 128 && sizeof(ucd_record) == 12);\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\nif (!common->utf)\n  {\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n  JUMPHERE(jump);\n  }\n#endif\n\nOP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\nOP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n\n/* TMP2 is multiplied by 12. Same as (TMP2 << 2) + ((TMP2 << 2) << 1). */\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM2(TMP1, TMP2), 1);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\n#endif /* SUPPORT_UNICODE */\n\nstatic SLJIT_INLINE struct sljit_label *mainloop_entry(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_label *mainloop;\nstruct sljit_label *newlinelabel = NULL;\nstruct sljit_jump *start;\nstruct sljit_jump *end = NULL;\nstruct sljit_jump *end2 = NULL;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_label *loop;\nstruct sljit_jump *jump;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\njump_list *newline = NULL;\nsljit_u32 overall_options = common->re->overall_options;\nBOOL hascrorlf = (common->re->flags & PCRE2_HASCRORLF) != 0;\nBOOL newlinecheck = FALSE;\nBOOL readuchar = FALSE;\n\nif (!(hascrorlf || (overall_options & PCRE2_FIRSTLINE) != 0)\n    && (common->nltype == NLTYPE_ANY || common->nltype == NLTYPE_ANYCRLF || common->newline > 255))\n  newlinecheck = TRUE;\n\nSLJIT_ASSERT(common->abort_label == NULL);\n\nif ((overall_options & PCRE2_FIRSTLINE) != 0)\n  {\n  /* Search for the end of the first line. */\n  SLJIT_ASSERT(common->match_end_ptr != 0);\n  OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    mainloop = LABEL();\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    end = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff, mainloop);\n    CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff, mainloop);\n    JUMPHERE(end);\n    OP2(SLJIT_SUB, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    }\n  else\n    {\n    end = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n    mainloop = LABEL();\n    /* Continual stores does not cause data dependency. */\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, STR_PTR, 0);\n    read_char(common, common->nlmin, common->nlmax, NULL, READ_CHAR_NEWLINE);\n    check_newlinechar(common, common->nltype, &newline, TRUE);\n    CMPTO(SLJIT_LESS, STR_PTR, 0, STR_END, 0, mainloop);\n    JUMPHERE(end);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, STR_PTR, 0);\n    set_jumps(newline, LABEL());\n    }\n\n  OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n  }\nelse if ((overall_options & PCRE2_USE_OFFSET_LIMIT) != 0)\n  {\n  /* Check whether offset limit is set and valid. */\n  SLJIT_ASSERT(common->match_end_ptr != 0);\n\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, offset_limit));\n    }\n  else\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, offset_limit));\n\n  OP1(SLJIT_MOV, TMP2, 0, STR_END, 0);\n  end = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw) PCRE2_UNSET);\n  if (HAS_VIRTUAL_REGISTERS)\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n  else\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif /* PCRE2_CODE_UNIT_WIDTH == [16|32] */\n  if (HAS_VIRTUAL_REGISTERS)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, begin));\n\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n  end2 = CMP(SLJIT_LESS_EQUAL, TMP2, 0, STR_END, 0);\n  OP1(SLJIT_MOV, TMP2, 0, STR_END, 0);\n  JUMPHERE(end2);\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n  add_jump(compiler, &common->abort, CMP(SLJIT_LESS, TMP2, 0, STR_PTR, 0));\n  JUMPHERE(end);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, TMP2, 0);\n  }\n\nstart = JUMP(SLJIT_JUMP);\n\nif (newlinecheck)\n  {\n  newlinelabel = LABEL();\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  end = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, common->newline & 0xff);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif /* PCRE2_CODE_UNIT_WIDTH == [16|32] */\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  end2 = JUMP(SLJIT_JUMP);\n  }\n\nmainloop = LABEL();\n\n/* Increasing the STR_PTR here requires one less jump in the most common case. */\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nif (common->utf && !common->invalid_utf) readuchar = TRUE;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\nif (newlinecheck) readuchar = TRUE;\n\nif (readuchar)\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n\nif (newlinecheck)\n  CMPTO(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff, newlinelabel);\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->invalid_utf)\n  {\n  /* Skip continuation code units. */\n  loop = LABEL();\n  jump = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\n  CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x40, loop);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPHERE(jump);\n  }\nelse if (common->utf)\n  {\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->invalid_utf)\n  {\n  /* Skip continuation code units. */\n  loop = LABEL();\n  jump = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xdc00);\n  CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x400, loop);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPHERE(jump);\n  }\nelse if (common->utf)\n  {\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n\n  if (sljit_has_cpu_feature(SLJIT_HAS_CMOV))\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x400);\n    CMOV(SLJIT_LESS, STR_PTR, TMP2, 0);\n    }\n  else\n    {\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x400);\n    OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_LESS);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n    }\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16] */\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\nJUMPHERE(start);\n\nif (newlinecheck)\n  {\n  JUMPHERE(end);\n  JUMPHERE(end2);\n  }\n\nreturn mainloop;\n}\n\n\nstatic SLJIT_INLINE void add_prefix_char(PCRE2_UCHAR chr, fast_forward_char_data *chars, BOOL last)\n{\nsljit_u32 i, count = chars->count;\n\nif (count == 255)\n  return;\n\nif (count == 0)\n  {\n  chars->count = 1;\n  chars->chars[0] = chr;\n\n  if (last)\n    chars->last_count = 1;\n  return;\n  }\n\nfor (i = 0; i < count; i++)\n  if (chars->chars[i] == chr)\n    return;\n\nif (count >= MAX_DIFF_CHARS)\n  {\n  chars->count = 255;\n  return;\n  }\n\nchars->chars[count] = chr;\nchars->count = count + 1;\n\nif (last)\n  chars->last_count++;\n}\n\nstatic int scan_prefix(compiler_common *common, PCRE2_SPTR cc, fast_forward_char_data *chars, int max_chars, sljit_u32 *rec_count)\n{\n/* Recursive function, which scans prefix literals. */\nBOOL last, any, class, caseless;\nint len, repeat, len_save, consumed = 0;\nsljit_u32 chr; /* Any unicode character. */\nsljit_u8 *bytes, *bytes_end, byte;\nPCRE2_SPTR alternative, cc_save, oc;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nPCRE2_UCHAR othercase[4];\n#elif defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 16\nPCRE2_UCHAR othercase[2];\n#else\nPCRE2_UCHAR othercase[1];\n#endif\n\nrepeat = 1;\nwhile (TRUE)\n  {\n  if (*rec_count == 0)\n    return 0;\n  (*rec_count)--;\n\n  last = TRUE;\n  any = FALSE;\n  class = FALSE;\n  caseless = FALSE;\n\n  switch (*cc)\n    {\n    case OP_CHARI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_CHAR:\n    last = FALSE;\n    cc++;\n    break;\n\n    case OP_SOD:\n    case OP_SOM:\n    case OP_SET_SOM:\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_EODN:\n    case OP_EOD:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_DOLL:\n    case OP_DOLLM:\n    /* Zero width assertions. */\n    cc++;\n    continue;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    cc = bracketend(cc);\n    continue;\n\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_POSPLUSI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_POSPLUS:\n    cc++;\n    break;\n\n    case OP_EXACTI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_EXACT:\n    repeat = GET2(cc, 1);\n    last = FALSE;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_POSQUERYI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_POSQUERY:\n    len = 1;\n    cc++;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(*cc)) len += GET_EXTRALEN(*cc);\n#endif\n    max_chars = scan_prefix(common, cc + len, chars, max_chars, rec_count);\n    if (max_chars == 0)\n      return consumed;\n    last = FALSE;\n    break;\n\n    case OP_KET:\n    cc += 1 + LINK_SIZE;\n    continue;\n\n    case OP_ALT:\n    cc += GET(cc, 1);\n    continue;\n\n    case OP_ONCE:\n    case OP_BRA:\n    case OP_BRAPOS:\n    case OP_CBRA:\n    case OP_CBRAPOS:\n    alternative = cc + GET(cc, 1);\n    while (*alternative == OP_ALT)\n      {\n      max_chars = scan_prefix(common, alternative + 1 + LINK_SIZE, chars, max_chars, rec_count);\n      if (max_chars == 0)\n        return consumed;\n      alternative += GET(alternative, 1);\n      }\n\n    if (*cc == OP_CBRA || *cc == OP_CBRAPOS)\n      cc += IMM2_SIZE;\n    cc += 1 + LINK_SIZE;\n    continue;\n\n    case OP_CLASS:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)(cc + 1), FALSE))\n      return consumed;\n#endif\n    class = TRUE;\n    break;\n\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    class = TRUE;\n    break;\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    cc += GET(cc, 1);\n    break;\n#endif\n\n    case OP_DIGIT:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)common->ctypes - cbit_length + cbit_digit, FALSE))\n      return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n    case OP_WHITESPACE:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)common->ctypes - cbit_length + cbit_space, FALSE))\n      return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n    case OP_WORDCHAR:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)common->ctypes - cbit_length + cbit_word, FALSE))\n      return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n    case OP_NOT:\n    case OP_NOTI:\n    cc++;\n    /* Fall through. */\n    case OP_NOT_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_ANY:\n    case OP_ALLANY:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n#ifdef SUPPORT_UNICODE\n    case OP_NOTPROP:\n    case OP_PROP:\n#if PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    cc += 1 + 2;\n    break;\n#endif\n\n    case OP_TYPEEXACT:\n    repeat = GET2(cc, 1);\n    cc += 1 + IMM2_SIZE;\n    continue;\n\n    case OP_NOTEXACT:\n    case OP_NOTEXACTI:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    repeat = GET2(cc, 1);\n    cc += 1 + IMM2_SIZE + 1;\n    break;\n\n    default:\n    return consumed;\n    }\n\n  if (any)\n    {\n    do\n      {\n      chars->count = 255;\n\n      consumed++;\n      if (--max_chars == 0)\n        return consumed;\n      chars++;\n      }\n    while (--repeat > 0);\n\n    repeat = 1;\n    continue;\n    }\n\n  if (class)\n    {\n    bytes = (sljit_u8*) (cc + 1);\n    cc += 1 + 32 / sizeof(PCRE2_UCHAR);\n\n    switch (*cc)\n      {\n      case OP_CRSTAR:\n      case OP_CRMINSTAR:\n      case OP_CRPOSSTAR:\n      case OP_CRQUERY:\n      case OP_CRMINQUERY:\n      case OP_CRPOSQUERY:\n      max_chars = scan_prefix(common, cc + 1, chars, max_chars, rec_count);\n      if (max_chars == 0)\n        return consumed;\n      break;\n\n      default:\n      case OP_CRPLUS:\n      case OP_CRMINPLUS:\n      case OP_CRPOSPLUS:\n      break;\n\n      case OP_CRRANGE:\n      case OP_CRMINRANGE:\n      case OP_CRPOSRANGE:\n      repeat = GET2(cc, 1);\n      if (repeat <= 0)\n        return consumed;\n      break;\n      }\n\n    do\n      {\n      if (bytes[31] & 0x80)\n        chars->count = 255;\n      else if (chars->count != 255)\n        {\n        bytes_end = bytes + 32;\n        chr = 0;\n        do\n          {\n          byte = *bytes++;\n          SLJIT_ASSERT((chr & 0x7) == 0);\n          if (byte == 0)\n            chr += 8;\n          else\n            {\n            do\n              {\n              if ((byte & 0x1) != 0)\n                add_prefix_char(chr, chars, TRUE);\n              byte >>= 1;\n              chr++;\n              }\n            while (byte != 0);\n            chr = (chr + 7) & ~7;\n            }\n          }\n        while (chars->count != 255 && bytes < bytes_end);\n        bytes = bytes_end - 32;\n        }\n\n      consumed++;\n      if (--max_chars == 0)\n        return consumed;\n      chars++;\n      }\n    while (--repeat > 0);\n\n    switch (*cc)\n      {\n      case OP_CRSTAR:\n      case OP_CRMINSTAR:\n      case OP_CRPOSSTAR:\n      return consumed;\n\n      case OP_CRQUERY:\n      case OP_CRMINQUERY:\n      case OP_CRPOSQUERY:\n      cc++;\n      break;\n\n      case OP_CRRANGE:\n      case OP_CRMINRANGE:\n      case OP_CRPOSRANGE:\n      if (GET2(cc, 1) != GET2(cc, 1 + IMM2_SIZE))\n        return consumed;\n      cc += 1 + 2 * IMM2_SIZE;\n      break;\n      }\n\n    repeat = 1;\n    continue;\n    }\n\n  len = 1;\n#ifdef SUPPORT_UNICODE\n  if (common->utf && HAS_EXTRALEN(*cc)) len += GET_EXTRALEN(*cc);\n#endif\n\n  if (caseless && char_has_othercase(common, cc))\n    {\n#ifdef SUPPORT_UNICODE\n    if (common->utf)\n      {\n      GETCHAR(chr, cc);\n      if ((int)PRIV(ord2utf)(char_othercase(common, chr), othercase) != len)\n        return consumed;\n      }\n    else\n#endif\n      {\n      chr = *cc;\n#ifdef SUPPORT_UNICODE\n      if (common->ucp && chr > 127)\n        othercase[0] = UCD_OTHERCASE(chr);\n      else\n#endif\n        othercase[0] = TABLE_GET(chr, common->fcc, chr);\n      }\n    }\n  else\n    {\n    caseless = FALSE;\n    othercase[0] = 0; /* Stops compiler warning - PH */\n    }\n\n  len_save = len;\n  cc_save = cc;\n  while (TRUE)\n    {\n    oc = othercase;\n    do\n      {\n      len--;\n      consumed++;\n\n      chr = *cc;\n      add_prefix_char(*cc, chars, len == 0);\n\n      if (caseless)\n        add_prefix_char(*oc, chars, len == 0);\n\n      if (--max_chars == 0)\n        return consumed;\n      chars++;\n      cc++;\n      oc++;\n      }\n    while (len > 0);\n\n    if (--repeat == 0)\n      break;\n\n    len = len_save;\n    cc = cc_save;\n    }\n\n  repeat = 1;\n  if (last)\n    return consumed;\n  }\n}\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstatic void jumpto_if_not_utf_char_start(struct sljit_compiler *compiler, sljit_s32 reg, struct sljit_label *label)\n{\n#if PCRE2_CODE_UNIT_WIDTH == 8\nOP2(SLJIT_AND, reg, 0, reg, 0, SLJIT_IMM, 0xc0);\nCMPTO(SLJIT_EQUAL, reg, 0, SLJIT_IMM, 0x80, label);\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nOP2(SLJIT_AND, reg, 0, reg, 0, SLJIT_IMM, 0xfc00);\nCMPTO(SLJIT_EQUAL, reg, 0, SLJIT_IMM, 0xdc00, label);\n#else\n#error \"Unknown code width\"\n#endif\n}\n#endif\n\n#include \"pcre2_jit_simd_inc.h\"\n\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD\n\nstatic BOOL check_fast_forward_char_pair_simd(compiler_common *common, fast_forward_char_data *chars, int max)\n{\n  sljit_s32 i, j, max_i = 0, max_j = 0;\n  sljit_u32 max_pri = 0;\n  PCRE2_UCHAR a1, a2, a_pri, b1, b2, b_pri;\n\n  for (i = max - 1; i >= 1; i--)\n    {\n    if (chars[i].last_count > 2)\n      {\n      a1 = chars[i].chars[0];\n      a2 = chars[i].chars[1];\n      a_pri = chars[i].last_count;\n\n      j = i - max_fast_forward_char_pair_offset();\n      if (j < 0)\n        j = 0;\n\n      while (j < i)\n        {\n        b_pri = chars[j].last_count;\n        if (b_pri > 2 && a_pri + b_pri >= max_pri)\n          {\n          b1 = chars[j].chars[0];\n          b2 = chars[j].chars[1];\n\n          if (a1 != b1 && a1 != b2 && a2 != b1 && a2 != b2)\n            {\n            max_pri = a_pri + b_pri;\n            max_i = i;\n            max_j = j;\n            }\n          }\n        j++;\n        }\n      }\n    }\n\nif (max_pri == 0)\n  return FALSE;\n\nfast_forward_char_pair_simd(common, max_i, chars[max_i].chars[0], chars[max_i].chars[1], max_j, chars[max_j].chars[0], chars[max_j].chars[1]);\nreturn TRUE;\n}\n\n#endif /* JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD */\n\nstatic void fast_forward_first_char2(compiler_common *common, PCRE2_UCHAR char1, PCRE2_UCHAR char2, sljit_s32 offset)\n{\nDEFINE_COMPILER;\nstruct sljit_label *start;\nstruct sljit_jump *match;\nstruct sljit_jump *partial_quit;\nPCRE2_UCHAR mask;\nBOOL has_match_end = (common->match_end_ptr != 0);\n\nSLJIT_ASSERT(common->mode == PCRE2_JIT_COMPLETE || offset == 0);\n\nif (has_match_end)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n\nif (offset > 0)\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(offset));\n\nif (has_match_end)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(offset + 1));\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_END, 0, TMP1, 0);\n  CMOV(SLJIT_GREATER, STR_END, TMP1, 0);\n  }\n\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_SIMD\n\nif (JIT_HAS_FAST_FORWARD_CHAR_SIMD)\n  {\n  fast_forward_char_simd(common, char1, char2, offset);\n\n  if (offset > 0)\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(offset));\n\n  if (has_match_end)\n    OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n  return;\n  }\n\n#endif\n\nstart = LABEL();\n\npartial_quit = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nif (common->mode == PCRE2_JIT_COMPLETE)\n  add_jump(compiler, &common->failed_match, partial_quit);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (char1 == char2)\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, char1, start);\nelse\n  {\n  mask = char1 ^ char2;\n  if (is_powerof2(mask))\n    {\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, mask);\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, char1 | mask, start);\n    }\n  else\n    {\n    match = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, char1);\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, char2, start);\n    JUMPHERE(match);\n    }\n  }\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nif (common->utf && offset > 0)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-(offset + 1)));\n  jumpto_if_not_utf_char_start(compiler, TMP1, start);\n  }\n#endif\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(offset + 1));\n\nif (common->mode != PCRE2_JIT_COMPLETE)\n  JUMPHERE(partial_quit);\n\nif (has_match_end)\n  OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n}\n\nstatic SLJIT_INLINE BOOL fast_forward_first_n_chars(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_label *start;\nstruct sljit_jump *match;\nfast_forward_char_data chars[MAX_N_CHARS];\nsljit_s32 offset;\nPCRE2_UCHAR mask;\nPCRE2_UCHAR *char_set, *char_set_end;\nint i, max, from;\nint range_right = -1, range_len;\nsljit_u8 *update_table = NULL;\nBOOL in_range;\nsljit_u32 rec_count;\n\nfor (i = 0; i < MAX_N_CHARS; i++)\n  {\n  chars[i].count = 0;\n  chars[i].last_count = 0;\n  }\n\nrec_count = 10000;\nmax = scan_prefix(common, common->start, chars, MAX_N_CHARS, &rec_count);\n\nif (max < 1)\n  return FALSE;\n\n/* Convert last_count to priority. */\nfor (i = 0; i < max; i++)\n  {\n  SLJIT_ASSERT(chars[i].count > 0 && chars[i].last_count <= chars[i].count);\n\n  if (chars[i].count == 1)\n    {\n    chars[i].last_count = (chars[i].last_count == 1) ? 7 : 5;\n    /* Simplifies algorithms later. */\n    chars[i].chars[1] = chars[i].chars[0];\n    }\n  else if (chars[i].count == 2)\n    {\n    SLJIT_ASSERT(chars[i].chars[0] != chars[i].chars[1]);\n\n    if (is_powerof2(chars[i].chars[0] ^ chars[i].chars[1]))\n      chars[i].last_count = (chars[i].last_count == 2) ? 6 : 4;\n    else\n      chars[i].last_count = (chars[i].last_count == 2) ? 3 : 2;\n    }\n  else\n    chars[i].last_count = (chars[i].count == 255) ? 0 : 1;\n  }\n\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD\nif (JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD && check_fast_forward_char_pair_simd(common, chars, max))\n  return TRUE;\n#endif\n\nin_range = FALSE;\n/* Prevent compiler \"uninitialized\" warning */\nfrom = 0;\nrange_len = 4 /* minimum length */ - 1;\nfor (i = 0; i <= max; i++)\n  {\n  if (in_range && (i - from) > range_len && (chars[i - 1].count < 255))\n    {\n    range_len = i - from;\n    range_right = i - 1;\n    }\n\n  if (i < max && chars[i].count < 255)\n    {\n    SLJIT_ASSERT(chars[i].count > 0);\n    if (!in_range)\n      {\n      in_range = TRUE;\n      from = i;\n      }\n    }\n  else\n    in_range = FALSE;\n  }\n\nif (range_right >= 0)\n  {\n  update_table = (sljit_u8 *)allocate_read_only_data(common, 256);\n  if (update_table == NULL)\n    return TRUE;\n  memset(update_table, IN_UCHARS(range_len), 256);\n\n  for (i = 0; i < range_len; i++)\n    {\n    SLJIT_ASSERT(chars[range_right - i].count > 0 && chars[range_right - i].count < 255);\n\n    char_set = chars[range_right - i].chars;\n    char_set_end = char_set + chars[range_right - i].count;\n    do\n      {\n      if (update_table[(*char_set) & 0xff] > IN_UCHARS(i))\n        update_table[(*char_set) & 0xff] = IN_UCHARS(i);\n      char_set++;\n      }\n    while (char_set < char_set_end);\n    }\n  }\n\noffset = -1;\n/* Scan forward. */\nfor (i = 0; i < max; i++)\n  {\n  if (range_right == i)\n    continue;\n\n  if (offset == -1)\n    {\n    if (chars[i].last_count >= 2)\n      offset = i;\n    }\n  else if (chars[offset].last_count < chars[i].last_count)\n    offset = i;\n  }\n\nSLJIT_ASSERT(offset == -1 || (chars[offset].count >= 1 && chars[offset].count <= 2));\n\nif (range_right < 0)\n  {\n  if (offset < 0)\n    return FALSE;\n  /* Works regardless the value is 1 or 2. */\n  fast_forward_first_char2(common, chars[offset].chars[0], chars[offset].chars[1], offset);\n  return TRUE;\n  }\n\nSLJIT_ASSERT(range_right != offset);\n\nif (common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_LESS, STR_END, 0, STR_END, 0, SLJIT_IMM, IN_UCHARS(max));\n  add_jump(compiler, &common->failed_match, JUMP(SLJIT_LESS));\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_END, 0, TMP1, 0);\n  CMOV(SLJIT_GREATER, STR_END, TMP1, 0);\n  }\nelse\n  {\n  OP2(SLJIT_SUB | SLJIT_SET_LESS, STR_END, 0, STR_END, 0, SLJIT_IMM, IN_UCHARS(max));\n  add_jump(compiler, &common->failed_match, JUMP(SLJIT_LESS));\n  }\n\nSLJIT_ASSERT(range_right >= 0);\n\nif (!HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, SLJIT_IMM, (sljit_sw)update_table);\n\nstart = LABEL();\nadd_jump(compiler, &common->failed_match, CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0));\n\n#if PCRE2_CODE_UNIT_WIDTH == 8 || (defined SLJIT_LITTLE_ENDIAN && SLJIT_LITTLE_ENDIAN)\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(range_right));\n#else\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(range_right + 1) - 1);\n#endif\n\nif (!HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM2(RETURN_ADDR, TMP1), 0);\nelse\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)update_table);\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\nCMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, start);\n\nif (offset >= 0)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(offset));\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  if (chars[offset].count == 1)\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, chars[offset].chars[0], start);\n  else\n    {\n    mask = chars[offset].chars[0] ^ chars[offset].chars[1];\n    if (is_powerof2(mask))\n      {\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, mask);\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, chars[offset].chars[0] | mask, start);\n      }\n    else\n      {\n      match = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, chars[offset].chars[0]);\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, chars[offset].chars[1], start);\n      JUMPHERE(match);\n      }\n    }\n  }\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nif (common->utf && offset != 0)\n  {\n  if (offset < 0)\n    {\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    }\n  else\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n\n  jumpto_if_not_utf_char_start(compiler, TMP1, start);\n\n  if (offset < 0)\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  }\n#endif\n\nif (offset >= 0)\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (common->match_end_ptr != 0)\n  OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\nelse\n  OP2(SLJIT_ADD, STR_END, 0, STR_END, 0, SLJIT_IMM, IN_UCHARS(max));\nreturn TRUE;\n}\n\nstatic SLJIT_INLINE void fast_forward_first_char(compiler_common *common)\n{\nPCRE2_UCHAR first_char = (PCRE2_UCHAR)(common->re->first_codeunit);\nPCRE2_UCHAR oc;\n\noc = first_char;\nif ((common->re->flags & PCRE2_FIRSTCASELESS) != 0)\n  {\n  oc = TABLE_GET(first_char, common->fcc, first_char);\n#if defined SUPPORT_UNICODE\n  if (first_char > 127 && (common->utf || common->ucp))\n    oc = UCD_OTHERCASE(first_char);\n#endif\n  }\n\nfast_forward_first_char2(common, first_char, oc, 0);\n}\n\nstatic SLJIT_INLINE void fast_forward_newline(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nstruct sljit_jump *lastchar = NULL;\nstruct sljit_jump *firstchar;\nstruct sljit_jump *quit = NULL;\nstruct sljit_jump *foundcr = NULL;\nstruct sljit_jump *notfoundnl;\njump_list *newline = NULL;\n\nif (common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n  OP1(SLJIT_MOV, STR_END, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  }\n\nif (common->nltype == NLTYPE_FIXED && common->newline > 255)\n  {\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD\n  if (JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD && common->mode == PCRE2_JIT_COMPLETE)\n    {\n    if (HAS_VIRTUAL_REGISTERS)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n      }\n    firstchar = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2U(SLJIT_SUB | SLJIT_SET_Z, STR_PTR, 0, TMP1, 0);\n    OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_NOT_EQUAL);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n\n    fast_forward_char_pair_simd(common, 1, common->newline & 0xff, common->newline & 0xff, 0, (common->newline >> 8) & 0xff, (common->newline >> 8) & 0xff);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    }\n  else\n#endif /* JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD */\n    {\n    lastchar = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n    if (HAS_VIRTUAL_REGISTERS)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n      }\n    firstchar = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, STR_PTR, 0, TMP1, 0);\n    OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER_EQUAL);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\n    loop = LABEL();\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    quit = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff, loop);\n    CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff, loop);\n\n    JUMPHERE(quit);\n    JUMPHERE(lastchar);\n    }\n\n  JUMPHERE(firstchar);\n\n  if (common->match_end_ptr != 0)\n    OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n  return;\n  }\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n  }\nelse\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\n\n/* Example: match /^/ to \\r\\n from offset 1. */\nfirstchar = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n\nif (common->nltype == NLTYPE_ANY)\n  move_back(common, NULL, FALSE);\nelse\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nloop = LABEL();\ncommon->ff_newline_shortcut = loop;\n\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_SIMD\nif (JIT_HAS_FAST_FORWARD_CHAR_SIMD && (common->nltype == NLTYPE_FIXED || common->nltype == NLTYPE_ANYCRLF))\n  {\n  if (common->nltype == NLTYPE_ANYCRLF)\n    {\n    fast_forward_char_simd(common, CHAR_CR, CHAR_LF, 0);\n    if (common->mode != PCRE2_JIT_COMPLETE)\n      lastchar = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    quit = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n    }\n   else\n    {\n    fast_forward_char_simd(common, common->newline, common->newline, 0);\n\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    if (common->mode != PCRE2_JIT_COMPLETE)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_PTR, 0, STR_END, 0);\n      CMOV(SLJIT_GREATER, STR_PTR, STR_END, 0);\n      }\n    }\n  }\nelse\n#endif /* JIT_HAS_FAST_FORWARD_CHAR_SIMD */\n  {\n  read_char(common, common->nlmin, common->nlmax, NULL, READ_CHAR_NEWLINE);\n  lastchar = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  if (common->nltype == NLTYPE_ANY || common->nltype == NLTYPE_ANYCRLF)\n    foundcr = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n  check_newlinechar(common, common->nltype, &newline, FALSE);\n  set_jumps(newline, loop);\n  }\n\nif (common->nltype == NLTYPE_ANY || common->nltype == NLTYPE_ANYCRLF)\n  {\n  if (quit == NULL)\n    {\n    quit = JUMP(SLJIT_JUMP);\n    JUMPHERE(foundcr);\n    }\n\n  notfoundnl = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, CHAR_NL);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  JUMPHERE(notfoundnl);\n  JUMPHERE(quit);\n  }\n\nif (lastchar)\n  JUMPHERE(lastchar);\nJUMPHERE(firstchar);\n\nif (common->match_end_ptr != 0)\n  OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n}\n\nstatic BOOL optimize_class(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks);\n\nstatic SLJIT_INLINE void fast_forward_start_bits(compiler_common *common)\n{\nDEFINE_COMPILER;\nconst sljit_u8 *start_bits = common->re->start_bitmap;\nstruct sljit_label *start;\nstruct sljit_jump *partial_quit;\n#if PCRE2_CODE_UNIT_WIDTH != 8\nstruct sljit_jump *found = NULL;\n#endif\njump_list *matches = NULL;\n\nif (common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, STR_END, 0);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_END, 0, TMP1, 0);\n  CMOV(SLJIT_GREATER, STR_END, TMP1, 0);\n  }\n\nstart = LABEL();\n\npartial_quit = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nif (common->mode == PCRE2_JIT_COMPLETE)\n  add_jump(compiler, &common->failed_match, partial_quit);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (!optimize_class(common, start_bits, (start_bits[31] & 0x80) != 0, FALSE, &matches))\n  {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  if ((start_bits[31] & 0x80) != 0)\n    found = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 255);\n  else\n    CMPTO(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 255, start);\n#elif defined SUPPORT_UNICODE\n  if (common->utf && is_char7_bitset(start_bits, FALSE))\n    CMPTO(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 127, start);\n#endif\n  OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n  OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)start_bits);\n  if (!HAS_VIRTUAL_REGISTERS)\n    {\n    OP2(SLJIT_SHL, TMP3, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP3, 0);\n    }\n  else\n    {\n    OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n    }\n  JUMPTO(SLJIT_ZERO, start);\n  }\nelse\n  set_jumps(matches, start);\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\nif (found != NULL)\n  JUMPHERE(found);\n#endif\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (common->mode != PCRE2_JIT_COMPLETE)\n  JUMPHERE(partial_quit);\n\nif (common->match_end_ptr != 0)\n  OP1(SLJIT_MOV, STR_END, 0, RETURN_ADDR, 0);\n}\n\nstatic SLJIT_INLINE jump_list *search_requested_char(compiler_common *common, PCRE2_UCHAR req_char, BOOL caseless, BOOL has_firstchar)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nstruct sljit_jump *toolong;\nstruct sljit_jump *already_found;\nstruct sljit_jump *found;\nstruct sljit_jump *found_oc = NULL;\njump_list *not_found = NULL;\nsljit_u32 oc, bit;\n\nSLJIT_ASSERT(common->req_char_ptr != 0);\nOP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(REQ_CU_MAX) * 100);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->req_char_ptr);\ntoolong = CMP(SLJIT_LESS, TMP2, 0, STR_END, 0);\nalready_found = CMP(SLJIT_LESS, STR_PTR, 0, TMP1, 0);\n\nif (has_firstchar)\n  OP2(SLJIT_ADD, TMP1, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nelse\n  OP1(SLJIT_MOV, TMP1, 0, STR_PTR, 0);\n\noc = req_char;\nif (caseless)\n  {\n  oc = TABLE_GET(req_char, common->fcc, req_char);\n#if defined SUPPORT_UNICODE\n  if (req_char > 127 && (common->utf || common->ucp))\n    oc = UCD_OTHERCASE(req_char);\n#endif\n  }\n\n#ifdef JIT_HAS_FAST_REQUESTED_CHAR_SIMD\nif (JIT_HAS_FAST_REQUESTED_CHAR_SIMD)\n  {\n  not_found = fast_requested_char_simd(common, req_char, oc);\n  }\nelse\n#endif\n  {\n  loop = LABEL();\n  add_jump(compiler, &not_found, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, STR_END, 0));\n\n  OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(TMP1), 0);\n\n  if (req_char == oc)\n    found = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, req_char);\n  else\n    {\n    bit = req_char ^ oc;\n    if (is_powerof2(bit))\n      {\n       OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, bit);\n      found = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, req_char | bit);\n      }\n    else\n      {\n      found = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, req_char);\n      found_oc = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, oc);\n      }\n    }\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_JUMP, loop);\n\n  JUMPHERE(found);\n  if (found_oc)\n    JUMPHERE(found_oc);\n  }\n\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->req_char_ptr, TMP1, 0);\n\nJUMPHERE(already_found);\nJUMPHERE(toolong);\nreturn not_found;\n}\n\nstatic void do_revertframes(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_label *mainloop;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\nGET_LOCAL_BASE(TMP1, 0, 0);\n\n/* Drop frames until we reach STACK_TOP. */\nmainloop = LABEL();\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), -sizeof(sljit_sw));\njump = CMP(SLJIT_SIG_LESS_EQUAL, TMP2, 0, SLJIT_IMM, 0);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), sizeof(sljit_sw), SLJIT_MEM1(STACK_TOP), -(3 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 3 * sizeof(sljit_sw));\n  }\nelse\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP1(SLJIT_MOV, TMP3, 0, SLJIT_MEM1(STACK_TOP), -(3 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 3 * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, TMP1, 0);\n  GET_LOCAL_BASE(TMP1, 0, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), sizeof(sljit_sw), TMP3, 0);\n  }\nJUMPTO(SLJIT_JUMP, mainloop);\n\nJUMPHERE(jump);\njump = CMP(SLJIT_NOT_ZERO /* SIG_LESS */, TMP2, 0, SLJIT_IMM, 0);\n/* End of reverting values. */\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\nOP1(SLJIT_NEG, TMP2, 0, TMP2, 0);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 2 * sizeof(sljit_sw));\n  }\nelse\n  {\n  OP1(SLJIT_MOV, TMP3, 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 2 * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, TMP3, 0);\n  }\nJUMPTO(SLJIT_JUMP, mainloop);\n}\n\nstatic void check_wordboundary(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *skipread;\njump_list *skipread_list = NULL;\n#ifdef SUPPORT_UNICODE\nstruct sljit_label *valid_utf;\njump_list *invalid_utf1 = NULL;\n#endif /* SUPPORT_UNICODE */\njump_list *invalid_utf2 = NULL;\n#if PCRE2_CODE_UNIT_WIDTH != 8 || defined SUPPORT_UNICODE\nstruct sljit_jump *jump;\n#endif /* PCRE2_CODE_UNIT_WIDTH != 8 || SUPPORT_UNICODE */\n\nSLJIT_COMPILE_ASSERT(ctype_word == 0x10, ctype_word_must_be_16);\n\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n/* Get type of the previous char, and put it to TMP3. */\nOP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\nOP1(SLJIT_MOV, TMP3, 0, SLJIT_IMM, 0);\nskipread = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n\n#ifdef SUPPORT_UNICODE\nif (common->invalid_utf)\n  {\n  peek_char_back(common, READ_CHAR_MAX, &invalid_utf1);\n\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    {\n    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n    OP1(SLJIT_MOV, TMP2, 0, STR_PTR, 0);\n    move_back(common, NULL, TRUE);\n    check_start_used_ptr(common);\n    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n    OP1(SLJIT_MOV, STR_PTR, 0, TMP2, 0);\n    }\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n  if (common->mode == PCRE2_JIT_COMPLETE)\n    peek_char_back(common, READ_CHAR_MAX, NULL);\n  else\n    {\n    move_back(common, NULL, TRUE);\n    check_start_used_ptr(common);\n    read_char(common, 0, READ_CHAR_MAX, NULL, READ_CHAR_UPDATE_STR_PTR);\n    }\n  }\n\n/* Testing char type. */\n#ifdef SUPPORT_UNICODE\nif (common->ucp)\n  {\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 1);\n  jump = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_UNDERSCORE);\n  add_jump(compiler, &common->getucdtype, JUMP(SLJIT_FAST_CALL));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Ll);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n  OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Nd - ucp_Ll);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP3, 0, TMP2, 0);\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#elif defined SUPPORT_UNICODE\n  /* Here TMP3 has already been zeroed. */\n  jump = NULL;\n  if (common->utf)\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), common->ctypes);\n  OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 4 /* ctype_word */);\n  OP2(SLJIT_AND, TMP3, 0, TMP1, 0, SLJIT_IMM, 1);\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  JUMPHERE(jump);\n#elif defined SUPPORT_UNICODE\n  if (jump != NULL)\n    JUMPHERE(jump);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n  }\nJUMPHERE(skipread);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\ncheck_str_end(common, &skipread_list);\npeek_char(common, READ_CHAR_MAX, SLJIT_MEM1(SLJIT_SP), LOCALS1, &invalid_utf2);\n\n/* Testing char type. This is a code duplication. */\n#ifdef SUPPORT_UNICODE\n\nvalid_utf = LABEL();\n\nif (common->ucp)\n  {\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 1);\n  jump = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_UNDERSCORE);\n  add_jump(compiler, &common->getucdtype, JUMP(SLJIT_FAST_CALL));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Ll);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n  OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Nd - ucp_Ll);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n  JUMPHERE(jump);\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  /* TMP2 may be destroyed by peek_char. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\n  jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#elif defined SUPPORT_UNICODE\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\n  jump = NULL;\n  if (common->utf)\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#endif\n  OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP1), common->ctypes);\n  OP2(SLJIT_LSHR, TMP2, 0, TMP2, 0, SLJIT_IMM, 4 /* ctype_word */);\n  OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  JUMPHERE(jump);\n#elif defined SUPPORT_UNICODE\n  if (jump != NULL)\n    JUMPHERE(jump);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n  }\nset_jumps(skipread_list, LABEL());\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP2(SLJIT_XOR | SLJIT_SET_Z, TMP2, 0, TMP2, 0, TMP3, 0);\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n\n#ifdef SUPPORT_UNICODE\nif (common->invalid_utf)\n  {\n  set_jumps(invalid_utf1, LABEL());\n\n  peek_char(common, READ_CHAR_MAX, SLJIT_MEM1(SLJIT_SP), LOCALS1, NULL);\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR, valid_utf);\n\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, -1);\n  OP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n\n  set_jumps(invalid_utf2, LABEL());\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  OP1(SLJIT_MOV, TMP2, 0, TMP3, 0);\n  OP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n  }\n#endif /* SUPPORT_UNICODE */\n}\n\nstatic BOOL optimize_class_ranges(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks)\n{\n/* May destroy TMP1. */\nDEFINE_COMPILER;\nint ranges[MAX_CLASS_RANGE_SIZE];\nsljit_u8 bit, cbit, all;\nint i, byte, length = 0;\n\nbit = bits[0] & 0x1;\n/* All bits will be zero or one (since bit is zero or one). */\nall = -bit;\n\nfor (i = 0; i < 256; )\n  {\n  byte = i >> 3;\n  if ((i & 0x7) == 0 && bits[byte] == all)\n    i += 8;\n  else\n    {\n    cbit = (bits[byte] >> (i & 0x7)) & 0x1;\n    if (cbit != bit)\n      {\n      if (length >= MAX_CLASS_RANGE_SIZE)\n        return FALSE;\n      ranges[length] = i;\n      length++;\n      bit = cbit;\n      all = -cbit;\n      }\n    i++;\n    }\n  }\n\nif (((bit == 0) && nclass) || ((bit == 1) && !nclass))\n  {\n  if (length >= MAX_CLASS_RANGE_SIZE)\n    return FALSE;\n  ranges[length] = 256;\n  length++;\n  }\n\nif (length < 0 || length > 4)\n  return FALSE;\n\nbit = bits[0] & 0x1;\nif (invert) bit ^= 0x1;\n\n/* No character is accepted. */\nif (length == 0 && bit == 0)\n  add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n\nswitch(length)\n  {\n  case 0:\n  /* When bit != 0, all characters are accepted. */\n  return TRUE;\n\n  case 1:\n  add_jump(compiler, backtracks, CMP(bit == 0 ? SLJIT_LESS : SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[0]));\n  return TRUE;\n\n  case 2:\n  if (ranges[0] + 1 != ranges[1])\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[0]);\n    add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_LESS : SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_EQUAL : SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[0]));\n  return TRUE;\n\n  case 3:\n  if (bit != 0)\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[2]));\n    if (ranges[0] + 1 != ranges[1])\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[0]);\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]));\n      }\n    else\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[0]));\n    return TRUE;\n    }\n\n  add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[0]));\n  if (ranges[1] + 1 != ranges[2])\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[1]);\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[2] - ranges[1]));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[1]));\n  return TRUE;\n\n  case 4:\n  if ((ranges[1] - ranges[0]) == (ranges[3] - ranges[2])\n      && (ranges[0] | (ranges[2] - ranges[0])) == ranges[2]\n      && (ranges[1] & (ranges[2] - ranges[0])) == 0\n      && is_powerof2(ranges[2] - ranges[0]))\n    {\n    SLJIT_ASSERT((ranges[0] & (ranges[2] - ranges[0])) == 0 && (ranges[2] & ranges[3] & (ranges[2] - ranges[0])) != 0);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[2] - ranges[0]);\n    if (ranges[2] + 1 != ranges[3])\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[2]);\n      add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_LESS : SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[3] - ranges[2]));\n      }\n    else\n      add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_EQUAL : SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[2]));\n    return TRUE;\n    }\n\n  if (bit != 0)\n    {\n    i = 0;\n    if (ranges[0] + 1 != ranges[1])\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[0]);\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]));\n      i = ranges[0];\n      }\n    else\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[0]));\n\n    if (ranges[2] + 1 != ranges[3])\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[2] - i);\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[3] - ranges[2]));\n      }\n    else\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[2] - i));\n    return TRUE;\n    }\n\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[0]);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[3] - ranges[0]));\n  if (ranges[1] + 1 != ranges[2])\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]);\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[2] - ranges[1]));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]));\n  return TRUE;\n\n  default:\n  SLJIT_UNREACHABLE();\n  return FALSE;\n  }\n}\n\nstatic BOOL optimize_class_chars(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks)\n{\n/* May destroy TMP1. */\nDEFINE_COMPILER;\nuint16_t char_list[MAX_CLASS_CHARS_SIZE];\nuint8_t byte;\nsljit_s32 type;\nint i, j, k, len, c;\n\nif (!sljit_has_cpu_feature(SLJIT_HAS_CMOV))\n  return FALSE;\n\nlen = 0;\n\nfor (i = 0; i < 32; i++)\n  {\n  byte = bits[i];\n\n  if (nclass)\n    byte = ~byte;\n\n  j = 0;\n  while (byte != 0)\n    {\n    if (byte & 0x1)\n      {\n      c = i * 8 + j;\n\n      k = len;\n\n      if ((c & 0x20) != 0)\n        {\n        for (k = 0; k < len; k++)\n          if (char_list[k] == c - 0x20)\n            {\n            char_list[k] |= 0x120;\n            break;\n            }\n        }\n\n      if (k == len)\n        {\n        if (len >= MAX_CLASS_CHARS_SIZE)\n          return FALSE;\n\n        char_list[len++] = (uint16_t) c;\n        }\n      }\n\n    byte >>= 1;\n    j++;\n    }\n  }\n\nif (len == 0) return FALSE;  /* Should never occur, but stops analyzers complaining. */\n\ni = 0;\nj = 0;\n\nif (char_list[0] == 0)\n  {\n  i++;\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0);\n  OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_ZERO);\n  }\nelse\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\n\nwhile (i < len)\n  {\n  if ((char_list[i] & 0x100) != 0)\n    j++;\n  else\n    {\n    OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, char_list[i]);\n    CMOV(SLJIT_ZERO, TMP2, TMP1, 0);\n    }\n  i++;\n  }\n\nif (j != 0)\n  {\n  OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x20);\n\n  for (i = 0; i < len; i++)\n    if ((char_list[i] & 0x100) != 0)\n      {\n      j--;\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, char_list[i] & 0xff);\n      CMOV(SLJIT_ZERO, TMP2, TMP1, 0);\n      }\n  }\n\nif (invert)\n  nclass = !nclass;\n\ntype = nclass ? SLJIT_NOT_EQUAL : SLJIT_EQUAL;\nadd_jump(compiler, backtracks, CMP(type, TMP2, 0, SLJIT_IMM, 0));\nreturn TRUE;\n}\n\nstatic BOOL optimize_class(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks)\n{\n/* May destroy TMP1. */\nif (optimize_class_ranges(common, bits, nclass, invert, backtracks))\n  return TRUE;\nreturn optimize_class_chars(common, bits, nclass, invert, backtracks);\n}\n\nstatic void check_anynewline(compiler_common *common)\n{\n/* Check whether TMP1 contains a newline character. TMP2 destroyed. */\nDEFINE_COMPILER;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x0a);\nOP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x0d - 0x0a);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x0a);\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n#endif\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x1);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x2029 - 0x0a);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  }\n#endif\n#endif /* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == [16|32] */\nOP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void check_hspace(compiler_common *common)\n{\n/* Check whether TMP1 contains a newline character. TMP2 destroyed. */\nDEFINE_COMPILER;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x09);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x20);\nOP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0xa0);\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n#endif\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x1680);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x2000);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x200A - 0x2000);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x202f - 0x2000);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x205f - 0x2000);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x3000 - 0x2000);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  }\n#endif\n#endif /* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == [16|32] */\nOP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void check_vspace(compiler_common *common)\n{\n/* Check whether TMP1 contains a newline character. TMP2 destroyed. */\nDEFINE_COMPILER;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x0a);\nOP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x0d - 0x0a);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x0a);\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n#endif\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x1);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x2029 - 0x0a);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  }\n#endif\n#endif /* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == [16|32] */\nOP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_casefulcmp(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_label *label;\nint char1_reg;\nint char2_reg;\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  char1_reg = STR_END;\n  char2_reg = STACK_TOP;\n  }\nelse\n  {\n  char1_reg = TMP3;\n  char2_reg = RETURN_ADDR;\n  }\n\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\nif (char1_reg == STR_END)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, char1_reg, 0);\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, char2_reg, 0);\n  }\n\nif (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  {\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  jump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_NOT_ZERO, label);\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  }\nelse if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  {\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  jump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_NOT_ZERO, label);\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  }\nelse\n  {\n  label = LABEL();\n  OP1(MOV_UCHAR, char1_reg, 0, SLJIT_MEM1(TMP1), 0);\n  OP1(MOV_UCHAR, char2_reg, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  jump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_NOT_ZERO, label);\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  }\n\nif (char1_reg == STR_END)\n  {\n  OP1(SLJIT_MOV, char1_reg, 0, TMP3, 0);\n  OP1(SLJIT_MOV, char2_reg, 0, RETURN_ADDR, 0);\n  }\n\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n}\n\nstatic void do_caselesscmp(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_label *label;\nint char1_reg = STR_END;\nint char2_reg;\nint lcc_table;\nint opt_type = 0;\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  char2_reg = STACK_TOP;\n  lcc_table = STACK_LIMIT;\n  }\nelse\n  {\n  char2_reg = RETURN_ADDR;\n  lcc_table = TMP3;\n  }\n\nif (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  opt_type = 1;\nelse if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  opt_type = 2;\n\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS1, char1_reg, 0);\n\nif (char2_reg == STACK_TOP)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, char2_reg, 0);\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, lcc_table, 0);\n  }\n\nOP1(SLJIT_MOV, lcc_table, 0, SLJIT_IMM, common->lcc);\n\nif (opt_type == 1)\n  {\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  }\nelse if (opt_type == 2)\n  {\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  }\nelse\n  {\n  label = LABEL();\n  OP1(MOV_UCHAR, char1_reg, 0, SLJIT_MEM1(TMP1), 0);\n  OP1(MOV_UCHAR, char2_reg, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  }\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\njump = CMP(SLJIT_GREATER, char1_reg, 0, SLJIT_IMM, 255);\n#endif\nOP1(SLJIT_MOV_U8, char1_reg, 0, SLJIT_MEM2(lcc_table, char1_reg), 0);\n#if PCRE2_CODE_UNIT_WIDTH != 8\nJUMPHERE(jump);\njump = CMP(SLJIT_GREATER, char2_reg, 0, SLJIT_IMM, 255);\n#endif\nOP1(SLJIT_MOV_U8, char2_reg, 0, SLJIT_MEM2(lcc_table, char2_reg), 0);\n#if PCRE2_CODE_UNIT_WIDTH != 8\nJUMPHERE(jump);\n#endif\n\nif (opt_type == 0)\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\njump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\nOP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\nJUMPTO(SLJIT_NOT_ZERO, label);\n\nJUMPHERE(jump);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n\nif (opt_type == 2)\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (char2_reg == STACK_TOP)\n  {\n  OP1(SLJIT_MOV, char2_reg, 0, TMP3, 0);\n  OP1(SLJIT_MOV, lcc_table, 0, RETURN_ADDR, 0);\n  }\n\nOP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), LOCALS1);\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n}\n\nstatic PCRE2_SPTR byte_sequence_compare(compiler_common *common, BOOL caseless, PCRE2_SPTR cc,\n    compare_context *context, jump_list **backtracks)\n{\nDEFINE_COMPILER;\nunsigned int othercasebit = 0;\nPCRE2_SPTR othercasechar = NULL;\n#ifdef SUPPORT_UNICODE\nint utflength;\n#endif\n\nif (caseless && char_has_othercase(common, cc))\n  {\n  othercasebit = char_get_othercase_bit(common, cc);\n  SLJIT_ASSERT(othercasebit);\n  /* Extracting bit difference info. */\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  othercasechar = cc + (othercasebit >> 8);\n  othercasebit &= 0xff;\n#elif PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  /* Note that this code only handles characters in the BMP. If there\n  ever are characters outside the BMP whose othercase differs in only one\n  bit from itself (there currently are none), this code will need to be\n  revised for PCRE2_CODE_UNIT_WIDTH == 32. */\n  othercasechar = cc + (othercasebit >> 9);\n  if ((othercasebit & 0x100) != 0)\n    othercasebit = (othercasebit & 0xff) << 8;\n  else\n    othercasebit &= 0xff;\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n  }\n\nif (context->sourcereg == -1)\n  {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  if (context->length >= 4)\n    OP1(SLJIT_MOV_S32, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n  else if (context->length >= 2)\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n  else\n#endif\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  if (context->length >= 4)\n    OP1(SLJIT_MOV_S32, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n  else\n#endif\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n  context->sourcereg = TMP2;\n  }\n\n#ifdef SUPPORT_UNICODE\nutflength = 1;\nif (common->utf && HAS_EXTRALEN(*cc))\n  utflength += GET_EXTRALEN(*cc);\n\ndo\n  {\n#endif\n\n  context->length -= IN_UCHARS(1);\n#if (defined SLJIT_UNALIGNED && SLJIT_UNALIGNED) && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\n\n  /* Unaligned read is supported. */\n  if (othercasebit != 0 && othercasechar == cc)\n    {\n    context->c.asuchars[context->ucharptr] = *cc | othercasebit;\n    context->oc.asuchars[context->ucharptr] = othercasebit;\n    }\n  else\n    {\n    context->c.asuchars[context->ucharptr] = *cc;\n    context->oc.asuchars[context->ucharptr] = 0;\n    }\n  context->ucharptr++;\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  if (context->ucharptr >= 4 || context->length == 0 || (context->ucharptr == 2 && context->length == 1))\n#else\n  if (context->ucharptr >= 2 || context->length == 0)\n#endif\n    {\n    if (context->length >= 4)\n      OP1(SLJIT_MOV_S32, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n    else if (context->length >= 2)\n      OP1(SLJIT_MOV_U16, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    else if (context->length >= 1)\n      OP1(SLJIT_MOV_U8, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n    context->sourcereg = context->sourcereg == TMP1 ? TMP2 : TMP1;\n\n    switch(context->ucharptr)\n      {\n      case 4 / sizeof(PCRE2_UCHAR):\n      if (context->oc.asint != 0)\n        OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, context->oc.asint);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, context->c.asint | context->oc.asint));\n      break;\n\n      case 2 / sizeof(PCRE2_UCHAR):\n      if (context->oc.asushort != 0)\n        OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, context->oc.asushort);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, context->c.asushort | context->oc.asushort));\n      break;\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n      case 1:\n      if (context->oc.asbyte != 0)\n        OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, context->oc.asbyte);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, context->c.asbyte | context->oc.asbyte));\n      break;\n#endif\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    context->ucharptr = 0;\n    }\n\n#else\n\n  /* Unaligned read is unsupported or in 32 bit mode. */\n  if (context->length >= 1)\n    OP1(MOV_UCHAR, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n\n  context->sourcereg = context->sourcereg == TMP1 ? TMP2 : TMP1;\n\n  if (othercasebit != 0 && othercasechar == cc)\n    {\n    OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, othercasebit);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, *cc | othercasebit));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, *cc));\n\n#endif\n\n  cc++;\n#ifdef SUPPORT_UNICODE\n  utflength--;\n  }\nwhile (utflength > 0);\n#endif\n\nreturn cc;\n}\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n\n#define SET_TYPE_OFFSET(value) \\\n  if ((value) != typeoffset) \\\n    { \\\n    if ((value) < typeoffset) \\\n      OP2(SLJIT_ADD, typereg, 0, typereg, 0, SLJIT_IMM, typeoffset - (value)); \\\n    else \\\n      OP2(SLJIT_SUB, typereg, 0, typereg, 0, SLJIT_IMM, (value) - typeoffset); \\\n    } \\\n  typeoffset = (value);\n\n#define SET_CHAR_OFFSET(value) \\\n  if ((value) != charoffset) \\\n    { \\\n    if ((value) < charoffset) \\\n      OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)(charoffset - (value))); \\\n    else \\\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)((value) - charoffset)); \\\n    } \\\n  charoffset = (value);\n\nstatic PCRE2_SPTR compile_char1_matchingpath(compiler_common *common, PCRE2_UCHAR type, PCRE2_SPTR cc, jump_list **backtracks, BOOL check_str_ptr);\n\n#ifdef SUPPORT_UNICODE\n#define XCLASS_SAVE_CHAR 0x001\n#define XCLASS_CHAR_SAVED 0x002\n#define XCLASS_HAS_TYPE 0x004\n#define XCLASS_HAS_SCRIPT 0x008\n#define XCLASS_HAS_SCRIPT_EXTENSION 0x010\n#define XCLASS_HAS_BOOL 0x020\n#define XCLASS_HAS_BIDICL 0x040\n#define XCLASS_NEEDS_UCD (XCLASS_HAS_TYPE | XCLASS_HAS_SCRIPT | XCLASS_HAS_SCRIPT_EXTENSION | XCLASS_HAS_BOOL | XCLASS_HAS_BIDICL)\n#define XCLASS_SCRIPT_EXTENSION_NOTPROP 0x080\n#define XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR 0x100\n#define XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0 0x200\n\n#endif /* SUPPORT_UNICODE */\n\nstatic void compile_xclass_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks)\n{\nDEFINE_COMPILER;\njump_list *found = NULL;\njump_list **list = (cc[0] & XCL_NOT) == 0 ? &found : backtracks;\nsljit_uw c, charoffset, max = 256, min = READ_CHAR_MAX;\nstruct sljit_jump *jump = NULL;\nPCRE2_SPTR ccbegin;\nint compares, invertcmp, numberofcmps;\n#if defined SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\nBOOL utf = common->utf;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == [8|16] */\n\n#ifdef SUPPORT_UNICODE\nsljit_u32 unicode_status = 0;\nint typereg = TMP1;\nconst sljit_u32 *other_cases;\nsljit_uw typeoffset;\n#endif /* SUPPORT_UNICODE */\n\n/* Scanning the necessary info. */\ncc++;\nccbegin = cc;\ncompares = 0;\n\nif (cc[-1] & XCL_MAP)\n  {\n  min = 0;\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\nwhile (*cc != XCL_END)\n  {\n  compares++;\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n    if (c < min) min = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c < min) min = c;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    cc++;\n    if (*cc == PT_CLIST && cc[-1] == XCL_PROP)\n      {\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n      while (*other_cases != NOTACHAR)\n        {\n        if (*other_cases > max) max = *other_cases;\n        if (*other_cases < min) min = *other_cases;\n        other_cases++;\n        }\n      }\n    else\n      {\n      max = READ_CHAR_MAX;\n      min = 0;\n      }\n\n    switch(*cc)\n      {\n      case PT_ANY:\n      /* Any either accepts everything or ignored. */\n      if (cc[-1] == XCL_PROP)\n        {\n        compile_char1_matchingpath(common, OP_ALLANY, cc, backtracks, FALSE);\n        if (list == backtracks)\n          add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n        return;\n        }\n      break;\n\n      case PT_LAMP:\n      case PT_GC:\n      case PT_PC:\n      case PT_ALNUM:\n      unicode_status |= XCLASS_HAS_TYPE;\n      break;\n\n      case PT_SCX:\n      unicode_status |= XCLASS_HAS_SCRIPT_EXTENSION;\n      if (cc[-1] == XCL_NOTPROP)\n        {\n        unicode_status |= XCLASS_SCRIPT_EXTENSION_NOTPROP;\n        break;\n        }\n      compares++;\n      /* Fall through */ \n\n      case PT_SC:\n      unicode_status |= XCLASS_HAS_SCRIPT;\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      case PT_WORD:\n      case PT_PXGRAPH:\n      case PT_PXPRINT:\n      case PT_PXPUNCT:\n      unicode_status |= XCLASS_SAVE_CHAR | XCLASS_HAS_TYPE;\n      break;\n\n      case PT_CLIST:\n      case PT_UCNC:\n      unicode_status |= XCLASS_SAVE_CHAR;\n      break;\n\n      case PT_BOOL:\n      unicode_status |= XCLASS_HAS_BOOL;\n      break;\n\n      case PT_BIDICL:\n      unicode_status |= XCLASS_HAS_BIDICL;\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n  }\nSLJIT_ASSERT(compares > 0);\n\n/* We are not necessary in utf mode even in 8 bit mode. */\ncc = ccbegin;\nif ((cc[-1] & XCL_NOT) != 0)\n  read_char(common, min, max, backtracks, READ_CHAR_UPDATE_STR_PTR);\nelse\n  {\n#ifdef SUPPORT_UNICODE\n  read_char(common, min, max, (unicode_status & XCLASS_NEEDS_UCD) ? backtracks : NULL, 0);\n#else /* !SUPPORT_UNICODE */\n  read_char(common, min, max, NULL, 0);\n#endif /* SUPPORT_UNICODE */\n  }\n\nif ((cc[-1] & XCL_HASPROP) == 0)\n  {\n  if ((cc[-1] & XCL_MAP) != 0)\n    {\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n    if (!optimize_class(common, (const sljit_u8 *)cc, (((const sljit_u8 *)cc)[31] & 0x80) != 0, TRUE, &found))\n      {\n      OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n      OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n      OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n      OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n      add_jump(compiler, &found, JUMP(SLJIT_NOT_ZERO));\n      }\n\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    JUMPHERE(jump);\n\n    cc += 32 / sizeof(PCRE2_UCHAR);\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, min);\n    add_jump(compiler, (cc[-1] & XCL_NOT) == 0 ? backtracks : &found, CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, max - min));\n    }\n  }\nelse if ((cc[-1] & XCL_MAP) != 0)\n  {\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n#ifdef SUPPORT_UNICODE\n  unicode_status |= XCLASS_CHAR_SAVED;\n#endif /* SUPPORT_UNICODE */\n  if (!optimize_class(common, (const sljit_u8 *)cc, FALSE, TRUE, list))\n    {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    jump = NULL;\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n\n    OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n    OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n    add_jump(compiler, list, JUMP(SLJIT_NOT_ZERO));\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      JUMPHERE(jump);\n    }\n\n  OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\n#ifdef SUPPORT_UNICODE\nif (unicode_status & XCLASS_NEEDS_UCD)\n  {\n  if ((unicode_status & (XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED)) == XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\n  if (!common->utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n    JUMPHERE(jump);\n    }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n  OP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n  OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 3);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n  ccbegin = cc;\n\n  if (unicode_status & XCLASS_HAS_BIDICL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BIDICLASS_SHIFT);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BIDICL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n          jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]);\n          add_jump(compiler, compares > 0 ? list : backtracks, jump);\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_BOOL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, bprops));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BPROPS_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BOOL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_boolprop_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT)\n    {\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        switch (*cc)\n          {\n          case PT_SCX:\n          if (cc[-1] == XCL_NOTPROP)\n            break;\n          /* Fall through */ \n\n          case PT_SC:\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          add_jump(compiler, compares > 0 ? list : backtracks, CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT_EXTENSION)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_SCRIPTX_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_NOTPROP)\n      {\n      if (unicode_status & XCLASS_HAS_TYPE)\n        {\n        if (unicode_status & XCLASS_SAVE_CHAR)\n          {\n          OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0;\n          }\n        else\n          {\n          OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR;\n          }\n        }\n      OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n      }\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_SCX)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n\n          jump = NULL;\n          if (cc[-1] == XCL_NOTPROP)\n            {\n            jump = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, (int)cc[1]);\n            if (invertcmp)\n              {\n              add_jump(compiler, backtracks, jump);\n              jump = NULL;\n              }\n            invertcmp ^= 0x1;\n            }\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_script_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n\n          if (jump != NULL)\n            JUMPHERE(jump);\n          }\n        cc += 2;\n        }\n      }\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n    else if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR)\n      OP1(SLJIT_MOV, TMP2, 0, RETURN_ADDR, 0);\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n\n  if (unicode_status & XCLASS_HAS_TYPE)\n    {\n    if (unicode_status & XCLASS_SAVE_CHAR)\n      typereg = RETURN_ADDR;\n\n    OP1(SLJIT_MOV_U8, typereg, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));\n    }\n  }\n#endif /* SUPPORT_UNICODE */\n\n/* Generating code. */\ncharoffset = 0;\nnumberofcmps = 0;\n#ifdef SUPPORT_UNICODE\ntypeoffset = 0;\n#endif /* SUPPORT_UNICODE */\n\nwhile (*cc != XCL_END)\n  {\n  compares--;\n  invertcmp = (compares == 0 && list != backtracks);\n  jump = NULL;\n\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    SET_CHAR_OFFSET(c);\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    if (*cc == XCL_NOTPROP)\n      invertcmp ^= 0x1;\n    cc++;\n    switch(*cc)\n      {\n      case PT_ANY:\n      if (!invertcmp)\n        jump = JUMP(SLJIT_JUMP);\n      break;\n\n      case PT_LAMP:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lu - typeoffset);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Ll - typeoffset);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lt - typeoffset);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_GC:\n      c = PRIV(ucp_typerange)[(int)cc[1] * 2];\n      SET_TYPE_OFFSET(c);\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, PRIV(ucp_typerange)[(int)cc[1] * 2 + 1] - c);\n      break;\n\n      case PT_PC:\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, (int)cc[1] - typeoffset);\n      break;\n\n      case PT_SC:\n      case PT_SCX:\n      case PT_BOOL:\n      case PT_BIDICL:\n      compares++;\n      /* Do nothing. */\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      SET_CHAR_OFFSET(9);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0xd - 0x9);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Zl);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Zl);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_WORD:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_UNDERSCORE - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      /* Fall through. */\n\n      case PT_ALNUM:\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n      OP_FLAGS((*cc == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_TYPE_OFFSET(ucp_Nd);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_CLIST:\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n\n      /* At least three characters are required.\n         Otherwise this case would be handled by the normal code path. */\n      SLJIT_ASSERT(other_cases[0] != NOTACHAR && other_cases[1] != NOTACHAR && other_cases[2] != NOTACHAR);\n      SLJIT_ASSERT(other_cases[0] < other_cases[1] && other_cases[1] < other_cases[2]);\n\n      /* Optimizing character pairs, if their difference is power of 2. */\n      if (is_powerof2(other_cases[1] ^ other_cases[0]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[1]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        other_cases += 2;\n        }\n      else if (is_powerof2(other_cases[2] ^ other_cases[1]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[2] ^ other_cases[1]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[2]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(other_cases[0] - charoffset));\n        OP_FLAGS(SLJIT_OR | ((other_cases[3] == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n\n        other_cases += 3;\n        }\n      else\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        }\n\n      while (*other_cases != NOTACHAR)\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_OR | ((*other_cases == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n        }\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_UCNC:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_DOLLAR_SIGN - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_COMMERCIAL_AT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_GRAVE_ACCENT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_CHAR_OFFSET(0xa0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(0xd7ff - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000 - 0);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_GREATER_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_PXGRAPH:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPRINT:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Ll);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPUNCT:\n      SET_TYPE_OFFSET(ucp_Sc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_So - ucp_Sc);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x7f);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Pc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Ps - ucp_Pc);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n\n  if (jump != NULL)\n    add_jump(compiler, compares > 0 ? list : backtracks, jump);\n  }\n\nif (found != NULL)\n  set_jumps(found, LABEL());\n}\n\n#undef SET_TYPE_OFFSET\n#undef SET_CHAR_OFFSET\n\n#endif\n\nstatic PCRE2_SPTR compile_simple_assertion_matchingpath(compiler_common *common, PCRE2_UCHAR type, PCRE2_SPTR cc, jump_list **backtracks)\n{\nDEFINE_COMPILER;\nint length;\nstruct sljit_jump *jump[4];\n#ifdef SUPPORT_UNICODE\nstruct sljit_label *label;\n#endif /* SUPPORT_UNICODE */\n\nswitch(type)\n  {\n  case OP_SOD:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n    }\n  else\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n  add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, TMP1, 0));\n  return cc;\n\n  case OP_SOM:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n    }\n  else\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\n  add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, TMP1, 0));\n  return cc;\n\n  case OP_NOT_WORD_BOUNDARY:\n  case OP_WORD_BOUNDARY:\n  add_jump(compiler, &common->wordboundary, JUMP(SLJIT_FAST_CALL));\n#ifdef SUPPORT_UNICODE\n  if (common->invalid_utf)\n    {\n    add_jump(compiler, backtracks, CMP((type == OP_NOT_WORD_BOUNDARY) ? SLJIT_NOT_EQUAL : SLJIT_SIG_LESS_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n    return cc;\n    }\n#endif /* SUPPORT_UNICODE */\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(type == OP_NOT_WORD_BOUNDARY ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  return cc;\n\n  case OP_EODN:\n  /* Requires rather complex checks. */\n  jump[0] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, STR_END, 0));\n    else\n      {\n      jump[1] = CMP(SLJIT_EQUAL, TMP2, 0, STR_END, 0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, STR_END, 0);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_NOT_EQUAL);\n      add_jump(compiler, backtracks, JUMP(SLJIT_NOT_EQUAL));\n      check_partial(common, TRUE);\n      add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n      JUMPHERE(jump[1]);\n      }\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff));\n    }\n  else if (common->nltype == NLTYPE_FIXED)\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, STR_END, 0));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, common->newline));\n    }\n  else\n    {\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    jump[1] = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP2U(SLJIT_SUB | SLJIT_SET_Z | SLJIT_SET_GREATER, TMP2, 0, STR_END, 0);\n    jump[2] = JUMP(SLJIT_GREATER);\n    add_jump(compiler, backtracks, JUMP(SLJIT_NOT_EQUAL) /* LESS */);\n    /* Equal. */\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    jump[3] = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL);\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n\n    JUMPHERE(jump[1]);\n    if (common->nltype == NLTYPE_ANYCRLF)\n      {\n      OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, STR_END, 0));\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL));\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n      read_char(common, common->nlmin, common->nlmax, backtracks, READ_CHAR_UPDATE_STR_PTR);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, STR_END, 0));\n      add_jump(compiler, &common->anynewline, JUMP(SLJIT_FAST_CALL));\n      sljit_set_current_flags(compiler, SLJIT_SET_Z);\n      add_jump(compiler, backtracks, JUMP(SLJIT_ZERO));\n      OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n      }\n    JUMPHERE(jump[2]);\n    JUMPHERE(jump[3]);\n    }\n  JUMPHERE(jump[0]);\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    check_partial(common, TRUE);\n  return cc;\n\n  case OP_EOD:\n  add_jump(compiler, backtracks, CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0));\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    check_partial(common, TRUE);\n  return cc;\n\n  case OP_DOLL:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n    }\n  else\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n  add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n\n  if (!common->endonly)\n    compile_simple_assertion_matchingpath(common, OP_EODN, cc, backtracks);\n  else\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0));\n    check_partial(common, FALSE);\n    }\n  return cc;\n\n  case OP_DOLLM:\n  jump[1] = CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0);\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n    }\n  else\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n  add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n  check_partial(common, FALSE);\n  jump[0] = JUMP(SLJIT_JUMP);\n  JUMPHERE(jump[1]);\n\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER, TMP2, 0, STR_END, 0));\n    else\n      {\n      jump[1] = CMP(SLJIT_LESS_EQUAL, TMP2, 0, STR_END, 0);\n      /* STR_PTR = STR_END - IN_UCHARS(1) */\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n      check_partial(common, TRUE);\n      add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n      JUMPHERE(jump[1]);\n      }\n\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff));\n    }\n  else\n    {\n    peek_char(common, common->nlmax, TMP3, 0, NULL);\n    check_newlinechar(common, common->nltype, backtracks, FALSE);\n    }\n  JUMPHERE(jump[0]);\n  return cc;\n\n  case OP_CIRC:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, begin));\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, TMP1, 0));\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, TMP1, 0));\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n    }\n  return cc;\n\n  case OP_CIRCM:\n  /* TMP2 might be used by peek_char_back. */\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n    jump[1] = CMP(SLJIT_GREATER, STR_PTR, 0, TMP2, 0);\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n    jump[1] = CMP(SLJIT_GREATER, STR_PTR, 0, TMP2, 0);\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    }\n  add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n  jump[0] = JUMP(SLJIT_JUMP);\n  JUMPHERE(jump[1]);\n\n  if (!common->alt_circumflex)\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    OP2(SLJIT_SUB, TMP1, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, TMP2, 0));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff));\n    }\n  else\n    {\n    peek_char_back(common, common->nlmax, backtracks);\n    check_newlinechar(common, common->nltype, backtracks, FALSE);\n    }\n  JUMPHERE(jump[0]);\n  return cc;\n\n  case OP_REVERSE:\n  length = GET(cc, 0);\n  if (length == 0)\n    return cc + LINK_SIZE;\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n    }\n  else\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n    OP1(SLJIT_MOV, TMP3, 0, SLJIT_IMM, length);\n    label = LABEL();\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0));\n    move_back(common, backtracks, FALSE);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP3, 0, TMP3, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, label);\n    }\n  else\n#endif\n    {\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(length));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0));\n    }\n  check_start_used_ptr(common);\n  return cc + LINK_SIZE;\n  }\nSLJIT_UNREACHABLE();\nreturn cc;\n}\n\n#ifdef SUPPORT_UNICODE\n\n#if PCRE2_CODE_UNIT_WIDTH != 32\n\nstatic PCRE2_SPTR SLJIT_FUNC do_extuni_utf(jit_arguments *args, PCRE2_SPTR cc)\n{\nPCRE2_SPTR start_subject = args->begin;\nPCRE2_SPTR end_subject = args->end;\nint lgb, rgb, ricount;\nPCRE2_SPTR prevcc, endcc, bptr;\nBOOL first = TRUE;\nuint32_t c;\n\nprevcc = cc;\nendcc = NULL;\ndo\n  {\n  GETCHARINC(c, cc);\n  rgb = UCD_GRAPHBREAK(c);\n\n  if (first)\n    {\n    lgb = rgb;\n    endcc = cc;\n    first = FALSE;\n    continue;\n    }\n\n  if ((PRIV(ucp_gbtable)[lgb] & (1 << rgb)) == 0)\n    break;\n\n  /* Not breaking between Regional Indicators is allowed only if there\n  are an even number of preceding RIs. */\n\n  if (lgb == ucp_gbRegional_Indicator && rgb == ucp_gbRegional_Indicator)\n    {\n    ricount = 0;\n    bptr = prevcc;\n\n    /* bptr is pointing to the left-hand character */\n    while (bptr > start_subject)\n      {\n      bptr--;\n      BACKCHAR(bptr);\n      GETCHAR(c, bptr);\n\n      if (UCD_GRAPHBREAK(c) != ucp_gbRegional_Indicator)\n        break;\n\n      ricount++;\n      }\n\n    if ((ricount & 1) != 0) break;  /* Grapheme break required */\n    }\n\n  /* If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this\n  allows any number of them before a following Extended_Pictographic. */\n\n  if ((rgb != ucp_gbExtend && rgb != ucp_gbZWJ) ||\n       lgb != ucp_gbExtended_Pictographic)\n    lgb = rgb;\n\n  prevcc = endcc;\n  endcc = cc;\n  }\nwhile (cc < end_subject);\n\nreturn endcc;\n}\n\n#endif /* PCRE2_CODE_UNIT_WIDTH != 32 */\n\nstatic PCRE2_SPTR SLJIT_FUNC do_extuni_utf_invalid(jit_arguments *args, PCRE2_SPTR cc)\n{\nPCRE2_SPTR start_subject = args->begin;\nPCRE2_SPTR end_subject = args->end;\nint lgb, rgb, ricount;\nPCRE2_SPTR prevcc, endcc, bptr;\nBOOL first = TRUE;\nuint32_t c;\n\nprevcc = cc;\nendcc = NULL;\ndo\n  {\n  GETCHARINC_INVALID(c, cc, end_subject, break);\n  rgb = UCD_GRAPHBREAK(c);\n\n  if (first)\n    {\n    lgb = rgb;\n    endcc = cc;\n    first = FALSE;\n    continue;\n    }\n\n  if ((PRIV(ucp_gbtable)[lgb] & (1 << rgb)) == 0)\n    break;\n\n  /* Not breaking between Regional Indicators is allowed only if there\n  are an even number of preceding RIs. */\n\n  if (lgb == ucp_gbRegional_Indicator && rgb == ucp_gbRegional_Indicator)\n    {\n    ricount = 0;\n    bptr = prevcc;\n\n    /* bptr is pointing to the left-hand character */\n    while (bptr > start_subject)\n      {\n      GETCHARBACK_INVALID(c, bptr, start_subject, break);\n\n      if (UCD_GRAPHBREAK(c) != ucp_gbRegional_Indicator)\n        break;\n\n      ricount++;\n      }\n\n    if ((ricount & 1) != 0)\n      break;  /* Grapheme break required */\n    }\n\n  /* If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this\n  allows any number of them before a following Extended_Pictographic. */\n\n  if ((rgb != ucp_gbExtend && rgb != ucp_gbZWJ) ||\n       lgb != ucp_gbExtended_Pictographic)\n    lgb = rgb;\n\n  prevcc = endcc;\n  endcc = cc;\n  }\nwhile (cc < end_subject);\n\nreturn endcc;\n}\n\nstatic PCRE2_SPTR SLJIT_FUNC do_extuni_no_utf(jit_arguments *args, PCRE2_SPTR cc)\n{\nPCRE2_SPTR start_subject = args->begin;\nPCRE2_SPTR end_subject = args->end;\nint lgb, rgb, ricount;\nPCRE2_SPTR bptr;\nuint32_t c;\n\n/* Patch by PH */\n/* GETCHARINC(c, cc); */\nc = *cc++;\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\nif (c >= 0x110000)\n  return NULL;\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\nlgb = UCD_GRAPHBREAK(c);\n\nwhile (cc < end_subject)\n  {\n  c = *cc;\n#if PCRE2_CODE_UNIT_WIDTH == 32\n  if (c >= 0x110000)\n    break;\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n  rgb = UCD_GRAPHBREAK(c);\n\n  if ((PRIV(ucp_gbtable)[lgb] & (1 << rgb)) == 0)\n    break;\n\n  /* Not breaking between Regional Indicators is allowed only if there\n  are an even number of preceding RIs. */\n\n  if (lgb == ucp_gbRegional_Indicator && rgb == ucp_gbRegional_Indicator)\n    {\n    ricount = 0;\n    bptr = cc - 1;\n\n    /* bptr is pointing to the left-hand character */\n    while (bptr > start_subject)\n      {\n      bptr--;\n      c = *bptr;\n#if PCRE2_CODE_UNIT_WIDTH == 32\n      if (c >= 0x110000)\n        break;\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n      if (UCD_GRAPHBREAK(c) != ucp_gbRegional_Indicator) break;\n\n      ricount++;\n      }\n\n    if ((ricount & 1) != 0)\n      break;  /* Grapheme break required */\n    }\n\n  /* If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this\n  allows any number of them before a following Extended_Pictographic. */\n\n  if ((rgb != ucp_gbExtend && rgb != ucp_gbZWJ) ||\n       lgb != ucp_gbExtended_Pictographic)\n    lgb = rgb;\n\n  cc++;\n  }\n\nreturn cc;\n}\n\n#endif /* SUPPORT_UNICODE */\n\nstatic PCRE2_SPTR compile_char1_matchingpath(compiler_common *common, PCRE2_UCHAR type, PCRE2_SPTR cc, jump_list **backtracks, BOOL check_str_ptr)\n{\nDEFINE_COMPILER;\nint length;\nunsigned int c, oc, bit;\ncompare_context context;\nstruct sljit_jump *jump[3];\njump_list *end_list;\n#ifdef SUPPORT_UNICODE\nPCRE2_UCHAR propdata[5];\n#endif /* SUPPORT_UNICODE */\n\nswitch(type)\n  {\n  case OP_NOT_DIGIT:\n  case OP_DIGIT:\n  /* Digits are usually 0-9, so it is worth to optimize them. */\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  if (common->utf && is_char7_bitset((const sljit_u8*)common->ctypes - cbit_length + cbit_digit, FALSE))\n    read_char7_type(common, backtracks, type == OP_NOT_DIGIT);\n  else\n#endif\n    read_char8_type(common, backtracks, type == OP_NOT_DIGIT);\n    /* Flip the starting bit in the negative case. */\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, ctype_digit);\n  add_jump(compiler, backtracks, JUMP(type == OP_DIGIT ? SLJIT_ZERO : SLJIT_NOT_ZERO));\n  return cc;\n\n  case OP_NOT_WHITESPACE:\n  case OP_WHITESPACE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  if (common->utf && is_char7_bitset((const sljit_u8*)common->ctypes - cbit_length + cbit_space, FALSE))\n    read_char7_type(common, backtracks, type == OP_NOT_WHITESPACE);\n  else\n#endif\n    read_char8_type(common, backtracks, type == OP_NOT_WHITESPACE);\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, ctype_space);\n  add_jump(compiler, backtracks, JUMP(type == OP_WHITESPACE ? SLJIT_ZERO : SLJIT_NOT_ZERO));\n  return cc;\n\n  case OP_NOT_WORDCHAR:\n  case OP_WORDCHAR:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  if (common->utf && is_char7_bitset((const sljit_u8*)common->ctypes - cbit_length + cbit_word, FALSE))\n    read_char7_type(common, backtracks, type == OP_NOT_WORDCHAR);\n  else\n#endif\n    read_char8_type(common, backtracks, type == OP_NOT_WORDCHAR);\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, ctype_word);\n  add_jump(compiler, backtracks, JUMP(type == OP_WORDCHAR ? SLJIT_ZERO : SLJIT_NOT_ZERO));\n  return cc;\n\n  case OP_ANY:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  read_char(common, common->nlmin, common->nlmax, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    jump[0] = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff);\n    end_list = NULL;\n    if (common->mode != PCRE2_JIT_PARTIAL_HARD)\n      add_jump(compiler, &end_list, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n    else\n      check_str_end(common, &end_list);\n\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, common->newline & 0xff));\n    set_jumps(end_list, LABEL());\n    JUMPHERE(jump[0]);\n    }\n  else\n    check_newlinechar(common, common->nltype, backtracks, TRUE);\n  return cc;\n\n  case OP_ALLANY:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n    if (common->invalid_utf)\n      {\n      read_char(common, 0, READ_CHAR_MAX, backtracks, READ_CHAR_UPDATE_STR_PTR);\n      return cc;\n      }\n\n#if PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    jump[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n    jump[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xfc00);\n    OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n    JUMPHERE(jump[0]);\n    return cc;\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16] */\n    }\n#endif /* SUPPORT_UNICODE */\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  return cc;\n\n  case OP_ANYBYTE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  return cc;\n\n#ifdef SUPPORT_UNICODE\n  case OP_NOTPROP:\n  case OP_PROP:\n  propdata[0] = XCL_HASPROP;\n  propdata[1] = type == OP_NOTPROP ? XCL_NOTPROP : XCL_PROP;\n  propdata[2] = cc[0];\n  propdata[3] = cc[1];\n  propdata[4] = XCL_END;\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  compile_xclass_matchingpath(common, propdata, backtracks);\n  return cc + 2;\n#endif\n\n  case OP_ANYNL:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  read_char(common, common->bsr_nlmin, common->bsr_nlmax, NULL, 0);\n  jump[0] = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n  /* We don't need to handle soft partial matching case. */\n  end_list = NULL;\n  if (common->mode != PCRE2_JIT_PARTIAL_HARD)\n    add_jump(compiler, &end_list, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n  else\n    check_str_end(common, &end_list);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  jump[1] = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  jump[2] = JUMP(SLJIT_JUMP);\n  JUMPHERE(jump[0]);\n  check_newlinechar(common, common->bsr_nltype, backtracks, FALSE);\n  set_jumps(end_list, LABEL());\n  JUMPHERE(jump[1]);\n  JUMPHERE(jump[2]);\n  return cc;\n\n  case OP_NOT_HSPACE:\n  case OP_HSPACE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  if (type == OP_NOT_HSPACE)\n    read_char(common, 0x9, 0x3000, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0x9, 0x3000, NULL, 0);\n\n  add_jump(compiler, &common->hspace, JUMP(SLJIT_FAST_CALL));\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(type == OP_NOT_HSPACE ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  return cc;\n\n  case OP_NOT_VSPACE:\n  case OP_VSPACE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  if (type == OP_NOT_VSPACE)\n    read_char(common, 0xa, 0x2029, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0xa, 0x2029, NULL, 0);\n\n  add_jump(compiler, &common->vspace, JUMP(SLJIT_FAST_CALL));\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(type == OP_NOT_VSPACE ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  return cc;\n\n#ifdef SUPPORT_UNICODE\n  case OP_EXTUNI:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  SLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n  OP1(SLJIT_MOV, SLJIT_R0, 0, ARGUMENTS, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH != 32\n  sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM,\n    common->utf ? (common->invalid_utf ? SLJIT_FUNC_ADDR(do_extuni_utf_invalid) : SLJIT_FUNC_ADDR(do_extuni_utf)) : SLJIT_FUNC_ADDR(do_extuni_no_utf));\n  if (common->invalid_utf)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0));\n#else\n  sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM,\n    common->invalid_utf ? SLJIT_FUNC_ADDR(do_extuni_utf_invalid) : SLJIT_FUNC_ADDR(do_extuni_no_utf));\n  if (!common->utf || common->invalid_utf)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0));\n#endif\n\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_RETURN_REG, 0);\n\n  if (common->mode == PCRE2_JIT_PARTIAL_HARD)\n    {\n    jump[0] = CMP(SLJIT_LESS, SLJIT_RETURN_REG, 0, STR_END, 0);\n    /* Since we successfully read a char above, partial matching must occure. */\n    check_partial(common, TRUE);\n    JUMPHERE(jump[0]);\n    }\n  return cc;\n#endif\n\n  case OP_CHAR:\n  case OP_CHARI:\n  length = 1;\n#ifdef SUPPORT_UNICODE\n  if (common->utf && HAS_EXTRALEN(*cc)) length += GET_EXTRALEN(*cc);\n#endif\n\n  if (check_str_ptr && common->mode != PCRE2_JIT_COMPLETE)\n    detect_partial_match(common, backtracks);\n\n  if (type == OP_CHAR || !char_has_othercase(common, cc) || char_get_othercase_bit(common, cc) != 0)\n    {\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(length));\n    if (length > 1 || (check_str_ptr && common->mode == PCRE2_JIT_COMPLETE))\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0));\n\n    context.length = IN_UCHARS(length);\n    context.sourcereg = -1;\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n    context.ucharptr = 0;\n#endif\n    return byte_sequence_compare(common, type == OP_CHARI, cc, &context, backtracks);\n    }\n\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n    GETCHAR(c, cc);\n    }\n  else\n#endif\n    c = *cc;\n\n  SLJIT_ASSERT(type == OP_CHARI && char_has_othercase(common, cc));\n\n  if (check_str_ptr && common->mode == PCRE2_JIT_COMPLETE)\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n  oc = char_othercase(common, c);\n  read_char(common, c < oc ? c : oc, c > oc ? c : oc, NULL, 0);\n\n  SLJIT_ASSERT(!is_powerof2(c ^ oc));\n\n  if (sljit_has_cpu_feature(SLJIT_HAS_CMOV))\n    {\n    OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, oc);\n    CMOV(SLJIT_EQUAL, TMP1, SLJIT_IMM, c);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n    }\n  else\n    {\n    jump[0] = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, oc));\n    JUMPHERE(jump[0]);\n    }\n  return cc + length;\n\n  case OP_NOT:\n  case OP_NOTI:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  length = 1;\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    c = *cc;\n    if (c < 128 && !common->invalid_utf)\n      {\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n      if (type == OP_NOT || !char_has_othercase(common, cc))\n        add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n      else\n        {\n        /* Since UTF8 code page is fixed, we know that c is in [a-z] or [A-Z] range. */\n        OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x20);\n        add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, c | 0x20));\n        }\n      /* Skip the variable-length character. */\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      jump[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n      OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n      JUMPHERE(jump[0]);\n      return cc + 1;\n      }\n    else\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      {\n      GETCHARLEN(c, cc, length);\n      }\n    }\n  else\n#endif /* SUPPORT_UNICODE */\n    c = *cc;\n\n  if (type == OP_NOT || !char_has_othercase(common, cc))\n    {\n    read_char(common, c, c, backtracks, READ_CHAR_UPDATE_STR_PTR);\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n    }\n  else\n    {\n    oc = char_othercase(common, c);\n    read_char(common, c < oc ? c : oc, c > oc ? c : oc, backtracks, READ_CHAR_UPDATE_STR_PTR);\n    bit = c ^ oc;\n    if (is_powerof2(bit))\n      {\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, bit);\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c | bit));\n      }\n    else\n      {\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, oc));\n      }\n    }\n  return cc + length;\n\n  case OP_CLASS:\n  case OP_NCLASS:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  bit = (common->utf && is_char7_bitset((const sljit_u8 *)cc, type == OP_NCLASS)) ? 127 : 255;\n  if (type == OP_NCLASS)\n    read_char(common, 0, bit, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0, bit, NULL, 0);\n#else\n  if (type == OP_NCLASS)\n    read_char(common, 0, 255, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0, 255, NULL, 0);\n#endif\n\n  if (optimize_class(common, (const sljit_u8 *)cc, type == OP_NCLASS, FALSE, backtracks))\n    return cc + 32 / sizeof(PCRE2_UCHAR);\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  jump[0] = NULL;\n  if (common->utf)\n    {\n    jump[0] = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, bit);\n    if (type == OP_CLASS)\n      {\n      add_jump(compiler, backtracks, jump[0]);\n      jump[0] = NULL;\n      }\n    }\n#elif PCRE2_CODE_UNIT_WIDTH != 8\n  jump[0] = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n  if (type == OP_CLASS)\n    {\n    add_jump(compiler, backtracks, jump[0]);\n    jump[0] = NULL;\n    }\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8 */\n\n  OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n  OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n  OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n  add_jump(compiler, backtracks, JUMP(SLJIT_ZERO));\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n  if (jump[0] != NULL)\n    JUMPHERE(jump[0]);\n#endif\n  return cc + 32 / sizeof(PCRE2_UCHAR);\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  case OP_XCLASS:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  compile_xclass_matchingpath(common, cc + LINK_SIZE, backtracks);\n  return cc + GET(cc, 0) - 1;\n#endif\n  }\nSLJIT_UNREACHABLE();\nreturn cc;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_charn_matchingpath(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, jump_list **backtracks)\n{\n/* This function consumes at least one input character. */\n/* To decrease the number of length checks, we try to concatenate the fixed length character sequences. */\nDEFINE_COMPILER;\nPCRE2_SPTR ccbegin = cc;\ncompare_context context;\nint size;\n\ncontext.length = 0;\ndo\n  {\n  if (cc >= ccend)\n    break;\n\n  if (*cc == OP_CHAR)\n    {\n    size = 1;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[1]))\n      size += GET_EXTRALEN(cc[1]);\n#endif\n    }\n  else if (*cc == OP_CHARI)\n    {\n    size = 1;\n#ifdef SUPPORT_UNICODE\n    if (common->utf)\n      {\n      if (char_has_othercase(common, cc + 1) && char_get_othercase_bit(common, cc + 1) == 0)\n        size = 0;\n      else if (HAS_EXTRALEN(cc[1]))\n        size += GET_EXTRALEN(cc[1]);\n      }\n    else\n#endif\n    if (char_has_othercase(common, cc + 1) && char_get_othercase_bit(common, cc + 1) == 0)\n      size = 0;\n    }\n  else\n    size = 0;\n\n  cc += 1 + size;\n  context.length += IN_UCHARS(size);\n  }\nwhile (size > 0 && context.length <= 128);\n\ncc = ccbegin;\nif (context.length > 0)\n  {\n  /* We have a fixed-length byte sequence. */\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, context.length);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0));\n\n  context.sourcereg = -1;\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  context.ucharptr = 0;\n#endif\n  do cc = byte_sequence_compare(common, *cc == OP_CHARI, cc + 1, &context, backtracks); while (context.length > 0);\n  return cc;\n  }\n\n/* A non-fixed length character will be checked if length == 0. */\nreturn compile_char1_matchingpath(common, *cc, cc + 1, backtracks, TRUE);\n}\n\n/* Forward definitions. */\nstatic void compile_matchingpath(compiler_common *, PCRE2_SPTR, PCRE2_SPTR, backtrack_common *);\nstatic void compile_backtrackingpath(compiler_common *, struct backtrack_common *);\n\n#define PUSH_BACKTRACK(size, ccstart, error) \\\n  do \\\n    { \\\n    backtrack = sljit_alloc_memory(compiler, (size)); \\\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \\\n      return error; \\\n    memset(backtrack, 0, size); \\\n    backtrack->prev = parent->top; \\\n    backtrack->cc = (ccstart); \\\n    parent->top = backtrack; \\\n    } \\\n  while (0)\n\n#define PUSH_BACKTRACK_NOVALUE(size, ccstart) \\\n  do \\\n    { \\\n    backtrack = sljit_alloc_memory(compiler, (size)); \\\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \\\n      return; \\\n    memset(backtrack, 0, size); \\\n    backtrack->prev = parent->top; \\\n    backtrack->cc = (ccstart); \\\n    parent->top = backtrack; \\\n    } \\\n  while (0)\n\n#define BACKTRACK_AS(type) ((type *)backtrack)\n\nstatic void compile_dnref_search(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks)\n{\n/* The OVECTOR offset goes to TMP2. */\nDEFINE_COMPILER;\nint count = GET2(cc, 1 + IMM2_SIZE);\nPCRE2_SPTR slot = common->name_table + GET2(cc, 1) * common->name_entry_size;\nunsigned int offset;\njump_list *found = NULL;\n\nSLJIT_ASSERT(*cc == OP_DNREF || *cc == OP_DNREFI);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\n\ncount--;\nwhile (count-- > 0)\n  {\n  offset = GET2(slot, 0) << 1;\n  GET_LOCAL_BASE(TMP2, 0, OVECTOR(offset));\n  add_jump(compiler, &found, CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0));\n  slot += common->name_entry_size;\n  }\n\noffset = GET2(slot, 0) << 1;\nGET_LOCAL_BASE(TMP2, 0, OVECTOR(offset));\nif (backtracks != NULL && !common->unset_backref)\n  add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0));\n\nset_jumps(found, LABEL());\n}\n\nstatic void compile_ref_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks, BOOL withchecks, BOOL emptyfail)\n{\nDEFINE_COMPILER;\nBOOL ref = (*cc == OP_REF || *cc == OP_REFI);\nint offset = 0;\nstruct sljit_jump *jump = NULL;\nstruct sljit_jump *partial;\nstruct sljit_jump *nopartial;\n#if defined SUPPORT_UNICODE\nstruct sljit_label *loop;\nstruct sljit_label *caseless_loop;\njump_list *no_match = NULL;\nint source_reg = COUNT_MATCH;\nint source_end_reg = ARGUMENTS;\nint char1_reg = STACK_LIMIT;\n#endif /* SUPPORT_UNICODE */\n\nif (ref)\n  {\n  offset = GET2(cc, 1) << 1;\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n  /* OVECTOR(1) contains the \"string begin - 1\" constant. */\n  if (withchecks && !common->unset_backref)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n  }\nelse\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n\n#if defined SUPPORT_UNICODE\nif (common->utf && *cc == OP_REFI)\n  {\n  SLJIT_ASSERT(common->iref_ptr != 0);\n\n  if (ref)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n  else\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n\n  if (withchecks && emptyfail)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, TMP2, 0));\n\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->iref_ptr, source_reg, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw), source_end_reg, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2, char1_reg, 0);\n\n  OP1(SLJIT_MOV, source_reg, 0, TMP1, 0);\n  OP1(SLJIT_MOV, source_end_reg, 0, TMP2, 0);\n\n  loop = LABEL();\n  jump = CMP(SLJIT_GREATER_EQUAL, source_reg, 0, source_end_reg, 0);\n  partial = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\n  /* Read original character. It must be a valid UTF character. */\n  OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n  OP1(SLJIT_MOV, STR_PTR, 0, source_reg, 0);\n\n  read_char(common, 0, READ_CHAR_MAX, NULL, READ_CHAR_UPDATE_STR_PTR | READ_CHAR_VALID_UTF);\n\n  OP1(SLJIT_MOV, source_reg, 0, STR_PTR, 0);\n  OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n  OP1(SLJIT_MOV, char1_reg, 0, TMP1, 0);\n\n  /* Read second character. */\n  read_char(common, 0, READ_CHAR_MAX, &no_match, READ_CHAR_UPDATE_STR_PTR);\n\n  CMPTO(SLJIT_EQUAL, TMP1, 0, char1_reg, 0, loop);\n\n  OP1(SLJIT_MOV, TMP3, 0, TMP1, 0);\n\n  add_jump(compiler, &common->getucd, JUMP(SLJIT_FAST_CALL));\n\n  OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 3);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_records));\n\n  OP1(SLJIT_MOV_S32, TMP1, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(ucd_record, other_case));\n  OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(ucd_record, caseset));\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP3, 0);\n  CMPTO(SLJIT_EQUAL, TMP1, 0, char1_reg, 0, loop);\n\n  add_jump(compiler, &no_match, CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_caseless_sets));\n\n  caseless_loop = LABEL();\n  OP1(SLJIT_MOV_U32, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, sizeof(uint32_t));\n  OP2U(SLJIT_SUB | SLJIT_SET_Z | SLJIT_SET_LESS, TMP1, 0, char1_reg, 0);\n  JUMPTO(SLJIT_EQUAL, loop);\n  JUMPTO(SLJIT_LESS, caseless_loop);\n\n  set_jumps(no_match, LABEL());\n  if (common->mode == PCRE2_JIT_COMPLETE)\n    JUMPHERE(partial);\n\n  OP1(SLJIT_MOV, source_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr);\n  OP1(SLJIT_MOV, source_end_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw));\n  OP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2);\n  add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    {\n    JUMPHERE(partial);\n    OP1(SLJIT_MOV, source_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr);\n    OP1(SLJIT_MOV, source_end_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2);\n\n    check_partial(common, FALSE);\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    }\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, source_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr);\n  OP1(SLJIT_MOV, source_end_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw));\n  OP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2);\n  return;\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n  if (ref)\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP1, 0);\n  else\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw), TMP1, 0);\n\n  if (withchecks)\n    jump = JUMP(SLJIT_ZERO);\n\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n  partial = CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0);\n  if (common->mode == PCRE2_JIT_COMPLETE)\n    add_jump(compiler, backtracks, partial);\n\n  add_jump(compiler, *cc == OP_REF ? &common->casefulcmp : &common->caselesscmp, JUMP(SLJIT_FAST_CALL));\n  add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    {\n    nopartial = JUMP(SLJIT_JUMP);\n    JUMPHERE(partial);\n    /* TMP2 -= STR_END - STR_PTR */\n    OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, STR_PTR, 0);\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, STR_END, 0);\n    partial = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, STR_PTR, 0, STR_END, 0);\n    add_jump(compiler, *cc == OP_REF ? &common->casefulcmp : &common->caselesscmp, JUMP(SLJIT_FAST_CALL));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n    JUMPHERE(partial);\n    check_partial(common, FALSE);\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    JUMPHERE(nopartial);\n    }\n  }\n\nif (jump != NULL)\n  {\n  if (emptyfail)\n    add_jump(compiler, backtracks, jump);\n  else\n    JUMPHERE(jump);\n  }\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_ref_iterator_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nBOOL ref = (*cc == OP_REF || *cc == OP_REFI);\nbacktrack_common *backtrack;\nPCRE2_UCHAR type;\nint offset = 0;\nstruct sljit_label *label;\nstruct sljit_jump *zerolength;\nstruct sljit_jump *jump = NULL;\nPCRE2_SPTR ccbegin = cc;\nint min = 0, max = 0;\nBOOL minimize;\n\nPUSH_BACKTRACK(sizeof(ref_iterator_backtrack), cc, NULL);\n\nif (ref)\n  offset = GET2(cc, 1) << 1;\nelse\n  cc += IMM2_SIZE;\ntype = cc[1 + IMM2_SIZE];\n\nSLJIT_COMPILE_ASSERT((OP_CRSTAR & 0x1) == 0, crstar_opcode_must_be_even);\nminimize = (type & 0x1) != 0;\nswitch(type)\n  {\n  case OP_CRSTAR:\n  case OP_CRMINSTAR:\n  min = 0;\n  max = 0;\n  cc += 1 + IMM2_SIZE + 1;\n  break;\n  case OP_CRPLUS:\n  case OP_CRMINPLUS:\n  min = 1;\n  max = 0;\n  cc += 1 + IMM2_SIZE + 1;\n  break;\n  case OP_CRQUERY:\n  case OP_CRMINQUERY:\n  min = 0;\n  max = 1;\n  cc += 1 + IMM2_SIZE + 1;\n  break;\n  case OP_CRRANGE:\n  case OP_CRMINRANGE:\n  min = GET2(cc, 1 + IMM2_SIZE + 1);\n  max = GET2(cc, 1 + IMM2_SIZE + 1 + IMM2_SIZE);\n  cc += 1 + IMM2_SIZE + 1 + 2 * IMM2_SIZE;\n  break;\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\nif (!minimize)\n  {\n  if (min == 0)\n    {\n    allocate_stack(common, 2);\n    if (ref)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 0);\n    /* Temporary release of STR_PTR. */\n    OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n    /* Handles both invalid and empty cases. Since the minimum repeat,\n    is zero the invalid case is basically the same as an empty case. */\n    if (ref)\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    else\n      {\n      compile_dnref_search(common, ccbegin, NULL);\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, TMP2, 0);\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n      }\n    /* Restore if not zero length. */\n    OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n    }\n  else\n    {\n    allocate_stack(common, 1);\n    if (ref)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n    if (ref)\n      {\n      add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n      }\n    else\n      {\n      compile_dnref_search(common, ccbegin, &backtrack->topbacktracks);\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, TMP2, 0);\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n      }\n    }\n\n  if (min > 1 || max > 1)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, SLJIT_IMM, 0);\n\n  label = LABEL();\n  if (!ref)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1);\n  compile_ref_matchingpath(common, ccbegin, &backtrack->topbacktracks, FALSE, FALSE);\n\n  if (min > 1 || max > 1)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, TMP1, 0);\n    if (min > 1)\n      CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, min, label);\n    if (max > 1)\n      {\n      jump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, max);\n      allocate_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      JUMPTO(SLJIT_JUMP, label);\n      JUMPHERE(jump);\n      }\n    }\n\n  if (max == 0)\n    {\n    /* Includes min > 1 case as well. */\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    JUMPTO(SLJIT_JUMP, label);\n    }\n\n  JUMPHERE(zerolength);\n  BACKTRACK_AS(ref_iterator_backtrack)->matchingpath = LABEL();\n\n  count_match(common);\n  return cc;\n  }\n\nallocate_stack(common, ref ? 2 : 3);\nif (ref)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\nif (type != OP_CRMINSTAR)\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 0);\n\nif (min == 0)\n  {\n  /* Handles both invalid and empty cases. Since the minimum repeat,\n  is zero the invalid case is basically the same as an empty case. */\n  if (ref)\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n  else\n    {\n    compile_dnref_search(common, ccbegin, NULL);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP2, 0);\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n    }\n  /* Length is non-zero, we can match real repeats. */\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n  jump = JUMP(SLJIT_JUMP);\n  }\nelse\n  {\n  if (ref)\n    {\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    }\n  else\n    {\n    compile_dnref_search(common, ccbegin, &backtrack->topbacktracks);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP2, 0);\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n    }\n  }\n\nBACKTRACK_AS(ref_iterator_backtrack)->matchingpath = LABEL();\nif (max > 0)\n  add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, max));\n\nif (!ref)\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(2));\ncompile_ref_matchingpath(common, ccbegin, &backtrack->topbacktracks, TRUE, TRUE);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\nif (min > 1)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0);\n  CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, min, BACKTRACK_AS(ref_iterator_backtrack)->matchingpath);\n  }\nelse if (max > 0)\n  OP2(SLJIT_ADD, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 1);\n\nif (jump != NULL)\n  JUMPHERE(jump);\nJUMPHERE(zerolength);\n\ncount_match(common);\nreturn cc;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_recurse_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nrecurse_entry *entry = common->entries;\nrecurse_entry *prev = NULL;\nsljit_sw start = GET(cc, 1);\nPCRE2_SPTR start_cc;\nBOOL needs_control_head;\n\nPUSH_BACKTRACK(sizeof(recurse_backtrack), cc, NULL);\n\n/* Inlining simple patterns. */\nif (get_framesize(common, common->start + start, NULL, TRUE, &needs_control_head) == no_stack)\n  {\n  start_cc = common->start + start;\n  compile_matchingpath(common, next_opcode(common, start_cc), bracketend(start_cc) - (1 + LINK_SIZE), backtrack);\n  BACKTRACK_AS(recurse_backtrack)->inlined_pattern = TRUE;\n  return cc + 1 + LINK_SIZE;\n  }\n\nwhile (entry != NULL)\n  {\n  if (entry->start == start)\n    break;\n  prev = entry;\n  entry = entry->next;\n  }\n\nif (entry == NULL)\n  {\n  entry = sljit_alloc_memory(compiler, sizeof(recurse_entry));\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return NULL;\n  entry->next = NULL;\n  entry->entry_label = NULL;\n  entry->backtrack_label = NULL;\n  entry->entry_calls = NULL;\n  entry->backtrack_calls = NULL;\n  entry->start = start;\n\n  if (prev != NULL)\n    prev->next = entry;\n  else\n    common->entries = entry;\n  }\n\nBACKTRACK_AS(recurse_backtrack)->entry = entry;\n\nif (entry->entry_label == NULL)\n  add_jump(compiler, &entry->entry_calls, JUMP(SLJIT_FAST_CALL));\nelse\n  JUMPTO(SLJIT_FAST_CALL, entry->entry_label);\n/* Leave if the match is failed. */\nadd_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0));\nBACKTRACK_AS(recurse_backtrack)->matchingpath = LABEL();\nreturn cc + 1 + LINK_SIZE;\n}\n\nstatic sljit_s32 SLJIT_FUNC do_callout(struct jit_arguments *arguments, pcre2_callout_block *callout_block, PCRE2_SPTR *jit_ovector)\n{\nPCRE2_SPTR begin;\nPCRE2_SIZE *ovector;\nsljit_u32 oveccount, capture_top;\n\nif (arguments->callout == NULL)\n  return 0;\n\nSLJIT_COMPILE_ASSERT(sizeof (PCRE2_SIZE) <= sizeof (sljit_sw), pcre2_size_must_be_lower_than_sljit_sw_size);\n\nbegin = arguments->begin;\novector = (PCRE2_SIZE*)(callout_block + 1);\noveccount = callout_block->capture_top;\n\nSLJIT_ASSERT(oveccount >= 1);\n\ncallout_block->version = 2;\ncallout_block->callout_flags = 0;\n\n/* Offsets in subject. */\ncallout_block->subject_length = arguments->end - arguments->begin;\ncallout_block->start_match = jit_ovector[0] - begin;\ncallout_block->current_position = (PCRE2_SPTR)callout_block->offset_vector - begin;\ncallout_block->subject = begin;\n\n/* Convert and copy the JIT offset vector to the ovector array. */\ncallout_block->capture_top = 1;\ncallout_block->offset_vector = ovector;\n\novector[0] = PCRE2_UNSET;\novector[1] = PCRE2_UNSET;\novector += 2;\njit_ovector += 2;\ncapture_top = 1;\n\n/* Convert pointers to sizes. */\nwhile (--oveccount != 0)\n  {\n  capture_top++;\n\n  ovector[0] = (PCRE2_SIZE)(jit_ovector[0] - begin);\n  ovector[1] = (PCRE2_SIZE)(jit_ovector[1] - begin);\n\n  if (ovector[0] != PCRE2_UNSET)\n    callout_block->capture_top = capture_top;\n\n  ovector += 2;\n  jit_ovector += 2;\n  }\n\nreturn (arguments->callout)(callout_block, arguments->callout_data);\n}\n\n#define CALLOUT_ARG_OFFSET(arg) \\\n    SLJIT_OFFSETOF(pcre2_callout_block, arg)\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_callout_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nsljit_s32 mov_opcode;\nunsigned int callout_length = (*cc == OP_CALLOUT)\n    ? PRIV(OP_lengths)[OP_CALLOUT] : GET(cc, 1 + 2 * LINK_SIZE);\nsljit_sw value1;\nsljit_sw value2;\nsljit_sw value3;\nsljit_uw callout_arg_size = (common->re->top_bracket + 1) * 2 * sizeof(sljit_sw);\n\nPUSH_BACKTRACK(sizeof(backtrack_common), cc, NULL);\n\ncallout_arg_size = (sizeof(pcre2_callout_block) + callout_arg_size + sizeof(sljit_sw) - 1) / sizeof(sljit_sw);\n\nallocate_stack(common, callout_arg_size);\n\nSLJIT_ASSERT(common->capture_last_ptr != 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\nOP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\nvalue1 = (*cc == OP_CALLOUT) ? cc[1 + 2 * LINK_SIZE] : 0;\nOP1(SLJIT_MOV_U32, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_number), SLJIT_IMM, value1);\nOP1(SLJIT_MOV_U32, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(capture_last), TMP2, 0);\nOP1(SLJIT_MOV_U32, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(capture_top), SLJIT_IMM, common->re->top_bracket + 1);\n\n/* These pointer sized fields temporarly stores internal variables. */\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(offset_vector), STR_PTR, 0);\n\nif (common->mark_ptr != 0)\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, mark_ptr));\nmov_opcode = (sizeof(PCRE2_SIZE) == 4) ? SLJIT_MOV_U32 : SLJIT_MOV;\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(pattern_position), SLJIT_IMM, GET(cc, 1));\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(next_item_length), SLJIT_IMM, GET(cc, 1 + LINK_SIZE));\n\nif (*cc == OP_CALLOUT)\n  {\n  value1 = 0;\n  value2 = 0;\n  value3 = 0;\n  }\nelse\n  {\n  value1 = (sljit_sw) (cc + (1 + 4*LINK_SIZE) + 1);\n  value2 = (callout_length - (1 + 4*LINK_SIZE + 2));\n  value3 = (sljit_sw) (GET(cc, 1 + 3*LINK_SIZE));\n  }\n\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_string), SLJIT_IMM, value1);\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_string_length), SLJIT_IMM, value2);\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_string_offset), SLJIT_IMM, value3);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(mark), (common->mark_ptr != 0) ? TMP2 : SLJIT_IMM, 0);\n\nSLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n\n/* Needed to save important temporary registers. */\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, STR_PTR, 0);\n/* SLJIT_R0 = arguments */\nOP1(SLJIT_MOV, SLJIT_R1, 0, STACK_TOP, 0);\nGET_LOCAL_BASE(SLJIT_R2, 0, OVECTOR_START);\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS3(32, W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(do_callout));\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nfree_stack(common, callout_arg_size);\n\n/* Check return value. */\nOP2U(SLJIT_SUB32 | SLJIT_SET_Z | SLJIT_SET_SIG_GREATER, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0);\nadd_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_SIG_GREATER));\nif (common->abort_label == NULL)\n  add_jump(compiler, &common->abort, JUMP(SLJIT_NOT_EQUAL) /* SIG_LESS */);\nelse\n  JUMPTO(SLJIT_NOT_EQUAL /* SIG_LESS */, common->abort_label);\nreturn cc + callout_length;\n}\n\n#undef CALLOUT_ARG_SIZE\n#undef CALLOUT_ARG_OFFSET\n\nstatic SLJIT_INLINE BOOL assert_needs_str_ptr_saving(PCRE2_SPTR cc)\n{\nwhile (TRUE)\n  {\n  switch (*cc)\n    {\n    case OP_CALLOUT_STR:\n    cc += GET(cc, 1 + 2*LINK_SIZE);\n    break;\n\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_DOLL:\n    case OP_DOLLM:\n    case OP_CALLOUT:\n    case OP_ALT:\n    cc += PRIV(OP_lengths)[*cc];\n    break;\n\n    case OP_KET:\n    return FALSE;\n\n    default:\n    return TRUE;\n    }\n  }\n}\n\nstatic PCRE2_SPTR compile_assert_matchingpath(compiler_common *common, PCRE2_SPTR cc, assert_backtrack *backtrack, BOOL conditional)\n{\nDEFINE_COMPILER;\nint framesize;\nint extrasize;\nBOOL local_quit_available = FALSE;\nBOOL needs_control_head;\nint private_data_ptr;\nbacktrack_common altbacktrack;\nPCRE2_SPTR ccbegin;\nPCRE2_UCHAR opcode;\nPCRE2_UCHAR bra = OP_BRA;\njump_list *tmp = NULL;\njump_list **target = (conditional) ? &backtrack->condfailed : &backtrack->common.topbacktracks;\njump_list **found;\n/* Saving previous accept variables. */\nBOOL save_local_quit_available = common->local_quit_available;\nBOOL save_in_positive_assertion = common->in_positive_assertion;\nthen_trap_backtrack *save_then_trap = common->then_trap;\nstruct sljit_label *save_quit_label = common->quit_label;\nstruct sljit_label *save_accept_label = common->accept_label;\njump_list *save_quit = common->quit;\njump_list *save_positive_assertion_quit = common->positive_assertion_quit;\njump_list *save_accept = common->accept;\nstruct sljit_jump *jump;\nstruct sljit_jump *brajump = NULL;\n\n/* Assert captures then. */\ncommon->then_trap = NULL;\n\nif (*cc == OP_BRAZERO || *cc == OP_BRAMINZERO)\n  {\n  SLJIT_ASSERT(!conditional);\n  bra = *cc;\n  cc++;\n  }\nprivate_data_ptr = PRIVATE_DATA(cc);\nSLJIT_ASSERT(private_data_ptr != 0);\nframesize = get_framesize(common, cc, NULL, FALSE, &needs_control_head);\nbacktrack->framesize = framesize;\nbacktrack->private_data_ptr = private_data_ptr;\nopcode = *cc;\nSLJIT_ASSERT(opcode >= OP_ASSERT && opcode <= OP_ASSERTBACK_NOT);\nfound = (opcode == OP_ASSERT || opcode == OP_ASSERTBACK) ? &tmp : target;\nccbegin = cc;\ncc += GET(cc, 1);\n\nif (bra == OP_BRAMINZERO)\n  {\n  /* This is a braminzero backtrack path. */\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  brajump = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n  }\n\nif (framesize < 0)\n  {\n  extrasize = 1;\n  if (bra == OP_BRA && !assert_needs_str_ptr_saving(ccbegin + 1 + LINK_SIZE))\n    extrasize = 0;\n\n  if (needs_control_head)\n    extrasize++;\n\n  if (framesize == no_frame)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0);\n\n  if (extrasize > 0)\n    allocate_stack(common, extrasize);\n\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n\n  if (extrasize > 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\n  if (needs_control_head)\n    {\n    SLJIT_ASSERT(extrasize == 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0);\n    }\n  }\nelse\n  {\n  extrasize = needs_control_head ? 3 : 2;\n  allocate_stack(common, framesize + extrasize);\n\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  OP2(SLJIT_ADD, TMP2, 0, STACK_TOP, 0, SLJIT_IMM, (framesize + extrasize) * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP2, 0);\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\n  if (needs_control_head)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP2, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n    }\n  else\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0);\n\n  init_frame(common, ccbegin, NULL, framesize + extrasize - 1, extrasize);\n  }\n\nmemset(&altbacktrack, 0, sizeof(backtrack_common));\nif (conditional || (opcode == OP_ASSERT_NOT || opcode == OP_ASSERTBACK_NOT))\n  {\n  /* Control verbs cannot escape from these asserts. */\n  local_quit_available = TRUE;\n  common->local_quit_available = TRUE;\n  common->quit_label = NULL;\n  common->quit = NULL;\n  }\n\ncommon->in_positive_assertion = (opcode == OP_ASSERT || opcode == OP_ASSERTBACK);\ncommon->positive_assertion_quit = NULL;\n\nwhile (1)\n  {\n  common->accept_label = NULL;\n  common->accept = NULL;\n  altbacktrack.top = NULL;\n  altbacktrack.topbacktracks = NULL;\n\n  if (*ccbegin == OP_ALT && extrasize > 0)\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  altbacktrack.cc = ccbegin;\n  compile_matchingpath(common, ccbegin + 1 + LINK_SIZE, cc, &altbacktrack);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    {\n    if (local_quit_available)\n      {\n      common->local_quit_available = save_local_quit_available;\n      common->quit_label = save_quit_label;\n      common->quit = save_quit;\n      }\n    common->in_positive_assertion = save_in_positive_assertion;\n    common->then_trap = save_then_trap;\n    common->accept_label = save_accept_label;\n    common->positive_assertion_quit = save_positive_assertion_quit;\n    common->accept = save_accept;\n    return NULL;\n    }\n  common->accept_label = LABEL();\n  if (common->accept != NULL)\n    set_jumps(common->accept, common->accept_label);\n\n  /* Reset stack. */\n  if (framesize < 0)\n    {\n    if (framesize == no_frame)\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    else if (extrasize > 0)\n      free_stack(common, extrasize);\n\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(-1));\n    }\n  else\n    {\n    if ((opcode != OP_ASSERT_NOT && opcode != OP_ASSERTBACK_NOT) || conditional)\n      {\n      /* We don't need to keep the STR_PTR, only the previous private_data_ptr. */\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + 1) * sizeof(sljit_sw));\n      if (needs_control_head)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(-1));\n      }\n    else\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      if (needs_control_head)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(-framesize - 2));\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (framesize - 1) * sizeof(sljit_sw));\n      }\n    }\n\n  if (opcode == OP_ASSERT_NOT || opcode == OP_ASSERTBACK_NOT)\n    {\n    /* We know that STR_PTR was stored on the top of the stack. */\n    if (conditional)\n      {\n      if (extrasize > 0)\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), needs_control_head ? STACK(-2) : STACK(-1));\n      }\n    else if (bra == OP_BRAZERO)\n      {\n      if (framesize < 0)\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-extrasize));\n      else\n        {\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-framesize - 1));\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-framesize - extrasize));\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n        }\n      OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else if (framesize >= 0)\n      {\n      /* For OP_BRA and OP_BRAMINZERO. */\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-framesize - 1));\n      }\n    }\n  add_jump(compiler, found, JUMP(SLJIT_JUMP));\n\n  compile_backtrackingpath(common, altbacktrack.top);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    {\n    if (local_quit_available)\n      {\n      common->local_quit_available = save_local_quit_available;\n      common->quit_label = save_quit_label;\n      common->quit = save_quit;\n      }\n    common->in_positive_assertion = save_in_positive_assertion;\n    common->then_trap = save_then_trap;\n    common->accept_label = save_accept_label;\n    common->positive_assertion_quit = save_positive_assertion_quit;\n    common->accept = save_accept;\n    return NULL;\n    }\n  set_jumps(altbacktrack.topbacktracks, LABEL());\n\n  if (*cc != OP_ALT)\n    break;\n\n  ccbegin = cc;\n  cc += GET(cc, 1);\n  }\n\nif (local_quit_available)\n  {\n  SLJIT_ASSERT(common->positive_assertion_quit == NULL);\n  /* Makes the check less complicated below. */\n  common->positive_assertion_quit = common->quit;\n  }\n\n/* None of them matched. */\nif (common->positive_assertion_quit != NULL)\n  {\n  jump = JUMP(SLJIT_JUMP);\n  set_jumps(common->positive_assertion_quit, LABEL());\n  SLJIT_ASSERT(framesize != no_stack);\n  if (framesize < 0)\n    OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, extrasize * sizeof(sljit_sw));\n  else\n    {\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n    OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (extrasize + 1) * sizeof(sljit_sw));\n    }\n  JUMPHERE(jump);\n  }\n\nif (needs_control_head)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(1));\n\nif (opcode == OP_ASSERT || opcode == OP_ASSERTBACK)\n  {\n  /* Assert is failed. */\n  if ((conditional && extrasize > 0) || bra == OP_BRAZERO)\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  if (framesize < 0)\n    {\n    /* The topmost item should be 0. */\n    if (bra == OP_BRAZERO)\n      {\n      if (extrasize == 2)\n        free_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else if (extrasize > 0)\n      free_stack(common, extrasize);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(extrasize - 1));\n    /* The topmost item should be 0. */\n    if (bra == OP_BRAZERO)\n      {\n      free_stack(common, framesize + extrasize - 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else\n      free_stack(common, framesize + extrasize);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n  jump = JUMP(SLJIT_JUMP);\n  if (bra != OP_BRAZERO)\n    add_jump(compiler, target, jump);\n\n  /* Assert is successful. */\n  set_jumps(tmp, LABEL());\n  if (framesize < 0)\n    {\n    /* We know that STR_PTR was stored on the top of the stack. */\n    if (extrasize > 0)\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-extrasize));\n\n    /* Keep the STR_PTR on the top of the stack. */\n    if (bra == OP_BRAZERO)\n      {\n      OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n      if (extrasize == 2)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      }\n    else if (bra == OP_BRAMINZERO)\n      {\n      OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    }\n  else\n    {\n    if (bra == OP_BRA)\n      {\n      /* We don't need to keep the STR_PTR, only the previous private_data_ptr. */\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-extrasize + 1));\n      }\n    else\n      {\n      /* We don't need to keep the STR_PTR, only the previous private_data_ptr. */\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + 2) * sizeof(sljit_sw));\n      if (extrasize == 2)\n        {\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n        if (bra == OP_BRAMINZERO)\n          OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n        }\n      else\n        {\n        SLJIT_ASSERT(extrasize == 3);\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-1));\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), bra == OP_BRAZERO ? STR_PTR : SLJIT_IMM, 0);\n        }\n      }\n    }\n\n  if (bra == OP_BRAZERO)\n    {\n    backtrack->matchingpath = LABEL();\n    SET_LABEL(jump, backtrack->matchingpath);\n    }\n  else if (bra == OP_BRAMINZERO)\n    {\n    JUMPTO(SLJIT_JUMP, backtrack->matchingpath);\n    JUMPHERE(brajump);\n    if (framesize >= 0)\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (framesize - 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n      }\n    set_jumps(backtrack->common.topbacktracks, LABEL());\n    }\n  }\nelse\n  {\n  /* AssertNot is successful. */\n  if (framesize < 0)\n    {\n    if (extrasize > 0)\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n    if (bra != OP_BRA)\n      {\n      if (extrasize == 2)\n        free_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else if (extrasize > 0)\n      free_stack(common, extrasize);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(extrasize - 1));\n    /* The topmost item should be 0. */\n    if (bra != OP_BRA)\n      {\n      free_stack(common, framesize + extrasize - 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else\n      free_stack(common, framesize + extrasize);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n\n  if (bra == OP_BRAZERO)\n    backtrack->matchingpath = LABEL();\n  else if (bra == OP_BRAMINZERO)\n    {\n    JUMPTO(SLJIT_JUMP, backtrack->matchingpath);\n    JUMPHERE(brajump);\n    }\n\n  if (bra != OP_BRA)\n    {\n    SLJIT_ASSERT(found == &backtrack->common.topbacktracks);\n    set_jumps(backtrack->common.topbacktracks, LABEL());\n    backtrack->common.topbacktracks = NULL;\n    }\n  }\n\nif (local_quit_available)\n  {\n  common->local_quit_available = save_local_quit_available;\n  common->quit_label = save_quit_label;\n  common->quit = save_quit;\n  }\ncommon->in_positive_assertion = save_in_positive_assertion;\ncommon->then_trap = save_then_trap;\ncommon->accept_label = save_accept_label;\ncommon->positive_assertion_quit = save_positive_assertion_quit;\ncommon->accept = save_accept;\nreturn cc + 1 + LINK_SIZE;\n}\n\nstatic SLJIT_INLINE void match_once_common(compiler_common *common, PCRE2_UCHAR ket, int framesize, int private_data_ptr, BOOL has_alternatives, BOOL needs_control_head)\n{\nDEFINE_COMPILER;\nint stacksize;\n\nif (framesize < 0)\n  {\n  if (framesize == no_frame)\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  else\n    {\n    stacksize = needs_control_head ? 1 : 0;\n    if (ket != OP_KET || has_alternatives)\n      stacksize++;\n\n    if (stacksize > 0)\n      free_stack(common, stacksize);\n    }\n\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), (ket != OP_KET || has_alternatives) ? STACK(-2) : STACK(-1));\n\n  /* TMP2 which is set here used by OP_KETRMAX below. */\n  if (ket == OP_KETRMAX)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(-1));\n  else if (ket == OP_KETRMIN)\n    {\n    /* Move the STR_PTR to the private_data_ptr. */\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-1));\n    }\n  }\nelse\n  {\n  stacksize = (ket != OP_KET || has_alternatives) ? 2 : 1;\n  OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + stacksize) * sizeof(sljit_sw));\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-1));\n\n  if (ket == OP_KETRMAX)\n    {\n    /* TMP2 which is set here used by OP_KETRMAX below. */\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    }\n  }\nif (needs_control_head)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, TMP1, 0);\n}\n\nstatic SLJIT_INLINE int match_capture_common(compiler_common *common, int stacksize, int offset, int private_data_ptr)\n{\nDEFINE_COMPILER;\n\nif (common->capture_last_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, offset >> 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n  stacksize++;\n  }\nif (common->optimized_cbracket[offset >> 1] == 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize + 1), TMP2, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n  stacksize += 2;\n  }\nreturn stacksize;\n}\n\nstatic PCRE2_SPTR SLJIT_FUNC do_script_run(PCRE2_SPTR ptr, PCRE2_SPTR endptr)\n{\n  if (PRIV(script_run)(ptr, endptr, FALSE))\n    return endptr;\n  return NULL;\n}\n\n#ifdef SUPPORT_UNICODE\n\nstatic PCRE2_SPTR SLJIT_FUNC do_script_run_utf(PCRE2_SPTR ptr, PCRE2_SPTR endptr)\n{\n  if (PRIV(script_run)(ptr, endptr, TRUE))\n    return endptr;\n  return NULL;\n}\n\n#endif /* SUPPORT_UNICODE */\n\nstatic SLJIT_INLINE void match_script_run_common(compiler_common *common, int private_data_ptr, backtrack_common *parent)\n{\nDEFINE_COMPILER;\n\nSLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n#ifdef SUPPORT_UNICODE\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM,\n  common->utf ? SLJIT_FUNC_ADDR(do_script_run_utf) : SLJIT_FUNC_ADDR(do_script_run));\n#else\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(do_script_run));\n#endif\n\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_RETURN_REG, 0);\nadd_jump(compiler, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0));\n}\n\n/*\n  Handling bracketed expressions is probably the most complex part.\n\n  Stack layout naming characters:\n    S - Push the current STR_PTR\n    0 - Push a 0 (NULL)\n    A - Push the current STR_PTR. Needed for restoring the STR_PTR\n        before the next alternative. Not pushed if there are no alternatives.\n    M - Any values pushed by the current alternative. Can be empty, or anything.\n    C - Push the previous OVECTOR(i), OVECTOR(i+1) and OVECTOR_PRIV(i) to the stack.\n    L - Push the previous local (pointed by localptr) to the stack\n   () - opional values stored on the stack\n  ()* - optonal, can be stored multiple times\n\n  The following list shows the regular expression templates, their PCRE byte codes\n  and stack layout supported by pcre-sljit.\n\n  (?:)                     OP_BRA     | OP_KET                A M\n  ()                       OP_CBRA    | OP_KET                C M\n  (?:)+                    OP_BRA     | OP_KETRMAX        0   A M S   ( A M S )*\n                           OP_SBRA    | OP_KETRMAX        0   L M S   ( L M S )*\n  (?:)+?                   OP_BRA     | OP_KETRMIN        0   A M S   ( A M S )*\n                           OP_SBRA    | OP_KETRMIN        0   L M S   ( L M S )*\n  ()+                      OP_CBRA    | OP_KETRMAX        0   C M S   ( C M S )*\n                           OP_SCBRA   | OP_KETRMAX        0   C M S   ( C M S )*\n  ()+?                     OP_CBRA    | OP_KETRMIN        0   C M S   ( C M S )*\n                           OP_SCBRA   | OP_KETRMIN        0   C M S   ( C M S )*\n  (?:)?    OP_BRAZERO    | OP_BRA     | OP_KET            S ( A M 0 )\n  (?:)??   OP_BRAMINZERO | OP_BRA     | OP_KET            S ( A M 0 )\n  ()?      OP_BRAZERO    | OP_CBRA    | OP_KET            S ( C M 0 )\n  ()??     OP_BRAMINZERO | OP_CBRA    | OP_KET            S ( C M 0 )\n  (?:)*    OP_BRAZERO    | OP_BRA     | OP_KETRMAX      S 0 ( A M S )*\n           OP_BRAZERO    | OP_SBRA    | OP_KETRMAX      S 0 ( L M S )*\n  (?:)*?   OP_BRAMINZERO | OP_BRA     | OP_KETRMIN      S 0 ( A M S )*\n           OP_BRAMINZERO | OP_SBRA    | OP_KETRMIN      S 0 ( L M S )*\n  ()*      OP_BRAZERO    | OP_CBRA    | OP_KETRMAX      S 0 ( C M S )*\n           OP_BRAZERO    | OP_SCBRA   | OP_KETRMAX      S 0 ( C M S )*\n  ()*?     OP_BRAMINZERO | OP_CBRA    | OP_KETRMIN      S 0 ( C M S )*\n           OP_BRAMINZERO | OP_SCBRA   | OP_KETRMIN      S 0 ( C M S )*\n\n\n  Stack layout naming characters:\n    A - Push the alternative index (starting from 0) on the stack.\n        Not pushed if there is no alternatives.\n    M - Any values pushed by the current alternative. Can be empty, or anything.\n\n  The next list shows the possible content of a bracket:\n  (|)     OP_*BRA    | OP_ALT ...         M A\n  (?()|)  OP_*COND   | OP_ALT             M A\n  (?>|)   OP_ONCE    | OP_ALT ...         [stack trace] M A\n                                          Or nothing, if trace is unnecessary\n*/\n\nstatic PCRE2_SPTR compile_bracket_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode;\nint private_data_ptr = 0;\nint offset = 0;\nint i, stacksize;\nint repeat_ptr = 0, repeat_length = 0;\nint repeat_type = 0, repeat_count = 0;\nPCRE2_SPTR ccbegin;\nPCRE2_SPTR matchingpath;\nPCRE2_SPTR slot;\nPCRE2_UCHAR bra = OP_BRA;\nPCRE2_UCHAR ket;\nassert_backtrack *assert;\nBOOL has_alternatives;\nBOOL needs_control_head = FALSE;\nstruct sljit_jump *jump;\nstruct sljit_jump *skip;\nstruct sljit_label *rmax_label = NULL;\nstruct sljit_jump *braminzero = NULL;\n\nPUSH_BACKTRACK(sizeof(bracket_backtrack), cc, NULL);\n\nif (*cc == OP_BRAZERO || *cc == OP_BRAMINZERO)\n  {\n  bra = *cc;\n  cc++;\n  opcode = *cc;\n  }\n\nopcode = *cc;\nccbegin = cc;\nmatchingpath = bracketend(cc) - 1 - LINK_SIZE;\nket = *matchingpath;\nif (ket == OP_KET && PRIVATE_DATA(matchingpath) != 0)\n  {\n  repeat_ptr = PRIVATE_DATA(matchingpath);\n  repeat_length = PRIVATE_DATA(matchingpath + 1);\n  repeat_type = PRIVATE_DATA(matchingpath + 2);\n  repeat_count = PRIVATE_DATA(matchingpath + 3);\n  SLJIT_ASSERT(repeat_length != 0 && repeat_type != 0 && repeat_count != 0);\n  if (repeat_type == OP_UPTO)\n    ket = OP_KETRMAX;\n  if (repeat_type == OP_MINUPTO)\n    ket = OP_KETRMIN;\n  }\n\nmatchingpath = ccbegin + 1 + LINK_SIZE;\nSLJIT_ASSERT(ket == OP_KET || ket == OP_KETRMAX || ket == OP_KETRMIN);\nSLJIT_ASSERT(!((bra == OP_BRAZERO && ket == OP_KETRMIN) || (bra == OP_BRAMINZERO && ket == OP_KETRMAX)));\ncc += GET(cc, 1);\n\nhas_alternatives = *cc == OP_ALT;\nif (SLJIT_UNLIKELY(opcode == OP_COND || opcode == OP_SCOND))\n  {\n  SLJIT_COMPILE_ASSERT(OP_DNRREF == OP_RREF + 1 && OP_FALSE == OP_RREF + 2 && OP_TRUE == OP_RREF + 3,\n    compile_time_checks_must_be_grouped_together);\n  has_alternatives = ((*matchingpath >= OP_RREF && *matchingpath <= OP_TRUE) || *matchingpath == OP_FAIL) ? FALSE : TRUE;\n  }\n\nif (SLJIT_UNLIKELY(opcode == OP_COND) && (*cc == OP_KETRMAX || *cc == OP_KETRMIN))\n  opcode = OP_SCOND;\n\nif (opcode == OP_CBRA || opcode == OP_SCBRA)\n  {\n  /* Capturing brackets has a pre-allocated space. */\n  offset = GET2(ccbegin, 1 + LINK_SIZE);\n  if (common->optimized_cbracket[offset] == 0)\n    {\n    private_data_ptr = OVECTOR_PRIV(offset);\n    offset <<= 1;\n    }\n  else\n    {\n    offset <<= 1;\n    private_data_ptr = OVECTOR(offset);\n    }\n  BACKTRACK_AS(bracket_backtrack)->private_data_ptr = private_data_ptr;\n  matchingpath += IMM2_SIZE;\n  }\nelse if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA || opcode == OP_ONCE || opcode == OP_SCRIPT_RUN || opcode == OP_SBRA || opcode == OP_SCOND)\n  {\n  /* Other brackets simply allocate the next entry. */\n  private_data_ptr = PRIVATE_DATA(ccbegin);\n  SLJIT_ASSERT(private_data_ptr != 0);\n  BACKTRACK_AS(bracket_backtrack)->private_data_ptr = private_data_ptr;\n  if (opcode == OP_ONCE)\n    BACKTRACK_AS(bracket_backtrack)->u.framesize = get_framesize(common, ccbegin, NULL, FALSE, &needs_control_head);\n  }\n\n/* Instructions before the first alternative. */\nstacksize = 0;\nif (ket == OP_KETRMAX || (ket == OP_KETRMIN && bra != OP_BRAMINZERO))\n  stacksize++;\nif (bra == OP_BRAZERO)\n  stacksize++;\n\nif (stacksize > 0)\n  allocate_stack(common, stacksize);\n\nstacksize = 0;\nif (ket == OP_KETRMAX || (ket == OP_KETRMIN && bra != OP_BRAMINZERO))\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n  stacksize++;\n  }\n\nif (bra == OP_BRAZERO)\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n\nif (bra == OP_BRAMINZERO)\n  {\n  /* This is a backtrack path! (Since the try-path of OP_BRAMINZERO matches to the empty string) */\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  if (ket != OP_KETRMIN)\n    {\n    free_stack(common, 1);\n    braminzero = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n    }\n  else if (opcode == OP_ONCE || opcode >= OP_SBRA)\n    {\n    jump = CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    /* Nothing stored during the first run. */\n    skip = JUMP(SLJIT_JUMP);\n    JUMPHERE(jump);\n    /* Checking zero-length iteration. */\n    if (opcode != OP_ONCE || BACKTRACK_AS(bracket_backtrack)->u.framesize < 0)\n      {\n      /* When we come from outside, private_data_ptr contains the previous STR_PTR. */\n      braminzero = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      }\n    else\n      {\n      /* Except when the whole stack frame must be saved. */\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      braminzero = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_MEM1(TMP1), STACK(-BACKTRACK_AS(bracket_backtrack)->u.framesize - 2));\n      }\n    JUMPHERE(skip);\n    }\n  else\n    {\n    jump = CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    JUMPHERE(jump);\n    }\n  }\n\nif (repeat_type != 0)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, repeat_count);\n  if (repeat_type == OP_EXACT)\n    rmax_label = LABEL();\n  }\n\nif (ket == OP_KETRMIN)\n  BACKTRACK_AS(bracket_backtrack)->recursive_matchingpath = LABEL();\n\nif (ket == OP_KETRMAX)\n  {\n  rmax_label = LABEL();\n  if (has_alternatives && opcode >= OP_BRA && opcode < OP_SBRA && repeat_type == 0)\n    BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = rmax_label;\n  }\n\n/* Handling capturing brackets and alternatives. */\nif (opcode == OP_ONCE)\n  {\n  stacksize = 0;\n  if (needs_control_head)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    stacksize++;\n    }\n\n  if (BACKTRACK_AS(bracket_backtrack)->u.framesize < 0)\n    {\n    /* Neither capturing brackets nor recursions are found in the block. */\n    if (ket == OP_KETRMIN)\n      {\n      stacksize += 2;\n      if (!needs_control_head)\n        OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      }\n    else\n      {\n      if (BACKTRACK_AS(bracket_backtrack)->u.framesize == no_frame)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0);\n      if (ket == OP_KETRMAX || has_alternatives)\n        stacksize++;\n      }\n\n    if (stacksize > 0)\n      allocate_stack(common, stacksize);\n\n    stacksize = 0;\n    if (needs_control_head)\n      {\n      stacksize++;\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n      }\n\n    if (ket == OP_KETRMIN)\n      {\n      if (needs_control_head)\n        OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n      if (BACKTRACK_AS(bracket_backtrack)->u.framesize == no_frame)\n        OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0, SLJIT_IMM, needs_control_head ? (2 * sizeof(sljit_sw)) : sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize + 1), TMP2, 0);\n      }\n    else if (ket == OP_KETRMAX || has_alternatives)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n    }\n  else\n    {\n    if (ket != OP_KET || has_alternatives)\n      stacksize++;\n\n    stacksize += BACKTRACK_AS(bracket_backtrack)->u.framesize + 1;\n    allocate_stack(common, stacksize);\n\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    OP2(SLJIT_ADD, TMP2, 0, STACK_TOP, 0, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n\n    stacksize = needs_control_head ? 1 : 0;\n    if (ket != OP_KET || has_alternatives)\n      {\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP2, 0);\n      stacksize++;\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP2, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n      }\n    init_frame(common, ccbegin, NULL, BACKTRACK_AS(bracket_backtrack)->u.framesize + stacksize, stacksize + 1);\n    }\n  }\nelse if (opcode == OP_CBRA || opcode == OP_SCBRA)\n  {\n  /* Saving the previous values. */\n  if (common->optimized_cbracket[offset >> 1] != 0)\n    {\n    SLJIT_ASSERT(private_data_ptr == OVECTOR(offset));\n    allocate_stack(common, 2);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP2, 0);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n    }\n  }\nelse if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA || opcode == OP_SCRIPT_RUN || opcode == OP_SBRA || opcode == OP_SCOND)\n  {\n  /* Saving the previous value. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n  }\nelse if (has_alternatives)\n  {\n  /* Pushing the starting string pointer. */\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n  }\n\n/* Generating code for the first alternative. */\nif (opcode == OP_COND || opcode == OP_SCOND)\n  {\n  if (*matchingpath == OP_CREF)\n    {\n    SLJIT_ASSERT(has_alternatives);\n    add_jump(compiler, &(BACKTRACK_AS(bracket_backtrack)->u.condfailed),\n      CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), OVECTOR(GET2(matchingpath, 1) << 1), SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n    matchingpath += 1 + IMM2_SIZE;\n    }\n  else if (*matchingpath == OP_DNCREF)\n    {\n    SLJIT_ASSERT(has_alternatives);\n\n    i = GET2(matchingpath, 1 + IMM2_SIZE);\n    slot = common->name_table + GET2(matchingpath, 1) * common->name_entry_size;\n    OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(GET2(slot, 0) << 1), TMP1, 0);\n    slot += common->name_entry_size;\n    i--;\n    while (i-- > 0)\n      {\n      OP2(SLJIT_SUB, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(GET2(slot, 0) << 1), TMP1, 0);\n      OP2(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, TMP2, 0, STR_PTR, 0);\n      slot += common->name_entry_size;\n      }\n    OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n    add_jump(compiler, &(BACKTRACK_AS(bracket_backtrack)->u.condfailed), JUMP(SLJIT_ZERO));\n    matchingpath += 1 + 2 * IMM2_SIZE;\n    }\n  else if ((*matchingpath >= OP_RREF && *matchingpath <= OP_TRUE) || *matchingpath == OP_FAIL)\n    {\n    /* Never has other case. */\n    BACKTRACK_AS(bracket_backtrack)->u.condfailed = NULL;\n    SLJIT_ASSERT(!has_alternatives);\n\n    if (*matchingpath == OP_TRUE)\n      {\n      stacksize = 1;\n      matchingpath++;\n      }\n    else if (*matchingpath == OP_FALSE || *matchingpath == OP_FAIL)\n      stacksize = 0;\n    else if (*matchingpath == OP_RREF)\n      {\n      stacksize = GET2(matchingpath, 1);\n      if (common->currententry == NULL)\n        stacksize = 0;\n      else if (stacksize == RREF_ANY)\n        stacksize = 1;\n      else if (common->currententry->start == 0)\n        stacksize = stacksize == 0;\n      else\n        stacksize = stacksize == (int)GET2(common->start, common->currententry->start + 1 + LINK_SIZE);\n\n      if (stacksize != 0)\n        matchingpath += 1 + IMM2_SIZE;\n      }\n    else\n      {\n      if (common->currententry == NULL || common->currententry->start == 0)\n        stacksize = 0;\n      else\n        {\n        stacksize = GET2(matchingpath, 1 + IMM2_SIZE);\n        slot = common->name_table + GET2(matchingpath, 1) * common->name_entry_size;\n        i = (int)GET2(common->start, common->currententry->start + 1 + LINK_SIZE);\n        while (stacksize > 0)\n          {\n          if ((int)GET2(slot, 0) == i)\n            break;\n          slot += common->name_entry_size;\n          stacksize--;\n          }\n        }\n\n      if (stacksize != 0)\n        matchingpath += 1 + 2 * IMM2_SIZE;\n      }\n\n      /* The stacksize == 0 is a common \"else\" case. */\n      if (stacksize == 0)\n        {\n        if (*cc == OP_ALT)\n          {\n          matchingpath = cc + 1 + LINK_SIZE;\n          cc += GET(cc, 1);\n          }\n        else\n          matchingpath = cc;\n        }\n    }\n  else\n    {\n    SLJIT_ASSERT(has_alternatives && *matchingpath >= OP_ASSERT && *matchingpath <= OP_ASSERTBACK_NOT);\n    /* Similar code as PUSH_BACKTRACK macro. */\n    assert = sljit_alloc_memory(compiler, sizeof(assert_backtrack));\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n      return NULL;\n    memset(assert, 0, sizeof(assert_backtrack));\n    assert->common.cc = matchingpath;\n    BACKTRACK_AS(bracket_backtrack)->u.assert = assert;\n    matchingpath = compile_assert_matchingpath(common, matchingpath, assert, TRUE);\n    }\n  }\n\ncompile_matchingpath(common, matchingpath, cc, backtrack);\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  return NULL;\n\nif (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA)\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n\nif (opcode == OP_ONCE)\n  match_once_common(common, ket, BACKTRACK_AS(bracket_backtrack)->u.framesize, private_data_ptr, has_alternatives, needs_control_head);\n\nif (opcode == OP_SCRIPT_RUN)\n  match_script_run_common(common, private_data_ptr, backtrack);\n\nstacksize = 0;\nif (repeat_type == OP_MINUPTO)\n  {\n  /* We need to preserve the counter. TMP2 will be used below. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr);\n  stacksize++;\n  }\nif (ket != OP_KET || bra != OP_BRA)\n  stacksize++;\nif (offset != 0)\n  {\n  if (common->capture_last_ptr != 0)\n    stacksize++;\n  if (common->optimized_cbracket[offset >> 1] == 0)\n    stacksize += 2;\n  }\nif (has_alternatives && opcode != OP_ONCE)\n  stacksize++;\n\nif (stacksize > 0)\n  allocate_stack(common, stacksize);\n\nstacksize = 0;\nif (repeat_type == OP_MINUPTO)\n  {\n  /* TMP2 was set above. */\n  OP2(SLJIT_SUB, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP2, 0, SLJIT_IMM, 1);\n  stacksize++;\n  }\n\nif (ket != OP_KET || bra != OP_BRA)\n  {\n  if (ket != OP_KET)\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n  else\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n  stacksize++;\n  }\n\nif (offset != 0)\n  stacksize = match_capture_common(common, stacksize, offset, private_data_ptr);\n\n/* Skip and count the other alternatives. */\ni = 1;\nwhile (*cc == OP_ALT)\n  {\n  cc += GET(cc, 1);\n  i++;\n  }\n\nif (has_alternatives)\n  {\n  if (opcode != OP_ONCE)\n    {\n    if (i <= 3)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n    else\n      BACKTRACK_AS(bracket_backtrack)->u.matching_put_label = sljit_emit_put_label(compiler, SLJIT_MEM1(STACK_TOP), STACK(stacksize));\n    }\n  if (ket != OP_KETRMAX)\n    BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = LABEL();\n  }\n\n/* Must be after the matchingpath label. */\nif (offset != 0 && common->optimized_cbracket[offset >> 1] != 0)\n  {\n  SLJIT_ASSERT(private_data_ptr == OVECTOR(offset + 0));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n  }\n\nif (ket == OP_KETRMAX)\n  {\n  if (repeat_type != 0)\n    {\n    if (has_alternatives)\n      BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = LABEL();\n    OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, rmax_label);\n    /* Drop STR_PTR for greedy plus quantifier. */\n    if (opcode != OP_ONCE)\n      free_stack(common, 1);\n    }\n  else if (opcode < OP_BRA || opcode >= OP_SBRA)\n    {\n    if (has_alternatives)\n      BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = LABEL();\n\n    /* Checking zero-length iteration. */\n    if (opcode != OP_ONCE)\n      {\n      /* This case includes opcodes such as OP_SCRIPT_RUN. */\n      CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0, rmax_label);\n      /* Drop STR_PTR for greedy plus quantifier. */\n      if (bra != OP_BRAZERO)\n        free_stack(common, 1);\n      }\n    else\n      /* TMP2 must contain the starting STR_PTR. */\n      CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0, rmax_label);\n    }\n  else\n    JUMPTO(SLJIT_JUMP, rmax_label);\n  BACKTRACK_AS(bracket_backtrack)->recursive_matchingpath = LABEL();\n  }\n\nif (repeat_type == OP_EXACT)\n  {\n  count_match(common);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  JUMPTO(SLJIT_NOT_ZERO, rmax_label);\n  }\nelse if (repeat_type == OP_UPTO)\n  {\n  /* We need to preserve the counter. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr);\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n  }\n\nif (bra == OP_BRAZERO)\n  BACKTRACK_AS(bracket_backtrack)->zero_matchingpath = LABEL();\n\nif (bra == OP_BRAMINZERO)\n  {\n  /* This is a backtrack path! (From the viewpoint of OP_BRAMINZERO) */\n  JUMPTO(SLJIT_JUMP, ((braminzero_backtrack *)parent)->matchingpath);\n  if (braminzero != NULL)\n    {\n    JUMPHERE(braminzero);\n    /* We need to release the end pointer to perform the\n    backtrack for the zero-length iteration. When\n    framesize is < 0, OP_ONCE will do the release itself. */\n    if (opcode == OP_ONCE && BACKTRACK_AS(bracket_backtrack)->u.framesize >= 0)\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (BACKTRACK_AS(bracket_backtrack)->u.framesize - 1) * sizeof(sljit_sw));\n      }\n    else if (ket == OP_KETRMIN && opcode != OP_ONCE)\n      free_stack(common, 1);\n    }\n  /* Continue to the normal backtrack. */\n  }\n\nif ((ket != OP_KET && bra != OP_BRAMINZERO) || bra == OP_BRAZERO)\n  count_match(common);\n\ncc += 1 + LINK_SIZE;\n\nif (opcode == OP_ONCE)\n  {\n  /* We temporarily encode the needs_control_head in the lowest bit.\n     Note: on the target architectures of SLJIT the ((x << 1) >> 1) returns\n     the same value for small signed numbers (including negative numbers). */\n  BACKTRACK_AS(bracket_backtrack)->u.framesize = (int)((unsigned)BACKTRACK_AS(bracket_backtrack)->u.framesize << 1) | (needs_control_head ? 1 : 0);\n  }\nreturn cc + repeat_length;\n}\n\nstatic PCRE2_SPTR compile_bracketpos_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode;\nint private_data_ptr;\nint cbraprivptr = 0;\nBOOL needs_control_head;\nint framesize;\nint stacksize;\nint offset = 0;\nBOOL zero = FALSE;\nPCRE2_SPTR ccbegin = NULL;\nint stack; /* Also contains the offset of control head. */\nstruct sljit_label *loop = NULL;\nstruct jump_list *emptymatch = NULL;\n\nPUSH_BACKTRACK(sizeof(bracketpos_backtrack), cc, NULL);\nif (*cc == OP_BRAPOSZERO)\n  {\n  zero = TRUE;\n  cc++;\n  }\n\nopcode = *cc;\nprivate_data_ptr = PRIVATE_DATA(cc);\nSLJIT_ASSERT(private_data_ptr != 0);\nBACKTRACK_AS(bracketpos_backtrack)->private_data_ptr = private_data_ptr;\nswitch(opcode)\n  {\n  case OP_BRAPOS:\n  case OP_SBRAPOS:\n  ccbegin = cc + 1 + LINK_SIZE;\n  break;\n\n  case OP_CBRAPOS:\n  case OP_SCBRAPOS:\n  offset = GET2(cc, 1 + LINK_SIZE);\n  /* This case cannot be optimized in the same was as\n  normal capturing brackets. */\n  SLJIT_ASSERT(common->optimized_cbracket[offset] == 0);\n  cbraprivptr = OVECTOR_PRIV(offset);\n  offset <<= 1;\n  ccbegin = cc + 1 + LINK_SIZE + IMM2_SIZE;\n  break;\n\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\nframesize = get_framesize(common, cc, NULL, FALSE, &needs_control_head);\nBACKTRACK_AS(bracketpos_backtrack)->framesize = framesize;\nif (framesize < 0)\n  {\n  if (offset != 0)\n    {\n    stacksize = 2;\n    if (common->capture_last_ptr != 0)\n      stacksize++;\n    }\n  else\n    stacksize = 1;\n\n  if (needs_control_head)\n    stacksize++;\n  if (!zero)\n    stacksize++;\n\n  BACKTRACK_AS(bracketpos_backtrack)->stacksize = stacksize;\n  allocate_stack(common, stacksize);\n  if (framesize == no_frame)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0);\n\n  stack = 0;\n  if (offset != 0)\n    {\n    stack = 2;\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP1, 0);\n    if (common->capture_last_ptr != 0)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP2, 0);\n    if (needs_control_head)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    if (common->capture_last_ptr != 0)\n      {\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP1, 0);\n      stack = 3;\n      }\n    }\n  else\n    {\n    if (needs_control_head)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    stack = 1;\n    }\n\n  if (needs_control_head)\n    stack++;\n  if (!zero)\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), SLJIT_IMM, 1);\n  if (needs_control_head)\n    {\n    stack--;\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), TMP2, 0);\n    }\n  }\nelse\n  {\n  stacksize = framesize + 1;\n  if (!zero)\n    stacksize++;\n  if (needs_control_head)\n    stacksize++;\n  if (offset == 0)\n    stacksize++;\n  BACKTRACK_AS(bracketpos_backtrack)->stacksize = stacksize;\n\n  allocate_stack(common, stacksize);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n  OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n\n  stack = 0;\n  if (!zero)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 1);\n    stack = 1;\n    }\n  if (needs_control_head)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), TMP2, 0);\n    stack++;\n    }\n  if (offset == 0)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), STR_PTR, 0);\n    stack++;\n    }\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), TMP1, 0);\n  init_frame(common, cc, NULL, stacksize - 1, stacksize - framesize);\n  stack -= 1 + (offset == 0);\n  }\n\nif (offset != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), cbraprivptr, STR_PTR, 0);\n\nloop = LABEL();\nwhile (*cc != OP_KETRPOS)\n  {\n  backtrack->top = NULL;\n  backtrack->topbacktracks = NULL;\n  cc += GET(cc, 1);\n\n  compile_matchingpath(common, ccbegin, cc, backtrack);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return NULL;\n\n  if (framesize < 0)\n    {\n    if (framesize == no_frame)\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n\n    if (offset != 0)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), cbraprivptr, STR_PTR, 0);\n      if (common->capture_last_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, offset >> 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n      }\n    else\n      {\n      if (opcode == OP_SBRAPOS)\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      }\n\n    /* Even if the match is empty, we need to reset the control head. */\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(stack));\n\n    if (opcode == OP_SBRAPOS || opcode == OP_SCBRAPOS)\n      add_jump(compiler, &emptymatch, CMP(SLJIT_EQUAL, TMP1, 0, STR_PTR, 0));\n\n    if (!zero)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize - 1), SLJIT_IMM, 0);\n    }\n  else\n    {\n    if (offset != 0)\n      {\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), cbraprivptr, STR_PTR, 0);\n      if (common->capture_last_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, offset >> 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP2(SLJIT_SUB, STACK_TOP, 0, TMP2, 0, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n      if (opcode == OP_SBRAPOS)\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), STACK(-framesize - 2));\n      OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), STACK(-framesize - 2), STR_PTR, 0);\n      }\n\n    /* Even if the match is empty, we need to reset the control head. */\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(stack));\n\n    if (opcode == OP_SBRAPOS || opcode == OP_SCBRAPOS)\n      add_jump(compiler, &emptymatch, CMP(SLJIT_EQUAL, TMP1, 0, STR_PTR, 0));\n\n    if (!zero)\n      {\n      if (framesize < 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize - 1), SLJIT_IMM, 0);\n      else\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    }\n\n  JUMPTO(SLJIT_JUMP, loop);\n  flush_stubs(common);\n\n  compile_backtrackingpath(common, backtrack->top);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return NULL;\n  set_jumps(backtrack->topbacktracks, LABEL());\n\n  if (framesize < 0)\n    {\n    if (offset != 0)\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n    else\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    }\n  else\n    {\n    if (offset != 0)\n      {\n      /* Last alternative. */\n      if (*cc == OP_KETRPOS)\n        OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(TMP2), STACK(-framesize - 2));\n      }\n    }\n\n  if (*cc == OP_KETRPOS)\n    break;\n  ccbegin = cc + 1 + LINK_SIZE;\n  }\n\n/* We don't have to restore the control head in case of a failed match. */\n\nbacktrack->topbacktracks = NULL;\nif (!zero)\n  {\n  if (framesize < 0)\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(stacksize - 1), SLJIT_IMM, 0));\n  else /* TMP2 is set to [private_data_ptr] above. */\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(TMP2), STACK(-stacksize), SLJIT_IMM, 0));\n  }\n\n/* None of them matched. */\nset_jumps(emptymatch, LABEL());\ncount_match(common);\nreturn cc + 1 + LINK_SIZE;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR get_iterator_parameters(compiler_common *common, PCRE2_SPTR cc, PCRE2_UCHAR *opcode, PCRE2_UCHAR *type, sljit_u32 *max, sljit_u32 *exact, PCRE2_SPTR *end)\n{\nint class_len;\n\n*opcode = *cc;\n*exact = 0;\n\nif (*opcode >= OP_STAR && *opcode <= OP_POSUPTO)\n  {\n  cc++;\n  *type = OP_CHAR;\n  }\nelse if (*opcode >= OP_STARI && *opcode <= OP_POSUPTOI)\n  {\n  cc++;\n  *type = OP_CHARI;\n  *opcode -= OP_STARI - OP_STAR;\n  }\nelse if (*opcode >= OP_NOTSTAR && *opcode <= OP_NOTPOSUPTO)\n  {\n  cc++;\n  *type = OP_NOT;\n  *opcode -= OP_NOTSTAR - OP_STAR;\n  }\nelse if (*opcode >= OP_NOTSTARI && *opcode <= OP_NOTPOSUPTOI)\n  {\n  cc++;\n  *type = OP_NOTI;\n  *opcode -= OP_NOTSTARI - OP_STAR;\n  }\nelse if (*opcode >= OP_TYPESTAR && *opcode <= OP_TYPEPOSUPTO)\n  {\n  cc++;\n  *opcode -= OP_TYPESTAR - OP_STAR;\n  *type = OP_END;\n  }\nelse\n  {\n  SLJIT_ASSERT(*opcode == OP_CLASS || *opcode == OP_NCLASS || *opcode == OP_XCLASS);\n  *type = *opcode;\n  cc++;\n  class_len = (*type < OP_XCLASS) ? (int)(1 + (32 / sizeof(PCRE2_UCHAR))) : GET(cc, 0);\n  *opcode = cc[class_len - 1];\n\n  if (*opcode >= OP_CRSTAR && *opcode <= OP_CRMINQUERY)\n    {\n    *opcode -= OP_CRSTAR - OP_STAR;\n    *end = cc + class_len;\n\n    if (*opcode == OP_PLUS || *opcode == OP_MINPLUS)\n      {\n      *exact = 1;\n      *opcode -= OP_PLUS - OP_STAR;\n      }\n    }\n  else if (*opcode >= OP_CRPOSSTAR && *opcode <= OP_CRPOSQUERY)\n    {\n    *opcode -= OP_CRPOSSTAR - OP_POSSTAR;\n    *end = cc + class_len;\n\n    if (*opcode == OP_POSPLUS)\n      {\n      *exact = 1;\n      *opcode = OP_POSSTAR;\n      }\n    }\n  else\n    {\n    SLJIT_ASSERT(*opcode == OP_CRRANGE || *opcode == OP_CRMINRANGE || *opcode == OP_CRPOSRANGE);\n    *max = GET2(cc, (class_len + IMM2_SIZE));\n    *exact = GET2(cc, class_len);\n\n    if (*max == 0)\n      {\n      if (*opcode == OP_CRPOSRANGE)\n        *opcode = OP_POSSTAR;\n      else\n        *opcode -= OP_CRRANGE - OP_STAR;\n      }\n    else\n      {\n      *max -= *exact;\n      if (*max == 0)\n        *opcode = OP_EXACT;\n      else if (*max == 1)\n        {\n        if (*opcode == OP_CRPOSRANGE)\n          *opcode = OP_POSQUERY;\n        else\n          *opcode -= OP_CRRANGE - OP_QUERY;\n        }\n      else\n        {\n        if (*opcode == OP_CRPOSRANGE)\n          *opcode = OP_POSUPTO;\n        else\n          *opcode -= OP_CRRANGE - OP_UPTO;\n        }\n      }\n    *end = cc + class_len + 2 * IMM2_SIZE;\n    }\n  return cc;\n  }\n\nswitch(*opcode)\n  {\n  case OP_EXACT:\n  *exact = GET2(cc, 0);\n  cc += IMM2_SIZE;\n  break;\n\n  case OP_PLUS:\n  case OP_MINPLUS:\n  *exact = 1;\n  *opcode -= OP_PLUS - OP_STAR;\n  break;\n\n  case OP_POSPLUS:\n  *exact = 1;\n  *opcode = OP_POSSTAR;\n  break;\n\n  case OP_UPTO:\n  case OP_MINUPTO:\n  case OP_POSUPTO:\n  *max = GET2(cc, 0);\n  cc += IMM2_SIZE;\n  break;\n  }\n\nif (*type == OP_END)\n  {\n  *type = *cc;\n  *end = next_opcode(common, cc);\n  cc++;\n  return cc;\n  }\n\n*end = cc + 1;\n#ifdef SUPPORT_UNICODE\nif (common->utf && HAS_EXTRALEN(*cc)) *end += GET_EXTRALEN(*cc);\n#endif\nreturn cc;\n}\n\nstatic PCRE2_SPTR compile_iterator_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode;\nPCRE2_UCHAR type;\nsljit_u32 max = 0, exact;\nsljit_s32 early_fail_ptr = PRIVATE_DATA(cc + 1);\nsljit_s32 early_fail_type;\nBOOL charpos_enabled;\nPCRE2_UCHAR charpos_char;\nunsigned int charpos_othercasebit;\nPCRE2_SPTR end;\njump_list *no_match = NULL;\njump_list *no_char1_match = NULL;\nstruct sljit_jump *jump = NULL;\nstruct sljit_label *label;\nint private_data_ptr = PRIVATE_DATA(cc);\nint base = (private_data_ptr == 0) ? SLJIT_MEM1(STACK_TOP) : SLJIT_MEM1(SLJIT_SP);\nint offset0 = (private_data_ptr == 0) ? STACK(0) : private_data_ptr;\nint offset1 = (private_data_ptr == 0) ? STACK(1) : private_data_ptr + (int)sizeof(sljit_sw);\nint tmp_base, tmp_offset;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nBOOL use_tmp;\n#endif\n\nPUSH_BACKTRACK(sizeof(char_iterator_backtrack), cc, NULL);\n\nearly_fail_type = (early_fail_ptr & 0x7);\nearly_fail_ptr >>= 3;\n\n/* During recursion, these optimizations are disabled. */\nif (common->early_fail_start_ptr == 0 && common->fast_forward_bc_ptr == NULL)\n  {\n  early_fail_ptr = 0;\n  early_fail_type = type_skip;\n  }\n\nSLJIT_ASSERT(common->fast_forward_bc_ptr != NULL || early_fail_ptr == 0\n  || (early_fail_ptr >= common->early_fail_start_ptr && early_fail_ptr <= common->early_fail_end_ptr));\n\nif (early_fail_type == type_fail)\n  add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), early_fail_ptr));\n\ncc = get_iterator_parameters(common, cc, &opcode, &type, &max, &exact, &end);\n\nif (type != OP_EXTUNI)\n  {\n  tmp_base = TMP3;\n  tmp_offset = 0;\n  }\nelse\n  {\n  tmp_base = SLJIT_MEM1(SLJIT_SP);\n  tmp_offset = POSSESSIVE0;\n  }\n\n/* Handle fixed part first. */\nif (exact > 1)\n  {\n  SLJIT_ASSERT(early_fail_ptr == 0);\n\n  if (common->mode == PCRE2_JIT_COMPLETE\n#ifdef SUPPORT_UNICODE\n      && !common->utf\n#endif\n      && type != OP_ANYNL && type != OP_EXTUNI)\n    {\n    OP2(SLJIT_ADD, TMP1, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(exact));\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_GREATER, TMP1, 0, STR_END, 0));\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, exact);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, FALSE);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, label);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, exact);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, TRUE);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, label);\n    }\n  }\nelse if (exact == 1)\n  {\n  compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, TRUE);\n\n  if (early_fail_type == type_fail_range)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), early_fail_ptr);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), early_fail_ptr + (int)sizeof(sljit_sw));\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP2(SLJIT_SUB, TMP2, 0, STR_PTR, 0, TMP2, 0);\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_LESS_EQUAL, TMP2, 0, TMP1, 0));\n\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr + (int)sizeof(sljit_sw), STR_PTR, 0);\n    }\n  }\n\nswitch(opcode)\n  {\n  case OP_STAR:\n  case OP_UPTO:\n  SLJIT_ASSERT(early_fail_ptr == 0 || opcode == OP_STAR);\n\n  if (type == OP_ANYNL || type == OP_EXTUNI)\n    {\n    SLJIT_ASSERT(private_data_ptr == 0);\n    SLJIT_ASSERT(early_fail_ptr == 0);\n\n    allocate_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 0);\n\n    if (opcode == OP_UPTO)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, SLJIT_IMM, max);\n\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &BACKTRACK_AS(char_iterator_backtrack)->u.backtracks, TRUE);\n    if (opcode == OP_UPTO)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0);\n      OP2(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n      jump = JUMP(SLJIT_ZERO);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, TMP1, 0);\n      }\n\n    /* We cannot use TMP3 because of allocate_stack. */\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    JUMPTO(SLJIT_JUMP, label);\n    if (jump != NULL)\n      JUMPHERE(jump);\n    BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n    break;\n    }\n#ifdef SUPPORT_UNICODE\n  else if (type == OP_ALLANY && !common->invalid_utf)\n#else\n  else if (type == OP_ALLANY)\n#endif\n    {\n    if (opcode == OP_STAR)\n      {\n      if (private_data_ptr == 0)\n        allocate_stack(common, 2);\n\n      OP1(SLJIT_MOV, base, offset0, STR_END, 0);\n      OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n\n      OP1(SLJIT_MOV, STR_PTR, 0, STR_END, 0);\n      process_partial_match(common);\n\n      if (early_fail_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_END, 0);\n      BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n      break;\n      }\n#ifdef SUPPORT_UNICODE\n    else if (!common->utf)\n#else\n    else\n#endif\n      {\n      if (private_data_ptr == 0)\n        allocate_stack(common, 2);\n\n      OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(max));\n\n      if (common->mode == PCRE2_JIT_COMPLETE)\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_PTR, 0, STR_END, 0);\n        CMOV(SLJIT_GREATER, STR_PTR, STR_END, 0);\n        }\n      else\n        {\n        jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, STR_END, 0);\n        process_partial_match(common);\n        JUMPHERE(jump);\n        }\n\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n\n      if (early_fail_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n      BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n      break;\n      }\n    }\n\n  charpos_enabled = FALSE;\n  charpos_char = 0;\n  charpos_othercasebit = 0;\n\n  if ((type != OP_CHAR && type != OP_CHARI) && (*end == OP_CHAR || *end == OP_CHARI))\n    {\n#ifdef SUPPORT_UNICODE\n    charpos_enabled = !common->utf || !HAS_EXTRALEN(end[1]);\n#else\n    charpos_enabled = TRUE;\n#endif\n    if (charpos_enabled && *end == OP_CHARI && char_has_othercase(common, end + 1))\n      {\n      charpos_othercasebit = char_get_othercase_bit(common, end + 1);\n      if (charpos_othercasebit == 0)\n        charpos_enabled = FALSE;\n      }\n\n    if (charpos_enabled)\n      {\n      charpos_char = end[1];\n      /* Consume the OP_CHAR opcode. */\n      end += 2;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n      SLJIT_ASSERT((charpos_othercasebit >> 8) == 0);\n#elif PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n      SLJIT_ASSERT((charpos_othercasebit >> 9) == 0);\n      if ((charpos_othercasebit & 0x100) != 0)\n        charpos_othercasebit = (charpos_othercasebit & 0xff) << 8;\n#endif\n      if (charpos_othercasebit != 0)\n        charpos_char |= charpos_othercasebit;\n\n      BACKTRACK_AS(char_iterator_backtrack)->u.charpos.enabled = TRUE;\n      BACKTRACK_AS(char_iterator_backtrack)->u.charpos.chr = charpos_char;\n      BACKTRACK_AS(char_iterator_backtrack)->u.charpos.othercasebit = charpos_othercasebit;\n      }\n    }\n\n  if (charpos_enabled)\n    {\n    if (opcode == OP_UPTO)\n      OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max + 1);\n\n    /* Search the first instance of charpos_char. */\n    jump = JUMP(SLJIT_JUMP);\n    label = LABEL();\n    if (opcode == OP_UPTO)\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      add_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_ZERO));\n      }\n    compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, FALSE);\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n    JUMPHERE(jump);\n\n    detect_partial_match(common, &backtrack->topbacktracks);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (charpos_othercasebit != 0)\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, charpos_othercasebit);\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, charpos_char, label);\n\n    if (private_data_ptr == 0)\n      allocate_stack(common, 2);\n    OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n    OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n\n    if (opcode == OP_UPTO)\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n      }\n\n    /* Search the last instance of charpos_char. */\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_match, FALSE);\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n    detect_partial_match(common, &no_match);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (charpos_othercasebit != 0)\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, charpos_othercasebit);\n\n    if (opcode == OP_STAR)\n      {\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, charpos_char, label);\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      JUMPTO(SLJIT_JUMP, label);\n      }\n    else\n      {\n      jump = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, charpos_char);\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      JUMPHERE(jump);\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      JUMPTO(SLJIT_NOT_ZERO, label);\n      }\n\n    set_jumps(no_match, LABEL());\n    OP2(SLJIT_ADD, STR_PTR, 0, base, offset0, SLJIT_IMM, IN_UCHARS(1));\n    OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n    }\n  else\n    {\n    if (private_data_ptr == 0)\n      allocate_stack(common, 2);\n\n    OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    use_tmp = (!HAS_VIRTUAL_REGISTERS && opcode == OP_STAR);\n    SLJIT_ASSERT(!use_tmp || tmp_base == TMP3);\n\n    if (common->utf)\n      OP1(SLJIT_MOV, use_tmp ? TMP3 : base, use_tmp ? 0 : offset0, STR_PTR, 0);\n#endif\n    if (opcode == OP_UPTO)\n      OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max);\n\n    detect_partial_match(common, &no_match);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_char1_match, FALSE);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf)\n      OP1(SLJIT_MOV, use_tmp ? TMP3 : base, use_tmp ? 0 : offset0, STR_PTR, 0);\n#endif\n\n    if (opcode == OP_UPTO)\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n      }\n\n    detect_partial_match_to(common, label);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n    set_jumps(no_char1_match, LABEL());\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf)\n      {\n      set_jumps(no_match, LABEL());\n      if (use_tmp)\n        {\n        OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n        OP1(SLJIT_MOV, base, offset0, TMP3, 0);\n        }\n      else\n        OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n      }\n    else\n#endif\n      {\n      OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      set_jumps(no_match, LABEL());\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      }\n\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n    }\n\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  break;\n\n  case OP_MINSTAR:\n  if (private_data_ptr == 0)\n    allocate_stack(common, 1);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  if (early_fail_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n  break;\n\n  case OP_MINUPTO:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n  if (private_data_ptr == 0)\n    allocate_stack(common, 2);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  OP1(SLJIT_MOV, base, offset1, SLJIT_IMM, max + 1);\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  break;\n\n  case OP_QUERY:\n  case OP_MINQUERY:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n  if (private_data_ptr == 0)\n    allocate_stack(common, 1);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  if (opcode == OP_QUERY)\n    compile_char1_matchingpath(common, type, cc, &BACKTRACK_AS(char_iterator_backtrack)->u.backtracks, TRUE);\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  break;\n\n  case OP_EXACT:\n  break;\n\n  case OP_POSSTAR:\n#if defined SUPPORT_UNICODE\n  if (type == OP_ALLANY && !common->invalid_utf)\n#else\n  if (type == OP_ALLANY)\n#endif\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, STR_END, 0);\n    process_partial_match(common);\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_END, 0);\n    break;\n    }\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n  if (common->utf)\n    {\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n    detect_partial_match(common, &no_match);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_match, FALSE);\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n    detect_partial_match_to(common, label);\n\n    set_jumps(no_match, LABEL());\n    OP1(SLJIT_MOV, STR_PTR, 0, tmp_base, tmp_offset);\n    if (early_fail_ptr != 0)\n      {\n      if (!HAS_VIRTUAL_REGISTERS && tmp_base == TMP3)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, TMP3, 0);\n      else\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n      }\n    break;\n    }\n#endif\n\n  detect_partial_match(common, &no_match);\n  label = LABEL();\n  compile_char1_matchingpath(common, type, cc, &no_char1_match, FALSE);\n  detect_partial_match_to(common, label);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  set_jumps(no_char1_match, LABEL());\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  set_jumps(no_match, LABEL());\n  if (early_fail_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n  break;\n\n  case OP_POSUPTO:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n  if (common->utf)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, STR_PTR, 0);\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max);\n\n    detect_partial_match(common, &no_match);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_match, FALSE);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, STR_PTR, 0);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n    add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n    detect_partial_match_to(common, label);\n\n    set_jumps(no_match, LABEL());\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1);\n    break;\n    }\n#endif\n\n  if (type == OP_ALLANY)\n    {\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(max));\n\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_PTR, 0, STR_END, 0);\n      CMOV(SLJIT_GREATER, STR_PTR, STR_END, 0);\n      }\n    else\n      {\n      jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, STR_END, 0);\n      process_partial_match(common);\n      JUMPHERE(jump);\n      }\n    break;\n    }\n\n  OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max);\n\n  detect_partial_match(common, &no_match);\n  label = LABEL();\n  compile_char1_matchingpath(common, type, cc, &no_char1_match, FALSE);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n  add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n  detect_partial_match_to(common, label);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  set_jumps(no_char1_match, LABEL());\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  set_jumps(no_match, LABEL());\n  break;\n\n  case OP_POSQUERY:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n  OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n  compile_char1_matchingpath(common, type, cc, &no_match, TRUE);\n  OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n  set_jumps(no_match, LABEL());\n  OP1(SLJIT_MOV, STR_PTR, 0, tmp_base, tmp_offset);\n  break;\n\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\ncount_match(common);\nreturn end;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_fail_accept_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\n\nPUSH_BACKTRACK(sizeof(backtrack_common), cc, NULL);\n\nif (*cc == OP_FAIL)\n  {\n  add_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_JUMP));\n  return cc + 1;\n  }\n\nif (*cc == OP_ACCEPT && common->currententry == NULL && (common->re->overall_options & PCRE2_ENDANCHORED) != 0)\n  add_jump(compiler, &common->reset_match, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, STR_END, 0));\n\nif (*cc == OP_ASSERT_ACCEPT || common->currententry != NULL || !common->might_be_empty)\n  {\n  /* No need to check notempty conditions. */\n  if (common->accept_label == NULL)\n    add_jump(compiler, &common->accept, JUMP(SLJIT_JUMP));\n  else\n    JUMPTO(SLJIT_JUMP, common->accept_label);\n  return cc + 1;\n  }\n\nif (common->accept_label == NULL)\n  add_jump(compiler, &common->accept, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0)));\nelse\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), common->accept_label);\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV_U32, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, options));\n  }\nelse\n  OP1(SLJIT_MOV_U32, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options));\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY);\nadd_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_NOT_ZERO));\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY_ATSTART);\nif (common->accept_label == NULL)\n  add_jump(compiler, &common->accept, JUMP(SLJIT_ZERO));\nelse\n  JUMPTO(SLJIT_ZERO, common->accept_label);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? TMP1 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\nif (common->accept_label == NULL)\n  add_jump(compiler, &common->accept, CMP(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0));\nelse\n  CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0, common->accept_label);\nadd_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_JUMP));\nreturn cc + 1;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_close_matchingpath(compiler_common *common, PCRE2_SPTR cc)\n{\nDEFINE_COMPILER;\nint offset = GET2(cc, 1);\nBOOL optimized_cbracket = common->optimized_cbracket[offset] != 0;\n\n/* Data will be discarded anyway... */\nif (common->currententry != NULL)\n  return cc + 1 + IMM2_SIZE;\n\nif (!optimized_cbracket)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR_PRIV(offset));\noffset <<= 1;\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\nif (!optimized_cbracket)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\nreturn cc + 1 + IMM2_SIZE;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_control_verb_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode = *cc;\nPCRE2_SPTR ccend = cc + 1;\n\nif (opcode == OP_COMMIT_ARG || opcode == OP_PRUNE_ARG ||\n    opcode == OP_SKIP_ARG || opcode == OP_THEN_ARG)\n  ccend += 2 + cc[1];\n\nPUSH_BACKTRACK(sizeof(backtrack_common), cc, NULL);\n\nif (opcode == OP_SKIP)\n  {\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n  return ccend;\n  }\n\nif (opcode == OP_COMMIT_ARG || opcode == OP_PRUNE_ARG || opcode == OP_THEN_ARG)\n  {\n  if (HAS_VIRTUAL_REGISTERS)\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)(cc + 2));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, TMP2, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? TMP1 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, mark_ptr), TMP2, 0);\n  }\n\nreturn ccend;\n}\n\nstatic PCRE2_UCHAR then_trap_opcode[1] = { OP_THEN_TRAP };\n\nstatic SLJIT_INLINE void compile_then_trap_matchingpath(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nBOOL needs_control_head;\nint size;\n\nPUSH_BACKTRACK_NOVALUE(sizeof(then_trap_backtrack), cc);\ncommon->then_trap = BACKTRACK_AS(then_trap_backtrack);\nBACKTRACK_AS(then_trap_backtrack)->common.cc = then_trap_opcode;\nBACKTRACK_AS(then_trap_backtrack)->start = (sljit_sw)(cc - common->start);\nBACKTRACK_AS(then_trap_backtrack)->framesize = get_framesize(common, cc, ccend, FALSE, &needs_control_head);\n\nsize = BACKTRACK_AS(then_trap_backtrack)->framesize;\nsize = 3 + (size < 0 ? 0 : size);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\nallocate_stack(common, size);\nif (size > 3)\n  OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, STACK_TOP, 0, SLJIT_IMM, (size - 3) * sizeof(sljit_sw));\nelse\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, STACK_TOP, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(size - 1), SLJIT_IMM, BACKTRACK_AS(then_trap_backtrack)->start);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(size - 2), SLJIT_IMM, type_then_trap);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(size - 3), TMP2, 0);\n\nsize = BACKTRACK_AS(then_trap_backtrack)->framesize;\nif (size >= 0)\n  init_frame(common, cc, ccend, size - 1, 0);\n}\n\nstatic void compile_matchingpath(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nBOOL has_then_trap = FALSE;\nthen_trap_backtrack *save_then_trap = NULL;\n\nSLJIT_ASSERT(*ccend == OP_END || (*ccend >= OP_ALT && *ccend <= OP_KETRPOS));\n\nif (common->has_then && common->then_offsets[cc - common->start] != 0)\n  {\n  SLJIT_ASSERT(*ccend != OP_END && common->control_head_ptr != 0);\n  has_then_trap = TRUE;\n  save_then_trap = common->then_trap;\n  /* Tail item on backtrack. */\n  compile_then_trap_matchingpath(common, cc, ccend, parent);\n  }\n\nwhile (cc < ccend)\n  {\n  switch(*cc)\n    {\n    case OP_SOD:\n    case OP_SOM:\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_EODN:\n    case OP_EOD:\n    case OP_DOLL:\n    case OP_DOLLM:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_REVERSE:\n    cc = compile_simple_assertion_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks);\n    break;\n\n    case OP_NOT_DIGIT:\n    case OP_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_WORDCHAR:\n    case OP_ANY:\n    case OP_ALLANY:\n    case OP_ANYBYTE:\n    case OP_NOTPROP:\n    case OP_PROP:\n    case OP_ANYNL:\n    case OP_NOT_HSPACE:\n    case OP_HSPACE:\n    case OP_NOT_VSPACE:\n    case OP_VSPACE:\n    case OP_EXTUNI:\n    case OP_NOT:\n    case OP_NOTI:\n    cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n\n    case OP_SET_SOM:\n    PUSH_BACKTRACK_NOVALUE(sizeof(backtrack_common), cc);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n    cc++;\n    break;\n\n    case OP_CHAR:\n    case OP_CHARI:\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      cc = compile_charn_matchingpath(common, cc, ccend, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks);\n    else\n      cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_UPTO:\n    case OP_MINUPTO:\n    case OP_EXACT:\n    case OP_POSSTAR:\n    case OP_POSPLUS:\n    case OP_POSQUERY:\n    case OP_POSUPTO:\n    case OP_STARI:\n    case OP_MINSTARI:\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_UPTOI:\n    case OP_MINUPTOI:\n    case OP_EXACTI:\n    case OP_POSSTARI:\n    case OP_POSPLUSI:\n    case OP_POSQUERYI:\n    case OP_POSUPTOI:\n    case OP_NOTSTAR:\n    case OP_NOTMINSTAR:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTQUERY:\n    case OP_NOTMINQUERY:\n    case OP_NOTUPTO:\n    case OP_NOTMINUPTO:\n    case OP_NOTEXACT:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSUPTO:\n    case OP_NOTSTARI:\n    case OP_NOTMINSTARI:\n    case OP_NOTPLUSI:\n    case OP_NOTMINPLUSI:\n    case OP_NOTQUERYI:\n    case OP_NOTMINQUERYI:\n    case OP_NOTUPTOI:\n    case OP_NOTMINUPTOI:\n    case OP_NOTEXACTI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTPOSQUERYI:\n    case OP_NOTPOSUPTOI:\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    case OP_TYPEEXACT:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEPOSQUERY:\n    case OP_TYPEPOSUPTO:\n    cc = compile_iterator_matchingpath(common, cc, parent);\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    if (cc[1 + (32 / sizeof(PCRE2_UCHAR))] >= OP_CRSTAR && cc[1 + (32 / sizeof(PCRE2_UCHAR))] <= OP_CRPOSRANGE)\n      cc = compile_iterator_matchingpath(common, cc, parent);\n    else\n      cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n    case OP_XCLASS:\n    if (*(cc + GET(cc, 1)) >= OP_CRSTAR && *(cc + GET(cc, 1)) <= OP_CRPOSRANGE)\n      cc = compile_iterator_matchingpath(common, cc, parent);\n    else\n      cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n#endif\n\n    case OP_REF:\n    case OP_REFI:\n    if (cc[1 + IMM2_SIZE] >= OP_CRSTAR && cc[1 + IMM2_SIZE] <= OP_CRPOSRANGE)\n      cc = compile_ref_iterator_matchingpath(common, cc, parent);\n    else\n      {\n      compile_ref_matchingpath(common, cc, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE, FALSE);\n      cc += 1 + IMM2_SIZE;\n      }\n    break;\n\n    case OP_DNREF:\n    case OP_DNREFI:\n    if (cc[1 + 2 * IMM2_SIZE] >= OP_CRSTAR && cc[1 + 2 * IMM2_SIZE] <= OP_CRPOSRANGE)\n      cc = compile_ref_iterator_matchingpath(common, cc, parent);\n    else\n      {\n      compile_dnref_search(common, cc, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks);\n      compile_ref_matchingpath(common, cc, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE, FALSE);\n      cc += 1 + 2 * IMM2_SIZE;\n      }\n    break;\n\n    case OP_RECURSE:\n    cc = compile_recurse_matchingpath(common, cc, parent);\n    break;\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n    cc = compile_callout_matchingpath(common, cc, parent);\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    PUSH_BACKTRACK_NOVALUE(sizeof(assert_backtrack), cc);\n    cc = compile_assert_matchingpath(common, cc, BACKTRACK_AS(assert_backtrack), FALSE);\n    break;\n\n    case OP_BRAMINZERO:\n    PUSH_BACKTRACK_NOVALUE(sizeof(braminzero_backtrack), cc);\n    cc = bracketend(cc + 1);\n    if (*(cc - 1 - LINK_SIZE) != OP_KETRMIN)\n      {\n      allocate_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      }\n    else\n      {\n      allocate_stack(common, 2);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), STR_PTR, 0);\n      }\n    BACKTRACK_AS(braminzero_backtrack)->matchingpath = LABEL();\n    count_match(common);\n    break;\n\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRA:\n    case OP_CBRA:\n    case OP_COND:\n    case OP_SBRA:\n    case OP_SCBRA:\n    case OP_SCOND:\n    cc = compile_bracket_matchingpath(common, cc, parent);\n    break;\n\n    case OP_BRAZERO:\n    if (cc[1] > OP_ASSERTBACK_NOT)\n      cc = compile_bracket_matchingpath(common, cc, parent);\n    else\n      {\n      PUSH_BACKTRACK_NOVALUE(sizeof(assert_backtrack), cc);\n      cc = compile_assert_matchingpath(common, cc, BACKTRACK_AS(assert_backtrack), FALSE);\n      }\n    break;\n\n    case OP_BRAPOS:\n    case OP_CBRAPOS:\n    case OP_SBRAPOS:\n    case OP_SCBRAPOS:\n    case OP_BRAPOSZERO:\n    cc = compile_bracketpos_matchingpath(common, cc, parent);\n    break;\n\n    case OP_MARK:\n    PUSH_BACKTRACK_NOVALUE(sizeof(backtrack_common), cc);\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n    allocate_stack(common, common->has_skip_arg ? 5 : 1);\n    if (HAS_VIRTUAL_REGISTERS)\n      OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(common->has_skip_arg ? 4 : 0), TMP2, 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)(cc + 2));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, TMP2, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? TMP1 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, mark_ptr), TMP2, 0);\n    if (common->has_skip_arg)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, STACK_TOP, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, type_mark);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), SLJIT_IMM, (sljit_sw)(cc + 2));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(3), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP1, 0);\n      }\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_PRUNE:\n    case OP_PRUNE_ARG:\n    case OP_SKIP:\n    case OP_SKIP_ARG:\n    case OP_THEN:\n    case OP_THEN_ARG:\n    case OP_COMMIT:\n    case OP_COMMIT_ARG:\n    cc = compile_control_verb_matchingpath(common, cc, parent);\n    break;\n\n    case OP_FAIL:\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    cc = compile_fail_accept_matchingpath(common, cc, parent);\n    break;\n\n    case OP_CLOSE:\n    cc = compile_close_matchingpath(common, cc);\n    break;\n\n    case OP_SKIPZERO:\n    cc = bracketend(cc + 1);\n    break;\n\n    default:\n    SLJIT_UNREACHABLE();\n    return;\n    }\n  if (cc == NULL)\n    return;\n  }\n\nif (has_then_trap)\n  {\n  /* Head item on backtrack. */\n  PUSH_BACKTRACK_NOVALUE(sizeof(then_trap_backtrack), cc);\n  BACKTRACK_AS(then_trap_backtrack)->common.cc = then_trap_opcode;\n  BACKTRACK_AS(then_trap_backtrack)->then_trap = common->then_trap;\n  common->then_trap = save_then_trap;\n  }\nSLJIT_ASSERT(cc == ccend);\n}\n\n#undef PUSH_BACKTRACK\n#undef PUSH_BACKTRACK_NOVALUE\n#undef BACKTRACK_AS\n\n#define COMPILE_BACKTRACKINGPATH(current) \\\n  do \\\n    { \\\n    compile_backtrackingpath(common, (current)); \\\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \\\n      return; \\\n    } \\\n  while (0)\n\n#define CURRENT_AS(type) ((type *)current)\n\nstatic void compile_iterator_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = current->cc;\nPCRE2_UCHAR opcode;\nPCRE2_UCHAR type;\nsljit_u32 max = 0, exact;\nstruct sljit_label *label = NULL;\nstruct sljit_jump *jump = NULL;\njump_list *jumplist = NULL;\nPCRE2_SPTR end;\nint private_data_ptr = PRIVATE_DATA(cc);\nint base = (private_data_ptr == 0) ? SLJIT_MEM1(STACK_TOP) : SLJIT_MEM1(SLJIT_SP);\nint offset0 = (private_data_ptr == 0) ? STACK(0) : private_data_ptr;\nint offset1 = (private_data_ptr == 0) ? STACK(1) : private_data_ptr + (int)sizeof(sljit_sw);\n\ncc = get_iterator_parameters(common, cc, &opcode, &type, &max, &exact, &end);\n\nswitch(opcode)\n  {\n  case OP_STAR:\n  case OP_UPTO:\n  if (type == OP_ANYNL || type == OP_EXTUNI)\n    {\n    SLJIT_ASSERT(private_data_ptr == 0);\n    set_jumps(CURRENT_AS(char_iterator_backtrack)->u.backtracks, LABEL());\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n    }\n  else\n    {\n    if (CURRENT_AS(char_iterator_backtrack)->u.charpos.enabled)\n      {\n      OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n      OP1(SLJIT_MOV, TMP2, 0, base, offset1);\n      OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n      jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n      label = LABEL();\n      OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      if (CURRENT_AS(char_iterator_backtrack)->u.charpos.othercasebit != 0)\n        OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, CURRENT_AS(char_iterator_backtrack)->u.charpos.othercasebit);\n      CMPTO(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CURRENT_AS(char_iterator_backtrack)->u.charpos.chr, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n      move_back(common, NULL, TRUE);\n      CMPTO(SLJIT_GREATER, STR_PTR, 0, TMP2, 0, label);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n      jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, base, offset1);\n      move_back(common, NULL, TRUE);\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n      }\n    JUMPHERE(jump);\n    if (private_data_ptr == 0)\n      free_stack(common, 2);\n    }\n  break;\n\n  case OP_MINSTAR:\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  compile_char1_matchingpath(common, type, cc, &jumplist, TRUE);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  set_jumps(jumplist, LABEL());\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  break;\n\n  case OP_MINUPTO:\n  OP1(SLJIT_MOV, TMP1, 0, base, offset1);\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n  add_jump(compiler, &jumplist, JUMP(SLJIT_ZERO));\n\n  OP1(SLJIT_MOV, base, offset1, TMP1, 0);\n  compile_char1_matchingpath(common, type, cc, &jumplist, TRUE);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n\n  set_jumps(jumplist, LABEL());\n  if (private_data_ptr == 0)\n    free_stack(common, 2);\n  break;\n\n  case OP_QUERY:\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP1(SLJIT_MOV, base, offset0, SLJIT_IMM, 0);\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  jump = JUMP(SLJIT_JUMP);\n  set_jumps(CURRENT_AS(char_iterator_backtrack)->u.backtracks, LABEL());\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP1(SLJIT_MOV, base, offset0, SLJIT_IMM, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  JUMPHERE(jump);\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  break;\n\n  case OP_MINQUERY:\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP1(SLJIT_MOV, base, offset0, SLJIT_IMM, 0);\n  jump = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n  compile_char1_matchingpath(common, type, cc, &jumplist, TRUE);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  set_jumps(jumplist, LABEL());\n  JUMPHERE(jump);\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  break;\n\n  case OP_EXACT:\n  case OP_POSSTAR:\n  case OP_POSQUERY:\n  case OP_POSUPTO:\n  break;\n\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\nset_jumps(current->topbacktracks, LABEL());\n}\n\nstatic SLJIT_INLINE void compile_ref_iterator_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = current->cc;\nBOOL ref = (*cc == OP_REF || *cc == OP_REFI);\nPCRE2_UCHAR type;\n\ntype = cc[ref ? 1 + IMM2_SIZE : 1 + 2 * IMM2_SIZE];\n\nif ((type & 0x1) == 0)\n  {\n  /* Maximize case. */\n  set_jumps(current->topbacktracks, LABEL());\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(ref_iterator_backtrack)->matchingpath);\n  return;\n  }\n\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\nCMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(ref_iterator_backtrack)->matchingpath);\nset_jumps(current->topbacktracks, LABEL());\nfree_stack(common, ref ? 2 : 3);\n}\n\nstatic SLJIT_INLINE void compile_recurse_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nrecurse_entry *entry;\n\nif (!CURRENT_AS(recurse_backtrack)->inlined_pattern)\n  {\n  entry = CURRENT_AS(recurse_backtrack)->entry;\n  if (entry->backtrack_label == NULL)\n    add_jump(compiler, &entry->backtrack_calls, JUMP(SLJIT_FAST_CALL));\n  else\n    JUMPTO(SLJIT_FAST_CALL, entry->backtrack_label);\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, CURRENT_AS(recurse_backtrack)->matchingpath);\n  }\nelse\n  compile_backtrackingpath(common, current->top);\n\nset_jumps(current->topbacktracks, LABEL());\n}\n\nstatic void compile_assert_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = current->cc;\nPCRE2_UCHAR bra = OP_BRA;\nstruct sljit_jump *brajump = NULL;\n\nSLJIT_ASSERT(*cc != OP_BRAMINZERO);\nif (*cc == OP_BRAZERO)\n  {\n  bra = *cc;\n  cc++;\n  }\n\nif (bra == OP_BRAZERO)\n  {\n  SLJIT_ASSERT(current->topbacktracks == NULL);\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  }\n\nif (CURRENT_AS(assert_backtrack)->framesize < 0)\n  {\n  set_jumps(current->topbacktracks, LABEL());\n\n  if (bra == OP_BRAZERO)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n    CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(assert_backtrack)->matchingpath);\n    free_stack(common, 1);\n    }\n  return;\n  }\n\nif (bra == OP_BRAZERO)\n  {\n  if (*cc == OP_ASSERT_NOT || *cc == OP_ASSERTBACK_NOT)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n    CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(assert_backtrack)->matchingpath);\n    free_stack(common, 1);\n    return;\n    }\n  free_stack(common, 1);\n  brajump = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n  }\n\nif (*cc == OP_ASSERT || *cc == OP_ASSERTBACK)\n  {\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(assert_backtrack)->private_data_ptr);\n  add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n  OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(assert_backtrack)->framesize - 1) * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(assert_backtrack)->private_data_ptr, TMP1, 0);\n\n  set_jumps(current->topbacktracks, LABEL());\n  }\nelse\n  set_jumps(current->topbacktracks, LABEL());\n\nif (bra == OP_BRAZERO)\n  {\n  /* We know there is enough place on the stack. */\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(assert_backtrack)->matchingpath);\n  JUMPHERE(brajump);\n  }\n}\n\nstatic void compile_bracket_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nint opcode, stacksize, alt_count, alt_max;\nint offset = 0;\nint private_data_ptr = CURRENT_AS(bracket_backtrack)->private_data_ptr;\nint repeat_ptr = 0, repeat_type = 0, repeat_count = 0;\nPCRE2_SPTR cc = current->cc;\nPCRE2_SPTR ccbegin;\nPCRE2_SPTR ccprev;\nPCRE2_UCHAR bra = OP_BRA;\nPCRE2_UCHAR ket;\nassert_backtrack *assert;\nBOOL has_alternatives;\nBOOL needs_control_head = FALSE;\nstruct sljit_jump *brazero = NULL;\nstruct sljit_jump *next_alt = NULL;\nstruct sljit_jump *once = NULL;\nstruct sljit_jump *cond = NULL;\nstruct sljit_label *rmin_label = NULL;\nstruct sljit_label *exact_label = NULL;\nstruct sljit_put_label *put_label = NULL;\n\nif (*cc == OP_BRAZERO || *cc == OP_BRAMINZERO)\n  {\n  bra = *cc;\n  cc++;\n  }\n\nopcode = *cc;\nccbegin = bracketend(cc) - 1 - LINK_SIZE;\nket = *ccbegin;\nif (ket == OP_KET && PRIVATE_DATA(ccbegin) != 0)\n  {\n  repeat_ptr = PRIVATE_DATA(ccbegin);\n  repeat_type = PRIVATE_DATA(ccbegin + 2);\n  repeat_count = PRIVATE_DATA(ccbegin + 3);\n  SLJIT_ASSERT(repeat_type != 0 && repeat_count != 0);\n  if (repeat_type == OP_UPTO)\n    ket = OP_KETRMAX;\n  if (repeat_type == OP_MINUPTO)\n    ket = OP_KETRMIN;\n  }\nccbegin = cc;\ncc += GET(cc, 1);\nhas_alternatives = *cc == OP_ALT;\nif (SLJIT_UNLIKELY(opcode == OP_COND) || SLJIT_UNLIKELY(opcode == OP_SCOND))\n  has_alternatives = (ccbegin[1 + LINK_SIZE] >= OP_ASSERT && ccbegin[1 + LINK_SIZE] <= OP_ASSERTBACK_NOT) || CURRENT_AS(bracket_backtrack)->u.condfailed != NULL;\nif (opcode == OP_CBRA || opcode == OP_SCBRA)\n  offset = (GET2(ccbegin, 1 + LINK_SIZE)) << 1;\nif (SLJIT_UNLIKELY(opcode == OP_COND) && (*cc == OP_KETRMAX || *cc == OP_KETRMIN))\n  opcode = OP_SCOND;\n\nalt_max = has_alternatives ? no_alternatives(ccbegin) : 0;\n\n/* Decoding the needs_control_head in framesize. */\nif (opcode == OP_ONCE)\n  {\n  needs_control_head = (CURRENT_AS(bracket_backtrack)->u.framesize & 0x1) != 0;\n  CURRENT_AS(bracket_backtrack)->u.framesize >>= 1;\n  }\n\nif (ket != OP_KET && repeat_type != 0)\n  {\n  /* TMP1 is used in OP_KETRMIN below. */\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  if (repeat_type == OP_UPTO)\n    OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), repeat_ptr, TMP1, 0, SLJIT_IMM, 1);\n  else\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, TMP1, 0);\n  }\n\nif (ket == OP_KETRMAX)\n  {\n  if (bra == OP_BRAZERO)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    brazero = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n    }\n  }\nelse if (ket == OP_KETRMIN)\n  {\n  if (bra != OP_BRAMINZERO)\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    if (repeat_type != 0)\n      {\n      /* TMP1 was set a few lines above. */\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n      /* Drop STR_PTR for non-greedy plus quantifier. */\n      if (opcode != OP_ONCE)\n        free_stack(common, 1);\n      }\n    else if (opcode >= OP_SBRA || opcode == OP_ONCE)\n      {\n      /* Checking zero-length iteration. */\n      if (opcode != OP_ONCE || CURRENT_AS(bracket_backtrack)->u.framesize < 0)\n        CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n      else\n        {\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n        CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(TMP1), STACK(-CURRENT_AS(bracket_backtrack)->u.framesize - 2), CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n        }\n      /* Drop STR_PTR for non-greedy plus quantifier. */\n      if (opcode != OP_ONCE)\n        free_stack(common, 1);\n      }\n    else\n      JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n    }\n  rmin_label = LABEL();\n  if (repeat_type != 0)\n    OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  }\nelse if (bra == OP_BRAZERO)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  brazero = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n  }\nelse if (repeat_type == OP_EXACT)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  exact_label = LABEL();\n  }\n\nif (offset != 0)\n  {\n  if (common->capture_last_ptr != 0)\n    {\n    SLJIT_ASSERT(common->optimized_cbracket[offset >> 1] == 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, TMP1, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(2));\n    free_stack(common, 3);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP2, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP1, 0);\n    }\n  else if (common->optimized_cbracket[offset >> 1] == 0)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    free_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP2, 0);\n    }\n  }\n\nif (SLJIT_UNLIKELY(opcode == OP_ONCE))\n  {\n  if (CURRENT_AS(bracket_backtrack)->u.framesize >= 0)\n    {\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n    OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(bracket_backtrack)->u.framesize - 1) * sizeof(sljit_sw));\n    }\n  once = JUMP(SLJIT_JUMP);\n  }\nelse if (SLJIT_UNLIKELY(opcode == OP_COND) || SLJIT_UNLIKELY(opcode == OP_SCOND))\n  {\n  if (has_alternatives)\n    {\n    /* Always exactly one alternative. */\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n\n    alt_max = 2;\n    next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n    }\n  }\nelse if (has_alternatives)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n\n  if (alt_max > 3)\n    {\n    sljit_emit_ijump(compiler, SLJIT_JUMP, TMP1, 0);\n\n    SLJIT_ASSERT(CURRENT_AS(bracket_backtrack)->u.matching_put_label);\n    sljit_set_put_label(CURRENT_AS(bracket_backtrack)->u.matching_put_label, LABEL());\n    sljit_emit_op0(compiler, SLJIT_ENDBR);\n    }\n  else\n    next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n  }\n\nCOMPILE_BACKTRACKINGPATH(current->top);\nif (current->topbacktracks)\n  set_jumps(current->topbacktracks, LABEL());\n\nif (SLJIT_UNLIKELY(opcode == OP_COND) || SLJIT_UNLIKELY(opcode == OP_SCOND))\n  {\n  /* Conditional block always has at most one alternative. */\n  if (ccbegin[1 + LINK_SIZE] >= OP_ASSERT && ccbegin[1 + LINK_SIZE] <= OP_ASSERTBACK_NOT)\n    {\n    SLJIT_ASSERT(has_alternatives);\n    assert = CURRENT_AS(bracket_backtrack)->u.assert;\n    if (assert->framesize >= 0 && (ccbegin[1 + LINK_SIZE] == OP_ASSERT || ccbegin[1 + LINK_SIZE] == OP_ASSERTBACK))\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (assert->framesize - 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr, TMP1, 0);\n      }\n    cond = JUMP(SLJIT_JUMP);\n    set_jumps(CURRENT_AS(bracket_backtrack)->u.assert->condfailed, LABEL());\n    }\n  else if (CURRENT_AS(bracket_backtrack)->u.condfailed != NULL)\n    {\n    SLJIT_ASSERT(has_alternatives);\n    cond = JUMP(SLJIT_JUMP);\n    set_jumps(CURRENT_AS(bracket_backtrack)->u.condfailed, LABEL());\n    }\n  else\n    SLJIT_ASSERT(!has_alternatives);\n  }\n\nif (has_alternatives)\n  {\n  alt_count = 1;\n  do\n    {\n    current->top = NULL;\n    current->topbacktracks = NULL;\n    current->nextbacktracks = NULL;\n    /* Conditional blocks always have an additional alternative, even if it is empty. */\n    if (*cc == OP_ALT)\n      {\n      ccprev = cc + 1 + LINK_SIZE;\n      cc += GET(cc, 1);\n      if (opcode != OP_COND && opcode != OP_SCOND)\n        {\n        if (opcode != OP_ONCE)\n          {\n          if (private_data_ptr != 0)\n            OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n          else\n            OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n          }\n        else\n          OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(needs_control_head ? 1 : 0));\n        }\n      compile_matchingpath(common, ccprev, cc, current);\n      if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n        return;\n\n      if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA)\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n\n      if (opcode == OP_SCRIPT_RUN)\n        match_script_run_common(common, private_data_ptr, current);\n      }\n\n    /* Instructions after the current alternative is successfully matched. */\n    /* There is a similar code in compile_bracket_matchingpath. */\n    if (opcode == OP_ONCE)\n      match_once_common(common, ket, CURRENT_AS(bracket_backtrack)->u.framesize, private_data_ptr, has_alternatives, needs_control_head);\n\n    stacksize = 0;\n    if (repeat_type == OP_MINUPTO)\n      {\n      /* We need to preserve the counter. TMP2 will be used below. */\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr);\n      stacksize++;\n      }\n    if (ket != OP_KET || bra != OP_BRA)\n      stacksize++;\n    if (offset != 0)\n      {\n      if (common->capture_last_ptr != 0)\n        stacksize++;\n      if (common->optimized_cbracket[offset >> 1] == 0)\n        stacksize += 2;\n      }\n    if (opcode != OP_ONCE)\n      stacksize++;\n\n    if (stacksize > 0)\n      allocate_stack(common, stacksize);\n\n    stacksize = 0;\n    if (repeat_type == OP_MINUPTO)\n      {\n      /* TMP2 was set above. */\n      OP2(SLJIT_SUB, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP2, 0, SLJIT_IMM, 1);\n      stacksize++;\n      }\n\n    if (ket != OP_KET || bra != OP_BRA)\n      {\n      if (ket != OP_KET)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n      else\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n      stacksize++;\n      }\n\n    if (offset != 0)\n      stacksize = match_capture_common(common, stacksize, offset, private_data_ptr);\n\n    if (opcode != OP_ONCE)\n      {\n      if (alt_max <= 3)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, alt_count);\n      else\n        put_label = sljit_emit_put_label(compiler, SLJIT_MEM1(STACK_TOP), STACK(stacksize));\n      }\n\n    if (offset != 0 && ket == OP_KETRMAX && common->optimized_cbracket[offset >> 1] != 0)\n      {\n      /* If ket is not OP_KETRMAX, this code path is executed after the jump to alternative_matchingpath. */\n      SLJIT_ASSERT(private_data_ptr == OVECTOR(offset + 0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n      }\n\n    JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->alternative_matchingpath);\n\n    if (opcode != OP_ONCE)\n      {\n      if (alt_max <= 3)\n        {\n        JUMPHERE(next_alt);\n        alt_count++;\n        if (alt_count < alt_max)\n          {\n          SLJIT_ASSERT(alt_count == 2 && alt_max == 3);\n          next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 1);\n          }\n        }\n      else\n        {\n        sljit_set_put_label(put_label, LABEL());\n        sljit_emit_op0(compiler, SLJIT_ENDBR);\n        }\n      }\n\n    COMPILE_BACKTRACKINGPATH(current->top);\n    if (current->topbacktracks)\n      set_jumps(current->topbacktracks, LABEL());\n    SLJIT_ASSERT(!current->nextbacktracks);\n    }\n  while (*cc == OP_ALT);\n\n  if (cond != NULL)\n    {\n    SLJIT_ASSERT(opcode == OP_COND || opcode == OP_SCOND);\n    assert = CURRENT_AS(bracket_backtrack)->u.assert;\n    if ((ccbegin[1 + LINK_SIZE] == OP_ASSERT_NOT || ccbegin[1 + LINK_SIZE] == OP_ASSERTBACK_NOT) && assert->framesize >= 0)\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (assert->framesize - 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr, TMP1, 0);\n      }\n    JUMPHERE(cond);\n    }\n\n  /* Free the STR_PTR. */\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  }\n\nif (offset != 0)\n  {\n  /* Using both tmp register is better for instruction scheduling. */\n  if (common->optimized_cbracket[offset >> 1] != 0)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    free_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP2, 0);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n  }\nelse if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA || opcode == OP_SCRIPT_RUN || opcode == OP_SBRA || opcode == OP_SCOND)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  }\nelse if (opcode == OP_ONCE)\n  {\n  cc = ccbegin + GET(ccbegin, 1);\n  stacksize = needs_control_head ? 1 : 0;\n\n  if (CURRENT_AS(bracket_backtrack)->u.framesize >= 0)\n    {\n    /* Reset head and drop saved frame. */\n    stacksize += CURRENT_AS(bracket_backtrack)->u.framesize + ((ket != OP_KET || *cc == OP_ALT) ? 2 : 1);\n    }\n  else if (ket == OP_KETRMAX || (*cc == OP_ALT && ket != OP_KETRMIN))\n    {\n    /* The STR_PTR must be released. */\n    stacksize++;\n    }\n\n  if (stacksize > 0)\n    free_stack(common, stacksize);\n\n  JUMPHERE(once);\n  /* Restore previous private_data_ptr */\n  if (CURRENT_AS(bracket_backtrack)->u.framesize >= 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-CURRENT_AS(bracket_backtrack)->u.framesize - 1));\n  else if (ket == OP_KETRMIN)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    /* See the comment below. */\n    free_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n  }\n\nif (repeat_type == OP_EXACT)\n  {\n  OP2(SLJIT_ADD, TMP1, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, TMP1, 0);\n  CMPTO(SLJIT_LESS_EQUAL, TMP1, 0, SLJIT_IMM, repeat_count, exact_label);\n  }\nelse if (ket == OP_KETRMAX)\n  {\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  if (bra != OP_BRAZERO)\n    free_stack(common, 1);\n\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n  if (bra == OP_BRAZERO)\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->zero_matchingpath);\n    JUMPHERE(brazero);\n    free_stack(common, 1);\n    }\n  }\nelse if (ket == OP_KETRMIN)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  /* OP_ONCE removes everything in case of a backtrack, so we don't\n  need to explicitly release the STR_PTR. The extra release would\n  affect badly the free_stack(2) above. */\n  if (opcode != OP_ONCE)\n    free_stack(common, 1);\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, rmin_label);\n  if (opcode == OP_ONCE)\n    free_stack(common, bra == OP_BRAMINZERO ? 2 : 1);\n  else if (bra == OP_BRAMINZERO)\n    free_stack(common, 1);\n  }\nelse if (bra == OP_BRAZERO)\n  {\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->zero_matchingpath);\n  JUMPHERE(brazero);\n  }\n}\n\nstatic SLJIT_INLINE void compile_bracketpos_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nint offset;\nstruct sljit_jump *jump;\n\nif (CURRENT_AS(bracketpos_backtrack)->framesize < 0)\n  {\n  if (*current->cc == OP_CBRAPOS || *current->cc == OP_SCBRAPOS)\n    {\n    offset = (GET2(current->cc, 1 + LINK_SIZE)) << 1;\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n    if (common->capture_last_ptr != 0)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(2));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP2, 0);\n    if (common->capture_last_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, TMP1, 0);\n    }\n  set_jumps(current->topbacktracks, LABEL());\n  free_stack(common, CURRENT_AS(bracketpos_backtrack)->stacksize);\n  return;\n  }\n\nOP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(bracketpos_backtrack)->private_data_ptr);\nadd_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\nOP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(bracketpos_backtrack)->framesize - 1) * sizeof(sljit_sw));\n\nif (current->topbacktracks)\n  {\n  jump = JUMP(SLJIT_JUMP);\n  set_jumps(current->topbacktracks, LABEL());\n  /* Drop the stack frame. */\n  free_stack(common, CURRENT_AS(bracketpos_backtrack)->stacksize);\n  JUMPHERE(jump);\n  }\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(bracketpos_backtrack)->private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-CURRENT_AS(bracketpos_backtrack)->framesize - 1));\n}\n\nstatic SLJIT_INLINE void compile_braminzero_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nassert_backtrack backtrack;\n\ncurrent->top = NULL;\ncurrent->topbacktracks = NULL;\ncurrent->nextbacktracks = NULL;\nif (current->cc[1] > OP_ASSERTBACK_NOT)\n  {\n  /* Manual call of compile_bracket_matchingpath and compile_bracket_backtrackingpath. */\n  compile_bracket_matchingpath(common, current->cc, current);\n  compile_bracket_backtrackingpath(common, current->top);\n  }\nelse\n  {\n  memset(&backtrack, 0, sizeof(backtrack));\n  backtrack.common.cc = current->cc;\n  backtrack.matchingpath = CURRENT_AS(braminzero_backtrack)->matchingpath;\n  /* Manual call of compile_assert_matchingpath. */\n  compile_assert_matchingpath(common, current->cc, &backtrack, FALSE);\n  }\nSLJIT_ASSERT(!current->nextbacktracks && !current->topbacktracks);\n}\n\nstatic SLJIT_INLINE void compile_control_verb_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_UCHAR opcode = *current->cc;\nstruct sljit_label *loop;\nstruct sljit_jump *jump;\n\nif (opcode == OP_THEN || opcode == OP_THEN_ARG)\n  {\n  if (common->then_trap != NULL)\n    {\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, type_then_trap);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, common->then_trap->start);\n    jump = JUMP(SLJIT_JUMP);\n\n    loop = LABEL();\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    JUMPHERE(jump);\n    CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0, loop);\n    CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(2), TMP2, 0, loop);\n    add_jump(compiler, &common->then_trap->quit, JUMP(SLJIT_JUMP));\n    return;\n    }\n  else if (!common->local_quit_available && common->in_positive_assertion)\n    {\n    add_jump(compiler, &common->positive_assertion_quit, JUMP(SLJIT_JUMP));\n    return;\n    }\n  }\n\nif (common->local_quit_available)\n  {\n  /* Abort match with a fail. */\n  if (common->quit_label == NULL)\n    add_jump(compiler, &common->quit, JUMP(SLJIT_JUMP));\n  else\n    JUMPTO(SLJIT_JUMP, common->quit_label);\n  return;\n  }\n\nif (opcode == OP_SKIP_ARG)\n  {\n  SLJIT_ASSERT(common->control_head_ptr != 0 && TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n  OP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_IMM, (sljit_sw)(current->cc + 2));\n  sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(do_search_mark));\n\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_R0, 0);\n  add_jump(compiler, &common->reset_match, CMP(SLJIT_NOT_EQUAL, SLJIT_R0, 0, SLJIT_IMM, 0));\n  return;\n  }\n\nif (opcode == OP_SKIP)\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\nelse\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_IMM, 0);\nadd_jump(compiler, &common->reset_match, JUMP(SLJIT_JUMP));\n}\n\nstatic SLJIT_INLINE void compile_then_trap_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nint size;\n\nif (CURRENT_AS(then_trap_backtrack)->then_trap)\n  {\n  common->then_trap = CURRENT_AS(then_trap_backtrack)->then_trap;\n  return;\n  }\n\nsize = CURRENT_AS(then_trap_backtrack)->framesize;\nsize = 3 + (size < 0 ? 0 : size);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(size - 3));\nfree_stack(common, size);\njump = JUMP(SLJIT_JUMP);\n\nset_jumps(CURRENT_AS(then_trap_backtrack)->quit, LABEL());\n/* STACK_TOP is set by THEN. */\nif (CURRENT_AS(then_trap_backtrack)->framesize >= 0)\n  {\n  add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n  OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(then_trap_backtrack)->framesize - 1) * sizeof(sljit_sw));\n  }\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\nfree_stack(common, 3);\n\nJUMPHERE(jump);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, TMP1, 0);\n}\n\nstatic void compile_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nthen_trap_backtrack *save_then_trap = common->then_trap;\n\nwhile (current)\n  {\n  if (current->nextbacktracks != NULL)\n    set_jumps(current->nextbacktracks, LABEL());\n  switch(*current->cc)\n    {\n    case OP_SET_SOM:\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), TMP1, 0);\n    break;\n\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_UPTO:\n    case OP_MINUPTO:\n    case OP_EXACT:\n    case OP_POSSTAR:\n    case OP_POSPLUS:\n    case OP_POSQUERY:\n    case OP_POSUPTO:\n    case OP_STARI:\n    case OP_MINSTARI:\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_UPTOI:\n    case OP_MINUPTOI:\n    case OP_EXACTI:\n    case OP_POSSTARI:\n    case OP_POSPLUSI:\n    case OP_POSQUERYI:\n    case OP_POSUPTOI:\n    case OP_NOTSTAR:\n    case OP_NOTMINSTAR:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTQUERY:\n    case OP_NOTMINQUERY:\n    case OP_NOTUPTO:\n    case OP_NOTMINUPTO:\n    case OP_NOTEXACT:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSUPTO:\n    case OP_NOTSTARI:\n    case OP_NOTMINSTARI:\n    case OP_NOTPLUSI:\n    case OP_NOTMINPLUSI:\n    case OP_NOTQUERYI:\n    case OP_NOTMINQUERYI:\n    case OP_NOTUPTOI:\n    case OP_NOTMINUPTOI:\n    case OP_NOTEXACTI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTPOSQUERYI:\n    case OP_NOTPOSUPTOI:\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    case OP_TYPEEXACT:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEPOSQUERY:\n    case OP_TYPEPOSUPTO:\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n#endif\n    compile_iterator_backtrackingpath(common, current);\n    break;\n\n    case OP_REF:\n    case OP_REFI:\n    case OP_DNREF:\n    case OP_DNREFI:\n    compile_ref_iterator_backtrackingpath(common, current);\n    break;\n\n    case OP_RECURSE:\n    compile_recurse_backtrackingpath(common, current);\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    compile_assert_backtrackingpath(common, current);\n    break;\n\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRA:\n    case OP_CBRA:\n    case OP_COND:\n    case OP_SBRA:\n    case OP_SCBRA:\n    case OP_SCOND:\n    compile_bracket_backtrackingpath(common, current);\n    break;\n\n    case OP_BRAZERO:\n    if (current->cc[1] > OP_ASSERTBACK_NOT)\n      compile_bracket_backtrackingpath(common, current);\n    else\n      compile_assert_backtrackingpath(common, current);\n    break;\n\n    case OP_BRAPOS:\n    case OP_CBRAPOS:\n    case OP_SBRAPOS:\n    case OP_SCBRAPOS:\n    case OP_BRAPOSZERO:\n    compile_bracketpos_backtrackingpath(common, current);\n    break;\n\n    case OP_BRAMINZERO:\n    compile_braminzero_backtrackingpath(common, current);\n    break;\n\n    case OP_MARK:\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(common->has_skip_arg ? 4 : 0));\n    if (common->has_skip_arg)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, common->has_skip_arg ? 5 : 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, TMP1, 0);\n    if (common->has_skip_arg)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, TMP2, 0);\n    break;\n\n    case OP_THEN:\n    case OP_THEN_ARG:\n    case OP_PRUNE:\n    case OP_PRUNE_ARG:\n    case OP_SKIP:\n    case OP_SKIP_ARG:\n    compile_control_verb_backtrackingpath(common, current);\n    break;\n\n    case OP_COMMIT:\n    case OP_COMMIT_ARG:\n    if (!common->local_quit_available)\n      OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n    if (common->quit_label == NULL)\n      add_jump(compiler, &common->quit, JUMP(SLJIT_JUMP));\n    else\n      JUMPTO(SLJIT_JUMP, common->quit_label);\n    break;\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n    case OP_FAIL:\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    set_jumps(current->topbacktracks, LABEL());\n    break;\n\n    case OP_THEN_TRAP:\n    /* A virtual opcode for then traps. */\n    compile_then_trap_backtrackingpath(common, current);\n    break;\n\n    default:\n    SLJIT_UNREACHABLE();\n    break;\n    }\n  current = current->prev;\n  }\ncommon->then_trap = save_then_trap;\n}\n\nstatic SLJIT_INLINE void compile_recurse(compiler_common *common)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = common->start + common->currententry->start;\nPCRE2_SPTR ccbegin = cc + 1 + LINK_SIZE + (*cc == OP_BRA ? 0 : IMM2_SIZE);\nPCRE2_SPTR ccend = bracketend(cc) - (1 + LINK_SIZE);\nBOOL needs_control_head;\nBOOL has_quit;\nBOOL has_accept;\nint private_data_size = get_recurse_data_length(common, ccbegin, ccend, &needs_control_head, &has_quit, &has_accept);\nint alt_count, alt_max, local_size;\nbacktrack_common altbacktrack;\njump_list *match = NULL;\nstruct sljit_jump *next_alt = NULL;\nstruct sljit_jump *accept_exit = NULL;\nstruct sljit_label *quit;\nstruct sljit_put_label *put_label = NULL;\n\n/* Recurse captures then. */\ncommon->then_trap = NULL;\n\nSLJIT_ASSERT(*cc == OP_BRA || *cc == OP_CBRA || *cc == OP_CBRAPOS || *cc == OP_SCBRA || *cc == OP_SCBRAPOS);\n\nalt_max = no_alternatives(cc);\nalt_count = 0;\n\n/* Matching path. */\nSLJIT_ASSERT(common->currententry->entry_label == NULL && common->recursive_head_ptr != 0);\ncommon->currententry->entry_label = LABEL();\nset_jumps(common->currententry->entry_calls, common->currententry->entry_label);\n\nsljit_emit_fast_enter(compiler, TMP2, 0);\ncount_match(common);\n\nlocal_size = (alt_max > 1) ? 2 : 1;\n\n/* (Reversed) stack layout:\n   [private data][return address][optional: str ptr] ... [optional: alternative index][recursive_head_ptr] */\n\nallocate_stack(common, private_data_size + local_size);\n/* Save return address. */\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1), TMP2, 0);\n\ncopy_recurse_data(common, ccbegin, ccend, recurse_copy_from_global, local_size, private_data_size + local_size, has_quit);\n\n/* This variable is saved and restored all time when we enter or exit from a recursive context. */\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr, STACK_TOP, 0);\n\nif (needs_control_head)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n\nif (alt_max > 1)\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\nmemset(&altbacktrack, 0, sizeof(backtrack_common));\ncommon->quit_label = NULL;\ncommon->accept_label = NULL;\ncommon->quit = NULL;\ncommon->accept = NULL;\naltbacktrack.cc = ccbegin;\ncc += GET(cc, 1);\nwhile (1)\n  {\n  altbacktrack.top = NULL;\n  altbacktrack.topbacktracks = NULL;\n\n  if (altbacktrack.cc != ccbegin)\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  compile_matchingpath(common, altbacktrack.cc, cc, &altbacktrack);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return;\n\n  allocate_stack(common, (alt_max > 1 || has_accept) ? 2 : 1);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr);\n\n  if (alt_max > 1 || has_accept)\n    {\n    if (alt_max > 3)\n      put_label = sljit_emit_put_label(compiler, SLJIT_MEM1(STACK_TOP), STACK(1));\n    else\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, alt_count);\n    }\n\n  add_jump(compiler, &match, JUMP(SLJIT_JUMP));\n\n  if (alt_count == 0)\n    {\n    /* Backtracking path entry. */\n    SLJIT_ASSERT(common->currententry->backtrack_label == NULL);\n    common->currententry->backtrack_label = LABEL();\n    set_jumps(common->currententry->backtrack_calls, common->currententry->backtrack_label);\n\n    sljit_emit_fast_enter(compiler, TMP1, 0);\n\n    if (has_accept)\n      accept_exit = CMP(SLJIT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, -1);\n\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    /* Save return address. */\n    OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), STACK(local_size - 1), TMP1, 0);\n\n    copy_recurse_data(common, ccbegin, ccend, recurse_swap_global, local_size, private_data_size + local_size, has_quit);\n\n    if (alt_max > 1)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n      free_stack(common, 2);\n\n      if (alt_max > 3)\n        {\n        sljit_emit_ijump(compiler, SLJIT_JUMP, TMP1, 0);\n        sljit_set_put_label(put_label, LABEL());\n        sljit_emit_op0(compiler, SLJIT_ENDBR);\n        }\n      else\n        next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n      }\n    else\n      free_stack(common, has_accept ? 2 : 1);\n    }\n  else if (alt_max > 3)\n    {\n    sljit_set_put_label(put_label, LABEL());\n    sljit_emit_op0(compiler, SLJIT_ENDBR);\n    }\n  else\n    {\n    JUMPHERE(next_alt);\n    if (alt_count + 1 < alt_max)\n      {\n      SLJIT_ASSERT(alt_count == 1 && alt_max == 3);\n      next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 1);\n      }\n    }\n\n  alt_count++;\n\n  compile_backtrackingpath(common, altbacktrack.top);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return;\n  set_jumps(altbacktrack.topbacktracks, LABEL());\n\n  if (*cc != OP_ALT)\n    break;\n\n  altbacktrack.cc = cc + 1 + LINK_SIZE;\n  cc += GET(cc, 1);\n  }\n\n/* No alternative is matched. */\n\nquit = LABEL();\n\ncopy_recurse_data(common, ccbegin, ccend, recurse_copy_private_to_global, local_size, private_data_size + local_size, has_quit);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1));\nfree_stack(common, private_data_size + local_size);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP_SRC(SLJIT_FAST_RETURN, TMP2, 0);\n\nif (common->quit != NULL)\n  {\n  SLJIT_ASSERT(has_quit);\n\n  set_jumps(common->quit, LABEL());\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr);\n  copy_recurse_data(common, ccbegin, ccend, recurse_copy_shared_to_global, local_size, private_data_size + local_size, has_quit);\n  JUMPTO(SLJIT_JUMP, quit);\n  }\n\nif (has_accept)\n  {\n  JUMPHERE(accept_exit);\n  free_stack(common, 2);\n\n  /* Save return address. */\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1), TMP1, 0);\n\n  copy_recurse_data(common, ccbegin, ccend, recurse_copy_kept_shared_to_global, local_size, private_data_size + local_size, has_quit);\n\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1));\n  free_stack(common, private_data_size + local_size);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n  OP_SRC(SLJIT_FAST_RETURN, TMP2, 0);\n  }\n\nif (common->accept != NULL)\n  {\n  SLJIT_ASSERT(has_accept);\n\n  set_jumps(common->accept, LABEL());\n\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr);\n  OP1(SLJIT_MOV, TMP2, 0, STACK_TOP, 0);\n\n  allocate_stack(common, 2);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, -1);\n  }\n\nset_jumps(match, LABEL());\n\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n\ncopy_recurse_data(common, ccbegin, ccend, recurse_swap_global, local_size, private_data_size + local_size, has_quit);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP2), STACK(local_size - 1));\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP_SRC(SLJIT_FAST_RETURN, TMP2, 0);\n}\n\n#undef COMPILE_BACKTRACKINGPATH\n#undef CURRENT_AS\n\n#define PUBLIC_JIT_COMPILE_CONFIGURATION_OPTIONS \\\n  (PCRE2_JIT_INVALID_UTF)\n\nstatic int jit_compile(pcre2_code *code, sljit_u32 mode)\n{\npcre2_real_code *re = (pcre2_real_code *)code;\nstruct sljit_compiler *compiler;\nbacktrack_common rootbacktrack;\ncompiler_common common_data;\ncompiler_common *common = &common_data;\nconst sljit_u8 *tables = re->tables;\nvoid *allocator_data = &re->memctl;\nint private_data_size;\nPCRE2_SPTR ccend;\nexecutable_functions *functions;\nvoid *executable_func;\nsljit_uw executable_size;\nsljit_uw total_length;\nstruct sljit_label *mainloop_label = NULL;\nstruct sljit_label *continue_match_label;\nstruct sljit_label *empty_match_found_label = NULL;\nstruct sljit_label *empty_match_backtrack_label = NULL;\nstruct sljit_label *reset_match_label;\nstruct sljit_label *quit_label;\nstruct sljit_jump *jump;\nstruct sljit_jump *minlength_check_failed = NULL;\nstruct sljit_jump *empty_match = NULL;\nstruct sljit_jump *end_anchor_failed = NULL;\njump_list *reqcu_not_found = NULL;\n\nSLJIT_ASSERT(tables);\n\n#if HAS_VIRTUAL_REGISTERS == 1\nSLJIT_ASSERT(sljit_get_register_index(TMP3) < 0 && sljit_get_register_index(ARGUMENTS) < 0 && sljit_get_register_index(RETURN_ADDR) < 0);\n#elif HAS_VIRTUAL_REGISTERS == 0\nSLJIT_ASSERT(sljit_get_register_index(TMP3) >= 0 && sljit_get_register_index(ARGUMENTS) >= 0 && sljit_get_register_index(RETURN_ADDR) >= 0);\n#else\n#error \"Invalid value for HAS_VIRTUAL_REGISTERS\"\n#endif\n\nmemset(&rootbacktrack, 0, sizeof(backtrack_common));\nmemset(common, 0, sizeof(compiler_common));\ncommon->re = re;\ncommon->name_table = (PCRE2_SPTR)((uint8_t *)re + sizeof(pcre2_real_code));\nrootbacktrack.cc = common->name_table + re->name_count * re->name_entry_size;\n\n#ifdef SUPPORT_UNICODE\ncommon->invalid_utf = (mode & PCRE2_JIT_INVALID_UTF) != 0;\n#endif /* SUPPORT_UNICODE */\nmode &= ~PUBLIC_JIT_COMPILE_CONFIGURATION_OPTIONS;\n\ncommon->start = rootbacktrack.cc;\ncommon->read_only_data_head = NULL;\ncommon->fcc = tables + fcc_offset;\ncommon->lcc = (sljit_sw)(tables + lcc_offset);\ncommon->mode = mode;\ncommon->might_be_empty = (re->minlength == 0) || (re->flags & PCRE2_MATCH_EMPTY);\ncommon->allow_empty_partial = (re->max_lookbehind > 0) || (re->flags & PCRE2_MATCH_EMPTY);\ncommon->nltype = NLTYPE_FIXED;\nswitch(re->newline_convention)\n  {\n  case PCRE2_NEWLINE_CR: common->newline = CHAR_CR; break;\n  case PCRE2_NEWLINE_LF: common->newline = CHAR_NL; break;\n  case PCRE2_NEWLINE_CRLF: common->newline = (CHAR_CR << 8) | CHAR_NL; break;\n  case PCRE2_NEWLINE_ANY: common->newline = (CHAR_CR << 8) | CHAR_NL; common->nltype = NLTYPE_ANY; break;\n  case PCRE2_NEWLINE_ANYCRLF: common->newline = (CHAR_CR << 8) | CHAR_NL; common->nltype = NLTYPE_ANYCRLF; break;\n  case PCRE2_NEWLINE_NUL: common->newline = CHAR_NUL; break;\n  default: return PCRE2_ERROR_INTERNAL;\n  }\ncommon->nlmax = READ_CHAR_MAX;\ncommon->nlmin = 0;\nif (re->bsr_convention == PCRE2_BSR_UNICODE)\n  common->bsr_nltype = NLTYPE_ANY;\nelse if (re->bsr_convention == PCRE2_BSR_ANYCRLF)\n  common->bsr_nltype = NLTYPE_ANYCRLF;\nelse\n  {\n#ifdef BSR_ANYCRLF\n  common->bsr_nltype = NLTYPE_ANYCRLF;\n#else\n  common->bsr_nltype = NLTYPE_ANY;\n#endif\n  }\ncommon->bsr_nlmax = READ_CHAR_MAX;\ncommon->bsr_nlmin = 0;\ncommon->endonly = (re->overall_options & PCRE2_DOLLAR_ENDONLY) != 0;\ncommon->ctypes = (sljit_sw)(tables + ctypes_offset);\ncommon->name_count = re->name_count;\ncommon->name_entry_size = re->name_entry_size;\ncommon->unset_backref = (re->overall_options & PCRE2_MATCH_UNSET_BACKREF) != 0;\ncommon->alt_circumflex = (re->overall_options & PCRE2_ALT_CIRCUMFLEX) != 0;\n#ifdef SUPPORT_UNICODE\n/* PCRE_UTF[16|32] have the same value as PCRE_UTF8. */\ncommon->utf = (re->overall_options & PCRE2_UTF) != 0;\ncommon->ucp = (re->overall_options & PCRE2_UCP) != 0;\nif (common->utf)\n  {\n  if (common->nltype == NLTYPE_ANY)\n    common->nlmax = 0x2029;\n  else if (common->nltype == NLTYPE_ANYCRLF)\n    common->nlmax = (CHAR_CR > CHAR_NL) ? CHAR_CR : CHAR_NL;\n  else\n    {\n    /* We only care about the first newline character. */\n    common->nlmax = common->newline & 0xff;\n    }\n\n  if (common->nltype == NLTYPE_FIXED)\n    common->nlmin = common->newline & 0xff;\n  else\n    common->nlmin = (CHAR_CR < CHAR_NL) ? CHAR_CR : CHAR_NL;\n\n  if (common->bsr_nltype == NLTYPE_ANY)\n    common->bsr_nlmax = 0x2029;\n  else\n    common->bsr_nlmax = (CHAR_CR > CHAR_NL) ? CHAR_CR : CHAR_NL;\n  common->bsr_nlmin = (CHAR_CR < CHAR_NL) ? CHAR_CR : CHAR_NL;\n  }\nelse\n  common->invalid_utf = FALSE;\n#endif /* SUPPORT_UNICODE */\nccend = bracketend(common->start);\n\n/* Calculate the local space size on the stack. */\ncommon->ovector_start = LIMIT_MATCH + sizeof(sljit_sw);\ncommon->optimized_cbracket = (sljit_u8 *)SLJIT_MALLOC(re->top_bracket + 1, allocator_data);\nif (!common->optimized_cbracket)\n  return PCRE2_ERROR_NOMEMORY;\n#if defined DEBUG_FORCE_UNOPTIMIZED_CBRAS && DEBUG_FORCE_UNOPTIMIZED_CBRAS == 1\nmemset(common->optimized_cbracket, 0, re->top_bracket + 1);\n#else\nmemset(common->optimized_cbracket, 1, re->top_bracket + 1);\n#endif\n\nSLJIT_ASSERT(*common->start == OP_BRA && ccend[-(1 + LINK_SIZE)] == OP_KET);\n#if defined DEBUG_FORCE_UNOPTIMIZED_CBRAS && DEBUG_FORCE_UNOPTIMIZED_CBRAS == 2\ncommon->capture_last_ptr = common->ovector_start;\ncommon->ovector_start += sizeof(sljit_sw);\n#endif\nif (!check_opcode_types(common, common->start, ccend))\n  {\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\n/* Checking flags and updating ovector_start. */\nif (mode == PCRE2_JIT_COMPLETE && (re->flags & PCRE2_LASTSET) != 0 && (re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n  {\n  common->req_char_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\nif (mode != PCRE2_JIT_COMPLETE)\n  {\n  common->start_used_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  if (mode == PCRE2_JIT_PARTIAL_SOFT)\n    {\n    common->hit_start = common->ovector_start;\n    common->ovector_start += sizeof(sljit_sw);\n    }\n  }\nif ((re->overall_options & (PCRE2_FIRSTLINE | PCRE2_USE_OFFSET_LIMIT)) != 0)\n  {\n  common->match_end_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\ncommon->control_head_ptr = 1;\n#endif\nif (common->control_head_ptr != 0)\n  {\n  common->control_head_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\nif (common->has_set_som)\n  {\n  /* Saving the real start pointer is necessary. */\n  common->start_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\n\n/* Aligning ovector to even number of sljit words. */\nif ((common->ovector_start & sizeof(sljit_sw)) != 0)\n  common->ovector_start += sizeof(sljit_sw);\n\nif (common->start_ptr == 0)\n  common->start_ptr = OVECTOR(0);\n\n/* Capturing brackets cannot be optimized if callouts are allowed. */\nif (common->capture_last_ptr != 0)\n  memset(common->optimized_cbracket, 0, re->top_bracket + 1);\n\nSLJIT_ASSERT(!(common->req_char_ptr != 0 && common->start_used_ptr != 0));\ncommon->cbra_ptr = OVECTOR_START + (re->top_bracket + 1) * 2 * sizeof(sljit_sw);\n\ntotal_length = ccend - common->start;\ncommon->private_data_ptrs = (sljit_s32 *)SLJIT_MALLOC(total_length * (sizeof(sljit_s32) + (common->has_then ? 1 : 0)), allocator_data);\nif (!common->private_data_ptrs)\n  {\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\nmemset(common->private_data_ptrs, 0, total_length * sizeof(sljit_s32));\n\nprivate_data_size = common->cbra_ptr + (re->top_bracket + 1) * sizeof(sljit_sw);\n\nif ((re->overall_options & PCRE2_ANCHORED) == 0 && (re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0 && !common->has_skip_in_assert_back)\n  detect_early_fail(common, common->start, &private_data_size, 0, 0, TRUE);\n\nset_private_data_ptrs(common, &private_data_size, ccend);\n\nSLJIT_ASSERT(common->early_fail_start_ptr <= common->early_fail_end_ptr);\n\nif (private_data_size > SLJIT_MAX_LOCAL_SIZE)\n  {\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\nif (common->has_then)\n  {\n  common->then_offsets = (sljit_u8 *)(common->private_data_ptrs + total_length);\n  memset(common->then_offsets, 0, total_length);\n  set_then_offsets(common, common->start, NULL);\n  }\n\ncompiler = sljit_create_compiler(allocator_data, NULL);\nif (!compiler)\n  {\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\ncommon->compiler = compiler;\n\n/* Main pcre2_jit_exec entry. */\nsljit_emit_enter(compiler, 0, SLJIT_ARGS1(W, W), 5, 5, 0, 0, private_data_size);\n\n/* Register init. */\nreset_ovector(common, (re->top_bracket + 1) * 2);\nif (common->req_char_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->req_char_ptr, SLJIT_R0, 0);\n\nOP1(SLJIT_MOV, ARGUMENTS, 0, SLJIT_S0, 0);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_S0, 0);\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\nOP1(SLJIT_MOV, STR_END, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, end));\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, stack));\nOP1(SLJIT_MOV_U32, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, limit_match));\nOP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(struct sljit_stack, end));\nOP1(SLJIT_MOV, STACK_LIMIT, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(struct sljit_stack, start));\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LIMIT_MATCH, TMP1, 0);\n\nif (common->early_fail_start_ptr < common->early_fail_end_ptr)\n  reset_early_fail(common);\n\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, -1);\nif (common->mark_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, SLJIT_IMM, 0);\nif (common->control_head_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n\n/* Main part of the matching */\nif ((re->overall_options & PCRE2_ANCHORED) == 0)\n  {\n  mainloop_label = mainloop_entry(common);\n  continue_match_label = LABEL();\n  /* Forward search if possible. */\n  if ((re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n    {\n    if (mode == PCRE2_JIT_COMPLETE && fast_forward_first_n_chars(common))\n      ;\n    else if ((re->flags & PCRE2_FIRSTSET) != 0)\n      fast_forward_first_char(common);\n    else if ((re->flags & PCRE2_STARTLINE) != 0)\n      fast_forward_newline(common);\n    else if ((re->flags & PCRE2_FIRSTMAPSET) != 0)\n      fast_forward_start_bits(common);\n    }\n  }\nelse\n  continue_match_label = LABEL();\n\nif (mode == PCRE2_JIT_COMPLETE && re->minlength > 0 && (re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n  {\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n  OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(re->minlength));\n  minlength_check_failed = CMP(SLJIT_GREATER, TMP2, 0, STR_END, 0);\n  }\nif (common->req_char_ptr != 0)\n  reqcu_not_found = search_requested_char(common, (PCRE2_UCHAR)(re->last_codeunit), (re->flags & PCRE2_LASTCASELESS) != 0, (re->flags & PCRE2_FIRSTSET) != 0);\n\n/* Store the current STR_PTR in OVECTOR(0). */\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), STR_PTR, 0);\n/* Copy the limit of allowed recursions. */\nOP1(SLJIT_MOV, COUNT_MATCH, 0, SLJIT_MEM1(SLJIT_SP), LIMIT_MATCH);\nif (common->capture_last_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, 0);\nif (common->fast_forward_bc_ptr != NULL)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), PRIVATE_DATA(common->fast_forward_bc_ptr + 1) >> 3, STR_PTR, 0);\n\nif (common->start_ptr != OVECTOR(0))\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_ptr, STR_PTR, 0);\n\n/* Copy the beginning of the string. */\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  jump = CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, -1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  JUMPHERE(jump);\n  }\nelse if (mode == PCRE2_JIT_PARTIAL_HARD)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n\ncompile_matchingpath(common, common->start, ccend, &rootbacktrack);\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  {\n  sljit_free_compiler(compiler);\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\nif ((re->overall_options & PCRE2_ENDANCHORED) != 0)\n  end_anchor_failed = CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, STR_END, 0);\n\nif (common->might_be_empty)\n  {\n  empty_match = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n  empty_match_found_label = LABEL();\n  }\n\ncommon->accept_label = LABEL();\nif (common->accept != NULL)\n  set_jumps(common->accept, common->accept_label);\n\n/* This means we have a match. Update the ovector. */\ncopy_ovector(common, re->top_bracket + 1);\ncommon->quit_label = common->abort_label = LABEL();\nif (common->quit != NULL)\n  set_jumps(common->quit, common->quit_label);\nif (common->abort != NULL)\n  set_jumps(common->abort, common->abort_label);\nif (minlength_check_failed != NULL)\n  SET_LABEL(minlength_check_failed, common->abort_label);\n\nsljit_emit_op0(compiler, SLJIT_SKIP_FRAMES_BEFORE_RETURN);\nsljit_emit_return(compiler, SLJIT_MOV, SLJIT_RETURN_REG, 0);\n\nif (common->failed_match != NULL)\n  {\n  SLJIT_ASSERT(common->mode == PCRE2_JIT_COMPLETE);\n  set_jumps(common->failed_match, LABEL());\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n  JUMPTO(SLJIT_JUMP, common->abort_label);\n  }\n\nif ((re->overall_options & PCRE2_ENDANCHORED) != 0)\n  JUMPHERE(end_anchor_failed);\n\nif (mode != PCRE2_JIT_COMPLETE)\n  {\n  common->partialmatchlabel = LABEL();\n  set_jumps(common->partialmatch, common->partialmatchlabel);\n  return_with_partial_match(common, common->quit_label);\n  }\n\nif (common->might_be_empty)\n  empty_match_backtrack_label = LABEL();\ncompile_backtrackingpath(common, rootbacktrack.top);\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  {\n  sljit_free_compiler(compiler);\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\nSLJIT_ASSERT(rootbacktrack.prev == NULL);\nreset_match_label = LABEL();\n\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  /* Update hit_start only in the first time. */\n  jump = CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, -1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, TMP1, 0);\n  JUMPHERE(jump);\n  }\n\n/* Check we have remaining characters. */\nif ((re->overall_options & PCRE2_ANCHORED) == 0 && common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  }\n\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP),\n    (common->fast_forward_bc_ptr != NULL) ? (PRIVATE_DATA(common->fast_forward_bc_ptr + 1) >> 3) : common->start_ptr);\n\nif ((re->overall_options & PCRE2_ANCHORED) == 0)\n  {\n  if (common->ff_newline_shortcut != NULL)\n    {\n    /* There cannot be more newlines if PCRE2_FIRSTLINE is set. */\n    if ((re->overall_options & PCRE2_FIRSTLINE) == 0)\n      {\n      if (common->match_end_ptr != 0)\n        {\n        OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n        OP1(SLJIT_MOV, STR_END, 0, TMP1, 0);\n        CMPTO(SLJIT_LESS, STR_PTR, 0, TMP1, 0, common->ff_newline_shortcut);\n        OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n        }\n      else\n        CMPTO(SLJIT_LESS, STR_PTR, 0, STR_END, 0, common->ff_newline_shortcut);\n      }\n    }\n  else\n    CMPTO(SLJIT_LESS, STR_PTR, 0, (common->match_end_ptr == 0) ? STR_END : TMP1, 0, mainloop_label);\n  }\n\n/* No more remaining characters. */\nif (reqcu_not_found != NULL)\n  set_jumps(reqcu_not_found, LABEL());\n\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, -1, common->partialmatchlabel);\n\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\nJUMPTO(SLJIT_JUMP, common->quit_label);\n\nflush_stubs(common);\n\nif (common->might_be_empty)\n  {\n  JUMPHERE(empty_match);\n  OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV_U32, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, options));\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY);\n  JUMPTO(SLJIT_NOT_ZERO, empty_match_backtrack_label);\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY_ATSTART);\n  JUMPTO(SLJIT_ZERO, empty_match_found_label);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n  CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0, empty_match_found_label);\n  JUMPTO(SLJIT_JUMP, empty_match_backtrack_label);\n  }\n\ncommon->fast_forward_bc_ptr = NULL;\ncommon->early_fail_start_ptr = 0;\ncommon->early_fail_end_ptr = 0;\ncommon->currententry = common->entries;\ncommon->local_quit_available = TRUE;\nquit_label = common->quit_label;\nwhile (common->currententry != NULL)\n  {\n  /* Might add new entries. */\n  compile_recurse(common);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    {\n    sljit_free_compiler(compiler);\n    SLJIT_FREE(common->optimized_cbracket, allocator_data);\n    SLJIT_FREE(common->private_data_ptrs, allocator_data);\n    PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n    return PCRE2_ERROR_NOMEMORY;\n    }\n  flush_stubs(common);\n  common->currententry = common->currententry->next;\n  }\ncommon->local_quit_available = FALSE;\ncommon->quit_label = quit_label;\n\n/* Allocating stack, returns with PCRE_ERROR_JIT_STACKLIMIT if fails. */\n/* This is a (really) rare case. */\nset_jumps(common->stackalloc, LABEL());\n/* RETURN_ADDR is not a saved register. */\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n\nSLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS1, STR_PTR, 0);\nOP1(SLJIT_MOV, SLJIT_R0, 0, ARGUMENTS, 0);\nOP2(SLJIT_SUB, SLJIT_R1, 0, STACK_LIMIT, 0, SLJIT_IMM, STACK_GROWTH_RATE);\nOP1(SLJIT_MOV, SLJIT_R0, 0, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, stack));\nOP1(SLJIT_MOV, STACK_LIMIT, 0, TMP2, 0);\n\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(sljit_stack_resize));\n\njump = CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0);\nOP1(SLJIT_MOV, TMP2, 0, STACK_LIMIT, 0);\nOP1(SLJIT_MOV, STACK_LIMIT, 0, SLJIT_RETURN_REG, 0);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), LOCALS1);\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n\n/* Allocation failed. */\nJUMPHERE(jump);\n/* We break the return address cache here, but this is a really rare case. */\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_JIT_STACKLIMIT);\nJUMPTO(SLJIT_JUMP, common->quit_label);\n\n/* Call limit reached. */\nset_jumps(common->calllimit, LABEL());\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_MATCHLIMIT);\nJUMPTO(SLJIT_JUMP, common->quit_label);\n\nif (common->revertframes != NULL)\n  {\n  set_jumps(common->revertframes, LABEL());\n  do_revertframes(common);\n  }\nif (common->wordboundary != NULL)\n  {\n  set_jumps(common->wordboundary, LABEL());\n  check_wordboundary(common);\n  }\nif (common->anynewline != NULL)\n  {\n  set_jumps(common->anynewline, LABEL());\n  check_anynewline(common);\n  }\nif (common->hspace != NULL)\n  {\n  set_jumps(common->hspace, LABEL());\n  check_hspace(common);\n  }\nif (common->vspace != NULL)\n  {\n  set_jumps(common->vspace, LABEL());\n  check_vspace(common);\n  }\nif (common->casefulcmp != NULL)\n  {\n  set_jumps(common->casefulcmp, LABEL());\n  do_casefulcmp(common);\n  }\nif (common->caselesscmp != NULL)\n  {\n  set_jumps(common->caselesscmp, LABEL());\n  do_caselesscmp(common);\n  }\nif (common->reset_match != NULL)\n  {\n  set_jumps(common->reset_match, LABEL());\n  do_reset_match(common, (re->top_bracket + 1) * 2);\n  CMPTO(SLJIT_GREATER, STR_PTR, 0, TMP1, 0, continue_match_label);\n  OP1(SLJIT_MOV, STR_PTR, 0, TMP1, 0);\n  JUMPTO(SLJIT_JUMP, reset_match_label);\n  }\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utfreadchar != NULL)\n  {\n  set_jumps(common->utfreadchar, LABEL());\n  do_utfreadchar(common);\n  }\nif (common->utfreadtype8 != NULL)\n  {\n  set_jumps(common->utfreadtype8, LABEL());\n  do_utfreadtype8(common);\n  }\nif (common->utfpeakcharback != NULL)\n  {\n  set_jumps(common->utfpeakcharback, LABEL());\n  do_utfpeakcharback(common);\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n#if PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utfreadchar_invalid != NULL)\n  {\n  set_jumps(common->utfreadchar_invalid, LABEL());\n  do_utfreadchar_invalid(common);\n  }\nif (common->utfreadnewline_invalid != NULL)\n  {\n  set_jumps(common->utfreadnewline_invalid, LABEL());\n  do_utfreadnewline_invalid(common);\n  }\nif (common->utfmoveback_invalid)\n  {\n  set_jumps(common->utfmoveback_invalid, LABEL());\n  do_utfmoveback_invalid(common);\n  }\nif (common->utfpeakcharback_invalid)\n  {\n  set_jumps(common->utfpeakcharback_invalid, LABEL());\n  do_utfpeakcharback_invalid(common);\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16 */\nif (common->getucd != NULL)\n  {\n  set_jumps(common->getucd, LABEL());\n  do_getucd(common);\n  }\nif (common->getucdtype != NULL)\n  {\n  set_jumps(common->getucdtype, LABEL());\n  do_getucdtype(common);\n  }\n#endif /* SUPPORT_UNICODE */\n\nSLJIT_FREE(common->optimized_cbracket, allocator_data);\nSLJIT_FREE(common->private_data_ptrs, allocator_data);\n\nexecutable_func = sljit_generate_code(compiler);\nexecutable_size = sljit_get_generated_code_size(compiler);\nsljit_free_compiler(compiler);\n\nif (executable_func == NULL)\n  {\n  PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\n/* Reuse the function descriptor if possible. */\nif (re->executable_jit != NULL)\n  functions = (executable_functions *)re->executable_jit;\nelse\n  {\n  functions = SLJIT_MALLOC(sizeof(executable_functions), allocator_data);\n  if (functions == NULL)\n    {\n    /* This case is highly unlikely since we just recently\n    freed a lot of memory. Not impossible though. */\n    sljit_free_code(executable_func, NULL);\n    PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n    return PCRE2_ERROR_NOMEMORY;\n    }\n  memset(functions, 0, sizeof(executable_functions));\n  functions->top_bracket = re->top_bracket + 1;\n  functions->limit_match = re->limit_match;\n  re->executable_jit = functions;\n  }\n\n/* Turn mode into an index. */\nif (mode == PCRE2_JIT_COMPLETE)\n  mode = 0;\nelse\n  mode = (mode == PCRE2_JIT_PARTIAL_SOFT) ? 1 : 2;\n\nSLJIT_ASSERT(mode < JIT_NUMBER_OF_COMPILE_MODES);\nfunctions->executable_funcs[mode] = executable_func;\nfunctions->read_only_data_heads[mode] = common->read_only_data_head;\nfunctions->executable_sizes[mode] = executable_size;\nreturn 0;\n}\n\n#endif\n\n/*************************************************\n*        JIT compile a Regular Expression        *\n*************************************************/\n\n/* This function used JIT to convert a previously-compiled pattern into machine\ncode.\n\nArguments:\n  code          a compiled pattern\n  options       JIT option bits\n\nReturns:        0: success or (*NOJIT) was used\n               <0: an error code\n*/\n\n#define PUBLIC_JIT_COMPILE_OPTIONS \\\n  (PCRE2_JIT_COMPLETE|PCRE2_JIT_PARTIAL_SOFT|PCRE2_JIT_PARTIAL_HARD|PCRE2_JIT_INVALID_UTF)\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_jit_compile(pcre2_code *code, uint32_t options)\n{\npcre2_real_code *re = (pcre2_real_code *)code;\n#ifdef SUPPORT_JIT\nexecutable_functions *functions;\nstatic int executable_allocator_is_working = 0;\n#endif\n\nif (code == NULL)\n  return PCRE2_ERROR_NULL;\n\nif ((options & ~PUBLIC_JIT_COMPILE_OPTIONS) != 0)\n  return PCRE2_ERROR_JIT_BADOPTION;\n\n/* Support for invalid UTF was first introduced in JIT, with the option\nPCRE2_JIT_INVALID_UTF. Later, support was added to the interpreter, and the\ncompile-time option PCRE2_MATCH_INVALID_UTF was created. This is now the\npreferred feature, with the earlier option deprecated. However, for backward\ncompatibility, if the earlier option is set, it forces the new option so that\nif JIT matching falls back to the interpreter, there is still support for\ninvalid UTF. However, if this function has already been successfully called\nwithout PCRE2_JIT_INVALID_UTF and without PCRE2_MATCH_INVALID_UTF (meaning that\nnon-invalid-supporting JIT code was compiled), give an error.\n\nIf in the future support for PCRE2_JIT_INVALID_UTF is withdrawn, the following\nactions are needed:\n\n  1. Remove the definition from pcre2.h.in and from the list in\n     PUBLIC_JIT_COMPILE_OPTIONS above.\n\n  2. Replace PCRE2_JIT_INVALID_UTF with a local flag in this module.\n\n  3. Replace PCRE2_JIT_INVALID_UTF in pcre2_jit_test.c.\n\n  4. Delete the following short block of code. The setting of \"re\" and\n     \"functions\" can be moved into the JIT-only block below, but if that is\n     done, (void)re and (void)functions will be needed in the non-JIT case, to\n     avoid compiler warnings.\n*/\n\n#ifdef SUPPORT_JIT\nfunctions = (executable_functions *)re->executable_jit;\n#endif\n\nif ((options & PCRE2_JIT_INVALID_UTF) != 0)\n  {\n  if ((re->overall_options & PCRE2_MATCH_INVALID_UTF) == 0)\n    {\n#ifdef SUPPORT_JIT\n    if (functions != NULL) return PCRE2_ERROR_JIT_BADOPTION;\n#endif\n    re->overall_options |= PCRE2_MATCH_INVALID_UTF;\n    }\n  }\n\n/* The above tests are run with and without JIT support. This means that\nPCRE2_JIT_INVALID_UTF propagates back into the regex options (ensuring\ninterpreter support) even in the absence of JIT. But now, if there is no JIT\nsupport, give an error return. */\n\n#ifndef SUPPORT_JIT\nreturn PCRE2_ERROR_JIT_BADOPTION;\n#else  /* SUPPORT_JIT */\n\n/* There is JIT support. Do the necessary. */\n\nif ((re->flags & PCRE2_NOJIT) != 0) return 0;\n\nif (executable_allocator_is_working == 0)\n  {\n  /* Checks whether the executable allocator is working. This check\n     might run multiple times in multi-threaded environments, but the\n     result should not be affected by it. */\n  void *ptr = SLJIT_MALLOC_EXEC(32, NULL);\n\n  executable_allocator_is_working = -1;\n\n  if (ptr != NULL)\n    {\n    SLJIT_FREE_EXEC(((sljit_u8*)(ptr)) + SLJIT_EXEC_OFFSET(ptr), NULL);\n    executable_allocator_is_working = 1;\n    }\n  }\n\nif (executable_allocator_is_working < 0)\n  return PCRE2_ERROR_NOMEMORY;\n\nif ((re->overall_options & PCRE2_MATCH_INVALID_UTF) != 0)\n  options |= PCRE2_JIT_INVALID_UTF;\n\nif ((options & PCRE2_JIT_COMPLETE) != 0 && (functions == NULL\n    || functions->executable_funcs[0] == NULL)) {\n  uint32_t excluded_options = (PCRE2_JIT_PARTIAL_SOFT | PCRE2_JIT_PARTIAL_HARD);\n  int result = jit_compile(code, options & ~excluded_options);\n  if (result != 0)\n    return result;\n  }\n\nif ((options & PCRE2_JIT_PARTIAL_SOFT) != 0 && (functions == NULL\n    || functions->executable_funcs[1] == NULL)) {\n  uint32_t excluded_options = (PCRE2_JIT_COMPLETE | PCRE2_JIT_PARTIAL_HARD);\n  int result = jit_compile(code, options & ~excluded_options);\n  if (result != 0)\n    return result;\n  }\n\nif ((options & PCRE2_JIT_PARTIAL_HARD) != 0 && (functions == NULL\n    || functions->executable_funcs[2] == NULL)) {\n  uint32_t excluded_options = (PCRE2_JIT_COMPLETE | PCRE2_JIT_PARTIAL_SOFT);\n  int result = jit_compile(code, options & ~excluded_options);\n  if (result != 0)\n    return result;\n  }\n\nreturn 0;\n\n#endif  /* SUPPORT_JIT */\n}\n\n/* JIT compiler uses an all-in-one approach. This improves security,\n   since the code generator functions are not exported. */\n\n#define INCLUDED_FROM_PCRE2_JIT_COMPILE\n\n#include \"pcre2_jit_match.c\"\n#include \"pcre2_jit_misc.c\"\n\n/* End of pcre2_jit_compile.c */\n", "/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n         New API code Copyright (c) 2016 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <string.h>\n\n#define PCRE2_CODE_UNIT_WIDTH 0\n#include \"pcre2.h\"\n\n/*\n Letter characters:\n   \\xe6\\x92\\xad = 0x64ad = 25773 (kanji)\n Non-letter characters:\n   \\xc2\\xa1 = 0xa1 =  (Inverted Exclamation Mark)\n   \\xf3\\xa9\\xb7\\x80 = 0xe9dc0 = 957888\n   \\xed\\xa0\\x80 = 55296 = 0xd800 (Invalid UTF character)\n   \\xed\\xb0\\x80 = 56320 = 0xdc00 (Invalid UTF character)\n Newlines:\n   \\xc2\\x85 = 0x85 = 133 (NExt Line = NEL)\n   \\xe2\\x80\\xa8 = 0x2028 = 8232 (Line Separator)\n Othercase pairs:\n   \\xc3\\xa9 = 0xe9 = 233 (e')\n      \\xc3\\x89 = 0xc9 = 201 (E')\n   \\xc3\\xa1 = 0xe1 = 225 (a')\n      \\xc3\\x81 = 0xc1 = 193 (A')\n   \\x53 = 0x53 = S\n     \\x73 = 0x73 = s\n     \\xc5\\xbf = 0x17f = 383 (long S)\n   \\xc8\\xba = 0x23a = 570\n      \\xe2\\xb1\\xa5 = 0x2c65 = 11365\n   \\xe1\\xbd\\xb8 = 0x1f78 = 8056\n      \\xe1\\xbf\\xb8 = 0x1ff8 = 8184\n   \\xf0\\x90\\x90\\x80 = 0x10400 = 66560\n      \\xf0\\x90\\x90\\xa8 = 0x10428 = 66600\n   \\xc7\\x84 = 0x1c4 = 452\n     \\xc7\\x85 = 0x1c5 = 453\n     \\xc7\\x86 = 0x1c6 = 454\n Caseless sets:\n   ucp_Armenian - \\x{531}-\\x{556} -> \\x{561}-\\x{586}\n   ucp_Coptic - \\x{2c80}-\\x{2ce3} -> caseless: XOR 0x1\n   ucp_Latin - \\x{ff21}-\\x{ff3a} -> \\x{ff41]-\\x{ff5a}\n\n Mark property:\n   \\xcc\\x8d = 0x30d = 781\n Special:\n   \\xc2\\x80 = 0x80 = 128 (lowest 2 byte character)\n   \\xdf\\xbf = 0x7ff = 2047 (highest 2 byte character)\n   \\xe0\\xa0\\x80 = 0x800 = 2048 (lowest 2 byte character)\n   \\xef\\xbf\\xbf = 0xffff = 65535 (highest 3 byte character)\n   \\xf0\\x90\\x80\\x80 = 0x10000 = 65536 (lowest 4 byte character)\n   \\xf4\\x8f\\xbf\\xbf = 0x10ffff = 1114111 (highest allowed utf character)\n*/\n\nstatic int regression_tests(void);\nstatic int invalid_utf8_regression_tests(void);\nstatic int invalid_utf16_regression_tests(void);\nstatic int invalid_utf32_regression_tests(void);\n\nint main(void)\n{\n\tint jit = 0;\n#if defined SUPPORT_PCRE2_8\n\tpcre2_config_8(PCRE2_CONFIG_JIT, &jit);\n#elif defined SUPPORT_PCRE2_16\n\tpcre2_config_16(PCRE2_CONFIG_JIT, &jit);\n#elif defined SUPPORT_PCRE2_32\n\tpcre2_config_32(PCRE2_CONFIG_JIT, &jit);\n#endif\n\tif (!jit) {\n\t\tprintf(\"JIT must be enabled to run pcre2_jit_test\\n\");\n\t\treturn 1;\n\t}\n\treturn regression_tests()\n\t\t| invalid_utf8_regression_tests()\n\t\t| invalid_utf16_regression_tests()\n\t\t| invalid_utf32_regression_tests();\n}\n\n/* --------------------------------------------------------------------------------------- */\n\n#if !(defined SUPPORT_PCRE2_8) && !(defined SUPPORT_PCRE2_16) && !(defined SUPPORT_PCRE2_32)\n#error SUPPORT_PCRE2_8 or SUPPORT_PCRE2_16 or SUPPORT_PCRE2_32 must be defined\n#endif\n\n#define MU\t(PCRE2_MULTILINE | PCRE2_UTF)\n#define MUP\t(PCRE2_MULTILINE | PCRE2_UTF | PCRE2_UCP)\n#define CMU\t(PCRE2_CASELESS | PCRE2_MULTILINE | PCRE2_UTF)\n#define CMUP\t(PCRE2_CASELESS | PCRE2_MULTILINE | PCRE2_UTF | PCRE2_UCP)\n#define M\t(PCRE2_MULTILINE)\n#define MP\t(PCRE2_MULTILINE | PCRE2_UCP)\n#define U\t(PCRE2_UTF)\n#define CM\t(PCRE2_CASELESS | PCRE2_MULTILINE)\n\n#define BSR(x)\t((x) << 16)\n#define A\tPCRE2_NEWLINE_ANYCRLF\n\n#define GET_NEWLINE(x)\t((x) & 0xffff)\n#define GET_BSR(x)\t((x) >> 16)\n\n#define OFFSET_MASK\t0x00ffff\n#define F_NO8\t\t0x010000\n#define F_NO16\t\t0x020000\n#define F_NO32\t\t0x020000\n#define F_NOMATCH\t0x040000\n#define F_DIFF\t\t0x080000\n#define F_FORCECONV\t0x100000\n#define F_PROPERTY\t0x200000\n\nstruct regression_test_case {\n\tint compile_options;\n\tint newline;\n\tint match_options;\n\tint start_offset;\n\tconst char *pattern;\n\tconst char *input;\n};\n\nstatic struct regression_test_case regression_test_cases[] = {\n\t/* Constant strings. */\n\t{ MU, A, 0, 0, \"AbC\", \"AbAbC\" },\n\t{ MU, A, 0, 0, \"ACCEPT\", \"AACACCACCEACCEPACCEPTACCEPTT\" },\n\t{ CMU, A, 0, 0, \"aA#\\xc3\\xa9\\xc3\\x81\", \"aA#Aa#\\xc3\\x89\\xc3\\xa1\" },\n\t{ M, A, 0, 0, \"[^a]\", \"aAbB\" },\n\t{ CM, A, 0, 0, \"[^m]\", \"mMnN\" },\n\t{ M, A, 0, 0, \"a[^b][^#]\", \"abacd\" },\n\t{ CM, A, 0, 0, \"A[^B][^E]\", \"abacd\" },\n\t{ CMU, A, 0, 0, \"[^x][^#]\", \"XxBll\" },\n\t{ MU, A, 0, 0, \"[^a]\", \"aaa\\xc3\\xa1#Ab\" },\n\t{ CMU, A, 0, 0, \"[^A]\", \"aA\\xe6\\x92\\xad\" },\n\t{ MU, A, 0, 0, \"\\\\W(\\\\W)?\\\\w\", \"\\r\\n+bc\" },\n\t{ MU, A, 0, 0, \"\\\\W(\\\\W)?\\\\w\", \"\\n\\r+bc\" },\n\t{ MU, A, 0, 0, \"\\\\W(\\\\W)?\\\\w\", \"\\r\\r+bc\" },\n\t{ MU, A, 0, 0, \"\\\\W(\\\\W)?\\\\w\", \"\\n\\n+bc\" },\n\t{ MU, A, 0, 0, \"[axd]\", \"sAXd\" },\n\t{ CMU, A, 0, 0, \"[axd]\", \"sAXd\" },\n\t{ CMU, A, 0, 0 | F_NOMATCH, \"[^axd]\", \"DxA\" },\n\t{ MU, A, 0, 0, \"[a-dA-C]\", \"\\xe6\\x92\\xad\\xc3\\xa9.B\" },\n\t{ MU, A, 0, 0, \"[^a-dA-C]\", \"\\xe6\\x92\\xad\\xc3\\xa9\" },\n\t{ CMU, A, 0, 0, \"[^\\xc3\\xa9]\", \"\\xc3\\xa9\\xc3\\x89.\" },\n\t{ MU, A, 0, 0, \"[^\\xc3\\xa9]\", \"\\xc3\\xa9\\xc3\\x89.\" },\n\t{ MU, A, 0, 0, \"[^a]\", \"\\xc2\\x80[]\" },\n\t{ CMU, A, 0, 0, \"\\xf0\\x90\\x90\\xa7\", \"\\xf0\\x90\\x91\\x8f\" },\n\t{ CM, A, 0, 0, \"1a2b3c4\", \"1a2B3c51A2B3C4\" },\n\t{ PCRE2_CASELESS, 0, 0, 0, \"\\xff#a\", \"\\xff#\\xff\\xfe##\\xff#A\" },\n\t{ PCRE2_CASELESS, 0, 0, 0, \"\\xfe\", \"\\xff\\xfc#\\xfe\\xfe\" },\n\t{ PCRE2_CASELESS, 0, 0, 0, \"a1\", \"Aa1\" },\n#ifndef NEVER_BACKSLASH_C\n\t{ M, A, 0, 0, \"\\\\Ca\", \"cda\" },\n\t{ CM, A, 0, 0, \"\\\\Ca\", \"CDA\" },\n\t{ M, A, 0, 0 | F_NOMATCH, \"\\\\Cx\", \"cda\" },\n\t{ CM, A, 0, 0 | F_NOMATCH, \"\\\\Cx\", \"CDA\" },\n#endif /* !NEVER_BACKSLASH_C */\n\t{ CMUP, A, 0, 0, \"\\xf0\\x90\\x90\\x80\\xf0\\x90\\x90\\xa8\", \"\\xf0\\x90\\x90\\xa8\\xf0\\x90\\x90\\x80\" },\n\t{ CMUP, A, 0, 0, \"\\xf0\\x90\\x90\\x80{2}\", \"\\xf0\\x90\\x90\\x80#\\xf0\\x90\\x90\\xa8\\xf0\\x90\\x90\\x80\" },\n\t{ CMUP, A, 0, 0, \"\\xf0\\x90\\x90\\xa8{2}\", \"\\xf0\\x90\\x90\\x80#\\xf0\\x90\\x90\\xa8\\xf0\\x90\\x90\\x80\" },\n\t{ CMUP, A, 0, 0, \"\\xe1\\xbd\\xb8\\xe1\\xbf\\xb8\", \"\\xe1\\xbf\\xb8\\xe1\\xbd\\xb8\" },\n\t{ M, A, 0, 0, \"[3-57-9]\", \"5\" },\n\t{ PCRE2_AUTO_CALLOUT, A, 0, 0, \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\",\n\t\t\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\" },\n\n\t/* Assertions. */\n\t{ MU, A, 0, 0, \"\\\\b[^A]\", \"A_B#\" },\n\t{ M, A, 0, 0 | F_NOMATCH, \"\\\\b\\\\W\", \"\\n*\" },\n\t{ MU, A, 0, 0, \"\\\\B[^,]\\\\b[^s]\\\\b\", \"#X\" },\n\t{ MP, A, 0, 0, \"\\\\B\", \"_\\xa1\" },\n\t{ MP, A, 0, 0 | F_PROPERTY, \"\\\\b_\\\\b[,A]\\\\B\", \"_,\" },\n\t{ MUP, A, 0, 0, \"\\\\b\", \"\\xe6\\x92\\xad!\" },\n\t{ MUP, A, 0, 0, \"\\\\B\", \"_\\xc2\\xa1\\xc3\\xa1\\xc2\\x85\" },\n\t{ MUP, A, 0, 0, \"\\\\b[^A]\\\\B[^c]\\\\b[^_]\\\\B\", \"_\\xc3\\xa1\\xe2\\x80\\xa8\" },\n\t{ MUP, A, 0, 0, \"\\\\b\\\\w+\\\\B\", \"\\xc3\\x89\\xc2\\xa1\\xe6\\x92\\xad\\xc3\\x81\\xc3\\xa1\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"\\\\b.\", \"\\xcd\\xbe\" },\n\t{ CMUP, A, 0, 0, \"\\\\By\", \"\\xf0\\x90\\x90\\xa8y\" },\n\t{ M, A, 0, 0 | F_NOMATCH, \"\\\\R^\", \"\\n\" },\n\t{ M, A, 0, 1 | F_NOMATCH, \"^\", \"\\n\" },\n\t{ 0, 0, 0, 0, \"^ab\", \"ab\" },\n\t{ 0, 0, 0, 0 | F_NOMATCH, \"^ab\", \"aab\" },\n\t{ M, PCRE2_NEWLINE_CRLF, 0, 0, \"^a\", \"\\r\\raa\\n\\naa\\r\\naa\" },\n\t{ MU, A, 0, 0, \"^-\", \"\\xe2\\x80\\xa8--\\xc2\\x85-\\r\\n-\" },\n\t{ M, PCRE2_NEWLINE_ANY, 0, 0, \"^-\", \"a--b--\\x85--\" },\n\t{ MU, PCRE2_NEWLINE_ANY, 0, 0, \"^-\", \"a--\\xe2\\x80\\xa8--\" },\n\t{ MU, PCRE2_NEWLINE_ANY, 0, 0, \"^-\", \"a--\\xc2\\x85--\" },\n\t{ 0, 0, 0, 0, \"ab$\", \"ab\" },\n\t{ 0, 0, 0, 0 | F_NOMATCH, \"ab$\", \"abab\\n\\n\" },\n\t{ PCRE2_DOLLAR_ENDONLY, 0, 0, 0 | F_NOMATCH, \"ab$\", \"abab\\r\\n\" },\n\t{ M, PCRE2_NEWLINE_CRLF, 0, 0, \"a$\", \"\\r\\raa\\n\\naa\\r\\naa\" },\n\t{ M, PCRE2_NEWLINE_ANY, 0, 0, \"a$\", \"aaa\" },\n\t{ MU, PCRE2_NEWLINE_ANYCRLF, 0, 0, \"#$\", \"#\\xc2\\x85###\\r#\" },\n\t{ MU, PCRE2_NEWLINE_ANY, 0, 0, \"#$\", \"#\\xe2\\x80\\xa9\" },\n\t{ 0, PCRE2_NEWLINE_ANY, PCRE2_NOTBOL, 0 | F_NOMATCH, \"^a\", \"aa\\naa\" },\n\t{ M, PCRE2_NEWLINE_ANY, PCRE2_NOTBOL, 0, \"^a\", \"aa\\naa\" },\n\t{ 0, PCRE2_NEWLINE_ANY, PCRE2_NOTEOL, 0 | F_NOMATCH, \"a$\", \"aa\\naa\" },\n\t{ 0, PCRE2_NEWLINE_ANY, PCRE2_NOTEOL, 0 | F_NOMATCH, \"a$\", \"aa\\r\\n\" },\n\t{ U | PCRE2_DOLLAR_ENDONLY, PCRE2_NEWLINE_ANY, 0, 0 | F_PROPERTY, \"\\\\p{Any}{2,}$\", \"aa\\r\\n\" },\n\t{ M, PCRE2_NEWLINE_ANY, PCRE2_NOTEOL, 0, \"a$\", \"aa\\naa\" },\n\t{ 0, PCRE2_NEWLINE_CR, 0, 0, \".\\\\Z\", \"aaa\" },\n\t{ U, PCRE2_NEWLINE_CR, 0, 0, \"a\\\\Z\", \"aaa\\r\" },\n\t{ 0, PCRE2_NEWLINE_CR, 0, 0, \".\\\\Z\", \"aaa\\n\" },\n\t{ 0, PCRE2_NEWLINE_CRLF, 0, 0, \".\\\\Z\", \"aaa\\r\" },\n\t{ U, PCRE2_NEWLINE_CRLF, 0, 0, \".\\\\Z\", \"aaa\\n\" },\n\t{ 0, PCRE2_NEWLINE_CRLF, 0, 0, \".\\\\Z\", \"aaa\\r\\n\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".\\\\Z\", \"aaa\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".\\\\Z\", \"aaa\\r\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".\\\\Z\", \"aaa\\n\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".\\\\Z\", \"aaa\\r\\n\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".\\\\Z\", \"aaa\\xe2\\x80\\xa8\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".\\\\Z\", \"aaa\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".\\\\Z\", \"aaa\\r\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".\\\\Z\", \"aaa\\n\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".\\\\Z\", \"aaa\\r\\n\" },\n\t{ U, PCRE2_NEWLINE_ANY, 0, 0, \".\\\\Z\", \"aaa\\xc2\\x85\" },\n\t{ U, PCRE2_NEWLINE_ANY, 0, 0, \".\\\\Z\", \"aaa\\xe2\\x80\\xa8\" },\n\t{ M, A, 0, 0, \"\\\\Aa\", \"aaa\" },\n\t{ M, A, 0, 1 | F_NOMATCH, \"\\\\Aa\", \"aaa\" },\n\t{ M, A, 0, 1, \"\\\\Ga\", \"aaa\" },\n\t{ M, A, 0, 1 | F_NOMATCH, \"\\\\Ga\", \"aba\" },\n\t{ M, A, 0, 0, \"a\\\\z\", \"aaa\" },\n\t{ M, A, 0, 0 | F_NOMATCH, \"a\\\\z\", \"aab\" },\n\n\t/* Brackets and alternatives. */\n\t{ MU, A, 0, 0, \"(ab|bb|cd)\", \"bacde\" },\n\t{ MU, A, 0, 0, \"(?:ab|a)(bc|c)\", \"ababc\" },\n\t{ MU, A, 0, 0, \"((ab|(cc))|(bb)|(?:cd|efg))\", \"abac\" },\n\t{ CMU, A, 0, 0, \"((aB|(Cc))|(bB)|(?:cd|EFg))\", \"AcCe\" },\n\t{ MU, A, 0, 0, \"((ab|(cc))|(bb)|(?:cd|ebg))\", \"acebebg\" },\n\t{ MU, A, 0, 0, \"(?:(a)|(?:b))(cc|(?:d|e))(a|b)k\", \"accabdbbccbk\" },\n\t{ MU, A, 0, 0, \"\\xc7\\x82|\\xc6\\x82\", \"\\xf1\\x83\\x82\\x82\\xc7\\x82\\xc7\\x83\" },\n\t{ MU, A, 0, 0, \"=\\xc7\\x82|#\\xc6\\x82\", \"\\xf1\\x83\\x82\\x82=\\xc7\\x82\\xc7\\x83\" },\n\t{ MU, A, 0, 0, \"\\xc7\\x82\\xc7\\x83|\\xc6\\x82\\xc6\\x82\", \"\\xf1\\x83\\x82\\x82\\xc7\\x82\\xc7\\x83\" },\n\t{ MU, A, 0, 0, \"\\xc6\\x82\\xc6\\x82|\\xc7\\x83\\xc7\\x83|\\xc8\\x84\\xc8\\x84\", \"\\xf1\\x83\\x82\\x82\\xc8\\x84\\xc8\\x84\" },\n\t{ U, A, 0, 0, \"\\xe1\\x81\\x80|\\xe2\\x82\\x80|\\xe4\\x84\\x80\", \"\\xdf\\xbf\\xc2\\x80\\xe4\\x84\\x80\" },\n\t{ U, A, 0, 0, \"(?:\\xe1\\x81\\x80|\\xe2\\x82\\x80|\\xe4\\x84\\x80)#\", \"\\xdf\\xbf\\xc2\\x80#\\xe4\\x84\\x80#\" },\n\t{ CM, A, 0, 0, \"ab|cd\", \"CD\" },\n\t{ CM, A, 0, 0, \"a1277|a1377|bX487\", \"bx487\" },\n\t{ CM, A, 0, 0, \"a1277|a1377|bx487\", \"bX487\" },\n\n\t/* Greedy and non-greedy ? operators. */\n\t{ MU, A, 0, 0, \"(?:a)?a\", \"laab\" },\n\t{ CMU, A, 0, 0, \"(A)?A\", \"llaab\" },\n\t{ MU, A, 0, 0, \"(a)?\\?a\", \"aab\" }, /* ?? is the prefix of trygraphs in GCC. */\n\t{ MU, A, 0, 0, \"(a)?a\", \"manm\" },\n\t{ CMU, A, 0, 0, \"(a|b)?\\?d((?:e)?)\", \"ABABdx\" },\n\t{ MU, A, 0, 0, \"(a|b)?\\?d((?:e)?)\", \"abcde\" },\n\t{ MU, A, 0, 0, \"((?:ab)?\\?g|b(?:g(nn|d)?\\?)?)?\\?(?:n)?m\", \"abgnbgnnbgdnmm\" },\n\n\t/* Greedy and non-greedy + operators */\n\t{ MU, A, 0, 0, \"(aa)+aa\", \"aaaaaaa\" },\n\t{ MU, A, 0, 0, \"(aa)+?aa\", \"aaaaaaa\" },\n\t{ MU, A, 0, 0, \"(?:aba|ab|a)+l\", \"ababamababal\" },\n\t{ MU, A, 0, 0, \"(?:aba|ab|a)+?l\", \"ababamababal\" },\n\t{ MU, A, 0, 0, \"(a(?:bc|cb|b|c)+?|ss)+e\", \"accssabccbcacbccbbXaccssabccbcacbccbbe\" },\n\t{ MU, A, 0, 0, \"(a(?:bc|cb|b|c)+|ss)+?e\", \"accssabccbcacbccbbXaccssabccbcacbccbbe\" },\n\t{ MU, A, 0, 0, \"(?:(b(c)+?)+)?\\?(?:(bc)+|(cb)+)+(?:m)+\", \"bccbcccbcbccbcbPbccbcccbcbccbcbmmn\" },\n\t{ MU, A, 0, 0, \"(aa|bb){8,1000}\", \"abaabbaabbaabbaab_aabbaabbaabbaabbaabbaabb_\" },\n\n\t/* Greedy and non-greedy * operators */\n\t{ CMU, A, 0, 0, \"(?:AA)*AB\", \"aaaaaaamaaaaaaab\" },\n\t{ MU, A, 0, 0, \"(?:aa)*?ab\", \"aaaaaaamaaaaaaab\" },\n\t{ MU, A, 0, 0, \"(aa|ab)*ab\", \"aaabaaab\" },\n\t{ CMU, A, 0, 0, \"(aa|Ab)*?aB\", \"aaabaaab\" },\n\t{ MU, A, 0, 0, \"(a|b)*(?:a)*(?:b)*m\", \"abbbaaababanabbbaaababamm\" },\n\t{ MU, A, 0, 0, \"(a|b)*?(?:a)*?(?:b)*?m\", \"abbbaaababanabbbaaababamm\" },\n\t{ M, A, 0, 0, \"a(a(\\\\1*)a|(b)b+){0}a\", \"aa\" },\n\t{ M, A, 0, 0, \"((?:a|)*){0}a\", \"a\" },\n\n\t/* Combining ? + * operators */\n\t{ MU, A, 0, 0, \"((bm)+)?\\?(?:a)*(bm)+n|((am)+?)?(?:a)+(am)*n\", \"bmbmabmamaaamambmaman\" },\n\t{ MU, A, 0, 0, \"(((ab)?cd)*ef)+g\", \"abcdcdefcdefefmabcdcdefcdefefgg\" },\n\t{ MU, A, 0, 0, \"(((ab)?\\?cd)*?ef)+?g\", \"abcdcdefcdefefmabcdcdefcdefefgg\" },\n\t{ MU, A, 0, 0, \"(?:(ab)?c|(?:ab)+?d)*g\", \"ababcdccababddg\" },\n\t{ MU, A, 0, 0, \"(?:(?:ab)?\\?c|(ab)+d)*?g\", \"ababcdccababddg\" },\n\n\t/* Single character iterators. */\n\t{ MU, A, 0, 0, \"(a+aab)+aaaab\", \"aaaabcaaaabaabcaabcaaabaaaab\" },\n\t{ MU, A, 0, 0, \"(a*a*aab)+x\", \"aaaaabaabaaabmaabx\" },\n\t{ MU, A, 0, 0, \"(a*?(b|ab)a*?)+x\", \"aaaabcxbbaabaacbaaabaabax\" },\n\t{ MU, A, 0, 0, \"(a+(ab|ad)a+)+x\", \"aaabaaaadaabaaabaaaadaaax\" },\n\t{ MU, A, 0, 0, \"(a?(a)a?)+(aaa)\", \"abaaabaaaaaaaa\" },\n\t{ MU, A, 0, 0, \"(a?\\?(a)a?\\?)+(b)\", \"aaaacaaacaacacbaaab\" },\n\t{ MU, A, 0, 0, \"(a{0,4}(b))+d\", \"aaaaaabaabcaaaaabaaaaabd\" },\n\t{ MU, A, 0, 0, \"(a{0,4}?[^b])+d+(a{0,4}[^b])d+\", \"aaaaadaaaacaadddaaddd\" },\n\t{ MU, A, 0, 0, \"(ba{2})+c\", \"baabaaabacbaabaac\" },\n\t{ MU, A, 0, 0, \"(a*+bc++)+\", \"aaabbcaaabcccab\" },\n\t{ MU, A, 0, 0, \"(a?+[^b])+\", \"babaacacb\" },\n\t{ MU, A, 0, 0, \"(a{0,3}+b)(a{0,3}+b)(a{0,3}+)[^c]\", \"abaabaaacbaabaaaac\" },\n\t{ CMU, A, 0, 0, \"([a-c]+[d-f]+?)+?g\", \"aBdacdehAbDaFgA\" },\n\t{ CMU, A, 0, 0, \"[c-f]+k\", \"DemmFke\" },\n\t{ MU, A, 0, 0, \"([DGH]{0,4}M)+\", \"GGDGHDGMMHMDHHGHM\" },\n\t{ MU, A, 0, 0, \"([a-c]{4,}s)+\", \"abasabbasbbaabsbba\" },\n\t{ CMU, A, 0, 0, \"[ace]{3,7}\", \"AcbDAcEEcEd\" },\n\t{ CMU, A, 0, 0, \"[ace]{3,7}?\", \"AcbDAcEEcEd\" },\n\t{ CMU, A, 0, 0, \"[ace]{3,}\", \"AcbDAcEEcEd\" },\n\t{ CMU, A, 0, 0, \"[ace]{3,}?\", \"AcbDAcEEcEd\" },\n\t{ MU, A, 0, 0, \"[ckl]{2,}?g\", \"cdkkmlglglkcg\" },\n\t{ CMU, A, 0, 0, \"[ace]{5}?\", \"AcCebDAcEEcEd\" },\n\t{ MU, A, 0, 0, \"([AbC]{3,5}?d)+\", \"BACaAbbAEAACCbdCCbdCCAAbb\" },\n\t{ MU, A, 0, 0, \"([^ab]{0,}s){2}\", \"abaabcdsABamsDDs\" },\n\t{ MU, A, 0, 0, \"\\\\b\\\\w+\\\\B\", \"x,a_cd\" },\n\t{ MUP, A, 0, 0, \"\\\\b[^\\xc2\\xa1]+\\\\B\", \"\\xc3\\x89\\xc2\\xa1\\xe6\\x92\\xad\\xc3\\x81\\xc3\\xa1\" },\n\t{ CMU, A, 0, 0, \"[^b]+(a*)([^c]?d{3})\", \"aaaaddd\" },\n\t{ CMUP, A, 0, 0, \"\\xe1\\xbd\\xb8{2}\", \"\\xe1\\xbf\\xb8#\\xe1\\xbf\\xb8\\xe1\\xbd\\xb8\" },\n\t{ CMU, A, 0, 0, \"[^\\xf0\\x90\\x90\\x80]{2,4}@\", \"\\xf0\\x90\\x90\\xa8\\xf0\\x90\\x90\\x80###\\xf0\\x90\\x90\\x80@@@\" },\n\t{ CMU, A, 0, 0, \"[^\\xe1\\xbd\\xb8][^\\xc3\\xa9]\", \"\\xe1\\xbd\\xb8\\xe1\\xbf\\xb8\\xc3\\xa9\\xc3\\x89#\" },\n\t{ MU, A, 0, 0, \"[^\\xe1\\xbd\\xb8][^\\xc3\\xa9]\", \"\\xe1\\xbd\\xb8\\xe1\\xbf\\xb8\\xc3\\xa9\\xc3\\x89#\" },\n\t{ MU, A, 0, 0, \"[^\\xe1\\xbd\\xb8]{3,}?\", \"##\\xe1\\xbd\\xb8#\\xe1\\xbd\\xb8#\\xc3\\x89#\\xe1\\xbd\\xb8\" },\n\t{ MU, A, 0, 0, \"\\\\d+123\", \"987654321,01234\" },\n\t{ MU, A, 0, 0, \"abcd*|\\\\w+xy\", \"aaaaa,abxyz\" },\n\t{ MU, A, 0, 0, \"(?:abc|((?:amc|\\\\b\\\\w*xy)))\", \"aaaaa,abxyz\" },\n\t{ MU, A, 0, 0, \"a(?R)|([a-z]++)#\", \".abcd.abcd#.\"},\n\t{ MU, A, 0, 0, \"a(?R)|([a-z]++)#\", \".abcd.mbcd#.\"},\n\t{ MU, A, 0, 0, \".[ab]*.\", \"xx\" },\n\t{ MU, A, 0, 0, \".[ab]*a\", \"xxa\" },\n\t{ MU, A, 0, 0, \".[ab]?.\", \"xx\" },\n\t{ MU, A, 0, 0, \"_[ab]+_*a\", \"_aa\" },\n\t{ MU, A, 0, 0, \"#(A+)#\\\\d+\", \"#A#A#0\" },\n\t{ MU, A, 0, 0, \"(?P<size>\\\\d+)m|M\", \"4M\" },\n\n\t/* Bracket repeats with limit. */\n\t{ MU, A, 0, 0, \"(?:(ab){2}){5}M\", \"abababababababababababM\" },\n\t{ MU, A, 0, 0, \"(?:ab|abab){1,5}M\", \"abababababababababababM\" },\n\t{ MU, A, 0, 0, \"(?>ab|abab){1,5}M\", \"abababababababababababM\" },\n\t{ MU, A, 0, 0, \"(?:ab|abab){1,5}?M\", \"abababababababababababM\" },\n\t{ MU, A, 0, 0, \"(?>ab|abab){1,5}?M\", \"abababababababababababM\" },\n\t{ MU, A, 0, 0, \"(?:(ab){1,4}?){1,3}?M\", \"abababababababababababababM\" },\n\t{ MU, A, 0, 0, \"(?:(ab){1,4}){1,3}abababababababababababM\", \"ababababababababababababM\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?:(ab){1,4}){1,3}abababababababababababM\", \"abababababababababababM\" },\n\t{ MU, A, 0, 0, \"(ab){4,6}?M\", \"abababababababM\" },\n\n\t/* Basic character sets. */\n\t{ MU, A, 0, 0, \"(?:\\\\s)+(?:\\\\S)+\", \"ab \\t\\xc3\\xa9\\xe6\\x92\\xad \" },\n\t{ MU, A, 0, 0, \"(\\\\w)*(k)(\\\\W)?\\?\", \"abcdef abck11\" },\n\t{ MU, A, 0, 0, \"\\\\((\\\\d)+\\\\)\\\\D\", \"a() (83 (8)2 (9)ab\" },\n\t{ MU, A, 0, 0, \"\\\\w(\\\\s|(?:\\\\d)*,)+\\\\w\\\\wb\", \"a 5, 4,, bb 5, 4,, aab\" },\n\t{ MU, A, 0, 0, \"(\\\\v+)(\\\\V+)\", \"\\x0e\\xc2\\x85\\xe2\\x80\\xa8\\x0b\\x09\\xe2\\x80\\xa9\" },\n\t{ MU, A, 0, 0, \"(\\\\h+)(\\\\H+)\", \"\\xe2\\x80\\xa8\\xe2\\x80\\x80\\x20\\xe2\\x80\\x8a\\xe2\\x81\\x9f\\xe3\\x80\\x80\\x09\\x20\\xc2\\xa0\\x0a\" },\n\t{ MU, A, 0, 0, \"x[bcef]+\", \"xaxdxecbfg\" },\n\t{ MU, A, 0, 0, \"x[bcdghij]+\", \"xaxexfxdgbjk\" },\n\t{ MU, A, 0, 0, \"x[^befg]+\", \"xbxexacdhg\" },\n\t{ MU, A, 0, 0, \"x[^bcdl]+\", \"xlxbxaekmd\" },\n\t{ MU, A, 0, 0, \"x[^bcdghi]+\", \"xbxdxgxaefji\" },\n\t{ MU, A, 0, 0, \"x[B-Fb-f]+\", \"xaxAxgxbfBFG\" },\n\t{ CMU, A, 0, 0, \"\\\\x{e9}+\", \"#\\xf0\\x90\\x90\\xa8\\xc3\\xa8\\xc3\\xa9\\xc3\\x89\\xc3\\x88\" },\n\t{ CMU, A, 0, 0, \"[^\\\\x{e9}]+\", \"\\xc3\\xa9#\\xf0\\x90\\x90\\xa8\\xc3\\xa8\\xc3\\x88\\xc3\\x89\" },\n\t{ MU, A, 0, 0, \"[\\\\x02\\\\x7e]+\", \"\\xc3\\x81\\xe1\\xbf\\xb8\\xf0\\x90\\x90\\xa8\\x01\\x02\\x7e\\x7f\" },\n\t{ MU, A, 0, 0, \"[^\\\\x02\\\\x7e]+\", \"\\x02\\xc3\\x81\\xe1\\xbf\\xb8\\xf0\\x90\\x90\\xa8\\x01\\x7f\\x7e\" },\n\t{ MU, A, 0, 0, \"[\\\\x{81}-\\\\x{7fe}]+\", \"#\\xe1\\xbf\\xb8\\xf0\\x90\\x90\\xa8\\xc2\\x80\\xc2\\x81\\xdf\\xbe\\xdf\\xbf\" },\n\t{ MU, A, 0, 0, \"[^\\\\x{81}-\\\\x{7fe}]+\", \"\\xc2\\x81#\\xe1\\xbf\\xb8\\xf0\\x90\\x90\\xa8\\xc2\\x80\\xdf\\xbf\\xdf\\xbe\" },\n\t{ MU, A, 0, 0, \"[\\\\x{801}-\\\\x{fffe}]+\", \"#\\xc3\\xa9\\xf0\\x90\\x90\\x80\\xe0\\xa0\\x80\\xe0\\xa0\\x81\\xef\\xbf\\xbe\\xef\\xbf\\xbf\" },\n\t{ MU, A, 0, 0, \"[^\\\\x{801}-\\\\x{fffe}]+\", \"\\xe0\\xa0\\x81#\\xc3\\xa9\\xf0\\x90\\x90\\x80\\xe0\\xa0\\x80\\xef\\xbf\\xbf\\xef\\xbf\\xbe\" },\n\t{ MU, A, 0, 0, \"[\\\\x{10001}-\\\\x{10fffe}]+\", \"#\\xc3\\xa9\\xe2\\xb1\\xa5\\xf0\\x90\\x80\\x80\\xf0\\x90\\x80\\x81\\xf4\\x8f\\xbf\\xbe\\xf4\\x8f\\xbf\\xbf\" },\n\t{ MU, A, 0, 0, \"[^\\\\x{10001}-\\\\x{10fffe}]+\", \"\\xf0\\x90\\x80\\x81#\\xc3\\xa9\\xe2\\xb1\\xa5\\xf0\\x90\\x80\\x80\\xf4\\x8f\\xbf\\xbf\\xf4\\x8f\\xbf\\xbe\" },\n\t{ CMU, A, 0, 0 | F_NOMATCH, \"^[\\\\x{0100}-\\\\x{017f}]\", \" \" },\n\n\t/* Unicode properties. */\n\t{ MUP, A, 0, 0, \"[1-5\\xc3\\xa9\\\\w]\", \"\\xc3\\xa1_\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"[\\xc3\\x81\\\\p{Ll}]\", \"A_\\xc3\\x89\\xc3\\xa1\" },\n\t{ MUP, A, 0, 0, \"[\\\\Wd-h_x-z]+\", \"a\\xc2\\xa1#_yhzdxi\" },\n\t{ MUP, A, 0, 0 | F_NOMATCH | F_PROPERTY, \"[\\\\P{Any}]\", \"abc\" },\n\t{ MUP, A, 0, 0 | F_NOMATCH | F_PROPERTY, \"[^\\\\p{Any}]\", \"abc\" },\n\t{ MUP, A, 0, 0 | F_NOMATCH | F_PROPERTY, \"[\\\\P{Any}\\xc3\\xa1-\\xc3\\xa8]\", \"abc\" },\n\t{ MUP, A, 0, 0 | F_NOMATCH | F_PROPERTY, \"[^\\\\p{Any}\\xc3\\xa1-\\xc3\\xa8]\", \"abc\" },\n\t{ MUP, A, 0, 0 | F_NOMATCH | F_PROPERTY, \"[\\xc3\\xa1-\\xc3\\xa8\\\\P{Any}]\", \"abc\" },\n\t{ MUP, A, 0, 0 | F_NOMATCH | F_PROPERTY, \"[^\\xc3\\xa1-\\xc3\\xa8\\\\p{Any}]\", \"abc\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"[\\xc3\\xa1-\\xc3\\xa8\\\\p{Any}]\", \"abc\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"[^\\xc3\\xa1-\\xc3\\xa8\\\\P{Any}]\", \"abc\" },\n\t{ MUP, A, 0, 0, \"[b-\\xc3\\xa9\\\\s]\", \"a\\xc\\xe6\\x92\\xad\" },\n\t{ CMUP, A, 0, 0, \"[\\xc2\\x85-\\xc2\\x89\\xc3\\x89]\", \"\\xc2\\x84\\xc3\\xa9\" },\n\t{ MUP, A, 0, 0, \"[^b-d^&\\\\s]{3,}\", \"db^ !a\\xe2\\x80\\xa8_ae\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"[^\\\\S\\\\P{Any}][\\\\sN]{1,3}[\\\\P{N}]{4}\", \"\\xe2\\x80\\xaa\\xa N\\x9\\xc3\\xa9_0\" },\n\t{ MU, A, 0, 0 | F_PROPERTY, \"[^\\\\P{L}\\x9!D-F\\xa]{2,3}\", \"\\x9,.DF\\xa.CG\\xc3\\x81\" },\n\t{ CMUP, A, 0, 0, \"[\\xc3\\xa1-\\xc3\\xa9_\\xe2\\x80\\xa0-\\xe2\\x80\\xaf]{1,5}[^\\xe2\\x80\\xa0-\\xe2\\x80\\xaf]\", \"\\xc2\\xa1\\xc3\\x89\\xc3\\x89\\xe2\\x80\\xaf_\\xe2\\x80\\xa0\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"[\\xc3\\xa2-\\xc3\\xa6\\xc3\\x81-\\xc3\\x84\\xe2\\x80\\xa8-\\xe2\\x80\\xa9\\xe6\\x92\\xad\\\\p{Zs}]{2,}\", \"\\xe2\\x80\\xa7\\xe2\\x80\\xa9\\xe6\\x92\\xad \\xe6\\x92\\xae\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"[\\\\P{L&}]{2}[^\\xc2\\x85-\\xc2\\x89\\\\p{Ll}\\\\p{Lu}]{2}\", \"\\xc3\\xa9\\xe6\\x92\\xad.a\\xe6\\x92\\xad|\\xc2\\x8a#\" },\n\t{ PCRE2_UCP, 0, 0, 0 | F_PROPERTY, \"[a-b\\\\s]{2,5}[^a]\", \"AB  baaa\" },\n\t{ MUP, 0, 0, 0 | F_NOMATCH, \"[^\\\\p{Hangul}\\\\p{Z}]\", \" \" },\n\t{ MUP, 0, 0, 0, \"[\\\\p{Lu}\\\\P{Latin}]+\", \"c\\xEA\\xA4\\xAE,A,b\" },\n\t{ MUP, 0, 0, 0, \"[\\\\x{a92e}\\\\p{Lu}\\\\P{Latin}]+\", \"c\\xEA\\xA4\\xAE,A,b\" },\n\t{ CMUP, 0, 0, 0, \"[^S]\\\\B\", \"\\xe2\\x80\\x8a\" },\n\n\t/* Possible empty brackets. */\n\t{ MU, A, 0, 0, \"(?:|ab||bc|a)+d\", \"abcxabcabd\" },\n\t{ MU, A, 0, 0, \"(|ab||bc|a)+d\", \"abcxabcabd\" },\n\t{ MU, A, 0, 0, \"(?:|ab||bc|a)*d\", \"abcxabcabd\" },\n\t{ MU, A, 0, 0, \"(|ab||bc|a)*d\", \"abcxabcabd\" },\n\t{ MU, A, 0, 0, \"(?:|ab||bc|a)+?d\", \"abcxabcabd\" },\n\t{ MU, A, 0, 0, \"(|ab||bc|a)+?d\", \"abcxabcabd\" },\n\t{ MU, A, 0, 0, \"(?:|ab||bc|a)*?d\", \"abcxabcabd\" },\n\t{ MU, A, 0, 0, \"(|ab||bc|a)*?d\", \"abcxabcabd\" },\n\t{ MU, A, 0, 0, \"(((a)*?|(?:ba)+)+?|(?:|c|ca)*)*m\", \"abaacaccabacabalabaacaccabacabamm\" },\n\t{ MU, A, 0, 0, \"(?:((?:a)*|(ba)+?)+|(|c|ca)*?)*?m\", \"abaacaccabacabalabaacaccabacabamm\" },\n\n\t/* Start offset. */\n\t{ MU, A, 0, 3, \"(\\\\d|(?:\\\\w)*\\\\w)+\", \"0ac01Hb\" },\n\t{ MU, A, 0, 4 | F_NOMATCH, \"(\\\\w\\\\W\\\\w)+\", \"ab#d\" },\n\t{ MU, A, 0, 2 | F_NOMATCH, \"(\\\\w\\\\W\\\\w)+\", \"ab#d\" },\n\t{ MU, A, 0, 1, \"(\\\\w\\\\W\\\\w)+\", \"ab#d\" },\n\n\t/* Newline. */\n\t{ M, PCRE2_NEWLINE_CRLF, 0, 0, \"\\\\W{0,2}[^#]{3}\", \"\\r\\n#.....\" },\n\t{ M, PCRE2_NEWLINE_CR, 0, 0, \"\\\\W{0,2}[^#]{3}\", \"\\r\\n#.....\" },\n\t{ M, PCRE2_NEWLINE_CRLF, 0, 0, \"\\\\W{1,3}[^#]\", \"\\r\\n##....\" },\n\t{ MU, A, PCRE2_NO_UTF_CHECK, 1, \"^.a\", \"\\n\\x80\\nxa\" },\n\t{ MU, A, 0, 1, \"^\", \"\\r\\n\" },\n\t{ M, PCRE2_NEWLINE_CRLF, 0, 1 | F_NOMATCH, \"^\", \"\\r\\n\" },\n\t{ M, PCRE2_NEWLINE_CRLF, 0, 1, \"^\", \"\\r\\na\" },\n\n\t/* Any character except newline or any newline. */\n\t{ 0, PCRE2_NEWLINE_CRLF, 0, 0, \".\", \"\\r\" },\n\t{ U, PCRE2_NEWLINE_CRLF, 0, 0, \".(.).\", \"a\\xc3\\xa1\\r\\n\\n\\r\\r\" },\n\t{ 0, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".(.)\", \"a\\rb\\nc\\r\\n\\xc2\\x85\\xe2\\x80\\xa8\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".(.)\", \"a\\rb\\nc\\r\\n\\xc2\\x85\\xe2\\x80\\xa8\" },\n\t{ U, PCRE2_NEWLINE_ANY, 0, 0, \"(.).\", \"a\\rb\\nc\\r\\n\\xc2\\x85\\xe2\\x80\\xa9$de\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0 | F_NOMATCH, \".(.).\", \"\\xe2\\x80\\xa8\\nb\\r\" },\n\t{ 0, PCRE2_NEWLINE_ANY, 0, 0, \"(.)(.)\", \"#\\x85#\\r#\\n#\\r\\n#\\x84\" },\n\t{ U, PCRE2_NEWLINE_ANY, 0, 0, \"(.+)#\", \"#\\rMn\\xc2\\x85#\\n###\" },\n\t{ 0, BSR(PCRE2_BSR_ANYCRLF), 0, 0, \"\\\\R\", \"\\r\" },\n\t{ 0, BSR(PCRE2_BSR_ANYCRLF), 0, 0, \"\\\\R\", \"\\x85#\\r\\n#\" },\n\t{ U, BSR(PCRE2_BSR_UNICODE), 0, 0, \"\\\\R\", \"ab\\xe2\\x80\\xa8#c\" },\n\t{ U, BSR(PCRE2_BSR_UNICODE), 0, 0, \"\\\\R\", \"ab\\r\\nc\" },\n\t{ U, PCRE2_NEWLINE_CRLF | BSR(PCRE2_BSR_UNICODE), 0, 0, \"(\\\\R.)+\", \"\\xc2\\x85\\r\\n#\\xe2\\x80\\xa8\\n\\r\\n\\r\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"\\\\R+\", \"ab\" },\n\t{ MU, A, 0, 0, \"\\\\R+\", \"ab\\r\\n\\r\" },\n\t{ MU, A, 0, 0, \"\\\\R*\", \"ab\\r\\n\\r\" },\n\t{ MU, A, 0, 0, \"\\\\R*\", \"\\r\\n\\r\" },\n\t{ MU, A, 0, 0, \"\\\\R{2,4}\", \"\\r\\nab\\r\\r\" },\n\t{ MU, A, 0, 0, \"\\\\R{2,4}\", \"\\r\\nab\\n\\n\\n\\r\\r\\r\" },\n\t{ MU, A, 0, 0, \"\\\\R{2,}\", \"\\r\\nab\\n\\n\\n\\r\\r\\r\" },\n\t{ MU, A, 0, 0, \"\\\\R{0,3}\", \"\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"\\\\R+\\\\R\\\\R\", \"\\r\\n\\r\\n\" },\n\t{ MU, A, 0, 0, \"\\\\R+\\\\R\\\\R\", \"\\r\\r\\r\" },\n\t{ MU, A, 0, 0, \"\\\\R*\\\\R\\\\R\", \"\\n\\r\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"\\\\R{2,4}\\\\R\\\\R\", \"\\r\\r\\r\" },\n\t{ MU, A, 0, 0, \"\\\\R{2,4}\\\\R\\\\R\", \"\\r\\r\\r\\r\" },\n\n\t/* Atomic groups (no fallback from \"next\" direction). */\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?>ab)ab\", \"bab\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?>(ab))ab\", \"bab\" },\n\t{ MU, A, 0, 0, \"(?>ab)+abc(?>de)*def(?>gh)?ghe(?>ij)+?k(?>lm)*?n(?>op)?\\?op\",\n\t\t\t\"bababcdedefgheijijklmlmnop\" },\n\t{ MU, A, 0, 0, \"(?>a(b)+a|(ab)?\\?(b))an\", \"abban\" },\n\t{ MU, A, 0, 0, \"(?>ab+a|(?:ab)?\\?b)an\", \"abban\" },\n\t{ MU, A, 0, 0, \"((?>ab|ad|)*?)(?>|c)*abad\", \"abababcababad\" },\n\t{ MU, A, 0, 0, \"(?>(aa|b|)*+(?>(##)|###)*d|(aa)(?>(baa)?)m)\", \"aabaa#####da\" },\n\t{ MU, A, 0, 0, \"((?>a|)+?)b\", \"aaacaaab\" },\n\t{ MU, A, 0, 0, \"(?>x|)*$\", \"aaa\" },\n\t{ MU, A, 0, 0, \"(?>(x)|)*$\", \"aaa\" },\n\t{ MU, A, 0, 0, \"(?>x|())*$\", \"aaa\" },\n\t{ MU, A, 0, 0, \"((?>[cxy]a|[a-d])*?)b\", \"aaa+ aaab\" },\n\t{ MU, A, 0, 0, \"((?>[cxy](a)|[a-d])*?)b\", \"aaa+ aaab\" },\n\t{ MU, A, 0, 0, \"(?>((?>(a+))))bab|(?>((?>(a+))))bb\", \"aaaabaaabaabab\" },\n\t{ MU, A, 0, 0, \"(?>(?>a+))bab|(?>(?>a+))bb\", \"aaaabaaabaabab\" },\n\t{ MU, A, 0, 0, \"(?>(a)c|(?>(c)|(a))a)b*?bab\", \"aaaabaaabaabab\" },\n\t{ MU, A, 0, 0, \"(?>ac|(?>c|a)a)b*?bab\", \"aaaabaaabaabab\" },\n\t{ MU, A, 0, 0, \"(?>(b)b|(a))*b(?>(c)|d)?x\", \"ababcaaabdbx\" },\n\t{ MU, A, 0, 0, \"(?>bb|a)*b(?>c|d)?x\", \"ababcaaabdbx\" },\n\t{ MU, A, 0, 0, \"(?>(bb)|a)*b(?>c|(d))?x\", \"ababcaaabdbx\" },\n\t{ MU, A, 0, 0, \"(?>(a))*?(?>(a))+?(?>(a))??x\", \"aaaaaacccaaaaabax\" },\n\t{ MU, A, 0, 0, \"(?>a)*?(?>a)+?(?>a)??x\", \"aaaaaacccaaaaabax\" },\n\t{ MU, A, 0, 0, \"(?>(a)|)*?(?>(a)|)+?(?>(a)|)??x\", \"aaaaaacccaaaaabax\" },\n\t{ MU, A, 0, 0, \"(?>a|)*?(?>a|)+?(?>a|)??x\", \"aaaaaacccaaaaabax\" },\n\t{ MU, A, 0, 0, \"(?>a(?>(a{0,2}))*?b|aac)+b\", \"aaaaaaacaaaabaaaaacaaaabaacaaabb\" },\n\t{ CM, A, 0, 0, \"(?>((?>a{32}|b+|(a*))?(?>c+|d*)?\\?)+e)+?f\", \"aaccebbdde bbdaaaccebbdee bbdaaaccebbdeef\" },\n\t{ MU, A, 0, 0, \"(?>(?:(?>aa|a||x)+?b|(?>aa|a||(x))+?c)?(?>[ad]{0,2})*?d)+d\", \"aaacdbaabdcabdbaaacd aacaabdbdcdcaaaadaabcbaadd\" },\n\t{ MU, A, 0, 0, \"(?>(?:(?>aa|a||(x))+?b|(?>aa|a||x)+?c)?(?>[ad]{0,2})*?d)+d\", \"aaacdbaabdcabdbaaacd aacaabdbdcdcaaaadaabcbaadd\" },\n\t{ MU, A, 0, 0 | F_PROPERTY, \"\\\\X\", \"\\xcc\\x8d\\xcc\\x8d\" },\n\t{ MU, A, 0, 0 | F_PROPERTY, \"\\\\X\", \"\\xcc\\x8d\\xcc\\x8d#\\xcc\\x8d\\xcc\\x8d\" },\n\t{ MU, A, 0, 0 | F_PROPERTY, \"\\\\X+..\", \"\\xcc\\x8d#\\xcc\\x8d#\\xcc\\x8d\\xcc\\x8d\" },\n\t{ MU, A, 0, 0 | F_PROPERTY, \"\\\\X{2,4}\", \"abcdef\" },\n\t{ MU, A, 0, 0 | F_PROPERTY, \"\\\\X{2,4}?\", \"abcdef\" },\n\t{ MU, A, 0, 0 | F_NOMATCH | F_PROPERTY, \"\\\\X{2,4}..\", \"#\\xcc\\x8d##\" },\n\t{ MU, A, 0, 0 | F_PROPERTY, \"\\\\X{2,4}..\", \"#\\xcc\\x8d#\\xcc\\x8d##\" },\n\t{ MU, A, 0, 0, \"(c(ab)?+ab)+\", \"cabcababcab\" },\n\t{ MU, A, 0, 0, \"(?>(a+)b)+aabab\", \"aaaabaaabaabab\" },\n\n\t/* Possessive quantifiers. */\n\t{ MU, A, 0, 0, \"(?:a|b)++m\", \"mababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(?:a|b)*+m\", \"mababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(?:a|b)*+m\", \"ababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(a|b)++m\", \"mababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(a|b)*+m\", \"mababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(a|b)*+m\", \"ababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(a|b(*ACCEPT))++m\", \"maaxab\" },\n\t{ MU, A, 0, 0, \"(?:b*)++m\", \"bxbbxbbbxm\" },\n\t{ MU, A, 0, 0, \"(?:b*)++m\", \"bxbbxbbbxbbm\" },\n\t{ MU, A, 0, 0, \"(?:b*)*+m\", \"bxbbxbbbxm\" },\n\t{ MU, A, 0, 0, \"(?:b*)*+m\", \"bxbbxbbbxbbm\" },\n\t{ MU, A, 0, 0, \"(b*)++m\", \"bxbbxbbbxm\" },\n\t{ MU, A, 0, 0, \"(b*)++m\", \"bxbbxbbbxbbm\" },\n\t{ MU, A, 0, 0, \"(b*)*+m\", \"bxbbxbbbxm\" },\n\t{ MU, A, 0, 0, \"(b*)*+m\", \"bxbbxbbbxbbm\" },\n\t{ MU, A, 0, 0, \"(?:a|(b))++m\", \"mababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(?:(a)|b)*+m\", \"mababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(?:(a)|(b))*+m\", \"ababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(a|(b))++m\", \"mababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"((a)|b)*+m\", \"mababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"((a)|(b))*+m\", \"ababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(a|(b)(*ACCEPT))++m\", \"maaxab\" },\n\t{ MU, A, 0, 0, \"(?:(b*))++m\", \"bxbbxbbbxm\" },\n\t{ MU, A, 0, 0, \"(?:(b*))++m\", \"bxbbxbbbxbbm\" },\n\t{ MU, A, 0, 0, \"(?:(b*))*+m\", \"bxbbxbbbxm\" },\n\t{ MU, A, 0, 0, \"(?:(b*))*+m\", \"bxbbxbbbxbbm\" },\n\t{ MU, A, 0, 0, \"((b*))++m\", \"bxbbxbbbxm\" },\n\t{ MU, A, 0, 0, \"((b*))++m\", \"bxbbxbbbxbbm\" },\n\t{ MU, A, 0, 0, \"((b*))*+m\", \"bxbbxbbbxm\" },\n\t{ MU, A, 0, 0, \"((b*))*+m\", \"bxbbxbbbxbbm\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?>(b{2,4}))(?:(?:(aa|c))++m|(?:(aa|c))+n)\", \"bbaacaaccaaaacxbbbmbn\" },\n\t{ MU, A, 0, 0, \"((?:b)++a)+(cd)*+m\", \"bbababbacdcdnbbababbacdcdm\" },\n\t{ MU, A, 0, 0, \"((?:(b))++a)+((c)d)*+m\", \"bbababbacdcdnbbababbacdcdm\" },\n\t{ MU, A, 0, 0, \"(?:(?:(?:ab)*+k)++(?:n(?:cd)++)*+)*+m\", \"ababkkXababkkabkncXababkkabkncdcdncdXababkkabkncdcdncdkkabkncdXababkkabkncdcdncdkkabkncdm\" },\n\t{ MU, A, 0, 0, \"(?:((ab)*+(k))++(n(?:c(d))++)*+)*+m\", \"ababkkXababkkabkncXababkkabkncdcdncdXababkkabkncdcdncdkkabkncdXababkkabkncdcdncdkkabkncdm\" },\n\n\t/* Back references. */\n\t{ MU, A, 0, 0, \"(aa|bb)(\\\\1*)(ll|)(\\\\3*)bbbbbbc\", \"aaaaaabbbbbbbbc\" },\n\t{ CMU, A, 0, 0, \"(aa|bb)(\\\\1+)(ll|)(\\\\3+)bbbbbbc\", \"bBbbBbCbBbbbBbbcbbBbbbBBbbC\" },\n\t{ CM, A, 0, 0, \"(a{2,4})\\\\1\", \"AaAaaAaA\" },\n\t{ MU, A, 0, 0, \"(aa|bb)(\\\\1?)aa(\\\\1?)(ll|)(\\\\4+)bbc\", \"aaaaaaaabbaabbbbaabbbbc\" },\n\t{ MU, A, 0, 0, \"(aa|bb)(\\\\1{0,5})(ll|)(\\\\3{0,5})cc\", \"bbxxbbbbxxaaaaaaaaaaaaaaaacc\" },\n\t{ MU, A, 0, 0, \"(aa|bb)(\\\\1{3,5})(ll|)(\\\\3{3,5})cc\", \"bbbbbbbbbbbbaaaaaaccbbbbbbbbbbbbbbcc\" },\n\t{ MU, A, 0, 0, \"(aa|bb)(\\\\1{3,})(ll|)(\\\\3{3,})cc\", \"bbbbbbbbbbbbaaaaaaccbbbbbbbbbbbbbbcc\" },\n\t{ MU, A, 0, 0, \"(\\\\w+)b(\\\\1+)c\", \"GabGaGaDbGaDGaDc\" },\n\t{ MU, A, 0, 0, \"(?:(aa)|b)\\\\1?b\", \"bb\" },\n\t{ CMU, A, 0, 0, \"(aa|bb)(\\\\1*?)aa(\\\\1+?)\", \"bBBbaaAAaaAAaa\" },\n\t{ MU, A, 0, 0, \"(aa|bb)(\\\\1*?)(dd|)cc(\\\\3+?)\", \"aaaaaccdd\" },\n\t{ CMU, A, 0, 0, \"(?:(aa|bb)(\\\\1?\\?)cc){2}(\\\\1?\\?)\", \"aAaABBbbAAaAcCaAcCaA\" },\n\t{ MU, A, 0, 0, \"(?:(aa|bb)(\\\\1{3,5}?)){2}(dd|)(\\\\3{3,5}?)\", \"aaaaaabbbbbbbbbbaaaaaaaaaaaaaa\" },\n\t{ CM, A, 0, 0, \"(?:(aa|bb)(\\\\1{3,}?)){2}(dd|)(\\\\3{3,}?)\", \"aaaaaabbbbbbbbbbaaaaaaaaaaaaaa\" },\n\t{ MU, A, 0, 0, \"(?:(aa|bb)(\\\\1{0,3}?)){2}(dd|)(\\\\3{0,3}?)b(\\\\1{0,3}?)(\\\\1{0,3})\", \"aaaaaaaaaaaaaaabaaaaa\" },\n\t{ MU, A, 0, 0, \"(a(?:\\\\1|)a){3}b\", \"aaaaaaaaaaab\" },\n\t{ M, A, 0, 0, \"(a?)b(\\\\1\\\\1*\\\\1+\\\\1?\\\\1*?\\\\1+?\\\\1??\\\\1*+\\\\1++\\\\1?+\\\\1{4}\\\\1{3,5}\\\\1{4,}\\\\1{0,5}\\\\1{3,5}?\\\\1{4,}?\\\\1{0,5}?\\\\1{3,5}+\\\\1{4,}+\\\\1{0,5}+#){2}d\", \"bb#b##d\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"(\\\\P{N})\\\\1{2,}\", \".www.\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"(\\\\P{N})\\\\1{0,2}\", \"wwwww.\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"(\\\\P{N})\\\\1{1,2}ww\", \"wwww\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"(\\\\P{N})\\\\1{1,2}ww\", \"wwwww\" },\n\t{ PCRE2_UCP, 0, 0, 0 | F_PROPERTY, \"(\\\\P{N})\\\\1{2,}\", \".www.\" },\n\t{ CMUP, A, 0, 0, \"(\\xf0\\x90\\x90\\x80)\\\\1\", \"\\xf0\\x90\\x90\\xa8\\xf0\\x90\\x90\\xa8\" },\n\t{ MU | PCRE2_DUPNAMES, A, 0, 0 | F_NOMATCH, \"\\\\k<A>{1,3}(?<A>aa)(?<A>bb)\", \"aabb\" },\n\t{ MU | PCRE2_DUPNAMES | PCRE2_MATCH_UNSET_BACKREF, A, 0, 0, \"\\\\k<A>{1,3}(?<A>aa)(?<A>bb)\", \"aabb\" },\n\t{ MU | PCRE2_DUPNAMES | PCRE2_MATCH_UNSET_BACKREF, A, 0, 0, \"\\\\k<A>*(?<A>aa)(?<A>bb)\", \"aabb\" },\n\t{ MU | PCRE2_DUPNAMES, A, 0, 0, \"(?<A>aa)(?<A>bb)\\\\k<A>{0,3}aaaaaa\", \"aabbaaaaaa\" },\n\t{ MU | PCRE2_DUPNAMES, A, 0, 0, \"(?<A>aa)(?<A>bb)\\\\k<A>{2,5}bb\", \"aabbaaaabb\" },\n\t{ MU | PCRE2_DUPNAMES, A, 0, 0, \"(?:(?<A>aa)|(?<A>bb))\\\\k<A>{0,3}m\", \"aaaaaaaabbbbaabbbbm\" },\n\t{ MU | PCRE2_DUPNAMES, A, 0, 0 | F_NOMATCH, \"\\\\k<A>{1,3}?(?<A>aa)(?<A>bb)\", \"aabb\" },\n\t{ MU | PCRE2_DUPNAMES | PCRE2_MATCH_UNSET_BACKREF, A, 0, 0, \"\\\\k<A>{1,3}?(?<A>aa)(?<A>bb)\", \"aabb\" },\n\t{ MU | PCRE2_DUPNAMES, A, 0, 0, \"\\\\k<A>*?(?<A>aa)(?<A>bb)\", \"aabb\" },\n\t{ MU | PCRE2_DUPNAMES, A, 0, 0, \"(?:(?<A>aa)|(?<A>bb))\\\\k<A>{0,3}?m\", \"aaaaaabbbbbbaabbbbbbbbbbm\" },\n\t{ MU | PCRE2_DUPNAMES, A, 0, 0, \"(?:(?<A>aa)|(?<A>bb))\\\\k<A>*?m\", \"aaaaaabbbbbbaabbbbbbbbbbm\" },\n\t{ MU | PCRE2_DUPNAMES, A, 0, 0, \"(?:(?<A>aa)|(?<A>bb))\\\\k<A>{2,3}?\", \"aaaabbbbaaaabbbbbbbbbb\" },\n\t{ CMU | PCRE2_DUPNAMES, A, 0, 0, \"(?:(?<A>AA)|(?<A>BB))\\\\k<A>{0,3}M\", \"aaaaaaaabbbbaabbbbm\" },\n\t{ CMU | PCRE2_DUPNAMES, A, 0, 0, \"(?:(?<A>AA)|(?<A>BB))\\\\k<A>{1,3}M\", \"aaaaaaaabbbbaabbbbm\" },\n\t{ CMU | PCRE2_DUPNAMES, A, 0, 0, \"(?:(?<A>AA)|(?<A>BB))\\\\k<A>{0,3}?M\", \"aaaaaabbbbbbaabbbbbbbbbbm\" },\n\t{ CMU | PCRE2_DUPNAMES, A, 0, 0, \"(?:(?<A>AA)|(?<A>BB))\\\\k<A>{2,3}?\", \"aaaabbbbaaaabbbbbbbbbb\" },\n\n\t/* Assertions. */\n\t{ MU, A, 0, 0, \"(?=xx|yy|zz)\\\\w{4}\", \"abczzdefg\" },\n\t{ MU, A, 0, 0, \"(?=((\\\\w+)b){3}|ab)\", \"dbbbb ab\" },\n\t{ MU, A, 0, 0, \"(?!ab|bc|cd)[a-z]{2}\", \"Xabcdef\" },\n\t{ MU, A, 0, 0, \"(?<=aaa|aa|a)a\", \"aaa\" },\n\t{ MU, A, 0, 2, \"(?<=aaa|aa|a)a\", \"aaa\" },\n\t{ M, A, 0, 0, \"(?<=aaa|aa|a)a\", \"aaa\" },\n\t{ M, A, 0, 2, \"(?<=aaa|aa|a)a\", \"aaa\" },\n\t{ MU, A, 0, 0, \"(\\\\d{2})(?!\\\\w+c|(((\\\\w?)m){2}n)+|\\\\1)\", \"x5656\" },\n\t{ MU, A, 0, 0, \"((?=((\\\\d{2,6}\\\\w){2,}))\\\\w{5,20}K){2,}\", \"567v09708K12l00M00 567v09708K12l00M00K45K\" },\n\t{ MU, A, 0, 0, \"(?=(?:(?=\\\\S+a)\\\\w*(b)){3})\\\\w+\\\\d\", \"bba bbab nbbkba nbbkba0kl\" },\n\t{ MU, A, 0, 0, \"(?>a(?>(b+))a(?=(..)))*?k\", \"acabbcabbaabacabaabbakk\" },\n\t{ MU, A, 0, 0, \"((?(?=(a))a)+k)\", \"bbak\" },\n\t{ MU, A, 0, 0, \"((?(?=a)a)+k)\", \"bbak\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?=(?>(a))m)amk\", \"a k\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?!(?>(a))m)amk\", \"a k\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?>(?=(a))am)amk\", \"a k\" },\n\t{ MU, A, 0, 0, \"(?=(?>a|(?=(?>(b+))a|c)[a-c]+)*?m)[a-cm]+k\", \"aaam bbam baaambaam abbabba baaambaamk\" },\n\t{ MU, A, 0, 0, \"(?> ?\\?\\\\b(?(?=\\\\w{1,4}(a))m)\\\\w{0,8}bc){2,}?\", \"bca ssbc mabd ssbc mabc\" },\n\t{ MU, A, 0, 0, \"(?:(?=ab)?[^n][^n])+m\", \"ababcdabcdcdabnababcdabcdcdabm\" },\n\t{ MU, A, 0, 0, \"(?:(?=a(b))?[^n][^n])+m\", \"ababcdabcdcdabnababcdabcdcdabm\" },\n\t{ MU, A, 0, 0, \"(?:(?=.(.))??\\\\1.)+m\", \"aabbbcbacccanaabbbcbacccam\" },\n\t{ MU, A, 0, 0, \"(?:(?=.)??[a-c])+m\", \"abacdcbacacdcaccam\" },\n\t{ MU, A, 0, 0, \"((?!a)?(?!([^a]))?)+$\", \"acbab\" },\n\t{ MU, A, 0, 0, \"((?!a)?\\?(?!([^a]))?\\?)+$\", \"acbab\" },\n\t{ MU, A, 0, 0, \"a(?=(?C)\\\\B(?C`x`))b\", \"ab\" },\n\t{ MU, A, 0, 0, \"a(?!(?C)\\\\B(?C`x`))bb|ab\", \"abb\" },\n\t{ MU, A, 0, 0, \"a(?=\\\\b|(?C)\\\\B(?C`x`))b\", \"ab\" },\n\t{ MU, A, 0, 0, \"a(?!\\\\b|(?C)\\\\B(?C`x`))bb|ab\", \"abb\" },\n\t{ MU, A, 0, 0, \"c(?(?=(?C)\\\\B(?C`x`))ab|a)\", \"cab\" },\n\t{ MU, A, 0, 0, \"c(?(?!(?C)\\\\B(?C`x`))ab|a)\", \"cab\" },\n\t{ MU, A, 0, 0, \"c(?(?=\\\\b|(?C)\\\\B(?C`x`))ab|a)\", \"cab\" },\n\t{ MU, A, 0, 0, \"c(?(?!\\\\b|(?C)\\\\B(?C`x`))ab|a)\", \"cab\" },\n\t{ MU, A, 0, 0, \"a(?=)b\", \"ab\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"a(?!)b\", \"ab\" },\n\n\t/* Not empty, ACCEPT, FAIL */\n\t{ MU, A, PCRE2_NOTEMPTY, 0 | F_NOMATCH, \"a*\", \"bcx\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0, \"a*\", \"bcaad\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0, \"a*?\", \"bcaad\" },\n\t{ MU, A, PCRE2_NOTEMPTY_ATSTART, 0, \"a*\", \"bcaad\" },\n\t{ MU, A, 0, 0, \"a(*ACCEPT)b\", \"ab\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0 | F_NOMATCH, \"a*(*ACCEPT)b\", \"bcx\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0, \"a*(*ACCEPT)b\", \"bcaad\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0, \"a*?(*ACCEPT)b\", \"bcaad\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0 | F_NOMATCH, \"(?:z|a*(*ACCEPT)b)\", \"bcx\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0, \"(?:z|a*(*ACCEPT)b)\", \"bcaad\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0, \"(?:z|a*?(*ACCEPT)b)\", \"bcaad\" },\n\t{ MU, A, PCRE2_NOTEMPTY_ATSTART, 0, \"a*(*ACCEPT)b\", \"bcx\" },\n\t{ MU, A, PCRE2_NOTEMPTY_ATSTART, 0 | F_NOMATCH, \"a*(*ACCEPT)b\", \"\" },\n\t{ MU, A, 0, 0, \"((a(*ACCEPT)b))\", \"ab\" },\n\t{ MU, A, 0, 0, \"(a(*FAIL)a|a)\", \"aaa\" },\n\t{ MU, A, 0, 0, \"(?=ab(*ACCEPT)b)a\", \"ab\" },\n\t{ MU, A, 0, 0, \"(?=(?:x|ab(*ACCEPT)b))\", \"ab\" },\n\t{ MU, A, 0, 0, \"(?=(a(b(*ACCEPT)b)))a\", \"ab\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0, \"(?=a*(*ACCEPT))c\", \"c\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0 | F_NOMATCH, \"(?=A)\", \"AB\" },\n\n\t/* Conditional blocks. */\n\t{ MU, A, 0, 0, \"(?(?=(a))a|b)+k\", \"ababbalbbadabak\" },\n\t{ MU, A, 0, 0, \"(?(?!(b))a|b)+k\", \"ababbalbbadabak\" },\n\t{ MU, A, 0, 0, \"(?(?=a)a|b)+k\", \"ababbalbbadabak\" },\n\t{ MU, A, 0, 0, \"(?(?!b)a|b)+k\", \"ababbalbbadabak\" },\n\t{ MU, A, 0, 0, \"(?(?=(a))a*|b*)+k\", \"ababbalbbadabak\" },\n\t{ MU, A, 0, 0, \"(?(?!(b))a*|b*)+k\", \"ababbalbbadabak\" },\n\t{ MU, A, 0, 0, \"(?(?!(b))(?:aaaaaa|a)|(?:bbbbbb|b))+aaaak\", \"aaaaaaaaaaaaaa bbbbbbbbbbbbbbb aaaaaaak\" },\n\t{ MU, A, 0, 0, \"(?(?!b)(?:aaaaaa|a)|(?:bbbbbb|b))+aaaak\", \"aaaaaaaaaaaaaa bbbbbbbbbbbbbbb aaaaaaak\" },\n\t{ MU, A, 0, 0 | F_DIFF, \"(?(?!(b))(?:aaaaaa|a)|(?:bbbbbb|b))+bbbbk\", \"aaaaaaaaaaaaaa bbbbbbbbbbbbbbb bbbbbbbk\" },\n\t{ MU, A, 0, 0, \"(?(?!b)(?:aaaaaa|a)|(?:bbbbbb|b))+bbbbk\", \"aaaaaaaaaaaaaa bbbbbbbbbbbbbbb bbbbbbbk\" },\n\t{ MU, A, 0, 0, \"(?(?=a)a*|b*)+k\", \"ababbalbbadabak\" },\n\t{ MU, A, 0, 0, \"(?(?!b)a*|b*)+k\", \"ababbalbbadabak\" },\n\t{ MU, A, 0, 0, \"(?(?=a)ab)\", \"a\" },\n\t{ MU, A, 0, 0, \"(?(?<!b)c)\", \"b\" },\n\t{ MU, A, 0, 0, \"(?(DEFINE)a(b))\", \"a\" },\n\t{ MU, A, 0, 0, \"a(?(DEFINE)(?:b|(?:c?)+)*)\", \"a\" },\n\t{ MU, A, 0, 0, \"(?(?=.[a-c])[k-l]|[A-D])\", \"kdB\" },\n\t{ MU, A, 0, 0, \"(?(?!.{0,4}[cd])(aa|bb)|(cc|dd))+\", \"aabbccddaa\" },\n\t{ MU, A, 0, 0, \"(?(?=[^#@]*@)(aaab|aa|aba)|(aba|aab)){3,}\", \"aaabaaaba#aaabaaaba#aaabaaaba@\" },\n\t{ MU, A, 0, 0, \"((?=\\\\w{5})\\\\w(?(?=\\\\w*k)\\\\d|[a-f_])*\\\\w\\\\s)+\", \"mol m10kk m088k _f_a_ mbkkl\" },\n\t{ MU, A, 0, 0, \"(c)?\\?(?(1)a|b)\", \"cdcaa\" },\n\t{ MU, A, 0, 0, \"(c)?\\?(?(1)a|b)\", \"cbb\" },\n\t{ MU, A, 0, 0 | F_DIFF, \"(?(?=(a))(aaaa|a?))+aak\", \"aaaaab aaaaak\" },\n\t{ MU, A, 0, 0, \"(?(?=a)(aaaa|a?))+aak\", \"aaaaab aaaaak\" },\n\t{ MU, A, 0, 0, \"(?(?!(b))(aaaa|a?))+aak\", \"aaaaab aaaaak\" },\n\t{ MU, A, 0, 0, \"(?(?!b)(aaaa|a?))+aak\", \"aaaaab aaaaak\" },\n\t{ MU, A, 0, 0 | F_DIFF, \"(?(?=(a))a*)+aak\", \"aaaaab aaaaak\" },\n\t{ MU, A, 0, 0, \"(?(?=a)a*)+aak\", \"aaaaab aaaaak\" },\n\t{ MU, A, 0, 0, \"(?(?!(b))a*)+aak\", \"aaaaab aaaaak\" },\n\t{ MU, A, 0, 0, \"(?(?!b)a*)+aak\", \"aaaaab aaaaak\" },\n\t{ MU, A, 0, 0, \"(?(?=(?=(?!(x))a)aa)aaa|(?(?=(?!y)bb)bbb))*k\", \"abaabbaaabbbaaabbb abaabbaaabbbaaabbbk\" },\n\t{ MU, A, 0, 0, \"(?P<Name>a)?(?P<Name2>b)?(?(Name)c|d)*l\", \"bc ddd abccabccl\" },\n\t{ MU, A, 0, 0, \"(?P<Name>a)?(?P<Name2>b)?(?(Name)c|d)+?dd\", \"bcabcacdb bdddd\" },\n\t{ MU, A, 0, 0, \"(?P<Name>a)?(?P<Name2>b)?(?(Name)c|d)+l\", \"ababccddabdbccd abcccl\" },\n\t{ MU, A, 0, 0, \"((?:a|aa)(?(1)aaa))x\", \"aax\" },\n\t{ MU, A, 0, 0, \"(?(?!)a|b)\", \"ab\" },\n\t{ MU, A, 0, 0, \"(?(?!)a)\", \"ab\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?(?!)a|b)\", \"ac\" },\n\n\t/* Set start of match. */\n\t{ MU, A, 0, 0, \"(?:\\\\Ka)*aaaab\", \"aaaaaaaa aaaaaaabb\" },\n\t{ MU, A, 0, 0, \"(?>\\\\Ka\\\\Ka)*aaaab\", \"aaaaaaaa aaaaaaaaaabb\" },\n\t{ MU, A, 0, 0, \"a+\\\\K(?<=\\\\Gaa)a\", \"aaaaaa\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0 | F_NOMATCH, \"a\\\\K(*ACCEPT)b\", \"aa\" },\n\t{ MU, A, PCRE2_NOTEMPTY_ATSTART, 0, \"a\\\\K(*ACCEPT)b\", \"aa\" },\n\n\t/* First line. */\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0 | F_PROPERTY, \"\\\\p{Any}a\", \"bb\\naaa\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0 | F_NOMATCH | F_PROPERTY, \"\\\\p{Any}a\", \"bb\\r\\naaa\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0, \"(?<=a)\", \"a\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0 | F_NOMATCH, \"[^a][^b]\", \"ab\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0 | F_NOMATCH, \"a\", \"\\na\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0 | F_NOMATCH, \"[abc]\", \"\\na\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0 | F_NOMATCH, \"^a\", \"\\na\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0 | F_NOMATCH, \"^(?<=\\n)\", \"\\na\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0, \"\\xf0\\x90\\x90\\x80\", \"\\xf0\\x90\\x90\\x80\" },\n\t{ MU | PCRE2_FIRSTLINE, PCRE2_NEWLINE_ANY, 0, 0 | F_NOMATCH, \"#\", \"\\xc2\\x85#\" },\n\t{ M | PCRE2_FIRSTLINE, PCRE2_NEWLINE_ANY, 0, 0 | F_NOMATCH, \"#\", \"\\x85#\" },\n\t{ MU | PCRE2_FIRSTLINE, PCRE2_NEWLINE_ANY, 0, 0 | F_NOMATCH, \"^#\", \"\\xe2\\x80\\xa8#\" },\n\t{ MU | PCRE2_FIRSTLINE, PCRE2_NEWLINE_CRLF, 0, 0 | F_PROPERTY, \"\\\\p{Any}\", \"\\r\\na\" },\n\t{ MU | PCRE2_FIRSTLINE, PCRE2_NEWLINE_CRLF, 0, 0, \".\", \"\\r\" },\n\t{ MU | PCRE2_FIRSTLINE, PCRE2_NEWLINE_CRLF, 0, 0, \"a\", \"\\ra\" },\n\t{ MU | PCRE2_FIRSTLINE, PCRE2_NEWLINE_CRLF, 0, 0 | F_NOMATCH, \"ba\", \"bbb\\r\\nba\" },\n\t{ MU | PCRE2_FIRSTLINE, PCRE2_NEWLINE_CRLF, 0, 0 | F_NOMATCH | F_PROPERTY, \"\\\\p{Any}{4}|a\", \"\\r\\na\" },\n\t{ MU | PCRE2_FIRSTLINE, PCRE2_NEWLINE_CRLF, 0, 1, \".\", \"\\r\\n\" },\n\t{ PCRE2_FIRSTLINE | PCRE2_DOTALL, PCRE2_NEWLINE_LF, 0, 0 | F_NOMATCH, \"ab.\", \"ab\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 1 | F_NOMATCH, \"^[a-d0-9]\", \"\\nxx\\nd\" },\n\t{ PCRE2_FIRSTLINE | PCRE2_DOTALL, PCRE2_NEWLINE_ANY, 0, 0, \"....a\", \"012\\n0a\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0, \"[aC]\", \"a\" },\n\n\t/* Recurse. */\n\t{ MU, A, 0, 0, \"(a)(?1)\", \"aa\" },\n\t{ MU, A, 0, 0, \"((a))(?1)\", \"aa\" },\n\t{ MU, A, 0, 0, \"(b|a)(?1)\", \"aa\" },\n\t{ MU, A, 0, 0, \"(b|(a))(?1)\", \"aa\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"((a)(b)(?:a*))(?1)\", \"aba\" },\n\t{ MU, A, 0, 0, \"((a)(b)(?:a*))(?1)\", \"abab\" },\n\t{ MU, A, 0, 0, \"((a+)c(?2))b(?1)\", \"aacaabaca\" },\n\t{ MU, A, 0, 0, \"((?2)b|(a)){2}(?1)\", \"aabab\" },\n\t{ MU, A, 0, 0, \"(?1)(a)*+(?2)(b(?1))\", \"aababa\" },\n\t{ MU, A, 0, 0, \"(?1)(((a(*ACCEPT)))b)\", \"axaa\" },\n\t{ MU, A, 0, 0, \"(?1)(?(DEFINE) (((ac(*ACCEPT)))b) )\", \"akaac\" },\n\t{ MU, A, 0, 0, \"(a+)b(?1)b\\\\1\", \"abaaabaaaaa\" },\n\t{ MU, A, 0, 0, \"(?(DEFINE)(aa|a))(?1)ab\", \"aab\" },\n\t{ MU, A, 0, 0, \"(?(DEFINE)(a\\\\Kb))(?1)+ababc\", \"abababxabababc\" },\n\t{ MU, A, 0, 0, \"(a\\\\Kb)(?1)+ababc\", \"abababxababababc\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(a\\\\Kb)(?1)+ababc\", \"abababxababababxc\" },\n\t{ MU, A, 0, 0, \"b|<(?R)*>\", \"<<b>\" },\n\t{ MU, A, 0, 0, \"(a\\\\K){0}(?:(?1)b|ac)\", \"ac\" },\n\t{ MU, A, 0, 0, \"(?(DEFINE)(a(?2)|b)(b(?1)|(a)))(?:(?1)|(?2))m\", \"ababababnababababaam\" },\n\t{ MU, A, 0, 0, \"(a)((?(R)a|b))(?2)\", \"aabbabaa\" },\n\t{ MU, A, 0, 0, \"(a)((?(R2)a|b))(?2)\", \"aabbabaa\" },\n\t{ MU, A, 0, 0, \"(a)((?(R1)a|b))(?2)\", \"ababba\" },\n\t{ MU, A, 0, 0, \"(?(R0)aa|bb(?R))\", \"abba aabb bbaa\" },\n\t{ MU, A, 0, 0, \"((?(R)(?:aaaa|a)|(?:(aaaa)|(a)))+)(?1)$\", \"aaaaaaaaaa aaaa\" },\n\t{ MU, A, 0, 0, \"(?P<Name>a(?(R&Name)a|b))(?1)\", \"aab abb abaa\" },\n\t{ MU, A, 0, 0, \"((?(R)a|(?1)){3})\", \"XaaaaaaaaaX\" },\n\t{ MU, A, 0, 0, \"((?:(?(R)a|(?1))){3})\", \"XaaaaaaaaaX\" },\n\t{ MU, A, 0, 0, \"((?(R)a|(?1)){1,3})aaaaaa\", \"aaaaaaaaXaaaaaaaaa\" },\n\t{ MU, A, 0, 0, \"((?(R)a|(?1)){1,3}?)M\", \"aaaM\" },\n\t{ MU, A, 0, 0, \"((.)(?:.|\\\\2(?1))){0}#(?1)#\", \"#aabbccdde# #aabbccddee#\" },\n\t{ MU, A, 0, 0, \"((.)(?:\\\\2|\\\\2{4}b)){0}#(?:(?1))+#\", \"#aaaab# #aaaaab#\" },\n\n\t/* 16 bit specific tests. */\n\t{ CM, A, 0, 0 | F_FORCECONV, \"\\xc3\\xa1\", \"\\xc3\\x81\\xc3\\xa1\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"\\xe1\\xbd\\xb8\", \"\\xe1\\xbf\\xb8\\xe1\\xbd\\xb8\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"[\\xc3\\xa1]\", \"\\xc3\\x81\\xc3\\xa1\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"[\\xe1\\xbd\\xb8]\", \"\\xe1\\xbf\\xb8\\xe1\\xbd\\xb8\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"[a-\\xed\\xb0\\x80]\", \"A\" },\n\t{ CM, A, 0, 0 | F_NO8 | F_FORCECONV, \"[a-\\\\x{dc00}]\", \"B\" },\n\t{ CM, A, 0, 0 | F_NO8 | F_NOMATCH | F_FORCECONV, \"[b-\\\\x{dc00}]\", \"a\" },\n\t{ CM, A, 0, 0 | F_NO8 | F_FORCECONV, \"\\xed\\xa0\\x80\\\\x{d800}\\xed\\xb0\\x80\\\\x{dc00}\", \"\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xb0\\x80\\xed\\xb0\\x80\" },\n\t{ CM, A, 0, 0 | F_NO8 | F_FORCECONV, \"[\\xed\\xa0\\x80\\\\x{d800}]{1,2}?[\\xed\\xb0\\x80\\\\x{dc00}]{1,2}?#\", \"\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xb0\\x80\\xed\\xb0\\x80#\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"[\\xed\\xa0\\x80\\xed\\xb0\\x80#]{0,3}(?<=\\xed\\xb0\\x80.)\", \"\\xed\\xa0\\x80#\\xed\\xa0\\x80##\\xed\\xb0\\x80\\xed\\xa0\\x80\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"[\\xed\\xa0\\x80-\\xed\\xb3\\xbf]\", \"\\xed\\x9f\\xbf\\xed\\xa0\\x83\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"[\\xed\\xa0\\x80-\\xed\\xb3\\xbf]\", \"\\xed\\xb4\\x80\\xed\\xb3\\xb0\" },\n\t{ CM, A, 0, 0 | F_NO8 | F_FORCECONV, \"[\\\\x{d800}-\\\\x{dcff}]\", \"\\xed\\x9f\\xbf\\xed\\xa0\\x83\" },\n\t{ CM, A, 0, 0 | F_NO8 | F_FORCECONV, \"[\\\\x{d800}-\\\\x{dcff}]\", \"\\xed\\xb4\\x80\\xed\\xb3\\xb0\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"[\\xed\\xa0\\x80-\\xef\\xbf\\xbf]+[\\x1-\\xed\\xb0\\x80]+#\", \"\\xed\\xa0\\x85\\xc3\\x81\\xed\\xa0\\x85\\xef\\xbf\\xb0\\xc2\\x85\\xed\\xa9\\x89#\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"[\\xed\\xa0\\x80][\\xed\\xb0\\x80]{2,}\", \"\\xed\\xa0\\x80\\xed\\xb0\\x80\\xed\\xa0\\x80\\xed\\xb0\\x80\\xed\\xb0\\x80\\xed\\xb0\\x80\" },\n\t{ M, A, 0, 0 | F_FORCECONV, \"[^\\xed\\xb0\\x80]{3,}?\", \"##\\xed\\xb0\\x80#\\xed\\xb0\\x80#\\xc3\\x89#\\xed\\xb0\\x80\" },\n\t{ M, A, 0, 0 | F_NO8 | F_FORCECONV, \"[^\\\\x{dc00}]{3,}?\", \"##\\xed\\xb0\\x80#\\xed\\xb0\\x80#\\xc3\\x89#\\xed\\xb0\\x80\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \".\\\\B.\", \"\\xed\\xa0\\x80\\xed\\xb0\\x80\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"\\\\D+(?:\\\\d+|.)\\\\S+(?:\\\\s+|.)\\\\W+(?:\\\\w+|.)\\xed\\xa0\\x80\\xed\\xa0\\x80\", \"\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xa0\\x80\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"\\\\d*\\\\s*\\\\w*\\xed\\xa0\\x80\\xed\\xa0\\x80\", \"\\xed\\xa0\\x80\\xed\\xa0\\x80\" },\n\t{ CM, A, 0, 0 | F_FORCECONV | F_NOMATCH, \"\\\\d*?\\\\D*?\\\\s*?\\\\S*?\\\\w*?\\\\W*?##\", \"\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xa0\\x80#\" },\n\t{ CM | PCRE2_EXTENDED, A, 0, 0 | F_FORCECONV, \"\\xed\\xa0\\x80 \\xed\\xb0\\x80 !\", \"\\xed\\xa0\\x80\\xed\\xb0\\x80!\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"\\xed\\xa0\\x80+#[^#]+\\xed\\xa0\\x80\", \"\\xed\\xa0\\x80#a\\xed\\xa0\\x80\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"(\\xed\\xa0\\x80+)#\\\\1\", \"\\xed\\xa0\\x80\\xed\\xa0\\x80#\\xed\\xa0\\x80\\xed\\xa0\\x80\" },\n\t{ M, PCRE2_NEWLINE_ANY, 0, 0 | F_NO8 | F_FORCECONV, \"^-\", \"a--\\xe2\\x80\\xa8--\" },\n\t{ 0, BSR(PCRE2_BSR_UNICODE), 0, 0 | F_NO8 | F_FORCECONV, \"\\\\R\", \"ab\\xe2\\x80\\xa8\" },\n\t{ 0, 0, 0, 0 | F_NO8 | F_FORCECONV, \"\\\\v\", \"ab\\xe2\\x80\\xa9\" },\n\t{ 0, 0, 0, 0 | F_NO8 | F_FORCECONV, \"\\\\h\", \"ab\\xe1\\xa0\\x8e\" },\n\t{ 0, 0, 0, 0 | F_NO8 | F_FORCECONV, \"\\\\v+?\\\\V+?#\", \"\\xe2\\x80\\xa9\\xe2\\x80\\xa9\\xef\\xbf\\xbf\\xef\\xbf\\xbf#\" },\n\t{ 0, 0, 0, 0 | F_NO8 | F_FORCECONV, \"\\\\h+?\\\\H+?#\", \"\\xe1\\xa0\\x8e\\xe1\\xa0\\x8e\\xef\\xbf\\xbf\\xef\\xbf\\xbf#\" },\n\n\t/* Partial matching. */\n\t{ MU, A, PCRE2_PARTIAL_SOFT, 0, \"ab\", \"a\" },\n\t{ MU, A, PCRE2_PARTIAL_SOFT, 0, \"ab|a\", \"a\" },\n\t{ MU, A, PCRE2_PARTIAL_HARD, 0, \"ab|a\", \"a\" },\n\t{ MU, A, PCRE2_PARTIAL_SOFT, 0, \"\\\\b#\", \"a\" },\n\t{ MU, A, PCRE2_PARTIAL_SOFT, 0, \"(?<=a)b\", \"a\" },\n\t{ MU, A, PCRE2_PARTIAL_SOFT, 0, \"abc|(?<=xxa)bc\", \"xxab\" },\n\t{ MU, A, PCRE2_PARTIAL_SOFT, 0, \"a\\\\B\", \"a\" },\n\t{ MU, A, PCRE2_PARTIAL_HARD, 0, \"a\\\\b\", \"a\" },\n\n\t/* (*MARK) verb. */\n\t{ MU, A, 0, 0, \"a(*MARK:aa)a\", \"ababaa\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"a(*:aa)a\", \"abab\" },\n\t{ MU, A, 0, 0, \"a(*:aa)(b(*:bb)b|bc)\", \"abc\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"a(*:1)x|b(*:2)y\", \"abc\" },\n\t{ MU, A, 0, 0, \"(?>a(*:aa))b|ac\", \"ac\" },\n\t{ MU, A, 0, 0, \"(?(DEFINE)(a(*:aa)))(?1)\", \"a\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?(DEFINE)((a)(*:aa)))(?1)b\", \"aa\" },\n\t{ MU, A, 0, 0, \"(?(DEFINE)(a(*:aa)))a(?1)b|aac\", \"aac\" },\n\t{ MU, A, 0, 0, \"(a(*:aa)){0}(?:b(?1)b|c)+c\", \"babbab cc\" },\n\t{ MU, A, 0, 0, \"(a(*:aa)){0}(?:b(?1)b)+\", \"babba\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(a(*:aa)){0}(?:b(?1)b)+\", \"ba\" },\n\t{ MU, A, 0, 0, \"(a\\\\K(*:aa)){0}(?:b(?1)b|c)+c\", \"babbab cc\" },\n\t{ MU, A, 0, 0, \"(a\\\\K(*:aa)){0}(?:b(?1)b)+\", \"babba\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(a\\\\K(*:aa)){0}(?:b(?1)b)+\", \"ba\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*:mark)m\", \"a\" },\n\n\t/* (*COMMIT) verb. */\n\t{ MU, A, 0, 0 | F_NOMATCH, \"a(*COMMIT)b\", \"ac\" },\n\t{ MU, A, 0, 0, \"aa(*COMMIT)b\", \"xaxaab\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"a(*COMMIT)(*:msg)b|ac\", \"ac\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(a(*COMMIT)b)++\", \"abac\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"((a)(*COMMIT)b)++\", \"abac\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?=a(*COMMIT)b)ab|ad\", \"ad\" },\n\n\t/* (*PRUNE) verb. */\n\t{ MU, A, 0, 0, \"aa\\\\K(*PRUNE)b\", \"aaab\" },\n\t{ MU, A, 0, 0, \"aa(*PRUNE:bb)b|a\", \"aa\" },\n\t{ MU, A, 0, 0, \"(a)(a)(*PRUNE)b|(a)\", \"aa\" },\n\t{ MU, A, 0, 0, \"(a)(a)(a)(a)(a)(a)(a)(a)(*PRUNE)b|(a)\", \"aaaaaaaa\" },\n\t{ MU, A, PCRE2_PARTIAL_SOFT, 0, \"a(*PRUNE)a|\", \"a\" },\n\t{ MU, A, PCRE2_PARTIAL_SOFT, 0, \"a(*PRUNE)a|m\", \"a\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?=a(*PRUNE)b)ab|ad\", \"ad\" },\n\t{ MU, A, 0, 0, \"a(*COMMIT)(*PRUNE)d|bc\", \"abc\" },\n\t{ MU, A, 0, 0, \"(?=a(*COMMIT)b)a(*PRUNE)c|bc\", \"abc\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)(?=a(*COMMIT)b)a(*PRUNE)c|bc\", \"abc\" },\n\t{ MU, A, 0, 0, \"(?=(a)(*COMMIT)b)a(*PRUNE)c|bc\", \"abc\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)(?=(a)(*COMMIT)b)a(*PRUNE)c|bc\", \"abc\" },\n\t{ MU, A, 0, 0, \"(a(*COMMIT)b){0}a(?1)(*PRUNE)c|bc\", \"abc\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(a(*COMMIT)b){0}a(*COMMIT)(?1)(*PRUNE)c|bc\", \"abc\" },\n\t{ MU, A, 0, 0, \"(a(*COMMIT)b)++(*PRUNE)d|c\", \"ababc\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)(a(*COMMIT)b)++(*PRUNE)d|c\", \"ababc\" },\n\t{ MU, A, 0, 0, \"((a)(*COMMIT)b)++(*PRUNE)d|c\", \"ababc\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)((a)(*COMMIT)b)++(*PRUNE)d|c\", \"ababc\" },\n\t{ MU, A, 0, 0, \"(?>a(*COMMIT)b)*abab(*PRUNE)d|ba\", \"ababab\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)(?>a(*COMMIT)b)*abab(*PRUNE)d|ba\", \"ababab\" },\n\t{ MU, A, 0, 0, \"(?>a(*COMMIT)b)+abab(*PRUNE)d|ba\", \"ababab\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)(?>a(*COMMIT)b)+abab(*PRUNE)d|ba\", \"ababab\" },\n\t{ MU, A, 0, 0, \"(?>a(*COMMIT)b)?ab(*PRUNE)d|ba\", \"aba\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)(?>a(*COMMIT)b)?ab(*PRUNE)d|ba\", \"aba\" },\n\t{ MU, A, 0, 0, \"(?>a(*COMMIT)b)*?n(*PRUNE)d|ba\", \"abababn\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)(?>a(*COMMIT)b)*?n(*PRUNE)d|ba\", \"abababn\" },\n\t{ MU, A, 0, 0, \"(?>a(*COMMIT)b)+?n(*PRUNE)d|ba\", \"abababn\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)(?>a(*COMMIT)b)+?n(*PRUNE)d|ba\", \"abababn\" },\n\t{ MU, A, 0, 0, \"(?>a(*COMMIT)b)??n(*PRUNE)d|bn\", \"abn\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)(?>a(*COMMIT)b)??n(*PRUNE)d|bn\", \"abn\" },\n\n\t/* (*SKIP) verb. */\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?=a(*SKIP)b)ab|ad\", \"ad\" },\n\t{ MU, A, 0, 0, \"(\\\\w+(*SKIP)#)\", \"abcd,xyz#,\" },\n\t{ MU, A, 0, 0, \"\\\\w+(*SKIP)#|mm\", \"abcd,xyz#,\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"b+(?<=(*SKIP)#c)|b+\", \"#bbb\" },\n\n\t/* (*THEN) verb. */\n\t{ MU, A, 0, 0, \"((?:a(*THEN)|aab)(*THEN)c|a+)+m\", \"aabcaabcaabcaabcnacm\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"((?:a(*THEN)|aab)(*THEN)c|a+)+m\", \"aabcm\" },\n\t{ MU, A, 0, 0, \"((?:a(*THEN)|aab)c|a+)+m\", \"aabcaabcnmaabcaabcm\" },\n\t{ MU, A, 0, 0, \"((?:a|aab)(*THEN)c|a+)+m\", \"aam\" },\n\t{ MU, A, 0, 0, \"((?:a(*COMMIT)|aab)(*THEN)c|a+)+m\", \"aam\" },\n\t{ MU, A, 0, 0, \"(?(?=a(*THEN)b)ab|ad)\", \"ad\" },\n\t{ MU, A, 0, 0, \"(?(?!a(*THEN)b)ad|add)\", \"add\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?(?=a)a(*THEN)b|ad)\", \"ad\" },\n\t{ MU, A, 0, 0, \"(?!(?(?=a)ab|b(*THEN)d))bn|bnn\", \"bnn\" },\n\t{ MU, A, 0, 0, \"(?=(*THEN: ))* \", \" \" },\n\t{ MU, A, 0, 0, \"a(*THEN)(?R) |\", \"a\" },\n\n\t/* Recurse and control verbs. */\n\t{ MU, A, 0, 0, \"(a(*ACCEPT)b){0}a(?1)b\", \"aacaabb\" },\n\t{ MU, A, 0, 0, \"((a)\\\\2(*ACCEPT)b){0}a(?1)b\", \"aaacaaabb\" },\n\t{ MU, A, 0, 0, \"((ab|a(*ACCEPT)x)+|ababababax){0}_(?1)_\", \"_ababababax_ _ababababa_\" },\n\t{ MU, A, 0, 0, \"((.)(?:A(*ACCEPT)|(?1)\\\\2)){0}_(?1)_\", \"_bcdaAdcb_bcdaAdcb_\" },\n\t{ MU, A, 0, 0, \"((*MARK:m)(?:a|a(*COMMIT)b|aa)){0}_(?1)_\", \"_ab_\" },\n\t{ MU, A, 0, 0, \"((*MARK:m)(?:a|a(*COMMIT)b|aa)){0}_(?1)_|(_aa_)\", \"_aa_\" },\n\t{ MU, A, 0, 0, \"(a(*COMMIT)(?:b|bb)|c(*ACCEPT)d|dd){0}_(?1)+_\", \"_ax_ _cd_ _abbb_ _abcd_ _abbcdd_\" },\n\t{ MU, A, 0, 0, \"((.)(?:.|(*COMMIT)\\\\2{3}(*ACCEPT).*|.*)){0}_(?1){0,4}_\", \"_aaaabbbbccccddd_ _aaaabbbbccccdddd_\" },\n\n#ifdef SUPPORT_UNICODE\n\t/* Script runs and iterations. */\n\t{ MU, A, 0, 0, \"!(*sr:\\\\w\\\\w|\\\\w\\\\w\\\\w)*#\", \"!abcdefghijklmno!abcdefghijklmno!abcdef#\" },\n\t{ MU, A, 0, 0, \"!(*sr:\\\\w\\\\w|\\\\w\\\\w\\\\w)+#\", \"!abcdefghijklmno!abcdefghijklmno!abcdef#\" },\n\t{ MU, A, 0, 0, \"!(*sr:\\\\w\\\\w|\\\\w\\\\w\\\\w)*?#\", \"!abcdefghijklmno!abcdefghijklmno!abcdef#\" },\n\t{ MU, A, 0, 0, \"!(*sr:\\\\w\\\\w|\\\\w\\\\w\\\\w)+?#\", \"!abcdefghijklmno!abcdefghijklmno!abcdef#\" },\n\t{ MU, A, 0, 0, \"!(*sr:\\\\w\\\\w|\\\\w\\\\w\\\\w)*+#\", \"!abcdefghijklmno!abcdefghijklmno!abcdef#\" },\n\t{ MU, A, 0, 0, \"!(*sr:\\\\w\\\\w|\\\\w\\\\w\\\\w)++#\", \"!abcdefghijklmno!abcdefghijklmno!abcdef#\" },\n\t{ MU, A, 0, 0, \"!(*sr:\\\\w\\\\w|\\\\w\\\\w\\\\w)?#\", \"!ab!abc!ab!ab#\" },\n\t{ MU, A, 0, 0, \"!(*sr:\\\\w\\\\w|\\\\w\\\\w\\\\w)??#\", \"!ab!abc!ab!ab#\" },\n#endif\n\n\t/* Deep recursion. */\n\t{ MU, A, 0, 0, \"((((?:(?:(?:\\\\w)+)?)*|(?>\\\\w)+?)+|(?>\\\\w)?\\?)*)?\\\\s\", \"aaaaa+ \" },\n\t{ MU, A, 0, 0, \"(?:((?:(?:(?:\\\\w*?)+)??|(?>\\\\w)?|\\\\w*+)*)+)+?\\\\s\", \"aa+ \" },\n\t{ MU, A, 0, 0, \"((a?)+)+b\", \"aaaaaaaaaaaa b\" },\n\n\t/* Deep recursion: Stack limit reached. */\n\t{ M, A, 0, 0 | F_NOMATCH, \"a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaa\", \"aaaaaaaaaaaaaaaaaaaaaaa\" },\n\t{ M, A, 0, 0 | F_NOMATCH, \"(?:a+)+b\", \"aaaaaaaaaaaaaaaaaaaaaaaa b\" },\n\t{ M, A, 0, 0 | F_NOMATCH, \"(?:a+?)+?b\", \"aaaaaaaaaaaaaaaaaaaaaaaa b\" },\n\t{ M, A, 0, 0 | F_NOMATCH, \"(?:a*)*b\", \"aaaaaaaaaaaaaaaaaaaaaaaa b\" },\n\t{ M, A, 0, 0 | F_NOMATCH, \"(?:a*?)*?b\", \"aaaaaaaaaaaaaaaaaaaaaaaa b\" },\n\n\t{ 0, 0, 0, 0, NULL, NULL }\n};\n\n#ifdef SUPPORT_PCRE2_8\nstatic pcre2_jit_stack_8* callback8(void *arg)\n{\n\treturn (pcre2_jit_stack_8 *)arg;\n}\n#endif\n\n#ifdef SUPPORT_PCRE2_16\nstatic pcre2_jit_stack_16* callback16(void *arg)\n{\n\treturn (pcre2_jit_stack_16 *)arg;\n}\n#endif\n\n#ifdef SUPPORT_PCRE2_32\nstatic pcre2_jit_stack_32* callback32(void *arg)\n{\n\treturn (pcre2_jit_stack_32 *)arg;\n}\n#endif\n\n#ifdef SUPPORT_PCRE2_8\nstatic pcre2_jit_stack_8 *stack8;\n\nstatic pcre2_jit_stack_8 *getstack8(void)\n{\n\tif (!stack8)\n\t\tstack8 = pcre2_jit_stack_create_8(1, 1024 * 1024, NULL);\n\treturn stack8;\n}\n\nstatic void setstack8(pcre2_match_context_8 *mcontext)\n{\n\tif (!mcontext) {\n\t\tif (stack8)\n\t\t\tpcre2_jit_stack_free_8(stack8);\n\t\tstack8 = NULL;\n\t\treturn;\n\t}\n\n\tpcre2_jit_stack_assign_8(mcontext, callback8, getstack8());\n}\n#endif /* SUPPORT_PCRE2_8 */\n\n#ifdef SUPPORT_PCRE2_16\nstatic pcre2_jit_stack_16 *stack16;\n\nstatic pcre2_jit_stack_16 *getstack16(void)\n{\n\tif (!stack16)\n\t\tstack16 = pcre2_jit_stack_create_16(1, 1024 * 1024, NULL);\n\treturn stack16;\n}\n\nstatic void setstack16(pcre2_match_context_16 *mcontext)\n{\n\tif (!mcontext) {\n\t\tif (stack16)\n\t\t\tpcre2_jit_stack_free_16(stack16);\n\t\tstack16 = NULL;\n\t\treturn;\n\t}\n\n\tpcre2_jit_stack_assign_16(mcontext, callback16, getstack16());\n}\n#endif /* SUPPORT_PCRE2_16 */\n\n#ifdef SUPPORT_PCRE2_32\nstatic pcre2_jit_stack_32 *stack32;\n\nstatic pcre2_jit_stack_32 *getstack32(void)\n{\n\tif (!stack32)\n\t\tstack32 = pcre2_jit_stack_create_32(1, 1024 * 1024, NULL);\n\treturn stack32;\n}\n\nstatic void setstack32(pcre2_match_context_32 *mcontext)\n{\n\tif (!mcontext) {\n\t\tif (stack32)\n\t\t\tpcre2_jit_stack_free_32(stack32);\n\t\tstack32 = NULL;\n\t\treturn;\n\t}\n\n\tpcre2_jit_stack_assign_32(mcontext, callback32, getstack32());\n}\n#endif /* SUPPORT_PCRE2_32 */\n\n#ifdef SUPPORT_PCRE2_16\n\nstatic int convert_utf8_to_utf16(PCRE2_SPTR8 input, PCRE2_UCHAR16 *output, int *offsetmap, int max_length)\n{\n\tPCRE2_SPTR8 iptr = input;\n\tPCRE2_UCHAR16 *optr = output;\n\tunsigned int c;\n\n\tif (max_length == 0)\n\t\treturn 0;\n\n\twhile (*iptr && max_length > 1) {\n\t\tc = 0;\n\t\tif (offsetmap)\n\t\t\t*offsetmap++ = (int)(iptr - (unsigned char*)input);\n\n\t\tif (*iptr < 0xc0)\n\t\t\tc = *iptr++;\n\t\telse if (!(*iptr & 0x20)) {\n\t\t\tc = ((iptr[0] & 0x1f) << 6) | (iptr[1] & 0x3f);\n\t\t\tiptr += 2;\n\t\t} else if (!(*iptr & 0x10)) {\n\t\t\tc = ((iptr[0] & 0x0f) << 12) | ((iptr[1] & 0x3f) << 6) | (iptr[2] & 0x3f);\n\t\t\tiptr += 3;\n\t\t} else if (!(*iptr & 0x08)) {\n\t\t\tc = ((iptr[0] & 0x07) << 18) | ((iptr[1] & 0x3f) << 12) | ((iptr[2] & 0x3f) << 6) | (iptr[3] & 0x3f);\n\t\t\tiptr += 4;\n\t\t}\n\n\t\tif (c < 65536) {\n\t\t\t*optr++ = c;\n\t\t\tmax_length--;\n\t\t} else if (max_length <= 2) {\n\t\t\t*optr = '\\0';\n\t\t\treturn (int)(optr - output);\n\t\t} else {\n\t\t\tc -= 0x10000;\n\t\t\t*optr++ = 0xd800 | ((c >> 10) & 0x3ff);\n\t\t\t*optr++ = 0xdc00 | (c & 0x3ff);\n\t\t\tmax_length -= 2;\n\t\t\tif (offsetmap)\n\t\t\t\toffsetmap++;\n\t\t}\n\t}\n\tif (offsetmap)\n\t\t*offsetmap = (int)(iptr - (unsigned char*)input);\n\t*optr = '\\0';\n\treturn (int)(optr - output);\n}\n\nstatic int copy_char8_to_char16(PCRE2_SPTR8 input, PCRE2_UCHAR16 *output, int max_length)\n{\n\tPCRE2_SPTR8 iptr = input;\n\tPCRE2_UCHAR16 *optr = output;\n\n\tif (max_length == 0)\n\t\treturn 0;\n\n\twhile (*iptr && max_length > 1) {\n\t\t*optr++ = *iptr++;\n\t\tmax_length--;\n\t}\n\t*optr = '\\0';\n\treturn (int)(optr - output);\n}\n\n#define REGTEST_MAX_LENGTH16 4096\nstatic PCRE2_UCHAR16 regtest_buf16[REGTEST_MAX_LENGTH16];\nstatic int regtest_offsetmap16[REGTEST_MAX_LENGTH16];\n\n#endif /* SUPPORT_PCRE2_16 */\n\n#ifdef SUPPORT_PCRE2_32\n\nstatic int convert_utf8_to_utf32(PCRE2_SPTR8 input, PCRE2_UCHAR32 *output, int *offsetmap, int max_length)\n{\n\tPCRE2_SPTR8 iptr = input;\n\tPCRE2_UCHAR32 *optr = output;\n\tunsigned int c;\n\n\tif (max_length == 0)\n\t\treturn 0;\n\n\twhile (*iptr && max_length > 1) {\n\t\tc = 0;\n\t\tif (offsetmap)\n\t\t\t*offsetmap++ = (int)(iptr - (unsigned char*)input);\n\n\t\tif (*iptr < 0xc0)\n\t\t\tc = *iptr++;\n\t\telse if (!(*iptr & 0x20)) {\n\t\t\tc = ((iptr[0] & 0x1f) << 6) | (iptr[1] & 0x3f);\n\t\t\tiptr += 2;\n\t\t} else if (!(*iptr & 0x10)) {\n\t\t\tc = ((iptr[0] & 0x0f) << 12) | ((iptr[1] & 0x3f) << 6) | (iptr[2] & 0x3f);\n\t\t\tiptr += 3;\n\t\t} else if (!(*iptr & 0x08)) {\n\t\t\tc = ((iptr[0] & 0x07) << 18) | ((iptr[1] & 0x3f) << 12) | ((iptr[2] & 0x3f) << 6) | (iptr[3] & 0x3f);\n\t\t\tiptr += 4;\n\t\t}\n\n\t\t*optr++ = c;\n\t\tmax_length--;\n\t}\n\tif (offsetmap)\n\t\t*offsetmap = (int)(iptr - (unsigned char*)input);\n\t*optr = 0;\n\treturn (int)(optr - output);\n}\n\nstatic int copy_char8_to_char32(PCRE2_SPTR8 input, PCRE2_UCHAR32 *output, int max_length)\n{\n\tPCRE2_SPTR8 iptr = input;\n\tPCRE2_UCHAR32 *optr = output;\n\n\tif (max_length == 0)\n\t\treturn 0;\n\n\twhile (*iptr && max_length > 1) {\n\t\t*optr++ = *iptr++;\n\t\tmax_length--;\n\t}\n\t*optr = '\\0';\n\treturn (int)(optr - output);\n}\n\n#define REGTEST_MAX_LENGTH32 4096\nstatic PCRE2_UCHAR32 regtest_buf32[REGTEST_MAX_LENGTH32];\nstatic int regtest_offsetmap32[REGTEST_MAX_LENGTH32];\n\n#endif /* SUPPORT_PCRE2_32 */\n\nstatic int check_ascii(const char *input)\n{\n\tconst unsigned char *ptr = (unsigned char *)input;\n\twhile (*ptr) {\n\t\tif (*ptr > 127)\n\t\t\treturn 0;\n\t\tptr++;\n\t}\n\treturn 1;\n}\n\n#define OVECTOR_SIZE 15\n\nstatic int regression_tests(void)\n{\n\tstruct regression_test_case *current = regression_test_cases;\n\tint error;\n\tPCRE2_SIZE err_offs;\n\tint is_successful;\n\tint is_ascii;\n\tint total = 0;\n\tint successful = 0;\n\tint successful_row = 0;\n\tint counter = 0;\n\tint jit_compile_mode;\n\tint utf = 0;\n\tint disabled_options = 0;\n\tint i;\n#ifdef SUPPORT_PCRE2_8\n\tpcre2_code_8 *re8;\n\tpcre2_compile_context_8 *ccontext8;\n\tpcre2_match_data_8 *mdata8_1;\n\tpcre2_match_data_8 *mdata8_2;\n\tpcre2_match_context_8 *mcontext8;\n\tPCRE2_SIZE *ovector8_1 = NULL;\n\tPCRE2_SIZE *ovector8_2 = NULL;\n\tint return_value8[2];\n#endif\n#ifdef SUPPORT_PCRE2_16\n\tpcre2_code_16 *re16;\n\tpcre2_compile_context_16 *ccontext16;\n\tpcre2_match_data_16 *mdata16_1;\n\tpcre2_match_data_16 *mdata16_2;\n\tpcre2_match_context_16 *mcontext16;\n\tPCRE2_SIZE *ovector16_1 = NULL;\n\tPCRE2_SIZE *ovector16_2 = NULL;\n\tint return_value16[2];\n\tint length16;\n#endif\n#ifdef SUPPORT_PCRE2_32\n\tpcre2_code_32 *re32;\n\tpcre2_compile_context_32 *ccontext32;\n\tpcre2_match_data_32 *mdata32_1;\n\tpcre2_match_data_32 *mdata32_2;\n\tpcre2_match_context_32 *mcontext32;\n\tPCRE2_SIZE *ovector32_1 = NULL;\n\tPCRE2_SIZE *ovector32_2 = NULL;\n\tint return_value32[2];\n\tint length32;\n#endif\n\n#if defined SUPPORT_PCRE2_8\n\tPCRE2_UCHAR8 cpu_info[128];\n#elif defined SUPPORT_PCRE2_16\n\tPCRE2_UCHAR16 cpu_info[128];\n#elif defined SUPPORT_PCRE2_32\n\tPCRE2_UCHAR32 cpu_info[128];\n#endif\n#if defined SUPPORT_UNICODE && ((defined(SUPPORT_PCRE2_8) + defined(SUPPORT_PCRE2_16) + defined(SUPPORT_PCRE2_32)) >= 2)\n\tint return_value;\n#endif\n\n\t/* This test compares the behaviour of interpreter and JIT. Although disabling\n\tutf or ucp may make tests fail, if the pcre2_match result is the SAME, it is\n\tstill considered successful from pcre2_jit_test point of view. */\n\n#if defined SUPPORT_PCRE2_8\n\tpcre2_config_8(PCRE2_CONFIG_JITTARGET, &cpu_info);\n#elif defined SUPPORT_PCRE2_16\n\tpcre2_config_16(PCRE2_CONFIG_JITTARGET, &cpu_info);\n#elif defined SUPPORT_PCRE2_32\n\tpcre2_config_32(PCRE2_CONFIG_JITTARGET, &cpu_info);\n#endif\n\n\tprintf(\"Running JIT regression tests\\n\");\n\tprintf(\"  target CPU of SLJIT compiler: \");\n\tfor (i = 0; cpu_info[i]; i++)\n\t\tprintf(\"%c\", (char)(cpu_info[i]));\n\tprintf(\"\\n\");\n\n#if defined SUPPORT_PCRE2_8\n\tpcre2_config_8(PCRE2_CONFIG_UNICODE, &utf);\n#elif defined SUPPORT_PCRE2_16\n\tpcre2_config_16(PCRE2_CONFIG_UNICODE, &utf);\n#elif defined SUPPORT_PCRE2_32\n\tpcre2_config_32(PCRE2_CONFIG_UNICODE, &utf);\n#endif\n\n\tif (!utf)\n\t\tdisabled_options |= PCRE2_UTF;\n#ifdef SUPPORT_PCRE2_8\n\tprintf(\"  in  8 bit mode with UTF-8  %s:\\n\", utf ? \"enabled\" : \"disabled\");\n#endif\n#ifdef SUPPORT_PCRE2_16\n\tprintf(\"  in 16 bit mode with UTF-16 %s:\\n\", utf ? \"enabled\" : \"disabled\");\n#endif\n#ifdef SUPPORT_PCRE2_32\n\tprintf(\"  in 32 bit mode with UTF-32 %s:\\n\", utf ? \"enabled\" : \"disabled\");\n#endif\n\n\twhile (current->pattern) {\n\t\t/* printf(\"\\nPattern: %s :\\n\", current->pattern); */\n\t\ttotal++;\n\t\tis_ascii = 0;\n\t\tif (!(current->start_offset & F_PROPERTY))\n\t\t\tis_ascii = check_ascii(current->pattern) && check_ascii(current->input);\n\n\t\tif (current->match_options & PCRE2_PARTIAL_SOFT)\n\t\t\tjit_compile_mode = PCRE2_JIT_PARTIAL_SOFT;\n\t\telse if (current->match_options & PCRE2_PARTIAL_HARD)\n\t\t\tjit_compile_mode = PCRE2_JIT_PARTIAL_HARD;\n\t\telse\n\t\t\tjit_compile_mode = PCRE2_JIT_COMPLETE;\n\t\terror = 0;\n#ifdef SUPPORT_PCRE2_8\n\t\tre8 = NULL;\n\t\tccontext8 = pcre2_compile_context_create_8(NULL);\n\t\tif (ccontext8) {\n\t\t\tif (GET_NEWLINE(current->newline))\n\t\t\t\tpcre2_set_newline_8(ccontext8, GET_NEWLINE(current->newline));\n\t\t\tif (GET_BSR(current->newline))\n\t\t\t\tpcre2_set_bsr_8(ccontext8, GET_BSR(current->newline));\n\n\t\t\tif (!(current->start_offset & F_NO8)) {\n\t\t\t\tre8 = pcre2_compile_8((PCRE2_SPTR8)current->pattern, PCRE2_ZERO_TERMINATED,\n\t\t\t\t\tcurrent->compile_options & ~disabled_options,\n\t\t\t\t\t&error, &err_offs, ccontext8);\n\n\t\t\t\tif (!re8 && (utf || is_ascii))\n\t\t\t\t\tprintf(\"\\n8 bit: Cannot compile pattern \\\"%s\\\": %d\\n\", current->pattern, error);\n\t\t\t}\n\t\t\tpcre2_compile_context_free_8(ccontext8);\n\t\t}\n\t\telse\n\t\t\tprintf(\"\\n8 bit: Cannot allocate compile context\\n\");\n#endif\n#ifdef SUPPORT_PCRE2_16\n\t\tif ((current->compile_options & PCRE2_UTF) || (current->start_offset & F_FORCECONV))\n\t\t\tconvert_utf8_to_utf16((PCRE2_SPTR8)current->pattern, regtest_buf16, NULL, REGTEST_MAX_LENGTH16);\n\t\telse\n\t\t\tcopy_char8_to_char16((PCRE2_SPTR8)current->pattern, regtest_buf16, REGTEST_MAX_LENGTH16);\n\n\t\tre16 = NULL;\n\t\tccontext16 = pcre2_compile_context_create_16(NULL);\n\t\tif (ccontext16) {\n\t\t\tif (GET_NEWLINE(current->newline))\n\t\t\t\tpcre2_set_newline_16(ccontext16, GET_NEWLINE(current->newline));\n\t\t\tif (GET_BSR(current->newline))\n\t\t\t\tpcre2_set_bsr_16(ccontext16, GET_BSR(current->newline));\n\n\t\t\tif (!(current->start_offset & F_NO16)) {\n\t\t\t\tre16 = pcre2_compile_16(regtest_buf16, PCRE2_ZERO_TERMINATED,\n\t\t\t\t\tcurrent->compile_options & ~disabled_options,\n\t\t\t\t\t&error, &err_offs, ccontext16);\n\n\t\t\t\tif (!re16 && (utf || is_ascii))\n\t\t\t\t\tprintf(\"\\n16 bit: Cannot compile pattern \\\"%s\\\": %d\\n\", current->pattern, error);\n\t\t\t}\n\t\t\tpcre2_compile_context_free_16(ccontext16);\n\t\t}\n\t\telse\n\t\t\tprintf(\"\\n16 bit: Cannot allocate compile context\\n\");\n#endif\n#ifdef SUPPORT_PCRE2_32\n\t\tif ((current->compile_options & PCRE2_UTF) || (current->start_offset & F_FORCECONV))\n\t\t\tconvert_utf8_to_utf32((PCRE2_SPTR8)current->pattern, regtest_buf32, NULL, REGTEST_MAX_LENGTH32);\n\t\telse\n\t\t\tcopy_char8_to_char32((PCRE2_SPTR8)current->pattern, regtest_buf32, REGTEST_MAX_LENGTH32);\n\n\t\tre32 = NULL;\n\t\tccontext32 = pcre2_compile_context_create_32(NULL);\n\t\tif (ccontext32) {\n\t\t\tif (GET_NEWLINE(current->newline))\n\t\t\t\tpcre2_set_newline_32(ccontext32, GET_NEWLINE(current->newline));\n\t\t\tif (GET_BSR(current->newline))\n\t\t\t\tpcre2_set_bsr_32(ccontext32, GET_BSR(current->newline));\n\n\t\t\tif (!(current->start_offset & F_NO32)) {\n\t\t\t\tre32 = pcre2_compile_32(regtest_buf32, PCRE2_ZERO_TERMINATED,\n\t\t\t\t\tcurrent->compile_options & ~disabled_options,\n\t\t\t\t\t&error, &err_offs, ccontext32);\n\n\t\t\t\tif (!re32 && (utf || is_ascii))\n\t\t\t\t\tprintf(\"\\n32 bit: Cannot compile pattern \\\"%s\\\": %d\\n\", current->pattern, error);\n\t\t\t}\n\t\t\tpcre2_compile_context_free_32(ccontext32);\n\t\t}\n\t\telse\n\t\t\tprintf(\"\\n32 bit: Cannot allocate compile context\\n\");\n#endif\n\n\t\tcounter++;\n\t\tif ((counter & 0x3) != 0) {\n#ifdef SUPPORT_PCRE2_8\n\t\t\tsetstack8(NULL);\n#endif\n#ifdef SUPPORT_PCRE2_16\n\t\t\tsetstack16(NULL);\n#endif\n#ifdef SUPPORT_PCRE2_32\n\t\t\tsetstack32(NULL);\n#endif\n\t\t}\n\n#ifdef SUPPORT_PCRE2_8\n\t\treturn_value8[0] = -1000;\n\t\treturn_value8[1] = -1000;\n\t\tmdata8_1 = pcre2_match_data_create_8(OVECTOR_SIZE, NULL);\n\t\tmdata8_2 = pcre2_match_data_create_8(OVECTOR_SIZE, NULL);\n\t\tmcontext8 = pcre2_match_context_create_8(NULL);\n\t\tif (!mdata8_1 || !mdata8_2 || !mcontext8) {\n\t\t\tprintf(\"\\n8 bit: Cannot allocate match data\\n\");\n\t\t\tpcre2_match_data_free_8(mdata8_1);\n\t\t\tpcre2_match_data_free_8(mdata8_2);\n\t\t\tpcre2_match_context_free_8(mcontext8);\n\t\t\tpcre2_code_free_8(re8);\n\t\t\tre8 = NULL;\n\t\t} else {\n\t\t\tovector8_1 = pcre2_get_ovector_pointer_8(mdata8_1);\n\t\t\tovector8_2 = pcre2_get_ovector_pointer_8(mdata8_2);\n\t\t\tfor (i = 0; i < OVECTOR_SIZE * 2; ++i)\n\t\t\t\tovector8_1[i] = -2;\n\t\t\tfor (i = 0; i < OVECTOR_SIZE * 2; ++i)\n\t\t\t\tovector8_2[i] = -2;\n\t\t\tpcre2_set_match_limit_8(mcontext8, 10000000);\n\t\t}\n\t\tif (re8) {\n\t\t\treturn_value8[1] = pcre2_match_8(re8, (PCRE2_SPTR8)current->input, strlen(current->input),\n\t\t\t\tcurrent->start_offset & OFFSET_MASK, current->match_options, mdata8_2, mcontext8);\n\n\t\t\tif (pcre2_jit_compile_8(re8, jit_compile_mode)) {\n\t\t\t\tprintf(\"\\n8 bit: JIT compiler does not support \\\"%s\\\"\\n\", current->pattern);\n\t\t\t} else if ((counter & 0x1) != 0) {\n\t\t\t\tsetstack8(mcontext8);\n\t\t\t\treturn_value8[0] = pcre2_match_8(re8, (PCRE2_SPTR8)current->input, strlen(current->input),\n\t\t\t\t\tcurrent->start_offset & OFFSET_MASK, current->match_options, mdata8_1, mcontext8);\n\t\t\t} else {\n\t\t\t\tpcre2_jit_stack_assign_8(mcontext8, NULL, getstack8());\n\t\t\t\treturn_value8[0] = pcre2_jit_match_8(re8, (PCRE2_SPTR8)current->input, strlen(current->input),\n\t\t\t\t\tcurrent->start_offset & OFFSET_MASK, current->match_options, mdata8_1, mcontext8);\n\t\t\t}\n\t\t}\n#endif\n\n#ifdef SUPPORT_PCRE2_16\n\t\treturn_value16[0] = -1000;\n\t\treturn_value16[1] = -1000;\n\t\tmdata16_1 = pcre2_match_data_create_16(OVECTOR_SIZE, NULL);\n\t\tmdata16_2 = pcre2_match_data_create_16(OVECTOR_SIZE, NULL);\n\t\tmcontext16 = pcre2_match_context_create_16(NULL);\n\t\tif (!mdata16_1 || !mdata16_2 || !mcontext16) {\n\t\t\tprintf(\"\\n16 bit: Cannot allocate match data\\n\");\n\t\t\tpcre2_match_data_free_16(mdata16_1);\n\t\t\tpcre2_match_data_free_16(mdata16_2);\n\t\t\tpcre2_match_context_free_16(mcontext16);\n\t\t\tpcre2_code_free_16(re16);\n\t\t\tre16 = NULL;\n\t\t} else {\n\t\t\tovector16_1 = pcre2_get_ovector_pointer_16(mdata16_1);\n\t\t\tovector16_2 = pcre2_get_ovector_pointer_16(mdata16_2);\n\t\t\tfor (i = 0; i < OVECTOR_SIZE * 2; ++i)\n\t\t\t\tovector16_1[i] = -2;\n\t\t\tfor (i = 0; i < OVECTOR_SIZE * 2; ++i)\n\t\t\t\tovector16_2[i] = -2;\n\t\t\tpcre2_set_match_limit_16(mcontext16, 10000000);\n\t\t}\n\t\tif (re16) {\n\t\t\tif ((current->compile_options & PCRE2_UTF) || (current->start_offset & F_FORCECONV))\n\t\t\t\tlength16 = convert_utf8_to_utf16((PCRE2_SPTR8)current->input, regtest_buf16, regtest_offsetmap16, REGTEST_MAX_LENGTH16);\n\t\t\telse\n\t\t\t\tlength16 = copy_char8_to_char16((PCRE2_SPTR8)current->input, regtest_buf16, REGTEST_MAX_LENGTH16);\n\n\t\t\treturn_value16[1] = pcre2_match_16(re16, regtest_buf16, length16,\n\t\t\t\tcurrent->start_offset & OFFSET_MASK, current->match_options, mdata16_2, mcontext16);\n\n\t\t\tif (pcre2_jit_compile_16(re16, jit_compile_mode)) {\n\t\t\t\tprintf(\"\\n16 bit: JIT compiler does not support \\\"%s\\\"\\n\", current->pattern);\n\t\t\t} else if ((counter & 0x1) != 0) {\n\t\t\t\tsetstack16(mcontext16);\n\t\t\t\treturn_value16[0] = pcre2_match_16(re16, regtest_buf16, length16,\n\t\t\t\t\tcurrent->start_offset & OFFSET_MASK, current->match_options, mdata16_1, mcontext16);\n\t\t\t} else {\n\t\t\t\tpcre2_jit_stack_assign_16(mcontext16, NULL, getstack16());\n\t\t\t\treturn_value16[0] = pcre2_jit_match_16(re16, regtest_buf16, length16,\n\t\t\t\t\tcurrent->start_offset & OFFSET_MASK, current->match_options, mdata16_1, mcontext16);\n\t\t\t}\n\t\t}\n#endif\n\n#ifdef SUPPORT_PCRE2_32\n\t\treturn_value32[0] = -1000;\n\t\treturn_value32[1] = -1000;\n\t\tmdata32_1 = pcre2_match_data_create_32(OVECTOR_SIZE, NULL);\n\t\tmdata32_2 = pcre2_match_data_create_32(OVECTOR_SIZE, NULL);\n\t\tmcontext32 = pcre2_match_context_create_32(NULL);\n\t\tif (!mdata32_1 || !mdata32_2 || !mcontext32) {\n\t\t\tprintf(\"\\n32 bit: Cannot allocate match data\\n\");\n\t\t\tpcre2_match_data_free_32(mdata32_1);\n\t\t\tpcre2_match_data_free_32(mdata32_2);\n\t\t\tpcre2_match_context_free_32(mcontext32);\n\t\t\tpcre2_code_free_32(re32);\n\t\t\tre32 = NULL;\n\t\t} else {\n\t\t\tovector32_1 = pcre2_get_ovector_pointer_32(mdata32_1);\n\t\t\tovector32_2 = pcre2_get_ovector_pointer_32(mdata32_2);\n\t\t\tfor (i = 0; i < OVECTOR_SIZE * 2; ++i)\n\t\t\t\tovector32_1[i] = -2;\n\t\t\tfor (i = 0; i < OVECTOR_SIZE * 2; ++i)\n\t\t\t\tovector32_2[i] = -2;\n\t\t\tpcre2_set_match_limit_32(mcontext32, 10000000);\n\t\t}\n\t\tif (re32) {\n\t\t\tif ((current->compile_options & PCRE2_UTF) || (current->start_offset & F_FORCECONV))\n\t\t\t\tlength32 = convert_utf8_to_utf32((PCRE2_SPTR8)current->input, regtest_buf32, regtest_offsetmap32, REGTEST_MAX_LENGTH32);\n\t\t\telse\n\t\t\t\tlength32 = copy_char8_to_char32((PCRE2_SPTR8)current->input, regtest_buf32, REGTEST_MAX_LENGTH32);\n\n\t\t\treturn_value32[1] = pcre2_match_32(re32, regtest_buf32, length32,\n\t\t\t\tcurrent->start_offset & OFFSET_MASK, current->match_options, mdata32_2, mcontext32);\n\n\t\t\tif (pcre2_jit_compile_32(re32, jit_compile_mode)) {\n\t\t\t\tprintf(\"\\n32 bit: JIT compiler does not support \\\"%s\\\"\\n\", current->pattern);\n\t\t\t} else if ((counter & 0x1) != 0) {\n\t\t\t\tsetstack32(mcontext32);\n\t\t\t\treturn_value32[0] = pcre2_match_32(re32, regtest_buf32, length32,\n\t\t\t\t\tcurrent->start_offset & OFFSET_MASK, current->match_options, mdata32_1, mcontext32);\n\t\t\t} else {\n\t\t\t\tpcre2_jit_stack_assign_32(mcontext32, NULL, getstack32());\n\t\t\t\treturn_value32[0] = pcre2_jit_match_32(re32, regtest_buf32, length32,\n\t\t\t\t\tcurrent->start_offset & OFFSET_MASK, current->match_options, mdata32_1, mcontext32);\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/* printf(\"[%d-%d-%d|%d-%d|%d-%d|%d-%d]%s\",\n\t\t\treturn_value8[0], return_value16[0], return_value32[0],\n\t\t\t(int)ovector8_1[0], (int)ovector8_1[1],\n\t\t\t(int)ovector16_1[0], (int)ovector16_1[1],\n\t\t\t(int)ovector32_1[0], (int)ovector32_1[1],\n\t\t\t(current->compile_options & PCRE2_CASELESS) ? \"C\" : \"\"); */\n\n\t\t/* If F_DIFF is set, just run the test, but do not compare the results.\n\t\tSegfaults can still be captured. */\n\n\t\tis_successful = 1;\n\t\tif (!(current->start_offset & F_DIFF)) {\n#if defined SUPPORT_UNICODE && ((defined(SUPPORT_PCRE2_8) + defined(SUPPORT_PCRE2_16) + defined(SUPPORT_PCRE2_32)) >= 2)\n\t\t\tif (!(current->start_offset & F_FORCECONV)) {\n\n\t\t\t\t/* All results must be the same. */\n#ifdef SUPPORT_PCRE2_8\n\t\t\t\tif ((return_value = return_value8[0]) != return_value8[1]) {\n\t\t\t\t\tprintf(\"\\n8 bit: Return value differs(J8:%d,I8:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\treturn_value8[0], return_value8[1], total, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t} else\n#endif\n#ifdef SUPPORT_PCRE2_16\n\t\t\t\tif ((return_value = return_value16[0]) != return_value16[1]) {\n\t\t\t\t\tprintf(\"\\n16 bit: Return value differs(J16:%d,I16:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\treturn_value16[0], return_value16[1], total, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t} else\n#endif\n#ifdef SUPPORT_PCRE2_32\n\t\t\t\tif ((return_value = return_value32[0]) != return_value32[1]) {\n\t\t\t\t\tprintf(\"\\n32 bit: Return value differs(J32:%d,I32:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\treturn_value32[0], return_value32[1], total, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t} else\n#endif\n#if defined SUPPORT_PCRE2_8 && defined SUPPORT_PCRE2_16\n\t\t\t\tif (return_value8[0] != return_value16[0]) {\n\t\t\t\t\tprintf(\"\\n8 and 16 bit: Return value differs(J8:%d,J16:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\treturn_value8[0], return_value16[0],\n\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t} else\n#endif\n#if defined SUPPORT_PCRE2_8 && defined SUPPORT_PCRE2_32\n\t\t\t\tif (return_value8[0] != return_value32[0]) {\n\t\t\t\t\tprintf(\"\\n8 and 32 bit: Return value differs(J8:%d,J32:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\treturn_value8[0], return_value32[0],\n\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t} else\n#endif\n#if defined SUPPORT_PCRE2_16 && defined SUPPORT_PCRE2_32\n\t\t\t\tif (return_value16[0] != return_value32[0]) {\n\t\t\t\t\tprintf(\"\\n16 and 32 bit: Return value differs(J16:%d,J32:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\treturn_value16[0], return_value32[0],\n\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t} else\n#endif\n\t\t\t\tif (return_value >= 0 || return_value == PCRE2_ERROR_PARTIAL) {\n\t\t\t\t\tif (return_value == PCRE2_ERROR_PARTIAL) {\n\t\t\t\t\t\treturn_value = 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn_value *= 2;\n\t\t\t\t\t}\n#ifdef SUPPORT_PCRE2_8\n\t\t\t\t\treturn_value8[0] = return_value;\n#endif\n#ifdef SUPPORT_PCRE2_16\n\t\t\t\t\treturn_value16[0] = return_value;\n#endif\n#ifdef SUPPORT_PCRE2_32\n\t\t\t\t\treturn_value32[0] = return_value;\n#endif\n\t\t\t\t\t/* Transform back the results. */\n\t\t\t\t\tif (current->compile_options & PCRE2_UTF) {\n#ifdef SUPPORT_PCRE2_16\n\t\t\t\t\t\tfor (i = 0; i < return_value; ++i) {\n\t\t\t\t\t\t\tif (ovector16_1[i] != PCRE2_UNSET)\n\t\t\t\t\t\t\t\tovector16_1[i] = regtest_offsetmap16[ovector16_1[i]];\n\t\t\t\t\t\t\tif (ovector16_2[i] != PCRE2_UNSET)\n\t\t\t\t\t\t\t\tovector16_2[i] = regtest_offsetmap16[ovector16_2[i]];\n\t\t\t\t\t\t}\n#endif\n#ifdef SUPPORT_PCRE2_32\n\t\t\t\t\t\tfor (i = 0; i < return_value; ++i) {\n\t\t\t\t\t\t\tif (ovector32_1[i] != PCRE2_UNSET)\n\t\t\t\t\t\t\t\tovector32_1[i] = regtest_offsetmap32[ovector32_1[i]];\n\t\t\t\t\t\t\tif (ovector32_2[i] != PCRE2_UNSET)\n\t\t\t\t\t\t\t\tovector32_2[i] = regtest_offsetmap32[ovector32_2[i]];\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = 0; i < return_value; ++i) {\n#if defined SUPPORT_PCRE2_8 && defined SUPPORT_PCRE2_16\n\t\t\t\t\t\tif (ovector8_1[i] != ovector8_2[i] || ovector8_1[i] != ovector16_1[i] || ovector8_1[i] != ovector16_2[i]) {\n\t\t\t\t\t\t\tprintf(\"\\n8 and 16 bit: Ovector[%d] value differs(J8:%d,I8:%d,J16:%d,I16:%d): [%d] '%s' @ '%s' \\n\",\n\t\t\t\t\t\t\t\ti, (int)ovector8_1[i], (int)ovector8_2[i], (int)ovector16_1[i], (int)ovector16_2[i],\n\t\t\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\t\t\tis_successful = 0;\n\t\t\t\t\t\t}\n#endif\n#if defined SUPPORT_PCRE2_8 && defined SUPPORT_PCRE2_32\n\t\t\t\t\t\tif (ovector8_1[i] != ovector8_2[i] || ovector8_1[i] != ovector32_1[i] || ovector8_1[i] != ovector32_2[i]) {\n\t\t\t\t\t\t\tprintf(\"\\n8 and 32 bit: Ovector[%d] value differs(J8:%d,I8:%d,J32:%d,I32:%d): [%d] '%s' @ '%s' \\n\",\n\t\t\t\t\t\t\t\ti, (int)ovector8_1[i], (int)ovector8_2[i], (int)ovector32_1[i], (int)ovector32_2[i],\n\t\t\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\t\t\tis_successful = 0;\n\t\t\t\t\t\t}\n#endif\n#if defined SUPPORT_PCRE2_16 && defined SUPPORT_PCRE2_32\n\t\t\t\t\t\tif (ovector16_1[i] != ovector16_2[i] || ovector16_1[i] != ovector32_1[i] || ovector16_1[i] != ovector32_2[i]) {\n\t\t\t\t\t\t\tprintf(\"\\n16 and 32 bit: Ovector[%d] value differs(J16:%d,I16:%d,J32:%d,I32:%d): [%d] '%s' @ '%s' \\n\",\n\t\t\t\t\t\t\t\ti, (int)ovector16_1[i], (int)ovector16_2[i], (int)ovector32_1[i], (int)ovector32_2[i],\n\t\t\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\t\t\tis_successful = 0;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n#endif /* more than one of SUPPORT_PCRE2_8, SUPPORT_PCRE2_16 and SUPPORT_PCRE2_32 */\n\t\t\t{\n#ifdef SUPPORT_PCRE2_8\n\t\t\t\tif (return_value8[0] != return_value8[1]) {\n\t\t\t\t\tprintf(\"\\n8 bit: Return value differs(%d:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\treturn_value8[0], return_value8[1], total, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t} else if (return_value8[0] >= 0 || return_value8[0] == PCRE2_ERROR_PARTIAL) {\n\t\t\t\t\tif (return_value8[0] == PCRE2_ERROR_PARTIAL)\n\t\t\t\t\t\treturn_value8[0] = 2;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn_value8[0] *= 2;\n\n\t\t\t\t\tfor (i = 0; i < return_value8[0]; ++i)\n\t\t\t\t\t\tif (ovector8_1[i] != ovector8_2[i]) {\n\t\t\t\t\t\t\tprintf(\"\\n8 bit: Ovector[%d] value differs(%d:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\t\t\ti, (int)ovector8_1[i], (int)ovector8_2[i], total, current->pattern, current->input);\n\t\t\t\t\t\t\tis_successful = 0;\n\t\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\n#ifdef SUPPORT_PCRE2_16\n\t\t\t\tif (return_value16[0] != return_value16[1]) {\n\t\t\t\t\tprintf(\"\\n16 bit: Return value differs(%d:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\treturn_value16[0], return_value16[1], total, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t} else if (return_value16[0] >= 0 || return_value16[0] == PCRE2_ERROR_PARTIAL) {\n\t\t\t\t\tif (return_value16[0] == PCRE2_ERROR_PARTIAL)\n\t\t\t\t\t\treturn_value16[0] = 2;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn_value16[0] *= 2;\n\n\t\t\t\t\tfor (i = 0; i < return_value16[0]; ++i)\n\t\t\t\t\t\tif (ovector16_1[i] != ovector16_2[i]) {\n\t\t\t\t\t\t\tprintf(\"\\n16 bit: Ovector[%d] value differs(%d:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\t\t\ti, (int)ovector16_1[i], (int)ovector16_2[i], total, current->pattern, current->input);\n\t\t\t\t\t\t\tis_successful = 0;\n\t\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\n#ifdef SUPPORT_PCRE2_32\n\t\t\t\tif (return_value32[0] != return_value32[1]) {\n\t\t\t\t\tprintf(\"\\n32 bit: Return value differs(%d:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\treturn_value32[0], return_value32[1], total, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t} else if (return_value32[0] >= 0 || return_value32[0] == PCRE2_ERROR_PARTIAL) {\n\t\t\t\t\tif (return_value32[0] == PCRE2_ERROR_PARTIAL)\n\t\t\t\t\t\treturn_value32[0] = 2;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn_value32[0] *= 2;\n\n\t\t\t\t\tfor (i = 0; i < return_value32[0]; ++i)\n\t\t\t\t\t\tif (ovector32_1[i] != ovector32_2[i]) {\n\t\t\t\t\t\t\tprintf(\"\\n32 bit: Ovector[%d] value differs(%d:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\t\t\ti, (int)ovector32_1[i], (int)ovector32_2[i], total, current->pattern, current->input);\n\t\t\t\t\t\t\tis_successful = 0;\n\t\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\n\t\tif (is_successful) {\n#ifdef SUPPORT_PCRE2_8\n\t\t\tif (!(current->start_offset & F_NO8) && (utf || is_ascii)) {\n\t\t\t\tif (return_value8[0] < 0 && !(current->start_offset & F_NOMATCH)) {\n\t\t\t\t\tprintf(\"8 bit: Test should match: [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t}\n\n\t\t\t\tif (return_value8[0] >= 0 && (current->start_offset & F_NOMATCH)) {\n\t\t\t\t\tprintf(\"8 bit: Test should not match: [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t}\n\t\t\t}\n#endif\n#ifdef SUPPORT_PCRE2_16\n\t\t\tif (!(current->start_offset & F_NO16) && (utf || is_ascii)) {\n\t\t\t\tif (return_value16[0] < 0 && !(current->start_offset & F_NOMATCH)) {\n\t\t\t\t\tprintf(\"16 bit: Test should match: [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t}\n\n\t\t\t\tif (return_value16[0] >= 0 && (current->start_offset & F_NOMATCH)) {\n\t\t\t\t\tprintf(\"16 bit: Test should not match: [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t}\n\t\t\t}\n#endif\n#ifdef SUPPORT_PCRE2_32\n\t\t\tif (!(current->start_offset & F_NO32) && (utf || is_ascii)) {\n\t\t\t\tif (return_value32[0] < 0 && !(current->start_offset & F_NOMATCH)) {\n\t\t\t\t\tprintf(\"32 bit: Test should match: [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t}\n\n\t\t\t\tif (return_value32[0] >= 0 && (current->start_offset & F_NOMATCH)) {\n\t\t\t\t\tprintf(\"32 bit: Test should not match: [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t}\n\n\t\tif (is_successful) {\n#ifdef SUPPORT_PCRE2_8\n\t\t\tif (re8 && !(current->start_offset & F_NO8) && pcre2_get_mark_8(mdata8_1) != pcre2_get_mark_8(mdata8_2)) {\n\t\t\t\tprintf(\"8 bit: Mark value mismatch: [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\tis_successful = 0;\n\t\t\t}\n#endif\n#ifdef SUPPORT_PCRE2_16\n\t\t\tif (re16 && !(current->start_offset & F_NO16) && pcre2_get_mark_16(mdata16_1) != pcre2_get_mark_16(mdata16_2)) {\n\t\t\t\tprintf(\"16 bit: Mark value mismatch: [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\tis_successful = 0;\n\t\t\t}\n#endif\n#ifdef SUPPORT_PCRE2_32\n\t\t\tif (re32 && !(current->start_offset & F_NO32) && pcre2_get_mark_32(mdata32_1) != pcre2_get_mark_32(mdata32_2)) {\n\t\t\t\tprintf(\"32 bit: Mark value mismatch: [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\tis_successful = 0;\n\t\t\t}\n#endif\n\t\t}\n\n#ifdef SUPPORT_PCRE2_8\n\t\tpcre2_code_free_8(re8);\n\t\tpcre2_match_data_free_8(mdata8_1);\n\t\tpcre2_match_data_free_8(mdata8_2);\n\t\tpcre2_match_context_free_8(mcontext8);\n#endif\n#ifdef SUPPORT_PCRE2_16\n\t\tpcre2_code_free_16(re16);\n\t\tpcre2_match_data_free_16(mdata16_1);\n\t\tpcre2_match_data_free_16(mdata16_2);\n\t\tpcre2_match_context_free_16(mcontext16);\n#endif\n#ifdef SUPPORT_PCRE2_32\n\t\tpcre2_code_free_32(re32);\n\t\tpcre2_match_data_free_32(mdata32_1);\n\t\tpcre2_match_data_free_32(mdata32_2);\n\t\tpcre2_match_context_free_32(mcontext32);\n#endif\n\n\t\tif (is_successful) {\n\t\t\tsuccessful++;\n\t\t\tsuccessful_row++;\n\t\t\tprintf(\".\");\n\t\t\tif (successful_row >= 60) {\n\t\t\t\tsuccessful_row = 0;\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t} else\n\t\t\tsuccessful_row = 0;\n\n\t\tfflush(stdout);\n\t\tcurrent++;\n\t}\n#ifdef SUPPORT_PCRE2_8\n\tsetstack8(NULL);\n#endif\n#ifdef SUPPORT_PCRE2_16\n\tsetstack16(NULL);\n#endif\n#ifdef SUPPORT_PCRE2_32\n\tsetstack32(NULL);\n#endif\n\n\tif (total == successful) {\n\t\tprintf(\"\\nAll JIT regression tests are successfully passed.\\n\");\n\t\treturn 0;\n\t} else {\n\t\tprintf(\"\\nSuccessful test ratio: %d%% (%d failed)\\n\", successful * 100 / total, total - successful);\n\t\treturn 1;\n\t}\n}\n\n#if defined SUPPORT_UNICODE\n\nstatic int check_invalid_utf_result(int pattern_index, const char *type, int result,\n\tint match_start, int match_end, PCRE2_SIZE *ovector)\n{\n\tif (match_start < 0) {\n\t\tif (result != -1) {\n\t\t\tprintf(\"Pattern[%d] %s result is not -1.\\n\", pattern_index, type);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (result <= 0) {\n\t\tprintf(\"Pattern[%d] %s result (%d) is not greater than 0.\\n\", pattern_index, type, result);\n\t\treturn 1;\n\t}\n\n\tif (ovector[0] != (PCRE2_SIZE)match_start) {\n\t\tprintf(\"Pattern[%d] %s ovector[0] is unexpected (%d instead of %d)\\n\",\n\t\t\tpattern_index, type, (int)ovector[0], match_start);\n\t\treturn 1;\n\t}\n\n\tif (ovector[1] != (PCRE2_SIZE)match_end) {\n\t\tprintf(\"Pattern[%d] %s ovector[1] is unexpected (%d instead of %d)\\n\",\n\t\t\tpattern_index, type, (int)ovector[1], match_end);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n#endif /* SUPPORT_UNICODE */\n\n#if defined SUPPORT_UNICODE && defined SUPPORT_PCRE2_8\n\n#define UDA (PCRE2_UTF | PCRE2_DOTALL | PCRE2_ANCHORED)\n#define CI (PCRE2_JIT_COMPLETE | PCRE2_JIT_INVALID_UTF)\n#define CPI (PCRE2_JIT_COMPLETE | PCRE2_JIT_PARTIAL_SOFT | PCRE2_JIT_INVALID_UTF)\n\nstruct invalid_utf8_regression_test_case {\n\tint compile_options;\n\tint jit_compile_options;\n\tint start_offset;\n\tint skip_left;\n\tint skip_right;\n\tint match_start;\n\tint match_end;\n\tconst char *pattern[2];\n\tconst char *input;\n};\n\nstatic const char invalid_utf8_newline_cr;\n\nstatic const struct invalid_utf8_regression_test_case invalid_utf8_regression_test_cases[] = {\n\t{ UDA, CI, 0, 0, 0, 0, 4, { \".\", NULL }, \"\\xf4\\x8f\\xbf\\xbf\" },\n\t{ UDA, CI, 0, 0, 0, 0, 4, { \".\", NULL }, \"\\xf0\\x90\\x80\\x80\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xf4\\x90\\x80\\x80\" },\n\t{ UDA, CI, 0, 0, 1, -1, -1, { \".\", NULL }, \"\\xf4\\x8f\\xbf\\xbf\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xf0\\x90\\x80\\x7f\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xf0\\x90\\x80\\xc0\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xf0\\x8f\\xbf\\xbf\" },\n\t{ UDA, CI, 0, 0, 0, 0, 3, { \".\", NULL }, \"\\xef\\xbf\\xbf#\" },\n\t{ UDA, CI, 0, 0, 0, 0, 3, { \".\", NULL }, \"\\xef\\xbf\\xbf\" },\n\t{ UDA, CI, 0, 0, 0, 0, 3, { \".\", NULL }, \"\\xe0\\xa0\\x80#\" },\n\t{ UDA, CI, 0, 0, 0, 0, 3, { \".\", NULL }, \"\\xe0\\xa0\\x80\" },\n\t{ UDA, CI, 0, 0, 2, -1, -1, { \".\", NULL }, \"\\xef\\xbf\\xbf#\" },\n\t{ UDA, CI, 0, 0, 1, -1, -1, { \".\", NULL }, \"\\xef\\xbf\\xbf\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xef\\xbf\\x7f#\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xef\\xbf\\xc0\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xe0\\x9f\\xbf#\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xe0\\x9f\\xbf\" },\n\t{ UDA, CI, 0, 0, 0, 0, 3, { \".\", NULL }, \"\\xed\\x9f\\xbf#\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xed\\xa0\\x80#\" },\n\t{ UDA, CI, 0, 0, 0, 0, 3, { \".\", NULL }, \"\\xee\\x80\\x80#\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xed\\xbf\\xbf#\" },\n\t{ UDA, CI, 0, 0, 0, 0, 2, { \".\", NULL }, \"\\xdf\\xbf##\" },\n\t{ UDA, CI, 0, 0, 0, 0, 2, { \".\", NULL }, \"\\xdf\\xbf#\" },\n\t{ UDA, CI, 0, 0, 0, 0, 2, { \".\", NULL }, \"\\xdf\\xbf\" },\n\t{ UDA, CI, 0, 0, 0, 0, 2, { \".\", NULL }, \"\\xc2\\x80##\" },\n\t{ UDA, CI, 0, 0, 0, 0, 2, { \".\", NULL }, \"\\xc2\\x80#\" },\n\t{ UDA, CI, 0, 0, 0, 0, 2, { \".\", NULL }, \"\\xc2\\x80\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xe0\\x80##\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xdf\\xc0##\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xe0\\x80\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xdf\\xc0\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xc1\\xbf##\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xc1\\xbf\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\x80###\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\x80\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xf8###\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xf8\" },\n\t{ UDA, CI, 0, 0, 0, 0, 1, { \".\", NULL }, \"\\x7f\" },\n\n\t{ UDA, CPI, 4, 0, 0, 4, 4, { \"\\\\B\", NULL }, \"\\xf4\\x8f\\xbf\\xbf#\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xf4\\xa0\\x80\\x80\\xf4\\xa0\\x80\\x80\" },\n\t{ UDA, CPI, 4, 1, 1, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xf4\\x8f\\xbf\\xbf\\xf4\\x8f\\xbf\\xbf\" },\n\t{ UDA, CPI, 4, 0, 0, 4, 4, { \"\\\\B\", NULL }, \"#\\xef\\xbf\\xbf#\" },\n\t{ UDA, CPI, 4, 0, 0, 4, 4, { \"\\\\B\", NULL }, \"#\\xe0\\xa0\\x80#\" },\n\t{ UDA, CPI, 4, 0, 0, 4, 4, { \"\\\\B\", NULL }, \"\\xf0\\x90\\x80\\x80#\" },\n\t{ UDA, CPI, 4, 0, 0, 4, 4, { \"\\\\B\", NULL }, \"\\xf3\\xbf\\xbf\\xbf#\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xf0\\x8f\\xbf\\xbf\\xf0\\x8f\\xbf\\xbf\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xf5\\x80\\x80\\x80\\xf5\\x80\\x80\\x80\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xf4\\x90\\x80\\x80\\xf4\\x90\\x80\\x80\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xf4\\x8f\\xbf\\xff\\xf4\\x8f\\xbf\\xff\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xf4\\x8f\\xff\\xbf\\xf4\\x8f\\xff\\xbf\" },\n\t{ UDA, CPI, 4, 0, 1, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xef\\x80\\x80\\x80\\xef\\x80\\x80\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"#\\xe0\\x9f\\xbf\\xe0\\x9f\\xbf#\" },\n\t{ UDA, CPI, 4, 2, 2, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"#\\xe0\\xa0\\x80\\xe0\\xa0\\x80#\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"#\\xf0\\x80\\x80\\xf0\\x80\\x80#\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"#\\xed\\xa0\\x80\\xed\\xa0\\x80#\" },\n\t{ UDA, CPI, 4, 0, 0, 4, 4, { \"\\\\B\", NULL }, \"##\\xdf\\xbf#\" },\n\t{ UDA, CPI, 4, 2, 0, 2, 2, { \"\\\\B\", NULL }, \"##\\xdf\\xbf#\" },\n\t{ UDA, CPI, 4, 0, 0, 4, 4, { \"\\\\B\", NULL }, \"##\\xc2\\x80#\" },\n\t{ UDA, CPI, 4, 2, 0, 2, 2, { \"\\\\B\", NULL }, \"##\\xc2\\x80#\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"##\\xc1\\xbf\\xc1\\xbf##\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"##\\xdf\\xc0\\xdf\\xc0##\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"##\\xe0\\x80\\xe0\\x80##\" },\n\n\t{ UDA, CPI, 3, 0, 0, 3, 3, { \"\\\\B\", NULL }, \"\\xef\\xbf\\xbf#\" },\n\t{ UDA, CPI, 3, 0, 0, 3, 3, { \"\\\\B\", NULL }, \"\\xe0\\xa0\\x80#\" },\n\t{ UDA, CPI, 3, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xe0\\x9f\\xbf\\xe0\\x9f\\xbf\" },\n\t{ UDA, CPI, 3, 1, 1, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xef\\xbf\\xbf\\xef\\xbf\\xbf\" },\n\t{ UDA, CPI, 3, 0, 1, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xdf\\x80\\x80\\xdf\\x80\" },\n\t{ UDA, CPI, 3, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xef\\xbf\\xff\\xef\\xbf\\xff\" },\n\t{ UDA, CPI, 3, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xef\\xff\\xbf\\xef\\xff\\xbf\" },\n\t{ UDA, CPI, 3, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xed\\xbf\\xbf\\xed\\xbf\\xbf\" },\n\n\t{ UDA, CPI, 2, 0, 0, 2, 2, { \"\\\\B\", NULL }, \"\\xdf\\xbf#\" },\n\t{ UDA, CPI, 2, 0, 0, 2, 2, { \"\\\\B\", NULL }, \"\\xc2\\x80#\" },\n\t{ UDA, CPI, 2, 1, 1, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xdf\\xbf\\xdf\\xbf\" },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xc1\\xbf\\xc1\\xbf\" },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xe0\\x80\\xe0\\x80\" },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xdf\\xff\\xdf\\xff\" },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xff\\xbf\\xff\\xbf\" },\n\n\t{ UDA, CPI, 1, 0, 0, 1, 1, { \"\\\\B\", NULL }, \"\\x7f#\" },\n\t{ UDA, CPI, 1, 0, 0, 1, 1, { \"\\\\B\", NULL }, \"\\x01#\" },\n\t{ UDA, CPI, 1, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\x80\\x80\" },\n\t{ UDA, CPI, 1, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xb0\\xb0\" },\n\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 0, 0, 2, { \"(.)\\\\1\", NULL }, \"aA\" },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 0, -1, -1, { \"(.)\\\\1\", NULL }, \"a\\xff\" },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 0, 0, 4, { \"(.)\\\\1\", NULL }, \"\\xc3\\xa1\\xc3\\x81\" },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 1, -1, -1, { \"(.)\\\\1\", NULL }, \"\\xc3\\xa1\\xc3\\x81\" },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 0, -1, -1, { \"(.)\\\\1\", NULL }, \"\\xc2\\x80\\x80\" },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 0, 0, 6, { \"(.)\\\\1\", NULL }, \"\\xe1\\xbd\\xb8\\xe1\\xbf\\xb8\" },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 1, -1, -1, { \"(.)\\\\1\", NULL }, \"\\xe1\\xbd\\xb8\\xe1\\xbf\\xb8\" },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 0, 0, 8, { \"(.)\\\\1\", NULL }, \"\\xf0\\x90\\x90\\x80\\xf0\\x90\\x90\\xa8\" },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 1, -1, -1, { \"(.)\\\\1\", NULL }, \"\\xf0\\x90\\x90\\x80\\xf0\\x90\\x90\\xa8\" },\n\n\t{ UDA, CPI, 0, 0, 0, 0, 1, { \"\\\\X\", NULL }, \"A\" },\n\t{ UDA, CPI, 0, 0, 0, -1, -1, { \"\\\\X\", NULL }, \"\\xff\" },\n\t{ UDA, CPI, 0, 0, 0, 0, 2, { \"\\\\X\", NULL }, \"\\xc3\\xa1\" },\n\t{ UDA, CPI, 0, 0, 1, -1, -1, { \"\\\\X\", NULL }, \"\\xc3\\xa1\" },\n\t{ UDA, CPI, 0, 0, 0, -1, -1, { \"\\\\X\", NULL }, \"\\xc3\\x7f\" },\n\t{ UDA, CPI, 0, 0, 0, 0, 3, { \"\\\\X\", NULL }, \"\\xe1\\xbd\\xb8\" },\n\t{ UDA, CPI, 0, 0, 1, -1, -1, { \"\\\\X\", NULL }, \"\\xe1\\xbd\\xb8\" },\n\t{ UDA, CPI, 0, 0, 0, 0, 4, { \"\\\\X\", NULL }, \"\\xf0\\x90\\x90\\x80\" },\n\t{ UDA, CPI, 0, 0, 1, -1, -1, { \"\\\\X\", NULL }, \"\\xf0\\x90\\x90\\x80\" },\n\n\t{ UDA, CPI, 0, 0, 0, -1, -1, { \"[^#]\", NULL }, \"#\" },\n\t{ UDA, CPI, 0, 0, 0, 0, 4, { \"[^#]\", NULL }, \"\\xf4\\x8f\\xbf\\xbf\" },\n\t{ UDA, CPI, 0, 0, 0, -1, -1, { \"[^#]\", NULL }, \"\\xf4\\x90\\x80\\x80\" },\n\t{ UDA, CPI, 0, 0, 0, -1, -1, { \"[^#]\", NULL }, \"\\xc1\\x80\" },\n\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 2, 3, { \"^\\\\W\", NULL }, \" \\x0a#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 14, 15, { \"^\\\\W\", NULL }, \" \\xc0\\x8a#\\xe0\\x80\\x8a#\\xf0\\x80\\x80\\x8a#\\x0a#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 3, 4, { \"^\\\\W\", NULL }, \" \\xf8\\x0a#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 3, 4, { \"^\\\\W\", NULL }, \" \\xc3\\x0a#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 3, 4, { \"^\\\\W\", NULL }, \" \\xf1\\x0a#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 4, 5, { \"^\\\\W\", NULL }, \" \\xf2\\xbf\\x0a#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 5, 6, { \"^\\\\W\", NULL }, \" \\xf2\\xbf\\xbf\\x0a#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 3, 4, { \"^\\\\W\", NULL }, \" \\xef\\x0a#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 4, 5, { \"^\\\\W\", NULL }, \" \\xef\\xbf\\x0a#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 5, 6, { \"^\\\\W\", NULL }, \" \\x85#\\xc2\\x85#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 7, 8, { \"^\\\\W\", NULL }, \" \\xe2\\x80\\xf8\\xe2\\x80\\xa8#\"},\n\n\t{ PCRE2_UTF | PCRE2_FIRSTLINE, CI, 0, 0, 0, -1, -1, { \"#\", NULL }, \"\\xe2\\x80\\xf8\\xe2\\x80\\xa8#\"},\n\t{ PCRE2_UTF | PCRE2_FIRSTLINE, CI, 0, 0, 0, 3, 4, { \"#\", NULL }, \"\\xe2\\x80\\xf8#\\xe2\\x80\\xa8#\"},\n\t{ PCRE2_UTF | PCRE2_FIRSTLINE, CI, 0, 0, 0, -1, -1, { \"#\", NULL }, \"abcd\\xc2\\x85#\"},\n\t{ PCRE2_UTF | PCRE2_FIRSTLINE, CI, 0, 0, 0, 1, 2, { \"#\", NULL }, \"\\x85#\\xc2\\x85#\"},\n\t{ PCRE2_UTF | PCRE2_FIRSTLINE, CI, 0, 0, 0, 5, 6, { \"#\", NULL }, \"\\xef,\\x80,\\xf8#\\x0a\"},\n\t{ PCRE2_UTF | PCRE2_FIRSTLINE, CI, 0, 0, 0, -1, -1, { \"#\", NULL }, \"\\xef,\\x80,\\xf8\\x0a#\"},\n\n\t{ PCRE2_UTF | PCRE2_NO_START_OPTIMIZE, CI, 0, 0, 0, 4, 8, { \"#\\xc7\\x85#\", NULL }, \"\\x80\\x80#\\xc7#\\xc7\\x85#\" },\n\t{ PCRE2_UTF | PCRE2_NO_START_OPTIMIZE, CI, 0, 0, 0, 7, 11, { \"#\\xc7\\x85#\", NULL }, \"\\x80\\x80#\\xc7\\x80\\x80\\x80#\\xc7\\x85#\" },\n\t{ PCRE2_UTF, CI, 0, 0, 0, 4, 8, { \"#\\xc7\\x85#\", NULL }, \"\\x80\\x80#\\xc7#\\xc7\\x85#\" },\n\t{ PCRE2_UTF, CI, 0, 0, 0, 7, 11, { \"#\\xc7\\x85#\", NULL }, \"\\x80\\x80#\\xc7\\x80\\x80\\x80#\\xc7\\x85#\" },\n\n\t{ PCRE2_UTF | PCRE2_UCP, CI, 0, 0, 0, -1, -1, { \"[\\\\s]\", NULL }, \"\\xed\\xa0\\x80\" },\n\n\t/* These two are not invalid UTF tests, but this infrastructure fits better for them. */\n\t{ 0, PCRE2_JIT_COMPLETE, 0, 0, 1, -1, -1, { \"\\\\X{2}\", NULL }, \"\\r\\n\\n\" },\n\t{ 0, PCRE2_JIT_COMPLETE, 0, 0, 1, -1, -1, { \"\\\\R{2}\", NULL }, \"\\r\\n\\n\" },\n\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 0, 0, 0, -1, -1, { \"^.a\", &invalid_utf8_newline_cr }, \"\\xc3\\xa7#a\" },\n\n\t{ 0, 0, 0, 0, 0, 0, 0, { NULL, NULL }, NULL }\n};\n\n#undef UDA\n#undef CI\n#undef CPI\n\nstatic int run_invalid_utf8_test(const struct invalid_utf8_regression_test_case *current,\n\tint pattern_index, int i, pcre2_compile_context_8 *ccontext, pcre2_match_data_8 *mdata)\n{\n\tpcre2_code_8 *code;\n\tint result, errorcode;\n\tPCRE2_SIZE length, erroroffset;\n\tPCRE2_SIZE *ovector = pcre2_get_ovector_pointer_8(mdata);\n\n\tif (current->pattern[i] == NULL)\n\t\treturn 1;\n\n\tcode = pcre2_compile_8((PCRE2_UCHAR8*)current->pattern[i], PCRE2_ZERO_TERMINATED,\n\t\tcurrent->compile_options, &errorcode, &erroroffset, ccontext);\n\n\tif (!code) {\n\t\tprintf(\"Pattern[%d:0] cannot be compiled. Error offset: %d\\n\", pattern_index, (int)erroroffset);\n\t\treturn 0;\n\t}\n\n\tif (pcre2_jit_compile_8(code, current->jit_compile_options) != 0) {\n\t\tprintf(\"Pattern[%d:0] cannot be compiled by the JIT compiler.\\n\", pattern_index);\n\t\tpcre2_code_free_8(code);\n\t\treturn 0;\n\t}\n\n\tlength = (PCRE2_SIZE)(strlen(current->input) - current->skip_left - current->skip_right);\n\n\tif (current->jit_compile_options & PCRE2_JIT_COMPLETE) {\n\t\tresult = pcre2_jit_match_8(code, (PCRE2_UCHAR8*)(current->input + current->skip_left),\n\t\t\tlength, current->start_offset - current->skip_left, 0, mdata, NULL);\n\n\t\tif (check_invalid_utf_result(pattern_index, \"match\", result, current->match_start, current->match_end, ovector)) {\n\t\t\tpcre2_code_free_8(code);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (current->jit_compile_options & PCRE2_JIT_PARTIAL_SOFT) {\n\t\tresult = pcre2_jit_match_8(code, (PCRE2_UCHAR8*)(current->input + current->skip_left),\n\t\t\tlength, current->start_offset - current->skip_left, PCRE2_PARTIAL_SOFT, mdata, NULL);\n\n\t\tif (check_invalid_utf_result(pattern_index, \"partial match\", result, current->match_start, current->match_end, ovector)) {\n\t\t\tpcre2_code_free_8(code);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpcre2_code_free_8(code);\n\treturn 1;\n}\n\nstatic int invalid_utf8_regression_tests(void)\n{\n\tconst struct invalid_utf8_regression_test_case *current;\n\tpcre2_compile_context_8 *ccontext;\n\tpcre2_match_data_8 *mdata;\n\tint total = 0, successful = 0;\n\tint result;\n\n\tprintf(\"\\nRunning invalid-utf8 JIT regression tests\\n\");\n\n\tccontext = pcre2_compile_context_create_8(NULL);\n\tpcre2_set_newline_8(ccontext, PCRE2_NEWLINE_ANY);\n\tmdata = pcre2_match_data_create_8(4, NULL);\n\n\tfor (current = invalid_utf8_regression_test_cases; current->pattern[0]; current++) {\n\t\t/* printf(\"\\nPattern: %s :\\n\", current->pattern); */\n\t\ttotal++;\n\n\t\tresult = 1;\n\t\tif (current->pattern[1] != &invalid_utf8_newline_cr)\n\t\t{\n\t\t\tif (!run_invalid_utf8_test(current, total - 1, 0, ccontext, mdata))\n\t\t\t\tresult = 0;\n\t\t\tif (!run_invalid_utf8_test(current, total - 1, 1, ccontext, mdata))\n\t\t\t\tresult = 0;\n\t\t} else {\n\t\t\tpcre2_set_newline_8(ccontext, PCRE2_NEWLINE_CR);\n\t\t\tif (!run_invalid_utf8_test(current, total - 1, 0, ccontext, mdata))\n\t\t\t\tresult = 0;\n\t\t\tpcre2_set_newline_8(ccontext, PCRE2_NEWLINE_ANY);\n\t\t}\n\n\t\tif (result) {\n\t\t\tsuccessful++;\n\t\t}\n\n\t\tprintf(\".\");\n\t\tif ((total % 60) == 0)\n\t\t\tprintf(\"\\n\");\n\t}\n\n\tif ((total % 60) != 0)\n\t\tprintf(\"\\n\");\n\n\tpcre2_match_data_free_8(mdata);\n\tpcre2_compile_context_free_8(ccontext);\n\n\tif (total == successful) {\n\t\tprintf(\"\\nAll invalid UTF8 JIT regression tests are successfully passed.\\n\");\n\t\treturn 0;\n\t} else {\n\t\tprintf(\"\\nInvalid UTF8 successful test ratio: %d%% (%d failed)\\n\", successful * 100 / total, total - successful);\n\t\treturn 1;\n\t}\n}\n\n#else /* !SUPPORT_UNICODE || !SUPPORT_PCRE2_8 */\n\nstatic int invalid_utf8_regression_tests(void)\n{\n\treturn 0;\n}\n\n#endif /* SUPPORT_UNICODE && SUPPORT_PCRE2_8 */\n\n#if defined SUPPORT_UNICODE && defined SUPPORT_PCRE2_16\n\n#define UDA (PCRE2_UTF | PCRE2_DOTALL | PCRE2_ANCHORED)\n#define CI (PCRE2_JIT_COMPLETE | PCRE2_JIT_INVALID_UTF)\n#define CPI (PCRE2_JIT_COMPLETE | PCRE2_JIT_PARTIAL_SOFT | PCRE2_JIT_INVALID_UTF)\n\nstruct invalid_utf16_regression_test_case {\n\tint compile_options;\n\tint jit_compile_options;\n\tint start_offset;\n\tint skip_left;\n\tint skip_right;\n\tint match_start;\n\tint match_end;\n\tconst PCRE2_UCHAR16 *pattern[2];\n\tconst PCRE2_UCHAR16 *input;\n};\n\nstatic PCRE2_UCHAR16 allany16[] = { '.', 0 };\nstatic PCRE2_UCHAR16 non_word_boundary16[] = { '\\\\', 'B', 0 };\nstatic PCRE2_UCHAR16 word_boundary16[] = { '\\\\', 'b', 0 };\nstatic PCRE2_UCHAR16 backreference16[] = { '(', '.', ')', '\\\\', '1', 0 };\nstatic PCRE2_UCHAR16 grapheme16[] = { '\\\\', 'X', 0 };\nstatic PCRE2_UCHAR16 nothashmark16[] = { '[', '^', '#', ']', 0 };\nstatic PCRE2_UCHAR16 afternl16[] = { '^', '\\\\', 'W', 0 };\nstatic PCRE2_UCHAR16 generic16[] = { '#', 0xd800, 0xdc00, '#', 0 };\nstatic PCRE2_UCHAR16 test16_1[] = { 0xd7ff, 0xe000, 0xffff, 0x01, '#', 0 };\nstatic PCRE2_UCHAR16 test16_2[] = { 0xd800, 0xdc00, 0xd800, 0xdc00, 0 };\nstatic PCRE2_UCHAR16 test16_3[] = { 0xdbff, 0xdfff, 0xdbff, 0xdfff, 0 };\nstatic PCRE2_UCHAR16 test16_4[] = { 0xd800, 0xdbff, 0xd800, 0xdbff, 0 };\nstatic PCRE2_UCHAR16 test16_5[] = { '#', 0xd800, 0xdc00, '#', 0 };\nstatic PCRE2_UCHAR16 test16_6[] = { 'a', 'A', 0xdc28, 0 };\nstatic PCRE2_UCHAR16 test16_7[] = { 0xd801, 0xdc00, 0xd801, 0xdc28, 0 };\nstatic PCRE2_UCHAR16 test16_8[] = { '#', 0xd800, 0xdc00, 0 };\nstatic PCRE2_UCHAR16 test16_9[] = { ' ', 0x2028, '#', 0 };\nstatic PCRE2_UCHAR16 test16_10[] = { ' ', 0xdc00, 0xd800, 0x2028, '#', 0 };\nstatic PCRE2_UCHAR16 test16_11[] = { 0xdc00, 0xdc00, 0xd800, 0xdc00, 0xdc00, '#', 0xd800, 0xdc00, '#', 0 };\nstatic PCRE2_UCHAR16 test16_12[] = { '#', 0xd800, 0xdc00, 0xd800, '#', 0xd800, 0xdc00, 0xdc00, 0xdc00, '#', 0xd800, 0xdc00, '#', 0 };\n\nstatic const struct invalid_utf16_regression_test_case invalid_utf16_regression_test_cases[] = {\n\t{ UDA, CI, 0, 0, 0, 0, 1, { allany16, NULL }, test16_1 },\n\t{ UDA, CI, 1, 0, 0, 1, 2, { allany16, NULL }, test16_1 },\n\t{ UDA, CI, 2, 0, 0, 2, 3, { allany16, NULL }, test16_1 },\n\t{ UDA, CI, 3, 0, 0, 3, 4, { allany16, NULL }, test16_1 },\n\t{ UDA, CI, 0, 0, 0, 0, 2, { allany16, NULL }, test16_2 },\n\t{ UDA, CI, 0, 0, 3, -1, -1, { allany16, NULL }, test16_2 },\n\t{ UDA, CI, 1, 0, 0, -1, -1, { allany16, NULL }, test16_2 },\n\t{ UDA, CI, 0, 0, 0, 0, 2, { allany16, NULL }, test16_3 },\n\t{ UDA, CI, 0, 0, 3, -1, -1, { allany16, NULL }, test16_3 },\n\t{ UDA, CI, 1, 0, 0, -1, -1, { allany16, NULL }, test16_3 },\n\n\t{ UDA, CPI, 1, 0, 0, 1, 1, { non_word_boundary16, NULL }, test16_1 },\n\t{ UDA, CPI, 2, 0, 0, 2, 2, { non_word_boundary16, NULL }, test16_1 },\n\t{ UDA, CPI, 3, 0, 0, 3, 3, { non_word_boundary16, NULL }, test16_1 },\n\t{ UDA, CPI, 4, 0, 0, 4, 4, { non_word_boundary16, NULL }, test16_1 },\n\t{ UDA, CPI, 2, 0, 0, 2, 2, { non_word_boundary16, NULL }, test16_2 },\n\t{ UDA, CPI, 2, 0, 0, 2, 2, { non_word_boundary16, NULL }, test16_3 },\n\t{ UDA, CPI, 2, 1, 1, -1, -1, { non_word_boundary16, word_boundary16 }, test16_2 },\n\t{ UDA, CPI, 2, 1, 1, -1, -1, { non_word_boundary16, word_boundary16 }, test16_3 },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { non_word_boundary16, word_boundary16 }, test16_4 },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { non_word_boundary16, word_boundary16 }, test16_5 },\n\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 0, 0, 2, { backreference16, NULL }, test16_6 },\n\t{ UDA | PCRE2_CASELESS, CPI, 1, 0, 0, -1, -1, { backreference16, NULL }, test16_6 },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 0, 0, 4, { backreference16, NULL }, test16_7 },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 1, -1, -1, { backreference16, NULL }, test16_7 },\n\n\t{ UDA, CPI, 0, 0, 0, 0, 1, { grapheme16, NULL }, test16_6 },\n\t{ UDA, CPI, 1, 0, 0, 1, 2, { grapheme16, NULL }, test16_6 },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { grapheme16, NULL }, test16_6 },\n\t{ UDA, CPI, 0, 0, 0, 0, 2, { grapheme16, NULL }, test16_7 },\n\t{ UDA, CPI, 2, 0, 0, 2, 4, { grapheme16, NULL }, test16_7 },\n\t{ UDA, CPI, 1, 0, 0, -1, -1, { grapheme16, NULL }, test16_7 },\n\n\t{ UDA, CPI, 0, 0, 0, -1, -1, { nothashmark16, NULL }, test16_8 },\n\t{ UDA, CPI, 1, 0, 0, 1, 3, { nothashmark16, NULL }, test16_8 },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { nothashmark16, NULL }, test16_8 },\n\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 2, 3, { afternl16, NULL }, test16_9 },\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 4, 5, { afternl16, NULL }, test16_10 },\n\n\t{ PCRE2_UTF | PCRE2_NO_START_OPTIMIZE, CI, 0, 0, 0, 5, 9, { generic16, NULL }, test16_11 },\n\t{ PCRE2_UTF | PCRE2_NO_START_OPTIMIZE, CI, 0, 0, 0, 9, 13, { generic16, NULL }, test16_12 },\n\t{ PCRE2_UTF, CI, 0, 0, 0, 5, 9, { generic16, NULL }, test16_11 },\n\t{ PCRE2_UTF, CI, 0, 0, 0, 9, 13, { generic16, NULL }, test16_12 },\n\n\t{ 0, 0, 0, 0, 0, 0, 0, { NULL, NULL }, NULL }\n};\n\n#undef UDA\n#undef CI\n#undef CPI\n\nstatic int run_invalid_utf16_test(const struct invalid_utf16_regression_test_case *current,\n\tint pattern_index, int i, pcre2_compile_context_16 *ccontext, pcre2_match_data_16 *mdata)\n{\n\tpcre2_code_16 *code;\n\tint result, errorcode;\n\tPCRE2_SIZE length, erroroffset;\n\tconst PCRE2_UCHAR16 *input;\n\tPCRE2_SIZE *ovector = pcre2_get_ovector_pointer_16(mdata);\n\n\tif (current->pattern[i] == NULL)\n\t\treturn 1;\n\n\tcode = pcre2_compile_16(current->pattern[i], PCRE2_ZERO_TERMINATED,\n\t\tcurrent->compile_options, &errorcode, &erroroffset, ccontext);\n\n\tif (!code) {\n\t\tprintf(\"Pattern[%d:0] cannot be compiled. Error offset: %d\\n\", pattern_index, (int)erroroffset);\n\t\treturn 0;\n\t}\n\n\tif (pcre2_jit_compile_16(code, current->jit_compile_options) != 0) {\n\t\tprintf(\"Pattern[%d:0] cannot be compiled by the JIT compiler.\\n\", pattern_index);\n\t\tpcre2_code_free_16(code);\n\t\treturn 0;\n\t}\n\n\tinput = current->input;\n\tlength = 0;\n\n\twhile (*input++ != 0)\n\t\tlength++;\n\n\tlength -= current->skip_left + current->skip_right;\n\n\tif (current->jit_compile_options & PCRE2_JIT_COMPLETE) {\n\t\tresult = pcre2_jit_match_16(code, (current->input + current->skip_left),\n\t\t\tlength, current->start_offset - current->skip_left, 0, mdata, NULL);\n\n\t\tif (check_invalid_utf_result(pattern_index, \"match\", result, current->match_start, current->match_end, ovector)) {\n\t\t\tpcre2_code_free_16(code);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (current->jit_compile_options & PCRE2_JIT_PARTIAL_SOFT) {\n\t\tresult = pcre2_jit_match_16(code, (current->input + current->skip_left),\n\t\t\tlength, current->start_offset - current->skip_left, PCRE2_PARTIAL_SOFT, mdata, NULL);\n\n\t\tif (check_invalid_utf_result(pattern_index, \"partial match\", result, current->match_start, current->match_end, ovector)) {\n\t\t\tpcre2_code_free_16(code);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpcre2_code_free_16(code);\n\treturn 1;\n}\n\nstatic int invalid_utf16_regression_tests(void)\n{\n\tconst struct invalid_utf16_regression_test_case *current;\n\tpcre2_compile_context_16 *ccontext;\n\tpcre2_match_data_16 *mdata;\n\tint total = 0, successful = 0;\n\tint result;\n\n\tprintf(\"\\nRunning invalid-utf16 JIT regression tests\\n\");\n\n\tccontext = pcre2_compile_context_create_16(NULL);\n\tpcre2_set_newline_16(ccontext, PCRE2_NEWLINE_ANY);\n\tmdata = pcre2_match_data_create_16(4, NULL);\n\n\tfor (current = invalid_utf16_regression_test_cases; current->pattern[0]; current++) {\n\t\t/* printf(\"\\nPattern: %s :\\n\", current->pattern); */\n\t\ttotal++;\n\n\t\tresult = 1;\n\t\tif (!run_invalid_utf16_test(current, total - 1, 0, ccontext, mdata))\n\t\t\tresult = 0;\n\t\tif (!run_invalid_utf16_test(current, total - 1, 1, ccontext, mdata))\n\t\t\tresult = 0;\n\n\t\tif (result) {\n\t\t\tsuccessful++;\n\t\t}\n\n\t\tprintf(\".\");\n\t\tif ((total % 60) == 0)\n\t\t\tprintf(\"\\n\");\n\t}\n\n\tif ((total % 60) != 0)\n\t\tprintf(\"\\n\");\n\n\tpcre2_match_data_free_16(mdata);\n\tpcre2_compile_context_free_16(ccontext);\n\n\tif (total == successful) {\n\t\tprintf(\"\\nAll invalid UTF16 JIT regression tests are successfully passed.\\n\");\n\t\treturn 0;\n\t} else {\n\t\tprintf(\"\\nInvalid UTF16 successful test ratio: %d%% (%d failed)\\n\", successful * 100 / total, total - successful);\n\t\treturn 1;\n\t}\n}\n\n#else /* !SUPPORT_UNICODE || !SUPPORT_PCRE2_16 */\n\nstatic int invalid_utf16_regression_tests(void)\n{\n\treturn 0;\n}\n\n#endif /* SUPPORT_UNICODE && SUPPORT_PCRE2_16 */\n\n#if defined SUPPORT_UNICODE && defined SUPPORT_PCRE2_32\n\n#define UDA (PCRE2_UTF | PCRE2_DOTALL | PCRE2_ANCHORED)\n#define CI (PCRE2_JIT_COMPLETE | PCRE2_JIT_INVALID_UTF)\n#define CPI (PCRE2_JIT_COMPLETE | PCRE2_JIT_PARTIAL_SOFT | PCRE2_JIT_INVALID_UTF)\n\nstruct invalid_utf32_regression_test_case {\n\tint compile_options;\n\tint jit_compile_options;\n\tint start_offset;\n\tint skip_left;\n\tint skip_right;\n\tint match_start;\n\tint match_end;\n\tconst PCRE2_UCHAR32 *pattern[2];\n\tconst PCRE2_UCHAR32 *input;\n};\n\nstatic PCRE2_UCHAR32 allany32[] = { '.', 0 };\nstatic PCRE2_UCHAR32 non_word_boundary32[] = { '\\\\', 'B', 0 };\nstatic PCRE2_UCHAR32 word_boundary32[] = { '\\\\', 'b', 0 };\nstatic PCRE2_UCHAR32 backreference32[] = { '(', '.', ')', '\\\\', '1', 0 };\nstatic PCRE2_UCHAR32 grapheme32[] = { '\\\\', 'X', 0 };\nstatic PCRE2_UCHAR32 nothashmark32[] = { '[', '^', '#', ']', 0 };\nstatic PCRE2_UCHAR32 afternl32[] = { '^', '\\\\', 'W', 0 };\nstatic PCRE2_UCHAR32 test32_1[] = { 0x10ffff, 0x10ffff, 0x110000, 0x110000, 0x10ffff, 0 };\nstatic PCRE2_UCHAR32 test32_2[] = { 0xd7ff, 0xe000, 0xd800, 0xdfff, 0xe000, 0xdfff, 0xd800, 0 };\nstatic PCRE2_UCHAR32 test32_3[] = { 'a', 'A', 0x110000, 0 };\nstatic PCRE2_UCHAR32 test32_4[] = { '#', 0x10ffff, 0x110000, 0 };\nstatic PCRE2_UCHAR32 test32_5[] = { ' ', 0x2028, '#', 0 };\nstatic PCRE2_UCHAR32 test32_6[] = { ' ', 0x110000, 0x2028, '#', 0 };\n\nstatic const struct invalid_utf32_regression_test_case invalid_utf32_regression_test_cases[] = {\n\t{ UDA, CI, 0, 0, 0, 0, 1, { allany32, NULL }, test32_1 },\n\t{ UDA, CI, 2, 0, 0, -1, -1, { allany32, NULL }, test32_1 },\n\t{ UDA, CI, 0, 0, 0, 0, 1, { allany32, NULL }, test32_2 },\n\t{ UDA, CI, 1, 0, 0, 1, 2, { allany32, NULL }, test32_2 },\n\t{ UDA, CI, 2, 0, 0, -1, -1, { allany32, NULL }, test32_2 },\n\t{ UDA, CI, 3, 0, 0, -1, -1, { allany32, NULL }, test32_2 },\n\n\t{ UDA, CPI, 1, 0, 0, 1, 1, { non_word_boundary32, NULL }, test32_1 },\n\t{ UDA, CPI, 3, 0, 0, -1, -1, { non_word_boundary32, word_boundary32 }, test32_1 },\n\t{ UDA, CPI, 1, 0, 0, 1, 1, { non_word_boundary32, NULL }, test32_2 },\n\t{ UDA, CPI, 3, 0, 0, -1, -1, { non_word_boundary32, word_boundary32 }, test32_2 },\n\t{ UDA, CPI, 6, 0, 0, -1, -1, { non_word_boundary32, word_boundary32 }, test32_2 },\n\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 0, 0, 2, { backreference32, NULL }, test32_3 },\n\t{ UDA | PCRE2_CASELESS, CPI, 1, 0, 0, -1, -1, { backreference32, NULL }, test32_3 },\n\n\t{ UDA, CPI, 0, 0, 0, 0, 1, { grapheme32, NULL }, test32_1 },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { grapheme32, NULL }, test32_1 },\n\t{ UDA, CPI, 1, 0, 0, 1, 2, { grapheme32, NULL }, test32_2 },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { grapheme32, NULL }, test32_2 },\n\t{ UDA, CPI, 3, 0, 0, -1, -1, { grapheme32, NULL }, test32_2 },\n\t{ UDA, CPI, 4, 0, 0, 4, 5, { grapheme32, NULL }, test32_2 },\n\n\t{ UDA, CPI, 0, 0, 0, -1, -1, { nothashmark32, NULL }, test32_4 },\n\t{ UDA, CPI, 1, 0, 0, 1, 2, { nothashmark32, NULL }, test32_4 },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { nothashmark32, NULL }, test32_4 },\n\t{ UDA, CPI, 1, 0, 0, 1, 2, { nothashmark32, NULL }, test32_2 },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { nothashmark32, NULL }, test32_2 },\n\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 2, 3, { afternl32, NULL }, test32_5 },\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 3, 4, { afternl32, NULL }, test32_6 },\n\n\t{ 0, 0, 0, 0, 0, 0, 0, { NULL, NULL }, NULL }\n};\n\n#undef UDA\n#undef CI\n#undef CPI\n\nstatic int run_invalid_utf32_test(const struct invalid_utf32_regression_test_case *current,\n\tint pattern_index, int i, pcre2_compile_context_32 *ccontext, pcre2_match_data_32 *mdata)\n{\n\tpcre2_code_32 *code;\n\tint result, errorcode;\n\tPCRE2_SIZE length, erroroffset;\n\tconst PCRE2_UCHAR32 *input;\n\tPCRE2_SIZE *ovector = pcre2_get_ovector_pointer_32(mdata);\n\n\tif (current->pattern[i] == NULL)\n\t\treturn 1;\n\n\tcode = pcre2_compile_32(current->pattern[i], PCRE2_ZERO_TERMINATED,\n\t\tcurrent->compile_options, &errorcode, &erroroffset, ccontext);\n\n\tif (!code) {\n\t\tprintf(\"Pattern[%d:0] cannot be compiled. Error offset: %d\\n\", pattern_index, (int)erroroffset);\n\t\treturn 0;\n\t}\n\n\tif (pcre2_jit_compile_32(code, current->jit_compile_options) != 0) {\n\t\tprintf(\"Pattern[%d:0] cannot be compiled by the JIT compiler.\\n\", pattern_index);\n\t\tpcre2_code_free_32(code);\n\t\treturn 0;\n\t}\n\n\tinput = current->input;\n\tlength = 0;\n\n\twhile (*input++ != 0)\n\t\tlength++;\n\n\tlength -= current->skip_left + current->skip_right;\n\n\tif (current->jit_compile_options & PCRE2_JIT_COMPLETE) {\n\t\tresult = pcre2_jit_match_32(code, (current->input + current->skip_left),\n\t\t\tlength, current->start_offset - current->skip_left, 0, mdata, NULL);\n\n\t\tif (check_invalid_utf_result(pattern_index, \"match\", result, current->match_start, current->match_end, ovector)) {\n\t\t\tpcre2_code_free_32(code);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (current->jit_compile_options & PCRE2_JIT_PARTIAL_SOFT) {\n\t\tresult = pcre2_jit_match_32(code, (current->input + current->skip_left),\n\t\t\tlength, current->start_offset - current->skip_left, PCRE2_PARTIAL_SOFT, mdata, NULL);\n\n\t\tif (check_invalid_utf_result(pattern_index, \"partial match\", result, current->match_start, current->match_end, ovector)) {\n\t\t\tpcre2_code_free_32(code);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpcre2_code_free_32(code);\n\treturn 1;\n}\n\nstatic int invalid_utf32_regression_tests(void)\n{\n\tconst struct invalid_utf32_regression_test_case *current;\n\tpcre2_compile_context_32 *ccontext;\n\tpcre2_match_data_32 *mdata;\n\tint total = 0, successful = 0;\n\tint result;\n\n\tprintf(\"\\nRunning invalid-utf32 JIT regression tests\\n\");\n\n\tccontext = pcre2_compile_context_create_32(NULL);\n\tpcre2_set_newline_32(ccontext, PCRE2_NEWLINE_ANY);\n\tmdata = pcre2_match_data_create_32(4, NULL);\n\n\tfor (current = invalid_utf32_regression_test_cases; current->pattern[0]; current++) {\n\t\t/* printf(\"\\nPattern: %s :\\n\", current->pattern); */\n\t\ttotal++;\n\n\t\tresult = 1;\n\t\tif (!run_invalid_utf32_test(current, total - 1, 0, ccontext, mdata))\n\t\t\tresult = 0;\n\t\tif (!run_invalid_utf32_test(current, total - 1, 1, ccontext, mdata))\n\t\t\tresult = 0;\n\n\t\tif (result) {\n\t\t\tsuccessful++;\n\t\t}\n\n\t\tprintf(\".\");\n\t\tif ((total % 60) == 0)\n\t\t\tprintf(\"\\n\");\n\t}\n\n\tif ((total % 60) != 0)\n\t\tprintf(\"\\n\");\n\n\tpcre2_match_data_free_32(mdata);\n\tpcre2_compile_context_free_32(ccontext);\n\n\tif (total == successful) {\n\t\tprintf(\"\\nAll invalid UTF32 JIT regression tests are successfully passed.\\n\");\n\t\treturn 0;\n\t} else {\n\t\tprintf(\"\\nInvalid UTF32 successful test ratio: %d%% (%d failed)\\n\", successful * 100 / total, total - successful);\n\t\treturn 1;\n\t}\n}\n\n#else /* !SUPPORT_UNICODE || !SUPPORT_PCRE2_32 */\n\nstatic int invalid_utf32_regression_tests(void)\n{\n\treturn 0;\n}\n\n#endif /* SUPPORT_UNICODE && SUPPORT_PCRE2_32 */\n\n/* End of pcre2_jit_test.c */\n"], "fixing_code": ["Change Log for PCRE2\n--------------------\n\n\nVersion 10.40-RC1 xx-xxx-2021\n-----------------------------\n\n1. Merged patch from @carenas (GitHub #35, 7db87842) to fix pcre2grep incorrect\nhandling of multiple passes.\n\n2. Merged patch from @carenas (GitHub #36, dae47509) to fix portability issue\nin pcre2grep with buffered fseek(stdin).\n\n3. Merged patch from @carenas (GitHub #37, acc520924) to fix tests when -S is\nnot supported.\n\n4. Revert an unintended change in JIT repeat detection.\n\n5. Merged patch from @carenas (GitHub #52, b037bfa1) to fix build on GNU Hurd.\n\n6. Merged documentation and comments patches from @carenas (GitHub #47).\n\n7. Merged patch from @carenas (GitHub #49) to remove obsolete JFriedl test code\nfrom pcre2grep.\n\n8. Merged patch from @carenas (GitHub #48) to fix CMake install issue #46.\n\n9. Merged patch from @carenas (GitHub #53) fixing NULL checks in matching and\nsubstituting.\n\n10. Add null_subject and null_replacement modifiers to pcre2test.\n\n11. Add check for NULL subject to POSIX regexec() function.\n\n12. Add check for NULL replacement to pcre2_substitute().\n\n13. For the subject arguments of pcre2_match(), pcre2_dfa_match(), and\npcre2_substitute(), and the replacement argument of the latter, if the pointer\nis NULL and the length is zero, treat as an empty string. Apparently a number\nof applications treat NULL/0 in this way.\n\n14. Added support for Bidi_Class and a number of binary Unicode properties, \nincluding Bidi_Control. \n\n15. Fix some minor issues raised by clang sanitize.\n\n16. Very minor code speed up for maximizing character property matches.\n\n17. A number of changes to script matching for \\p and \\P:\n\n    (a) Script extensions for a character are now coded as a bitmap instead of\n        a list of script numbers, which should be faster and does not need a\n        loop.\n\n    (b) Added the syntax \\p{script:xxx} and \\p{script_extensions:xxx} (synonyms\n        sc and scx).\n\n    (c) Changed \\p{scriptname} from being the same as \\p{sc:scriptname} to being\n        the same as \\p{scx:scriptname} because this change happened in Perl at\n        release 5.26.\n        \n    (d) The standard Unicode 4-letter abbreviations for script names are now \n        recognized.\n        \n    (e) In accordance with Unicode and Perl's \"loose matching\" rules, spaces,\n        hyphens, and underscores are ignored in property names, which are then \n        matched independent of case. \n\n18. The Python scripts in the maint directory have been refactored. There are\nnow three scripts that generate pcre2_ucd.c, pcre2_ucp.h, and pcre2_ucptables.c\n(which is #included by pcre2_tables.c). The data lists that used to be\nduplicated are now held in a single common Python module.\n\n19. On CHERI, and thus Arm's Morello prototype, pointers are represented as\nhardware capabilities, which consist of both an integer address and additional\nmetadata, meaning they are twice the size of the platform's size_t type, i.e.\n16 bytes on a 64-bit system. The ovector member of heapframe happens to only be\n8 byte aligned, and so computing frame_size ended up with a multiple of 8 but\nnot 16. Whilst the first frame was always suitably aligned, this then\nmisaligned the frame that follows, resulting in an alignment fault when storing\na pointer to Fecode at the start of match. Patch to fix this issue by Jessica\nClarke PR#72.\n\n20. Added -LP and -LS listing options to pcre2test.\n\n21. A user discovered that the library names in CMakeLists.txt for MSVC \ndebugger (PDB) files were incorrect - perhaps never tried for PCRE2?\n\n22. An item such as [Aa] is optimized into a caseless single character match.\nWhen this was quantified (e.g. [Aa]{2}) and was also the last literal item in a\npattern, the optimizing \"must be present for a match\" character check was not\nbeing flagged as caseless, causing some matches that should have succeeded to\nfail.\n\n23. Fixed a unicode properrty matching issue in JIT. The character was not\nfully read in caseless matching.\n\n24. Fixed an issue affecting recursions in JIT caused by duplicated data\ntransfers.\n\n\nVersion 10.39 29-October-2021\n-----------------------------\n\n1. Fix incorrect detection of alternatives in first character search in JIT.\n\n2. Merged patch from @carenas (GitHub #28):\n\n  Visual Studio 2013 includes support for %zu and %td, so let newer\n  versions of it avoid the fallback, and while at it, make sure that\n  the first check is for DISABLE_PERCENT_ZT so it will be always\n  honoured if chosen.\n\n  prtdiff_t is signed, so use a signed type instead, and make sure\n  that an appropiate width is chosen if pointers are 64bit wide and\n  long is not (ex: Windows 64bit).\n\n  IMHO removing the cast (and therefore the positibilty of truncation)\n  make the code cleaner and the fallback is likely portable enough\n  with all 64-bit POSIX systems doing LP64 except for Windows.\n\n3. Merged patch from @carenas (GitHub #29) to update to Unicode 14.0.0.\n\n4. Merged patch from @carenas (GitHub #30):\n\n  * Cleanup: remove references to no longer used stdint.h\n\n  Since 19c50b9d (Unconditionally use inttypes.h instead of trying for stdint.h\n  (simplification) and remove the now unnecessary inclusion in\n  pcre2_internal.h., 2018-11-14), stdint.h is no longer used.\n\n  Remove checks for it in autotools and CMake and document better the expected\n  build failures for systems that might have stdint.h (C99) and not inttypes.h\n  (from POSIX), like old Windows.\n\n  * Cleanup: remove detection for inttypes.h which is a hard dependency\n\n  CMake checks for standard headers are not meant to be used for hard\n  dependencies, so will prevent a possible fallback to work.\n\n  Alternatively, the header could be checked to make the configuration fail\n  instead of breaking the build, but that was punted, as it was missing anyway\n  from autotools.\n\n5. Merged patch from @carenas (GitHub #32):\n\n  * jit: allow building with ancient MSVC versions\n\n  Visual Studio older than 2013 fails to build with JIT enabled, because it is\n  unable to parse non C89 compatible syntax, with mixed declarations and code.\n  While most recent compilers wouldn't even report this as a warning since it\n  is valid C99, it could be also made visible by adding to gcc/clang the\n  -Wdeclaration-after-statement flag at build time.\n\n  Move the code below the affected definitions.\n\n  * pcre2grep: avoid mixing declarations with code\n\n  Since d5a61ee8 (Patch to detect (and ignore) symlink loops in pcre2grep,\n  2021-08-28), code will fail to build in a strict C89 compiler.\n\n  Reformat slightly to make it C89 compatible again.\n\n\nVersion 10.38 01-October-2021\n-----------------------------\n\n1. Fix invalid single character repetition issues in JIT when the repetition\nis inside a capturing bracket and the bracket is preceeded by character\nliterals.\n\n2. Installed revised CMake configuration files provided by Jan-Willem Blokland.\nThis extends the CMake build system to build both static and shared libraries\nin one go, builds the static library with PIC, and exposes PCRE2 libraries\nusing the CMake config files. JWB provided these notes:\n\n- Introduced CMake variable BUILD_STATIC_LIBS to build the static library.\n\n- Make a small modification to config-cmake.h.in by removing the PCRE2_STATIC\n  variable. Added PCRE2_STATIC variable to the static build using the\n  target_compile_definitions() function.\n\n- Extended the CMake config files.\n\n  - Introduced CMake variable PCRE2_USE_STATIC_LIBS to easily switch between\n    the static and shared libraries.\n\n  - Added the PCRE_STATIC variable to the target compile definitions for the\n    import of the static library.\n\nBuilding static and shared libraries using MSVC results in a name clash of\nthe libraries. Both static and shared library builds create, for example, the\nfile pcre2-8.lib. Therefore, I decided to change the static library names by\nadding \"-static\". For example, pcre2-8.lib has become pcre2-8-static.lib.\n[Comment by PH: this is MSVC-specific. It doesn't happen on Linux.]\n\n3. Increased the minimum release number for CMake to 3.0.0 because older than\n2.8.12 is deprecated (it was set to 2.8.5) and causes warnings. Even 3.0.0 is\nquite old; it was released in 2014.\n\n4. Implemented a modified version of Thomas Tempelmann's pcre2grep patch for\ndetecting symlink loops. This is dependent on the availability of realpath(),\nwhich is now tested for in ./configure and CMakeLists.txt.\n\n5. Implemented a modified version of Thomas Tempelmann's patch for faster\ncase-independent \"first code unit\" searches for unanchored patterns in 8-bit\nmode in the interpreters. Instead of just remembering whether one case matched\nor not, it remembers the position of a previous match so as to avoid\nunnecessary repeated searching.\n\n6. Perl now locks out \\K in lookarounds, so PCRE2 now does the same by default.\nHowever, just in case anybody was relying on the old behaviour, there is an\noption called PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK that enables the old behaviour.\nAn option has also been added to pcre2grep to enable this.\n\n7. Re-enable a JIT optimization which was unintentionally disabled in 10.35.\n\n8. There is a loop counter to catch excessively crazy patterns when checking\nthe lengths of lookbehinds at compile time. This was incorrectly getting reset\nwhenever a lookahead was processed, leading to some fuzzer-generated patterns\ntaking a very long time to compile when (?|) was present in the pattern,\nbecause (?|) disables caching of group lengths.\n\n\nVersion 10.37 26-May-2021\n-------------------------\n\n1. Change RunGrepTest to use tr instead of sed when testing with binary\nzero bytes, because sed varies a lot from system to system and has problems\nwith binary zeros. This is from Bugzilla #2681. Patch from Jeremie\nCourreges-Anglas via Nam Nguyen. This fixes RunGrepTest for OpenBSD. Later:\nit broke it for at least one version of Solaris, where tr can't handle binary\nzeros. However, that system had /usr/xpg4/bin/tr installed, which works OK, so\nRunGrepTest now checks for that command and uses it if found.\n\n2. Compiling with gcc 10.2's -fanalyzer option showed up a hypothetical problem\nwith a NULL dereference. I don't think this case could ever occur in practice,\nbut I have put in a check in order to get rid of the compiler error.\n\n3. An alternative patch for CMakeLists.txt because 10.36 #4 breaks CMake on\nWindows. Patch from email@cs-ware.de fixes bugzilla #2688.\n\n4. Two bugs related to over-large numbers have been fixed so the behaviour is\nnow the same as Perl.\n\n  (a) A pattern such as /\\214748364/ gave an overflow error instead of being\n  treated as the octal number \\214 followed by literal digits.\n\n  (b) A sequence such as {65536 that has no terminating } so is not a\n  quantifier was nevertheless complaining that a quantifier number was too big.\n\n5. A run of autoconf suggested that configure.ac was out-of-date with respect\nto the lastest autoconf. Running autoupdate made some valid changes, some valid\nsuggestions, and also some invalid changes, which were fixed by hand. Autoconf\nnow runs clean and the resulting \"configure\" seems to work, so I hope nothing\nis broken. Later: the requirement for autoconf 2.70 broke some automatic test\nrobots. It doesn't seem to be necessary: trying a reduction to 2.60.\n\n6. The pattern /a\\K.(?0)*/ when matched against \"abac\" by the interpreter gave\nthe answer \"bac\", whereas Perl and JIT both yield \"c\". This was because the\neffect of \\K was not propagating back from the full pattern recursion. Other\nrecursions such as /(a\\K.(?1)*)/ did not have this problem.\n\n7. Restore single character repetition optimization in JIT. Currently fewer\ncharacter repetitions are optimized than in 10.34.\n\n8. When the names of the functions in the POSIX wrapper were changed to\npcre2_regcomp() etc. (see change 10.33 #4 below), functions with the original\nnames were left in the library so that pre-compiled programs would still work.\nHowever, this has proved troublesome when programs link with several libraries,\nsome of which use PCRE2 via the POSIX interface while others use a native POSIX\nlibrary. For this reason, the POSIX function names are removed in this release.\nThe macros in pcre2posix.h should ensure that re-compiling fixes any programs\nthat haven't been compiled since before 10.33.\n\n\nVersion 10.36 04-December-2020\n------------------------------\n\n1. Add CET_CFLAGS so that when Intel CET is enabled, pass -mshstk to\ncompiler. This fixes https://bugs.exim.org/show_bug.cgi?id=2578. Patch for\nMakefile.am and configure.ac by H.J. Lu. Equivalent patch for CMakeLists.txt\ninvented by PH.\n\n2. Fix inifinite loop when a single byte newline is searched in JIT when\ninvalid utf8 mode is enabled.\n\n3. Updated CMakeLists.txt with patch from Wolfgang St\u00f6ggl (Bugzilla #2584):\n\n  - Include GNUInstallDirs and use ${CMAKE_INSTALL_LIBDIR} instead of hardcoded\n    lib. This allows differentiation between lib and lib64.\n    CMAKE_INSTALL_LIBDIR is used for installation of libraries and also for\n    pkgconfig file generation.\n\n  - Add the version of PCRE2 to the configuration summary like ./configure\n    does.\n\n  - Fix typo: MACTHED_STRING->MATCHED_STRING\n\n4. Updated CMakeLists.txt with another patch from Wolfgang St\u00f6ggl (Bugzilla\n#2588):\n\n  - Add escaped double quotes around include directory in CMakeLists.txt to\n    allow spaces in directory names.\n\n  - This fixes a cmake error, if the path of the pcre2 source contains a space.\n\n5. Updated CMakeLists.txt with a patch from B. Scott Michel: CMake's\ndocumentation suggests using CHECK_SYMBOL_EXISTS over CHECK_FUNCTION_EXIST.\nMoreover, these functions come from specific header files, which need to be\nspecified (and, thankfully, are the same on both the Linux and WinXX\nplatforms.)\n\n6. Added a (uint32_t) cast to prevent a compiler warning in pcre2_compile.c.\n\n7. Applied a patch from Wolfgang St\u00f6ggl (Bugzilla #2600) to fix postfix for\ndebug Windows builds using CMake. This also updated configure so that it\ngenerates *.pc files and pcre2-config with the same content, as in the past.\n\n8. If a pattern ended with (?(VERSION=n.d where n is any number but d is just a\nsingle digit, the code unit beyond d was being read (i.e. there was a read\nbuffer overflow). Fixes ClusterFuzz 23779.\n\n9. After the rework in r1235, certain character ranges were incorrectly\nhandled by an optimization in JIT. Furthermore a wrong offset was used to\nread a value from a buffer which could lead to memory overread.\n\n10. Unnoticed for many years was the fact that delimiters other than / in the\ntestinput1 and testinput4 files could cause incorrect behaviour when these\nfiles were processed by perltest.sh. There were several tests that used quotes\nas delimiters, and it was just luck that they didn't go wrong with perltest.sh.\nAll the patterns in testinput1 and testinput4 now use / as their delimiter.\nThis fixes Bugzilla #2641.\n\n11. Perl has started to give an error for \\K within lookarounds (though there\nare cases where it doesn't). PCRE2 still allows this, so the tests that include\nthis case have been moved from test 1 to test 2.\n\n12. Further to 10 above, pcre2test has been updated to detect and grumble if a\ndelimiter other than / is used after #perltest.\n\n13. Fixed a bug with PCRE2_MATCH_INVALID_UTF in 8-bit mode when PCRE2_CASELESS\nwas set and PCRE2_NO_START_OPTIMIZE was not set. The optimization for finding\nthe start of a match was not resetting correctly after a failed match on the\nfirst valid fragment of the subject, possibly causing incorrect \"no match\"\nreturns on subsequent fragments. For example, the pattern /A/ failed to match\nthe subject \\xe5A. Fixes Bugzilla #2642.\n\n14. Fixed a bug in character set matching when JIT is enabled and both unicode\nscripts and unicode classes are present at the same time.\n\n15. Added GNU grep's -m (aka --max-count) option to pcre2grep.\n\n16. Refactored substitution processing in pcre2grep strings, both for the -O\noption and when dealing with callouts. There is now a single function that\nhandles $ expansion in all cases (instead of multiple copies of almost\nidentical code). This means that the same escape sequences are available\neverywhere, which was not previously the case. At the same time, the escape\nsequences $x{...} and $o{...} have been introduced, to allow for characters\nwhose code points are greater than 255 in Unicode mode.\n\n17. Applied the patch from Bugzilla #2628 to RunGrepTest. This does an explicit\ntest for a version of sed that can handle binary zero, instead of assuming that\nany Linux version will work. Later: replaced $(...) by `...` because not all\nshells recognize the former.\n\n18. Fixed a word boundary check bug in JIT when partial matching is enabled.\n\n19. Fix ARM64 compilation warning in JIT. Patch by Carlo.\n\n20. A bug in the RunTest script meant that if the first part of test 2 failed,\nthe failure was not reported.\n\n21. Test 2 was failing when run from a directory other than the source\ndirectory. This failure was previously missed in RunTest because of 20 above.\nFixes added to both RunTest and RunTest.bat.\n\n22. Patch to CMakeLists.txt from Daniel to fix problem with testing under\nWindows.\n\n\nVersion 10.35 09-May-2020\n---------------------------\n\n1. Use PCRE2_MATCH_EMPTY flag to detect empty matches in JIT.\n\n2. Fix ARMv5 JIT improper handling of labels right after a constant pool.\n\n3. A JIT bug is fixed which allowed to read the fields of the compiled\npattern before its existence is checked.\n\n4. Back in the PCRE1 day, capturing groups that contained recursive back\nreferences to themselves were made atomic (version 8.01, change 18) because\nafter the end a repeated group, the captured substrings had their values from\nthe final repetition, not from an earlier repetition that might be the\ndestination of a backtrack. This feature was documented, and was carried over\ninto PCRE2. However, it has now been realized that the major refactoring that\nwas done for 10.30 has made this atomicizing unnecessary, and it is confusing\nwhen users are unaware of it, making some patterns appear not to be working as\nexpected. Capture values of recursive back references in repeated groups are\nnow correctly backtracked, so this unnecessary restriction has been removed.\n\n5. Added PCRE2_SUBSTITUTE_LITERAL.\n\n6. Avoid some VS compiler warnings.\n\n7. Added PCRE2_SUBSTITUTE_MATCHED.\n\n8. Added (?* and (?<* as synonms for (*napla: and (*naplb: to match another\nregex engine. The Perl regex folks are aware of this usage and have made a note\nabout it.\n\n9. When an assertion is repeated, PCRE2 used to limit the maximum repetition to\n1, believing that repeating an assertion is pointless. However, if a positive\nassertion contains capturing groups, repetition can be useful. In any case, an\nassertion could always be wrapped in a repeated group. The only restriction\nthat is now imposed is that an unlimited maximum is changed to one more than\nthe minimum.\n\n10. Fix *THEN verbs in lookahead assertions in JIT.\n\n11. Added PCRE2_SUBSTITUTE_REPLACEMENT_ONLY.\n\n12. The JIT stack should be freed when the low-level stack allocation fails.\n\n13. In pcre2grep, if the final line in a scanned file is output but does not\nend with a newline sequence, add a newline according to the --newline setting.\n\n14. (?(DEFINE)...) groups were not being handled correctly when checking for\nthe fixed length of a lookbehind assertion. Such a group within a lookbehind\nshould be skipped, as it does not contribute to the length of the group.\nInstead, the (DEFINE) group was being processed, and if at the end of the\nlookbehind, that end was not correctly recognized. Errors such as \"lookbehind\nassertion is not fixed length\" and also \"internal error: bad code value in\nparsed_skip()\" could result.\n\n15. Put a limit of 1000 on recursive calls in pcre2_study() when searching\nnested groups for starting code units, in order to avoid stack overflow issues.\nIf the limit is reached, it just gives up trying for this optimization.\n\n16. The control verb chain list must always be restored when exiting from a\nrecurse function in JIT.\n\n17. Fix a crash which occurs when the character type of an invalid UTF\ncharacter is decoded in JIT.\n\n18. Changes in many areas of the code so that when Unicode is supported and\nPCRE2_UCP is set without PCRE2_UTF, Unicode character properties are used for\nupper/lower case computations on characters whose code points are greater than\n127.\n\n19. The function for checking UTF-16 validity was returning an incorrect offset\nfor the start of the error when a high surrogate was not followed by a valid\nlow surrogate. This caused incorrect behaviour, for example when\nPCRE2_MATCH_INVALID_UTF was set and a match started immediately following the\ninvalid high surrogate, such as /aa/ matching \"\\x{d800}aa\".\n\n20. If a DEFINE group immediately preceded a lookbehind assertion, the pattern\ncould be mis-compiled and therefore not match correctly. This is the example\nthat found this: /(?(DEFINE)(?<foo>bar))(?<![-a-z0-9])word/ which failed to\nmatch \"word\" because the \"move back\" value was set to zero.\n\n21. Following a request from a user, some extensions and tidies to the\ncharacter tables handling have been done:\n\n  (a) The dftables auxiliary program is renamed pcre2_dftables, but it is still\n  not installed for public use.\n\n  (b) There is now a -b option for pcre2_dftables, which causes the tables to\n  be written in binary. There is also a -help option.\n\n  (c) PCRE2_CONFIG_TABLES_LENGTH is added to pcre2_config() so that an\n  application that wants to save tables in binary knows how long they are.\n\n22. Changed setting of CMAKE_MODULE_PATH in CMakeLists.txt from SET to\nLIST(APPEND...) to allow a setting from the command line to be included.\n\n23. Updated to Unicode 13.0.0.\n\n24. CMake build now checks for secure_getenv() and strerror(). Patch by Carlo.\n\n25. Avoid using [-1] as a suffix in pcre2test because it can provoke a compiler\nwarning.\n\n26. Added tests for __attribute__((uninitialized)) to both the configure and\nCMake build files, and then applied this attribute to the variable called\nstack_frames_vector[] in pcre2_match(). When implemented, this disables\nautomatic initialization (a facility in clang), which can take time on big\nvariables.\n\n27. Updated CMakeLists.txt (patches by Uwe Korn) to add support for\npcre2-config, the libpcre*.pc files, SOVERSION, VERSION and the\nMACHO_*_VERSIONS settings for CMake builds.\n\n28. Another patch to CMakeLists.txt to check for mkostemp (configure already\ndoes). Patch by Carlo Marcelo Arenas Belon.\n\n29. Check for the existence of memfd_create in both CMake and configure\nconfigurations. Patch by Carlo Marcelo Arenas Belon.\n\n30. Restrict the configuration setting for the SELinux compatible execmem\nallocator (change 10.30/44) to Linux and NetBSD.\n\n\nVersion 10.34 21-November-2019\n------------------------------\n\n1. The maximum number of capturing subpatterns is 65535 (documented), but no\ncheck on this was ever implemented. This omission has been rectified; it fixes\nClusterFuzz 14376.\n\n2. Improved the invalid utf32 support of the JIT compiler. Now it correctly\ndetects invalid characters in the 0xd800-0xdfff range.\n\n3. Fix minor typo bug in JIT compile when \\X is used in a non-UTF string.\n\n4. Add support for matching in invalid UTF strings to the pcre2_match()\ninterpreter, and integrate with the existing JIT support via the new\nPCRE2_MATCH_INVALID_UTF compile-time option.\n\n5. Give more error detail for invalid UTF-8 when detected in pcre2grep.\n\n6. Add support for invalid UTF-8 to pcre2grep.\n\n7. Adjust the limit for \"must have\" code unit searching, in particular,\nincrease it substantially for non-anchored patterns.\n\n8. Allow (*ACCEPT) to be quantified, because an ungreedy quantifier with a zero\nminimum is potentially useful.\n\n9. Some changes to the way the minimum subject length is handled:\n\n   * When PCRE2_NO_START_OPTIMIZE is set, no minimum length is computed;\n     pcre2test now omits this item instead of showing a value of zero.\n\n   * An incorrect minimum length could be calculated for a pattern that\n     contained (*ACCEPT) inside a qualified group whose minimum repetition was\n     zero, for example /A(?:(*ACCEPT))?B/, which incorrectly computed a minimum\n     of 2. The minimum length scan no longer happens for a pattern that\n     contains (*ACCEPT).\n\n   * When no minimum length is set by the normal scan, but a first and/or last\n     code unit is recorded, set the minimum to 1 or 2 as appropriate.\n\n   * When a pattern contains multiple groups with the same number, a back\n     reference cannot know which one to scan for a minimum length. This used to\n     cause the minimum length finder to give up with no result. Now it treats\n     such references as not adding to the minimum length (which it should have\n     done all along).\n\n   * Furthermore, the above action now happens only if the back reference is to\n     a group that exists more than once in a pattern instead of any back\n     reference in a pattern with duplicate numbers.\n\n10. A (*MARK) value inside a successful condition was not being returned by the\ninterpretive matcher (it was returned by JIT). This bug has been mended.\n\n11. A bug in pcre2grep meant that -o without an argument (or -o0) didn't work\nif the pattern had more than 32 capturing parentheses. This is fixed. In\naddition (a) the default limit for groups requested by -o<n> has been raised to\n50, (b) the new --om-capture option changes the limit, (c) an error is raised\nif -o asks for a group that is above the limit.\n\n12. The quantifier {1} was always being ignored, but this is incorrect when it\nis made possessive and applied to an item in parentheses, because a\nparenthesized item may contain multiple branches or other backtracking points,\nfor example /(a|ab){1}+c/ or /(a+){1}+a/.\n\n13. For partial matches, pcre2test was always showing the maximum lookbehind\ncharacters, flagged with \"<\", which is misleading when the lookbehind didn't\nactually look behind the start (because it was later in the pattern). Showing\nall consulted preceding characters for partial matches is now controlled by the\nexisting \"allusedtext\" modifier and, as for complete matches, this facility is\navailable only for non-JIT matching, because JIT does not maintain the first\nand last consulted characters.\n\n14. DFA matching (using pcre2_dfa_match()) was not recognising a partial match\nif the end of the subject was encountered in a lookahead (conditional or\notherwise), an atomic group, or a recursion.\n\n15. Give error if pcre2test -t, -T, -tm or -TM is given an argument of zero.\n\n16. Check for integer overflow when computing lookbehind lengths. Fixes\nClusterfuzz issue 15636.\n\n17. Implemented non-atomic positive lookaround assertions.\n\n18. If a lookbehind contained a lookahead that contained another lookbehind\nwithin it, the nested lookbehind was not correctly processed. For example, if\n/(?<=(?=(?<=a)))b/ was matched to \"ab\" it gave no match instead of matching\n\"b\".\n\n19. Implemented pcre2_get_match_data_size().\n\n20. Two alterations to partial matching:\n\n    (a) The definition of a partial match is slightly changed: if a pattern\n    contains any lookbehinds, an empty partial match may be given, because this\n    is another situation where adding characters to the current subject can\n    lead to a full match. Example: /c*+(?<=[bc])/ with subject \"ab\".\n\n    (b) Similarly, if a pattern could match an empty string, an empty partial\n    match may be given. Example: /(?![ab]).*/ with subject \"ab\". This case\n    applies only to PCRE2_PARTIAL_HARD.\n\n    (c) An empty string partial hard match can be returned for \\z and \\Z as it\n    is documented that they shouldn't match.\n\n21. A branch that started with (*ACCEPT) was not being recognized as one that\ncould match an empty string.\n\n22. Corrected pcre2_set_character_tables() tables data type: was const unsigned\nchar * instead of const uint8_t *, as generated by pcre2_maketables().\n\n23. Upgraded to Unicode 12.1.0.\n\n24. Add -jitfast command line option to pcre2test (to make all the jit options\navailable directly).\n\n25. Make pcre2test -C show if libreadline or libedit is supported.\n\n26. If the length of one branch of a group exceeded 65535 (the maximum value\nthat is remembered as a minimum length), the whole group's length was\nincorrectly recorded as 65535, leading to incorrect \"no match\" when start-up\noptimizations were in force.\n\n27. The \"rightmost consulted character\" value was not always correct; in\nparticular, if a pattern ended with a negative lookahead, characters that were\ninspected in that lookahead were not included.\n\n28. Add the pcre2_maketables_free() function.\n\n29. The start-up optimization that looks for a unique initial matching\ncode unit in the interpretive engines uses memchr() in 8-bit mode. When the\nsearch is caseless, it was doing so inefficiently, which ended up slowing down\nthe match drastically when the subject was very long. The revised code (a)\nremembers if one case is not found, so it never repeats the search for that\ncase after a bumpalong and (b) when one case has been found, it searches only\nup to that position for an earlier occurrence of the other case. This fix\napplies to both interpretive pcre2_match() and to pcre2_dfa_match().\n\n30. While scanning to find the minimum length of a group, if any branch has\nminimum length zero, there is no need to scan any subsequent branches (a small\ncompile-time performance improvement).\n\n31. Installed a .gitignore file on a user's suggestion. When using the svn\nrepository with git (through git svn) this helps keep it tidy.\n\n32. Add underflow check in JIT which may occur when the value of subject\nstring pointer is close to 0.\n\n33. Arrange for classes such as [Aa] which contain just the two cases of the\nsame character, to be treated as a single caseless character. This causes the\nfirst and required code unit optimizations to kick in where relevant.\n\n34. Improve the bitmap of starting bytes for positive classes that include wide\ncharacters, but no property types, in UTF-8 mode. Previously, on encountering\nsuch a class, the bits for all bytes greater than \\xc4 were set, thus\nspecifying any character with codepoint >= 0x100. Now the only bits that are\nset are for the relevant bytes that start the wide characters. This can give a\nnoticeable performance improvement.\n\n35. If the bitmap of starting code units contains only 1 or 2 bits, replace it\nwith a single starting code unit (1 bit) or a caseless single starting code\nunit if the two relevant characters are case-partners. This is particularly\nrelevant to the 8-bit library, though it applies to all. It can give a\nperformance boost for patterns such as [Ww]ord and (word|WORD). However, this\noptimization doesn't happen if there is a \"required\" code unit of the same\nvalue (because the search for a \"required\" code unit starts at the match start\nfor non-unique first code unit patterns, but after a unique first code unit,\nand patterns such as a*a need the former action).\n\n36. Small patch to pcre2posix.c to set the erroroffset field to -1 immediately\nafter a successful compile, instead of at the start of matching to avoid a\nsanitizer complaint (regexec is supposed to be thread safe).\n\n37. Add NEON vectorization to JIT to speed up matching of first character and\npairs of characters on ARM64 CPUs.\n\n38. If a non-ASCII character was the first in a starting assertion in a\ncaseless match, the \"first code unit\" optimization did not get the casing\nright, and the assertion failed to match a character in the other case if it\ndid not start with the same code unit.\n\n39. Fixed the incorrect computation of jump sizes on x86 CPUs in JIT. A masking\noperation was incorrectly removed in r1136. Reported by Ralf Junker.\n\n\nVersion 10.33 16-April-2019\n---------------------------\n\n1. Added \"allvector\" to pcre2test to make it easy to check the part of the\novector that shouldn't be changed, in particular after substitute and failed or\npartial matches.\n\n2. Fix subject buffer overread in JIT when UTF is disabled and \\X or \\R has\na greater than 1 fixed quantifier. This issue was found by Yunho Kim.\n\n3. Added support for callouts from pcre2_substitute(). After 10.33-RC1, but\nprior to release, fixed a bug that caused a crash if pcre2_substitute() was\ncalled with a NULL match context.\n\n4. The POSIX functions are now all called pcre2_regcomp() etc., with wrapper\nfunctions that use the standard POSIX names. However, in pcre2posix.h the POSIX\nnames are defined as macros. This should help avoid linking with the wrong\nlibrary in some environments while still exporting the POSIX names for\npre-existing programs that use them. (The Debian alternative names are also\ndefined as macros, but not documented.)\n\n5. Fix an xclass matching issue in JIT.\n\n6. Implement PCRE2_EXTRA_ESCAPED_CR_IS_LF (see Bugzilla 2315).\n\n7. Implement the Perl 5.28 experimental alphabetic names for atomic groups and\nlookaround assertions, for example, (*pla:...) and (*atomic:...). These are\ncharacterized by a lower case letter following (* and to simplify coding for\nthis, the character tables created by pcre2_maketables() were updated to add a\nnew \"is lower case letter\" bit. At the same time, the now unused \"is\nhexadecimal digit\" bit was removed. The default tables in\nsrc/pcre2_chartables.c.dist are updated.\n\n8. Implement the new Perl \"script run\" features (*script_run:...) and\n(*atomic_script_run:...) aka (*sr:...) and (*asr:...).\n\n9. Fixed two typos in change 22 for 10.21, which added special handling for\nranges such as a-z in EBCDIC environments. The original code probably never\nworked, though there were no bug reports.\n\n10. Implement PCRE2_COPY_MATCHED_SUBJECT for pcre2_match() (including JIT via\npcre2_match()) and pcre2_dfa_match(), but *not* the pcre2_jit_match() fast\npath. Also, when a match fails, set the subject field in the match data to NULL\nfor tidiness - none of the substring extractors should reference this after\nmatch failure.\n\n11. If a pattern started with a subroutine call that had a quantifier with a\nminimum of zero, an incorrect \"match must start with this character\" could be\nrecorded. Example: /(?&xxx)*ABC(?<xxx>XYZ)/ would (incorrectly) expect 'A' to\nbe the first character of a match.\n\n12. The heap limit checking code in pcre2_dfa_match() could suffer from\noverflow if the heap limit was set very large. This could cause incorrect \"heap\nlimit exceeded\" errors.\n\n13. Add \"kibibytes\" to the heap limit output from pcre2test -C to make the\nunits clear.\n\n14. Add a call to pcre2_jit_free_unused_memory() in pcre2grep, for tidiness.\n\n15. Updated the VMS-specific code in pcre2test on the advice of a VMS user.\n\n16. Removed the unnecessary inclusion of stdint.h (or inttypes.h) from\npcre2_internal.h as it is now included by pcre2.h. Also, change 17 for 10.32\nbelow was unnecessarily complicated, as inttypes.h is a Standard C header,\nwhich is defined to be a superset of stdint.h. Instead of conditionally\nincluding stdint.h or inttypes.h, pcre2.h now unconditionally includes\ninttypes.h. This supports environments that do not have stdint.h but do have\ninttypes.h, which are known to exist. A note in the autotools documentation\nsays (November 2018) that there are none known that are the other way round.\n\n17. Added --disable-percent-zt to \"configure\" (and equivalent to CMake) to\nforcibly disable the use of %zu and %td in formatting strings because there is\nat least one version of VMS that claims to be C99 but does not support these\nmodifiers.\n\n18. Added --disable-pcre2grep-callout-fork, which restricts the callout support\nin pcre2grep to the inbuilt echo facility. This may be useful in environments\nthat do not support fork().\n\n19. Fix two instances of <= 0 being applied to unsigned integers (the VMS\ncompiler complains).\n\n20. Added \"fork\" support for VMS to pcre2grep, for running an external program\nvia a string callout.\n\n21. Improve MAP_JIT flag usage on MacOS. Patch by Rich Siegel.\n\n22. If a pattern started with (*MARK), (*COMMIT), (*PRUNE), (*SKIP), or (*THEN)\nfollowed by ^ it was not recognized as anchored.\n\n23. The RunGrepTest script used to cut out the test of NUL characters for\nSolaris and MacOS as printf and sed can't handle them. It seems that the *BSD\nsystems can't either. I've inverted the test so that only those OS that are\nknown to work (currently only Linux) try to run this test.\n\n24. Some tests in RunGrepTest appended to testtrygrep from two different file\ndescriptors instead of redirecting stderr to stdout. This worked on Linux, but\nit was reported not to on other systems, causing the tests to fail.\n\n25. In the RunTest script, make the test for stack setting use the same value\nfor the stack as it needs for -bigstack.\n\n26. Insert a cast in pcre2_dfa_match.c to suppress a compiler warning.\n\n26. With PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL set, escape sequences such as \\s\nwhich are valid in character classes, but not as the end of ranges, were being\ntreated as literals. An example is [_-\\s] (but not [\\s-_] because that gave an\nerror at the *start* of a range). Now an \"invalid range\" error is given\nindependently of PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL.\n\n27. Related to 26 above, PCRE2_BAD_ESCAPE_IS_LITERAL was affecting known escape\nsequences such as \\eX when they appeared invalidly in a character class. Now\nthe option applies only to unrecognized or malformed escape sequences.\n\n28. Fix word boundary in JIT compiler. Patch by Mike Munday.\n\n29. The pcre2_dfa_match() function was incorrectly handling conditional version\ntests such as (?(VERSION>=0)...) when the version test was true. Incorrect\nprocessing or a crash could result.\n\n30. When PCRE2_UTF is set, allow non-ASCII letters and decimal digits in group\nnames, as Perl does. There was a small bug in this new code, found by\nClusterFuzz 12950, fixed before release.\n\n31. Implemented PCRE2_EXTRA_ALT_BSUX to support ECMAScript 6's \\u{hhh}\nconstruct.\n\n32. Compile \\p{Any} to be the same as . in DOTALL mode, so that it benefits\nfrom auto-anchoring if \\p{Any}* starts a pattern.\n\n33. Compile invalid UTF check in JIT test when only pcre32 is enabled.\n\n34. For some time now, CMake has been warning about the setting of policy\nCMP0026 to \"OLD\" in CmakeLists.txt, and hinting that the feature might be\nremoved in a future version. A request for CMake expertise on the list produced\nno result, so I have now hacked CMakeLists.txt along the lines of some changes\nI found on the Internet. The new code no longer needs the policy setting, and\nit appears to work fine on Linux.\n\n35. Setting --enable-jit=auto for an out-of-tree build failed because the\nsource directory wasn't in the search path for AC_TRY_COMPILE always. Patch\nfrom Ross Burton.\n\n36. Disable SSE2 JIT optimizations in x86 CPUs when SSE2 is not available.\nPatch by Guillem Jover.\n\n37. Changed expressions such as 1<<10 to 1u<<10 in many places because compiler\nwarnings were reported.\n\n38. Using the clang compiler with sanitizing options causes runtime complaints\nabout truncation for statments such as x = ~x when x is an 8-bit value; it\nseems to compute ~x as a 32-bit value. Changing such statements to x = 255 ^ x\ngets rid of the warnings. There were also two missing casts in pcre2test.\n\n\nVersion 10.32 10-September-2018\n-------------------------------\n\n1. When matching using the the REG_STARTEND feature of the POSIX API with a\nnon-zero starting offset, unset capturing groups with lower numbers than a\ngroup that did capture something were not being correctly returned as \"unset\"\n(that is, with offset values of -1).\n\n2. When matching using the POSIX API, pcre2test used to omit listing unset\ngroups altogether. Now it shows those that come before any actual captures as\n\"<unset>\", as happens for non-POSIX matching.\n\n3. Running \"pcre2test -C\" always stated \"\\R matches CR, LF, or CRLF only\",\nwhatever the build configuration was. It now correctly says \"\\R matches all\nUnicode newlines\" in the default case when --enable-bsr-anycrlf has not been\nspecified. Similarly, running \"pcre2test -C bsr\" never produced the result\nANY.\n\n4. Matching the pattern /(*UTF)\\C[^\\v]+\\x80/ against an 8-bit string containing\nmulti-code-unit characters caused bad behaviour and possibly a crash. This\nissue was fixed for other kinds of repeat in release 10.20 by change 19, but\nrepeating character classes were overlooked.\n\n5. pcre2grep now supports the inclusion of binary zeros in patterns that are\nread from files via the -f option.\n\n6. A small fix to pcre2grep to avoid compiler warnings for -Wformat-overflow=2.\n\n7. Added --enable-jit=auto support to configure.ac.\n\n8. Added some dummy variables to the heapframe structure in 16-bit and 32-bit\nmodes for the benefit of m68k, where pointers can be 16-bit aligned. The\ndummies force 32-bit alignment and this ensures that the structure is a\nmultiple of PCRE2_SIZE, a requirement that is tested at compile time. In other\narchitectures, alignment requirements take care of this automatically.\n\n9. When returning an error from pcre2_pattern_convert(), ensure the error\noffset is set zero for early errors.\n\n10. A number of patches for Windows support from Daniel Richard G:\n\n  (a) List of error numbers in Runtest.bat corrected (it was not the same as in\n      Runtest).\n\n  (b) pcre2grep snprintf() workaround as used elsewhere in the tree.\n\n  (c) Support for non-C99 snprintf() that returns -1 in the overflow case.\n\n11. Minor tidy of pcre2_dfa_match() code.\n\n12. Refactored pcre2_dfa_match() so that the internal recursive calls no longer\nuse the stack for local workspace and local ovectors. Instead, an initial block\nof stack is reserved, but if this is insufficient, heap memory is used. The\nheap limit parameter now applies to pcre2_dfa_match().\n\n13. If a \"find limits\" test of DFA matching in pcre2test resulted in too many\nmatches for the ovector, no matches were displayed.\n\n14. Removed an occurrence of ctrl/Z from test 6 because Windows treats it as\nEOF. The test looks to have come from a fuzzer.\n\n15. If PCRE2 was built with a default match limit a lot greater than the\ndefault default of 10 000 000, some JIT tests of the match limit no longer\nfailed. All such tests now set 10 000 000 as the upper limit.\n\n16. Another Windows related patch for pcregrep to ensure that WIN32 is\nundefined under Cygwin.\n\n17. Test for the presence of stdint.h and inttypes.h in configure and CMake and\ninclude whichever exists (stdint preferred) instead of unconditionally\nincluding stdint. This makes life easier for old and non-standard systems.\n\n18. Further changes to improve portability, especially to old and or non-\nstandard systems:\n\n  (a) Put all printf arguments in RunGrepTest into single, not double, quotes,\n      and use \\0 not \\x00 for binary zero.\n\n  (b) Avoid the use of C++ (i.e. BCPL) // comments.\n\n  (c) Parameterize the use of %zu in pcre2test to make it like %td. For both of\n      these now, if using MSVC or a standard C before C99, %lu is used with a\n      cast if necessary.\n\n19. Applied a contributed patch to CMakeLists.txt to increase the stack size\nwhen linking pcre2test with MSVC. This gets rid of a stack overflow error in\nthe standard set of tests.\n\n20. Output a warning in pcre2test when ignoring the \"altglobal\" modifier when\nit is given with the \"replace\" modifier.\n\n21. In both pcre2test and pcre2_substitute(), with global matching, a pattern\nthat matched an empty string, but never at the starting match offset, was not\nhandled in a Perl-compatible way. The pattern /(<?=\\G.)/ is an example of such\na pattern. Because \\G is in a lookbehind assertion, there has to be a\n\"bumpalong\" before there can be a match. The automatic \"advance by one\ncharacter after an empty string match\" rule is therefore inappropriate. A more\ncomplicated algorithm has now been implemented.\n\n22. When checking to see if a lookbehind is of fixed length, lookaheads were\ncorrectly ignored, but qualifiers on lookaheads were not being ignored, leading\nto an incorrect \"lookbehind assertion is not fixed length\" error.\n\n23. The VERSION condition test was reading fractional PCRE2 version numbers\nsuch as the 04 in 10.04 incorrectly and hence giving wrong results.\n\n24. Updated to Unicode version 11.0.0. As well as the usual addition of new\nscripts and characters, this involved re-jigging the grapheme break property\nalgorithm because Unicode has changed the way emojis are handled.\n\n25. Fixed an obscure bug that struck when there were two atomic groups not\nseparated by something with a backtracking point. There could be an incorrect\nbacktrack into the first of the atomic groups. A complicated example is\n/(?>a(*:1))(?>b)(*SKIP:1)x|.*/ matched against \"abc\", where the *SKIP\nshouldn't find a MARK (because is in an atomic group), but it did.\n\n26. Upgraded the perltest.sh script: (1) #pattern lines can now be used to set\na list of modifiers for all subsequent patterns - only those that the script\nrecognizes are meaningful; (2) #subject lines can be used to set or unset a\ndefault \"mark\" modifier; (3) Unsupported #command lines give a warning when\nthey are ignored; (4) Mark data is output only if the \"mark\" modifier is\npresent.\n\n27. (*ACCEPT:ARG), (*FAIL:ARG), and (*COMMIT:ARG) are now supported.\n\n28. A (*MARK) name was not being passed back for positive assertions that were\nterminated by (*ACCEPT).\n\n29. Add support for \\N{U+dddd}, but only in Unicode mode.\n\n30. Add support for (?^) for unsetting all imnsx options.\n\n31. The PCRE2_EXTENDED (/x) option only ever discarded space characters whose\ncode point was less than 256 and that were recognized by the lookup table\ngenerated by pcre2_maketables(), which uses isspace() to identify white space.\nNow, when Unicode support is compiled, PCRE2_EXTENDED also discards U+0085,\nU+200E, U+200F, U+2028, and U+2029, which are additional characters defined by\nUnicode as \"Pattern White Space\". This makes PCRE2 compatible with Perl.\n\n32. In certain circumstances, option settings within patterns were not being\ncorrectly processed. For example, the pattern /((?i)A)(?m)B/ incorrectly\nmatched \"ab\". (The (?m) setting lost the fact that (?i) should be reset at the\nend of its group during the parse process, but without another setting such as\n(?m) the compile phase got it right.) This bug was introduced by the\nrefactoring in release 10.23.\n\n33. PCRE2 uses bcopy() if available when memmove() is not, and it used just to\ndefine memmove() as function call to bcopy(). This hasn't been tested for a\nlong time because in pcre2test the result of memmove() was being used, whereas\nbcopy() doesn't return a result. This feature is now refactored always to call\nan emulation function when there is no memmove(). The emulation makes use of\nbcopy() when available.\n\n34. When serializing a pattern, set the memctl, executable_jit, and tables\nfields (that is, all the fields that contain pointers) to zeros so that the\nresult of serializing is always the same. These fields are re-set when the\npattern is deserialized.\n\n35. In a pattern such as /[^\\x{100}-\\x{ffff}]*[\\x80-\\xff]/ which has a repeated\nnegative class with no characters less than 0x100 followed by a positive class\nwith only characters less than 0x100, the first class was incorrectly being\nauto-possessified, causing incorrect match failures.\n\n36. Removed the character type bit ctype_meta, which dates from PCRE1 and is\nnot used in PCRE2.\n\n37. Tidied up unnecessarily complicated macros used in the escapes table.\n\n38. Since 10.21, the new testoutput8-16-4 file has accidentally been omitted\nfrom distribution tarballs, owing to a typo in Makefile.am which had\ntestoutput8-16-3 twice. Now fixed.\n\n39. If the only branch in a conditional subpattern was anchored, the whole\nsubpattern was treated as anchored, when it should not have been, since the\nassumed empty second branch cannot be anchored. Demonstrated by test patterns\nsuch as /(?(1)^())b/ or /(?(?=^))b/.\n\n40. A repeated conditional subpattern that could match an empty string was\nalways assumed to be unanchored. Now it it checked just like any other\nrepeated conditional subpattern, and can be found to be anchored if the minimum\nquantifier is one or more. I can't see much use for a repeated anchored\npattern, but the behaviour is now consistent.\n\n41. Minor addition to pcre2_jit_compile.c to avoid static analyzer complaint\n(for an event that could never occur but you had to have external information\nto know that).\n\n42. If before the first match in a file that was being searched by pcre2grep\nthere was a line that was sufficiently long to cause the input buffer to be\nexpanded, the variable holding the location of the end of the previous match\nwas being adjusted incorrectly, and could cause an overflow warning from a code\nsanitizer. However, as the value is used only to print pending \"after\" lines\nwhen the next match is reached (and there are no such lines in this case) this\nbug could do no damage.\n\n\nVersion 10.31 12-February-2018\n------------------------------\n\n1. Fix typo (missing ]) in VMS code in pcre2test.c.\n\n2. Replace the replicated code for matching extended Unicode grapheme sequences\n(which got a lot more complicated by change 10.30/49) by a single subroutine\nthat is called by both pcre2_match() and pcre2_dfa_match().\n\n3. Add idempotent guard to pcre2_internal.h.\n\n4. Add new pcre2_config() options: PCRE2_CONFIG_NEVER_BACKSLASH_C and\nPCRE2_CONFIG_COMPILED_WIDTHS.\n\n5. Cut out \\C tests in the JIT regression tests when NEVER_BACKSLASH_C is\ndefined (e.g. by --enable-never-backslash-C).\n\n6. Defined public names for all the pcre2_compile() error numbers, and used\nthe public names in pcre2_convert.c.\n\n7. Fixed a small memory leak in pcre2test (convert contexts).\n\n8. Added two casts to compile.c and one to match.c to avoid compiler warnings.\n\n9. Added code to pcre2grep when compiled under VMS to set the symbol\nPCRE2GREP_RC to the exit status, because VMS does not distinguish between\nexit(0) and exit(1).\n\n10. Added the -LM (list modifiers) option to pcre2test. Also made -C complain\nabout a bad option only if the following argument item does not start with a\nhyphen.\n\n11. pcre2grep was truncating components of file names to 128 characters when\nprocessing files with the -r option, and also (some very odd code) truncating\npath names to 512 characters. There is now a check on the absolute length of\nfull path file names, which may be up to 2047 characters long.\n\n12. When an assertion contained (*ACCEPT) it caused all open capturing groups\nto be closed (as for a non-assertion ACCEPT), which was wrong and could lead to\nmisbehaviour for subsequent references to groups that started outside the\nassertion. ACCEPT in an assertion now closes only those groups that were\nstarted within that assertion. Fixes oss-fuzz issues 3852 and 3891.\n\n13. Multiline matching in pcre2grep was misbehaving if the pattern matched\nwithin a line, and then matched again at the end of the line and over into\nsubsequent lines. Behaviour was different with and without colouring, and\nsometimes context lines were incorrectly printed and/or line endings were lost.\nAll these issues should now be fixed.\n\n14. If --line-buffered was specified for pcre2grep when input was from a\ncompressed file (.gz or .bz2) a segfault occurred. (Line buffering should be\nignored for compressed files.)\n\n15. Although pcre2_jit_match checks whether the pattern is compiled\nin a given mode, it was also expected that at least one mode is available.\nThis is fixed and pcre2_jit_match returns with PCRE2_ERROR_JIT_BADOPTION\nwhen the pattern is not optimized by JIT at all.\n\n16. The line number and related variables such as match counts in pcre2grep\nwere all int variables, causing overflow when files with more than 2147483647\nlines were processed (assuming 32-bit ints). They have all been changed to\nunsigned long ints.\n\n17. If a backreference with a minimum repeat count of zero was first in a\npattern, apart from assertions, an incorrect first matching character could be\nrecorded. For example, for the pattern /(?=(a))\\1?b/, \"b\" was incorrectly set\nas the first character of a match.\n\n18. Characters in a leading positive assertion are considered for recording a\nfirst character of a match when the rest of the pattern does not provide one.\nHowever, a character in a non-assertive group within a leading assertion such\nas in the pattern /(?=(a))\\1?b/ caused this process to fail. This was an\ninfelicity rather than an outright bug, because it did not affect the result of\na match, just its speed. (In fact, in this case, the starting 'a' was\nsubsequently picked up in the study.)\n\n19. A minor tidy in pcre2_match(): making all PCRE2_ERROR_ returns use \"return\"\ninstead of \"RRETURN\" saves unwinding the backtracks in these cases (only one\ndidn't).\n\n20. Allocate a single callout block on the stack at the start of pcre2_match()\nand set its never-changing fields once only. Do the same for pcre2_dfa_match().\n\n21. Save the extra compile options (set in the compile context) with the\ncompiled pattern (they were not previously saved), add PCRE2_INFO_EXTRAOPTIONS\nto retrieve them, and update pcre2test to show them.\n\n22. Added PCRE2_CALLOUT_STARTMATCH and PCRE2_CALLOUT_BACKTRACK bits to a new\nfield callout_flags in callout blocks. The bits are set by pcre2_match(), but\nnot by JIT or pcre2_dfa_match(). Their settings are shown in pcre2test callouts\nif the callout_extra subject modifier is set. These bits are provided to help\nwith tracking how a backtracking match is proceeding.\n\n23. Updated the pcre2demo.c demonstration program, which was missing the extra\ncode for -g that handles the case when \\K in an assertion causes the match to\nend at the original start point. Also arranged for it to detect when \\K causes\nthe end of a match to be before its start.\n\n24. Similar to 23 above, strange things (including loops) could happen in\npcre2grep when \\K was used in an assertion when --colour was used or in\nmultiline mode. The \"end at original start point\" bug is fixed, and if the end\npoint is found to be before the start point, they are swapped.\n\n25. When PCRE2_FIRSTLINE without PCRE2_NO_START_OPTIMIZE was used in non-JIT\nmatching (both pcre2_match() and pcre2_dfa_match()) and the matched string\nstarted with the first code unit of a newline sequence, matching failed because\nit was not tried at the newline.\n\n26. Code for giving up a non-partial match after failing to find a starting\ncode unit anywhere in the subject was missing when searching for one of a\nnumber of code units (the bitmap case) in both pcre2_match() and\npcre2_dfa_match(). This was a missing optimization rather than a bug.\n\n27. Tidied up the ACROSSCHAR macro to be like FORWARDCHAR and BACKCHAR, using a\npointer argument rather than a code unit value. This should not have affected\nthe generated code.\n\n28. The JIT compiler has been updated.\n\n29. Avoid pointer overflow for unset captures in pcre2_substring_list_get().\nThis could not actually cause a crash because it was always used in a memcpy()\ncall with zero length.\n\n30. Some internal structures have a variable-length ovector[] as their last\nelement. Their actual memory is obtained dynamically, giving an ovector of\nappropriate length. However, they are defined in the structure as\novector[NUMBER], where NUMBER is large so that array bound checkers don't\ngrumble. The value of NUMBER was 10000, but a fuzzer exceeded 5000 capturing\ngroups, making the ovector larger than this. The number has been increased to\n131072, which allows for the maximum number of captures (65535) plus the\noverall match. This fixes oss-fuzz issue 5415.\n\n31. Auto-possessification at the end of a capturing group was dependent on what\nfollows the group (e.g. /(a+)b/ would auto-possessify the a+) but this caused\nincorrect behaviour when the group was called recursively from elsewhere in the\npattern where something different might follow. This bug is an unforseen\nconsequence of change #1 for 10.30 - the implementation of backtracking into\nrecursions. Iterators at the ends of capturing groups are no longer considered\nfor auto-possessification if the pattern contains any recursions. Fixes\nBugzilla #2232.\n\n\nVersion 10.30 14-August-2017\n----------------------------\n\n1. The main interpreter, pcre2_match(), has been refactored into a new version\nthat does not use recursive function calls (and therefore the stack) for\nremembering backtracking positions. This makes --disable-stack-for-recursion a\nNOOP. The new implementation allows backtracking into recursive group calls in\npatterns, making it more compatible with Perl, and also fixes some other\nhard-to-do issues such as #1887 in Bugzilla. The code is also cleaner because\nthe old code had a number of fudges to try to reduce stack usage. It seems to\nrun no slower than the old code.\n\nA number of bugs in the refactored code were subsequently fixed during testing\nbefore release, but after the code was made available in the repository. These\nbugs were never in fully released code, but are noted here for the record.\n\n  (a) If a pattern had fewer capturing parentheses than the ovector supplied in\n      the match data block, a memory error (detectable by ASAN) occurred after\n      a match, because the external block was being set from non-existent\n      internal ovector fields. Fixes oss-fuzz issue 781.\n\n  (b) A pattern with very many capturing parentheses (when the internal frame\n      size was greater than the initial frame vector on the stack) caused a\n      crash. A vector on the heap is now set up at the start of matching if the\n      vector on the stack is not big enough to handle at least 10 frames.\n      Fixes oss-fuzz issue 783.\n\n  (c) Handling of (*VERB)s in recursions was wrong in some cases.\n\n  (d) Captures in negative assertions that were used as conditions were not\n      happening if the assertion matched via (*ACCEPT).\n\n  (e) Mark values were not being passed out of recursions.\n\n  (f) Refactor some code in do_callout() to avoid picky compiler warnings about\n      negative indices. Fixes oss-fuzz issue 1454.\n\n  (g) Similarly refactor the way the variable length ovector is addressed for\n      similar reasons. Fixes oss-fuzz issue 1465.\n\n2. Now that pcre2_match() no longer uses recursive function calls (see above),\nthe \"match limit recursion\" value seems misnamed. It still exists, and limits\nthe depth of tree that is searched. To avoid future confusion, it has been\nrenamed as \"depth limit\" in all relevant places (--with-depth-limit,\n(*LIMIT_DEPTH), pcre2_set_depth_limit(), etc) but the old names are still\navailable for backwards compatibility.\n\n3. Hardened pcre2test so as to reduce the number of bugs reported by fuzzers:\n\n  (a) Check for malloc failures when getting memory for the ovector (POSIX) or\n      the match data block (non-POSIX).\n\n4. In the 32-bit library in non-UTF mode, an attempt to find a Unicode property\nfor a character with a code point greater than 0x10ffff (the Unicode maximum)\ncaused a crash.\n\n5. If a lookbehind assertion that contained a back reference to a group\nappearing later in the pattern was compiled with the PCRE2_ANCHORED option,\nundefined actions (often a segmentation fault) could occur, depending on what\nother options were set. An example assertion is (?<!\\1(abc)) where the\nreference \\1 precedes the group (abc). This fixes oss-fuzz issue 865.\n\n6. Added the PCRE2_INFO_FRAMESIZE item to pcre2_pattern_info() and arranged for\npcre2test to use it to output the frame size when the \"framesize\" modifier is\ngiven.\n\n7. Reworked the recursive pattern matching in the JIT compiler to follow the\ninterpreter changes.\n\n8. When the zero_terminate modifier was specified on a pcre2test subject line\nfor global matching, unpredictable things could happen. For example, in UTF-8\nmode, the pattern //g,zero_terminate read random memory when matched against an\nempty string with zero_terminate. This was a bug in pcre2test, not the library.\n\n9. Moved some Windows-specific code in pcre2grep (introduced in 10.23/13) out\nof the section that is compiled when Unix-style directory scanning is\navailable, and into a new section that is always compiled for Windows.\n\n10. In pcre2test, explicitly close the file after an error during serialization\nor deserialization (the \"load\" or \"save\" commands).\n\n11. Fix memory leak in pcre2_serialize_decode() when the input is invalid.\n\n12. Fix potential NULL dereference in pcre2_callout_enumerate() if called with\na NULL pattern pointer when Unicode support is available.\n\n13. When the 32-bit library was being tested by pcre2test, error messages that\nwere longer than 64 code units could cause a buffer overflow. This was a bug in\npcre2test.\n\n14. The alternative matching function, pcre2_dfa_match() misbehaved if it\nencountered a character class with a possessive repeat, for example [a-f]{3}+.\n\n15. The depth (formerly recursion) limit now applies to DFA matching (as\nof 10.23/36); pcre2test has been upgraded so that \\=find_limits works with DFA\nmatching to find the minimum value for this limit.\n\n16. Since 10.21, if pcre2_match() was called with a null context, default\nmemory allocation functions were used instead of whatever was used when the\npattern was compiled.\n\n17. Changes to the pcre2test \"memory\" modifier on a subject line. These apply\nonly to pcre2_match():\n\n  (a) Warn if null_context is set on both pattern and subject, because the\n      memory details cannot then be shown.\n\n  (b) Remember (up to a certain number of) memory allocations and their\n      lengths, and list only the lengths, so as to be system-independent.\n      (In practice, the new interpreter never has more than 2 blocks allocated\n      simultaneously.)\n\n18. Make pcre2test detect an error return from pcre2_get_error_message(), give\na message, and abandon the run (this would have detected #13 above).\n\n19. Implemented PCRE2_ENDANCHORED.\n\n20. Applied Jason Hood's patches (slightly modified) to pcre2grep, to implement\nthe --output=text (-O) option and the inbuilt callout echo.\n\n21. Extend auto-anchoring etc. to ignore groups with a zero qualifier and\nsingle-branch conditions with a false condition (e.g. DEFINE) at the start of a\nbranch. For example, /(?(DEFINE)...)^A/ and /(...){0}^B/ are now flagged as\nanchored.\n\n22. Added an explicit limit on the amount of heap used by pcre2_match(), set by\npcre2_set_heap_limit() or (*LIMIT_HEAP=xxx). Upgraded pcre2test to show the\nheap limit along with other pattern information, and to find the minimum when\nthe find_limits modifier is set.\n\n23. Write to the last 8 bytes of the pcre2_real_code structure when a compiled\npattern is set up so as to initialize any padding the compiler might have\nincluded. This avoids valgrind warnings when a compiled pattern is copied, in\nparticular when it is serialized.\n\n24. Remove a redundant line of code left in accidentally a long time ago.\n\n25. Remove a duplication typo in pcre2_tables.c\n\n26. Correct an incorrect cast in pcre2_valid_utf.c\n\n27. Update pcre2test, remove some unused code in pcre2_match(), and upgrade the\ntests to improve coverage.\n\n28. Some fixes/tidies as a result of looking at Coverity Scan output:\n\n    (a) Typo: \">\" should be \">=\" in opcode check in pcre2_auto_possess.c.\n    (b) Added some casts to avoid \"suspicious implicit sign extension\".\n    (c) Resource leaks in pcre2test in rare error cases.\n    (d) Avoid warning for never-use case OP_TABLE_LENGTH which is just a fudge\n        for checking at compile time that tables are the right size.\n    (e) Add missing \"fall through\" comment.\n\n29. Implemented PCRE2_EXTENDED_MORE and related /xx and (?xx) features.\n\n30. Implement (?n: for PCRE2_NO_AUTO_CAPTURE, because Perl now has this.\n\n31. If more than one of \"push\", \"pushcopy\", or \"pushtablescopy\" were set in\npcre2test, a crash could occur.\n\n32. Make -bigstack in RunTest allocate a 64MiB stack (instead of 16MiB) so\nthat all the tests can run with clang's sanitizing options.\n\n33. Implement extra compile options in the compile context and add the first\none: PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES.\n\n34. Implement newline type PCRE2_NEWLINE_NUL.\n\n35. A lookbehind assertion that had a zero-length branch caused undefined\nbehaviour when processed by pcre2_dfa_match(). This is oss-fuzz issue 1859.\n\n36. The match limit value now also applies to pcre2_dfa_match() as there are\npatterns that can use up a lot of resources without necessarily recursing very\ndeeply. (Compare item 10.23/36.) This should fix oss-fuzz #1761.\n\n37. Implement PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL.\n\n38. Fix returned offsets from regexec() when REG_STARTEND is used with a\nstarting offset greater than zero.\n\n39. Implement REG_PEND (GNU extension) for the POSIX wrapper.\n\n40. Implement the subject_literal modifier in pcre2test, and allow jitstack on\npattern lines.\n\n41. Implement PCRE2_LITERAL and use it to support REG_NOSPEC.\n\n42. Implement PCRE2_EXTRA_MATCH_LINE and PCRE2_EXTRA_MATCH_WORD for the benefit\nof pcre2grep.\n\n43. Re-implement pcre2grep's -F, -w, and -x options using PCRE2_LITERAL,\nPCRE2_EXTRA_MATCH_WORD, and PCRE2_EXTRA_MATCH_LINE. This fixes two bugs:\n\n    (a) The -F option did not work for fixed strings containing \\E.\n    (b) The -w option did not work for patterns with multiple branches.\n\n44. Added configuration options for the SELinux compatible execmem allocator in\nJIT.\n\n45. Increased the limit for searching for a \"must be present\" code unit in\nsubjects from 1000 to 2000 for 8-bit searches, since they use memchr() and are\nmuch faster.\n\n46. Arrange for anchored patterns to record and use \"first code unit\" data,\nbecause this can give a fast \"no match\" without searching for a \"required code\nunit\". Previously only non-anchored patterns did this.\n\n47. Upgraded the Unicode tables from Unicode 8.0.0 to Unicode 10.0.0.\n\n48. Add the callout_no_where modifier to pcre2test.\n\n49. Update extended grapheme breaking rules to the latest set that are in\nUnicode Standard Annex #29.\n\n50. Added experimental foreign pattern conversion facilities\n(pcre2_pattern_convert() and friends).\n\n51. Change the macro FWRITE, used in pcre2grep, to FWRITE_IGNORE because FWRITE\nis defined in a system header in cygwin. Also modified some of the #ifdefs in\npcre2grep related to Windows and Cygwin support.\n\n52. Change 3(g) for 10.23 was a bit too zealous. If a hyphen that follows a\ncharacter class is the last character in the class, Perl does not give a\nwarning. PCRE2 now also treats this as a literal.\n\n53. Related to 52, though PCRE2 was throwing an error for [[:digit:]-X] it was\nnot doing so for [\\d-X] (and similar escapes), as is documented.\n\n54. Fixed a MIPS issue in the JIT compiler reported by Joshua Kinard.\n\n55. Fixed a \"maybe uninitialized\" warning for class_uchardata in \\p handling in\npcre2_compile() which could never actually trigger (code should have been cut\nout when Unicode support is disabled).\n\n\nVersion 10.23 14-February-2017\n------------------------------\n\n1. Extended pcre2test with the utf8_input modifier so that it is able to\ngenerate all possible 16-bit and 32-bit code unit values in non-UTF modes.\n\n2. In any wide-character mode (8-bit UTF or any 16-bit or 32-bit mode), without\nPCRE2_UCP set, a negative character type such as \\D in a positive class should\ncause all characters greater than 255 to match, whatever else is in the class.\nThere was a bug that caused this not to happen if a Unicode property item was\nadded to such a class, for example [\\D\\P{Nd}] or [\\W\\pL].\n\n3. There has been a major re-factoring of the pcre2_compile.c file. Most syntax\nchecking is now done in the pre-pass that identifies capturing groups. This has\nreduced the amount of duplication and made the code tidier. While doing this,\nsome minor bugs and Perl incompatibilities were fixed, including:\n\n  (a) \\Q\\E in the middle of a quantifier such as A+\\Q\\E+ is now ignored instead\n      of giving an invalid quantifier error.\n\n  (b) {0} can now be used after a group in a lookbehind assertion; previously\n      this caused an \"assertion is not fixed length\" error.\n\n  (c) Perl always treats (?(DEFINE) as a \"define\" group, even if a group with\n      the name \"DEFINE\" exists. PCRE2 now does likewise.\n\n  (d) A recursion condition test such as (?(R2)...) must now refer to an\n      existing subpattern.\n\n  (e) A conditional recursion test such as (?(R)...) misbehaved if there was a\n      group whose name began with \"R\".\n\n  (f) When testing zero-terminated patterns under valgrind, the terminating\n      zero is now marked \"no access\". This catches bugs that would otherwise\n      show up only with non-zero-terminated patterns.\n\n  (g) A hyphen appearing immediately after a POSIX character class (for example\n      /[[:ascii:]-z]/) now generates an error. Perl does accept this as a\n      literal, but gives a warning, so it seems best to fail it in PCRE.\n\n  (h) An empty \\Q\\E sequence may appear after a callout that precedes an\n      assertion condition (it is, of course, ignored).\n\nOne effect of the refactoring is that some error numbers and messages have\nchanged, and the pattern offset given for compiling errors is not always the\nright-most character that has been read. In particular, for a variable-length\nlookbehind assertion it now points to the start of the assertion. Another\nchange is that when a callout appears before a group, the \"length of next\npattern item\" that is passed now just gives the length of the opening\nparenthesis item, not the length of the whole group. A length of zero is now\ngiven only for a callout at the end of the pattern. Automatic callouts are no\nlonger inserted before and after explicit callouts in the pattern.\n\nA number of bugs in the refactored code were subsequently fixed during testing\nbefore release, but after the code was made available in the repository. Many\nof the bugs were discovered by fuzzing testing. Several of them were related to\nthe change from assuming a zero-terminated pattern (which previously had\nrequired non-zero terminated strings to be copied). These bugs were never in\nfully released code, but are noted here for the record.\n\n  (a) An overall recursion such as (?0) inside a lookbehind assertion was not\n      being diagnosed as an error.\n\n  (b) In utf mode, the length of a *MARK (or other verb) name was being checked\n      in characters instead of code units, which could lead to bad code being\n      compiled, leading to unpredictable behaviour.\n\n  (c) In extended /x mode, characters whose code was greater than 255 caused\n      a lookup outside one of the global tables. A similar bug existed for wide\n      characters in *VERB names.\n\n  (d) The amount of memory needed for a compiled pattern was miscalculated if a\n      lookbehind contained more than one toplevel branch and the first branch\n      was of length zero.\n\n  (e) In UTF-8 or UTF-16 modes with PCRE2_EXTENDED (/x) set and a non-zero-\n      terminated pattern, if a # comment ran on to the end of the pattern, one\n      or more code units past the end were being read.\n\n  (f) An unterminated repeat at the end of a non-zero-terminated pattern (e.g.\n      \"{2,2\") could cause reading beyond the pattern.\n\n  (g) When reading a callout string, if the end delimiter was at the end of the\n      pattern one further code unit was read.\n\n  (h) An unterminated number after \\g' could cause reading beyond the pattern.\n\n  (i) An insufficient memory size was being computed for compiling with\n      PCRE2_AUTO_CALLOUT.\n\n  (j) A conditional group with an assertion condition used more memory than was\n      allowed for it during parsing, so too many of them could therefore\n      overrun a buffer.\n\n  (k) If parsing a pattern exactly filled the buffer, the internal test for\n      overrun did not check when the final META_END item was added.\n\n  (l) If a lookbehind contained a subroutine call, and the called group\n      contained an option setting such as (?s), and the PCRE2_ANCHORED option\n      was set, unpredictable behaviour could occur. The underlying bug was\n      incorrect code and insufficient checking while searching for the end of\n      the called subroutine in the parsed pattern.\n\n  (m) Quantifiers following (*VERB)s were not being diagnosed as errors.\n\n  (n) The use of \\Q...\\E in a (*VERB) name when PCRE2_ALT_VERBNAMES and\n      PCRE2_AUTO_CALLOUT were both specified caused undetermined behaviour.\n\n  (o) If \\Q was preceded by a quantified item, and the following \\E was\n      followed by '?' or '+', and there was at least one literal character\n      between them, an internal error \"unexpected repeat\" occurred (example:\n      /.+\\QX\\E+/).\n\n  (p) A buffer overflow could occur while sorting the names in the group name\n      list (depending on the order in which the names were seen).\n\n  (q) A conditional group that started with a callout was not doing the right\n      check for a following assertion, leading to compiling bad code. Example:\n      /(?(C'XX))?!XX/\n\n  (r) If a character whose code point was greater than 0xffff appeared within\n      a lookbehind that was within another lookbehind, the calculation of the\n      lookbehind length went wrong and could provoke an internal error.\n\n  (t) The sequence \\E- or \\Q\\E- after a POSIX class in a character class caused\n      an internal error. Now the hyphen is treated as a literal.\n\n4. Back references are now permitted in lookbehind assertions when there are\nno duplicated group numbers (that is, (?| has not been used), and, if the\nreference is by name, there is only one group of that name. The referenced\ngroup must, of course be of fixed length.\n\n5. pcre2test has been upgraded so that, when run under valgrind with valgrind\nsupport enabled, reading past the end of the pattern is detected, both when\ncompiling and during callout processing.\n\n6. \\g{+<number>} (e.g. \\g{+2} ) is now supported. It is a \"forward back\nreference\" and can be useful in repetitions (compare \\g{-<number>} ). Perl does\nnot recognize this syntax.\n\n7. Automatic callouts are no longer generated before and after callouts in the\npattern.\n\n8. When pcre2test was outputing information from a callout, the caret indicator\nfor the current position in the subject line was incorrect if it was after an\nescape sequence for a character whose code point was greater than \\x{ff}.\n\n9. Change 19 for 10.22 had a typo (PCRE_STATIC_RUNTIME should be\nPCRE2_STATIC_RUNTIME). Fix from David Gaussmann.\n\n10. Added --max-buffer-size to pcre2grep, to allow for automatic buffer\nexpansion when long lines are encountered. Original patch by Dmitry\nCherniachenko.\n\n11. If pcre2grep was compiled with JIT support, but the library was compiled\nwithout it (something that neither ./configure nor CMake allow, but it can be\ndone by editing config.h), pcre2grep was giving a JIT error. Now it detects\nthis situation and does not try to use JIT.\n\n12. Added some \"const\" qualifiers to variables in pcre2grep.\n\n13. Added Dmitry Cherniachenko's patch for colouring output in Windows\n(untested by me). Also, look for GREP_COLOUR or GREP_COLOR if the environment\nvariables PCRE2GREP_COLOUR and PCRE2GREP_COLOR are not found.\n\n14. Add the -t (grand total) option to pcre2grep.\n\n15. A number of bugs have been mended relating to match start-up optimizations\nwhen the first thing in a pattern is a positive lookahead. These all applied\nonly when PCRE2_NO_START_OPTIMIZE was *not* set:\n\n    (a) A pattern such as (?=.*X)X$ was incorrectly optimized as if it needed\n        both an initial 'X' and a following 'X'.\n    (b) Some patterns starting with an assertion that started with .* were\n        incorrectly optimized as having to match at the start of the subject or\n        after a newline. There are cases where this is not true, for example,\n        (?=.*[A-Z])(?=.{8,16})(?!.*[\\s]) matches after the start in lines that\n        start with spaces. Starting .* in an assertion is no longer taken as an\n        indication of matching at the start (or after a newline).\n\n16. The \"offset\" modifier in pcre2test was not being ignored (as documented)\nwhen the POSIX API was in use.\n\n17. Added --enable-fuzz-support to \"configure\", causing an non-installed\nlibrary containing a test function that can be called by fuzzers to be\ncompiled. A non-installed  binary to run the test function locally, called\npcre2fuzzcheck is also compiled.\n\n18. A pattern with PCRE2_DOTALL (/s) set but not PCRE2_NO_DOTSTAR_ANCHOR, and\nwhich started with .* inside a positive lookahead was incorrectly being\ncompiled as implicitly anchored.\n\n19. Removed all instances of \"register\" declarations, as they are considered\nobsolete these days and in any case had become very haphazard.\n\n20. Add strerror() to pcre2test for failed file opening.\n\n21. Make pcre2test -C list valgrind support when it is enabled.\n\n22. Add the use_length modifier to pcre2test.\n\n23. Fix an off-by-one bug in pcre2test for the list of names for 'get' and\n'copy' modifiers.\n\n24. Add PCRE2_CALL_CONVENTION into the prototype declarations in pcre2.h as it\nis apparently needed there as well as in the function definitions. (Why did\nnobody ask for this in PCRE1?)\n\n25. Change the _PCRE2_H and _PCRE2_UCP_H guard macros in the header files to\nPCRE2_H_IDEMPOTENT_GUARD and PCRE2_UCP_H_IDEMPOTENT_GUARD to be more standard\ncompliant and unique.\n\n26. pcre2-config --libs-posix was listing -lpcre2posix instead of\n-lpcre2-posix. Also, the CMake build process was building the library with the\nwrong name.\n\n27. In pcre2test, give some offset information for errors in hex patterns.\nThis uses the C99 formatting sequence %td, except for MSVC which doesn't\nsupport it - %lu is used instead.\n\n28. Implemented pcre2_code_copy_with_tables(), and added pushtablescopy to\npcre2test for testing it.\n\n29. Fix small memory leak in pcre2test.\n\n30. Fix out-of-bounds read for partial matching of /./ against an empty string\nwhen the newline type is CRLF.\n\n31. Fix a bug in pcre2test that caused a crash when a locale was set either in\nthe current pattern or a previous one and a wide character was matched.\n\n32. The appearance of \\p, \\P, or \\X in a substitution string when\nPCRE2_SUBSTITUTE_EXTENDED was set caused a segmentation fault (NULL\ndereference).\n\n33. If the starting offset was specified as greater than the subject length in\na call to pcre2_substitute() an out-of-bounds memory reference could occur.\n\n34. When PCRE2 was compiled to use the heap instead of the stack for recursive\ncalls to match(), a repeated minimizing caseless back reference, or a\nmaximizing one where the two cases had different numbers of code units,\nfollowed by a caseful back reference, could lose the caselessness of the first\nrepeated back reference (example: /(Z)(a)\\2{1,2}?(?-i)\\1X/i should match ZaAAZX\nbut didn't).\n\n35. When a pattern is too complicated, PCRE2 gives up trying to find a minimum\nmatching length and just records zero. Typically this happens when there are\ntoo many nested or recursive back references. If the limit was reached in\ncertain recursive cases it failed to be triggered and an internal error could\nbe the result.\n\n36. The pcre2_dfa_match() function now takes note of the recursion limit for\nthe internal recursive calls that are used for lookrounds and recursions within\nthe pattern.\n\n37. More refactoring has got rid of the internal could_be_empty_branch()\nfunction (around 400 lines of code, including comments) by keeping track of\ncould-be-emptiness as the pattern is compiled instead of scanning compiled\ngroups. (This would have been much harder before the refactoring of #3 above.)\nThis lifts a restriction on the number of branches in a group (more than about\n1100 would give \"pattern is too complicated\").\n\n38. Add the \"-ac\" command line option to pcre2test as a synonym for \"-pattern\nauto_callout\".\n\n39. In a library with Unicode support, incorrect data was compiled for a\npattern with PCRE2_UCP set without PCRE2_UTF if a class required all wide\ncharacters to match (for example, /[\\s[:^ascii:]]/).\n\n40. The callout_error modifier has been added to pcre2test to make it possible\nto return PCRE2_ERROR_CALLOUT from a callout.\n\n41. A minor change to pcre2grep: colour reset is now \"<esc>[0m\" instead of\n\"<esc>[00m\".\n\n42. The limit in the auto-possessification code that was intended to catch\noverly-complicated patterns and not spend too much time auto-possessifying was\nbeing reset too often, resulting in very long compile times for some patterns.\nNow such patterns are no longer completely auto-possessified.\n\n43. Applied Jason Hood's revised patch for RunTest.bat.\n\n44. Added a new Windows script RunGrepTest.bat, courtesy of Jason Hood.\n\n45. Minor cosmetic fix to pcre2test: move a variable that is not used under\nWindows into the \"not Windows\" code.\n\n46. Applied Jason Hood's patches to upgrade pcre2grep under Windows and tidy\nsome of the code:\n\n  * normalised the Windows condition by ensuring WIN32 is defined;\n  * enables the callout feature under Windows;\n  * adds globbing (Microsoft's implementation expands quoted args),\n    using a tweaked opendirectory;\n  * implements the is_*_tty functions for Windows;\n  * --color=always will write the ANSI sequences to file;\n  * add sequences 4 (underline works on Win10) and 5 (blink as bright\n    background, relatively standard on DOS/Win);\n  * remove the (char *) casts for the now-const strings;\n  * remove GREP_COLOUR (grep's command line allowed the 'u', but not\n    the environment), parsing GREP_COLORS instead;\n  * uses the current colour if not set, rather than black;\n  * add print_match for the undefined case;\n  * fixes a typo.\n\nIn addition, colour settings containing anything other than digits and\nsemicolon are ignored, and the colour controls are no longer output for empty\nstrings.\n\n47. Detecting patterns that are too large inside the length-measuring loop\nsaves processing ridiculously long patterns to their end.\n\n48. Ignore PCRE2_CASELESS when processing \\h, \\H, \\v, and \\V in classes as it\njust wastes time. In the UTF case it can also produce redundant entries in\nXCLASS lists caused by characters with multiple other cases and pairs of\ncharacters in the same \"not-x\" sublists.\n\n49. A pattern such as /(?=(a\\K))/ can report the end of the match being before\nits start; pcre2test was not handling this correctly when using the POSIX\ninterface (it was OK with the native interface).\n\n50. In pcre2grep, ignore all JIT compile errors. This means that pcre2grep will\ncontinue to work, falling back to interpretation if anything goes wrong with\nJIT.\n\n51. Applied patches from Christian Persch to configure.ac to make use of the\nAC_USE_SYSTEM_EXTENSIONS macro and to test for functions used by the JIT\nmodules.\n\n52. Minor fixes to pcre2grep from Jason Hood:\n    * fixed some spacing;\n    * Windows doesn't usually use single quotes, so I've added a define\n      to use appropriate quotes [in an example];\n    * LC_ALL was displayed as \"LCC_ALL\";\n    * numbers 11, 12 & 13 should end in \"th\";\n    * use double quotes in usage message.\n\n53. When autopossessifying, skip empty branches without recursion, to reduce\nstack usage for the benefit of clang with -fsanitize-address, which uses huge\nstack frames. Example pattern: /X?(R||){3335}/. Fixes oss-fuzz issue 553.\n\n54. A pattern with very many explicit back references to a group that is a long\nway from the start of the pattern could take a long time to compile because\nsearching for the referenced group in order to find the minimum length was\nbeing done repeatedly. Now up to 128 group minimum lengths are cached and the\nattempt to find a minimum length is abandoned if there is a back reference to a\ngroup whose number is greater than 128. (In that case, the pattern is so\ncomplicated that this optimization probably isn't worth it.) This fixes\noss-fuzz issue 557.\n\n55. Issue 32 for 10.22 below was not correctly fixed. If pcre2grep in multiline\nmode with --only-matching matched several lines, it restarted scanning at the\nnext line instead of moving on to the end of the matched string, which can be\nseveral lines after the start.\n\n56. Applied Jason Hood's new patch for RunGrepTest.bat that updates it in line\nwith updates to the non-Windows version.\n\n\n\nVersion 10.22 29-July-2016\n--------------------------\n\n1. Applied Jason Hood's patches to RunTest.bat and testdata/wintestoutput3\nto fix problems with running the tests under Windows.\n\n2. Implemented a facility for quoting literal characters within hexadecimal\npatterns in pcre2test, to make it easier to create patterns with just a few\nnon-printing characters.\n\n3. Binary zeros are not supported in pcre2test input files. It now detects them\nand gives an error.\n\n4. Updated the valgrind parameters in RunTest: (a) changed smc-check=all to\nsmc-check=all-non-file; (b) changed obj:* in the suppression file to obj:??? so\nthat it matches only unknown objects.\n\n5. Updated the maintenance script maint/ManyConfigTests to make it easier to\nselect individual groups of tests.\n\n6. When the POSIX wrapper function regcomp() is called, the REG_NOSUB option\nused to set PCRE2_NO_AUTO_CAPTURE when calling pcre2_compile(). However, this\ndisables the use of back references (and subroutine calls), which are supported\nby other implementations of regcomp() with RE_NOSUB. Therefore, REG_NOSUB no\nlonger causes PCRE2_NO_AUTO_CAPTURE to be set, though it still ignores nmatch\nand pmatch when regexec() is called.\n\n7. Because of 6 above, pcre2test has been modified with a new modifier called\nposix_nosub, to call regcomp() with REG_NOSUB. Previously the no_auto_capture\nmodifier had this effect. That option is now ignored when the POSIX API is in\nuse.\n\n8. Minor tidies to the pcre2demo.c sample program, including more comments\nabout its 8-bit-ness.\n\n9. Detect unmatched closing parentheses and give the error in the pre-scan\ninstead of later. Previously the pre-scan carried on and could give a\nmisleading incorrect error message. For example, /(?J)(?'a'))(?'a')/ gave a\nmessage about invalid duplicate group names.\n\n10. It has happened that pcre2test was accidentally linked with another POSIX\nregex library instead of libpcre2-posix. In this situation, a call to regcomp()\n(in the other library) may succeed, returning zero, but of course putting its\nown data into the regex_t block. In one example the re_pcre2_code field was\nleft as NULL, which made pcre2test think it had not got a compiled POSIX regex,\nso it treated the next line as another pattern line, resulting in a confusing\nerror message. A check has been added to pcre2test to see if the data returned\nfrom a successful call of regcomp() are valid for PCRE2's regcomp(). If they\nare not, an error message is output and the pcre2test run is abandoned. The\nmessage points out the possibility of a mis-linking. Hopefully this will avoid\nsome head-scratching the next time this happens.\n\n11. A pattern such as /(?<=((?C)0))/, which has a callout inside a lookbehind\nassertion, caused pcre2test to output a very large number of spaces when the\ncallout was taken, making the program appearing to loop.\n\n12. A pattern that included (*ACCEPT) in the middle of a sufficiently deeply\nnested set of parentheses of sufficient size caused an overflow of the\ncompiling workspace (which was diagnosed, but of course is not desirable).\n\n13. Detect missing closing parentheses during the pre-pass for group\nidentification.\n\n14. Changed some integer variable types and put in a number of casts, following\na report of compiler warnings from Visual Studio 2013 and a few tests with\ngcc's -Wconversion (which still throws up a lot).\n\n15. Implemented pcre2_code_copy(), and added pushcopy and #popcopy to pcre2test\nfor testing it.\n\n16. Change 66 for 10.21 introduced the use of snprintf() in PCRE2's version of\nregerror(). When the error buffer is too small, my version of snprintf() puts a\nbinary zero in the final byte. Bug #1801 seems to show that other versions do\nnot do this, leading to bad output from pcre2test when it was checking for\nbuffer overflow. It no longer assumes a binary zero at the end of a too-small\nregerror() buffer.\n\n17. Fixed typo (\"&&\" for \"&\") in pcre2_study(). Fortunately, this could not\nactually affect anything, by sheer luck.\n\n18. Two minor fixes for MSVC compilation: (a) removal of apparently incorrect\n\"const\" qualifiers in pcre2test and (b) defining snprintf as _snprintf for\nolder MSVC compilers. This has been done both in src/pcre2_internal.h for most\nof the library, and also in src/pcre2posix.c, which no longer includes\npcre2_internal.h (see 24 below).\n\n19. Applied Chris Wilson's patch (Bugzilla #1681) to CMakeLists.txt for MSVC\nstatic compilation. Subsequently applied Chris Wilson's second patch, putting\nthe first patch under a new option instead of being unconditional when\nPCRE_STATIC is set.\n\n20. Updated pcre2grep to set stdout as binary when run under Windows, so as not\nto convert \\r\\n at the ends of reflected lines into \\r\\r\\n. This required\nensuring that other output that is written to stdout (e.g. file names) uses the\nappropriate line terminator: \\r\\n for Windows, \\n otherwise.\n\n21. When a line is too long for pcre2grep's internal buffer, show the maximum\nlength in the error message.\n\n22. Added support for string callouts to pcre2grep (Zoltan's patch with PH\nadditions).\n\n23. RunTest.bat was missing a \"set type\" line for test 22.\n\n24. The pcre2posix.c file was including pcre2_internal.h, and using some\n\"private\" knowledge of the data structures. This is unnecessary; the code has\nbeen re-factored and no longer includes pcre2_internal.h.\n\n25. A racing condition is fixed in JIT reported by Mozilla.\n\n26. Minor code refactor to avoid \"array subscript is below array bounds\"\ncompiler warning.\n\n27. Minor code refactor to avoid \"left shift of negative number\" warning.\n\n28. Add a bit more sanity checking to pcre2_serialize_decode() and document\nthat it expects trusted data.\n\n29. Fix typo in pcre2_jit_test.c\n\n30. Due to an oversight, pcre2grep was not making use of JIT when available.\nThis is now fixed.\n\n31. The RunGrepTest script is updated to use the valgrind suppressions file\nwhen testing with JIT under valgrind (compare 10.21/51 below). The suppressions\nfile is updated so that is now the same as for PCRE1: it suppresses the\nMemcheck warnings Addr16 and Cond in unknown objects (that is, JIT-compiled\ncode). Also changed smc-check=all to smc-check=all-non-file as was done for\nRunTest (see 4 above).\n\n32. Implemented the PCRE2_NO_JIT option for pcre2_match().\n\n33. Fix typo that gave a compiler error when JIT not supported.\n\n34. Fix comment describing the returns from find_fixedlength().\n\n35. Fix potential negative index in pcre2test.\n\n36. Calls to pcre2_get_error_message() with error numbers that are never\nreturned by PCRE2 functions were returning empty strings. Now the error code\nPCRE2_ERROR_BADDATA is returned. A facility has been added to pcre2test to\nshow the texts for given error numbers (i.e. to call pcre2_get_error_message()\nand display what it returns) and a few representative error codes are now\nchecked in RunTest.\n\n37. Added \"&& !defined(__INTEL_COMPILER)\" to the test for __GNUC__ in\npcre2_match.c, in anticipation that this is needed for the same reason it was\nrecently added to pcrecpp.cc in PCRE1.\n\n38. Using -o with -M in pcre2grep could cause unnecessary repeated output when\nthe match extended over a line boundary, as it tried to find more matches \"on\nthe same line\" - but it was already over the end.\n\n39. Allow \\C in lookbehinds and DFA matching in UTF-32 mode (by converting it\nto the same code as '.' when PCRE2_DOTALL is set).\n\n40. Fix two clang compiler warnings in pcre2test when only one code unit width\nis supported.\n\n41. Upgrade RunTest to automatically re-run test 2 with a large (64MiB) stack\nif it fails when running the interpreter with a 16MiB stack (and if changing\nthe stack size via pcre2test is possible). This avoids having to manually set a\nlarge stack size when testing with clang.\n\n42. Fix register overwite in JIT when SSE2 acceleration is enabled.\n\n43. Detect integer overflow in pcre2test pattern and data repetition counts.\n\n44. In pcre2test, ignore \"allcaptures\" after DFA matching.\n\n45. Fix unaligned accesses on x86. Patch by Marc Mutz.\n\n46. Fix some more clang compiler warnings.\n\n\nVersion 10.21 12-January-2016\n-----------------------------\n\n1. Improve matching speed of patterns starting with + or * in JIT.\n\n2. Use memchr() to find the first character in an unanchored match in 8-bit\nmode in the interpreter. This gives a significant speed improvement.\n\n3. Removed a redundant copy of the opcode_possessify table in the\npcre2_auto_possessify.c source.\n\n4. Fix typos in dftables.c for z/OS.\n\n5. Change 36 for 10.20 broke the handling of [[:>:]] and [[:<:]] in that\nprocessing them could involve a buffer overflow if the following character was\nan opening parenthesis.\n\n6. Change 36 for 10.20 also introduced a bug in processing this pattern:\n/((?x)(*:0))#(?'/. Specifically: if a setting of (?x) was followed by a (*MARK)\nsetting (which (*:0) is), then (?x) did not get unset at the end of its group\nduring the scan for named groups, and hence the external # was incorrectly\ntreated as a comment and the invalid (?' at the end of the pattern was not\ndiagnosed. This caused a buffer overflow during the real compile. This bug was\ndiscovered by Karl Skomski with the LLVM fuzzer.\n\n7. Moved the pcre2_find_bracket() function from src/pcre2_compile.c into its\nown source module to avoid a circular dependency between src/pcre2_compile.c\nand src/pcre2_study.c\n\n8. A callout with a string argument containing an opening square bracket, for\nexample /(?C$[$)(?<]/, was incorrectly processed and could provoke a buffer\noverflow. This bug was discovered by Karl Skomski with the LLVM fuzzer.\n\n9. The handling of callouts during the pre-pass for named group identification\nhas been tightened up.\n\n10. The quantifier {1} can be ignored, whether greedy, non-greedy, or\npossessive. This is a very minor optimization.\n\n11. A possessively repeated conditional group that could match an empty string,\nfor example, /(?(R))*+/, was incorrectly compiled.\n\n12. The Unicode tables have been updated to Unicode 8.0.0 (thanks to Christian\nPersch).\n\n13. An empty comment (?#) in a pattern was incorrectly processed and could\nprovoke a buffer overflow. This bug was discovered by Karl Skomski with the\nLLVM fuzzer.\n\n14. Fix infinite recursion in the JIT compiler when certain patterns such as\n/(?:|a|){100}x/ are analysed.\n\n15. Some patterns with character classes involving [: and \\\\ were incorrectly\ncompiled and could cause reading from uninitialized memory or an incorrect\nerror diagnosis. Examples are: /[[:\\\\](?<[::]/ and /[[:\\\\](?'abc')[a:]. The\nfirst of these bugs was discovered by Karl Skomski with the LLVM fuzzer.\n\n16. Pathological patterns containing many nested occurrences of [: caused\npcre2_compile() to run for a very long time. This bug was found by the LLVM\nfuzzer.\n\n17. A missing closing parenthesis for a callout with a string argument was not\nbeing diagnosed, possibly leading to a buffer overflow. This bug was found by\nthe LLVM fuzzer.\n\n18. A conditional group with only one branch has an implicit empty alternative\nbranch and must therefore be treated as potentially matching an empty string.\n\n19. If (?R was followed by - or + incorrect behaviour happened instead of a\ndiagnostic. This bug was discovered by Karl Skomski with the LLVM fuzzer.\n\n20. Another bug that was introduced by change 36 for 10.20: conditional groups\nwhose condition was an assertion preceded by an explicit callout with a string\nargument might be incorrectly processed, especially if the string contained \\Q.\nThis bug was discovered by Karl Skomski with the LLVM fuzzer.\n\n21. Compiling PCRE2 with the sanitize options of clang showed up a number of\nvery pedantic coding infelicities and a buffer overflow while checking a UTF-8\nstring if the final multi-byte UTF-8 character was truncated.\n\n22. For Perl compatibility in EBCDIC environments, ranges such as a-z in a\nclass, where both values are literal letters in the same case, omit the\nnon-letter EBCDIC code points within the range.\n\n23. Finding the minimum matching length of complex patterns with back\nreferences and/or recursions can take a long time. There is now a cut-off that\ngives up trying to find a minimum length when things get too complex.\n\n24. An optimization has been added that speeds up finding the minimum matching\nlength for patterns containing repeated capturing groups or recursions.\n\n25. If a pattern contained a back reference to a group whose number was\nduplicated as a result of appearing in a (?|...) group, the computation of the\nminimum matching length gave a wrong result, which could cause incorrect \"no\nmatch\" errors. For such patterns, a minimum matching length cannot at present\nbe computed.\n\n26. Added a check for integer overflow in conditions (?(<digits>) and\n(?(R<digits>). This omission was discovered by Karl Skomski with the LLVM\nfuzzer.\n\n27. Fixed an issue when \\p{Any} inside an xclass did not read the current\ncharacter.\n\n28. If pcre2grep was given the -q option with -c or -l, or when handling a\nbinary file, it incorrectly wrote output to stdout.\n\n29. The JIT compiler did not restore the control verb head in case of *THEN\ncontrol verbs. This issue was found by Karl Skomski with a custom LLVM fuzzer.\n\n30. The way recursive references such as (?3) are compiled has been re-written\nbecause the old way was the cause of many issues. Now, conversion of the group\nnumber into a pattern offset does not happen until the pattern has been\ncompletely compiled. This does mean that detection of all infinitely looping\nrecursions is postponed till match time. In the past, some easy ones were\ndetected at compile time. This re-writing was done in response to yet another\nbug found by the LLVM fuzzer.\n\n31. A test for a back reference to a non-existent group was missing for items\nsuch as \\987. This caused incorrect code to be compiled. This issue was found\nby Karl Skomski with a custom LLVM fuzzer.\n\n32. Error messages for syntax errors following \\g and \\k were giving inaccurate\noffsets in the pattern.\n\n33. Improve the performance of starting single character repetitions in JIT.\n\n34. (*LIMIT_MATCH=) now gives an error instead of setting the value to 0.\n\n35. Error messages for syntax errors in *LIMIT_MATCH and *LIMIT_RECURSION now\ngive the right offset instead of zero.\n\n36. The JIT compiler should not check repeats after a {0,1} repeat byte code.\nThis issue was found by Karl Skomski with a custom LLVM fuzzer.\n\n37. The JIT compiler should restore the control chain for empty possessive\nrepeats. This issue was found by Karl Skomski with a custom LLVM fuzzer.\n\n38. A bug which was introduced by the single character repetition optimization\nwas fixed.\n\n39. Match limit check added to recursion. This issue was found by Karl Skomski\nwith a custom LLVM fuzzer.\n\n40. Arrange for the UTF check in pcre2_match() and pcre2_dfa_match() to look\nonly at the part of the subject that is relevant when the starting offset is\nnon-zero.\n\n41. Improve first character match in JIT with SSE2 on x86.\n\n42. Fix two assertion fails in JIT. These issues were found by Karl Skomski\nwith a custom LLVM fuzzer.\n\n43. Correct the setting of CMAKE_C_FLAGS in CMakeLists.txt (patch from Roy Ivy\nIII).\n\n44. Fix bug in RunTest.bat for new test 14, and adjust the script for the added\ntest (there are now 20 in total).\n\n45. Fixed a corner case of range optimization in JIT.\n\n46. Add the ${*MARK} facility to pcre2_substitute().\n\n47. Modifier lists in pcre2test were splitting at spaces without the required\ncommas.\n\n48. Implemented PCRE2_ALT_VERBNAMES.\n\n49. Fixed two issues in JIT. These were found by Karl Skomski with a custom\nLLVM fuzzer.\n\n50. The pcre2test program has been extended by adding the #newline_default\ncommand. This has made it possible to run the standard tests when PCRE2 is\ncompiled with either CR or CRLF as the default newline convention. As part of\nthis work, the new command was added to several test files and the testing\nscripts were modified. The pcre2grep tests can now also be run when there is no\nLF in the default newline convention.\n\n51. The RunTest script has been modified so that, when JIT is used and valgrind\nis specified, a valgrind suppressions file is set up to ignore \"Invalid read of\nsize 16\" errors because these are false positives when the hardware supports\nthe SSE2 instruction set.\n\n52. It is now possible to have comment lines amid the subject strings in\npcre2test (and perltest.sh) input.\n\n53. Implemented PCRE2_USE_OFFSET_LIMIT and pcre2_set_offset_limit().\n\n54. Add the null_context modifier to pcre2test so that calling pcre2_compile()\nand the matching functions with NULL contexts can be tested.\n\n55. Implemented PCRE2_SUBSTITUTE_EXTENDED.\n\n56. In a character class such as [\\W\\p{Any}] where both a negative-type escape\n(\"not a word character\") and a property escape were present, the property\nescape was being ignored.\n\n57. Fixed integer overflow for patterns whose minimum matching length is very,\nvery large.\n\n58. Implemented --never-backslash-C.\n\n59. Change 55 above introduced a bug by which certain patterns provoked the\nerroneous error \"\\ at end of pattern\".\n\n60. The special sequences [[:<:]] and [[:>:]] gave rise to incorrect compiling\nerrors or other strange effects if compiled in UCP mode. Found with libFuzzer\nand AddressSanitizer.\n\n61. Whitespace at the end of a pcre2test pattern line caused a spurious error\nmessage if there were only single-character modifiers. It should be ignored.\n\n62. The use of PCRE2_NO_AUTO_CAPTURE could cause incorrect compilation results\nor segmentation errors for some patterns. Found with libFuzzer and\nAddressSanitizer.\n\n63. Very long names in (*MARK) or (*THEN) etc. items could provoke a buffer\noverflow.\n\n64. Improve error message for overly-complicated patterns.\n\n65. Implemented an optional replication feature for patterns in pcre2test, to\nmake it easier to test long repetitive patterns. The tests for 63 above are\nconverted to use the new feature.\n\n66. In the POSIX wrapper, if regerror() was given too small a buffer, it could\nmisbehave.\n\n67. In pcre2_substitute() in UTF mode, the UTF validity check on the\nreplacement string was happening before the length setting when the replacement\nstring was zero-terminated.\n\n68. In pcre2_substitute() in UTF mode, PCRE2_NO_UTF_CHECK can be set for the\nsecond and subsequent calls to pcre2_match().\n\n69. There was no check for integer overflow for a replacement group number in\npcre2_substitute(). An added check for a number greater than the largest group\nnumber in the pattern means this is not now needed.\n\n70. The PCRE2-specific VERSION condition didn't work correctly if only one\ndigit was given after the decimal point, or if more than two digits were given.\nIt now works with one or two digits, and gives a compile time error if more are\ngiven.\n\n71. In pcre2_substitute() there was the possibility of reading one code unit\nbeyond the end of the replacement string.\n\n72. The code for checking a subject's UTF-32 validity for a pattern with a\nlookbehind involved an out-of-bounds pointer, which could potentially cause\ntrouble in some environments.\n\n73. The maximum lookbehind length was incorrectly calculated for patterns such\nas /(?<=(a)(?-1))x/ which have a recursion within a backreference.\n\n74. Give an error if a lookbehind assertion is longer than 65535 code units.\n\n75. Give an error in pcre2_substitute() if a match ends before it starts (as a\nresult of the use of \\K).\n\n76. Check the length of subpattern names and the names in (*MARK:xx) etc.\ndynamically to avoid the possibility of integer overflow.\n\n77. Implement pcre2_set_max_pattern_length() so that programs can restrict the\nsize of patterns that they are prepared to handle.\n\n78. (*NO_AUTO_POSSESS) was not working.\n\n79. Adding group information caching improves the speed of compiling when\nchecking whether a group has a fixed length and/or could match an empty string,\nespecially when recursion or subroutine calls are involved. However, this\ncannot be used when (?| is present in the pattern because the same number may\nbe used for groups of different sizes. To catch runaway patterns in this\nsituation, counts have been introduced to the functions that scan for empty\nbranches or compute fixed lengths.\n\n80. Allow for the possibility of the size of the nest_save structure not being\na factor of the size of the compiling workspace (it currently is).\n\n81. Check for integer overflow in minimum length calculation and cap it at\n65535.\n\n82. Small optimizations in code for finding the minimum matching length.\n\n83. Lock out configuring for EBCDIC with non-8-bit libraries.\n\n84. Test for error code <= 0 in regerror().\n\n85. Check for too many replacements (more than INT_MAX) in pcre2_substitute().\n\n86. Avoid the possibility of computing with an out-of-bounds pointer (though\nnot dereferencing it) while handling lookbehind assertions.\n\n87. Failure to get memory for the match data in regcomp() is now given as a\nregcomp() error instead of waiting for regexec() to pick it up.\n\n88. In pcre2_substitute(), ensure that CRLF is not split when it is a valid\nnewline sequence.\n\n89. Paranoid check in regcomp() for bad error code from pcre2_compile().\n\n90. Run test 8 (internal offsets and code sizes) for link sizes 3 and 4 as well\nas for link size 2.\n\n91. Document that JIT has a limit on pattern size, and give more information\nabout JIT compile failures in pcre2test.\n\n92. Implement PCRE2_INFO_HASBACKSLASHC.\n\n93. Re-arrange valgrind support code in pcre2test to avoid spurious reports\nwith JIT (possibly caused by SSE2?).\n\n94. Support offset_limit in JIT.\n\n95. A sequence such as [[:punct:]b] that is, a POSIX character class followed\nby a single ASCII character in a class item, was incorrectly compiled in UCP\nmode. The POSIX class got lost, but only if the single character followed it.\n\n96. [:punct:] in UCP mode was matching some characters in the range 128-255\nthat should not have been matched.\n\n97. If [:^ascii:] or [:^xdigit:] are present in a non-negated class, all\ncharacters with code points greater than 255 are in the class. When a Unicode\nproperty was also in the class (if PCRE2_UCP is set, escapes such as \\w are\nturned into Unicode properties), wide characters were not correctly handled,\nand could fail to match.\n\n98. In pcre2test, make the \"startoffset\" modifier a synonym of \"offset\",\nbecause it sets the \"startoffset\" parameter for pcre2_match().\n\n99. If PCRE2_AUTO_CALLOUT was set on a pattern that had a (?# comment between\nan item and its qualifier (for example, A(?#comment)?B) pcre2_compile()\nmisbehaved. This bug was found by the LLVM fuzzer.\n\n100. The error for an invalid UTF pattern string always gave the code unit\noffset as zero instead of where the invalidity was found.\n\n101. Further to 97 above, negated classes such as [^[:^ascii:]\\d] were also not\nworking correctly in UCP mode.\n\n102. Similar to 99 above, if an isolated \\E was present between an item and its\nqualifier when PCRE2_AUTO_CALLOUT was set, pcre2_compile() misbehaved. This bug\nwas found by the LLVM fuzzer.\n\n103. The POSIX wrapper function regexec() crashed if the option REG_STARTEND\nwas set when the pmatch argument was NULL. It now returns REG_INVARG.\n\n104. Allow for up to 32-bit numbers in the ordin() function in pcre2grep.\n\n105. An empty \\Q\\E sequence between an item and its qualifier caused\npcre2_compile() to misbehave when auto callouts were enabled. This bug\nwas found by the LLVM fuzzer.\n\n106. If both PCRE2_ALT_VERBNAMES and PCRE2_EXTENDED were set, and a (*MARK) or\nother verb \"name\" ended with whitespace immediately before the closing\nparenthesis, pcre2_compile() misbehaved. Example: /(*:abc )/, but only when\nboth those options were set.\n\n107. In a number of places pcre2_compile() was not handling NULL characters\ncorrectly, and pcre2test with the \"bincode\" modifier was not always correctly\ndisplaying fields containing NULLS:\n\n   (a) Within /x extended #-comments\n   (b) Within the \"name\" part of (*MARK) and other *verbs\n   (c) Within the text argument of a callout\n\n108. If a pattern that was compiled with PCRE2_EXTENDED started with white\nspace or a #-type comment that was followed by (?-x), which turns off\nPCRE2_EXTENDED, and there was no subsequent (?x) to turn it on again,\npcre2_compile() assumed that (?-x) applied to the whole pattern and\nconsequently mis-compiled it. This bug was found by the LLVM fuzzer. The fix\nfor this bug means that a setting of any of the (?imsxJU) options at the start\nof a pattern is no longer transferred to the options that are returned by\nPCRE2_INFO_ALLOPTIONS. In fact, this was an anachronism that should have\nchanged when the effects of those options were all moved to compile time.\n\n109. An escaped closing parenthesis in the \"name\" part of a (*verb) when\nPCRE2_ALT_VERBNAMES was set caused pcre2_compile() to malfunction. This bug\nwas found by the LLVM fuzzer.\n\n110. Implemented PCRE2_SUBSTITUTE_UNSET_EMPTY, and updated pcre2test to make it\npossible to test it.\n\n111. \"Harden\" pcre2test against ridiculously large values in modifiers and\ncommand line arguments.\n\n112. Implemented PCRE2_SUBSTITUTE_UNKNOWN_UNSET and PCRE2_SUBSTITUTE_OVERFLOW_\nLENGTH.\n\n113. Fix printing of *MARK names that contain binary zeroes in pcre2test.\n\n\nVersion 10.20 30-June-2015\n--------------------------\n\n1. Callouts with string arguments have been added.\n\n2. Assertion code generator in JIT has been optimized.\n\n3. The invalid pattern (?(?C) has a missing assertion condition at the end. The\npcre2_compile() function read past the end of the input before diagnosing an\nerror. This bug was discovered by the LLVM fuzzer.\n\n4. Implemented pcre2_callout_enumerate().\n\n5. Fix JIT compilation of conditional blocks whose assertion is converted to\n(*FAIL). E.g: /(?(?!))/.\n\n6. The pattern /(?(?!)^)/ caused references to random memory. This bug was\ndiscovered by the LLVM fuzzer.\n\n7. The assertion (?!) is optimized to (*FAIL). This was not handled correctly\nwhen this assertion was used as a condition, for example (?(?!)a|b). In\npcre2_match() it worked by luck; in pcre2_dfa_match() it gave an incorrect\nerror about an unsupported item.\n\n8. For some types of pattern, for example /Z*(|d*){216}/, the auto-\npossessification code could take exponential time to complete. A recursion\ndepth limit of 1000 has been imposed to limit the resources used by this\noptimization. This infelicity was discovered by the LLVM fuzzer.\n\n9. A pattern such as /(*UTF)[\\S\\V\\H]/, which contains a negated special class\nsuch as \\S in non-UCP mode, explicit wide characters (> 255) can be ignored\nbecause \\S ensures they are all in the class. The code for doing this was\ninteracting badly with the code for computing the amount of space needed to\ncompile the pattern, leading to a buffer overflow. This bug was discovered by\nthe LLVM fuzzer.\n\n10. A pattern such as /((?2)+)((?1))/ which has mutual recursion nested inside\nother kinds of group caused stack overflow at compile time. This bug was\ndiscovered by the LLVM fuzzer.\n\n11. A pattern such as /(?1)(?#?'){8}(a)/ which had a parenthesized comment\nbetween a subroutine call and its quantifier was incorrectly compiled, leading\nto buffer overflow or other errors. This bug was discovered by the LLVM fuzzer.\n\n12. The illegal pattern /(?(?<E>.*!.*)?)/ was not being diagnosed as missing an\nassertion after (?(. The code was failing to check the character after (?(?<\nfor the ! or = that would indicate a lookbehind assertion. This bug was\ndiscovered by the LLVM fuzzer.\n\n13. A pattern such as /X((?2)()*+){2}+/ which has a possessive quantifier with\na fixed maximum following a group that contains a subroutine reference was\nincorrectly compiled and could trigger buffer overflow. This bug was discovered\nby the LLVM fuzzer.\n\n14. Negative relative recursive references such as (?-7) to non-existent\nsubpatterns were not being diagnosed and could lead to unpredictable behaviour.\nThis bug was discovered by the LLVM fuzzer.\n\n15. The bug fixed in 14 was due to an integer variable that was unsigned when\nit should have been signed. Some other \"int\" variables, having been checked,\nhave either been changed to uint32_t or commented as \"must be signed\".\n\n16. A mutual recursion within a lookbehind assertion such as (?<=((?2))((?1)))\ncaused a stack overflow instead of the diagnosis of a non-fixed length\nlookbehind assertion. This bug was discovered by the LLVM fuzzer.\n\n17. The use of \\K in a positive lookbehind assertion in a non-anchored pattern\n(e.g. /(?<=\\Ka)/) could make pcre2grep loop.\n\n18. There was a similar problem to 17 in pcre2test for global matches, though\nthe code there did catch the loop.\n\n19. If a greedy quantified \\X was preceded by \\C in UTF mode (e.g. \\C\\X*),\nand a subsequent item in the pattern caused a non-match, backtracking over the\nrepeated \\X did not stop, but carried on past the start of the subject, causing\nreference to random memory and/or a segfault. There were also some other cases\nwhere backtracking after \\C could crash. This set of bugs was discovered by the\nLLVM fuzzer.\n\n20. The function for finding the minimum length of a matching string could take\na very long time if mutual recursion was present many times in a pattern, for\nexample, /((?2){73}(?2))((?1))/. A better mutual recursion detection method has\nbeen implemented. This infelicity was discovered by the LLVM fuzzer.\n\n21. Implemented PCRE2_NEVER_BACKSLASH_C.\n\n22. The feature for string replication in pcre2test could read from freed\nmemory if the replication required a buffer to be extended, and it was not\nworking properly in 16-bit and 32-bit modes. This issue was discovered by a\nfuzzer: see http://lcamtuf.coredump.cx/afl/.\n\n23. Added the PCRE2_ALT_CIRCUMFLEX option.\n\n24. Adjust the treatment of \\8 and \\9 to be the same as the current Perl\nbehaviour.\n\n25. Static linking against the PCRE2 library using the pkg-config module was\nfailing on missing pthread symbols.\n\n26. If a group that contained a recursive back reference also contained a\nforward reference subroutine call followed by a non-forward-reference\nsubroutine call, for example /.((?2)(?R)\\1)()/, pcre2_compile() failed to\ncompile correct code, leading to undefined behaviour or an internally detected\nerror. This bug was discovered by the LLVM fuzzer.\n\n27. Quantification of certain items (e.g. atomic back references) could cause\nincorrect code to be compiled when recursive forward references were involved.\nFor example, in this pattern: /(?1)()((((((\\1++))\\x85)+)|))/. This bug was\ndiscovered by the LLVM fuzzer.\n\n28. A repeated conditional group whose condition was a reference by name caused\na buffer overflow if there was more than one group with the given name. This\nbug was discovered by the LLVM fuzzer.\n\n29. A recursive back reference by name within a group that had the same name as\nanother group caused a buffer overflow. For example: /(?J)(?'d'(?'d'\\g{d}))/.\nThis bug was discovered by the LLVM fuzzer.\n\n30. A forward reference by name to a group whose number is the same as the\ncurrent group, for example in this pattern: /(?|(\\k'Pm')|(?'Pm'))/, caused a\nbuffer overflow at compile time. This bug was discovered by the LLVM fuzzer.\n\n31. Fix -fsanitize=undefined warnings for left shifts of 1 by 31 (it treats 1\nas an int; fixed by writing it as 1u).\n\n32. Fix pcre2grep compile when -std=c99 is used with gcc, though it still gives\na warning for \"fileno\" unless -std=gnu99 us used.\n\n33. A lookbehind assertion within a set of mutually recursive subpatterns could\nprovoke a buffer overflow. This bug was discovered by the LLVM fuzzer.\n\n34. Give an error for an empty subpattern name such as (?'').\n\n35. Make pcre2test give an error if a pattern that follows #forbud_utf contains\n\\P, \\p, or \\X.\n\n36. The way named subpatterns are handled has been refactored. There is now a\npre-pass over the regex which does nothing other than identify named\nsubpatterns and count the total captures. This means that information about\nnamed patterns is known before the rest of the compile. In particular, it means\nthat forward references can be checked as they are encountered. Previously, the\ncode for handling forward references was contorted and led to several errors in\ncomputing the memory requirements for some patterns, leading to buffer\noverflows.\n\n37. There was no check for integer overflow in subroutine calls such as (?123).\n\n38. The table entry for \\l in EBCDIC environments was incorrect, leading to its\nbeing treated as a literal 'l' instead of causing an error.\n\n39. If a non-capturing group containing a conditional group that could match\nan empty string was repeated, it was not identified as matching an empty string\nitself. For example: /^(?:(?(1)x|)+)+$()/.\n\n40. In an EBCDIC environment, pcretest was mishandling the escape sequences\n\\a and \\e in test subject lines.\n\n41. In an EBCDIC environment, \\a in a pattern was converted to the ASCII\ninstead of the EBCDIC value.\n\n42. The handling of \\c in an EBCDIC environment has been revised so that it is\nnow compatible with the specification in Perl's perlebcdic page.\n\n43. Single character repetition in JIT has been improved. 20-30% speedup\nwas achieved on certain patterns.\n\n44. The EBCDIC character 0x41 is a non-breaking space, equivalent to 0xa0 in\nASCII/Unicode. This has now been added to the list of characters that are\nrecognized as white space in EBCDIC.\n\n45. When PCRE2 was compiled without Unicode support, the use of \\p and \\P gave\nan error (correctly) when used outside a class, but did not give an error\nwithin a class.\n\n46. \\h within a class was incorrectly compiled in EBCDIC environments.\n\n47. JIT should return with error when the compiled pattern requires\nmore stack space than the maximum.\n\n48. Fixed a memory leak in pcre2grep when a locale is set.\n\n\nVersion 10.10 06-March-2015\n---------------------------\n\n1. When a pattern is compiled, it remembers the highest back reference so that\nwhen matching, if the ovector is too small, extra memory can be obtained to\nuse instead. A conditional subpattern whose condition is a check on a capture\nhaving happened, such as, for example in the pattern /^(?:(a)|b)(?(1)A|B)/, is\nanother kind of back reference, but it was not setting the highest\nbackreference number. This mattered only if pcre2_match() was called with an\novector that was too small to hold the capture, and there was no other kind of\nback reference (a situation which is probably quite rare). The effect of the\nbug was that the condition was always treated as FALSE when the capture could\nnot be consulted, leading to a incorrect behaviour by pcre2_match(). This bug\nhas been fixed.\n\n2. Functions for serialization and deserialization of sets of compiled patterns\nhave been added.\n\n3. The value that is returned by PCRE2_INFO_SIZE has been corrected to remove\nexcess code units at the end of the data block that may occasionally occur if\nthe code for calculating the size over-estimates. This change stops the\nserialization code copying uninitialized data, to which valgrind objects. The\ndocumentation of PCRE2_INFO_SIZE was incorrect in stating that the size did not\ninclude the general overhead. This has been corrected.\n\n4. All code units in every slot in the table of group names are now set, again\nin order to avoid accessing uninitialized data when serializing.\n\n5. The (*NO_JIT) feature is implemented.\n\n6. If a bug that caused pcre2_compile() to use more memory than allocated was\ntriggered when using valgrind, the code in (3) above passed a stupidly large\nvalue to valgrind. This caused a crash instead of an \"internal error\" return.\n\n7. A reference to a duplicated named group (either a back reference or a test\nfor being set in a conditional) that occurred in a part of the pattern where\nPCRE2_DUPNAMES was not set caused the amount of memory needed for the pattern\nto be incorrectly calculated, leading to overwriting.\n\n8. A mutually recursive set of back references such as (\\2)(\\1) caused a\nsegfault at compile time (while trying to find the minimum matching length).\nThe infinite loop is now broken (with the minimum length unset, that is, zero).\n\n9. If an assertion that was used as a condition was quantified with a minimum\nof zero, matching went wrong. In particular, if the whole group had unlimited\nrepetition and could match an empty string, a segfault was likely. The pattern\n(?(?=0)?)+ is an example that caused this. Perl allows assertions to be\nquantified, but not if they are being used as conditions, so the above pattern\nis faulted by Perl. PCRE2 has now been changed so that it also rejects such\npatterns.\n\n10. The error message for an invalid quantifier has been changed from \"nothing\nto repeat\" to \"quantifier does not follow a repeatable item\".\n\n11. If a bad UTF string is compiled with NO_UTF_CHECK, it may succeed, but\nscanning the compiled pattern in subsequent auto-possessification can get out\nof step and lead to an unknown opcode. Previously this could have caused an\ninfinite loop. Now it generates an \"internal error\" error. This is a tidyup,\nnot a bug fix; passing bad UTF with NO_UTF_CHECK is documented as having an\nundefined outcome.\n\n12. A UTF pattern containing a \"not\" match of a non-ASCII character and a\nsubroutine reference could loop at compile time. Example: /[^\\xff]((?1))/.\n\n13. The locale test (RunTest 3) has been upgraded. It now checks that a locale\nthat is found in the output of \"locale -a\" can actually be set by pcre2test\nbefore it is accepted. Previously, in an environment where a locale was listed\nbut would not set (an example does exist), the test would \"pass\" without\nactually doing anything. Also the fr_CA locale has been added to the list of\nlocales that can be used.\n\n14. Fixed a bug in pcre2_substitute(). If a replacement string ended in a\ncapturing group number without parentheses, the last character was incorrectly\nliterally included at the end of the replacement string.\n\n15. A possessive capturing group such as (a)*+ with a minimum repeat of zero\nfailed to allow the zero-repeat case if pcre2_match() was called with an\novector too small to capture the group.\n\n16. Improved error message in pcre2test when setting the stack size (-S) fails.\n\n17. Fixed two bugs in CMakeLists.txt: (1) Some lines had got lost in the\ntransfer from PCRE1, meaning that CMake configuration failed if \"build tests\"\nwas selected. (2) The file src/pcre2_serialize.c had not been added to the list\nof PCRE2 sources, which caused a failure to build pcre2test.\n\n18. Fixed typo in pcre2_serialize.c (DECL instead of DEFN) that causes problems\nonly on Windows.\n\n19. Use binary input when reading back saved serialized patterns in pcre2test.\n\n20. Added RunTest.bat for running the tests under Windows.\n\n21. \"make distclean\" was not removing config.h, a file that may be created for\nuse with CMake.\n\n22. A pattern such as \"((?2){0,1999}())?\", which has a group containing a\nforward reference repeated a large (but limited) number of times within a\nrepeated outer group that has a zero minimum quantifier, caused incorrect code\nto be compiled, leading to the error \"internal error: previously-checked\nreferenced subpattern not found\" when an incorrect memory address was read.\nThis bug was reported as \"heap overflow\", discovered by Kai Lu of Fortinet's\nFortiGuard Labs. (Added 24-March-2015: CVE-2015-2325 was given to this.)\n\n23. A pattern such as \"((?+1)(\\1))/\" containing a forward reference subroutine\ncall within a group that also contained a recursive back reference caused\nincorrect code to be compiled. This bug was reported as \"heap overflow\",\ndiscovered by Kai Lu of Fortinet's FortiGuard Labs. (Added 24-March-2015:\nCVE-2015-2326 was given to this.)\n\n24. Computing the size of the JIT read-only data in advance has been a source\nof various issues, and new ones are still appear unfortunately. To fix\nexisting and future issues, size computation is eliminated from the code,\nand replaced by on-demand memory allocation.\n\n25. A pattern such as /(?i)[A-`]/, where characters in the other case are\nadjacent to the end of the range, and the range contained characters with more\nthan one other case, caused incorrect behaviour when compiled in UTF mode. In\nthat example, the range a-j was left out of the class.\n\n\nVersion 10.00 05-January-2015\n-----------------------------\n\nVersion 10.00 is the first release of PCRE2, a revised API for the PCRE\nlibrary. Changes prior to 10.00 are logged in the ChangeLog file for the old\nAPI, up to item 20 for release 8.36.\n\nThe code of the library was heavily revised as part of the new API\nimplementation. Details of each and every modification were not individually\nlogged. In addition to the API changes, the following changes were made. They\nare either new functionality, or bug fixes and other noticeable changes of\nbehaviour that were implemented after the code had been forked.\n\n1. Including Unicode support at build time is now enabled by default, but it\ncan optionally be disabled. It is not enabled by default at run time (no\nchange).\n\n2. The test program, now called pcre2test, was re-specified and almost\ncompletely re-written. Its input is not compatible with input for pcretest.\n\n3. Patterns may start with (*NOTEMPTY) or (*NOTEMPTY_ATSTART) to set the\nPCRE2_NOTEMPTY or PCRE2_NOTEMPTY_ATSTART options for every subject line that is\nmatched by that pattern.\n\n4. For the benefit of those who use PCRE2 via some other application, that is,\nnot writing the function calls themselves, it is possible to check the PCRE2\nversion by matching a pattern such as /(?(VERSION>=10)yes|no)/ against a\nstring such as \"yesno\".\n\n5. There are case-equivalent Unicode characters whose encodings use different\nnumbers of code units in UTF-8. U+023A and U+2C65 are one example. (It is\ntheoretically possible for this to happen in UTF-16 too.) If a backreference to\na group containing one of these characters was greedily repeated, and during\nthe match a backtrack occurred, the subject might be backtracked by the wrong\nnumber of code units. For example, if /^(\\x{23a})\\1*(.)/ is matched caselessly\n(and in UTF-8 mode) against \"\\x{23a}\\x{2c65}\\x{2c65}\\x{2c65}\", group 2 should\ncapture the final character, which is the three bytes E2, B1, and A5 in UTF-8.\nIncorrect backtracking meant that group 2 captured only the last two bytes.\nThis bug has been fixed; the new code is slower, but it is used only when the\nstrings matched by the repetition are not all the same length.\n\n6. A pattern such as /()a/ was not setting the \"first character must be 'a'\"\ninformation. This applied to any pattern with a group that matched no\ncharacters, for example: /(?:(?=.)|(?<!x))a/.\n\n7. When an (*ACCEPT) is triggered inside capturing parentheses, it arranges for\nthose parentheses to be closed with whatever has been captured so far. However,\nit was failing to mark any other groups between the highest capture so far and\nthe currrent group as \"unset\". Thus, the ovector for those groups contained\nwhatever was previously there. An example is the pattern /(x)|((*ACCEPT))/ when\nmatched against \"abcd\".\n\n8. The pcre2_substitute() function has been implemented.\n\n9. If an assertion used as a condition was quantified with a minimum of zero\n(an odd thing to do, but it happened), SIGSEGV or other misbehaviour could\noccur.\n\n10. The PCRE2_NO_DOTSTAR_ANCHOR option has been implemented.\n\n****\n", "/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n                    This module by Zoltan Herczeg\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n          New API code Copyright (c) 2016-2021 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"pcre2_internal.h\"\n\n#ifdef SUPPORT_JIT\n\n/* All-in-one: Since we use the JIT compiler only from here,\nwe just include it. This way we don't need to touch the build\nsystem files. */\n\n#define SLJIT_CONFIG_AUTO 1\n#define SLJIT_CONFIG_STATIC 1\n#define SLJIT_VERBOSE 0\n\n#ifdef PCRE2_DEBUG\n#define SLJIT_DEBUG 1\n#else\n#define SLJIT_DEBUG 0\n#endif\n\n#define SLJIT_MALLOC(size, allocator_data) pcre2_jit_malloc(size, allocator_data)\n#define SLJIT_FREE(ptr, allocator_data) pcre2_jit_free(ptr, allocator_data)\n\nstatic void * pcre2_jit_malloc(size_t size, void *allocator_data)\n{\npcre2_memctl *allocator = ((pcre2_memctl*)allocator_data);\nreturn allocator->malloc(size, allocator->memory_data);\n}\n\nstatic void pcre2_jit_free(void *ptr, void *allocator_data)\n{\npcre2_memctl *allocator = ((pcre2_memctl*)allocator_data);\nallocator->free(ptr, allocator->memory_data);\n}\n\n#include \"sljit/sljitLir.c\"\n\n#if defined SLJIT_CONFIG_UNSUPPORTED && SLJIT_CONFIG_UNSUPPORTED\n#error Unsupported architecture\n#endif\n\n/* Defines for debugging purposes. */\n\n/* 1 - Use unoptimized capturing brackets.\n   2 - Enable capture_last_ptr (includes option 1). */\n/* #define DEBUG_FORCE_UNOPTIMIZED_CBRAS 2 */\n\n/* 1 - Always have a control head. */\n/* #define DEBUG_FORCE_CONTROL_HEAD 1 */\n\n/* Allocate memory for the regex stack on the real machine stack.\nFast, but limited size. */\n#define MACHINE_STACK_SIZE 32768\n\n/* Growth rate for stack allocated by the OS. Should be the multiply\nof page size. */\n#define STACK_GROWTH_RATE 8192\n\n/* Enable to check that the allocation could destroy temporaries. */\n#if defined SLJIT_DEBUG && SLJIT_DEBUG\n#define DESTROY_REGISTERS 1\n#endif\n\n/*\nShort summary about the backtracking mechanism empolyed by the jit code generator:\n\nThe code generator follows the recursive nature of the PERL compatible regular\nexpressions. The basic blocks of regular expressions are condition checkers\nwhose execute different commands depending on the result of the condition check.\nThe relationship between the operators can be horizontal (concatenation) and\nvertical (sub-expression) (See struct backtrack_common for more details).\n\n  'ab' - 'a' and 'b' regexps are concatenated\n  'a+' - 'a' is the sub-expression of the '+' operator\n\nThe condition checkers are boolean (true/false) checkers. Machine code is generated\nfor the checker itself and for the actions depending on the result of the checker.\nThe 'true' case is called as the matching path (expected path), and the other is called as\nthe 'backtrack' path. Branch instructions are expesive for all CPUs, so we avoid taken\nbranches on the matching path.\n\n Greedy star operator (*) :\n   Matching path: match happens.\n   Backtrack path: match failed.\n Non-greedy star operator (*?) :\n   Matching path: no need to perform a match.\n   Backtrack path: match is required.\n\nThe following example shows how the code generated for a capturing bracket\nwith two alternatives. Let A, B, C, D are arbirary regular expressions, and\nwe have the following regular expression:\n\n   A(B|C)D\n\nThe generated code will be the following:\n\n A matching path\n '(' matching path (pushing arguments to the stack)\n B matching path\n ')' matching path (pushing arguments to the stack)\n D matching path\n return with successful match\n\n D backtrack path\n ')' backtrack path (If we arrived from \"C\" jump to the backtrack of \"C\")\n B backtrack path\n C expected path\n jump to D matching path\n C backtrack path\n A backtrack path\n\n Notice, that the order of backtrack code paths are the opposite of the fast\n code paths. In this way the topmost value on the stack is always belong\n to the current backtrack code path. The backtrack path must check\n whether there is a next alternative. If so, it needs to jump back to\n the matching path eventually. Otherwise it needs to clear out its own stack\n frame and continue the execution on the backtrack code paths.\n*/\n\n/*\nSaved stack frames:\n\nAtomic blocks and asserts require reloading the values of private data\nwhen the backtrack mechanism performed. Because of OP_RECURSE, the data\nare not necessarly known in compile time, thus we need a dynamic restore\nmechanism.\n\nThe stack frames are stored in a chain list, and have the following format:\n([ capturing bracket offset ][ start value ][ end value ])+ ... [ 0 ] [ previous head ]\n\nThus we can restore the private data to a particular point in the stack.\n*/\n\ntypedef struct jit_arguments {\n  /* Pointers first. */\n  struct sljit_stack *stack;\n  PCRE2_SPTR str;\n  PCRE2_SPTR begin;\n  PCRE2_SPTR end;\n  pcre2_match_data *match_data;\n  PCRE2_SPTR startchar_ptr;\n  PCRE2_UCHAR *mark_ptr;\n  int (*callout)(pcre2_callout_block *, void *);\n  void *callout_data;\n  /* Everything else after. */\n  sljit_uw offset_limit;\n  sljit_u32 limit_match;\n  sljit_u32 oveccount;\n  sljit_u32 options;\n} jit_arguments;\n\n#define JIT_NUMBER_OF_COMPILE_MODES 3\n\ntypedef struct executable_functions {\n  void *executable_funcs[JIT_NUMBER_OF_COMPILE_MODES];\n  void *read_only_data_heads[JIT_NUMBER_OF_COMPILE_MODES];\n  sljit_uw executable_sizes[JIT_NUMBER_OF_COMPILE_MODES];\n  sljit_u32 top_bracket;\n  sljit_u32 limit_match;\n} executable_functions;\n\ntypedef struct jump_list {\n  struct sljit_jump *jump;\n  struct jump_list *next;\n} jump_list;\n\ntypedef struct stub_list {\n  struct sljit_jump *start;\n  struct sljit_label *quit;\n  struct stub_list *next;\n} stub_list;\n\nenum frame_types {\n  no_frame = -1,\n  no_stack = -2\n};\n\nenum control_types {\n  type_mark = 0,\n  type_then_trap = 1\n};\n\nenum  early_fail_types {\n  type_skip = 0,\n  type_fail = 1,\n  type_fail_range = 2\n};\n\ntypedef int (SLJIT_FUNC *jit_function)(jit_arguments *args);\n\n/* The following structure is the key data type for the recursive\ncode generator. It is allocated by compile_matchingpath, and contains\nthe arguments for compile_backtrackingpath. Must be the first member\nof its descendants. */\ntypedef struct backtrack_common {\n  /* Concatenation stack. */\n  struct backtrack_common *prev;\n  jump_list *nextbacktracks;\n  /* Internal stack (for component operators). */\n  struct backtrack_common *top;\n  jump_list *topbacktracks;\n  /* Opcode pointer. */\n  PCRE2_SPTR cc;\n} backtrack_common;\n\ntypedef struct assert_backtrack {\n  backtrack_common common;\n  jump_list *condfailed;\n  /* Less than 0 if a frame is not needed. */\n  int framesize;\n  /* Points to our private memory word on the stack. */\n  int private_data_ptr;\n  /* For iterators. */\n  struct sljit_label *matchingpath;\n} assert_backtrack;\n\ntypedef struct bracket_backtrack {\n  backtrack_common common;\n  /* Where to coninue if an alternative is successfully matched. */\n  struct sljit_label *alternative_matchingpath;\n  /* For rmin and rmax iterators. */\n  struct sljit_label *recursive_matchingpath;\n  /* For greedy ? operator. */\n  struct sljit_label *zero_matchingpath;\n  /* Contains the branches of a failed condition. */\n  union {\n    /* Both for OP_COND, OP_SCOND. */\n    jump_list *condfailed;\n    assert_backtrack *assert;\n    /* For OP_ONCE. Less than 0 if not needed. */\n    int framesize;\n    /* For brackets with >3 alternatives. */\n    struct sljit_put_label *matching_put_label;\n  } u;\n  /* Points to our private memory word on the stack. */\n  int private_data_ptr;\n} bracket_backtrack;\n\ntypedef struct bracketpos_backtrack {\n  backtrack_common common;\n  /* Points to our private memory word on the stack. */\n  int private_data_ptr;\n  /* Reverting stack is needed. */\n  int framesize;\n  /* Allocated stack size. */\n  int stacksize;\n} bracketpos_backtrack;\n\ntypedef struct braminzero_backtrack {\n  backtrack_common common;\n  struct sljit_label *matchingpath;\n} braminzero_backtrack;\n\ntypedef struct char_iterator_backtrack {\n  backtrack_common common;\n  /* Next iteration. */\n  struct sljit_label *matchingpath;\n  union {\n    jump_list *backtracks;\n    struct {\n      unsigned int othercasebit;\n      PCRE2_UCHAR chr;\n      BOOL enabled;\n    } charpos;\n  } u;\n} char_iterator_backtrack;\n\ntypedef struct ref_iterator_backtrack {\n  backtrack_common common;\n  /* Next iteration. */\n  struct sljit_label *matchingpath;\n} ref_iterator_backtrack;\n\ntypedef struct recurse_entry {\n  struct recurse_entry *next;\n  /* Contains the function entry label. */\n  struct sljit_label *entry_label;\n  /* Contains the function entry label. */\n  struct sljit_label *backtrack_label;\n  /* Collects the entry calls until the function is not created. */\n  jump_list *entry_calls;\n  /* Collects the backtrack calls until the function is not created. */\n  jump_list *backtrack_calls;\n  /* Points to the starting opcode. */\n  sljit_sw start;\n} recurse_entry;\n\ntypedef struct recurse_backtrack {\n  backtrack_common common;\n  /* Return to the matching path. */\n  struct sljit_label *matchingpath;\n  /* Recursive pattern. */\n  recurse_entry *entry;\n  /* Pattern is inlined. */\n  BOOL inlined_pattern;\n} recurse_backtrack;\n\n#define OP_THEN_TRAP OP_TABLE_LENGTH\n\ntypedef struct then_trap_backtrack {\n  backtrack_common common;\n  /* If then_trap is not NULL, this structure contains the real\n  then_trap for the backtracking path. */\n  struct then_trap_backtrack *then_trap;\n  /* Points to the starting opcode. */\n  sljit_sw start;\n  /* Exit point for the then opcodes of this alternative. */\n  jump_list *quit;\n  /* Frame size of the current alternative. */\n  int framesize;\n} then_trap_backtrack;\n\n#define MAX_N_CHARS 12\n#define MAX_DIFF_CHARS 5\n\ntypedef struct fast_forward_char_data {\n  /* Number of characters in the chars array, 255 for any character. */\n  sljit_u8 count;\n  /* Number of last UTF-8 characters in the chars array. */\n  sljit_u8 last_count;\n  /* Available characters in the current position. */\n  PCRE2_UCHAR chars[MAX_DIFF_CHARS];\n} fast_forward_char_data;\n\n#define MAX_CLASS_RANGE_SIZE 4\n#define MAX_CLASS_CHARS_SIZE 3\n\ntypedef struct compiler_common {\n  /* The sljit ceneric compiler. */\n  struct sljit_compiler *compiler;\n  /* Compiled regular expression. */\n  pcre2_real_code *re;\n  /* First byte code. */\n  PCRE2_SPTR start;\n  /* Maps private data offset to each opcode. */\n  sljit_s32 *private_data_ptrs;\n  /* Chain list of read-only data ptrs. */\n  void *read_only_data_head;\n  /* Tells whether the capturing bracket is optimized. */\n  sljit_u8 *optimized_cbracket;\n  /* Tells whether the starting offset is a target of then. */\n  sljit_u8 *then_offsets;\n  /* Current position where a THEN must jump. */\n  then_trap_backtrack *then_trap;\n  /* Starting offset of private data for capturing brackets. */\n  sljit_s32 cbra_ptr;\n  /* Output vector starting point. Must be divisible by 2. */\n  sljit_s32 ovector_start;\n  /* Points to the starting character of the current match. */\n  sljit_s32 start_ptr;\n  /* Last known position of the requested byte. */\n  sljit_s32 req_char_ptr;\n  /* Head of the last recursion. */\n  sljit_s32 recursive_head_ptr;\n  /* First inspected character for partial matching.\n     (Needed for avoiding zero length partial matches.) */\n  sljit_s32 start_used_ptr;\n  /* Starting pointer for partial soft matches. */\n  sljit_s32 hit_start;\n  /* Pointer of the match end position. */\n  sljit_s32 match_end_ptr;\n  /* Points to the marked string. */\n  sljit_s32 mark_ptr;\n  /* Recursive control verb management chain. */\n  sljit_s32 control_head_ptr;\n  /* Points to the last matched capture block index. */\n  sljit_s32 capture_last_ptr;\n  /* Fast forward skipping byte code pointer. */\n  PCRE2_SPTR fast_forward_bc_ptr;\n  /* Locals used by fast fail optimization. */\n  sljit_s32 early_fail_start_ptr;\n  sljit_s32 early_fail_end_ptr;\n  /* Variables used by recursive call generator. */\n  sljit_s32 recurse_bitset_size;\n  uint8_t *recurse_bitset;\n\n  /* Flipped and lower case tables. */\n  const sljit_u8 *fcc;\n  sljit_sw lcc;\n  /* Mode can be PCRE2_JIT_COMPLETE and others. */\n  int mode;\n  /* TRUE, when empty match is accepted for partial matching. */\n  BOOL allow_empty_partial;\n  /* TRUE, when minlength is greater than 0. */\n  BOOL might_be_empty;\n  /* \\K is found in the pattern. */\n  BOOL has_set_som;\n  /* (*SKIP:arg) is found in the pattern. */\n  BOOL has_skip_arg;\n  /* (*THEN) is found in the pattern. */\n  BOOL has_then;\n  /* (*SKIP) or (*SKIP:arg) is found in lookbehind assertion. */\n  BOOL has_skip_in_assert_back;\n  /* Quit is redirected by recurse, negative assertion, or positive assertion in conditional block. */\n  BOOL local_quit_available;\n  /* Currently in a positive assertion. */\n  BOOL in_positive_assertion;\n  /* Newline control. */\n  int nltype;\n  sljit_u32 nlmax;\n  sljit_u32 nlmin;\n  int newline;\n  int bsr_nltype;\n  sljit_u32 bsr_nlmax;\n  sljit_u32 bsr_nlmin;\n  /* Dollar endonly. */\n  int endonly;\n  /* Tables. */\n  sljit_sw ctypes;\n  /* Named capturing brackets. */\n  PCRE2_SPTR name_table;\n  sljit_sw name_count;\n  sljit_sw name_entry_size;\n\n  /* Labels and jump lists. */\n  struct sljit_label *partialmatchlabel;\n  struct sljit_label *quit_label;\n  struct sljit_label *abort_label;\n  struct sljit_label *accept_label;\n  struct sljit_label *ff_newline_shortcut;\n  stub_list *stubs;\n  recurse_entry *entries;\n  recurse_entry *currententry;\n  jump_list *partialmatch;\n  jump_list *quit;\n  jump_list *positive_assertion_quit;\n  jump_list *abort;\n  jump_list *failed_match;\n  jump_list *accept;\n  jump_list *calllimit;\n  jump_list *stackalloc;\n  jump_list *revertframes;\n  jump_list *wordboundary;\n  jump_list *anynewline;\n  jump_list *hspace;\n  jump_list *vspace;\n  jump_list *casefulcmp;\n  jump_list *caselesscmp;\n  jump_list *reset_match;\n  BOOL unset_backref;\n  BOOL alt_circumflex;\n#ifdef SUPPORT_UNICODE\n  BOOL utf;\n  BOOL invalid_utf;\n  BOOL ucp;\n  /* Points to saving area for iref. */\n  sljit_s32 iref_ptr;\n  jump_list *getucd;\n  jump_list *getucdtype;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  jump_list *utfreadchar;\n  jump_list *utfreadtype8;\n  jump_list *utfpeakcharback;\n#endif\n#if PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16\n  jump_list *utfreadchar_invalid;\n  jump_list *utfreadnewline_invalid;\n  jump_list *utfmoveback_invalid;\n  jump_list *utfpeakcharback_invalid;\n#endif\n#endif /* SUPPORT_UNICODE */\n} compiler_common;\n\n/* For byte_sequence_compare. */\n\ntypedef struct compare_context {\n  int length;\n  int sourcereg;\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  int ucharptr;\n  union {\n    sljit_s32 asint;\n    sljit_u16 asushort;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    sljit_u8 asbyte;\n    sljit_u8 asuchars[4];\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n    sljit_u16 asuchars[2];\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n    sljit_u32 asuchars[1];\n#endif\n  } c;\n  union {\n    sljit_s32 asint;\n    sljit_u16 asushort;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    sljit_u8 asbyte;\n    sljit_u8 asuchars[4];\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n    sljit_u16 asuchars[2];\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n    sljit_u32 asuchars[1];\n#endif\n  } oc;\n#endif\n} compare_context;\n\n/* Undefine sljit macros. */\n#undef CMP\n\n/* Used for accessing the elements of the stack. */\n#define STACK(i)      ((i) * (int)sizeof(sljit_sw))\n\n#ifdef SLJIT_PREF_SHIFT_REG\n#if SLJIT_PREF_SHIFT_REG == SLJIT_R2\n/* Nothing. */\n#elif SLJIT_PREF_SHIFT_REG == SLJIT_R3\n#define SHIFT_REG_IS_R3\n#else\n#error \"Unsupported shift register\"\n#endif\n#endif\n\n#define TMP1          SLJIT_R0\n#ifdef SHIFT_REG_IS_R3\n#define TMP2          SLJIT_R3\n#define TMP3          SLJIT_R2\n#else\n#define TMP2          SLJIT_R2\n#define TMP3          SLJIT_R3\n#endif\n#define STR_PTR       SLJIT_R1\n#define STR_END       SLJIT_S0\n#define STACK_TOP     SLJIT_S1\n#define STACK_LIMIT   SLJIT_S2\n#define COUNT_MATCH   SLJIT_S3\n#define ARGUMENTS     SLJIT_S4\n#define RETURN_ADDR   SLJIT_R4\n\n#if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)\n#define HAS_VIRTUAL_REGISTERS 1\n#else\n#define HAS_VIRTUAL_REGISTERS 0\n#endif\n\n/* Local space layout. */\n/* These two locals can be used by the current opcode. */\n#define LOCALS0          (0 * sizeof(sljit_sw))\n#define LOCALS1          (1 * sizeof(sljit_sw))\n/* Two local variables for possessive quantifiers (char1 cannot use them). */\n#define POSSESSIVE0      (2 * sizeof(sljit_sw))\n#define POSSESSIVE1      (3 * sizeof(sljit_sw))\n/* Max limit of recursions. */\n#define LIMIT_MATCH      (4 * sizeof(sljit_sw))\n/* The output vector is stored on the stack, and contains pointers\nto characters. The vector data is divided into two groups: the first\ngroup contains the start / end character pointers, and the second is\nthe start pointers when the end of the capturing group has not yet reached. */\n#define OVECTOR_START    (common->ovector_start)\n#define OVECTOR(i)       (OVECTOR_START + (i) * (sljit_sw)sizeof(sljit_sw))\n#define OVECTOR_PRIV(i)  (common->cbra_ptr + (i) * (sljit_sw)sizeof(sljit_sw))\n#define PRIVATE_DATA(cc) (common->private_data_ptrs[(cc) - common->start])\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n#define MOV_UCHAR  SLJIT_MOV_U8\n#define IN_UCHARS(x) (x)\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n#define MOV_UCHAR  SLJIT_MOV_U16\n#define UCHAR_SHIFT (1)\n#define IN_UCHARS(x) ((x) * 2)\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n#define MOV_UCHAR  SLJIT_MOV_U32\n#define UCHAR_SHIFT (2)\n#define IN_UCHARS(x) ((x) * 4)\n#else\n#error Unsupported compiling mode\n#endif\n\n/* Shortcuts. */\n#define DEFINE_COMPILER \\\n  struct sljit_compiler *compiler = common->compiler\n#define OP1(op, dst, dstw, src, srcw) \\\n  sljit_emit_op1(compiler, (op), (dst), (dstw), (src), (srcw))\n#define OP2(op, dst, dstw, src1, src1w, src2, src2w) \\\n  sljit_emit_op2(compiler, (op), (dst), (dstw), (src1), (src1w), (src2), (src2w))\n#define OP2U(op, src1, src1w, src2, src2w) \\\n  sljit_emit_op2u(compiler, (op), (src1), (src1w), (src2), (src2w))\n#define OP_SRC(op, src, srcw) \\\n  sljit_emit_op_src(compiler, (op), (src), (srcw))\n#define LABEL() \\\n  sljit_emit_label(compiler)\n#define JUMP(type) \\\n  sljit_emit_jump(compiler, (type))\n#define JUMPTO(type, label) \\\n  sljit_set_label(sljit_emit_jump(compiler, (type)), (label))\n#define JUMPHERE(jump) \\\n  sljit_set_label((jump), sljit_emit_label(compiler))\n#define SET_LABEL(jump, label) \\\n  sljit_set_label((jump), (label))\n#define CMP(type, src1, src1w, src2, src2w) \\\n  sljit_emit_cmp(compiler, (type), (src1), (src1w), (src2), (src2w))\n#define CMPTO(type, src1, src1w, src2, src2w, label) \\\n  sljit_set_label(sljit_emit_cmp(compiler, (type), (src1), (src1w), (src2), (src2w)), (label))\n#define OP_FLAGS(op, dst, dstw, type) \\\n  sljit_emit_op_flags(compiler, (op), (dst), (dstw), (type))\n#define CMOV(type, dst_reg, src, srcw) \\\n  sljit_emit_cmov(compiler, (type), (dst_reg), (src), (srcw))\n#define GET_LOCAL_BASE(dst, dstw, offset) \\\n  sljit_get_local_base(compiler, (dst), (dstw), (offset))\n\n#define READ_CHAR_MAX 0x7fffffff\n\n#define INVALID_UTF_CHAR -1\n#define UNASSIGNED_UTF_CHAR 888\n\n#if defined SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\n\n#define GETCHARINC_INVALID(c, ptr, end, invalid_action) \\\n  { \\\n  if (ptr[0] <= 0x7f) \\\n    c = *ptr++; \\\n  else if (ptr + 1 < end && ptr[1] >= 0x80 && ptr[1] < 0xc0) \\\n    { \\\n    c = ptr[1] - 0x80; \\\n    \\\n    if (ptr[0] >= 0xc2 && ptr[0] <= 0xdf) \\\n      { \\\n      c |= (ptr[0] - 0xc0) << 6; \\\n      ptr += 2; \\\n      } \\\n    else if (ptr + 2 < end && ptr[2] >= 0x80 && ptr[2] < 0xc0) \\\n      { \\\n      c = c << 6 | (ptr[2] - 0x80); \\\n      \\\n      if (ptr[0] >= 0xe0 && ptr[0] <= 0xef) \\\n        { \\\n        c |= (ptr[0] - 0xe0) << 12; \\\n        ptr += 3; \\\n        \\\n        if (c < 0x800 || (c >= 0xd800 && c < 0xe000)) \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else if (ptr + 3 < end && ptr[3] >= 0x80 && ptr[3] < 0xc0) \\\n        { \\\n        c = c << 6 | (ptr[3] - 0x80); \\\n        \\\n        if (ptr[0] >= 0xf0 && ptr[0] <= 0xf4) \\\n          { \\\n          c |= (ptr[0] - 0xf0) << 18; \\\n          ptr += 4; \\\n          \\\n          if (c >= 0x110000 || c < 0x10000) \\\n            { \\\n            invalid_action; \\\n            } \\\n          } \\\n        else \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else \\\n        { \\\n        invalid_action; \\\n        } \\\n      } \\\n    else \\\n      { \\\n      invalid_action; \\\n      } \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#define GETCHARBACK_INVALID(c, ptr, start, invalid_action) \\\n  { \\\n  c = ptr[-1]; \\\n  if (c <= 0x7f) \\\n    ptr--; \\\n  else if (ptr - 1 > start && ptr[-1] >= 0x80 && ptr[-1] < 0xc0) \\\n    { \\\n    c -= 0x80; \\\n    \\\n    if (ptr[-2] >= 0xc2 && ptr[-2] <= 0xdf) \\\n      { \\\n      c |= (ptr[-2] - 0xc0) << 6; \\\n      ptr -= 2; \\\n      } \\\n    else if (ptr - 2 > start && ptr[-2] >= 0x80 && ptr[-2] < 0xc0) \\\n      { \\\n      c = c << 6 | (ptr[-2] - 0x80); \\\n      \\\n      if (ptr[-3] >= 0xe0 && ptr[-3] <= 0xef) \\\n        { \\\n        c |= (ptr[-3] - 0xe0) << 12; \\\n        ptr -= 3; \\\n        \\\n        if (c < 0x800 || (c >= 0xd800 && c < 0xe000)) \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else if (ptr - 3 > start && ptr[-3] >= 0x80 && ptr[-3] < 0xc0) \\\n        { \\\n        c = c << 6 | (ptr[-3] - 0x80); \\\n        \\\n        if (ptr[-4] >= 0xf0 && ptr[-4] <= 0xf4) \\\n          { \\\n          c |= (ptr[-4] - 0xf0) << 18; \\\n          ptr -= 4; \\\n          \\\n          if (c >= 0x110000 || c < 0x10000) \\\n            { \\\n            invalid_action; \\\n            } \\\n          } \\\n        else \\\n          { \\\n          invalid_action; \\\n          } \\\n        } \\\n      else \\\n        { \\\n        invalid_action; \\\n        } \\\n      } \\\n    else \\\n      { \\\n      invalid_action; \\\n      } \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n\n#define GETCHARINC_INVALID(c, ptr, end, invalid_action) \\\n  { \\\n  if (ptr[0] < 0xd800 || ptr[0] >= 0xe000) \\\n    c = *ptr++; \\\n  else if (ptr[0] < 0xdc00 && ptr + 1 < end && ptr[1] >= 0xdc00 && ptr[1] < 0xe000) \\\n    { \\\n    c = (((ptr[0] - 0xd800) << 10) | (ptr[1] - 0xdc00)) + 0x10000; \\\n    ptr += 2; \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#define GETCHARBACK_INVALID(c, ptr, start, invalid_action) \\\n  { \\\n  c = ptr[-1]; \\\n  if (c < 0xd800 || c >= 0xe000) \\\n    ptr--; \\\n  else if (c >= 0xdc00 && ptr - 1 > start && ptr[-2] >= 0xd800 && ptr[-2] < 0xdc00) \\\n    { \\\n    c = (((ptr[-2] - 0xd800) << 10) | (c - 0xdc00)) + 0x10000; \\\n    ptr -= 2; \\\n    } \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n\n#define GETCHARINC_INVALID(c, ptr, end, invalid_action) \\\n  { \\\n  if (ptr[0] < 0xd800 || (ptr[0] >= 0xe000 && ptr[0] < 0x110000)) \\\n    c = *ptr++; \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#define GETCHARBACK_INVALID(c, ptr, start, invalid_action) \\\n  { \\\n  c = ptr[-1]; \\\n  if (ptr[-1] < 0xd800 || (ptr[-1] >= 0xe000 && ptr[-1] < 0x110000)) \\\n    ptr--; \\\n  else \\\n    { \\\n    invalid_action; \\\n    } \\\n  }\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n\nstatic PCRE2_SPTR bracketend(PCRE2_SPTR cc)\n{\nSLJIT_ASSERT((*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA) || (*cc >= OP_ONCE && *cc <= OP_SCOND));\ndo cc += GET(cc, 1); while (*cc == OP_ALT);\nSLJIT_ASSERT(*cc >= OP_KET && *cc <= OP_KETRPOS);\ncc += 1 + LINK_SIZE;\nreturn cc;\n}\n\nstatic int no_alternatives(PCRE2_SPTR cc)\n{\nint count = 0;\nSLJIT_ASSERT((*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA) || (*cc >= OP_ONCE && *cc <= OP_SCOND));\ndo\n  {\n  cc += GET(cc, 1);\n  count++;\n  }\nwhile (*cc == OP_ALT);\nSLJIT_ASSERT(*cc >= OP_KET && *cc <= OP_KETRPOS);\nreturn count;\n}\n\n/* Functions whose might need modification for all new supported opcodes:\n next_opcode\n check_opcode_types\n set_private_data_ptrs\n get_framesize\n init_frame\n get_recurse_data_length\n copy_recurse_data\n compile_matchingpath\n compile_backtrackingpath\n*/\n\nstatic PCRE2_SPTR next_opcode(compiler_common *common, PCRE2_SPTR cc)\n{\nSLJIT_UNUSED_ARG(common);\nswitch(*cc)\n  {\n  case OP_SOD:\n  case OP_SOM:\n  case OP_SET_SOM:\n  case OP_NOT_WORD_BOUNDARY:\n  case OP_WORD_BOUNDARY:\n  case OP_NOT_DIGIT:\n  case OP_DIGIT:\n  case OP_NOT_WHITESPACE:\n  case OP_WHITESPACE:\n  case OP_NOT_WORDCHAR:\n  case OP_WORDCHAR:\n  case OP_ANY:\n  case OP_ALLANY:\n  case OP_NOTPROP:\n  case OP_PROP:\n  case OP_ANYNL:\n  case OP_NOT_HSPACE:\n  case OP_HSPACE:\n  case OP_NOT_VSPACE:\n  case OP_VSPACE:\n  case OP_EXTUNI:\n  case OP_EODN:\n  case OP_EOD:\n  case OP_CIRC:\n  case OP_CIRCM:\n  case OP_DOLL:\n  case OP_DOLLM:\n  case OP_CRSTAR:\n  case OP_CRMINSTAR:\n  case OP_CRPLUS:\n  case OP_CRMINPLUS:\n  case OP_CRQUERY:\n  case OP_CRMINQUERY:\n  case OP_CRRANGE:\n  case OP_CRMINRANGE:\n  case OP_CRPOSSTAR:\n  case OP_CRPOSPLUS:\n  case OP_CRPOSQUERY:\n  case OP_CRPOSRANGE:\n  case OP_CLASS:\n  case OP_NCLASS:\n  case OP_REF:\n  case OP_REFI:\n  case OP_DNREF:\n  case OP_DNREFI:\n  case OP_RECURSE:\n  case OP_CALLOUT:\n  case OP_ALT:\n  case OP_KET:\n  case OP_KETRMAX:\n  case OP_KETRMIN:\n  case OP_KETRPOS:\n  case OP_REVERSE:\n  case OP_ASSERT:\n  case OP_ASSERT_NOT:\n  case OP_ASSERTBACK:\n  case OP_ASSERTBACK_NOT:\n  case OP_ASSERT_NA:\n  case OP_ASSERTBACK_NA:\n  case OP_ONCE:\n  case OP_SCRIPT_RUN:\n  case OP_BRA:\n  case OP_BRAPOS:\n  case OP_CBRA:\n  case OP_CBRAPOS:\n  case OP_COND:\n  case OP_SBRA:\n  case OP_SBRAPOS:\n  case OP_SCBRA:\n  case OP_SCBRAPOS:\n  case OP_SCOND:\n  case OP_CREF:\n  case OP_DNCREF:\n  case OP_RREF:\n  case OP_DNRREF:\n  case OP_FALSE:\n  case OP_TRUE:\n  case OP_BRAZERO:\n  case OP_BRAMINZERO:\n  case OP_BRAPOSZERO:\n  case OP_PRUNE:\n  case OP_SKIP:\n  case OP_THEN:\n  case OP_COMMIT:\n  case OP_FAIL:\n  case OP_ACCEPT:\n  case OP_ASSERT_ACCEPT:\n  case OP_CLOSE:\n  case OP_SKIPZERO:\n  return cc + PRIV(OP_lengths)[*cc];\n\n  case OP_CHAR:\n  case OP_CHARI:\n  case OP_NOT:\n  case OP_NOTI:\n  case OP_STAR:\n  case OP_MINSTAR:\n  case OP_PLUS:\n  case OP_MINPLUS:\n  case OP_QUERY:\n  case OP_MINQUERY:\n  case OP_UPTO:\n  case OP_MINUPTO:\n  case OP_EXACT:\n  case OP_POSSTAR:\n  case OP_POSPLUS:\n  case OP_POSQUERY:\n  case OP_POSUPTO:\n  case OP_STARI:\n  case OP_MINSTARI:\n  case OP_PLUSI:\n  case OP_MINPLUSI:\n  case OP_QUERYI:\n  case OP_MINQUERYI:\n  case OP_UPTOI:\n  case OP_MINUPTOI:\n  case OP_EXACTI:\n  case OP_POSSTARI:\n  case OP_POSPLUSI:\n  case OP_POSQUERYI:\n  case OP_POSUPTOI:\n  case OP_NOTSTAR:\n  case OP_NOTMINSTAR:\n  case OP_NOTPLUS:\n  case OP_NOTMINPLUS:\n  case OP_NOTQUERY:\n  case OP_NOTMINQUERY:\n  case OP_NOTUPTO:\n  case OP_NOTMINUPTO:\n  case OP_NOTEXACT:\n  case OP_NOTPOSSTAR:\n  case OP_NOTPOSPLUS:\n  case OP_NOTPOSQUERY:\n  case OP_NOTPOSUPTO:\n  case OP_NOTSTARI:\n  case OP_NOTMINSTARI:\n  case OP_NOTPLUSI:\n  case OP_NOTMINPLUSI:\n  case OP_NOTQUERYI:\n  case OP_NOTMINQUERYI:\n  case OP_NOTUPTOI:\n  case OP_NOTMINUPTOI:\n  case OP_NOTEXACTI:\n  case OP_NOTPOSSTARI:\n  case OP_NOTPOSPLUSI:\n  case OP_NOTPOSQUERYI:\n  case OP_NOTPOSUPTOI:\n  cc += PRIV(OP_lengths)[*cc];\n#ifdef SUPPORT_UNICODE\n  if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n  return cc;\n\n  /* Special cases. */\n  case OP_TYPESTAR:\n  case OP_TYPEMINSTAR:\n  case OP_TYPEPLUS:\n  case OP_TYPEMINPLUS:\n  case OP_TYPEQUERY:\n  case OP_TYPEMINQUERY:\n  case OP_TYPEUPTO:\n  case OP_TYPEMINUPTO:\n  case OP_TYPEEXACT:\n  case OP_TYPEPOSSTAR:\n  case OP_TYPEPOSPLUS:\n  case OP_TYPEPOSQUERY:\n  case OP_TYPEPOSUPTO:\n  return cc + PRIV(OP_lengths)[*cc] - 1;\n\n  case OP_ANYBYTE:\n#ifdef SUPPORT_UNICODE\n  if (common->utf) return NULL;\n#endif\n  return cc + 1;\n\n  case OP_CALLOUT_STR:\n  return cc + GET(cc, 1 + 2*LINK_SIZE);\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n  case OP_XCLASS:\n  return cc + GET(cc, 1);\n#endif\n\n  case OP_MARK:\n  case OP_COMMIT_ARG:\n  case OP_PRUNE_ARG:\n  case OP_SKIP_ARG:\n  case OP_THEN_ARG:\n  return cc + 1 + 2 + cc[1];\n\n  default:\n  SLJIT_UNREACHABLE();\n  return NULL;\n  }\n}\n\nstatic BOOL check_opcode_types(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend)\n{\nint count;\nPCRE2_SPTR slot;\nPCRE2_SPTR assert_back_end = cc - 1;\nPCRE2_SPTR assert_na_end = cc - 1;\n\n/* Calculate important variables (like stack size) and checks whether all opcodes are supported. */\nwhile (cc < ccend)\n  {\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    common->has_set_som = TRUE;\n    common->might_be_empty = TRUE;\n    cc += 1;\n    break;\n\n    case OP_REFI:\n#ifdef SUPPORT_UNICODE\n    if (common->iref_ptr == 0)\n      {\n      common->iref_ptr = common->ovector_start;\n      common->ovector_start += 3 * sizeof(sljit_sw);\n      }\n#endif /* SUPPORT_UNICODE */\n    /* Fall through. */\n    case OP_REF:\n    common->optimized_cbracket[GET2(cc, 1)] = 0;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    slot = bracketend(cc);\n    if (slot > assert_na_end)\n      assert_na_end = slot;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] = 0;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    case OP_SCOND:\n    /* Only AUTO_CALLOUT can insert this opcode. We do\n       not intend to support this case. */\n    if (cc[1 + LINK_SIZE] == OP_CALLOUT || cc[1 + LINK_SIZE] == OP_CALLOUT_STR)\n      return FALSE;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CREF:\n    common->optimized_cbracket[GET2(cc, 1)] = 0;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_DNREF:\n    case OP_DNREFI:\n    case OP_DNCREF:\n    count = GET2(cc, 1 + IMM2_SIZE);\n    slot = common->name_table + GET2(cc, 1) * common->name_entry_size;\n    while (count-- > 0)\n      {\n      common->optimized_cbracket[GET2(slot, 0)] = 0;\n      slot += common->name_entry_size;\n      }\n    cc += 1 + 2 * IMM2_SIZE;\n    break;\n\n    case OP_RECURSE:\n    /* Set its value only once. */\n    if (common->recursive_head_ptr == 0)\n      {\n      common->recursive_head_ptr = common->ovector_start;\n      common->ovector_start += sizeof(sljit_sw);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n    if (common->capture_last_ptr == 0)\n      {\n      common->capture_last_ptr = common->ovector_start;\n      common->ovector_start += sizeof(sljit_sw);\n      }\n    cc += (*cc == OP_CALLOUT) ? PRIV(OP_lengths)[OP_CALLOUT] : GET(cc, 1 + 2*LINK_SIZE);\n    break;\n\n    case OP_ASSERTBACK:\n    slot = bracketend(cc);\n    if (slot > assert_back_end)\n      assert_back_end = slot;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_THEN_ARG:\n    common->has_then = TRUE;\n    common->control_head_ptr = 1;\n    /* Fall through. */\n\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    if (cc < assert_na_end)\n      return FALSE;\n    /* Fall through */\n    case OP_MARK:\n    if (common->mark_ptr == 0)\n      {\n      common->mark_ptr = common->ovector_start;\n      common->ovector_start += sizeof(sljit_sw);\n      }\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_THEN:\n    common->has_then = TRUE;\n    common->control_head_ptr = 1;\n    cc += 1;\n    break;\n\n    case OP_SKIP:\n    if (cc < assert_back_end)\n      common->has_skip_in_assert_back = TRUE;\n    if (cc < assert_na_end)\n      return FALSE;\n    cc += 1;\n    break;\n\n    case OP_SKIP_ARG:\n    common->control_head_ptr = 1;\n    common->has_skip_arg = TRUE;\n    if (cc < assert_back_end)\n      common->has_skip_in_assert_back = TRUE;\n    if (cc < assert_na_end)\n      return FALSE;\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_PRUNE:\n    case OP_COMMIT:\n    case OP_ASSERT_ACCEPT:\n    if (cc < assert_na_end)\n      return FALSE;\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    if (cc == NULL)\n      return FALSE;\n    break;\n    }\n  }\nreturn TRUE;\n}\n\n#define EARLY_FAIL_ENHANCE_MAX (1 + 3)\n\n/*\nstart:\n  0 - skip / early fail allowed\n  1 - only early fail with range allowed\n  >1 - (start - 1) early fail is processed\n\nreturn: current number of iterators enhanced with fast fail\n*/\nstatic int detect_early_fail(compiler_common *common, PCRE2_SPTR cc, int *private_data_start,\n   sljit_s32 depth, int start, BOOL fast_forward_allowed)\n{\nPCRE2_SPTR begin = cc;\nPCRE2_SPTR next_alt;\nPCRE2_SPTR end;\nPCRE2_SPTR accelerated_start;\nBOOL prev_fast_forward_allowed;\nint result = 0;\nint count;\n\nSLJIT_ASSERT(*cc == OP_ONCE || *cc == OP_BRA || *cc == OP_CBRA);\nSLJIT_ASSERT(*cc != OP_CBRA || common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] != 0);\nSLJIT_ASSERT(start < EARLY_FAIL_ENHANCE_MAX);\n\nnext_alt = cc + GET(cc, 1);\nif (*next_alt == OP_ALT)\n  fast_forward_allowed = FALSE;\n\ndo\n  {\n  count = start;\n  cc += 1 + LINK_SIZE + ((*cc == OP_CBRA) ? IMM2_SIZE : 0);\n\n  while (TRUE)\n    {\n    accelerated_start = NULL;\n\n    switch(*cc)\n      {\n      case OP_SOD:\n      case OP_SOM:\n      case OP_SET_SOM:\n      case OP_NOT_WORD_BOUNDARY:\n      case OP_WORD_BOUNDARY:\n      case OP_EODN:\n      case OP_EOD:\n      case OP_CIRC:\n      case OP_CIRCM:\n      case OP_DOLL:\n      case OP_DOLLM:\n      /* Zero width assertions. */\n      cc++;\n      continue;\n\n      case OP_NOT_DIGIT:\n      case OP_DIGIT:\n      case OP_NOT_WHITESPACE:\n      case OP_WHITESPACE:\n      case OP_NOT_WORDCHAR:\n      case OP_WORDCHAR:\n      case OP_ANY:\n      case OP_ALLANY:\n      case OP_ANYBYTE:\n      case OP_NOT_HSPACE:\n      case OP_HSPACE:\n      case OP_NOT_VSPACE:\n      case OP_VSPACE:\n      fast_forward_allowed = FALSE;\n      cc++;\n      continue;\n\n      case OP_ANYNL:\n      case OP_EXTUNI:\n      fast_forward_allowed = FALSE;\n      if (count == 0)\n        count = 1;\n      cc++;\n      continue;\n\n      case OP_NOTPROP:\n      case OP_PROP:\n      fast_forward_allowed = FALSE;\n      cc += 1 + 2;\n      continue;\n\n      case OP_CHAR:\n      case OP_CHARI:\n      case OP_NOT:\n      case OP_NOTI:\n      fast_forward_allowed = FALSE;\n      cc += 2;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n      continue;\n\n      case OP_TYPESTAR:\n      case OP_TYPEMINSTAR:\n      case OP_TYPEPLUS:\n      case OP_TYPEMINPLUS:\n      case OP_TYPEPOSSTAR:\n      case OP_TYPEPOSPLUS:\n      /* The type or prop opcode is skipped in the next iteration. */\n      cc += 1;\n\n      if (cc[0] != OP_ANYNL && cc[0] != OP_EXTUNI)\n        {\n        accelerated_start = cc - 1;\n        break;\n        }\n\n      if (count == 0)\n        count = 1;\n      fast_forward_allowed = FALSE;\n      continue;\n\n      case OP_TYPEUPTO:\n      case OP_TYPEMINUPTO:\n      case OP_TYPEEXACT:\n      case OP_TYPEPOSUPTO:\n      cc += IMM2_SIZE;\n      /* Fall through */\n\n      case OP_TYPEQUERY:\n      case OP_TYPEMINQUERY:\n      case OP_TYPEPOSQUERY:\n      /* The type or prop opcode is skipped in the next iteration. */\n      fast_forward_allowed = FALSE;\n      if (count == 0)\n        count = 1;\n      cc += 1;\n      continue;\n\n      case OP_STAR:\n      case OP_MINSTAR:\n      case OP_PLUS:\n      case OP_MINPLUS:\n      case OP_POSSTAR:\n      case OP_POSPLUS:\n\n      case OP_STARI:\n      case OP_MINSTARI:\n      case OP_PLUSI:\n      case OP_MINPLUSI:\n      case OP_POSSTARI:\n      case OP_POSPLUSI:\n\n      case OP_NOTSTAR:\n      case OP_NOTMINSTAR:\n      case OP_NOTPLUS:\n      case OP_NOTMINPLUS:\n      case OP_NOTPOSSTAR:\n      case OP_NOTPOSPLUS:\n\n      case OP_NOTSTARI:\n      case OP_NOTMINSTARI:\n      case OP_NOTPLUSI:\n      case OP_NOTMINPLUSI:\n      case OP_NOTPOSSTARI:\n      case OP_NOTPOSPLUSI:\n      accelerated_start = cc;\n      cc += 2;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n      break;\n\n      case OP_UPTO:\n      case OP_MINUPTO:\n      case OP_EXACT:\n      case OP_POSUPTO:\n      case OP_UPTOI:\n      case OP_MINUPTOI:\n      case OP_EXACTI:\n      case OP_POSUPTOI:\n      case OP_NOTUPTO:\n      case OP_NOTMINUPTO:\n      case OP_NOTEXACT:\n      case OP_NOTPOSUPTO:\n      case OP_NOTUPTOI:\n      case OP_NOTMINUPTOI:\n      case OP_NOTEXACTI:\n      case OP_NOTPOSUPTOI:\n      cc += IMM2_SIZE;\n      /* Fall through */\n\n      case OP_QUERY:\n      case OP_MINQUERY:\n      case OP_POSQUERY:\n      case OP_QUERYI:\n      case OP_MINQUERYI:\n      case OP_POSQUERYI:\n      case OP_NOTQUERY:\n      case OP_NOTMINQUERY:\n      case OP_NOTPOSQUERY:\n      case OP_NOTQUERYI:\n      case OP_NOTMINQUERYI:\n      case OP_NOTPOSQUERYI:\n      fast_forward_allowed = FALSE;\n      if (count == 0)\n        count = 1;\n      cc += 2;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n      continue;\n\n      case OP_CLASS:\n      case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n      case OP_XCLASS:\n      accelerated_start = cc;\n      cc += ((*cc == OP_XCLASS) ? GET(cc, 1) : (unsigned int)(1 + (32 / sizeof(PCRE2_UCHAR))));\n#else\n      accelerated_start = cc;\n      cc += (1 + (32 / sizeof(PCRE2_UCHAR)));\n#endif\n\n      switch (*cc)\n        {\n        case OP_CRSTAR:\n        case OP_CRMINSTAR:\n        case OP_CRPLUS:\n        case OP_CRMINPLUS:\n        case OP_CRPOSSTAR:\n        case OP_CRPOSPLUS:\n        cc++;\n        break;\n\n        case OP_CRRANGE:\n        case OP_CRMINRANGE:\n        case OP_CRPOSRANGE:\n        cc += 2 * IMM2_SIZE;\n        /* Fall through */\n        case OP_CRQUERY:\n        case OP_CRMINQUERY:\n        case OP_CRPOSQUERY:\n        cc++;\n        if (count == 0)\n          count = 1;\n        /* Fall through */\n        default:\n        accelerated_start = NULL;\n        fast_forward_allowed = FALSE;\n        continue;\n        }\n      break;\n\n      case OP_ONCE:\n      case OP_BRA:\n      case OP_CBRA:\n      end = cc + GET(cc, 1);\n\n      prev_fast_forward_allowed = fast_forward_allowed;\n      fast_forward_allowed = FALSE;\n      if (depth >= 4)\n        break;\n\n      end = bracketend(cc) - (1 + LINK_SIZE);\n      if (*end != OP_KET || (*cc == OP_CBRA && common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] == 0))\n        break;\n\n      count = detect_early_fail(common, cc, private_data_start, depth + 1, count, prev_fast_forward_allowed);\n\n      if (PRIVATE_DATA(cc) != 0)\n        common->private_data_ptrs[begin - common->start] = 1;\n\n      if (count < EARLY_FAIL_ENHANCE_MAX)\n        {\n        cc = end + (1 + LINK_SIZE);\n        continue;\n        }\n      break;\n\n      case OP_KET:\n      SLJIT_ASSERT(PRIVATE_DATA(cc) == 0);\n      if (cc >= next_alt)\n        break;\n      cc += 1 + LINK_SIZE;\n      continue;\n      }\n\n    if (accelerated_start != NULL)\n      {\n      if (count == 0)\n        {\n        count++;\n\n        if (fast_forward_allowed)\n          {\n          common->fast_forward_bc_ptr = accelerated_start;\n          common->private_data_ptrs[(accelerated_start + 1) - common->start] = ((*private_data_start) << 3) | type_skip;\n          *private_data_start += sizeof(sljit_sw);\n          }\n        else\n          {\n          common->private_data_ptrs[(accelerated_start + 1) - common->start] = ((*private_data_start) << 3) | type_fail;\n\n          if (common->early_fail_start_ptr == 0)\n            common->early_fail_start_ptr = *private_data_start;\n\n          *private_data_start += sizeof(sljit_sw);\n          common->early_fail_end_ptr = *private_data_start;\n\n          if (*private_data_start > SLJIT_MAX_LOCAL_SIZE)\n            return EARLY_FAIL_ENHANCE_MAX;\n          }\n        }\n      else\n        {\n        common->private_data_ptrs[(accelerated_start + 1) - common->start] = ((*private_data_start) << 3) | type_fail_range;\n\n        if (common->early_fail_start_ptr == 0)\n          common->early_fail_start_ptr = *private_data_start;\n\n        *private_data_start += 2 * sizeof(sljit_sw);\n        common->early_fail_end_ptr = *private_data_start;\n\n        if (*private_data_start > SLJIT_MAX_LOCAL_SIZE)\n          return EARLY_FAIL_ENHANCE_MAX;\n        }\n\n      /* Cannot be part of a repeat. */\n      common->private_data_ptrs[begin - common->start] = 1;\n      count++;\n\n      if (count < EARLY_FAIL_ENHANCE_MAX)\n        continue;\n      }\n\n    break;\n    }\n\n  if (*cc != OP_ALT && *cc != OP_KET)\n    result = EARLY_FAIL_ENHANCE_MAX;\n  else if (result < count)\n    result = count;\n\n  cc = next_alt;\n  next_alt = cc + GET(cc, 1);\n  }\nwhile (*cc == OP_ALT);\n\nreturn result;\n}\n\nstatic int get_class_iterator_size(PCRE2_SPTR cc)\n{\nsljit_u32 min;\nsljit_u32 max;\nswitch(*cc)\n  {\n  case OP_CRSTAR:\n  case OP_CRPLUS:\n  return 2;\n\n  case OP_CRMINSTAR:\n  case OP_CRMINPLUS:\n  case OP_CRQUERY:\n  case OP_CRMINQUERY:\n  return 1;\n\n  case OP_CRRANGE:\n  case OP_CRMINRANGE:\n  min = GET2(cc, 1);\n  max = GET2(cc, 1 + IMM2_SIZE);\n  if (max == 0)\n    return (*cc == OP_CRRANGE) ? 2 : 1;\n  max -= min;\n  if (max > 2)\n    max = 2;\n  return max;\n\n  default:\n  return 0;\n  }\n}\n\nstatic BOOL detect_repeat(compiler_common *common, PCRE2_SPTR begin)\n{\nPCRE2_SPTR end = bracketend(begin);\nPCRE2_SPTR next;\nPCRE2_SPTR next_end;\nPCRE2_SPTR max_end;\nPCRE2_UCHAR type;\nsljit_sw length = end - begin;\nsljit_s32 min, max, i;\n\n/* Detect fixed iterations first. */\nif (end[-(1 + LINK_SIZE)] != OP_KET || PRIVATE_DATA(begin) != 0)\n  return FALSE;\n\n/* /(?:AB){4,6}/ is currently converted to /(?:AB){3}(?AB){1,3}/\n * Skip the check of the second part. */\nif (PRIVATE_DATA(end - LINK_SIZE) != 0)\n  return TRUE;\n\nnext = end;\nmin = 1;\nwhile (1)\n  {\n  if (*next != *begin)\n    break;\n  next_end = bracketend(next);\n  if (next_end - next != length || memcmp(begin, next, IN_UCHARS(length)) != 0)\n    break;\n  next = next_end;\n  min++;\n  }\n\nif (min == 2)\n  return FALSE;\n\nmax = 0;\nmax_end = next;\nif (*next == OP_BRAZERO || *next == OP_BRAMINZERO)\n  {\n  type = *next;\n  while (1)\n    {\n    if (next[0] != type || next[1] != OP_BRA || next[2 + LINK_SIZE] != *begin)\n      break;\n    next_end = bracketend(next + 2 + LINK_SIZE);\n    if (next_end - next != (length + 2 + LINK_SIZE) || memcmp(begin, next + 2 + LINK_SIZE, IN_UCHARS(length)) != 0)\n      break;\n    next = next_end;\n    max++;\n    }\n\n  if (next[0] == type && next[1] == *begin && max >= 1)\n    {\n    next_end = bracketend(next + 1);\n    if (next_end - next == (length + 1) && memcmp(begin, next + 1, IN_UCHARS(length)) == 0)\n      {\n      for (i = 0; i < max; i++, next_end += 1 + LINK_SIZE)\n        if (*next_end != OP_KET)\n          break;\n\n      if (i == max)\n        {\n        common->private_data_ptrs[max_end - common->start - LINK_SIZE] = next_end - max_end;\n        common->private_data_ptrs[max_end - common->start - LINK_SIZE + 1] = (type == OP_BRAZERO) ? OP_UPTO : OP_MINUPTO;\n        /* +2 the original and the last. */\n        common->private_data_ptrs[max_end - common->start - LINK_SIZE + 2] = max + 2;\n        if (min == 1)\n          return TRUE;\n        min--;\n        max_end -= (1 + LINK_SIZE) + GET(max_end, -LINK_SIZE);\n        }\n      }\n    }\n  }\n\nif (min >= 3)\n  {\n  common->private_data_ptrs[end - common->start - LINK_SIZE] = max_end - end;\n  common->private_data_ptrs[end - common->start - LINK_SIZE + 1] = OP_EXACT;\n  common->private_data_ptrs[end - common->start - LINK_SIZE + 2] = min;\n  return TRUE;\n  }\n\nreturn FALSE;\n}\n\n#define CASE_ITERATOR_PRIVATE_DATA_1 \\\n    case OP_MINSTAR: \\\n    case OP_MINPLUS: \\\n    case OP_QUERY: \\\n    case OP_MINQUERY: \\\n    case OP_MINSTARI: \\\n    case OP_MINPLUSI: \\\n    case OP_QUERYI: \\\n    case OP_MINQUERYI: \\\n    case OP_NOTMINSTAR: \\\n    case OP_NOTMINPLUS: \\\n    case OP_NOTQUERY: \\\n    case OP_NOTMINQUERY: \\\n    case OP_NOTMINSTARI: \\\n    case OP_NOTMINPLUSI: \\\n    case OP_NOTQUERYI: \\\n    case OP_NOTMINQUERYI:\n\n#define CASE_ITERATOR_PRIVATE_DATA_2A \\\n    case OP_STAR: \\\n    case OP_PLUS: \\\n    case OP_STARI: \\\n    case OP_PLUSI: \\\n    case OP_NOTSTAR: \\\n    case OP_NOTPLUS: \\\n    case OP_NOTSTARI: \\\n    case OP_NOTPLUSI:\n\n#define CASE_ITERATOR_PRIVATE_DATA_2B \\\n    case OP_UPTO: \\\n    case OP_MINUPTO: \\\n    case OP_UPTOI: \\\n    case OP_MINUPTOI: \\\n    case OP_NOTUPTO: \\\n    case OP_NOTMINUPTO: \\\n    case OP_NOTUPTOI: \\\n    case OP_NOTMINUPTOI:\n\n#define CASE_ITERATOR_TYPE_PRIVATE_DATA_1 \\\n    case OP_TYPEMINSTAR: \\\n    case OP_TYPEMINPLUS: \\\n    case OP_TYPEQUERY: \\\n    case OP_TYPEMINQUERY:\n\n#define CASE_ITERATOR_TYPE_PRIVATE_DATA_2A \\\n    case OP_TYPESTAR: \\\n    case OP_TYPEPLUS:\n\n#define CASE_ITERATOR_TYPE_PRIVATE_DATA_2B \\\n    case OP_TYPEUPTO: \\\n    case OP_TYPEMINUPTO:\n\nstatic void set_private_data_ptrs(compiler_common *common, int *private_data_start, PCRE2_SPTR ccend)\n{\nPCRE2_SPTR cc = common->start;\nPCRE2_SPTR alternative;\nPCRE2_SPTR end = NULL;\nint private_data_ptr = *private_data_start;\nint space, size, bracketlen;\nBOOL repeat_check = TRUE;\n\nwhile (cc < ccend)\n  {\n  space = 0;\n  size = 0;\n  bracketlen = 0;\n  if (private_data_ptr > SLJIT_MAX_LOCAL_SIZE)\n    break;\n\n  /* When the bracket is prefixed by a zero iteration, skip the repeat check (at this point). */\n  if (repeat_check && (*cc == OP_ONCE || *cc == OP_BRA || *cc == OP_CBRA || *cc == OP_COND))\n    {\n    if (detect_repeat(common, cc))\n      {\n      /* These brackets are converted to repeats, so no global\n      based single character repeat is allowed. */\n      if (cc >= end)\n        end = bracketend(cc);\n      }\n    }\n  repeat_check = TRUE;\n\n  switch(*cc)\n    {\n    case OP_KET:\n    if (common->private_data_ptrs[cc + 1 - common->start] != 0)\n      {\n      common->private_data_ptrs[cc - common->start] = private_data_ptr;\n      private_data_ptr += sizeof(sljit_sw);\n      cc += common->private_data_ptrs[cc + 1 - common->start];\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    common->private_data_ptrs[cc - common->start] = private_data_ptr;\n    private_data_ptr += sizeof(sljit_sw);\n    bracketlen = 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    common->private_data_ptrs[cc - common->start] = private_data_ptr;\n    private_data_ptr += sizeof(sljit_sw);\n    bracketlen = 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    common->private_data_ptrs[cc - common->start] = 0;\n    alternative = cc + GET(cc, 1);\n    if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n      {\n      common->private_data_ptrs[cc - common->start] = private_data_ptr;\n      private_data_ptr += sizeof(sljit_sw);\n      }\n    bracketlen = 1 + LINK_SIZE;\n    break;\n\n    case OP_BRA:\n    bracketlen = 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    bracketlen = 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_BRAZERO:\n    case OP_BRAMINZERO:\n    case OP_BRAPOSZERO:\n    size = 1;\n    repeat_check = FALSE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    size = -2;\n    space = 1;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    size = -2;\n    space = 2;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    size = -(2 + IMM2_SIZE);\n    space = 2;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    size = 1;\n    space = 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    size = 1;\n    if (cc[1] != OP_ANYNL && cc[1] != OP_EXTUNI)\n      space = 2;\n    break;\n\n    case OP_TYPEUPTO:\n    size = 1 + IMM2_SIZE;\n    if (cc[1 + IMM2_SIZE] != OP_ANYNL && cc[1 + IMM2_SIZE] != OP_EXTUNI)\n      space = 2;\n    break;\n\n    case OP_TYPEMINUPTO:\n    size = 1 + IMM2_SIZE;\n    space = 2;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    size = 1 + 32 / sizeof(PCRE2_UCHAR);\n    space = get_class_iterator_size(cc + size);\n    break;\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    size = GET(cc, 1);\n    space = get_class_iterator_size(cc + size);\n    break;\n#endif\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\n  /* Character iterators, which are not inside a repeated bracket,\n     gets a private slot instead of allocating it on the stack. */\n  if (space > 0 && cc >= end)\n    {\n    common->private_data_ptrs[cc - common->start] = private_data_ptr;\n    private_data_ptr += sizeof(sljit_sw) * space;\n    }\n\n  if (size != 0)\n    {\n    if (size < 0)\n      {\n      cc += -size;\n#ifdef SUPPORT_UNICODE\n      if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n      }\n    else\n      cc += size;\n    }\n\n  if (bracketlen > 0)\n    {\n    if (cc >= end)\n      {\n      end = bracketend(cc);\n      if (end[-1 - LINK_SIZE] == OP_KET)\n        end = NULL;\n      }\n    cc += bracketlen;\n    }\n  }\n*private_data_start = private_data_ptr;\n}\n\n/* Returns with a frame_types (always < 0) if no need for frame. */\nstatic int get_framesize(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, BOOL recursive, BOOL *needs_control_head)\n{\nint length = 0;\nint possessive = 0;\nBOOL stack_restore = FALSE;\nBOOL setsom_found = recursive;\nBOOL setmark_found = recursive;\n/* The last capture is a local variable even for recursions. */\nBOOL capture_last_found = FALSE;\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\n*needs_control_head = TRUE;\n#else\n*needs_control_head = FALSE;\n#endif\n\nif (ccend == NULL)\n  {\n  ccend = bracketend(cc) - (1 + LINK_SIZE);\n  if (!recursive && (*cc == OP_CBRAPOS || *cc == OP_SCBRAPOS))\n    {\n    possessive = length = (common->capture_last_ptr != 0) ? 5 : 3;\n    /* This is correct regardless of common->capture_last_ptr. */\n    capture_last_found = TRUE;\n    }\n  cc = next_opcode(common, cc);\n  }\n\nSLJIT_ASSERT(cc != NULL);\nwhile (cc < ccend)\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    stack_restore = TRUE;\n    if (!setsom_found)\n      {\n      length += 2;\n      setsom_found = TRUE;\n      }\n    cc += 1;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    stack_restore = TRUE;\n    if (!setmark_found)\n      {\n      length += 2;\n      setmark_found = TRUE;\n      }\n    if (common->control_head_ptr != 0)\n      *needs_control_head = TRUE;\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_RECURSE:\n    stack_restore = TRUE;\n    if (common->has_set_som && !setsom_found)\n      {\n      length += 2;\n      setsom_found = TRUE;\n      }\n    if (common->mark_ptr != 0 && !setmark_found)\n      {\n      length += 2;\n      setmark_found = TRUE;\n      }\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      length += 2;\n      capture_last_found = TRUE;\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_CBRAPOS:\n    case OP_SCBRA:\n    case OP_SCBRAPOS:\n    stack_restore = TRUE;\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      length += 2;\n      capture_last_found = TRUE;\n      }\n    length += 3;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_THEN:\n    stack_restore = TRUE;\n    if (common->control_head_ptr != 0)\n      *needs_control_head = TRUE;\n    cc ++;\n    break;\n\n    default:\n    stack_restore = TRUE;\n    /* Fall through. */\n\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_NOT_DIGIT:\n    case OP_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_WORDCHAR:\n    case OP_ANY:\n    case OP_ALLANY:\n    case OP_ANYBYTE:\n    case OP_NOTPROP:\n    case OP_PROP:\n    case OP_ANYNL:\n    case OP_NOT_HSPACE:\n    case OP_HSPACE:\n    case OP_NOT_VSPACE:\n    case OP_VSPACE:\n    case OP_EXTUNI:\n    case OP_EODN:\n    case OP_EOD:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_DOLL:\n    case OP_DOLLM:\n    case OP_CHAR:\n    case OP_CHARI:\n    case OP_NOT:\n    case OP_NOTI:\n\n    case OP_EXACT:\n    case OP_POSSTAR:\n    case OP_POSPLUS:\n    case OP_POSQUERY:\n    case OP_POSUPTO:\n\n    case OP_EXACTI:\n    case OP_POSSTARI:\n    case OP_POSPLUSI:\n    case OP_POSQUERYI:\n    case OP_POSUPTOI:\n\n    case OP_NOTEXACT:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSUPTO:\n\n    case OP_NOTEXACTI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTPOSQUERYI:\n    case OP_NOTPOSUPTOI:\n\n    case OP_TYPEEXACT:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEPOSQUERY:\n    case OP_TYPEPOSUPTO:\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    case OP_XCLASS:\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\n/* Possessive quantifiers can use a special case. */\nif (SLJIT_UNLIKELY(possessive == length))\n  return stack_restore ? no_frame : no_stack;\n\nif (length > 0)\n  return length + 1;\nreturn stack_restore ? no_frame : no_stack;\n}\n\nstatic void init_frame(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, int stackpos, int stacktop)\n{\nDEFINE_COMPILER;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\n/* The last capture is a local variable even for recursions. */\nBOOL capture_last_found = FALSE;\nint offset;\n\n/* >= 1 + shortest item size (2) */\nSLJIT_UNUSED_ARG(stacktop);\nSLJIT_ASSERT(stackpos >= stacktop + 2);\n\nstackpos = STACK(stackpos);\nif (ccend == NULL)\n  {\n  ccend = bracketend(cc) - (1 + LINK_SIZE);\n  if (*cc != OP_CBRAPOS && *cc != OP_SCBRAPOS)\n    cc = next_opcode(common, cc);\n  }\n\nSLJIT_ASSERT(cc != NULL);\nwhile (cc < ccend)\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    if (!setsom_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -OVECTOR(0));\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setsom_found = TRUE;\n      }\n    cc += 1;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (!setmark_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->mark_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setmark_found = TRUE;\n      }\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_RECURSE:\n    if (common->has_set_som && !setsom_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -OVECTOR(0));\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setsom_found = TRUE;\n      }\n    if (common->mark_ptr != 0 && !setmark_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->mark_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      setmark_found = TRUE;\n      }\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->capture_last_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      capture_last_found = TRUE;\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_CBRAPOS:\n    case OP_SCBRA:\n    case OP_SCBRAPOS:\n    if (common->capture_last_ptr != 0 && !capture_last_found)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, -common->capture_last_ptr);\n      stackpos -= (int)sizeof(sljit_sw);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n      stackpos -= (int)sizeof(sljit_sw);\n      capture_last_found = TRUE;\n      }\n    offset = (GET2(cc, 1 + LINK_SIZE)) << 1;\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, OVECTOR(offset));\n    stackpos -= (int)sizeof(sljit_sw);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP1, 0);\n    stackpos -= (int)sizeof(sljit_sw);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, TMP2, 0);\n    stackpos -= (int)sizeof(sljit_sw);\n\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), stackpos, SLJIT_IMM, 0);\nSLJIT_ASSERT(stackpos == STACK(stacktop));\n}\n\n#define RECURSE_TMP_REG_COUNT 3\n\ntypedef struct delayed_mem_copy_status {\n  struct sljit_compiler *compiler;\n  int store_bases[RECURSE_TMP_REG_COUNT];\n  int store_offsets[RECURSE_TMP_REG_COUNT];\n  int tmp_regs[RECURSE_TMP_REG_COUNT];\n  int saved_tmp_regs[RECURSE_TMP_REG_COUNT];\n  int next_tmp_reg;\n} delayed_mem_copy_status;\n\nstatic void delayed_mem_copy_init(delayed_mem_copy_status *status, compiler_common *common)\n{\nint i;\n\nfor (i = 0; i < RECURSE_TMP_REG_COUNT; i++)\n  {\n  SLJIT_ASSERT(status->tmp_regs[i] >= 0);\n  SLJIT_ASSERT(sljit_get_register_index(status->saved_tmp_regs[i]) < 0 || status->tmp_regs[i] == status->saved_tmp_regs[i]);\n\n  status->store_bases[i] = -1;\n  }\nstatus->next_tmp_reg = 0;\nstatus->compiler = common->compiler;\n}\n\nstatic void delayed_mem_copy_move(delayed_mem_copy_status *status, int load_base, sljit_sw load_offset,\n  int store_base, sljit_sw store_offset)\n{\nstruct sljit_compiler *compiler = status->compiler;\nint next_tmp_reg = status->next_tmp_reg;\nint tmp_reg = status->tmp_regs[next_tmp_reg];\n\nSLJIT_ASSERT(load_base > 0 && store_base > 0);\n\nif (status->store_bases[next_tmp_reg] == -1)\n  {\n  /* Preserve virtual registers. */\n  if (sljit_get_register_index(status->saved_tmp_regs[next_tmp_reg]) < 0)\n    OP1(SLJIT_MOV, status->saved_tmp_regs[next_tmp_reg], 0, tmp_reg, 0);\n  }\nelse\n  OP1(SLJIT_MOV, SLJIT_MEM1(status->store_bases[next_tmp_reg]), status->store_offsets[next_tmp_reg], tmp_reg, 0);\n\nOP1(SLJIT_MOV, tmp_reg, 0, SLJIT_MEM1(load_base), load_offset);\nstatus->store_bases[next_tmp_reg] = store_base;\nstatus->store_offsets[next_tmp_reg] = store_offset;\n\nstatus->next_tmp_reg = (next_tmp_reg + 1) % RECURSE_TMP_REG_COUNT;\n}\n\nstatic void delayed_mem_copy_finish(delayed_mem_copy_status *status)\n{\nstruct sljit_compiler *compiler = status->compiler;\nint next_tmp_reg = status->next_tmp_reg;\nint tmp_reg, saved_tmp_reg, i;\n\nfor (i = 0; i < RECURSE_TMP_REG_COUNT; i++)\n  {\n  if (status->store_bases[next_tmp_reg] != -1)\n    {\n    tmp_reg = status->tmp_regs[next_tmp_reg];\n    saved_tmp_reg = status->saved_tmp_regs[next_tmp_reg];\n\n    OP1(SLJIT_MOV, SLJIT_MEM1(status->store_bases[next_tmp_reg]), status->store_offsets[next_tmp_reg], tmp_reg, 0);\n\n    /* Restore virtual registers. */\n    if (sljit_get_register_index(saved_tmp_reg) < 0)\n      OP1(SLJIT_MOV, tmp_reg, 0, saved_tmp_reg, 0);\n    }\n\n  next_tmp_reg = (next_tmp_reg + 1) % RECURSE_TMP_REG_COUNT;\n  }\n}\n\n#undef RECURSE_TMP_REG_COUNT\n\nstatic BOOL recurse_check_bit(compiler_common *common, sljit_sw bit_index)\n{\nuint8_t *byte;\nuint8_t mask;\n\nSLJIT_ASSERT((bit_index & (sizeof(sljit_sw) - 1)) == 0);\n\nbit_index >>= SLJIT_WORD_SHIFT;\n\nmask = 1 << (bit_index & 0x7);\nbyte = common->recurse_bitset + (bit_index >> 3);\n\nif (*byte & mask)\n  return FALSE;\n\n*byte |= mask;\nreturn TRUE;\n}\n\nstatic int get_recurse_data_length(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend,\n  BOOL *needs_control_head, BOOL *has_quit, BOOL *has_accept)\n{\nint length = 1;\nint size, offset;\nPCRE2_SPTR alternative;\nBOOL quit_found = FALSE;\nBOOL accept_found = FALSE;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\nBOOL control_head_found = FALSE;\n\nmemset(common->recurse_bitset, 0, common->recurse_bitset_size);\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\ncontrol_head_found = TRUE;\n#endif\n\n/* Calculate the sum of the private machine words. */\nwhile (cc < ccend)\n  {\n  size = 0;\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    setsom_found = TRUE;\n    cc += 1;\n    break;\n\n    case OP_RECURSE:\n    if (common->has_set_som)\n      setsom_found = TRUE;\n    if (common->mark_ptr != 0)\n      setmark_found = TRUE;\n    if (common->capture_last_ptr != 0 && recurse_check_bit(common, common->capture_last_ptr))\n      length++;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_KET:\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0)\n      {\n      if (recurse_check_bit(common, offset))\n        length++;\n      SLJIT_ASSERT(PRIVATE_DATA(cc + 1) != 0);\n      cc += PRIVATE_DATA(cc + 1);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    SLJIT_ASSERT(PRIVATE_DATA(cc) != 0);\n    if (recurse_check_bit(common, PRIVATE_DATA(cc)))\n      length++;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    offset = GET2(cc, 1 + LINK_SIZE);\n    if (recurse_check_bit(common, OVECTOR(offset << 1)))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, OVECTOR((offset << 1) + 1)));\n      length += 2;\n      }\n    if (common->optimized_cbracket[offset] == 0 && recurse_check_bit(common, OVECTOR_PRIV(offset)))\n      length++;\n    if (common->capture_last_ptr != 0 && recurse_check_bit(common, common->capture_last_ptr))\n      length++;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    offset = GET2(cc, 1 + LINK_SIZE);\n    if (recurse_check_bit(common, OVECTOR(offset << 1)))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, OVECTOR((offset << 1) + 1)));\n      length += 2;\n      }\n    if (recurse_check_bit(common, OVECTOR_PRIV(offset)))\n      length++;\n    if (recurse_check_bit(common, PRIVATE_DATA(cc)))\n      length++;\n    if (common->capture_last_ptr != 0 && recurse_check_bit(common, common->capture_last_ptr))\n      length++;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    alternative = cc + GET(cc, 1);\n    if ((*alternative == OP_KETRMAX || *alternative == OP_KETRMIN) && recurse_check_bit(common, PRIVATE_DATA(cc)))\n      length++;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      length++;\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, offset + sizeof(sljit_sw)));\n      length += 2;\n      }\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, offset + sizeof(sljit_sw)));\n      length += 2;\n      }\n    cc += 2 + IMM2_SIZE;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      length++;\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, offset + sizeof(sljit_sw)));\n      length += 2;\n      }\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, offset + sizeof(sljit_sw)));\n      length += 2;\n      }\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    size = (*cc == OP_XCLASS) ? GET(cc, 1) : 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#else\n    size = 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#endif\n\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      length += get_class_iterator_size(cc + size);\n    cc += size;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (!setmark_found)\n      setmark_found = TRUE;\n    if (common->control_head_ptr != 0)\n      control_head_found = TRUE;\n    if (*cc != OP_MARK)\n      quit_found = TRUE;\n\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_PRUNE:\n    case OP_SKIP:\n    case OP_COMMIT:\n    quit_found = TRUE;\n    cc++;\n    break;\n\n    case OP_SKIP_ARG:\n    quit_found = TRUE;\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_THEN:\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n    quit_found = TRUE;\n    control_head_found = TRUE;\n    cc++;\n    break;\n\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    accept_found = TRUE;\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n  }\nSLJIT_ASSERT(cc == ccend);\n\nif (control_head_found)\n  length++;\nif (quit_found)\n  {\n  if (setsom_found)\n    length++;\n  if (setmark_found)\n    length++;\n  }\n\n*needs_control_head = control_head_found;\n*has_quit = quit_found;\n*has_accept = accept_found;\nreturn length;\n}\n\nenum copy_recurse_data_types {\n  recurse_copy_from_global,\n  recurse_copy_private_to_global,\n  recurse_copy_shared_to_global,\n  recurse_copy_kept_shared_to_global,\n  recurse_swap_global\n};\n\nstatic void copy_recurse_data(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend,\n  int type, int stackptr, int stacktop, BOOL has_quit)\n{\ndelayed_mem_copy_status status;\nPCRE2_SPTR alternative;\nsljit_sw private_srcw[2];\nsljit_sw shared_srcw[3];\nsljit_sw kept_shared_srcw[2];\nint private_count, shared_count, kept_shared_count;\nint from_sp, base_reg, offset, i;\n\nmemset(common->recurse_bitset, 0, common->recurse_bitset_size);\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\nrecurse_check_bit(common, common->control_head_ptr);\n#endif\n\nswitch (type)\n  {\n  case recurse_copy_from_global:\n  from_sp = TRUE;\n  base_reg = STACK_TOP;\n  break;\n\n  case recurse_copy_private_to_global:\n  case recurse_copy_shared_to_global:\n  case recurse_copy_kept_shared_to_global:\n  from_sp = FALSE;\n  base_reg = STACK_TOP;\n  break;\n\n  default:\n  SLJIT_ASSERT(type == recurse_swap_global);\n  from_sp = FALSE;\n  base_reg = TMP2;\n  break;\n  }\n\nstackptr = STACK(stackptr);\nstacktop = STACK(stacktop);\n\nstatus.tmp_regs[0] = TMP1;\nstatus.saved_tmp_regs[0] = TMP1;\n\nif (base_reg != TMP2)\n  {\n  status.tmp_regs[1] = TMP2;\n  status.saved_tmp_regs[1] = TMP2;\n  }\nelse\n  {\n  status.saved_tmp_regs[1] = RETURN_ADDR;\n  if (HAS_VIRTUAL_REGISTERS)\n    status.tmp_regs[1] = STR_PTR;\n  else\n    status.tmp_regs[1] = RETURN_ADDR;\n  }\n\nstatus.saved_tmp_regs[2] = TMP3;\nif (HAS_VIRTUAL_REGISTERS)\n  status.tmp_regs[2] = STR_END;\nelse\n  status.tmp_regs[2] = TMP3;\n\ndelayed_mem_copy_init(&status, common);\n\nif (type != recurse_copy_shared_to_global && type != recurse_copy_kept_shared_to_global)\n  {\n  SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_private_to_global || type == recurse_swap_global);\n\n  if (!from_sp)\n    delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, common->recursive_head_ptr);\n\n  if (from_sp || type == recurse_swap_global)\n    delayed_mem_copy_move(&status, SLJIT_SP, common->recursive_head_ptr, base_reg, stackptr);\n  }\n\nstackptr += sizeof(sljit_sw);\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nif (type != recurse_copy_shared_to_global)\n  {\n  if (!from_sp)\n    delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, common->control_head_ptr);\n\n  if (from_sp || type == recurse_swap_global)\n    delayed_mem_copy_move(&status, SLJIT_SP, common->control_head_ptr, base_reg, stackptr);\n  }\n\nstackptr += sizeof(sljit_sw);\n#endif\n\nwhile (cc < ccend)\n  {\n  private_count = 0;\n  shared_count = 0;\n  kept_shared_count = 0;\n\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    if (has_quit && recurse_check_bit(common, OVECTOR(0)))\n      {\n      kept_shared_srcw[0] = OVECTOR(0);\n      kept_shared_count = 1;\n      }\n    cc += 1;\n    break;\n\n    case OP_RECURSE:\n    if (has_quit)\n      {\n      if (common->has_set_som && recurse_check_bit(common, OVECTOR(0)))\n        {\n        kept_shared_srcw[0] = OVECTOR(0);\n        kept_shared_count = 1;\n        }\n      if (common->mark_ptr != 0 && recurse_check_bit(common, common->mark_ptr))\n        {\n        kept_shared_srcw[kept_shared_count] = common->mark_ptr;\n        kept_shared_count++;\n        }\n      }\n    if (common->capture_last_ptr != 0 && recurse_check_bit(common, common->capture_last_ptr))\n      {\n      shared_srcw[0] = common->capture_last_ptr;\n      shared_count = 1;\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_KET:\n    private_srcw[0] = PRIVATE_DATA(cc);\n    if (private_srcw[0] != 0)\n      {\n      if (recurse_check_bit(common, private_srcw[0]))\n        private_count = 1;\n      SLJIT_ASSERT(PRIVATE_DATA(cc + 1) != 0);\n      cc += PRIVATE_DATA(cc + 1);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    private_srcw[0] = PRIVATE_DATA(cc);\n    if (recurse_check_bit(common, private_srcw[0]))\n      private_count = 1;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    offset = GET2(cc, 1 + LINK_SIZE);\n    shared_srcw[0] = OVECTOR(offset << 1);\n    if (recurse_check_bit(common, shared_srcw[0]))\n      {\n      shared_srcw[1] = shared_srcw[0] + sizeof(sljit_sw);\n      SLJIT_ASSERT(recurse_check_bit(common, shared_srcw[1]));\n      shared_count = 2;\n      }\n\n    if (common->capture_last_ptr != 0 && recurse_check_bit(common, common->capture_last_ptr))\n      {\n      shared_srcw[shared_count] = common->capture_last_ptr;\n      shared_count++;\n      }\n\n    if (common->optimized_cbracket[offset] == 0)\n      {\n      private_srcw[0] = OVECTOR_PRIV(offset);\n      if (recurse_check_bit(common, private_srcw[0]))\n        private_count = 1;\n      }\n\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    offset = GET2(cc, 1 + LINK_SIZE);\n    shared_srcw[0] = OVECTOR(offset << 1);\n    if (recurse_check_bit(common, shared_srcw[0]))\n      {\n      shared_srcw[1] = shared_srcw[0] + sizeof(sljit_sw);\n      SLJIT_ASSERT(recurse_check_bit(common, shared_srcw[1]));\n      shared_count = 2;\n      }\n\n    if (common->capture_last_ptr != 0 && recurse_check_bit(common, common->capture_last_ptr))\n      {\n      shared_srcw[shared_count] = common->capture_last_ptr;\n      shared_count++;\n      }\n\n    private_srcw[0] = PRIVATE_DATA(cc);\n    if (recurse_check_bit(common, private_srcw[0]))\n      private_count = 1;\n\n    offset = OVECTOR_PRIV(offset);\n    if (recurse_check_bit(common, offset))\n      {\n      private_srcw[private_count] = offset;\n      private_count++;\n      }\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    alternative = cc + GET(cc, 1);\n    if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n      {\n      private_srcw[0] = PRIVATE_DATA(cc);\n      if (recurse_check_bit(common, private_srcw[0]))\n        private_count = 1;\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    private_srcw[0] = PRIVATE_DATA(cc);\n    if (private_srcw[0] != 0 && recurse_check_bit(common, private_srcw[0]))\n      private_count = 1;\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    private_srcw[0] = PRIVATE_DATA(cc);\n    if (private_srcw[0] != 0 && recurse_check_bit(common, private_srcw[0]))\n      {\n      private_count = 2;\n      private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n      SLJIT_ASSERT(recurse_check_bit(common, private_srcw[1]));\n      }\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    private_srcw[0] = PRIVATE_DATA(cc);\n    if (private_srcw[0] != 0 && recurse_check_bit(common, private_srcw[0]))\n      {\n      private_count = 2;\n      private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n      SLJIT_ASSERT(recurse_check_bit(common, private_srcw[1]));\n      }\n    cc += 2 + IMM2_SIZE;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    private_srcw[0] = PRIVATE_DATA(cc);\n    if (private_srcw[0] != 0 && recurse_check_bit(common, private_srcw[0]))\n      private_count = 1;\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    private_srcw[0] = PRIVATE_DATA(cc);\n    if (private_srcw[0] != 0 && recurse_check_bit(common, private_srcw[0]))\n      {\n      private_count = 2;\n      private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n      SLJIT_ASSERT(recurse_check_bit(common, private_srcw[1]));\n      }\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n    private_srcw[0] = PRIVATE_DATA(cc);\n    if (private_srcw[0] != 0 && recurse_check_bit(common, private_srcw[0]))\n      {\n      private_count = 2;\n      private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n      SLJIT_ASSERT(recurse_check_bit(common, private_srcw[1]));\n      }\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    i = (*cc == OP_XCLASS) ? GET(cc, 1) : 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#else\n    i = 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#endif\n    if (PRIVATE_DATA(cc) != 0)\n      switch(get_class_iterator_size(cc + i))\n        {\n        case 1:\n        private_srcw[0] = PRIVATE_DATA(cc);\n        break;\n\n        case 2:\n        private_srcw[0] = PRIVATE_DATA(cc);\n        if (recurse_check_bit(common, private_srcw[0]))\n          {\n          private_count = 2;\n          private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n          SLJIT_ASSERT(recurse_check_bit(common, private_srcw[1]));\n          }\n        break;\n\n        default:\n        SLJIT_UNREACHABLE();\n        break;\n        }\n    cc += i;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (has_quit && recurse_check_bit(common, common->mark_ptr))\n      {\n      kept_shared_srcw[0] = common->mark_ptr;\n      kept_shared_count = 1;\n      }\n    if (common->control_head_ptr != 0 && recurse_check_bit(common, common->control_head_ptr))\n      {\n      private_srcw[0] = common->control_head_ptr;\n      private_count = 1;\n      }\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_THEN:\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n    if (recurse_check_bit(common, common->control_head_ptr))\n      {\n      private_srcw[0] = common->control_head_ptr;\n      private_count = 1;\n      }\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    continue;\n    }\n\n  if (type != recurse_copy_shared_to_global && type != recurse_copy_kept_shared_to_global)\n    {\n    SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_private_to_global || type == recurse_swap_global);\n\n    for (i = 0; i < private_count; i++)\n      {\n      SLJIT_ASSERT(private_srcw[i] != 0);\n\n      if (!from_sp)\n        delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, private_srcw[i]);\n\n      if (from_sp || type == recurse_swap_global)\n        delayed_mem_copy_move(&status, SLJIT_SP, private_srcw[i], base_reg, stackptr);\n\n      stackptr += sizeof(sljit_sw);\n      }\n    }\n  else\n    stackptr += sizeof(sljit_sw) * private_count;\n\n  if (type != recurse_copy_private_to_global && type != recurse_copy_kept_shared_to_global)\n    {\n    SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_shared_to_global || type == recurse_swap_global);\n\n    for (i = 0; i < shared_count; i++)\n      {\n      SLJIT_ASSERT(shared_srcw[i] != 0);\n\n      if (!from_sp)\n        delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, shared_srcw[i]);\n\n      if (from_sp || type == recurse_swap_global)\n        delayed_mem_copy_move(&status, SLJIT_SP, shared_srcw[i], base_reg, stackptr);\n\n      stackptr += sizeof(sljit_sw);\n      }\n    }\n  else\n    stackptr += sizeof(sljit_sw) * shared_count;\n\n  if (type != recurse_copy_private_to_global && type != recurse_swap_global)\n    {\n    SLJIT_ASSERT(type == recurse_copy_from_global || type == recurse_copy_shared_to_global || type == recurse_copy_kept_shared_to_global);\n\n    for (i = 0; i < kept_shared_count; i++)\n      {\n      SLJIT_ASSERT(kept_shared_srcw[i] != 0);\n\n      if (!from_sp)\n        delayed_mem_copy_move(&status, base_reg, stackptr, SLJIT_SP, kept_shared_srcw[i]);\n\n      if (from_sp || type == recurse_swap_global)\n        delayed_mem_copy_move(&status, SLJIT_SP, kept_shared_srcw[i], base_reg, stackptr);\n\n      stackptr += sizeof(sljit_sw);\n      }\n    }\n  else\n    stackptr += sizeof(sljit_sw) * kept_shared_count;\n  }\n\nSLJIT_ASSERT(cc == ccend && stackptr == stacktop);\n\ndelayed_mem_copy_finish(&status);\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR set_then_offsets(compiler_common *common, PCRE2_SPTR cc, sljit_u8 *current_offset)\n{\nPCRE2_SPTR end = bracketend(cc);\nBOOL has_alternatives = cc[GET(cc, 1)] == OP_ALT;\n\n/* Assert captures then. */\nif (*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA)\n  current_offset = NULL;\n/* Conditional block does not. */\nif (*cc == OP_COND || *cc == OP_SCOND)\n  has_alternatives = FALSE;\n\ncc = next_opcode(common, cc);\nif (has_alternatives)\n  current_offset = common->then_offsets + (cc - common->start);\n\nwhile (cc < end)\n  {\n  if ((*cc >= OP_ASSERT && *cc <= OP_ASSERTBACK_NA) || (*cc >= OP_ONCE && *cc <= OP_SCOND))\n    cc = set_then_offsets(common, cc, current_offset);\n  else\n    {\n    if (*cc == OP_ALT && has_alternatives)\n      current_offset = common->then_offsets + (cc + 1 + LINK_SIZE - common->start);\n    if (*cc >= OP_THEN && *cc <= OP_THEN_ARG && current_offset != NULL)\n      *current_offset = 1;\n    cc = next_opcode(common, cc);\n    }\n  }\n\nreturn end;\n}\n\n#undef CASE_ITERATOR_PRIVATE_DATA_1\n#undef CASE_ITERATOR_PRIVATE_DATA_2A\n#undef CASE_ITERATOR_PRIVATE_DATA_2B\n#undef CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n#undef CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n#undef CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n\nstatic SLJIT_INLINE BOOL is_powerof2(unsigned int value)\n{\nreturn (value & (value - 1)) == 0;\n}\n\nstatic SLJIT_INLINE void set_jumps(jump_list *list, struct sljit_label *label)\n{\nwhile (list)\n  {\n  /* sljit_set_label is clever enough to do nothing\n  if either the jump or the label is NULL. */\n  SET_LABEL(list->jump, label);\n  list = list->next;\n  }\n}\n\nstatic SLJIT_INLINE void add_jump(struct sljit_compiler *compiler, jump_list **list, struct sljit_jump *jump)\n{\njump_list *list_item = sljit_alloc_memory(compiler, sizeof(jump_list));\nif (list_item)\n  {\n  list_item->next = *list;\n  list_item->jump = jump;\n  *list = list_item;\n  }\n}\n\nstatic void add_stub(compiler_common *common, struct sljit_jump *start)\n{\nDEFINE_COMPILER;\nstub_list *list_item = sljit_alloc_memory(compiler, sizeof(stub_list));\n\nif (list_item)\n  {\n  list_item->start = start;\n  list_item->quit = LABEL();\n  list_item->next = common->stubs;\n  common->stubs = list_item;\n  }\n}\n\nstatic void flush_stubs(compiler_common *common)\n{\nDEFINE_COMPILER;\nstub_list *list_item = common->stubs;\n\nwhile (list_item)\n  {\n  JUMPHERE(list_item->start);\n  add_jump(compiler, &common->stackalloc, JUMP(SLJIT_FAST_CALL));\n  JUMPTO(SLJIT_JUMP, list_item->quit);\n  list_item = list_item->next;\n  }\ncommon->stubs = NULL;\n}\n\nstatic SLJIT_INLINE void count_match(compiler_common *common)\n{\nDEFINE_COMPILER;\n\nOP2(SLJIT_SUB | SLJIT_SET_Z, COUNT_MATCH, 0, COUNT_MATCH, 0, SLJIT_IMM, 1);\nadd_jump(compiler, &common->calllimit, JUMP(SLJIT_ZERO));\n}\n\nstatic SLJIT_INLINE void allocate_stack(compiler_common *common, int size)\n{\n/* May destroy all locals and registers except TMP2. */\nDEFINE_COMPILER;\n\nSLJIT_ASSERT(size > 0);\nOP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, size * sizeof(sljit_sw));\n#ifdef DESTROY_REGISTERS\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 12345);\nOP1(SLJIT_MOV, TMP3, 0, TMP1, 0);\nOP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP1, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS1, TMP1, 0);\n#endif\nadd_stub(common, CMP(SLJIT_LESS, STACK_TOP, 0, STACK_LIMIT, 0));\n}\n\nstatic SLJIT_INLINE void free_stack(compiler_common *common, int size)\n{\nDEFINE_COMPILER;\n\nSLJIT_ASSERT(size > 0);\nOP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, size * sizeof(sljit_sw));\n}\n\nstatic sljit_uw * allocate_read_only_data(compiler_common *common, sljit_uw size)\n{\nDEFINE_COMPILER;\nsljit_uw *result;\n\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  return NULL;\n\nresult = (sljit_uw *)SLJIT_MALLOC(size + sizeof(sljit_uw), compiler->allocator_data);\nif (SLJIT_UNLIKELY(result == NULL))\n  {\n  sljit_set_compiler_memory_error(compiler);\n  return NULL;\n  }\n\n*(void**)result = common->read_only_data_head;\ncommon->read_only_data_head = (void *)result;\nreturn result + 1;\n}\n\nstatic SLJIT_INLINE void reset_ovector(compiler_common *common, int length)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nsljit_s32 i;\n\n/* At this point we can freely use all temporary registers. */\nSLJIT_ASSERT(length > 1);\n/* TMP1 returns with begin - 1. */\nOP2(SLJIT_SUB, SLJIT_R0, 0, SLJIT_MEM1(SLJIT_S0), SLJIT_OFFSETOF(jit_arguments, begin), SLJIT_IMM, IN_UCHARS(1));\nif (length < 8)\n  {\n  for (i = 1; i < length; i++)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(i), SLJIT_R0, 0);\n  }\nelse\n  {\n  if (sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_STORE | SLJIT_MEM_PRE, SLJIT_R0, SLJIT_MEM1(SLJIT_R1), sizeof(sljit_sw)) == SLJIT_SUCCESS)\n    {\n    GET_LOCAL_BASE(SLJIT_R1, 0, OVECTOR_START);\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_IMM, length - 1);\n    loop = LABEL();\n    sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_STORE | SLJIT_MEM_PRE, SLJIT_R0, SLJIT_MEM1(SLJIT_R1), sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  else\n    {\n    GET_LOCAL_BASE(SLJIT_R1, 0, OVECTOR_START + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_IMM, length - 1);\n    loop = LABEL();\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_R1), 0, SLJIT_R0, 0);\n    OP2(SLJIT_ADD, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  }\n}\n\nstatic SLJIT_INLINE void reset_early_fail(compiler_common *common)\n{\nDEFINE_COMPILER;\nsljit_u32 size = (sljit_u32)(common->early_fail_end_ptr - common->early_fail_start_ptr);\nsljit_u32 uncleared_size;\nsljit_s32 src = SLJIT_IMM;\nsljit_s32 i;\nstruct sljit_label *loop;\n\nSLJIT_ASSERT(common->early_fail_start_ptr < common->early_fail_end_ptr);\n\nif (size == sizeof(sljit_sw))\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->early_fail_start_ptr, SLJIT_IMM, 0);\n  return;\n  }\n\nif (sljit_get_register_index(TMP3) >= 0 && !sljit_has_cpu_feature(SLJIT_HAS_ZERO_REGISTER))\n  {\n  OP1(SLJIT_MOV, TMP3, 0, SLJIT_IMM, 0);\n  src = TMP3;\n  }\n\nif (size <= 6 * sizeof(sljit_sw))\n  {\n  for (i = common->early_fail_start_ptr; i < common->early_fail_end_ptr; i += sizeof(sljit_sw))\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), i, src, 0);\n  return;\n  }\n\nGET_LOCAL_BASE(TMP1, 0, common->early_fail_start_ptr);\n\nuncleared_size = ((size / sizeof(sljit_sw)) % 3) * sizeof(sljit_sw);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, size - uncleared_size);\n\nloop = LABEL();\nOP1(SLJIT_MOV, SLJIT_MEM1(TMP1), 0, src, 0);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 3 * sizeof(sljit_sw));\nOP1(SLJIT_MOV, SLJIT_MEM1(TMP1), -2 * (sljit_sw)sizeof(sljit_sw), src, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(TMP1), -1 * (sljit_sw)sizeof(sljit_sw), src, 0);\nCMPTO(SLJIT_LESS, TMP1, 0, TMP2, 0, loop);\n\nif (uncleared_size >= sizeof(sljit_sw))\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP1), 0, src, 0);\n\nif (uncleared_size >= 2 * sizeof(sljit_sw))\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP1), sizeof(sljit_sw), src, 0);\n}\n\nstatic SLJIT_INLINE void do_reset_match(compiler_common *common, int length)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nint i;\n\nSLJIT_ASSERT(length > 1);\n/* OVECTOR(1) contains the \"string begin - 1\" constant. */\nif (length > 2)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\nif (length < 8)\n  {\n  for (i = 2; i < length; i++)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(i), TMP1, 0);\n  }\nelse\n  {\n  if (sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_STORE | SLJIT_MEM_PRE, TMP1, SLJIT_MEM1(TMP2), sizeof(sljit_sw)) == SLJIT_SUCCESS)\n    {\n    GET_LOCAL_BASE(TMP2, 0, OVECTOR_START + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_IMM, length - 2);\n    loop = LABEL();\n    sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_STORE | SLJIT_MEM_PRE, TMP1, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  else\n    {\n    GET_LOCAL_BASE(TMP2, 0, OVECTOR_START + 2 * sizeof(sljit_sw));\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_IMM, length - 2);\n    loop = LABEL();\n    OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, TMP1, 0);\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, sizeof(sljit_sw));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, loop);\n    }\n  }\n\nif (!HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, stack));\nelse\n  OP1(SLJIT_MOV, STACK_TOP, 0, ARGUMENTS, 0);\n\nif (common->mark_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, SLJIT_IMM, 0);\nif (common->control_head_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\nif (HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(STACK_TOP), SLJIT_OFFSETOF(jit_arguments, stack));\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\nOP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(STACK_TOP), SLJIT_OFFSETOF(struct sljit_stack, end));\n}\n\nstatic sljit_sw SLJIT_FUNC do_search_mark(sljit_sw *current, PCRE2_SPTR skip_arg)\n{\nwhile (current != NULL)\n  {\n  switch (current[1])\n    {\n    case type_then_trap:\n    break;\n\n    case type_mark:\n    if (PRIV(strcmp)(skip_arg, (PCRE2_SPTR)current[2]) == 0)\n      return current[3];\n    break;\n\n    default:\n    SLJIT_UNREACHABLE();\n    break;\n    }\n  SLJIT_ASSERT(current[0] == 0 || current < (sljit_sw*)current[0]);\n  current = (sljit_sw*)current[0];\n  }\nreturn 0;\n}\n\nstatic SLJIT_INLINE void copy_ovector(compiler_common *common, int topbracket)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nBOOL has_pre;\n\n/* At this point we can freely use all registers. */\nOP1(SLJIT_MOV, SLJIT_S2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(1), STR_PTR, 0);\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, SLJIT_R0, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV, SLJIT_S0, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n  OP1(SLJIT_MOV_U32, SLJIT_R1, 0, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, oveccount));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, startchar_ptr), SLJIT_S0, 0);\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, mark_ptr), SLJIT_R2, 0);\n  OP2(SLJIT_ADD, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, match_data),\n    SLJIT_IMM, SLJIT_OFFSETOF(pcre2_match_data, ovector) - sizeof(PCRE2_SIZE));\n  }\nelse\n  {\n  OP1(SLJIT_MOV, SLJIT_S0, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\n  OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, match_data));\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_R0, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n  OP1(SLJIT_MOV_U32, SLJIT_R1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, oveccount));\n  OP1(SLJIT_MOV, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, startchar_ptr), SLJIT_S0, 0);\n  if (common->mark_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, mark_ptr), SLJIT_R0, 0);\n  OP2(SLJIT_ADD, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, SLJIT_OFFSETOF(pcre2_match_data, ovector) - sizeof(PCRE2_SIZE));\n  }\n\nhas_pre = sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, SLJIT_S1, SLJIT_MEM1(SLJIT_S0), sizeof(sljit_sw)) == SLJIT_SUCCESS;\n\nGET_LOCAL_BASE(SLJIT_S0, 0, OVECTOR_START - (has_pre ? sizeof(sljit_sw) : 0));\nOP1(SLJIT_MOV, SLJIT_R0, 0, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? SLJIT_R0 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n\nloop = LABEL();\n\nif (has_pre)\n  sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_PRE, SLJIT_S1, SLJIT_MEM1(SLJIT_S0), sizeof(sljit_sw));\nelse\n  {\n  OP1(SLJIT_MOV, SLJIT_S1, 0, SLJIT_MEM1(SLJIT_S0), 0);\n  OP2(SLJIT_ADD, SLJIT_S0, 0, SLJIT_S0, 0, SLJIT_IMM, sizeof(sljit_sw));\n  }\n\nOP2(SLJIT_ADD, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, sizeof(PCRE2_SIZE));\nOP2(SLJIT_SUB, SLJIT_S1, 0, SLJIT_S1, 0, SLJIT_R0, 0);\n/* Copy the integer value to the output buffer */\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\nOP2(SLJIT_ASHR, SLJIT_S1, 0, SLJIT_S1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\n\nSLJIT_ASSERT(sizeof(PCRE2_SIZE) == 4 || sizeof(PCRE2_SIZE) == 8);\nOP1(((sizeof(PCRE2_SIZE) == 4) ? SLJIT_MOV_U32 : SLJIT_MOV), SLJIT_MEM1(SLJIT_R2), 0, SLJIT_S1, 0);\n\nOP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, 1);\nJUMPTO(SLJIT_NOT_ZERO, loop);\n\n/* Calculate the return value, which is the maximum ovector value. */\nif (topbracket > 1)\n  {\n  if (sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, SLJIT_R2, SLJIT_MEM1(SLJIT_R0), -(2 * (sljit_sw)sizeof(sljit_sw))) == SLJIT_SUCCESS)\n    {\n    GET_LOCAL_BASE(SLJIT_R0, 0, OVECTOR_START + topbracket * 2 * sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_IMM, topbracket + 1);\n\n    /* OVECTOR(0) is never equal to SLJIT_S2. */\n    loop = LABEL();\n    sljit_emit_mem(compiler, SLJIT_MOV | SLJIT_MEM_PRE, SLJIT_R2, SLJIT_MEM1(SLJIT_R0), -(2 * (sljit_sw)sizeof(sljit_sw)));\n    OP2(SLJIT_SUB, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, 1);\n    CMPTO(SLJIT_EQUAL, SLJIT_R2, 0, SLJIT_S2, 0, loop);\n    OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_R1, 0);\n    }\n  else\n    {\n    GET_LOCAL_BASE(SLJIT_R0, 0, OVECTOR_START + (topbracket - 1) * 2 * sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_IMM, topbracket + 1);\n\n    /* OVECTOR(0) is never equal to SLJIT_S2. */\n    loop = LABEL();\n    OP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_R0), 0);\n    OP2(SLJIT_SUB, SLJIT_R0, 0, SLJIT_R0, 0, SLJIT_IMM, 2 * (sljit_sw)sizeof(sljit_sw));\n    OP2(SLJIT_SUB, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, 1);\n    CMPTO(SLJIT_EQUAL, SLJIT_R2, 0, SLJIT_S2, 0, loop);\n    OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_R1, 0);\n    }\n  }\nelse\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, 1);\n}\n\nstatic SLJIT_INLINE void return_with_partial_match(compiler_common *common, struct sljit_label *quit)\n{\nDEFINE_COMPILER;\nsljit_s32 mov_opcode;\nsljit_s32 arguments_reg = !HAS_VIRTUAL_REGISTERS ? ARGUMENTS : SLJIT_R1;\n\nSLJIT_COMPILE_ASSERT(STR_END == SLJIT_S0, str_end_must_be_saved_reg0);\nSLJIT_ASSERT(common->start_used_ptr != 0 && common->start_ptr != 0\n  && (common->mode == PCRE2_JIT_PARTIAL_SOFT ? common->hit_start != 0 : common->hit_start == 0));\n\nif (arguments_reg != ARGUMENTS)\n  OP1(SLJIT_MOV, arguments_reg, 0, ARGUMENTS, 0);\nOP1(SLJIT_MOV, SLJIT_R2, 0, SLJIT_MEM1(SLJIT_SP),\n  common->mode == PCRE2_JIT_PARTIAL_SOFT ? common->hit_start : common->start_ptr);\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_PARTIAL);\n\n/* Store match begin and end. */\nOP1(SLJIT_MOV, SLJIT_S1, 0, SLJIT_MEM1(arguments_reg), SLJIT_OFFSETOF(jit_arguments, begin));\nOP1(SLJIT_MOV, SLJIT_MEM1(arguments_reg), SLJIT_OFFSETOF(jit_arguments, startchar_ptr), SLJIT_R2, 0);\nOP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_MEM1(arguments_reg), SLJIT_OFFSETOF(jit_arguments, match_data));\n\nmov_opcode = (sizeof(PCRE2_SIZE) == 4) ? SLJIT_MOV_U32 : SLJIT_MOV;\n\nOP2(SLJIT_SUB, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_S1, 0);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\nOP2(SLJIT_ASHR, SLJIT_R2, 0, SLJIT_R2, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\nOP1(mov_opcode, SLJIT_MEM1(SLJIT_R1), SLJIT_OFFSETOF(pcre2_match_data, ovector), SLJIT_R2, 0);\n\nOP2(SLJIT_SUB, STR_END, 0, STR_END, 0, SLJIT_S1, 0);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\nOP2(SLJIT_ASHR, STR_END, 0, STR_END, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\nOP1(mov_opcode, SLJIT_MEM1(SLJIT_R1), SLJIT_OFFSETOF(pcre2_match_data, ovector) + sizeof(PCRE2_SIZE), STR_END, 0);\n\nJUMPTO(SLJIT_JUMP, quit);\n}\n\nstatic SLJIT_INLINE void check_start_used_ptr(compiler_common *common)\n{\n/* May destroy TMP1. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  /* The value of -1 must be kept for start_used_ptr! */\n  OP2(SLJIT_ADD, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, 1);\n  /* Jumps if start_used_ptr < STR_PTR, or start_used_ptr == -1. Although overwriting\n  is not necessary if start_used_ptr == STR_PTR, it does not hurt as well. */\n  jump = CMP(SLJIT_LESS_EQUAL, TMP1, 0, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  JUMPHERE(jump);\n  }\nelse if (common->mode == PCRE2_JIT_PARTIAL_HARD)\n  {\n  jump = CMP(SLJIT_LESS_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  JUMPHERE(jump);\n  }\n}\n\nstatic SLJIT_INLINE BOOL char_has_othercase(compiler_common *common, PCRE2_SPTR cc)\n{\n/* Detects if the character has an othercase. */\nunsigned int c;\n\n#ifdef SUPPORT_UNICODE\nif (common->utf || common->ucp)\n  {\n  if (common->utf)\n    {\n    GETCHAR(c, cc);\n    }\n  else\n    c = *cc;\n\n  if (c > 127)\n    return c != UCD_OTHERCASE(c);\n\n  return common->fcc[c] != c;\n  }\nelse\n#endif\n  c = *cc;\nreturn MAX_255(c) ? common->fcc[c] != c : FALSE;\n}\n\nstatic SLJIT_INLINE unsigned int char_othercase(compiler_common *common, unsigned int c)\n{\n/* Returns with the othercase. */\n#ifdef SUPPORT_UNICODE\nif ((common->utf || common->ucp) && c > 127)\n  return UCD_OTHERCASE(c);\n#endif\nreturn TABLE_GET(c, common->fcc, c);\n}\n\nstatic unsigned int char_get_othercase_bit(compiler_common *common, PCRE2_SPTR cc)\n{\n/* Detects if the character and its othercase has only 1 bit difference. */\nunsigned int c, oc, bit;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nint n;\n#endif\n\n#ifdef SUPPORT_UNICODE\nif (common->utf || common->ucp)\n  {\n  if (common->utf)\n    {\n    GETCHAR(c, cc);\n    }\n  else\n    c = *cc;\n\n  if (c <= 127)\n    oc = common->fcc[c];\n  else\n    oc = UCD_OTHERCASE(c);\n  }\nelse\n  {\n  c = *cc;\n  oc = TABLE_GET(c, common->fcc, c);\n  }\n#else\nc = *cc;\noc = TABLE_GET(c, common->fcc, c);\n#endif\n\nSLJIT_ASSERT(c != oc);\n\nbit = c ^ oc;\n/* Optimized for English alphabet. */\nif (c <= 127 && bit == 0x20)\n  return (0 << 8) | 0x20;\n\n/* Since c != oc, they must have at least 1 bit difference. */\nif (!is_powerof2(bit))\n  return 0;\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n\n#ifdef SUPPORT_UNICODE\nif (common->utf && c > 127)\n  {\n  n = GET_EXTRALEN(*cc);\n  while ((bit & 0x3f) == 0)\n    {\n    n--;\n    bit >>= 6;\n    }\n  return (n << 8) | bit;\n  }\n#endif /* SUPPORT_UNICODE */\nreturn (0 << 8) | bit;\n\n#elif PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n\n#ifdef SUPPORT_UNICODE\nif (common->utf && c > 65535)\n  {\n  if (bit >= (1u << 10))\n    bit >>= 10;\n  else\n    return (bit < 256) ? ((2 << 8) | bit) : ((3 << 8) | (bit >> 8));\n  }\n#endif /* SUPPORT_UNICODE */\nreturn (bit < 256) ? ((0u << 8) | bit) : ((1u << 8) | (bit >> 8));\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n}\n\nstatic void check_partial(compiler_common *common, BOOL force)\n{\n/* Checks whether a partial matching is occurred. Does not modify registers. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump = NULL;\n\nSLJIT_ASSERT(!force || common->mode != PCRE2_JIT_COMPLETE);\n\nif (common->mode == PCRE2_JIT_COMPLETE)\n  return;\n\nif (!force && !common->allow_empty_partial)\n  jump = CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\nelse if (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  jump = CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, -1);\n\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\nelse\n  {\n  if (common->partialmatchlabel != NULL)\n    JUMPTO(SLJIT_JUMP, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, JUMP(SLJIT_JUMP));\n  }\n\nif (jump != NULL)\n  JUMPHERE(jump);\n}\n\nstatic void check_str_end(compiler_common *common, jump_list **end_reached)\n{\n/* Does not affect registers. Usually used in a tight spot. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (common->mode == PCRE2_JIT_COMPLETE)\n  {\n  add_jump(compiler, end_reached, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n  return;\n  }\n\njump = CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0);\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  add_jump(compiler, end_reached, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  add_jump(compiler, end_reached, JUMP(SLJIT_JUMP));\n  }\nelse\n  {\n  add_jump(compiler, end_reached, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\n  if (common->partialmatchlabel != NULL)\n    JUMPTO(SLJIT_JUMP, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, JUMP(SLJIT_JUMP));\n  }\nJUMPHERE(jump);\n}\n\nstatic void detect_partial_match(compiler_common *common, jump_list **backtracks)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (common->mode == PCRE2_JIT_COMPLETE)\n  {\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n  return;\n  }\n\n/* Partial matching mode. */\njump = CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0);\nif (!common->allow_empty_partial)\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\nelse if (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, -1));\n\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n  }\nelse\n  {\n  if (common->partialmatchlabel != NULL)\n    JUMPTO(SLJIT_JUMP, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, JUMP(SLJIT_JUMP));\n  }\nJUMPHERE(jump);\n}\n\nstatic void process_partial_match(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\n/* Partial matching mode. */\nif (common->mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  jump = CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  JUMPHERE(jump);\n  }\nelse if (common->mode == PCRE2_JIT_PARTIAL_HARD)\n  {\n  if (common->partialmatchlabel != NULL)\n    CMPTO(SLJIT_LESS, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0, common->partialmatchlabel);\n  else\n    add_jump(compiler, &common->partialmatch, CMP(SLJIT_LESS, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0));\n  }\n}\n\nstatic void detect_partial_match_to(compiler_common *common, struct sljit_label *label)\n{\nDEFINE_COMPILER;\n\nCMPTO(SLJIT_LESS, STR_PTR, 0, STR_END, 0, label);\nprocess_partial_match(common);\n}\n\nstatic void peek_char(compiler_common *common, sljit_u32 max, sljit_s32 dst, sljit_sw dstw, jump_list **backtracks)\n{\n/* Reads the character into TMP1, keeps STR_PTR.\nDoes not check STR_END. TMP2, dst, RETURN_ADDR Destroyed. */\nDEFINE_COMPILER;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\n\nSLJIT_UNUSED_ARG(max);\nSLJIT_UNUSED_ARG(dst);\nSLJIT_UNUSED_ARG(dstw);\nSLJIT_UNUSED_ARG(backtracks);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  if (max < 128) return;\n\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n  OP1(SLJIT_MOV, dst, dstw, STR_PTR, 0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  add_jump(compiler, common->invalid_utf ? &common->utfreadchar_invalid : &common->utfreadchar, JUMP(SLJIT_FAST_CALL));\n  OP1(SLJIT_MOV, STR_PTR, 0, dst, dstw);\n  if (backtracks && common->invalid_utf)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  if (max < 0xd800) return;\n\n  OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n\n  if (common->invalid_utf)\n    {\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    OP1(SLJIT_MOV, dst, dstw, STR_PTR, 0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n    OP1(SLJIT_MOV, STR_PTR, 0, dst, dstw);\n    if (backtracks && common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    }\n  else\n    {\n    /* TMP2 contains the high surrogate. */\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xdc00 - 0xd800);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000 - 0xdc00);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n    }\n\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf)\n  {\n  if (max < 0xd800) return;\n\n  if (backtracks != NULL)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800));\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000);\n    CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    }\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n}\n\nstatic void peek_char_back(compiler_common *common, sljit_u32 max, jump_list **backtracks)\n{\n/* Reads one character back without moving STR_PTR. TMP2 must\ncontain the start of the subject buffer. Affects TMP1, TMP2, and RETURN_ADDR. */\nDEFINE_COMPILER;\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\n\nSLJIT_UNUSED_ARG(max);\nSLJIT_UNUSED_ARG(backtracks);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  if (max < 128) return;\n\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n  if (common->invalid_utf)\n    {\n    add_jump(compiler, &common->utfpeakcharback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    }\n  else\n    add_jump(compiler, &common->utfpeakcharback, JUMP(SLJIT_FAST_CALL));\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  if (max < 0xd800) return;\n\n  if (common->invalid_utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xd800);\n    add_jump(compiler, &common->utfpeakcharback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xdc00);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xdc00);\n    /* TMP2 contains the low surrogate. */\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x10000);\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 10);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n    }\n    JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf)\n  {\n  OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n  add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800));\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n}\n\n#define READ_CHAR_UPDATE_STR_PTR 0x1\n#define READ_CHAR_UTF8_NEWLINE 0x2\n#define READ_CHAR_NEWLINE (READ_CHAR_UPDATE_STR_PTR | READ_CHAR_UTF8_NEWLINE)\n#define READ_CHAR_VALID_UTF 0x4\n\nstatic void read_char(compiler_common *common, sljit_u32 min, sljit_u32 max,\n  jump_list **backtracks, sljit_u32 options)\n{\n/* Reads the precise value of a character into TMP1, if the character is\nbetween min and max (c >= min && c <= max). Otherwise it returns with a value\noutside the range. Does not check STR_END. */\nDEFINE_COMPILER;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nstruct sljit_jump *jump2;\n#endif\n\nSLJIT_UNUSED_ARG(min);\nSLJIT_UNUSED_ARG(max);\nSLJIT_UNUSED_ARG(backtracks);\nSLJIT_UNUSED_ARG(options);\nSLJIT_ASSERT(min <= max);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  if (max < 128 && !(options & READ_CHAR_UPDATE_STR_PTR)) return;\n\n  if (common->invalid_utf && !(options & READ_CHAR_VALID_UTF))\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n\n    if (options & READ_CHAR_UTF8_NEWLINE)\n      add_jump(compiler, &common->utfreadnewline_invalid, JUMP(SLJIT_FAST_CALL));\n    else\n      add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    JUMPHERE(jump);\n    return;\n    }\n\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n  if (min >= 0x10000)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xf0);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP1(SLJIT_MOV_U8, RETURN_ADDR, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(2));\n    if (!(options & READ_CHAR_UPDATE_STR_PTR))\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    JUMPHERE(jump2);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, RETURN_ADDR, 0);\n    }\n  else if (min >= 0x800 && max <= 0xffff)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xe0);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP1(SLJIT_MOV_U8, RETURN_ADDR, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 0xf);\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    if (!(options & READ_CHAR_UPDATE_STR_PTR))\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    JUMPHERE(jump2);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, RETURN_ADDR, 0);\n    }\n  else if (max >= 0x800)\n    {\n    add_jump(compiler, &common->utfreadchar, JUMP(SLJIT_FAST_CALL));\n    }\n  else if (max < 128)\n    {\n    OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n    }\n  else\n    {\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (!(options & READ_CHAR_UPDATE_STR_PTR))\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    else\n      OP1(SLJIT_MOV_U8, RETURN_ADDR, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, RETURN_ADDR, 0);\n    }\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  if (max < 0xd800 && !(options & READ_CHAR_UPDATE_STR_PTR)) return;\n\n  if (common->invalid_utf && !(options & READ_CHAR_VALID_UTF))\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n\n    if (options & READ_CHAR_UTF8_NEWLINE)\n      add_jump(compiler, &common->utfreadnewline_invalid, JUMP(SLJIT_FAST_CALL));\n    else\n      add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    JUMPHERE(jump);\n    return;\n    }\n\n  if (max >= 0x10000)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xdc00 - 0xd800);\n    /* TMP2 contains the high surrogate. */\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000 - 0xdc00);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n    JUMPHERE(jump);\n    return;\n    }\n\n  /* Skip low surrogate if necessary. */\n  OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n\n  if (sljit_has_cpu_feature(SLJIT_HAS_CMOV) && !HAS_VIRTUAL_REGISTERS)\n    {\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, RETURN_ADDR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0x400);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      CMOV(SLJIT_LESS, STR_PTR, RETURN_ADDR, 0);\n    if (max >= 0xd800)\n      CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, 0x10000);\n    }\n  else\n    {\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400);\n    if (options & READ_CHAR_UPDATE_STR_PTR)\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    if (max >= 0xd800)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0x10000);\n    JUMPHERE(jump);\n    }\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf)\n  {\n  if (backtracks != NULL)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800));\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000);\n    CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n    }\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n}\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n\nstatic BOOL is_char7_bitset(const sljit_u8 *bitset, BOOL nclass)\n{\n/* Tells whether the character codes below 128 are enough\nto determine a match. */\nconst sljit_u8 value = nclass ? 0xff : 0;\nconst sljit_u8 *end = bitset + 32;\n\nbitset += 16;\ndo\n  {\n  if (*bitset++ != value)\n    return FALSE;\n  }\nwhile (bitset < end);\nreturn TRUE;\n}\n\nstatic void read_char7_type(compiler_common *common, jump_list **backtracks, BOOL negated)\n{\n/* Reads the precise character type of a character into TMP1, if the character\nis less than 128. Otherwise it returns with zero. Does not check STR_END. The\nfull_read argument tells whether characters above max are accepted or not. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nSLJIT_ASSERT(common->utf);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n/* All values > 127 are zero in ctypes. */\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n\nif (negated)\n  {\n  jump = CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x80);\n\n  if (common->invalid_utf)\n    {\n    add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n    }\n  else\n    {\n    OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n    }\n  JUMPHERE(jump);\n  }\n}\n\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8 */\n\nstatic void read_char8_type(compiler_common *common, jump_list **backtracks, BOOL negated)\n{\n/* Reads the character type into TMP1, updates STR_PTR. Does not check STR_END. */\nDEFINE_COMPILER;\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\nstruct sljit_jump *jump;\n#endif\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nstruct sljit_jump *jump2;\n#endif\n\nSLJIT_UNUSED_ARG(backtracks);\nSLJIT_UNUSED_ARG(negated);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n  /* The result of this read may be unused, but saves an \"else\" part. */\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n  jump = CMP(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x80);\n\n  if (!negated)\n    {\n    if (common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\n    if (common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe0 - 0xc2));\n\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\n    if (common->invalid_utf)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40));\n\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 255);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n    JUMPHERE(jump2);\n    }\n  else if (common->invalid_utf)\n    {\n    add_jump(compiler, &common->utfreadchar_invalid, JUMP(SLJIT_FAST_CALL));\n    OP1(SLJIT_MOV, TMP2, 0, TMP1, 0);\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR));\n\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n    jump2 = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 255);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n    JUMPHERE(jump2);\n    }\n  else\n    add_jump(compiler, &common->utfreadtype8, JUMP(SLJIT_FAST_CALL));\n\n  JUMPHERE(jump);\n  return;\n  }\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8 */\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf && negated)\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x110000));\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 32 */\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\n/* The ctypes array contains only 256 values. */\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\njump = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 255);\n#endif /* PCRE2_CODE_UNIT_WIDTH != 8 */\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\n#if PCRE2_CODE_UNIT_WIDTH != 8\nJUMPHERE(jump);\n#endif /* PCRE2_CODE_UNIT_WIDTH != 8 */\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf && negated)\n  {\n  /* Skip low surrogate if necessary. */\n  if (!common->invalid_utf)\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xd800);\n\n    if (sljit_has_cpu_feature(SLJIT_HAS_CMOV) && !HAS_VIRTUAL_REGISTERS)\n      {\n      OP2(SLJIT_ADD, RETURN_ADDR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0x400);\n      CMOV(SLJIT_LESS, STR_PTR, RETURN_ADDR, 0);\n      }\n    else\n      {\n      jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400);\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      JUMPHERE(jump);\n      }\n    return;\n    }\n\n  OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xd800);\n  jump = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0xe000 - 0xd800);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400));\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n  OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xdc00);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400));\n\n  JUMPHERE(jump);\n  return;\n  }\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 16 */\n}\n\nstatic void move_back(compiler_common *common, jump_list **backtracks, BOOL must_be_valid)\n{\n/* Goes one character back. Affects STR_PTR and TMP1. If must_be_valid is TRUE,\nTMP2 is not used. Otherwise TMP2 must contain the start of the subject buffer,\nand it is destroyed. Does not modify STR_PTR for invalid character sequences. */\nDEFINE_COMPILER;\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_jump *jump;\n#endif\n\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nstruct sljit_label *label;\n\nif (common->utf)\n  {\n  if (!must_be_valid && common->invalid_utf)\n    {\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x80);\n    add_jump(compiler, &common->utfmoveback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0));\n    JUMPHERE(jump);\n    return;\n    }\n\n  label = LABEL();\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\n  CMPTO(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0x80, label);\n  return;\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utf)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  if (!must_be_valid && common->invalid_utf)\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n    jump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000 - 0xd800);\n    add_jump(compiler, &common->utfmoveback_invalid, JUMP(SLJIT_FAST_CALL));\n    if (backtracks != NULL)\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0));\n    JUMPHERE(jump);\n    return;\n    }\n\n  /* Skip low surrogate if necessary. */\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xfc00);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0xdc00);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  return;\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 32\nif (common->invalid_utf && !must_be_valid)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -IN_UCHARS(1));\n  if (backtracks != NULL)\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x110000));\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    return;\n    }\n\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x110000);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_LESS);\n  OP2(SLJIT_SHL,  TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  return;\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n#endif /* SUPPORT_UNICODE */\n\nSLJIT_UNUSED_ARG(backtracks);\nSLJIT_UNUSED_ARG(must_be_valid);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n}\n\nstatic void check_newlinechar(compiler_common *common, int nltype, jump_list **backtracks, BOOL jumpifmatch)\n{\n/* Character comes in TMP1. Checks if it is a newline. TMP2 may be destroyed. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nif (nltype == NLTYPE_ANY)\n  {\n  add_jump(compiler, &common->anynewline, JUMP(SLJIT_FAST_CALL));\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(jumpifmatch ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  }\nelse if (nltype == NLTYPE_ANYCRLF)\n  {\n  if (jumpifmatch)\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR));\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL));\n    }\n  else\n    {\n    jump = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL));\n    JUMPHERE(jump);\n    }\n  }\nelse\n  {\n  SLJIT_ASSERT(nltype == NLTYPE_FIXED && common->newline < 256);\n  add_jump(compiler, backtracks, CMP(jumpifmatch ? SLJIT_EQUAL : SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, common->newline));\n  }\n}\n\n#ifdef SUPPORT_UNICODE\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\nstatic void do_utfreadchar(compiler_common *common)\n{\n/* Fast decoding a UTF-8 character. TMP1 contains the first byte\nof the character (>= 0xc0). Return char value in TMP1. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Searching for the first zero. */\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x800);\njump = JUMP(SLJIT_NOT_ZERO);\n/* Two byte sequence. */\nOP2(SLJIT_XOR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3000);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x10000);\njump = JUMP(SLJIT_NOT_ZERO);\n/* Three byte sequence. */\nOP2(SLJIT_XOR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0000);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Four byte sequence. */\nJUMPHERE(jump);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(2));\nOP2(SLJIT_XOR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xf0000);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadtype8(compiler_common *common)\n{\n/* Fast decoding a UTF-8 character type. TMP2 contains the first byte\nof the character (>= 0xc0). Return value in TMP1. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_jump *compare;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, 0x20);\njump = JUMP(SLJIT_NOT_ZERO);\n/* Two byte sequence. */\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x1f);\n/* The upper 5 bits are known at this point. */\ncompare = CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, 0x3);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x3f);\nOP2(SLJIT_OR, TMP2, 0, TMP2, 0, TMP1, 0);\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), common->ctypes);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(compare);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* We only have types for characters less than 256. */\nJUMPHERE(jump);\nOP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(utf8_table4) - 0xc0);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadchar_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-8 character. TMP1 contains the first byte\nof the character (>= 0xc0). Return char value in TMP1. STR_PTR is\nundefined for invalid characters. */\nDEFINE_COMPILER;\nsljit_s32 i;\nsljit_s32 has_cmov = sljit_has_cpu_feature(SLJIT_HAS_CMOV);\nstruct sljit_jump *jump;\nstruct sljit_jump *buffer_end_close;\nstruct sljit_label *three_byte_entry;\nstruct sljit_label *exit_invalid_label;\nstruct sljit_jump *exit_invalid[11];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc2);\n\n/* Usually more than 3 characters remained in the subject buffer. */\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\n\n/* Not a valid start of a multi-byte sequence, no more bytes read. */\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xf5 - 0xc2);\n\nbuffer_end_close = CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n/* If TMP2 is in 0x80-0xbf range, TMP1 is also increased by (0x2 << 6). */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x800);\njump = JUMP(SLJIT_NOT_ZERO);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\n\n/* Three-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, 0x20000);\n  exit_invalid[2] = NULL;\n  }\nelse\n  exit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x10000);\njump = JUMP(SLJIT_NOT_ZERO);\n\nthree_byte_entry = LABEL();\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x2d800);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR - 0xd800);\n  exit_invalid[3] = NULL;\n  }\nelse\n  exit_invalid[3] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n  exit_invalid[4] = NULL;\n  }\nelse\n  exit_invalid[4] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\n\n/* Four-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, 0);\n  exit_invalid[5] = NULL;\n  }\nelse\n  exit_invalid[5] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc10000);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x100000);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR - 0x10000);\n  exit_invalid[6] = NULL;\n  }\nelse\n  exit_invalid[6] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x100000);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(buffer_end_close);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nexit_invalid[7] = CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\n/* If TMP2 is in 0x80-0xbf range, TMP1 is also increased by (0x2 << 6). */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nexit_invalid[8] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x800);\njump = JUMP(SLJIT_NOT_ZERO);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Three-byte sequence. */\nJUMPHERE(jump);\nexit_invalid[9] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n  exit_invalid[10] = NULL;\n  }\nelse\n  exit_invalid[10] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\n\n/* One will be substracted from STR_PTR later. */\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n\n/* Four byte sequences are not possible. */\nCMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x30000, three_byte_entry);\n\nexit_invalid_label = LABEL();\nfor (i = 0; i < 11; i++)\n  sljit_set_label(exit_invalid[i], exit_invalid_label);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadnewline_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-8 character, specialized for newlines.\nTMP1 contains the first byte of the character (>= 0xc0). Return\nchar value in TMP1. */\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nstruct sljit_label *skip_start;\nstruct sljit_label *three_byte_exit;\nstruct sljit_jump *jump[5];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nif (common->nltype != NLTYPE_ANY)\n  {\n  SLJIT_ASSERT(common->nltype != NLTYPE_FIXED || common->newline < 128);\n\n  /* All newlines are ascii, just skip intermediate octets. */\n  jump[0] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  loop = LABEL();\n  if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, TMP2, SLJIT_MEM1(STR_PTR), IN_UCHARS(1)) == SLJIT_SUCCESS)\n    sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, TMP2, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  else\n    {\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    }\n\n  OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc0);\n  CMPTO(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80, loop);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  JUMPHERE(jump[0]);\n\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\n  OP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n  return;\n  }\n\njump[0] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\njump[1] = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0xc2);\njump[2] = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0xe2);\n\nskip_start = LABEL();\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc0);\njump[3] = CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80);\n\n/* Skip intermediate octets. */\nloop = LABEL();\njump[4] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc0);\nCMPTO(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80, loop);\n\nJUMPHERE(jump[3]);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nthree_byte_exit = LABEL();\nJUMPHERE(jump[0]);\nJUMPHERE(jump[4]);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Two byte long newline: 0x85. */\nJUMPHERE(jump[1]);\nCMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0x85, skip_start);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0x85);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Three byte long newlines: 0x2028 and 0x2029. */\nJUMPHERE(jump[2]);\nCMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80, skip_start);\nCMPTO(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0, three_byte_exit);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP2, 0, SLJIT_IMM, 0x80);\nCMPTO(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x40, skip_start);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0x2000);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfmoveback_invalid(compiler_common *common)\n{\n/* Goes one character back. */\nDEFINE_COMPILER;\nsljit_s32 i;\nstruct sljit_jump *jump;\nstruct sljit_jump *buffer_start_close;\nstruct sljit_label *exit_ok_label;\nstruct sljit_label *exit_invalid_label;\nstruct sljit_jump *exit_invalid[7];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xc0);\n\n/* Two-byte sequence. */\nbuffer_start_close = CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(2));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\njump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x20);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Three-byte sequence. */\nJUMPHERE(jump);\nexit_invalid[1] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, -0x40);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0);\njump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x10);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Four-byte sequence. */\nJUMPHERE(jump);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0 - 0x80);\nexit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x40);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xf0);\nexit_invalid[3] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x05);\n\nexit_ok_label = LABEL();\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\n/* Two-byte sequence. */\nJUMPHERE(buffer_start_close);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n\nexit_invalid[4] = CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\nCMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x20, exit_ok_label);\n\n/* Three-byte sequence. */\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nexit_invalid[5] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, -0x40);\nexit_invalid[6] = CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0);\nCMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x10, exit_ok_label);\n\n/* Four-byte sequences are not possible. */\n\nexit_invalid_label = LABEL();\nsljit_set_label(exit_invalid[5], exit_invalid_label);\nsljit_set_label(exit_invalid[6], exit_invalid_label);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(3));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[4]);\n/* -2 + 4 = 2 */\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n\nexit_invalid_label = LABEL();\nfor (i = 0; i < 4; i++)\n  sljit_set_label(exit_invalid[i], exit_invalid_label);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(4));\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfpeakcharback(compiler_common *common)\n{\n/* Peak a character back. Does not modify STR_PTR. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump[2];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xc0);\njump[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x20);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0);\njump[1] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x10);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-4));\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xe0 - 0x80);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xf0);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nJUMPHERE(jump[1]);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nJUMPHERE(jump[0]);\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 6);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x80);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfpeakcharback_invalid(compiler_common *common)\n{\n/* Peak a character back. Does not modify STR_PTR. */\nDEFINE_COMPILER;\nsljit_s32 i;\nsljit_s32 has_cmov = sljit_has_cpu_feature(SLJIT_HAS_CMOV);\nstruct sljit_jump *jump[2];\nstruct sljit_label *two_byte_entry;\nstruct sljit_label *three_byte_entry;\nstruct sljit_label *exit_invalid_label;\nstruct sljit_jump *exit_invalid[8];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(3));\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xc0);\njump[0] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\njump[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x1e);\n\ntwo_byte_entry = LABEL();\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\n/* If TMP1 is in 0x80-0xbf range, TMP1 is also increased by (0x2 << 6). */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump[1]);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2 - 0x80);\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Three-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xe0);\njump[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x10);\n\nthree_byte_entry = LABEL();\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 12);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, -0xd800);\n  exit_invalid[2] = NULL;\n  }\nelse\n  exit_invalid[2] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n  CMOV(SLJIT_LESS, TMP1, SLJIT_IMM, INVALID_UTF_CHAR);\n  exit_invalid[3] = NULL;\n  }\nelse\n  exit_invalid[3] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x800);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump[1]);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xe0 - 0x80);\nexit_invalid[4] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 12);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Four-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-4));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xf0);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 18);\n/* ADD is used instead of OR because of the SUB 0x10000 above. */\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n\nif (has_cmov)\n  {\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x100000);\n  CMOV(SLJIT_GREATER_EQUAL, TMP1, SLJIT_IMM, INVALID_UTF_CHAR - 0x10000);\n  exit_invalid[5] = NULL;\n  }\nelse\n  exit_invalid[5] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x100000);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump[0]);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\njump[0] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\nCMPTO(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x1e, two_byte_entry);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2 - 0x80);\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\nexit_invalid[6] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x40);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 6);\nOP2(SLJIT_OR, TMP1, 0, TMP1, 0, TMP2, 0);\n\n/* Three-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-3));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xe0);\nCMPTO(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x10, three_byte_entry);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump[0]);\nexit_invalid[7] = CMP(SLJIT_GREATER, TMP2, 0, STR_PTR, 0);\n\n/* Two-byte sequence. */\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc2);\nCMPTO(SLJIT_LESS, TMP2, 0, SLJIT_IMM, 0x1e, two_byte_entry);\n\nexit_invalid_label = LABEL();\nfor (i = 0; i < 8; i++)\n  sljit_set_label(exit_invalid[i], exit_invalid_label);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n\n#if PCRE2_CODE_UNIT_WIDTH == 16\n\nstatic void do_utfreadchar_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-16 character. TMP1 contains the first half\nof the character (>= 0xd800). Return char value in TMP1. STR_PTR is\nundefined for invalid characters. */\nDEFINE_COMPILER;\nstruct sljit_jump *exit_invalid[3];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n/* TMP2 contains the high surrogate. */\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xdc00);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xdc00);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, 0x10000);\nexit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x400);\n\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[0]);\nJUMPHERE(exit_invalid[1]);\nJUMPHERE(exit_invalid[2]);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfreadnewline_invalid(compiler_common *common)\n{\n/* Slow decoding a UTF-16 character, specialized for newlines.\nTMP1 contains the first half of the character (>= 0xd800). Return\nchar value in TMP1. */\n\nDEFINE_COMPILER;\nstruct sljit_jump *exit_invalid[2];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n/* TMP2 contains the high surrogate. */\nexit_invalid[0] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xdc00);\n\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xdc00);\nOP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, SLJIT_IMM, 0x400);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0x10000);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCHAR_SHIFT);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[0]);\nJUMPHERE(exit_invalid[1]);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfmoveback_invalid(compiler_common *common)\n{\n/* Goes one character back. */\nDEFINE_COMPILER;\nstruct sljit_jump *exit_invalid[3];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nexit_invalid[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x400);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\nexit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0x400);\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[0]);\nJUMPHERE(exit_invalid[1]);\nJUMPHERE(exit_invalid[2]);\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_utfpeakcharback_invalid(compiler_common *common)\n{\n/* Peak a character back. Does not modify STR_PTR. */\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_jump *exit_invalid[3];\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\njump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\nexit_invalid[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xdc00);\nexit_invalid[1] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, STR_PTR, 0);\n\nOP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x10000 - 0xdc00);\nOP2(SLJIT_SUB, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xd800);\nexit_invalid[2] = CMP(SLJIT_GREATER_EQUAL, TMP2, 0, SLJIT_IMM, 0x400);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 10);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n\nJUMPHERE(jump);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(exit_invalid[0]);\nJUMPHERE(exit_invalid[1]);\nJUMPHERE(exit_invalid[2]);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\n#endif /* PCRE2_CODE_UNIT_WIDTH == 16 */\n\n/* UCD_BLOCK_SIZE must be 128 (see the assert below). */\n#define UCD_BLOCK_MASK 127\n#define UCD_BLOCK_SHIFT 7\n\nstatic void do_getucd(compiler_common *common)\n{\n/* Search the UCD record for the character comes in TMP1.\nReturns chartype in TMP1 and UCD offset in TMP2. */\nDEFINE_COMPILER;\n#if PCRE2_CODE_UNIT_WIDTH == 32\nstruct sljit_jump *jump;\n#endif\n\n#if defined SLJIT_DEBUG && SLJIT_DEBUG\n/* dummy_ucd_record */\nconst ucd_record *record = GET_UCD(UNASSIGNED_UTF_CHAR);\nSLJIT_ASSERT(record->script == ucp_Unknown && record->chartype == ucp_Cn && record->gbprop == ucp_gbOther);\nSLJIT_ASSERT(record->caseset == 0 && record->other_case == 0);\n#endif\n\nSLJIT_ASSERT(UCD_BLOCK_SIZE == 128 && sizeof(ucd_record) == 12);\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\nif (!common->utf)\n  {\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n  JUMPHERE(jump);\n  }\n#endif\n\nOP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\nOP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_getucdtype(compiler_common *common)\n{\n/* Search the UCD record for the character comes in TMP1.\nReturns chartype in TMP1 and UCD offset in TMP2. */\nDEFINE_COMPILER;\n#if PCRE2_CODE_UNIT_WIDTH == 32\nstruct sljit_jump *jump;\n#endif\n\n#if defined SLJIT_DEBUG && SLJIT_DEBUG\n/* dummy_ucd_record */\nconst ucd_record *record = GET_UCD(UNASSIGNED_UTF_CHAR);\nSLJIT_ASSERT(record->script == ucp_Unknown && record->chartype == ucp_Cn && record->gbprop == ucp_gbOther);\nSLJIT_ASSERT(record->caseset == 0 && record->other_case == 0);\n#endif\n\nSLJIT_ASSERT(UCD_BLOCK_SIZE == 128 && sizeof(ucd_record) == 12);\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\nif (!common->utf)\n  {\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n  JUMPHERE(jump);\n  }\n#endif\n\nOP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\nOP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\nOP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n\n/* TMP2 is multiplied by 12. Same as (TMP2 << 2) + ((TMP2 << 2) << 1). */\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));\nOP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM2(TMP1, TMP2), 1);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\n#endif /* SUPPORT_UNICODE */\n\nstatic SLJIT_INLINE struct sljit_label *mainloop_entry(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_label *mainloop;\nstruct sljit_label *newlinelabel = NULL;\nstruct sljit_jump *start;\nstruct sljit_jump *end = NULL;\nstruct sljit_jump *end2 = NULL;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstruct sljit_label *loop;\nstruct sljit_jump *jump;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\njump_list *newline = NULL;\nsljit_u32 overall_options = common->re->overall_options;\nBOOL hascrorlf = (common->re->flags & PCRE2_HASCRORLF) != 0;\nBOOL newlinecheck = FALSE;\nBOOL readuchar = FALSE;\n\nif (!(hascrorlf || (overall_options & PCRE2_FIRSTLINE) != 0)\n    && (common->nltype == NLTYPE_ANY || common->nltype == NLTYPE_ANYCRLF || common->newline > 255))\n  newlinecheck = TRUE;\n\nSLJIT_ASSERT(common->abort_label == NULL);\n\nif ((overall_options & PCRE2_FIRSTLINE) != 0)\n  {\n  /* Search for the end of the first line. */\n  SLJIT_ASSERT(common->match_end_ptr != 0);\n  OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    mainloop = LABEL();\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    end = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff, mainloop);\n    CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff, mainloop);\n    JUMPHERE(end);\n    OP2(SLJIT_SUB, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    }\n  else\n    {\n    end = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n    mainloop = LABEL();\n    /* Continual stores does not cause data dependency. */\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, STR_PTR, 0);\n    read_char(common, common->nlmin, common->nlmax, NULL, READ_CHAR_NEWLINE);\n    check_newlinechar(common, common->nltype, &newline, TRUE);\n    CMPTO(SLJIT_LESS, STR_PTR, 0, STR_END, 0, mainloop);\n    JUMPHERE(end);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, STR_PTR, 0);\n    set_jumps(newline, LABEL());\n    }\n\n  OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n  }\nelse if ((overall_options & PCRE2_USE_OFFSET_LIMIT) != 0)\n  {\n  /* Check whether offset limit is set and valid. */\n  SLJIT_ASSERT(common->match_end_ptr != 0);\n\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, offset_limit));\n    }\n  else\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, offset_limit));\n\n  OP1(SLJIT_MOV, TMP2, 0, STR_END, 0);\n  end = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw) PCRE2_UNSET);\n  if (HAS_VIRTUAL_REGISTERS)\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n  else\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif /* PCRE2_CODE_UNIT_WIDTH == [16|32] */\n  if (HAS_VIRTUAL_REGISTERS)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, begin));\n\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n  end2 = CMP(SLJIT_LESS_EQUAL, TMP2, 0, STR_END, 0);\n  OP1(SLJIT_MOV, TMP2, 0, STR_END, 0);\n  JUMPHERE(end2);\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n  add_jump(compiler, &common->abort, CMP(SLJIT_LESS, TMP2, 0, STR_PTR, 0));\n  JUMPHERE(end);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr, TMP2, 0);\n  }\n\nstart = JUMP(SLJIT_JUMP);\n\nif (newlinecheck)\n  {\n  newlinelabel = LABEL();\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  end = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, common->newline & 0xff);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif /* PCRE2_CODE_UNIT_WIDTH == [16|32] */\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  end2 = JUMP(SLJIT_JUMP);\n  }\n\nmainloop = LABEL();\n\n/* Increasing the STR_PTR here requires one less jump in the most common case. */\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nif (common->utf && !common->invalid_utf) readuchar = TRUE;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\nif (newlinecheck) readuchar = TRUE;\n\nif (readuchar)\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n\nif (newlinecheck)\n  CMPTO(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff, newlinelabel);\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->invalid_utf)\n  {\n  /* Skip continuation code units. */\n  loop = LABEL();\n  jump = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x80);\n  CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x40, loop);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPHERE(jump);\n  }\nelse if (common->utf)\n  {\n  jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  JUMPHERE(jump);\n  }\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nif (common->invalid_utf)\n  {\n  /* Skip continuation code units. */\n  loop = LABEL();\n  jump = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xdc00);\n  CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0x400, loop);\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPHERE(jump);\n  }\nelse if (common->utf)\n  {\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xd800);\n\n  if (sljit_has_cpu_feature(SLJIT_HAS_CMOV))\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x400);\n    CMOV(SLJIT_LESS, STR_PTR, TMP2, 0);\n    }\n  else\n    {\n    OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP1, 0, SLJIT_IMM, 0x400);\n    OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_LESS);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n    }\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16] */\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32 */\nJUMPHERE(start);\n\nif (newlinecheck)\n  {\n  JUMPHERE(end);\n  JUMPHERE(end2);\n  }\n\nreturn mainloop;\n}\n\n\nstatic SLJIT_INLINE void add_prefix_char(PCRE2_UCHAR chr, fast_forward_char_data *chars, BOOL last)\n{\nsljit_u32 i, count = chars->count;\n\nif (count == 255)\n  return;\n\nif (count == 0)\n  {\n  chars->count = 1;\n  chars->chars[0] = chr;\n\n  if (last)\n    chars->last_count = 1;\n  return;\n  }\n\nfor (i = 0; i < count; i++)\n  if (chars->chars[i] == chr)\n    return;\n\nif (count >= MAX_DIFF_CHARS)\n  {\n  chars->count = 255;\n  return;\n  }\n\nchars->chars[count] = chr;\nchars->count = count + 1;\n\nif (last)\n  chars->last_count++;\n}\n\nstatic int scan_prefix(compiler_common *common, PCRE2_SPTR cc, fast_forward_char_data *chars, int max_chars, sljit_u32 *rec_count)\n{\n/* Recursive function, which scans prefix literals. */\nBOOL last, any, class, caseless;\nint len, repeat, len_save, consumed = 0;\nsljit_u32 chr; /* Any unicode character. */\nsljit_u8 *bytes, *bytes_end, byte;\nPCRE2_SPTR alternative, cc_save, oc;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\nPCRE2_UCHAR othercase[4];\n#elif defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 16\nPCRE2_UCHAR othercase[2];\n#else\nPCRE2_UCHAR othercase[1];\n#endif\n\nrepeat = 1;\nwhile (TRUE)\n  {\n  if (*rec_count == 0)\n    return 0;\n  (*rec_count)--;\n\n  last = TRUE;\n  any = FALSE;\n  class = FALSE;\n  caseless = FALSE;\n\n  switch (*cc)\n    {\n    case OP_CHARI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_CHAR:\n    last = FALSE;\n    cc++;\n    break;\n\n    case OP_SOD:\n    case OP_SOM:\n    case OP_SET_SOM:\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_EODN:\n    case OP_EOD:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_DOLL:\n    case OP_DOLLM:\n    /* Zero width assertions. */\n    cc++;\n    continue;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    cc = bracketend(cc);\n    continue;\n\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_POSPLUSI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_POSPLUS:\n    cc++;\n    break;\n\n    case OP_EXACTI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_EXACT:\n    repeat = GET2(cc, 1);\n    last = FALSE;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_POSQUERYI:\n    caseless = TRUE;\n    /* Fall through */\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_POSQUERY:\n    len = 1;\n    cc++;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(*cc)) len += GET_EXTRALEN(*cc);\n#endif\n    max_chars = scan_prefix(common, cc + len, chars, max_chars, rec_count);\n    if (max_chars == 0)\n      return consumed;\n    last = FALSE;\n    break;\n\n    case OP_KET:\n    cc += 1 + LINK_SIZE;\n    continue;\n\n    case OP_ALT:\n    cc += GET(cc, 1);\n    continue;\n\n    case OP_ONCE:\n    case OP_BRA:\n    case OP_BRAPOS:\n    case OP_CBRA:\n    case OP_CBRAPOS:\n    alternative = cc + GET(cc, 1);\n    while (*alternative == OP_ALT)\n      {\n      max_chars = scan_prefix(common, alternative + 1 + LINK_SIZE, chars, max_chars, rec_count);\n      if (max_chars == 0)\n        return consumed;\n      alternative += GET(alternative, 1);\n      }\n\n    if (*cc == OP_CBRA || *cc == OP_CBRAPOS)\n      cc += IMM2_SIZE;\n    cc += 1 + LINK_SIZE;\n    continue;\n\n    case OP_CLASS:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)(cc + 1), FALSE))\n      return consumed;\n#endif\n    class = TRUE;\n    break;\n\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    class = TRUE;\n    break;\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    cc += GET(cc, 1);\n    break;\n#endif\n\n    case OP_DIGIT:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)common->ctypes - cbit_length + cbit_digit, FALSE))\n      return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n    case OP_WHITESPACE:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)common->ctypes - cbit_length + cbit_space, FALSE))\n      return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n    case OP_WORDCHAR:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf && !is_char7_bitset((const sljit_u8 *)common->ctypes - cbit_length + cbit_word, FALSE))\n      return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n    case OP_NOT:\n    case OP_NOTI:\n    cc++;\n    /* Fall through. */\n    case OP_NOT_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_ANY:\n    case OP_ALLANY:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    cc++;\n    break;\n\n#ifdef SUPPORT_UNICODE\n    case OP_NOTPROP:\n    case OP_PROP:\n#if PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    cc += 1 + 2;\n    break;\n#endif\n\n    case OP_TYPEEXACT:\n    repeat = GET2(cc, 1);\n    cc += 1 + IMM2_SIZE;\n    continue;\n\n    case OP_NOTEXACT:\n    case OP_NOTEXACTI:\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf) return consumed;\n#endif\n    any = TRUE;\n    repeat = GET2(cc, 1);\n    cc += 1 + IMM2_SIZE + 1;\n    break;\n\n    default:\n    return consumed;\n    }\n\n  if (any)\n    {\n    do\n      {\n      chars->count = 255;\n\n      consumed++;\n      if (--max_chars == 0)\n        return consumed;\n      chars++;\n      }\n    while (--repeat > 0);\n\n    repeat = 1;\n    continue;\n    }\n\n  if (class)\n    {\n    bytes = (sljit_u8*) (cc + 1);\n    cc += 1 + 32 / sizeof(PCRE2_UCHAR);\n\n    switch (*cc)\n      {\n      case OP_CRSTAR:\n      case OP_CRMINSTAR:\n      case OP_CRPOSSTAR:\n      case OP_CRQUERY:\n      case OP_CRMINQUERY:\n      case OP_CRPOSQUERY:\n      max_chars = scan_prefix(common, cc + 1, chars, max_chars, rec_count);\n      if (max_chars == 0)\n        return consumed;\n      break;\n\n      default:\n      case OP_CRPLUS:\n      case OP_CRMINPLUS:\n      case OP_CRPOSPLUS:\n      break;\n\n      case OP_CRRANGE:\n      case OP_CRMINRANGE:\n      case OP_CRPOSRANGE:\n      repeat = GET2(cc, 1);\n      if (repeat <= 0)\n        return consumed;\n      break;\n      }\n\n    do\n      {\n      if (bytes[31] & 0x80)\n        chars->count = 255;\n      else if (chars->count != 255)\n        {\n        bytes_end = bytes + 32;\n        chr = 0;\n        do\n          {\n          byte = *bytes++;\n          SLJIT_ASSERT((chr & 0x7) == 0);\n          if (byte == 0)\n            chr += 8;\n          else\n            {\n            do\n              {\n              if ((byte & 0x1) != 0)\n                add_prefix_char(chr, chars, TRUE);\n              byte >>= 1;\n              chr++;\n              }\n            while (byte != 0);\n            chr = (chr + 7) & ~7;\n            }\n          }\n        while (chars->count != 255 && bytes < bytes_end);\n        bytes = bytes_end - 32;\n        }\n\n      consumed++;\n      if (--max_chars == 0)\n        return consumed;\n      chars++;\n      }\n    while (--repeat > 0);\n\n    switch (*cc)\n      {\n      case OP_CRSTAR:\n      case OP_CRMINSTAR:\n      case OP_CRPOSSTAR:\n      return consumed;\n\n      case OP_CRQUERY:\n      case OP_CRMINQUERY:\n      case OP_CRPOSQUERY:\n      cc++;\n      break;\n\n      case OP_CRRANGE:\n      case OP_CRMINRANGE:\n      case OP_CRPOSRANGE:\n      if (GET2(cc, 1) != GET2(cc, 1 + IMM2_SIZE))\n        return consumed;\n      cc += 1 + 2 * IMM2_SIZE;\n      break;\n      }\n\n    repeat = 1;\n    continue;\n    }\n\n  len = 1;\n#ifdef SUPPORT_UNICODE\n  if (common->utf && HAS_EXTRALEN(*cc)) len += GET_EXTRALEN(*cc);\n#endif\n\n  if (caseless && char_has_othercase(common, cc))\n    {\n#ifdef SUPPORT_UNICODE\n    if (common->utf)\n      {\n      GETCHAR(chr, cc);\n      if ((int)PRIV(ord2utf)(char_othercase(common, chr), othercase) != len)\n        return consumed;\n      }\n    else\n#endif\n      {\n      chr = *cc;\n#ifdef SUPPORT_UNICODE\n      if (common->ucp && chr > 127)\n        othercase[0] = UCD_OTHERCASE(chr);\n      else\n#endif\n        othercase[0] = TABLE_GET(chr, common->fcc, chr);\n      }\n    }\n  else\n    {\n    caseless = FALSE;\n    othercase[0] = 0; /* Stops compiler warning - PH */\n    }\n\n  len_save = len;\n  cc_save = cc;\n  while (TRUE)\n    {\n    oc = othercase;\n    do\n      {\n      len--;\n      consumed++;\n\n      chr = *cc;\n      add_prefix_char(*cc, chars, len == 0);\n\n      if (caseless)\n        add_prefix_char(*oc, chars, len == 0);\n\n      if (--max_chars == 0)\n        return consumed;\n      chars++;\n      cc++;\n      oc++;\n      }\n    while (len > 0);\n\n    if (--repeat == 0)\n      break;\n\n    len = len_save;\n    cc = cc_save;\n    }\n\n  repeat = 1;\n  if (last)\n    return consumed;\n  }\n}\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nstatic void jumpto_if_not_utf_char_start(struct sljit_compiler *compiler, sljit_s32 reg, struct sljit_label *label)\n{\n#if PCRE2_CODE_UNIT_WIDTH == 8\nOP2(SLJIT_AND, reg, 0, reg, 0, SLJIT_IMM, 0xc0);\nCMPTO(SLJIT_EQUAL, reg, 0, SLJIT_IMM, 0x80, label);\n#elif PCRE2_CODE_UNIT_WIDTH == 16\nOP2(SLJIT_AND, reg, 0, reg, 0, SLJIT_IMM, 0xfc00);\nCMPTO(SLJIT_EQUAL, reg, 0, SLJIT_IMM, 0xdc00, label);\n#else\n#error \"Unknown code width\"\n#endif\n}\n#endif\n\n#include \"pcre2_jit_simd_inc.h\"\n\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD\n\nstatic BOOL check_fast_forward_char_pair_simd(compiler_common *common, fast_forward_char_data *chars, int max)\n{\n  sljit_s32 i, j, max_i = 0, max_j = 0;\n  sljit_u32 max_pri = 0;\n  PCRE2_UCHAR a1, a2, a_pri, b1, b2, b_pri;\n\n  for (i = max - 1; i >= 1; i--)\n    {\n    if (chars[i].last_count > 2)\n      {\n      a1 = chars[i].chars[0];\n      a2 = chars[i].chars[1];\n      a_pri = chars[i].last_count;\n\n      j = i - max_fast_forward_char_pair_offset();\n      if (j < 0)\n        j = 0;\n\n      while (j < i)\n        {\n        b_pri = chars[j].last_count;\n        if (b_pri > 2 && a_pri + b_pri >= max_pri)\n          {\n          b1 = chars[j].chars[0];\n          b2 = chars[j].chars[1];\n\n          if (a1 != b1 && a1 != b2 && a2 != b1 && a2 != b2)\n            {\n            max_pri = a_pri + b_pri;\n            max_i = i;\n            max_j = j;\n            }\n          }\n        j++;\n        }\n      }\n    }\n\nif (max_pri == 0)\n  return FALSE;\n\nfast_forward_char_pair_simd(common, max_i, chars[max_i].chars[0], chars[max_i].chars[1], max_j, chars[max_j].chars[0], chars[max_j].chars[1]);\nreturn TRUE;\n}\n\n#endif /* JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD */\n\nstatic void fast_forward_first_char2(compiler_common *common, PCRE2_UCHAR char1, PCRE2_UCHAR char2, sljit_s32 offset)\n{\nDEFINE_COMPILER;\nstruct sljit_label *start;\nstruct sljit_jump *match;\nstruct sljit_jump *partial_quit;\nPCRE2_UCHAR mask;\nBOOL has_match_end = (common->match_end_ptr != 0);\n\nSLJIT_ASSERT(common->mode == PCRE2_JIT_COMPLETE || offset == 0);\n\nif (has_match_end)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n\nif (offset > 0)\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(offset));\n\nif (has_match_end)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(offset + 1));\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_END, 0, TMP1, 0);\n  CMOV(SLJIT_GREATER, STR_END, TMP1, 0);\n  }\n\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_SIMD\n\nif (JIT_HAS_FAST_FORWARD_CHAR_SIMD)\n  {\n  fast_forward_char_simd(common, char1, char2, offset);\n\n  if (offset > 0)\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(offset));\n\n  if (has_match_end)\n    OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n  return;\n  }\n\n#endif\n\nstart = LABEL();\n\npartial_quit = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nif (common->mode == PCRE2_JIT_COMPLETE)\n  add_jump(compiler, &common->failed_match, partial_quit);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (char1 == char2)\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, char1, start);\nelse\n  {\n  mask = char1 ^ char2;\n  if (is_powerof2(mask))\n    {\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, mask);\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, char1 | mask, start);\n    }\n  else\n    {\n    match = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, char1);\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, char2, start);\n    JUMPHERE(match);\n    }\n  }\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nif (common->utf && offset > 0)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-(offset + 1)));\n  jumpto_if_not_utf_char_start(compiler, TMP1, start);\n  }\n#endif\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(offset + 1));\n\nif (common->mode != PCRE2_JIT_COMPLETE)\n  JUMPHERE(partial_quit);\n\nif (has_match_end)\n  OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n}\n\nstatic SLJIT_INLINE BOOL fast_forward_first_n_chars(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_label *start;\nstruct sljit_jump *match;\nfast_forward_char_data chars[MAX_N_CHARS];\nsljit_s32 offset;\nPCRE2_UCHAR mask;\nPCRE2_UCHAR *char_set, *char_set_end;\nint i, max, from;\nint range_right = -1, range_len;\nsljit_u8 *update_table = NULL;\nBOOL in_range;\nsljit_u32 rec_count;\n\nfor (i = 0; i < MAX_N_CHARS; i++)\n  {\n  chars[i].count = 0;\n  chars[i].last_count = 0;\n  }\n\nrec_count = 10000;\nmax = scan_prefix(common, common->start, chars, MAX_N_CHARS, &rec_count);\n\nif (max < 1)\n  return FALSE;\n\n/* Convert last_count to priority. */\nfor (i = 0; i < max; i++)\n  {\n  SLJIT_ASSERT(chars[i].count > 0 && chars[i].last_count <= chars[i].count);\n\n  if (chars[i].count == 1)\n    {\n    chars[i].last_count = (chars[i].last_count == 1) ? 7 : 5;\n    /* Simplifies algorithms later. */\n    chars[i].chars[1] = chars[i].chars[0];\n    }\n  else if (chars[i].count == 2)\n    {\n    SLJIT_ASSERT(chars[i].chars[0] != chars[i].chars[1]);\n\n    if (is_powerof2(chars[i].chars[0] ^ chars[i].chars[1]))\n      chars[i].last_count = (chars[i].last_count == 2) ? 6 : 4;\n    else\n      chars[i].last_count = (chars[i].last_count == 2) ? 3 : 2;\n    }\n  else\n    chars[i].last_count = (chars[i].count == 255) ? 0 : 1;\n  }\n\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD\nif (JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD && check_fast_forward_char_pair_simd(common, chars, max))\n  return TRUE;\n#endif\n\nin_range = FALSE;\n/* Prevent compiler \"uninitialized\" warning */\nfrom = 0;\nrange_len = 4 /* minimum length */ - 1;\nfor (i = 0; i <= max; i++)\n  {\n  if (in_range && (i - from) > range_len && (chars[i - 1].count < 255))\n    {\n    range_len = i - from;\n    range_right = i - 1;\n    }\n\n  if (i < max && chars[i].count < 255)\n    {\n    SLJIT_ASSERT(chars[i].count > 0);\n    if (!in_range)\n      {\n      in_range = TRUE;\n      from = i;\n      }\n    }\n  else\n    in_range = FALSE;\n  }\n\nif (range_right >= 0)\n  {\n  update_table = (sljit_u8 *)allocate_read_only_data(common, 256);\n  if (update_table == NULL)\n    return TRUE;\n  memset(update_table, IN_UCHARS(range_len), 256);\n\n  for (i = 0; i < range_len; i++)\n    {\n    SLJIT_ASSERT(chars[range_right - i].count > 0 && chars[range_right - i].count < 255);\n\n    char_set = chars[range_right - i].chars;\n    char_set_end = char_set + chars[range_right - i].count;\n    do\n      {\n      if (update_table[(*char_set) & 0xff] > IN_UCHARS(i))\n        update_table[(*char_set) & 0xff] = IN_UCHARS(i);\n      char_set++;\n      }\n    while (char_set < char_set_end);\n    }\n  }\n\noffset = -1;\n/* Scan forward. */\nfor (i = 0; i < max; i++)\n  {\n  if (range_right == i)\n    continue;\n\n  if (offset == -1)\n    {\n    if (chars[i].last_count >= 2)\n      offset = i;\n    }\n  else if (chars[offset].last_count < chars[i].last_count)\n    offset = i;\n  }\n\nSLJIT_ASSERT(offset == -1 || (chars[offset].count >= 1 && chars[offset].count <= 2));\n\nif (range_right < 0)\n  {\n  if (offset < 0)\n    return FALSE;\n  /* Works regardless the value is 1 or 2. */\n  fast_forward_first_char2(common, chars[offset].chars[0], chars[offset].chars[1], offset);\n  return TRUE;\n  }\n\nSLJIT_ASSERT(range_right != offset);\n\nif (common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_LESS, STR_END, 0, STR_END, 0, SLJIT_IMM, IN_UCHARS(max));\n  add_jump(compiler, &common->failed_match, JUMP(SLJIT_LESS));\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_END, 0, TMP1, 0);\n  CMOV(SLJIT_GREATER, STR_END, TMP1, 0);\n  }\nelse\n  {\n  OP2(SLJIT_SUB | SLJIT_SET_LESS, STR_END, 0, STR_END, 0, SLJIT_IMM, IN_UCHARS(max));\n  add_jump(compiler, &common->failed_match, JUMP(SLJIT_LESS));\n  }\n\nSLJIT_ASSERT(range_right >= 0);\n\nif (!HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, SLJIT_IMM, (sljit_sw)update_table);\n\nstart = LABEL();\nadd_jump(compiler, &common->failed_match, CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0));\n\n#if PCRE2_CODE_UNIT_WIDTH == 8 || (defined SLJIT_LITTLE_ENDIAN && SLJIT_LITTLE_ENDIAN)\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(range_right));\n#else\nOP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(range_right + 1) - 1);\n#endif\n\nif (!HAS_VIRTUAL_REGISTERS)\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM2(RETURN_ADDR, TMP1), 0);\nelse\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)update_table);\n\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\nCMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, start);\n\nif (offset >= 0)\n  {\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(offset));\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  if (chars[offset].count == 1)\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, chars[offset].chars[0], start);\n  else\n    {\n    mask = chars[offset].chars[0] ^ chars[offset].chars[1];\n    if (is_powerof2(mask))\n      {\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, mask);\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, chars[offset].chars[0] | mask, start);\n      }\n    else\n      {\n      match = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, chars[offset].chars[0]);\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, chars[offset].chars[1], start);\n      JUMPHERE(match);\n      }\n    }\n  }\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nif (common->utf && offset != 0)\n  {\n  if (offset < 0)\n    {\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    }\n  else\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n\n  jumpto_if_not_utf_char_start(compiler, TMP1, start);\n\n  if (offset < 0)\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  }\n#endif\n\nif (offset >= 0)\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (common->match_end_ptr != 0)\n  OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\nelse\n  OP2(SLJIT_ADD, STR_END, 0, STR_END, 0, SLJIT_IMM, IN_UCHARS(max));\nreturn TRUE;\n}\n\nstatic SLJIT_INLINE void fast_forward_first_char(compiler_common *common)\n{\nPCRE2_UCHAR first_char = (PCRE2_UCHAR)(common->re->first_codeunit);\nPCRE2_UCHAR oc;\n\noc = first_char;\nif ((common->re->flags & PCRE2_FIRSTCASELESS) != 0)\n  {\n  oc = TABLE_GET(first_char, common->fcc, first_char);\n#if defined SUPPORT_UNICODE\n  if (first_char > 127 && (common->utf || common->ucp))\n    oc = UCD_OTHERCASE(first_char);\n#endif\n  }\n\nfast_forward_first_char2(common, first_char, oc, 0);\n}\n\nstatic SLJIT_INLINE void fast_forward_newline(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nstruct sljit_jump *lastchar = NULL;\nstruct sljit_jump *firstchar;\nstruct sljit_jump *quit = NULL;\nstruct sljit_jump *foundcr = NULL;\nstruct sljit_jump *notfoundnl;\njump_list *newline = NULL;\n\nif (common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n  OP1(SLJIT_MOV, STR_END, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  }\n\nif (common->nltype == NLTYPE_FIXED && common->newline > 255)\n  {\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD\n  if (JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD && common->mode == PCRE2_JIT_COMPLETE)\n    {\n    if (HAS_VIRTUAL_REGISTERS)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n      }\n    firstchar = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP2U(SLJIT_SUB | SLJIT_SET_Z, STR_PTR, 0, TMP1, 0);\n    OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_NOT_EQUAL);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n\n    fast_forward_char_pair_simd(common, 1, common->newline & 0xff, common->newline & 0xff, 0, (common->newline >> 8) & 0xff, (common->newline >> 8) & 0xff);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    }\n  else\n#endif /* JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD */\n    {\n    lastchar = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n    if (HAS_VIRTUAL_REGISTERS)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n      }\n    firstchar = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, STR_PTR, 0, TMP1, 0);\n    OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER_EQUAL);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\n    loop = LABEL();\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    quit = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff, loop);\n    CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff, loop);\n\n    JUMPHERE(quit);\n    JUMPHERE(lastchar);\n    }\n\n  JUMPHERE(firstchar);\n\n  if (common->match_end_ptr != 0)\n    OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n  return;\n  }\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n  }\nelse\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\n\n/* Example: match /^/ to \\r\\n from offset 1. */\nfirstchar = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n\nif (common->nltype == NLTYPE_ANY)\n  move_back(common, NULL, FALSE);\nelse\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nloop = LABEL();\ncommon->ff_newline_shortcut = loop;\n\n#ifdef JIT_HAS_FAST_FORWARD_CHAR_SIMD\nif (JIT_HAS_FAST_FORWARD_CHAR_SIMD && (common->nltype == NLTYPE_FIXED || common->nltype == NLTYPE_ANYCRLF))\n  {\n  if (common->nltype == NLTYPE_ANYCRLF)\n    {\n    fast_forward_char_simd(common, CHAR_CR, CHAR_LF, 0);\n    if (common->mode != PCRE2_JIT_COMPLETE)\n      lastchar = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    quit = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n    }\n   else\n    {\n    fast_forward_char_simd(common, common->newline, common->newline, 0);\n\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    if (common->mode != PCRE2_JIT_COMPLETE)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_PTR, 0, STR_END, 0);\n      CMOV(SLJIT_GREATER, STR_PTR, STR_END, 0);\n      }\n    }\n  }\nelse\n#endif /* JIT_HAS_FAST_FORWARD_CHAR_SIMD */\n  {\n  read_char(common, common->nlmin, common->nlmax, NULL, READ_CHAR_NEWLINE);\n  lastchar = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  if (common->nltype == NLTYPE_ANY || common->nltype == NLTYPE_ANYCRLF)\n    foundcr = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n  check_newlinechar(common, common->nltype, &newline, FALSE);\n  set_jumps(newline, loop);\n  }\n\nif (common->nltype == NLTYPE_ANY || common->nltype == NLTYPE_ANYCRLF)\n  {\n  if (quit == NULL)\n    {\n    quit = JUMP(SLJIT_JUMP);\n    JUMPHERE(foundcr);\n    }\n\n  notfoundnl = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, CHAR_NL);\n  OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);\n#endif\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n  JUMPHERE(notfoundnl);\n  JUMPHERE(quit);\n  }\n\nif (lastchar)\n  JUMPHERE(lastchar);\nJUMPHERE(firstchar);\n\nif (common->match_end_ptr != 0)\n  OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n}\n\nstatic BOOL optimize_class(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks);\n\nstatic SLJIT_INLINE void fast_forward_start_bits(compiler_common *common)\n{\nDEFINE_COMPILER;\nconst sljit_u8 *start_bits = common->re->start_bitmap;\nstruct sljit_label *start;\nstruct sljit_jump *partial_quit;\n#if PCRE2_CODE_UNIT_WIDTH != 8\nstruct sljit_jump *found = NULL;\n#endif\njump_list *matches = NULL;\n\nif (common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, STR_END, 0);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_END, 0, TMP1, 0);\n  CMOV(SLJIT_GREATER, STR_END, TMP1, 0);\n  }\n\nstart = LABEL();\n\npartial_quit = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\nif (common->mode == PCRE2_JIT_COMPLETE)\n  add_jump(compiler, &common->failed_match, partial_quit);\n\nOP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\nOP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (!optimize_class(common, start_bits, (start_bits[31] & 0x80) != 0, FALSE, &matches))\n  {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  if ((start_bits[31] & 0x80) != 0)\n    found = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 255);\n  else\n    CMPTO(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 255, start);\n#elif defined SUPPORT_UNICODE\n  if (common->utf && is_char7_bitset(start_bits, FALSE))\n    CMPTO(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 127, start);\n#endif\n  OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n  OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)start_bits);\n  if (!HAS_VIRTUAL_REGISTERS)\n    {\n    OP2(SLJIT_SHL, TMP3, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP3, 0);\n    }\n  else\n    {\n    OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n    }\n  JUMPTO(SLJIT_ZERO, start);\n  }\nelse\n  set_jumps(matches, start);\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\nif (found != NULL)\n  JUMPHERE(found);\n#endif\n\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (common->mode != PCRE2_JIT_COMPLETE)\n  JUMPHERE(partial_quit);\n\nif (common->match_end_ptr != 0)\n  OP1(SLJIT_MOV, STR_END, 0, RETURN_ADDR, 0);\n}\n\nstatic SLJIT_INLINE jump_list *search_requested_char(compiler_common *common, PCRE2_UCHAR req_char, BOOL caseless, BOOL has_firstchar)\n{\nDEFINE_COMPILER;\nstruct sljit_label *loop;\nstruct sljit_jump *toolong;\nstruct sljit_jump *already_found;\nstruct sljit_jump *found;\nstruct sljit_jump *found_oc = NULL;\njump_list *not_found = NULL;\nsljit_u32 oc, bit;\n\nSLJIT_ASSERT(common->req_char_ptr != 0);\nOP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(REQ_CU_MAX) * 100);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->req_char_ptr);\ntoolong = CMP(SLJIT_LESS, TMP2, 0, STR_END, 0);\nalready_found = CMP(SLJIT_LESS, STR_PTR, 0, TMP1, 0);\n\nif (has_firstchar)\n  OP2(SLJIT_ADD, TMP1, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\nelse\n  OP1(SLJIT_MOV, TMP1, 0, STR_PTR, 0);\n\noc = req_char;\nif (caseless)\n  {\n  oc = TABLE_GET(req_char, common->fcc, req_char);\n#if defined SUPPORT_UNICODE\n  if (req_char > 127 && (common->utf || common->ucp))\n    oc = UCD_OTHERCASE(req_char);\n#endif\n  }\n\n#ifdef JIT_HAS_FAST_REQUESTED_CHAR_SIMD\nif (JIT_HAS_FAST_REQUESTED_CHAR_SIMD)\n  {\n  not_found = fast_requested_char_simd(common, req_char, oc);\n  }\nelse\n#endif\n  {\n  loop = LABEL();\n  add_jump(compiler, &not_found, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, STR_END, 0));\n\n  OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(TMP1), 0);\n\n  if (req_char == oc)\n    found = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, req_char);\n  else\n    {\n    bit = req_char ^ oc;\n    if (is_powerof2(bit))\n      {\n       OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, bit);\n      found = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, req_char | bit);\n      }\n    else\n      {\n      found = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, req_char);\n      found_oc = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, oc);\n      }\n    }\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_JUMP, loop);\n\n  JUMPHERE(found);\n  if (found_oc)\n    JUMPHERE(found_oc);\n  }\n\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->req_char_ptr, TMP1, 0);\n\nJUMPHERE(already_found);\nJUMPHERE(toolong);\nreturn not_found;\n}\n\nstatic void do_revertframes(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_label *mainloop;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\nGET_LOCAL_BASE(TMP1, 0, 0);\n\n/* Drop frames until we reach STACK_TOP. */\nmainloop = LABEL();\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), -sizeof(sljit_sw));\njump = CMP(SLJIT_SIG_LESS_EQUAL, TMP2, 0, SLJIT_IMM, 0);\n\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), sizeof(sljit_sw), SLJIT_MEM1(STACK_TOP), -(3 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 3 * sizeof(sljit_sw));\n  }\nelse\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP1(SLJIT_MOV, TMP3, 0, SLJIT_MEM1(STACK_TOP), -(3 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 3 * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, TMP1, 0);\n  GET_LOCAL_BASE(TMP1, 0, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), sizeof(sljit_sw), TMP3, 0);\n  }\nJUMPTO(SLJIT_JUMP, mainloop);\n\nJUMPHERE(jump);\njump = CMP(SLJIT_NOT_ZERO /* SIG_LESS */, TMP2, 0, SLJIT_IMM, 0);\n/* End of reverting values. */\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n\nJUMPHERE(jump);\nOP1(SLJIT_NEG, TMP2, 0, TMP2, 0);\nOP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 2 * sizeof(sljit_sw));\n  }\nelse\n  {\n  OP1(SLJIT_MOV, TMP3, 0, SLJIT_MEM1(STACK_TOP), -(2 * sizeof(sljit_sw)));\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, 2 * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), 0, TMP3, 0);\n  }\nJUMPTO(SLJIT_JUMP, mainloop);\n}\n\nstatic void check_wordboundary(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *skipread;\njump_list *skipread_list = NULL;\n#ifdef SUPPORT_UNICODE\nstruct sljit_label *valid_utf;\njump_list *invalid_utf1 = NULL;\n#endif /* SUPPORT_UNICODE */\njump_list *invalid_utf2 = NULL;\n#if PCRE2_CODE_UNIT_WIDTH != 8 || defined SUPPORT_UNICODE\nstruct sljit_jump *jump;\n#endif /* PCRE2_CODE_UNIT_WIDTH != 8 || SUPPORT_UNICODE */\n\nSLJIT_COMPILE_ASSERT(ctype_word == 0x10, ctype_word_must_be_16);\n\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n/* Get type of the previous char, and put it to TMP3. */\nOP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\nOP1(SLJIT_MOV, TMP3, 0, SLJIT_IMM, 0);\nskipread = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n\n#ifdef SUPPORT_UNICODE\nif (common->invalid_utf)\n  {\n  peek_char_back(common, READ_CHAR_MAX, &invalid_utf1);\n\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    {\n    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n    OP1(SLJIT_MOV, TMP2, 0, STR_PTR, 0);\n    move_back(common, NULL, TRUE);\n    check_start_used_ptr(common);\n    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n    OP1(SLJIT_MOV, STR_PTR, 0, TMP2, 0);\n    }\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n  if (common->mode == PCRE2_JIT_COMPLETE)\n    peek_char_back(common, READ_CHAR_MAX, NULL);\n  else\n    {\n    move_back(common, NULL, TRUE);\n    check_start_used_ptr(common);\n    read_char(common, 0, READ_CHAR_MAX, NULL, READ_CHAR_UPDATE_STR_PTR);\n    }\n  }\n\n/* Testing char type. */\n#ifdef SUPPORT_UNICODE\nif (common->ucp)\n  {\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 1);\n  jump = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_UNDERSCORE);\n  add_jump(compiler, &common->getucdtype, JUMP(SLJIT_FAST_CALL));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Ll);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n  OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Nd - ucp_Ll);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP3, 0, TMP2, 0);\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#elif defined SUPPORT_UNICODE\n  /* Here TMP3 has already been zeroed. */\n  jump = NULL;\n  if (common->utf)\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), common->ctypes);\n  OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 4 /* ctype_word */);\n  OP2(SLJIT_AND, TMP3, 0, TMP1, 0, SLJIT_IMM, 1);\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  JUMPHERE(jump);\n#elif defined SUPPORT_UNICODE\n  if (jump != NULL)\n    JUMPHERE(jump);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n  }\nJUMPHERE(skipread);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\ncheck_str_end(common, &skipread_list);\npeek_char(common, READ_CHAR_MAX, SLJIT_MEM1(SLJIT_SP), LOCALS1, &invalid_utf2);\n\n/* Testing char type. This is a code duplication. */\n#ifdef SUPPORT_UNICODE\n\nvalid_utf = LABEL();\n\nif (common->ucp)\n  {\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 1);\n  jump = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_UNDERSCORE);\n  add_jump(compiler, &common->getucdtype, JUMP(SLJIT_FAST_CALL));\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Ll);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n  OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ucp_Nd - ucp_Ll);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n  JUMPHERE(jump);\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  /* TMP2 may be destroyed by peek_char. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\n  jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#elif defined SUPPORT_UNICODE\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\n  jump = NULL;\n  if (common->utf)\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n#endif\n  OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP1), common->ctypes);\n  OP2(SLJIT_LSHR, TMP2, 0, TMP2, 0, SLJIT_IMM, 4 /* ctype_word */);\n  OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\n#if PCRE2_CODE_UNIT_WIDTH != 8\n  JUMPHERE(jump);\n#elif defined SUPPORT_UNICODE\n  if (jump != NULL)\n    JUMPHERE(jump);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n  }\nset_jumps(skipread_list, LABEL());\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP2(SLJIT_XOR | SLJIT_SET_Z, TMP2, 0, TMP2, 0, TMP3, 0);\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n\n#ifdef SUPPORT_UNICODE\nif (common->invalid_utf)\n  {\n  set_jumps(invalid_utf1, LABEL());\n\n  peek_char(common, READ_CHAR_MAX, SLJIT_MEM1(SLJIT_SP), LOCALS1, NULL);\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, INVALID_UTF_CHAR, valid_utf);\n\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, -1);\n  OP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n\n  set_jumps(invalid_utf2, LABEL());\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  OP1(SLJIT_MOV, TMP2, 0, TMP3, 0);\n  OP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n  }\n#endif /* SUPPORT_UNICODE */\n}\n\nstatic BOOL optimize_class_ranges(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks)\n{\n/* May destroy TMP1. */\nDEFINE_COMPILER;\nint ranges[MAX_CLASS_RANGE_SIZE];\nsljit_u8 bit, cbit, all;\nint i, byte, length = 0;\n\nbit = bits[0] & 0x1;\n/* All bits will be zero or one (since bit is zero or one). */\nall = -bit;\n\nfor (i = 0; i < 256; )\n  {\n  byte = i >> 3;\n  if ((i & 0x7) == 0 && bits[byte] == all)\n    i += 8;\n  else\n    {\n    cbit = (bits[byte] >> (i & 0x7)) & 0x1;\n    if (cbit != bit)\n      {\n      if (length >= MAX_CLASS_RANGE_SIZE)\n        return FALSE;\n      ranges[length] = i;\n      length++;\n      bit = cbit;\n      all = -cbit;\n      }\n    i++;\n    }\n  }\n\nif (((bit == 0) && nclass) || ((bit == 1) && !nclass))\n  {\n  if (length >= MAX_CLASS_RANGE_SIZE)\n    return FALSE;\n  ranges[length] = 256;\n  length++;\n  }\n\nif (length < 0 || length > 4)\n  return FALSE;\n\nbit = bits[0] & 0x1;\nif (invert) bit ^= 0x1;\n\n/* No character is accepted. */\nif (length == 0 && bit == 0)\n  add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n\nswitch(length)\n  {\n  case 0:\n  /* When bit != 0, all characters are accepted. */\n  return TRUE;\n\n  case 1:\n  add_jump(compiler, backtracks, CMP(bit == 0 ? SLJIT_LESS : SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[0]));\n  return TRUE;\n\n  case 2:\n  if (ranges[0] + 1 != ranges[1])\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[0]);\n    add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_LESS : SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_EQUAL : SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[0]));\n  return TRUE;\n\n  case 3:\n  if (bit != 0)\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[2]));\n    if (ranges[0] + 1 != ranges[1])\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[0]);\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]));\n      }\n    else\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[0]));\n    return TRUE;\n    }\n\n  add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[0]));\n  if (ranges[1] + 1 != ranges[2])\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[1]);\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[2] - ranges[1]));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[1]));\n  return TRUE;\n\n  case 4:\n  if ((ranges[1] - ranges[0]) == (ranges[3] - ranges[2])\n      && (ranges[0] | (ranges[2] - ranges[0])) == ranges[2]\n      && (ranges[1] & (ranges[2] - ranges[0])) == 0\n      && is_powerof2(ranges[2] - ranges[0]))\n    {\n    SLJIT_ASSERT((ranges[0] & (ranges[2] - ranges[0])) == 0 && (ranges[2] & ranges[3] & (ranges[2] - ranges[0])) != 0);\n    OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[2] - ranges[0]);\n    if (ranges[2] + 1 != ranges[3])\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[2]);\n      add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_LESS : SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[3] - ranges[2]));\n      }\n    else\n      add_jump(compiler, backtracks, CMP(bit != 0 ? SLJIT_EQUAL : SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[2]));\n    return TRUE;\n    }\n\n  if (bit != 0)\n    {\n    i = 0;\n    if (ranges[0] + 1 != ranges[1])\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[0]);\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]));\n      i = ranges[0];\n      }\n    else\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[0]));\n\n    if (ranges[2] + 1 != ranges[3])\n      {\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[2] - i);\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[3] - ranges[2]));\n      }\n    else\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[2] - i));\n    return TRUE;\n    }\n\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[0]);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, ranges[3] - ranges[0]));\n  if (ranges[1] + 1 != ranges[2])\n    {\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]);\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, ranges[2] - ranges[1]));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, ranges[1] - ranges[0]));\n  return TRUE;\n\n  default:\n  SLJIT_UNREACHABLE();\n  return FALSE;\n  }\n}\n\nstatic BOOL optimize_class_chars(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks)\n{\n/* May destroy TMP1. */\nDEFINE_COMPILER;\nuint16_t char_list[MAX_CLASS_CHARS_SIZE];\nuint8_t byte;\nsljit_s32 type;\nint i, j, k, len, c;\n\nif (!sljit_has_cpu_feature(SLJIT_HAS_CMOV))\n  return FALSE;\n\nlen = 0;\n\nfor (i = 0; i < 32; i++)\n  {\n  byte = bits[i];\n\n  if (nclass)\n    byte = ~byte;\n\n  j = 0;\n  while (byte != 0)\n    {\n    if (byte & 0x1)\n      {\n      c = i * 8 + j;\n\n      k = len;\n\n      if ((c & 0x20) != 0)\n        {\n        for (k = 0; k < len; k++)\n          if (char_list[k] == c - 0x20)\n            {\n            char_list[k] |= 0x120;\n            break;\n            }\n        }\n\n      if (k == len)\n        {\n        if (len >= MAX_CLASS_CHARS_SIZE)\n          return FALSE;\n\n        char_list[len++] = (uint16_t) c;\n        }\n      }\n\n    byte >>= 1;\n    j++;\n    }\n  }\n\nif (len == 0) return FALSE;  /* Should never occur, but stops analyzers complaining. */\n\ni = 0;\nj = 0;\n\nif (char_list[0] == 0)\n  {\n  i++;\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0);\n  OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_ZERO);\n  }\nelse\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, 0);\n\nwhile (i < len)\n  {\n  if ((char_list[i] & 0x100) != 0)\n    j++;\n  else\n    {\n    OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, char_list[i]);\n    CMOV(SLJIT_ZERO, TMP2, TMP1, 0);\n    }\n  i++;\n  }\n\nif (j != 0)\n  {\n  OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x20);\n\n  for (i = 0; i < len; i++)\n    if ((char_list[i] & 0x100) != 0)\n      {\n      j--;\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, char_list[i] & 0xff);\n      CMOV(SLJIT_ZERO, TMP2, TMP1, 0);\n      }\n  }\n\nif (invert)\n  nclass = !nclass;\n\ntype = nclass ? SLJIT_NOT_EQUAL : SLJIT_EQUAL;\nadd_jump(compiler, backtracks, CMP(type, TMP2, 0, SLJIT_IMM, 0));\nreturn TRUE;\n}\n\nstatic BOOL optimize_class(compiler_common *common, const sljit_u8 *bits, BOOL nclass, BOOL invert, jump_list **backtracks)\n{\n/* May destroy TMP1. */\nif (optimize_class_ranges(common, bits, nclass, invert, backtracks))\n  return TRUE;\nreturn optimize_class_chars(common, bits, nclass, invert, backtracks);\n}\n\nstatic void check_anynewline(compiler_common *common)\n{\n/* Check whether TMP1 contains a newline character. TMP2 destroyed. */\nDEFINE_COMPILER;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x0a);\nOP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x0d - 0x0a);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x0a);\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n#endif\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x1);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x2029 - 0x0a);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  }\n#endif\n#endif /* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == [16|32] */\nOP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void check_hspace(compiler_common *common)\n{\n/* Check whether TMP1 contains a newline character. TMP2 destroyed. */\nDEFINE_COMPILER;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x09);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x20);\nOP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0xa0);\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n#endif\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x1680);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x2000);\n  OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x200A - 0x2000);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x202f - 0x2000);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x205f - 0x2000);\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x3000 - 0x2000);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  }\n#endif\n#endif /* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == [16|32] */\nOP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void check_vspace(compiler_common *common)\n{\n/* Check whether TMP1 contains a newline character. TMP2 destroyed. */\nDEFINE_COMPILER;\n\nsljit_emit_fast_enter(compiler, RETURN_ADDR, 0);\n\nOP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x0a);\nOP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x0d - 0x0a);\nOP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\nOP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x0a);\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utf)\n  {\n#endif\n  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n  OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0x1);\n  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x2029 - 0x0a);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  }\n#endif\n#endif /* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == [16|32] */\nOP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n\nOP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);\n}\n\nstatic void do_casefulcmp(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_label *label;\nint char1_reg;\nint char2_reg;\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  char1_reg = STR_END;\n  char2_reg = STACK_TOP;\n  }\nelse\n  {\n  char1_reg = TMP3;\n  char2_reg = RETURN_ADDR;\n  }\n\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\nif (char1_reg == STR_END)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, char1_reg, 0);\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, char2_reg, 0);\n  }\n\nif (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  {\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  jump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_NOT_ZERO, label);\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  }\nelse if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  {\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  jump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_NOT_ZERO, label);\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  }\nelse\n  {\n  label = LABEL();\n  OP1(MOV_UCHAR, char1_reg, 0, SLJIT_MEM1(TMP1), 0);\n  OP1(MOV_UCHAR, char2_reg, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  jump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\n  JUMPTO(SLJIT_NOT_ZERO, label);\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n  }\n\nif (char1_reg == STR_END)\n  {\n  OP1(SLJIT_MOV, char1_reg, 0, TMP3, 0);\n  OP1(SLJIT_MOV, char2_reg, 0, RETURN_ADDR, 0);\n  }\n\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n}\n\nstatic void do_caselesscmp(compiler_common *common)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nstruct sljit_label *label;\nint char1_reg = STR_END;\nint char2_reg;\nint lcc_table;\nint opt_type = 0;\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  char2_reg = STACK_TOP;\n  lcc_table = STACK_LIMIT;\n  }\nelse\n  {\n  char2_reg = RETURN_ADDR;\n  lcc_table = TMP3;\n  }\n\nif (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  opt_type = 1;\nelse if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1)) == SLJIT_SUCCESS)\n  opt_type = 2;\n\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS1, char1_reg, 0);\n\nif (char2_reg == STACK_TOP)\n  {\n  OP1(SLJIT_MOV, TMP3, 0, char2_reg, 0);\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, lcc_table, 0);\n  }\n\nOP1(SLJIT_MOV, lcc_table, 0, SLJIT_IMM, common->lcc);\n\nif (opt_type == 1)\n  {\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  }\nelse if (opt_type == 2)\n  {\n  OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  label = LABEL();\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char1_reg, SLJIT_MEM1(TMP1), IN_UCHARS(1));\n  sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_PRE, char2_reg, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n  }\nelse\n  {\n  label = LABEL();\n  OP1(MOV_UCHAR, char1_reg, 0, SLJIT_MEM1(TMP1), 0);\n  OP1(MOV_UCHAR, char2_reg, 0, SLJIT_MEM1(STR_PTR), 0);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(1));\n  }\n\n#if PCRE2_CODE_UNIT_WIDTH != 8\njump = CMP(SLJIT_GREATER, char1_reg, 0, SLJIT_IMM, 255);\n#endif\nOP1(SLJIT_MOV_U8, char1_reg, 0, SLJIT_MEM2(lcc_table, char1_reg), 0);\n#if PCRE2_CODE_UNIT_WIDTH != 8\nJUMPHERE(jump);\njump = CMP(SLJIT_GREATER, char2_reg, 0, SLJIT_IMM, 255);\n#endif\nOP1(SLJIT_MOV_U8, char2_reg, 0, SLJIT_MEM2(lcc_table, char2_reg), 0);\n#if PCRE2_CODE_UNIT_WIDTH != 8\nJUMPHERE(jump);\n#endif\n\nif (opt_type == 0)\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\njump = CMP(SLJIT_NOT_EQUAL, char1_reg, 0, char2_reg, 0);\nOP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, TMP2, 0, SLJIT_IMM, IN_UCHARS(1));\nJUMPTO(SLJIT_NOT_ZERO, label);\n\nJUMPHERE(jump);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n\nif (opt_type == 2)\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\nif (char2_reg == STACK_TOP)\n  {\n  OP1(SLJIT_MOV, char2_reg, 0, TMP3, 0);\n  OP1(SLJIT_MOV, lcc_table, 0, RETURN_ADDR, 0);\n  }\n\nOP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), LOCALS1);\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n}\n\nstatic PCRE2_SPTR byte_sequence_compare(compiler_common *common, BOOL caseless, PCRE2_SPTR cc,\n    compare_context *context, jump_list **backtracks)\n{\nDEFINE_COMPILER;\nunsigned int othercasebit = 0;\nPCRE2_SPTR othercasechar = NULL;\n#ifdef SUPPORT_UNICODE\nint utflength;\n#endif\n\nif (caseless && char_has_othercase(common, cc))\n  {\n  othercasebit = char_get_othercase_bit(common, cc);\n  SLJIT_ASSERT(othercasebit);\n  /* Extracting bit difference info. */\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  othercasechar = cc + (othercasebit >> 8);\n  othercasebit &= 0xff;\n#elif PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  /* Note that this code only handles characters in the BMP. If there\n  ever are characters outside the BMP whose othercase differs in only one\n  bit from itself (there currently are none), this code will need to be\n  revised for PCRE2_CODE_UNIT_WIDTH == 32. */\n  othercasechar = cc + (othercasebit >> 9);\n  if ((othercasebit & 0x100) != 0)\n    othercasebit = (othercasebit & 0xff) << 8;\n  else\n    othercasebit &= 0xff;\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n  }\n\nif (context->sourcereg == -1)\n  {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  if (context->length >= 4)\n    OP1(SLJIT_MOV_S32, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n  else if (context->length >= 2)\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n  else\n#endif\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  if (context->length >= 4)\n    OP1(SLJIT_MOV_S32, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n  else\n#endif\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#elif PCRE2_CODE_UNIT_WIDTH == 32\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */\n  context->sourcereg = TMP2;\n  }\n\n#ifdef SUPPORT_UNICODE\nutflength = 1;\nif (common->utf && HAS_EXTRALEN(*cc))\n  utflength += GET_EXTRALEN(*cc);\n\ndo\n  {\n#endif\n\n  context->length -= IN_UCHARS(1);\n#if (defined SLJIT_UNALIGNED && SLJIT_UNALIGNED) && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\n\n  /* Unaligned read is supported. */\n  if (othercasebit != 0 && othercasechar == cc)\n    {\n    context->c.asuchars[context->ucharptr] = *cc | othercasebit;\n    context->oc.asuchars[context->ucharptr] = othercasebit;\n    }\n  else\n    {\n    context->c.asuchars[context->ucharptr] = *cc;\n    context->oc.asuchars[context->ucharptr] = 0;\n    }\n  context->ucharptr++;\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n  if (context->ucharptr >= 4 || context->length == 0 || (context->ucharptr == 2 && context->length == 1))\n#else\n  if (context->ucharptr >= 2 || context->length == 0)\n#endif\n    {\n    if (context->length >= 4)\n      OP1(SLJIT_MOV_S32, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n    else if (context->length >= 2)\n      OP1(SLJIT_MOV_U16, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    else if (context->length >= 1)\n      OP1(SLJIT_MOV_U8, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n    context->sourcereg = context->sourcereg == TMP1 ? TMP2 : TMP1;\n\n    switch(context->ucharptr)\n      {\n      case 4 / sizeof(PCRE2_UCHAR):\n      if (context->oc.asint != 0)\n        OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, context->oc.asint);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, context->c.asint | context->oc.asint));\n      break;\n\n      case 2 / sizeof(PCRE2_UCHAR):\n      if (context->oc.asushort != 0)\n        OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, context->oc.asushort);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, context->c.asushort | context->oc.asushort));\n      break;\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n      case 1:\n      if (context->oc.asbyte != 0)\n        OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, context->oc.asbyte);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, context->c.asbyte | context->oc.asbyte));\n      break;\n#endif\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    context->ucharptr = 0;\n    }\n\n#else\n\n  /* Unaligned read is unsupported or in 32 bit mode. */\n  if (context->length >= 1)\n    OP1(MOV_UCHAR, context->sourcereg, 0, SLJIT_MEM1(STR_PTR), -context->length);\n\n  context->sourcereg = context->sourcereg == TMP1 ? TMP2 : TMP1;\n\n  if (othercasebit != 0 && othercasechar == cc)\n    {\n    OP2(SLJIT_OR, context->sourcereg, 0, context->sourcereg, 0, SLJIT_IMM, othercasebit);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, *cc | othercasebit));\n    }\n  else\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, context->sourcereg, 0, SLJIT_IMM, *cc));\n\n#endif\n\n  cc++;\n#ifdef SUPPORT_UNICODE\n  utflength--;\n  }\nwhile (utflength > 0);\n#endif\n\nreturn cc;\n}\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n\n#define SET_TYPE_OFFSET(value) \\\n  if ((value) != typeoffset) \\\n    { \\\n    if ((value) < typeoffset) \\\n      OP2(SLJIT_ADD, typereg, 0, typereg, 0, SLJIT_IMM, typeoffset - (value)); \\\n    else \\\n      OP2(SLJIT_SUB, typereg, 0, typereg, 0, SLJIT_IMM, (value) - typeoffset); \\\n    } \\\n  typeoffset = (value);\n\n#define SET_CHAR_OFFSET(value) \\\n  if ((value) != charoffset) \\\n    { \\\n    if ((value) < charoffset) \\\n      OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)(charoffset - (value))); \\\n    else \\\n      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)((value) - charoffset)); \\\n    } \\\n  charoffset = (value);\n\nstatic PCRE2_SPTR compile_char1_matchingpath(compiler_common *common, PCRE2_UCHAR type, PCRE2_SPTR cc, jump_list **backtracks, BOOL check_str_ptr);\n\n#ifdef SUPPORT_UNICODE\n#define XCLASS_SAVE_CHAR 0x001\n#define XCLASS_CHAR_SAVED 0x002\n#define XCLASS_HAS_TYPE 0x004\n#define XCLASS_HAS_SCRIPT 0x008\n#define XCLASS_HAS_SCRIPT_EXTENSION 0x010\n#define XCLASS_HAS_BOOL 0x020\n#define XCLASS_HAS_BIDICL 0x040\n#define XCLASS_NEEDS_UCD (XCLASS_HAS_TYPE | XCLASS_HAS_SCRIPT | XCLASS_HAS_SCRIPT_EXTENSION | XCLASS_HAS_BOOL | XCLASS_HAS_BIDICL)\n#define XCLASS_SCRIPT_EXTENSION_NOTPROP 0x080\n#define XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR 0x100\n#define XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0 0x200\n\n#endif /* SUPPORT_UNICODE */\n\nstatic void compile_xclass_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks)\n{\nDEFINE_COMPILER;\njump_list *found = NULL;\njump_list **list = (cc[0] & XCL_NOT) == 0 ? &found : backtracks;\nsljit_uw c, charoffset, max = 256, min = READ_CHAR_MAX;\nstruct sljit_jump *jump = NULL;\nPCRE2_SPTR ccbegin;\nint compares, invertcmp, numberofcmps;\n#if defined SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\nBOOL utf = common->utf;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == [8|16] */\n\n#ifdef SUPPORT_UNICODE\nsljit_u32 unicode_status = 0;\nint typereg = TMP1;\nconst sljit_u32 *other_cases;\nsljit_uw typeoffset;\n#endif /* SUPPORT_UNICODE */\n\n/* Scanning the necessary info. */\ncc++;\nccbegin = cc;\ncompares = 0;\n\nif (cc[-1] & XCL_MAP)\n  {\n  min = 0;\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\nwhile (*cc != XCL_END)\n  {\n  compares++;\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n    if (c < min) min = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c < min) min = c;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    cc++;\n    if (*cc == PT_CLIST && cc[-1] == XCL_PROP)\n      {\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n      while (*other_cases != NOTACHAR)\n        {\n        if (*other_cases > max) max = *other_cases;\n        if (*other_cases < min) min = *other_cases;\n        other_cases++;\n        }\n      }\n    else\n      {\n      max = READ_CHAR_MAX;\n      min = 0;\n      }\n\n    switch(*cc)\n      {\n      case PT_ANY:\n      /* Any either accepts everything or ignored. */\n      if (cc[-1] == XCL_PROP)\n        {\n        compile_char1_matchingpath(common, OP_ALLANY, cc, backtracks, FALSE);\n        if (list == backtracks)\n          add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n        return;\n        }\n      break;\n\n      case PT_LAMP:\n      case PT_GC:\n      case PT_PC:\n      case PT_ALNUM:\n      unicode_status |= XCLASS_HAS_TYPE;\n      break;\n\n      case PT_SCX:\n      unicode_status |= XCLASS_HAS_SCRIPT_EXTENSION;\n      if (cc[-1] == XCL_NOTPROP)\n        {\n        unicode_status |= XCLASS_SCRIPT_EXTENSION_NOTPROP;\n        break;\n        }\n      compares++;\n      /* Fall through */ \n\n      case PT_SC:\n      unicode_status |= XCLASS_HAS_SCRIPT;\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      case PT_WORD:\n      case PT_PXGRAPH:\n      case PT_PXPRINT:\n      case PT_PXPUNCT:\n      unicode_status |= XCLASS_SAVE_CHAR | XCLASS_HAS_TYPE;\n      break;\n\n      case PT_CLIST:\n      case PT_UCNC:\n      unicode_status |= XCLASS_SAVE_CHAR;\n      break;\n\n      case PT_BOOL:\n      unicode_status |= XCLASS_HAS_BOOL;\n      break;\n\n      case PT_BIDICL:\n      unicode_status |= XCLASS_HAS_BIDICL;\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n  }\nSLJIT_ASSERT(compares > 0);\n\n/* We are not necessary in utf mode even in 8 bit mode. */\ncc = ccbegin;\nif ((cc[-1] & XCL_NOT) != 0)\n  read_char(common, min, max, backtracks, READ_CHAR_UPDATE_STR_PTR);\nelse\n  {\n#ifdef SUPPORT_UNICODE\n  read_char(common, min, max, (unicode_status & XCLASS_NEEDS_UCD) ? backtracks : NULL, 0);\n#else /* !SUPPORT_UNICODE */\n  read_char(common, min, max, NULL, 0);\n#endif /* SUPPORT_UNICODE */\n  }\n\nif ((cc[-1] & XCL_HASPROP) == 0)\n  {\n  if ((cc[-1] & XCL_MAP) != 0)\n    {\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n    if (!optimize_class(common, (const sljit_u8 *)cc, (((const sljit_u8 *)cc)[31] & 0x80) != 0, TRUE, &found))\n      {\n      OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n      OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n      OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n      OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n      add_jump(compiler, &found, JUMP(SLJIT_NOT_ZERO));\n      }\n\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    JUMPHERE(jump);\n\n    cc += 32 / sizeof(PCRE2_UCHAR);\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, min);\n    add_jump(compiler, (cc[-1] & XCL_NOT) == 0 ? backtracks : &found, CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, max - min));\n    }\n  }\nelse if ((cc[-1] & XCL_MAP) != 0)\n  {\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n#ifdef SUPPORT_UNICODE\n  unicode_status |= XCLASS_CHAR_SAVED;\n#endif /* SUPPORT_UNICODE */\n  if (!optimize_class(common, (const sljit_u8 *)cc, FALSE, TRUE, list))\n    {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    jump = NULL;\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n\n    OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n    OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n    add_jump(compiler, list, JUMP(SLJIT_NOT_ZERO));\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      JUMPHERE(jump);\n    }\n\n  OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\n#ifdef SUPPORT_UNICODE\nif (unicode_status & XCLASS_NEEDS_UCD)\n  {\n  if ((unicode_status & (XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED)) == XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\n  if (!common->utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n    JUMPHERE(jump);\n    }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n  OP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n  OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 3);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n  ccbegin = cc;\n\n  if (unicode_status & XCLASS_HAS_BIDICL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BIDICLASS_SHIFT);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BIDICL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n          jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]);\n          add_jump(compiler, compares > 0 ? list : backtracks, jump);\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_BOOL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, bprops));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BPROPS_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BOOL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_boolprop_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT)\n    {\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        switch (*cc)\n          {\n          case PT_SCX:\n          if (cc[-1] == XCL_NOTPROP)\n            break;\n          /* Fall through */ \n\n          case PT_SC:\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          add_jump(compiler, compares > 0 ? list : backtracks, CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT_EXTENSION)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_SCRIPTX_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_NOTPROP)\n      {\n      if (unicode_status & XCLASS_HAS_TYPE)\n        {\n        if (unicode_status & XCLASS_SAVE_CHAR)\n          {\n          OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0;\n          }\n        else\n          {\n          OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR;\n          }\n        }\n      OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n      }\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_SCX)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n\n          jump = NULL;\n          if (cc[-1] == XCL_NOTPROP)\n            {\n            jump = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, (int)cc[1]);\n            if (invertcmp)\n              {\n              add_jump(compiler, backtracks, jump);\n              jump = NULL;\n              }\n            invertcmp ^= 0x1;\n            }\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_script_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n\n          if (jump != NULL)\n            JUMPHERE(jump);\n          }\n        cc += 2;\n        }\n      }\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n    else if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR)\n      OP1(SLJIT_MOV, TMP2, 0, RETURN_ADDR, 0);\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n\n  if (unicode_status & XCLASS_HAS_TYPE)\n    {\n    if (unicode_status & XCLASS_SAVE_CHAR)\n      typereg = RETURN_ADDR;\n\n    OP1(SLJIT_MOV_U8, typereg, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));\n    }\n  }\n#endif /* SUPPORT_UNICODE */\n\n/* Generating code. */\ncharoffset = 0;\nnumberofcmps = 0;\n#ifdef SUPPORT_UNICODE\ntypeoffset = 0;\n#endif /* SUPPORT_UNICODE */\n\nwhile (*cc != XCL_END)\n  {\n  compares--;\n  invertcmp = (compares == 0 && list != backtracks);\n  jump = NULL;\n\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    SET_CHAR_OFFSET(c);\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    if (*cc == XCL_NOTPROP)\n      invertcmp ^= 0x1;\n    cc++;\n    switch(*cc)\n      {\n      case PT_ANY:\n      if (!invertcmp)\n        jump = JUMP(SLJIT_JUMP);\n      break;\n\n      case PT_LAMP:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lu - typeoffset);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Ll - typeoffset);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lt - typeoffset);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_GC:\n      c = PRIV(ucp_typerange)[(int)cc[1] * 2];\n      SET_TYPE_OFFSET(c);\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, PRIV(ucp_typerange)[(int)cc[1] * 2 + 1] - c);\n      break;\n\n      case PT_PC:\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, (int)cc[1] - typeoffset);\n      break;\n\n      case PT_SC:\n      case PT_SCX:\n      case PT_BOOL:\n      case PT_BIDICL:\n      compares++;\n      /* Do nothing. */\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      SET_CHAR_OFFSET(9);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0xd - 0x9);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Zl);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Zl);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_WORD:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_UNDERSCORE - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      /* Fall through. */\n\n      case PT_ALNUM:\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n      OP_FLAGS((*cc == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_TYPE_OFFSET(ucp_Nd);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_CLIST:\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n\n      /* At least three characters are required.\n         Otherwise this case would be handled by the normal code path. */\n      SLJIT_ASSERT(other_cases[0] != NOTACHAR && other_cases[1] != NOTACHAR && other_cases[2] != NOTACHAR);\n      SLJIT_ASSERT(other_cases[0] < other_cases[1] && other_cases[1] < other_cases[2]);\n\n      /* Optimizing character pairs, if their difference is power of 2. */\n      if (is_powerof2(other_cases[1] ^ other_cases[0]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[1]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        other_cases += 2;\n        }\n      else if (is_powerof2(other_cases[2] ^ other_cases[1]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[2] ^ other_cases[1]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[2]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(other_cases[0] - charoffset));\n        OP_FLAGS(SLJIT_OR | ((other_cases[3] == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n\n        other_cases += 3;\n        }\n      else\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        }\n\n      while (*other_cases != NOTACHAR)\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_OR | ((*other_cases == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n        }\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_UCNC:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_DOLLAR_SIGN - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_COMMERCIAL_AT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_GRAVE_ACCENT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_CHAR_OFFSET(0xa0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(0xd7ff - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000 - 0);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_GREATER_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_PXGRAPH:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPRINT:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Ll);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPUNCT:\n      SET_TYPE_OFFSET(ucp_Sc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_So - ucp_Sc);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x7f);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Pc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Ps - ucp_Pc);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n\n  if (jump != NULL)\n    add_jump(compiler, compares > 0 ? list : backtracks, jump);\n  }\n\nif (found != NULL)\n  set_jumps(found, LABEL());\n}\n\n#undef SET_TYPE_OFFSET\n#undef SET_CHAR_OFFSET\n\n#endif\n\nstatic PCRE2_SPTR compile_simple_assertion_matchingpath(compiler_common *common, PCRE2_UCHAR type, PCRE2_SPTR cc, jump_list **backtracks)\n{\nDEFINE_COMPILER;\nint length;\nstruct sljit_jump *jump[4];\n#ifdef SUPPORT_UNICODE\nstruct sljit_label *label;\n#endif /* SUPPORT_UNICODE */\n\nswitch(type)\n  {\n  case OP_SOD:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n    }\n  else\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n  add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, TMP1, 0));\n  return cc;\n\n  case OP_SOM:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n    }\n  else\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\n  add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, TMP1, 0));\n  return cc;\n\n  case OP_NOT_WORD_BOUNDARY:\n  case OP_WORD_BOUNDARY:\n  add_jump(compiler, &common->wordboundary, JUMP(SLJIT_FAST_CALL));\n#ifdef SUPPORT_UNICODE\n  if (common->invalid_utf)\n    {\n    add_jump(compiler, backtracks, CMP((type == OP_NOT_WORD_BOUNDARY) ? SLJIT_NOT_EQUAL : SLJIT_SIG_LESS_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n    return cc;\n    }\n#endif /* SUPPORT_UNICODE */\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(type == OP_NOT_WORD_BOUNDARY ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  return cc;\n\n  case OP_EODN:\n  /* Requires rather complex checks. */\n  jump[0] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, STR_END, 0));\n    else\n      {\n      jump[1] = CMP(SLJIT_EQUAL, TMP2, 0, STR_END, 0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS, TMP2, 0, STR_END, 0);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_NOT_EQUAL);\n      add_jump(compiler, backtracks, JUMP(SLJIT_NOT_EQUAL));\n      check_partial(common, TRUE);\n      add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n      JUMPHERE(jump[1]);\n      }\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff));\n    }\n  else if (common->nltype == NLTYPE_FIXED)\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, STR_END, 0));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, common->newline));\n    }\n  else\n    {\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    jump[1] = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP2U(SLJIT_SUB | SLJIT_SET_Z | SLJIT_SET_GREATER, TMP2, 0, STR_END, 0);\n    jump[2] = JUMP(SLJIT_GREATER);\n    add_jump(compiler, backtracks, JUMP(SLJIT_NOT_EQUAL) /* LESS */);\n    /* Equal. */\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    jump[3] = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL);\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n\n    JUMPHERE(jump[1]);\n    if (common->nltype == NLTYPE_ANYCRLF)\n      {\n      OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP2, 0, STR_END, 0));\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL));\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n      read_char(common, common->nlmin, common->nlmax, backtracks, READ_CHAR_UPDATE_STR_PTR);\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, STR_END, 0));\n      add_jump(compiler, &common->anynewline, JUMP(SLJIT_FAST_CALL));\n      sljit_set_current_flags(compiler, SLJIT_SET_Z);\n      add_jump(compiler, backtracks, JUMP(SLJIT_ZERO));\n      OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n      }\n    JUMPHERE(jump[2]);\n    JUMPHERE(jump[3]);\n    }\n  JUMPHERE(jump[0]);\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    check_partial(common, TRUE);\n  return cc;\n\n  case OP_EOD:\n  add_jump(compiler, backtracks, CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0));\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    check_partial(common, TRUE);\n  return cc;\n\n  case OP_DOLL:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n    }\n  else\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n  add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n\n  if (!common->endonly)\n    compile_simple_assertion_matchingpath(common, OP_EODN, cc, backtracks);\n  else\n    {\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0));\n    check_partial(common, FALSE);\n    }\n  return cc;\n\n  case OP_DOLLM:\n  jump[1] = CMP(SLJIT_LESS, STR_PTR, 0, STR_END, 0);\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n    }\n  else\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTEOL);\n  add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n  check_partial(common, FALSE);\n  jump[0] = JUMP(SLJIT_JUMP);\n  JUMPHERE(jump[1]);\n\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER, TMP2, 0, STR_END, 0));\n    else\n      {\n      jump[1] = CMP(SLJIT_LESS_EQUAL, TMP2, 0, STR_END, 0);\n      /* STR_PTR = STR_END - IN_UCHARS(1) */\n      add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n      check_partial(common, TRUE);\n      add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n      JUMPHERE(jump[1]);\n      }\n\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff));\n    }\n  else\n    {\n    peek_char(common, common->nlmax, TMP3, 0, NULL);\n    check_newlinechar(common, common->nltype, backtracks, FALSE);\n    }\n  JUMPHERE(jump[0]);\n  return cc;\n\n  case OP_CIRC:\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, begin));\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, TMP1, 0));\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, TMP1, 0));\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n    }\n  return cc;\n\n  case OP_CIRCM:\n  /* TMP2 might be used by peek_char_back. */\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n    jump[1] = CMP(SLJIT_GREATER, STR_PTR, 0, TMP2, 0);\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n    jump[1] = CMP(SLJIT_GREATER, STR_PTR, 0, TMP2, 0);\n    OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options), SLJIT_IMM, PCRE2_NOTBOL);\n    }\n  add_jump(compiler, backtracks, JUMP(SLJIT_NOT_ZERO));\n  jump[0] = JUMP(SLJIT_JUMP);\n  JUMPHERE(jump[1]);\n\n  if (!common->alt_circumflex)\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    OP2(SLJIT_SUB, TMP1, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, TMP1, 0, TMP2, 0));\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));\n    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff));\n    }\n  else\n    {\n    peek_char_back(common, common->nlmax, backtracks);\n    check_newlinechar(common, common->nltype, backtracks, FALSE);\n    }\n  JUMPHERE(jump[0]);\n  return cc;\n\n  case OP_REVERSE:\n  length = GET(cc, 0);\n  if (length == 0)\n    return cc + LINK_SIZE;\n  if (HAS_VIRTUAL_REGISTERS)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));\n    }\n  else\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n    OP1(SLJIT_MOV, TMP3, 0, SLJIT_IMM, length);\n    label = LABEL();\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0));\n    move_back(common, backtracks, FALSE);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP3, 0, TMP3, 0, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, label);\n    }\n  else\n#endif\n    {\n    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(length));\n    add_jump(compiler, backtracks, CMP(SLJIT_LESS, STR_PTR, 0, TMP2, 0));\n    }\n  check_start_used_ptr(common);\n  return cc + LINK_SIZE;\n  }\nSLJIT_UNREACHABLE();\nreturn cc;\n}\n\n#ifdef SUPPORT_UNICODE\n\n#if PCRE2_CODE_UNIT_WIDTH != 32\n\nstatic PCRE2_SPTR SLJIT_FUNC do_extuni_utf(jit_arguments *args, PCRE2_SPTR cc)\n{\nPCRE2_SPTR start_subject = args->begin;\nPCRE2_SPTR end_subject = args->end;\nint lgb, rgb, ricount;\nPCRE2_SPTR prevcc, endcc, bptr;\nBOOL first = TRUE;\nuint32_t c;\n\nprevcc = cc;\nendcc = NULL;\ndo\n  {\n  GETCHARINC(c, cc);\n  rgb = UCD_GRAPHBREAK(c);\n\n  if (first)\n    {\n    lgb = rgb;\n    endcc = cc;\n    first = FALSE;\n    continue;\n    }\n\n  if ((PRIV(ucp_gbtable)[lgb] & (1 << rgb)) == 0)\n    break;\n\n  /* Not breaking between Regional Indicators is allowed only if there\n  are an even number of preceding RIs. */\n\n  if (lgb == ucp_gbRegional_Indicator && rgb == ucp_gbRegional_Indicator)\n    {\n    ricount = 0;\n    bptr = prevcc;\n\n    /* bptr is pointing to the left-hand character */\n    while (bptr > start_subject)\n      {\n      bptr--;\n      BACKCHAR(bptr);\n      GETCHAR(c, bptr);\n\n      if (UCD_GRAPHBREAK(c) != ucp_gbRegional_Indicator)\n        break;\n\n      ricount++;\n      }\n\n    if ((ricount & 1) != 0) break;  /* Grapheme break required */\n    }\n\n  /* If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this\n  allows any number of them before a following Extended_Pictographic. */\n\n  if ((rgb != ucp_gbExtend && rgb != ucp_gbZWJ) ||\n       lgb != ucp_gbExtended_Pictographic)\n    lgb = rgb;\n\n  prevcc = endcc;\n  endcc = cc;\n  }\nwhile (cc < end_subject);\n\nreturn endcc;\n}\n\n#endif /* PCRE2_CODE_UNIT_WIDTH != 32 */\n\nstatic PCRE2_SPTR SLJIT_FUNC do_extuni_utf_invalid(jit_arguments *args, PCRE2_SPTR cc)\n{\nPCRE2_SPTR start_subject = args->begin;\nPCRE2_SPTR end_subject = args->end;\nint lgb, rgb, ricount;\nPCRE2_SPTR prevcc, endcc, bptr;\nBOOL first = TRUE;\nuint32_t c;\n\nprevcc = cc;\nendcc = NULL;\ndo\n  {\n  GETCHARINC_INVALID(c, cc, end_subject, break);\n  rgb = UCD_GRAPHBREAK(c);\n\n  if (first)\n    {\n    lgb = rgb;\n    endcc = cc;\n    first = FALSE;\n    continue;\n    }\n\n  if ((PRIV(ucp_gbtable)[lgb] & (1 << rgb)) == 0)\n    break;\n\n  /* Not breaking between Regional Indicators is allowed only if there\n  are an even number of preceding RIs. */\n\n  if (lgb == ucp_gbRegional_Indicator && rgb == ucp_gbRegional_Indicator)\n    {\n    ricount = 0;\n    bptr = prevcc;\n\n    /* bptr is pointing to the left-hand character */\n    while (bptr > start_subject)\n      {\n      GETCHARBACK_INVALID(c, bptr, start_subject, break);\n\n      if (UCD_GRAPHBREAK(c) != ucp_gbRegional_Indicator)\n        break;\n\n      ricount++;\n      }\n\n    if ((ricount & 1) != 0)\n      break;  /* Grapheme break required */\n    }\n\n  /* If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this\n  allows any number of them before a following Extended_Pictographic. */\n\n  if ((rgb != ucp_gbExtend && rgb != ucp_gbZWJ) ||\n       lgb != ucp_gbExtended_Pictographic)\n    lgb = rgb;\n\n  prevcc = endcc;\n  endcc = cc;\n  }\nwhile (cc < end_subject);\n\nreturn endcc;\n}\n\nstatic PCRE2_SPTR SLJIT_FUNC do_extuni_no_utf(jit_arguments *args, PCRE2_SPTR cc)\n{\nPCRE2_SPTR start_subject = args->begin;\nPCRE2_SPTR end_subject = args->end;\nint lgb, rgb, ricount;\nPCRE2_SPTR bptr;\nuint32_t c;\n\n/* Patch by PH */\n/* GETCHARINC(c, cc); */\nc = *cc++;\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\nif (c >= 0x110000)\n  return NULL;\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\nlgb = UCD_GRAPHBREAK(c);\n\nwhile (cc < end_subject)\n  {\n  c = *cc;\n#if PCRE2_CODE_UNIT_WIDTH == 32\n  if (c >= 0x110000)\n    break;\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n  rgb = UCD_GRAPHBREAK(c);\n\n  if ((PRIV(ucp_gbtable)[lgb] & (1 << rgb)) == 0)\n    break;\n\n  /* Not breaking between Regional Indicators is allowed only if there\n  are an even number of preceding RIs. */\n\n  if (lgb == ucp_gbRegional_Indicator && rgb == ucp_gbRegional_Indicator)\n    {\n    ricount = 0;\n    bptr = cc - 1;\n\n    /* bptr is pointing to the left-hand character */\n    while (bptr > start_subject)\n      {\n      bptr--;\n      c = *bptr;\n#if PCRE2_CODE_UNIT_WIDTH == 32\n      if (c >= 0x110000)\n        break;\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n      if (UCD_GRAPHBREAK(c) != ucp_gbRegional_Indicator) break;\n\n      ricount++;\n      }\n\n    if ((ricount & 1) != 0)\n      break;  /* Grapheme break required */\n    }\n\n  /* If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this\n  allows any number of them before a following Extended_Pictographic. */\n\n  if ((rgb != ucp_gbExtend && rgb != ucp_gbZWJ) ||\n       lgb != ucp_gbExtended_Pictographic)\n    lgb = rgb;\n\n  cc++;\n  }\n\nreturn cc;\n}\n\n#endif /* SUPPORT_UNICODE */\n\nstatic PCRE2_SPTR compile_char1_matchingpath(compiler_common *common, PCRE2_UCHAR type, PCRE2_SPTR cc, jump_list **backtracks, BOOL check_str_ptr)\n{\nDEFINE_COMPILER;\nint length;\nunsigned int c, oc, bit;\ncompare_context context;\nstruct sljit_jump *jump[3];\njump_list *end_list;\n#ifdef SUPPORT_UNICODE\nPCRE2_UCHAR propdata[5];\n#endif /* SUPPORT_UNICODE */\n\nswitch(type)\n  {\n  case OP_NOT_DIGIT:\n  case OP_DIGIT:\n  /* Digits are usually 0-9, so it is worth to optimize them. */\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  if (common->utf && is_char7_bitset((const sljit_u8*)common->ctypes - cbit_length + cbit_digit, FALSE))\n    read_char7_type(common, backtracks, type == OP_NOT_DIGIT);\n  else\n#endif\n    read_char8_type(common, backtracks, type == OP_NOT_DIGIT);\n    /* Flip the starting bit in the negative case. */\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, ctype_digit);\n  add_jump(compiler, backtracks, JUMP(type == OP_DIGIT ? SLJIT_ZERO : SLJIT_NOT_ZERO));\n  return cc;\n\n  case OP_NOT_WHITESPACE:\n  case OP_WHITESPACE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  if (common->utf && is_char7_bitset((const sljit_u8*)common->ctypes - cbit_length + cbit_space, FALSE))\n    read_char7_type(common, backtracks, type == OP_NOT_WHITESPACE);\n  else\n#endif\n    read_char8_type(common, backtracks, type == OP_NOT_WHITESPACE);\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, ctype_space);\n  add_jump(compiler, backtracks, JUMP(type == OP_WHITESPACE ? SLJIT_ZERO : SLJIT_NOT_ZERO));\n  return cc;\n\n  case OP_NOT_WORDCHAR:\n  case OP_WORDCHAR:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  if (common->utf && is_char7_bitset((const sljit_u8*)common->ctypes - cbit_length + cbit_word, FALSE))\n    read_char7_type(common, backtracks, type == OP_NOT_WORDCHAR);\n  else\n#endif\n    read_char8_type(common, backtracks, type == OP_NOT_WORDCHAR);\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, ctype_word);\n  add_jump(compiler, backtracks, JUMP(type == OP_WORDCHAR ? SLJIT_ZERO : SLJIT_NOT_ZERO));\n  return cc;\n\n  case OP_ANY:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  read_char(common, common->nlmin, common->nlmax, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  if (common->nltype == NLTYPE_FIXED && common->newline > 255)\n    {\n    jump[0] = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff);\n    end_list = NULL;\n    if (common->mode != PCRE2_JIT_PARTIAL_HARD)\n      add_jump(compiler, &end_list, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n    else\n      check_str_end(common, &end_list);\n\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, common->newline & 0xff));\n    set_jumps(end_list, LABEL());\n    JUMPHERE(jump[0]);\n    }\n  else\n    check_newlinechar(common, common->nltype, backtracks, TRUE);\n  return cc;\n\n  case OP_ALLANY:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n    if (common->invalid_utf)\n      {\n      read_char(common, 0, READ_CHAR_MAX, backtracks, READ_CHAR_UPDATE_STR_PTR);\n      return cc;\n      }\n\n#if PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    jump[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n#elif PCRE2_CODE_UNIT_WIDTH == 16\n    jump[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, 0xfc00);\n    OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0xd800);\n    OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_EQUAL);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n    JUMPHERE(jump[0]);\n    return cc;\n#endif /* PCRE2_CODE_UNIT_WIDTH == [8|16] */\n    }\n#endif /* SUPPORT_UNICODE */\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  return cc;\n\n  case OP_ANYBYTE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  return cc;\n\n#ifdef SUPPORT_UNICODE\n  case OP_NOTPROP:\n  case OP_PROP:\n  propdata[0] = XCL_HASPROP;\n  propdata[1] = type == OP_NOTPROP ? XCL_NOTPROP : XCL_PROP;\n  propdata[2] = cc[0];\n  propdata[3] = cc[1];\n  propdata[4] = XCL_END;\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  compile_xclass_matchingpath(common, propdata, backtracks);\n  return cc + 2;\n#endif\n\n  case OP_ANYNL:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  read_char(common, common->bsr_nlmin, common->bsr_nlmax, NULL, 0);\n  jump[0] = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);\n  /* We don't need to handle soft partial matching case. */\n  end_list = NULL;\n  if (common->mode != PCRE2_JIT_PARTIAL_HARD)\n    add_jump(compiler, &end_list, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n  else\n    check_str_end(common, &end_list);\n  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n  jump[1] = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  jump[2] = JUMP(SLJIT_JUMP);\n  JUMPHERE(jump[0]);\n  check_newlinechar(common, common->bsr_nltype, backtracks, FALSE);\n  set_jumps(end_list, LABEL());\n  JUMPHERE(jump[1]);\n  JUMPHERE(jump[2]);\n  return cc;\n\n  case OP_NOT_HSPACE:\n  case OP_HSPACE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  if (type == OP_NOT_HSPACE)\n    read_char(common, 0x9, 0x3000, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0x9, 0x3000, NULL, 0);\n\n  add_jump(compiler, &common->hspace, JUMP(SLJIT_FAST_CALL));\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(type == OP_NOT_HSPACE ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  return cc;\n\n  case OP_NOT_VSPACE:\n  case OP_VSPACE:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  if (type == OP_NOT_VSPACE)\n    read_char(common, 0xa, 0x2029, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0xa, 0x2029, NULL, 0);\n\n  add_jump(compiler, &common->vspace, JUMP(SLJIT_FAST_CALL));\n  sljit_set_current_flags(compiler, SLJIT_SET_Z);\n  add_jump(compiler, backtracks, JUMP(type == OP_NOT_VSPACE ? SLJIT_NOT_ZERO : SLJIT_ZERO));\n  return cc;\n\n#ifdef SUPPORT_UNICODE\n  case OP_EXTUNI:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  SLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n  OP1(SLJIT_MOV, SLJIT_R0, 0, ARGUMENTS, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH != 32\n  sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM,\n    common->utf ? (common->invalid_utf ? SLJIT_FUNC_ADDR(do_extuni_utf_invalid) : SLJIT_FUNC_ADDR(do_extuni_utf)) : SLJIT_FUNC_ADDR(do_extuni_no_utf));\n  if (common->invalid_utf)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0));\n#else\n  sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM,\n    common->invalid_utf ? SLJIT_FUNC_ADDR(do_extuni_utf_invalid) : SLJIT_FUNC_ADDR(do_extuni_no_utf));\n  if (!common->utf || common->invalid_utf)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0));\n#endif\n\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_RETURN_REG, 0);\n\n  if (common->mode == PCRE2_JIT_PARTIAL_HARD)\n    {\n    jump[0] = CMP(SLJIT_LESS, SLJIT_RETURN_REG, 0, STR_END, 0);\n    /* Since we successfully read a char above, partial matching must occure. */\n    check_partial(common, TRUE);\n    JUMPHERE(jump[0]);\n    }\n  return cc;\n#endif\n\n  case OP_CHAR:\n  case OP_CHARI:\n  length = 1;\n#ifdef SUPPORT_UNICODE\n  if (common->utf && HAS_EXTRALEN(*cc)) length += GET_EXTRALEN(*cc);\n#endif\n\n  if (check_str_ptr && common->mode != PCRE2_JIT_COMPLETE)\n    detect_partial_match(common, backtracks);\n\n  if (type == OP_CHAR || !char_has_othercase(common, cc) || char_get_othercase_bit(common, cc) != 0)\n    {\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(length));\n    if (length > 1 || (check_str_ptr && common->mode == PCRE2_JIT_COMPLETE))\n      add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0));\n\n    context.length = IN_UCHARS(length);\n    context.sourcereg = -1;\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n    context.ucharptr = 0;\n#endif\n    return byte_sequence_compare(common, type == OP_CHARI, cc, &context, backtracks);\n    }\n\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n    GETCHAR(c, cc);\n    }\n  else\n#endif\n    c = *cc;\n\n  SLJIT_ASSERT(type == OP_CHARI && char_has_othercase(common, cc));\n\n  if (check_str_ptr && common->mode == PCRE2_JIT_COMPLETE)\n    add_jump(compiler, backtracks, CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0));\n\n  oc = char_othercase(common, c);\n  read_char(common, c < oc ? c : oc, c > oc ? c : oc, NULL, 0);\n\n  SLJIT_ASSERT(!is_powerof2(c ^ oc));\n\n  if (sljit_has_cpu_feature(SLJIT_HAS_CMOV))\n    {\n    OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, oc);\n    CMOV(SLJIT_EQUAL, TMP1, SLJIT_IMM, c);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n    }\n  else\n    {\n    jump[0] = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c);\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, oc));\n    JUMPHERE(jump[0]);\n    }\n  return cc + length;\n\n  case OP_NOT:\n  case OP_NOTI:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n  length = 1;\n#ifdef SUPPORT_UNICODE\n  if (common->utf)\n    {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    c = *cc;\n    if (c < 128 && !common->invalid_utf)\n      {\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);\n      if (type == OP_NOT || !char_has_othercase(common, cc))\n        add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n      else\n        {\n        /* Since UTF8 code page is fixed, we know that c is in [a-z] or [A-Z] range. */\n        OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x20);\n        add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, c | 0x20));\n        }\n      /* Skip the variable-length character. */\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      jump[0] = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, 0xc0);\n      OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(utf8_table4) - 0xc0);\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP1, 0);\n      JUMPHERE(jump[0]);\n      return cc + 1;\n      }\n    else\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      {\n      GETCHARLEN(c, cc, length);\n      }\n    }\n  else\n#endif /* SUPPORT_UNICODE */\n    c = *cc;\n\n  if (type == OP_NOT || !char_has_othercase(common, cc))\n    {\n    read_char(common, c, c, backtracks, READ_CHAR_UPDATE_STR_PTR);\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n    }\n  else\n    {\n    oc = char_othercase(common, c);\n    read_char(common, c < oc ? c : oc, c > oc ? c : oc, backtracks, READ_CHAR_UPDATE_STR_PTR);\n    bit = c ^ oc;\n    if (is_powerof2(bit))\n      {\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, bit);\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c | bit));\n      }\n    else\n      {\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, c));\n      add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, oc));\n      }\n    }\n  return cc + length;\n\n  case OP_CLASS:\n  case OP_NCLASS:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  bit = (common->utf && is_char7_bitset((const sljit_u8 *)cc, type == OP_NCLASS)) ? 127 : 255;\n  if (type == OP_NCLASS)\n    read_char(common, 0, bit, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0, bit, NULL, 0);\n#else\n  if (type == OP_NCLASS)\n    read_char(common, 0, 255, backtracks, READ_CHAR_UPDATE_STR_PTR);\n  else\n    read_char(common, 0, 255, NULL, 0);\n#endif\n\n  if (optimize_class(common, (const sljit_u8 *)cc, type == OP_NCLASS, FALSE, backtracks))\n    return cc + 32 / sizeof(PCRE2_UCHAR);\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8\n  jump[0] = NULL;\n  if (common->utf)\n    {\n    jump[0] = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, bit);\n    if (type == OP_CLASS)\n      {\n      add_jump(compiler, backtracks, jump[0]);\n      jump[0] = NULL;\n      }\n    }\n#elif PCRE2_CODE_UNIT_WIDTH != 8\n  jump[0] = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n  if (type == OP_CLASS)\n    {\n    add_jump(compiler, backtracks, jump[0]);\n    jump[0] = NULL;\n    }\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == 8 */\n\n  OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n  OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n  OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n  OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n  add_jump(compiler, backtracks, JUMP(SLJIT_ZERO));\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n  if (jump[0] != NULL)\n    JUMPHERE(jump[0]);\n#endif\n  return cc + 32 / sizeof(PCRE2_UCHAR);\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n  case OP_XCLASS:\n  if (check_str_ptr)\n    detect_partial_match(common, backtracks);\n  compile_xclass_matchingpath(common, cc + LINK_SIZE, backtracks);\n  return cc + GET(cc, 0) - 1;\n#endif\n  }\nSLJIT_UNREACHABLE();\nreturn cc;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_charn_matchingpath(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, jump_list **backtracks)\n{\n/* This function consumes at least one input character. */\n/* To decrease the number of length checks, we try to concatenate the fixed length character sequences. */\nDEFINE_COMPILER;\nPCRE2_SPTR ccbegin = cc;\ncompare_context context;\nint size;\n\ncontext.length = 0;\ndo\n  {\n  if (cc >= ccend)\n    break;\n\n  if (*cc == OP_CHAR)\n    {\n    size = 1;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[1]))\n      size += GET_EXTRALEN(cc[1]);\n#endif\n    }\n  else if (*cc == OP_CHARI)\n    {\n    size = 1;\n#ifdef SUPPORT_UNICODE\n    if (common->utf)\n      {\n      if (char_has_othercase(common, cc + 1) && char_get_othercase_bit(common, cc + 1) == 0)\n        size = 0;\n      else if (HAS_EXTRALEN(cc[1]))\n        size += GET_EXTRALEN(cc[1]);\n      }\n    else\n#endif\n    if (char_has_othercase(common, cc + 1) && char_get_othercase_bit(common, cc + 1) == 0)\n      size = 0;\n    }\n  else\n    size = 0;\n\n  cc += 1 + size;\n  context.length += IN_UCHARS(size);\n  }\nwhile (size > 0 && context.length <= 128);\n\ncc = ccbegin;\nif (context.length > 0)\n  {\n  /* We have a fixed-length byte sequence. */\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, context.length);\n  add_jump(compiler, backtracks, CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0));\n\n  context.sourcereg = -1;\n#if defined SLJIT_UNALIGNED && SLJIT_UNALIGNED\n  context.ucharptr = 0;\n#endif\n  do cc = byte_sequence_compare(common, *cc == OP_CHARI, cc + 1, &context, backtracks); while (context.length > 0);\n  return cc;\n  }\n\n/* A non-fixed length character will be checked if length == 0. */\nreturn compile_char1_matchingpath(common, *cc, cc + 1, backtracks, TRUE);\n}\n\n/* Forward definitions. */\nstatic void compile_matchingpath(compiler_common *, PCRE2_SPTR, PCRE2_SPTR, backtrack_common *);\nstatic void compile_backtrackingpath(compiler_common *, struct backtrack_common *);\n\n#define PUSH_BACKTRACK(size, ccstart, error) \\\n  do \\\n    { \\\n    backtrack = sljit_alloc_memory(compiler, (size)); \\\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \\\n      return error; \\\n    memset(backtrack, 0, size); \\\n    backtrack->prev = parent->top; \\\n    backtrack->cc = (ccstart); \\\n    parent->top = backtrack; \\\n    } \\\n  while (0)\n\n#define PUSH_BACKTRACK_NOVALUE(size, ccstart) \\\n  do \\\n    { \\\n    backtrack = sljit_alloc_memory(compiler, (size)); \\\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \\\n      return; \\\n    memset(backtrack, 0, size); \\\n    backtrack->prev = parent->top; \\\n    backtrack->cc = (ccstart); \\\n    parent->top = backtrack; \\\n    } \\\n  while (0)\n\n#define BACKTRACK_AS(type) ((type *)backtrack)\n\nstatic void compile_dnref_search(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks)\n{\n/* The OVECTOR offset goes to TMP2. */\nDEFINE_COMPILER;\nint count = GET2(cc, 1 + IMM2_SIZE);\nPCRE2_SPTR slot = common->name_table + GET2(cc, 1) * common->name_entry_size;\nunsigned int offset;\njump_list *found = NULL;\n\nSLJIT_ASSERT(*cc == OP_DNREF || *cc == OP_DNREFI);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\n\ncount--;\nwhile (count-- > 0)\n  {\n  offset = GET2(slot, 0) << 1;\n  GET_LOCAL_BASE(TMP2, 0, OVECTOR(offset));\n  add_jump(compiler, &found, CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0));\n  slot += common->name_entry_size;\n  }\n\noffset = GET2(slot, 0) << 1;\nGET_LOCAL_BASE(TMP2, 0, OVECTOR(offset));\nif (backtracks != NULL && !common->unset_backref)\n  add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0));\n\nset_jumps(found, LABEL());\n}\n\nstatic void compile_ref_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks, BOOL withchecks, BOOL emptyfail)\n{\nDEFINE_COMPILER;\nBOOL ref = (*cc == OP_REF || *cc == OP_REFI);\nint offset = 0;\nstruct sljit_jump *jump = NULL;\nstruct sljit_jump *partial;\nstruct sljit_jump *nopartial;\n#if defined SUPPORT_UNICODE\nstruct sljit_label *loop;\nstruct sljit_label *caseless_loop;\njump_list *no_match = NULL;\nint source_reg = COUNT_MATCH;\nint source_end_reg = ARGUMENTS;\nint char1_reg = STACK_LIMIT;\n#endif /* SUPPORT_UNICODE */\n\nif (ref)\n  {\n  offset = GET2(cc, 1) << 1;\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n  /* OVECTOR(1) contains the \"string begin - 1\" constant. */\n  if (withchecks && !common->unset_backref)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n  }\nelse\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n\n#if defined SUPPORT_UNICODE\nif (common->utf && *cc == OP_REFI)\n  {\n  SLJIT_ASSERT(common->iref_ptr != 0);\n\n  if (ref)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n  else\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n\n  if (withchecks && emptyfail)\n    add_jump(compiler, backtracks, CMP(SLJIT_EQUAL, TMP1, 0, TMP2, 0));\n\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->iref_ptr, source_reg, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw), source_end_reg, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2, char1_reg, 0);\n\n  OP1(SLJIT_MOV, source_reg, 0, TMP1, 0);\n  OP1(SLJIT_MOV, source_end_reg, 0, TMP2, 0);\n\n  loop = LABEL();\n  jump = CMP(SLJIT_GREATER_EQUAL, source_reg, 0, source_end_reg, 0);\n  partial = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);\n\n  /* Read original character. It must be a valid UTF character. */\n  OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n  OP1(SLJIT_MOV, STR_PTR, 0, source_reg, 0);\n\n  read_char(common, 0, READ_CHAR_MAX, NULL, READ_CHAR_UPDATE_STR_PTR | READ_CHAR_VALID_UTF);\n\n  OP1(SLJIT_MOV, source_reg, 0, STR_PTR, 0);\n  OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n  OP1(SLJIT_MOV, char1_reg, 0, TMP1, 0);\n\n  /* Read second character. */\n  read_char(common, 0, READ_CHAR_MAX, &no_match, READ_CHAR_UPDATE_STR_PTR);\n\n  CMPTO(SLJIT_EQUAL, TMP1, 0, char1_reg, 0, loop);\n\n  OP1(SLJIT_MOV, TMP3, 0, TMP1, 0);\n\n  add_jump(compiler, &common->getucd, JUMP(SLJIT_FAST_CALL));\n\n  OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 3);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_records));\n\n  OP1(SLJIT_MOV_S32, TMP1, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(ucd_record, other_case));\n  OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(ucd_record, caseset));\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP3, 0);\n  CMPTO(SLJIT_EQUAL, TMP1, 0, char1_reg, 0, loop);\n\n  add_jump(compiler, &no_match, CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_caseless_sets));\n\n  caseless_loop = LABEL();\n  OP1(SLJIT_MOV_U32, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, SLJIT_IMM, sizeof(uint32_t));\n  OP2U(SLJIT_SUB | SLJIT_SET_Z | SLJIT_SET_LESS, TMP1, 0, char1_reg, 0);\n  JUMPTO(SLJIT_EQUAL, loop);\n  JUMPTO(SLJIT_LESS, caseless_loop);\n\n  set_jumps(no_match, LABEL());\n  if (common->mode == PCRE2_JIT_COMPLETE)\n    JUMPHERE(partial);\n\n  OP1(SLJIT_MOV, source_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr);\n  OP1(SLJIT_MOV, source_end_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw));\n  OP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2);\n  add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    {\n    JUMPHERE(partial);\n    OP1(SLJIT_MOV, source_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr);\n    OP1(SLJIT_MOV, source_end_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2);\n\n    check_partial(common, FALSE);\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    }\n\n  JUMPHERE(jump);\n  OP1(SLJIT_MOV, source_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr);\n  OP1(SLJIT_MOV, source_end_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw));\n  OP1(SLJIT_MOV, char1_reg, 0, SLJIT_MEM1(SLJIT_SP), common->iref_ptr + sizeof(sljit_sw) * 2);\n  return;\n  }\nelse\n#endif /* SUPPORT_UNICODE */\n  {\n  if (ref)\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP1, 0);\n  else\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw), TMP1, 0);\n\n  if (withchecks)\n    jump = JUMP(SLJIT_ZERO);\n\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, TMP2, 0);\n  partial = CMP(SLJIT_GREATER, STR_PTR, 0, STR_END, 0);\n  if (common->mode == PCRE2_JIT_COMPLETE)\n    add_jump(compiler, backtracks, partial);\n\n  add_jump(compiler, *cc == OP_REF ? &common->casefulcmp : &common->caselesscmp, JUMP(SLJIT_FAST_CALL));\n  add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n\n  if (common->mode != PCRE2_JIT_COMPLETE)\n    {\n    nopartial = JUMP(SLJIT_JUMP);\n    JUMPHERE(partial);\n    /* TMP2 -= STR_END - STR_PTR */\n    OP2(SLJIT_SUB, TMP2, 0, TMP2, 0, STR_PTR, 0);\n    OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, STR_END, 0);\n    partial = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, STR_PTR, 0, STR_END, 0);\n    add_jump(compiler, *cc == OP_REF ? &common->casefulcmp : &common->caselesscmp, JUMP(SLJIT_FAST_CALL));\n    add_jump(compiler, backtracks, CMP(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, 0));\n    JUMPHERE(partial);\n    check_partial(common, FALSE);\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    JUMPHERE(nopartial);\n    }\n  }\n\nif (jump != NULL)\n  {\n  if (emptyfail)\n    add_jump(compiler, backtracks, jump);\n  else\n    JUMPHERE(jump);\n  }\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_ref_iterator_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nBOOL ref = (*cc == OP_REF || *cc == OP_REFI);\nbacktrack_common *backtrack;\nPCRE2_UCHAR type;\nint offset = 0;\nstruct sljit_label *label;\nstruct sljit_jump *zerolength;\nstruct sljit_jump *jump = NULL;\nPCRE2_SPTR ccbegin = cc;\nint min = 0, max = 0;\nBOOL minimize;\n\nPUSH_BACKTRACK(sizeof(ref_iterator_backtrack), cc, NULL);\n\nif (ref)\n  offset = GET2(cc, 1) << 1;\nelse\n  cc += IMM2_SIZE;\ntype = cc[1 + IMM2_SIZE];\n\nSLJIT_COMPILE_ASSERT((OP_CRSTAR & 0x1) == 0, crstar_opcode_must_be_even);\nminimize = (type & 0x1) != 0;\nswitch(type)\n  {\n  case OP_CRSTAR:\n  case OP_CRMINSTAR:\n  min = 0;\n  max = 0;\n  cc += 1 + IMM2_SIZE + 1;\n  break;\n  case OP_CRPLUS:\n  case OP_CRMINPLUS:\n  min = 1;\n  max = 0;\n  cc += 1 + IMM2_SIZE + 1;\n  break;\n  case OP_CRQUERY:\n  case OP_CRMINQUERY:\n  min = 0;\n  max = 1;\n  cc += 1 + IMM2_SIZE + 1;\n  break;\n  case OP_CRRANGE:\n  case OP_CRMINRANGE:\n  min = GET2(cc, 1 + IMM2_SIZE + 1);\n  max = GET2(cc, 1 + IMM2_SIZE + 1 + IMM2_SIZE);\n  cc += 1 + IMM2_SIZE + 1 + 2 * IMM2_SIZE;\n  break;\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\nif (!minimize)\n  {\n  if (min == 0)\n    {\n    allocate_stack(common, 2);\n    if (ref)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 0);\n    /* Temporary release of STR_PTR. */\n    OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n    /* Handles both invalid and empty cases. Since the minimum repeat,\n    is zero the invalid case is basically the same as an empty case. */\n    if (ref)\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    else\n      {\n      compile_dnref_search(common, ccbegin, NULL);\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, TMP2, 0);\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n      }\n    /* Restore if not zero length. */\n    OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n    }\n  else\n    {\n    allocate_stack(common, 1);\n    if (ref)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n    if (ref)\n      {\n      add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n      }\n    else\n      {\n      compile_dnref_search(common, ccbegin, &backtrack->topbacktracks);\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, TMP2, 0);\n      zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n      }\n    }\n\n  if (min > 1 || max > 1)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, SLJIT_IMM, 0);\n\n  label = LABEL();\n  if (!ref)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1);\n  compile_ref_matchingpath(common, ccbegin, &backtrack->topbacktracks, FALSE, FALSE);\n\n  if (min > 1 || max > 1)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0);\n    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, TMP1, 0);\n    if (min > 1)\n      CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, min, label);\n    if (max > 1)\n      {\n      jump = CMP(SLJIT_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, max);\n      allocate_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      JUMPTO(SLJIT_JUMP, label);\n      JUMPHERE(jump);\n      }\n    }\n\n  if (max == 0)\n    {\n    /* Includes min > 1 case as well. */\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    JUMPTO(SLJIT_JUMP, label);\n    }\n\n  JUMPHERE(zerolength);\n  BACKTRACK_AS(ref_iterator_backtrack)->matchingpath = LABEL();\n\n  count_match(common);\n  return cc;\n  }\n\nallocate_stack(common, ref ? 2 : 3);\nif (ref)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\nif (type != OP_CRMINSTAR)\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 0);\n\nif (min == 0)\n  {\n  /* Handles both invalid and empty cases. Since the minimum repeat,\n  is zero the invalid case is basically the same as an empty case. */\n  if (ref)\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n  else\n    {\n    compile_dnref_search(common, ccbegin, NULL);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP2, 0);\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n    }\n  /* Length is non-zero, we can match real repeats. */\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n  jump = JUMP(SLJIT_JUMP);\n  }\nelse\n  {\n  if (ref)\n    {\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    }\n  else\n    {\n    compile_dnref_search(common, ccbegin, &backtrack->topbacktracks);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP2, 0);\n    zerolength = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_MEM1(TMP2), sizeof(sljit_sw));\n    }\n  }\n\nBACKTRACK_AS(ref_iterator_backtrack)->matchingpath = LABEL();\nif (max > 0)\n  add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_GREATER_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, max));\n\nif (!ref)\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(2));\ncompile_ref_matchingpath(common, ccbegin, &backtrack->topbacktracks, TRUE, TRUE);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\nif (min > 1)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0);\n  CMPTO(SLJIT_LESS, TMP1, 0, SLJIT_IMM, min, BACKTRACK_AS(ref_iterator_backtrack)->matchingpath);\n  }\nelse if (max > 0)\n  OP2(SLJIT_ADD, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 1);\n\nif (jump != NULL)\n  JUMPHERE(jump);\nJUMPHERE(zerolength);\n\ncount_match(common);\nreturn cc;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_recurse_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nrecurse_entry *entry = common->entries;\nrecurse_entry *prev = NULL;\nsljit_sw start = GET(cc, 1);\nPCRE2_SPTR start_cc;\nBOOL needs_control_head;\n\nPUSH_BACKTRACK(sizeof(recurse_backtrack), cc, NULL);\n\n/* Inlining simple patterns. */\nif (get_framesize(common, common->start + start, NULL, TRUE, &needs_control_head) == no_stack)\n  {\n  start_cc = common->start + start;\n  compile_matchingpath(common, next_opcode(common, start_cc), bracketend(start_cc) - (1 + LINK_SIZE), backtrack);\n  BACKTRACK_AS(recurse_backtrack)->inlined_pattern = TRUE;\n  return cc + 1 + LINK_SIZE;\n  }\n\nwhile (entry != NULL)\n  {\n  if (entry->start == start)\n    break;\n  prev = entry;\n  entry = entry->next;\n  }\n\nif (entry == NULL)\n  {\n  entry = sljit_alloc_memory(compiler, sizeof(recurse_entry));\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return NULL;\n  entry->next = NULL;\n  entry->entry_label = NULL;\n  entry->backtrack_label = NULL;\n  entry->entry_calls = NULL;\n  entry->backtrack_calls = NULL;\n  entry->start = start;\n\n  if (prev != NULL)\n    prev->next = entry;\n  else\n    common->entries = entry;\n  }\n\nBACKTRACK_AS(recurse_backtrack)->entry = entry;\n\nif (entry->entry_label == NULL)\n  add_jump(compiler, &entry->entry_calls, JUMP(SLJIT_FAST_CALL));\nelse\n  JUMPTO(SLJIT_FAST_CALL, entry->entry_label);\n/* Leave if the match is failed. */\nadd_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0));\nBACKTRACK_AS(recurse_backtrack)->matchingpath = LABEL();\nreturn cc + 1 + LINK_SIZE;\n}\n\nstatic sljit_s32 SLJIT_FUNC do_callout(struct jit_arguments *arguments, pcre2_callout_block *callout_block, PCRE2_SPTR *jit_ovector)\n{\nPCRE2_SPTR begin;\nPCRE2_SIZE *ovector;\nsljit_u32 oveccount, capture_top;\n\nif (arguments->callout == NULL)\n  return 0;\n\nSLJIT_COMPILE_ASSERT(sizeof (PCRE2_SIZE) <= sizeof (sljit_sw), pcre2_size_must_be_lower_than_sljit_sw_size);\n\nbegin = arguments->begin;\novector = (PCRE2_SIZE*)(callout_block + 1);\noveccount = callout_block->capture_top;\n\nSLJIT_ASSERT(oveccount >= 1);\n\ncallout_block->version = 2;\ncallout_block->callout_flags = 0;\n\n/* Offsets in subject. */\ncallout_block->subject_length = arguments->end - arguments->begin;\ncallout_block->start_match = jit_ovector[0] - begin;\ncallout_block->current_position = (PCRE2_SPTR)callout_block->offset_vector - begin;\ncallout_block->subject = begin;\n\n/* Convert and copy the JIT offset vector to the ovector array. */\ncallout_block->capture_top = 1;\ncallout_block->offset_vector = ovector;\n\novector[0] = PCRE2_UNSET;\novector[1] = PCRE2_UNSET;\novector += 2;\njit_ovector += 2;\ncapture_top = 1;\n\n/* Convert pointers to sizes. */\nwhile (--oveccount != 0)\n  {\n  capture_top++;\n\n  ovector[0] = (PCRE2_SIZE)(jit_ovector[0] - begin);\n  ovector[1] = (PCRE2_SIZE)(jit_ovector[1] - begin);\n\n  if (ovector[0] != PCRE2_UNSET)\n    callout_block->capture_top = capture_top;\n\n  ovector += 2;\n  jit_ovector += 2;\n  }\n\nreturn (arguments->callout)(callout_block, arguments->callout_data);\n}\n\n#define CALLOUT_ARG_OFFSET(arg) \\\n    SLJIT_OFFSETOF(pcre2_callout_block, arg)\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_callout_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nsljit_s32 mov_opcode;\nunsigned int callout_length = (*cc == OP_CALLOUT)\n    ? PRIV(OP_lengths)[OP_CALLOUT] : GET(cc, 1 + 2 * LINK_SIZE);\nsljit_sw value1;\nsljit_sw value2;\nsljit_sw value3;\nsljit_uw callout_arg_size = (common->re->top_bracket + 1) * 2 * sizeof(sljit_sw);\n\nPUSH_BACKTRACK(sizeof(backtrack_common), cc, NULL);\n\ncallout_arg_size = (sizeof(pcre2_callout_block) + callout_arg_size + sizeof(sljit_sw) - 1) / sizeof(sljit_sw);\n\nallocate_stack(common, callout_arg_size);\n\nSLJIT_ASSERT(common->capture_last_ptr != 0);\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\nOP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\nvalue1 = (*cc == OP_CALLOUT) ? cc[1 + 2 * LINK_SIZE] : 0;\nOP1(SLJIT_MOV_U32, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_number), SLJIT_IMM, value1);\nOP1(SLJIT_MOV_U32, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(capture_last), TMP2, 0);\nOP1(SLJIT_MOV_U32, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(capture_top), SLJIT_IMM, common->re->top_bracket + 1);\n\n/* These pointer sized fields temporarly stores internal variables. */\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(offset_vector), STR_PTR, 0);\n\nif (common->mark_ptr != 0)\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, mark_ptr));\nmov_opcode = (sizeof(PCRE2_SIZE) == 4) ? SLJIT_MOV_U32 : SLJIT_MOV;\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(pattern_position), SLJIT_IMM, GET(cc, 1));\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(next_item_length), SLJIT_IMM, GET(cc, 1 + LINK_SIZE));\n\nif (*cc == OP_CALLOUT)\n  {\n  value1 = 0;\n  value2 = 0;\n  value3 = 0;\n  }\nelse\n  {\n  value1 = (sljit_sw) (cc + (1 + 4*LINK_SIZE) + 1);\n  value2 = (callout_length - (1 + 4*LINK_SIZE + 2));\n  value3 = (sljit_sw) (GET(cc, 1 + 3*LINK_SIZE));\n  }\n\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_string), SLJIT_IMM, value1);\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_string_length), SLJIT_IMM, value2);\nOP1(mov_opcode, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(callout_string_offset), SLJIT_IMM, value3);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), CALLOUT_ARG_OFFSET(mark), (common->mark_ptr != 0) ? TMP2 : SLJIT_IMM, 0);\n\nSLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n\n/* Needed to save important temporary registers. */\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, STR_PTR, 0);\n/* SLJIT_R0 = arguments */\nOP1(SLJIT_MOV, SLJIT_R1, 0, STACK_TOP, 0);\nGET_LOCAL_BASE(SLJIT_R2, 0, OVECTOR_START);\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS3(32, W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(do_callout));\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nfree_stack(common, callout_arg_size);\n\n/* Check return value. */\nOP2U(SLJIT_SUB32 | SLJIT_SET_Z | SLJIT_SET_SIG_GREATER, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0);\nadd_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_SIG_GREATER));\nif (common->abort_label == NULL)\n  add_jump(compiler, &common->abort, JUMP(SLJIT_NOT_EQUAL) /* SIG_LESS */);\nelse\n  JUMPTO(SLJIT_NOT_EQUAL /* SIG_LESS */, common->abort_label);\nreturn cc + callout_length;\n}\n\n#undef CALLOUT_ARG_SIZE\n#undef CALLOUT_ARG_OFFSET\n\nstatic SLJIT_INLINE BOOL assert_needs_str_ptr_saving(PCRE2_SPTR cc)\n{\nwhile (TRUE)\n  {\n  switch (*cc)\n    {\n    case OP_CALLOUT_STR:\n    cc += GET(cc, 1 + 2*LINK_SIZE);\n    break;\n\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_DOLL:\n    case OP_DOLLM:\n    case OP_CALLOUT:\n    case OP_ALT:\n    cc += PRIV(OP_lengths)[*cc];\n    break;\n\n    case OP_KET:\n    return FALSE;\n\n    default:\n    return TRUE;\n    }\n  }\n}\n\nstatic PCRE2_SPTR compile_assert_matchingpath(compiler_common *common, PCRE2_SPTR cc, assert_backtrack *backtrack, BOOL conditional)\n{\nDEFINE_COMPILER;\nint framesize;\nint extrasize;\nBOOL local_quit_available = FALSE;\nBOOL needs_control_head;\nint private_data_ptr;\nbacktrack_common altbacktrack;\nPCRE2_SPTR ccbegin;\nPCRE2_UCHAR opcode;\nPCRE2_UCHAR bra = OP_BRA;\njump_list *tmp = NULL;\njump_list **target = (conditional) ? &backtrack->condfailed : &backtrack->common.topbacktracks;\njump_list **found;\n/* Saving previous accept variables. */\nBOOL save_local_quit_available = common->local_quit_available;\nBOOL save_in_positive_assertion = common->in_positive_assertion;\nthen_trap_backtrack *save_then_trap = common->then_trap;\nstruct sljit_label *save_quit_label = common->quit_label;\nstruct sljit_label *save_accept_label = common->accept_label;\njump_list *save_quit = common->quit;\njump_list *save_positive_assertion_quit = common->positive_assertion_quit;\njump_list *save_accept = common->accept;\nstruct sljit_jump *jump;\nstruct sljit_jump *brajump = NULL;\n\n/* Assert captures then. */\ncommon->then_trap = NULL;\n\nif (*cc == OP_BRAZERO || *cc == OP_BRAMINZERO)\n  {\n  SLJIT_ASSERT(!conditional);\n  bra = *cc;\n  cc++;\n  }\nprivate_data_ptr = PRIVATE_DATA(cc);\nSLJIT_ASSERT(private_data_ptr != 0);\nframesize = get_framesize(common, cc, NULL, FALSE, &needs_control_head);\nbacktrack->framesize = framesize;\nbacktrack->private_data_ptr = private_data_ptr;\nopcode = *cc;\nSLJIT_ASSERT(opcode >= OP_ASSERT && opcode <= OP_ASSERTBACK_NOT);\nfound = (opcode == OP_ASSERT || opcode == OP_ASSERTBACK) ? &tmp : target;\nccbegin = cc;\ncc += GET(cc, 1);\n\nif (bra == OP_BRAMINZERO)\n  {\n  /* This is a braminzero backtrack path. */\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  brajump = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n  }\n\nif (framesize < 0)\n  {\n  extrasize = 1;\n  if (bra == OP_BRA && !assert_needs_str_ptr_saving(ccbegin + 1 + LINK_SIZE))\n    extrasize = 0;\n\n  if (needs_control_head)\n    extrasize++;\n\n  if (framesize == no_frame)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0);\n\n  if (extrasize > 0)\n    allocate_stack(common, extrasize);\n\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n\n  if (extrasize > 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\n  if (needs_control_head)\n    {\n    SLJIT_ASSERT(extrasize == 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0);\n    }\n  }\nelse\n  {\n  extrasize = needs_control_head ? 3 : 2;\n  allocate_stack(common, framesize + extrasize);\n\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  OP2(SLJIT_ADD, TMP2, 0, STACK_TOP, 0, SLJIT_IMM, (framesize + extrasize) * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP2, 0);\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\n  if (needs_control_head)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP2, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n    }\n  else\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0);\n\n  init_frame(common, ccbegin, NULL, framesize + extrasize - 1, extrasize);\n  }\n\nmemset(&altbacktrack, 0, sizeof(backtrack_common));\nif (conditional || (opcode == OP_ASSERT_NOT || opcode == OP_ASSERTBACK_NOT))\n  {\n  /* Control verbs cannot escape from these asserts. */\n  local_quit_available = TRUE;\n  common->local_quit_available = TRUE;\n  common->quit_label = NULL;\n  common->quit = NULL;\n  }\n\ncommon->in_positive_assertion = (opcode == OP_ASSERT || opcode == OP_ASSERTBACK);\ncommon->positive_assertion_quit = NULL;\n\nwhile (1)\n  {\n  common->accept_label = NULL;\n  common->accept = NULL;\n  altbacktrack.top = NULL;\n  altbacktrack.topbacktracks = NULL;\n\n  if (*ccbegin == OP_ALT && extrasize > 0)\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  altbacktrack.cc = ccbegin;\n  compile_matchingpath(common, ccbegin + 1 + LINK_SIZE, cc, &altbacktrack);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    {\n    if (local_quit_available)\n      {\n      common->local_quit_available = save_local_quit_available;\n      common->quit_label = save_quit_label;\n      common->quit = save_quit;\n      }\n    common->in_positive_assertion = save_in_positive_assertion;\n    common->then_trap = save_then_trap;\n    common->accept_label = save_accept_label;\n    common->positive_assertion_quit = save_positive_assertion_quit;\n    common->accept = save_accept;\n    return NULL;\n    }\n  common->accept_label = LABEL();\n  if (common->accept != NULL)\n    set_jumps(common->accept, common->accept_label);\n\n  /* Reset stack. */\n  if (framesize < 0)\n    {\n    if (framesize == no_frame)\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    else if (extrasize > 0)\n      free_stack(common, extrasize);\n\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(-1));\n    }\n  else\n    {\n    if ((opcode != OP_ASSERT_NOT && opcode != OP_ASSERTBACK_NOT) || conditional)\n      {\n      /* We don't need to keep the STR_PTR, only the previous private_data_ptr. */\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + 1) * sizeof(sljit_sw));\n      if (needs_control_head)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(-1));\n      }\n    else\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      if (needs_control_head)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(-framesize - 2));\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (framesize - 1) * sizeof(sljit_sw));\n      }\n    }\n\n  if (opcode == OP_ASSERT_NOT || opcode == OP_ASSERTBACK_NOT)\n    {\n    /* We know that STR_PTR was stored on the top of the stack. */\n    if (conditional)\n      {\n      if (extrasize > 0)\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), needs_control_head ? STACK(-2) : STACK(-1));\n      }\n    else if (bra == OP_BRAZERO)\n      {\n      if (framesize < 0)\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-extrasize));\n      else\n        {\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-framesize - 1));\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-framesize - extrasize));\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n        }\n      OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else if (framesize >= 0)\n      {\n      /* For OP_BRA and OP_BRAMINZERO. */\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-framesize - 1));\n      }\n    }\n  add_jump(compiler, found, JUMP(SLJIT_JUMP));\n\n  compile_backtrackingpath(common, altbacktrack.top);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    {\n    if (local_quit_available)\n      {\n      common->local_quit_available = save_local_quit_available;\n      common->quit_label = save_quit_label;\n      common->quit = save_quit;\n      }\n    common->in_positive_assertion = save_in_positive_assertion;\n    common->then_trap = save_then_trap;\n    common->accept_label = save_accept_label;\n    common->positive_assertion_quit = save_positive_assertion_quit;\n    common->accept = save_accept;\n    return NULL;\n    }\n  set_jumps(altbacktrack.topbacktracks, LABEL());\n\n  if (*cc != OP_ALT)\n    break;\n\n  ccbegin = cc;\n  cc += GET(cc, 1);\n  }\n\nif (local_quit_available)\n  {\n  SLJIT_ASSERT(common->positive_assertion_quit == NULL);\n  /* Makes the check less complicated below. */\n  common->positive_assertion_quit = common->quit;\n  }\n\n/* None of them matched. */\nif (common->positive_assertion_quit != NULL)\n  {\n  jump = JUMP(SLJIT_JUMP);\n  set_jumps(common->positive_assertion_quit, LABEL());\n  SLJIT_ASSERT(framesize != no_stack);\n  if (framesize < 0)\n    OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, extrasize * sizeof(sljit_sw));\n  else\n    {\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n    OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (extrasize + 1) * sizeof(sljit_sw));\n    }\n  JUMPHERE(jump);\n  }\n\nif (needs_control_head)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(1));\n\nif (opcode == OP_ASSERT || opcode == OP_ASSERTBACK)\n  {\n  /* Assert is failed. */\n  if ((conditional && extrasize > 0) || bra == OP_BRAZERO)\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  if (framesize < 0)\n    {\n    /* The topmost item should be 0. */\n    if (bra == OP_BRAZERO)\n      {\n      if (extrasize == 2)\n        free_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else if (extrasize > 0)\n      free_stack(common, extrasize);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(extrasize - 1));\n    /* The topmost item should be 0. */\n    if (bra == OP_BRAZERO)\n      {\n      free_stack(common, framesize + extrasize - 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else\n      free_stack(common, framesize + extrasize);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n  jump = JUMP(SLJIT_JUMP);\n  if (bra != OP_BRAZERO)\n    add_jump(compiler, target, jump);\n\n  /* Assert is successful. */\n  set_jumps(tmp, LABEL());\n  if (framesize < 0)\n    {\n    /* We know that STR_PTR was stored on the top of the stack. */\n    if (extrasize > 0)\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-extrasize));\n\n    /* Keep the STR_PTR on the top of the stack. */\n    if (bra == OP_BRAZERO)\n      {\n      OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n      if (extrasize == 2)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      }\n    else if (bra == OP_BRAMINZERO)\n      {\n      OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    }\n  else\n    {\n    if (bra == OP_BRA)\n      {\n      /* We don't need to keep the STR_PTR, only the previous private_data_ptr. */\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-extrasize + 1));\n      }\n    else\n      {\n      /* We don't need to keep the STR_PTR, only the previous private_data_ptr. */\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + 2) * sizeof(sljit_sw));\n      if (extrasize == 2)\n        {\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n        if (bra == OP_BRAMINZERO)\n          OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n        }\n      else\n        {\n        SLJIT_ASSERT(extrasize == 3);\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(-1));\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), bra == OP_BRAZERO ? STR_PTR : SLJIT_IMM, 0);\n        }\n      }\n    }\n\n  if (bra == OP_BRAZERO)\n    {\n    backtrack->matchingpath = LABEL();\n    SET_LABEL(jump, backtrack->matchingpath);\n    }\n  else if (bra == OP_BRAMINZERO)\n    {\n    JUMPTO(SLJIT_JUMP, backtrack->matchingpath);\n    JUMPHERE(brajump);\n    if (framesize >= 0)\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (framesize - 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n      }\n    set_jumps(backtrack->common.topbacktracks, LABEL());\n    }\n  }\nelse\n  {\n  /* AssertNot is successful. */\n  if (framesize < 0)\n    {\n    if (extrasize > 0)\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n    if (bra != OP_BRA)\n      {\n      if (extrasize == 2)\n        free_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else if (extrasize > 0)\n      free_stack(common, extrasize);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(extrasize - 1));\n    /* The topmost item should be 0. */\n    if (bra != OP_BRA)\n      {\n      free_stack(common, framesize + extrasize - 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    else\n      free_stack(common, framesize + extrasize);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n\n  if (bra == OP_BRAZERO)\n    backtrack->matchingpath = LABEL();\n  else if (bra == OP_BRAMINZERO)\n    {\n    JUMPTO(SLJIT_JUMP, backtrack->matchingpath);\n    JUMPHERE(brajump);\n    }\n\n  if (bra != OP_BRA)\n    {\n    SLJIT_ASSERT(found == &backtrack->common.topbacktracks);\n    set_jumps(backtrack->common.topbacktracks, LABEL());\n    backtrack->common.topbacktracks = NULL;\n    }\n  }\n\nif (local_quit_available)\n  {\n  common->local_quit_available = save_local_quit_available;\n  common->quit_label = save_quit_label;\n  common->quit = save_quit;\n  }\ncommon->in_positive_assertion = save_in_positive_assertion;\ncommon->then_trap = save_then_trap;\ncommon->accept_label = save_accept_label;\ncommon->positive_assertion_quit = save_positive_assertion_quit;\ncommon->accept = save_accept;\nreturn cc + 1 + LINK_SIZE;\n}\n\nstatic SLJIT_INLINE void match_once_common(compiler_common *common, PCRE2_UCHAR ket, int framesize, int private_data_ptr, BOOL has_alternatives, BOOL needs_control_head)\n{\nDEFINE_COMPILER;\nint stacksize;\n\nif (framesize < 0)\n  {\n  if (framesize == no_frame)\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  else\n    {\n    stacksize = needs_control_head ? 1 : 0;\n    if (ket != OP_KET || has_alternatives)\n      stacksize++;\n\n    if (stacksize > 0)\n      free_stack(common, stacksize);\n    }\n\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), (ket != OP_KET || has_alternatives) ? STACK(-2) : STACK(-1));\n\n  /* TMP2 which is set here used by OP_KETRMAX below. */\n  if (ket == OP_KETRMAX)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(-1));\n  else if (ket == OP_KETRMIN)\n    {\n    /* Move the STR_PTR to the private_data_ptr. */\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-1));\n    }\n  }\nelse\n  {\n  stacksize = (ket != OP_KET || has_alternatives) ? 2 : 1;\n  OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, (framesize + stacksize) * sizeof(sljit_sw));\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-1));\n\n  if (ket == OP_KETRMAX)\n    {\n    /* TMP2 which is set here used by OP_KETRMAX below. */\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    }\n  }\nif (needs_control_head)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, TMP1, 0);\n}\n\nstatic SLJIT_INLINE int match_capture_common(compiler_common *common, int stacksize, int offset, int private_data_ptr)\n{\nDEFINE_COMPILER;\n\nif (common->capture_last_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, offset >> 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n  stacksize++;\n  }\nif (common->optimized_cbracket[offset >> 1] == 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize + 1), TMP2, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n  stacksize += 2;\n  }\nreturn stacksize;\n}\n\nstatic PCRE2_SPTR SLJIT_FUNC do_script_run(PCRE2_SPTR ptr, PCRE2_SPTR endptr)\n{\n  if (PRIV(script_run)(ptr, endptr, FALSE))\n    return endptr;\n  return NULL;\n}\n\n#ifdef SUPPORT_UNICODE\n\nstatic PCRE2_SPTR SLJIT_FUNC do_script_run_utf(PCRE2_SPTR ptr, PCRE2_SPTR endptr)\n{\n  if (PRIV(script_run)(ptr, endptr, TRUE))\n    return endptr;\n  return NULL;\n}\n\n#endif /* SUPPORT_UNICODE */\n\nstatic SLJIT_INLINE void match_script_run_common(compiler_common *common, int private_data_ptr, backtrack_common *parent)\n{\nDEFINE_COMPILER;\n\nSLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n#ifdef SUPPORT_UNICODE\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM,\n  common->utf ? SLJIT_FUNC_ADDR(do_script_run_utf) : SLJIT_FUNC_ADDR(do_script_run));\n#else\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(do_script_run));\n#endif\n\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_RETURN_REG, 0);\nadd_jump(compiler, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0));\n}\n\n/*\n  Handling bracketed expressions is probably the most complex part.\n\n  Stack layout naming characters:\n    S - Push the current STR_PTR\n    0 - Push a 0 (NULL)\n    A - Push the current STR_PTR. Needed for restoring the STR_PTR\n        before the next alternative. Not pushed if there are no alternatives.\n    M - Any values pushed by the current alternative. Can be empty, or anything.\n    C - Push the previous OVECTOR(i), OVECTOR(i+1) and OVECTOR_PRIV(i) to the stack.\n    L - Push the previous local (pointed by localptr) to the stack\n   () - opional values stored on the stack\n  ()* - optonal, can be stored multiple times\n\n  The following list shows the regular expression templates, their PCRE byte codes\n  and stack layout supported by pcre-sljit.\n\n  (?:)                     OP_BRA     | OP_KET                A M\n  ()                       OP_CBRA    | OP_KET                C M\n  (?:)+                    OP_BRA     | OP_KETRMAX        0   A M S   ( A M S )*\n                           OP_SBRA    | OP_KETRMAX        0   L M S   ( L M S )*\n  (?:)+?                   OP_BRA     | OP_KETRMIN        0   A M S   ( A M S )*\n                           OP_SBRA    | OP_KETRMIN        0   L M S   ( L M S )*\n  ()+                      OP_CBRA    | OP_KETRMAX        0   C M S   ( C M S )*\n                           OP_SCBRA   | OP_KETRMAX        0   C M S   ( C M S )*\n  ()+?                     OP_CBRA    | OP_KETRMIN        0   C M S   ( C M S )*\n                           OP_SCBRA   | OP_KETRMIN        0   C M S   ( C M S )*\n  (?:)?    OP_BRAZERO    | OP_BRA     | OP_KET            S ( A M 0 )\n  (?:)??   OP_BRAMINZERO | OP_BRA     | OP_KET            S ( A M 0 )\n  ()?      OP_BRAZERO    | OP_CBRA    | OP_KET            S ( C M 0 )\n  ()??     OP_BRAMINZERO | OP_CBRA    | OP_KET            S ( C M 0 )\n  (?:)*    OP_BRAZERO    | OP_BRA     | OP_KETRMAX      S 0 ( A M S )*\n           OP_BRAZERO    | OP_SBRA    | OP_KETRMAX      S 0 ( L M S )*\n  (?:)*?   OP_BRAMINZERO | OP_BRA     | OP_KETRMIN      S 0 ( A M S )*\n           OP_BRAMINZERO | OP_SBRA    | OP_KETRMIN      S 0 ( L M S )*\n  ()*      OP_BRAZERO    | OP_CBRA    | OP_KETRMAX      S 0 ( C M S )*\n           OP_BRAZERO    | OP_SCBRA   | OP_KETRMAX      S 0 ( C M S )*\n  ()*?     OP_BRAMINZERO | OP_CBRA    | OP_KETRMIN      S 0 ( C M S )*\n           OP_BRAMINZERO | OP_SCBRA   | OP_KETRMIN      S 0 ( C M S )*\n\n\n  Stack layout naming characters:\n    A - Push the alternative index (starting from 0) on the stack.\n        Not pushed if there is no alternatives.\n    M - Any values pushed by the current alternative. Can be empty, or anything.\n\n  The next list shows the possible content of a bracket:\n  (|)     OP_*BRA    | OP_ALT ...         M A\n  (?()|)  OP_*COND   | OP_ALT             M A\n  (?>|)   OP_ONCE    | OP_ALT ...         [stack trace] M A\n                                          Or nothing, if trace is unnecessary\n*/\n\nstatic PCRE2_SPTR compile_bracket_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode;\nint private_data_ptr = 0;\nint offset = 0;\nint i, stacksize;\nint repeat_ptr = 0, repeat_length = 0;\nint repeat_type = 0, repeat_count = 0;\nPCRE2_SPTR ccbegin;\nPCRE2_SPTR matchingpath;\nPCRE2_SPTR slot;\nPCRE2_UCHAR bra = OP_BRA;\nPCRE2_UCHAR ket;\nassert_backtrack *assert;\nBOOL has_alternatives;\nBOOL needs_control_head = FALSE;\nstruct sljit_jump *jump;\nstruct sljit_jump *skip;\nstruct sljit_label *rmax_label = NULL;\nstruct sljit_jump *braminzero = NULL;\n\nPUSH_BACKTRACK(sizeof(bracket_backtrack), cc, NULL);\n\nif (*cc == OP_BRAZERO || *cc == OP_BRAMINZERO)\n  {\n  bra = *cc;\n  cc++;\n  opcode = *cc;\n  }\n\nopcode = *cc;\nccbegin = cc;\nmatchingpath = bracketend(cc) - 1 - LINK_SIZE;\nket = *matchingpath;\nif (ket == OP_KET && PRIVATE_DATA(matchingpath) != 0)\n  {\n  repeat_ptr = PRIVATE_DATA(matchingpath);\n  repeat_length = PRIVATE_DATA(matchingpath + 1);\n  repeat_type = PRIVATE_DATA(matchingpath + 2);\n  repeat_count = PRIVATE_DATA(matchingpath + 3);\n  SLJIT_ASSERT(repeat_length != 0 && repeat_type != 0 && repeat_count != 0);\n  if (repeat_type == OP_UPTO)\n    ket = OP_KETRMAX;\n  if (repeat_type == OP_MINUPTO)\n    ket = OP_KETRMIN;\n  }\n\nmatchingpath = ccbegin + 1 + LINK_SIZE;\nSLJIT_ASSERT(ket == OP_KET || ket == OP_KETRMAX || ket == OP_KETRMIN);\nSLJIT_ASSERT(!((bra == OP_BRAZERO && ket == OP_KETRMIN) || (bra == OP_BRAMINZERO && ket == OP_KETRMAX)));\ncc += GET(cc, 1);\n\nhas_alternatives = *cc == OP_ALT;\nif (SLJIT_UNLIKELY(opcode == OP_COND || opcode == OP_SCOND))\n  {\n  SLJIT_COMPILE_ASSERT(OP_DNRREF == OP_RREF + 1 && OP_FALSE == OP_RREF + 2 && OP_TRUE == OP_RREF + 3,\n    compile_time_checks_must_be_grouped_together);\n  has_alternatives = ((*matchingpath >= OP_RREF && *matchingpath <= OP_TRUE) || *matchingpath == OP_FAIL) ? FALSE : TRUE;\n  }\n\nif (SLJIT_UNLIKELY(opcode == OP_COND) && (*cc == OP_KETRMAX || *cc == OP_KETRMIN))\n  opcode = OP_SCOND;\n\nif (opcode == OP_CBRA || opcode == OP_SCBRA)\n  {\n  /* Capturing brackets has a pre-allocated space. */\n  offset = GET2(ccbegin, 1 + LINK_SIZE);\n  if (common->optimized_cbracket[offset] == 0)\n    {\n    private_data_ptr = OVECTOR_PRIV(offset);\n    offset <<= 1;\n    }\n  else\n    {\n    offset <<= 1;\n    private_data_ptr = OVECTOR(offset);\n    }\n  BACKTRACK_AS(bracket_backtrack)->private_data_ptr = private_data_ptr;\n  matchingpath += IMM2_SIZE;\n  }\nelse if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA || opcode == OP_ONCE || opcode == OP_SCRIPT_RUN || opcode == OP_SBRA || opcode == OP_SCOND)\n  {\n  /* Other brackets simply allocate the next entry. */\n  private_data_ptr = PRIVATE_DATA(ccbegin);\n  SLJIT_ASSERT(private_data_ptr != 0);\n  BACKTRACK_AS(bracket_backtrack)->private_data_ptr = private_data_ptr;\n  if (opcode == OP_ONCE)\n    BACKTRACK_AS(bracket_backtrack)->u.framesize = get_framesize(common, ccbegin, NULL, FALSE, &needs_control_head);\n  }\n\n/* Instructions before the first alternative. */\nstacksize = 0;\nif (ket == OP_KETRMAX || (ket == OP_KETRMIN && bra != OP_BRAMINZERO))\n  stacksize++;\nif (bra == OP_BRAZERO)\n  stacksize++;\n\nif (stacksize > 0)\n  allocate_stack(common, stacksize);\n\nstacksize = 0;\nif (ket == OP_KETRMAX || (ket == OP_KETRMIN && bra != OP_BRAMINZERO))\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n  stacksize++;\n  }\n\nif (bra == OP_BRAZERO)\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n\nif (bra == OP_BRAMINZERO)\n  {\n  /* This is a backtrack path! (Since the try-path of OP_BRAMINZERO matches to the empty string) */\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  if (ket != OP_KETRMIN)\n    {\n    free_stack(common, 1);\n    braminzero = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n    }\n  else if (opcode == OP_ONCE || opcode >= OP_SBRA)\n    {\n    jump = CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    /* Nothing stored during the first run. */\n    skip = JUMP(SLJIT_JUMP);\n    JUMPHERE(jump);\n    /* Checking zero-length iteration. */\n    if (opcode != OP_ONCE || BACKTRACK_AS(bracket_backtrack)->u.framesize < 0)\n      {\n      /* When we come from outside, private_data_ptr contains the previous STR_PTR. */\n      braminzero = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      }\n    else\n      {\n      /* Except when the whole stack frame must be saved. */\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      braminzero = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_MEM1(TMP1), STACK(-BACKTRACK_AS(bracket_backtrack)->u.framesize - 2));\n      }\n    JUMPHERE(skip);\n    }\n  else\n    {\n    jump = CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    JUMPHERE(jump);\n    }\n  }\n\nif (repeat_type != 0)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, repeat_count);\n  if (repeat_type == OP_EXACT)\n    rmax_label = LABEL();\n  }\n\nif (ket == OP_KETRMIN)\n  BACKTRACK_AS(bracket_backtrack)->recursive_matchingpath = LABEL();\n\nif (ket == OP_KETRMAX)\n  {\n  rmax_label = LABEL();\n  if (has_alternatives && opcode >= OP_BRA && opcode < OP_SBRA && repeat_type == 0)\n    BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = rmax_label;\n  }\n\n/* Handling capturing brackets and alternatives. */\nif (opcode == OP_ONCE)\n  {\n  stacksize = 0;\n  if (needs_control_head)\n    {\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    stacksize++;\n    }\n\n  if (BACKTRACK_AS(bracket_backtrack)->u.framesize < 0)\n    {\n    /* Neither capturing brackets nor recursions are found in the block. */\n    if (ket == OP_KETRMIN)\n      {\n      stacksize += 2;\n      if (!needs_control_head)\n        OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      }\n    else\n      {\n      if (BACKTRACK_AS(bracket_backtrack)->u.framesize == no_frame)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0);\n      if (ket == OP_KETRMAX || has_alternatives)\n        stacksize++;\n      }\n\n    if (stacksize > 0)\n      allocate_stack(common, stacksize);\n\n    stacksize = 0;\n    if (needs_control_head)\n      {\n      stacksize++;\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n      }\n\n    if (ket == OP_KETRMIN)\n      {\n      if (needs_control_head)\n        OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n      if (BACKTRACK_AS(bracket_backtrack)->u.framesize == no_frame)\n        OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0, SLJIT_IMM, needs_control_head ? (2 * sizeof(sljit_sw)) : sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize + 1), TMP2, 0);\n      }\n    else if (ket == OP_KETRMAX || has_alternatives)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n    }\n  else\n    {\n    if (ket != OP_KET || has_alternatives)\n      stacksize++;\n\n    stacksize += BACKTRACK_AS(bracket_backtrack)->u.framesize + 1;\n    allocate_stack(common, stacksize);\n\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    OP2(SLJIT_ADD, TMP2, 0, STACK_TOP, 0, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n\n    stacksize = needs_control_head ? 1 : 0;\n    if (ket != OP_KET || has_alternatives)\n      {\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP2, 0);\n      stacksize++;\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP2, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP1, 0);\n      }\n    init_frame(common, ccbegin, NULL, BACKTRACK_AS(bracket_backtrack)->u.framesize + stacksize, stacksize + 1);\n    }\n  }\nelse if (opcode == OP_CBRA || opcode == OP_SCBRA)\n  {\n  /* Saving the previous values. */\n  if (common->optimized_cbracket[offset >> 1] != 0)\n    {\n    SLJIT_ASSERT(private_data_ptr == OVECTOR(offset));\n    allocate_stack(common, 2);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr + sizeof(sljit_sw));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP2, 0);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n    }\n  }\nelse if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA || opcode == OP_SCRIPT_RUN || opcode == OP_SBRA || opcode == OP_SCOND)\n  {\n  /* Saving the previous value. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n  }\nelse if (has_alternatives)\n  {\n  /* Pushing the starting string pointer. */\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n  }\n\n/* Generating code for the first alternative. */\nif (opcode == OP_COND || opcode == OP_SCOND)\n  {\n  if (*matchingpath == OP_CREF)\n    {\n    SLJIT_ASSERT(has_alternatives);\n    add_jump(compiler, &(BACKTRACK_AS(bracket_backtrack)->u.condfailed),\n      CMP(SLJIT_EQUAL, SLJIT_MEM1(SLJIT_SP), OVECTOR(GET2(matchingpath, 1) << 1), SLJIT_MEM1(SLJIT_SP), OVECTOR(1)));\n    matchingpath += 1 + IMM2_SIZE;\n    }\n  else if (*matchingpath == OP_DNCREF)\n    {\n    SLJIT_ASSERT(has_alternatives);\n\n    i = GET2(matchingpath, 1 + IMM2_SIZE);\n    slot = common->name_table + GET2(matchingpath, 1) * common->name_entry_size;\n    OP1(SLJIT_MOV, TMP3, 0, STR_PTR, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(1));\n    OP2(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(GET2(slot, 0) << 1), TMP1, 0);\n    slot += common->name_entry_size;\n    i--;\n    while (i-- > 0)\n      {\n      OP2(SLJIT_SUB, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(GET2(slot, 0) << 1), TMP1, 0);\n      OP2(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, TMP2, 0, STR_PTR, 0);\n      slot += common->name_entry_size;\n      }\n    OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n    add_jump(compiler, &(BACKTRACK_AS(bracket_backtrack)->u.condfailed), JUMP(SLJIT_ZERO));\n    matchingpath += 1 + 2 * IMM2_SIZE;\n    }\n  else if ((*matchingpath >= OP_RREF && *matchingpath <= OP_TRUE) || *matchingpath == OP_FAIL)\n    {\n    /* Never has other case. */\n    BACKTRACK_AS(bracket_backtrack)->u.condfailed = NULL;\n    SLJIT_ASSERT(!has_alternatives);\n\n    if (*matchingpath == OP_TRUE)\n      {\n      stacksize = 1;\n      matchingpath++;\n      }\n    else if (*matchingpath == OP_FALSE || *matchingpath == OP_FAIL)\n      stacksize = 0;\n    else if (*matchingpath == OP_RREF)\n      {\n      stacksize = GET2(matchingpath, 1);\n      if (common->currententry == NULL)\n        stacksize = 0;\n      else if (stacksize == RREF_ANY)\n        stacksize = 1;\n      else if (common->currententry->start == 0)\n        stacksize = stacksize == 0;\n      else\n        stacksize = stacksize == (int)GET2(common->start, common->currententry->start + 1 + LINK_SIZE);\n\n      if (stacksize != 0)\n        matchingpath += 1 + IMM2_SIZE;\n      }\n    else\n      {\n      if (common->currententry == NULL || common->currententry->start == 0)\n        stacksize = 0;\n      else\n        {\n        stacksize = GET2(matchingpath, 1 + IMM2_SIZE);\n        slot = common->name_table + GET2(matchingpath, 1) * common->name_entry_size;\n        i = (int)GET2(common->start, common->currententry->start + 1 + LINK_SIZE);\n        while (stacksize > 0)\n          {\n          if ((int)GET2(slot, 0) == i)\n            break;\n          slot += common->name_entry_size;\n          stacksize--;\n          }\n        }\n\n      if (stacksize != 0)\n        matchingpath += 1 + 2 * IMM2_SIZE;\n      }\n\n      /* The stacksize == 0 is a common \"else\" case. */\n      if (stacksize == 0)\n        {\n        if (*cc == OP_ALT)\n          {\n          matchingpath = cc + 1 + LINK_SIZE;\n          cc += GET(cc, 1);\n          }\n        else\n          matchingpath = cc;\n        }\n    }\n  else\n    {\n    SLJIT_ASSERT(has_alternatives && *matchingpath >= OP_ASSERT && *matchingpath <= OP_ASSERTBACK_NOT);\n    /* Similar code as PUSH_BACKTRACK macro. */\n    assert = sljit_alloc_memory(compiler, sizeof(assert_backtrack));\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n      return NULL;\n    memset(assert, 0, sizeof(assert_backtrack));\n    assert->common.cc = matchingpath;\n    BACKTRACK_AS(bracket_backtrack)->u.assert = assert;\n    matchingpath = compile_assert_matchingpath(common, matchingpath, assert, TRUE);\n    }\n  }\n\ncompile_matchingpath(common, matchingpath, cc, backtrack);\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  return NULL;\n\nif (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA)\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n\nif (opcode == OP_ONCE)\n  match_once_common(common, ket, BACKTRACK_AS(bracket_backtrack)->u.framesize, private_data_ptr, has_alternatives, needs_control_head);\n\nif (opcode == OP_SCRIPT_RUN)\n  match_script_run_common(common, private_data_ptr, backtrack);\n\nstacksize = 0;\nif (repeat_type == OP_MINUPTO)\n  {\n  /* We need to preserve the counter. TMP2 will be used below. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr);\n  stacksize++;\n  }\nif (ket != OP_KET || bra != OP_BRA)\n  stacksize++;\nif (offset != 0)\n  {\n  if (common->capture_last_ptr != 0)\n    stacksize++;\n  if (common->optimized_cbracket[offset >> 1] == 0)\n    stacksize += 2;\n  }\nif (has_alternatives && opcode != OP_ONCE)\n  stacksize++;\n\nif (stacksize > 0)\n  allocate_stack(common, stacksize);\n\nstacksize = 0;\nif (repeat_type == OP_MINUPTO)\n  {\n  /* TMP2 was set above. */\n  OP2(SLJIT_SUB, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP2, 0, SLJIT_IMM, 1);\n  stacksize++;\n  }\n\nif (ket != OP_KET || bra != OP_BRA)\n  {\n  if (ket != OP_KET)\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n  else\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n  stacksize++;\n  }\n\nif (offset != 0)\n  stacksize = match_capture_common(common, stacksize, offset, private_data_ptr);\n\n/* Skip and count the other alternatives. */\ni = 1;\nwhile (*cc == OP_ALT)\n  {\n  cc += GET(cc, 1);\n  i++;\n  }\n\nif (has_alternatives)\n  {\n  if (opcode != OP_ONCE)\n    {\n    if (i <= 3)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n    else\n      BACKTRACK_AS(bracket_backtrack)->u.matching_put_label = sljit_emit_put_label(compiler, SLJIT_MEM1(STACK_TOP), STACK(stacksize));\n    }\n  if (ket != OP_KETRMAX)\n    BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = LABEL();\n  }\n\n/* Must be after the matchingpath label. */\nif (offset != 0 && common->optimized_cbracket[offset >> 1] != 0)\n  {\n  SLJIT_ASSERT(private_data_ptr == OVECTOR(offset + 0));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n  }\n\nif (ket == OP_KETRMAX)\n  {\n  if (repeat_type != 0)\n    {\n    if (has_alternatives)\n      BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = LABEL();\n    OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, rmax_label);\n    /* Drop STR_PTR for greedy plus quantifier. */\n    if (opcode != OP_ONCE)\n      free_stack(common, 1);\n    }\n  else if (opcode < OP_BRA || opcode >= OP_SBRA)\n    {\n    if (has_alternatives)\n      BACKTRACK_AS(bracket_backtrack)->alternative_matchingpath = LABEL();\n\n    /* Checking zero-length iteration. */\n    if (opcode != OP_ONCE)\n      {\n      /* This case includes opcodes such as OP_SCRIPT_RUN. */\n      CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STR_PTR, 0, rmax_label);\n      /* Drop STR_PTR for greedy plus quantifier. */\n      if (bra != OP_BRAZERO)\n        free_stack(common, 1);\n      }\n    else\n      /* TMP2 must contain the starting STR_PTR. */\n      CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0, rmax_label);\n    }\n  else\n    JUMPTO(SLJIT_JUMP, rmax_label);\n  BACKTRACK_AS(bracket_backtrack)->recursive_matchingpath = LABEL();\n  }\n\nif (repeat_type == OP_EXACT)\n  {\n  count_match(common);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  JUMPTO(SLJIT_NOT_ZERO, rmax_label);\n  }\nelse if (repeat_type == OP_UPTO)\n  {\n  /* We need to preserve the counter. */\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr);\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n  }\n\nif (bra == OP_BRAZERO)\n  BACKTRACK_AS(bracket_backtrack)->zero_matchingpath = LABEL();\n\nif (bra == OP_BRAMINZERO)\n  {\n  /* This is a backtrack path! (From the viewpoint of OP_BRAMINZERO) */\n  JUMPTO(SLJIT_JUMP, ((braminzero_backtrack *)parent)->matchingpath);\n  if (braminzero != NULL)\n    {\n    JUMPHERE(braminzero);\n    /* We need to release the end pointer to perform the\n    backtrack for the zero-length iteration. When\n    framesize is < 0, OP_ONCE will do the release itself. */\n    if (opcode == OP_ONCE && BACKTRACK_AS(bracket_backtrack)->u.framesize >= 0)\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (BACKTRACK_AS(bracket_backtrack)->u.framesize - 1) * sizeof(sljit_sw));\n      }\n    else if (ket == OP_KETRMIN && opcode != OP_ONCE)\n      free_stack(common, 1);\n    }\n  /* Continue to the normal backtrack. */\n  }\n\nif ((ket != OP_KET && bra != OP_BRAMINZERO) || bra == OP_BRAZERO)\n  count_match(common);\n\ncc += 1 + LINK_SIZE;\n\nif (opcode == OP_ONCE)\n  {\n  /* We temporarily encode the needs_control_head in the lowest bit.\n     Note: on the target architectures of SLJIT the ((x << 1) >> 1) returns\n     the same value for small signed numbers (including negative numbers). */\n  BACKTRACK_AS(bracket_backtrack)->u.framesize = (int)((unsigned)BACKTRACK_AS(bracket_backtrack)->u.framesize << 1) | (needs_control_head ? 1 : 0);\n  }\nreturn cc + repeat_length;\n}\n\nstatic PCRE2_SPTR compile_bracketpos_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode;\nint private_data_ptr;\nint cbraprivptr = 0;\nBOOL needs_control_head;\nint framesize;\nint stacksize;\nint offset = 0;\nBOOL zero = FALSE;\nPCRE2_SPTR ccbegin = NULL;\nint stack; /* Also contains the offset of control head. */\nstruct sljit_label *loop = NULL;\nstruct jump_list *emptymatch = NULL;\n\nPUSH_BACKTRACK(sizeof(bracketpos_backtrack), cc, NULL);\nif (*cc == OP_BRAPOSZERO)\n  {\n  zero = TRUE;\n  cc++;\n  }\n\nopcode = *cc;\nprivate_data_ptr = PRIVATE_DATA(cc);\nSLJIT_ASSERT(private_data_ptr != 0);\nBACKTRACK_AS(bracketpos_backtrack)->private_data_ptr = private_data_ptr;\nswitch(opcode)\n  {\n  case OP_BRAPOS:\n  case OP_SBRAPOS:\n  ccbegin = cc + 1 + LINK_SIZE;\n  break;\n\n  case OP_CBRAPOS:\n  case OP_SCBRAPOS:\n  offset = GET2(cc, 1 + LINK_SIZE);\n  /* This case cannot be optimized in the same was as\n  normal capturing brackets. */\n  SLJIT_ASSERT(common->optimized_cbracket[offset] == 0);\n  cbraprivptr = OVECTOR_PRIV(offset);\n  offset <<= 1;\n  ccbegin = cc + 1 + LINK_SIZE + IMM2_SIZE;\n  break;\n\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\nframesize = get_framesize(common, cc, NULL, FALSE, &needs_control_head);\nBACKTRACK_AS(bracketpos_backtrack)->framesize = framesize;\nif (framesize < 0)\n  {\n  if (offset != 0)\n    {\n    stacksize = 2;\n    if (common->capture_last_ptr != 0)\n      stacksize++;\n    }\n  else\n    stacksize = 1;\n\n  if (needs_control_head)\n    stacksize++;\n  if (!zero)\n    stacksize++;\n\n  BACKTRACK_AS(bracketpos_backtrack)->stacksize = stacksize;\n  allocate_stack(common, stacksize);\n  if (framesize == no_frame)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0);\n\n  stack = 0;\n  if (offset != 0)\n    {\n    stack = 2;\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP1, 0);\n    if (common->capture_last_ptr != 0)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), TMP2, 0);\n    if (needs_control_head)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    if (common->capture_last_ptr != 0)\n      {\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), TMP1, 0);\n      stack = 3;\n      }\n    }\n  else\n    {\n    if (needs_control_head)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    stack = 1;\n    }\n\n  if (needs_control_head)\n    stack++;\n  if (!zero)\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), SLJIT_IMM, 1);\n  if (needs_control_head)\n    {\n    stack--;\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), TMP2, 0);\n    }\n  }\nelse\n  {\n  stacksize = framesize + 1;\n  if (!zero)\n    stacksize++;\n  if (needs_control_head)\n    stacksize++;\n  if (offset == 0)\n    stacksize++;\n  BACKTRACK_AS(bracketpos_backtrack)->stacksize = stacksize;\n\n  allocate_stack(common, stacksize);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n  if (needs_control_head)\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n  OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), private_data_ptr, STACK_TOP, 0, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n\n  stack = 0;\n  if (!zero)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 1);\n    stack = 1;\n    }\n  if (needs_control_head)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), TMP2, 0);\n    stack++;\n    }\n  if (offset == 0)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), STR_PTR, 0);\n    stack++;\n    }\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stack), TMP1, 0);\n  init_frame(common, cc, NULL, stacksize - 1, stacksize - framesize);\n  stack -= 1 + (offset == 0);\n  }\n\nif (offset != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), cbraprivptr, STR_PTR, 0);\n\nloop = LABEL();\nwhile (*cc != OP_KETRPOS)\n  {\n  backtrack->top = NULL;\n  backtrack->topbacktracks = NULL;\n  cc += GET(cc, 1);\n\n  compile_matchingpath(common, ccbegin, cc, backtrack);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return NULL;\n\n  if (framesize < 0)\n    {\n    if (framesize == no_frame)\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n\n    if (offset != 0)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), cbraprivptr, STR_PTR, 0);\n      if (common->capture_last_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, offset >> 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n      }\n    else\n      {\n      if (opcode == OP_SBRAPOS)\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      }\n\n    /* Even if the match is empty, we need to reset the control head. */\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(stack));\n\n    if (opcode == OP_SBRAPOS || opcode == OP_SCBRAPOS)\n      add_jump(compiler, &emptymatch, CMP(SLJIT_EQUAL, TMP1, 0, STR_PTR, 0));\n\n    if (!zero)\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize - 1), SLJIT_IMM, 0);\n    }\n  else\n    {\n    if (offset != 0)\n      {\n      OP2(SLJIT_SUB, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), cbraprivptr, STR_PTR, 0);\n      if (common->capture_last_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, offset >> 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP2(SLJIT_SUB, STACK_TOP, 0, TMP2, 0, SLJIT_IMM, stacksize * sizeof(sljit_sw));\n      if (opcode == OP_SBRAPOS)\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP2), STACK(-framesize - 2));\n      OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), STACK(-framesize - 2), STR_PTR, 0);\n      }\n\n    /* Even if the match is empty, we need to reset the control head. */\n    if (needs_control_head)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_MEM1(STACK_TOP), STACK(stack));\n\n    if (opcode == OP_SBRAPOS || opcode == OP_SCBRAPOS)\n      add_jump(compiler, &emptymatch, CMP(SLJIT_EQUAL, TMP1, 0, STR_PTR, 0));\n\n    if (!zero)\n      {\n      if (framesize < 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize - 1), SLJIT_IMM, 0);\n      else\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      }\n    }\n\n  JUMPTO(SLJIT_JUMP, loop);\n  flush_stubs(common);\n\n  compile_backtrackingpath(common, backtrack->top);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return NULL;\n  set_jumps(backtrack->topbacktracks, LABEL());\n\n  if (framesize < 0)\n    {\n    if (offset != 0)\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n    else\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    }\n  else\n    {\n    if (offset != 0)\n      {\n      /* Last alternative. */\n      if (*cc == OP_KETRPOS)\n        OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), cbraprivptr);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n      OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(TMP2), STACK(-framesize - 2));\n      }\n    }\n\n  if (*cc == OP_KETRPOS)\n    break;\n  ccbegin = cc + 1 + LINK_SIZE;\n  }\n\n/* We don't have to restore the control head in case of a failed match. */\n\nbacktrack->topbacktracks = NULL;\nif (!zero)\n  {\n  if (framesize < 0)\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(stacksize - 1), SLJIT_IMM, 0));\n  else /* TMP2 is set to [private_data_ptr] above. */\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(TMP2), STACK(-stacksize), SLJIT_IMM, 0));\n  }\n\n/* None of them matched. */\nset_jumps(emptymatch, LABEL());\ncount_match(common);\nreturn cc + 1 + LINK_SIZE;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR get_iterator_parameters(compiler_common *common, PCRE2_SPTR cc, PCRE2_UCHAR *opcode, PCRE2_UCHAR *type, sljit_u32 *max, sljit_u32 *exact, PCRE2_SPTR *end)\n{\nint class_len;\n\n*opcode = *cc;\n*exact = 0;\n\nif (*opcode >= OP_STAR && *opcode <= OP_POSUPTO)\n  {\n  cc++;\n  *type = OP_CHAR;\n  }\nelse if (*opcode >= OP_STARI && *opcode <= OP_POSUPTOI)\n  {\n  cc++;\n  *type = OP_CHARI;\n  *opcode -= OP_STARI - OP_STAR;\n  }\nelse if (*opcode >= OP_NOTSTAR && *opcode <= OP_NOTPOSUPTO)\n  {\n  cc++;\n  *type = OP_NOT;\n  *opcode -= OP_NOTSTAR - OP_STAR;\n  }\nelse if (*opcode >= OP_NOTSTARI && *opcode <= OP_NOTPOSUPTOI)\n  {\n  cc++;\n  *type = OP_NOTI;\n  *opcode -= OP_NOTSTARI - OP_STAR;\n  }\nelse if (*opcode >= OP_TYPESTAR && *opcode <= OP_TYPEPOSUPTO)\n  {\n  cc++;\n  *opcode -= OP_TYPESTAR - OP_STAR;\n  *type = OP_END;\n  }\nelse\n  {\n  SLJIT_ASSERT(*opcode == OP_CLASS || *opcode == OP_NCLASS || *opcode == OP_XCLASS);\n  *type = *opcode;\n  cc++;\n  class_len = (*type < OP_XCLASS) ? (int)(1 + (32 / sizeof(PCRE2_UCHAR))) : GET(cc, 0);\n  *opcode = cc[class_len - 1];\n\n  if (*opcode >= OP_CRSTAR && *opcode <= OP_CRMINQUERY)\n    {\n    *opcode -= OP_CRSTAR - OP_STAR;\n    *end = cc + class_len;\n\n    if (*opcode == OP_PLUS || *opcode == OP_MINPLUS)\n      {\n      *exact = 1;\n      *opcode -= OP_PLUS - OP_STAR;\n      }\n    }\n  else if (*opcode >= OP_CRPOSSTAR && *opcode <= OP_CRPOSQUERY)\n    {\n    *opcode -= OP_CRPOSSTAR - OP_POSSTAR;\n    *end = cc + class_len;\n\n    if (*opcode == OP_POSPLUS)\n      {\n      *exact = 1;\n      *opcode = OP_POSSTAR;\n      }\n    }\n  else\n    {\n    SLJIT_ASSERT(*opcode == OP_CRRANGE || *opcode == OP_CRMINRANGE || *opcode == OP_CRPOSRANGE);\n    *max = GET2(cc, (class_len + IMM2_SIZE));\n    *exact = GET2(cc, class_len);\n\n    if (*max == 0)\n      {\n      if (*opcode == OP_CRPOSRANGE)\n        *opcode = OP_POSSTAR;\n      else\n        *opcode -= OP_CRRANGE - OP_STAR;\n      }\n    else\n      {\n      *max -= *exact;\n      if (*max == 0)\n        *opcode = OP_EXACT;\n      else if (*max == 1)\n        {\n        if (*opcode == OP_CRPOSRANGE)\n          *opcode = OP_POSQUERY;\n        else\n          *opcode -= OP_CRRANGE - OP_QUERY;\n        }\n      else\n        {\n        if (*opcode == OP_CRPOSRANGE)\n          *opcode = OP_POSUPTO;\n        else\n          *opcode -= OP_CRRANGE - OP_UPTO;\n        }\n      }\n    *end = cc + class_len + 2 * IMM2_SIZE;\n    }\n  return cc;\n  }\n\nswitch(*opcode)\n  {\n  case OP_EXACT:\n  *exact = GET2(cc, 0);\n  cc += IMM2_SIZE;\n  break;\n\n  case OP_PLUS:\n  case OP_MINPLUS:\n  *exact = 1;\n  *opcode -= OP_PLUS - OP_STAR;\n  break;\n\n  case OP_POSPLUS:\n  *exact = 1;\n  *opcode = OP_POSSTAR;\n  break;\n\n  case OP_UPTO:\n  case OP_MINUPTO:\n  case OP_POSUPTO:\n  *max = GET2(cc, 0);\n  cc += IMM2_SIZE;\n  break;\n  }\n\nif (*type == OP_END)\n  {\n  *type = *cc;\n  *end = next_opcode(common, cc);\n  cc++;\n  return cc;\n  }\n\n*end = cc + 1;\n#ifdef SUPPORT_UNICODE\nif (common->utf && HAS_EXTRALEN(*cc)) *end += GET_EXTRALEN(*cc);\n#endif\nreturn cc;\n}\n\nstatic PCRE2_SPTR compile_iterator_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode;\nPCRE2_UCHAR type;\nsljit_u32 max = 0, exact;\nsljit_s32 early_fail_ptr = PRIVATE_DATA(cc + 1);\nsljit_s32 early_fail_type;\nBOOL charpos_enabled;\nPCRE2_UCHAR charpos_char;\nunsigned int charpos_othercasebit;\nPCRE2_SPTR end;\njump_list *no_match = NULL;\njump_list *no_char1_match = NULL;\nstruct sljit_jump *jump = NULL;\nstruct sljit_label *label;\nint private_data_ptr = PRIVATE_DATA(cc);\nint base = (private_data_ptr == 0) ? SLJIT_MEM1(STACK_TOP) : SLJIT_MEM1(SLJIT_SP);\nint offset0 = (private_data_ptr == 0) ? STACK(0) : private_data_ptr;\nint offset1 = (private_data_ptr == 0) ? STACK(1) : private_data_ptr + (int)sizeof(sljit_sw);\nint tmp_base, tmp_offset;\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\nBOOL use_tmp;\n#endif\n\nPUSH_BACKTRACK(sizeof(char_iterator_backtrack), cc, NULL);\n\nearly_fail_type = (early_fail_ptr & 0x7);\nearly_fail_ptr >>= 3;\n\n/* During recursion, these optimizations are disabled. */\nif (common->early_fail_start_ptr == 0 && common->fast_forward_bc_ptr == NULL)\n  {\n  early_fail_ptr = 0;\n  early_fail_type = type_skip;\n  }\n\nSLJIT_ASSERT(common->fast_forward_bc_ptr != NULL || early_fail_ptr == 0\n  || (early_fail_ptr >= common->early_fail_start_ptr && early_fail_ptr <= common->early_fail_end_ptr));\n\nif (early_fail_type == type_fail)\n  add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), early_fail_ptr));\n\ncc = get_iterator_parameters(common, cc, &opcode, &type, &max, &exact, &end);\n\nif (type != OP_EXTUNI)\n  {\n  tmp_base = TMP3;\n  tmp_offset = 0;\n  }\nelse\n  {\n  tmp_base = SLJIT_MEM1(SLJIT_SP);\n  tmp_offset = POSSESSIVE0;\n  }\n\n/* Handle fixed part first. */\nif (exact > 1)\n  {\n  SLJIT_ASSERT(early_fail_ptr == 0);\n\n  if (common->mode == PCRE2_JIT_COMPLETE\n#ifdef SUPPORT_UNICODE\n      && !common->utf\n#endif\n      && type != OP_ANYNL && type != OP_EXTUNI)\n    {\n    OP2(SLJIT_ADD, TMP1, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(exact));\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_GREATER, TMP1, 0, STR_END, 0));\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, exact);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, FALSE);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, label);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, exact);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, TRUE);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n    JUMPTO(SLJIT_NOT_ZERO, label);\n    }\n  }\nelse if (exact == 1)\n  {\n  compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, TRUE);\n\n  if (early_fail_type == type_fail_range)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), early_fail_ptr);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), early_fail_ptr + (int)sizeof(sljit_sw));\n    OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, TMP2, 0);\n    OP2(SLJIT_SUB, TMP2, 0, STR_PTR, 0, TMP2, 0);\n    add_jump(compiler, &backtrack->topbacktracks, CMP(SLJIT_LESS_EQUAL, TMP2, 0, TMP1, 0));\n\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr + (int)sizeof(sljit_sw), STR_PTR, 0);\n    }\n  }\n\nswitch(opcode)\n  {\n  case OP_STAR:\n  case OP_UPTO:\n  SLJIT_ASSERT(early_fail_ptr == 0 || opcode == OP_STAR);\n\n  if (type == OP_ANYNL || type == OP_EXTUNI)\n    {\n    SLJIT_ASSERT(private_data_ptr == 0);\n    SLJIT_ASSERT(early_fail_ptr == 0);\n\n    allocate_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, 0);\n\n    if (opcode == OP_UPTO)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, SLJIT_IMM, max);\n\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &BACKTRACK_AS(char_iterator_backtrack)->u.backtracks, TRUE);\n    if (opcode == OP_UPTO)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0);\n      OP2(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n      jump = JUMP(SLJIT_ZERO);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE0, TMP1, 0);\n      }\n\n    /* We cannot use TMP3 because of allocate_stack. */\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n    JUMPTO(SLJIT_JUMP, label);\n    if (jump != NULL)\n      JUMPHERE(jump);\n    BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n    break;\n    }\n#ifdef SUPPORT_UNICODE\n  else if (type == OP_ALLANY && !common->invalid_utf)\n#else\n  else if (type == OP_ALLANY)\n#endif\n    {\n    if (opcode == OP_STAR)\n      {\n      if (private_data_ptr == 0)\n        allocate_stack(common, 2);\n\n      OP1(SLJIT_MOV, base, offset0, STR_END, 0);\n      OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n\n      OP1(SLJIT_MOV, STR_PTR, 0, STR_END, 0);\n      process_partial_match(common);\n\n      if (early_fail_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_END, 0);\n      BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n      break;\n      }\n#ifdef SUPPORT_UNICODE\n    else if (!common->utf)\n#else\n    else\n#endif\n      {\n      if (private_data_ptr == 0)\n        allocate_stack(common, 2);\n\n      OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n      OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(max));\n\n      if (common->mode == PCRE2_JIT_COMPLETE)\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_PTR, 0, STR_END, 0);\n        CMOV(SLJIT_GREATER, STR_PTR, STR_END, 0);\n        }\n      else\n        {\n        jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, STR_END, 0);\n        process_partial_match(common);\n        JUMPHERE(jump);\n        }\n\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n\n      if (early_fail_ptr != 0)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n      BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n      break;\n      }\n    }\n\n  charpos_enabled = FALSE;\n  charpos_char = 0;\n  charpos_othercasebit = 0;\n\n  if ((type != OP_CHAR && type != OP_CHARI) && (*end == OP_CHAR || *end == OP_CHARI))\n    {\n#ifdef SUPPORT_UNICODE\n    charpos_enabled = !common->utf || !HAS_EXTRALEN(end[1]);\n#else\n    charpos_enabled = TRUE;\n#endif\n    if (charpos_enabled && *end == OP_CHARI && char_has_othercase(common, end + 1))\n      {\n      charpos_othercasebit = char_get_othercase_bit(common, end + 1);\n      if (charpos_othercasebit == 0)\n        charpos_enabled = FALSE;\n      }\n\n    if (charpos_enabled)\n      {\n      charpos_char = end[1];\n      /* Consume the OP_CHAR opcode. */\n      end += 2;\n#if PCRE2_CODE_UNIT_WIDTH == 8\n      SLJIT_ASSERT((charpos_othercasebit >> 8) == 0);\n#elif PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n      SLJIT_ASSERT((charpos_othercasebit >> 9) == 0);\n      if ((charpos_othercasebit & 0x100) != 0)\n        charpos_othercasebit = (charpos_othercasebit & 0xff) << 8;\n#endif\n      if (charpos_othercasebit != 0)\n        charpos_char |= charpos_othercasebit;\n\n      BACKTRACK_AS(char_iterator_backtrack)->u.charpos.enabled = TRUE;\n      BACKTRACK_AS(char_iterator_backtrack)->u.charpos.chr = charpos_char;\n      BACKTRACK_AS(char_iterator_backtrack)->u.charpos.othercasebit = charpos_othercasebit;\n      }\n    }\n\n  if (charpos_enabled)\n    {\n    if (opcode == OP_UPTO)\n      OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max + 1);\n\n    /* Search the first instance of charpos_char. */\n    jump = JUMP(SLJIT_JUMP);\n    label = LABEL();\n    if (opcode == OP_UPTO)\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      add_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_ZERO));\n      }\n    compile_char1_matchingpath(common, type, cc, &backtrack->topbacktracks, FALSE);\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n    JUMPHERE(jump);\n\n    detect_partial_match(common, &backtrack->topbacktracks);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (charpos_othercasebit != 0)\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, charpos_othercasebit);\n    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, charpos_char, label);\n\n    if (private_data_ptr == 0)\n      allocate_stack(common, 2);\n    OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n    OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n\n    if (opcode == OP_UPTO)\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n      }\n\n    /* Search the last instance of charpos_char. */\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_match, FALSE);\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n    detect_partial_match(common, &no_match);\n    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));\n    if (charpos_othercasebit != 0)\n      OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, charpos_othercasebit);\n\n    if (opcode == OP_STAR)\n      {\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, charpos_char, label);\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      JUMPTO(SLJIT_JUMP, label);\n      }\n    else\n      {\n      jump = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, charpos_char);\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      JUMPHERE(jump);\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      JUMPTO(SLJIT_NOT_ZERO, label);\n      }\n\n    set_jumps(no_match, LABEL());\n    OP2(SLJIT_ADD, STR_PTR, 0, base, offset0, SLJIT_IMM, IN_UCHARS(1));\n    OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n    }\n  else\n    {\n    if (private_data_ptr == 0)\n      allocate_stack(common, 2);\n\n    OP1(SLJIT_MOV, base, offset1, STR_PTR, 0);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    use_tmp = (!HAS_VIRTUAL_REGISTERS && opcode == OP_STAR);\n    SLJIT_ASSERT(!use_tmp || tmp_base == TMP3);\n\n    if (common->utf)\n      OP1(SLJIT_MOV, use_tmp ? TMP3 : base, use_tmp ? 0 : offset0, STR_PTR, 0);\n#endif\n    if (opcode == OP_UPTO)\n      OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max);\n\n    detect_partial_match(common, &no_match);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_char1_match, FALSE);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf)\n      OP1(SLJIT_MOV, use_tmp ? TMP3 : base, use_tmp ? 0 : offset0, STR_PTR, 0);\n#endif\n\n    if (opcode == OP_UPTO)\n      {\n      OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n      add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n      }\n\n    detect_partial_match_to(common, label);\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n    set_jumps(no_char1_match, LABEL());\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n    if (common->utf)\n      {\n      set_jumps(no_match, LABEL());\n      if (use_tmp)\n        {\n        OP1(SLJIT_MOV, STR_PTR, 0, TMP3, 0);\n        OP1(SLJIT_MOV, base, offset0, TMP3, 0);\n        }\n      else\n        OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n      }\n    else\n#endif\n      {\n      OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n      set_jumps(no_match, LABEL());\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      }\n\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n    }\n\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  break;\n\n  case OP_MINSTAR:\n  if (private_data_ptr == 0)\n    allocate_stack(common, 1);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  if (early_fail_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n  break;\n\n  case OP_MINUPTO:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n  if (private_data_ptr == 0)\n    allocate_stack(common, 2);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  OP1(SLJIT_MOV, base, offset1, SLJIT_IMM, max + 1);\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  break;\n\n  case OP_QUERY:\n  case OP_MINQUERY:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n  if (private_data_ptr == 0)\n    allocate_stack(common, 1);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  if (opcode == OP_QUERY)\n    compile_char1_matchingpath(common, type, cc, &BACKTRACK_AS(char_iterator_backtrack)->u.backtracks, TRUE);\n  BACKTRACK_AS(char_iterator_backtrack)->matchingpath = LABEL();\n  break;\n\n  case OP_EXACT:\n  break;\n\n  case OP_POSSTAR:\n#if defined SUPPORT_UNICODE\n  if (type == OP_ALLANY && !common->invalid_utf)\n#else\n  if (type == OP_ALLANY)\n#endif\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, STR_END, 0);\n    process_partial_match(common);\n    if (early_fail_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_END, 0);\n    break;\n    }\n\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n  if (common->utf)\n    {\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n    detect_partial_match(common, &no_match);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_match, FALSE);\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n    detect_partial_match_to(common, label);\n\n    set_jumps(no_match, LABEL());\n    OP1(SLJIT_MOV, STR_PTR, 0, tmp_base, tmp_offset);\n    if (early_fail_ptr != 0)\n      {\n      if (!HAS_VIRTUAL_REGISTERS && tmp_base == TMP3)\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, TMP3, 0);\n      else\n        OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n      }\n    break;\n    }\n#endif\n\n  detect_partial_match(common, &no_match);\n  label = LABEL();\n  compile_char1_matchingpath(common, type, cc, &no_char1_match, FALSE);\n  detect_partial_match_to(common, label);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  set_jumps(no_char1_match, LABEL());\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  set_jumps(no_match, LABEL());\n  if (early_fail_ptr != 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), early_fail_ptr, STR_PTR, 0);\n  break;\n\n  case OP_POSUPTO:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n#if defined SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH != 32\n  if (common->utf)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, STR_PTR, 0);\n    OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max);\n\n    detect_partial_match(common, &no_match);\n    label = LABEL();\n    compile_char1_matchingpath(common, type, cc, &no_match, FALSE);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1, STR_PTR, 0);\n    OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n    add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n    detect_partial_match_to(common, label);\n\n    set_jumps(no_match, LABEL());\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), POSSESSIVE1);\n    break;\n    }\n#endif\n\n  if (type == OP_ALLANY)\n    {\n    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(max));\n\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, STR_PTR, 0, STR_END, 0);\n      CMOV(SLJIT_GREATER, STR_PTR, STR_END, 0);\n      }\n    else\n      {\n      jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, STR_END, 0);\n      process_partial_match(common);\n      JUMPHERE(jump);\n      }\n    break;\n    }\n\n  OP1(SLJIT_MOV, tmp_base, tmp_offset, SLJIT_IMM, max);\n\n  detect_partial_match(common, &no_match);\n  label = LABEL();\n  compile_char1_matchingpath(common, type, cc, &no_char1_match, FALSE);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, tmp_base, tmp_offset, tmp_base, tmp_offset, SLJIT_IMM, 1);\n  add_jump(compiler, &no_match, JUMP(SLJIT_ZERO));\n  detect_partial_match_to(common, label);\n  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n  set_jumps(no_char1_match, LABEL());\n  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n  set_jumps(no_match, LABEL());\n  break;\n\n  case OP_POSQUERY:\n  SLJIT_ASSERT(early_fail_ptr == 0);\n  OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n  compile_char1_matchingpath(common, type, cc, &no_match, TRUE);\n  OP1(SLJIT_MOV, tmp_base, tmp_offset, STR_PTR, 0);\n  set_jumps(no_match, LABEL());\n  OP1(SLJIT_MOV, STR_PTR, 0, tmp_base, tmp_offset);\n  break;\n\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\ncount_match(common);\nreturn end;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_fail_accept_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\n\nPUSH_BACKTRACK(sizeof(backtrack_common), cc, NULL);\n\nif (*cc == OP_FAIL)\n  {\n  add_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_JUMP));\n  return cc + 1;\n  }\n\nif (*cc == OP_ACCEPT && common->currententry == NULL && (common->re->overall_options & PCRE2_ENDANCHORED) != 0)\n  add_jump(compiler, &common->reset_match, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, STR_END, 0));\n\nif (*cc == OP_ASSERT_ACCEPT || common->currententry != NULL || !common->might_be_empty)\n  {\n  /* No need to check notempty conditions. */\n  if (common->accept_label == NULL)\n    add_jump(compiler, &common->accept, JUMP(SLJIT_JUMP));\n  else\n    JUMPTO(SLJIT_JUMP, common->accept_label);\n  return cc + 1;\n  }\n\nif (common->accept_label == NULL)\n  add_jump(compiler, &common->accept, CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0)));\nelse\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), common->accept_label);\n\nif (HAS_VIRTUAL_REGISTERS)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV_U32, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, options));\n  }\nelse\n  OP1(SLJIT_MOV_U32, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, options));\n\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY);\nadd_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_NOT_ZERO));\nOP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY_ATSTART);\nif (common->accept_label == NULL)\n  add_jump(compiler, &common->accept, JUMP(SLJIT_ZERO));\nelse\n  JUMPTO(SLJIT_ZERO, common->accept_label);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? TMP1 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));\nif (common->accept_label == NULL)\n  add_jump(compiler, &common->accept, CMP(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0));\nelse\n  CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0, common->accept_label);\nadd_jump(compiler, &backtrack->topbacktracks, JUMP(SLJIT_JUMP));\nreturn cc + 1;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_close_matchingpath(compiler_common *common, PCRE2_SPTR cc)\n{\nDEFINE_COMPILER;\nint offset = GET2(cc, 1);\nBOOL optimized_cbracket = common->optimized_cbracket[offset] != 0;\n\n/* Data will be discarded anyway... */\nif (common->currententry != NULL)\n  return cc + 1 + IMM2_SIZE;\n\nif (!optimized_cbracket)\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR_PRIV(offset));\noffset <<= 1;\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\nif (!optimized_cbracket)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\nreturn cc + 1 + IMM2_SIZE;\n}\n\nstatic SLJIT_INLINE PCRE2_SPTR compile_control_verb_matchingpath(compiler_common *common, PCRE2_SPTR cc, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nPCRE2_UCHAR opcode = *cc;\nPCRE2_SPTR ccend = cc + 1;\n\nif (opcode == OP_COMMIT_ARG || opcode == OP_PRUNE_ARG ||\n    opcode == OP_SKIP_ARG || opcode == OP_THEN_ARG)\n  ccend += 2 + cc[1];\n\nPUSH_BACKTRACK(sizeof(backtrack_common), cc, NULL);\n\nif (opcode == OP_SKIP)\n  {\n  allocate_stack(common, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n  return ccend;\n  }\n\nif (opcode == OP_COMMIT_ARG || opcode == OP_PRUNE_ARG || opcode == OP_THEN_ARG)\n  {\n  if (HAS_VIRTUAL_REGISTERS)\n    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)(cc + 2));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, TMP2, 0);\n  OP1(SLJIT_MOV, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? TMP1 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, mark_ptr), TMP2, 0);\n  }\n\nreturn ccend;\n}\n\nstatic PCRE2_UCHAR then_trap_opcode[1] = { OP_THEN_TRAP };\n\nstatic SLJIT_INLINE void compile_then_trap_matchingpath(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nBOOL needs_control_head;\nint size;\n\nPUSH_BACKTRACK_NOVALUE(sizeof(then_trap_backtrack), cc);\ncommon->then_trap = BACKTRACK_AS(then_trap_backtrack);\nBACKTRACK_AS(then_trap_backtrack)->common.cc = then_trap_opcode;\nBACKTRACK_AS(then_trap_backtrack)->start = (sljit_sw)(cc - common->start);\nBACKTRACK_AS(then_trap_backtrack)->framesize = get_framesize(common, cc, ccend, FALSE, &needs_control_head);\n\nsize = BACKTRACK_AS(then_trap_backtrack)->framesize;\nsize = 3 + (size < 0 ? 0 : size);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\nallocate_stack(common, size);\nif (size > 3)\n  OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, STACK_TOP, 0, SLJIT_IMM, (size - 3) * sizeof(sljit_sw));\nelse\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, STACK_TOP, 0);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(size - 1), SLJIT_IMM, BACKTRACK_AS(then_trap_backtrack)->start);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(size - 2), SLJIT_IMM, type_then_trap);\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(size - 3), TMP2, 0);\n\nsize = BACKTRACK_AS(then_trap_backtrack)->framesize;\nif (size >= 0)\n  init_frame(common, cc, ccend, size - 1, 0);\n}\n\nstatic void compile_matchingpath(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend, backtrack_common *parent)\n{\nDEFINE_COMPILER;\nbacktrack_common *backtrack;\nBOOL has_then_trap = FALSE;\nthen_trap_backtrack *save_then_trap = NULL;\n\nSLJIT_ASSERT(*ccend == OP_END || (*ccend >= OP_ALT && *ccend <= OP_KETRPOS));\n\nif (common->has_then && common->then_offsets[cc - common->start] != 0)\n  {\n  SLJIT_ASSERT(*ccend != OP_END && common->control_head_ptr != 0);\n  has_then_trap = TRUE;\n  save_then_trap = common->then_trap;\n  /* Tail item on backtrack. */\n  compile_then_trap_matchingpath(common, cc, ccend, parent);\n  }\n\nwhile (cc < ccend)\n  {\n  switch(*cc)\n    {\n    case OP_SOD:\n    case OP_SOM:\n    case OP_NOT_WORD_BOUNDARY:\n    case OP_WORD_BOUNDARY:\n    case OP_EODN:\n    case OP_EOD:\n    case OP_DOLL:\n    case OP_DOLLM:\n    case OP_CIRC:\n    case OP_CIRCM:\n    case OP_REVERSE:\n    cc = compile_simple_assertion_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks);\n    break;\n\n    case OP_NOT_DIGIT:\n    case OP_DIGIT:\n    case OP_NOT_WHITESPACE:\n    case OP_WHITESPACE:\n    case OP_NOT_WORDCHAR:\n    case OP_WORDCHAR:\n    case OP_ANY:\n    case OP_ALLANY:\n    case OP_ANYBYTE:\n    case OP_NOTPROP:\n    case OP_PROP:\n    case OP_ANYNL:\n    case OP_NOT_HSPACE:\n    case OP_HSPACE:\n    case OP_NOT_VSPACE:\n    case OP_VSPACE:\n    case OP_EXTUNI:\n    case OP_NOT:\n    case OP_NOTI:\n    cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n\n    case OP_SET_SOM:\n    PUSH_BACKTRACK_NOVALUE(sizeof(backtrack_common), cc);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n    allocate_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), STR_PTR, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n    cc++;\n    break;\n\n    case OP_CHAR:\n    case OP_CHARI:\n    if (common->mode == PCRE2_JIT_COMPLETE)\n      cc = compile_charn_matchingpath(common, cc, ccend, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks);\n    else\n      cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_UPTO:\n    case OP_MINUPTO:\n    case OP_EXACT:\n    case OP_POSSTAR:\n    case OP_POSPLUS:\n    case OP_POSQUERY:\n    case OP_POSUPTO:\n    case OP_STARI:\n    case OP_MINSTARI:\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_UPTOI:\n    case OP_MINUPTOI:\n    case OP_EXACTI:\n    case OP_POSSTARI:\n    case OP_POSPLUSI:\n    case OP_POSQUERYI:\n    case OP_POSUPTOI:\n    case OP_NOTSTAR:\n    case OP_NOTMINSTAR:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTQUERY:\n    case OP_NOTMINQUERY:\n    case OP_NOTUPTO:\n    case OP_NOTMINUPTO:\n    case OP_NOTEXACT:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSUPTO:\n    case OP_NOTSTARI:\n    case OP_NOTMINSTARI:\n    case OP_NOTPLUSI:\n    case OP_NOTMINPLUSI:\n    case OP_NOTQUERYI:\n    case OP_NOTMINQUERYI:\n    case OP_NOTUPTOI:\n    case OP_NOTMINUPTOI:\n    case OP_NOTEXACTI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTPOSQUERYI:\n    case OP_NOTPOSUPTOI:\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    case OP_TYPEEXACT:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEPOSQUERY:\n    case OP_TYPEPOSUPTO:\n    cc = compile_iterator_matchingpath(common, cc, parent);\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n    if (cc[1 + (32 / sizeof(PCRE2_UCHAR))] >= OP_CRSTAR && cc[1 + (32 / sizeof(PCRE2_UCHAR))] <= OP_CRPOSRANGE)\n      cc = compile_iterator_matchingpath(common, cc, parent);\n    else\n      cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32\n    case OP_XCLASS:\n    if (*(cc + GET(cc, 1)) >= OP_CRSTAR && *(cc + GET(cc, 1)) <= OP_CRPOSRANGE)\n      cc = compile_iterator_matchingpath(common, cc, parent);\n    else\n      cc = compile_char1_matchingpath(common, *cc, cc + 1, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE);\n    break;\n#endif\n\n    case OP_REF:\n    case OP_REFI:\n    if (cc[1 + IMM2_SIZE] >= OP_CRSTAR && cc[1 + IMM2_SIZE] <= OP_CRPOSRANGE)\n      cc = compile_ref_iterator_matchingpath(common, cc, parent);\n    else\n      {\n      compile_ref_matchingpath(common, cc, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE, FALSE);\n      cc += 1 + IMM2_SIZE;\n      }\n    break;\n\n    case OP_DNREF:\n    case OP_DNREFI:\n    if (cc[1 + 2 * IMM2_SIZE] >= OP_CRSTAR && cc[1 + 2 * IMM2_SIZE] <= OP_CRPOSRANGE)\n      cc = compile_ref_iterator_matchingpath(common, cc, parent);\n    else\n      {\n      compile_dnref_search(common, cc, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks);\n      compile_ref_matchingpath(common, cc, parent->top != NULL ? &parent->top->nextbacktracks : &parent->topbacktracks, TRUE, FALSE);\n      cc += 1 + 2 * IMM2_SIZE;\n      }\n    break;\n\n    case OP_RECURSE:\n    cc = compile_recurse_matchingpath(common, cc, parent);\n    break;\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n    cc = compile_callout_matchingpath(common, cc, parent);\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    PUSH_BACKTRACK_NOVALUE(sizeof(assert_backtrack), cc);\n    cc = compile_assert_matchingpath(common, cc, BACKTRACK_AS(assert_backtrack), FALSE);\n    break;\n\n    case OP_BRAMINZERO:\n    PUSH_BACKTRACK_NOVALUE(sizeof(braminzero_backtrack), cc);\n    cc = bracketend(cc + 1);\n    if (*(cc - 1 - LINK_SIZE) != OP_KETRMIN)\n      {\n      allocate_stack(common, 1);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n      }\n    else\n      {\n      allocate_stack(common, 2);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), STR_PTR, 0);\n      }\n    BACKTRACK_AS(braminzero_backtrack)->matchingpath = LABEL();\n    count_match(common);\n    break;\n\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRA:\n    case OP_CBRA:\n    case OP_COND:\n    case OP_SBRA:\n    case OP_SCBRA:\n    case OP_SCOND:\n    cc = compile_bracket_matchingpath(common, cc, parent);\n    break;\n\n    case OP_BRAZERO:\n    if (cc[1] > OP_ASSERTBACK_NOT)\n      cc = compile_bracket_matchingpath(common, cc, parent);\n    else\n      {\n      PUSH_BACKTRACK_NOVALUE(sizeof(assert_backtrack), cc);\n      cc = compile_assert_matchingpath(common, cc, BACKTRACK_AS(assert_backtrack), FALSE);\n      }\n    break;\n\n    case OP_BRAPOS:\n    case OP_CBRAPOS:\n    case OP_SBRAPOS:\n    case OP_SCBRAPOS:\n    case OP_BRAPOSZERO:\n    cc = compile_bracketpos_matchingpath(common, cc, parent);\n    break;\n\n    case OP_MARK:\n    PUSH_BACKTRACK_NOVALUE(sizeof(backtrack_common), cc);\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->mark_ptr);\n    allocate_stack(common, common->has_skip_arg ? 5 : 1);\n    if (HAS_VIRTUAL_REGISTERS)\n      OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(common->has_skip_arg ? 4 : 0), TMP2, 0);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)(cc + 2));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, TMP2, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(HAS_VIRTUAL_REGISTERS ? TMP1 : ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, mark_ptr), TMP2, 0);\n    if (common->has_skip_arg)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, STACK_TOP, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, type_mark);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(2), SLJIT_IMM, (sljit_sw)(cc + 2));\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(3), STR_PTR, 0);\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP1, 0);\n      }\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_PRUNE:\n    case OP_PRUNE_ARG:\n    case OP_SKIP:\n    case OP_SKIP_ARG:\n    case OP_THEN:\n    case OP_THEN_ARG:\n    case OP_COMMIT:\n    case OP_COMMIT_ARG:\n    cc = compile_control_verb_matchingpath(common, cc, parent);\n    break;\n\n    case OP_FAIL:\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    cc = compile_fail_accept_matchingpath(common, cc, parent);\n    break;\n\n    case OP_CLOSE:\n    cc = compile_close_matchingpath(common, cc);\n    break;\n\n    case OP_SKIPZERO:\n    cc = bracketend(cc + 1);\n    break;\n\n    default:\n    SLJIT_UNREACHABLE();\n    return;\n    }\n  if (cc == NULL)\n    return;\n  }\n\nif (has_then_trap)\n  {\n  /* Head item on backtrack. */\n  PUSH_BACKTRACK_NOVALUE(sizeof(then_trap_backtrack), cc);\n  BACKTRACK_AS(then_trap_backtrack)->common.cc = then_trap_opcode;\n  BACKTRACK_AS(then_trap_backtrack)->then_trap = common->then_trap;\n  common->then_trap = save_then_trap;\n  }\nSLJIT_ASSERT(cc == ccend);\n}\n\n#undef PUSH_BACKTRACK\n#undef PUSH_BACKTRACK_NOVALUE\n#undef BACKTRACK_AS\n\n#define COMPILE_BACKTRACKINGPATH(current) \\\n  do \\\n    { \\\n    compile_backtrackingpath(common, (current)); \\\n    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \\\n      return; \\\n    } \\\n  while (0)\n\n#define CURRENT_AS(type) ((type *)current)\n\nstatic void compile_iterator_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = current->cc;\nPCRE2_UCHAR opcode;\nPCRE2_UCHAR type;\nsljit_u32 max = 0, exact;\nstruct sljit_label *label = NULL;\nstruct sljit_jump *jump = NULL;\njump_list *jumplist = NULL;\nPCRE2_SPTR end;\nint private_data_ptr = PRIVATE_DATA(cc);\nint base = (private_data_ptr == 0) ? SLJIT_MEM1(STACK_TOP) : SLJIT_MEM1(SLJIT_SP);\nint offset0 = (private_data_ptr == 0) ? STACK(0) : private_data_ptr;\nint offset1 = (private_data_ptr == 0) ? STACK(1) : private_data_ptr + (int)sizeof(sljit_sw);\n\ncc = get_iterator_parameters(common, cc, &opcode, &type, &max, &exact, &end);\n\nswitch(opcode)\n  {\n  case OP_STAR:\n  case OP_UPTO:\n  if (type == OP_ANYNL || type == OP_EXTUNI)\n    {\n    SLJIT_ASSERT(private_data_ptr == 0);\n    set_jumps(CURRENT_AS(char_iterator_backtrack)->u.backtracks, LABEL());\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n    }\n  else\n    {\n    if (CURRENT_AS(char_iterator_backtrack)->u.charpos.enabled)\n      {\n      OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n      OP1(SLJIT_MOV, TMP2, 0, base, offset1);\n      OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));\n\n      jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);\n      label = LABEL();\n      OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      if (CURRENT_AS(char_iterator_backtrack)->u.charpos.othercasebit != 0)\n        OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, CURRENT_AS(char_iterator_backtrack)->u.charpos.othercasebit);\n      CMPTO(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CURRENT_AS(char_iterator_backtrack)->u.charpos.chr, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n      move_back(common, NULL, TRUE);\n      CMPTO(SLJIT_GREATER, STR_PTR, 0, TMP2, 0, label);\n      }\n    else\n      {\n      OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n      jump = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, base, offset1);\n      move_back(common, NULL, TRUE);\n      OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n      JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n      }\n    JUMPHERE(jump);\n    if (private_data_ptr == 0)\n      free_stack(common, 2);\n    }\n  break;\n\n  case OP_MINSTAR:\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  compile_char1_matchingpath(common, type, cc, &jumplist, TRUE);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  set_jumps(jumplist, LABEL());\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  break;\n\n  case OP_MINUPTO:\n  OP1(SLJIT_MOV, TMP1, 0, base, offset1);\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP2(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\n  add_jump(compiler, &jumplist, JUMP(SLJIT_ZERO));\n\n  OP1(SLJIT_MOV, base, offset1, TMP1, 0);\n  compile_char1_matchingpath(common, type, cc, &jumplist, TRUE);\n  OP1(SLJIT_MOV, base, offset0, STR_PTR, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n\n  set_jumps(jumplist, LABEL());\n  if (private_data_ptr == 0)\n    free_stack(common, 2);\n  break;\n\n  case OP_QUERY:\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP1(SLJIT_MOV, base, offset0, SLJIT_IMM, 0);\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  jump = JUMP(SLJIT_JUMP);\n  set_jumps(CURRENT_AS(char_iterator_backtrack)->u.backtracks, LABEL());\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP1(SLJIT_MOV, base, offset0, SLJIT_IMM, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  JUMPHERE(jump);\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  break;\n\n  case OP_MINQUERY:\n  OP1(SLJIT_MOV, STR_PTR, 0, base, offset0);\n  OP1(SLJIT_MOV, base, offset0, SLJIT_IMM, 0);\n  jump = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n  compile_char1_matchingpath(common, type, cc, &jumplist, TRUE);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(char_iterator_backtrack)->matchingpath);\n  set_jumps(jumplist, LABEL());\n  JUMPHERE(jump);\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  break;\n\n  case OP_EXACT:\n  case OP_POSSTAR:\n  case OP_POSQUERY:\n  case OP_POSUPTO:\n  break;\n\n  default:\n  SLJIT_UNREACHABLE();\n  break;\n  }\n\nset_jumps(current->topbacktracks, LABEL());\n}\n\nstatic SLJIT_INLINE void compile_ref_iterator_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = current->cc;\nBOOL ref = (*cc == OP_REF || *cc == OP_REFI);\nPCRE2_UCHAR type;\n\ntype = cc[ref ? 1 + IMM2_SIZE : 1 + 2 * IMM2_SIZE];\n\nif ((type & 0x1) == 0)\n  {\n  /* Maximize case. */\n  set_jumps(current->topbacktracks, LABEL());\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(ref_iterator_backtrack)->matchingpath);\n  return;\n  }\n\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\nCMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(ref_iterator_backtrack)->matchingpath);\nset_jumps(current->topbacktracks, LABEL());\nfree_stack(common, ref ? 2 : 3);\n}\n\nstatic SLJIT_INLINE void compile_recurse_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nrecurse_entry *entry;\n\nif (!CURRENT_AS(recurse_backtrack)->inlined_pattern)\n  {\n  entry = CURRENT_AS(recurse_backtrack)->entry;\n  if (entry->backtrack_label == NULL)\n    add_jump(compiler, &entry->backtrack_calls, JUMP(SLJIT_FAST_CALL));\n  else\n    JUMPTO(SLJIT_FAST_CALL, entry->backtrack_label);\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, CURRENT_AS(recurse_backtrack)->matchingpath);\n  }\nelse\n  compile_backtrackingpath(common, current->top);\n\nset_jumps(current->topbacktracks, LABEL());\n}\n\nstatic void compile_assert_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = current->cc;\nPCRE2_UCHAR bra = OP_BRA;\nstruct sljit_jump *brajump = NULL;\n\nSLJIT_ASSERT(*cc != OP_BRAMINZERO);\nif (*cc == OP_BRAZERO)\n  {\n  bra = *cc;\n  cc++;\n  }\n\nif (bra == OP_BRAZERO)\n  {\n  SLJIT_ASSERT(current->topbacktracks == NULL);\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  }\n\nif (CURRENT_AS(assert_backtrack)->framesize < 0)\n  {\n  set_jumps(current->topbacktracks, LABEL());\n\n  if (bra == OP_BRAZERO)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n    CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(assert_backtrack)->matchingpath);\n    free_stack(common, 1);\n    }\n  return;\n  }\n\nif (bra == OP_BRAZERO)\n  {\n  if (*cc == OP_ASSERT_NOT || *cc == OP_ASSERTBACK_NOT)\n    {\n    OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n    CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(assert_backtrack)->matchingpath);\n    free_stack(common, 1);\n    return;\n    }\n  free_stack(common, 1);\n  brajump = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0);\n  }\n\nif (*cc == OP_ASSERT || *cc == OP_ASSERTBACK)\n  {\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(assert_backtrack)->private_data_ptr);\n  add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n  OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(assert_backtrack)->framesize - 1) * sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(assert_backtrack)->private_data_ptr, TMP1, 0);\n\n  set_jumps(current->topbacktracks, LABEL());\n  }\nelse\n  set_jumps(current->topbacktracks, LABEL());\n\nif (bra == OP_BRAZERO)\n  {\n  /* We know there is enough place on the stack. */\n  OP2(SLJIT_SUB, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, sizeof(sljit_sw));\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), SLJIT_IMM, 0);\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(assert_backtrack)->matchingpath);\n  JUMPHERE(brajump);\n  }\n}\n\nstatic void compile_bracket_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nint opcode, stacksize, alt_count, alt_max;\nint offset = 0;\nint private_data_ptr = CURRENT_AS(bracket_backtrack)->private_data_ptr;\nint repeat_ptr = 0, repeat_type = 0, repeat_count = 0;\nPCRE2_SPTR cc = current->cc;\nPCRE2_SPTR ccbegin;\nPCRE2_SPTR ccprev;\nPCRE2_UCHAR bra = OP_BRA;\nPCRE2_UCHAR ket;\nassert_backtrack *assert;\nBOOL has_alternatives;\nBOOL needs_control_head = FALSE;\nstruct sljit_jump *brazero = NULL;\nstruct sljit_jump *next_alt = NULL;\nstruct sljit_jump *once = NULL;\nstruct sljit_jump *cond = NULL;\nstruct sljit_label *rmin_label = NULL;\nstruct sljit_label *exact_label = NULL;\nstruct sljit_put_label *put_label = NULL;\n\nif (*cc == OP_BRAZERO || *cc == OP_BRAMINZERO)\n  {\n  bra = *cc;\n  cc++;\n  }\n\nopcode = *cc;\nccbegin = bracketend(cc) - 1 - LINK_SIZE;\nket = *ccbegin;\nif (ket == OP_KET && PRIVATE_DATA(ccbegin) != 0)\n  {\n  repeat_ptr = PRIVATE_DATA(ccbegin);\n  repeat_type = PRIVATE_DATA(ccbegin + 2);\n  repeat_count = PRIVATE_DATA(ccbegin + 3);\n  SLJIT_ASSERT(repeat_type != 0 && repeat_count != 0);\n  if (repeat_type == OP_UPTO)\n    ket = OP_KETRMAX;\n  if (repeat_type == OP_MINUPTO)\n    ket = OP_KETRMIN;\n  }\nccbegin = cc;\ncc += GET(cc, 1);\nhas_alternatives = *cc == OP_ALT;\nif (SLJIT_UNLIKELY(opcode == OP_COND) || SLJIT_UNLIKELY(opcode == OP_SCOND))\n  has_alternatives = (ccbegin[1 + LINK_SIZE] >= OP_ASSERT && ccbegin[1 + LINK_SIZE] <= OP_ASSERTBACK_NOT) || CURRENT_AS(bracket_backtrack)->u.condfailed != NULL;\nif (opcode == OP_CBRA || opcode == OP_SCBRA)\n  offset = (GET2(ccbegin, 1 + LINK_SIZE)) << 1;\nif (SLJIT_UNLIKELY(opcode == OP_COND) && (*cc == OP_KETRMAX || *cc == OP_KETRMIN))\n  opcode = OP_SCOND;\n\nalt_max = has_alternatives ? no_alternatives(ccbegin) : 0;\n\n/* Decoding the needs_control_head in framesize. */\nif (opcode == OP_ONCE)\n  {\n  needs_control_head = (CURRENT_AS(bracket_backtrack)->u.framesize & 0x1) != 0;\n  CURRENT_AS(bracket_backtrack)->u.framesize >>= 1;\n  }\n\nif (ket != OP_KET && repeat_type != 0)\n  {\n  /* TMP1 is used in OP_KETRMIN below. */\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  if (repeat_type == OP_UPTO)\n    OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), repeat_ptr, TMP1, 0, SLJIT_IMM, 1);\n  else\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, TMP1, 0);\n  }\n\nif (ket == OP_KETRMAX)\n  {\n  if (bra == OP_BRAZERO)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    brazero = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n    }\n  }\nelse if (ket == OP_KETRMIN)\n  {\n  if (bra != OP_BRAMINZERO)\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    if (repeat_type != 0)\n      {\n      /* TMP1 was set a few lines above. */\n      CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n      /* Drop STR_PTR for non-greedy plus quantifier. */\n      if (opcode != OP_ONCE)\n        free_stack(common, 1);\n      }\n    else if (opcode >= OP_SBRA || opcode == OP_ONCE)\n      {\n      /* Checking zero-length iteration. */\n      if (opcode != OP_ONCE || CURRENT_AS(bracket_backtrack)->u.framesize < 0)\n        CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n      else\n        {\n        OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n        CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_MEM1(TMP1), STACK(-CURRENT_AS(bracket_backtrack)->u.framesize - 2), CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n        }\n      /* Drop STR_PTR for non-greedy plus quantifier. */\n      if (opcode != OP_ONCE)\n        free_stack(common, 1);\n      }\n    else\n      JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n    }\n  rmin_label = LABEL();\n  if (repeat_type != 0)\n    OP2(SLJIT_ADD, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  }\nelse if (bra == OP_BRAZERO)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  brazero = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n  }\nelse if (repeat_type == OP_EXACT)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  exact_label = LABEL();\n  }\n\nif (offset != 0)\n  {\n  if (common->capture_last_ptr != 0)\n    {\n    SLJIT_ASSERT(common->optimized_cbracket[offset >> 1] == 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, TMP1, 0);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(2));\n    free_stack(common, 3);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP2, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP1, 0);\n    }\n  else if (common->optimized_cbracket[offset >> 1] == 0)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    free_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP2, 0);\n    }\n  }\n\nif (SLJIT_UNLIKELY(opcode == OP_ONCE))\n  {\n  if (CURRENT_AS(bracket_backtrack)->u.framesize >= 0)\n    {\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n    add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n    OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(bracket_backtrack)->u.framesize - 1) * sizeof(sljit_sw));\n    }\n  once = JUMP(SLJIT_JUMP);\n  }\nelse if (SLJIT_UNLIKELY(opcode == OP_COND) || SLJIT_UNLIKELY(opcode == OP_SCOND))\n  {\n  if (has_alternatives)\n    {\n    /* Always exactly one alternative. */\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n\n    alt_max = 2;\n    next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n    }\n  }\nelse if (has_alternatives)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n\n  if (alt_max > 3)\n    {\n    sljit_emit_ijump(compiler, SLJIT_JUMP, TMP1, 0);\n\n    SLJIT_ASSERT(CURRENT_AS(bracket_backtrack)->u.matching_put_label);\n    sljit_set_put_label(CURRENT_AS(bracket_backtrack)->u.matching_put_label, LABEL());\n    sljit_emit_op0(compiler, SLJIT_ENDBR);\n    }\n  else\n    next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n  }\n\nCOMPILE_BACKTRACKINGPATH(current->top);\nif (current->topbacktracks)\n  set_jumps(current->topbacktracks, LABEL());\n\nif (SLJIT_UNLIKELY(opcode == OP_COND) || SLJIT_UNLIKELY(opcode == OP_SCOND))\n  {\n  /* Conditional block always has at most one alternative. */\n  if (ccbegin[1 + LINK_SIZE] >= OP_ASSERT && ccbegin[1 + LINK_SIZE] <= OP_ASSERTBACK_NOT)\n    {\n    SLJIT_ASSERT(has_alternatives);\n    assert = CURRENT_AS(bracket_backtrack)->u.assert;\n    if (assert->framesize >= 0 && (ccbegin[1 + LINK_SIZE] == OP_ASSERT || ccbegin[1 + LINK_SIZE] == OP_ASSERTBACK))\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (assert->framesize - 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr, TMP1, 0);\n      }\n    cond = JUMP(SLJIT_JUMP);\n    set_jumps(CURRENT_AS(bracket_backtrack)->u.assert->condfailed, LABEL());\n    }\n  else if (CURRENT_AS(bracket_backtrack)->u.condfailed != NULL)\n    {\n    SLJIT_ASSERT(has_alternatives);\n    cond = JUMP(SLJIT_JUMP);\n    set_jumps(CURRENT_AS(bracket_backtrack)->u.condfailed, LABEL());\n    }\n  else\n    SLJIT_ASSERT(!has_alternatives);\n  }\n\nif (has_alternatives)\n  {\n  alt_count = 1;\n  do\n    {\n    current->top = NULL;\n    current->topbacktracks = NULL;\n    current->nextbacktracks = NULL;\n    /* Conditional blocks always have an additional alternative, even if it is empty. */\n    if (*cc == OP_ALT)\n      {\n      ccprev = cc + 1 + LINK_SIZE;\n      cc += GET(cc, 1);\n      if (opcode != OP_COND && opcode != OP_SCOND)\n        {\n        if (opcode != OP_ONCE)\n          {\n          if (private_data_ptr != 0)\n            OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n          else\n            OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n          }\n        else\n          OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(needs_control_head ? 1 : 0));\n        }\n      compile_matchingpath(common, ccprev, cc, current);\n      if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n        return;\n\n      if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA)\n        OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), private_data_ptr);\n\n      if (opcode == OP_SCRIPT_RUN)\n        match_script_run_common(common, private_data_ptr, current);\n      }\n\n    /* Instructions after the current alternative is successfully matched. */\n    /* There is a similar code in compile_bracket_matchingpath. */\n    if (opcode == OP_ONCE)\n      match_once_common(common, ket, CURRENT_AS(bracket_backtrack)->u.framesize, private_data_ptr, has_alternatives, needs_control_head);\n\n    stacksize = 0;\n    if (repeat_type == OP_MINUPTO)\n      {\n      /* We need to preserve the counter. TMP2 will be used below. */\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr);\n      stacksize++;\n      }\n    if (ket != OP_KET || bra != OP_BRA)\n      stacksize++;\n    if (offset != 0)\n      {\n      if (common->capture_last_ptr != 0)\n        stacksize++;\n      if (common->optimized_cbracket[offset >> 1] == 0)\n        stacksize += 2;\n      }\n    if (opcode != OP_ONCE)\n      stacksize++;\n\n    if (stacksize > 0)\n      allocate_stack(common, stacksize);\n\n    stacksize = 0;\n    if (repeat_type == OP_MINUPTO)\n      {\n      /* TMP2 was set above. */\n      OP2(SLJIT_SUB, SLJIT_MEM1(STACK_TOP), STACK(stacksize), TMP2, 0, SLJIT_IMM, 1);\n      stacksize++;\n      }\n\n    if (ket != OP_KET || bra != OP_BRA)\n      {\n      if (ket != OP_KET)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), STR_PTR, 0);\n      else\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, 0);\n      stacksize++;\n      }\n\n    if (offset != 0)\n      stacksize = match_capture_common(common, stacksize, offset, private_data_ptr);\n\n    if (opcode != OP_ONCE)\n      {\n      if (alt_max <= 3)\n        OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(stacksize), SLJIT_IMM, alt_count);\n      else\n        put_label = sljit_emit_put_label(compiler, SLJIT_MEM1(STACK_TOP), STACK(stacksize));\n      }\n\n    if (offset != 0 && ket == OP_KETRMAX && common->optimized_cbracket[offset >> 1] != 0)\n      {\n      /* If ket is not OP_KETRMAX, this code path is executed after the jump to alternative_matchingpath. */\n      SLJIT_ASSERT(private_data_ptr == OVECTOR(offset + 0));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), STR_PTR, 0);\n      }\n\n    JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->alternative_matchingpath);\n\n    if (opcode != OP_ONCE)\n      {\n      if (alt_max <= 3)\n        {\n        JUMPHERE(next_alt);\n        alt_count++;\n        if (alt_count < alt_max)\n          {\n          SLJIT_ASSERT(alt_count == 2 && alt_max == 3);\n          next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 1);\n          }\n        }\n      else\n        {\n        sljit_set_put_label(put_label, LABEL());\n        sljit_emit_op0(compiler, SLJIT_ENDBR);\n        }\n      }\n\n    COMPILE_BACKTRACKINGPATH(current->top);\n    if (current->topbacktracks)\n      set_jumps(current->topbacktracks, LABEL());\n    SLJIT_ASSERT(!current->nextbacktracks);\n    }\n  while (*cc == OP_ALT);\n\n  if (cond != NULL)\n    {\n    SLJIT_ASSERT(opcode == OP_COND || opcode == OP_SCOND);\n    assert = CURRENT_AS(bracket_backtrack)->u.assert;\n    if ((ccbegin[1 + LINK_SIZE] == OP_ASSERT_NOT || ccbegin[1 + LINK_SIZE] == OP_ASSERTBACK_NOT) && assert->framesize >= 0)\n      {\n      OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr);\n      add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(-2));\n      OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (assert->framesize - 1) * sizeof(sljit_sw));\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), assert->private_data_ptr, TMP1, 0);\n      }\n    JUMPHERE(cond);\n    }\n\n  /* Free the STR_PTR. */\n  if (private_data_ptr == 0)\n    free_stack(common, 1);\n  }\n\nif (offset != 0)\n  {\n  /* Using both tmp register is better for instruction scheduling. */\n  if (common->optimized_cbracket[offset >> 1] != 0)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    free_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP2, 0);\n    }\n  else\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n  }\nelse if (opcode == OP_ASSERT_NA || opcode == OP_ASSERTBACK_NA || opcode == OP_SCRIPT_RUN || opcode == OP_SBRA || opcode == OP_SCOND)\n  {\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(0));\n  free_stack(common, 1);\n  }\nelse if (opcode == OP_ONCE)\n  {\n  cc = ccbegin + GET(ccbegin, 1);\n  stacksize = needs_control_head ? 1 : 0;\n\n  if (CURRENT_AS(bracket_backtrack)->u.framesize >= 0)\n    {\n    /* Reset head and drop saved frame. */\n    stacksize += CURRENT_AS(bracket_backtrack)->u.framesize + ((ket != OP_KET || *cc == OP_ALT) ? 2 : 1);\n    }\n  else if (ket == OP_KETRMAX || (*cc == OP_ALT && ket != OP_KETRMIN))\n    {\n    /* The STR_PTR must be released. */\n    stacksize++;\n    }\n\n  if (stacksize > 0)\n    free_stack(common, stacksize);\n\n  JUMPHERE(once);\n  /* Restore previous private_data_ptr */\n  if (CURRENT_AS(bracket_backtrack)->u.framesize >= 0)\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-CURRENT_AS(bracket_backtrack)->u.framesize - 1));\n  else if (ket == OP_KETRMIN)\n    {\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    /* See the comment below. */\n    free_stack(common, 2);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), private_data_ptr, TMP1, 0);\n    }\n  }\n\nif (repeat_type == OP_EXACT)\n  {\n  OP2(SLJIT_ADD, TMP1, 0, SLJIT_MEM1(SLJIT_SP), repeat_ptr, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), repeat_ptr, TMP1, 0);\n  CMPTO(SLJIT_LESS_EQUAL, TMP1, 0, SLJIT_IMM, repeat_count, exact_label);\n  }\nelse if (ket == OP_KETRMAX)\n  {\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  if (bra != OP_BRAZERO)\n    free_stack(common, 1);\n\n  CMPTO(SLJIT_NOT_EQUAL, STR_PTR, 0, SLJIT_IMM, 0, CURRENT_AS(bracket_backtrack)->recursive_matchingpath);\n  if (bra == OP_BRAZERO)\n    {\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->zero_matchingpath);\n    JUMPHERE(brazero);\n    free_stack(common, 1);\n    }\n  }\nelse if (ket == OP_KETRMIN)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  /* OP_ONCE removes everything in case of a backtrack, so we don't\n  need to explicitly release the STR_PTR. The extra release would\n  affect badly the free_stack(2) above. */\n  if (opcode != OP_ONCE)\n    free_stack(common, 1);\n  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0, rmin_label);\n  if (opcode == OP_ONCE)\n    free_stack(common, bra == OP_BRAMINZERO ? 2 : 1);\n  else if (bra == OP_BRAMINZERO)\n    free_stack(common, 1);\n  }\nelse if (bra == OP_BRAZERO)\n  {\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n  JUMPTO(SLJIT_JUMP, CURRENT_AS(bracket_backtrack)->zero_matchingpath);\n  JUMPHERE(brazero);\n  }\n}\n\nstatic SLJIT_INLINE void compile_bracketpos_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nint offset;\nstruct sljit_jump *jump;\n\nif (CURRENT_AS(bracketpos_backtrack)->framesize < 0)\n  {\n  if (*current->cc == OP_CBRAPOS || *current->cc == OP_SCBRAPOS)\n    {\n    offset = (GET2(current->cc, 1 + LINK_SIZE)) << 1;\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset), TMP1, 0);\n    if (common->capture_last_ptr != 0)\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(2));\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(offset + 1), TMP2, 0);\n    if (common->capture_last_ptr != 0)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, TMP1, 0);\n    }\n  set_jumps(current->topbacktracks, LABEL());\n  free_stack(common, CURRENT_AS(bracketpos_backtrack)->stacksize);\n  return;\n  }\n\nOP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(bracketpos_backtrack)->private_data_ptr);\nadd_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\nOP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(bracketpos_backtrack)->framesize - 1) * sizeof(sljit_sw));\n\nif (current->topbacktracks)\n  {\n  jump = JUMP(SLJIT_JUMP);\n  set_jumps(current->topbacktracks, LABEL());\n  /* Drop the stack frame. */\n  free_stack(common, CURRENT_AS(bracketpos_backtrack)->stacksize);\n  JUMPHERE(jump);\n  }\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), CURRENT_AS(bracketpos_backtrack)->private_data_ptr, SLJIT_MEM1(STACK_TOP), STACK(-CURRENT_AS(bracketpos_backtrack)->framesize - 1));\n}\n\nstatic SLJIT_INLINE void compile_braminzero_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nassert_backtrack backtrack;\n\ncurrent->top = NULL;\ncurrent->topbacktracks = NULL;\ncurrent->nextbacktracks = NULL;\nif (current->cc[1] > OP_ASSERTBACK_NOT)\n  {\n  /* Manual call of compile_bracket_matchingpath and compile_bracket_backtrackingpath. */\n  compile_bracket_matchingpath(common, current->cc, current);\n  compile_bracket_backtrackingpath(common, current->top);\n  }\nelse\n  {\n  memset(&backtrack, 0, sizeof(backtrack));\n  backtrack.common.cc = current->cc;\n  backtrack.matchingpath = CURRENT_AS(braminzero_backtrack)->matchingpath;\n  /* Manual call of compile_assert_matchingpath. */\n  compile_assert_matchingpath(common, current->cc, &backtrack, FALSE);\n  }\nSLJIT_ASSERT(!current->nextbacktracks && !current->topbacktracks);\n}\n\nstatic SLJIT_INLINE void compile_control_verb_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nPCRE2_UCHAR opcode = *current->cc;\nstruct sljit_label *loop;\nstruct sljit_jump *jump;\n\nif (opcode == OP_THEN || opcode == OP_THEN_ARG)\n  {\n  if (common->then_trap != NULL)\n    {\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, type_then_trap);\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, common->then_trap->start);\n    jump = JUMP(SLJIT_JUMP);\n\n    loop = LABEL();\n    OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    JUMPHERE(jump);\n    CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(1), TMP1, 0, loop);\n    CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(2), TMP2, 0, loop);\n    add_jump(compiler, &common->then_trap->quit, JUMP(SLJIT_JUMP));\n    return;\n    }\n  else if (!common->local_quit_available && common->in_positive_assertion)\n    {\n    add_jump(compiler, &common->positive_assertion_quit, JUMP(SLJIT_JUMP));\n    return;\n    }\n  }\n\nif (common->local_quit_available)\n  {\n  /* Abort match with a fail. */\n  if (common->quit_label == NULL)\n    add_jump(compiler, &common->quit, JUMP(SLJIT_JUMP));\n  else\n    JUMPTO(SLJIT_JUMP, common->quit_label);\n  return;\n  }\n\nif (opcode == OP_SKIP_ARG)\n  {\n  SLJIT_ASSERT(common->control_head_ptr != 0 && TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr);\n  OP1(SLJIT_MOV, SLJIT_R1, 0, SLJIT_IMM, (sljit_sw)(current->cc + 2));\n  sljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(do_search_mark));\n\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_R0, 0);\n  add_jump(compiler, &common->reset_match, CMP(SLJIT_NOT_EQUAL, SLJIT_R0, 0, SLJIT_IMM, 0));\n  return;\n  }\n\nif (opcode == OP_SKIP)\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\nelse\n  OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_IMM, 0);\nadd_jump(compiler, &common->reset_match, JUMP(SLJIT_JUMP));\n}\n\nstatic SLJIT_INLINE void compile_then_trap_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nstruct sljit_jump *jump;\nint size;\n\nif (CURRENT_AS(then_trap_backtrack)->then_trap)\n  {\n  common->then_trap = CURRENT_AS(then_trap_backtrack)->then_trap;\n  return;\n  }\n\nsize = CURRENT_AS(then_trap_backtrack)->framesize;\nsize = 3 + (size < 0 ? 0 : size);\n\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(size - 3));\nfree_stack(common, size);\njump = JUMP(SLJIT_JUMP);\n\nset_jumps(CURRENT_AS(then_trap_backtrack)->quit, LABEL());\n/* STACK_TOP is set by THEN. */\nif (CURRENT_AS(then_trap_backtrack)->framesize >= 0)\n  {\n  add_jump(compiler, &common->revertframes, JUMP(SLJIT_FAST_CALL));\n  OP2(SLJIT_ADD, STACK_TOP, 0, STACK_TOP, 0, SLJIT_IMM, (CURRENT_AS(then_trap_backtrack)->framesize - 1) * sizeof(sljit_sw));\n  }\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\nfree_stack(common, 3);\n\nJUMPHERE(jump);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, TMP1, 0);\n}\n\nstatic void compile_backtrackingpath(compiler_common *common, struct backtrack_common *current)\n{\nDEFINE_COMPILER;\nthen_trap_backtrack *save_then_trap = common->then_trap;\n\nwhile (current)\n  {\n  if (current->nextbacktracks != NULL)\n    set_jumps(current->nextbacktracks, LABEL());\n  switch(*current->cc)\n    {\n    case OP_SET_SOM:\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), TMP1, 0);\n    break;\n\n    case OP_STAR:\n    case OP_MINSTAR:\n    case OP_PLUS:\n    case OP_MINPLUS:\n    case OP_QUERY:\n    case OP_MINQUERY:\n    case OP_UPTO:\n    case OP_MINUPTO:\n    case OP_EXACT:\n    case OP_POSSTAR:\n    case OP_POSPLUS:\n    case OP_POSQUERY:\n    case OP_POSUPTO:\n    case OP_STARI:\n    case OP_MINSTARI:\n    case OP_PLUSI:\n    case OP_MINPLUSI:\n    case OP_QUERYI:\n    case OP_MINQUERYI:\n    case OP_UPTOI:\n    case OP_MINUPTOI:\n    case OP_EXACTI:\n    case OP_POSSTARI:\n    case OP_POSPLUSI:\n    case OP_POSQUERYI:\n    case OP_POSUPTOI:\n    case OP_NOTSTAR:\n    case OP_NOTMINSTAR:\n    case OP_NOTPLUS:\n    case OP_NOTMINPLUS:\n    case OP_NOTQUERY:\n    case OP_NOTMINQUERY:\n    case OP_NOTUPTO:\n    case OP_NOTMINUPTO:\n    case OP_NOTEXACT:\n    case OP_NOTPOSSTAR:\n    case OP_NOTPOSPLUS:\n    case OP_NOTPOSQUERY:\n    case OP_NOTPOSUPTO:\n    case OP_NOTSTARI:\n    case OP_NOTMINSTARI:\n    case OP_NOTPLUSI:\n    case OP_NOTMINPLUSI:\n    case OP_NOTQUERYI:\n    case OP_NOTMINQUERYI:\n    case OP_NOTUPTOI:\n    case OP_NOTMINUPTOI:\n    case OP_NOTEXACTI:\n    case OP_NOTPOSSTARI:\n    case OP_NOTPOSPLUSI:\n    case OP_NOTPOSQUERYI:\n    case OP_NOTPOSUPTOI:\n    case OP_TYPESTAR:\n    case OP_TYPEMINSTAR:\n    case OP_TYPEPLUS:\n    case OP_TYPEMINPLUS:\n    case OP_TYPEQUERY:\n    case OP_TYPEMINQUERY:\n    case OP_TYPEUPTO:\n    case OP_TYPEMINUPTO:\n    case OP_TYPEEXACT:\n    case OP_TYPEPOSSTAR:\n    case OP_TYPEPOSPLUS:\n    case OP_TYPEPOSQUERY:\n    case OP_TYPEPOSUPTO:\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n#endif\n    compile_iterator_backtrackingpath(common, current);\n    break;\n\n    case OP_REF:\n    case OP_REFI:\n    case OP_DNREF:\n    case OP_DNREFI:\n    compile_ref_iterator_backtrackingpath(common, current);\n    break;\n\n    case OP_RECURSE:\n    compile_recurse_backtrackingpath(common, current);\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    compile_assert_backtrackingpath(common, current);\n    break;\n\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRA:\n    case OP_CBRA:\n    case OP_COND:\n    case OP_SBRA:\n    case OP_SCBRA:\n    case OP_SCOND:\n    compile_bracket_backtrackingpath(common, current);\n    break;\n\n    case OP_BRAZERO:\n    if (current->cc[1] > OP_ASSERTBACK_NOT)\n      compile_bracket_backtrackingpath(common, current);\n    else\n      compile_assert_backtrackingpath(common, current);\n    break;\n\n    case OP_BRAPOS:\n    case OP_CBRAPOS:\n    case OP_SBRAPOS:\n    case OP_SCBRAPOS:\n    case OP_BRAPOSZERO:\n    compile_bracketpos_backtrackingpath(common, current);\n    break;\n\n    case OP_BRAMINZERO:\n    compile_braminzero_backtrackingpath(common, current);\n    break;\n\n    case OP_MARK:\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(common->has_skip_arg ? 4 : 0));\n    if (common->has_skip_arg)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    free_stack(common, common->has_skip_arg ? 5 : 1);\n    OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, TMP1, 0);\n    if (common->has_skip_arg)\n      OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, TMP2, 0);\n    break;\n\n    case OP_THEN:\n    case OP_THEN_ARG:\n    case OP_PRUNE:\n    case OP_PRUNE_ARG:\n    case OP_SKIP:\n    case OP_SKIP_ARG:\n    compile_control_verb_backtrackingpath(common, current);\n    break;\n\n    case OP_COMMIT:\n    case OP_COMMIT_ARG:\n    if (!common->local_quit_available)\n      OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n    if (common->quit_label == NULL)\n      add_jump(compiler, &common->quit, JUMP(SLJIT_JUMP));\n    else\n      JUMPTO(SLJIT_JUMP, common->quit_label);\n    break;\n\n    case OP_CALLOUT:\n    case OP_CALLOUT_STR:\n    case OP_FAIL:\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    set_jumps(current->topbacktracks, LABEL());\n    break;\n\n    case OP_THEN_TRAP:\n    /* A virtual opcode for then traps. */\n    compile_then_trap_backtrackingpath(common, current);\n    break;\n\n    default:\n    SLJIT_UNREACHABLE();\n    break;\n    }\n  current = current->prev;\n  }\ncommon->then_trap = save_then_trap;\n}\n\nstatic SLJIT_INLINE void compile_recurse(compiler_common *common)\n{\nDEFINE_COMPILER;\nPCRE2_SPTR cc = common->start + common->currententry->start;\nPCRE2_SPTR ccbegin = cc + 1 + LINK_SIZE + (*cc == OP_BRA ? 0 : IMM2_SIZE);\nPCRE2_SPTR ccend = bracketend(cc) - (1 + LINK_SIZE);\nBOOL needs_control_head;\nBOOL has_quit;\nBOOL has_accept;\nint private_data_size = get_recurse_data_length(common, ccbegin, ccend, &needs_control_head, &has_quit, &has_accept);\nint alt_count, alt_max, local_size;\nbacktrack_common altbacktrack;\njump_list *match = NULL;\nstruct sljit_jump *next_alt = NULL;\nstruct sljit_jump *accept_exit = NULL;\nstruct sljit_label *quit;\nstruct sljit_put_label *put_label = NULL;\n\n/* Recurse captures then. */\ncommon->then_trap = NULL;\n\nSLJIT_ASSERT(*cc == OP_BRA || *cc == OP_CBRA || *cc == OP_CBRAPOS || *cc == OP_SCBRA || *cc == OP_SCBRAPOS);\n\nalt_max = no_alternatives(cc);\nalt_count = 0;\n\n/* Matching path. */\nSLJIT_ASSERT(common->currententry->entry_label == NULL && common->recursive_head_ptr != 0);\ncommon->currententry->entry_label = LABEL();\nset_jumps(common->currententry->entry_calls, common->currententry->entry_label);\n\nsljit_emit_fast_enter(compiler, TMP2, 0);\ncount_match(common);\n\nlocal_size = (alt_max > 1) ? 2 : 1;\n\n/* (Reversed) stack layout:\n   [private data][return address][optional: str ptr] ... [optional: alternative index][recursive_head_ptr] */\n\nallocate_stack(common, private_data_size + local_size);\n/* Save return address. */\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1), TMP2, 0);\n\ncopy_recurse_data(common, ccbegin, ccend, recurse_copy_from_global, local_size, private_data_size + local_size, has_quit);\n\n/* This variable is saved and restored all time when we enter or exit from a recursive context. */\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr, STACK_TOP, 0);\n\nif (needs_control_head)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n\nif (alt_max > 1)\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), STR_PTR, 0);\n\nmemset(&altbacktrack, 0, sizeof(backtrack_common));\ncommon->quit_label = NULL;\ncommon->accept_label = NULL;\ncommon->quit = NULL;\ncommon->accept = NULL;\naltbacktrack.cc = ccbegin;\ncc += GET(cc, 1);\nwhile (1)\n  {\n  altbacktrack.top = NULL;\n  altbacktrack.topbacktracks = NULL;\n\n  if (altbacktrack.cc != ccbegin)\n    OP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n\n  compile_matchingpath(common, altbacktrack.cc, cc, &altbacktrack);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return;\n\n  allocate_stack(common, (alt_max > 1 || has_accept) ? 2 : 1);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr);\n\n  if (alt_max > 1 || has_accept)\n    {\n    if (alt_max > 3)\n      put_label = sljit_emit_put_label(compiler, SLJIT_MEM1(STACK_TOP), STACK(1));\n    else\n      OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, alt_count);\n    }\n\n  add_jump(compiler, &match, JUMP(SLJIT_JUMP));\n\n  if (alt_count == 0)\n    {\n    /* Backtracking path entry. */\n    SLJIT_ASSERT(common->currententry->backtrack_label == NULL);\n    common->currententry->backtrack_label = LABEL();\n    set_jumps(common->currententry->backtrack_calls, common->currententry->backtrack_label);\n\n    sljit_emit_fast_enter(compiler, TMP1, 0);\n\n    if (has_accept)\n      accept_exit = CMP(SLJIT_EQUAL, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, -1);\n\n    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(0));\n    /* Save return address. */\n    OP1(SLJIT_MOV, SLJIT_MEM1(TMP2), STACK(local_size - 1), TMP1, 0);\n\n    copy_recurse_data(common, ccbegin, ccend, recurse_swap_global, local_size, private_data_size + local_size, has_quit);\n\n    if (alt_max > 1)\n      {\n      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(STACK_TOP), STACK(1));\n      free_stack(common, 2);\n\n      if (alt_max > 3)\n        {\n        sljit_emit_ijump(compiler, SLJIT_JUMP, TMP1, 0);\n        sljit_set_put_label(put_label, LABEL());\n        sljit_emit_op0(compiler, SLJIT_ENDBR);\n        }\n      else\n        next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 0);\n      }\n    else\n      free_stack(common, has_accept ? 2 : 1);\n    }\n  else if (alt_max > 3)\n    {\n    sljit_set_put_label(put_label, LABEL());\n    sljit_emit_op0(compiler, SLJIT_ENDBR);\n    }\n  else\n    {\n    JUMPHERE(next_alt);\n    if (alt_count + 1 < alt_max)\n      {\n      SLJIT_ASSERT(alt_count == 1 && alt_max == 3);\n      next_alt = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, 1);\n      }\n    }\n\n  alt_count++;\n\n  compile_backtrackingpath(common, altbacktrack.top);\n  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n    return;\n  set_jumps(altbacktrack.topbacktracks, LABEL());\n\n  if (*cc != OP_ALT)\n    break;\n\n  altbacktrack.cc = cc + 1 + LINK_SIZE;\n  cc += GET(cc, 1);\n  }\n\n/* No alternative is matched. */\n\nquit = LABEL();\n\ncopy_recurse_data(common, ccbegin, ccend, recurse_copy_private_to_global, local_size, private_data_size + local_size, has_quit);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1));\nfree_stack(common, private_data_size + local_size);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\nOP_SRC(SLJIT_FAST_RETURN, TMP2, 0);\n\nif (common->quit != NULL)\n  {\n  SLJIT_ASSERT(has_quit);\n\n  set_jumps(common->quit, LABEL());\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr);\n  copy_recurse_data(common, ccbegin, ccend, recurse_copy_shared_to_global, local_size, private_data_size + local_size, has_quit);\n  JUMPTO(SLJIT_JUMP, quit);\n  }\n\nif (has_accept)\n  {\n  JUMPHERE(accept_exit);\n  free_stack(common, 2);\n\n  /* Save return address. */\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1), TMP1, 0);\n\n  copy_recurse_data(common, ccbegin, ccend, recurse_copy_kept_shared_to_global, local_size, private_data_size + local_size, has_quit);\n\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(STACK_TOP), STACK(local_size - 1));\n  free_stack(common, private_data_size + local_size);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 0);\n  OP_SRC(SLJIT_FAST_RETURN, TMP2, 0);\n  }\n\nif (common->accept != NULL)\n  {\n  SLJIT_ASSERT(has_accept);\n\n  set_jumps(common->accept, LABEL());\n\n  OP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(SLJIT_SP), common->recursive_head_ptr);\n  OP1(SLJIT_MOV, TMP2, 0, STACK_TOP, 0);\n\n  allocate_stack(common, 2);\n  OP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(1), SLJIT_IMM, -1);\n  }\n\nset_jumps(match, LABEL());\n\nOP1(SLJIT_MOV, SLJIT_MEM1(STACK_TOP), STACK(0), TMP2, 0);\n\ncopy_recurse_data(common, ccbegin, ccend, recurse_swap_global, local_size, private_data_size + local_size, has_quit);\n\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP2), STACK(local_size - 1));\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, 1);\nOP_SRC(SLJIT_FAST_RETURN, TMP2, 0);\n}\n\n#undef COMPILE_BACKTRACKINGPATH\n#undef CURRENT_AS\n\n#define PUBLIC_JIT_COMPILE_CONFIGURATION_OPTIONS \\\n  (PCRE2_JIT_INVALID_UTF)\n\nstatic int jit_compile(pcre2_code *code, sljit_u32 mode)\n{\npcre2_real_code *re = (pcre2_real_code *)code;\nstruct sljit_compiler *compiler;\nbacktrack_common rootbacktrack;\ncompiler_common common_data;\ncompiler_common *common = &common_data;\nconst sljit_u8 *tables = re->tables;\nvoid *allocator_data = &re->memctl;\nint private_data_size;\nPCRE2_SPTR ccend;\nexecutable_functions *functions;\nvoid *executable_func;\nsljit_uw executable_size;\nsljit_uw total_length;\nstruct sljit_label *mainloop_label = NULL;\nstruct sljit_label *continue_match_label;\nstruct sljit_label *empty_match_found_label = NULL;\nstruct sljit_label *empty_match_backtrack_label = NULL;\nstruct sljit_label *reset_match_label;\nstruct sljit_label *quit_label;\nstruct sljit_jump *jump;\nstruct sljit_jump *minlength_check_failed = NULL;\nstruct sljit_jump *empty_match = NULL;\nstruct sljit_jump *end_anchor_failed = NULL;\njump_list *reqcu_not_found = NULL;\n\nSLJIT_ASSERT(tables);\n\n#if HAS_VIRTUAL_REGISTERS == 1\nSLJIT_ASSERT(sljit_get_register_index(TMP3) < 0 && sljit_get_register_index(ARGUMENTS) < 0 && sljit_get_register_index(RETURN_ADDR) < 0);\n#elif HAS_VIRTUAL_REGISTERS == 0\nSLJIT_ASSERT(sljit_get_register_index(TMP3) >= 0 && sljit_get_register_index(ARGUMENTS) >= 0 && sljit_get_register_index(RETURN_ADDR) >= 0);\n#else\n#error \"Invalid value for HAS_VIRTUAL_REGISTERS\"\n#endif\n\nmemset(&rootbacktrack, 0, sizeof(backtrack_common));\nmemset(common, 0, sizeof(compiler_common));\ncommon->re = re;\ncommon->name_table = (PCRE2_SPTR)((uint8_t *)re + sizeof(pcre2_real_code));\nrootbacktrack.cc = common->name_table + re->name_count * re->name_entry_size;\n\n#ifdef SUPPORT_UNICODE\ncommon->invalid_utf = (mode & PCRE2_JIT_INVALID_UTF) != 0;\n#endif /* SUPPORT_UNICODE */\nmode &= ~PUBLIC_JIT_COMPILE_CONFIGURATION_OPTIONS;\n\ncommon->start = rootbacktrack.cc;\ncommon->read_only_data_head = NULL;\ncommon->fcc = tables + fcc_offset;\ncommon->lcc = (sljit_sw)(tables + lcc_offset);\ncommon->mode = mode;\ncommon->might_be_empty = (re->minlength == 0) || (re->flags & PCRE2_MATCH_EMPTY);\ncommon->allow_empty_partial = (re->max_lookbehind > 0) || (re->flags & PCRE2_MATCH_EMPTY);\ncommon->nltype = NLTYPE_FIXED;\nswitch(re->newline_convention)\n  {\n  case PCRE2_NEWLINE_CR: common->newline = CHAR_CR; break;\n  case PCRE2_NEWLINE_LF: common->newline = CHAR_NL; break;\n  case PCRE2_NEWLINE_CRLF: common->newline = (CHAR_CR << 8) | CHAR_NL; break;\n  case PCRE2_NEWLINE_ANY: common->newline = (CHAR_CR << 8) | CHAR_NL; common->nltype = NLTYPE_ANY; break;\n  case PCRE2_NEWLINE_ANYCRLF: common->newline = (CHAR_CR << 8) | CHAR_NL; common->nltype = NLTYPE_ANYCRLF; break;\n  case PCRE2_NEWLINE_NUL: common->newline = CHAR_NUL; break;\n  default: return PCRE2_ERROR_INTERNAL;\n  }\ncommon->nlmax = READ_CHAR_MAX;\ncommon->nlmin = 0;\nif (re->bsr_convention == PCRE2_BSR_UNICODE)\n  common->bsr_nltype = NLTYPE_ANY;\nelse if (re->bsr_convention == PCRE2_BSR_ANYCRLF)\n  common->bsr_nltype = NLTYPE_ANYCRLF;\nelse\n  {\n#ifdef BSR_ANYCRLF\n  common->bsr_nltype = NLTYPE_ANYCRLF;\n#else\n  common->bsr_nltype = NLTYPE_ANY;\n#endif\n  }\ncommon->bsr_nlmax = READ_CHAR_MAX;\ncommon->bsr_nlmin = 0;\ncommon->endonly = (re->overall_options & PCRE2_DOLLAR_ENDONLY) != 0;\ncommon->ctypes = (sljit_sw)(tables + ctypes_offset);\ncommon->name_count = re->name_count;\ncommon->name_entry_size = re->name_entry_size;\ncommon->unset_backref = (re->overall_options & PCRE2_MATCH_UNSET_BACKREF) != 0;\ncommon->alt_circumflex = (re->overall_options & PCRE2_ALT_CIRCUMFLEX) != 0;\n#ifdef SUPPORT_UNICODE\n/* PCRE_UTF[16|32] have the same value as PCRE_UTF8. */\ncommon->utf = (re->overall_options & PCRE2_UTF) != 0;\ncommon->ucp = (re->overall_options & PCRE2_UCP) != 0;\nif (common->utf)\n  {\n  if (common->nltype == NLTYPE_ANY)\n    common->nlmax = 0x2029;\n  else if (common->nltype == NLTYPE_ANYCRLF)\n    common->nlmax = (CHAR_CR > CHAR_NL) ? CHAR_CR : CHAR_NL;\n  else\n    {\n    /* We only care about the first newline character. */\n    common->nlmax = common->newline & 0xff;\n    }\n\n  if (common->nltype == NLTYPE_FIXED)\n    common->nlmin = common->newline & 0xff;\n  else\n    common->nlmin = (CHAR_CR < CHAR_NL) ? CHAR_CR : CHAR_NL;\n\n  if (common->bsr_nltype == NLTYPE_ANY)\n    common->bsr_nlmax = 0x2029;\n  else\n    common->bsr_nlmax = (CHAR_CR > CHAR_NL) ? CHAR_CR : CHAR_NL;\n  common->bsr_nlmin = (CHAR_CR < CHAR_NL) ? CHAR_CR : CHAR_NL;\n  }\nelse\n  common->invalid_utf = FALSE;\n#endif /* SUPPORT_UNICODE */\nccend = bracketend(common->start);\n\n/* Calculate the local space size on the stack. */\ncommon->ovector_start = LIMIT_MATCH + sizeof(sljit_sw);\ncommon->optimized_cbracket = (sljit_u8 *)SLJIT_MALLOC(re->top_bracket + 1, allocator_data);\nif (!common->optimized_cbracket)\n  return PCRE2_ERROR_NOMEMORY;\n#if defined DEBUG_FORCE_UNOPTIMIZED_CBRAS && DEBUG_FORCE_UNOPTIMIZED_CBRAS == 1\nmemset(common->optimized_cbracket, 0, re->top_bracket + 1);\n#else\nmemset(common->optimized_cbracket, 1, re->top_bracket + 1);\n#endif\n\nSLJIT_ASSERT(*common->start == OP_BRA && ccend[-(1 + LINK_SIZE)] == OP_KET);\n#if defined DEBUG_FORCE_UNOPTIMIZED_CBRAS && DEBUG_FORCE_UNOPTIMIZED_CBRAS == 2\ncommon->capture_last_ptr = common->ovector_start;\ncommon->ovector_start += sizeof(sljit_sw);\n#endif\nif (!check_opcode_types(common, common->start, ccend))\n  {\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\n/* Checking flags and updating ovector_start. */\nif (mode == PCRE2_JIT_COMPLETE && (re->flags & PCRE2_LASTSET) != 0 && (re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n  {\n  common->req_char_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\nif (mode != PCRE2_JIT_COMPLETE)\n  {\n  common->start_used_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  if (mode == PCRE2_JIT_PARTIAL_SOFT)\n    {\n    common->hit_start = common->ovector_start;\n    common->ovector_start += sizeof(sljit_sw);\n    }\n  }\nif ((re->overall_options & (PCRE2_FIRSTLINE | PCRE2_USE_OFFSET_LIMIT)) != 0)\n  {\n  common->match_end_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\ncommon->control_head_ptr = 1;\n#endif\nif (common->control_head_ptr != 0)\n  {\n  common->control_head_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\nif (common->has_set_som)\n  {\n  /* Saving the real start pointer is necessary. */\n  common->start_ptr = common->ovector_start;\n  common->ovector_start += sizeof(sljit_sw);\n  }\n\n/* Aligning ovector to even number of sljit words. */\nif ((common->ovector_start & sizeof(sljit_sw)) != 0)\n  common->ovector_start += sizeof(sljit_sw);\n\nif (common->start_ptr == 0)\n  common->start_ptr = OVECTOR(0);\n\n/* Capturing brackets cannot be optimized if callouts are allowed. */\nif (common->capture_last_ptr != 0)\n  memset(common->optimized_cbracket, 0, re->top_bracket + 1);\n\nSLJIT_ASSERT(!(common->req_char_ptr != 0 && common->start_used_ptr != 0));\ncommon->cbra_ptr = OVECTOR_START + (re->top_bracket + 1) * 2 * sizeof(sljit_sw);\n\ntotal_length = ccend - common->start;\ncommon->private_data_ptrs = (sljit_s32*)SLJIT_MALLOC(total_length * (sizeof(sljit_s32) + (common->has_then ? 1 : 0)), allocator_data);\nif (!common->private_data_ptrs)\n  {\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\nmemset(common->private_data_ptrs, 0, total_length * sizeof(sljit_s32));\n\nprivate_data_size = common->cbra_ptr + (re->top_bracket + 1) * sizeof(sljit_sw);\n\nif ((re->overall_options & PCRE2_ANCHORED) == 0 && (re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0 && !common->has_skip_in_assert_back)\n  detect_early_fail(common, common->start, &private_data_size, 0, 0, TRUE);\n\nset_private_data_ptrs(common, &private_data_size, ccend);\n\nSLJIT_ASSERT(common->early_fail_start_ptr <= common->early_fail_end_ptr);\n\nif (private_data_size > SLJIT_MAX_LOCAL_SIZE)\n  {\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\nif (common->has_then)\n  {\n  common->then_offsets = (sljit_u8 *)(common->private_data_ptrs + total_length);\n  memset(common->then_offsets, 0, total_length);\n  set_then_offsets(common, common->start, NULL);\n  }\n\ncompiler = sljit_create_compiler(allocator_data, NULL);\nif (!compiler)\n  {\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\ncommon->compiler = compiler;\n\n/* Main pcre2_jit_exec entry. */\nSLJIT_ASSERT((private_data_size & (sizeof(sljit_sw) - 1)) == 0);\nsljit_emit_enter(compiler, 0, SLJIT_ARGS1(W, W), 5, 5, 0, 0, private_data_size);\n\n/* Register init. */\nreset_ovector(common, (re->top_bracket + 1) * 2);\nif (common->req_char_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->req_char_ptr, SLJIT_R0, 0);\n\nOP1(SLJIT_MOV, ARGUMENTS, 0, SLJIT_S0, 0);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_S0, 0);\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\nOP1(SLJIT_MOV, STR_END, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, end));\nOP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, stack));\nOP1(SLJIT_MOV_U32, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, limit_match));\nOP1(SLJIT_MOV, STACK_TOP, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(struct sljit_stack, end));\nOP1(SLJIT_MOV, STACK_LIMIT, 0, SLJIT_MEM1(TMP2), SLJIT_OFFSETOF(struct sljit_stack, start));\nOP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, 1);\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LIMIT_MATCH, TMP1, 0);\n\nif (common->early_fail_start_ptr < common->early_fail_end_ptr)\n  reset_early_fail(common);\n\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, -1);\nif (common->mark_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->mark_ptr, SLJIT_IMM, 0);\nif (common->control_head_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->control_head_ptr, SLJIT_IMM, 0);\n\n/* Main part of the matching */\nif ((re->overall_options & PCRE2_ANCHORED) == 0)\n  {\n  mainloop_label = mainloop_entry(common);\n  continue_match_label = LABEL();\n  /* Forward search if possible. */\n  if ((re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n    {\n    if (mode == PCRE2_JIT_COMPLETE && fast_forward_first_n_chars(common))\n      ;\n    else if ((re->flags & PCRE2_FIRSTSET) != 0)\n      fast_forward_first_char(common);\n    else if ((re->flags & PCRE2_STARTLINE) != 0)\n      fast_forward_newline(common);\n    else if ((re->flags & PCRE2_FIRSTMAPSET) != 0)\n      fast_forward_start_bits(common);\n    }\n  }\nelse\n  continue_match_label = LABEL();\n\nif (mode == PCRE2_JIT_COMPLETE && re->minlength > 0 && (re->overall_options & PCRE2_NO_START_OPTIMIZE) == 0)\n  {\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n  OP2(SLJIT_ADD, TMP2, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(re->minlength));\n  minlength_check_failed = CMP(SLJIT_GREATER, TMP2, 0, STR_END, 0);\n  }\nif (common->req_char_ptr != 0)\n  reqcu_not_found = search_requested_char(common, (PCRE2_UCHAR)(re->last_codeunit), (re->flags & PCRE2_LASTCASELESS) != 0, (re->flags & PCRE2_FIRSTSET) != 0);\n\n/* Store the current STR_PTR in OVECTOR(0). */\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), OVECTOR(0), STR_PTR, 0);\n/* Copy the limit of allowed recursions. */\nOP1(SLJIT_MOV, COUNT_MATCH, 0, SLJIT_MEM1(SLJIT_SP), LIMIT_MATCH);\nif (common->capture_last_ptr != 0)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->capture_last_ptr, SLJIT_IMM, 0);\nif (common->fast_forward_bc_ptr != NULL)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), PRIVATE_DATA(common->fast_forward_bc_ptr + 1) >> 3, STR_PTR, 0);\n\nif (common->start_ptr != OVECTOR(0))\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_ptr, STR_PTR, 0);\n\n/* Copy the beginning of the string. */\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  jump = CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, -1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n  JUMPHERE(jump);\n  }\nelse if (mode == PCRE2_JIT_PARTIAL_HARD)\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, STR_PTR, 0);\n\ncompile_matchingpath(common, common->start, ccend, &rootbacktrack);\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  {\n  sljit_free_compiler(compiler);\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\nif ((re->overall_options & PCRE2_ENDANCHORED) != 0)\n  end_anchor_failed = CMP(SLJIT_NOT_EQUAL, STR_PTR, 0, STR_END, 0);\n\nif (common->might_be_empty)\n  {\n  empty_match = CMP(SLJIT_EQUAL, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), OVECTOR(0));\n  empty_match_found_label = LABEL();\n  }\n\ncommon->accept_label = LABEL();\nif (common->accept != NULL)\n  set_jumps(common->accept, common->accept_label);\n\n/* This means we have a match. Update the ovector. */\ncopy_ovector(common, re->top_bracket + 1);\ncommon->quit_label = common->abort_label = LABEL();\nif (common->quit != NULL)\n  set_jumps(common->quit, common->quit_label);\nif (common->abort != NULL)\n  set_jumps(common->abort, common->abort_label);\nif (minlength_check_failed != NULL)\n  SET_LABEL(minlength_check_failed, common->abort_label);\n\nsljit_emit_op0(compiler, SLJIT_SKIP_FRAMES_BEFORE_RETURN);\nsljit_emit_return(compiler, SLJIT_MOV, SLJIT_RETURN_REG, 0);\n\nif (common->failed_match != NULL)\n  {\n  SLJIT_ASSERT(common->mode == PCRE2_JIT_COMPLETE);\n  set_jumps(common->failed_match, LABEL());\n  OP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\n  JUMPTO(SLJIT_JUMP, common->abort_label);\n  }\n\nif ((re->overall_options & PCRE2_ENDANCHORED) != 0)\n  JUMPHERE(end_anchor_failed);\n\nif (mode != PCRE2_JIT_COMPLETE)\n  {\n  common->partialmatchlabel = LABEL();\n  set_jumps(common->partialmatch, common->partialmatchlabel);\n  return_with_partial_match(common, common->quit_label);\n  }\n\nif (common->might_be_empty)\n  empty_match_backtrack_label = LABEL();\ncompile_backtrackingpath(common, rootbacktrack.top);\nif (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n  {\n  sljit_free_compiler(compiler);\n  SLJIT_FREE(common->optimized_cbracket, allocator_data);\n  SLJIT_FREE(common->private_data_ptrs, allocator_data);\n  PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\nSLJIT_ASSERT(rootbacktrack.prev == NULL);\nreset_match_label = LABEL();\n\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  {\n  /* Update hit_start only in the first time. */\n  jump = CMP(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, 0);\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->start_ptr);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->start_used_ptr, SLJIT_IMM, -1);\n  OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), common->hit_start, TMP1, 0);\n  JUMPHERE(jump);\n  }\n\n/* Check we have remaining characters. */\nif ((re->overall_options & PCRE2_ANCHORED) == 0 && common->match_end_ptr != 0)\n  {\n  OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), common->match_end_ptr);\n  }\n\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP),\n    (common->fast_forward_bc_ptr != NULL) ? (PRIVATE_DATA(common->fast_forward_bc_ptr + 1) >> 3) : common->start_ptr);\n\nif ((re->overall_options & PCRE2_ANCHORED) == 0)\n  {\n  if (common->ff_newline_shortcut != NULL)\n    {\n    /* There cannot be more newlines if PCRE2_FIRSTLINE is set. */\n    if ((re->overall_options & PCRE2_FIRSTLINE) == 0)\n      {\n      if (common->match_end_ptr != 0)\n        {\n        OP1(SLJIT_MOV, TMP3, 0, STR_END, 0);\n        OP1(SLJIT_MOV, STR_END, 0, TMP1, 0);\n        CMPTO(SLJIT_LESS, STR_PTR, 0, TMP1, 0, common->ff_newline_shortcut);\n        OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);\n        }\n      else\n        CMPTO(SLJIT_LESS, STR_PTR, 0, STR_END, 0, common->ff_newline_shortcut);\n      }\n    }\n  else\n    CMPTO(SLJIT_LESS, STR_PTR, 0, (common->match_end_ptr == 0) ? STR_END : TMP1, 0, mainloop_label);\n  }\n\n/* No more remaining characters. */\nif (reqcu_not_found != NULL)\n  set_jumps(reqcu_not_found, LABEL());\n\nif (mode == PCRE2_JIT_PARTIAL_SOFT)\n  CMPTO(SLJIT_NOT_EQUAL, SLJIT_MEM1(SLJIT_SP), common->hit_start, SLJIT_IMM, -1, common->partialmatchlabel);\n\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_NOMATCH);\nJUMPTO(SLJIT_JUMP, common->quit_label);\n\nflush_stubs(common);\n\nif (common->might_be_empty)\n  {\n  JUMPHERE(empty_match);\n  OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);\n  OP1(SLJIT_MOV_U32, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, options));\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY);\n  JUMPTO(SLJIT_NOT_ZERO, empty_match_backtrack_label);\n  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, PCRE2_NOTEMPTY_ATSTART);\n  JUMPTO(SLJIT_ZERO, empty_match_found_label);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));\n  CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, STR_PTR, 0, empty_match_found_label);\n  JUMPTO(SLJIT_JUMP, empty_match_backtrack_label);\n  }\n\ncommon->fast_forward_bc_ptr = NULL;\ncommon->early_fail_start_ptr = 0;\ncommon->early_fail_end_ptr = 0;\ncommon->currententry = common->entries;\ncommon->local_quit_available = TRUE;\nquit_label = common->quit_label;\nif (common->currententry != NULL)\n  {\n  /* A free bit for each private data. */\n  common->recurse_bitset_size = ((private_data_size / (int)sizeof(sljit_sw)) + 7) >> 3;\n  SLJIT_ASSERT(common->recurse_bitset_size > 0);\n  common->recurse_bitset = (sljit_u8*)SLJIT_MALLOC(common->recurse_bitset_size, allocator_data);;\n\n  if (common->recurse_bitset != NULL)\n    {\n    do\n      {\n      /* Might add new entries. */\n      compile_recurse(common);\n      if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n        break;\n      flush_stubs(common);\n      common->currententry = common->currententry->next;\n      }\n    while (common->currententry != NULL);\n\n    SLJIT_FREE(common->recurse_bitset, allocator_data);\n    }\n\n  if (common->currententry != NULL)\n    {\n    /* The common->recurse_bitset has been freed. */\n    SLJIT_ASSERT(sljit_get_compiler_error(compiler) || common->recurse_bitset == NULL);\n\n    sljit_free_compiler(compiler);\n    SLJIT_FREE(common->optimized_cbracket, allocator_data);\n    SLJIT_FREE(common->private_data_ptrs, allocator_data);\n    PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n    return PCRE2_ERROR_NOMEMORY;\n    }\n  }\ncommon->local_quit_available = FALSE;\ncommon->quit_label = quit_label;\n\n/* Allocating stack, returns with PCRE_ERROR_JIT_STACKLIMIT if fails. */\n/* This is a (really) rare case. */\nset_jumps(common->stackalloc, LABEL());\n/* RETURN_ADDR is not a saved register. */\nsljit_emit_fast_enter(compiler, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n\nSLJIT_ASSERT(TMP1 == SLJIT_R0 && STR_PTR == SLJIT_R1);\n\nOP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS1, STR_PTR, 0);\nOP1(SLJIT_MOV, SLJIT_R0, 0, ARGUMENTS, 0);\nOP2(SLJIT_SUB, SLJIT_R1, 0, STACK_LIMIT, 0, SLJIT_IMM, STACK_GROWTH_RATE);\nOP1(SLJIT_MOV, SLJIT_R0, 0, SLJIT_MEM1(SLJIT_R0), SLJIT_OFFSETOF(jit_arguments, stack));\nOP1(SLJIT_MOV, STACK_LIMIT, 0, TMP2, 0);\n\nsljit_emit_icall(compiler, SLJIT_CALL, SLJIT_ARGS2(W, W, W), SLJIT_IMM, SLJIT_FUNC_ADDR(sljit_stack_resize));\n\njump = CMP(SLJIT_EQUAL, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0);\nOP1(SLJIT_MOV, TMP2, 0, STACK_LIMIT, 0);\nOP1(SLJIT_MOV, STACK_LIMIT, 0, SLJIT_RETURN_REG, 0);\nOP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\nOP1(SLJIT_MOV, STR_PTR, 0, SLJIT_MEM1(SLJIT_SP), LOCALS1);\nOP_SRC(SLJIT_FAST_RETURN, TMP1, 0);\n\n/* Allocation failed. */\nJUMPHERE(jump);\n/* We break the return address cache here, but this is a really rare case. */\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_JIT_STACKLIMIT);\nJUMPTO(SLJIT_JUMP, common->quit_label);\n\n/* Call limit reached. */\nset_jumps(common->calllimit, LABEL());\nOP1(SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, PCRE2_ERROR_MATCHLIMIT);\nJUMPTO(SLJIT_JUMP, common->quit_label);\n\nif (common->revertframes != NULL)\n  {\n  set_jumps(common->revertframes, LABEL());\n  do_revertframes(common);\n  }\nif (common->wordboundary != NULL)\n  {\n  set_jumps(common->wordboundary, LABEL());\n  check_wordboundary(common);\n  }\nif (common->anynewline != NULL)\n  {\n  set_jumps(common->anynewline, LABEL());\n  check_anynewline(common);\n  }\nif (common->hspace != NULL)\n  {\n  set_jumps(common->hspace, LABEL());\n  check_hspace(common);\n  }\nif (common->vspace != NULL)\n  {\n  set_jumps(common->vspace, LABEL());\n  check_vspace(common);\n  }\nif (common->casefulcmp != NULL)\n  {\n  set_jumps(common->casefulcmp, LABEL());\n  do_casefulcmp(common);\n  }\nif (common->caselesscmp != NULL)\n  {\n  set_jumps(common->caselesscmp, LABEL());\n  do_caselesscmp(common);\n  }\nif (common->reset_match != NULL)\n  {\n  set_jumps(common->reset_match, LABEL());\n  do_reset_match(common, (re->top_bracket + 1) * 2);\n  CMPTO(SLJIT_GREATER, STR_PTR, 0, TMP1, 0, continue_match_label);\n  OP1(SLJIT_MOV, STR_PTR, 0, TMP1, 0);\n  JUMPTO(SLJIT_JUMP, reset_match_label);\n  }\n#ifdef SUPPORT_UNICODE\n#if PCRE2_CODE_UNIT_WIDTH == 8\nif (common->utfreadchar != NULL)\n  {\n  set_jumps(common->utfreadchar, LABEL());\n  do_utfreadchar(common);\n  }\nif (common->utfreadtype8 != NULL)\n  {\n  set_jumps(common->utfreadtype8, LABEL());\n  do_utfreadtype8(common);\n  }\nif (common->utfpeakcharback != NULL)\n  {\n  set_jumps(common->utfpeakcharback, LABEL());\n  do_utfpeakcharback(common);\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n#if PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16\nif (common->utfreadchar_invalid != NULL)\n  {\n  set_jumps(common->utfreadchar_invalid, LABEL());\n  do_utfreadchar_invalid(common);\n  }\nif (common->utfreadnewline_invalid != NULL)\n  {\n  set_jumps(common->utfreadnewline_invalid, LABEL());\n  do_utfreadnewline_invalid(common);\n  }\nif (common->utfmoveback_invalid)\n  {\n  set_jumps(common->utfmoveback_invalid, LABEL());\n  do_utfmoveback_invalid(common);\n  }\nif (common->utfpeakcharback_invalid)\n  {\n  set_jumps(common->utfpeakcharback_invalid, LABEL());\n  do_utfpeakcharback_invalid(common);\n  }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16 */\nif (common->getucd != NULL)\n  {\n  set_jumps(common->getucd, LABEL());\n  do_getucd(common);\n  }\nif (common->getucdtype != NULL)\n  {\n  set_jumps(common->getucdtype, LABEL());\n  do_getucdtype(common);\n  }\n#endif /* SUPPORT_UNICODE */\n\nSLJIT_FREE(common->optimized_cbracket, allocator_data);\nSLJIT_FREE(common->private_data_ptrs, allocator_data);\n\nexecutable_func = sljit_generate_code(compiler);\nexecutable_size = sljit_get_generated_code_size(compiler);\nsljit_free_compiler(compiler);\n\nif (executable_func == NULL)\n  {\n  PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n  return PCRE2_ERROR_NOMEMORY;\n  }\n\n/* Reuse the function descriptor if possible. */\nif (re->executable_jit != NULL)\n  functions = (executable_functions *)re->executable_jit;\nelse\n  {\n  functions = SLJIT_MALLOC(sizeof(executable_functions), allocator_data);\n  if (functions == NULL)\n    {\n    /* This case is highly unlikely since we just recently\n    freed a lot of memory. Not impossible though. */\n    sljit_free_code(executable_func, NULL);\n    PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n    return PCRE2_ERROR_NOMEMORY;\n    }\n  memset(functions, 0, sizeof(executable_functions));\n  functions->top_bracket = re->top_bracket + 1;\n  functions->limit_match = re->limit_match;\n  re->executable_jit = functions;\n  }\n\n/* Turn mode into an index. */\nif (mode == PCRE2_JIT_COMPLETE)\n  mode = 0;\nelse\n  mode = (mode == PCRE2_JIT_PARTIAL_SOFT) ? 1 : 2;\n\nSLJIT_ASSERT(mode < JIT_NUMBER_OF_COMPILE_MODES);\nfunctions->executable_funcs[mode] = executable_func;\nfunctions->read_only_data_heads[mode] = common->read_only_data_head;\nfunctions->executable_sizes[mode] = executable_size;\nreturn 0;\n}\n\n#endif\n\n/*************************************************\n*        JIT compile a Regular Expression        *\n*************************************************/\n\n/* This function used JIT to convert a previously-compiled pattern into machine\ncode.\n\nArguments:\n  code          a compiled pattern\n  options       JIT option bits\n\nReturns:        0: success or (*NOJIT) was used\n               <0: an error code\n*/\n\n#define PUBLIC_JIT_COMPILE_OPTIONS \\\n  (PCRE2_JIT_COMPLETE|PCRE2_JIT_PARTIAL_SOFT|PCRE2_JIT_PARTIAL_HARD|PCRE2_JIT_INVALID_UTF)\n\nPCRE2_EXP_DEFN int PCRE2_CALL_CONVENTION\npcre2_jit_compile(pcre2_code *code, uint32_t options)\n{\npcre2_real_code *re = (pcre2_real_code *)code;\n#ifdef SUPPORT_JIT\nexecutable_functions *functions;\nstatic int executable_allocator_is_working = 0;\n#endif\n\nif (code == NULL)\n  return PCRE2_ERROR_NULL;\n\nif ((options & ~PUBLIC_JIT_COMPILE_OPTIONS) != 0)\n  return PCRE2_ERROR_JIT_BADOPTION;\n\n/* Support for invalid UTF was first introduced in JIT, with the option\nPCRE2_JIT_INVALID_UTF. Later, support was added to the interpreter, and the\ncompile-time option PCRE2_MATCH_INVALID_UTF was created. This is now the\npreferred feature, with the earlier option deprecated. However, for backward\ncompatibility, if the earlier option is set, it forces the new option so that\nif JIT matching falls back to the interpreter, there is still support for\ninvalid UTF. However, if this function has already been successfully called\nwithout PCRE2_JIT_INVALID_UTF and without PCRE2_MATCH_INVALID_UTF (meaning that\nnon-invalid-supporting JIT code was compiled), give an error.\n\nIf in the future support for PCRE2_JIT_INVALID_UTF is withdrawn, the following\nactions are needed:\n\n  1. Remove the definition from pcre2.h.in and from the list in\n     PUBLIC_JIT_COMPILE_OPTIONS above.\n\n  2. Replace PCRE2_JIT_INVALID_UTF with a local flag in this module.\n\n  3. Replace PCRE2_JIT_INVALID_UTF in pcre2_jit_test.c.\n\n  4. Delete the following short block of code. The setting of \"re\" and\n     \"functions\" can be moved into the JIT-only block below, but if that is\n     done, (void)re and (void)functions will be needed in the non-JIT case, to\n     avoid compiler warnings.\n*/\n\n#ifdef SUPPORT_JIT\nfunctions = (executable_functions *)re->executable_jit;\n#endif\n\nif ((options & PCRE2_JIT_INVALID_UTF) != 0)\n  {\n  if ((re->overall_options & PCRE2_MATCH_INVALID_UTF) == 0)\n    {\n#ifdef SUPPORT_JIT\n    if (functions != NULL) return PCRE2_ERROR_JIT_BADOPTION;\n#endif\n    re->overall_options |= PCRE2_MATCH_INVALID_UTF;\n    }\n  }\n\n/* The above tests are run with and without JIT support. This means that\nPCRE2_JIT_INVALID_UTF propagates back into the regex options (ensuring\ninterpreter support) even in the absence of JIT. But now, if there is no JIT\nsupport, give an error return. */\n\n#ifndef SUPPORT_JIT\nreturn PCRE2_ERROR_JIT_BADOPTION;\n#else  /* SUPPORT_JIT */\n\n/* There is JIT support. Do the necessary. */\n\nif ((re->flags & PCRE2_NOJIT) != 0) return 0;\n\nif (executable_allocator_is_working == 0)\n  {\n  /* Checks whether the executable allocator is working. This check\n     might run multiple times in multi-threaded environments, but the\n     result should not be affected by it. */\n  void *ptr = SLJIT_MALLOC_EXEC(32, NULL);\n\n  executable_allocator_is_working = -1;\n\n  if (ptr != NULL)\n    {\n    SLJIT_FREE_EXEC(((sljit_u8*)(ptr)) + SLJIT_EXEC_OFFSET(ptr), NULL);\n    executable_allocator_is_working = 1;\n    }\n  }\n\nif (executable_allocator_is_working < 0)\n  return PCRE2_ERROR_NOMEMORY;\n\nif ((re->overall_options & PCRE2_MATCH_INVALID_UTF) != 0)\n  options |= PCRE2_JIT_INVALID_UTF;\n\nif ((options & PCRE2_JIT_COMPLETE) != 0 && (functions == NULL\n    || functions->executable_funcs[0] == NULL)) {\n  uint32_t excluded_options = (PCRE2_JIT_PARTIAL_SOFT | PCRE2_JIT_PARTIAL_HARD);\n  int result = jit_compile(code, options & ~excluded_options);\n  if (result != 0)\n    return result;\n  }\n\nif ((options & PCRE2_JIT_PARTIAL_SOFT) != 0 && (functions == NULL\n    || functions->executable_funcs[1] == NULL)) {\n  uint32_t excluded_options = (PCRE2_JIT_COMPLETE | PCRE2_JIT_PARTIAL_HARD);\n  int result = jit_compile(code, options & ~excluded_options);\n  if (result != 0)\n    return result;\n  }\n\nif ((options & PCRE2_JIT_PARTIAL_HARD) != 0 && (functions == NULL\n    || functions->executable_funcs[2] == NULL)) {\n  uint32_t excluded_options = (PCRE2_JIT_COMPLETE | PCRE2_JIT_PARTIAL_SOFT);\n  int result = jit_compile(code, options & ~excluded_options);\n  if (result != 0)\n    return result;\n  }\n\nreturn 0;\n\n#endif  /* SUPPORT_JIT */\n}\n\n/* JIT compiler uses an all-in-one approach. This improves security,\n   since the code generator functions are not exported. */\n\n#define INCLUDED_FROM_PCRE2_JIT_COMPILE\n\n#include \"pcre2_jit_match.c\"\n#include \"pcre2_jit_misc.c\"\n\n/* End of pcre2_jit_compile.c */\n", "/*************************************************\n*      Perl-Compatible Regular Expressions       *\n*************************************************/\n\n/* PCRE is a library of functions to support regular expressions whose syntax\nand semantics are as close as possible to those of the Perl 5 language.\n\n                       Written by Philip Hazel\n     Original API code Copyright (c) 1997-2012 University of Cambridge\n         New API code Copyright (c) 2016 University of Cambridge\n\n-----------------------------------------------------------------------------\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n    * Neither the name of the University of Cambridge nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n-----------------------------------------------------------------------------\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <string.h>\n\n#define PCRE2_CODE_UNIT_WIDTH 0\n#include \"pcre2.h\"\n\n/*\n Letter characters:\n   \\xe6\\x92\\xad = 0x64ad = 25773 (kanji)\n Non-letter characters:\n   \\xc2\\xa1 = 0xa1 =  (Inverted Exclamation Mark)\n   \\xf3\\xa9\\xb7\\x80 = 0xe9dc0 = 957888\n   \\xed\\xa0\\x80 = 55296 = 0xd800 (Invalid UTF character)\n   \\xed\\xb0\\x80 = 56320 = 0xdc00 (Invalid UTF character)\n Newlines:\n   \\xc2\\x85 = 0x85 = 133 (NExt Line = NEL)\n   \\xe2\\x80\\xa8 = 0x2028 = 8232 (Line Separator)\n Othercase pairs:\n   \\xc3\\xa9 = 0xe9 = 233 (e')\n      \\xc3\\x89 = 0xc9 = 201 (E')\n   \\xc3\\xa1 = 0xe1 = 225 (a')\n      \\xc3\\x81 = 0xc1 = 193 (A')\n   \\x53 = 0x53 = S\n     \\x73 = 0x73 = s\n     \\xc5\\xbf = 0x17f = 383 (long S)\n   \\xc8\\xba = 0x23a = 570\n      \\xe2\\xb1\\xa5 = 0x2c65 = 11365\n   \\xe1\\xbd\\xb8 = 0x1f78 = 8056\n      \\xe1\\xbf\\xb8 = 0x1ff8 = 8184\n   \\xf0\\x90\\x90\\x80 = 0x10400 = 66560\n      \\xf0\\x90\\x90\\xa8 = 0x10428 = 66600\n   \\xc7\\x84 = 0x1c4 = 452\n     \\xc7\\x85 = 0x1c5 = 453\n     \\xc7\\x86 = 0x1c6 = 454\n Caseless sets:\n   ucp_Armenian - \\x{531}-\\x{556} -> \\x{561}-\\x{586}\n   ucp_Coptic - \\x{2c80}-\\x{2ce3} -> caseless: XOR 0x1\n   ucp_Latin - \\x{ff21}-\\x{ff3a} -> \\x{ff41]-\\x{ff5a}\n\n Mark property:\n   \\xcc\\x8d = 0x30d = 781\n Special:\n   \\xc2\\x80 = 0x80 = 128 (lowest 2 byte character)\n   \\xdf\\xbf = 0x7ff = 2047 (highest 2 byte character)\n   \\xe0\\xa0\\x80 = 0x800 = 2048 (lowest 2 byte character)\n   \\xef\\xbf\\xbf = 0xffff = 65535 (highest 3 byte character)\n   \\xf0\\x90\\x80\\x80 = 0x10000 = 65536 (lowest 4 byte character)\n   \\xf4\\x8f\\xbf\\xbf = 0x10ffff = 1114111 (highest allowed utf character)\n*/\n\nstatic int regression_tests(void);\nstatic int invalid_utf8_regression_tests(void);\nstatic int invalid_utf16_regression_tests(void);\nstatic int invalid_utf32_regression_tests(void);\n\nint main(void)\n{\n\tint jit = 0;\n#if defined SUPPORT_PCRE2_8\n\tpcre2_config_8(PCRE2_CONFIG_JIT, &jit);\n#elif defined SUPPORT_PCRE2_16\n\tpcre2_config_16(PCRE2_CONFIG_JIT, &jit);\n#elif defined SUPPORT_PCRE2_32\n\tpcre2_config_32(PCRE2_CONFIG_JIT, &jit);\n#endif\n\tif (!jit) {\n\t\tprintf(\"JIT must be enabled to run pcre2_jit_test\\n\");\n\t\treturn 1;\n\t}\n\treturn regression_tests()\n\t\t| invalid_utf8_regression_tests()\n\t\t| invalid_utf16_regression_tests()\n\t\t| invalid_utf32_regression_tests();\n}\n\n/* --------------------------------------------------------------------------------------- */\n\n#if !(defined SUPPORT_PCRE2_8) && !(defined SUPPORT_PCRE2_16) && !(defined SUPPORT_PCRE2_32)\n#error SUPPORT_PCRE2_8 or SUPPORT_PCRE2_16 or SUPPORT_PCRE2_32 must be defined\n#endif\n\n#define MU\t(PCRE2_MULTILINE | PCRE2_UTF)\n#define MUP\t(PCRE2_MULTILINE | PCRE2_UTF | PCRE2_UCP)\n#define CMU\t(PCRE2_CASELESS | PCRE2_MULTILINE | PCRE2_UTF)\n#define CMUP\t(PCRE2_CASELESS | PCRE2_MULTILINE | PCRE2_UTF | PCRE2_UCP)\n#define M\t(PCRE2_MULTILINE)\n#define MP\t(PCRE2_MULTILINE | PCRE2_UCP)\n#define U\t(PCRE2_UTF)\n#define CM\t(PCRE2_CASELESS | PCRE2_MULTILINE)\n\n#define BSR(x)\t((x) << 16)\n#define A\tPCRE2_NEWLINE_ANYCRLF\n\n#define GET_NEWLINE(x)\t((x) & 0xffff)\n#define GET_BSR(x)\t((x) >> 16)\n\n#define OFFSET_MASK\t0x00ffff\n#define F_NO8\t\t0x010000\n#define F_NO16\t\t0x020000\n#define F_NO32\t\t0x020000\n#define F_NOMATCH\t0x040000\n#define F_DIFF\t\t0x080000\n#define F_FORCECONV\t0x100000\n#define F_PROPERTY\t0x200000\n\nstruct regression_test_case {\n\tint compile_options;\n\tint newline;\n\tint match_options;\n\tint start_offset;\n\tconst char *pattern;\n\tconst char *input;\n};\n\nstatic struct regression_test_case regression_test_cases[] = {\n\t/* Constant strings. */\n\t{ MU, A, 0, 0, \"AbC\", \"AbAbC\" },\n\t{ MU, A, 0, 0, \"ACCEPT\", \"AACACCACCEACCEPACCEPTACCEPTT\" },\n\t{ CMU, A, 0, 0, \"aA#\\xc3\\xa9\\xc3\\x81\", \"aA#Aa#\\xc3\\x89\\xc3\\xa1\" },\n\t{ M, A, 0, 0, \"[^a]\", \"aAbB\" },\n\t{ CM, A, 0, 0, \"[^m]\", \"mMnN\" },\n\t{ M, A, 0, 0, \"a[^b][^#]\", \"abacd\" },\n\t{ CM, A, 0, 0, \"A[^B][^E]\", \"abacd\" },\n\t{ CMU, A, 0, 0, \"[^x][^#]\", \"XxBll\" },\n\t{ MU, A, 0, 0, \"[^a]\", \"aaa\\xc3\\xa1#Ab\" },\n\t{ CMU, A, 0, 0, \"[^A]\", \"aA\\xe6\\x92\\xad\" },\n\t{ MU, A, 0, 0, \"\\\\W(\\\\W)?\\\\w\", \"\\r\\n+bc\" },\n\t{ MU, A, 0, 0, \"\\\\W(\\\\W)?\\\\w\", \"\\n\\r+bc\" },\n\t{ MU, A, 0, 0, \"\\\\W(\\\\W)?\\\\w\", \"\\r\\r+bc\" },\n\t{ MU, A, 0, 0, \"\\\\W(\\\\W)?\\\\w\", \"\\n\\n+bc\" },\n\t{ MU, A, 0, 0, \"[axd]\", \"sAXd\" },\n\t{ CMU, A, 0, 0, \"[axd]\", \"sAXd\" },\n\t{ CMU, A, 0, 0 | F_NOMATCH, \"[^axd]\", \"DxA\" },\n\t{ MU, A, 0, 0, \"[a-dA-C]\", \"\\xe6\\x92\\xad\\xc3\\xa9.B\" },\n\t{ MU, A, 0, 0, \"[^a-dA-C]\", \"\\xe6\\x92\\xad\\xc3\\xa9\" },\n\t{ CMU, A, 0, 0, \"[^\\xc3\\xa9]\", \"\\xc3\\xa9\\xc3\\x89.\" },\n\t{ MU, A, 0, 0, \"[^\\xc3\\xa9]\", \"\\xc3\\xa9\\xc3\\x89.\" },\n\t{ MU, A, 0, 0, \"[^a]\", \"\\xc2\\x80[]\" },\n\t{ CMU, A, 0, 0, \"\\xf0\\x90\\x90\\xa7\", \"\\xf0\\x90\\x91\\x8f\" },\n\t{ CM, A, 0, 0, \"1a2b3c4\", \"1a2B3c51A2B3C4\" },\n\t{ PCRE2_CASELESS, 0, 0, 0, \"\\xff#a\", \"\\xff#\\xff\\xfe##\\xff#A\" },\n\t{ PCRE2_CASELESS, 0, 0, 0, \"\\xfe\", \"\\xff\\xfc#\\xfe\\xfe\" },\n\t{ PCRE2_CASELESS, 0, 0, 0, \"a1\", \"Aa1\" },\n#ifndef NEVER_BACKSLASH_C\n\t{ M, A, 0, 0, \"\\\\Ca\", \"cda\" },\n\t{ CM, A, 0, 0, \"\\\\Ca\", \"CDA\" },\n\t{ M, A, 0, 0 | F_NOMATCH, \"\\\\Cx\", \"cda\" },\n\t{ CM, A, 0, 0 | F_NOMATCH, \"\\\\Cx\", \"CDA\" },\n#endif /* !NEVER_BACKSLASH_C */\n\t{ CMUP, A, 0, 0, \"\\xf0\\x90\\x90\\x80\\xf0\\x90\\x90\\xa8\", \"\\xf0\\x90\\x90\\xa8\\xf0\\x90\\x90\\x80\" },\n\t{ CMUP, A, 0, 0, \"\\xf0\\x90\\x90\\x80{2}\", \"\\xf0\\x90\\x90\\x80#\\xf0\\x90\\x90\\xa8\\xf0\\x90\\x90\\x80\" },\n\t{ CMUP, A, 0, 0, \"\\xf0\\x90\\x90\\xa8{2}\", \"\\xf0\\x90\\x90\\x80#\\xf0\\x90\\x90\\xa8\\xf0\\x90\\x90\\x80\" },\n\t{ CMUP, A, 0, 0, \"\\xe1\\xbd\\xb8\\xe1\\xbf\\xb8\", \"\\xe1\\xbf\\xb8\\xe1\\xbd\\xb8\" },\n\t{ M, A, 0, 0, \"[3-57-9]\", \"5\" },\n\t{ PCRE2_AUTO_CALLOUT, A, 0, 0, \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\",\n\t\t\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\" },\n\n\t/* Assertions. */\n\t{ MU, A, 0, 0, \"\\\\b[^A]\", \"A_B#\" },\n\t{ M, A, 0, 0 | F_NOMATCH, \"\\\\b\\\\W\", \"\\n*\" },\n\t{ MU, A, 0, 0, \"\\\\B[^,]\\\\b[^s]\\\\b\", \"#X\" },\n\t{ MP, A, 0, 0, \"\\\\B\", \"_\\xa1\" },\n\t{ MP, A, 0, 0 | F_PROPERTY, \"\\\\b_\\\\b[,A]\\\\B\", \"_,\" },\n\t{ MUP, A, 0, 0, \"\\\\b\", \"\\xe6\\x92\\xad!\" },\n\t{ MUP, A, 0, 0, \"\\\\B\", \"_\\xc2\\xa1\\xc3\\xa1\\xc2\\x85\" },\n\t{ MUP, A, 0, 0, \"\\\\b[^A]\\\\B[^c]\\\\b[^_]\\\\B\", \"_\\xc3\\xa1\\xe2\\x80\\xa8\" },\n\t{ MUP, A, 0, 0, \"\\\\b\\\\w+\\\\B\", \"\\xc3\\x89\\xc2\\xa1\\xe6\\x92\\xad\\xc3\\x81\\xc3\\xa1\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"\\\\b.\", \"\\xcd\\xbe\" },\n\t{ CMUP, A, 0, 0, \"\\\\By\", \"\\xf0\\x90\\x90\\xa8y\" },\n\t{ M, A, 0, 0 | F_NOMATCH, \"\\\\R^\", \"\\n\" },\n\t{ M, A, 0, 1 | F_NOMATCH, \"^\", \"\\n\" },\n\t{ 0, 0, 0, 0, \"^ab\", \"ab\" },\n\t{ 0, 0, 0, 0 | F_NOMATCH, \"^ab\", \"aab\" },\n\t{ M, PCRE2_NEWLINE_CRLF, 0, 0, \"^a\", \"\\r\\raa\\n\\naa\\r\\naa\" },\n\t{ MU, A, 0, 0, \"^-\", \"\\xe2\\x80\\xa8--\\xc2\\x85-\\r\\n-\" },\n\t{ M, PCRE2_NEWLINE_ANY, 0, 0, \"^-\", \"a--b--\\x85--\" },\n\t{ MU, PCRE2_NEWLINE_ANY, 0, 0, \"^-\", \"a--\\xe2\\x80\\xa8--\" },\n\t{ MU, PCRE2_NEWLINE_ANY, 0, 0, \"^-\", \"a--\\xc2\\x85--\" },\n\t{ 0, 0, 0, 0, \"ab$\", \"ab\" },\n\t{ 0, 0, 0, 0 | F_NOMATCH, \"ab$\", \"abab\\n\\n\" },\n\t{ PCRE2_DOLLAR_ENDONLY, 0, 0, 0 | F_NOMATCH, \"ab$\", \"abab\\r\\n\" },\n\t{ M, PCRE2_NEWLINE_CRLF, 0, 0, \"a$\", \"\\r\\raa\\n\\naa\\r\\naa\" },\n\t{ M, PCRE2_NEWLINE_ANY, 0, 0, \"a$\", \"aaa\" },\n\t{ MU, PCRE2_NEWLINE_ANYCRLF, 0, 0, \"#$\", \"#\\xc2\\x85###\\r#\" },\n\t{ MU, PCRE2_NEWLINE_ANY, 0, 0, \"#$\", \"#\\xe2\\x80\\xa9\" },\n\t{ 0, PCRE2_NEWLINE_ANY, PCRE2_NOTBOL, 0 | F_NOMATCH, \"^a\", \"aa\\naa\" },\n\t{ M, PCRE2_NEWLINE_ANY, PCRE2_NOTBOL, 0, \"^a\", \"aa\\naa\" },\n\t{ 0, PCRE2_NEWLINE_ANY, PCRE2_NOTEOL, 0 | F_NOMATCH, \"a$\", \"aa\\naa\" },\n\t{ 0, PCRE2_NEWLINE_ANY, PCRE2_NOTEOL, 0 | F_NOMATCH, \"a$\", \"aa\\r\\n\" },\n\t{ U | PCRE2_DOLLAR_ENDONLY, PCRE2_NEWLINE_ANY, 0, 0 | F_PROPERTY, \"\\\\p{Any}{2,}$\", \"aa\\r\\n\" },\n\t{ M, PCRE2_NEWLINE_ANY, PCRE2_NOTEOL, 0, \"a$\", \"aa\\naa\" },\n\t{ 0, PCRE2_NEWLINE_CR, 0, 0, \".\\\\Z\", \"aaa\" },\n\t{ U, PCRE2_NEWLINE_CR, 0, 0, \"a\\\\Z\", \"aaa\\r\" },\n\t{ 0, PCRE2_NEWLINE_CR, 0, 0, \".\\\\Z\", \"aaa\\n\" },\n\t{ 0, PCRE2_NEWLINE_CRLF, 0, 0, \".\\\\Z\", \"aaa\\r\" },\n\t{ U, PCRE2_NEWLINE_CRLF, 0, 0, \".\\\\Z\", \"aaa\\n\" },\n\t{ 0, PCRE2_NEWLINE_CRLF, 0, 0, \".\\\\Z\", \"aaa\\r\\n\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".\\\\Z\", \"aaa\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".\\\\Z\", \"aaa\\r\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".\\\\Z\", \"aaa\\n\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".\\\\Z\", \"aaa\\r\\n\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".\\\\Z\", \"aaa\\xe2\\x80\\xa8\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".\\\\Z\", \"aaa\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".\\\\Z\", \"aaa\\r\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".\\\\Z\", \"aaa\\n\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".\\\\Z\", \"aaa\\r\\n\" },\n\t{ U, PCRE2_NEWLINE_ANY, 0, 0, \".\\\\Z\", \"aaa\\xc2\\x85\" },\n\t{ U, PCRE2_NEWLINE_ANY, 0, 0, \".\\\\Z\", \"aaa\\xe2\\x80\\xa8\" },\n\t{ M, A, 0, 0, \"\\\\Aa\", \"aaa\" },\n\t{ M, A, 0, 1 | F_NOMATCH, \"\\\\Aa\", \"aaa\" },\n\t{ M, A, 0, 1, \"\\\\Ga\", \"aaa\" },\n\t{ M, A, 0, 1 | F_NOMATCH, \"\\\\Ga\", \"aba\" },\n\t{ M, A, 0, 0, \"a\\\\z\", \"aaa\" },\n\t{ M, A, 0, 0 | F_NOMATCH, \"a\\\\z\", \"aab\" },\n\n\t/* Brackets and alternatives. */\n\t{ MU, A, 0, 0, \"(ab|bb|cd)\", \"bacde\" },\n\t{ MU, A, 0, 0, \"(?:ab|a)(bc|c)\", \"ababc\" },\n\t{ MU, A, 0, 0, \"((ab|(cc))|(bb)|(?:cd|efg))\", \"abac\" },\n\t{ CMU, A, 0, 0, \"((aB|(Cc))|(bB)|(?:cd|EFg))\", \"AcCe\" },\n\t{ MU, A, 0, 0, \"((ab|(cc))|(bb)|(?:cd|ebg))\", \"acebebg\" },\n\t{ MU, A, 0, 0, \"(?:(a)|(?:b))(cc|(?:d|e))(a|b)k\", \"accabdbbccbk\" },\n\t{ MU, A, 0, 0, \"\\xc7\\x82|\\xc6\\x82\", \"\\xf1\\x83\\x82\\x82\\xc7\\x82\\xc7\\x83\" },\n\t{ MU, A, 0, 0, \"=\\xc7\\x82|#\\xc6\\x82\", \"\\xf1\\x83\\x82\\x82=\\xc7\\x82\\xc7\\x83\" },\n\t{ MU, A, 0, 0, \"\\xc7\\x82\\xc7\\x83|\\xc6\\x82\\xc6\\x82\", \"\\xf1\\x83\\x82\\x82\\xc7\\x82\\xc7\\x83\" },\n\t{ MU, A, 0, 0, \"\\xc6\\x82\\xc6\\x82|\\xc7\\x83\\xc7\\x83|\\xc8\\x84\\xc8\\x84\", \"\\xf1\\x83\\x82\\x82\\xc8\\x84\\xc8\\x84\" },\n\t{ U, A, 0, 0, \"\\xe1\\x81\\x80|\\xe2\\x82\\x80|\\xe4\\x84\\x80\", \"\\xdf\\xbf\\xc2\\x80\\xe4\\x84\\x80\" },\n\t{ U, A, 0, 0, \"(?:\\xe1\\x81\\x80|\\xe2\\x82\\x80|\\xe4\\x84\\x80)#\", \"\\xdf\\xbf\\xc2\\x80#\\xe4\\x84\\x80#\" },\n\t{ CM, A, 0, 0, \"ab|cd\", \"CD\" },\n\t{ CM, A, 0, 0, \"a1277|a1377|bX487\", \"bx487\" },\n\t{ CM, A, 0, 0, \"a1277|a1377|bx487\", \"bX487\" },\n\n\t/* Greedy and non-greedy ? operators. */\n\t{ MU, A, 0, 0, \"(?:a)?a\", \"laab\" },\n\t{ CMU, A, 0, 0, \"(A)?A\", \"llaab\" },\n\t{ MU, A, 0, 0, \"(a)?\\?a\", \"aab\" }, /* ?? is the prefix of trygraphs in GCC. */\n\t{ MU, A, 0, 0, \"(a)?a\", \"manm\" },\n\t{ CMU, A, 0, 0, \"(a|b)?\\?d((?:e)?)\", \"ABABdx\" },\n\t{ MU, A, 0, 0, \"(a|b)?\\?d((?:e)?)\", \"abcde\" },\n\t{ MU, A, 0, 0, \"((?:ab)?\\?g|b(?:g(nn|d)?\\?)?)?\\?(?:n)?m\", \"abgnbgnnbgdnmm\" },\n\n\t/* Greedy and non-greedy + operators */\n\t{ MU, A, 0, 0, \"(aa)+aa\", \"aaaaaaa\" },\n\t{ MU, A, 0, 0, \"(aa)+?aa\", \"aaaaaaa\" },\n\t{ MU, A, 0, 0, \"(?:aba|ab|a)+l\", \"ababamababal\" },\n\t{ MU, A, 0, 0, \"(?:aba|ab|a)+?l\", \"ababamababal\" },\n\t{ MU, A, 0, 0, \"(a(?:bc|cb|b|c)+?|ss)+e\", \"accssabccbcacbccbbXaccssabccbcacbccbbe\" },\n\t{ MU, A, 0, 0, \"(a(?:bc|cb|b|c)+|ss)+?e\", \"accssabccbcacbccbbXaccssabccbcacbccbbe\" },\n\t{ MU, A, 0, 0, \"(?:(b(c)+?)+)?\\?(?:(bc)+|(cb)+)+(?:m)+\", \"bccbcccbcbccbcbPbccbcccbcbccbcbmmn\" },\n\t{ MU, A, 0, 0, \"(aa|bb){8,1000}\", \"abaabbaabbaabbaab_aabbaabbaabbaabbaabbaabb_\" },\n\n\t/* Greedy and non-greedy * operators */\n\t{ CMU, A, 0, 0, \"(?:AA)*AB\", \"aaaaaaamaaaaaaab\" },\n\t{ MU, A, 0, 0, \"(?:aa)*?ab\", \"aaaaaaamaaaaaaab\" },\n\t{ MU, A, 0, 0, \"(aa|ab)*ab\", \"aaabaaab\" },\n\t{ CMU, A, 0, 0, \"(aa|Ab)*?aB\", \"aaabaaab\" },\n\t{ MU, A, 0, 0, \"(a|b)*(?:a)*(?:b)*m\", \"abbbaaababanabbbaaababamm\" },\n\t{ MU, A, 0, 0, \"(a|b)*?(?:a)*?(?:b)*?m\", \"abbbaaababanabbbaaababamm\" },\n\t{ M, A, 0, 0, \"a(a(\\\\1*)a|(b)b+){0}a\", \"aa\" },\n\t{ M, A, 0, 0, \"((?:a|)*){0}a\", \"a\" },\n\n\t/* Combining ? + * operators */\n\t{ MU, A, 0, 0, \"((bm)+)?\\?(?:a)*(bm)+n|((am)+?)?(?:a)+(am)*n\", \"bmbmabmamaaamambmaman\" },\n\t{ MU, A, 0, 0, \"(((ab)?cd)*ef)+g\", \"abcdcdefcdefefmabcdcdefcdefefgg\" },\n\t{ MU, A, 0, 0, \"(((ab)?\\?cd)*?ef)+?g\", \"abcdcdefcdefefmabcdcdefcdefefgg\" },\n\t{ MU, A, 0, 0, \"(?:(ab)?c|(?:ab)+?d)*g\", \"ababcdccababddg\" },\n\t{ MU, A, 0, 0, \"(?:(?:ab)?\\?c|(ab)+d)*?g\", \"ababcdccababddg\" },\n\n\t/* Single character iterators. */\n\t{ MU, A, 0, 0, \"(a+aab)+aaaab\", \"aaaabcaaaabaabcaabcaaabaaaab\" },\n\t{ MU, A, 0, 0, \"(a*a*aab)+x\", \"aaaaabaabaaabmaabx\" },\n\t{ MU, A, 0, 0, \"(a*?(b|ab)a*?)+x\", \"aaaabcxbbaabaacbaaabaabax\" },\n\t{ MU, A, 0, 0, \"(a+(ab|ad)a+)+x\", \"aaabaaaadaabaaabaaaadaaax\" },\n\t{ MU, A, 0, 0, \"(a?(a)a?)+(aaa)\", \"abaaabaaaaaaaa\" },\n\t{ MU, A, 0, 0, \"(a?\\?(a)a?\\?)+(b)\", \"aaaacaaacaacacbaaab\" },\n\t{ MU, A, 0, 0, \"(a{0,4}(b))+d\", \"aaaaaabaabcaaaaabaaaaabd\" },\n\t{ MU, A, 0, 0, \"(a{0,4}?[^b])+d+(a{0,4}[^b])d+\", \"aaaaadaaaacaadddaaddd\" },\n\t{ MU, A, 0, 0, \"(ba{2})+c\", \"baabaaabacbaabaac\" },\n\t{ MU, A, 0, 0, \"(a*+bc++)+\", \"aaabbcaaabcccab\" },\n\t{ MU, A, 0, 0, \"(a?+[^b])+\", \"babaacacb\" },\n\t{ MU, A, 0, 0, \"(a{0,3}+b)(a{0,3}+b)(a{0,3}+)[^c]\", \"abaabaaacbaabaaaac\" },\n\t{ CMU, A, 0, 0, \"([a-c]+[d-f]+?)+?g\", \"aBdacdehAbDaFgA\" },\n\t{ CMU, A, 0, 0, \"[c-f]+k\", \"DemmFke\" },\n\t{ MU, A, 0, 0, \"([DGH]{0,4}M)+\", \"GGDGHDGMMHMDHHGHM\" },\n\t{ MU, A, 0, 0, \"([a-c]{4,}s)+\", \"abasabbasbbaabsbba\" },\n\t{ CMU, A, 0, 0, \"[ace]{3,7}\", \"AcbDAcEEcEd\" },\n\t{ CMU, A, 0, 0, \"[ace]{3,7}?\", \"AcbDAcEEcEd\" },\n\t{ CMU, A, 0, 0, \"[ace]{3,}\", \"AcbDAcEEcEd\" },\n\t{ CMU, A, 0, 0, \"[ace]{3,}?\", \"AcbDAcEEcEd\" },\n\t{ MU, A, 0, 0, \"[ckl]{2,}?g\", \"cdkkmlglglkcg\" },\n\t{ CMU, A, 0, 0, \"[ace]{5}?\", \"AcCebDAcEEcEd\" },\n\t{ MU, A, 0, 0, \"([AbC]{3,5}?d)+\", \"BACaAbbAEAACCbdCCbdCCAAbb\" },\n\t{ MU, A, 0, 0, \"([^ab]{0,}s){2}\", \"abaabcdsABamsDDs\" },\n\t{ MU, A, 0, 0, \"\\\\b\\\\w+\\\\B\", \"x,a_cd\" },\n\t{ MUP, A, 0, 0, \"\\\\b[^\\xc2\\xa1]+\\\\B\", \"\\xc3\\x89\\xc2\\xa1\\xe6\\x92\\xad\\xc3\\x81\\xc3\\xa1\" },\n\t{ CMU, A, 0, 0, \"[^b]+(a*)([^c]?d{3})\", \"aaaaddd\" },\n\t{ CMUP, A, 0, 0, \"\\xe1\\xbd\\xb8{2}\", \"\\xe1\\xbf\\xb8#\\xe1\\xbf\\xb8\\xe1\\xbd\\xb8\" },\n\t{ CMU, A, 0, 0, \"[^\\xf0\\x90\\x90\\x80]{2,4}@\", \"\\xf0\\x90\\x90\\xa8\\xf0\\x90\\x90\\x80###\\xf0\\x90\\x90\\x80@@@\" },\n\t{ CMU, A, 0, 0, \"[^\\xe1\\xbd\\xb8][^\\xc3\\xa9]\", \"\\xe1\\xbd\\xb8\\xe1\\xbf\\xb8\\xc3\\xa9\\xc3\\x89#\" },\n\t{ MU, A, 0, 0, \"[^\\xe1\\xbd\\xb8][^\\xc3\\xa9]\", \"\\xe1\\xbd\\xb8\\xe1\\xbf\\xb8\\xc3\\xa9\\xc3\\x89#\" },\n\t{ MU, A, 0, 0, \"[^\\xe1\\xbd\\xb8]{3,}?\", \"##\\xe1\\xbd\\xb8#\\xe1\\xbd\\xb8#\\xc3\\x89#\\xe1\\xbd\\xb8\" },\n\t{ MU, A, 0, 0, \"\\\\d+123\", \"987654321,01234\" },\n\t{ MU, A, 0, 0, \"abcd*|\\\\w+xy\", \"aaaaa,abxyz\" },\n\t{ MU, A, 0, 0, \"(?:abc|((?:amc|\\\\b\\\\w*xy)))\", \"aaaaa,abxyz\" },\n\t{ MU, A, 0, 0, \"a(?R)|([a-z]++)#\", \".abcd.abcd#.\"},\n\t{ MU, A, 0, 0, \"a(?R)|([a-z]++)#\", \".abcd.mbcd#.\"},\n\t{ MU, A, 0, 0, \".[ab]*.\", \"xx\" },\n\t{ MU, A, 0, 0, \".[ab]*a\", \"xxa\" },\n\t{ MU, A, 0, 0, \".[ab]?.\", \"xx\" },\n\t{ MU, A, 0, 0, \"_[ab]+_*a\", \"_aa\" },\n\t{ MU, A, 0, 0, \"#(A+)#\\\\d+\", \"#A#A#0\" },\n\t{ MU, A, 0, 0, \"(?P<size>\\\\d+)m|M\", \"4M\" },\n\n\t/* Bracket repeats with limit. */\n\t{ MU, A, 0, 0, \"(?:(ab){2}){5}M\", \"abababababababababababM\" },\n\t{ MU, A, 0, 0, \"(?:ab|abab){1,5}M\", \"abababababababababababM\" },\n\t{ MU, A, 0, 0, \"(?>ab|abab){1,5}M\", \"abababababababababababM\" },\n\t{ MU, A, 0, 0, \"(?:ab|abab){1,5}?M\", \"abababababababababababM\" },\n\t{ MU, A, 0, 0, \"(?>ab|abab){1,5}?M\", \"abababababababababababM\" },\n\t{ MU, A, 0, 0, \"(?:(ab){1,4}?){1,3}?M\", \"abababababababababababababM\" },\n\t{ MU, A, 0, 0, \"(?:(ab){1,4}){1,3}abababababababababababM\", \"ababababababababababababM\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?:(ab){1,4}){1,3}abababababababababababM\", \"abababababababababababM\" },\n\t{ MU, A, 0, 0, \"(ab){4,6}?M\", \"abababababababM\" },\n\n\t/* Basic character sets. */\n\t{ MU, A, 0, 0, \"(?:\\\\s)+(?:\\\\S)+\", \"ab \\t\\xc3\\xa9\\xe6\\x92\\xad \" },\n\t{ MU, A, 0, 0, \"(\\\\w)*(k)(\\\\W)?\\?\", \"abcdef abck11\" },\n\t{ MU, A, 0, 0, \"\\\\((\\\\d)+\\\\)\\\\D\", \"a() (83 (8)2 (9)ab\" },\n\t{ MU, A, 0, 0, \"\\\\w(\\\\s|(?:\\\\d)*,)+\\\\w\\\\wb\", \"a 5, 4,, bb 5, 4,, aab\" },\n\t{ MU, A, 0, 0, \"(\\\\v+)(\\\\V+)\", \"\\x0e\\xc2\\x85\\xe2\\x80\\xa8\\x0b\\x09\\xe2\\x80\\xa9\" },\n\t{ MU, A, 0, 0, \"(\\\\h+)(\\\\H+)\", \"\\xe2\\x80\\xa8\\xe2\\x80\\x80\\x20\\xe2\\x80\\x8a\\xe2\\x81\\x9f\\xe3\\x80\\x80\\x09\\x20\\xc2\\xa0\\x0a\" },\n\t{ MU, A, 0, 0, \"x[bcef]+\", \"xaxdxecbfg\" },\n\t{ MU, A, 0, 0, \"x[bcdghij]+\", \"xaxexfxdgbjk\" },\n\t{ MU, A, 0, 0, \"x[^befg]+\", \"xbxexacdhg\" },\n\t{ MU, A, 0, 0, \"x[^bcdl]+\", \"xlxbxaekmd\" },\n\t{ MU, A, 0, 0, \"x[^bcdghi]+\", \"xbxdxgxaefji\" },\n\t{ MU, A, 0, 0, \"x[B-Fb-f]+\", \"xaxAxgxbfBFG\" },\n\t{ CMU, A, 0, 0, \"\\\\x{e9}+\", \"#\\xf0\\x90\\x90\\xa8\\xc3\\xa8\\xc3\\xa9\\xc3\\x89\\xc3\\x88\" },\n\t{ CMU, A, 0, 0, \"[^\\\\x{e9}]+\", \"\\xc3\\xa9#\\xf0\\x90\\x90\\xa8\\xc3\\xa8\\xc3\\x88\\xc3\\x89\" },\n\t{ MU, A, 0, 0, \"[\\\\x02\\\\x7e]+\", \"\\xc3\\x81\\xe1\\xbf\\xb8\\xf0\\x90\\x90\\xa8\\x01\\x02\\x7e\\x7f\" },\n\t{ MU, A, 0, 0, \"[^\\\\x02\\\\x7e]+\", \"\\x02\\xc3\\x81\\xe1\\xbf\\xb8\\xf0\\x90\\x90\\xa8\\x01\\x7f\\x7e\" },\n\t{ MU, A, 0, 0, \"[\\\\x{81}-\\\\x{7fe}]+\", \"#\\xe1\\xbf\\xb8\\xf0\\x90\\x90\\xa8\\xc2\\x80\\xc2\\x81\\xdf\\xbe\\xdf\\xbf\" },\n\t{ MU, A, 0, 0, \"[^\\\\x{81}-\\\\x{7fe}]+\", \"\\xc2\\x81#\\xe1\\xbf\\xb8\\xf0\\x90\\x90\\xa8\\xc2\\x80\\xdf\\xbf\\xdf\\xbe\" },\n\t{ MU, A, 0, 0, \"[\\\\x{801}-\\\\x{fffe}]+\", \"#\\xc3\\xa9\\xf0\\x90\\x90\\x80\\xe0\\xa0\\x80\\xe0\\xa0\\x81\\xef\\xbf\\xbe\\xef\\xbf\\xbf\" },\n\t{ MU, A, 0, 0, \"[^\\\\x{801}-\\\\x{fffe}]+\", \"\\xe0\\xa0\\x81#\\xc3\\xa9\\xf0\\x90\\x90\\x80\\xe0\\xa0\\x80\\xef\\xbf\\xbf\\xef\\xbf\\xbe\" },\n\t{ MU, A, 0, 0, \"[\\\\x{10001}-\\\\x{10fffe}]+\", \"#\\xc3\\xa9\\xe2\\xb1\\xa5\\xf0\\x90\\x80\\x80\\xf0\\x90\\x80\\x81\\xf4\\x8f\\xbf\\xbe\\xf4\\x8f\\xbf\\xbf\" },\n\t{ MU, A, 0, 0, \"[^\\\\x{10001}-\\\\x{10fffe}]+\", \"\\xf0\\x90\\x80\\x81#\\xc3\\xa9\\xe2\\xb1\\xa5\\xf0\\x90\\x80\\x80\\xf4\\x8f\\xbf\\xbf\\xf4\\x8f\\xbf\\xbe\" },\n\t{ CMU, A, 0, 0 | F_NOMATCH, \"^[\\\\x{0100}-\\\\x{017f}]\", \" \" },\n\n\t/* Unicode properties. */\n\t{ MUP, A, 0, 0, \"[1-5\\xc3\\xa9\\\\w]\", \"\\xc3\\xa1_\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"[\\xc3\\x81\\\\p{Ll}]\", \"A_\\xc3\\x89\\xc3\\xa1\" },\n\t{ MUP, A, 0, 0, \"[\\\\Wd-h_x-z]+\", \"a\\xc2\\xa1#_yhzdxi\" },\n\t{ MUP, A, 0, 0 | F_NOMATCH | F_PROPERTY, \"[\\\\P{Any}]\", \"abc\" },\n\t{ MUP, A, 0, 0 | F_NOMATCH | F_PROPERTY, \"[^\\\\p{Any}]\", \"abc\" },\n\t{ MUP, A, 0, 0 | F_NOMATCH | F_PROPERTY, \"[\\\\P{Any}\\xc3\\xa1-\\xc3\\xa8]\", \"abc\" },\n\t{ MUP, A, 0, 0 | F_NOMATCH | F_PROPERTY, \"[^\\\\p{Any}\\xc3\\xa1-\\xc3\\xa8]\", \"abc\" },\n\t{ MUP, A, 0, 0 | F_NOMATCH | F_PROPERTY, \"[\\xc3\\xa1-\\xc3\\xa8\\\\P{Any}]\", \"abc\" },\n\t{ MUP, A, 0, 0 | F_NOMATCH | F_PROPERTY, \"[^\\xc3\\xa1-\\xc3\\xa8\\\\p{Any}]\", \"abc\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"[\\xc3\\xa1-\\xc3\\xa8\\\\p{Any}]\", \"abc\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"[^\\xc3\\xa1-\\xc3\\xa8\\\\P{Any}]\", \"abc\" },\n\t{ MUP, A, 0, 0, \"[b-\\xc3\\xa9\\\\s]\", \"a\\xc\\xe6\\x92\\xad\" },\n\t{ CMUP, A, 0, 0, \"[\\xc2\\x85-\\xc2\\x89\\xc3\\x89]\", \"\\xc2\\x84\\xc3\\xa9\" },\n\t{ MUP, A, 0, 0, \"[^b-d^&\\\\s]{3,}\", \"db^ !a\\xe2\\x80\\xa8_ae\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"[^\\\\S\\\\P{Any}][\\\\sN]{1,3}[\\\\P{N}]{4}\", \"\\xe2\\x80\\xaa\\xa N\\x9\\xc3\\xa9_0\" },\n\t{ MU, A, 0, 0 | F_PROPERTY, \"[^\\\\P{L}\\x9!D-F\\xa]{2,3}\", \"\\x9,.DF\\xa.CG\\xc3\\x81\" },\n\t{ CMUP, A, 0, 0, \"[\\xc3\\xa1-\\xc3\\xa9_\\xe2\\x80\\xa0-\\xe2\\x80\\xaf]{1,5}[^\\xe2\\x80\\xa0-\\xe2\\x80\\xaf]\", \"\\xc2\\xa1\\xc3\\x89\\xc3\\x89\\xe2\\x80\\xaf_\\xe2\\x80\\xa0\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"[\\xc3\\xa2-\\xc3\\xa6\\xc3\\x81-\\xc3\\x84\\xe2\\x80\\xa8-\\xe2\\x80\\xa9\\xe6\\x92\\xad\\\\p{Zs}]{2,}\", \"\\xe2\\x80\\xa7\\xe2\\x80\\xa9\\xe6\\x92\\xad \\xe6\\x92\\xae\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"[\\\\P{L&}]{2}[^\\xc2\\x85-\\xc2\\x89\\\\p{Ll}\\\\p{Lu}]{2}\", \"\\xc3\\xa9\\xe6\\x92\\xad.a\\xe6\\x92\\xad|\\xc2\\x8a#\" },\n\t{ PCRE2_UCP, 0, 0, 0 | F_PROPERTY, \"[a-b\\\\s]{2,5}[^a]\", \"AB  baaa\" },\n\t{ MUP, 0, 0, 0 | F_NOMATCH, \"[^\\\\p{Hangul}\\\\p{Z}]\", \" \" },\n\t{ MUP, 0, 0, 0, \"[\\\\p{Lu}\\\\P{Latin}]+\", \"c\\xEA\\xA4\\xAE,A,b\" },\n\t{ MUP, 0, 0, 0, \"[\\\\x{a92e}\\\\p{Lu}\\\\P{Latin}]+\", \"c\\xEA\\xA4\\xAE,A,b\" },\n\t{ CMUP, 0, 0, 0, \"[^S]\\\\B\", \"\\xe2\\x80\\x8a\" },\n\n\t/* Possible empty brackets. */\n\t{ MU, A, 0, 0, \"(?:|ab||bc|a)+d\", \"abcxabcabd\" },\n\t{ MU, A, 0, 0, \"(|ab||bc|a)+d\", \"abcxabcabd\" },\n\t{ MU, A, 0, 0, \"(?:|ab||bc|a)*d\", \"abcxabcabd\" },\n\t{ MU, A, 0, 0, \"(|ab||bc|a)*d\", \"abcxabcabd\" },\n\t{ MU, A, 0, 0, \"(?:|ab||bc|a)+?d\", \"abcxabcabd\" },\n\t{ MU, A, 0, 0, \"(|ab||bc|a)+?d\", \"abcxabcabd\" },\n\t{ MU, A, 0, 0, \"(?:|ab||bc|a)*?d\", \"abcxabcabd\" },\n\t{ MU, A, 0, 0, \"(|ab||bc|a)*?d\", \"abcxabcabd\" },\n\t{ MU, A, 0, 0, \"(((a)*?|(?:ba)+)+?|(?:|c|ca)*)*m\", \"abaacaccabacabalabaacaccabacabamm\" },\n\t{ MU, A, 0, 0, \"(?:((?:a)*|(ba)+?)+|(|c|ca)*?)*?m\", \"abaacaccabacabalabaacaccabacabamm\" },\n\n\t/* Start offset. */\n\t{ MU, A, 0, 3, \"(\\\\d|(?:\\\\w)*\\\\w)+\", \"0ac01Hb\" },\n\t{ MU, A, 0, 4 | F_NOMATCH, \"(\\\\w\\\\W\\\\w)+\", \"ab#d\" },\n\t{ MU, A, 0, 2 | F_NOMATCH, \"(\\\\w\\\\W\\\\w)+\", \"ab#d\" },\n\t{ MU, A, 0, 1, \"(\\\\w\\\\W\\\\w)+\", \"ab#d\" },\n\n\t/* Newline. */\n\t{ M, PCRE2_NEWLINE_CRLF, 0, 0, \"\\\\W{0,2}[^#]{3}\", \"\\r\\n#.....\" },\n\t{ M, PCRE2_NEWLINE_CR, 0, 0, \"\\\\W{0,2}[^#]{3}\", \"\\r\\n#.....\" },\n\t{ M, PCRE2_NEWLINE_CRLF, 0, 0, \"\\\\W{1,3}[^#]\", \"\\r\\n##....\" },\n\t{ MU, A, PCRE2_NO_UTF_CHECK, 1, \"^.a\", \"\\n\\x80\\nxa\" },\n\t{ MU, A, 0, 1, \"^\", \"\\r\\n\" },\n\t{ M, PCRE2_NEWLINE_CRLF, 0, 1 | F_NOMATCH, \"^\", \"\\r\\n\" },\n\t{ M, PCRE2_NEWLINE_CRLF, 0, 1, \"^\", \"\\r\\na\" },\n\n\t/* Any character except newline or any newline. */\n\t{ 0, PCRE2_NEWLINE_CRLF, 0, 0, \".\", \"\\r\" },\n\t{ U, PCRE2_NEWLINE_CRLF, 0, 0, \".(.).\", \"a\\xc3\\xa1\\r\\n\\n\\r\\r\" },\n\t{ 0, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".(.)\", \"a\\rb\\nc\\r\\n\\xc2\\x85\\xe2\\x80\\xa8\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0, \".(.)\", \"a\\rb\\nc\\r\\n\\xc2\\x85\\xe2\\x80\\xa8\" },\n\t{ U, PCRE2_NEWLINE_ANY, 0, 0, \"(.).\", \"a\\rb\\nc\\r\\n\\xc2\\x85\\xe2\\x80\\xa9$de\" },\n\t{ U, PCRE2_NEWLINE_ANYCRLF, 0, 0 | F_NOMATCH, \".(.).\", \"\\xe2\\x80\\xa8\\nb\\r\" },\n\t{ 0, PCRE2_NEWLINE_ANY, 0, 0, \"(.)(.)\", \"#\\x85#\\r#\\n#\\r\\n#\\x84\" },\n\t{ U, PCRE2_NEWLINE_ANY, 0, 0, \"(.+)#\", \"#\\rMn\\xc2\\x85#\\n###\" },\n\t{ 0, BSR(PCRE2_BSR_ANYCRLF), 0, 0, \"\\\\R\", \"\\r\" },\n\t{ 0, BSR(PCRE2_BSR_ANYCRLF), 0, 0, \"\\\\R\", \"\\x85#\\r\\n#\" },\n\t{ U, BSR(PCRE2_BSR_UNICODE), 0, 0, \"\\\\R\", \"ab\\xe2\\x80\\xa8#c\" },\n\t{ U, BSR(PCRE2_BSR_UNICODE), 0, 0, \"\\\\R\", \"ab\\r\\nc\" },\n\t{ U, PCRE2_NEWLINE_CRLF | BSR(PCRE2_BSR_UNICODE), 0, 0, \"(\\\\R.)+\", \"\\xc2\\x85\\r\\n#\\xe2\\x80\\xa8\\n\\r\\n\\r\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"\\\\R+\", \"ab\" },\n\t{ MU, A, 0, 0, \"\\\\R+\", \"ab\\r\\n\\r\" },\n\t{ MU, A, 0, 0, \"\\\\R*\", \"ab\\r\\n\\r\" },\n\t{ MU, A, 0, 0, \"\\\\R*\", \"\\r\\n\\r\" },\n\t{ MU, A, 0, 0, \"\\\\R{2,4}\", \"\\r\\nab\\r\\r\" },\n\t{ MU, A, 0, 0, \"\\\\R{2,4}\", \"\\r\\nab\\n\\n\\n\\r\\r\\r\" },\n\t{ MU, A, 0, 0, \"\\\\R{2,}\", \"\\r\\nab\\n\\n\\n\\r\\r\\r\" },\n\t{ MU, A, 0, 0, \"\\\\R{0,3}\", \"\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"\\\\R+\\\\R\\\\R\", \"\\r\\n\\r\\n\" },\n\t{ MU, A, 0, 0, \"\\\\R+\\\\R\\\\R\", \"\\r\\r\\r\" },\n\t{ MU, A, 0, 0, \"\\\\R*\\\\R\\\\R\", \"\\n\\r\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"\\\\R{2,4}\\\\R\\\\R\", \"\\r\\r\\r\" },\n\t{ MU, A, 0, 0, \"\\\\R{2,4}\\\\R\\\\R\", \"\\r\\r\\r\\r\" },\n\n\t/* Atomic groups (no fallback from \"next\" direction). */\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?>ab)ab\", \"bab\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?>(ab))ab\", \"bab\" },\n\t{ MU, A, 0, 0, \"(?>ab)+abc(?>de)*def(?>gh)?ghe(?>ij)+?k(?>lm)*?n(?>op)?\\?op\",\n\t\t\t\"bababcdedefgheijijklmlmnop\" },\n\t{ MU, A, 0, 0, \"(?>a(b)+a|(ab)?\\?(b))an\", \"abban\" },\n\t{ MU, A, 0, 0, \"(?>ab+a|(?:ab)?\\?b)an\", \"abban\" },\n\t{ MU, A, 0, 0, \"((?>ab|ad|)*?)(?>|c)*abad\", \"abababcababad\" },\n\t{ MU, A, 0, 0, \"(?>(aa|b|)*+(?>(##)|###)*d|(aa)(?>(baa)?)m)\", \"aabaa#####da\" },\n\t{ MU, A, 0, 0, \"((?>a|)+?)b\", \"aaacaaab\" },\n\t{ MU, A, 0, 0, \"(?>x|)*$\", \"aaa\" },\n\t{ MU, A, 0, 0, \"(?>(x)|)*$\", \"aaa\" },\n\t{ MU, A, 0, 0, \"(?>x|())*$\", \"aaa\" },\n\t{ MU, A, 0, 0, \"((?>[cxy]a|[a-d])*?)b\", \"aaa+ aaab\" },\n\t{ MU, A, 0, 0, \"((?>[cxy](a)|[a-d])*?)b\", \"aaa+ aaab\" },\n\t{ MU, A, 0, 0, \"(?>((?>(a+))))bab|(?>((?>(a+))))bb\", \"aaaabaaabaabab\" },\n\t{ MU, A, 0, 0, \"(?>(?>a+))bab|(?>(?>a+))bb\", \"aaaabaaabaabab\" },\n\t{ MU, A, 0, 0, \"(?>(a)c|(?>(c)|(a))a)b*?bab\", \"aaaabaaabaabab\" },\n\t{ MU, A, 0, 0, \"(?>ac|(?>c|a)a)b*?bab\", \"aaaabaaabaabab\" },\n\t{ MU, A, 0, 0, \"(?>(b)b|(a))*b(?>(c)|d)?x\", \"ababcaaabdbx\" },\n\t{ MU, A, 0, 0, \"(?>bb|a)*b(?>c|d)?x\", \"ababcaaabdbx\" },\n\t{ MU, A, 0, 0, \"(?>(bb)|a)*b(?>c|(d))?x\", \"ababcaaabdbx\" },\n\t{ MU, A, 0, 0, \"(?>(a))*?(?>(a))+?(?>(a))??x\", \"aaaaaacccaaaaabax\" },\n\t{ MU, A, 0, 0, \"(?>a)*?(?>a)+?(?>a)??x\", \"aaaaaacccaaaaabax\" },\n\t{ MU, A, 0, 0, \"(?>(a)|)*?(?>(a)|)+?(?>(a)|)??x\", \"aaaaaacccaaaaabax\" },\n\t{ MU, A, 0, 0, \"(?>a|)*?(?>a|)+?(?>a|)??x\", \"aaaaaacccaaaaabax\" },\n\t{ MU, A, 0, 0, \"(?>a(?>(a{0,2}))*?b|aac)+b\", \"aaaaaaacaaaabaaaaacaaaabaacaaabb\" },\n\t{ CM, A, 0, 0, \"(?>((?>a{32}|b+|(a*))?(?>c+|d*)?\\?)+e)+?f\", \"aaccebbdde bbdaaaccebbdee bbdaaaccebbdeef\" },\n\t{ MU, A, 0, 0, \"(?>(?:(?>aa|a||x)+?b|(?>aa|a||(x))+?c)?(?>[ad]{0,2})*?d)+d\", \"aaacdbaabdcabdbaaacd aacaabdbdcdcaaaadaabcbaadd\" },\n\t{ MU, A, 0, 0, \"(?>(?:(?>aa|a||(x))+?b|(?>aa|a||x)+?c)?(?>[ad]{0,2})*?d)+d\", \"aaacdbaabdcabdbaaacd aacaabdbdcdcaaaadaabcbaadd\" },\n\t{ MU, A, 0, 0 | F_PROPERTY, \"\\\\X\", \"\\xcc\\x8d\\xcc\\x8d\" },\n\t{ MU, A, 0, 0 | F_PROPERTY, \"\\\\X\", \"\\xcc\\x8d\\xcc\\x8d#\\xcc\\x8d\\xcc\\x8d\" },\n\t{ MU, A, 0, 0 | F_PROPERTY, \"\\\\X+..\", \"\\xcc\\x8d#\\xcc\\x8d#\\xcc\\x8d\\xcc\\x8d\" },\n\t{ MU, A, 0, 0 | F_PROPERTY, \"\\\\X{2,4}\", \"abcdef\" },\n\t{ MU, A, 0, 0 | F_PROPERTY, \"\\\\X{2,4}?\", \"abcdef\" },\n\t{ MU, A, 0, 0 | F_NOMATCH | F_PROPERTY, \"\\\\X{2,4}..\", \"#\\xcc\\x8d##\" },\n\t{ MU, A, 0, 0 | F_PROPERTY, \"\\\\X{2,4}..\", \"#\\xcc\\x8d#\\xcc\\x8d##\" },\n\t{ MU, A, 0, 0, \"(c(ab)?+ab)+\", \"cabcababcab\" },\n\t{ MU, A, 0, 0, \"(?>(a+)b)+aabab\", \"aaaabaaabaabab\" },\n\n\t/* Possessive quantifiers. */\n\t{ MU, A, 0, 0, \"(?:a|b)++m\", \"mababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(?:a|b)*+m\", \"mababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(?:a|b)*+m\", \"ababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(a|b)++m\", \"mababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(a|b)*+m\", \"mababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(a|b)*+m\", \"ababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(a|b(*ACCEPT))++m\", \"maaxab\" },\n\t{ MU, A, 0, 0, \"(?:b*)++m\", \"bxbbxbbbxm\" },\n\t{ MU, A, 0, 0, \"(?:b*)++m\", \"bxbbxbbbxbbm\" },\n\t{ MU, A, 0, 0, \"(?:b*)*+m\", \"bxbbxbbbxm\" },\n\t{ MU, A, 0, 0, \"(?:b*)*+m\", \"bxbbxbbbxbbm\" },\n\t{ MU, A, 0, 0, \"(b*)++m\", \"bxbbxbbbxm\" },\n\t{ MU, A, 0, 0, \"(b*)++m\", \"bxbbxbbbxbbm\" },\n\t{ MU, A, 0, 0, \"(b*)*+m\", \"bxbbxbbbxm\" },\n\t{ MU, A, 0, 0, \"(b*)*+m\", \"bxbbxbbbxbbm\" },\n\t{ MU, A, 0, 0, \"(?:a|(b))++m\", \"mababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(?:(a)|b)*+m\", \"mababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(?:(a)|(b))*+m\", \"ababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(a|(b))++m\", \"mababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"((a)|b)*+m\", \"mababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"((a)|(b))*+m\", \"ababbaaxababbaam\" },\n\t{ MU, A, 0, 0, \"(a|(b)(*ACCEPT))++m\", \"maaxab\" },\n\t{ MU, A, 0, 0, \"(?:(b*))++m\", \"bxbbxbbbxm\" },\n\t{ MU, A, 0, 0, \"(?:(b*))++m\", \"bxbbxbbbxbbm\" },\n\t{ MU, A, 0, 0, \"(?:(b*))*+m\", \"bxbbxbbbxm\" },\n\t{ MU, A, 0, 0, \"(?:(b*))*+m\", \"bxbbxbbbxbbm\" },\n\t{ MU, A, 0, 0, \"((b*))++m\", \"bxbbxbbbxm\" },\n\t{ MU, A, 0, 0, \"((b*))++m\", \"bxbbxbbbxbbm\" },\n\t{ MU, A, 0, 0, \"((b*))*+m\", \"bxbbxbbbxm\" },\n\t{ MU, A, 0, 0, \"((b*))*+m\", \"bxbbxbbbxbbm\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?>(b{2,4}))(?:(?:(aa|c))++m|(?:(aa|c))+n)\", \"bbaacaaccaaaacxbbbmbn\" },\n\t{ MU, A, 0, 0, \"((?:b)++a)+(cd)*+m\", \"bbababbacdcdnbbababbacdcdm\" },\n\t{ MU, A, 0, 0, \"((?:(b))++a)+((c)d)*+m\", \"bbababbacdcdnbbababbacdcdm\" },\n\t{ MU, A, 0, 0, \"(?:(?:(?:ab)*+k)++(?:n(?:cd)++)*+)*+m\", \"ababkkXababkkabkncXababkkabkncdcdncdXababkkabkncdcdncdkkabkncdXababkkabkncdcdncdkkabkncdm\" },\n\t{ MU, A, 0, 0, \"(?:((ab)*+(k))++(n(?:c(d))++)*+)*+m\", \"ababkkXababkkabkncXababkkabkncdcdncdXababkkabkncdcdncdkkabkncdXababkkabkncdcdncdkkabkncdm\" },\n\n\t/* Back references. */\n\t{ MU, A, 0, 0, \"(aa|bb)(\\\\1*)(ll|)(\\\\3*)bbbbbbc\", \"aaaaaabbbbbbbbc\" },\n\t{ CMU, A, 0, 0, \"(aa|bb)(\\\\1+)(ll|)(\\\\3+)bbbbbbc\", \"bBbbBbCbBbbbBbbcbbBbbbBBbbC\" },\n\t{ CM, A, 0, 0, \"(a{2,4})\\\\1\", \"AaAaaAaA\" },\n\t{ MU, A, 0, 0, \"(aa|bb)(\\\\1?)aa(\\\\1?)(ll|)(\\\\4+)bbc\", \"aaaaaaaabbaabbbbaabbbbc\" },\n\t{ MU, A, 0, 0, \"(aa|bb)(\\\\1{0,5})(ll|)(\\\\3{0,5})cc\", \"bbxxbbbbxxaaaaaaaaaaaaaaaacc\" },\n\t{ MU, A, 0, 0, \"(aa|bb)(\\\\1{3,5})(ll|)(\\\\3{3,5})cc\", \"bbbbbbbbbbbbaaaaaaccbbbbbbbbbbbbbbcc\" },\n\t{ MU, A, 0, 0, \"(aa|bb)(\\\\1{3,})(ll|)(\\\\3{3,})cc\", \"bbbbbbbbbbbbaaaaaaccbbbbbbbbbbbbbbcc\" },\n\t{ MU, A, 0, 0, \"(\\\\w+)b(\\\\1+)c\", \"GabGaGaDbGaDGaDc\" },\n\t{ MU, A, 0, 0, \"(?:(aa)|b)\\\\1?b\", \"bb\" },\n\t{ CMU, A, 0, 0, \"(aa|bb)(\\\\1*?)aa(\\\\1+?)\", \"bBBbaaAAaaAAaa\" },\n\t{ MU, A, 0, 0, \"(aa|bb)(\\\\1*?)(dd|)cc(\\\\3+?)\", \"aaaaaccdd\" },\n\t{ CMU, A, 0, 0, \"(?:(aa|bb)(\\\\1?\\?)cc){2}(\\\\1?\\?)\", \"aAaABBbbAAaAcCaAcCaA\" },\n\t{ MU, A, 0, 0, \"(?:(aa|bb)(\\\\1{3,5}?)){2}(dd|)(\\\\3{3,5}?)\", \"aaaaaabbbbbbbbbbaaaaaaaaaaaaaa\" },\n\t{ CM, A, 0, 0, \"(?:(aa|bb)(\\\\1{3,}?)){2}(dd|)(\\\\3{3,}?)\", \"aaaaaabbbbbbbbbbaaaaaaaaaaaaaa\" },\n\t{ MU, A, 0, 0, \"(?:(aa|bb)(\\\\1{0,3}?)){2}(dd|)(\\\\3{0,3}?)b(\\\\1{0,3}?)(\\\\1{0,3})\", \"aaaaaaaaaaaaaaabaaaaa\" },\n\t{ MU, A, 0, 0, \"(a(?:\\\\1|)a){3}b\", \"aaaaaaaaaaab\" },\n\t{ M, A, 0, 0, \"(a?)b(\\\\1\\\\1*\\\\1+\\\\1?\\\\1*?\\\\1+?\\\\1??\\\\1*+\\\\1++\\\\1?+\\\\1{4}\\\\1{3,5}\\\\1{4,}\\\\1{0,5}\\\\1{3,5}?\\\\1{4,}?\\\\1{0,5}?\\\\1{3,5}+\\\\1{4,}+\\\\1{0,5}+#){2}d\", \"bb#b##d\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"(\\\\P{N})\\\\1{2,}\", \".www.\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"(\\\\P{N})\\\\1{0,2}\", \"wwwww.\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"(\\\\P{N})\\\\1{1,2}ww\", \"wwww\" },\n\t{ MUP, A, 0, 0 | F_PROPERTY, \"(\\\\P{N})\\\\1{1,2}ww\", \"wwwww\" },\n\t{ PCRE2_UCP, 0, 0, 0 | F_PROPERTY, \"(\\\\P{N})\\\\1{2,}\", \".www.\" },\n\t{ CMUP, A, 0, 0, \"(\\xf0\\x90\\x90\\x80)\\\\1\", \"\\xf0\\x90\\x90\\xa8\\xf0\\x90\\x90\\xa8\" },\n\t{ MU | PCRE2_DUPNAMES, A, 0, 0 | F_NOMATCH, \"\\\\k<A>{1,3}(?<A>aa)(?<A>bb)\", \"aabb\" },\n\t{ MU | PCRE2_DUPNAMES | PCRE2_MATCH_UNSET_BACKREF, A, 0, 0, \"\\\\k<A>{1,3}(?<A>aa)(?<A>bb)\", \"aabb\" },\n\t{ MU | PCRE2_DUPNAMES | PCRE2_MATCH_UNSET_BACKREF, A, 0, 0, \"\\\\k<A>*(?<A>aa)(?<A>bb)\", \"aabb\" },\n\t{ MU | PCRE2_DUPNAMES, A, 0, 0, \"(?<A>aa)(?<A>bb)\\\\k<A>{0,3}aaaaaa\", \"aabbaaaaaa\" },\n\t{ MU | PCRE2_DUPNAMES, A, 0, 0, \"(?<A>aa)(?<A>bb)\\\\k<A>{2,5}bb\", \"aabbaaaabb\" },\n\t{ MU | PCRE2_DUPNAMES, A, 0, 0, \"(?:(?<A>aa)|(?<A>bb))\\\\k<A>{0,3}m\", \"aaaaaaaabbbbaabbbbm\" },\n\t{ MU | PCRE2_DUPNAMES, A, 0, 0 | F_NOMATCH, \"\\\\k<A>{1,3}?(?<A>aa)(?<A>bb)\", \"aabb\" },\n\t{ MU | PCRE2_DUPNAMES | PCRE2_MATCH_UNSET_BACKREF, A, 0, 0, \"\\\\k<A>{1,3}?(?<A>aa)(?<A>bb)\", \"aabb\" },\n\t{ MU | PCRE2_DUPNAMES, A, 0, 0, \"\\\\k<A>*?(?<A>aa)(?<A>bb)\", \"aabb\" },\n\t{ MU | PCRE2_DUPNAMES, A, 0, 0, \"(?:(?<A>aa)|(?<A>bb))\\\\k<A>{0,3}?m\", \"aaaaaabbbbbbaabbbbbbbbbbm\" },\n\t{ MU | PCRE2_DUPNAMES, A, 0, 0, \"(?:(?<A>aa)|(?<A>bb))\\\\k<A>*?m\", \"aaaaaabbbbbbaabbbbbbbbbbm\" },\n\t{ MU | PCRE2_DUPNAMES, A, 0, 0, \"(?:(?<A>aa)|(?<A>bb))\\\\k<A>{2,3}?\", \"aaaabbbbaaaabbbbbbbbbb\" },\n\t{ CMU | PCRE2_DUPNAMES, A, 0, 0, \"(?:(?<A>AA)|(?<A>BB))\\\\k<A>{0,3}M\", \"aaaaaaaabbbbaabbbbm\" },\n\t{ CMU | PCRE2_DUPNAMES, A, 0, 0, \"(?:(?<A>AA)|(?<A>BB))\\\\k<A>{1,3}M\", \"aaaaaaaabbbbaabbbbm\" },\n\t{ CMU | PCRE2_DUPNAMES, A, 0, 0, \"(?:(?<A>AA)|(?<A>BB))\\\\k<A>{0,3}?M\", \"aaaaaabbbbbbaabbbbbbbbbbm\" },\n\t{ CMU | PCRE2_DUPNAMES, A, 0, 0, \"(?:(?<A>AA)|(?<A>BB))\\\\k<A>{2,3}?\", \"aaaabbbbaaaabbbbbbbbbb\" },\n\n\t/* Assertions. */\n\t{ MU, A, 0, 0, \"(?=xx|yy|zz)\\\\w{4}\", \"abczzdefg\" },\n\t{ MU, A, 0, 0, \"(?=((\\\\w+)b){3}|ab)\", \"dbbbb ab\" },\n\t{ MU, A, 0, 0, \"(?!ab|bc|cd)[a-z]{2}\", \"Xabcdef\" },\n\t{ MU, A, 0, 0, \"(?<=aaa|aa|a)a\", \"aaa\" },\n\t{ MU, A, 0, 2, \"(?<=aaa|aa|a)a\", \"aaa\" },\n\t{ M, A, 0, 0, \"(?<=aaa|aa|a)a\", \"aaa\" },\n\t{ M, A, 0, 2, \"(?<=aaa|aa|a)a\", \"aaa\" },\n\t{ MU, A, 0, 0, \"(\\\\d{2})(?!\\\\w+c|(((\\\\w?)m){2}n)+|\\\\1)\", \"x5656\" },\n\t{ MU, A, 0, 0, \"((?=((\\\\d{2,6}\\\\w){2,}))\\\\w{5,20}K){2,}\", \"567v09708K12l00M00 567v09708K12l00M00K45K\" },\n\t{ MU, A, 0, 0, \"(?=(?:(?=\\\\S+a)\\\\w*(b)){3})\\\\w+\\\\d\", \"bba bbab nbbkba nbbkba0kl\" },\n\t{ MU, A, 0, 0, \"(?>a(?>(b+))a(?=(..)))*?k\", \"acabbcabbaabacabaabbakk\" },\n\t{ MU, A, 0, 0, \"((?(?=(a))a)+k)\", \"bbak\" },\n\t{ MU, A, 0, 0, \"((?(?=a)a)+k)\", \"bbak\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?=(?>(a))m)amk\", \"a k\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?!(?>(a))m)amk\", \"a k\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?>(?=(a))am)amk\", \"a k\" },\n\t{ MU, A, 0, 0, \"(?=(?>a|(?=(?>(b+))a|c)[a-c]+)*?m)[a-cm]+k\", \"aaam bbam baaambaam abbabba baaambaamk\" },\n\t{ MU, A, 0, 0, \"(?> ?\\?\\\\b(?(?=\\\\w{1,4}(a))m)\\\\w{0,8}bc){2,}?\", \"bca ssbc mabd ssbc mabc\" },\n\t{ MU, A, 0, 0, \"(?:(?=ab)?[^n][^n])+m\", \"ababcdabcdcdabnababcdabcdcdabm\" },\n\t{ MU, A, 0, 0, \"(?:(?=a(b))?[^n][^n])+m\", \"ababcdabcdcdabnababcdabcdcdabm\" },\n\t{ MU, A, 0, 0, \"(?:(?=.(.))??\\\\1.)+m\", \"aabbbcbacccanaabbbcbacccam\" },\n\t{ MU, A, 0, 0, \"(?:(?=.)??[a-c])+m\", \"abacdcbacacdcaccam\" },\n\t{ MU, A, 0, 0, \"((?!a)?(?!([^a]))?)+$\", \"acbab\" },\n\t{ MU, A, 0, 0, \"((?!a)?\\?(?!([^a]))?\\?)+$\", \"acbab\" },\n\t{ MU, A, 0, 0, \"a(?=(?C)\\\\B(?C`x`))b\", \"ab\" },\n\t{ MU, A, 0, 0, \"a(?!(?C)\\\\B(?C`x`))bb|ab\", \"abb\" },\n\t{ MU, A, 0, 0, \"a(?=\\\\b|(?C)\\\\B(?C`x`))b\", \"ab\" },\n\t{ MU, A, 0, 0, \"a(?!\\\\b|(?C)\\\\B(?C`x`))bb|ab\", \"abb\" },\n\t{ MU, A, 0, 0, \"c(?(?=(?C)\\\\B(?C`x`))ab|a)\", \"cab\" },\n\t{ MU, A, 0, 0, \"c(?(?!(?C)\\\\B(?C`x`))ab|a)\", \"cab\" },\n\t{ MU, A, 0, 0, \"c(?(?=\\\\b|(?C)\\\\B(?C`x`))ab|a)\", \"cab\" },\n\t{ MU, A, 0, 0, \"c(?(?!\\\\b|(?C)\\\\B(?C`x`))ab|a)\", \"cab\" },\n\t{ MU, A, 0, 0, \"a(?=)b\", \"ab\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"a(?!)b\", \"ab\" },\n\n\t/* Not empty, ACCEPT, FAIL */\n\t{ MU, A, PCRE2_NOTEMPTY, 0 | F_NOMATCH, \"a*\", \"bcx\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0, \"a*\", \"bcaad\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0, \"a*?\", \"bcaad\" },\n\t{ MU, A, PCRE2_NOTEMPTY_ATSTART, 0, \"a*\", \"bcaad\" },\n\t{ MU, A, 0, 0, \"a(*ACCEPT)b\", \"ab\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0 | F_NOMATCH, \"a*(*ACCEPT)b\", \"bcx\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0, \"a*(*ACCEPT)b\", \"bcaad\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0, \"a*?(*ACCEPT)b\", \"bcaad\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0 | F_NOMATCH, \"(?:z|a*(*ACCEPT)b)\", \"bcx\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0, \"(?:z|a*(*ACCEPT)b)\", \"bcaad\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0, \"(?:z|a*?(*ACCEPT)b)\", \"bcaad\" },\n\t{ MU, A, PCRE2_NOTEMPTY_ATSTART, 0, \"a*(*ACCEPT)b\", \"bcx\" },\n\t{ MU, A, PCRE2_NOTEMPTY_ATSTART, 0 | F_NOMATCH, \"a*(*ACCEPT)b\", \"\" },\n\t{ MU, A, 0, 0, \"((a(*ACCEPT)b))\", \"ab\" },\n\t{ MU, A, 0, 0, \"(a(*FAIL)a|a)\", \"aaa\" },\n\t{ MU, A, 0, 0, \"(?=ab(*ACCEPT)b)a\", \"ab\" },\n\t{ MU, A, 0, 0, \"(?=(?:x|ab(*ACCEPT)b))\", \"ab\" },\n\t{ MU, A, 0, 0, \"(?=(a(b(*ACCEPT)b)))a\", \"ab\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0, \"(?=a*(*ACCEPT))c\", \"c\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0 | F_NOMATCH, \"(?=A)\", \"AB\" },\n\n\t/* Conditional blocks. */\n\t{ MU, A, 0, 0, \"(?(?=(a))a|b)+k\", \"ababbalbbadabak\" },\n\t{ MU, A, 0, 0, \"(?(?!(b))a|b)+k\", \"ababbalbbadabak\" },\n\t{ MU, A, 0, 0, \"(?(?=a)a|b)+k\", \"ababbalbbadabak\" },\n\t{ MU, A, 0, 0, \"(?(?!b)a|b)+k\", \"ababbalbbadabak\" },\n\t{ MU, A, 0, 0, \"(?(?=(a))a*|b*)+k\", \"ababbalbbadabak\" },\n\t{ MU, A, 0, 0, \"(?(?!(b))a*|b*)+k\", \"ababbalbbadabak\" },\n\t{ MU, A, 0, 0, \"(?(?!(b))(?:aaaaaa|a)|(?:bbbbbb|b))+aaaak\", \"aaaaaaaaaaaaaa bbbbbbbbbbbbbbb aaaaaaak\" },\n\t{ MU, A, 0, 0, \"(?(?!b)(?:aaaaaa|a)|(?:bbbbbb|b))+aaaak\", \"aaaaaaaaaaaaaa bbbbbbbbbbbbbbb aaaaaaak\" },\n\t{ MU, A, 0, 0 | F_DIFF, \"(?(?!(b))(?:aaaaaa|a)|(?:bbbbbb|b))+bbbbk\", \"aaaaaaaaaaaaaa bbbbbbbbbbbbbbb bbbbbbbk\" },\n\t{ MU, A, 0, 0, \"(?(?!b)(?:aaaaaa|a)|(?:bbbbbb|b))+bbbbk\", \"aaaaaaaaaaaaaa bbbbbbbbbbbbbbb bbbbbbbk\" },\n\t{ MU, A, 0, 0, \"(?(?=a)a*|b*)+k\", \"ababbalbbadabak\" },\n\t{ MU, A, 0, 0, \"(?(?!b)a*|b*)+k\", \"ababbalbbadabak\" },\n\t{ MU, A, 0, 0, \"(?(?=a)ab)\", \"a\" },\n\t{ MU, A, 0, 0, \"(?(?<!b)c)\", \"b\" },\n\t{ MU, A, 0, 0, \"(?(DEFINE)a(b))\", \"a\" },\n\t{ MU, A, 0, 0, \"a(?(DEFINE)(?:b|(?:c?)+)*)\", \"a\" },\n\t{ MU, A, 0, 0, \"(?(?=.[a-c])[k-l]|[A-D])\", \"kdB\" },\n\t{ MU, A, 0, 0, \"(?(?!.{0,4}[cd])(aa|bb)|(cc|dd))+\", \"aabbccddaa\" },\n\t{ MU, A, 0, 0, \"(?(?=[^#@]*@)(aaab|aa|aba)|(aba|aab)){3,}\", \"aaabaaaba#aaabaaaba#aaabaaaba@\" },\n\t{ MU, A, 0, 0, \"((?=\\\\w{5})\\\\w(?(?=\\\\w*k)\\\\d|[a-f_])*\\\\w\\\\s)+\", \"mol m10kk m088k _f_a_ mbkkl\" },\n\t{ MU, A, 0, 0, \"(c)?\\?(?(1)a|b)\", \"cdcaa\" },\n\t{ MU, A, 0, 0, \"(c)?\\?(?(1)a|b)\", \"cbb\" },\n\t{ MU, A, 0, 0 | F_DIFF, \"(?(?=(a))(aaaa|a?))+aak\", \"aaaaab aaaaak\" },\n\t{ MU, A, 0, 0, \"(?(?=a)(aaaa|a?))+aak\", \"aaaaab aaaaak\" },\n\t{ MU, A, 0, 0, \"(?(?!(b))(aaaa|a?))+aak\", \"aaaaab aaaaak\" },\n\t{ MU, A, 0, 0, \"(?(?!b)(aaaa|a?))+aak\", \"aaaaab aaaaak\" },\n\t{ MU, A, 0, 0 | F_DIFF, \"(?(?=(a))a*)+aak\", \"aaaaab aaaaak\" },\n\t{ MU, A, 0, 0, \"(?(?=a)a*)+aak\", \"aaaaab aaaaak\" },\n\t{ MU, A, 0, 0, \"(?(?!(b))a*)+aak\", \"aaaaab aaaaak\" },\n\t{ MU, A, 0, 0, \"(?(?!b)a*)+aak\", \"aaaaab aaaaak\" },\n\t{ MU, A, 0, 0, \"(?(?=(?=(?!(x))a)aa)aaa|(?(?=(?!y)bb)bbb))*k\", \"abaabbaaabbbaaabbb abaabbaaabbbaaabbbk\" },\n\t{ MU, A, 0, 0, \"(?P<Name>a)?(?P<Name2>b)?(?(Name)c|d)*l\", \"bc ddd abccabccl\" },\n\t{ MU, A, 0, 0, \"(?P<Name>a)?(?P<Name2>b)?(?(Name)c|d)+?dd\", \"bcabcacdb bdddd\" },\n\t{ MU, A, 0, 0, \"(?P<Name>a)?(?P<Name2>b)?(?(Name)c|d)+l\", \"ababccddabdbccd abcccl\" },\n\t{ MU, A, 0, 0, \"((?:a|aa)(?(1)aaa))x\", \"aax\" },\n\t{ MU, A, 0, 0, \"(?(?!)a|b)\", \"ab\" },\n\t{ MU, A, 0, 0, \"(?(?!)a)\", \"ab\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?(?!)a|b)\", \"ac\" },\n\n\t/* Set start of match. */\n\t{ MU, A, 0, 0, \"(?:\\\\Ka)*aaaab\", \"aaaaaaaa aaaaaaabb\" },\n\t{ MU, A, 0, 0, \"(?>\\\\Ka\\\\Ka)*aaaab\", \"aaaaaaaa aaaaaaaaaabb\" },\n\t{ MU, A, 0, 0, \"a+\\\\K(?<=\\\\Gaa)a\", \"aaaaaa\" },\n\t{ MU, A, PCRE2_NOTEMPTY, 0 | F_NOMATCH, \"a\\\\K(*ACCEPT)b\", \"aa\" },\n\t{ MU, A, PCRE2_NOTEMPTY_ATSTART, 0, \"a\\\\K(*ACCEPT)b\", \"aa\" },\n\n\t/* First line. */\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0 | F_PROPERTY, \"\\\\p{Any}a\", \"bb\\naaa\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0 | F_NOMATCH | F_PROPERTY, \"\\\\p{Any}a\", \"bb\\r\\naaa\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0, \"(?<=a)\", \"a\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0 | F_NOMATCH, \"[^a][^b]\", \"ab\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0 | F_NOMATCH, \"a\", \"\\na\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0 | F_NOMATCH, \"[abc]\", \"\\na\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0 | F_NOMATCH, \"^a\", \"\\na\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0 | F_NOMATCH, \"^(?<=\\n)\", \"\\na\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0, \"\\xf0\\x90\\x90\\x80\", \"\\xf0\\x90\\x90\\x80\" },\n\t{ MU | PCRE2_FIRSTLINE, PCRE2_NEWLINE_ANY, 0, 0 | F_NOMATCH, \"#\", \"\\xc2\\x85#\" },\n\t{ M | PCRE2_FIRSTLINE, PCRE2_NEWLINE_ANY, 0, 0 | F_NOMATCH, \"#\", \"\\x85#\" },\n\t{ MU | PCRE2_FIRSTLINE, PCRE2_NEWLINE_ANY, 0, 0 | F_NOMATCH, \"^#\", \"\\xe2\\x80\\xa8#\" },\n\t{ MU | PCRE2_FIRSTLINE, PCRE2_NEWLINE_CRLF, 0, 0 | F_PROPERTY, \"\\\\p{Any}\", \"\\r\\na\" },\n\t{ MU | PCRE2_FIRSTLINE, PCRE2_NEWLINE_CRLF, 0, 0, \".\", \"\\r\" },\n\t{ MU | PCRE2_FIRSTLINE, PCRE2_NEWLINE_CRLF, 0, 0, \"a\", \"\\ra\" },\n\t{ MU | PCRE2_FIRSTLINE, PCRE2_NEWLINE_CRLF, 0, 0 | F_NOMATCH, \"ba\", \"bbb\\r\\nba\" },\n\t{ MU | PCRE2_FIRSTLINE, PCRE2_NEWLINE_CRLF, 0, 0 | F_NOMATCH | F_PROPERTY, \"\\\\p{Any}{4}|a\", \"\\r\\na\" },\n\t{ MU | PCRE2_FIRSTLINE, PCRE2_NEWLINE_CRLF, 0, 1, \".\", \"\\r\\n\" },\n\t{ PCRE2_FIRSTLINE | PCRE2_DOTALL, PCRE2_NEWLINE_LF, 0, 0 | F_NOMATCH, \"ab.\", \"ab\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 1 | F_NOMATCH, \"^[a-d0-9]\", \"\\nxx\\nd\" },\n\t{ PCRE2_FIRSTLINE | PCRE2_DOTALL, PCRE2_NEWLINE_ANY, 0, 0, \"....a\", \"012\\n0a\" },\n\t{ MU | PCRE2_FIRSTLINE, A, 0, 0, \"[aC]\", \"a\" },\n\n\t/* Recurse. */\n\t{ MU, A, 0, 0, \"(a)(?1)\", \"aa\" },\n\t{ MU, A, 0, 0, \"((a))(?1)\", \"aa\" },\n\t{ MU, A, 0, 0, \"(b|a)(?1)\", \"aa\" },\n\t{ MU, A, 0, 0, \"(b|(a))(?1)\", \"aa\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"((a)(b)(?:a*))(?1)\", \"aba\" },\n\t{ MU, A, 0, 0, \"((a)(b)(?:a*))(?1)\", \"abab\" },\n\t{ MU, A, 0, 0, \"((a+)c(?2))b(?1)\", \"aacaabaca\" },\n\t{ MU, A, 0, 0, \"((?2)b|(a)){2}(?1)\", \"aabab\" },\n\t{ MU, A, 0, 0, \"(?1)(a)*+(?2)(b(?1))\", \"aababa\" },\n\t{ MU, A, 0, 0, \"(?1)(((a(*ACCEPT)))b)\", \"axaa\" },\n\t{ MU, A, 0, 0, \"(?1)(?(DEFINE) (((ac(*ACCEPT)))b) )\", \"akaac\" },\n\t{ MU, A, 0, 0, \"(a+)b(?1)b\\\\1\", \"abaaabaaaaa\" },\n\t{ MU, A, 0, 0, \"(?(DEFINE)(aa|a))(?1)ab\", \"aab\" },\n\t{ MU, A, 0, 0, \"(?(DEFINE)(a\\\\Kb))(?1)+ababc\", \"abababxabababc\" },\n\t{ MU, A, 0, 0, \"(a\\\\Kb)(?1)+ababc\", \"abababxababababc\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(a\\\\Kb)(?1)+ababc\", \"abababxababababxc\" },\n\t{ MU, A, 0, 0, \"b|<(?R)*>\", \"<<b>\" },\n\t{ MU, A, 0, 0, \"(a\\\\K){0}(?:(?1)b|ac)\", \"ac\" },\n\t{ MU, A, 0, 0, \"(?(DEFINE)(a(?2)|b)(b(?1)|(a)))(?:(?1)|(?2))m\", \"ababababnababababaam\" },\n\t{ MU, A, 0, 0, \"(a)((?(R)a|b))(?2)\", \"aabbabaa\" },\n\t{ MU, A, 0, 0, \"(a)((?(R2)a|b))(?2)\", \"aabbabaa\" },\n\t{ MU, A, 0, 0, \"(a)((?(R1)a|b))(?2)\", \"ababba\" },\n\t{ MU, A, 0, 0, \"(?(R0)aa|bb(?R))\", \"abba aabb bbaa\" },\n\t{ MU, A, 0, 0, \"((?(R)(?:aaaa|a)|(?:(aaaa)|(a)))+)(?1)$\", \"aaaaaaaaaa aaaa\" },\n\t{ MU, A, 0, 0, \"(?P<Name>a(?(R&Name)a|b))(?1)\", \"aab abb abaa\" },\n\t{ MU, A, 0, 0, \"((?(R)a|(?1)){3})\", \"XaaaaaaaaaX\" },\n\t{ MU, A, 0, 0, \"((?:(?(R)a|(?1))){3})\", \"XaaaaaaaaaX\" },\n\t{ MU, A, 0, 0, \"((?(R)a|(?1)){1,3})aaaaaa\", \"aaaaaaaaXaaaaaaaaa\" },\n\t{ MU, A, 0, 0, \"((?(R)a|(?1)){1,3}?)M\", \"aaaM\" },\n\t{ MU, A, 0, 0, \"((.)(?:.|\\\\2(?1))){0}#(?1)#\", \"#aabbccdde# #aabbccddee#\" },\n\t{ MU, A, 0, 0, \"((.)(?:\\\\2|\\\\2{4}b)){0}#(?:(?1))+#\", \"#aaaab# #aaaaab#\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?1)$((.|\\\\2xx){1,2})\", \"abc\" },\n\n\t/* 16 bit specific tests. */\n\t{ CM, A, 0, 0 | F_FORCECONV, \"\\xc3\\xa1\", \"\\xc3\\x81\\xc3\\xa1\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"\\xe1\\xbd\\xb8\", \"\\xe1\\xbf\\xb8\\xe1\\xbd\\xb8\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"[\\xc3\\xa1]\", \"\\xc3\\x81\\xc3\\xa1\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"[\\xe1\\xbd\\xb8]\", \"\\xe1\\xbf\\xb8\\xe1\\xbd\\xb8\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"[a-\\xed\\xb0\\x80]\", \"A\" },\n\t{ CM, A, 0, 0 | F_NO8 | F_FORCECONV, \"[a-\\\\x{dc00}]\", \"B\" },\n\t{ CM, A, 0, 0 | F_NO8 | F_NOMATCH | F_FORCECONV, \"[b-\\\\x{dc00}]\", \"a\" },\n\t{ CM, A, 0, 0 | F_NO8 | F_FORCECONV, \"\\xed\\xa0\\x80\\\\x{d800}\\xed\\xb0\\x80\\\\x{dc00}\", \"\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xb0\\x80\\xed\\xb0\\x80\" },\n\t{ CM, A, 0, 0 | F_NO8 | F_FORCECONV, \"[\\xed\\xa0\\x80\\\\x{d800}]{1,2}?[\\xed\\xb0\\x80\\\\x{dc00}]{1,2}?#\", \"\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xb0\\x80\\xed\\xb0\\x80#\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"[\\xed\\xa0\\x80\\xed\\xb0\\x80#]{0,3}(?<=\\xed\\xb0\\x80.)\", \"\\xed\\xa0\\x80#\\xed\\xa0\\x80##\\xed\\xb0\\x80\\xed\\xa0\\x80\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"[\\xed\\xa0\\x80-\\xed\\xb3\\xbf]\", \"\\xed\\x9f\\xbf\\xed\\xa0\\x83\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"[\\xed\\xa0\\x80-\\xed\\xb3\\xbf]\", \"\\xed\\xb4\\x80\\xed\\xb3\\xb0\" },\n\t{ CM, A, 0, 0 | F_NO8 | F_FORCECONV, \"[\\\\x{d800}-\\\\x{dcff}]\", \"\\xed\\x9f\\xbf\\xed\\xa0\\x83\" },\n\t{ CM, A, 0, 0 | F_NO8 | F_FORCECONV, \"[\\\\x{d800}-\\\\x{dcff}]\", \"\\xed\\xb4\\x80\\xed\\xb3\\xb0\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"[\\xed\\xa0\\x80-\\xef\\xbf\\xbf]+[\\x1-\\xed\\xb0\\x80]+#\", \"\\xed\\xa0\\x85\\xc3\\x81\\xed\\xa0\\x85\\xef\\xbf\\xb0\\xc2\\x85\\xed\\xa9\\x89#\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"[\\xed\\xa0\\x80][\\xed\\xb0\\x80]{2,}\", \"\\xed\\xa0\\x80\\xed\\xb0\\x80\\xed\\xa0\\x80\\xed\\xb0\\x80\\xed\\xb0\\x80\\xed\\xb0\\x80\" },\n\t{ M, A, 0, 0 | F_FORCECONV, \"[^\\xed\\xb0\\x80]{3,}?\", \"##\\xed\\xb0\\x80#\\xed\\xb0\\x80#\\xc3\\x89#\\xed\\xb0\\x80\" },\n\t{ M, A, 0, 0 | F_NO8 | F_FORCECONV, \"[^\\\\x{dc00}]{3,}?\", \"##\\xed\\xb0\\x80#\\xed\\xb0\\x80#\\xc3\\x89#\\xed\\xb0\\x80\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \".\\\\B.\", \"\\xed\\xa0\\x80\\xed\\xb0\\x80\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"\\\\D+(?:\\\\d+|.)\\\\S+(?:\\\\s+|.)\\\\W+(?:\\\\w+|.)\\xed\\xa0\\x80\\xed\\xa0\\x80\", \"\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xa0\\x80\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"\\\\d*\\\\s*\\\\w*\\xed\\xa0\\x80\\xed\\xa0\\x80\", \"\\xed\\xa0\\x80\\xed\\xa0\\x80\" },\n\t{ CM, A, 0, 0 | F_FORCECONV | F_NOMATCH, \"\\\\d*?\\\\D*?\\\\s*?\\\\S*?\\\\w*?\\\\W*?##\", \"\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xa0\\x80\\xed\\xa0\\x80#\" },\n\t{ CM | PCRE2_EXTENDED, A, 0, 0 | F_FORCECONV, \"\\xed\\xa0\\x80 \\xed\\xb0\\x80 !\", \"\\xed\\xa0\\x80\\xed\\xb0\\x80!\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"\\xed\\xa0\\x80+#[^#]+\\xed\\xa0\\x80\", \"\\xed\\xa0\\x80#a\\xed\\xa0\\x80\" },\n\t{ CM, A, 0, 0 | F_FORCECONV, \"(\\xed\\xa0\\x80+)#\\\\1\", \"\\xed\\xa0\\x80\\xed\\xa0\\x80#\\xed\\xa0\\x80\\xed\\xa0\\x80\" },\n\t{ M, PCRE2_NEWLINE_ANY, 0, 0 | F_NO8 | F_FORCECONV, \"^-\", \"a--\\xe2\\x80\\xa8--\" },\n\t{ 0, BSR(PCRE2_BSR_UNICODE), 0, 0 | F_NO8 | F_FORCECONV, \"\\\\R\", \"ab\\xe2\\x80\\xa8\" },\n\t{ 0, 0, 0, 0 | F_NO8 | F_FORCECONV, \"\\\\v\", \"ab\\xe2\\x80\\xa9\" },\n\t{ 0, 0, 0, 0 | F_NO8 | F_FORCECONV, \"\\\\h\", \"ab\\xe1\\xa0\\x8e\" },\n\t{ 0, 0, 0, 0 | F_NO8 | F_FORCECONV, \"\\\\v+?\\\\V+?#\", \"\\xe2\\x80\\xa9\\xe2\\x80\\xa9\\xef\\xbf\\xbf\\xef\\xbf\\xbf#\" },\n\t{ 0, 0, 0, 0 | F_NO8 | F_FORCECONV, \"\\\\h+?\\\\H+?#\", \"\\xe1\\xa0\\x8e\\xe1\\xa0\\x8e\\xef\\xbf\\xbf\\xef\\xbf\\xbf#\" },\n\n\t/* Partial matching. */\n\t{ MU, A, PCRE2_PARTIAL_SOFT, 0, \"ab\", \"a\" },\n\t{ MU, A, PCRE2_PARTIAL_SOFT, 0, \"ab|a\", \"a\" },\n\t{ MU, A, PCRE2_PARTIAL_HARD, 0, \"ab|a\", \"a\" },\n\t{ MU, A, PCRE2_PARTIAL_SOFT, 0, \"\\\\b#\", \"a\" },\n\t{ MU, A, PCRE2_PARTIAL_SOFT, 0, \"(?<=a)b\", \"a\" },\n\t{ MU, A, PCRE2_PARTIAL_SOFT, 0, \"abc|(?<=xxa)bc\", \"xxab\" },\n\t{ MU, A, PCRE2_PARTIAL_SOFT, 0, \"a\\\\B\", \"a\" },\n\t{ MU, A, PCRE2_PARTIAL_HARD, 0, \"a\\\\b\", \"a\" },\n\n\t/* (*MARK) verb. */\n\t{ MU, A, 0, 0, \"a(*MARK:aa)a\", \"ababaa\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"a(*:aa)a\", \"abab\" },\n\t{ MU, A, 0, 0, \"a(*:aa)(b(*:bb)b|bc)\", \"abc\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"a(*:1)x|b(*:2)y\", \"abc\" },\n\t{ MU, A, 0, 0, \"(?>a(*:aa))b|ac\", \"ac\" },\n\t{ MU, A, 0, 0, \"(?(DEFINE)(a(*:aa)))(?1)\", \"a\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?(DEFINE)((a)(*:aa)))(?1)b\", \"aa\" },\n\t{ MU, A, 0, 0, \"(?(DEFINE)(a(*:aa)))a(?1)b|aac\", \"aac\" },\n\t{ MU, A, 0, 0, \"(a(*:aa)){0}(?:b(?1)b|c)+c\", \"babbab cc\" },\n\t{ MU, A, 0, 0, \"(a(*:aa)){0}(?:b(?1)b)+\", \"babba\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(a(*:aa)){0}(?:b(?1)b)+\", \"ba\" },\n\t{ MU, A, 0, 0, \"(a\\\\K(*:aa)){0}(?:b(?1)b|c)+c\", \"babbab cc\" },\n\t{ MU, A, 0, 0, \"(a\\\\K(*:aa)){0}(?:b(?1)b)+\", \"babba\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(a\\\\K(*:aa)){0}(?:b(?1)b)+\", \"ba\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*:mark)m\", \"a\" },\n\n\t/* (*COMMIT) verb. */\n\t{ MU, A, 0, 0 | F_NOMATCH, \"a(*COMMIT)b\", \"ac\" },\n\t{ MU, A, 0, 0, \"aa(*COMMIT)b\", \"xaxaab\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"a(*COMMIT)(*:msg)b|ac\", \"ac\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(a(*COMMIT)b)++\", \"abac\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"((a)(*COMMIT)b)++\", \"abac\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?=a(*COMMIT)b)ab|ad\", \"ad\" },\n\n\t/* (*PRUNE) verb. */\n\t{ MU, A, 0, 0, \"aa\\\\K(*PRUNE)b\", \"aaab\" },\n\t{ MU, A, 0, 0, \"aa(*PRUNE:bb)b|a\", \"aa\" },\n\t{ MU, A, 0, 0, \"(a)(a)(*PRUNE)b|(a)\", \"aa\" },\n\t{ MU, A, 0, 0, \"(a)(a)(a)(a)(a)(a)(a)(a)(*PRUNE)b|(a)\", \"aaaaaaaa\" },\n\t{ MU, A, PCRE2_PARTIAL_SOFT, 0, \"a(*PRUNE)a|\", \"a\" },\n\t{ MU, A, PCRE2_PARTIAL_SOFT, 0, \"a(*PRUNE)a|m\", \"a\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?=a(*PRUNE)b)ab|ad\", \"ad\" },\n\t{ MU, A, 0, 0, \"a(*COMMIT)(*PRUNE)d|bc\", \"abc\" },\n\t{ MU, A, 0, 0, \"(?=a(*COMMIT)b)a(*PRUNE)c|bc\", \"abc\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)(?=a(*COMMIT)b)a(*PRUNE)c|bc\", \"abc\" },\n\t{ MU, A, 0, 0, \"(?=(a)(*COMMIT)b)a(*PRUNE)c|bc\", \"abc\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)(?=(a)(*COMMIT)b)a(*PRUNE)c|bc\", \"abc\" },\n\t{ MU, A, 0, 0, \"(a(*COMMIT)b){0}a(?1)(*PRUNE)c|bc\", \"abc\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(a(*COMMIT)b){0}a(*COMMIT)(?1)(*PRUNE)c|bc\", \"abc\" },\n\t{ MU, A, 0, 0, \"(a(*COMMIT)b)++(*PRUNE)d|c\", \"ababc\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)(a(*COMMIT)b)++(*PRUNE)d|c\", \"ababc\" },\n\t{ MU, A, 0, 0, \"((a)(*COMMIT)b)++(*PRUNE)d|c\", \"ababc\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)((a)(*COMMIT)b)++(*PRUNE)d|c\", \"ababc\" },\n\t{ MU, A, 0, 0, \"(?>a(*COMMIT)b)*abab(*PRUNE)d|ba\", \"ababab\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)(?>a(*COMMIT)b)*abab(*PRUNE)d|ba\", \"ababab\" },\n\t{ MU, A, 0, 0, \"(?>a(*COMMIT)b)+abab(*PRUNE)d|ba\", \"ababab\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)(?>a(*COMMIT)b)+abab(*PRUNE)d|ba\", \"ababab\" },\n\t{ MU, A, 0, 0, \"(?>a(*COMMIT)b)?ab(*PRUNE)d|ba\", \"aba\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)(?>a(*COMMIT)b)?ab(*PRUNE)d|ba\", \"aba\" },\n\t{ MU, A, 0, 0, \"(?>a(*COMMIT)b)*?n(*PRUNE)d|ba\", \"abababn\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)(?>a(*COMMIT)b)*?n(*PRUNE)d|ba\", \"abababn\" },\n\t{ MU, A, 0, 0, \"(?>a(*COMMIT)b)+?n(*PRUNE)d|ba\", \"abababn\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)(?>a(*COMMIT)b)+?n(*PRUNE)d|ba\", \"abababn\" },\n\t{ MU, A, 0, 0, \"(?>a(*COMMIT)b)??n(*PRUNE)d|bn\", \"abn\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(*COMMIT)(?>a(*COMMIT)b)??n(*PRUNE)d|bn\", \"abn\" },\n\n\t/* (*SKIP) verb. */\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?=a(*SKIP)b)ab|ad\", \"ad\" },\n\t{ MU, A, 0, 0, \"(\\\\w+(*SKIP)#)\", \"abcd,xyz#,\" },\n\t{ MU, A, 0, 0, \"\\\\w+(*SKIP)#|mm\", \"abcd,xyz#,\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"b+(?<=(*SKIP)#c)|b+\", \"#bbb\" },\n\n\t/* (*THEN) verb. */\n\t{ MU, A, 0, 0, \"((?:a(*THEN)|aab)(*THEN)c|a+)+m\", \"aabcaabcaabcaabcnacm\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"((?:a(*THEN)|aab)(*THEN)c|a+)+m\", \"aabcm\" },\n\t{ MU, A, 0, 0, \"((?:a(*THEN)|aab)c|a+)+m\", \"aabcaabcnmaabcaabcm\" },\n\t{ MU, A, 0, 0, \"((?:a|aab)(*THEN)c|a+)+m\", \"aam\" },\n\t{ MU, A, 0, 0, \"((?:a(*COMMIT)|aab)(*THEN)c|a+)+m\", \"aam\" },\n\t{ MU, A, 0, 0, \"(?(?=a(*THEN)b)ab|ad)\", \"ad\" },\n\t{ MU, A, 0, 0, \"(?(?!a(*THEN)b)ad|add)\", \"add\" },\n\t{ MU, A, 0, 0 | F_NOMATCH, \"(?(?=a)a(*THEN)b|ad)\", \"ad\" },\n\t{ MU, A, 0, 0, \"(?!(?(?=a)ab|b(*THEN)d))bn|bnn\", \"bnn\" },\n\t{ MU, A, 0, 0, \"(?=(*THEN: ))* \", \" \" },\n\t{ MU, A, 0, 0, \"a(*THEN)(?R) |\", \"a\" },\n\n\t/* Recurse and control verbs. */\n\t{ MU, A, 0, 0, \"(a(*ACCEPT)b){0}a(?1)b\", \"aacaabb\" },\n\t{ MU, A, 0, 0, \"((a)\\\\2(*ACCEPT)b){0}a(?1)b\", \"aaacaaabb\" },\n\t{ MU, A, 0, 0, \"((ab|a(*ACCEPT)x)+|ababababax){0}_(?1)_\", \"_ababababax_ _ababababa_\" },\n\t{ MU, A, 0, 0, \"((.)(?:A(*ACCEPT)|(?1)\\\\2)){0}_(?1)_\", \"_bcdaAdcb_bcdaAdcb_\" },\n\t{ MU, A, 0, 0, \"((*MARK:m)(?:a|a(*COMMIT)b|aa)){0}_(?1)_\", \"_ab_\" },\n\t{ MU, A, 0, 0, \"((*MARK:m)(?:a|a(*COMMIT)b|aa)){0}_(?1)_|(_aa_)\", \"_aa_\" },\n\t{ MU, A, 0, 0, \"(a(*COMMIT)(?:b|bb)|c(*ACCEPT)d|dd){0}_(?1)+_\", \"_ax_ _cd_ _abbb_ _abcd_ _abbcdd_\" },\n\t{ MU, A, 0, 0, \"((.)(?:.|(*COMMIT)\\\\2{3}(*ACCEPT).*|.*)){0}_(?1){0,4}_\", \"_aaaabbbbccccddd_ _aaaabbbbccccdddd_\" },\n\n#ifdef SUPPORT_UNICODE\n\t/* Script runs and iterations. */\n\t{ MU, A, 0, 0, \"!(*sr:\\\\w\\\\w|\\\\w\\\\w\\\\w)*#\", \"!abcdefghijklmno!abcdefghijklmno!abcdef#\" },\n\t{ MU, A, 0, 0, \"!(*sr:\\\\w\\\\w|\\\\w\\\\w\\\\w)+#\", \"!abcdefghijklmno!abcdefghijklmno!abcdef#\" },\n\t{ MU, A, 0, 0, \"!(*sr:\\\\w\\\\w|\\\\w\\\\w\\\\w)*?#\", \"!abcdefghijklmno!abcdefghijklmno!abcdef#\" },\n\t{ MU, A, 0, 0, \"!(*sr:\\\\w\\\\w|\\\\w\\\\w\\\\w)+?#\", \"!abcdefghijklmno!abcdefghijklmno!abcdef#\" },\n\t{ MU, A, 0, 0, \"!(*sr:\\\\w\\\\w|\\\\w\\\\w\\\\w)*+#\", \"!abcdefghijklmno!abcdefghijklmno!abcdef#\" },\n\t{ MU, A, 0, 0, \"!(*sr:\\\\w\\\\w|\\\\w\\\\w\\\\w)++#\", \"!abcdefghijklmno!abcdefghijklmno!abcdef#\" },\n\t{ MU, A, 0, 0, \"!(*sr:\\\\w\\\\w|\\\\w\\\\w\\\\w)?#\", \"!ab!abc!ab!ab#\" },\n\t{ MU, A, 0, 0, \"!(*sr:\\\\w\\\\w|\\\\w\\\\w\\\\w)??#\", \"!ab!abc!ab!ab#\" },\n#endif\n\n\t/* Deep recursion. */\n\t{ MU, A, 0, 0, \"((((?:(?:(?:\\\\w)+)?)*|(?>\\\\w)+?)+|(?>\\\\w)?\\?)*)?\\\\s\", \"aaaaa+ \" },\n\t{ MU, A, 0, 0, \"(?:((?:(?:(?:\\\\w*?)+)??|(?>\\\\w)?|\\\\w*+)*)+)+?\\\\s\", \"aa+ \" },\n\t{ MU, A, 0, 0, \"((a?)+)+b\", \"aaaaaaaaaaaa b\" },\n\n\t/* Deep recursion: Stack limit reached. */\n\t{ M, A, 0, 0 | F_NOMATCH, \"a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaa\", \"aaaaaaaaaaaaaaaaaaaaaaa\" },\n\t{ M, A, 0, 0 | F_NOMATCH, \"(?:a+)+b\", \"aaaaaaaaaaaaaaaaaaaaaaaa b\" },\n\t{ M, A, 0, 0 | F_NOMATCH, \"(?:a+?)+?b\", \"aaaaaaaaaaaaaaaaaaaaaaaa b\" },\n\t{ M, A, 0, 0 | F_NOMATCH, \"(?:a*)*b\", \"aaaaaaaaaaaaaaaaaaaaaaaa b\" },\n\t{ M, A, 0, 0 | F_NOMATCH, \"(?:a*?)*?b\", \"aaaaaaaaaaaaaaaaaaaaaaaa b\" },\n\n\t{ 0, 0, 0, 0, NULL, NULL }\n};\n\n#ifdef SUPPORT_PCRE2_8\nstatic pcre2_jit_stack_8* callback8(void *arg)\n{\n\treturn (pcre2_jit_stack_8 *)arg;\n}\n#endif\n\n#ifdef SUPPORT_PCRE2_16\nstatic pcre2_jit_stack_16* callback16(void *arg)\n{\n\treturn (pcre2_jit_stack_16 *)arg;\n}\n#endif\n\n#ifdef SUPPORT_PCRE2_32\nstatic pcre2_jit_stack_32* callback32(void *arg)\n{\n\treturn (pcre2_jit_stack_32 *)arg;\n}\n#endif\n\n#ifdef SUPPORT_PCRE2_8\nstatic pcre2_jit_stack_8 *stack8;\n\nstatic pcre2_jit_stack_8 *getstack8(void)\n{\n\tif (!stack8)\n\t\tstack8 = pcre2_jit_stack_create_8(1, 1024 * 1024, NULL);\n\treturn stack8;\n}\n\nstatic void setstack8(pcre2_match_context_8 *mcontext)\n{\n\tif (!mcontext) {\n\t\tif (stack8)\n\t\t\tpcre2_jit_stack_free_8(stack8);\n\t\tstack8 = NULL;\n\t\treturn;\n\t}\n\n\tpcre2_jit_stack_assign_8(mcontext, callback8, getstack8());\n}\n#endif /* SUPPORT_PCRE2_8 */\n\n#ifdef SUPPORT_PCRE2_16\nstatic pcre2_jit_stack_16 *stack16;\n\nstatic pcre2_jit_stack_16 *getstack16(void)\n{\n\tif (!stack16)\n\t\tstack16 = pcre2_jit_stack_create_16(1, 1024 * 1024, NULL);\n\treturn stack16;\n}\n\nstatic void setstack16(pcre2_match_context_16 *mcontext)\n{\n\tif (!mcontext) {\n\t\tif (stack16)\n\t\t\tpcre2_jit_stack_free_16(stack16);\n\t\tstack16 = NULL;\n\t\treturn;\n\t}\n\n\tpcre2_jit_stack_assign_16(mcontext, callback16, getstack16());\n}\n#endif /* SUPPORT_PCRE2_16 */\n\n#ifdef SUPPORT_PCRE2_32\nstatic pcre2_jit_stack_32 *stack32;\n\nstatic pcre2_jit_stack_32 *getstack32(void)\n{\n\tif (!stack32)\n\t\tstack32 = pcre2_jit_stack_create_32(1, 1024 * 1024, NULL);\n\treturn stack32;\n}\n\nstatic void setstack32(pcre2_match_context_32 *mcontext)\n{\n\tif (!mcontext) {\n\t\tif (stack32)\n\t\t\tpcre2_jit_stack_free_32(stack32);\n\t\tstack32 = NULL;\n\t\treturn;\n\t}\n\n\tpcre2_jit_stack_assign_32(mcontext, callback32, getstack32());\n}\n#endif /* SUPPORT_PCRE2_32 */\n\n#ifdef SUPPORT_PCRE2_16\n\nstatic int convert_utf8_to_utf16(PCRE2_SPTR8 input, PCRE2_UCHAR16 *output, int *offsetmap, int max_length)\n{\n\tPCRE2_SPTR8 iptr = input;\n\tPCRE2_UCHAR16 *optr = output;\n\tunsigned int c;\n\n\tif (max_length == 0)\n\t\treturn 0;\n\n\twhile (*iptr && max_length > 1) {\n\t\tc = 0;\n\t\tif (offsetmap)\n\t\t\t*offsetmap++ = (int)(iptr - (unsigned char*)input);\n\n\t\tif (*iptr < 0xc0)\n\t\t\tc = *iptr++;\n\t\telse if (!(*iptr & 0x20)) {\n\t\t\tc = ((iptr[0] & 0x1f) << 6) | (iptr[1] & 0x3f);\n\t\t\tiptr += 2;\n\t\t} else if (!(*iptr & 0x10)) {\n\t\t\tc = ((iptr[0] & 0x0f) << 12) | ((iptr[1] & 0x3f) << 6) | (iptr[2] & 0x3f);\n\t\t\tiptr += 3;\n\t\t} else if (!(*iptr & 0x08)) {\n\t\t\tc = ((iptr[0] & 0x07) << 18) | ((iptr[1] & 0x3f) << 12) | ((iptr[2] & 0x3f) << 6) | (iptr[3] & 0x3f);\n\t\t\tiptr += 4;\n\t\t}\n\n\t\tif (c < 65536) {\n\t\t\t*optr++ = c;\n\t\t\tmax_length--;\n\t\t} else if (max_length <= 2) {\n\t\t\t*optr = '\\0';\n\t\t\treturn (int)(optr - output);\n\t\t} else {\n\t\t\tc -= 0x10000;\n\t\t\t*optr++ = 0xd800 | ((c >> 10) & 0x3ff);\n\t\t\t*optr++ = 0xdc00 | (c & 0x3ff);\n\t\t\tmax_length -= 2;\n\t\t\tif (offsetmap)\n\t\t\t\toffsetmap++;\n\t\t}\n\t}\n\tif (offsetmap)\n\t\t*offsetmap = (int)(iptr - (unsigned char*)input);\n\t*optr = '\\0';\n\treturn (int)(optr - output);\n}\n\nstatic int copy_char8_to_char16(PCRE2_SPTR8 input, PCRE2_UCHAR16 *output, int max_length)\n{\n\tPCRE2_SPTR8 iptr = input;\n\tPCRE2_UCHAR16 *optr = output;\n\n\tif (max_length == 0)\n\t\treturn 0;\n\n\twhile (*iptr && max_length > 1) {\n\t\t*optr++ = *iptr++;\n\t\tmax_length--;\n\t}\n\t*optr = '\\0';\n\treturn (int)(optr - output);\n}\n\n#define REGTEST_MAX_LENGTH16 4096\nstatic PCRE2_UCHAR16 regtest_buf16[REGTEST_MAX_LENGTH16];\nstatic int regtest_offsetmap16[REGTEST_MAX_LENGTH16];\n\n#endif /* SUPPORT_PCRE2_16 */\n\n#ifdef SUPPORT_PCRE2_32\n\nstatic int convert_utf8_to_utf32(PCRE2_SPTR8 input, PCRE2_UCHAR32 *output, int *offsetmap, int max_length)\n{\n\tPCRE2_SPTR8 iptr = input;\n\tPCRE2_UCHAR32 *optr = output;\n\tunsigned int c;\n\n\tif (max_length == 0)\n\t\treturn 0;\n\n\twhile (*iptr && max_length > 1) {\n\t\tc = 0;\n\t\tif (offsetmap)\n\t\t\t*offsetmap++ = (int)(iptr - (unsigned char*)input);\n\n\t\tif (*iptr < 0xc0)\n\t\t\tc = *iptr++;\n\t\telse if (!(*iptr & 0x20)) {\n\t\t\tc = ((iptr[0] & 0x1f) << 6) | (iptr[1] & 0x3f);\n\t\t\tiptr += 2;\n\t\t} else if (!(*iptr & 0x10)) {\n\t\t\tc = ((iptr[0] & 0x0f) << 12) | ((iptr[1] & 0x3f) << 6) | (iptr[2] & 0x3f);\n\t\t\tiptr += 3;\n\t\t} else if (!(*iptr & 0x08)) {\n\t\t\tc = ((iptr[0] & 0x07) << 18) | ((iptr[1] & 0x3f) << 12) | ((iptr[2] & 0x3f) << 6) | (iptr[3] & 0x3f);\n\t\t\tiptr += 4;\n\t\t}\n\n\t\t*optr++ = c;\n\t\tmax_length--;\n\t}\n\tif (offsetmap)\n\t\t*offsetmap = (int)(iptr - (unsigned char*)input);\n\t*optr = 0;\n\treturn (int)(optr - output);\n}\n\nstatic int copy_char8_to_char32(PCRE2_SPTR8 input, PCRE2_UCHAR32 *output, int max_length)\n{\n\tPCRE2_SPTR8 iptr = input;\n\tPCRE2_UCHAR32 *optr = output;\n\n\tif (max_length == 0)\n\t\treturn 0;\n\n\twhile (*iptr && max_length > 1) {\n\t\t*optr++ = *iptr++;\n\t\tmax_length--;\n\t}\n\t*optr = '\\0';\n\treturn (int)(optr - output);\n}\n\n#define REGTEST_MAX_LENGTH32 4096\nstatic PCRE2_UCHAR32 regtest_buf32[REGTEST_MAX_LENGTH32];\nstatic int regtest_offsetmap32[REGTEST_MAX_LENGTH32];\n\n#endif /* SUPPORT_PCRE2_32 */\n\nstatic int check_ascii(const char *input)\n{\n\tconst unsigned char *ptr = (unsigned char *)input;\n\twhile (*ptr) {\n\t\tif (*ptr > 127)\n\t\t\treturn 0;\n\t\tptr++;\n\t}\n\treturn 1;\n}\n\n#define OVECTOR_SIZE 15\n\nstatic int regression_tests(void)\n{\n\tstruct regression_test_case *current = regression_test_cases;\n\tint error;\n\tPCRE2_SIZE err_offs;\n\tint is_successful;\n\tint is_ascii;\n\tint total = 0;\n\tint successful = 0;\n\tint successful_row = 0;\n\tint counter = 0;\n\tint jit_compile_mode;\n\tint utf = 0;\n\tint disabled_options = 0;\n\tint i;\n#ifdef SUPPORT_PCRE2_8\n\tpcre2_code_8 *re8;\n\tpcre2_compile_context_8 *ccontext8;\n\tpcre2_match_data_8 *mdata8_1;\n\tpcre2_match_data_8 *mdata8_2;\n\tpcre2_match_context_8 *mcontext8;\n\tPCRE2_SIZE *ovector8_1 = NULL;\n\tPCRE2_SIZE *ovector8_2 = NULL;\n\tint return_value8[2];\n#endif\n#ifdef SUPPORT_PCRE2_16\n\tpcre2_code_16 *re16;\n\tpcre2_compile_context_16 *ccontext16;\n\tpcre2_match_data_16 *mdata16_1;\n\tpcre2_match_data_16 *mdata16_2;\n\tpcre2_match_context_16 *mcontext16;\n\tPCRE2_SIZE *ovector16_1 = NULL;\n\tPCRE2_SIZE *ovector16_2 = NULL;\n\tint return_value16[2];\n\tint length16;\n#endif\n#ifdef SUPPORT_PCRE2_32\n\tpcre2_code_32 *re32;\n\tpcre2_compile_context_32 *ccontext32;\n\tpcre2_match_data_32 *mdata32_1;\n\tpcre2_match_data_32 *mdata32_2;\n\tpcre2_match_context_32 *mcontext32;\n\tPCRE2_SIZE *ovector32_1 = NULL;\n\tPCRE2_SIZE *ovector32_2 = NULL;\n\tint return_value32[2];\n\tint length32;\n#endif\n\n#if defined SUPPORT_PCRE2_8\n\tPCRE2_UCHAR8 cpu_info[128];\n#elif defined SUPPORT_PCRE2_16\n\tPCRE2_UCHAR16 cpu_info[128];\n#elif defined SUPPORT_PCRE2_32\n\tPCRE2_UCHAR32 cpu_info[128];\n#endif\n#if defined SUPPORT_UNICODE && ((defined(SUPPORT_PCRE2_8) + defined(SUPPORT_PCRE2_16) + defined(SUPPORT_PCRE2_32)) >= 2)\n\tint return_value;\n#endif\n\n\t/* This test compares the behaviour of interpreter and JIT. Although disabling\n\tutf or ucp may make tests fail, if the pcre2_match result is the SAME, it is\n\tstill considered successful from pcre2_jit_test point of view. */\n\n#if defined SUPPORT_PCRE2_8\n\tpcre2_config_8(PCRE2_CONFIG_JITTARGET, &cpu_info);\n#elif defined SUPPORT_PCRE2_16\n\tpcre2_config_16(PCRE2_CONFIG_JITTARGET, &cpu_info);\n#elif defined SUPPORT_PCRE2_32\n\tpcre2_config_32(PCRE2_CONFIG_JITTARGET, &cpu_info);\n#endif\n\n\tprintf(\"Running JIT regression tests\\n\");\n\tprintf(\"  target CPU of SLJIT compiler: \");\n\tfor (i = 0; cpu_info[i]; i++)\n\t\tprintf(\"%c\", (char)(cpu_info[i]));\n\tprintf(\"\\n\");\n\n#if defined SUPPORT_PCRE2_8\n\tpcre2_config_8(PCRE2_CONFIG_UNICODE, &utf);\n#elif defined SUPPORT_PCRE2_16\n\tpcre2_config_16(PCRE2_CONFIG_UNICODE, &utf);\n#elif defined SUPPORT_PCRE2_32\n\tpcre2_config_32(PCRE2_CONFIG_UNICODE, &utf);\n#endif\n\n\tif (!utf)\n\t\tdisabled_options |= PCRE2_UTF;\n#ifdef SUPPORT_PCRE2_8\n\tprintf(\"  in  8 bit mode with UTF-8  %s:\\n\", utf ? \"enabled\" : \"disabled\");\n#endif\n#ifdef SUPPORT_PCRE2_16\n\tprintf(\"  in 16 bit mode with UTF-16 %s:\\n\", utf ? \"enabled\" : \"disabled\");\n#endif\n#ifdef SUPPORT_PCRE2_32\n\tprintf(\"  in 32 bit mode with UTF-32 %s:\\n\", utf ? \"enabled\" : \"disabled\");\n#endif\n\n\twhile (current->pattern) {\n\t\t/* printf(\"\\nPattern: %s :\\n\", current->pattern); */\n\t\ttotal++;\n\t\tis_ascii = 0;\n\t\tif (!(current->start_offset & F_PROPERTY))\n\t\t\tis_ascii = check_ascii(current->pattern) && check_ascii(current->input);\n\n\t\tif (current->match_options & PCRE2_PARTIAL_SOFT)\n\t\t\tjit_compile_mode = PCRE2_JIT_PARTIAL_SOFT;\n\t\telse if (current->match_options & PCRE2_PARTIAL_HARD)\n\t\t\tjit_compile_mode = PCRE2_JIT_PARTIAL_HARD;\n\t\telse\n\t\t\tjit_compile_mode = PCRE2_JIT_COMPLETE;\n\t\terror = 0;\n#ifdef SUPPORT_PCRE2_8\n\t\tre8 = NULL;\n\t\tccontext8 = pcre2_compile_context_create_8(NULL);\n\t\tif (ccontext8) {\n\t\t\tif (GET_NEWLINE(current->newline))\n\t\t\t\tpcre2_set_newline_8(ccontext8, GET_NEWLINE(current->newline));\n\t\t\tif (GET_BSR(current->newline))\n\t\t\t\tpcre2_set_bsr_8(ccontext8, GET_BSR(current->newline));\n\n\t\t\tif (!(current->start_offset & F_NO8)) {\n\t\t\t\tre8 = pcre2_compile_8((PCRE2_SPTR8)current->pattern, PCRE2_ZERO_TERMINATED,\n\t\t\t\t\tcurrent->compile_options & ~disabled_options,\n\t\t\t\t\t&error, &err_offs, ccontext8);\n\n\t\t\t\tif (!re8 && (utf || is_ascii))\n\t\t\t\t\tprintf(\"\\n8 bit: Cannot compile pattern \\\"%s\\\": %d\\n\", current->pattern, error);\n\t\t\t}\n\t\t\tpcre2_compile_context_free_8(ccontext8);\n\t\t}\n\t\telse\n\t\t\tprintf(\"\\n8 bit: Cannot allocate compile context\\n\");\n#endif\n#ifdef SUPPORT_PCRE2_16\n\t\tif ((current->compile_options & PCRE2_UTF) || (current->start_offset & F_FORCECONV))\n\t\t\tconvert_utf8_to_utf16((PCRE2_SPTR8)current->pattern, regtest_buf16, NULL, REGTEST_MAX_LENGTH16);\n\t\telse\n\t\t\tcopy_char8_to_char16((PCRE2_SPTR8)current->pattern, regtest_buf16, REGTEST_MAX_LENGTH16);\n\n\t\tre16 = NULL;\n\t\tccontext16 = pcre2_compile_context_create_16(NULL);\n\t\tif (ccontext16) {\n\t\t\tif (GET_NEWLINE(current->newline))\n\t\t\t\tpcre2_set_newline_16(ccontext16, GET_NEWLINE(current->newline));\n\t\t\tif (GET_BSR(current->newline))\n\t\t\t\tpcre2_set_bsr_16(ccontext16, GET_BSR(current->newline));\n\n\t\t\tif (!(current->start_offset & F_NO16)) {\n\t\t\t\tre16 = pcre2_compile_16(regtest_buf16, PCRE2_ZERO_TERMINATED,\n\t\t\t\t\tcurrent->compile_options & ~disabled_options,\n\t\t\t\t\t&error, &err_offs, ccontext16);\n\n\t\t\t\tif (!re16 && (utf || is_ascii))\n\t\t\t\t\tprintf(\"\\n16 bit: Cannot compile pattern \\\"%s\\\": %d\\n\", current->pattern, error);\n\t\t\t}\n\t\t\tpcre2_compile_context_free_16(ccontext16);\n\t\t}\n\t\telse\n\t\t\tprintf(\"\\n16 bit: Cannot allocate compile context\\n\");\n#endif\n#ifdef SUPPORT_PCRE2_32\n\t\tif ((current->compile_options & PCRE2_UTF) || (current->start_offset & F_FORCECONV))\n\t\t\tconvert_utf8_to_utf32((PCRE2_SPTR8)current->pattern, regtest_buf32, NULL, REGTEST_MAX_LENGTH32);\n\t\telse\n\t\t\tcopy_char8_to_char32((PCRE2_SPTR8)current->pattern, regtest_buf32, REGTEST_MAX_LENGTH32);\n\n\t\tre32 = NULL;\n\t\tccontext32 = pcre2_compile_context_create_32(NULL);\n\t\tif (ccontext32) {\n\t\t\tif (GET_NEWLINE(current->newline))\n\t\t\t\tpcre2_set_newline_32(ccontext32, GET_NEWLINE(current->newline));\n\t\t\tif (GET_BSR(current->newline))\n\t\t\t\tpcre2_set_bsr_32(ccontext32, GET_BSR(current->newline));\n\n\t\t\tif (!(current->start_offset & F_NO32)) {\n\t\t\t\tre32 = pcre2_compile_32(regtest_buf32, PCRE2_ZERO_TERMINATED,\n\t\t\t\t\tcurrent->compile_options & ~disabled_options,\n\t\t\t\t\t&error, &err_offs, ccontext32);\n\n\t\t\t\tif (!re32 && (utf || is_ascii))\n\t\t\t\t\tprintf(\"\\n32 bit: Cannot compile pattern \\\"%s\\\": %d\\n\", current->pattern, error);\n\t\t\t}\n\t\t\tpcre2_compile_context_free_32(ccontext32);\n\t\t}\n\t\telse\n\t\t\tprintf(\"\\n32 bit: Cannot allocate compile context\\n\");\n#endif\n\n\t\tcounter++;\n\t\tif ((counter & 0x3) != 0) {\n#ifdef SUPPORT_PCRE2_8\n\t\t\tsetstack8(NULL);\n#endif\n#ifdef SUPPORT_PCRE2_16\n\t\t\tsetstack16(NULL);\n#endif\n#ifdef SUPPORT_PCRE2_32\n\t\t\tsetstack32(NULL);\n#endif\n\t\t}\n\n#ifdef SUPPORT_PCRE2_8\n\t\treturn_value8[0] = -1000;\n\t\treturn_value8[1] = -1000;\n\t\tmdata8_1 = pcre2_match_data_create_8(OVECTOR_SIZE, NULL);\n\t\tmdata8_2 = pcre2_match_data_create_8(OVECTOR_SIZE, NULL);\n\t\tmcontext8 = pcre2_match_context_create_8(NULL);\n\t\tif (!mdata8_1 || !mdata8_2 || !mcontext8) {\n\t\t\tprintf(\"\\n8 bit: Cannot allocate match data\\n\");\n\t\t\tpcre2_match_data_free_8(mdata8_1);\n\t\t\tpcre2_match_data_free_8(mdata8_2);\n\t\t\tpcre2_match_context_free_8(mcontext8);\n\t\t\tpcre2_code_free_8(re8);\n\t\t\tre8 = NULL;\n\t\t} else {\n\t\t\tovector8_1 = pcre2_get_ovector_pointer_8(mdata8_1);\n\t\t\tovector8_2 = pcre2_get_ovector_pointer_8(mdata8_2);\n\t\t\tfor (i = 0; i < OVECTOR_SIZE * 2; ++i)\n\t\t\t\tovector8_1[i] = -2;\n\t\t\tfor (i = 0; i < OVECTOR_SIZE * 2; ++i)\n\t\t\t\tovector8_2[i] = -2;\n\t\t\tpcre2_set_match_limit_8(mcontext8, 10000000);\n\t\t}\n\t\tif (re8) {\n\t\t\treturn_value8[1] = pcre2_match_8(re8, (PCRE2_SPTR8)current->input, strlen(current->input),\n\t\t\t\tcurrent->start_offset & OFFSET_MASK, current->match_options, mdata8_2, mcontext8);\n\n\t\t\tif (pcre2_jit_compile_8(re8, jit_compile_mode)) {\n\t\t\t\tprintf(\"\\n8 bit: JIT compiler does not support \\\"%s\\\"\\n\", current->pattern);\n\t\t\t} else if ((counter & 0x1) != 0) {\n\t\t\t\tsetstack8(mcontext8);\n\t\t\t\treturn_value8[0] = pcre2_match_8(re8, (PCRE2_SPTR8)current->input, strlen(current->input),\n\t\t\t\t\tcurrent->start_offset & OFFSET_MASK, current->match_options, mdata8_1, mcontext8);\n\t\t\t} else {\n\t\t\t\tpcre2_jit_stack_assign_8(mcontext8, NULL, getstack8());\n\t\t\t\treturn_value8[0] = pcre2_jit_match_8(re8, (PCRE2_SPTR8)current->input, strlen(current->input),\n\t\t\t\t\tcurrent->start_offset & OFFSET_MASK, current->match_options, mdata8_1, mcontext8);\n\t\t\t}\n\t\t}\n#endif\n\n#ifdef SUPPORT_PCRE2_16\n\t\treturn_value16[0] = -1000;\n\t\treturn_value16[1] = -1000;\n\t\tmdata16_1 = pcre2_match_data_create_16(OVECTOR_SIZE, NULL);\n\t\tmdata16_2 = pcre2_match_data_create_16(OVECTOR_SIZE, NULL);\n\t\tmcontext16 = pcre2_match_context_create_16(NULL);\n\t\tif (!mdata16_1 || !mdata16_2 || !mcontext16) {\n\t\t\tprintf(\"\\n16 bit: Cannot allocate match data\\n\");\n\t\t\tpcre2_match_data_free_16(mdata16_1);\n\t\t\tpcre2_match_data_free_16(mdata16_2);\n\t\t\tpcre2_match_context_free_16(mcontext16);\n\t\t\tpcre2_code_free_16(re16);\n\t\t\tre16 = NULL;\n\t\t} else {\n\t\t\tovector16_1 = pcre2_get_ovector_pointer_16(mdata16_1);\n\t\t\tovector16_2 = pcre2_get_ovector_pointer_16(mdata16_2);\n\t\t\tfor (i = 0; i < OVECTOR_SIZE * 2; ++i)\n\t\t\t\tovector16_1[i] = -2;\n\t\t\tfor (i = 0; i < OVECTOR_SIZE * 2; ++i)\n\t\t\t\tovector16_2[i] = -2;\n\t\t\tpcre2_set_match_limit_16(mcontext16, 10000000);\n\t\t}\n\t\tif (re16) {\n\t\t\tif ((current->compile_options & PCRE2_UTF) || (current->start_offset & F_FORCECONV))\n\t\t\t\tlength16 = convert_utf8_to_utf16((PCRE2_SPTR8)current->input, regtest_buf16, regtest_offsetmap16, REGTEST_MAX_LENGTH16);\n\t\t\telse\n\t\t\t\tlength16 = copy_char8_to_char16((PCRE2_SPTR8)current->input, regtest_buf16, REGTEST_MAX_LENGTH16);\n\n\t\t\treturn_value16[1] = pcre2_match_16(re16, regtest_buf16, length16,\n\t\t\t\tcurrent->start_offset & OFFSET_MASK, current->match_options, mdata16_2, mcontext16);\n\n\t\t\tif (pcre2_jit_compile_16(re16, jit_compile_mode)) {\n\t\t\t\tprintf(\"\\n16 bit: JIT compiler does not support \\\"%s\\\"\\n\", current->pattern);\n\t\t\t} else if ((counter & 0x1) != 0) {\n\t\t\t\tsetstack16(mcontext16);\n\t\t\t\treturn_value16[0] = pcre2_match_16(re16, regtest_buf16, length16,\n\t\t\t\t\tcurrent->start_offset & OFFSET_MASK, current->match_options, mdata16_1, mcontext16);\n\t\t\t} else {\n\t\t\t\tpcre2_jit_stack_assign_16(mcontext16, NULL, getstack16());\n\t\t\t\treturn_value16[0] = pcre2_jit_match_16(re16, regtest_buf16, length16,\n\t\t\t\t\tcurrent->start_offset & OFFSET_MASK, current->match_options, mdata16_1, mcontext16);\n\t\t\t}\n\t\t}\n#endif\n\n#ifdef SUPPORT_PCRE2_32\n\t\treturn_value32[0] = -1000;\n\t\treturn_value32[1] = -1000;\n\t\tmdata32_1 = pcre2_match_data_create_32(OVECTOR_SIZE, NULL);\n\t\tmdata32_2 = pcre2_match_data_create_32(OVECTOR_SIZE, NULL);\n\t\tmcontext32 = pcre2_match_context_create_32(NULL);\n\t\tif (!mdata32_1 || !mdata32_2 || !mcontext32) {\n\t\t\tprintf(\"\\n32 bit: Cannot allocate match data\\n\");\n\t\t\tpcre2_match_data_free_32(mdata32_1);\n\t\t\tpcre2_match_data_free_32(mdata32_2);\n\t\t\tpcre2_match_context_free_32(mcontext32);\n\t\t\tpcre2_code_free_32(re32);\n\t\t\tre32 = NULL;\n\t\t} else {\n\t\t\tovector32_1 = pcre2_get_ovector_pointer_32(mdata32_1);\n\t\t\tovector32_2 = pcre2_get_ovector_pointer_32(mdata32_2);\n\t\t\tfor (i = 0; i < OVECTOR_SIZE * 2; ++i)\n\t\t\t\tovector32_1[i] = -2;\n\t\t\tfor (i = 0; i < OVECTOR_SIZE * 2; ++i)\n\t\t\t\tovector32_2[i] = -2;\n\t\t\tpcre2_set_match_limit_32(mcontext32, 10000000);\n\t\t}\n\t\tif (re32) {\n\t\t\tif ((current->compile_options & PCRE2_UTF) || (current->start_offset & F_FORCECONV))\n\t\t\t\tlength32 = convert_utf8_to_utf32((PCRE2_SPTR8)current->input, regtest_buf32, regtest_offsetmap32, REGTEST_MAX_LENGTH32);\n\t\t\telse\n\t\t\t\tlength32 = copy_char8_to_char32((PCRE2_SPTR8)current->input, regtest_buf32, REGTEST_MAX_LENGTH32);\n\n\t\t\treturn_value32[1] = pcre2_match_32(re32, regtest_buf32, length32,\n\t\t\t\tcurrent->start_offset & OFFSET_MASK, current->match_options, mdata32_2, mcontext32);\n\n\t\t\tif (pcre2_jit_compile_32(re32, jit_compile_mode)) {\n\t\t\t\tprintf(\"\\n32 bit: JIT compiler does not support \\\"%s\\\"\\n\", current->pattern);\n\t\t\t} else if ((counter & 0x1) != 0) {\n\t\t\t\tsetstack32(mcontext32);\n\t\t\t\treturn_value32[0] = pcre2_match_32(re32, regtest_buf32, length32,\n\t\t\t\t\tcurrent->start_offset & OFFSET_MASK, current->match_options, mdata32_1, mcontext32);\n\t\t\t} else {\n\t\t\t\tpcre2_jit_stack_assign_32(mcontext32, NULL, getstack32());\n\t\t\t\treturn_value32[0] = pcre2_jit_match_32(re32, regtest_buf32, length32,\n\t\t\t\t\tcurrent->start_offset & OFFSET_MASK, current->match_options, mdata32_1, mcontext32);\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/* printf(\"[%d-%d-%d|%d-%d|%d-%d|%d-%d]%s\",\n\t\t\treturn_value8[0], return_value16[0], return_value32[0],\n\t\t\t(int)ovector8_1[0], (int)ovector8_1[1],\n\t\t\t(int)ovector16_1[0], (int)ovector16_1[1],\n\t\t\t(int)ovector32_1[0], (int)ovector32_1[1],\n\t\t\t(current->compile_options & PCRE2_CASELESS) ? \"C\" : \"\"); */\n\n\t\t/* If F_DIFF is set, just run the test, but do not compare the results.\n\t\tSegfaults can still be captured. */\n\n\t\tis_successful = 1;\n\t\tif (!(current->start_offset & F_DIFF)) {\n#if defined SUPPORT_UNICODE && ((defined(SUPPORT_PCRE2_8) + defined(SUPPORT_PCRE2_16) + defined(SUPPORT_PCRE2_32)) >= 2)\n\t\t\tif (!(current->start_offset & F_FORCECONV)) {\n\n\t\t\t\t/* All results must be the same. */\n#ifdef SUPPORT_PCRE2_8\n\t\t\t\tif ((return_value = return_value8[0]) != return_value8[1]) {\n\t\t\t\t\tprintf(\"\\n8 bit: Return value differs(J8:%d,I8:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\treturn_value8[0], return_value8[1], total, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t} else\n#endif\n#ifdef SUPPORT_PCRE2_16\n\t\t\t\tif ((return_value = return_value16[0]) != return_value16[1]) {\n\t\t\t\t\tprintf(\"\\n16 bit: Return value differs(J16:%d,I16:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\treturn_value16[0], return_value16[1], total, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t} else\n#endif\n#ifdef SUPPORT_PCRE2_32\n\t\t\t\tif ((return_value = return_value32[0]) != return_value32[1]) {\n\t\t\t\t\tprintf(\"\\n32 bit: Return value differs(J32:%d,I32:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\treturn_value32[0], return_value32[1], total, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t} else\n#endif\n#if defined SUPPORT_PCRE2_8 && defined SUPPORT_PCRE2_16\n\t\t\t\tif (return_value8[0] != return_value16[0]) {\n\t\t\t\t\tprintf(\"\\n8 and 16 bit: Return value differs(J8:%d,J16:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\treturn_value8[0], return_value16[0],\n\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t} else\n#endif\n#if defined SUPPORT_PCRE2_8 && defined SUPPORT_PCRE2_32\n\t\t\t\tif (return_value8[0] != return_value32[0]) {\n\t\t\t\t\tprintf(\"\\n8 and 32 bit: Return value differs(J8:%d,J32:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\treturn_value8[0], return_value32[0],\n\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t} else\n#endif\n#if defined SUPPORT_PCRE2_16 && defined SUPPORT_PCRE2_32\n\t\t\t\tif (return_value16[0] != return_value32[0]) {\n\t\t\t\t\tprintf(\"\\n16 and 32 bit: Return value differs(J16:%d,J32:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\treturn_value16[0], return_value32[0],\n\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t} else\n#endif\n\t\t\t\tif (return_value >= 0 || return_value == PCRE2_ERROR_PARTIAL) {\n\t\t\t\t\tif (return_value == PCRE2_ERROR_PARTIAL) {\n\t\t\t\t\t\treturn_value = 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn_value *= 2;\n\t\t\t\t\t}\n#ifdef SUPPORT_PCRE2_8\n\t\t\t\t\treturn_value8[0] = return_value;\n#endif\n#ifdef SUPPORT_PCRE2_16\n\t\t\t\t\treturn_value16[0] = return_value;\n#endif\n#ifdef SUPPORT_PCRE2_32\n\t\t\t\t\treturn_value32[0] = return_value;\n#endif\n\t\t\t\t\t/* Transform back the results. */\n\t\t\t\t\tif (current->compile_options & PCRE2_UTF) {\n#ifdef SUPPORT_PCRE2_16\n\t\t\t\t\t\tfor (i = 0; i < return_value; ++i) {\n\t\t\t\t\t\t\tif (ovector16_1[i] != PCRE2_UNSET)\n\t\t\t\t\t\t\t\tovector16_1[i] = regtest_offsetmap16[ovector16_1[i]];\n\t\t\t\t\t\t\tif (ovector16_2[i] != PCRE2_UNSET)\n\t\t\t\t\t\t\t\tovector16_2[i] = regtest_offsetmap16[ovector16_2[i]];\n\t\t\t\t\t\t}\n#endif\n#ifdef SUPPORT_PCRE2_32\n\t\t\t\t\t\tfor (i = 0; i < return_value; ++i) {\n\t\t\t\t\t\t\tif (ovector32_1[i] != PCRE2_UNSET)\n\t\t\t\t\t\t\t\tovector32_1[i] = regtest_offsetmap32[ovector32_1[i]];\n\t\t\t\t\t\t\tif (ovector32_2[i] != PCRE2_UNSET)\n\t\t\t\t\t\t\t\tovector32_2[i] = regtest_offsetmap32[ovector32_2[i]];\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = 0; i < return_value; ++i) {\n#if defined SUPPORT_PCRE2_8 && defined SUPPORT_PCRE2_16\n\t\t\t\t\t\tif (ovector8_1[i] != ovector8_2[i] || ovector8_1[i] != ovector16_1[i] || ovector8_1[i] != ovector16_2[i]) {\n\t\t\t\t\t\t\tprintf(\"\\n8 and 16 bit: Ovector[%d] value differs(J8:%d,I8:%d,J16:%d,I16:%d): [%d] '%s' @ '%s' \\n\",\n\t\t\t\t\t\t\t\ti, (int)ovector8_1[i], (int)ovector8_2[i], (int)ovector16_1[i], (int)ovector16_2[i],\n\t\t\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\t\t\tis_successful = 0;\n\t\t\t\t\t\t}\n#endif\n#if defined SUPPORT_PCRE2_8 && defined SUPPORT_PCRE2_32\n\t\t\t\t\t\tif (ovector8_1[i] != ovector8_2[i] || ovector8_1[i] != ovector32_1[i] || ovector8_1[i] != ovector32_2[i]) {\n\t\t\t\t\t\t\tprintf(\"\\n8 and 32 bit: Ovector[%d] value differs(J8:%d,I8:%d,J32:%d,I32:%d): [%d] '%s' @ '%s' \\n\",\n\t\t\t\t\t\t\t\ti, (int)ovector8_1[i], (int)ovector8_2[i], (int)ovector32_1[i], (int)ovector32_2[i],\n\t\t\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\t\t\tis_successful = 0;\n\t\t\t\t\t\t}\n#endif\n#if defined SUPPORT_PCRE2_16 && defined SUPPORT_PCRE2_32\n\t\t\t\t\t\tif (ovector16_1[i] != ovector16_2[i] || ovector16_1[i] != ovector32_1[i] || ovector16_1[i] != ovector32_2[i]) {\n\t\t\t\t\t\t\tprintf(\"\\n16 and 32 bit: Ovector[%d] value differs(J16:%d,I16:%d,J32:%d,I32:%d): [%d] '%s' @ '%s' \\n\",\n\t\t\t\t\t\t\t\ti, (int)ovector16_1[i], (int)ovector16_2[i], (int)ovector32_1[i], (int)ovector32_2[i],\n\t\t\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\t\t\tis_successful = 0;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n#endif /* more than one of SUPPORT_PCRE2_8, SUPPORT_PCRE2_16 and SUPPORT_PCRE2_32 */\n\t\t\t{\n#ifdef SUPPORT_PCRE2_8\n\t\t\t\tif (return_value8[0] != return_value8[1]) {\n\t\t\t\t\tprintf(\"\\n8 bit: Return value differs(%d:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\treturn_value8[0], return_value8[1], total, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t} else if (return_value8[0] >= 0 || return_value8[0] == PCRE2_ERROR_PARTIAL) {\n\t\t\t\t\tif (return_value8[0] == PCRE2_ERROR_PARTIAL)\n\t\t\t\t\t\treturn_value8[0] = 2;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn_value8[0] *= 2;\n\n\t\t\t\t\tfor (i = 0; i < return_value8[0]; ++i)\n\t\t\t\t\t\tif (ovector8_1[i] != ovector8_2[i]) {\n\t\t\t\t\t\t\tprintf(\"\\n8 bit: Ovector[%d] value differs(%d:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\t\t\ti, (int)ovector8_1[i], (int)ovector8_2[i], total, current->pattern, current->input);\n\t\t\t\t\t\t\tis_successful = 0;\n\t\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\n#ifdef SUPPORT_PCRE2_16\n\t\t\t\tif (return_value16[0] != return_value16[1]) {\n\t\t\t\t\tprintf(\"\\n16 bit: Return value differs(%d:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\treturn_value16[0], return_value16[1], total, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t} else if (return_value16[0] >= 0 || return_value16[0] == PCRE2_ERROR_PARTIAL) {\n\t\t\t\t\tif (return_value16[0] == PCRE2_ERROR_PARTIAL)\n\t\t\t\t\t\treturn_value16[0] = 2;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn_value16[0] *= 2;\n\n\t\t\t\t\tfor (i = 0; i < return_value16[0]; ++i)\n\t\t\t\t\t\tif (ovector16_1[i] != ovector16_2[i]) {\n\t\t\t\t\t\t\tprintf(\"\\n16 bit: Ovector[%d] value differs(%d:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\t\t\ti, (int)ovector16_1[i], (int)ovector16_2[i], total, current->pattern, current->input);\n\t\t\t\t\t\t\tis_successful = 0;\n\t\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\n#ifdef SUPPORT_PCRE2_32\n\t\t\t\tif (return_value32[0] != return_value32[1]) {\n\t\t\t\t\tprintf(\"\\n32 bit: Return value differs(%d:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\treturn_value32[0], return_value32[1], total, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t} else if (return_value32[0] >= 0 || return_value32[0] == PCRE2_ERROR_PARTIAL) {\n\t\t\t\t\tif (return_value32[0] == PCRE2_ERROR_PARTIAL)\n\t\t\t\t\t\treturn_value32[0] = 2;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn_value32[0] *= 2;\n\n\t\t\t\t\tfor (i = 0; i < return_value32[0]; ++i)\n\t\t\t\t\t\tif (ovector32_1[i] != ovector32_2[i]) {\n\t\t\t\t\t\t\tprintf(\"\\n32 bit: Ovector[%d] value differs(%d:%d): [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\t\t\ti, (int)ovector32_1[i], (int)ovector32_2[i], total, current->pattern, current->input);\n\t\t\t\t\t\t\tis_successful = 0;\n\t\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\n\t\tif (is_successful) {\n#ifdef SUPPORT_PCRE2_8\n\t\t\tif (!(current->start_offset & F_NO8) && (utf || is_ascii)) {\n\t\t\t\tif (return_value8[0] < 0 && !(current->start_offset & F_NOMATCH)) {\n\t\t\t\t\tprintf(\"8 bit: Test should match: [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t}\n\n\t\t\t\tif (return_value8[0] >= 0 && (current->start_offset & F_NOMATCH)) {\n\t\t\t\t\tprintf(\"8 bit: Test should not match: [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t}\n\t\t\t}\n#endif\n#ifdef SUPPORT_PCRE2_16\n\t\t\tif (!(current->start_offset & F_NO16) && (utf || is_ascii)) {\n\t\t\t\tif (return_value16[0] < 0 && !(current->start_offset & F_NOMATCH)) {\n\t\t\t\t\tprintf(\"16 bit: Test should match: [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t}\n\n\t\t\t\tif (return_value16[0] >= 0 && (current->start_offset & F_NOMATCH)) {\n\t\t\t\t\tprintf(\"16 bit: Test should not match: [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t}\n\t\t\t}\n#endif\n#ifdef SUPPORT_PCRE2_32\n\t\t\tif (!(current->start_offset & F_NO32) && (utf || is_ascii)) {\n\t\t\t\tif (return_value32[0] < 0 && !(current->start_offset & F_NOMATCH)) {\n\t\t\t\t\tprintf(\"32 bit: Test should match: [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t}\n\n\t\t\t\tif (return_value32[0] >= 0 && (current->start_offset & F_NOMATCH)) {\n\t\t\t\t\tprintf(\"32 bit: Test should not match: [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\t\tis_successful = 0;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t}\n\n\t\tif (is_successful) {\n#ifdef SUPPORT_PCRE2_8\n\t\t\tif (re8 && !(current->start_offset & F_NO8) && pcre2_get_mark_8(mdata8_1) != pcre2_get_mark_8(mdata8_2)) {\n\t\t\t\tprintf(\"8 bit: Mark value mismatch: [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\tis_successful = 0;\n\t\t\t}\n#endif\n#ifdef SUPPORT_PCRE2_16\n\t\t\tif (re16 && !(current->start_offset & F_NO16) && pcre2_get_mark_16(mdata16_1) != pcre2_get_mark_16(mdata16_2)) {\n\t\t\t\tprintf(\"16 bit: Mark value mismatch: [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\tis_successful = 0;\n\t\t\t}\n#endif\n#ifdef SUPPORT_PCRE2_32\n\t\t\tif (re32 && !(current->start_offset & F_NO32) && pcre2_get_mark_32(mdata32_1) != pcre2_get_mark_32(mdata32_2)) {\n\t\t\t\tprintf(\"32 bit: Mark value mismatch: [%d] '%s' @ '%s'\\n\",\n\t\t\t\t\ttotal, current->pattern, current->input);\n\t\t\t\tis_successful = 0;\n\t\t\t}\n#endif\n\t\t}\n\n#ifdef SUPPORT_PCRE2_8\n\t\tpcre2_code_free_8(re8);\n\t\tpcre2_match_data_free_8(mdata8_1);\n\t\tpcre2_match_data_free_8(mdata8_2);\n\t\tpcre2_match_context_free_8(mcontext8);\n#endif\n#ifdef SUPPORT_PCRE2_16\n\t\tpcre2_code_free_16(re16);\n\t\tpcre2_match_data_free_16(mdata16_1);\n\t\tpcre2_match_data_free_16(mdata16_2);\n\t\tpcre2_match_context_free_16(mcontext16);\n#endif\n#ifdef SUPPORT_PCRE2_32\n\t\tpcre2_code_free_32(re32);\n\t\tpcre2_match_data_free_32(mdata32_1);\n\t\tpcre2_match_data_free_32(mdata32_2);\n\t\tpcre2_match_context_free_32(mcontext32);\n#endif\n\n\t\tif (is_successful) {\n\t\t\tsuccessful++;\n\t\t\tsuccessful_row++;\n\t\t\tprintf(\".\");\n\t\t\tif (successful_row >= 60) {\n\t\t\t\tsuccessful_row = 0;\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t} else\n\t\t\tsuccessful_row = 0;\n\n\t\tfflush(stdout);\n\t\tcurrent++;\n\t}\n#ifdef SUPPORT_PCRE2_8\n\tsetstack8(NULL);\n#endif\n#ifdef SUPPORT_PCRE2_16\n\tsetstack16(NULL);\n#endif\n#ifdef SUPPORT_PCRE2_32\n\tsetstack32(NULL);\n#endif\n\n\tif (total == successful) {\n\t\tprintf(\"\\nAll JIT regression tests are successfully passed.\\n\");\n\t\treturn 0;\n\t} else {\n\t\tprintf(\"\\nSuccessful test ratio: %d%% (%d failed)\\n\", successful * 100 / total, total - successful);\n\t\treturn 1;\n\t}\n}\n\n#if defined SUPPORT_UNICODE\n\nstatic int check_invalid_utf_result(int pattern_index, const char *type, int result,\n\tint match_start, int match_end, PCRE2_SIZE *ovector)\n{\n\tif (match_start < 0) {\n\t\tif (result != -1) {\n\t\t\tprintf(\"Pattern[%d] %s result is not -1.\\n\", pattern_index, type);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (result <= 0) {\n\t\tprintf(\"Pattern[%d] %s result (%d) is not greater than 0.\\n\", pattern_index, type, result);\n\t\treturn 1;\n\t}\n\n\tif (ovector[0] != (PCRE2_SIZE)match_start) {\n\t\tprintf(\"Pattern[%d] %s ovector[0] is unexpected (%d instead of %d)\\n\",\n\t\t\tpattern_index, type, (int)ovector[0], match_start);\n\t\treturn 1;\n\t}\n\n\tif (ovector[1] != (PCRE2_SIZE)match_end) {\n\t\tprintf(\"Pattern[%d] %s ovector[1] is unexpected (%d instead of %d)\\n\",\n\t\t\tpattern_index, type, (int)ovector[1], match_end);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n#endif /* SUPPORT_UNICODE */\n\n#if defined SUPPORT_UNICODE && defined SUPPORT_PCRE2_8\n\n#define UDA (PCRE2_UTF | PCRE2_DOTALL | PCRE2_ANCHORED)\n#define CI (PCRE2_JIT_COMPLETE | PCRE2_JIT_INVALID_UTF)\n#define CPI (PCRE2_JIT_COMPLETE | PCRE2_JIT_PARTIAL_SOFT | PCRE2_JIT_INVALID_UTF)\n\nstruct invalid_utf8_regression_test_case {\n\tint compile_options;\n\tint jit_compile_options;\n\tint start_offset;\n\tint skip_left;\n\tint skip_right;\n\tint match_start;\n\tint match_end;\n\tconst char *pattern[2];\n\tconst char *input;\n};\n\nstatic const char invalid_utf8_newline_cr;\n\nstatic const struct invalid_utf8_regression_test_case invalid_utf8_regression_test_cases[] = {\n\t{ UDA, CI, 0, 0, 0, 0, 4, { \".\", NULL }, \"\\xf4\\x8f\\xbf\\xbf\" },\n\t{ UDA, CI, 0, 0, 0, 0, 4, { \".\", NULL }, \"\\xf0\\x90\\x80\\x80\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xf4\\x90\\x80\\x80\" },\n\t{ UDA, CI, 0, 0, 1, -1, -1, { \".\", NULL }, \"\\xf4\\x8f\\xbf\\xbf\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xf0\\x90\\x80\\x7f\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xf0\\x90\\x80\\xc0\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xf0\\x8f\\xbf\\xbf\" },\n\t{ UDA, CI, 0, 0, 0, 0, 3, { \".\", NULL }, \"\\xef\\xbf\\xbf#\" },\n\t{ UDA, CI, 0, 0, 0, 0, 3, { \".\", NULL }, \"\\xef\\xbf\\xbf\" },\n\t{ UDA, CI, 0, 0, 0, 0, 3, { \".\", NULL }, \"\\xe0\\xa0\\x80#\" },\n\t{ UDA, CI, 0, 0, 0, 0, 3, { \".\", NULL }, \"\\xe0\\xa0\\x80\" },\n\t{ UDA, CI, 0, 0, 2, -1, -1, { \".\", NULL }, \"\\xef\\xbf\\xbf#\" },\n\t{ UDA, CI, 0, 0, 1, -1, -1, { \".\", NULL }, \"\\xef\\xbf\\xbf\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xef\\xbf\\x7f#\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xef\\xbf\\xc0\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xe0\\x9f\\xbf#\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xe0\\x9f\\xbf\" },\n\t{ UDA, CI, 0, 0, 0, 0, 3, { \".\", NULL }, \"\\xed\\x9f\\xbf#\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xed\\xa0\\x80#\" },\n\t{ UDA, CI, 0, 0, 0, 0, 3, { \".\", NULL }, \"\\xee\\x80\\x80#\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xed\\xbf\\xbf#\" },\n\t{ UDA, CI, 0, 0, 0, 0, 2, { \".\", NULL }, \"\\xdf\\xbf##\" },\n\t{ UDA, CI, 0, 0, 0, 0, 2, { \".\", NULL }, \"\\xdf\\xbf#\" },\n\t{ UDA, CI, 0, 0, 0, 0, 2, { \".\", NULL }, \"\\xdf\\xbf\" },\n\t{ UDA, CI, 0, 0, 0, 0, 2, { \".\", NULL }, \"\\xc2\\x80##\" },\n\t{ UDA, CI, 0, 0, 0, 0, 2, { \".\", NULL }, \"\\xc2\\x80#\" },\n\t{ UDA, CI, 0, 0, 0, 0, 2, { \".\", NULL }, \"\\xc2\\x80\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xe0\\x80##\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xdf\\xc0##\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xe0\\x80\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xdf\\xc0\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xc1\\xbf##\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xc1\\xbf\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\x80###\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\x80\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xf8###\" },\n\t{ UDA, CI, 0, 0, 0, -1, -1, { \".\", NULL }, \"\\xf8\" },\n\t{ UDA, CI, 0, 0, 0, 0, 1, { \".\", NULL }, \"\\x7f\" },\n\n\t{ UDA, CPI, 4, 0, 0, 4, 4, { \"\\\\B\", NULL }, \"\\xf4\\x8f\\xbf\\xbf#\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xf4\\xa0\\x80\\x80\\xf4\\xa0\\x80\\x80\" },\n\t{ UDA, CPI, 4, 1, 1, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xf4\\x8f\\xbf\\xbf\\xf4\\x8f\\xbf\\xbf\" },\n\t{ UDA, CPI, 4, 0, 0, 4, 4, { \"\\\\B\", NULL }, \"#\\xef\\xbf\\xbf#\" },\n\t{ UDA, CPI, 4, 0, 0, 4, 4, { \"\\\\B\", NULL }, \"#\\xe0\\xa0\\x80#\" },\n\t{ UDA, CPI, 4, 0, 0, 4, 4, { \"\\\\B\", NULL }, \"\\xf0\\x90\\x80\\x80#\" },\n\t{ UDA, CPI, 4, 0, 0, 4, 4, { \"\\\\B\", NULL }, \"\\xf3\\xbf\\xbf\\xbf#\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xf0\\x8f\\xbf\\xbf\\xf0\\x8f\\xbf\\xbf\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xf5\\x80\\x80\\x80\\xf5\\x80\\x80\\x80\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xf4\\x90\\x80\\x80\\xf4\\x90\\x80\\x80\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xf4\\x8f\\xbf\\xff\\xf4\\x8f\\xbf\\xff\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xf4\\x8f\\xff\\xbf\\xf4\\x8f\\xff\\xbf\" },\n\t{ UDA, CPI, 4, 0, 1, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xef\\x80\\x80\\x80\\xef\\x80\\x80\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"#\\xe0\\x9f\\xbf\\xe0\\x9f\\xbf#\" },\n\t{ UDA, CPI, 4, 2, 2, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"#\\xe0\\xa0\\x80\\xe0\\xa0\\x80#\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"#\\xf0\\x80\\x80\\xf0\\x80\\x80#\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"#\\xed\\xa0\\x80\\xed\\xa0\\x80#\" },\n\t{ UDA, CPI, 4, 0, 0, 4, 4, { \"\\\\B\", NULL }, \"##\\xdf\\xbf#\" },\n\t{ UDA, CPI, 4, 2, 0, 2, 2, { \"\\\\B\", NULL }, \"##\\xdf\\xbf#\" },\n\t{ UDA, CPI, 4, 0, 0, 4, 4, { \"\\\\B\", NULL }, \"##\\xc2\\x80#\" },\n\t{ UDA, CPI, 4, 2, 0, 2, 2, { \"\\\\B\", NULL }, \"##\\xc2\\x80#\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"##\\xc1\\xbf\\xc1\\xbf##\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"##\\xdf\\xc0\\xdf\\xc0##\" },\n\t{ UDA, CPI, 4, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"##\\xe0\\x80\\xe0\\x80##\" },\n\n\t{ UDA, CPI, 3, 0, 0, 3, 3, { \"\\\\B\", NULL }, \"\\xef\\xbf\\xbf#\" },\n\t{ UDA, CPI, 3, 0, 0, 3, 3, { \"\\\\B\", NULL }, \"\\xe0\\xa0\\x80#\" },\n\t{ UDA, CPI, 3, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xe0\\x9f\\xbf\\xe0\\x9f\\xbf\" },\n\t{ UDA, CPI, 3, 1, 1, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xef\\xbf\\xbf\\xef\\xbf\\xbf\" },\n\t{ UDA, CPI, 3, 0, 1, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xdf\\x80\\x80\\xdf\\x80\" },\n\t{ UDA, CPI, 3, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xef\\xbf\\xff\\xef\\xbf\\xff\" },\n\t{ UDA, CPI, 3, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xef\\xff\\xbf\\xef\\xff\\xbf\" },\n\t{ UDA, CPI, 3, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xed\\xbf\\xbf\\xed\\xbf\\xbf\" },\n\n\t{ UDA, CPI, 2, 0, 0, 2, 2, { \"\\\\B\", NULL }, \"\\xdf\\xbf#\" },\n\t{ UDA, CPI, 2, 0, 0, 2, 2, { \"\\\\B\", NULL }, \"\\xc2\\x80#\" },\n\t{ UDA, CPI, 2, 1, 1, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xdf\\xbf\\xdf\\xbf\" },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xc1\\xbf\\xc1\\xbf\" },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xe0\\x80\\xe0\\x80\" },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xdf\\xff\\xdf\\xff\" },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xff\\xbf\\xff\\xbf\" },\n\n\t{ UDA, CPI, 1, 0, 0, 1, 1, { \"\\\\B\", NULL }, \"\\x7f#\" },\n\t{ UDA, CPI, 1, 0, 0, 1, 1, { \"\\\\B\", NULL }, \"\\x01#\" },\n\t{ UDA, CPI, 1, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\x80\\x80\" },\n\t{ UDA, CPI, 1, 0, 0, -1, -1, { \"\\\\B\", \"\\\\b\" }, \"\\xb0\\xb0\" },\n\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 0, 0, 2, { \"(.)\\\\1\", NULL }, \"aA\" },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 0, -1, -1, { \"(.)\\\\1\", NULL }, \"a\\xff\" },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 0, 0, 4, { \"(.)\\\\1\", NULL }, \"\\xc3\\xa1\\xc3\\x81\" },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 1, -1, -1, { \"(.)\\\\1\", NULL }, \"\\xc3\\xa1\\xc3\\x81\" },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 0, -1, -1, { \"(.)\\\\1\", NULL }, \"\\xc2\\x80\\x80\" },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 0, 0, 6, { \"(.)\\\\1\", NULL }, \"\\xe1\\xbd\\xb8\\xe1\\xbf\\xb8\" },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 1, -1, -1, { \"(.)\\\\1\", NULL }, \"\\xe1\\xbd\\xb8\\xe1\\xbf\\xb8\" },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 0, 0, 8, { \"(.)\\\\1\", NULL }, \"\\xf0\\x90\\x90\\x80\\xf0\\x90\\x90\\xa8\" },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 1, -1, -1, { \"(.)\\\\1\", NULL }, \"\\xf0\\x90\\x90\\x80\\xf0\\x90\\x90\\xa8\" },\n\n\t{ UDA, CPI, 0, 0, 0, 0, 1, { \"\\\\X\", NULL }, \"A\" },\n\t{ UDA, CPI, 0, 0, 0, -1, -1, { \"\\\\X\", NULL }, \"\\xff\" },\n\t{ UDA, CPI, 0, 0, 0, 0, 2, { \"\\\\X\", NULL }, \"\\xc3\\xa1\" },\n\t{ UDA, CPI, 0, 0, 1, -1, -1, { \"\\\\X\", NULL }, \"\\xc3\\xa1\" },\n\t{ UDA, CPI, 0, 0, 0, -1, -1, { \"\\\\X\", NULL }, \"\\xc3\\x7f\" },\n\t{ UDA, CPI, 0, 0, 0, 0, 3, { \"\\\\X\", NULL }, \"\\xe1\\xbd\\xb8\" },\n\t{ UDA, CPI, 0, 0, 1, -1, -1, { \"\\\\X\", NULL }, \"\\xe1\\xbd\\xb8\" },\n\t{ UDA, CPI, 0, 0, 0, 0, 4, { \"\\\\X\", NULL }, \"\\xf0\\x90\\x90\\x80\" },\n\t{ UDA, CPI, 0, 0, 1, -1, -1, { \"\\\\X\", NULL }, \"\\xf0\\x90\\x90\\x80\" },\n\n\t{ UDA, CPI, 0, 0, 0, -1, -1, { \"[^#]\", NULL }, \"#\" },\n\t{ UDA, CPI, 0, 0, 0, 0, 4, { \"[^#]\", NULL }, \"\\xf4\\x8f\\xbf\\xbf\" },\n\t{ UDA, CPI, 0, 0, 0, -1, -1, { \"[^#]\", NULL }, \"\\xf4\\x90\\x80\\x80\" },\n\t{ UDA, CPI, 0, 0, 0, -1, -1, { \"[^#]\", NULL }, \"\\xc1\\x80\" },\n\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 2, 3, { \"^\\\\W\", NULL }, \" \\x0a#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 14, 15, { \"^\\\\W\", NULL }, \" \\xc0\\x8a#\\xe0\\x80\\x8a#\\xf0\\x80\\x80\\x8a#\\x0a#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 3, 4, { \"^\\\\W\", NULL }, \" \\xf8\\x0a#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 3, 4, { \"^\\\\W\", NULL }, \" \\xc3\\x0a#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 3, 4, { \"^\\\\W\", NULL }, \" \\xf1\\x0a#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 4, 5, { \"^\\\\W\", NULL }, \" \\xf2\\xbf\\x0a#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 5, 6, { \"^\\\\W\", NULL }, \" \\xf2\\xbf\\xbf\\x0a#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 3, 4, { \"^\\\\W\", NULL }, \" \\xef\\x0a#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 4, 5, { \"^\\\\W\", NULL }, \" \\xef\\xbf\\x0a#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 5, 6, { \"^\\\\W\", NULL }, \" \\x85#\\xc2\\x85#\"},\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 7, 8, { \"^\\\\W\", NULL }, \" \\xe2\\x80\\xf8\\xe2\\x80\\xa8#\"},\n\n\t{ PCRE2_UTF | PCRE2_FIRSTLINE, CI, 0, 0, 0, -1, -1, { \"#\", NULL }, \"\\xe2\\x80\\xf8\\xe2\\x80\\xa8#\"},\n\t{ PCRE2_UTF | PCRE2_FIRSTLINE, CI, 0, 0, 0, 3, 4, { \"#\", NULL }, \"\\xe2\\x80\\xf8#\\xe2\\x80\\xa8#\"},\n\t{ PCRE2_UTF | PCRE2_FIRSTLINE, CI, 0, 0, 0, -1, -1, { \"#\", NULL }, \"abcd\\xc2\\x85#\"},\n\t{ PCRE2_UTF | PCRE2_FIRSTLINE, CI, 0, 0, 0, 1, 2, { \"#\", NULL }, \"\\x85#\\xc2\\x85#\"},\n\t{ PCRE2_UTF | PCRE2_FIRSTLINE, CI, 0, 0, 0, 5, 6, { \"#\", NULL }, \"\\xef,\\x80,\\xf8#\\x0a\"},\n\t{ PCRE2_UTF | PCRE2_FIRSTLINE, CI, 0, 0, 0, -1, -1, { \"#\", NULL }, \"\\xef,\\x80,\\xf8\\x0a#\"},\n\n\t{ PCRE2_UTF | PCRE2_NO_START_OPTIMIZE, CI, 0, 0, 0, 4, 8, { \"#\\xc7\\x85#\", NULL }, \"\\x80\\x80#\\xc7#\\xc7\\x85#\" },\n\t{ PCRE2_UTF | PCRE2_NO_START_OPTIMIZE, CI, 0, 0, 0, 7, 11, { \"#\\xc7\\x85#\", NULL }, \"\\x80\\x80#\\xc7\\x80\\x80\\x80#\\xc7\\x85#\" },\n\t{ PCRE2_UTF, CI, 0, 0, 0, 4, 8, { \"#\\xc7\\x85#\", NULL }, \"\\x80\\x80#\\xc7#\\xc7\\x85#\" },\n\t{ PCRE2_UTF, CI, 0, 0, 0, 7, 11, { \"#\\xc7\\x85#\", NULL }, \"\\x80\\x80#\\xc7\\x80\\x80\\x80#\\xc7\\x85#\" },\n\n\t{ PCRE2_UTF | PCRE2_UCP, CI, 0, 0, 0, -1, -1, { \"[\\\\s]\", NULL }, \"\\xed\\xa0\\x80\" },\n\n\t/* These two are not invalid UTF tests, but this infrastructure fits better for them. */\n\t{ 0, PCRE2_JIT_COMPLETE, 0, 0, 1, -1, -1, { \"\\\\X{2}\", NULL }, \"\\r\\n\\n\" },\n\t{ 0, PCRE2_JIT_COMPLETE, 0, 0, 1, -1, -1, { \"\\\\R{2}\", NULL }, \"\\r\\n\\n\" },\n\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 0, 0, 0, -1, -1, { \"^.a\", &invalid_utf8_newline_cr }, \"\\xc3\\xa7#a\" },\n\n\t{ 0, 0, 0, 0, 0, 0, 0, { NULL, NULL }, NULL }\n};\n\n#undef UDA\n#undef CI\n#undef CPI\n\nstatic int run_invalid_utf8_test(const struct invalid_utf8_regression_test_case *current,\n\tint pattern_index, int i, pcre2_compile_context_8 *ccontext, pcre2_match_data_8 *mdata)\n{\n\tpcre2_code_8 *code;\n\tint result, errorcode;\n\tPCRE2_SIZE length, erroroffset;\n\tPCRE2_SIZE *ovector = pcre2_get_ovector_pointer_8(mdata);\n\n\tif (current->pattern[i] == NULL)\n\t\treturn 1;\n\n\tcode = pcre2_compile_8((PCRE2_UCHAR8*)current->pattern[i], PCRE2_ZERO_TERMINATED,\n\t\tcurrent->compile_options, &errorcode, &erroroffset, ccontext);\n\n\tif (!code) {\n\t\tprintf(\"Pattern[%d:0] cannot be compiled. Error offset: %d\\n\", pattern_index, (int)erroroffset);\n\t\treturn 0;\n\t}\n\n\tif (pcre2_jit_compile_8(code, current->jit_compile_options) != 0) {\n\t\tprintf(\"Pattern[%d:0] cannot be compiled by the JIT compiler.\\n\", pattern_index);\n\t\tpcre2_code_free_8(code);\n\t\treturn 0;\n\t}\n\n\tlength = (PCRE2_SIZE)(strlen(current->input) - current->skip_left - current->skip_right);\n\n\tif (current->jit_compile_options & PCRE2_JIT_COMPLETE) {\n\t\tresult = pcre2_jit_match_8(code, (PCRE2_UCHAR8*)(current->input + current->skip_left),\n\t\t\tlength, current->start_offset - current->skip_left, 0, mdata, NULL);\n\n\t\tif (check_invalid_utf_result(pattern_index, \"match\", result, current->match_start, current->match_end, ovector)) {\n\t\t\tpcre2_code_free_8(code);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (current->jit_compile_options & PCRE2_JIT_PARTIAL_SOFT) {\n\t\tresult = pcre2_jit_match_8(code, (PCRE2_UCHAR8*)(current->input + current->skip_left),\n\t\t\tlength, current->start_offset - current->skip_left, PCRE2_PARTIAL_SOFT, mdata, NULL);\n\n\t\tif (check_invalid_utf_result(pattern_index, \"partial match\", result, current->match_start, current->match_end, ovector)) {\n\t\t\tpcre2_code_free_8(code);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpcre2_code_free_8(code);\n\treturn 1;\n}\n\nstatic int invalid_utf8_regression_tests(void)\n{\n\tconst struct invalid_utf8_regression_test_case *current;\n\tpcre2_compile_context_8 *ccontext;\n\tpcre2_match_data_8 *mdata;\n\tint total = 0, successful = 0;\n\tint result;\n\n\tprintf(\"\\nRunning invalid-utf8 JIT regression tests\\n\");\n\n\tccontext = pcre2_compile_context_create_8(NULL);\n\tpcre2_set_newline_8(ccontext, PCRE2_NEWLINE_ANY);\n\tmdata = pcre2_match_data_create_8(4, NULL);\n\n\tfor (current = invalid_utf8_regression_test_cases; current->pattern[0]; current++) {\n\t\t/* printf(\"\\nPattern: %s :\\n\", current->pattern); */\n\t\ttotal++;\n\n\t\tresult = 1;\n\t\tif (current->pattern[1] != &invalid_utf8_newline_cr)\n\t\t{\n\t\t\tif (!run_invalid_utf8_test(current, total - 1, 0, ccontext, mdata))\n\t\t\t\tresult = 0;\n\t\t\tif (!run_invalid_utf8_test(current, total - 1, 1, ccontext, mdata))\n\t\t\t\tresult = 0;\n\t\t} else {\n\t\t\tpcre2_set_newline_8(ccontext, PCRE2_NEWLINE_CR);\n\t\t\tif (!run_invalid_utf8_test(current, total - 1, 0, ccontext, mdata))\n\t\t\t\tresult = 0;\n\t\t\tpcre2_set_newline_8(ccontext, PCRE2_NEWLINE_ANY);\n\t\t}\n\n\t\tif (result) {\n\t\t\tsuccessful++;\n\t\t}\n\n\t\tprintf(\".\");\n\t\tif ((total % 60) == 0)\n\t\t\tprintf(\"\\n\");\n\t}\n\n\tif ((total % 60) != 0)\n\t\tprintf(\"\\n\");\n\n\tpcre2_match_data_free_8(mdata);\n\tpcre2_compile_context_free_8(ccontext);\n\n\tif (total == successful) {\n\t\tprintf(\"\\nAll invalid UTF8 JIT regression tests are successfully passed.\\n\");\n\t\treturn 0;\n\t} else {\n\t\tprintf(\"\\nInvalid UTF8 successful test ratio: %d%% (%d failed)\\n\", successful * 100 / total, total - successful);\n\t\treturn 1;\n\t}\n}\n\n#else /* !SUPPORT_UNICODE || !SUPPORT_PCRE2_8 */\n\nstatic int invalid_utf8_regression_tests(void)\n{\n\treturn 0;\n}\n\n#endif /* SUPPORT_UNICODE && SUPPORT_PCRE2_8 */\n\n#if defined SUPPORT_UNICODE && defined SUPPORT_PCRE2_16\n\n#define UDA (PCRE2_UTF | PCRE2_DOTALL | PCRE2_ANCHORED)\n#define CI (PCRE2_JIT_COMPLETE | PCRE2_JIT_INVALID_UTF)\n#define CPI (PCRE2_JIT_COMPLETE | PCRE2_JIT_PARTIAL_SOFT | PCRE2_JIT_INVALID_UTF)\n\nstruct invalid_utf16_regression_test_case {\n\tint compile_options;\n\tint jit_compile_options;\n\tint start_offset;\n\tint skip_left;\n\tint skip_right;\n\tint match_start;\n\tint match_end;\n\tconst PCRE2_UCHAR16 *pattern[2];\n\tconst PCRE2_UCHAR16 *input;\n};\n\nstatic PCRE2_UCHAR16 allany16[] = { '.', 0 };\nstatic PCRE2_UCHAR16 non_word_boundary16[] = { '\\\\', 'B', 0 };\nstatic PCRE2_UCHAR16 word_boundary16[] = { '\\\\', 'b', 0 };\nstatic PCRE2_UCHAR16 backreference16[] = { '(', '.', ')', '\\\\', '1', 0 };\nstatic PCRE2_UCHAR16 grapheme16[] = { '\\\\', 'X', 0 };\nstatic PCRE2_UCHAR16 nothashmark16[] = { '[', '^', '#', ']', 0 };\nstatic PCRE2_UCHAR16 afternl16[] = { '^', '\\\\', 'W', 0 };\nstatic PCRE2_UCHAR16 generic16[] = { '#', 0xd800, 0xdc00, '#', 0 };\nstatic PCRE2_UCHAR16 test16_1[] = { 0xd7ff, 0xe000, 0xffff, 0x01, '#', 0 };\nstatic PCRE2_UCHAR16 test16_2[] = { 0xd800, 0xdc00, 0xd800, 0xdc00, 0 };\nstatic PCRE2_UCHAR16 test16_3[] = { 0xdbff, 0xdfff, 0xdbff, 0xdfff, 0 };\nstatic PCRE2_UCHAR16 test16_4[] = { 0xd800, 0xdbff, 0xd800, 0xdbff, 0 };\nstatic PCRE2_UCHAR16 test16_5[] = { '#', 0xd800, 0xdc00, '#', 0 };\nstatic PCRE2_UCHAR16 test16_6[] = { 'a', 'A', 0xdc28, 0 };\nstatic PCRE2_UCHAR16 test16_7[] = { 0xd801, 0xdc00, 0xd801, 0xdc28, 0 };\nstatic PCRE2_UCHAR16 test16_8[] = { '#', 0xd800, 0xdc00, 0 };\nstatic PCRE2_UCHAR16 test16_9[] = { ' ', 0x2028, '#', 0 };\nstatic PCRE2_UCHAR16 test16_10[] = { ' ', 0xdc00, 0xd800, 0x2028, '#', 0 };\nstatic PCRE2_UCHAR16 test16_11[] = { 0xdc00, 0xdc00, 0xd800, 0xdc00, 0xdc00, '#', 0xd800, 0xdc00, '#', 0 };\nstatic PCRE2_UCHAR16 test16_12[] = { '#', 0xd800, 0xdc00, 0xd800, '#', 0xd800, 0xdc00, 0xdc00, 0xdc00, '#', 0xd800, 0xdc00, '#', 0 };\n\nstatic const struct invalid_utf16_regression_test_case invalid_utf16_regression_test_cases[] = {\n\t{ UDA, CI, 0, 0, 0, 0, 1, { allany16, NULL }, test16_1 },\n\t{ UDA, CI, 1, 0, 0, 1, 2, { allany16, NULL }, test16_1 },\n\t{ UDA, CI, 2, 0, 0, 2, 3, { allany16, NULL }, test16_1 },\n\t{ UDA, CI, 3, 0, 0, 3, 4, { allany16, NULL }, test16_1 },\n\t{ UDA, CI, 0, 0, 0, 0, 2, { allany16, NULL }, test16_2 },\n\t{ UDA, CI, 0, 0, 3, -1, -1, { allany16, NULL }, test16_2 },\n\t{ UDA, CI, 1, 0, 0, -1, -1, { allany16, NULL }, test16_2 },\n\t{ UDA, CI, 0, 0, 0, 0, 2, { allany16, NULL }, test16_3 },\n\t{ UDA, CI, 0, 0, 3, -1, -1, { allany16, NULL }, test16_3 },\n\t{ UDA, CI, 1, 0, 0, -1, -1, { allany16, NULL }, test16_3 },\n\n\t{ UDA, CPI, 1, 0, 0, 1, 1, { non_word_boundary16, NULL }, test16_1 },\n\t{ UDA, CPI, 2, 0, 0, 2, 2, { non_word_boundary16, NULL }, test16_1 },\n\t{ UDA, CPI, 3, 0, 0, 3, 3, { non_word_boundary16, NULL }, test16_1 },\n\t{ UDA, CPI, 4, 0, 0, 4, 4, { non_word_boundary16, NULL }, test16_1 },\n\t{ UDA, CPI, 2, 0, 0, 2, 2, { non_word_boundary16, NULL }, test16_2 },\n\t{ UDA, CPI, 2, 0, 0, 2, 2, { non_word_boundary16, NULL }, test16_3 },\n\t{ UDA, CPI, 2, 1, 1, -1, -1, { non_word_boundary16, word_boundary16 }, test16_2 },\n\t{ UDA, CPI, 2, 1, 1, -1, -1, { non_word_boundary16, word_boundary16 }, test16_3 },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { non_word_boundary16, word_boundary16 }, test16_4 },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { non_word_boundary16, word_boundary16 }, test16_5 },\n\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 0, 0, 2, { backreference16, NULL }, test16_6 },\n\t{ UDA | PCRE2_CASELESS, CPI, 1, 0, 0, -1, -1, { backreference16, NULL }, test16_6 },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 0, 0, 4, { backreference16, NULL }, test16_7 },\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 1, -1, -1, { backreference16, NULL }, test16_7 },\n\n\t{ UDA, CPI, 0, 0, 0, 0, 1, { grapheme16, NULL }, test16_6 },\n\t{ UDA, CPI, 1, 0, 0, 1, 2, { grapheme16, NULL }, test16_6 },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { grapheme16, NULL }, test16_6 },\n\t{ UDA, CPI, 0, 0, 0, 0, 2, { grapheme16, NULL }, test16_7 },\n\t{ UDA, CPI, 2, 0, 0, 2, 4, { grapheme16, NULL }, test16_7 },\n\t{ UDA, CPI, 1, 0, 0, -1, -1, { grapheme16, NULL }, test16_7 },\n\n\t{ UDA, CPI, 0, 0, 0, -1, -1, { nothashmark16, NULL }, test16_8 },\n\t{ UDA, CPI, 1, 0, 0, 1, 3, { nothashmark16, NULL }, test16_8 },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { nothashmark16, NULL }, test16_8 },\n\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 2, 3, { afternl16, NULL }, test16_9 },\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 4, 5, { afternl16, NULL }, test16_10 },\n\n\t{ PCRE2_UTF | PCRE2_NO_START_OPTIMIZE, CI, 0, 0, 0, 5, 9, { generic16, NULL }, test16_11 },\n\t{ PCRE2_UTF | PCRE2_NO_START_OPTIMIZE, CI, 0, 0, 0, 9, 13, { generic16, NULL }, test16_12 },\n\t{ PCRE2_UTF, CI, 0, 0, 0, 5, 9, { generic16, NULL }, test16_11 },\n\t{ PCRE2_UTF, CI, 0, 0, 0, 9, 13, { generic16, NULL }, test16_12 },\n\n\t{ 0, 0, 0, 0, 0, 0, 0, { NULL, NULL }, NULL }\n};\n\n#undef UDA\n#undef CI\n#undef CPI\n\nstatic int run_invalid_utf16_test(const struct invalid_utf16_regression_test_case *current,\n\tint pattern_index, int i, pcre2_compile_context_16 *ccontext, pcre2_match_data_16 *mdata)\n{\n\tpcre2_code_16 *code;\n\tint result, errorcode;\n\tPCRE2_SIZE length, erroroffset;\n\tconst PCRE2_UCHAR16 *input;\n\tPCRE2_SIZE *ovector = pcre2_get_ovector_pointer_16(mdata);\n\n\tif (current->pattern[i] == NULL)\n\t\treturn 1;\n\n\tcode = pcre2_compile_16(current->pattern[i], PCRE2_ZERO_TERMINATED,\n\t\tcurrent->compile_options, &errorcode, &erroroffset, ccontext);\n\n\tif (!code) {\n\t\tprintf(\"Pattern[%d:0] cannot be compiled. Error offset: %d\\n\", pattern_index, (int)erroroffset);\n\t\treturn 0;\n\t}\n\n\tif (pcre2_jit_compile_16(code, current->jit_compile_options) != 0) {\n\t\tprintf(\"Pattern[%d:0] cannot be compiled by the JIT compiler.\\n\", pattern_index);\n\t\tpcre2_code_free_16(code);\n\t\treturn 0;\n\t}\n\n\tinput = current->input;\n\tlength = 0;\n\n\twhile (*input++ != 0)\n\t\tlength++;\n\n\tlength -= current->skip_left + current->skip_right;\n\n\tif (current->jit_compile_options & PCRE2_JIT_COMPLETE) {\n\t\tresult = pcre2_jit_match_16(code, (current->input + current->skip_left),\n\t\t\tlength, current->start_offset - current->skip_left, 0, mdata, NULL);\n\n\t\tif (check_invalid_utf_result(pattern_index, \"match\", result, current->match_start, current->match_end, ovector)) {\n\t\t\tpcre2_code_free_16(code);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (current->jit_compile_options & PCRE2_JIT_PARTIAL_SOFT) {\n\t\tresult = pcre2_jit_match_16(code, (current->input + current->skip_left),\n\t\t\tlength, current->start_offset - current->skip_left, PCRE2_PARTIAL_SOFT, mdata, NULL);\n\n\t\tif (check_invalid_utf_result(pattern_index, \"partial match\", result, current->match_start, current->match_end, ovector)) {\n\t\t\tpcre2_code_free_16(code);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpcre2_code_free_16(code);\n\treturn 1;\n}\n\nstatic int invalid_utf16_regression_tests(void)\n{\n\tconst struct invalid_utf16_regression_test_case *current;\n\tpcre2_compile_context_16 *ccontext;\n\tpcre2_match_data_16 *mdata;\n\tint total = 0, successful = 0;\n\tint result;\n\n\tprintf(\"\\nRunning invalid-utf16 JIT regression tests\\n\");\n\n\tccontext = pcre2_compile_context_create_16(NULL);\n\tpcre2_set_newline_16(ccontext, PCRE2_NEWLINE_ANY);\n\tmdata = pcre2_match_data_create_16(4, NULL);\n\n\tfor (current = invalid_utf16_regression_test_cases; current->pattern[0]; current++) {\n\t\t/* printf(\"\\nPattern: %s :\\n\", current->pattern); */\n\t\ttotal++;\n\n\t\tresult = 1;\n\t\tif (!run_invalid_utf16_test(current, total - 1, 0, ccontext, mdata))\n\t\t\tresult = 0;\n\t\tif (!run_invalid_utf16_test(current, total - 1, 1, ccontext, mdata))\n\t\t\tresult = 0;\n\n\t\tif (result) {\n\t\t\tsuccessful++;\n\t\t}\n\n\t\tprintf(\".\");\n\t\tif ((total % 60) == 0)\n\t\t\tprintf(\"\\n\");\n\t}\n\n\tif ((total % 60) != 0)\n\t\tprintf(\"\\n\");\n\n\tpcre2_match_data_free_16(mdata);\n\tpcre2_compile_context_free_16(ccontext);\n\n\tif (total == successful) {\n\t\tprintf(\"\\nAll invalid UTF16 JIT regression tests are successfully passed.\\n\");\n\t\treturn 0;\n\t} else {\n\t\tprintf(\"\\nInvalid UTF16 successful test ratio: %d%% (%d failed)\\n\", successful * 100 / total, total - successful);\n\t\treturn 1;\n\t}\n}\n\n#else /* !SUPPORT_UNICODE || !SUPPORT_PCRE2_16 */\n\nstatic int invalid_utf16_regression_tests(void)\n{\n\treturn 0;\n}\n\n#endif /* SUPPORT_UNICODE && SUPPORT_PCRE2_16 */\n\n#if defined SUPPORT_UNICODE && defined SUPPORT_PCRE2_32\n\n#define UDA (PCRE2_UTF | PCRE2_DOTALL | PCRE2_ANCHORED)\n#define CI (PCRE2_JIT_COMPLETE | PCRE2_JIT_INVALID_UTF)\n#define CPI (PCRE2_JIT_COMPLETE | PCRE2_JIT_PARTIAL_SOFT | PCRE2_JIT_INVALID_UTF)\n\nstruct invalid_utf32_regression_test_case {\n\tint compile_options;\n\tint jit_compile_options;\n\tint start_offset;\n\tint skip_left;\n\tint skip_right;\n\tint match_start;\n\tint match_end;\n\tconst PCRE2_UCHAR32 *pattern[2];\n\tconst PCRE2_UCHAR32 *input;\n};\n\nstatic PCRE2_UCHAR32 allany32[] = { '.', 0 };\nstatic PCRE2_UCHAR32 non_word_boundary32[] = { '\\\\', 'B', 0 };\nstatic PCRE2_UCHAR32 word_boundary32[] = { '\\\\', 'b', 0 };\nstatic PCRE2_UCHAR32 backreference32[] = { '(', '.', ')', '\\\\', '1', 0 };\nstatic PCRE2_UCHAR32 grapheme32[] = { '\\\\', 'X', 0 };\nstatic PCRE2_UCHAR32 nothashmark32[] = { '[', '^', '#', ']', 0 };\nstatic PCRE2_UCHAR32 afternl32[] = { '^', '\\\\', 'W', 0 };\nstatic PCRE2_UCHAR32 test32_1[] = { 0x10ffff, 0x10ffff, 0x110000, 0x110000, 0x10ffff, 0 };\nstatic PCRE2_UCHAR32 test32_2[] = { 0xd7ff, 0xe000, 0xd800, 0xdfff, 0xe000, 0xdfff, 0xd800, 0 };\nstatic PCRE2_UCHAR32 test32_3[] = { 'a', 'A', 0x110000, 0 };\nstatic PCRE2_UCHAR32 test32_4[] = { '#', 0x10ffff, 0x110000, 0 };\nstatic PCRE2_UCHAR32 test32_5[] = { ' ', 0x2028, '#', 0 };\nstatic PCRE2_UCHAR32 test32_6[] = { ' ', 0x110000, 0x2028, '#', 0 };\n\nstatic const struct invalid_utf32_regression_test_case invalid_utf32_regression_test_cases[] = {\n\t{ UDA, CI, 0, 0, 0, 0, 1, { allany32, NULL }, test32_1 },\n\t{ UDA, CI, 2, 0, 0, -1, -1, { allany32, NULL }, test32_1 },\n\t{ UDA, CI, 0, 0, 0, 0, 1, { allany32, NULL }, test32_2 },\n\t{ UDA, CI, 1, 0, 0, 1, 2, { allany32, NULL }, test32_2 },\n\t{ UDA, CI, 2, 0, 0, -1, -1, { allany32, NULL }, test32_2 },\n\t{ UDA, CI, 3, 0, 0, -1, -1, { allany32, NULL }, test32_2 },\n\n\t{ UDA, CPI, 1, 0, 0, 1, 1, { non_word_boundary32, NULL }, test32_1 },\n\t{ UDA, CPI, 3, 0, 0, -1, -1, { non_word_boundary32, word_boundary32 }, test32_1 },\n\t{ UDA, CPI, 1, 0, 0, 1, 1, { non_word_boundary32, NULL }, test32_2 },\n\t{ UDA, CPI, 3, 0, 0, -1, -1, { non_word_boundary32, word_boundary32 }, test32_2 },\n\t{ UDA, CPI, 6, 0, 0, -1, -1, { non_word_boundary32, word_boundary32 }, test32_2 },\n\n\t{ UDA | PCRE2_CASELESS, CPI, 0, 0, 0, 0, 2, { backreference32, NULL }, test32_3 },\n\t{ UDA | PCRE2_CASELESS, CPI, 1, 0, 0, -1, -1, { backreference32, NULL }, test32_3 },\n\n\t{ UDA, CPI, 0, 0, 0, 0, 1, { grapheme32, NULL }, test32_1 },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { grapheme32, NULL }, test32_1 },\n\t{ UDA, CPI, 1, 0, 0, 1, 2, { grapheme32, NULL }, test32_2 },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { grapheme32, NULL }, test32_2 },\n\t{ UDA, CPI, 3, 0, 0, -1, -1, { grapheme32, NULL }, test32_2 },\n\t{ UDA, CPI, 4, 0, 0, 4, 5, { grapheme32, NULL }, test32_2 },\n\n\t{ UDA, CPI, 0, 0, 0, -1, -1, { nothashmark32, NULL }, test32_4 },\n\t{ UDA, CPI, 1, 0, 0, 1, 2, { nothashmark32, NULL }, test32_4 },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { nothashmark32, NULL }, test32_4 },\n\t{ UDA, CPI, 1, 0, 0, 1, 2, { nothashmark32, NULL }, test32_2 },\n\t{ UDA, CPI, 2, 0, 0, -1, -1, { nothashmark32, NULL }, test32_2 },\n\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 2, 3, { afternl32, NULL }, test32_5 },\n\t{ PCRE2_UTF | PCRE2_MULTILINE, CI, 1, 0, 0, 3, 4, { afternl32, NULL }, test32_6 },\n\n\t{ 0, 0, 0, 0, 0, 0, 0, { NULL, NULL }, NULL }\n};\n\n#undef UDA\n#undef CI\n#undef CPI\n\nstatic int run_invalid_utf32_test(const struct invalid_utf32_regression_test_case *current,\n\tint pattern_index, int i, pcre2_compile_context_32 *ccontext, pcre2_match_data_32 *mdata)\n{\n\tpcre2_code_32 *code;\n\tint result, errorcode;\n\tPCRE2_SIZE length, erroroffset;\n\tconst PCRE2_UCHAR32 *input;\n\tPCRE2_SIZE *ovector = pcre2_get_ovector_pointer_32(mdata);\n\n\tif (current->pattern[i] == NULL)\n\t\treturn 1;\n\n\tcode = pcre2_compile_32(current->pattern[i], PCRE2_ZERO_TERMINATED,\n\t\tcurrent->compile_options, &errorcode, &erroroffset, ccontext);\n\n\tif (!code) {\n\t\tprintf(\"Pattern[%d:0] cannot be compiled. Error offset: %d\\n\", pattern_index, (int)erroroffset);\n\t\treturn 0;\n\t}\n\n\tif (pcre2_jit_compile_32(code, current->jit_compile_options) != 0) {\n\t\tprintf(\"Pattern[%d:0] cannot be compiled by the JIT compiler.\\n\", pattern_index);\n\t\tpcre2_code_free_32(code);\n\t\treturn 0;\n\t}\n\n\tinput = current->input;\n\tlength = 0;\n\n\twhile (*input++ != 0)\n\t\tlength++;\n\n\tlength -= current->skip_left + current->skip_right;\n\n\tif (current->jit_compile_options & PCRE2_JIT_COMPLETE) {\n\t\tresult = pcre2_jit_match_32(code, (current->input + current->skip_left),\n\t\t\tlength, current->start_offset - current->skip_left, 0, mdata, NULL);\n\n\t\tif (check_invalid_utf_result(pattern_index, \"match\", result, current->match_start, current->match_end, ovector)) {\n\t\t\tpcre2_code_free_32(code);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (current->jit_compile_options & PCRE2_JIT_PARTIAL_SOFT) {\n\t\tresult = pcre2_jit_match_32(code, (current->input + current->skip_left),\n\t\t\tlength, current->start_offset - current->skip_left, PCRE2_PARTIAL_SOFT, mdata, NULL);\n\n\t\tif (check_invalid_utf_result(pattern_index, \"partial match\", result, current->match_start, current->match_end, ovector)) {\n\t\t\tpcre2_code_free_32(code);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpcre2_code_free_32(code);\n\treturn 1;\n}\n\nstatic int invalid_utf32_regression_tests(void)\n{\n\tconst struct invalid_utf32_regression_test_case *current;\n\tpcre2_compile_context_32 *ccontext;\n\tpcre2_match_data_32 *mdata;\n\tint total = 0, successful = 0;\n\tint result;\n\n\tprintf(\"\\nRunning invalid-utf32 JIT regression tests\\n\");\n\n\tccontext = pcre2_compile_context_create_32(NULL);\n\tpcre2_set_newline_32(ccontext, PCRE2_NEWLINE_ANY);\n\tmdata = pcre2_match_data_create_32(4, NULL);\n\n\tfor (current = invalid_utf32_regression_test_cases; current->pattern[0]; current++) {\n\t\t/* printf(\"\\nPattern: %s :\\n\", current->pattern); */\n\t\ttotal++;\n\n\t\tresult = 1;\n\t\tif (!run_invalid_utf32_test(current, total - 1, 0, ccontext, mdata))\n\t\t\tresult = 0;\n\t\tif (!run_invalid_utf32_test(current, total - 1, 1, ccontext, mdata))\n\t\t\tresult = 0;\n\n\t\tif (result) {\n\t\t\tsuccessful++;\n\t\t}\n\n\t\tprintf(\".\");\n\t\tif ((total % 60) == 0)\n\t\t\tprintf(\"\\n\");\n\t}\n\n\tif ((total % 60) != 0)\n\t\tprintf(\"\\n\");\n\n\tpcre2_match_data_free_32(mdata);\n\tpcre2_compile_context_free_32(ccontext);\n\n\tif (total == successful) {\n\t\tprintf(\"\\nAll invalid UTF32 JIT regression tests are successfully passed.\\n\");\n\t\treturn 0;\n\t} else {\n\t\tprintf(\"\\nInvalid UTF32 successful test ratio: %d%% (%d failed)\\n\", successful * 100 / total, total - successful);\n\t\treturn 1;\n\t}\n}\n\n#else /* !SUPPORT_UNICODE || !SUPPORT_PCRE2_32 */\n\nstatic int invalid_utf32_regression_tests(void)\n{\n\treturn 0;\n}\n\n#endif /* SUPPORT_UNICODE && SUPPORT_PCRE2_32 */\n\n/* End of pcre2_jit_test.c */\n"], "filenames": ["ChangeLog", "src/pcre2_jit_compile.c", "src/pcre2_jit_test.c"], "buggy_code_start_loc": [96, 415, 753], "buggy_code_end_loc": [96, 14091, 753], "fixing_code_start_loc": [97, 416, 754], "fixing_code_end_loc": [100, 14180, 755], "type": "CWE-125", "message": "An out-of-bounds read vulnerability was discovered in the PCRE2 library in the get_recurse_data_length() function of the pcre2_jit_compile.c file. This issue affects recursions in JIT-compiled regular expressions caused by duplicate data transfers.", "other": {"cve": {"id": "CVE-2022-1587", "sourceIdentifier": "secalert@redhat.com", "published": "2022-05-16T21:15:07.847", "lastModified": "2023-03-16T05:15:51.413", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An out-of-bounds read vulnerability was discovered in the PCRE2 library in the get_recurse_data_length() function of the pcre2_jit_compile.c file. This issue affects recursions in JIT-compiled regular expressions caused by duplicate data transfers."}, {"lang": "es", "value": "Se ha detectado una vulnerabilidad de lectura fuera de l\u00edmites en la biblioteca PCRE2 en la funci\u00f3n get_recurse_data_length() del archivo pcre2_jit_compile.c. Este problema afecta a las recursiones en expresiones regulares compiladas en JIT causadas por transferencias de datos duplicadas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pcre:pcre2:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.40", "matchCriteriaId": "EB329299-E960-45F2-80BA-5B6B9CD346D2"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:ontap_select_deploy_administration_utility:-:*:*:*:*:*:*:*", "matchCriteriaId": "E7CF3019-975D-40BB-A8A4-894E62BD3797"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2077983,", "source": "secalert@redhat.com", "tags": ["Broken Link", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/PCRE2Project/pcre2/commit/03654e751e7f0700693526b67dfcadda6b42c9d0", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/03/msg00014.html", "source": "secalert@redhat.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DWNG2NS3GINO6LQYUVC4BZLUQPJ3DYHA/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JXINO3KKI5DICQ45E2FKD6MKVMGJLEKJ/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KAX7767BCUFC7JMDGP7GOQ5GIZCAUGBB/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/M2GLQQUEY5VFM57CFYXVIFOXN2HUZPDM/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20221028-0009/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/PCRE2Project/pcre2/commit/03654e751e7f0700693526b67dfcadda6b42c9d0"}}