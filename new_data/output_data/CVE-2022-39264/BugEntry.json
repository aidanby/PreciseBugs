{"buggy_code": ["// SPDX-FileCopyrightText: 2021 Nheko Contributors\n// SPDX-FileCopyrightText: 2022 Nheko Contributors\n//\n// SPDX-License-Identifier: GPL-3.0-or-later\n\n#include \"Olm.h\"\n\n#include <QObject>\n#include <QTimer>\n\n#include <nlohmann/json.hpp>\n#include <variant>\n\n#include <mtx/responses/common.hpp>\n#include <mtx/secret_storage.hpp>\n\n#include \"Cache.h\"\n#include \"Cache_p.h\"\n#include \"ChatPage.h\"\n#include \"DeviceVerificationFlow.h\"\n#include \"EventAccessors.h\"\n#include \"Logging.h\"\n#include \"MatrixClient.h\"\n#include \"UserSettingsPage.h\"\n#include \"Utils.h\"\n\nnamespace {\nauto client_ = std::make_unique<mtx::crypto::OlmClient>();\n\nstd::map<std::string, std::string> request_id_to_secret_name;\n\nconstexpr auto MEGOLM_ALGO = \"m.megolm.v1.aes-sha2\";\n}\n\nnamespace olm {\nstatic void\nbackup_session_key(const MegolmSessionIndex &idx,\n                   const GroupSessionData &data,\n                   mtx::crypto::InboundGroupSessionPtr &session);\n\nvoid\nfrom_json(const nlohmann::json &obj, OlmMessage &msg)\n{\n    if (obj.at(\"type\") != \"m.room.encrypted\")\n        throw std::invalid_argument(\"invalid type for olm message\");\n\n    if (obj.at(\"content\").at(\"algorithm\") != OLM_ALGO)\n        throw std::invalid_argument(\"invalid algorithm for olm message\");\n\n    msg.sender     = obj.at(\"sender\").get<std::string>();\n    msg.sender_key = obj.at(\"content\").at(\"sender_key\").get<std::string>();\n    msg.ciphertext = obj.at(\"content\")\n                       .at(\"ciphertext\")\n                       .get<std::map<std::string, mtx::events::msg::OlmCipherContent>>();\n}\n\nmtx::crypto::OlmClient *\nclient()\n{\n    return client_.get();\n}\n\nstatic void\nhandle_secret_request(const mtx::events::DeviceEvent<mtx::events::msg::SecretRequest> *e,\n                      const std::string &sender)\n{\n    using namespace mtx::events;\n\n    if (e->content.action != mtx::events::msg::RequestAction::Request)\n        return;\n\n    auto local_user = http::client()->user_id();\n\n    if (sender != local_user.to_string())\n        return;\n\n    auto verificationStatus = cache::verificationStatus(local_user.to_string());\n\n    if (!verificationStatus)\n        return;\n\n    auto deviceKeys = cache::userKeys(local_user.to_string());\n    if (!deviceKeys)\n        return;\n\n    if (std::find(verificationStatus->verified_devices.begin(),\n                  verificationStatus->verified_devices.end(),\n                  e->content.requesting_device_id) == verificationStatus->verified_devices.end())\n        return;\n\n    // this is a verified device\n    mtx::events::DeviceEvent<mtx::events::msg::SecretSend> secretSend;\n    secretSend.type               = EventType::SecretSend;\n    secretSend.content.request_id = e->content.request_id;\n\n    auto secret = cache::client()->secret(e->content.name);\n    if (!secret)\n        return;\n    secretSend.content.secret = secret.value();\n\n    send_encrypted_to_device_messages(\n      {{local_user.to_string(), {{e->content.requesting_device_id}}}}, secretSend);\n\n    nhlog::net()->info(\"Sent secret '{}' to ({},{})\",\n                       e->content.name,\n                       local_user.to_string(),\n                       e->content.requesting_device_id);\n}\n\nvoid\nhandle_to_device_messages(const std::vector<mtx::events::collections::DeviceEvents> &msgs)\n{\n    if (msgs.empty())\n        return;\n    nhlog::crypto()->info(\"received {} to_device messages\", msgs.size());\n    nlohmann::json j_msg;\n\n    for (const auto &msg : msgs) {\n        j_msg = std::visit([](auto &e) { return nlohmann::json(e); }, std::move(msg));\n        if (j_msg.count(\"type\") == 0) {\n            nhlog::crypto()->warn(\"received message with no type field: {}\", j_msg.dump(2));\n            continue;\n        }\n\n        std::string msg_type = j_msg.at(\"type\").get<std::string>();\n\n        if (msg_type == to_string(mtx::events::EventType::RoomEncrypted)) {\n            try {\n                olm::OlmMessage olm_msg = j_msg.get<olm::OlmMessage>();\n                cache::client()->query_keys(\n                  olm_msg.sender, [olm_msg](const UserKeyCache &userKeys, mtx::http::RequestErr e) {\n                      if (e) {\n                          nhlog::crypto()->error(\"Failed to query user keys, dropping olm \"\n                                                 \"message\");\n                          return;\n                      }\n                      handle_olm_message(std::move(olm_msg), userKeys);\n                  });\n            } catch (const nlohmann::json::exception &e) {\n                nhlog::crypto()->warn(\n                  \"parsing error for olm message: {} {}\", e.what(), j_msg.dump(2));\n            } catch (const std::invalid_argument &e) {\n                nhlog::crypto()->warn(\n                  \"validation error for olm message: {} {}\", e.what(), j_msg.dump(2));\n            }\n\n        } else if (msg_type == to_string(mtx::events::EventType::RoomKeyRequest)) {\n            nhlog::crypto()->warn(\"handling key request event: {}\", j_msg.dump(2));\n            try {\n                mtx::events::DeviceEvent<mtx::events::msg::KeyRequest> req =\n                  j_msg.get<mtx::events::DeviceEvent<mtx::events::msg::KeyRequest>>();\n                if (req.content.action == mtx::events::msg::RequestAction::Request)\n                    handle_key_request_message(req);\n                else\n                    nhlog::crypto()->warn(\"ignore key request (unhandled action): {}\",\n                                          req.content.request_id);\n            } catch (const nlohmann::json::exception &e) {\n                nhlog::crypto()->warn(\n                  \"parsing error for key_request message: {} {}\", e.what(), j_msg.dump(2));\n            }\n        } else if (msg_type == to_string(mtx::events::EventType::KeyVerificationAccept)) {\n            auto message =\n              std::get<mtx::events::DeviceEvent<mtx::events::msg::KeyVerificationAccept>>(msg);\n            ChatPage::instance()->receivedDeviceVerificationAccept(message.content);\n        } else if (msg_type == to_string(mtx::events::EventType::KeyVerificationRequest)) {\n            auto message =\n              std::get<mtx::events::DeviceEvent<mtx::events::msg::KeyVerificationRequest>>(msg);\n            ChatPage::instance()->receivedDeviceVerificationRequest(message.content,\n                                                                    message.sender);\n        } else if (msg_type == to_string(mtx::events::EventType::KeyVerificationCancel)) {\n            auto message =\n              std::get<mtx::events::DeviceEvent<mtx::events::msg::KeyVerificationCancel>>(msg);\n            ChatPage::instance()->receivedDeviceVerificationCancel(message.content);\n        } else if (msg_type == to_string(mtx::events::EventType::KeyVerificationKey)) {\n            auto message =\n              std::get<mtx::events::DeviceEvent<mtx::events::msg::KeyVerificationKey>>(msg);\n            ChatPage::instance()->receivedDeviceVerificationKey(message.content);\n        } else if (msg_type == to_string(mtx::events::EventType::KeyVerificationMac)) {\n            auto message =\n              std::get<mtx::events::DeviceEvent<mtx::events::msg::KeyVerificationMac>>(msg);\n            ChatPage::instance()->receivedDeviceVerificationMac(message.content);\n        } else if (msg_type == to_string(mtx::events::EventType::KeyVerificationStart)) {\n            auto message =\n              std::get<mtx::events::DeviceEvent<mtx::events::msg::KeyVerificationStart>>(msg);\n            ChatPage::instance()->receivedDeviceVerificationStart(message.content, message.sender);\n        } else if (msg_type == to_string(mtx::events::EventType::KeyVerificationReady)) {\n            auto message =\n              std::get<mtx::events::DeviceEvent<mtx::events::msg::KeyVerificationReady>>(msg);\n            ChatPage::instance()->receivedDeviceVerificationReady(message.content);\n        } else if (msg_type == to_string(mtx::events::EventType::KeyVerificationDone)) {\n            auto message =\n              std::get<mtx::events::DeviceEvent<mtx::events::msg::KeyVerificationDone>>(msg);\n            ChatPage::instance()->receivedDeviceVerificationDone(message.content);\n        } else if (auto e =\n                     std::get_if<mtx::events::DeviceEvent<mtx::events::msg::SecretRequest>>(&msg)) {\n            handle_secret_request(e, e->sender);\n        } else {\n            nhlog::crypto()->warn(\"unhandled event: {}\", j_msg.dump(2));\n        }\n    }\n}\n\nvoid\nhandle_olm_message(const OlmMessage &msg, const UserKeyCache &otherUserDeviceKeys)\n{\n    nhlog::crypto()->info(\"sender    : {}\", msg.sender);\n    nhlog::crypto()->info(\"sender_key: {}\", msg.sender_key);\n\n    if (msg.sender_key == olm::client()->identity_keys().ed25519) {\n        nhlog::crypto()->warn(\"Ignoring olm message from ourselves!\");\n        return;\n    }\n\n    const auto my_key = olm::client()->identity_keys().curve25519;\n\n    bool failed_decryption = false;\n\n    for (const auto &cipher : msg.ciphertext) {\n        // We skip messages not meant for the current device.\n        if (cipher.first != my_key) {\n            nhlog::crypto()->debug(\n              \"Skipping message for {} since we are {}.\", cipher.first, my_key);\n            continue;\n        }\n\n        const auto type = cipher.second.type;\n        nhlog::crypto()->info(\"type: {}\", type == 0 ? \"OLM_PRE_KEY\" : \"OLM_MESSAGE\");\n\n        auto payload = try_olm_decryption(msg.sender_key, cipher.second);\n\n        if (payload.is_null()) {\n            // Check for PRE_KEY message\n            if (cipher.second.type == 0) {\n                payload = handle_pre_key_olm_message(msg.sender, msg.sender_key, cipher.second);\n            } else {\n                nhlog::crypto()->error(\"Undecryptable olm message!\");\n                failed_decryption = true;\n                continue;\n            }\n        }\n\n        if (!payload.is_null()) {\n            mtx::events::collections::DeviceEvents device_event;\n\n            // Other properties are included in order to prevent an attacker from\n            // publishing someone else's curve25519 keys as their own and subsequently\n            // claiming to have sent messages which they didn't. sender must correspond\n            // to the user who sent the event, recipient to the local user, and\n            // recipient_keys to the local ed25519 key.\n            std::string receiver_ed25519 = payload[\"recipient_keys\"][\"ed25519\"].get<std::string>();\n            if (receiver_ed25519.empty() ||\n                receiver_ed25519 != olm::client()->identity_keys().ed25519) {\n                nhlog::crypto()->warn(\"Decrypted event doesn't include our ed25519: {}\",\n                                      payload.dump());\n                return;\n            }\n            std::string receiver = payload[\"recipient\"].get<std::string>();\n            if (receiver.empty() || receiver != http::client()->user_id().to_string()) {\n                nhlog::crypto()->warn(\"Decrypted event doesn't include our user_id: {}\",\n                                      payload.dump());\n                return;\n            }\n\n            // Clients must confirm that the sender_key and the ed25519 field value\n            // under the keys property match the keys returned by /keys/query for the\n            // given user, and must also verify the signature of the payload. Without\n            // this check, a client cannot be sure that the sender device owns the\n            // private part of the ed25519 key it claims to have in the Olm payload.\n            // This is crucial when the ed25519 key corresponds to a verified device.\n            std::string sender_ed25519 = payload[\"keys\"][\"ed25519\"].get<std::string>();\n            if (sender_ed25519.empty()) {\n                nhlog::crypto()->warn(\"Decrypted event doesn't include sender ed25519: {}\",\n                                      payload.dump());\n                return;\n            }\n\n            bool from_their_device = false;\n            for (const auto &[device_id, key] : otherUserDeviceKeys.device_keys) {\n                auto c_key = key.keys.find(\"curve25519:\" + device_id);\n                auto e_key = key.keys.find(\"ed25519:\" + device_id);\n\n                if (c_key == key.keys.end() || e_key == key.keys.end()) {\n                    nhlog::crypto()->warn(\"Skipping device {} as we have no keys for it.\",\n                                          device_id);\n                } else if (c_key->second == msg.sender_key && e_key->second == sender_ed25519) {\n                    from_their_device = true;\n                    break;\n                }\n            }\n            if (!from_their_device) {\n                nhlog::crypto()->warn(\"Decrypted event isn't sent from a device \"\n                                      \"listed by that user! {}\",\n                                      payload.dump());\n                return;\n            }\n\n            {\n                std::string msg_type       = payload[\"type\"].get<std::string>();\n                nlohmann::json event_array = nlohmann::json::array();\n                event_array.push_back(payload);\n\n                std::vector<mtx::events::collections::DeviceEvents> temp_events;\n                mtx::responses::utils::parse_device_events(event_array, temp_events);\n                if (temp_events.empty()) {\n                    nhlog::crypto()->warn(\"Decrypted unknown event: {}\", payload.dump());\n                    return;\n                }\n                device_event = temp_events.at(0);\n            }\n\n            using namespace mtx::events;\n            if (auto e1 = std::get_if<DeviceEvent<msg::KeyVerificationAccept>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationAccept(e1->content);\n            } else if (auto e2 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationRequest>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationRequest(e2->content, e2->sender);\n            } else if (auto e3 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationCancel>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationCancel(e3->content);\n            } else if (auto e4 = std::get_if<DeviceEvent<msg::KeyVerificationKey>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationKey(e4->content);\n            } else if (auto e5 = std::get_if<DeviceEvent<msg::KeyVerificationMac>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationMac(e5->content);\n            } else if (auto e6 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationStart>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationStart(e6->content, e6->sender);\n            } else if (auto e7 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationReady>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationReady(e7->content);\n            } else if (auto e8 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationDone>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationDone(e8->content);\n            } else if (auto roomKey = std::get_if<DeviceEvent<msg::RoomKey>>(&device_event)) {\n                create_inbound_megolm_session(*roomKey, msg.sender_key, sender_ed25519);\n            } else if (auto forwardedRoomKey =\n                         std::get_if<DeviceEvent<msg::ForwardedRoomKey>>(&device_event)) {\n                forwardedRoomKey->content.forwarding_curve25519_key_chain.push_back(msg.sender_key);\n                import_inbound_megolm_session(*forwardedRoomKey);\n            } else if (auto e = std::get_if<DeviceEvent<msg::SecretSend>>(&device_event)) {\n                auto local_user = http::client()->user_id();\n\n                if (msg.sender != local_user.to_string())\n                    return;\n\n                auto secret_name = request_id_to_secret_name.find(e->content.request_id);\n\n                if (secret_name != request_id_to_secret_name.end()) {\n                    nhlog::crypto()->info(\"Received secret: {}\", secret_name->second);\n\n                    mtx::events::msg::SecretRequest secretRequest{};\n                    secretRequest.action = mtx::events::msg::RequestAction::Cancellation;\n                    secretRequest.requesting_device_id = http::client()->device_id();\n                    secretRequest.request_id           = e->content.request_id;\n\n                    auto verificationStatus = cache::verificationStatus(local_user.to_string());\n\n                    if (!verificationStatus)\n                        return;\n\n                    auto deviceKeys = cache::userKeys(local_user.to_string());\n                    std::string sender_device_id;\n                    if (deviceKeys) {\n                        for (auto &[dev, key] : deviceKeys->device_keys) {\n                            if (key.keys[\"curve25519:\" + dev] == msg.sender_key) {\n                                sender_device_id = dev;\n                                break;\n                            }\n                        }\n                    }\n\n                    std::map<mtx::identifiers::User,\n                             std::map<std::string, mtx::events::msg::SecretRequest>>\n                      body;\n\n                    for (const auto &dev : verificationStatus->verified_devices) {\n                        if (dev != secretRequest.requesting_device_id && dev != sender_device_id)\n                            body[local_user][dev] = secretRequest;\n                    }\n\n                    http::client()->send_to_device<mtx::events::msg::SecretRequest>(\n                      http::client()->generate_txn_id(),\n                      body,\n                      [name = secret_name->second](mtx::http::RequestErr err) {\n                          if (err) {\n                              nhlog::net()->error(\"Failed to send request cancellation \"\n                                                  \"for secrect \"\n                                                  \"'{}'\",\n                                                  name);\n                          }\n                      });\n\n                    nhlog::crypto()->info(\"Storing secret {}\", secret_name->second);\n                    cache::client()->storeSecret(secret_name->second, e->content.secret);\n\n                    request_id_to_secret_name.erase(secret_name);\n                }\n\n            } else if (auto sec_req = std::get_if<DeviceEvent<msg::SecretRequest>>(&device_event)) {\n                handle_secret_request(sec_req, msg.sender);\n            }\n\n            return;\n        } else {\n            failed_decryption = true;\n        }\n    }\n\n    if (failed_decryption) {\n        try {\n            std::map<std::string, std::vector<std::string>> targets;\n            for (const auto &[device_id, key] : otherUserDeviceKeys.device_keys) {\n                if (key.keys.at(\"curve25519:\" + device_id) == msg.sender_key)\n                    targets[msg.sender].push_back(device_id);\n            }\n\n            send_encrypted_to_device_messages(\n              targets, mtx::events::DeviceEvent<mtx::events::msg::Dummy>{}, true);\n            nhlog::crypto()->info(\n              \"Recovering from broken olm channel with {}:{}\", msg.sender, msg.sender_key);\n        } catch (std::exception &e) {\n            nhlog::crypto()->error(\"Failed to recover from broken olm sessions: {}\", e.what());\n        }\n    }\n}\n\nnlohmann::json\nhandle_pre_key_olm_message(const std::string &sender,\n                           const std::string &sender_key,\n                           const mtx::events::msg::OlmCipherContent &content)\n{\n    nhlog::crypto()->info(\"opening olm session with {}\", sender);\n\n    mtx::crypto::OlmSessionPtr inbound_session = nullptr;\n    try {\n        inbound_session = olm::client()->create_inbound_session_from(sender_key, content.body);\n\n        // We also remove the one time key used to establish that\n        // session so we'll have to update our copy of the account object.\n        cache::saveOlmAccount(olm::client()->save(cache::client()->pickleSecret()));\n    } catch (const mtx::crypto::olm_exception &e) {\n        nhlog::crypto()->critical(\"failed to create inbound session with {}: {}\", sender, e.what());\n        return {};\n    }\n\n    if (!mtx::crypto::matches_inbound_session_from(\n          inbound_session.get(), sender_key, content.body)) {\n        nhlog::crypto()->warn(\"inbound olm session doesn't match sender's key ({})\", sender);\n        return {};\n    }\n\n    mtx::crypto::BinaryBuf output;\n    try {\n        output = olm::client()->decrypt_message(inbound_session.get(), content.type, content.body);\n    } catch (const mtx::crypto::olm_exception &e) {\n        nhlog::crypto()->critical(\"failed to decrypt olm message {}: {}\", content.body, e.what());\n        return {};\n    }\n\n    auto plaintext = nlohmann::json::parse(std::string((char *)output.data(), output.size()));\n    nhlog::crypto()->debug(\"decrypted message: \\n {}\", plaintext.dump(2));\n\n    try {\n        nhlog::crypto()->debug(\"New olm session: {}\",\n                               mtx::crypto::session_id(inbound_session.get()));\n        cache::saveOlmSession(\n          sender_key, std::move(inbound_session), QDateTime::currentMSecsSinceEpoch());\n    } catch (const lmdb::error &e) {\n        nhlog::db()->warn(\"failed to save inbound olm session from {}: {}\", sender, e.what());\n    }\n\n    return plaintext;\n}\n\nmtx::events::msg::Encrypted\nencrypt_group_message_with_session(mtx::crypto::OutboundGroupSessionPtr &session,\n                                   const std::string &device_id,\n                                   nlohmann::json body)\n{\n    using namespace mtx::events;\n\n    // relations shouldn't be encrypted...\n    mtx::common::Relations relations = mtx::common::parse_relations(body[\"content\"]);\n\n    auto payload = olm::client()->encrypt_group_message(session.get(), body.dump());\n\n    // Prepare the m.room.encrypted event.\n    msg::Encrypted data;\n    data.ciphertext = std::string((char *)payload.data(), payload.size());\n    data.sender_key = olm::client()->identity_keys().curve25519;\n    data.session_id = mtx::crypto::session_id(session.get());\n    data.device_id  = device_id;\n    data.algorithm  = MEGOLM_ALGO;\n    data.relations  = relations;\n\n    return data;\n}\n\nmtx::events::msg::Encrypted\nencrypt_group_message(const std::string &room_id, const std::string &device_id, nlohmann::json body)\n{\n    using namespace mtx::events;\n    using namespace mtx::identifiers;\n\n    auto own_user_id = http::client()->user_id().to_string();\n\n    auto members = cache::client()->getMembersWithKeys(\n      room_id, UserSettings::instance()->onlyShareKeysWithVerifiedUsers());\n\n    std::map<std::string, std::vector<std::string>> sendSessionTo;\n    mtx::crypto::OutboundGroupSessionPtr session = nullptr;\n    GroupSessionData group_session_data;\n\n    if (cache::outboundMegolmSessionExists(room_id)) {\n        auto res                = cache::getOutboundMegolmSession(room_id);\n        auto encryptionSettings = cache::client()->roomEncryptionSettings(room_id);\n        mtx::events::state::Encryption defaultSettings;\n\n        // rotate if we crossed the limits for this key\n        if (res.data.message_index <\n              encryptionSettings.value_or(defaultSettings).rotation_period_msgs &&\n            (QDateTime::currentMSecsSinceEpoch() - res.data.timestamp) <\n              encryptionSettings.value_or(defaultSettings).rotation_period_ms) {\n            auto member_it             = members.begin();\n            auto session_member_it     = res.data.currently.keys.begin();\n            auto session_member_it_end = res.data.currently.keys.end();\n\n            while (member_it != members.end() || session_member_it != session_member_it_end) {\n                if (member_it == members.end()) {\n                    // a member left, purge session!\n                    nhlog::crypto()->debug(\"Rotating megolm session because of left member\");\n                    break;\n                }\n\n                if (session_member_it == session_member_it_end) {\n                    // share with all remaining members\n                    while (member_it != members.end()) {\n                        sendSessionTo[member_it->first] = {};\n\n                        if (member_it->second)\n                            for (const auto &dev : member_it->second->device_keys)\n                                if (member_it->first != own_user_id || dev.first != device_id)\n                                    sendSessionTo[member_it->first].push_back(dev.first);\n\n                        ++member_it;\n                    }\n\n                    session = std::move(res.session);\n                    break;\n                }\n\n                if (member_it->first > session_member_it->first) {\n                    // a member left, purge session\n                    nhlog::crypto()->debug(\"Rotating megolm session because of left member\");\n                    break;\n                } else if (member_it->first < session_member_it->first) {\n                    // new member, send them the session at this index\n                    sendSessionTo[member_it->first] = {};\n\n                    if (member_it->second) {\n                        for (const auto &dev : member_it->second->device_keys)\n                            if (member_it->first != own_user_id || dev.first != device_id)\n                                sendSessionTo[member_it->first].push_back(dev.first);\n                    }\n\n                    ++member_it;\n                } else {\n                    // compare devices\n                    bool device_removed = false;\n                    for (const auto &dev : session_member_it->second.deviceids) {\n                        if (!member_it->second ||\n                            !member_it->second->device_keys.count(dev.first)) {\n                            device_removed = true;\n                            break;\n                        }\n                    }\n\n                    if (device_removed) {\n                        // device removed, rotate session!\n                        nhlog::crypto()->debug(\"Rotating megolm session because of removed \"\n                                               \"device of {}\",\n                                               member_it->first);\n                        break;\n                    }\n\n                    // check for new devices to share with\n                    if (member_it->second)\n                        for (const auto &dev : member_it->second->device_keys)\n                            if (!session_member_it->second.deviceids.count(dev.first) &&\n                                (member_it->first != own_user_id || dev.first != device_id))\n                                sendSessionTo[member_it->first].push_back(dev.first);\n\n                    ++member_it;\n                    ++session_member_it;\n                    if (member_it == members.end() && session_member_it == session_member_it_end) {\n                        // all devices match or are newly added\n                        session = std::move(res.session);\n                    }\n                }\n            }\n        }\n\n        group_session_data = std::move(res.data);\n    }\n\n    if (!session) {\n        nhlog::ui()->debug(\"creating new outbound megolm session\");\n\n        // Create a new outbound megolm session.\n        session                = olm::client()->init_outbound_group_session();\n        const auto session_id  = mtx::crypto::session_id(session.get());\n        const auto session_key = mtx::crypto::session_key(session.get());\n\n        // Saving the new megolm session.\n        GroupSessionData session_data{};\n        session_data.message_index              = 0;\n        session_data.timestamp                  = QDateTime::currentMSecsSinceEpoch();\n        session_data.sender_claimed_ed25519_key = olm::client()->identity_keys().ed25519;\n        session_data.sender_key                 = olm::client()->identity_keys().curve25519;\n\n        sendSessionTo.clear();\n\n        for (const auto &[user, devices] : members) {\n            sendSessionTo[user]               = {};\n            session_data.currently.keys[user] = {};\n            if (devices) {\n                for (const auto &[device_id_, key] : devices->device_keys) {\n                    (void)key;\n                    if (device_id != device_id_ || user != own_user_id) {\n                        sendSessionTo[user].push_back(device_id_);\n                        session_data.currently.keys[user].deviceids[device_id_] = 0;\n                    }\n                }\n            }\n        }\n\n        {\n            MegolmSessionIndex index;\n            index.room_id       = room_id;\n            index.session_id    = session_id;\n            auto megolm_session = olm::client()->init_inbound_group_session(session_key);\n            backup_session_key(index, session_data, megolm_session);\n            cache::saveInboundMegolmSession(index, std::move(megolm_session), session_data);\n        }\n\n        cache::saveOutboundMegolmSession(room_id, session_data, session);\n        group_session_data = std::move(session_data);\n    }\n\n    mtx::events::DeviceEvent<mtx::events::msg::RoomKey> megolm_payload{};\n    megolm_payload.content.algorithm   = MEGOLM_ALGO;\n    megolm_payload.content.room_id     = room_id;\n    megolm_payload.content.session_id  = mtx::crypto::session_id(session.get());\n    megolm_payload.content.session_key = mtx::crypto::session_key(session.get());\n    megolm_payload.type                = mtx::events::EventType::RoomKey;\n\n    if (!sendSessionTo.empty())\n        olm::send_encrypted_to_device_messages(sendSessionTo, megolm_payload);\n\n    auto data = encrypt_group_message_with_session(session, device_id, body);\n\n    group_session_data.message_index = olm_outbound_group_session_message_index(session.get());\n    nhlog::crypto()->debug(\"next message_index {}\", group_session_data.message_index);\n\n    // update current set of members for the session with the new members and that message_index\n    for (const auto &[user, devices] : sendSessionTo) {\n        if (!group_session_data.currently.keys.count(user))\n            group_session_data.currently.keys[user] = {};\n\n        for (const auto &device_id_ : devices) {\n            if (!group_session_data.currently.keys[user].deviceids.count(device_id_))\n                group_session_data.currently.keys[user].deviceids[device_id_] =\n                  group_session_data.message_index;\n        }\n    }\n\n    // We need to re-pickle the session after we send a message to save the new message_index.\n    cache::updateOutboundMegolmSession(room_id, group_session_data, session);\n\n    return data;\n}\n\nnlohmann::json\ntry_olm_decryption(const std::string &sender_key, const mtx::events::msg::OlmCipherContent &msg)\n{\n    auto session_ids = cache::getOlmSessions(sender_key);\n\n    nhlog::crypto()->info(\"attempt to decrypt message with {} known session_ids\",\n                          session_ids.size());\n\n    for (const auto &id : session_ids) {\n        auto session = cache::getOlmSession(sender_key, id);\n\n        if (!session) {\n            nhlog::crypto()->warn(\"Unknown olm session: {}:{}\", sender_key, id);\n            continue;\n        }\n\n        mtx::crypto::BinaryBuf text;\n\n        try {\n            text = olm::client()->decrypt_message(session->get(), msg.type, msg.body);\n            nhlog::crypto()->debug(\"Updated olm session: {}\",\n                                   mtx::crypto::session_id(session->get()));\n            cache::saveOlmSession(\n              id, std::move(session.value()), QDateTime::currentMSecsSinceEpoch());\n        } catch (const mtx::crypto::olm_exception &e) {\n            nhlog::crypto()->debug(\"failed to decrypt olm message ({}, {}) with {}: {}\",\n                                   msg.type,\n                                   sender_key,\n                                   id,\n                                   e.what());\n            continue;\n        } catch (const lmdb::error &e) {\n            nhlog::crypto()->critical(\"failed to save session: {}\", e.what());\n            return {};\n        }\n\n        try {\n            return nlohmann::json::parse(std::string_view((char *)text.data(), text.size()));\n        } catch (const nlohmann::json::exception &e) {\n            nhlog::crypto()->critical(\"failed to parse the decrypted session msg: {} {}\",\n                                      e.what(),\n                                      std::string_view((char *)text.data(), text.size()));\n        }\n    }\n\n    return {};\n}\n\nvoid\ncreate_inbound_megolm_session(const mtx::events::DeviceEvent<mtx::events::msg::RoomKey> &roomKey,\n                              const std::string &sender_key,\n                              const std::string &sender_ed25519)\n{\n    MegolmSessionIndex index;\n    index.room_id    = roomKey.content.room_id;\n    index.session_id = roomKey.content.session_id;\n\n    try {\n        GroupSessionData data{};\n        data.forwarding_curve25519_key_chain = {sender_key};\n        data.sender_claimed_ed25519_key      = sender_ed25519;\n        data.sender_key                      = sender_key;\n\n        auto megolm_session =\n          olm::client()->init_inbound_group_session(roomKey.content.session_key);\n        backup_session_key(index, data, megolm_session);\n        cache::saveInboundMegolmSession(index, std::move(megolm_session), data);\n    } catch (const lmdb::error &e) {\n        nhlog::crypto()->critical(\"failed to save inbound megolm session: {}\", e.what());\n        return;\n    } catch (const mtx::crypto::olm_exception &e) {\n        nhlog::crypto()->critical(\"failed to create inbound megolm session: {}\", e.what());\n        return;\n    }\n\n    nhlog::crypto()->info(\n      \"established inbound megolm session ({}, {})\", roomKey.content.room_id, roomKey.sender);\n\n    ChatPage::instance()->receivedSessionKey(index.room_id, index.session_id);\n}\n\nvoid\nimport_inbound_megolm_session(\n  const mtx::events::DeviceEvent<mtx::events::msg::ForwardedRoomKey> &roomKey)\n{\n    MegolmSessionIndex index;\n    index.room_id    = roomKey.content.room_id;\n    index.session_id = roomKey.content.session_id;\n\n    try {\n        auto megolm_session =\n          olm::client()->import_inbound_group_session(roomKey.content.session_key);\n\n        GroupSessionData data{};\n        data.forwarding_curve25519_key_chain = roomKey.content.forwarding_curve25519_key_chain;\n        data.sender_claimed_ed25519_key      = roomKey.content.sender_claimed_ed25519_key;\n        data.sender_key                      = roomKey.content.sender_key;\n        // may have come from online key backup, so we can't trust it...\n        data.trusted = false;\n        // if we got it forwarded from the sender, assume it is trusted. They may still have\n        // used key backup, but it is unlikely.\n        if (roomKey.content.forwarding_curve25519_key_chain.size() == 1 &&\n            roomKey.content.forwarding_curve25519_key_chain.back() == roomKey.content.sender_key) {\n            data.trusted = true;\n        }\n\n        backup_session_key(index, data, megolm_session);\n        cache::saveInboundMegolmSession(index, std::move(megolm_session), data);\n    } catch (const lmdb::error &e) {\n        nhlog::crypto()->critical(\"failed to save inbound megolm session: {}\", e.what());\n        return;\n    } catch (const mtx::crypto::olm_exception &e) {\n        nhlog::crypto()->critical(\"failed to import inbound megolm session: {}\", e.what());\n        return;\n    }\n\n    nhlog::crypto()->info(\n      \"established inbound megolm session ({}, {})\", roomKey.content.room_id, roomKey.sender);\n\n    ChatPage::instance()->receivedSessionKey(index.room_id, index.session_id);\n}\n\nvoid\nbackup_session_key(const MegolmSessionIndex &idx,\n                   const GroupSessionData &data,\n                   mtx::crypto::InboundGroupSessionPtr &session)\n{\n    try {\n        if (!UserSettings::instance()->useOnlineKeyBackup()) {\n            // Online key backup disabled\n            return;\n        }\n\n        auto backupVersion = cache::client()->backupVersion();\n        if (!backupVersion) {\n            // no trusted OKB\n            return;\n        }\n\n        using namespace mtx::crypto;\n\n        auto decryptedSecret = cache::secret(mtx::secret_storage::secrets::megolm_backup_v1);\n        if (!decryptedSecret) {\n            // no backup key available\n            return;\n        }\n        auto sessionDecryptionKey = to_binary_buf(base642bin(*decryptedSecret));\n\n        auto public_key = mtx::crypto::CURVE25519_public_key_from_private(sessionDecryptionKey);\n\n        mtx::responses::backup::SessionData sessionData;\n        sessionData.algorithm                       = mtx::crypto::MEGOLM_ALGO;\n        sessionData.forwarding_curve25519_key_chain = data.forwarding_curve25519_key_chain;\n        sessionData.sender_claimed_keys[\"ed25519\"]  = data.sender_claimed_ed25519_key;\n        sessionData.sender_key                      = data.sender_key;\n        sessionData.session_key = mtx::crypto::export_session(session.get(), -1);\n\n        auto encrypt_session = mtx::crypto::encrypt_session(sessionData, public_key);\n\n        mtx::responses::backup::SessionBackup bk;\n        bk.first_message_index = olm_inbound_group_session_first_known_index(session.get());\n        bk.forwarded_count     = data.forwarding_curve25519_key_chain.size();\n        bk.is_verified         = false;\n        bk.session_data        = std::move(encrypt_session);\n\n        http::client()->put_room_keys(\n          backupVersion->version,\n          idx.room_id,\n          idx.session_id,\n          bk,\n          [idx](mtx::http::RequestErr err) {\n              if (err) {\n                  nhlog::net()->warn(\"failed to backup session key ({}:{}): {} ({})\",\n                                     idx.room_id,\n                                     idx.session_id,\n                                     err->matrix_error.error,\n                                     static_cast<int>(err->status_code));\n              } else {\n                  nhlog::crypto()->debug(\n                    \"backed up session key ({}:{})\", idx.room_id, idx.session_id);\n              }\n          });\n    } catch (std::exception &e) {\n        nhlog::net()->warn(\"failed to backup session key: {}\", e.what());\n    }\n}\n\nvoid\nmark_keys_as_published()\n{\n    olm::client()->mark_keys_as_published();\n    cache::saveOlmAccount(olm::client()->save(cache::client()->pickleSecret()));\n}\n\nvoid\ndownload_full_keybackup()\n{\n    if (!UserSettings::instance()->useOnlineKeyBackup()) {\n        // Online key backup disabled\n        return;\n    }\n\n    auto backupVersion = cache::client()->backupVersion();\n    if (!backupVersion) {\n        // no trusted OKB\n        return;\n    }\n\n    using namespace mtx::crypto;\n\n    auto decryptedSecret = cache::secret(mtx::secret_storage::secrets::megolm_backup_v1);\n    if (!decryptedSecret) {\n        // no backup key available\n        return;\n    }\n    auto sessionDecryptionKey = to_binary_buf(base642bin(*decryptedSecret));\n\n    http::client()->room_keys(\n      backupVersion->version,\n      [sessionDecryptionKey](const mtx::responses::backup::KeysBackup &bk,\n                             mtx::http::RequestErr err) {\n          if (err) {\n              if (err->status_code != 404)\n                  nhlog::crypto()->error(\"Failed to dowload backup: {} - {}\",\n                                         mtx::errors::to_string(err->matrix_error.errcode),\n                                         err->matrix_error.error);\n              return;\n          }\n\n          mtx::crypto::ExportedSessionKeys allKeys;\n          try {\n              for (const auto &[room, roomKey] : bk.rooms) {\n                  for (const auto &[session_id, encSession] : roomKey.sessions) {\n                      auto session = decrypt_session(encSession.session_data, sessionDecryptionKey);\n\n                      if (session.algorithm != mtx::crypto::MEGOLM_ALGO)\n                          // don't know this algorithm\n                          return;\n\n                      ExportedSession sess{};\n                      sess.session_id = session_id;\n                      sess.room_id    = room;\n                      sess.algorithm  = mtx::crypto::MEGOLM_ALGO;\n                      sess.forwarding_curve25519_key_chain =\n                        std::move(session.forwarding_curve25519_key_chain);\n                      sess.sender_claimed_keys = std::move(session.sender_claimed_keys);\n                      sess.sender_key          = std::move(session.sender_key);\n                      sess.session_key         = std::move(session.session_key);\n                      allKeys.sessions.push_back(std::move(sess));\n                  }\n              }\n\n              // call on UI thread\n              QTimer::singleShot(0, ChatPage::instance(), [keys = std::move(allKeys)] {\n                  cache::importSessionKeys(keys);\n              });\n          } catch (const lmdb::error &e) {\n              nhlog::crypto()->critical(\"failed to save inbound megolm session: {}\", e.what());\n          }\n      });\n}\nvoid\nlookup_keybackup(const std::string room, const std::string session_id)\n{\n    if (!UserSettings::instance()->useOnlineKeyBackup()) {\n        // Online key backup disabled\n        return;\n    }\n\n    auto backupVersion = cache::client()->backupVersion();\n    if (!backupVersion) {\n        // no trusted OKB\n        return;\n    }\n\n    using namespace mtx::crypto;\n\n    auto decryptedSecret = cache::secret(mtx::secret_storage::secrets::megolm_backup_v1);\n    if (!decryptedSecret) {\n        // no backup key available\n        return;\n    }\n    auto sessionDecryptionKey = to_binary_buf(base642bin(*decryptedSecret));\n\n    http::client()->room_keys(\n      backupVersion->version,\n      room,\n      session_id,\n      [room, session_id, sessionDecryptionKey](const mtx::responses::backup::SessionBackup &bk,\n                                               mtx::http::RequestErr err) {\n          if (err) {\n              if (err->status_code != 404)\n                  nhlog::crypto()->error(\"Failed to dowload key {}:{}: {} - {}\",\n                                         room,\n                                         session_id,\n                                         mtx::errors::to_string(err->matrix_error.errcode),\n                                         err->matrix_error.error);\n              return;\n          }\n          try {\n              auto session = decrypt_session(bk.session_data, sessionDecryptionKey);\n\n              if (session.algorithm != mtx::crypto::MEGOLM_ALGO)\n                  // don't know this algorithm\n                  return;\n\n              MegolmSessionIndex index;\n              index.room_id    = room;\n              index.session_id = session_id;\n\n              GroupSessionData data{};\n              data.forwarding_curve25519_key_chain = session.forwarding_curve25519_key_chain;\n              data.sender_claimed_ed25519_key      = session.sender_claimed_keys[\"ed25519\"];\n              data.sender_key                      = session.sender_key;\n              // online key backup can't be trusted, because anyone can upload to it.\n              data.trusted = false;\n\n              auto megolm_session =\n                olm::client()->import_inbound_group_session(session.session_key);\n\n              if (!cache::inboundMegolmSessionExists(index) ||\n                  olm_inbound_group_session_first_known_index(megolm_session.get()) <\n                    olm_inbound_group_session_first_known_index(\n                      cache::getInboundMegolmSession(index).get())) {\n                  cache::saveInboundMegolmSession(index, std::move(megolm_session), data);\n\n                  nhlog::crypto()->info(\"imported inbound megolm session \"\n                                        \"from key backup ({}, {})\",\n                                        room,\n                                        session_id);\n\n                  // call on UI thread\n                  QTimer::singleShot(0, ChatPage::instance(), [index] {\n                      ChatPage::instance()->receivedSessionKey(index.room_id, index.session_id);\n                  });\n              }\n          } catch (const lmdb::error &e) {\n              nhlog::crypto()->critical(\"failed to save inbound megolm session: {}\", e.what());\n              return;\n          } catch (const mtx::crypto::olm_exception &e) {\n              nhlog::crypto()->critical(\"failed to import inbound megolm session: {}\", e.what());\n              return;\n          }\n      });\n}\n\nvoid\nsend_key_request_for(mtx::events::EncryptedEvent<mtx::events::msg::Encrypted> e,\n                     const std::string &request_id,\n                     bool cancel)\n{\n    using namespace mtx::events;\n\n    nhlog::crypto()->debug(\"sending key request: sender_key {}, session_id {}\",\n                           e.content.sender_key,\n                           e.content.session_id);\n\n    mtx::events::msg::KeyRequest request;\n    request.action = cancel ? mtx::events::msg::RequestAction::Cancellation\n                            : mtx::events::msg::RequestAction::Request;\n\n    request.algorithm            = MEGOLM_ALGO;\n    request.room_id              = e.room_id;\n    request.sender_key           = e.content.sender_key;\n    request.session_id           = e.content.session_id;\n    request.request_id           = request_id;\n    request.requesting_device_id = http::client()->device_id();\n\n    nhlog::crypto()->debug(\"m.room_key_request: {}\", nlohmann::json(request).dump(2));\n\n    std::map<mtx::identifiers::User, std::map<std::string, decltype(request)>> body;\n    body[mtx::identifiers::parse<mtx::identifiers::User>(e.sender)][\"*\"] = request;\n    body[http::client()->user_id()][\"*\"]                                 = request;\n\n    http::client()->send_to_device(\n      http::client()->generate_txn_id(), body, [e](mtx::http::RequestErr err) {\n          if (err) {\n              nhlog::net()->warn(\"failed to send \"\n                                 \"send_to_device \"\n                                 \"message: {}\",\n                                 err->matrix_error.error);\n          }\n\n          nhlog::net()->info(\n            \"m.room_key_request sent to {}:{} and your own devices\", e.sender, e.content.device_id);\n      });\n\n    // http::client()->room_keys\n}\n\nvoid\nhandle_key_request_message(const mtx::events::DeviceEvent<mtx::events::msg::KeyRequest> &req)\n{\n    if (req.content.algorithm != MEGOLM_ALGO) {\n        nhlog::crypto()->debug(\"ignoring key request {} with invalid algorithm: {}\",\n                               req.content.request_id,\n                               req.content.algorithm);\n        return;\n    }\n\n    // Check that the requested session_id and the one we have saved match.\n    MegolmSessionIndex index{};\n    index.room_id    = req.content.room_id;\n    index.session_id = req.content.session_id;\n\n    // Check if we have the keys for the requested session.\n    auto sessionData = cache::getMegolmSessionData(index);\n    if (!sessionData) {\n        nhlog::crypto()->warn(\"requested session not found in room: {}\", req.content.room_id);\n        return;\n    }\n\n    // Check if we were the sender of the session being requested (unless it is actually us\n    // requesting the session).\n    if (req.sender != http::client()->user_id().to_string() &&\n        sessionData->sender_key != olm::client()->identity_keys().curve25519) {\n        nhlog::crypto()->debug(\n          \"ignoring key request {} because we did not create the requested session: \"\n          \"\\nrequested({}) ours({})\",\n          req.content.request_id,\n          sessionData->sender_key,\n          olm::client()->identity_keys().curve25519);\n        return;\n    }\n\n    const auto session = cache::getInboundMegolmSession(index);\n    if (!session) {\n        nhlog::crypto()->warn(\"No session with id {} in db\", req.content.session_id);\n        return;\n    }\n\n    if (!cache::isRoomMember(req.sender, req.content.room_id)) {\n        nhlog::crypto()->warn(\"user {} that requested the session key is not member of the room {}\",\n                              req.sender,\n                              req.content.room_id);\n        return;\n    }\n\n    // check if device is verified\n    auto verificationStatus = cache::verificationStatus(req.sender);\n    bool verifiedDevice     = false;\n    if (verificationStatus &&\n        // Share keys, if the option to share with trusted users is enabled or with yourself\n        (ChatPage::instance()->userSettings()->shareKeysWithTrustedUsers() ||\n         req.sender == http::client()->user_id().to_string())) {\n        for (const auto &dev : verificationStatus->verified_devices) {\n            if (dev == req.content.requesting_device_id) {\n                verifiedDevice = true;\n                nhlog::crypto()->debug(\"Verified device: {}\", dev);\n                break;\n            }\n        }\n    }\n\n    bool shouldSeeKeys    = false;\n    uint64_t minimumIndex = -1;\n    if (sessionData->currently.keys.count(req.sender)) {\n        if (sessionData->currently.keys.at(req.sender)\n              .deviceids.count(req.content.requesting_device_id)) {\n            shouldSeeKeys = true;\n            minimumIndex  = sessionData->currently.keys.at(req.sender)\n                             .deviceids.at(req.content.requesting_device_id);\n        }\n    }\n\n    if (!verifiedDevice && !shouldSeeKeys) {\n        nhlog::crypto()->debug(\"ignoring key request for room {}\", req.content.room_id);\n        return;\n    }\n\n    if (verifiedDevice) {\n        // share the minimum index we have\n        minimumIndex = -1;\n    }\n\n    try {\n        auto session_key = mtx::crypto::export_session(session.get(), minimumIndex);\n\n        //\n        // Prepare the m.room_key event.\n        //\n        mtx::events::msg::ForwardedRoomKey forward_key{};\n        forward_key.algorithm   = MEGOLM_ALGO;\n        forward_key.room_id     = index.room_id;\n        forward_key.session_id  = index.session_id;\n        forward_key.session_key = session_key;\n        forward_key.sender_key  = sessionData->sender_key;\n\n        // TODO(Nico): Figure out if this is correct\n        forward_key.sender_claimed_ed25519_key      = sessionData->sender_claimed_ed25519_key;\n        forward_key.forwarding_curve25519_key_chain = sessionData->forwarding_curve25519_key_chain;\n\n        send_megolm_key_to_device(req.sender, req.content.requesting_device_id, forward_key);\n    } catch (std::exception &e) {\n        nhlog::crypto()->error(\"Failed to forward session key: {}\", e.what());\n    }\n}\n\nvoid\nsend_megolm_key_to_device(const std::string &user_id,\n                          const std::string &device_id,\n                          const mtx::events::msg::ForwardedRoomKey &payload)\n{\n    mtx::events::DeviceEvent<mtx::events::msg::ForwardedRoomKey> room_key;\n    room_key.content = payload;\n    room_key.type    = mtx::events::EventType::ForwardedRoomKey;\n\n    std::map<std::string, std::vector<std::string>> targets;\n    targets[user_id] = {device_id};\n    send_encrypted_to_device_messages(targets, room_key);\n    nhlog::crypto()->debug(\"Forwarded key to {}:{}\", user_id, device_id);\n}\n\nDecryptionResult\ndecryptEvent(const MegolmSessionIndex &index,\n             const mtx::events::EncryptedEvent<mtx::events::msg::Encrypted> &event,\n             bool dont_write_db)\n{\n    try {\n        if (!cache::client()->inboundMegolmSessionExists(index)) {\n            return {DecryptionErrorCode::MissingSession, std::nullopt, std::nullopt};\n        }\n    } catch (const lmdb::error &e) {\n        return {DecryptionErrorCode::DbError, e.what(), std::nullopt};\n    }\n\n    std::string msg_str;\n    try {\n        auto session = cache::client()->getInboundMegolmSession(index);\n        if (!session) {\n            return {DecryptionErrorCode::MissingSession, std::nullopt, std::nullopt};\n        }\n\n        auto sessionData =\n          cache::client()->getMegolmSessionData(index).value_or(GroupSessionData{});\n\n        auto res = olm::client()->decrypt_group_message(session.get(), event.content.ciphertext);\n        msg_str  = std::string((char *)res.data.data(), res.data.size());\n\n        if (!event.event_id.empty() && event.event_id[0] == '$') {\n            auto oldIdx = sessionData.indices.find(res.message_index);\n            if (oldIdx != sessionData.indices.end()) {\n                if (oldIdx->second != event.event_id)\n                    return {DecryptionErrorCode::ReplayAttack, std::nullopt, std::nullopt};\n            } else if (!dont_write_db) {\n                sessionData.indices[res.message_index] = event.event_id;\n                cache::client()->saveInboundMegolmSession(index, std::move(session), sessionData);\n            }\n        }\n    } catch (const lmdb::error &e) {\n        return {DecryptionErrorCode::DbError, e.what(), std::nullopt};\n    } catch (const mtx::crypto::olm_exception &e) {\n        if (e.error_code() == mtx::crypto::OlmErrorCode::UNKNOWN_MESSAGE_INDEX)\n            return {DecryptionErrorCode::MissingSessionIndex, e.what(), std::nullopt};\n        return {DecryptionErrorCode::DecryptionFailed, e.what(), std::nullopt};\n    }\n\n    try {\n        // Add missing fields for the event.\n        nlohmann::json body      = nlohmann::json::parse(msg_str);\n        body[\"event_id\"]         = event.event_id;\n        body[\"sender\"]           = event.sender;\n        body[\"origin_server_ts\"] = event.origin_server_ts;\n        body[\"unsigned\"]         = event.unsigned_data;\n\n        mtx::events::collections::TimelineEvent te;\n        from_json(body, te);\n\n        // relations are unencrypted in content...\n        mtx::accessors::set_relations(te.data, std::move(event.content.relations));\n\n        return {DecryptionErrorCode::NoError, std::nullopt, std::move(te.data)};\n    } catch (std::exception &e) {\n        return {DecryptionErrorCode::ParsingFailed, e.what(), std::nullopt};\n    }\n}\n\ncrypto::Trust\ncalculate_trust(const std::string &user_id, const MegolmSessionIndex &index)\n{\n    auto status              = cache::client()->verificationStatus(user_id);\n    auto megolmData          = cache::client()->getMegolmSessionData(index);\n    crypto::Trust trustlevel = crypto::Trust::Unverified;\n\n    if (megolmData && megolmData->trusted &&\n        status.verified_device_keys.count(megolmData->sender_key))\n        trustlevel = status.verified_device_keys.at(megolmData->sender_key);\n\n    return trustlevel;\n}\n\n//! Send encrypted to device messages, targets is a map from userid to device ids or {} for all\n//! devices\nvoid\nsend_encrypted_to_device_messages(const std::map<std::string, std::vector<std::string>> targets,\n                                  const mtx::events::collections::DeviceEvents &event,\n                                  bool force_new_session)\n{\n    static QMap<QPair<std::string, std::string>, qint64> rateLimit;\n\n    nlohmann::json ev_json = std::visit([](const auto &e) { return nlohmann::json(e); }, event);\n\n    std::map<std::string, std::vector<std::string>> keysToQuery;\n    mtx::requests::ClaimKeys claims;\n    std::map<mtx::identifiers::User, std::map<std::string, mtx::events::msg::OlmEncrypted>>\n      messages;\n    std::map<std::string, std::map<std::string, DevicePublicKeys>> pks;\n\n    auto our_curve = olm::client()->identity_keys().curve25519;\n\n    for (const auto &[user, devices] : targets) {\n        auto deviceKeys = cache::client()->userKeys(user);\n\n        // no keys for user, query them\n        if (!deviceKeys) {\n            keysToQuery[user] = devices;\n            continue;\n        }\n\n        auto deviceTargets = devices;\n        if (devices.empty()) {\n            deviceTargets.clear();\n            deviceTargets.reserve(deviceKeys->device_keys.size());\n            for (const auto &[device, keys] : deviceKeys->device_keys) {\n                (void)keys;\n                deviceTargets.push_back(device);\n            }\n        }\n\n        for (const auto &device : deviceTargets) {\n            if (!deviceKeys->device_keys.count(device)) {\n                keysToQuery[user] = {};\n                break;\n            }\n\n            auto d = deviceKeys->device_keys.at(device);\n\n            if (!d.keys.count(\"curve25519:\" + device) || !d.keys.count(\"ed25519:\" + device)) {\n                nhlog::crypto()->warn(\"Skipping device {} since it has no keys!\", device);\n                continue;\n            }\n\n            auto device_curve = d.keys.at(\"curve25519:\" + device);\n            if (device_curve == our_curve) {\n                nhlog::crypto()->warn(\"Skipping our own device, since sending \"\n                                      \"ourselves olm messages makes no sense.\");\n                continue;\n            }\n\n            auto session = cache::getLatestOlmSession(device_curve);\n            if (!session || force_new_session) {\n                auto currentTime = QDateTime::currentSecsSinceEpoch();\n                if (rateLimit.value(QPair(user, device)) + 60 * 60 * 10 < currentTime) {\n                    claims.one_time_keys[user][device] = mtx::crypto::SIGNED_CURVE25519;\n                    pks[user][device].ed25519          = d.keys.at(\"ed25519:\" + device);\n                    pks[user][device].curve25519       = d.keys.at(\"curve25519:\" + device);\n\n                    rateLimit.insert(QPair(user, device), currentTime);\n                } else {\n                    nhlog::crypto()->warn(\"Not creating new session with {}:{} \"\n                                          \"because of rate limit\",\n                                          user,\n                                          device);\n                }\n                continue;\n            }\n\n            messages[mtx::identifiers::parse<mtx::identifiers::User>(user)][device] =\n              olm::client()\n                ->create_olm_encrypted_content(session->get(),\n                                               ev_json,\n                                               UserId(user),\n                                               d.keys.at(\"ed25519:\" + device),\n                                               device_curve)\n                .get<mtx::events::msg::OlmEncrypted>();\n\n            try {\n                nhlog::crypto()->debug(\"Updated olm session: {}\",\n                                       mtx::crypto::session_id(session->get()));\n                cache::saveOlmSession(d.keys.at(\"curve25519:\" + device),\n                                      std::move(*session),\n                                      QDateTime::currentMSecsSinceEpoch());\n            } catch (const lmdb::error &e) {\n                nhlog::db()->critical(\"failed to save outbound olm session: {}\", e.what());\n            } catch (const mtx::crypto::olm_exception &e) {\n                nhlog::crypto()->critical(\"failed to pickle outbound olm session: {}\", e.what());\n            }\n        }\n    }\n\n    if (!messages.empty())\n        http::client()->send_to_device<mtx::events::msg::OlmEncrypted>(\n          http::client()->generate_txn_id(), messages, [](mtx::http::RequestErr err) {\n              if (err) {\n                  nhlog::net()->warn(\"failed to send \"\n                                     \"send_to_device \"\n                                     \"message: {}\",\n                                     err->matrix_error.error);\n              }\n          });\n\n    auto BindPks = [ev_json](decltype(pks) pks_temp) {\n        return [pks = pks_temp, ev_json](const mtx::responses::ClaimKeys &res,\n                                         mtx::http::RequestErr) {\n            std::map<mtx::identifiers::User, std::map<std::string, mtx::events::msg::OlmEncrypted>>\n              messages;\n            for (const auto &[user_id, retrieved_devices] : res.one_time_keys) {\n                nhlog::net()->debug(\"claimed keys for {}\", user_id);\n                if (retrieved_devices.size() == 0) {\n                    nhlog::net()->debug(\"no one-time keys found for user_id: {}\", user_id);\n                    continue;\n                }\n\n                for (const auto &rd : retrieved_devices) {\n                    const auto device_id = rd.first;\n\n                    nhlog::net()->debug(\"{} : \\n {}\", device_id, rd.second.dump(2));\n\n                    if (rd.second.empty() || !rd.second.begin()->contains(\"key\")) {\n                        nhlog::net()->warn(\"Skipping device {} as it has no key.\", device_id);\n                        continue;\n                    }\n\n                    auto otk = rd.second.begin()->at(\"key\").get<std::string>();\n\n                    auto sign_key = pks.at(user_id).at(device_id).ed25519;\n                    auto id_key   = pks.at(user_id).at(device_id).curve25519;\n\n                    // Verify signature\n                    {\n                        auto signedKey = *rd.second.begin();\n                        std::string signature =\n                          signedKey[\"signatures\"][user_id].value(\"ed25519:\" + device_id, \"\");\n\n                        if (signature.empty() || !mtx::crypto::ed25519_verify_signature(\n                                                   sign_key, signedKey, signature)) {\n                            nhlog::net()->warn(\"Skipping device {} as its one time key \"\n                                               \"has an invalid signature.\",\n                                               device_id);\n                            continue;\n                        }\n                    }\n\n                    auto session = olm::client()->create_outbound_session(id_key, otk);\n\n                    messages[mtx::identifiers::parse<mtx::identifiers::User>(user_id)][device_id] =\n                      olm::client()\n                        ->create_olm_encrypted_content(\n                          session.get(), ev_json, UserId(user_id), sign_key, id_key)\n                        .get<mtx::events::msg::OlmEncrypted>();\n\n                    try {\n                        nhlog::crypto()->debug(\"Updated olm session: {}\",\n                                               mtx::crypto::session_id(session.get()));\n                        cache::saveOlmSession(\n                          id_key, std::move(session), QDateTime::currentMSecsSinceEpoch());\n                    } catch (const lmdb::error &e) {\n                        nhlog::db()->critical(\"failed to save outbound olm session: {}\", e.what());\n                    } catch (const mtx::crypto::olm_exception &e) {\n                        nhlog::crypto()->critical(\"failed to pickle outbound olm session: {}\",\n                                                  e.what());\n                    }\n                }\n                nhlog::net()->info(\"send_to_device: {}\", user_id);\n            }\n\n            if (!messages.empty())\n                http::client()->send_to_device<mtx::events::msg::OlmEncrypted>(\n                  http::client()->generate_txn_id(), messages, [](mtx::http::RequestErr err) {\n                      if (err) {\n                          nhlog::net()->warn(\"failed to send \"\n                                             \"send_to_device \"\n                                             \"message: {}\",\n                                             err->matrix_error.error);\n                      }\n                  });\n        };\n    };\n\n    if (!claims.one_time_keys.empty())\n        http::client()->claim_keys(claims, BindPks(pks));\n\n    if (!keysToQuery.empty()) {\n        mtx::requests::QueryKeys req;\n        req.device_keys = keysToQuery;\n        http::client()->query_keys(\n          req,\n          [ev_json, BindPks, our_curve](const mtx::responses::QueryKeys &res,\n                                        mtx::http::RequestErr err) {\n              if (err) {\n                  nhlog::net()->warn(\"failed to query device keys: {} {}\",\n                                     err->matrix_error.error,\n                                     static_cast<int>(err->status_code));\n                  return;\n              }\n\n              nhlog::net()->info(\"queried keys\");\n\n              cache::client()->updateUserKeys(cache::nextBatchToken(), res);\n\n              mtx::requests::ClaimKeys claim_keys;\n\n              std::map<std::string, std::map<std::string, DevicePublicKeys>> deviceKeys;\n\n              for (const auto &user : res.device_keys) {\n                  for (const auto &dev : user.second) {\n                      const auto user_id   = ::UserId(dev.second.user_id);\n                      const auto device_id = DeviceId(dev.second.device_id);\n\n                      if (user_id.get() == http::client()->user_id().to_string() &&\n                          device_id.get() == http::client()->device_id())\n                          continue;\n\n                      const auto device_keys = dev.second.keys;\n                      const auto curveKey    = \"curve25519:\" + device_id.get();\n                      const auto edKey       = \"ed25519:\" + device_id.get();\n\n                      if ((device_keys.find(curveKey) == device_keys.end()) ||\n                          (device_keys.find(edKey) == device_keys.end())) {\n                          nhlog::net()->debug(\"ignoring malformed keys for device {}\",\n                                              device_id.get());\n                          continue;\n                      }\n\n                      DevicePublicKeys pks;\n                      pks.ed25519    = device_keys.at(edKey);\n                      pks.curve25519 = device_keys.at(curveKey);\n\n                      if (pks.curve25519 == our_curve) {\n                          nhlog::crypto()->warn(\"Skipping our own device, since sending \"\n                                                \"ourselves olm messages makes no sense.\");\n                          continue;\n                      }\n\n                      try {\n                          if (!mtx::crypto::verify_identity_signature(\n                                dev.second, device_id, user_id)) {\n                              nhlog::crypto()->warn(\"failed to verify identity keys: {}\",\n                                                    nlohmann::json(dev.second).dump(2));\n                              continue;\n                          }\n                      } catch (const nlohmann::json::exception &e) {\n                          nhlog::crypto()->warn(\"failed to parse device key json: {}\", e.what());\n                          continue;\n                      } catch (const mtx::crypto::olm_exception &e) {\n                          nhlog::crypto()->warn(\"failed to verify device key json: {}\", e.what());\n                          continue;\n                      }\n\n                      auto currentTime = QDateTime::currentSecsSinceEpoch();\n                      if (rateLimit.value(QPair(user.first, device_id.get())) + 60 * 60 * 10 <\n                          currentTime) {\n                          deviceKeys[user_id].emplace(device_id, pks);\n                          claim_keys.one_time_keys[user.first][device_id] =\n                            mtx::crypto::SIGNED_CURVE25519;\n\n                          rateLimit.insert(QPair(user.first, device_id.get()), currentTime);\n                      } else {\n                          nhlog::crypto()->warn(\"Not creating new session with {}:{} \"\n                                                \"because of rate limit\",\n                                                user.first,\n                                                device_id.get());\n                          continue;\n                      }\n\n                      nhlog::net()->info(\"{}\", device_id.get());\n                      nhlog::net()->info(\"  curve25519 {}\", pks.curve25519);\n                      nhlog::net()->info(\"  ed25519 {}\", pks.ed25519);\n                  }\n              }\n\n              if (!claim_keys.one_time_keys.empty())\n                  http::client()->claim_keys(claim_keys, BindPks(deviceKeys));\n          });\n    }\n}\n\nvoid\nrequest_cross_signing_keys()\n{\n    mtx::events::msg::SecretRequest secretRequest{};\n    secretRequest.action               = mtx::events::msg::RequestAction::Request;\n    secretRequest.requesting_device_id = http::client()->device_id();\n\n    auto local_user = http::client()->user_id();\n\n    auto verificationStatus = cache::verificationStatus(local_user.to_string());\n\n    if (!verificationStatus)\n        return;\n\n    auto request = [&](std::string secretName) {\n        secretRequest.name       = secretName;\n        secretRequest.request_id = \"ss.\" + http::client()->generate_txn_id();\n\n        request_id_to_secret_name[secretRequest.request_id] = secretRequest.name;\n\n        std::map<mtx::identifiers::User, std::map<std::string, mtx::events::msg::SecretRequest>>\n          body;\n\n        for (const auto &dev : verificationStatus->verified_devices) {\n            if (dev != secretRequest.requesting_device_id)\n                body[local_user][dev] = secretRequest;\n        }\n\n        http::client()->send_to_device<mtx::events::msg::SecretRequest>(\n          http::client()->generate_txn_id(),\n          body,\n          [request_id = secretRequest.request_id, secretName](mtx::http::RequestErr err) {\n              if (err) {\n                  nhlog::net()->error(\"Failed to send request for secrect '{}'\", secretName);\n                  // Cancel request on UI thread\n                  QTimer::singleShot(1, cache::client(), [request_id]() {\n                      request_id_to_secret_name.erase(request_id);\n                  });\n                  return;\n              }\n          });\n\n        for (const auto &dev : verificationStatus->verified_devices) {\n            if (dev != secretRequest.requesting_device_id)\n                body[local_user][dev].action = mtx::events::msg::RequestAction::Cancellation;\n        }\n\n        // timeout after 15 min\n        QTimer::singleShot(15 * 60 * 1000, ChatPage::instance(), [secretRequest, body]() {\n            if (request_id_to_secret_name.count(secretRequest.request_id)) {\n                request_id_to_secret_name.erase(secretRequest.request_id);\n                http::client()->send_to_device<mtx::events::msg::SecretRequest>(\n                  http::client()->generate_txn_id(),\n                  body,\n                  [secretRequest](mtx::http::RequestErr err) {\n                      if (err) {\n                          nhlog::net()->error(\"Failed to cancel request for secrect '{}'\",\n                                              secretRequest.name);\n                          return;\n                      }\n                  });\n            }\n        });\n    };\n\n    request(mtx::secret_storage::secrets::cross_signing_master);\n    request(mtx::secret_storage::secrets::cross_signing_self_signing);\n    request(mtx::secret_storage::secrets::cross_signing_user_signing);\n    request(mtx::secret_storage::secrets::megolm_backup_v1);\n}\n\nnamespace {\nvoid\nunlock_secrets(const std::string &key,\n               const std::map<std::string, mtx::secret_storage::AesHmacSha2EncryptedData> &secrets)\n{\n    http::client()->secret_storage_key(\n      key,\n      [secrets](mtx::secret_storage::AesHmacSha2KeyDescription keyDesc, mtx::http::RequestErr err) {\n          if (err) {\n              nhlog::net()->error(\"Failed to download secret storage key\");\n              return;\n          }\n\n          emit ChatPage::instance()->downloadedSecrets(keyDesc, secrets);\n      });\n}\n}\n\nvoid\ndownload_cross_signing_keys()\n{\n    using namespace mtx::secret_storage;\n    http::client()->secret_storage_secret(\n      secrets::megolm_backup_v1, [](Secret secret, mtx::http::RequestErr err) {\n          std::optional<Secret> backup_key;\n          if (!err)\n              backup_key = secret;\n\n          http::client()->secret_storage_secret(\n            secrets::cross_signing_master, [backup_key](Secret secret, mtx::http::RequestErr err) {\n                std::optional<Secret> master_key;\n                if (!err)\n                    master_key = secret;\n\n                http::client()->secret_storage_secret(\n                  secrets::cross_signing_self_signing,\n                  [backup_key, master_key](Secret secret, mtx::http::RequestErr err) {\n                      std::optional<Secret> self_signing_key;\n                      if (!err)\n                          self_signing_key = secret;\n\n                      http::client()->secret_storage_secret(\n                        secrets::cross_signing_user_signing,\n                        [backup_key, self_signing_key, master_key](Secret secret,\n                                                                   mtx::http::RequestErr err) {\n                            std::optional<Secret> user_signing_key;\n                            if (!err)\n                                user_signing_key = secret;\n\n                            std::map<std::string, std::map<std::string, AesHmacSha2EncryptedData>>\n                              secrets;\n\n                            if (backup_key && !backup_key->encrypted.empty())\n                                secrets[backup_key->encrypted.begin()->first]\n                                       [secrets::megolm_backup_v1] =\n                                         backup_key->encrypted.begin()->second;\n\n                            if (master_key && !master_key->encrypted.empty())\n                                secrets[master_key->encrypted.begin()->first]\n                                       [secrets::cross_signing_master] =\n                                         master_key->encrypted.begin()->second;\n\n                            if (self_signing_key && !self_signing_key->encrypted.empty())\n                                secrets[self_signing_key->encrypted.begin()->first]\n                                       [secrets::cross_signing_self_signing] =\n                                         self_signing_key->encrypted.begin()->second;\n\n                            if (user_signing_key && !user_signing_key->encrypted.empty())\n                                secrets[user_signing_key->encrypted.begin()->first]\n                                       [secrets::cross_signing_user_signing] =\n                                         user_signing_key->encrypted.begin()->second;\n\n                            for (const auto &[key, secret_] : secrets)\n                                unlock_secrets(key, secret_);\n                        });\n                  });\n            });\n      });\n}\n\n} // namespace olm\n"], "fixing_code": ["// SPDX-FileCopyrightText: 2021 Nheko Contributors\n// SPDX-FileCopyrightText: 2022 Nheko Contributors\n//\n// SPDX-License-Identifier: GPL-3.0-or-later\n\n#include \"Olm.h\"\n\n#include <QObject>\n#include <QTimer>\n\n#include <nlohmann/json.hpp>\n#include <variant>\n\n#include <mtx/responses/common.hpp>\n#include <mtx/secret_storage.hpp>\n\n#include \"Cache.h\"\n#include \"Cache_p.h\"\n#include \"ChatPage.h\"\n#include \"DeviceVerificationFlow.h\"\n#include \"EventAccessors.h\"\n#include \"Logging.h\"\n#include \"MatrixClient.h\"\n#include \"UserSettingsPage.h\"\n#include \"Utils.h\"\n\nnamespace {\nauto client_ = std::make_unique<mtx::crypto::OlmClient>();\n\nstd::map<std::string, std::string> request_id_to_secret_name;\n\nconstexpr auto MEGOLM_ALGO = \"m.megolm.v1.aes-sha2\";\n}\n\nnamespace olm {\nstatic void\nbackup_session_key(const MegolmSessionIndex &idx,\n                   const GroupSessionData &data,\n                   mtx::crypto::InboundGroupSessionPtr &session);\n\nvoid\nfrom_json(const nlohmann::json &obj, OlmMessage &msg)\n{\n    if (obj.at(\"type\") != \"m.room.encrypted\")\n        throw std::invalid_argument(\"invalid type for olm message\");\n\n    if (obj.at(\"content\").at(\"algorithm\") != OLM_ALGO)\n        throw std::invalid_argument(\"invalid algorithm for olm message\");\n\n    msg.sender     = obj.at(\"sender\").get<std::string>();\n    msg.sender_key = obj.at(\"content\").at(\"sender_key\").get<std::string>();\n    msg.ciphertext = obj.at(\"content\")\n                       .at(\"ciphertext\")\n                       .get<std::map<std::string, mtx::events::msg::OlmCipherContent>>();\n}\n\nmtx::crypto::OlmClient *\nclient()\n{\n    return client_.get();\n}\n\nstatic void\nhandle_secret_request(const mtx::events::DeviceEvent<mtx::events::msg::SecretRequest> *e,\n                      const std::string &sender)\n{\n    using namespace mtx::events;\n\n    if (e->content.action != mtx::events::msg::RequestAction::Request)\n        return;\n\n    auto local_user = http::client()->user_id();\n\n    if (sender != local_user.to_string())\n        return;\n\n    auto verificationStatus = cache::verificationStatus(local_user.to_string());\n\n    if (!verificationStatus)\n        return;\n\n    auto deviceKeys = cache::userKeys(local_user.to_string());\n    if (!deviceKeys)\n        return;\n\n    if (std::find(verificationStatus->verified_devices.begin(),\n                  verificationStatus->verified_devices.end(),\n                  e->content.requesting_device_id) == verificationStatus->verified_devices.end())\n        return;\n\n    // this is a verified device\n    mtx::events::DeviceEvent<mtx::events::msg::SecretSend> secretSend;\n    secretSend.type               = EventType::SecretSend;\n    secretSend.content.request_id = e->content.request_id;\n\n    auto secret = cache::client()->secret(e->content.name);\n    if (!secret)\n        return;\n    secretSend.content.secret = secret.value();\n\n    send_encrypted_to_device_messages(\n      {{local_user.to_string(), {{e->content.requesting_device_id}}}}, secretSend);\n\n    nhlog::net()->info(\"Sent secret '{}' to ({},{})\",\n                       e->content.name,\n                       local_user.to_string(),\n                       e->content.requesting_device_id);\n}\n\nvoid\nhandle_to_device_messages(const std::vector<mtx::events::collections::DeviceEvents> &msgs)\n{\n    if (msgs.empty())\n        return;\n    nhlog::crypto()->info(\"received {} to_device messages\", msgs.size());\n    nlohmann::json j_msg;\n\n    for (const auto &msg : msgs) {\n        j_msg = std::visit([](auto &e) { return nlohmann::json(e); }, std::move(msg));\n        if (j_msg.count(\"type\") == 0) {\n            nhlog::crypto()->warn(\"received message with no type field: {}\", j_msg.dump(2));\n            continue;\n        }\n\n        std::string msg_type = j_msg.at(\"type\").get<std::string>();\n\n        if (msg_type == to_string(mtx::events::EventType::RoomEncrypted)) {\n            try {\n                olm::OlmMessage olm_msg = j_msg.get<olm::OlmMessage>();\n                cache::client()->query_keys(\n                  olm_msg.sender, [olm_msg](const UserKeyCache &userKeys, mtx::http::RequestErr e) {\n                      if (e) {\n                          nhlog::crypto()->error(\"Failed to query user keys, dropping olm \"\n                                                 \"message\");\n                          return;\n                      }\n                      handle_olm_message(std::move(olm_msg), userKeys);\n                  });\n            } catch (const nlohmann::json::exception &e) {\n                nhlog::crypto()->warn(\n                  \"parsing error for olm message: {} {}\", e.what(), j_msg.dump(2));\n            } catch (const std::invalid_argument &e) {\n                nhlog::crypto()->warn(\n                  \"validation error for olm message: {} {}\", e.what(), j_msg.dump(2));\n            }\n\n        } else if (msg_type == to_string(mtx::events::EventType::RoomKeyRequest)) {\n            nhlog::crypto()->warn(\"handling key request event: {}\", j_msg.dump(2));\n            try {\n                mtx::events::DeviceEvent<mtx::events::msg::KeyRequest> req =\n                  j_msg.get<mtx::events::DeviceEvent<mtx::events::msg::KeyRequest>>();\n                if (req.content.action == mtx::events::msg::RequestAction::Request)\n                    handle_key_request_message(req);\n                else\n                    nhlog::crypto()->warn(\"ignore key request (unhandled action): {}\",\n                                          req.content.request_id);\n            } catch (const nlohmann::json::exception &e) {\n                nhlog::crypto()->warn(\n                  \"parsing error for key_request message: {} {}\", e.what(), j_msg.dump(2));\n            }\n        } else if (msg_type == to_string(mtx::events::EventType::KeyVerificationAccept)) {\n            auto message =\n              std::get<mtx::events::DeviceEvent<mtx::events::msg::KeyVerificationAccept>>(msg);\n            ChatPage::instance()->receivedDeviceVerificationAccept(message.content);\n        } else if (msg_type == to_string(mtx::events::EventType::KeyVerificationRequest)) {\n            auto message =\n              std::get<mtx::events::DeviceEvent<mtx::events::msg::KeyVerificationRequest>>(msg);\n            ChatPage::instance()->receivedDeviceVerificationRequest(message.content,\n                                                                    message.sender);\n        } else if (msg_type == to_string(mtx::events::EventType::KeyVerificationCancel)) {\n            auto message =\n              std::get<mtx::events::DeviceEvent<mtx::events::msg::KeyVerificationCancel>>(msg);\n            ChatPage::instance()->receivedDeviceVerificationCancel(message.content);\n        } else if (msg_type == to_string(mtx::events::EventType::KeyVerificationKey)) {\n            auto message =\n              std::get<mtx::events::DeviceEvent<mtx::events::msg::KeyVerificationKey>>(msg);\n            ChatPage::instance()->receivedDeviceVerificationKey(message.content);\n        } else if (msg_type == to_string(mtx::events::EventType::KeyVerificationMac)) {\n            auto message =\n              std::get<mtx::events::DeviceEvent<mtx::events::msg::KeyVerificationMac>>(msg);\n            ChatPage::instance()->receivedDeviceVerificationMac(message.content);\n        } else if (msg_type == to_string(mtx::events::EventType::KeyVerificationStart)) {\n            auto message =\n              std::get<mtx::events::DeviceEvent<mtx::events::msg::KeyVerificationStart>>(msg);\n            ChatPage::instance()->receivedDeviceVerificationStart(message.content, message.sender);\n        } else if (msg_type == to_string(mtx::events::EventType::KeyVerificationReady)) {\n            auto message =\n              std::get<mtx::events::DeviceEvent<mtx::events::msg::KeyVerificationReady>>(msg);\n            ChatPage::instance()->receivedDeviceVerificationReady(message.content);\n        } else if (msg_type == to_string(mtx::events::EventType::KeyVerificationDone)) {\n            auto message =\n              std::get<mtx::events::DeviceEvent<mtx::events::msg::KeyVerificationDone>>(msg);\n            ChatPage::instance()->receivedDeviceVerificationDone(message.content);\n        } else if (auto e =\n                     std::get_if<mtx::events::DeviceEvent<mtx::events::msg::SecretRequest>>(&msg)) {\n            handle_secret_request(e, e->sender);\n        } else {\n            nhlog::crypto()->warn(\"unhandled event: {}\", j_msg.dump(2));\n        }\n    }\n}\n\nvoid\nhandle_olm_message(const OlmMessage &msg, const UserKeyCache &otherUserDeviceKeys)\n{\n    nhlog::crypto()->info(\"sender    : {}\", msg.sender);\n    nhlog::crypto()->info(\"sender_key: {}\", msg.sender_key);\n\n    if (msg.sender_key == olm::client()->identity_keys().ed25519) {\n        nhlog::crypto()->warn(\"Ignoring olm message from ourselves!\");\n        return;\n    }\n\n    const auto my_key = olm::client()->identity_keys().curve25519;\n\n    bool failed_decryption = false;\n\n    for (const auto &cipher : msg.ciphertext) {\n        // We skip messages not meant for the current device.\n        if (cipher.first != my_key) {\n            nhlog::crypto()->debug(\n              \"Skipping message for {} since we are {}.\", cipher.first, my_key);\n            continue;\n        }\n\n        const auto type = cipher.second.type;\n        nhlog::crypto()->info(\"type: {}\", type == 0 ? \"OLM_PRE_KEY\" : \"OLM_MESSAGE\");\n\n        auto payload = try_olm_decryption(msg.sender_key, cipher.second);\n\n        if (payload.is_null()) {\n            // Check for PRE_KEY message\n            if (cipher.second.type == 0) {\n                payload = handle_pre_key_olm_message(msg.sender, msg.sender_key, cipher.second);\n            } else {\n                nhlog::crypto()->error(\"Undecryptable olm message!\");\n                failed_decryption = true;\n                continue;\n            }\n        }\n\n        if (!payload.is_null()) {\n            mtx::events::collections::DeviceEvents device_event;\n\n            // Other properties are included in order to prevent an attacker from\n            // publishing someone else's curve25519 keys as their own and subsequently\n            // claiming to have sent messages which they didn't. sender must correspond\n            // to the user who sent the event, recipient to the local user, and\n            // recipient_keys to the local ed25519 key.\n            std::string receiver_ed25519 = payload[\"recipient_keys\"][\"ed25519\"].get<std::string>();\n            if (receiver_ed25519.empty() ||\n                receiver_ed25519 != olm::client()->identity_keys().ed25519) {\n                nhlog::crypto()->warn(\"Decrypted event doesn't include our ed25519: {}\",\n                                      payload.dump());\n                return;\n            }\n            std::string receiver = payload[\"recipient\"].get<std::string>();\n            if (receiver.empty() || receiver != http::client()->user_id().to_string()) {\n                nhlog::crypto()->warn(\"Decrypted event doesn't include our user_id: {}\",\n                                      payload.dump());\n                return;\n            }\n\n            // Clients must confirm that the sender_key and the ed25519 field value\n            // under the keys property match the keys returned by /keys/query for the\n            // given user, and must also verify the signature of the payload. Without\n            // this check, a client cannot be sure that the sender device owns the\n            // private part of the ed25519 key it claims to have in the Olm payload.\n            // This is crucial when the ed25519 key corresponds to a verified device.\n            std::string sender_ed25519 = payload[\"keys\"][\"ed25519\"].get<std::string>();\n            if (sender_ed25519.empty()) {\n                nhlog::crypto()->warn(\"Decrypted event doesn't include sender ed25519: {}\",\n                                      payload.dump());\n                return;\n            }\n\n            bool from_their_device = false;\n            for (const auto &[device_id, key] : otherUserDeviceKeys.device_keys) {\n                auto c_key = key.keys.find(\"curve25519:\" + device_id);\n                auto e_key = key.keys.find(\"ed25519:\" + device_id);\n\n                if (c_key == key.keys.end() || e_key == key.keys.end()) {\n                    nhlog::crypto()->warn(\"Skipping device {} as we have no keys for it.\",\n                                          device_id);\n                } else if (c_key->second == msg.sender_key && e_key->second == sender_ed25519) {\n                    from_their_device = true;\n                    break;\n                }\n            }\n            if (!from_their_device) {\n                nhlog::crypto()->warn(\"Decrypted event isn't sent from a device \"\n                                      \"listed by that user! {}\",\n                                      payload.dump());\n                return;\n            }\n\n            {\n                std::string msg_type       = payload[\"type\"].get<std::string>();\n                nlohmann::json event_array = nlohmann::json::array();\n                event_array.push_back(payload);\n\n                std::vector<mtx::events::collections::DeviceEvents> temp_events;\n                mtx::responses::utils::parse_device_events(event_array, temp_events);\n                if (temp_events.empty()) {\n                    nhlog::crypto()->warn(\"Decrypted unknown event: {}\", payload.dump());\n                    return;\n                }\n                device_event = temp_events.at(0);\n            }\n\n            using namespace mtx::events;\n            if (auto e1 = std::get_if<DeviceEvent<msg::KeyVerificationAccept>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationAccept(e1->content);\n            } else if (auto e2 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationRequest>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationRequest(e2->content, e2->sender);\n            } else if (auto e3 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationCancel>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationCancel(e3->content);\n            } else if (auto e4 = std::get_if<DeviceEvent<msg::KeyVerificationKey>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationKey(e4->content);\n            } else if (auto e5 = std::get_if<DeviceEvent<msg::KeyVerificationMac>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationMac(e5->content);\n            } else if (auto e6 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationStart>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationStart(e6->content, e6->sender);\n            } else if (auto e7 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationReady>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationReady(e7->content);\n            } else if (auto e8 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationDone>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationDone(e8->content);\n            } else if (auto roomKey = std::get_if<DeviceEvent<msg::RoomKey>>(&device_event)) {\n                create_inbound_megolm_session(*roomKey, msg.sender_key, sender_ed25519);\n            } else if (auto forwardedRoomKey =\n                         std::get_if<DeviceEvent<msg::ForwardedRoomKey>>(&device_event)) {\n                forwardedRoomKey->content.forwarding_curve25519_key_chain.push_back(msg.sender_key);\n                import_inbound_megolm_session(*forwardedRoomKey);\n            } else if (auto e = std::get_if<DeviceEvent<msg::SecretSend>>(&device_event)) {\n                auto local_user = http::client()->user_id();\n\n                if (msg.sender != local_user.to_string())\n                    return;\n\n                auto secret_name_it = request_id_to_secret_name.find(e->content.request_id);\n\n                if (secret_name_it != request_id_to_secret_name.end()) {\n                    auto secret_name = secret_name_it->second;\n                    request_id_to_secret_name.erase(secret_name_it);\n\n                    nhlog::crypto()->info(\"Received secret: {}\", secret_name);\n\n                    mtx::events::msg::SecretRequest secretRequest{};\n                    secretRequest.action = mtx::events::msg::RequestAction::Cancellation;\n                    secretRequest.requesting_device_id = http::client()->device_id();\n                    secretRequest.request_id           = e->content.request_id;\n\n                    auto verificationStatus = cache::verificationStatus(local_user.to_string());\n\n                    if (!verificationStatus)\n                        return;\n\n                    auto deviceKeys = cache::userKeys(local_user.to_string());\n                    if (!deviceKeys)\n                        return;\n\n                    std::string sender_device_id;\n                    for (auto &[dev, key] : deviceKeys->device_keys) {\n                        if (key.keys[\"curve25519:\" + dev] == msg.sender_key) {\n                            sender_device_id = dev;\n                            break;\n                        }\n                    }\n                    if (!verificationStatus->verified_devices.count(sender_device_id) ||\n                        !verificationStatus->verified_device_keys.count(msg.sender_key) ||\n                        verificationStatus->verified_device_keys.at(msg.sender_key) !=\n                          crypto::Trust::Verified) {\n                        nhlog::net()->critical(\n                          \"Received secret from unverified device {}! Ignoring!\", sender_device_id);\n                        return;\n                    }\n\n                    std::map<mtx::identifiers::User,\n                             std::map<std::string, mtx::events::msg::SecretRequest>>\n                      body;\n\n                    for (const auto &dev : verificationStatus->verified_devices) {\n                        if (dev != secretRequest.requesting_device_id && dev != sender_device_id)\n                            body[local_user][dev] = secretRequest;\n                    }\n\n                    http::client()->send_to_device<mtx::events::msg::SecretRequest>(\n                      http::client()->generate_txn_id(),\n                      body,\n                      [secret_name](mtx::http::RequestErr err) {\n                          if (err) {\n                              nhlog::net()->error(\"Failed to send request cancellation \"\n                                                  \"for secrect \"\n                                                  \"'{}'\",\n                                                  secret_name);\n                          }\n                      });\n\n                    nhlog::crypto()->info(\"Storing secret {}\", secret_name);\n                    cache::client()->storeSecret(secret_name, e->content.secret);\n                }\n\n            } else if (auto sec_req = std::get_if<DeviceEvent<msg::SecretRequest>>(&device_event)) {\n                handle_secret_request(sec_req, msg.sender);\n            }\n\n            return;\n        } else {\n            failed_decryption = true;\n        }\n    }\n\n    if (failed_decryption) {\n        try {\n            std::map<std::string, std::vector<std::string>> targets;\n            for (const auto &[device_id, key] : otherUserDeviceKeys.device_keys) {\n                if (key.keys.at(\"curve25519:\" + device_id) == msg.sender_key)\n                    targets[msg.sender].push_back(device_id);\n            }\n\n            send_encrypted_to_device_messages(\n              targets, mtx::events::DeviceEvent<mtx::events::msg::Dummy>{}, true);\n            nhlog::crypto()->info(\n              \"Recovering from broken olm channel with {}:{}\", msg.sender, msg.sender_key);\n        } catch (std::exception &e) {\n            nhlog::crypto()->error(\"Failed to recover from broken olm sessions: {}\", e.what());\n        }\n    }\n}\n\nnlohmann::json\nhandle_pre_key_olm_message(const std::string &sender,\n                           const std::string &sender_key,\n                           const mtx::events::msg::OlmCipherContent &content)\n{\n    nhlog::crypto()->info(\"opening olm session with {}\", sender);\n\n    mtx::crypto::OlmSessionPtr inbound_session = nullptr;\n    try {\n        inbound_session = olm::client()->create_inbound_session_from(sender_key, content.body);\n\n        // We also remove the one time key used to establish that\n        // session so we'll have to update our copy of the account object.\n        cache::saveOlmAccount(olm::client()->save(cache::client()->pickleSecret()));\n    } catch (const mtx::crypto::olm_exception &e) {\n        nhlog::crypto()->critical(\"failed to create inbound session with {}: {}\", sender, e.what());\n        return {};\n    }\n\n    if (!mtx::crypto::matches_inbound_session_from(\n          inbound_session.get(), sender_key, content.body)) {\n        nhlog::crypto()->warn(\"inbound olm session doesn't match sender's key ({})\", sender);\n        return {};\n    }\n\n    mtx::crypto::BinaryBuf output;\n    try {\n        output = olm::client()->decrypt_message(inbound_session.get(), content.type, content.body);\n    } catch (const mtx::crypto::olm_exception &e) {\n        nhlog::crypto()->critical(\"failed to decrypt olm message {}: {}\", content.body, e.what());\n        return {};\n    }\n\n    auto plaintext = nlohmann::json::parse(std::string((char *)output.data(), output.size()));\n    nhlog::crypto()->debug(\"decrypted message: \\n {}\", plaintext.dump(2));\n\n    try {\n        nhlog::crypto()->debug(\"New olm session: {}\",\n                               mtx::crypto::session_id(inbound_session.get()));\n        cache::saveOlmSession(\n          sender_key, std::move(inbound_session), QDateTime::currentMSecsSinceEpoch());\n    } catch (const lmdb::error &e) {\n        nhlog::db()->warn(\"failed to save inbound olm session from {}: {}\", sender, e.what());\n    }\n\n    return plaintext;\n}\n\nmtx::events::msg::Encrypted\nencrypt_group_message_with_session(mtx::crypto::OutboundGroupSessionPtr &session,\n                                   const std::string &device_id,\n                                   nlohmann::json body)\n{\n    using namespace mtx::events;\n\n    // relations shouldn't be encrypted...\n    mtx::common::Relations relations = mtx::common::parse_relations(body[\"content\"]);\n\n    auto payload = olm::client()->encrypt_group_message(session.get(), body.dump());\n\n    // Prepare the m.room.encrypted event.\n    msg::Encrypted data;\n    data.ciphertext = std::string((char *)payload.data(), payload.size());\n    data.sender_key = olm::client()->identity_keys().curve25519;\n    data.session_id = mtx::crypto::session_id(session.get());\n    data.device_id  = device_id;\n    data.algorithm  = MEGOLM_ALGO;\n    data.relations  = relations;\n\n    return data;\n}\n\nmtx::events::msg::Encrypted\nencrypt_group_message(const std::string &room_id, const std::string &device_id, nlohmann::json body)\n{\n    using namespace mtx::events;\n    using namespace mtx::identifiers;\n\n    auto own_user_id = http::client()->user_id().to_string();\n\n    auto members = cache::client()->getMembersWithKeys(\n      room_id, UserSettings::instance()->onlyShareKeysWithVerifiedUsers());\n\n    std::map<std::string, std::vector<std::string>> sendSessionTo;\n    mtx::crypto::OutboundGroupSessionPtr session = nullptr;\n    GroupSessionData group_session_data;\n\n    if (cache::outboundMegolmSessionExists(room_id)) {\n        auto res                = cache::getOutboundMegolmSession(room_id);\n        auto encryptionSettings = cache::client()->roomEncryptionSettings(room_id);\n        mtx::events::state::Encryption defaultSettings;\n\n        // rotate if we crossed the limits for this key\n        if (res.data.message_index <\n              encryptionSettings.value_or(defaultSettings).rotation_period_msgs &&\n            (QDateTime::currentMSecsSinceEpoch() - res.data.timestamp) <\n              encryptionSettings.value_or(defaultSettings).rotation_period_ms) {\n            auto member_it             = members.begin();\n            auto session_member_it     = res.data.currently.keys.begin();\n            auto session_member_it_end = res.data.currently.keys.end();\n\n            while (member_it != members.end() || session_member_it != session_member_it_end) {\n                if (member_it == members.end()) {\n                    // a member left, purge session!\n                    nhlog::crypto()->debug(\"Rotating megolm session because of left member\");\n                    break;\n                }\n\n                if (session_member_it == session_member_it_end) {\n                    // share with all remaining members\n                    while (member_it != members.end()) {\n                        sendSessionTo[member_it->first] = {};\n\n                        if (member_it->second)\n                            for (const auto &dev : member_it->second->device_keys)\n                                if (member_it->first != own_user_id || dev.first != device_id)\n                                    sendSessionTo[member_it->first].push_back(dev.first);\n\n                        ++member_it;\n                    }\n\n                    session = std::move(res.session);\n                    break;\n                }\n\n                if (member_it->first > session_member_it->first) {\n                    // a member left, purge session\n                    nhlog::crypto()->debug(\"Rotating megolm session because of left member\");\n                    break;\n                } else if (member_it->first < session_member_it->first) {\n                    // new member, send them the session at this index\n                    sendSessionTo[member_it->first] = {};\n\n                    if (member_it->second) {\n                        for (const auto &dev : member_it->second->device_keys)\n                            if (member_it->first != own_user_id || dev.first != device_id)\n                                sendSessionTo[member_it->first].push_back(dev.first);\n                    }\n\n                    ++member_it;\n                } else {\n                    // compare devices\n                    bool device_removed = false;\n                    for (const auto &dev : session_member_it->second.deviceids) {\n                        if (!member_it->second ||\n                            !member_it->second->device_keys.count(dev.first)) {\n                            device_removed = true;\n                            break;\n                        }\n                    }\n\n                    if (device_removed) {\n                        // device removed, rotate session!\n                        nhlog::crypto()->debug(\"Rotating megolm session because of removed \"\n                                               \"device of {}\",\n                                               member_it->first);\n                        break;\n                    }\n\n                    // check for new devices to share with\n                    if (member_it->second)\n                        for (const auto &dev : member_it->second->device_keys)\n                            if (!session_member_it->second.deviceids.count(dev.first) &&\n                                (member_it->first != own_user_id || dev.first != device_id))\n                                sendSessionTo[member_it->first].push_back(dev.first);\n\n                    ++member_it;\n                    ++session_member_it;\n                    if (member_it == members.end() && session_member_it == session_member_it_end) {\n                        // all devices match or are newly added\n                        session = std::move(res.session);\n                    }\n                }\n            }\n        }\n\n        group_session_data = std::move(res.data);\n    }\n\n    if (!session) {\n        nhlog::ui()->debug(\"creating new outbound megolm session\");\n\n        // Create a new outbound megolm session.\n        session                = olm::client()->init_outbound_group_session();\n        const auto session_id  = mtx::crypto::session_id(session.get());\n        const auto session_key = mtx::crypto::session_key(session.get());\n\n        // Saving the new megolm session.\n        GroupSessionData session_data{};\n        session_data.message_index              = 0;\n        session_data.timestamp                  = QDateTime::currentMSecsSinceEpoch();\n        session_data.sender_claimed_ed25519_key = olm::client()->identity_keys().ed25519;\n        session_data.sender_key                 = olm::client()->identity_keys().curve25519;\n\n        sendSessionTo.clear();\n\n        for (const auto &[user, devices] : members) {\n            sendSessionTo[user]               = {};\n            session_data.currently.keys[user] = {};\n            if (devices) {\n                for (const auto &[device_id_, key] : devices->device_keys) {\n                    (void)key;\n                    if (device_id != device_id_ || user != own_user_id) {\n                        sendSessionTo[user].push_back(device_id_);\n                        session_data.currently.keys[user].deviceids[device_id_] = 0;\n                    }\n                }\n            }\n        }\n\n        {\n            MegolmSessionIndex index;\n            index.room_id       = room_id;\n            index.session_id    = session_id;\n            auto megolm_session = olm::client()->init_inbound_group_session(session_key);\n            backup_session_key(index, session_data, megolm_session);\n            cache::saveInboundMegolmSession(index, std::move(megolm_session), session_data);\n        }\n\n        cache::saveOutboundMegolmSession(room_id, session_data, session);\n        group_session_data = std::move(session_data);\n    }\n\n    mtx::events::DeviceEvent<mtx::events::msg::RoomKey> megolm_payload{};\n    megolm_payload.content.algorithm   = MEGOLM_ALGO;\n    megolm_payload.content.room_id     = room_id;\n    megolm_payload.content.session_id  = mtx::crypto::session_id(session.get());\n    megolm_payload.content.session_key = mtx::crypto::session_key(session.get());\n    megolm_payload.type                = mtx::events::EventType::RoomKey;\n\n    if (!sendSessionTo.empty())\n        olm::send_encrypted_to_device_messages(sendSessionTo, megolm_payload);\n\n    auto data = encrypt_group_message_with_session(session, device_id, body);\n\n    group_session_data.message_index = olm_outbound_group_session_message_index(session.get());\n    nhlog::crypto()->debug(\"next message_index {}\", group_session_data.message_index);\n\n    // update current set of members for the session with the new members and that message_index\n    for (const auto &[user, devices] : sendSessionTo) {\n        if (!group_session_data.currently.keys.count(user))\n            group_session_data.currently.keys[user] = {};\n\n        for (const auto &device_id_ : devices) {\n            if (!group_session_data.currently.keys[user].deviceids.count(device_id_))\n                group_session_data.currently.keys[user].deviceids[device_id_] =\n                  group_session_data.message_index;\n        }\n    }\n\n    // We need to re-pickle the session after we send a message to save the new message_index.\n    cache::updateOutboundMegolmSession(room_id, group_session_data, session);\n\n    return data;\n}\n\nnlohmann::json\ntry_olm_decryption(const std::string &sender_key, const mtx::events::msg::OlmCipherContent &msg)\n{\n    auto session_ids = cache::getOlmSessions(sender_key);\n\n    nhlog::crypto()->info(\"attempt to decrypt message with {} known session_ids\",\n                          session_ids.size());\n\n    for (const auto &id : session_ids) {\n        auto session = cache::getOlmSession(sender_key, id);\n\n        if (!session) {\n            nhlog::crypto()->warn(\"Unknown olm session: {}:{}\", sender_key, id);\n            continue;\n        }\n\n        mtx::crypto::BinaryBuf text;\n\n        try {\n            text = olm::client()->decrypt_message(session->get(), msg.type, msg.body);\n            nhlog::crypto()->debug(\"Updated olm session: {}\",\n                                   mtx::crypto::session_id(session->get()));\n            cache::saveOlmSession(\n              id, std::move(session.value()), QDateTime::currentMSecsSinceEpoch());\n        } catch (const mtx::crypto::olm_exception &e) {\n            nhlog::crypto()->debug(\"failed to decrypt olm message ({}, {}) with {}: {}\",\n                                   msg.type,\n                                   sender_key,\n                                   id,\n                                   e.what());\n            continue;\n        } catch (const lmdb::error &e) {\n            nhlog::crypto()->critical(\"failed to save session: {}\", e.what());\n            return {};\n        }\n\n        try {\n            return nlohmann::json::parse(std::string_view((char *)text.data(), text.size()));\n        } catch (const nlohmann::json::exception &e) {\n            nhlog::crypto()->critical(\"failed to parse the decrypted session msg: {} {}\",\n                                      e.what(),\n                                      std::string_view((char *)text.data(), text.size()));\n        }\n    }\n\n    return {};\n}\n\nvoid\ncreate_inbound_megolm_session(const mtx::events::DeviceEvent<mtx::events::msg::RoomKey> &roomKey,\n                              const std::string &sender_key,\n                              const std::string &sender_ed25519)\n{\n    MegolmSessionIndex index;\n    index.room_id    = roomKey.content.room_id;\n    index.session_id = roomKey.content.session_id;\n\n    try {\n        GroupSessionData data{};\n        data.forwarding_curve25519_key_chain = {sender_key};\n        data.sender_claimed_ed25519_key      = sender_ed25519;\n        data.sender_key                      = sender_key;\n\n        auto megolm_session =\n          olm::client()->init_inbound_group_session(roomKey.content.session_key);\n        backup_session_key(index, data, megolm_session);\n        cache::saveInboundMegolmSession(index, std::move(megolm_session), data);\n    } catch (const lmdb::error &e) {\n        nhlog::crypto()->critical(\"failed to save inbound megolm session: {}\", e.what());\n        return;\n    } catch (const mtx::crypto::olm_exception &e) {\n        nhlog::crypto()->critical(\"failed to create inbound megolm session: {}\", e.what());\n        return;\n    }\n\n    nhlog::crypto()->info(\n      \"established inbound megolm session ({}, {})\", roomKey.content.room_id, roomKey.sender);\n\n    ChatPage::instance()->receivedSessionKey(index.room_id, index.session_id);\n}\n\nvoid\nimport_inbound_megolm_session(\n  const mtx::events::DeviceEvent<mtx::events::msg::ForwardedRoomKey> &roomKey)\n{\n    MegolmSessionIndex index;\n    index.room_id    = roomKey.content.room_id;\n    index.session_id = roomKey.content.session_id;\n\n    try {\n        auto megolm_session =\n          olm::client()->import_inbound_group_session(roomKey.content.session_key);\n\n        GroupSessionData data{};\n        data.forwarding_curve25519_key_chain = roomKey.content.forwarding_curve25519_key_chain;\n        data.sender_claimed_ed25519_key      = roomKey.content.sender_claimed_ed25519_key;\n        data.sender_key                      = roomKey.content.sender_key;\n        // may have come from online key backup, so we can't trust it...\n        data.trusted = false;\n        // if we got it forwarded from the sender, assume it is trusted. They may still have\n        // used key backup, but it is unlikely.\n        if (roomKey.content.forwarding_curve25519_key_chain.size() == 1 &&\n            roomKey.content.forwarding_curve25519_key_chain.back() == roomKey.content.sender_key) {\n            data.trusted = true;\n        }\n\n        backup_session_key(index, data, megolm_session);\n        cache::saveInboundMegolmSession(index, std::move(megolm_session), data);\n    } catch (const lmdb::error &e) {\n        nhlog::crypto()->critical(\"failed to save inbound megolm session: {}\", e.what());\n        return;\n    } catch (const mtx::crypto::olm_exception &e) {\n        nhlog::crypto()->critical(\"failed to import inbound megolm session: {}\", e.what());\n        return;\n    }\n\n    nhlog::crypto()->info(\n      \"established inbound megolm session ({}, {})\", roomKey.content.room_id, roomKey.sender);\n\n    ChatPage::instance()->receivedSessionKey(index.room_id, index.session_id);\n}\n\nvoid\nbackup_session_key(const MegolmSessionIndex &idx,\n                   const GroupSessionData &data,\n                   mtx::crypto::InboundGroupSessionPtr &session)\n{\n    try {\n        if (!UserSettings::instance()->useOnlineKeyBackup()) {\n            // Online key backup disabled\n            return;\n        }\n\n        auto backupVersion = cache::client()->backupVersion();\n        if (!backupVersion) {\n            // no trusted OKB\n            return;\n        }\n\n        using namespace mtx::crypto;\n\n        auto decryptedSecret = cache::secret(mtx::secret_storage::secrets::megolm_backup_v1);\n        if (!decryptedSecret) {\n            // no backup key available\n            return;\n        }\n        auto sessionDecryptionKey = to_binary_buf(base642bin(*decryptedSecret));\n\n        auto public_key = mtx::crypto::CURVE25519_public_key_from_private(sessionDecryptionKey);\n\n        mtx::responses::backup::SessionData sessionData;\n        sessionData.algorithm                       = mtx::crypto::MEGOLM_ALGO;\n        sessionData.forwarding_curve25519_key_chain = data.forwarding_curve25519_key_chain;\n        sessionData.sender_claimed_keys[\"ed25519\"]  = data.sender_claimed_ed25519_key;\n        sessionData.sender_key                      = data.sender_key;\n        sessionData.session_key = mtx::crypto::export_session(session.get(), -1);\n\n        auto encrypt_session = mtx::crypto::encrypt_session(sessionData, public_key);\n\n        mtx::responses::backup::SessionBackup bk;\n        bk.first_message_index = olm_inbound_group_session_first_known_index(session.get());\n        bk.forwarded_count     = data.forwarding_curve25519_key_chain.size();\n        bk.is_verified         = false;\n        bk.session_data        = std::move(encrypt_session);\n\n        http::client()->put_room_keys(\n          backupVersion->version,\n          idx.room_id,\n          idx.session_id,\n          bk,\n          [idx](mtx::http::RequestErr err) {\n              if (err) {\n                  nhlog::net()->warn(\"failed to backup session key ({}:{}): {} ({})\",\n                                     idx.room_id,\n                                     idx.session_id,\n                                     err->matrix_error.error,\n                                     static_cast<int>(err->status_code));\n              } else {\n                  nhlog::crypto()->debug(\n                    \"backed up session key ({}:{})\", idx.room_id, idx.session_id);\n              }\n          });\n    } catch (std::exception &e) {\n        nhlog::net()->warn(\"failed to backup session key: {}\", e.what());\n    }\n}\n\nvoid\nmark_keys_as_published()\n{\n    olm::client()->mark_keys_as_published();\n    cache::saveOlmAccount(olm::client()->save(cache::client()->pickleSecret()));\n}\n\nvoid\ndownload_full_keybackup()\n{\n    if (!UserSettings::instance()->useOnlineKeyBackup()) {\n        // Online key backup disabled\n        return;\n    }\n\n    auto backupVersion = cache::client()->backupVersion();\n    if (!backupVersion) {\n        // no trusted OKB\n        return;\n    }\n\n    using namespace mtx::crypto;\n\n    auto decryptedSecret = cache::secret(mtx::secret_storage::secrets::megolm_backup_v1);\n    if (!decryptedSecret) {\n        // no backup key available\n        return;\n    }\n    auto sessionDecryptionKey = to_binary_buf(base642bin(*decryptedSecret));\n\n    http::client()->room_keys(\n      backupVersion->version,\n      [sessionDecryptionKey](const mtx::responses::backup::KeysBackup &bk,\n                             mtx::http::RequestErr err) {\n          if (err) {\n              if (err->status_code != 404)\n                  nhlog::crypto()->error(\"Failed to dowload backup: {} - {}\",\n                                         mtx::errors::to_string(err->matrix_error.errcode),\n                                         err->matrix_error.error);\n              return;\n          }\n\n          mtx::crypto::ExportedSessionKeys allKeys;\n          try {\n              for (const auto &[room, roomKey] : bk.rooms) {\n                  for (const auto &[session_id, encSession] : roomKey.sessions) {\n                      auto session = decrypt_session(encSession.session_data, sessionDecryptionKey);\n\n                      if (session.algorithm != mtx::crypto::MEGOLM_ALGO)\n                          // don't know this algorithm\n                          return;\n\n                      ExportedSession sess{};\n                      sess.session_id = session_id;\n                      sess.room_id    = room;\n                      sess.algorithm  = mtx::crypto::MEGOLM_ALGO;\n                      sess.forwarding_curve25519_key_chain =\n                        std::move(session.forwarding_curve25519_key_chain);\n                      sess.sender_claimed_keys = std::move(session.sender_claimed_keys);\n                      sess.sender_key          = std::move(session.sender_key);\n                      sess.session_key         = std::move(session.session_key);\n                      allKeys.sessions.push_back(std::move(sess));\n                  }\n              }\n\n              // call on UI thread\n              QTimer::singleShot(0, ChatPage::instance(), [keys = std::move(allKeys)] {\n                  cache::importSessionKeys(keys);\n              });\n          } catch (const lmdb::error &e) {\n              nhlog::crypto()->critical(\"failed to save inbound megolm session: {}\", e.what());\n          }\n      });\n}\nvoid\nlookup_keybackup(const std::string room, const std::string session_id)\n{\n    if (!UserSettings::instance()->useOnlineKeyBackup()) {\n        // Online key backup disabled\n        return;\n    }\n\n    auto backupVersion = cache::client()->backupVersion();\n    if (!backupVersion) {\n        // no trusted OKB\n        return;\n    }\n\n    using namespace mtx::crypto;\n\n    auto decryptedSecret = cache::secret(mtx::secret_storage::secrets::megolm_backup_v1);\n    if (!decryptedSecret) {\n        // no backup key available\n        return;\n    }\n    auto sessionDecryptionKey = to_binary_buf(base642bin(*decryptedSecret));\n\n    http::client()->room_keys(\n      backupVersion->version,\n      room,\n      session_id,\n      [room, session_id, sessionDecryptionKey](const mtx::responses::backup::SessionBackup &bk,\n                                               mtx::http::RequestErr err) {\n          if (err) {\n              if (err->status_code != 404)\n                  nhlog::crypto()->error(\"Failed to dowload key {}:{}: {} - {}\",\n                                         room,\n                                         session_id,\n                                         mtx::errors::to_string(err->matrix_error.errcode),\n                                         err->matrix_error.error);\n              return;\n          }\n          try {\n              auto session = decrypt_session(bk.session_data, sessionDecryptionKey);\n\n              if (session.algorithm != mtx::crypto::MEGOLM_ALGO)\n                  // don't know this algorithm\n                  return;\n\n              MegolmSessionIndex index;\n              index.room_id    = room;\n              index.session_id = session_id;\n\n              GroupSessionData data{};\n              data.forwarding_curve25519_key_chain = session.forwarding_curve25519_key_chain;\n              data.sender_claimed_ed25519_key      = session.sender_claimed_keys[\"ed25519\"];\n              data.sender_key                      = session.sender_key;\n              // online key backup can't be trusted, because anyone can upload to it.\n              data.trusted = false;\n\n              auto megolm_session =\n                olm::client()->import_inbound_group_session(session.session_key);\n\n              if (!cache::inboundMegolmSessionExists(index) ||\n                  olm_inbound_group_session_first_known_index(megolm_session.get()) <\n                    olm_inbound_group_session_first_known_index(\n                      cache::getInboundMegolmSession(index).get())) {\n                  cache::saveInboundMegolmSession(index, std::move(megolm_session), data);\n\n                  nhlog::crypto()->info(\"imported inbound megolm session \"\n                                        \"from key backup ({}, {})\",\n                                        room,\n                                        session_id);\n\n                  // call on UI thread\n                  QTimer::singleShot(0, ChatPage::instance(), [index] {\n                      ChatPage::instance()->receivedSessionKey(index.room_id, index.session_id);\n                  });\n              }\n          } catch (const lmdb::error &e) {\n              nhlog::crypto()->critical(\"failed to save inbound megolm session: {}\", e.what());\n              return;\n          } catch (const mtx::crypto::olm_exception &e) {\n              nhlog::crypto()->critical(\"failed to import inbound megolm session: {}\", e.what());\n              return;\n          }\n      });\n}\n\nvoid\nsend_key_request_for(mtx::events::EncryptedEvent<mtx::events::msg::Encrypted> e,\n                     const std::string &request_id,\n                     bool cancel)\n{\n    using namespace mtx::events;\n\n    nhlog::crypto()->debug(\"sending key request: sender_key {}, session_id {}\",\n                           e.content.sender_key,\n                           e.content.session_id);\n\n    mtx::events::msg::KeyRequest request;\n    request.action = cancel ? mtx::events::msg::RequestAction::Cancellation\n                            : mtx::events::msg::RequestAction::Request;\n\n    request.algorithm            = MEGOLM_ALGO;\n    request.room_id              = e.room_id;\n    request.sender_key           = e.content.sender_key;\n    request.session_id           = e.content.session_id;\n    request.request_id           = request_id;\n    request.requesting_device_id = http::client()->device_id();\n\n    nhlog::crypto()->debug(\"m.room_key_request: {}\", nlohmann::json(request).dump(2));\n\n    std::map<mtx::identifiers::User, std::map<std::string, decltype(request)>> body;\n    body[mtx::identifiers::parse<mtx::identifiers::User>(e.sender)][\"*\"] = request;\n    body[http::client()->user_id()][\"*\"]                                 = request;\n\n    http::client()->send_to_device(\n      http::client()->generate_txn_id(), body, [e](mtx::http::RequestErr err) {\n          if (err) {\n              nhlog::net()->warn(\"failed to send \"\n                                 \"send_to_device \"\n                                 \"message: {}\",\n                                 err->matrix_error.error);\n          }\n\n          nhlog::net()->info(\n            \"m.room_key_request sent to {}:{} and your own devices\", e.sender, e.content.device_id);\n      });\n\n    // http::client()->room_keys\n}\n\nvoid\nhandle_key_request_message(const mtx::events::DeviceEvent<mtx::events::msg::KeyRequest> &req)\n{\n    if (req.content.algorithm != MEGOLM_ALGO) {\n        nhlog::crypto()->debug(\"ignoring key request {} with invalid algorithm: {}\",\n                               req.content.request_id,\n                               req.content.algorithm);\n        return;\n    }\n\n    // Check that the requested session_id and the one we have saved match.\n    MegolmSessionIndex index{};\n    index.room_id    = req.content.room_id;\n    index.session_id = req.content.session_id;\n\n    // Check if we have the keys for the requested session.\n    auto sessionData = cache::getMegolmSessionData(index);\n    if (!sessionData) {\n        nhlog::crypto()->warn(\"requested session not found in room: {}\", req.content.room_id);\n        return;\n    }\n\n    // Check if we were the sender of the session being requested (unless it is actually us\n    // requesting the session).\n    if (req.sender != http::client()->user_id().to_string() &&\n        sessionData->sender_key != olm::client()->identity_keys().curve25519) {\n        nhlog::crypto()->debug(\n          \"ignoring key request {} because we did not create the requested session: \"\n          \"\\nrequested({}) ours({})\",\n          req.content.request_id,\n          sessionData->sender_key,\n          olm::client()->identity_keys().curve25519);\n        return;\n    }\n\n    const auto session = cache::getInboundMegolmSession(index);\n    if (!session) {\n        nhlog::crypto()->warn(\"No session with id {} in db\", req.content.session_id);\n        return;\n    }\n\n    if (!cache::isRoomMember(req.sender, req.content.room_id)) {\n        nhlog::crypto()->warn(\"user {} that requested the session key is not member of the room {}\",\n                              req.sender,\n                              req.content.room_id);\n        return;\n    }\n\n    // check if device is verified\n    auto verificationStatus = cache::verificationStatus(req.sender);\n    bool verifiedDevice     = false;\n    if (verificationStatus &&\n        // Share keys, if the option to share with trusted users is enabled or with yourself\n        (ChatPage::instance()->userSettings()->shareKeysWithTrustedUsers() ||\n         req.sender == http::client()->user_id().to_string())) {\n        for (const auto &dev : verificationStatus->verified_devices) {\n            if (dev == req.content.requesting_device_id) {\n                verifiedDevice = true;\n                nhlog::crypto()->debug(\"Verified device: {}\", dev);\n                break;\n            }\n        }\n    }\n\n    bool shouldSeeKeys    = false;\n    uint64_t minimumIndex = -1;\n    if (sessionData->currently.keys.count(req.sender)) {\n        if (sessionData->currently.keys.at(req.sender)\n              .deviceids.count(req.content.requesting_device_id)) {\n            shouldSeeKeys = true;\n            minimumIndex  = sessionData->currently.keys.at(req.sender)\n                             .deviceids.at(req.content.requesting_device_id);\n        }\n    }\n\n    if (!verifiedDevice && !shouldSeeKeys) {\n        nhlog::crypto()->debug(\"ignoring key request for room {}\", req.content.room_id);\n        return;\n    }\n\n    if (verifiedDevice) {\n        // share the minimum index we have\n        minimumIndex = -1;\n    }\n\n    try {\n        auto session_key = mtx::crypto::export_session(session.get(), minimumIndex);\n\n        //\n        // Prepare the m.room_key event.\n        //\n        mtx::events::msg::ForwardedRoomKey forward_key{};\n        forward_key.algorithm   = MEGOLM_ALGO;\n        forward_key.room_id     = index.room_id;\n        forward_key.session_id  = index.session_id;\n        forward_key.session_key = session_key;\n        forward_key.sender_key  = sessionData->sender_key;\n\n        // TODO(Nico): Figure out if this is correct\n        forward_key.sender_claimed_ed25519_key      = sessionData->sender_claimed_ed25519_key;\n        forward_key.forwarding_curve25519_key_chain = sessionData->forwarding_curve25519_key_chain;\n\n        send_megolm_key_to_device(req.sender, req.content.requesting_device_id, forward_key);\n    } catch (std::exception &e) {\n        nhlog::crypto()->error(\"Failed to forward session key: {}\", e.what());\n    }\n}\n\nvoid\nsend_megolm_key_to_device(const std::string &user_id,\n                          const std::string &device_id,\n                          const mtx::events::msg::ForwardedRoomKey &payload)\n{\n    mtx::events::DeviceEvent<mtx::events::msg::ForwardedRoomKey> room_key;\n    room_key.content = payload;\n    room_key.type    = mtx::events::EventType::ForwardedRoomKey;\n\n    std::map<std::string, std::vector<std::string>> targets;\n    targets[user_id] = {device_id};\n    send_encrypted_to_device_messages(targets, room_key);\n    nhlog::crypto()->debug(\"Forwarded key to {}:{}\", user_id, device_id);\n}\n\nDecryptionResult\ndecryptEvent(const MegolmSessionIndex &index,\n             const mtx::events::EncryptedEvent<mtx::events::msg::Encrypted> &event,\n             bool dont_write_db)\n{\n    try {\n        if (!cache::client()->inboundMegolmSessionExists(index)) {\n            return {DecryptionErrorCode::MissingSession, std::nullopt, std::nullopt};\n        }\n    } catch (const lmdb::error &e) {\n        return {DecryptionErrorCode::DbError, e.what(), std::nullopt};\n    }\n\n    std::string msg_str;\n    try {\n        auto session = cache::client()->getInboundMegolmSession(index);\n        if (!session) {\n            return {DecryptionErrorCode::MissingSession, std::nullopt, std::nullopt};\n        }\n\n        auto sessionData =\n          cache::client()->getMegolmSessionData(index).value_or(GroupSessionData{});\n\n        auto res = olm::client()->decrypt_group_message(session.get(), event.content.ciphertext);\n        msg_str  = std::string((char *)res.data.data(), res.data.size());\n\n        if (!event.event_id.empty() && event.event_id[0] == '$') {\n            auto oldIdx = sessionData.indices.find(res.message_index);\n            if (oldIdx != sessionData.indices.end()) {\n                if (oldIdx->second != event.event_id)\n                    return {DecryptionErrorCode::ReplayAttack, std::nullopt, std::nullopt};\n            } else if (!dont_write_db) {\n                sessionData.indices[res.message_index] = event.event_id;\n                cache::client()->saveInboundMegolmSession(index, std::move(session), sessionData);\n            }\n        }\n    } catch (const lmdb::error &e) {\n        return {DecryptionErrorCode::DbError, e.what(), std::nullopt};\n    } catch (const mtx::crypto::olm_exception &e) {\n        if (e.error_code() == mtx::crypto::OlmErrorCode::UNKNOWN_MESSAGE_INDEX)\n            return {DecryptionErrorCode::MissingSessionIndex, e.what(), std::nullopt};\n        return {DecryptionErrorCode::DecryptionFailed, e.what(), std::nullopt};\n    }\n\n    try {\n        // Add missing fields for the event.\n        nlohmann::json body      = nlohmann::json::parse(msg_str);\n        body[\"event_id\"]         = event.event_id;\n        body[\"sender\"]           = event.sender;\n        body[\"origin_server_ts\"] = event.origin_server_ts;\n        body[\"unsigned\"]         = event.unsigned_data;\n\n        mtx::events::collections::TimelineEvent te;\n        from_json(body, te);\n\n        // relations are unencrypted in content...\n        mtx::accessors::set_relations(te.data, std::move(event.content.relations));\n\n        return {DecryptionErrorCode::NoError, std::nullopt, std::move(te.data)};\n    } catch (std::exception &e) {\n        return {DecryptionErrorCode::ParsingFailed, e.what(), std::nullopt};\n    }\n}\n\ncrypto::Trust\ncalculate_trust(const std::string &user_id, const MegolmSessionIndex &index)\n{\n    auto status              = cache::client()->verificationStatus(user_id);\n    auto megolmData          = cache::client()->getMegolmSessionData(index);\n    crypto::Trust trustlevel = crypto::Trust::Unverified;\n\n    if (megolmData && megolmData->trusted &&\n        status.verified_device_keys.count(megolmData->sender_key))\n        trustlevel = status.verified_device_keys.at(megolmData->sender_key);\n\n    return trustlevel;\n}\n\n//! Send encrypted to device messages, targets is a map from userid to device ids or {} for all\n//! devices\nvoid\nsend_encrypted_to_device_messages(const std::map<std::string, std::vector<std::string>> targets,\n                                  const mtx::events::collections::DeviceEvents &event,\n                                  bool force_new_session)\n{\n    static QMap<QPair<std::string, std::string>, qint64> rateLimit;\n\n    nlohmann::json ev_json = std::visit([](const auto &e) { return nlohmann::json(e); }, event);\n\n    std::map<std::string, std::vector<std::string>> keysToQuery;\n    mtx::requests::ClaimKeys claims;\n    std::map<mtx::identifiers::User, std::map<std::string, mtx::events::msg::OlmEncrypted>>\n      messages;\n    std::map<std::string, std::map<std::string, DevicePublicKeys>> pks;\n\n    auto our_curve = olm::client()->identity_keys().curve25519;\n\n    for (const auto &[user, devices] : targets) {\n        auto deviceKeys = cache::client()->userKeys(user);\n\n        // no keys for user, query them\n        if (!deviceKeys) {\n            keysToQuery[user] = devices;\n            continue;\n        }\n\n        auto deviceTargets = devices;\n        if (devices.empty()) {\n            deviceTargets.clear();\n            deviceTargets.reserve(deviceKeys->device_keys.size());\n            for (const auto &[device, keys] : deviceKeys->device_keys) {\n                (void)keys;\n                deviceTargets.push_back(device);\n            }\n        }\n\n        for (const auto &device : deviceTargets) {\n            if (!deviceKeys->device_keys.count(device)) {\n                keysToQuery[user] = {};\n                break;\n            }\n\n            auto d = deviceKeys->device_keys.at(device);\n\n            if (!d.keys.count(\"curve25519:\" + device) || !d.keys.count(\"ed25519:\" + device)) {\n                nhlog::crypto()->warn(\"Skipping device {} since it has no keys!\", device);\n                continue;\n            }\n\n            auto device_curve = d.keys.at(\"curve25519:\" + device);\n            if (device_curve == our_curve) {\n                nhlog::crypto()->warn(\"Skipping our own device, since sending \"\n                                      \"ourselves olm messages makes no sense.\");\n                continue;\n            }\n\n            auto session = cache::getLatestOlmSession(device_curve);\n            if (!session || force_new_session) {\n                auto currentTime = QDateTime::currentSecsSinceEpoch();\n                if (rateLimit.value(QPair(user, device)) + 60 * 60 * 10 < currentTime) {\n                    claims.one_time_keys[user][device] = mtx::crypto::SIGNED_CURVE25519;\n                    pks[user][device].ed25519          = d.keys.at(\"ed25519:\" + device);\n                    pks[user][device].curve25519       = d.keys.at(\"curve25519:\" + device);\n\n                    rateLimit.insert(QPair(user, device), currentTime);\n                } else {\n                    nhlog::crypto()->warn(\"Not creating new session with {}:{} \"\n                                          \"because of rate limit\",\n                                          user,\n                                          device);\n                }\n                continue;\n            }\n\n            messages[mtx::identifiers::parse<mtx::identifiers::User>(user)][device] =\n              olm::client()\n                ->create_olm_encrypted_content(session->get(),\n                                               ev_json,\n                                               UserId(user),\n                                               d.keys.at(\"ed25519:\" + device),\n                                               device_curve)\n                .get<mtx::events::msg::OlmEncrypted>();\n\n            try {\n                nhlog::crypto()->debug(\"Updated olm session: {}\",\n                                       mtx::crypto::session_id(session->get()));\n                cache::saveOlmSession(d.keys.at(\"curve25519:\" + device),\n                                      std::move(*session),\n                                      QDateTime::currentMSecsSinceEpoch());\n            } catch (const lmdb::error &e) {\n                nhlog::db()->critical(\"failed to save outbound olm session: {}\", e.what());\n            } catch (const mtx::crypto::olm_exception &e) {\n                nhlog::crypto()->critical(\"failed to pickle outbound olm session: {}\", e.what());\n            }\n        }\n    }\n\n    if (!messages.empty())\n        http::client()->send_to_device<mtx::events::msg::OlmEncrypted>(\n          http::client()->generate_txn_id(), messages, [](mtx::http::RequestErr err) {\n              if (err) {\n                  nhlog::net()->warn(\"failed to send \"\n                                     \"send_to_device \"\n                                     \"message: {}\",\n                                     err->matrix_error.error);\n              }\n          });\n\n    auto BindPks = [ev_json](decltype(pks) pks_temp) {\n        return [pks = pks_temp, ev_json](const mtx::responses::ClaimKeys &res,\n                                         mtx::http::RequestErr) {\n            std::map<mtx::identifiers::User, std::map<std::string, mtx::events::msg::OlmEncrypted>>\n              messages;\n            for (const auto &[user_id, retrieved_devices] : res.one_time_keys) {\n                nhlog::net()->debug(\"claimed keys for {}\", user_id);\n                if (retrieved_devices.size() == 0) {\n                    nhlog::net()->debug(\"no one-time keys found for user_id: {}\", user_id);\n                    continue;\n                }\n\n                for (const auto &rd : retrieved_devices) {\n                    const auto device_id = rd.first;\n\n                    nhlog::net()->debug(\"{} : \\n {}\", device_id, rd.second.dump(2));\n\n                    if (rd.second.empty() || !rd.second.begin()->contains(\"key\")) {\n                        nhlog::net()->warn(\"Skipping device {} as it has no key.\", device_id);\n                        continue;\n                    }\n\n                    auto otk = rd.second.begin()->at(\"key\").get<std::string>();\n\n                    auto sign_key = pks.at(user_id).at(device_id).ed25519;\n                    auto id_key   = pks.at(user_id).at(device_id).curve25519;\n\n                    // Verify signature\n                    {\n                        auto signedKey = *rd.second.begin();\n                        std::string signature =\n                          signedKey[\"signatures\"][user_id].value(\"ed25519:\" + device_id, \"\");\n\n                        if (signature.empty() || !mtx::crypto::ed25519_verify_signature(\n                                                   sign_key, signedKey, signature)) {\n                            nhlog::net()->warn(\"Skipping device {} as its one time key \"\n                                               \"has an invalid signature.\",\n                                               device_id);\n                            continue;\n                        }\n                    }\n\n                    auto session = olm::client()->create_outbound_session(id_key, otk);\n\n                    messages[mtx::identifiers::parse<mtx::identifiers::User>(user_id)][device_id] =\n                      olm::client()\n                        ->create_olm_encrypted_content(\n                          session.get(), ev_json, UserId(user_id), sign_key, id_key)\n                        .get<mtx::events::msg::OlmEncrypted>();\n\n                    try {\n                        nhlog::crypto()->debug(\"Updated olm session: {}\",\n                                               mtx::crypto::session_id(session.get()));\n                        cache::saveOlmSession(\n                          id_key, std::move(session), QDateTime::currentMSecsSinceEpoch());\n                    } catch (const lmdb::error &e) {\n                        nhlog::db()->critical(\"failed to save outbound olm session: {}\", e.what());\n                    } catch (const mtx::crypto::olm_exception &e) {\n                        nhlog::crypto()->critical(\"failed to pickle outbound olm session: {}\",\n                                                  e.what());\n                    }\n                }\n                nhlog::net()->info(\"send_to_device: {}\", user_id);\n            }\n\n            if (!messages.empty())\n                http::client()->send_to_device<mtx::events::msg::OlmEncrypted>(\n                  http::client()->generate_txn_id(), messages, [](mtx::http::RequestErr err) {\n                      if (err) {\n                          nhlog::net()->warn(\"failed to send \"\n                                             \"send_to_device \"\n                                             \"message: {}\",\n                                             err->matrix_error.error);\n                      }\n                  });\n        };\n    };\n\n    if (!claims.one_time_keys.empty())\n        http::client()->claim_keys(claims, BindPks(pks));\n\n    if (!keysToQuery.empty()) {\n        mtx::requests::QueryKeys req;\n        req.device_keys = keysToQuery;\n        http::client()->query_keys(\n          req,\n          [ev_json, BindPks, our_curve](const mtx::responses::QueryKeys &res,\n                                        mtx::http::RequestErr err) {\n              if (err) {\n                  nhlog::net()->warn(\"failed to query device keys: {} {}\",\n                                     err->matrix_error.error,\n                                     static_cast<int>(err->status_code));\n                  return;\n              }\n\n              nhlog::net()->info(\"queried keys\");\n\n              cache::client()->updateUserKeys(cache::nextBatchToken(), res);\n\n              mtx::requests::ClaimKeys claim_keys;\n\n              std::map<std::string, std::map<std::string, DevicePublicKeys>> deviceKeys;\n\n              for (const auto &user : res.device_keys) {\n                  for (const auto &dev : user.second) {\n                      const auto user_id   = ::UserId(dev.second.user_id);\n                      const auto device_id = DeviceId(dev.second.device_id);\n\n                      if (user_id.get() == http::client()->user_id().to_string() &&\n                          device_id.get() == http::client()->device_id())\n                          continue;\n\n                      const auto device_keys = dev.second.keys;\n                      const auto curveKey    = \"curve25519:\" + device_id.get();\n                      const auto edKey       = \"ed25519:\" + device_id.get();\n\n                      if ((device_keys.find(curveKey) == device_keys.end()) ||\n                          (device_keys.find(edKey) == device_keys.end())) {\n                          nhlog::net()->debug(\"ignoring malformed keys for device {}\",\n                                              device_id.get());\n                          continue;\n                      }\n\n                      DevicePublicKeys pks;\n                      pks.ed25519    = device_keys.at(edKey);\n                      pks.curve25519 = device_keys.at(curveKey);\n\n                      if (pks.curve25519 == our_curve) {\n                          nhlog::crypto()->warn(\"Skipping our own device, since sending \"\n                                                \"ourselves olm messages makes no sense.\");\n                          continue;\n                      }\n\n                      try {\n                          if (!mtx::crypto::verify_identity_signature(\n                                dev.second, device_id, user_id)) {\n                              nhlog::crypto()->warn(\"failed to verify identity keys: {}\",\n                                                    nlohmann::json(dev.second).dump(2));\n                              continue;\n                          }\n                      } catch (const nlohmann::json::exception &e) {\n                          nhlog::crypto()->warn(\"failed to parse device key json: {}\", e.what());\n                          continue;\n                      } catch (const mtx::crypto::olm_exception &e) {\n                          nhlog::crypto()->warn(\"failed to verify device key json: {}\", e.what());\n                          continue;\n                      }\n\n                      auto currentTime = QDateTime::currentSecsSinceEpoch();\n                      if (rateLimit.value(QPair(user.first, device_id.get())) + 60 * 60 * 10 <\n                          currentTime) {\n                          deviceKeys[user_id].emplace(device_id, pks);\n                          claim_keys.one_time_keys[user.first][device_id] =\n                            mtx::crypto::SIGNED_CURVE25519;\n\n                          rateLimit.insert(QPair(user.first, device_id.get()), currentTime);\n                      } else {\n                          nhlog::crypto()->warn(\"Not creating new session with {}:{} \"\n                                                \"because of rate limit\",\n                                                user.first,\n                                                device_id.get());\n                          continue;\n                      }\n\n                      nhlog::net()->info(\"{}\", device_id.get());\n                      nhlog::net()->info(\"  curve25519 {}\", pks.curve25519);\n                      nhlog::net()->info(\"  ed25519 {}\", pks.ed25519);\n                  }\n              }\n\n              if (!claim_keys.one_time_keys.empty())\n                  http::client()->claim_keys(claim_keys, BindPks(deviceKeys));\n          });\n    }\n}\n\nvoid\nrequest_cross_signing_keys()\n{\n    mtx::events::msg::SecretRequest secretRequest{};\n    secretRequest.action               = mtx::events::msg::RequestAction::Request;\n    secretRequest.requesting_device_id = http::client()->device_id();\n\n    auto local_user = http::client()->user_id();\n\n    auto verificationStatus = cache::verificationStatus(local_user.to_string());\n\n    if (!verificationStatus)\n        return;\n\n    auto request = [&](std::string secretName) {\n        secretRequest.name       = secretName;\n        secretRequest.request_id = \"ss.\" + http::client()->generate_txn_id();\n\n        request_id_to_secret_name[secretRequest.request_id] = secretRequest.name;\n\n        std::map<mtx::identifiers::User, std::map<std::string, mtx::events::msg::SecretRequest>>\n          body;\n\n        for (const auto &dev : verificationStatus->verified_devices) {\n            if (dev != secretRequest.requesting_device_id)\n                body[local_user][dev] = secretRequest;\n        }\n\n        http::client()->send_to_device<mtx::events::msg::SecretRequest>(\n          http::client()->generate_txn_id(),\n          body,\n          [request_id = secretRequest.request_id, secretName](mtx::http::RequestErr err) {\n              if (err) {\n                  nhlog::net()->error(\"Failed to send request for secrect '{}'\", secretName);\n                  // Cancel request on UI thread\n                  QTimer::singleShot(1, cache::client(), [request_id]() {\n                      request_id_to_secret_name.erase(request_id);\n                  });\n                  return;\n              }\n          });\n\n        for (const auto &dev : verificationStatus->verified_devices) {\n            if (dev != secretRequest.requesting_device_id)\n                body[local_user][dev].action = mtx::events::msg::RequestAction::Cancellation;\n        }\n\n        // timeout after 15 min\n        QTimer::singleShot(15 * 60 * 1000, ChatPage::instance(), [secretRequest, body]() {\n            if (request_id_to_secret_name.count(secretRequest.request_id)) {\n                request_id_to_secret_name.erase(secretRequest.request_id);\n                http::client()->send_to_device<mtx::events::msg::SecretRequest>(\n                  http::client()->generate_txn_id(),\n                  body,\n                  [secretRequest](mtx::http::RequestErr err) {\n                      if (err) {\n                          nhlog::net()->error(\"Failed to cancel request for secrect '{}'\",\n                                              secretRequest.name);\n                          return;\n                      }\n                  });\n            }\n        });\n    };\n\n    request(mtx::secret_storage::secrets::cross_signing_master);\n    request(mtx::secret_storage::secrets::cross_signing_self_signing);\n    request(mtx::secret_storage::secrets::cross_signing_user_signing);\n    request(mtx::secret_storage::secrets::megolm_backup_v1);\n}\n\nnamespace {\nvoid\nunlock_secrets(const std::string &key,\n               const std::map<std::string, mtx::secret_storage::AesHmacSha2EncryptedData> &secrets)\n{\n    http::client()->secret_storage_key(\n      key,\n      [secrets](mtx::secret_storage::AesHmacSha2KeyDescription keyDesc, mtx::http::RequestErr err) {\n          if (err) {\n              nhlog::net()->error(\"Failed to download secret storage key\");\n              return;\n          }\n\n          emit ChatPage::instance()->downloadedSecrets(keyDesc, secrets);\n      });\n}\n}\n\nvoid\ndownload_cross_signing_keys()\n{\n    using namespace mtx::secret_storage;\n    http::client()->secret_storage_secret(\n      secrets::megolm_backup_v1, [](Secret secret, mtx::http::RequestErr err) {\n          std::optional<Secret> backup_key;\n          if (!err)\n              backup_key = secret;\n\n          http::client()->secret_storage_secret(\n            secrets::cross_signing_master, [backup_key](Secret secret, mtx::http::RequestErr err) {\n                std::optional<Secret> master_key;\n                if (!err)\n                    master_key = secret;\n\n                http::client()->secret_storage_secret(\n                  secrets::cross_signing_self_signing,\n                  [backup_key, master_key](Secret secret, mtx::http::RequestErr err) {\n                      std::optional<Secret> self_signing_key;\n                      if (!err)\n                          self_signing_key = secret;\n\n                      http::client()->secret_storage_secret(\n                        secrets::cross_signing_user_signing,\n                        [backup_key, self_signing_key, master_key](Secret secret,\n                                                                   mtx::http::RequestErr err) {\n                            std::optional<Secret> user_signing_key;\n                            if (!err)\n                                user_signing_key = secret;\n\n                            std::map<std::string, std::map<std::string, AesHmacSha2EncryptedData>>\n                              secrets;\n\n                            if (backup_key && !backup_key->encrypted.empty())\n                                secrets[backup_key->encrypted.begin()->first]\n                                       [secrets::megolm_backup_v1] =\n                                         backup_key->encrypted.begin()->second;\n\n                            if (master_key && !master_key->encrypted.empty())\n                                secrets[master_key->encrypted.begin()->first]\n                                       [secrets::cross_signing_master] =\n                                         master_key->encrypted.begin()->second;\n\n                            if (self_signing_key && !self_signing_key->encrypted.empty())\n                                secrets[self_signing_key->encrypted.begin()->first]\n                                       [secrets::cross_signing_self_signing] =\n                                         self_signing_key->encrypted.begin()->second;\n\n                            if (user_signing_key && !user_signing_key->encrypted.empty())\n                                secrets[user_signing_key->encrypted.begin()->first]\n                                       [secrets::cross_signing_user_signing] =\n                                         user_signing_key->encrypted.begin()->second;\n\n                            for (const auto &[key, secret_] : secrets)\n                                unlock_secrets(key, secret_);\n                        });\n                  });\n            });\n      });\n}\n\n} // namespace olm\n"], "filenames": ["src/encryption/Olm.cpp"], "buggy_code_start_loc": [345], "buggy_code_end_loc": [396], "fixing_code_start_loc": [345], "fixing_code_end_loc": [406], "type": "CWE-287", "message": "nheko is a desktop client for the Matrix communication application. All versions below 0.10.2 are vulnerable homeservers inserting malicious secrets, which could lead to man-in-the-middle attacks. Users can upgrade to version 0.10.2 to protect against this issue. As a workaround, one may apply the patch manually, avoid doing verifications of one's own devices, and/or avoid pressing the request button in the settings menu.", "other": {"cve": {"id": "CVE-2022-39264", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-28T22:15:14.633", "lastModified": "2023-03-03T19:25:14.303", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "nheko is a desktop client for the Matrix communication application. All versions below 0.10.2 are vulnerable homeservers inserting malicious secrets, which could lead to man-in-the-middle attacks. Users can upgrade to version 0.10.2 to protect against this issue. As a workaround, one may apply the patch manually, avoid doing verifications of one's own devices, and/or avoid pressing the request button in the settings menu."}, {"lang": "es", "value": "nheko es un cliente de escritorio para la aplicaci\u00f3n de comunicaci\u00f3n Matrix. Todas las versiones anteriores a 0.10.2 son vulnerables a una inserci\u00f3n de secretos maliciosos por parte de los servidores dom\u00e9sticos, lo que podr\u00eda conllevar a ataques de tipo man-in-the-middle. Los usuarios pueden actualizar a versi\u00f3n 0.10.2 para protegerse de este problema. Como mitigaci\u00f3n, puede aplicarse el parche manualmente, evitar hacer verificaciones de los propios dispositivos y/o evitar pulsar el bot\u00f3n de petici\u00f3n en el men\u00fa de configuraci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}, {"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nheko-reborn:nheko:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.10.2", "matchCriteriaId": "065A6B94-C716-4629-9F8A-C50C012160C6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/Nheko-Reborn/nheko/commit/67bee15a389f9b8a9f6c3a340558d1e2319e7199", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Nheko-Reborn/nheko/releases/tag/v0.10.2", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/Nheko-Reborn/nheko/security/advisories/GHSA-8jcp-8jq4-5mm7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TA6A5ADUVAYKD3ZFLF2JPZOTIOFJOEU7/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YBOL6OOQGPZD2RLYT4EHAWTFXNIHLYEN/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Nheko-Reborn/nheko/commit/67bee15a389f9b8a9f6c3a340558d1e2319e7199"}}