{"buggy_code": ["STRUTS\n======\n\n![build status](https://circleci.com/gh/kawasima/struts1-forever.png?style=shield&circle-token=8f99c0e6c923ca570acda8c3640446fdacad2a47)\n\nThis struts1's fork is for maintenance to fix the vulnerabilities.\n\n$Id: README,v 1.18 2003/12/10 01:04:10 husted Exp $\n\nIntroduction (Original)\n------------------------\n\nThis subproject contains the source code for the \"Struts\" application support\npackage, consisting of the following major components:\n\n- Controller servlet with action mapping technology, implementing the Model-\n  View-Controller (MVC) design pattern for web applications commonly called\n  \"Model 2\", with a servlet as the \"front component\".\n\n- Comprehensive custom tag library for building internationalized JSP pages\n  that have HTML forms which interact with JavaBeans that are managed\n  automatically by the controller servlet.\n\nFor help with installing and using Struts, see the Struts User Guide.\n\n", "/*\n * $Id$ \n *\n * Copyright 2000-2005 The Apache Software Foundation.\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.struts.action;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.MissingResourceException;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.UnavailableException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.sql.DataSource;\n\nimport org.apache.commons.beanutils.BeanUtils;\nimport org.apache.commons.beanutils.ConvertUtils;\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.commons.beanutils.SuppressPropertiesBeanIntrospector;\nimport org.apache.commons.beanutils.converters.BigDecimalConverter;\nimport org.apache.commons.beanutils.converters.BigIntegerConverter;\nimport org.apache.commons.beanutils.converters.BooleanConverter;\nimport org.apache.commons.beanutils.converters.ByteConverter;\nimport org.apache.commons.beanutils.converters.CharacterConverter;\nimport org.apache.commons.beanutils.converters.DoubleConverter;\nimport org.apache.commons.beanutils.converters.FloatConverter;\nimport org.apache.commons.beanutils.converters.IntegerConverter;\nimport org.apache.commons.beanutils.converters.LongConverter;\nimport org.apache.commons.beanutils.converters.ShortConverter;\nimport org.apache.commons.collections.FastHashMap;\nimport org.apache.commons.digester.Digester;\nimport org.apache.commons.digester.RuleSet;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.struts.Globals;\nimport org.apache.struts.config.ConfigRuleSet;\nimport org.apache.struts.config.DataSourceConfig;\nimport org.apache.struts.config.FormBeanConfig;\nimport org.apache.struts.config.MessageResourcesConfig;\nimport org.apache.struts.config.ModuleConfig;\nimport org.apache.struts.config.ModuleConfigFactory;\nimport org.apache.struts.config.PlugInConfig;\nimport org.apache.struts.util.MessageResources;\nimport org.apache.struts.util.MessageResourcesFactory;\nimport org.apache.struts.util.ModuleUtils;\nimport org.apache.struts.util.RequestUtils;\nimport org.apache.struts.util.ServletContextWriter;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * <p><strong>ActionServlet</strong> provides the \"controller\" in the\n * Model-View-Controller (MVC) design pattern for web applications that is\n * commonly known as \"Model 2\".  This nomenclature originated with a\n * description in the JavaServerPages Specification, version 0.92, and has\n * persisted ever since (in the absence of a better name).</p>\n *\n * <p>Generally, a \"Model 2\" application is architected as follows:</p>\n * <ul>\n * <li>The user interface will generally be created with server pages, which\n *     will not themselves contain any business logic. These pages represent\n *     the \"view\" component of an MVC architecture.</li>\n * <li>Forms and hyperlinks in the user interface that require business logic\n *     to be executed will be submitted to a request URI that is mapped to this\n *     servlet.</li>\n * <li>There can be <b>one</b> instance of this servlet class,\n *     which receives and processes all requests that change the state of\n *     a user's interaction with the application.  The servlet delegates the\n *     handling of a request to a {@link RequestProcessor} object. This component\n *     represents the \"controller\" component of an MVC architecture.</li>\n * <li>The <code>RequestProcessor</code> selects and invokes an {@link Action} class to perform\n *     the requested business logic, or delegates the response to another resource.</li>\n * <li>The <code>Action</code> classes can manipulate the state of the application's\n *     interaction with the user, typically by creating or modifying JavaBeans\n *     that are stored as request or session attributes (depending on how long\n *     they need to be available). Such JavaBeans represent the \"model\"\n *     component of an MVC architecture.</li>\n * <li>Instead of producing the next page of the user interface directly,\n *     <code>Action</code> classes generally return an {@link ActionForward} to indicate\n *     which resource should handle the response. If the <code>Action</code>\n *     does not return null, the <code>RequestProcessor</code> forwards or\n *     redirects to the specified resource (by utilizing\n *     <code>RequestDispatcher.forward</code> or <code>Response.sendRedirect</code>)\n *     so as to produce the next page of the user interface.</li>\n * </ul>\n *\n * <p>The standard version of <code>RequestsProcessor</code> implements the\n *    following logic for each incoming HTTP request. You can override\n *    some or all of this functionality by subclassing this object and\n *    implementing your own version of the processing.</p>\n * <ul>\n * <li>Identify, from the incoming request URI, the substring that will be\n *     used to select an action procedure.</li>\n * <li>Use this substring to map to the Java class name of the corresponding\n *     action class (an implementation of the <code>Action</code> interface).\n *     </li>\n * <li>If this is the first request for a particular <code>Action</code> class,\n *     instantiate an instance of that class and cache it for future use.</li>\n * <li>Optionally populate the properties of an <code>ActionForm</code> bean\n *     associated with this mapping.</li>\n * <li>Call the <code>execute</code> method of this <code>Action</code> class, passing\n *     on a reference to the mapping that was used, the relevant form-bean\n *     (if any), and the request and the response that were passed to the\n *     controller by the servlet container (thereby providing access to any\n *     specialized properties of the mapping itself as well as to the\n *     ServletContext).\n *     </li>\n * </ul>\n *\n * <p>The standard version of <code>ActionServlet</code> is configured based\n * on the following servlet initialization parameters, which you will specify\n * in the web application deployment descriptor (<code>/WEB-INF/web.xml</code>)\n * for your application.  Subclasses that specialize this servlet are free to\n * define additional initialization parameters. </p>\n * <ul>\n * <li><strong>config</strong> - Comma-separated list of context-relative\n *     path(s) to the XML resource(s) containing the configuration information\n *     for the default module.  (Multiple files support since Struts 1.1)\n *     [/WEB-INF/struts-config.xml].</li>\n * <li><strong>config/${module}</strong> - Comma-separated list of\n *     Context-relative path(s) to the XML resource(s)\n *     containing the configuration information for the module that\n *     will use the specified prefix (/${module}). This can be repeated as many\n *     times as required for multiple modules. (Since Struts 1.1)</li>\n * <li><strong>configFactory</strong> - The Java class name of the\n *     <code>ModuleConfigFactory</code> used to create the implementation of the\n *     <code>ModuleConfig</code> interface.\n *     [org.apache.struts.config.impl.DefaultModuleConfigFactory]\n * </li>\n * <li><strong>convertNull</strong> - Force simulation of the Struts 1.0 behavior\n *     when populating forms. If set to true, the numeric Java wrapper class types\n *     (like <code>java.lang.Integer</code>) will default to null (rather than 0).\n *     (Since Struts 1.1) [false] </li>\n * <li><strong>rulesets</strong> - Comma-delimited list of fully qualified\n *     classnames of additional <code>org.apache.commons.digester.RuleSet</code>\n *     instances that should be added to the <code>Digester</code> that will\n *     be processing <code>struts-config.xml</code> files.  By default, only\n *     the <code>RuleSet</code> for the standard configuration elements is\n *     loaded.  (Since Struts 1.1)</li>\n * <li><strong>validating</strong> - Should we use a validating XML parser to\n *     process the configuration file (strongly recommended)? [true]</li>\n * </ul>\n *\n * @version $Rev$ $Date$\n */\npublic class ActionServlet extends HttpServlet {\n\n\n    // ----------------------------------------------------- Instance Variables\n\n\n    /**\n     * <p>Comma-separated list of context-relative path(s) to our configuration\n     * resource(s) for the default module.</p>\n     */\n    protected String config = \"/WEB-INF/struts-config.xml\";\n\n\n    /**\n     * <p>The Digester used to produce ModuleConfig objects from a\n     * Struts configuration file.</p>\n     *\n     * @since Struts 1.1\n     */\n    protected Digester configDigester = null;\n\n\n    /**\n     * <p>The flag to request backwards-compatible conversions for form bean\n     * properties of the Java wrapper class types.</p>\n     *\n     * @since Struts 1.1\n     */\n    protected boolean convertNull = false;\n\n\n    /**\n     * <p>The JDBC data sources that has been configured for this module,\n     * if any, keyed by the servlet context attribute under which they are\n     * stored.</p>\n     */\n    protected FastHashMap dataSources = new FastHashMap();\n\n\n    /**\n     * <p>The resources object for our internal resources.</p>\n     */\n    protected MessageResources internal = null;\n\n\n    /**\n     * <p>The Java base name of our internal resources.</p>\n     * @since Struts 1.1\n     */\n    protected String internalName = \"org.apache.struts.action.ActionResources\";\n\n\n    /**\n     * <p>Commons Logging instance.</p>\n     *\n     * @since Struts 1.1\n     */\n    protected static Log log = LogFactory.getLog(ActionServlet.class);\n\n\n    /**\n     * <p>The <code>RequestProcessor</code> instance we will use to process\n     * all incoming requests.</p>\n     *\n     * @since Struts 1.1\n     */\n    protected RequestProcessor processor = null;\n\n\n    /**\n     * <p>The set of public identifiers, and corresponding resource names, for\n     * the versions of the configuration file DTDs that we know about.  There\n     * <strong>MUST</strong> be an even number of Strings in this list!</p>\n     */\n    protected String registrations[] = {\n        \"-//Apache Software Foundation//DTD Struts Configuration 1.0//EN\",\n        \"/org/apache/struts/resources/struts-config_1_0.dtd\",\n        \"-//Apache Software Foundation//DTD Struts Configuration 1.1//EN\",\n        \"/org/apache/struts/resources/struts-config_1_1.dtd\",\n        \"-//Apache Software Foundation//DTD Struts Configuration 1.2//EN\",\n        \"/org/apache/struts/resources/struts-config_1_2.dtd\",\n        \"-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN\",\n        \"/org/apache/struts/resources/web-app_2_2.dtd\",\n        \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\",\n        \"/org/apache/struts/resources/web-app_2_3.dtd\"\n    };\n\n\n    /**\n     * <p>The URL pattern to which we are mapped in our web application\n     * deployment descriptor.</p>\n     */\n    protected String servletMapping = null; // :FIXME: - multiples?\n\n\n    /**\n     * <p>The servlet name under which we are registered in our web application\n     * deployment descriptor.</p>\n     */\n    protected String servletName = null;\n\n\n    // ---------------------------------------------------- HttpServlet Methods\n\n\n    /**\n     * <p>Gracefully shut down this controller servlet, releasing any resources\n     * that were allocated at initialization.</p>\n     */\n    public void destroy() {\n\n        if (log.isDebugEnabled()) {\n            log.debug(internal.getMessage(\"finalizing\"));\n        }\n\n        destroyModules();\n        destroyInternal();\n        getServletContext().removeAttribute(Globals.ACTION_SERVLET_KEY);\n\n        // Release our LogFactory and Log instances (if any)\n        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        if (classLoader == null) {\n            classLoader = ActionServlet.class.getClassLoader();\n        }\n        try {\n            LogFactory.release(classLoader);\n        } catch (Throwable t) {\n            ; // Servlet container doesn't have the latest version\n            ; // of commons-logging-api.jar installed\n\n            // :FIXME: Why is this dependent on the container's version of commons-logging?\n            // Shouldn't this depend on the version packaged with Struts?\n            /*\n              Reason: LogFactory.release(classLoader); was added as\n              an attempt to investigate the OutOfMemory error reported on Bugzilla #14042.\n              It was committed for version 1.136 by craigmcc\n            */\n        }\n\n        PropertyUtils.clearDescriptors();\n\n    }\n\n\n    /**\n     * <p>Initialize this servlet.  Most of the processing has been factored into\n     * support methods so that you can override particular functionality at a\n     * fairly granular level.</p>\n     *\n     * @exception ServletException if we cannot configure ourselves correctly\n     */\n    public void init() throws ServletException {\n\n        // Wraps the entire initialization in a try/catch to better handle\n        // unexpected exceptions and errors to provide better feedback\n        // to the developer\n        try {\n            initInternal();\n            initOther();\n            initServlet();\n    \n            getServletContext().setAttribute(Globals.ACTION_SERVLET_KEY, this);\n            initModuleConfigFactory();\n            // Initialize modules as needed\n            ModuleConfig moduleConfig = initModuleConfig(\"\", config);\n            initModuleMessageResources(moduleConfig);\n            initModuleDataSources(moduleConfig);\n            initModulePlugIns(moduleConfig);\n            moduleConfig.freeze();\n    \n            Enumeration names = getServletConfig().getInitParameterNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                if (!name.startsWith(\"config/\")) {\n                    continue;\n                }\n                String prefix = name.substring(6);\n                moduleConfig = initModuleConfig\n                    (prefix, getServletConfig().getInitParameter(name));\n                initModuleMessageResources(moduleConfig);\n                initModuleDataSources(moduleConfig);\n                initModulePlugIns(moduleConfig);\n                moduleConfig.freeze();\n            }\n    \n            this.initModulePrefixes(this.getServletContext());\n    \n            this.destroyConfigDigester();\n        } catch (UnavailableException ex) {\n            throw ex;\n        } catch (Throwable t) {\n\n            // The follow error message is not retrieved from internal message\n            // resources as they may not have been able to have been \n            // initialized\n            log.error(\"Unable to initialize Struts ActionServlet due to an \"\n                + \"unexpected exception or error thrown, so marking the \"\n                + \"servlet as unavailable.  Most likely, this is due to an \"\n                + \"incorrect or missing library dependency.\", t);\n            throw new UnavailableException(t.getMessage());\n        }    \n    }\n\n    /**\n     * <p>Saves a String[] of module prefixes in the ServletContext under\n     * Globals.MODULE_PREFIXES_KEY.  <strong>NOTE</strong> -\n     * the \"\" prefix for the default module is not included in this list.</p>\n     *\n     * @param context The servlet context.\n     * @since Struts 1.2\n     */\n    protected void initModulePrefixes(ServletContext context) {\n        ArrayList prefixList = new ArrayList();\n\n        Enumeration names = context.getAttributeNames();\n        while (names.hasMoreElements()) {\n            String name = (String) names.nextElement();\n            if (!name.startsWith(Globals.MODULE_KEY)) {\n                continue;\n            }\n\n            String prefix = name.substring(Globals.MODULE_KEY.length());\n            if (prefix.length() > 0) {\n                prefixList.add(prefix);\n            }\n        }\n\n        String[] prefixes = (String[]) prefixList.toArray(new String[prefixList.size()]);\n        context.setAttribute(Globals.MODULE_PREFIXES_KEY, prefixes);\n    }\n\n\n    /**\n     * <p>Process an HTTP \"GET\" request.</p>\n     *\n     * @param request The servlet request we are processing\n     * @param response The servlet response we are creating\n     *\n     * @exception IOException if an input/output error occurs\n     * @exception ServletException if a servlet exception occurs\n     */\n    public void doGet(HttpServletRequest request,\n              HttpServletResponse response)\n        throws IOException, ServletException {\n\n        process(request, response);\n\n    }\n\n\n    /**\n     * <p>Process an HTTP \"POST\" request.</p>\n     *\n     * @param request The servlet request we are processing\n     * @param response The servlet response we are creating\n     *\n     * @exception IOException if an input/output error occurs\n     * @exception ServletException if a servlet exception occurs\n     */\n    public void doPost(HttpServletRequest request,\n               HttpServletResponse response)\n        throws IOException, ServletException {\n\n        process(request, response);\n\n    }\n\n\n    // --------------------------------------------------------- Public Methods\n\n\n    /**\n     * <p>Remember a servlet mapping from our web application deployment\n     * descriptor, if it is for this servlet.</p>\n     *\n     * @param servletName The name of the servlet being mapped\n     * @param urlPattern The URL pattern to which this servlet is mapped\n     */\n    public void addServletMapping(String servletName, String urlPattern) {\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Process servletName=\" + servletName +\n                      \", urlPattern=\" + urlPattern);\n        }\n        if (servletName == null) {\n            return;\n        }\n        if (servletName.equals(this.servletName)) {\n            this.servletMapping = urlPattern;\n        }\n\n    }\n\n\n    /**\n     * <p>Return the <code>MessageResources</code> instance containing our\n     * internal message strings.</p>\n     *\n     * @since Struts 1.1\n     */\n    public MessageResources getInternal() {\n\n        return (this.internal);\n\n    }\n\n\n    // ------------------------------------------------------ Protected Methods\n\n    /**\n     * <p>Gracefully terminate use of any modules associated with this\n     * application (if any).</p>\n     *\n     * @since Struts 1.1\n     */\n    protected void destroyModules() {\n\n        ArrayList values = new ArrayList();\n        Enumeration names = getServletContext().getAttributeNames();\n        while (names.hasMoreElements()) {\n            values.add(names.nextElement());\n        }\n\n        Iterator keys = values.iterator();\n        while (keys.hasNext()) {\n            String name = (String) keys.next();\n            Object value = getServletContext().getAttribute(name);\n\n            if (!(value instanceof ModuleConfig)) {\n                continue;\n            }\n\n            ModuleConfig config = (ModuleConfig) value;\n\n            if (this.getProcessorForModule(config) != null) {\n                this.getProcessorForModule(config).destroy();\n            }\n\n            getServletContext().removeAttribute(name);\n\n            PlugIn plugIns[] =\n                (PlugIn[]) getServletContext().getAttribute(\n                    Globals.PLUG_INS_KEY + config.getPrefix());\n\n            if (plugIns != null) {\n                for (int i = 0; i < plugIns.length; i++) {\n                    int j = plugIns.length - (i + 1);\n                    plugIns[j].destroy();\n                }\n\n                getServletContext().removeAttribute(\n                    Globals.PLUG_INS_KEY + config.getPrefix());\n            }\n\n        }\n\n    }\n\n\n    /**\n     * <p>Gracefully release any configDigester instance that we have created.</p>\n     *\n     * @since Struts 1.1\n     */\n    protected void destroyConfigDigester() {\n\n        configDigester = null;\n\n    }\n\n\n    /**\n     * <p>Gracefully terminate use of the internal MessageResources.</p>\n     */\n    protected void destroyInternal() {\n\n        internal = null;\n\n    }\n\n    /**\n     * <p>Return the module configuration object for the currently selected\n     * module.</p>\n     *\n     * @param request The servlet request we are processing\n     * @since Struts 1.1\n     */\n    protected ModuleConfig getModuleConfig\n        (HttpServletRequest request) {\n\n        ModuleConfig config = (ModuleConfig)\n            request.getAttribute(Globals.MODULE_KEY);\n        if (config == null) {\n            config = (ModuleConfig)\n                getServletContext().getAttribute(Globals.MODULE_KEY);\n        }\n        return (config);\n\n    }\n\n\n    /**\n     * <p>Look up and return the {@link RequestProcessor} responsible for the\n     * specified module, creating a new one if necessary.</p>\n     *\n     * @param config The module configuration for which to\n     *  acquire and return a RequestProcessor.\n     *\n     * @exception ServletException if we cannot instantiate a RequestProcessor\n     *  instance\n     * @since Struts 1.1\n     */\n    protected synchronized RequestProcessor getRequestProcessor(ModuleConfig config)\n        throws ServletException {\n\n        // :FIXME: Document UnavailableException?\n\n        RequestProcessor processor = this.getProcessorForModule(config);\n\n        if (processor == null) {\n            try {\n                processor =\n                    (RequestProcessor) RequestUtils.applicationInstance(\n                        config.getControllerConfig().getProcessorClass());\n\n            } catch (Exception e) {\n                throw new UnavailableException(\n                    \"Cannot initialize RequestProcessor of class \"\n                        + config.getControllerConfig().getProcessorClass()\n                        + \": \"\n                        + e);\n            }\n\n            processor.init(this, config);\n\n            String key = Globals.REQUEST_PROCESSOR_KEY + config.getPrefix();\n            getServletContext().setAttribute(key, processor);\n\n        }\n\n        return (processor);\n\n    }\n\n\n    /**\n     * <p>Returns the RequestProcessor for the given module or null if one does not\n     * exist.  This method will not create a RequestProcessor.</p>\n     *\n     * @param config The ModuleConfig.\n     */\n    private RequestProcessor getProcessorForModule(ModuleConfig config) {\n        String key = Globals.REQUEST_PROCESSOR_KEY + config.getPrefix();\n        return (RequestProcessor) getServletContext().getAttribute(key);\n    }\n\n\n    /**\n     * <p>Initialize the factory used to create the module configuration.</p>\n     * @since Struts 1.2\n     */\n    protected void initModuleConfigFactory(){\n        String configFactory = getServletConfig().getInitParameter(\"configFactory\");\n        if (configFactory != null) {\n            ModuleConfigFactory.setFactoryClass(configFactory);\n        }\n    }\n\n\n    /**\n     * <p>Initialize the module configuration information for the\n     * specified module.</p>\n     *\n     * @param prefix Module prefix for this module\n     * @param paths Comma-separated list of context-relative resource path(s)\n     *  for this modules's configuration resource(s)\n     *\n     * @exception ServletException if initialization cannot be performed\n     * @since Struts 1.1\n     */\n    protected ModuleConfig initModuleConfig(String prefix, String paths)\n        throws ServletException {\n\n        // :FIXME: Document UnavailableException? (Doesn't actually throw anything)\n\n        if (log.isDebugEnabled()) {\n            log.debug(\n                \"Initializing module path '\"\n                    + prefix\n                    + \"' configuration from '\"\n                    + paths\n                    + \"'\");\n        }\n\n        // Parse the configuration for this module\n        ModuleConfigFactory factoryObject = ModuleConfigFactory.createFactory();\n        ModuleConfig config = factoryObject.createModuleConfig(prefix);\n\n        // Configure the Digester instance we will use\n        Digester digester = initConfigDigester();\n\n        // Process each specified resource path\n        while (paths.length() > 0) {\n            digester.push(config);\n            String path = null;\n            int comma = paths.indexOf(',');\n            if (comma >= 0) {\n                path = paths.substring(0, comma).trim();\n                paths = paths.substring(comma + 1);\n            } else {\n                path = paths.trim();\n                paths = \"\";\n            }\n\n            if (path.length() < 1) {\n                break;\n            }\n\n            this.parseModuleConfigFile(digester, path);\n        }\n\n        getServletContext().setAttribute(\n            Globals.MODULE_KEY + config.getPrefix(),\n            config);\n\n        // Force creation and registration of DynaActionFormClass instances\n        // for all dynamic form beans we wil be using\n        FormBeanConfig fbs[] = config.findFormBeanConfigs();\n        for (int i = 0; i < fbs.length; i++) {\n            if (fbs[i].getDynamic()) {\n                fbs[i].getDynaActionFormClass();\n            }\n        }\n\n        return config;\n    }\n\n\n    /**\n     * <p>Parses one module config file.</p>\n     *\n     * @param digester Digester instance that does the parsing\n     * @param path The path to the config file to parse.\n     *\n     * @throws UnavailableException if file cannot be read or parsed\n     * @since Struts 1.2\n     */\n    protected void parseModuleConfigFile(Digester digester, String path)\n        throws UnavailableException {\n\n        InputStream input = null;\n        try {\n            URL url = getServletContext().getResource(path);\n\n            // If the config isn't in the servlet context, try the class loader\n            // which allows the config files to be stored in a jar\n            if (url == null) {\n                url = getClass().getResource(path);\n            }\n            \n            if (url == null) {\n                String msg = internal.getMessage(\"configMissing\", path);\n                log.error(msg);\n                throw new UnavailableException(msg);\n            }\n\t    \n            InputSource is = new InputSource(url.toExternalForm());\n            input = url.openStream();\n            is.setByteStream(input);\n            digester.parse(is);\n\n        } catch (MalformedURLException e) {\n            handleConfigException(path, e);\n        } catch (IOException e) {\n            handleConfigException(path, e);\n        } catch (SAXException e) {\n            handleConfigException(path, e);\n        } finally {\n            if (input != null) {\n                try {\n                    input.close();\n                } catch (IOException e) {\n                    throw new UnavailableException(e.getMessage());\n                }\n            }\n        }\n    }\n\n\n    /**\n     * <p>Simplifies exception handling in the <code>parseModuleConfigFile</code> method.<p>\n     * @param path\n     * @param e\n     * @throws UnavailableException as a wrapper around Exception\n     */\n    private void handleConfigException(String path, Exception e)\n        throws UnavailableException {\n\n        String msg = internal.getMessage(\"configParse\", path);\n        log.error(msg, e);\n        throw new UnavailableException(msg);\n    }\n\n\n    /**\n     * <p>Initialize the data sources for the specified module.</p>\n     *\n     * @param config ModuleConfig information for this module\n     *\n     * @exception ServletException if initialization cannot be performed\n     * @since Struts 1.1\n     */\n    protected void initModuleDataSources(ModuleConfig config) throws ServletException {\n\n        // :FIXME: Document UnavailableException?\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Initializing module path '\" + config.getPrefix() +\n                \"' data sources\");\n        }\n\n        ServletContextWriter scw =\n            new ServletContextWriter(getServletContext());\n        DataSourceConfig dscs[] = config.findDataSourceConfigs();\n        if (dscs == null) {\n            dscs = new DataSourceConfig[0];\n        }\n\n        dataSources.setFast(false);\n        for (int i = 0; i < dscs.length; i++) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Initializing module path '\" + config.getPrefix() +\n                    \"' data source '\" + dscs[i].getKey() + \"'\");\n            }\n            DataSource ds = null;\n            try {\n                ds = (DataSource)\n                    RequestUtils.applicationInstance(dscs[i].getType());\n                BeanUtils.populate(ds, dscs[i].getProperties());\n                ds.setLogWriter(scw);\n\n            } catch (Exception e) {\n                log.error(internal.getMessage(\"dataSource.init\", dscs[i].getKey()), e);\n                throw new UnavailableException\n                    (internal.getMessage(\"dataSource.init\", dscs[i].getKey()));\n            }\n            getServletContext().setAttribute\n                (dscs[i].getKey() + config.getPrefix(), ds);\n            dataSources.put(dscs[i].getKey(), ds);\n        }\n\n        dataSources.setFast(true);\n\n    }\n\n\n    /**\n     * <p>Initialize the plug ins for the specified module.</p>\n     *\n     * @param config ModuleConfig information for this module\n     *\n     * @exception ServletException if initialization cannot be performed\n     * @since Struts 1.1\n     */\n    protected void initModulePlugIns\n        (ModuleConfig config) throws ServletException {\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Initializing module path '\" + config.getPrefix() + \"' plug ins\");\n        }\n\n        PlugInConfig plugInConfigs[] = config.findPlugInConfigs();\n        PlugIn plugIns[] = new PlugIn[plugInConfigs.length];\n\n        getServletContext().setAttribute(Globals.PLUG_INS_KEY + config.getPrefix(), plugIns);\n        for (int i = 0; i < plugIns.length; i++) {\n            try {\n                plugIns[i] =\n                    (PlugIn)RequestUtils.applicationInstance(plugInConfigs[i].getClassName());\n                 BeanUtils.populate(plugIns[i], plugInConfigs[i].getProperties());\n                  // Pass the current plugIn config object to the PlugIn.\n                  // The property is set only if the plugin declares it.\n                  // This plugin config object is needed by Tiles\n                try {\n                    PropertyUtils.setProperty(\n                        plugIns[i],\n                        \"currentPlugInConfigObject\",\n                        plugInConfigs[i]);\n                } catch (Exception e) {\n                  // FIXME Whenever we fail silently, we must document a valid reason\n                  // for doing so.  Why should we fail silently if a property can't be set on\n                  // the plugin?\n                    /**\n                     * Between version 1.138-1.140 cedric made these changes.\n                     * The exceptions are caught to deal with containers applying strict security.\n                     * This was in response to bug #15736\n                     *\n                     * Recommend that we make the currentPlugInConfigObject part of the PlugIn Interface if we can, Rob\n                     */\n                }\n                plugIns[i].init(this, config);\n\n            } catch (ServletException e) {\n                throw e;\n            } catch (Exception e) {\n                String errMsg =\n                    internal.getMessage(\n                        \"plugIn.init\",\n                        plugInConfigs[i].getClassName());\n\n                log(errMsg, e);\n                throw new UnavailableException(errMsg);\n            }\n        }\n\n    }\n\n\n    /**\n     * <p>Initialize the application <code>MessageResources</code> for the specified\n     * module.</p>\n     *\n     * @param config ModuleConfig information for this module\n     *\n     * @exception ServletException if initialization cannot be performed\n     * @since Struts 1.1\n     */\n    protected void initModuleMessageResources(ModuleConfig config)\n        throws ServletException {\n\n        MessageResourcesConfig mrcs[] = config.findMessageResourcesConfigs();\n        for (int i = 0; i < mrcs.length; i++) {\n            if ((mrcs[i].getFactory() == null)\n                || (mrcs[i].getParameter() == null)) {\n                continue;\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\n                    \"Initializing module path '\"\n                        + config.getPrefix()\n                        + \"' message resources from '\"\n                        + mrcs[i].getParameter()\n                        + \"'\");\n            }\n\n            String factory = mrcs[i].getFactory();\n            MessageResourcesFactory.setFactoryClass(factory);\n            MessageResourcesFactory factoryObject =\n                MessageResourcesFactory.createFactory();\n            factoryObject.setConfig(mrcs[i]);\n\n            MessageResources resources =\n                factoryObject.createResources(mrcs[i].getParameter());\n            resources.setReturnNull(mrcs[i].getNull());\n            resources.setEscape(mrcs[i].isEscape());\n            getServletContext().setAttribute(\n                mrcs[i].getKey() + config.getPrefix(),\n                resources);\n        }\n\n    }\n\n\n    /**\n     * <p>Create (if needed) and return a new <code>Digester</code>\n     * instance that has been initialized to process Struts module\n     * configuration files and configure a corresponding <code>ModuleConfig</code>\n     * object (which must be pushed on to the evaluation stack before parsing\n     * begins).</p>\n     *\n     * @exception ServletException if a Digester cannot be configured\n     * @since Struts 1.1\n     */\n    protected Digester initConfigDigester() throws ServletException {\n\n        // :FIXME: Where can ServletException be thrown?\n\n        // Do we have an existing instance?\n        if (configDigester != null) {\n            return (configDigester);\n        }\n\n        // Create a new Digester instance with standard capabilities\n        configDigester = new Digester();\n        configDigester.setNamespaceAware(true);\n        configDigester.setValidating(this.isValidating());\n        configDigester.setUseContextClassLoader(true);\n        configDigester.addRuleSet(new ConfigRuleSet());\n\n        for (int i = 0; i < registrations.length; i += 2) {\n            URL url = this.getClass().getResource(registrations[i+1]);\n            if (url != null) {\n                configDigester.register(registrations[i], url.toString());\n            }\n        }\n\n        this.addRuleSets();\n\n        // Return the completely configured Digester instance\n        return (configDigester);\n    }\n\n\n    /**\n     * <p>Add any custom RuleSet instances to configDigester that have\n     * been specified in the <code>rulesets</code> init parameter.</p>\n     *\n     * @throws ServletException\n     */\n    private void addRuleSets() throws ServletException {\n\n        String rulesets = getServletConfig().getInitParameter(\"rulesets\");\n        if (rulesets == null) {\n            rulesets = \"\";\n        }\n\n        rulesets = rulesets.trim();\n        String ruleset = null;\n        while (rulesets.length() > 0) {\n            int comma = rulesets.indexOf(\",\");\n            if (comma < 0) {\n                ruleset = rulesets.trim();\n                rulesets = \"\";\n            } else {\n                ruleset = rulesets.substring(0, comma).trim();\n                rulesets = rulesets.substring(comma + 1).trim();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Configuring custom Digester Ruleset of type \" + ruleset);\n            }\n\n            try {\n                RuleSet instance = (RuleSet) RequestUtils.applicationInstance(ruleset);\n                this.configDigester.addRuleSet(instance);\n            } catch (Exception e) {\n                log.error(\"Exception configuring custom Digester RuleSet\", e);\n                throw new ServletException(e);\n            }\n        }\n    }\n\n\n    /**\n     * <p>Check the status of the <code>validating</code> initialization parameter.</p>\n     *\n     * @return true if the module Digester should validate.\n     */\n    private boolean isValidating() {\n\n        boolean validating = true;\n        String value = getServletConfig().getInitParameter(\"validating\");\n\n        if (\"false\".equalsIgnoreCase(value)\n            || \"no\".equalsIgnoreCase(value)\n            || \"n\".equalsIgnoreCase(value)\n            || \"0\".equalsIgnoreCase(value)) {\n\n            validating = false;\n        }\n\n        return validating;\n    }\n\n\n\n    /**\n     * <p>Initialize our internal MessageResources bundle.</p>\n     *\n     * @exception ServletException if we cannot initialize these resources\n     */\n    protected void initInternal() throws ServletException {\n\n        // :FIXME: Document UnavailableException\n\n        try {\n            internal = MessageResources.getMessageResources(internalName);\n        } catch (MissingResourceException e) {\n            log.error(\"Cannot load internal resources from '\" + internalName + \"'\",\n                e);\n            throw new UnavailableException\n                (\"Cannot load internal resources from '\" + internalName + \"'\");\n        }\n\n    }\n\n\n    /**\n     * <p>Initialize other global characteristics of the controller servlet.</p>\n     *\n     * @exception ServletException if we cannot initialize these resources\n     */\n    protected void initOther() throws ServletException {\n        PropertyUtils.addBeanIntrospector(\n                SuppressPropertiesBeanIntrospector.SUPPRESS_CLASS);\n        PropertyUtils.clearDescriptors();\n\n        String value = null;\n        value = getServletConfig().getInitParameter(\"config\");\n        if (value != null) {\n            config = value;\n        }\n\n        // Backwards compatibility for form beans of Java wrapper classes\n        // Set to true for strict Struts 1.0 compatibility\n        value = getServletConfig().getInitParameter(\"convertNull\");\n        if (\"true\".equalsIgnoreCase(value)\n            || \"yes\".equalsIgnoreCase(value)\n            || \"on\".equalsIgnoreCase(value)\n            || \"y\".equalsIgnoreCase(value)\n            || \"1\".equalsIgnoreCase(value)) {\n\n            convertNull = true;\n        }\n\n        if (convertNull) {\n            ConvertUtils.deregister();\n            ConvertUtils.register(new BigDecimalConverter(null), BigDecimal.class);\n            ConvertUtils.register(new BigIntegerConverter(null), BigInteger.class);\n            ConvertUtils.register(new BooleanConverter(null), Boolean.class);\n            ConvertUtils.register(new ByteConverter(null), Byte.class);\n            ConvertUtils.register(new CharacterConverter(null), Character.class);\n            ConvertUtils.register(new DoubleConverter(null), Double.class);\n            ConvertUtils.register(new FloatConverter(null), Float.class);\n            ConvertUtils.register(new IntegerConverter(null), Integer.class);\n            ConvertUtils.register(new LongConverter(null), Long.class);\n            ConvertUtils.register(new ShortConverter(null), Short.class);\n        }\n\n    }\n\n\n    /**\n     * <p>Initialize the servlet mapping under which our controller servlet\n     * is being accessed.  This will be used in the <code>&html:form&gt;</code>\n     * tag to generate correct destination URLs for form submissions.</p>\n     *\n     * @throws ServletException if error happens while scanning web.xml\n     */\n    protected void initServlet() throws ServletException {\n\n        // Remember our servlet name\n        this.servletName = getServletConfig().getServletName();\n\n        // Prepare a Digester to scan the web application deployment descriptor\n        Digester digester = new Digester();\n        digester.push(this);\n        digester.setNamespaceAware(true);\n        digester.setValidating(false);\n\n        // Register our local copy of the DTDs that we can find\n        for (int i = 0; i < registrations.length; i += 2) {\n            URL url = this.getClass().getResource(registrations[i+1]);\n            if (url != null) {\n                digester.register(registrations[i], url.toString());\n            }\n        }\n\n        // Configure the processing rules that we need\n        digester.addCallMethod(\"web-app/servlet-mapping\",\n                               \"addServletMapping\", 2);\n        digester.addCallParam(\"web-app/servlet-mapping/servlet-name\", 0);\n        digester.addCallParam(\"web-app/servlet-mapping/url-pattern\", 1);\n\n        // Process the web application deployment descriptor\n        if (log.isDebugEnabled()) {\n            log.debug(\"Scanning web.xml for controller servlet mapping\");\n        }\n\n        InputStream input =\n            getServletContext().getResourceAsStream(\"/WEB-INF/web.xml\");\n\n        if (input == null) {\n            log.error(internal.getMessage(\"configWebXml\"));\n            throw new ServletException(internal.getMessage(\"configWebXml\"));\n        }\n\n        try {\n            digester.parse(input);\n\n        } catch (IOException e) {\n            log.error(internal.getMessage(\"configWebXml\"), e);\n            throw new ServletException(e);\n\n        } catch (SAXException e) {\n            log.error(internal.getMessage(\"configWebXml\"), e);\n            throw new ServletException(e);\n\n        } finally {\n            try {\n                input.close();\n            } catch (IOException e) {\n                log.error(internal.getMessage(\"configWebXml\"), e);\n                throw new ServletException(e);\n            }\n        }\n\n        // Record a servlet context attribute (if appropriate)\n        if (log.isDebugEnabled()) {\n            log.debug(\"Mapping for servlet '\" + servletName + \"' = '\" +\n                servletMapping + \"'\");\n        }\n\n        if (servletMapping != null) {\n            getServletContext().setAttribute(Globals.SERVLET_KEY, servletMapping);\n        }\n\n    }\n\n\n    /**\n     * <p>Perform the standard request processing for this request, and create\n     * the corresponding response.</p>\n     *\n     * @param request The servlet request we are processing\n     * @param response The servlet response we are creating\n     *\n     * @exception IOException if an input/output error occurs\n     * @exception ServletException if a servlet exception is thrown\n     */\n    protected void process(HttpServletRequest request, HttpServletResponse response)\n        throws IOException, ServletException {\n\n        ModuleUtils.getInstance().selectModule(request, getServletContext());\n        ModuleConfig config = getModuleConfig(request);\n\n        RequestProcessor processor = getProcessorForModule(config);\n        if (processor == null) {\n           processor = getRequestProcessor(config);\n        }\n        processor.process(request, response);\n\n    }\n\n}\n"], "fixing_code": ["# STRUTS\n\n![build status](https://circleci.com/gh/kawasima/struts1-forever.png?style=shield&circle-token=8f99c0e6c923ca570acda8c3640446fdacad2a47)\n\nThis struts1's fork is for maintenance to fix the vulnerabilities.\n\n## Requirements\n\nOriginal Struts requires Java 1.4 or higher. But struts1-forever requires Java 1.5 or higher.\nBecause Commons-Beanutils 1.9.2 is used for preventing a dangerous population.\n\n## Fixed vulnerabilities\n\n- CVE-2014-0114\n- CVE-2016-1181\n- CVE-2016-1182\n\n## Introduction (Original)\n\nThis subproject contains the source code for the \"Struts\" application support\npackage, consisting of the following major components:\n\n- Controller servlet with action mapping technology, implementing the Model-\n  View-Controller (MVC) design pattern for web applications commonly called\n  \"Model 2\", with a servlet as the \"front component\".\n\n- Comprehensive custom tag library for building internationalized JSP pages\n  that have HTML forms which interact with JavaBeans that are managed\n  automatically by the controller servlet.\n\nFor help with installing and using Struts, see the Struts User Guide.\n\n", "/*\n * $Id$\n *\n * Copyright 2000-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.struts.action;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.*;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.UnavailableException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.sql.DataSource;\n\nimport org.apache.commons.beanutils.BeanUtils;\nimport org.apache.commons.beanutils.ConvertUtils;\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.commons.beanutils.SuppressPropertiesBeanIntrospector;\nimport org.apache.commons.beanutils.converters.BigDecimalConverter;\nimport org.apache.commons.beanutils.converters.BigIntegerConverter;\nimport org.apache.commons.beanutils.converters.BooleanConverter;\nimport org.apache.commons.beanutils.converters.ByteConverter;\nimport org.apache.commons.beanutils.converters.CharacterConverter;\nimport org.apache.commons.beanutils.converters.DoubleConverter;\nimport org.apache.commons.beanutils.converters.FloatConverter;\nimport org.apache.commons.beanutils.converters.IntegerConverter;\nimport org.apache.commons.beanutils.converters.LongConverter;\nimport org.apache.commons.beanutils.converters.ShortConverter;\nimport org.apache.commons.collections.FastHashMap;\nimport org.apache.commons.digester.Digester;\nimport org.apache.commons.digester.RuleSet;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.struts.Globals;\nimport org.apache.struts.config.ConfigRuleSet;\nimport org.apache.struts.config.DataSourceConfig;\nimport org.apache.struts.config.FormBeanConfig;\nimport org.apache.struts.config.MessageResourcesConfig;\nimport org.apache.struts.config.ModuleConfig;\nimport org.apache.struts.config.ModuleConfigFactory;\nimport org.apache.struts.config.PlugInConfig;\nimport org.apache.struts.util.MessageResources;\nimport org.apache.struts.util.MessageResourcesFactory;\nimport org.apache.struts.util.ModuleUtils;\nimport org.apache.struts.util.RequestUtils;\nimport org.apache.struts.util.ServletContextWriter;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * <p><strong>ActionServlet</strong> provides the \"controller\" in the\n * Model-View-Controller (MVC) design pattern for web applications that is\n * commonly known as \"Model 2\".  This nomenclature originated with a\n * description in the JavaServerPages Specification, version 0.92, and has\n * persisted ever since (in the absence of a better name).</p>\n *\n * <p>Generally, a \"Model 2\" application is architected as follows:</p>\n * <ul>\n * <li>The user interface will generally be created with server pages, which\n *     will not themselves contain any business logic. These pages represent\n *     the \"view\" component of an MVC architecture.</li>\n * <li>Forms and hyperlinks in the user interface that require business logic\n *     to be executed will be submitted to a request URI that is mapped to this\n *     servlet.</li>\n * <li>There can be <b>one</b> instance of this servlet class,\n *     which receives and processes all requests that change the state of\n *     a user's interaction with the application.  The servlet delegates the\n *     handling of a request to a {@link RequestProcessor} object. This component\n *     represents the \"controller\" component of an MVC architecture.</li>\n * <li>The <code>RequestProcessor</code> selects and invokes an {@link Action} class to perform\n *     the requested business logic, or delegates the response to another resource.</li>\n * <li>The <code>Action</code> classes can manipulate the state of the application's\n *     interaction with the user, typically by creating or modifying JavaBeans\n *     that are stored as request or session attributes (depending on how long\n *     they need to be available). Such JavaBeans represent the \"model\"\n *     component of an MVC architecture.</li>\n * <li>Instead of producing the next page of the user interface directly,\n *     <code>Action</code> classes generally return an {@link ActionForward} to indicate\n *     which resource should handle the response. If the <code>Action</code>\n *     does not return null, the <code>RequestProcessor</code> forwards or\n *     redirects to the specified resource (by utilizing\n *     <code>RequestDispatcher.forward</code> or <code>Response.sendRedirect</code>)\n *     so as to produce the next page of the user interface.</li>\n * </ul>\n *\n * <p>The standard version of <code>RequestsProcessor</code> implements the\n *    following logic for each incoming HTTP request. You can override\n *    some or all of this functionality by subclassing this object and\n *    implementing your own version of the processing.</p>\n * <ul>\n * <li>Identify, from the incoming request URI, the substring that will be\n *     used to select an action procedure.</li>\n * <li>Use this substring to map to the Java class name of the corresponding\n *     action class (an implementation of the <code>Action</code> interface).\n *     </li>\n * <li>If this is the first request for a particular <code>Action</code> class,\n *     instantiate an instance of that class and cache it for future use.</li>\n * <li>Optionally populate the properties of an <code>ActionForm</code> bean\n *     associated with this mapping.</li>\n * <li>Call the <code>execute</code> method of this <code>Action</code> class, passing\n *     on a reference to the mapping that was used, the relevant form-bean\n *     (if any), and the request and the response that were passed to the\n *     controller by the servlet container (thereby providing access to any\n *     specialized properties of the mapping itself as well as to the\n *     ServletContext).\n *     </li>\n * </ul>\n *\n * <p>The standard version of <code>ActionServlet</code> is configured based\n * on the following servlet initialization parameters, which you will specify\n * in the web application deployment descriptor (<code>/WEB-INF/web.xml</code>)\n * for your application.  Subclasses that specialize this servlet are free to\n * define additional initialization parameters. </p>\n * <ul>\n * <li><strong>config</strong> - Comma-separated list of context-relative\n *     path(s) to the XML resource(s) containing the configuration information\n *     for the default module.  (Multiple files support since Struts 1.1)\n *     [/WEB-INF/struts-config.xml].</li>\n * <li><strong>config/${module}</strong> - Comma-separated list of\n *     Context-relative path(s) to the XML resource(s)\n *     containing the configuration information for the module that\n *     will use the specified prefix (/${module}). This can be repeated as many\n *     times as required for multiple modules. (Since Struts 1.1)</li>\n * <li><strong>configFactory</strong> - The Java class name of the\n *     <code>ModuleConfigFactory</code> used to create the implementation of the\n *     <code>ModuleConfig</code> interface.\n *     [org.apache.struts.config.impl.DefaultModuleConfigFactory]\n * </li>\n * <li><strong>convertNull</strong> - Force simulation of the Struts 1.0 behavior\n *     when populating forms. If set to true, the numeric Java wrapper class types\n *     (like <code>java.lang.Integer</code>) will default to null (rather than 0).\n *     (Since Struts 1.1) [false] </li>\n * <li><strong>rulesets</strong> - Comma-delimited list of fully qualified\n *     classnames of additional <code>org.apache.commons.digester.RuleSet</code>\n *     instances that should be added to the <code>Digester</code> that will\n *     be processing <code>struts-config.xml</code> files.  By default, only\n *     the <code>RuleSet</code> for the standard configuration elements is\n *     loaded.  (Since Struts 1.1)</li>\n * <li><strong>validating</strong> - Should we use a validating XML parser to\n *     process the configuration file (strongly recommended)? [true]</li>\n * </ul>\n *\n * @version $Rev$ $Date$\n */\npublic class ActionServlet extends HttpServlet {\n\n\n    // ----------------------------------------------------- Instance Variables\n\n\n    /**\n     * <p>Comma-separated list of context-relative path(s) to our configuration\n     * resource(s) for the default module.</p>\n     */\n    protected String config = \"/WEB-INF/struts-config.xml\";\n\n\n    /**\n     * <p>The Digester used to produce ModuleConfig objects from a\n     * Struts configuration file.</p>\n     *\n     * @since Struts 1.1\n     */\n    protected Digester configDigester = null;\n\n\n    /**\n     * <p>The flag to request backwards-compatible conversions for form bean\n     * properties of the Java wrapper class types.</p>\n     *\n     * @since Struts 1.1\n     */\n    protected boolean convertNull = false;\n\n\n    /**\n     * <p>The JDBC data sources that has been configured for this module,\n     * if any, keyed by the servlet context attribute under which they are\n     * stored.</p>\n     */\n    protected FastHashMap dataSources = new FastHashMap();\n\n\n    /**\n     * <p>The resources object for our internal resources.</p>\n     */\n    protected MessageResources internal = null;\n\n\n    /**\n     * <p>The Java base name of our internal resources.</p>\n     * @since Struts 1.1\n     */\n    protected String internalName = \"org.apache.struts.action.ActionResources\";\n\n\n    /**\n     * <p>Commons Logging instance.</p>\n     *\n     * @since Struts 1.1\n     */\n    protected static Log log = LogFactory.getLog(ActionServlet.class);\n\n\n    /**\n     * <p>The <code>RequestProcessor</code> instance we will use to process\n     * all incoming requests.</p>\n     *\n     * @since Struts 1.1\n     */\n    protected RequestProcessor processor = null;\n\n\n    /**\n     * <p>The set of public identifiers, and corresponding resource names, for\n     * the versions of the configuration file DTDs that we know about.  There\n     * <strong>MUST</strong> be an even number of Strings in this list!</p>\n     */\n    protected String registrations[] = {\n        \"-//Apache Software Foundation//DTD Struts Configuration 1.0//EN\",\n        \"/org/apache/struts/resources/struts-config_1_0.dtd\",\n        \"-//Apache Software Foundation//DTD Struts Configuration 1.1//EN\",\n        \"/org/apache/struts/resources/struts-config_1_1.dtd\",\n        \"-//Apache Software Foundation//DTD Struts Configuration 1.2//EN\",\n        \"/org/apache/struts/resources/struts-config_1_2.dtd\",\n        \"-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN\",\n        \"/org/apache/struts/resources/web-app_2_2.dtd\",\n        \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\",\n        \"/org/apache/struts/resources/web-app_2_3.dtd\"\n    };\n\n\n    /**\n     * <p>The URL pattern to which we are mapped in our web application\n     * deployment descriptor.</p>\n     */\n    protected String servletMapping = null; // :FIXME: - multiples?\n\n\n    /**\n     * <p>The servlet name under which we are registered in our web application\n     * deployment descriptor.</p>\n     */\n    protected String servletName = null;\n\n\n    // ---------------------------------------------------- HttpServlet Methods\n\n\n    /**\n     * <p>Gracefully shut down this controller servlet, releasing any resources\n     * that were allocated at initialization.</p>\n     */\n    public void destroy() {\n\n        if (log.isDebugEnabled()) {\n            log.debug(internal.getMessage(\"finalizing\"));\n        }\n\n        destroyModules();\n        destroyInternal();\n        getServletContext().removeAttribute(Globals.ACTION_SERVLET_KEY);\n\n        // Release our LogFactory and Log instances (if any)\n        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        if (classLoader == null) {\n            classLoader = ActionServlet.class.getClassLoader();\n        }\n        try {\n            LogFactory.release(classLoader);\n        } catch (Throwable t) {\n            ; // Servlet container doesn't have the latest version\n            ; // of commons-logging-api.jar installed\n\n            // :FIXME: Why is this dependent on the container's version of commons-logging?\n            // Shouldn't this depend on the version packaged with Struts?\n            /*\n              Reason: LogFactory.release(classLoader); was added as\n              an attempt to investigate the OutOfMemory error reported on Bugzilla #14042.\n              It was committed for version 1.136 by craigmcc\n            */\n        }\n\n        PropertyUtils.clearDescriptors();\n\n    }\n\n\n    /**\n     * <p>Initialize this servlet.  Most of the processing has been factored into\n     * support methods so that you can override particular functionality at a\n     * fairly granular level.</p>\n     *\n     * @exception ServletException if we cannot configure ourselves correctly\n     */\n    public void init() throws ServletException {\n\n        // Wraps the entire initialization in a try/catch to better handle\n        // unexpected exceptions and errors to provide better feedback\n        // to the developer\n        try {\n            initInternal();\n            initOther();\n            initServlet();\n\n            getServletContext().setAttribute(Globals.ACTION_SERVLET_KEY, this);\n            initModuleConfigFactory();\n            // Initialize modules as needed\n            ModuleConfig moduleConfig = initModuleConfig(\"\", config);\n            initModuleMessageResources(moduleConfig);\n            initModuleDataSources(moduleConfig);\n            initModulePlugIns(moduleConfig);\n            moduleConfig.freeze();\n\n            Enumeration names = getServletConfig().getInitParameterNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                if (!name.startsWith(\"config/\")) {\n                    continue;\n                }\n                String prefix = name.substring(6);\n                moduleConfig = initModuleConfig\n                    (prefix, getServletConfig().getInitParameter(name));\n                initModuleMessageResources(moduleConfig);\n                initModuleDataSources(moduleConfig);\n                initModulePlugIns(moduleConfig);\n                moduleConfig.freeze();\n            }\n\n            this.initModulePrefixes(this.getServletContext());\n\n            this.destroyConfigDigester();\n        } catch (UnavailableException ex) {\n            throw ex;\n        } catch (Throwable t) {\n\n            // The follow error message is not retrieved from internal message\n            // resources as they may not have been able to have been\n            // initialized\n            log.error(\"Unable to initialize Struts ActionServlet due to an \"\n                + \"unexpected exception or error thrown, so marking the \"\n                + \"servlet as unavailable.  Most likely, this is due to an \"\n                + \"incorrect or missing library dependency.\", t);\n            throw new UnavailableException(t.getMessage());\n        }\n    }\n\n    /**\n     * <p>Saves a String[] of module prefixes in the ServletContext under\n     * Globals.MODULE_PREFIXES_KEY.  <strong>NOTE</strong> -\n     * the \"\" prefix for the default module is not included in this list.</p>\n     *\n     * @param context The servlet context.\n     * @since Struts 1.2\n     */\n    protected void initModulePrefixes(ServletContext context) {\n        ArrayList prefixList = new ArrayList();\n\n        Enumeration names = context.getAttributeNames();\n        while (names.hasMoreElements()) {\n            String name = (String) names.nextElement();\n            if (!name.startsWith(Globals.MODULE_KEY)) {\n                continue;\n            }\n\n            String prefix = name.substring(Globals.MODULE_KEY.length());\n            if (prefix.length() > 0) {\n                prefixList.add(prefix);\n            }\n        }\n\n        String[] prefixes = (String[]) prefixList.toArray(new String[prefixList.size()]);\n        context.setAttribute(Globals.MODULE_PREFIXES_KEY, prefixes);\n    }\n\n\n    /**\n     * <p>Process an HTTP \"GET\" request.</p>\n     *\n     * @param request The servlet request we are processing\n     * @param response The servlet response we are creating\n     *\n     * @exception IOException if an input/output error occurs\n     * @exception ServletException if a servlet exception occurs\n     */\n    public void doGet(HttpServletRequest request,\n              HttpServletResponse response)\n        throws IOException, ServletException {\n\n        process(request, response);\n\n    }\n\n\n    /**\n     * <p>Process an HTTP \"POST\" request.</p>\n     *\n     * @param request The servlet request we are processing\n     * @param response The servlet response we are creating\n     *\n     * @exception IOException if an input/output error occurs\n     * @exception ServletException if a servlet exception occurs\n     */\n    public void doPost(HttpServletRequest request,\n               HttpServletResponse response)\n        throws IOException, ServletException {\n\n        process(request, response);\n\n    }\n\n\n    // --------------------------------------------------------- Public Methods\n\n\n    /**\n     * <p>Remember a servlet mapping from our web application deployment\n     * descriptor, if it is for this servlet.</p>\n     *\n     * @param servletName The name of the servlet being mapped\n     * @param urlPattern The URL pattern to which this servlet is mapped\n     */\n    public void addServletMapping(String servletName, String urlPattern) {\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Process servletName=\" + servletName +\n                      \", urlPattern=\" + urlPattern);\n        }\n        if (servletName == null) {\n            return;\n        }\n        if (servletName.equals(this.servletName)) {\n            this.servletMapping = urlPattern;\n        }\n\n    }\n\n\n    /**\n     * <p>Return the <code>MessageResources</code> instance containing our\n     * internal message strings.</p>\n     *\n     * @since Struts 1.1\n     */\n    public MessageResources getInternal() {\n\n        return (this.internal);\n\n    }\n\n\n    // ------------------------------------------------------ Protected Methods\n\n    /**\n     * <p>Gracefully terminate use of any modules associated with this\n     * application (if any).</p>\n     *\n     * @since Struts 1.1\n     */\n    protected void destroyModules() {\n\n        ArrayList values = new ArrayList();\n        Enumeration names = getServletContext().getAttributeNames();\n        while (names.hasMoreElements()) {\n            values.add(names.nextElement());\n        }\n\n        Iterator keys = values.iterator();\n        while (keys.hasNext()) {\n            String name = (String) keys.next();\n            Object value = getServletContext().getAttribute(name);\n\n            if (!(value instanceof ModuleConfig)) {\n                continue;\n            }\n\n            ModuleConfig config = (ModuleConfig) value;\n\n            if (this.getProcessorForModule(config) != null) {\n                this.getProcessorForModule(config).destroy();\n            }\n\n            getServletContext().removeAttribute(name);\n\n            PlugIn plugIns[] =\n                (PlugIn[]) getServletContext().getAttribute(\n                    Globals.PLUG_INS_KEY + config.getPrefix());\n\n            if (plugIns != null) {\n                for (int i = 0; i < plugIns.length; i++) {\n                    int j = plugIns.length - (i + 1);\n                    plugIns[j].destroy();\n                }\n\n                getServletContext().removeAttribute(\n                    Globals.PLUG_INS_KEY + config.getPrefix());\n            }\n\n        }\n\n    }\n\n\n    /**\n     * <p>Gracefully release any configDigester instance that we have created.</p>\n     *\n     * @since Struts 1.1\n     */\n    protected void destroyConfigDigester() {\n\n        configDigester = null;\n\n    }\n\n\n    /**\n     * <p>Gracefully terminate use of the internal MessageResources.</p>\n     */\n    protected void destroyInternal() {\n\n        internal = null;\n\n    }\n\n    /**\n     * <p>Return the module configuration object for the currently selected\n     * module.</p>\n     *\n     * @param request The servlet request we are processing\n     * @since Struts 1.1\n     */\n    protected ModuleConfig getModuleConfig\n        (HttpServletRequest request) {\n\n        ModuleConfig config = (ModuleConfig)\n            request.getAttribute(Globals.MODULE_KEY);\n        if (config == null) {\n            config = (ModuleConfig)\n                getServletContext().getAttribute(Globals.MODULE_KEY);\n        }\n        return (config);\n\n    }\n\n\n    /**\n     * <p>Look up and return the {@link RequestProcessor} responsible for the\n     * specified module, creating a new one if necessary.</p>\n     *\n     * @param config The module configuration for which to\n     *  acquire and return a RequestProcessor.\n     *\n     * @exception ServletException if we cannot instantiate a RequestProcessor\n     *  instance\n     * @since Struts 1.1\n     */\n    protected synchronized RequestProcessor getRequestProcessor(ModuleConfig config)\n        throws ServletException {\n\n        // :FIXME: Document UnavailableException?\n\n        RequestProcessor processor = this.getProcessorForModule(config);\n\n        if (processor == null) {\n            try {\n                processor =\n                    (RequestProcessor) RequestUtils.applicationInstance(\n                        config.getControllerConfig().getProcessorClass());\n\n            } catch (Exception e) {\n                throw new UnavailableException(\n                    \"Cannot initialize RequestProcessor of class \"\n                        + config.getControllerConfig().getProcessorClass()\n                        + \": \"\n                        + e);\n            }\n\n            processor.init(this, config);\n\n            String key = Globals.REQUEST_PROCESSOR_KEY + config.getPrefix();\n            getServletContext().setAttribute(key, processor);\n\n        }\n\n        return (processor);\n\n    }\n\n\n    /**\n     * <p>Returns the RequestProcessor for the given module or null if one does not\n     * exist.  This method will not create a RequestProcessor.</p>\n     *\n     * @param config The ModuleConfig.\n     */\n    private RequestProcessor getProcessorForModule(ModuleConfig config) {\n        String key = Globals.REQUEST_PROCESSOR_KEY + config.getPrefix();\n        return (RequestProcessor) getServletContext().getAttribute(key);\n    }\n\n\n    /**\n     * <p>Initialize the factory used to create the module configuration.</p>\n     * @since Struts 1.2\n     */\n    protected void initModuleConfigFactory(){\n        String configFactory = getServletConfig().getInitParameter(\"configFactory\");\n        if (configFactory != null) {\n            ModuleConfigFactory.setFactoryClass(configFactory);\n        }\n    }\n\n\n    /**\n     * <p>Initialize the module configuration information for the\n     * specified module.</p>\n     *\n     * @param prefix Module prefix for this module\n     * @param paths Comma-separated list of context-relative resource path(s)\n     *  for this modules's configuration resource(s)\n     *\n     * @exception ServletException if initialization cannot be performed\n     * @since Struts 1.1\n     */\n    protected ModuleConfig initModuleConfig(String prefix, String paths)\n        throws ServletException {\n\n        // :FIXME: Document UnavailableException? (Doesn't actually throw anything)\n\n        if (log.isDebugEnabled()) {\n            log.debug(\n                \"Initializing module path '\"\n                    + prefix\n                    + \"' configuration from '\"\n                    + paths\n                    + \"'\");\n        }\n\n        // Parse the configuration for this module\n        ModuleConfigFactory factoryObject = ModuleConfigFactory.createFactory();\n        ModuleConfig config = factoryObject.createModuleConfig(prefix);\n\n        // Configure the Digester instance we will use\n        Digester digester = initConfigDigester();\n\n        // Process each specified resource path\n        while (paths.length() > 0) {\n            digester.push(config);\n            String path = null;\n            int comma = paths.indexOf(',');\n            if (comma >= 0) {\n                path = paths.substring(0, comma).trim();\n                paths = paths.substring(comma + 1);\n            } else {\n                path = paths.trim();\n                paths = \"\";\n            }\n\n            if (path.length() < 1) {\n                break;\n            }\n\n            this.parseModuleConfigFile(digester, path);\n        }\n\n        getServletContext().setAttribute(\n            Globals.MODULE_KEY + config.getPrefix(),\n            config);\n\n        // Force creation and registration of DynaActionFormClass instances\n        // for all dynamic form beans we wil be using\n        FormBeanConfig fbs[] = config.findFormBeanConfigs();\n        for (int i = 0; i < fbs.length; i++) {\n            if (fbs[i].getDynamic()) {\n                fbs[i].getDynaActionFormClass();\n            }\n        }\n\n        return config;\n    }\n\n\n    /**\n     * <p>Parses one module config file.</p>\n     *\n     * @param digester Digester instance that does the parsing\n     * @param path The path to the config file to parse.\n     *\n     * @throws UnavailableException if file cannot be read or parsed\n     * @since Struts 1.2\n     */\n    protected void parseModuleConfigFile(Digester digester, String path)\n        throws UnavailableException {\n\n        InputStream input = null;\n        try {\n            URL url = getServletContext().getResource(path);\n\n            // If the config isn't in the servlet context, try the class loader\n            // which allows the config files to be stored in a jar\n            if (url == null) {\n                url = getClass().getResource(path);\n            }\n\n            if (url == null) {\n                String msg = internal.getMessage(\"configMissing\", path);\n                log.error(msg);\n                throw new UnavailableException(msg);\n            }\n\n            InputSource is = new InputSource(url.toExternalForm());\n            input = url.openStream();\n            is.setByteStream(input);\n            digester.parse(is);\n\n        } catch (MalformedURLException e) {\n            handleConfigException(path, e);\n        } catch (IOException e) {\n            handleConfigException(path, e);\n        } catch (SAXException e) {\n            handleConfigException(path, e);\n        } finally {\n            if (input != null) {\n                try {\n                    input.close();\n                } catch (IOException e) {\n                    throw new UnavailableException(e.getMessage());\n                }\n            }\n        }\n    }\n\n\n    /**\n     * <p>Simplifies exception handling in the <code>parseModuleConfigFile</code> method.<p>\n     * @param path\n     * @param e\n     * @throws UnavailableException as a wrapper around Exception\n     */\n    private void handleConfigException(String path, Exception e)\n        throws UnavailableException {\n\n        String msg = internal.getMessage(\"configParse\", path);\n        log.error(msg, e);\n        throw new UnavailableException(msg);\n    }\n\n\n    /**\n     * <p>Initialize the data sources for the specified module.</p>\n     *\n     * @param config ModuleConfig information for this module\n     *\n     * @exception ServletException if initialization cannot be performed\n     * @since Struts 1.1\n     */\n    protected void initModuleDataSources(ModuleConfig config) throws ServletException {\n\n        // :FIXME: Document UnavailableException?\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Initializing module path '\" + config.getPrefix() +\n                \"' data sources\");\n        }\n\n        ServletContextWriter scw =\n            new ServletContextWriter(getServletContext());\n        DataSourceConfig dscs[] = config.findDataSourceConfigs();\n        if (dscs == null) {\n            dscs = new DataSourceConfig[0];\n        }\n\n        dataSources.setFast(false);\n        for (int i = 0; i < dscs.length; i++) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Initializing module path '\" + config.getPrefix() +\n                    \"' data source '\" + dscs[i].getKey() + \"'\");\n            }\n            DataSource ds = null;\n            try {\n                ds = (DataSource)\n                    RequestUtils.applicationInstance(dscs[i].getType());\n                BeanUtils.populate(ds, dscs[i].getProperties());\n                ds.setLogWriter(scw);\n\n            } catch (Exception e) {\n                log.error(internal.getMessage(\"dataSource.init\", dscs[i].getKey()), e);\n                throw new UnavailableException\n                    (internal.getMessage(\"dataSource.init\", dscs[i].getKey()));\n            }\n            getServletContext().setAttribute\n                (dscs[i].getKey() + config.getPrefix(), ds);\n            dataSources.put(dscs[i].getKey(), ds);\n        }\n\n        dataSources.setFast(true);\n\n    }\n\n\n    /**\n     * <p>Initialize the plug ins for the specified module.</p>\n     *\n     * @param config ModuleConfig information for this module\n     *\n     * @exception ServletException if initialization cannot be performed\n     * @since Struts 1.1\n     */\n    protected void initModulePlugIns\n        (ModuleConfig config) throws ServletException {\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Initializing module path '\" + config.getPrefix() + \"' plug ins\");\n        }\n\n        PlugInConfig plugInConfigs[] = config.findPlugInConfigs();\n        PlugIn plugIns[] = new PlugIn[plugInConfigs.length];\n\n        getServletContext().setAttribute(Globals.PLUG_INS_KEY + config.getPrefix(), plugIns);\n        for (int i = 0; i < plugIns.length; i++) {\n            try {\n                plugIns[i] =\n                    (PlugIn)RequestUtils.applicationInstance(plugInConfigs[i].getClassName());\n                 BeanUtils.populate(plugIns[i], plugInConfigs[i].getProperties());\n                  // Pass the current plugIn config object to the PlugIn.\n                  // The property is set only if the plugin declares it.\n                  // This plugin config object is needed by Tiles\n                try {\n                    PropertyUtils.setProperty(\n                        plugIns[i],\n                        \"currentPlugInConfigObject\",\n                        plugInConfigs[i]);\n                } catch (Exception e) {\n                  // FIXME Whenever we fail silently, we must document a valid reason\n                  // for doing so.  Why should we fail silently if a property can't be set on\n                  // the plugin?\n                    /**\n                     * Between version 1.138-1.140 cedric made these changes.\n                     * The exceptions are caught to deal with containers applying strict security.\n                     * This was in response to bug #15736\n                     *\n                     * Recommend that we make the currentPlugInConfigObject part of the PlugIn Interface if we can, Rob\n                     */\n                }\n                plugIns[i].init(this, config);\n\n            } catch (ServletException e) {\n                throw e;\n            } catch (Exception e) {\n                String errMsg =\n                    internal.getMessage(\n                        \"plugIn.init\",\n                        plugInConfigs[i].getClassName());\n\n                log(errMsg, e);\n                throw new UnavailableException(errMsg);\n            }\n        }\n\n    }\n\n\n    /**\n     * <p>Initialize the application <code>MessageResources</code> for the specified\n     * module.</p>\n     *\n     * @param config ModuleConfig information for this module\n     *\n     * @exception ServletException if initialization cannot be performed\n     * @since Struts 1.1\n     */\n    protected void initModuleMessageResources(ModuleConfig config)\n        throws ServletException {\n\n        MessageResourcesConfig mrcs[] = config.findMessageResourcesConfigs();\n        for (int i = 0; i < mrcs.length; i++) {\n            if ((mrcs[i].getFactory() == null)\n                || (mrcs[i].getParameter() == null)) {\n                continue;\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\n                    \"Initializing module path '\"\n                        + config.getPrefix()\n                        + \"' message resources from '\"\n                        + mrcs[i].getParameter()\n                        + \"'\");\n            }\n\n            String factory = mrcs[i].getFactory();\n            MessageResourcesFactory.setFactoryClass(factory);\n            MessageResourcesFactory factoryObject =\n                MessageResourcesFactory.createFactory();\n            factoryObject.setConfig(mrcs[i]);\n\n            MessageResources resources =\n                factoryObject.createResources(mrcs[i].getParameter());\n            resources.setReturnNull(mrcs[i].getNull());\n            resources.setEscape(mrcs[i].isEscape());\n            getServletContext().setAttribute(\n                mrcs[i].getKey() + config.getPrefix(),\n                resources);\n        }\n\n    }\n\n\n    /**\n     * <p>Create (if needed) and return a new <code>Digester</code>\n     * instance that has been initialized to process Struts module\n     * configuration files and configure a corresponding <code>ModuleConfig</code>\n     * object (which must be pushed on to the evaluation stack before parsing\n     * begins).</p>\n     *\n     * @exception ServletException if a Digester cannot be configured\n     * @since Struts 1.1\n     */\n    protected Digester initConfigDigester() throws ServletException {\n\n        // :FIXME: Where can ServletException be thrown?\n\n        // Do we have an existing instance?\n        if (configDigester != null) {\n            return (configDigester);\n        }\n\n        // Create a new Digester instance with standard capabilities\n        configDigester = new Digester();\n        configDigester.setNamespaceAware(true);\n        configDigester.setValidating(this.isValidating());\n        configDigester.setUseContextClassLoader(true);\n        configDigester.addRuleSet(new ConfigRuleSet());\n\n        for (int i = 0; i < registrations.length; i += 2) {\n            URL url = this.getClass().getResource(registrations[i+1]);\n            if (url != null) {\n                configDigester.register(registrations[i], url.toString());\n            }\n        }\n\n        this.addRuleSets();\n\n        // Return the completely configured Digester instance\n        return (configDigester);\n    }\n\n\n    /**\n     * <p>Add any custom RuleSet instances to configDigester that have\n     * been specified in the <code>rulesets</code> init parameter.</p>\n     *\n     * @throws ServletException\n     */\n    private void addRuleSets() throws ServletException {\n\n        String rulesets = getServletConfig().getInitParameter(\"rulesets\");\n        if (rulesets == null) {\n            rulesets = \"\";\n        }\n\n        rulesets = rulesets.trim();\n        String ruleset = null;\n        while (rulesets.length() > 0) {\n            int comma = rulesets.indexOf(\",\");\n            if (comma < 0) {\n                ruleset = rulesets.trim();\n                rulesets = \"\";\n            } else {\n                ruleset = rulesets.substring(0, comma).trim();\n                rulesets = rulesets.substring(comma + 1).trim();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Configuring custom Digester Ruleset of type \" + ruleset);\n            }\n\n            try {\n                RuleSet instance = (RuleSet) RequestUtils.applicationInstance(ruleset);\n                this.configDigester.addRuleSet(instance);\n            } catch (Exception e) {\n                log.error(\"Exception configuring custom Digester RuleSet\", e);\n                throw new ServletException(e);\n            }\n        }\n    }\n\n\n    /**\n     * <p>Check the status of the <code>validating</code> initialization parameter.</p>\n     *\n     * @return true if the module Digester should validate.\n     */\n    private boolean isValidating() {\n\n        boolean validating = true;\n        String value = getServletConfig().getInitParameter(\"validating\");\n\n        if (\"false\".equalsIgnoreCase(value)\n            || \"no\".equalsIgnoreCase(value)\n            || \"n\".equalsIgnoreCase(value)\n            || \"0\".equalsIgnoreCase(value)) {\n\n            validating = false;\n        }\n\n        return validating;\n    }\n\n\n\n    /**\n     * <p>Initialize our internal MessageResources bundle.</p>\n     *\n     * @exception ServletException if we cannot initialize these resources\n     */\n    protected void initInternal() throws ServletException {\n\n        // :FIXME: Document UnavailableException\n\n        try {\n            internal = MessageResources.getMessageResources(internalName);\n        } catch (MissingResourceException e) {\n            log.error(\"Cannot load internal resources from '\" + internalName + \"'\",\n                e);\n            throw new UnavailableException\n                (\"Cannot load internal resources from '\" + internalName + \"'\");\n        }\n\n    }\n\n\n    /**\n     * <p>Initialize other global characteristics of the controller servlet.</p>\n     *\n     * @exception ServletException if we cannot initialize these resources\n     */\n    protected void initOther() throws ServletException {\n        HashSet suppressProperties = new HashSet();\n        suppressProperties.add(\"class\");\n        suppressProperties.add(\"multipartRequestHandler\");\n        suppressProperties.add(\"resultValueMap\");\n\n        PropertyUtils.addBeanIntrospector(\n                new SuppressPropertiesBeanIntrospector(suppressProperties));\n        PropertyUtils.clearDescriptors();\n\n        String value = null;\n        value = getServletConfig().getInitParameter(\"config\");\n        if (value != null) {\n            config = value;\n        }\n\n        // Backwards compatibility for form beans of Java wrapper classes\n        // Set to true for strict Struts 1.0 compatibility\n        value = getServletConfig().getInitParameter(\"convertNull\");\n        if (\"true\".equalsIgnoreCase(value)\n            || \"yes\".equalsIgnoreCase(value)\n            || \"on\".equalsIgnoreCase(value)\n            || \"y\".equalsIgnoreCase(value)\n            || \"1\".equalsIgnoreCase(value)) {\n\n            convertNull = true;\n        }\n\n        if (convertNull) {\n            ConvertUtils.deregister();\n            ConvertUtils.register(new BigDecimalConverter(null), BigDecimal.class);\n            ConvertUtils.register(new BigIntegerConverter(null), BigInteger.class);\n            ConvertUtils.register(new BooleanConverter(null), Boolean.class);\n            ConvertUtils.register(new ByteConverter(null), Byte.class);\n            ConvertUtils.register(new CharacterConverter(null), Character.class);\n            ConvertUtils.register(new DoubleConverter(null), Double.class);\n            ConvertUtils.register(new FloatConverter(null), Float.class);\n            ConvertUtils.register(new IntegerConverter(null), Integer.class);\n            ConvertUtils.register(new LongConverter(null), Long.class);\n            ConvertUtils.register(new ShortConverter(null), Short.class);\n        }\n\n    }\n\n\n    /**\n     * <p>Initialize the servlet mapping under which our controller servlet\n     * is being accessed.  This will be used in the <code>&html:form&gt;</code>\n     * tag to generate correct destination URLs for form submissions.</p>\n     *\n     * @throws ServletException if error happens while scanning web.xml\n     */\n    protected void initServlet() throws ServletException {\n\n        // Remember our servlet name\n        this.servletName = getServletConfig().getServletName();\n\n        // Prepare a Digester to scan the web application deployment descriptor\n        Digester digester = new Digester();\n        digester.push(this);\n        digester.setNamespaceAware(true);\n        digester.setValidating(false);\n\n        // Register our local copy of the DTDs that we can find\n        for (int i = 0; i < registrations.length; i += 2) {\n            URL url = this.getClass().getResource(registrations[i+1]);\n            if (url != null) {\n                digester.register(registrations[i], url.toString());\n            }\n        }\n\n        // Configure the processing rules that we need\n        digester.addCallMethod(\"web-app/servlet-mapping\",\n                               \"addServletMapping\", 2);\n        digester.addCallParam(\"web-app/servlet-mapping/servlet-name\", 0);\n        digester.addCallParam(\"web-app/servlet-mapping/url-pattern\", 1);\n\n        // Process the web application deployment descriptor\n        if (log.isDebugEnabled()) {\n            log.debug(\"Scanning web.xml for controller servlet mapping\");\n        }\n\n        InputStream input =\n            getServletContext().getResourceAsStream(\"/WEB-INF/web.xml\");\n\n        if (input == null) {\n            log.error(internal.getMessage(\"configWebXml\"));\n            throw new ServletException(internal.getMessage(\"configWebXml\"));\n        }\n\n        try {\n            digester.parse(input);\n\n        } catch (IOException e) {\n            log.error(internal.getMessage(\"configWebXml\"), e);\n            throw new ServletException(e);\n\n        } catch (SAXException e) {\n            log.error(internal.getMessage(\"configWebXml\"), e);\n            throw new ServletException(e);\n\n        } finally {\n            try {\n                input.close();\n            } catch (IOException e) {\n                log.error(internal.getMessage(\"configWebXml\"), e);\n                throw new ServletException(e);\n            }\n        }\n\n        // Record a servlet context attribute (if appropriate)\n        if (log.isDebugEnabled()) {\n            log.debug(\"Mapping for servlet '\" + servletName + \"' = '\" +\n                servletMapping + \"'\");\n        }\n\n        if (servletMapping != null) {\n            getServletContext().setAttribute(Globals.SERVLET_KEY, servletMapping);\n        }\n\n    }\n\n\n    /**\n     * <p>Perform the standard request processing for this request, and create\n     * the corresponding response.</p>\n     *\n     * @param request The servlet request we are processing\n     * @param response The servlet response we are creating\n     *\n     * @exception IOException if an input/output error occurs\n     * @exception ServletException if a servlet exception is thrown\n     */\n    protected void process(HttpServletRequest request, HttpServletResponse response)\n        throws IOException, ServletException {\n\n        ModuleUtils.getInstance().selectModule(request, getServletContext());\n        ModuleConfig config = getModuleConfig(request);\n\n        RequestProcessor processor = getProcessorForModule(config);\n        if (processor == null) {\n           processor = getRequestProcessor(config);\n        }\n        processor.process(request, response);\n\n    }\n\n}\n"], "filenames": ["README.md", "src/share/org/apache/struts/action/ActionServlet.java"], "buggy_code_start_loc": [1, 2], "buggy_code_end_loc": [12, 1065], "fixing_code_start_loc": [1, 2], "fixing_code_end_loc": [19, 1067], "type": "NVD-CWE-noinfo", "message": "ActionServlet.java in Apache Struts 1 1.x through 1.3.10 mishandles multithreaded access to an ActionForm instance, which allows remote attackers to execute arbitrary code or cause a denial of service (unexpected memory access) via a multipart request, a related issue to CVE-2015-0899.", "other": {"cve": {"id": "CVE-2016-1181", "sourceIdentifier": "vultures@jpcert.or.jp", "published": "2016-07-04T22:59:01.617", "lastModified": "2020-07-15T03:15:13.687", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "ActionServlet.java in Apache Struts 1 1.x through 1.3.10 mishandles multithreaded access to an ActionForm instance, which allows remote attackers to execute arbitrary code or cause a denial of service (unexpected memory access) via a multipart request, a related issue to CVE-2015-0899."}, {"lang": "es", "value": "ActionServlet.java en Apache Struts 1 1.x hasta la versi\u00f3n 1.3.10 no maneja adecuadamente accesos multihilo para una instancia ActionForm, lo que permite a atacantes remotos ejecutar c\u00f3digo arbitrario o provocar una denegaci\u00f3n de servicio (acceso inesperado a memoria) a trav\u00e9s de una solicitud multiparte, un problema relacionado con CVE-2015-0899."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "653CDB2C-E0B6-4BEF-A725-3C74BFC2BA0A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "C2BEE49E-A5AA-42D3-B422-460454505480"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "F4FF66F7-10C8-4A1C-910A-EF7D12A4284C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "35AD0C07-9688-4397-8D45-FBB88C0F0C11"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:portal:11.1.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "DE543F18-45AE-4C8B-A953-0CC7C0F10461"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "A5051228-446E-461D-9B5F-8F765C7BA57F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "32FFABC1-74F8-414A-BCC7-7CDC7EB078F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "1239ED60-1581-4FFB-A5FB-4FB898C1EBDA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "08266BA4-A365-4187-AC98-230E040B3B8C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "709E6CEB-461C-4C6C-A3E9-CC37E3AE9E58"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "EE1B8A83-43A4-4C4F-BB95-4D9CAD882D1C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.1:*:*:*:*:*:*:*", "matchCriteriaId": "A55DDFE1-A8AB-47BB-903E-957FCF3D023D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.1:b1:*:*:*:*:*:*", "matchCriteriaId": "93FA9AE3-B453-4FE6-82A9-7DDEF3F6C464"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.1:b2:*:*:*:*:*:*", "matchCriteriaId": "A3BB6FBE-469B-4920-A30B-33AD9E41ACCD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.1:b3:*:*:*:*:*:*", "matchCriteriaId": "34FC82D3-CCAF-4F37-B531-2A9CA17311A9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "E0B8B413-8C62-44B6-A382-26F35F4573D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "6309C679-890A-4214-8857-9F119CBBAA00"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "241A8B39-643B-4371-B629-1636F24DDC97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "4EE7EF4C-CD6F-4B74-89E3-321706B733FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "CD882860-03D0-49E9-8CED-DE6663392548"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "95087298-38D2-4ED6-9D99-494AE90F6DE2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "EDDD509E-9EBF-483F-9546-A1A3A1A3380E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "15BD4B0B-31A2-4DA3-814A-5C959D1BC64A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "B2ECF5E1-457F-4E76-81F7-65114DC4E1E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "2FC81E1A-2779-4FAF-866C-970752CD1828"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "CBD69FAE-C1A3-4213-824A-7DCCE357EB01"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "9C34FDB0-2778-4C36-8345-F7E27509A383"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "CF0302D3-CB8D-4FA7-8F07-C2C7593877BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "8FC3685E-CC47-479D-A418-065ADB38EDD5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "805A4E32-2447-49BB-8631-E41DAA221E10"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "03906D34-F3B3-4C56-A6A6-2F7A10168501"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.3.9:*:*:*:*:*:*:*", "matchCriteriaId": "91CBFC67-BDD8-4579-843A-F93A2661B032"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:struts:1.3.10:*:*:*:*:*:*:*", "matchCriteriaId": "1B3872B7-2972-433D-96A1-154FA545B311"}]}]}], "references": [{"url": "http://jvn.jp/en/jp/JVN03188560/index.html", "source": "vultures@jpcert.or.jp", "tags": ["Vendor Advisory"]}, {"url": "http://jvndb.jvn.jp/jvndb/JVNDB-2016-000096", "source": "vultures@jpcert.or.jp", "tags": ["Third Party Advisory", "VDB Entry", "Vendor Advisory"]}, {"url": "http://www.oracle.com/technetwork/security-advisory/cpujan2018-3236628.html", "source": "vultures@jpcert.or.jp", "tags": ["Patch"]}, {"url": "http://www.oracle.com/technetwork/security-advisory/cpujul2016-2881720.html", "source": "vultures@jpcert.or.jp", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/security-advisory/cpujul2017-3236622.html", "source": "vultures@jpcert.or.jp", "tags": ["Patch"]}, {"url": "http://www.oracle.com/technetwork/security-advisory/cpujul2018-4258247.html", "source": "vultures@jpcert.or.jp", "tags": ["Patch"]}, {"url": "http://www.oracle.com/technetwork/security-advisory/cpuoct2016-2881722.html", "source": "vultures@jpcert.or.jp", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/security-advisory/cpuoct2017-3236626.html", "source": "vultures@jpcert.or.jp", "tags": ["Patch"]}, {"url": "http://www.oracle.com/technetwork/security-advisory/cpuoct2018-4428296.html", "source": "vultures@jpcert.or.jp", "tags": ["Patch"]}, {"url": "http://www.securityfocus.com/bid/91068", "source": "vultures@jpcert.or.jp", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securityfocus.com/bid/91787", "source": "vultures@jpcert.or.jp", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1036056", "source": "vultures@jpcert.or.jp", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1343538", "source": "vultures@jpcert.or.jp", "tags": ["Issue Tracking"]}, {"url": "https://github.com/kawasima/struts1-forever/commit/eda3a79907ed8fcb0387a0496d0cb14332f250e8", "source": "vultures@jpcert.or.jp", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2016-1181", "source": "vultures@jpcert.or.jp", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20180629-0006/", "source": "vultures@jpcert.or.jp", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2020.html", "source": "vultures@jpcert.or.jp"}, {"url": "https://www.oracle.com/security-alerts/cpujul2020.html", "source": "vultures@jpcert.or.jp"}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpuapr2019-5072813.html", "source": "vultures@jpcert.or.jp"}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpujan2019-5072801.html", "source": "vultures@jpcert.or.jp", "tags": ["Patch"]}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpujul2019-5072835.html", "source": "vultures@jpcert.or.jp"}]}, "github_commit_url": "https://github.com/kawasima/struts1-forever/commit/eda3a79907ed8fcb0387a0496d0cb14332f250e8"}}