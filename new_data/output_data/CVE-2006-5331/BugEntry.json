{"buggy_code": ["/*\n *  Copyright (C) 1995-1996  Gary Thomas (gdt@linuxppc.org)\n *\n *  This program is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU General Public License\n *  as published by the Free Software Foundation; either version\n *  2 of the License, or (at your option) any later version.\n *\n *  Modified by Cort Dougan (cort@cs.nmt.edu)\n *  and Paul Mackerras (paulus@samba.org)\n */\n\n/*\n * This file handles the architecture-dependent parts of hardware exceptions\n */\n\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/ptrace.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/a.out.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/prctl.h>\n#include <linux/delay.h>\n#include <linux/kprobes.h>\n#include <linux/kexec.h>\n#include <linux/backlight.h>\n\n#include <asm/kdebug.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/system.h>\n#include <asm/io.h>\n#include <asm/machdep.h>\n#include <asm/rtas.h>\n#include <asm/pmc.h>\n#ifdef CONFIG_PPC32\n#include <asm/reg.h>\n#endif\n#ifdef CONFIG_PMAC_BACKLIGHT\n#include <asm/backlight.h>\n#endif\n#ifdef CONFIG_PPC64\n#include <asm/firmware.h>\n#include <asm/processor.h>\n#endif\n#include <asm/kexec.h>\n\n#ifdef CONFIG_PPC64\t/* XXX */\n#define _IO_BASE\tpci_io_base\n#endif\n\n#ifdef CONFIG_DEBUGGER\nint (*__debugger)(struct pt_regs *regs);\nint (*__debugger_ipi)(struct pt_regs *regs);\nint (*__debugger_bpt)(struct pt_regs *regs);\nint (*__debugger_sstep)(struct pt_regs *regs);\nint (*__debugger_iabr_match)(struct pt_regs *regs);\nint (*__debugger_dabr_match)(struct pt_regs *regs);\nint (*__debugger_fault_handler)(struct pt_regs *regs);\n\nEXPORT_SYMBOL(__debugger);\nEXPORT_SYMBOL(__debugger_ipi);\nEXPORT_SYMBOL(__debugger_bpt);\nEXPORT_SYMBOL(__debugger_sstep);\nEXPORT_SYMBOL(__debugger_iabr_match);\nEXPORT_SYMBOL(__debugger_dabr_match);\nEXPORT_SYMBOL(__debugger_fault_handler);\n#endif\n\nATOMIC_NOTIFIER_HEAD(powerpc_die_chain);\n\nint register_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_register(&powerpc_die_chain, nb);\n}\nEXPORT_SYMBOL(register_die_notifier);\n\nint unregister_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&powerpc_die_chain, nb);\n}\nEXPORT_SYMBOL(unregister_die_notifier);\n\n/*\n * Trap & Exception support\n */\n\nstatic DEFINE_SPINLOCK(die_lock);\n\nint die(const char *str, struct pt_regs *regs, long err)\n{\n\tstatic int die_counter;\n\n\tif (debugger(regs))\n\t\treturn 1;\n\n\tconsole_verbose();\n\tspin_lock_irq(&die_lock);\n\tbust_spinlocks(1);\n#ifdef CONFIG_PMAC_BACKLIGHT\n\tmutex_lock(&pmac_backlight_mutex);\n\tif (machine_is(powermac) && pmac_backlight) {\n\t\tstruct backlight_properties *props;\n\n\t\tdown(&pmac_backlight->sem);\n\t\tprops = pmac_backlight->props;\n\t\tprops->brightness = props->max_brightness;\n\t\tprops->power = FB_BLANK_UNBLANK;\n\t\tprops->update_status(pmac_backlight);\n\t\tup(&pmac_backlight->sem);\n\t}\n\tmutex_unlock(&pmac_backlight_mutex);\n#endif\n\tprintk(\"Oops: %s, sig: %ld [#%d]\\n\", str, err, ++die_counter);\n#ifdef CONFIG_PREEMPT\n\tprintk(\"PREEMPT \");\n#endif\n#ifdef CONFIG_SMP\n\tprintk(\"SMP NR_CPUS=%d \", NR_CPUS);\n#endif\n#ifdef CONFIG_DEBUG_PAGEALLOC\n\tprintk(\"DEBUG_PAGEALLOC \");\n#endif\n#ifdef CONFIG_NUMA\n\tprintk(\"NUMA \");\n#endif\n\tprintk(\"%s\\n\", ppc_md.name ? \"\" : ppc_md.name);\n\n\tprint_modules();\n\tshow_regs(regs);\n\tbust_spinlocks(0);\n\tspin_unlock_irq(&die_lock);\n\n\tif (kexec_should_crash(current) ||\n\t\tkexec_sr_activated(smp_processor_id()))\n\t\tcrash_kexec(regs);\n\tcrash_kexec_secondary(regs);\n\n\tif (in_interrupt())\n\t\tpanic(\"Fatal exception in interrupt\");\n\n\tif (panic_on_oops)\n\t\tpanic(\"Fatal exception\");\n\n\tdo_exit(err);\n\n\treturn 0;\n}\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\n\tif (!user_mode(regs)) {\n\t\tif (die(\"Exception in kernel mode\", regs, signr))\n\t\t\treturn;\n\t}\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n\n\t/*\n\t * Init gets no signals that it doesn't have a handler for.\n\t * That's all very well, but if it has caused a synchronous\n\t * exception and we ignore the resulting signal, it will just\n\t * generate the same exception over and over again and we get\n\t * nowhere.  Better to kill it and let the kernel panic.\n\t */\n\tif (current->pid == 1) {\n\t\t__sighandler_t handler;\n\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\thandler = current->sighand->action[signr-1].sa.sa_handler;\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tif (handler == SIG_DFL) {\n\t\t\t/* init has generated a synchronous exception\n\t\t\t   and it doesn't have a handler for the signal */\n\t\t\tprintk(KERN_CRIT \"init has generated signal %d \"\n\t\t\t       \"but has no handler for it\\n\", signr);\n\t\t\tdo_exit(signr);\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_PPC64\nvoid system_reset_exception(struct pt_regs *regs)\n{\n\t/* See if any machine dependent calls */\n\tif (ppc_md.system_reset_exception) {\n\t\tif (ppc_md.system_reset_exception(regs))\n\t\t\treturn;\n\t}\n\n#ifdef CONFIG_KEXEC\n\tcpu_set(smp_processor_id(), cpus_in_sr);\n#endif\n\n\tdie(\"System Reset\", regs, SIGABRT);\n\n\t/*\n\t * Some CPUs when released from the debugger will execute this path.\n\t * These CPUs entered the debugger via a soft-reset. If the CPU was\n\t * hung before entering the debugger it will return to the hung\n\t * state when exiting this function.  This causes a problem in\n\t * kdump since the hung CPU(s) will not respond to the IPI sent\n\t * from kdump. To prevent the problem we call crash_kexec_secondary()\n\t * here. If a kdump had not been initiated or we exit the debugger\n\t * with the \"exit and recover\" command (x) crash_kexec_secondary()\n\t * will return after 5ms and the CPU returns to its previous state.\n\t */\n\tcrash_kexec_secondary(regs);\n\n\t/* Must die if the interrupt is not recoverable */\n\tif (!(regs->msr & MSR_RI))\n\t\tpanic(\"Unrecoverable System Reset\");\n\n\t/* What should we do here? We could issue a shutdown or hard reset. */\n}\n#endif\n\n/*\n * I/O accesses can cause machine checks on powermacs.\n * Check if the NIP corresponds to the address of a sync\n * instruction for which there is an entry in the exception\n * table.\n * Note that the 601 only takes a machine check on TEA\n * (transfer error ack) signal assertion, and does not\n * set any of the top 16 bits of SRR1.\n *  -- paulus.\n */\nstatic inline int check_io_access(struct pt_regs *regs)\n{\n#if defined(CONFIG_PPC_PMAC) && defined(CONFIG_PPC32)\n\tunsigned long msr = regs->msr;\n\tconst struct exception_table_entry *entry;\n\tunsigned int *nip = (unsigned int *)regs->nip;\n\n\tif (((msr & 0xffff0000) == 0 || (msr & (0x80000 | 0x40000)))\n\t    && (entry = search_exception_tables(regs->nip)) != NULL) {\n\t\t/*\n\t\t * Check that it's a sync instruction, or somewhere\n\t\t * in the twi; isync; nop sequence that inb/inw/inl uses.\n\t\t * As the address is in the exception table\n\t\t * we should be able to read the instr there.\n\t\t * For the debug message, we look at the preceding\n\t\t * load or store.\n\t\t */\n\t\tif (*nip == 0x60000000)\t\t/* nop */\n\t\t\tnip -= 2;\n\t\telse if (*nip == 0x4c00012c)\t/* isync */\n\t\t\t--nip;\n\t\tif (*nip == 0x7c0004ac || (*nip >> 26) == 3) {\n\t\t\t/* sync or twi */\n\t\t\tunsigned int rb;\n\n\t\t\t--nip;\n\t\t\trb = (*nip >> 11) & 0x1f;\n\t\t\tprintk(KERN_DEBUG \"%s bad port %lx at %p\\n\",\n\t\t\t       (*nip & 0x100)? \"OUT to\": \"IN from\",\n\t\t\t       regs->gpr[rb] - _IO_BASE, nip);\n\t\t\tregs->msr |= MSR_RI;\n\t\t\tregs->nip = entry->fixup;\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif /* CONFIG_PPC_PMAC && CONFIG_PPC32 */\n\treturn 0;\n}\n\n#if defined(CONFIG_4xx) || defined(CONFIG_BOOKE)\n/* On 4xx, the reason for the machine check or program exception\n   is in the ESR. */\n#define get_reason(regs)\t((regs)->dsisr)\n#ifndef CONFIG_FSL_BOOKE\n#define get_mc_reason(regs)\t((regs)->dsisr)\n#else\n#define get_mc_reason(regs)\t(mfspr(SPRN_MCSR))\n#endif\n#define REASON_FP\t\tESR_FP\n#define REASON_ILLEGAL\t\t(ESR_PIL | ESR_PUO)\n#define REASON_PRIVILEGED\tESR_PPR\n#define REASON_TRAP\t\tESR_PTR\n\n/* single-step stuff */\n#define single_stepping(regs)\t(current->thread.dbcr0 & DBCR0_IC)\n#define clear_single_step(regs)\t(current->thread.dbcr0 &= ~DBCR0_IC)\n\n#else\n/* On non-4xx, the reason for the machine check or program\n   exception is in the MSR. */\n#define get_reason(regs)\t((regs)->msr)\n#define get_mc_reason(regs)\t((regs)->msr)\n#define REASON_FP\t\t0x100000\n#define REASON_ILLEGAL\t\t0x80000\n#define REASON_PRIVILEGED\t0x40000\n#define REASON_TRAP\t\t0x20000\n\n#define single_stepping(regs)\t((regs)->msr & MSR_SE)\n#define clear_single_step(regs)\t((regs)->msr &= ~MSR_SE)\n#endif\n\n/*\n * This is \"fall-back\" implementation for configurations\n * which don't provide platform-specific machine check info\n */\nvoid __attribute__ ((weak))\nplatform_machine_check(struct pt_regs *regs)\n{\n}\n\nvoid machine_check_exception(struct pt_regs *regs)\n{\n\tint recover = 0;\n\tunsigned long reason = get_mc_reason(regs);\n\n\t/* See if any machine dependent calls */\n\tif (ppc_md.machine_check_exception)\n\t\trecover = ppc_md.machine_check_exception(regs);\n\n\tif (recover)\n\t\treturn;\n\n\tif (user_mode(regs)) {\n\t\tregs->msr |= MSR_RI;\n\t\t_exception(SIGBUS, regs, BUS_ADRERR, regs->nip);\n\t\treturn;\n\t}\n\n#if defined(CONFIG_8xx) && defined(CONFIG_PCI)\n\t/* the qspan pci read routines can cause machine checks -- Cort */\n\tbad_page_fault(regs, regs->dar, SIGBUS);\n\treturn;\n#endif\n\n\tif (debugger_fault_handler(regs)) {\n\t\tregs->msr |= MSR_RI;\n\t\treturn;\n\t}\n\n\tif (check_io_access(regs))\n\t\treturn;\n\n#if defined(CONFIG_4xx) && !defined(CONFIG_440A)\n\tif (reason & ESR_IMCP) {\n\t\tprintk(\"Instruction\");\n\t\tmtspr(SPRN_ESR, reason & ~ESR_IMCP);\n\t} else\n\t\tprintk(\"Data\");\n\tprintk(\" machine check in kernel mode.\\n\");\n#elif defined(CONFIG_440A)\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tif (reason & ESR_IMCP){\n\t\tprintk(\"Instruction Synchronous Machine Check exception\\n\");\n\t\tmtspr(SPRN_ESR, reason & ~ESR_IMCP);\n\t}\n\telse {\n\t\tu32 mcsr = mfspr(SPRN_MCSR);\n\t\tif (mcsr & MCSR_IB)\n\t\t\tprintk(\"Instruction Read PLB Error\\n\");\n\t\tif (mcsr & MCSR_DRB)\n\t\t\tprintk(\"Data Read PLB Error\\n\");\n\t\tif (mcsr & MCSR_DWB)\n\t\t\tprintk(\"Data Write PLB Error\\n\");\n\t\tif (mcsr & MCSR_TLBP)\n\t\t\tprintk(\"TLB Parity Error\\n\");\n\t\tif (mcsr & MCSR_ICP){\n\t\t\tflush_instruction_cache();\n\t\t\tprintk(\"I-Cache Parity Error\\n\");\n\t\t}\n\t\tif (mcsr & MCSR_DCSP)\n\t\t\tprintk(\"D-Cache Search Parity Error\\n\");\n\t\tif (mcsr & MCSR_DCFP)\n\t\t\tprintk(\"D-Cache Flush Parity Error\\n\");\n\t\tif (mcsr & MCSR_IMPE)\n\t\t\tprintk(\"Machine Check exception is imprecise\\n\");\n\n\t\t/* Clear MCSR */\n\t\tmtspr(SPRN_MCSR, mcsr);\n\t}\n#elif defined (CONFIG_E500)\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from MCSR=%lx): \", reason);\n\n\tif (reason & MCSR_MCP)\n\t\tprintk(\"Machine Check Signal\\n\");\n\tif (reason & MCSR_ICPERR)\n\t\tprintk(\"Instruction Cache Parity Error\\n\");\n\tif (reason & MCSR_DCP_PERR)\n\t\tprintk(\"Data Cache Push Parity Error\\n\");\n\tif (reason & MCSR_DCPERR)\n\t\tprintk(\"Data Cache Parity Error\\n\");\n\tif (reason & MCSR_GL_CI)\n\t\tprintk(\"Guarded Load or Cache-Inhibited stwcx.\\n\");\n\tif (reason & MCSR_BUS_IAERR)\n\t\tprintk(\"Bus - Instruction Address Error\\n\");\n\tif (reason & MCSR_BUS_RAERR)\n\t\tprintk(\"Bus - Read Address Error\\n\");\n\tif (reason & MCSR_BUS_WAERR)\n\t\tprintk(\"Bus - Write Address Error\\n\");\n\tif (reason & MCSR_BUS_IBERR)\n\t\tprintk(\"Bus - Instruction Data Error\\n\");\n\tif (reason & MCSR_BUS_RBERR)\n\t\tprintk(\"Bus - Read Data Bus Error\\n\");\n\tif (reason & MCSR_BUS_WBERR)\n\t\tprintk(\"Bus - Read Data Bus Error\\n\");\n\tif (reason & MCSR_BUS_IPERR)\n\t\tprintk(\"Bus - Instruction Parity Error\\n\");\n\tif (reason & MCSR_BUS_RPERR)\n\t\tprintk(\"Bus - Read Parity Error\\n\");\n#elif defined (CONFIG_E200)\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from MCSR=%lx): \", reason);\n\n\tif (reason & MCSR_MCP)\n\t\tprintk(\"Machine Check Signal\\n\");\n\tif (reason & MCSR_CP_PERR)\n\t\tprintk(\"Cache Push Parity Error\\n\");\n\tif (reason & MCSR_CPERR)\n\t\tprintk(\"Cache Parity Error\\n\");\n\tif (reason & MCSR_EXCP_ERR)\n\t\tprintk(\"ISI, ITLB, or Bus Error on first instruction fetch for an exception handler\\n\");\n\tif (reason & MCSR_BUS_IRERR)\n\t\tprintk(\"Bus - Read Bus Error on instruction fetch\\n\");\n\tif (reason & MCSR_BUS_DRERR)\n\t\tprintk(\"Bus - Read Bus Error on data load\\n\");\n\tif (reason & MCSR_BUS_WRERR)\n\t\tprintk(\"Bus - Write Bus Error on buffered store or cache line push\\n\");\n#else /* !CONFIG_4xx && !CONFIG_E500 && !CONFIG_E200 */\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from SRR1=%lx): \", reason);\n\tswitch (reason & 0x601F0000) {\n\tcase 0x80000:\n\t\tprintk(\"Machine check signal\\n\");\n\t\tbreak;\n\tcase 0:\t\t/* for 601 */\n\tcase 0x40000:\n\tcase 0x140000:\t/* 7450 MSS error and TEA */\n\t\tprintk(\"Transfer error ack signal\\n\");\n\t\tbreak;\n\tcase 0x20000:\n\t\tprintk(\"Data parity error signal\\n\");\n\t\tbreak;\n\tcase 0x10000:\n\t\tprintk(\"Address parity error signal\\n\");\n\t\tbreak;\n\tcase 0x20000000:\n\t\tprintk(\"L1 Data Cache error\\n\");\n\t\tbreak;\n\tcase 0x40000000:\n\t\tprintk(\"L1 Instruction Cache error\\n\");\n\t\tbreak;\n\tcase 0x00100000:\n\t\tprintk(\"L2 data cache parity error\\n\");\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"Unknown values in msr\\n\");\n\t}\n#endif /* CONFIG_4xx */\n\n\t/*\n\t * Optional platform-provided routine to print out\n\t * additional info, e.g. bus error registers.\n\t */\n\tplatform_machine_check(regs);\n\n\tif (debugger_fault_handler(regs))\n\t\treturn;\n\tdie(\"Machine check\", regs, SIGBUS);\n\n\t/* Must die if the interrupt is not recoverable */\n\tif (!(regs->msr & MSR_RI))\n\t\tpanic(\"Unrecoverable Machine check\");\n}\n\nvoid SMIException(struct pt_regs *regs)\n{\n\tdie(\"System Management Interrupt\", regs, SIGABRT);\n}\n\nvoid unknown_exception(struct pt_regs *regs)\n{\n\tprintk(\"Bad trap at PC: %lx, SR: %lx, vector=%lx\\n\",\n\t       regs->nip, regs->msr, regs->trap);\n\n\t_exception(SIGTRAP, regs, 0, 0);\n}\n\nvoid instruction_breakpoint_exception(struct pt_regs *regs)\n{\n\tif (notify_die(DIE_IABR_MATCH, \"iabr_match\", regs, 5,\n\t\t\t\t\t5, SIGTRAP) == NOTIFY_STOP)\n\t\treturn;\n\tif (debugger_iabr_match(regs))\n\t\treturn;\n\t_exception(SIGTRAP, regs, TRAP_BRKPT, regs->nip);\n}\n\nvoid RunModeException(struct pt_regs *regs)\n{\n\t_exception(SIGTRAP, regs, 0, 0);\n}\n\nvoid __kprobes single_step_exception(struct pt_regs *regs)\n{\n\tregs->msr &= ~(MSR_SE | MSR_BE);  /* Turn off 'trace' bits */\n\n\tif (notify_die(DIE_SSTEP, \"single_step\", regs, 5,\n\t\t\t\t\t5, SIGTRAP) == NOTIFY_STOP)\n\t\treturn;\n\tif (debugger_sstep(regs))\n\t\treturn;\n\n\t_exception(SIGTRAP, regs, TRAP_TRACE, regs->nip);\n}\n\n/*\n * After we have successfully emulated an instruction, we have to\n * check if the instruction was being single-stepped, and if so,\n * pretend we got a single-step exception.  This was pointed out\n * by Kumar Gala.  -- paulus\n */\nstatic void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs)) {\n\t\tclear_single_step(regs);\n\t\t_exception(SIGTRAP, regs, TRAP_TRACE, 0);\n\t}\n}\n\nstatic void parse_fpe(struct pt_regs *regs)\n{\n\tint code = 0;\n\tunsigned long fpscr;\n\n\tflush_fp_to_thread(current);\n\n\tfpscr = current->thread.fpscr.val;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tcode = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tcode = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tcode = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tcode = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tcode = FPE_FLTRES;\n\n\t_exception(SIGFPE, regs, code, regs->nip);\n}\n\n/*\n * Illegal instruction emulation support.  Originally written to\n * provide the PVR to user applications using the mfspr rd, PVR.\n * Return non-zero if we can't emulate, or -EFAULT if the associated\n * memory access caused an access fault.  Return zero on success.\n *\n * There are a couple of ways to do this, either \"decode\" the instruction\n * or directly match lots of bits.  In this case, matching lots of\n * bits is faster and easier.\n *\n */\n#define INST_MFSPR_PVR\t\t0x7c1f42a6\n#define INST_MFSPR_PVR_MASK\t0xfc1fffff\n\n#define INST_DCBA\t\t0x7c0005ec\n#define INST_DCBA_MASK\t\t0xfc0007fe\n\n#define INST_MCRXR\t\t0x7c000400\n#define INST_MCRXR_MASK\t\t0xfc0007fe\n\n#define INST_STRING\t\t0x7c00042a\n#define INST_STRING_MASK\t0xfc0007fe\n#define INST_STRING_GEN_MASK\t0xfc00067e\n#define INST_LSWI\t\t0x7c0004aa\n#define INST_LSWX\t\t0x7c00042a\n#define INST_STSWI\t\t0x7c0005aa\n#define INST_STSWX\t\t0x7c00052a\n\n#define INST_POPCNTB\t\t0x7c0000f4\n#define INST_POPCNTB_MASK\t0xfc0007fe\n\nstatic int emulate_string_inst(struct pt_regs *regs, u32 instword)\n{\n\tu8 rT = (instword >> 21) & 0x1f;\n\tu8 rA = (instword >> 16) & 0x1f;\n\tu8 NB_RB = (instword >> 11) & 0x1f;\n\tu32 num_bytes;\n\tunsigned long EA;\n\tint pos = 0;\n\n\t/* Early out if we are an invalid form of lswx */\n\tif ((instword & INST_STRING_MASK) == INST_LSWX)\n\t\tif ((rT == rA) || (rT == NB_RB))\n\t\t\treturn -EINVAL;\n\n\tEA = (rA == 0) ? 0 : regs->gpr[rA];\n\n\tswitch (instword & INST_STRING_MASK) {\n\t\tcase INST_LSWX:\n\t\tcase INST_STSWX:\n\t\t\tEA += NB_RB;\n\t\t\tnum_bytes = regs->xer & 0x7f;\n\t\t\tbreak;\n\t\tcase INST_LSWI:\n\t\tcase INST_STSWI:\n\t\t\tnum_bytes = (NB_RB == 0) ? 32 : NB_RB;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\twhile (num_bytes != 0)\n\t{\n\t\tu8 val;\n\t\tu32 shift = 8 * (3 - (pos & 0x3));\n\n\t\tswitch ((instword & INST_STRING_MASK)) {\n\t\t\tcase INST_LSWX:\n\t\t\tcase INST_LSWI:\n\t\t\t\tif (get_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t/* first time updating this reg,\n\t\t\t\t * zero it out */\n\t\t\t\tif (pos == 0)\n\t\t\t\t\tregs->gpr[rT] = 0;\n\t\t\t\tregs->gpr[rT] |= val << shift;\n\t\t\t\tbreak;\n\t\t\tcase INST_STSWI:\n\t\t\tcase INST_STSWX:\n\t\t\t\tval = regs->gpr[rT] >> shift;\n\t\t\t\tif (put_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tbreak;\n\t\t}\n\t\t/* move EA to next address */\n\t\tEA += 1;\n\t\tnum_bytes--;\n\n\t\t/* manage our position within the register */\n\t\tif (++pos == 4) {\n\t\t\tpos = 0;\n\t\t\tif (++rT == 32)\n\t\t\t\trT = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int emulate_popcntb_inst(struct pt_regs *regs, u32 instword)\n{\n\tu32 ra,rs;\n\tunsigned long tmp;\n\n\tra = (instword >> 16) & 0x1f;\n\trs = (instword >> 21) & 0x1f;\n\n\ttmp = regs->gpr[rs];\n\ttmp = tmp - ((tmp >> 1) & 0x5555555555555555ULL);\n\ttmp = (tmp & 0x3333333333333333ULL) + ((tmp >> 2) & 0x3333333333333333ULL);\n\ttmp = (tmp + (tmp >> 4)) & 0x0f0f0f0f0f0f0f0fULL;\n\tregs->gpr[ra] = tmp;\n\n\treturn 0;\n}\n\nstatic int emulate_instruction(struct pt_regs *regs)\n{\n\tu32 instword;\n\tu32 rd;\n\n\tif (!user_mode(regs) || (regs->msr & MSR_LE))\n\t\treturn -EINVAL;\n\tCHECK_FULL_REGS(regs);\n\n\tif (get_user(instword, (u32 __user *)(regs->nip)))\n\t\treturn -EFAULT;\n\n\t/* Emulate the mfspr rD, PVR. */\n\tif ((instword & INST_MFSPR_PVR_MASK) == INST_MFSPR_PVR) {\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_PVR);\n\t\treturn 0;\n\t}\n\n\t/* Emulating the dcba insn is just a no-op.  */\n\tif ((instword & INST_DCBA_MASK) == INST_DCBA)\n\t\treturn 0;\n\n\t/* Emulate the mcrxr insn.  */\n\tif ((instword & INST_MCRXR_MASK) == INST_MCRXR) {\n\t\tint shift = (instword >> 21) & 0x1c;\n\t\tunsigned long msk = 0xf0000000UL >> shift;\n\n\t\tregs->ccr = (regs->ccr & ~msk) | ((regs->xer >> shift) & msk);\n\t\tregs->xer &= ~0xf0000000UL;\n\t\treturn 0;\n\t}\n\n\t/* Emulate load/store string insn. */\n\tif ((instword & INST_STRING_GEN_MASK) == INST_STRING)\n\t\treturn emulate_string_inst(regs, instword);\n\n\t/* Emulate the popcntb (Population Count Bytes) instruction. */\n\tif ((instword & INST_POPCNTB_MASK) == INST_POPCNTB) {\n\t\treturn emulate_popcntb_inst(regs, instword);\n\t}\n\n\treturn -EINVAL;\n}\n\n/*\n * Look through the list of trap instructions that are used for BUG(),\n * BUG_ON() and WARN_ON() and see if we hit one.  At this point we know\n * that the exception was caused by a trap instruction of some kind.\n * Returns 1 if we should continue (i.e. it was a WARN_ON) or 0\n * otherwise.\n */\nextern struct bug_entry __start___bug_table[], __stop___bug_table[];\n\n#ifndef CONFIG_MODULES\n#define module_find_bug(x)\tNULL\n#endif\n\nstruct bug_entry *find_bug(unsigned long bugaddr)\n{\n\tstruct bug_entry *bug;\n\n\tfor (bug = __start___bug_table; bug < __stop___bug_table; ++bug)\n\t\tif (bugaddr == bug->bug_addr)\n\t\t\treturn bug;\n\treturn module_find_bug(bugaddr);\n}\n\nstatic int check_bug_trap(struct pt_regs *regs)\n{\n\tstruct bug_entry *bug;\n\tunsigned long addr;\n\n\tif (regs->msr & MSR_PR)\n\t\treturn 0;\t/* not in kernel */\n\taddr = regs->nip;\t/* address of trap instruction */\n\tif (addr < PAGE_OFFSET)\n\t\treturn 0;\n\tbug = find_bug(regs->nip);\n\tif (bug == NULL)\n\t\treturn 0;\n\tif (bug->line & BUG_WARNING_TRAP) {\n\t\t/* this is a WARN_ON rather than BUG/BUG_ON */\n\t\tprintk(KERN_ERR \"Badness in %s at %s:%ld\\n\",\n\t\t       bug->function, bug->file,\n\t\t       bug->line & ~BUG_WARNING_TRAP);\n\t\tdump_stack();\n\t\treturn 1;\n\t}\n\tprintk(KERN_CRIT \"kernel BUG in %s at %s:%ld!\\n\",\n\t       bug->function, bug->file, bug->line);\n\n\treturn 0;\n}\n\nvoid __kprobes program_check_exception(struct pt_regs *regs)\n{\n\tunsigned int reason = get_reason(regs);\n\textern int do_mathemu(struct pt_regs *regs);\n\n#ifdef CONFIG_MATH_EMULATION\n\t/* (reason & REASON_ILLEGAL) would be the obvious thing here,\n\t * but there seems to be a hardware bug on the 405GP (RevD)\n\t * that means ESR is sometimes set incorrectly - either to\n\t * ESR_DST (!?) or 0.  In the process of chasing this with the\n\t * hardware people - not sure if it can happen on any illegal\n\t * instruction or only on FP instructions, whether there is a\n\t * pattern to occurences etc. -dgibson 31/Mar/2003 */\n\tif (!(reason & REASON_TRAP) && do_mathemu(regs) == 0) {\n\t\temulate_single_step(regs);\n\t\treturn;\n\t}\n#endif /* CONFIG_MATH_EMULATION */\n\n\tif (reason & REASON_FP) {\n\t\t/* IEEE FP exception */\n\t\tparse_fpe(regs);\n\t\treturn;\n\t}\n\tif (reason & REASON_TRAP) {\n\t\t/* trap exception */\n\t\tif (notify_die(DIE_BPT, \"breakpoint\", regs, 5, 5, SIGTRAP)\n\t\t\t\t== NOTIFY_STOP)\n\t\t\treturn;\n\t\tif (debugger_bpt(regs))\n\t\t\treturn;\n\t\tif (check_bug_trap(regs)) {\n\t\t\tregs->nip += 4;\n\t\t\treturn;\n\t\t}\n\t\t_exception(SIGTRAP, regs, TRAP_BRKPT, regs->nip);\n\t\treturn;\n\t}\n\n\tlocal_irq_enable();\n\n\t/* Try to emulate it if we should. */\n\tif (reason & (REASON_ILLEGAL | REASON_PRIVILEGED)) {\n\t\tswitch (emulate_instruction(regs)) {\n\t\tcase 0:\n\t\t\tregs->nip += 4;\n\t\t\temulate_single_step(regs);\n\t\t\treturn;\n\t\tcase -EFAULT:\n\t\t\t_exception(SIGSEGV, regs, SEGV_MAPERR, regs->nip);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (reason & REASON_PRIVILEGED)\n\t\t_exception(SIGILL, regs, ILL_PRVOPC, regs->nip);\n\telse\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n}\n\nvoid alignment_exception(struct pt_regs *regs)\n{\n\tint fixed = 0;\n\n\t/* we don't implement logging of alignment exceptions */\n\tif (!(current->thread.align_ctl & PR_UNALIGN_SIGBUS))\n\t\tfixed = fix_alignment(regs);\n\n\tif (fixed == 1) {\n\t\tregs->nip += 4;\t/* skip over emulated instruction */\n\t\temulate_single_step(regs);\n\t\treturn;\n\t}\n\n\t/* Operand address was bad */\n\tif (fixed == -EFAULT) {\n\t\tif (user_mode(regs))\n\t\t\t_exception(SIGSEGV, regs, SEGV_ACCERR, regs->dar);\n\t\telse\n\t\t\t/* Search exception table */\n\t\t\tbad_page_fault(regs, regs->dar, SIGSEGV);\n\t\treturn;\n\t}\n\t_exception(SIGBUS, regs, BUS_ADRALN, regs->dar);\n}\n\nvoid StackOverflow(struct pt_regs *regs)\n{\n\tprintk(KERN_CRIT \"Kernel stack overflow in process %p, r1=%lx\\n\",\n\t       current, regs->gpr[1]);\n\tdebugger(regs);\n\tshow_regs(regs);\n\tpanic(\"kernel stack overflow\");\n}\n\nvoid nonrecoverable_exception(struct pt_regs *regs)\n{\n\tprintk(KERN_ERR \"Non-recoverable exception at PC=%lx MSR=%lx\\n\",\n\t       regs->nip, regs->msr);\n\tdebugger(regs);\n\tdie(\"nonrecoverable exception\", regs, SIGKILL);\n}\n\nvoid trace_syscall(struct pt_regs *regs)\n{\n\tprintk(\"Task: %p(%d), PC: %08lX/%08lX, Syscall: %3ld, Result: %s%ld    %s\\n\",\n\t       current, current->pid, regs->nip, regs->link, regs->gpr[0],\n\t       regs->ccr&0x10000000?\"Error=\":\"\", regs->gpr[3], print_tainted());\n}\n\nvoid kernel_fp_unavailable_exception(struct pt_regs *regs)\n{\n\tprintk(KERN_EMERG \"Unrecoverable FP Unavailable Exception \"\n\t\t\t  \"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable FP Unavailable Exception\", regs, SIGABRT);\n}\n\nvoid altivec_unavailable_exception(struct pt_regs *regs)\n{\n#if !defined(CONFIG_ALTIVEC)\n\tif (user_mode(regs)) {\n\t\t/* A user program has executed an altivec instruction,\n\t\t   but this kernel doesn't support altivec. */\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n#endif\n\tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n}\n\nvoid performance_monitor_exception(struct pt_regs *regs)\n{\n\tperf_irq(regs);\n}\n\n#ifdef CONFIG_8xx\nvoid SoftwareEmulation(struct pt_regs *regs)\n{\n\textern int do_mathemu(struct pt_regs *);\n\textern int Soft_emulate_8xx(struct pt_regs *);\n\tint errcode;\n\n\tCHECK_FULL_REGS(regs);\n\n\tif (!user_mode(regs)) {\n\t\tdebugger(regs);\n\t\tdie(\"Kernel Mode Software FPU Emulation\", regs, SIGFPE);\n\t}\n\n#ifdef CONFIG_MATH_EMULATION\n\terrcode = do_mathemu(regs);\n#else\n\terrcode = Soft_emulate_8xx(regs);\n#endif\n\tif (errcode) {\n\t\tif (errcode > 0)\n\t\t\t_exception(SIGFPE, regs, 0, 0);\n\t\telse if (errcode == -EFAULT)\n\t\t\t_exception(SIGSEGV, regs, 0, 0);\n\t\telse\n\t\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t} else\n\t\temulate_single_step(regs);\n}\n#endif /* CONFIG_8xx */\n\n#if defined(CONFIG_40x) || defined(CONFIG_BOOKE)\n\nvoid DebugException(struct pt_regs *regs, unsigned long debug_status)\n{\n\tif (debug_status & DBSR_IC) {\t/* instruction completion */\n\t\tregs->msr &= ~MSR_DE;\n\t\tif (user_mode(regs)) {\n\t\t\tcurrent->thread.dbcr0 &= ~DBCR0_IC;\n\t\t} else {\n\t\t\t/* Disable instruction completion */\n\t\t\tmtspr(SPRN_DBCR0, mfspr(SPRN_DBCR0) & ~DBCR0_IC);\n\t\t\t/* Clear the instruction completion event */\n\t\t\tmtspr(SPRN_DBSR, DBSR_IC);\n\t\t\tif (debugger_sstep(regs))\n\t\t\t\treturn;\n\t\t}\n\t\t_exception(SIGTRAP, regs, TRAP_TRACE, 0);\n\t}\n}\n#endif /* CONFIG_4xx || CONFIG_BOOKE */\n\n#if !defined(CONFIG_TAU_INT)\nvoid TAUException(struct pt_regs *regs)\n{\n\tprintk(\"TAU trap at PC: %lx, MSR: %lx, vector=%lx    %s\\n\",\n\t       regs->nip, regs->msr, regs->trap, print_tainted());\n}\n#endif /* CONFIG_INT_TAU */\n\n#ifdef CONFIG_ALTIVEC\nvoid altivec_assist_exception(struct pt_regs *regs)\n{\n\tint err;\n\n\tif (!user_mode(regs)) {\n\t\tprintk(KERN_EMERG \"VMX/Altivec assist exception in kernel mode\"\n\t\t       \" at %lx\\n\", regs->nip);\n\t\tdie(\"Kernel VMX/Altivec assist exception\", regs, SIGILL);\n\t}\n\n\tflush_altivec_to_thread(current);\n\n\terr = emulate_altivec(regs);\n\tif (err == 0) {\n\t\tregs->nip += 4;\t\t/* skip emulated instruction */\n\t\temulate_single_step(regs);\n\t\treturn;\n\t}\n\n\tif (err == -EFAULT) {\n\t\t/* got an error reading the instruction */\n\t\t_exception(SIGSEGV, regs, SEGV_ACCERR, regs->nip);\n\t} else {\n\t\t/* didn't recognize the instruction */\n\t\t/* XXX quick hack for now: set the non-Java bit in the VSCR */\n\t\tif (printk_ratelimit())\n\t\t\tprintk(KERN_ERR \"Unrecognized altivec instruction \"\n\t\t\t       \"in %s at %lx\\n\", current->comm, regs->nip);\n\t\tcurrent->thread.vscr.u[3] |= 0x10000;\n\t}\n}\n#endif /* CONFIG_ALTIVEC */\n\n#ifdef CONFIG_FSL_BOOKE\nvoid CacheLockingException(struct pt_regs *regs, unsigned long address,\n\t\t\t   unsigned long error_code)\n{\n\t/* We treat cache locking instructions from the user\n\t * as priv ops, in the future we could try to do\n\t * something smarter\n\t */\n\tif (error_code & (ESR_DLK|ESR_ILK))\n\t\t_exception(SIGILL, regs, ILL_PRVOPC, regs->nip);\n\treturn;\n}\n#endif /* CONFIG_FSL_BOOKE */\n\n#ifdef CONFIG_SPE\nvoid SPEFloatingPointException(struct pt_regs *regs)\n{\n\tunsigned long spefscr;\n\tint fpexc_mode;\n\tint code = 0;\n\n\tspefscr = current->thread.spefscr;\n\tfpexc_mode = current->thread.fpexc_mode;\n\n\t/* Hardware does not neccessarily set sticky\n\t * underflow/overflow/invalid flags */\n\tif ((spefscr & SPEFSCR_FOVF) && (fpexc_mode & PR_FP_EXC_OVF)) {\n\t\tcode = FPE_FLTOVF;\n\t\tspefscr |= SPEFSCR_FOVFS;\n\t}\n\telse if ((spefscr & SPEFSCR_FUNF) && (fpexc_mode & PR_FP_EXC_UND)) {\n\t\tcode = FPE_FLTUND;\n\t\tspefscr |= SPEFSCR_FUNFS;\n\t}\n\telse if ((spefscr & SPEFSCR_FDBZ) && (fpexc_mode & PR_FP_EXC_DIV))\n\t\tcode = FPE_FLTDIV;\n\telse if ((spefscr & SPEFSCR_FINV) && (fpexc_mode & PR_FP_EXC_INV)) {\n\t\tcode = FPE_FLTINV;\n\t\tspefscr |= SPEFSCR_FINVS;\n\t}\n\telse if ((spefscr & (SPEFSCR_FG | SPEFSCR_FX)) && (fpexc_mode & PR_FP_EXC_RES))\n\t\tcode = FPE_FLTRES;\n\n\tcurrent->thread.spefscr = spefscr;\n\n\t_exception(SIGFPE, regs, code, regs->nip);\n\treturn;\n}\n#endif\n\n/*\n * We enter here if we get an unrecoverable exception, that is, one\n * that happened at a point where the RI (recoverable interrupt) bit\n * in the MSR is 0.  This indicates that SRR0/1 are live, and that\n * we therefore lost state by taking this exception.\n */\nvoid unrecoverable_exception(struct pt_regs *regs)\n{\n\tprintk(KERN_EMERG \"Unrecoverable exception %lx at %lx\\n\",\n\t       regs->trap, regs->nip);\n\tdie(\"Unrecoverable exception\", regs, SIGABRT);\n}\n\n#ifdef CONFIG_BOOKE_WDT\n/*\n * Default handler for a Watchdog exception,\n * spins until a reboot occurs\n */\nvoid __attribute__ ((weak)) WatchdogHandler(struct pt_regs *regs)\n{\n\t/* Generic WatchdogHandler, implement your own */\n\tmtspr(SPRN_TCR, mfspr(SPRN_TCR)&(~TCR_WIE));\n\treturn;\n}\n\nvoid WatchdogException(struct pt_regs *regs)\n{\n\tprintk (KERN_EMERG \"PowerPC Book-E Watchdog Exception\\n\");\n\tWatchdogHandler(regs);\n}\n#endif\n\n/*\n * We enter here if we discover during exception entry that we are\n * running in supervisor mode with a userspace value in the stack pointer.\n */\nvoid kernel_bad_stack(struct pt_regs *regs)\n{\n\tprintk(KERN_EMERG \"Bad kernel stack pointer %lx at %lx\\n\",\n\t       regs->gpr[1], regs->nip);\n\tdie(\"Bad kernel stack pointer\", regs, SIGABRT);\n}\n\nvoid __init trap_init(void)\n{\n}\n"], "fixing_code": ["/*\n *  Copyright (C) 1995-1996  Gary Thomas (gdt@linuxppc.org)\n *\n *  This program is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU General Public License\n *  as published by the Free Software Foundation; either version\n *  2 of the License, or (at your option) any later version.\n *\n *  Modified by Cort Dougan (cort@cs.nmt.edu)\n *  and Paul Mackerras (paulus@samba.org)\n */\n\n/*\n * This file handles the architecture-dependent parts of hardware exceptions\n */\n\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/ptrace.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/a.out.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/prctl.h>\n#include <linux/delay.h>\n#include <linux/kprobes.h>\n#include <linux/kexec.h>\n#include <linux/backlight.h>\n\n#include <asm/kdebug.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/system.h>\n#include <asm/io.h>\n#include <asm/machdep.h>\n#include <asm/rtas.h>\n#include <asm/pmc.h>\n#ifdef CONFIG_PPC32\n#include <asm/reg.h>\n#endif\n#ifdef CONFIG_PMAC_BACKLIGHT\n#include <asm/backlight.h>\n#endif\n#ifdef CONFIG_PPC64\n#include <asm/firmware.h>\n#include <asm/processor.h>\n#endif\n#include <asm/kexec.h>\n\n#ifdef CONFIG_PPC64\t/* XXX */\n#define _IO_BASE\tpci_io_base\n#endif\n\n#ifdef CONFIG_DEBUGGER\nint (*__debugger)(struct pt_regs *regs);\nint (*__debugger_ipi)(struct pt_regs *regs);\nint (*__debugger_bpt)(struct pt_regs *regs);\nint (*__debugger_sstep)(struct pt_regs *regs);\nint (*__debugger_iabr_match)(struct pt_regs *regs);\nint (*__debugger_dabr_match)(struct pt_regs *regs);\nint (*__debugger_fault_handler)(struct pt_regs *regs);\n\nEXPORT_SYMBOL(__debugger);\nEXPORT_SYMBOL(__debugger_ipi);\nEXPORT_SYMBOL(__debugger_bpt);\nEXPORT_SYMBOL(__debugger_sstep);\nEXPORT_SYMBOL(__debugger_iabr_match);\nEXPORT_SYMBOL(__debugger_dabr_match);\nEXPORT_SYMBOL(__debugger_fault_handler);\n#endif\n\nATOMIC_NOTIFIER_HEAD(powerpc_die_chain);\n\nint register_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_register(&powerpc_die_chain, nb);\n}\nEXPORT_SYMBOL(register_die_notifier);\n\nint unregister_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&powerpc_die_chain, nb);\n}\nEXPORT_SYMBOL(unregister_die_notifier);\n\n/*\n * Trap & Exception support\n */\n\nstatic DEFINE_SPINLOCK(die_lock);\n\nint die(const char *str, struct pt_regs *regs, long err)\n{\n\tstatic int die_counter;\n\n\tif (debugger(regs))\n\t\treturn 1;\n\n\tconsole_verbose();\n\tspin_lock_irq(&die_lock);\n\tbust_spinlocks(1);\n#ifdef CONFIG_PMAC_BACKLIGHT\n\tmutex_lock(&pmac_backlight_mutex);\n\tif (machine_is(powermac) && pmac_backlight) {\n\t\tstruct backlight_properties *props;\n\n\t\tdown(&pmac_backlight->sem);\n\t\tprops = pmac_backlight->props;\n\t\tprops->brightness = props->max_brightness;\n\t\tprops->power = FB_BLANK_UNBLANK;\n\t\tprops->update_status(pmac_backlight);\n\t\tup(&pmac_backlight->sem);\n\t}\n\tmutex_unlock(&pmac_backlight_mutex);\n#endif\n\tprintk(\"Oops: %s, sig: %ld [#%d]\\n\", str, err, ++die_counter);\n#ifdef CONFIG_PREEMPT\n\tprintk(\"PREEMPT \");\n#endif\n#ifdef CONFIG_SMP\n\tprintk(\"SMP NR_CPUS=%d \", NR_CPUS);\n#endif\n#ifdef CONFIG_DEBUG_PAGEALLOC\n\tprintk(\"DEBUG_PAGEALLOC \");\n#endif\n#ifdef CONFIG_NUMA\n\tprintk(\"NUMA \");\n#endif\n\tprintk(\"%s\\n\", ppc_md.name ? \"\" : ppc_md.name);\n\n\tprint_modules();\n\tshow_regs(regs);\n\tbust_spinlocks(0);\n\tspin_unlock_irq(&die_lock);\n\n\tif (kexec_should_crash(current) ||\n\t\tkexec_sr_activated(smp_processor_id()))\n\t\tcrash_kexec(regs);\n\tcrash_kexec_secondary(regs);\n\n\tif (in_interrupt())\n\t\tpanic(\"Fatal exception in interrupt\");\n\n\tif (panic_on_oops)\n\t\tpanic(\"Fatal exception\");\n\n\tdo_exit(err);\n\n\treturn 0;\n}\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tsiginfo_t info;\n\n\tif (!user_mode(regs)) {\n\t\tif (die(\"Exception in kernel mode\", regs, signr))\n\t\t\treturn;\n\t}\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.si_signo = signr;\n\tinfo.si_code = code;\n\tinfo.si_addr = (void __user *) addr;\n\tforce_sig_info(signr, &info, current);\n\n\t/*\n\t * Init gets no signals that it doesn't have a handler for.\n\t * That's all very well, but if it has caused a synchronous\n\t * exception and we ignore the resulting signal, it will just\n\t * generate the same exception over and over again and we get\n\t * nowhere.  Better to kill it and let the kernel panic.\n\t */\n\tif (current->pid == 1) {\n\t\t__sighandler_t handler;\n\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\thandler = current->sighand->action[signr-1].sa.sa_handler;\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tif (handler == SIG_DFL) {\n\t\t\t/* init has generated a synchronous exception\n\t\t\t   and it doesn't have a handler for the signal */\n\t\t\tprintk(KERN_CRIT \"init has generated signal %d \"\n\t\t\t       \"but has no handler for it\\n\", signr);\n\t\t\tdo_exit(signr);\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_PPC64\nvoid system_reset_exception(struct pt_regs *regs)\n{\n\t/* See if any machine dependent calls */\n\tif (ppc_md.system_reset_exception) {\n\t\tif (ppc_md.system_reset_exception(regs))\n\t\t\treturn;\n\t}\n\n#ifdef CONFIG_KEXEC\n\tcpu_set(smp_processor_id(), cpus_in_sr);\n#endif\n\n\tdie(\"System Reset\", regs, SIGABRT);\n\n\t/*\n\t * Some CPUs when released from the debugger will execute this path.\n\t * These CPUs entered the debugger via a soft-reset. If the CPU was\n\t * hung before entering the debugger it will return to the hung\n\t * state when exiting this function.  This causes a problem in\n\t * kdump since the hung CPU(s) will not respond to the IPI sent\n\t * from kdump. To prevent the problem we call crash_kexec_secondary()\n\t * here. If a kdump had not been initiated or we exit the debugger\n\t * with the \"exit and recover\" command (x) crash_kexec_secondary()\n\t * will return after 5ms and the CPU returns to its previous state.\n\t */\n\tcrash_kexec_secondary(regs);\n\n\t/* Must die if the interrupt is not recoverable */\n\tif (!(regs->msr & MSR_RI))\n\t\tpanic(\"Unrecoverable System Reset\");\n\n\t/* What should we do here? We could issue a shutdown or hard reset. */\n}\n#endif\n\n/*\n * I/O accesses can cause machine checks on powermacs.\n * Check if the NIP corresponds to the address of a sync\n * instruction for which there is an entry in the exception\n * table.\n * Note that the 601 only takes a machine check on TEA\n * (transfer error ack) signal assertion, and does not\n * set any of the top 16 bits of SRR1.\n *  -- paulus.\n */\nstatic inline int check_io_access(struct pt_regs *regs)\n{\n#if defined(CONFIG_PPC_PMAC) && defined(CONFIG_PPC32)\n\tunsigned long msr = regs->msr;\n\tconst struct exception_table_entry *entry;\n\tunsigned int *nip = (unsigned int *)regs->nip;\n\n\tif (((msr & 0xffff0000) == 0 || (msr & (0x80000 | 0x40000)))\n\t    && (entry = search_exception_tables(regs->nip)) != NULL) {\n\t\t/*\n\t\t * Check that it's a sync instruction, or somewhere\n\t\t * in the twi; isync; nop sequence that inb/inw/inl uses.\n\t\t * As the address is in the exception table\n\t\t * we should be able to read the instr there.\n\t\t * For the debug message, we look at the preceding\n\t\t * load or store.\n\t\t */\n\t\tif (*nip == 0x60000000)\t\t/* nop */\n\t\t\tnip -= 2;\n\t\telse if (*nip == 0x4c00012c)\t/* isync */\n\t\t\t--nip;\n\t\tif (*nip == 0x7c0004ac || (*nip >> 26) == 3) {\n\t\t\t/* sync or twi */\n\t\t\tunsigned int rb;\n\n\t\t\t--nip;\n\t\t\trb = (*nip >> 11) & 0x1f;\n\t\t\tprintk(KERN_DEBUG \"%s bad port %lx at %p\\n\",\n\t\t\t       (*nip & 0x100)? \"OUT to\": \"IN from\",\n\t\t\t       regs->gpr[rb] - _IO_BASE, nip);\n\t\t\tregs->msr |= MSR_RI;\n\t\t\tregs->nip = entry->fixup;\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif /* CONFIG_PPC_PMAC && CONFIG_PPC32 */\n\treturn 0;\n}\n\n#if defined(CONFIG_4xx) || defined(CONFIG_BOOKE)\n/* On 4xx, the reason for the machine check or program exception\n   is in the ESR. */\n#define get_reason(regs)\t((regs)->dsisr)\n#ifndef CONFIG_FSL_BOOKE\n#define get_mc_reason(regs)\t((regs)->dsisr)\n#else\n#define get_mc_reason(regs)\t(mfspr(SPRN_MCSR))\n#endif\n#define REASON_FP\t\tESR_FP\n#define REASON_ILLEGAL\t\t(ESR_PIL | ESR_PUO)\n#define REASON_PRIVILEGED\tESR_PPR\n#define REASON_TRAP\t\tESR_PTR\n\n/* single-step stuff */\n#define single_stepping(regs)\t(current->thread.dbcr0 & DBCR0_IC)\n#define clear_single_step(regs)\t(current->thread.dbcr0 &= ~DBCR0_IC)\n\n#else\n/* On non-4xx, the reason for the machine check or program\n   exception is in the MSR. */\n#define get_reason(regs)\t((regs)->msr)\n#define get_mc_reason(regs)\t((regs)->msr)\n#define REASON_FP\t\t0x100000\n#define REASON_ILLEGAL\t\t0x80000\n#define REASON_PRIVILEGED\t0x40000\n#define REASON_TRAP\t\t0x20000\n\n#define single_stepping(regs)\t((regs)->msr & MSR_SE)\n#define clear_single_step(regs)\t((regs)->msr &= ~MSR_SE)\n#endif\n\n/*\n * This is \"fall-back\" implementation for configurations\n * which don't provide platform-specific machine check info\n */\nvoid __attribute__ ((weak))\nplatform_machine_check(struct pt_regs *regs)\n{\n}\n\nvoid machine_check_exception(struct pt_regs *regs)\n{\n\tint recover = 0;\n\tunsigned long reason = get_mc_reason(regs);\n\n\t/* See if any machine dependent calls */\n\tif (ppc_md.machine_check_exception)\n\t\trecover = ppc_md.machine_check_exception(regs);\n\n\tif (recover)\n\t\treturn;\n\n\tif (user_mode(regs)) {\n\t\tregs->msr |= MSR_RI;\n\t\t_exception(SIGBUS, regs, BUS_ADRERR, regs->nip);\n\t\treturn;\n\t}\n\n#if defined(CONFIG_8xx) && defined(CONFIG_PCI)\n\t/* the qspan pci read routines can cause machine checks -- Cort */\n\tbad_page_fault(regs, regs->dar, SIGBUS);\n\treturn;\n#endif\n\n\tif (debugger_fault_handler(regs)) {\n\t\tregs->msr |= MSR_RI;\n\t\treturn;\n\t}\n\n\tif (check_io_access(regs))\n\t\treturn;\n\n#if defined(CONFIG_4xx) && !defined(CONFIG_440A)\n\tif (reason & ESR_IMCP) {\n\t\tprintk(\"Instruction\");\n\t\tmtspr(SPRN_ESR, reason & ~ESR_IMCP);\n\t} else\n\t\tprintk(\"Data\");\n\tprintk(\" machine check in kernel mode.\\n\");\n#elif defined(CONFIG_440A)\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tif (reason & ESR_IMCP){\n\t\tprintk(\"Instruction Synchronous Machine Check exception\\n\");\n\t\tmtspr(SPRN_ESR, reason & ~ESR_IMCP);\n\t}\n\telse {\n\t\tu32 mcsr = mfspr(SPRN_MCSR);\n\t\tif (mcsr & MCSR_IB)\n\t\t\tprintk(\"Instruction Read PLB Error\\n\");\n\t\tif (mcsr & MCSR_DRB)\n\t\t\tprintk(\"Data Read PLB Error\\n\");\n\t\tif (mcsr & MCSR_DWB)\n\t\t\tprintk(\"Data Write PLB Error\\n\");\n\t\tif (mcsr & MCSR_TLBP)\n\t\t\tprintk(\"TLB Parity Error\\n\");\n\t\tif (mcsr & MCSR_ICP){\n\t\t\tflush_instruction_cache();\n\t\t\tprintk(\"I-Cache Parity Error\\n\");\n\t\t}\n\t\tif (mcsr & MCSR_DCSP)\n\t\t\tprintk(\"D-Cache Search Parity Error\\n\");\n\t\tif (mcsr & MCSR_DCFP)\n\t\t\tprintk(\"D-Cache Flush Parity Error\\n\");\n\t\tif (mcsr & MCSR_IMPE)\n\t\t\tprintk(\"Machine Check exception is imprecise\\n\");\n\n\t\t/* Clear MCSR */\n\t\tmtspr(SPRN_MCSR, mcsr);\n\t}\n#elif defined (CONFIG_E500)\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from MCSR=%lx): \", reason);\n\n\tif (reason & MCSR_MCP)\n\t\tprintk(\"Machine Check Signal\\n\");\n\tif (reason & MCSR_ICPERR)\n\t\tprintk(\"Instruction Cache Parity Error\\n\");\n\tif (reason & MCSR_DCP_PERR)\n\t\tprintk(\"Data Cache Push Parity Error\\n\");\n\tif (reason & MCSR_DCPERR)\n\t\tprintk(\"Data Cache Parity Error\\n\");\n\tif (reason & MCSR_GL_CI)\n\t\tprintk(\"Guarded Load or Cache-Inhibited stwcx.\\n\");\n\tif (reason & MCSR_BUS_IAERR)\n\t\tprintk(\"Bus - Instruction Address Error\\n\");\n\tif (reason & MCSR_BUS_RAERR)\n\t\tprintk(\"Bus - Read Address Error\\n\");\n\tif (reason & MCSR_BUS_WAERR)\n\t\tprintk(\"Bus - Write Address Error\\n\");\n\tif (reason & MCSR_BUS_IBERR)\n\t\tprintk(\"Bus - Instruction Data Error\\n\");\n\tif (reason & MCSR_BUS_RBERR)\n\t\tprintk(\"Bus - Read Data Bus Error\\n\");\n\tif (reason & MCSR_BUS_WBERR)\n\t\tprintk(\"Bus - Read Data Bus Error\\n\");\n\tif (reason & MCSR_BUS_IPERR)\n\t\tprintk(\"Bus - Instruction Parity Error\\n\");\n\tif (reason & MCSR_BUS_RPERR)\n\t\tprintk(\"Bus - Read Parity Error\\n\");\n#elif defined (CONFIG_E200)\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from MCSR=%lx): \", reason);\n\n\tif (reason & MCSR_MCP)\n\t\tprintk(\"Machine Check Signal\\n\");\n\tif (reason & MCSR_CP_PERR)\n\t\tprintk(\"Cache Push Parity Error\\n\");\n\tif (reason & MCSR_CPERR)\n\t\tprintk(\"Cache Parity Error\\n\");\n\tif (reason & MCSR_EXCP_ERR)\n\t\tprintk(\"ISI, ITLB, or Bus Error on first instruction fetch for an exception handler\\n\");\n\tif (reason & MCSR_BUS_IRERR)\n\t\tprintk(\"Bus - Read Bus Error on instruction fetch\\n\");\n\tif (reason & MCSR_BUS_DRERR)\n\t\tprintk(\"Bus - Read Bus Error on data load\\n\");\n\tif (reason & MCSR_BUS_WRERR)\n\t\tprintk(\"Bus - Write Bus Error on buffered store or cache line push\\n\");\n#else /* !CONFIG_4xx && !CONFIG_E500 && !CONFIG_E200 */\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from SRR1=%lx): \", reason);\n\tswitch (reason & 0x601F0000) {\n\tcase 0x80000:\n\t\tprintk(\"Machine check signal\\n\");\n\t\tbreak;\n\tcase 0:\t\t/* for 601 */\n\tcase 0x40000:\n\tcase 0x140000:\t/* 7450 MSS error and TEA */\n\t\tprintk(\"Transfer error ack signal\\n\");\n\t\tbreak;\n\tcase 0x20000:\n\t\tprintk(\"Data parity error signal\\n\");\n\t\tbreak;\n\tcase 0x10000:\n\t\tprintk(\"Address parity error signal\\n\");\n\t\tbreak;\n\tcase 0x20000000:\n\t\tprintk(\"L1 Data Cache error\\n\");\n\t\tbreak;\n\tcase 0x40000000:\n\t\tprintk(\"L1 Instruction Cache error\\n\");\n\t\tbreak;\n\tcase 0x00100000:\n\t\tprintk(\"L2 data cache parity error\\n\");\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"Unknown values in msr\\n\");\n\t}\n#endif /* CONFIG_4xx */\n\n\t/*\n\t * Optional platform-provided routine to print out\n\t * additional info, e.g. bus error registers.\n\t */\n\tplatform_machine_check(regs);\n\n\tif (debugger_fault_handler(regs))\n\t\treturn;\n\tdie(\"Machine check\", regs, SIGBUS);\n\n\t/* Must die if the interrupt is not recoverable */\n\tif (!(regs->msr & MSR_RI))\n\t\tpanic(\"Unrecoverable Machine check\");\n}\n\nvoid SMIException(struct pt_regs *regs)\n{\n\tdie(\"System Management Interrupt\", regs, SIGABRT);\n}\n\nvoid unknown_exception(struct pt_regs *regs)\n{\n\tprintk(\"Bad trap at PC: %lx, SR: %lx, vector=%lx\\n\",\n\t       regs->nip, regs->msr, regs->trap);\n\n\t_exception(SIGTRAP, regs, 0, 0);\n}\n\nvoid instruction_breakpoint_exception(struct pt_regs *regs)\n{\n\tif (notify_die(DIE_IABR_MATCH, \"iabr_match\", regs, 5,\n\t\t\t\t\t5, SIGTRAP) == NOTIFY_STOP)\n\t\treturn;\n\tif (debugger_iabr_match(regs))\n\t\treturn;\n\t_exception(SIGTRAP, regs, TRAP_BRKPT, regs->nip);\n}\n\nvoid RunModeException(struct pt_regs *regs)\n{\n\t_exception(SIGTRAP, regs, 0, 0);\n}\n\nvoid __kprobes single_step_exception(struct pt_regs *regs)\n{\n\tregs->msr &= ~(MSR_SE | MSR_BE);  /* Turn off 'trace' bits */\n\n\tif (notify_die(DIE_SSTEP, \"single_step\", regs, 5,\n\t\t\t\t\t5, SIGTRAP) == NOTIFY_STOP)\n\t\treturn;\n\tif (debugger_sstep(regs))\n\t\treturn;\n\n\t_exception(SIGTRAP, regs, TRAP_TRACE, regs->nip);\n}\n\n/*\n * After we have successfully emulated an instruction, we have to\n * check if the instruction was being single-stepped, and if so,\n * pretend we got a single-step exception.  This was pointed out\n * by Kumar Gala.  -- paulus\n */\nstatic void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs)) {\n\t\tclear_single_step(regs);\n\t\t_exception(SIGTRAP, regs, TRAP_TRACE, 0);\n\t}\n}\n\nstatic void parse_fpe(struct pt_regs *regs)\n{\n\tint code = 0;\n\tunsigned long fpscr;\n\n\tflush_fp_to_thread(current);\n\n\tfpscr = current->thread.fpscr.val;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tcode = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tcode = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tcode = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tcode = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tcode = FPE_FLTRES;\n\n\t_exception(SIGFPE, regs, code, regs->nip);\n}\n\n/*\n * Illegal instruction emulation support.  Originally written to\n * provide the PVR to user applications using the mfspr rd, PVR.\n * Return non-zero if we can't emulate, or -EFAULT if the associated\n * memory access caused an access fault.  Return zero on success.\n *\n * There are a couple of ways to do this, either \"decode\" the instruction\n * or directly match lots of bits.  In this case, matching lots of\n * bits is faster and easier.\n *\n */\n#define INST_MFSPR_PVR\t\t0x7c1f42a6\n#define INST_MFSPR_PVR_MASK\t0xfc1fffff\n\n#define INST_DCBA\t\t0x7c0005ec\n#define INST_DCBA_MASK\t\t0xfc0007fe\n\n#define INST_MCRXR\t\t0x7c000400\n#define INST_MCRXR_MASK\t\t0xfc0007fe\n\n#define INST_STRING\t\t0x7c00042a\n#define INST_STRING_MASK\t0xfc0007fe\n#define INST_STRING_GEN_MASK\t0xfc00067e\n#define INST_LSWI\t\t0x7c0004aa\n#define INST_LSWX\t\t0x7c00042a\n#define INST_STSWI\t\t0x7c0005aa\n#define INST_STSWX\t\t0x7c00052a\n\n#define INST_POPCNTB\t\t0x7c0000f4\n#define INST_POPCNTB_MASK\t0xfc0007fe\n\nstatic int emulate_string_inst(struct pt_regs *regs, u32 instword)\n{\n\tu8 rT = (instword >> 21) & 0x1f;\n\tu8 rA = (instword >> 16) & 0x1f;\n\tu8 NB_RB = (instword >> 11) & 0x1f;\n\tu32 num_bytes;\n\tunsigned long EA;\n\tint pos = 0;\n\n\t/* Early out if we are an invalid form of lswx */\n\tif ((instword & INST_STRING_MASK) == INST_LSWX)\n\t\tif ((rT == rA) || (rT == NB_RB))\n\t\t\treturn -EINVAL;\n\n\tEA = (rA == 0) ? 0 : regs->gpr[rA];\n\n\tswitch (instword & INST_STRING_MASK) {\n\t\tcase INST_LSWX:\n\t\tcase INST_STSWX:\n\t\t\tEA += NB_RB;\n\t\t\tnum_bytes = regs->xer & 0x7f;\n\t\t\tbreak;\n\t\tcase INST_LSWI:\n\t\tcase INST_STSWI:\n\t\t\tnum_bytes = (NB_RB == 0) ? 32 : NB_RB;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\twhile (num_bytes != 0)\n\t{\n\t\tu8 val;\n\t\tu32 shift = 8 * (3 - (pos & 0x3));\n\n\t\tswitch ((instword & INST_STRING_MASK)) {\n\t\t\tcase INST_LSWX:\n\t\t\tcase INST_LSWI:\n\t\t\t\tif (get_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t/* first time updating this reg,\n\t\t\t\t * zero it out */\n\t\t\t\tif (pos == 0)\n\t\t\t\t\tregs->gpr[rT] = 0;\n\t\t\t\tregs->gpr[rT] |= val << shift;\n\t\t\t\tbreak;\n\t\t\tcase INST_STSWI:\n\t\t\tcase INST_STSWX:\n\t\t\t\tval = regs->gpr[rT] >> shift;\n\t\t\t\tif (put_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tbreak;\n\t\t}\n\t\t/* move EA to next address */\n\t\tEA += 1;\n\t\tnum_bytes--;\n\n\t\t/* manage our position within the register */\n\t\tif (++pos == 4) {\n\t\t\tpos = 0;\n\t\t\tif (++rT == 32)\n\t\t\t\trT = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int emulate_popcntb_inst(struct pt_regs *regs, u32 instword)\n{\n\tu32 ra,rs;\n\tunsigned long tmp;\n\n\tra = (instword >> 16) & 0x1f;\n\trs = (instword >> 21) & 0x1f;\n\n\ttmp = regs->gpr[rs];\n\ttmp = tmp - ((tmp >> 1) & 0x5555555555555555ULL);\n\ttmp = (tmp & 0x3333333333333333ULL) + ((tmp >> 2) & 0x3333333333333333ULL);\n\ttmp = (tmp + (tmp >> 4)) & 0x0f0f0f0f0f0f0f0fULL;\n\tregs->gpr[ra] = tmp;\n\n\treturn 0;\n}\n\nstatic int emulate_instruction(struct pt_regs *regs)\n{\n\tu32 instword;\n\tu32 rd;\n\n\tif (!user_mode(regs) || (regs->msr & MSR_LE))\n\t\treturn -EINVAL;\n\tCHECK_FULL_REGS(regs);\n\n\tif (get_user(instword, (u32 __user *)(regs->nip)))\n\t\treturn -EFAULT;\n\n\t/* Emulate the mfspr rD, PVR. */\n\tif ((instword & INST_MFSPR_PVR_MASK) == INST_MFSPR_PVR) {\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_PVR);\n\t\treturn 0;\n\t}\n\n\t/* Emulating the dcba insn is just a no-op.  */\n\tif ((instword & INST_DCBA_MASK) == INST_DCBA)\n\t\treturn 0;\n\n\t/* Emulate the mcrxr insn.  */\n\tif ((instword & INST_MCRXR_MASK) == INST_MCRXR) {\n\t\tint shift = (instword >> 21) & 0x1c;\n\t\tunsigned long msk = 0xf0000000UL >> shift;\n\n\t\tregs->ccr = (regs->ccr & ~msk) | ((regs->xer >> shift) & msk);\n\t\tregs->xer &= ~0xf0000000UL;\n\t\treturn 0;\n\t}\n\n\t/* Emulate load/store string insn. */\n\tif ((instword & INST_STRING_GEN_MASK) == INST_STRING)\n\t\treturn emulate_string_inst(regs, instword);\n\n\t/* Emulate the popcntb (Population Count Bytes) instruction. */\n\tif ((instword & INST_POPCNTB_MASK) == INST_POPCNTB) {\n\t\treturn emulate_popcntb_inst(regs, instword);\n\t}\n\n\treturn -EINVAL;\n}\n\n/*\n * Look through the list of trap instructions that are used for BUG(),\n * BUG_ON() and WARN_ON() and see if we hit one.  At this point we know\n * that the exception was caused by a trap instruction of some kind.\n * Returns 1 if we should continue (i.e. it was a WARN_ON) or 0\n * otherwise.\n */\nextern struct bug_entry __start___bug_table[], __stop___bug_table[];\n\n#ifndef CONFIG_MODULES\n#define module_find_bug(x)\tNULL\n#endif\n\nstruct bug_entry *find_bug(unsigned long bugaddr)\n{\n\tstruct bug_entry *bug;\n\n\tfor (bug = __start___bug_table; bug < __stop___bug_table; ++bug)\n\t\tif (bugaddr == bug->bug_addr)\n\t\t\treturn bug;\n\treturn module_find_bug(bugaddr);\n}\n\nstatic int check_bug_trap(struct pt_regs *regs)\n{\n\tstruct bug_entry *bug;\n\tunsigned long addr;\n\n\tif (regs->msr & MSR_PR)\n\t\treturn 0;\t/* not in kernel */\n\taddr = regs->nip;\t/* address of trap instruction */\n\tif (addr < PAGE_OFFSET)\n\t\treturn 0;\n\tbug = find_bug(regs->nip);\n\tif (bug == NULL)\n\t\treturn 0;\n\tif (bug->line & BUG_WARNING_TRAP) {\n\t\t/* this is a WARN_ON rather than BUG/BUG_ON */\n\t\tprintk(KERN_ERR \"Badness in %s at %s:%ld\\n\",\n\t\t       bug->function, bug->file,\n\t\t       bug->line & ~BUG_WARNING_TRAP);\n\t\tdump_stack();\n\t\treturn 1;\n\t}\n\tprintk(KERN_CRIT \"kernel BUG in %s at %s:%ld!\\n\",\n\t       bug->function, bug->file, bug->line);\n\n\treturn 0;\n}\n\nvoid __kprobes program_check_exception(struct pt_regs *regs)\n{\n\tunsigned int reason = get_reason(regs);\n\textern int do_mathemu(struct pt_regs *regs);\n\n#ifdef CONFIG_MATH_EMULATION\n\t/* (reason & REASON_ILLEGAL) would be the obvious thing here,\n\t * but there seems to be a hardware bug on the 405GP (RevD)\n\t * that means ESR is sometimes set incorrectly - either to\n\t * ESR_DST (!?) or 0.  In the process of chasing this with the\n\t * hardware people - not sure if it can happen on any illegal\n\t * instruction or only on FP instructions, whether there is a\n\t * pattern to occurences etc. -dgibson 31/Mar/2003 */\n\tif (!(reason & REASON_TRAP) && do_mathemu(regs) == 0) {\n\t\temulate_single_step(regs);\n\t\treturn;\n\t}\n#endif /* CONFIG_MATH_EMULATION */\n\n\tif (reason & REASON_FP) {\n\t\t/* IEEE FP exception */\n\t\tparse_fpe(regs);\n\t\treturn;\n\t}\n\tif (reason & REASON_TRAP) {\n\t\t/* trap exception */\n\t\tif (notify_die(DIE_BPT, \"breakpoint\", regs, 5, 5, SIGTRAP)\n\t\t\t\t== NOTIFY_STOP)\n\t\t\treturn;\n\t\tif (debugger_bpt(regs))\n\t\t\treturn;\n\t\tif (check_bug_trap(regs)) {\n\t\t\tregs->nip += 4;\n\t\t\treturn;\n\t\t}\n\t\t_exception(SIGTRAP, regs, TRAP_BRKPT, regs->nip);\n\t\treturn;\n\t}\n\n\tlocal_irq_enable();\n\n\t/* Try to emulate it if we should. */\n\tif (reason & (REASON_ILLEGAL | REASON_PRIVILEGED)) {\n\t\tswitch (emulate_instruction(regs)) {\n\t\tcase 0:\n\t\t\tregs->nip += 4;\n\t\t\temulate_single_step(regs);\n\t\t\treturn;\n\t\tcase -EFAULT:\n\t\t\t_exception(SIGSEGV, regs, SEGV_MAPERR, regs->nip);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (reason & REASON_PRIVILEGED)\n\t\t_exception(SIGILL, regs, ILL_PRVOPC, regs->nip);\n\telse\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n}\n\nvoid alignment_exception(struct pt_regs *regs)\n{\n\tint fixed = 0;\n\n\t/* we don't implement logging of alignment exceptions */\n\tif (!(current->thread.align_ctl & PR_UNALIGN_SIGBUS))\n\t\tfixed = fix_alignment(regs);\n\n\tif (fixed == 1) {\n\t\tregs->nip += 4;\t/* skip over emulated instruction */\n\t\temulate_single_step(regs);\n\t\treturn;\n\t}\n\n\t/* Operand address was bad */\n\tif (fixed == -EFAULT) {\n\t\tif (user_mode(regs))\n\t\t\t_exception(SIGSEGV, regs, SEGV_ACCERR, regs->dar);\n\t\telse\n\t\t\t/* Search exception table */\n\t\t\tbad_page_fault(regs, regs->dar, SIGSEGV);\n\t\treturn;\n\t}\n\t_exception(SIGBUS, regs, BUS_ADRALN, regs->dar);\n}\n\nvoid StackOverflow(struct pt_regs *regs)\n{\n\tprintk(KERN_CRIT \"Kernel stack overflow in process %p, r1=%lx\\n\",\n\t       current, regs->gpr[1]);\n\tdebugger(regs);\n\tshow_regs(regs);\n\tpanic(\"kernel stack overflow\");\n}\n\nvoid nonrecoverable_exception(struct pt_regs *regs)\n{\n\tprintk(KERN_ERR \"Non-recoverable exception at PC=%lx MSR=%lx\\n\",\n\t       regs->nip, regs->msr);\n\tdebugger(regs);\n\tdie(\"nonrecoverable exception\", regs, SIGKILL);\n}\n\nvoid trace_syscall(struct pt_regs *regs)\n{\n\tprintk(\"Task: %p(%d), PC: %08lX/%08lX, Syscall: %3ld, Result: %s%ld    %s\\n\",\n\t       current, current->pid, regs->nip, regs->link, regs->gpr[0],\n\t       regs->ccr&0x10000000?\"Error=\":\"\", regs->gpr[3], print_tainted());\n}\n\nvoid kernel_fp_unavailable_exception(struct pt_regs *regs)\n{\n\tprintk(KERN_EMERG \"Unrecoverable FP Unavailable Exception \"\n\t\t\t  \"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable FP Unavailable Exception\", regs, SIGABRT);\n}\n\nvoid altivec_unavailable_exception(struct pt_regs *regs)\n{\n\tif (user_mode(regs)) {\n\t\t/* A user program has executed an altivec instruction,\n\t\t   but this kernel doesn't support altivec. */\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n\n\tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n}\n\nvoid performance_monitor_exception(struct pt_regs *regs)\n{\n\tperf_irq(regs);\n}\n\n#ifdef CONFIG_8xx\nvoid SoftwareEmulation(struct pt_regs *regs)\n{\n\textern int do_mathemu(struct pt_regs *);\n\textern int Soft_emulate_8xx(struct pt_regs *);\n\tint errcode;\n\n\tCHECK_FULL_REGS(regs);\n\n\tif (!user_mode(regs)) {\n\t\tdebugger(regs);\n\t\tdie(\"Kernel Mode Software FPU Emulation\", regs, SIGFPE);\n\t}\n\n#ifdef CONFIG_MATH_EMULATION\n\terrcode = do_mathemu(regs);\n#else\n\terrcode = Soft_emulate_8xx(regs);\n#endif\n\tif (errcode) {\n\t\tif (errcode > 0)\n\t\t\t_exception(SIGFPE, regs, 0, 0);\n\t\telse if (errcode == -EFAULT)\n\t\t\t_exception(SIGSEGV, regs, 0, 0);\n\t\telse\n\t\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t} else\n\t\temulate_single_step(regs);\n}\n#endif /* CONFIG_8xx */\n\n#if defined(CONFIG_40x) || defined(CONFIG_BOOKE)\n\nvoid DebugException(struct pt_regs *regs, unsigned long debug_status)\n{\n\tif (debug_status & DBSR_IC) {\t/* instruction completion */\n\t\tregs->msr &= ~MSR_DE;\n\t\tif (user_mode(regs)) {\n\t\t\tcurrent->thread.dbcr0 &= ~DBCR0_IC;\n\t\t} else {\n\t\t\t/* Disable instruction completion */\n\t\t\tmtspr(SPRN_DBCR0, mfspr(SPRN_DBCR0) & ~DBCR0_IC);\n\t\t\t/* Clear the instruction completion event */\n\t\t\tmtspr(SPRN_DBSR, DBSR_IC);\n\t\t\tif (debugger_sstep(regs))\n\t\t\t\treturn;\n\t\t}\n\t\t_exception(SIGTRAP, regs, TRAP_TRACE, 0);\n\t}\n}\n#endif /* CONFIG_4xx || CONFIG_BOOKE */\n\n#if !defined(CONFIG_TAU_INT)\nvoid TAUException(struct pt_regs *regs)\n{\n\tprintk(\"TAU trap at PC: %lx, MSR: %lx, vector=%lx    %s\\n\",\n\t       regs->nip, regs->msr, regs->trap, print_tainted());\n}\n#endif /* CONFIG_INT_TAU */\n\n#ifdef CONFIG_ALTIVEC\nvoid altivec_assist_exception(struct pt_regs *regs)\n{\n\tint err;\n\n\tif (!user_mode(regs)) {\n\t\tprintk(KERN_EMERG \"VMX/Altivec assist exception in kernel mode\"\n\t\t       \" at %lx\\n\", regs->nip);\n\t\tdie(\"Kernel VMX/Altivec assist exception\", regs, SIGILL);\n\t}\n\n\tflush_altivec_to_thread(current);\n\n\terr = emulate_altivec(regs);\n\tif (err == 0) {\n\t\tregs->nip += 4;\t\t/* skip emulated instruction */\n\t\temulate_single_step(regs);\n\t\treturn;\n\t}\n\n\tif (err == -EFAULT) {\n\t\t/* got an error reading the instruction */\n\t\t_exception(SIGSEGV, regs, SEGV_ACCERR, regs->nip);\n\t} else {\n\t\t/* didn't recognize the instruction */\n\t\t/* XXX quick hack for now: set the non-Java bit in the VSCR */\n\t\tif (printk_ratelimit())\n\t\t\tprintk(KERN_ERR \"Unrecognized altivec instruction \"\n\t\t\t       \"in %s at %lx\\n\", current->comm, regs->nip);\n\t\tcurrent->thread.vscr.u[3] |= 0x10000;\n\t}\n}\n#endif /* CONFIG_ALTIVEC */\n\n#ifdef CONFIG_FSL_BOOKE\nvoid CacheLockingException(struct pt_regs *regs, unsigned long address,\n\t\t\t   unsigned long error_code)\n{\n\t/* We treat cache locking instructions from the user\n\t * as priv ops, in the future we could try to do\n\t * something smarter\n\t */\n\tif (error_code & (ESR_DLK|ESR_ILK))\n\t\t_exception(SIGILL, regs, ILL_PRVOPC, regs->nip);\n\treturn;\n}\n#endif /* CONFIG_FSL_BOOKE */\n\n#ifdef CONFIG_SPE\nvoid SPEFloatingPointException(struct pt_regs *regs)\n{\n\tunsigned long spefscr;\n\tint fpexc_mode;\n\tint code = 0;\n\n\tspefscr = current->thread.spefscr;\n\tfpexc_mode = current->thread.fpexc_mode;\n\n\t/* Hardware does not neccessarily set sticky\n\t * underflow/overflow/invalid flags */\n\tif ((spefscr & SPEFSCR_FOVF) && (fpexc_mode & PR_FP_EXC_OVF)) {\n\t\tcode = FPE_FLTOVF;\n\t\tspefscr |= SPEFSCR_FOVFS;\n\t}\n\telse if ((spefscr & SPEFSCR_FUNF) && (fpexc_mode & PR_FP_EXC_UND)) {\n\t\tcode = FPE_FLTUND;\n\t\tspefscr |= SPEFSCR_FUNFS;\n\t}\n\telse if ((spefscr & SPEFSCR_FDBZ) && (fpexc_mode & PR_FP_EXC_DIV))\n\t\tcode = FPE_FLTDIV;\n\telse if ((spefscr & SPEFSCR_FINV) && (fpexc_mode & PR_FP_EXC_INV)) {\n\t\tcode = FPE_FLTINV;\n\t\tspefscr |= SPEFSCR_FINVS;\n\t}\n\telse if ((spefscr & (SPEFSCR_FG | SPEFSCR_FX)) && (fpexc_mode & PR_FP_EXC_RES))\n\t\tcode = FPE_FLTRES;\n\n\tcurrent->thread.spefscr = spefscr;\n\n\t_exception(SIGFPE, regs, code, regs->nip);\n\treturn;\n}\n#endif\n\n/*\n * We enter here if we get an unrecoverable exception, that is, one\n * that happened at a point where the RI (recoverable interrupt) bit\n * in the MSR is 0.  This indicates that SRR0/1 are live, and that\n * we therefore lost state by taking this exception.\n */\nvoid unrecoverable_exception(struct pt_regs *regs)\n{\n\tprintk(KERN_EMERG \"Unrecoverable exception %lx at %lx\\n\",\n\t       regs->trap, regs->nip);\n\tdie(\"Unrecoverable exception\", regs, SIGABRT);\n}\n\n#ifdef CONFIG_BOOKE_WDT\n/*\n * Default handler for a Watchdog exception,\n * spins until a reboot occurs\n */\nvoid __attribute__ ((weak)) WatchdogHandler(struct pt_regs *regs)\n{\n\t/* Generic WatchdogHandler, implement your own */\n\tmtspr(SPRN_TCR, mfspr(SPRN_TCR)&(~TCR_WIE));\n\treturn;\n}\n\nvoid WatchdogException(struct pt_regs *regs)\n{\n\tprintk (KERN_EMERG \"PowerPC Book-E Watchdog Exception\\n\");\n\tWatchdogHandler(regs);\n}\n#endif\n\n/*\n * We enter here if we discover during exception entry that we are\n * running in supervisor mode with a userspace value in the stack pointer.\n */\nvoid kernel_bad_stack(struct pt_regs *regs)\n{\n\tprintk(KERN_EMERG \"Bad kernel stack pointer %lx at %lx\\n\",\n\t       regs->gpr[1], regs->nip);\n\tdie(\"Bad kernel stack pointer\", regs, SIGABRT);\n}\n\nvoid __init trap_init(void)\n{\n}\n"], "filenames": ["arch/powerpc/kernel/traps.c"], "buggy_code_start_loc": [903], "buggy_code_end_loc": [911], "fixing_code_start_loc": [902], "fixing_code_end_loc": [910], "type": "CWE-19", "message": "The altivec_unavailable_exception function in arch/powerpc/kernel/traps.c in the Linux kernel before 2.6.19 on 64-bit systems mishandles the case where CONFIG_ALTIVEC is defined and the CPU actually supports Altivec, but the Altivec support was not detected by the kernel, which allows local users to cause a denial of service (panic) by triggering execution of an Altivec instruction.", "other": {"cve": {"id": "CVE-2006-5331", "sourceIdentifier": "cve@mitre.org", "published": "2017-10-29T06:29:00.230", "lastModified": "2017-11-17T13:35:17.343", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The altivec_unavailable_exception function in arch/powerpc/kernel/traps.c in the Linux kernel before 2.6.19 on 64-bit systems mishandles the case where CONFIG_ALTIVEC is defined and the CPU actually supports Altivec, but the Altivec support was not detected by the kernel, which allows local users to cause a denial of service (panic) by triggering execution of an Altivec instruction."}, {"lang": "es", "value": "La funci\u00f3n altivec_unavailable_exception en arch/powerpc/kernel/traps.c en el kernel de Linux en versiones anteriores a la 2.6.19 en sistemas de 64 bits gestiona de manera incorrecta el caso en el que se define CONFIG_ALTIVEC y la CPU es compatible con Altivec, pero esa compatibilidad no la detecta el kernel, lo que hace que los usuarios locales provoquen una denegaci\u00f3n de servicio (p\u00e1nico) desencadenando la ejecuci\u00f3n de una instrucci\u00f3n de Altivec."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-19"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.19", "matchCriteriaId": "B46C2EC7-EC2C-45D6-A7F2-CED2C433271E"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=6c4841c2b6c32a134f9f36e5e08857138cc12b10", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.linuxgrill.com/anonymous/kernel/v2.6/ChangeLog-2.6.19", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=213229", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/6c4841c2b6c32a134f9f36e5e08857138cc12b10", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6c4841c2b6c32a134f9f36e5e08857138cc12b10"}}