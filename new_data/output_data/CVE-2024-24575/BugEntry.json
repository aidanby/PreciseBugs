{"buggy_code": ["/*\n * Copyright (C) the libgit2 contributors. All rights reserved.\n *\n * This file is part of libgit2, distributed under the GNU GPL v2 with\n * a Linking Exception. For full terms see the included COPYING file.\n */\n\n#include \"common.h\"\n\n#include \"str.h\"\n#include \"tree.h\"\n#include \"refdb.h\"\n#include \"regexp.h\"\n#include \"date.h\"\n\n#include \"git2.h\"\n\nstatic int maybe_sha_or_abbrev(git_object **out, git_repository *repo, const char *spec, size_t speclen)\n{\n\tgit_oid oid;\n\n\tif (git_oid_fromstrn(&oid, spec, speclen) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn git_object_lookup_prefix(out, repo, &oid, speclen, GIT_OBJECT_ANY);\n}\n\nstatic int maybe_sha(git_object **out, git_repository *repo, const char *spec)\n{\n\tsize_t speclen = strlen(spec);\n\n\tif (speclen != GIT_OID_HEXSZ)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn maybe_sha_or_abbrev(out, repo, spec, speclen);\n}\n\nstatic int maybe_abbrev(git_object **out, git_repository *repo, const char *spec)\n{\n\tsize_t speclen = strlen(spec);\n\n\treturn maybe_sha_or_abbrev(out, repo, spec, speclen);\n}\n\nstatic int build_regex(git_regexp *regex, const char *pattern)\n{\n\tint error;\n\n\tif (*pattern == '\\0') {\n\t\tgit_error_set(GIT_ERROR_REGEX, \"empty pattern\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\terror = git_regexp_compile(regex, pattern, 0);\n\tif (!error)\n\t\treturn 0;\n\n\tgit_regexp_dispose(regex);\n\n\treturn error;\n}\n\nstatic int maybe_describe(git_object**out, git_repository *repo, const char *spec)\n{\n\tconst char *substr;\n\tint error;\n\tgit_regexp regex;\n\n\tsubstr = strstr(spec, \"-g\");\n\n\tif (substr == NULL)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (build_regex(&regex, \".+-[0-9]+-g[0-9a-fA-F]+\") < 0)\n\t\treturn -1;\n\n\terror = git_regexp_match(&regex, spec);\n\tgit_regexp_dispose(&regex);\n\n\tif (error)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn maybe_abbrev(out, repo, substr+2);\n}\n\nstatic int revparse_lookup_object(\n\tgit_object **object_out,\n\tgit_reference **reference_out,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = maybe_sha(object_out, repo, spec)) != GIT_ENOTFOUND)\n\t\treturn error;\n\n\terror = git_reference_dwim(&ref, repo, spec);\n\tif (!error) {\n\n\t\terror = git_object_lookup(\n\t\t\tobject_out, repo, git_reference_target(ref), GIT_OBJECT_ANY);\n\n\t\tif (!error)\n\t\t\t*reference_out = ref;\n\n\t\treturn error;\n\t}\n\n\tif (error != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tif ((strlen(spec) < GIT_OID_HEXSZ) &&\n\t\t((error = maybe_abbrev(object_out, repo, spec)) != GIT_ENOTFOUND))\n\t\t\treturn error;\n\n\tif ((error = maybe_describe(object_out, repo, spec)) != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tgit_error_set(GIT_ERROR_REFERENCE, \"revspec '%s' not found\", spec);\n\treturn GIT_ENOTFOUND;\n}\n\nstatic int try_parse_numeric(int *n, const char *curly_braces_content)\n{\n\tint32_t content;\n\tconst char *end_ptr;\n\n\tif (git__strntol32(&content, curly_braces_content, strlen(curly_braces_content),\n\t\t\t   &end_ptr, 10) < 0)\n\t\treturn -1;\n\n\tif (*end_ptr != '\\0')\n\t\treturn -1;\n\n\t*n = (int)content;\n\treturn 0;\n}\n\nstatic int retrieve_previously_checked_out_branch_or_revision(git_object **out, git_reference **base_ref, git_repository *repo, const char *identifier, size_t position)\n{\n\tgit_reference *ref = NULL;\n\tgit_reflog *reflog = NULL;\n\tgit_regexp preg;\n\tint error = -1;\n\tsize_t i, numentries, cur;\n\tconst git_reflog_entry *entry;\n\tconst char *msg;\n\tgit_str buf = GIT_STR_INIT;\n\n\tcur = position;\n\n\tif (*identifier != '\\0' || *base_ref != NULL)\n\t\treturn GIT_EINVALIDSPEC;\n\n\tif (build_regex(&preg, \"checkout: moving from (.*) to .*\") < 0)\n\t\treturn -1;\n\n\tif (git_reference_lookup(&ref, repo, GIT_HEAD_FILE) < 0)\n\t\tgoto cleanup;\n\n\tif (git_reflog_read(&reflog, repo, GIT_HEAD_FILE) < 0)\n\t\tgoto cleanup;\n\n\tnumentries  = git_reflog_entrycount(reflog);\n\n\tfor (i = 0; i < numentries; i++) {\n\t\tgit_regmatch regexmatches[2];\n\n\t\tentry = git_reflog_entry_byindex(reflog, i);\n\t\tmsg = git_reflog_entry_message(entry);\n\t\tif (!msg)\n\t\t\tcontinue;\n\n\t\tif (git_regexp_search(&preg, msg, 2, regexmatches) < 0)\n\t\t\tcontinue;\n\n\t\tcur--;\n\n\t\tif (cur > 0)\n\t\t\tcontinue;\n\n\t\tif ((git_str_put(&buf, msg+regexmatches[1].start, regexmatches[1].end - regexmatches[1].start)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif ((error = git_reference_dwim(base_ref, repo, git_str_cstr(&buf))) == 0)\n\t\t\tgoto cleanup;\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\n\t\terror = maybe_abbrev(out, repo, git_str_cstr(&buf));\n\n\t\tgoto cleanup;\n\t}\n\n\terror = GIT_ENOTFOUND;\n\ncleanup:\n\tgit_reference_free(ref);\n\tgit_str_dispose(&buf);\n\tgit_regexp_dispose(&preg);\n\tgit_reflog_free(reflog);\n\treturn error;\n}\n\nstatic int retrieve_oid_from_reflog(git_oid *oid, git_reference *ref, size_t identifier)\n{\n\tgit_reflog *reflog;\n\tsize_t numentries;\n\tconst git_reflog_entry *entry = NULL;\n\tbool search_by_pos = (identifier <= 100000000);\n\n\tif (git_reflog_read(&reflog, git_reference_owner(ref), git_reference_name(ref)) < 0)\n\t\treturn -1;\n\n\tnumentries = git_reflog_entrycount(reflog);\n\n\tif (search_by_pos) {\n\t\tif (numentries < identifier + 1)\n\t\t\tgoto notfound;\n\n\t\tentry = git_reflog_entry_byindex(reflog, identifier);\n\t\tgit_oid_cpy(oid, git_reflog_entry_id_new(entry));\n\t} else {\n\t\tsize_t i;\n\t\tgit_time commit_time;\n\n\t\tfor (i = 0; i < numentries; i++) {\n\t\t\tentry = git_reflog_entry_byindex(reflog, i);\n\t\t\tcommit_time = git_reflog_entry_committer(entry)->when;\n\n\t\t\tif (commit_time.time > (git_time_t)identifier)\n\t\t\t\tcontinue;\n\n\t\t\tgit_oid_cpy(oid, git_reflog_entry_id_new(entry));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i == numentries) {\n\t\t\tif (entry == NULL)\n\t\t\t\tgoto notfound;\n\n\t\t\t/*\n\t\t\t * TODO: emit a warning (log for 'branch' only goes back to ...)\n\t\t\t */\n\t\t\tgit_oid_cpy(oid, git_reflog_entry_id_new(entry));\n\t\t}\n\t}\n\n\tgit_reflog_free(reflog);\n\treturn 0;\n\nnotfound:\n\tgit_error_set(\n\t\tGIT_ERROR_REFERENCE,\n\t\t\"reflog for '%s' has only %\"PRIuZ\" entries, asked for %\"PRIuZ,\n\t\tgit_reference_name(ref), numentries, identifier);\n\n\tgit_reflog_free(reflog);\n\treturn GIT_ENOTFOUND;\n}\n\nstatic int retrieve_revobject_from_reflog(git_object **out, git_reference **base_ref, git_repository *repo, const char *identifier, size_t position)\n{\n\tgit_reference *ref;\n\tgit_oid oid;\n\tint error = -1;\n\n\tif (*base_ref == NULL) {\n\t\tif ((error = git_reference_dwim(&ref, repo, identifier)) < 0)\n\t\t\treturn error;\n\t} else {\n\t\tref = *base_ref;\n\t\t*base_ref = NULL;\n\t}\n\n\tif (position == 0) {\n\t\terror = git_object_lookup(out, repo, git_reference_target(ref), GIT_OBJECT_ANY);\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = retrieve_oid_from_reflog(&oid, ref, position)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_object_lookup(out, repo, &oid, GIT_OBJECT_ANY);\n\ncleanup:\n\tgit_reference_free(ref);\n\treturn error;\n}\n\nstatic int retrieve_remote_tracking_reference(git_reference **base_ref, const char *identifier, git_repository *repo)\n{\n\tgit_reference *tracking, *ref;\n\tint error = -1;\n\n\tif (*base_ref == NULL) {\n\t\tif ((error = git_reference_dwim(&ref, repo, identifier)) < 0)\n\t\t\treturn error;\n\t} else {\n\t\tref = *base_ref;\n\t\t*base_ref = NULL;\n\t}\n\n\tif (!git_reference_is_branch(ref)) {\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_branch_upstream(&tracking, ref)) < 0)\n\t\tgoto cleanup;\n\n\t*base_ref = tracking;\n\ncleanup:\n\tgit_reference_free(ref);\n\treturn error;\n}\n\nstatic int handle_at_syntax(git_object **out, git_reference **ref, const char *spec, size_t identifier_len, git_repository *repo, const char *curly_braces_content)\n{\n\tbool is_numeric;\n\tint parsed = 0, error = -1;\n\tgit_str identifier = GIT_STR_INIT;\n\tgit_time_t timestamp;\n\n\tGIT_ASSERT(*out == NULL);\n\n\tif (git_str_put(&identifier, spec, identifier_len) < 0)\n\t\treturn -1;\n\n\tis_numeric = !try_parse_numeric(&parsed, curly_braces_content);\n\n\tif (*curly_braces_content == '-' && (!is_numeric || parsed == 0)) {\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\tif (is_numeric) {\n\t\tif (parsed < 0)\n\t\t\terror = retrieve_previously_checked_out_branch_or_revision(out, ref, repo, git_str_cstr(&identifier), -parsed);\n\t\telse\n\t\t\terror = retrieve_revobject_from_reflog(out, ref, repo, git_str_cstr(&identifier), parsed);\n\n\t\tgoto cleanup;\n\t}\n\n\tif (!strcmp(curly_braces_content, \"u\") || !strcmp(curly_braces_content, \"upstream\")) {\n\t\terror = retrieve_remote_tracking_reference(ref, git_str_cstr(&identifier), repo);\n\n\t\tgoto cleanup;\n\t}\n\n\tif (git_date_parse(&timestamp, curly_braces_content) < 0) {\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = retrieve_revobject_from_reflog(out, ref, repo, git_str_cstr(&identifier), (size_t)timestamp);\n\ncleanup:\n\tgit_str_dispose(&identifier);\n\treturn error;\n}\n\nstatic git_object_t parse_obj_type(const char *str)\n{\n\tif (!strcmp(str, \"commit\"))\n\t\treturn GIT_OBJECT_COMMIT;\n\n\tif (!strcmp(str, \"tree\"))\n\t\treturn GIT_OBJECT_TREE;\n\n\tif (!strcmp(str, \"blob\"))\n\t\treturn GIT_OBJECT_BLOB;\n\n\tif (!strcmp(str, \"tag\"))\n\t\treturn GIT_OBJECT_TAG;\n\n\treturn GIT_OBJECT_INVALID;\n}\n\nstatic int dereference_to_non_tag(git_object **out, git_object *obj)\n{\n\tif (git_object_type(obj) == GIT_OBJECT_TAG)\n\t\treturn git_tag_peel(out, (git_tag *)obj);\n\n\treturn git_object_dup(out, obj);\n}\n\nstatic int handle_caret_parent_syntax(git_object **out, git_object *obj, int n)\n{\n\tgit_object *temp_commit = NULL;\n\tint error;\n\n\tif ((error = git_object_peel(&temp_commit, obj, GIT_OBJECT_COMMIT)) < 0)\n\t\treturn (error == GIT_EAMBIGUOUS || error == GIT_ENOTFOUND) ?\n\t\t\tGIT_EINVALIDSPEC : error;\n\n\tif (n == 0) {\n\t\t*out = temp_commit;\n\t\treturn 0;\n\t}\n\n\terror = git_commit_parent((git_commit **)out, (git_commit*)temp_commit, n - 1);\n\n\tgit_object_free(temp_commit);\n\treturn error;\n}\n\nstatic int handle_linear_syntax(git_object **out, git_object *obj, int n)\n{\n\tgit_object *temp_commit = NULL;\n\tint error;\n\n\tif ((error = git_object_peel(&temp_commit, obj, GIT_OBJECT_COMMIT)) < 0)\n\t\treturn (error == GIT_EAMBIGUOUS || error == GIT_ENOTFOUND) ?\n\t\t\tGIT_EINVALIDSPEC : error;\n\n\terror = git_commit_nth_gen_ancestor((git_commit **)out, (git_commit*)temp_commit, n);\n\n\tgit_object_free(temp_commit);\n\treturn error;\n}\n\nstatic int handle_colon_syntax(\n\tgit_object **out,\n\tgit_object *obj,\n\tconst char *path)\n{\n\tgit_object *tree;\n\tint error = -1;\n\tgit_tree_entry *entry = NULL;\n\n\tif ((error = git_object_peel(&tree, obj, GIT_OBJECT_TREE)) < 0)\n\t\treturn error == GIT_ENOTFOUND ? GIT_EINVALIDSPEC : error;\n\n\tif (*path == '\\0') {\n\t\t*out = tree;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * TODO: Handle the relative path syntax\n\t * (:./relative/path and :../relative/path)\n\t */\n\tif ((error = git_tree_entry_bypath(&entry, (git_tree *)tree, path)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_tree_entry_to_object(out, git_object_owner(tree), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_object_free(tree);\n\n\treturn error;\n}\n\nstatic int walk_and_search(git_object **out, git_revwalk *walk, git_regexp *regex)\n{\n\tint error;\n\tgit_oid oid;\n\tgit_object *obj;\n\n\twhile (!(error = git_revwalk_next(&oid, walk))) {\n\n\t\terror = git_object_lookup(&obj, git_revwalk_repository(walk), &oid, GIT_OBJECT_COMMIT);\n\t\tif ((error < 0) && (error != GIT_ENOTFOUND))\n\t\t\treturn -1;\n\n\t\tif (!git_regexp_match(regex, git_commit_message((git_commit*)obj))) {\n\t\t\t*out = obj;\n\t\t\treturn 0;\n\t\t}\n\n\t\tgit_object_free(obj);\n\t}\n\n\tif (error < 0 && error == GIT_ITEROVER)\n\t\terror = GIT_ENOTFOUND;\n\n\treturn error;\n}\n\nstatic int handle_grep_syntax(git_object **out, git_repository *repo, const git_oid *spec_oid, const char *pattern)\n{\n\tgit_regexp preg;\n\tgit_revwalk *walk = NULL;\n\tint error;\n\n\tif ((error = build_regex(&preg, pattern)) < 0)\n\t\treturn error;\n\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\tgoto cleanup;\n\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\n\tif (spec_oid == NULL) {\n\t\tif ((error = git_revwalk_push_glob(walk, \"refs/*\")) < 0)\n\t\t\tgoto cleanup;\n\t} else if ((error = git_revwalk_push(walk, spec_oid)) < 0)\n\t\t\tgoto cleanup;\n\n\terror = walk_and_search(out, walk, &preg);\n\ncleanup:\n\tgit_regexp_dispose(&preg);\n\tgit_revwalk_free(walk);\n\n\treturn error;\n}\n\nstatic int handle_caret_curly_syntax(git_object **out, git_object *obj, const char *curly_braces_content)\n{\n\tgit_object_t expected_type;\n\n\tif (*curly_braces_content == '\\0')\n\t\treturn dereference_to_non_tag(out, obj);\n\n\tif (*curly_braces_content == '/')\n\t\treturn handle_grep_syntax(out, git_object_owner(obj), git_object_id(obj), curly_braces_content + 1);\n\n\texpected_type = parse_obj_type(curly_braces_content);\n\n\tif (expected_type == GIT_OBJECT_INVALID)\n\t\treturn GIT_EINVALIDSPEC;\n\n\treturn git_object_peel(out, obj, expected_type);\n}\n\nstatic int extract_curly_braces_content(git_str *buf, const char *spec, size_t *pos)\n{\n\tgit_str_clear(buf);\n\n\tGIT_ASSERT_ARG(spec[*pos] == '^' || spec[*pos] == '@');\n\n\t(*pos)++;\n\n\tif (spec[*pos] == '\\0' || spec[*pos] != '{')\n\t\treturn GIT_EINVALIDSPEC;\n\n\t(*pos)++;\n\n\twhile (spec[*pos] != '}') {\n\t\tif (spec[*pos] == '\\0')\n\t\t\treturn GIT_EINVALIDSPEC;\n\n\t\tif (git_str_putc(buf, spec[(*pos)++]) < 0)\n\t\t\treturn -1;\n\t}\n\n\t(*pos)++;\n\n\treturn 0;\n}\n\nstatic int extract_path(git_str *buf, const char *spec, size_t *pos)\n{\n\tgit_str_clear(buf);\n\n\tGIT_ASSERT_ARG(spec[*pos] == ':');\n\n\t(*pos)++;\n\n\tif (git_str_puts(buf, spec + *pos) < 0)\n\t\treturn -1;\n\n\t*pos += git_str_len(buf);\n\n\treturn 0;\n}\n\nstatic int extract_how_many(int *n, const char *spec, size_t *pos)\n{\n\tconst char *end_ptr;\n\tint parsed, accumulated;\n\tchar kind = spec[*pos];\n\n\tGIT_ASSERT_ARG(spec[*pos] == '^' || spec[*pos] == '~');\n\n\taccumulated = 0;\n\n\tdo {\n\t\tdo {\n\t\t\t(*pos)++;\n\t\t\taccumulated++;\n\t\t} while (spec[(*pos)] == kind && kind == '~');\n\n\t\tif (git__isdigit(spec[*pos])) {\n\t\t\tif (git__strntol32(&parsed, spec + *pos, strlen(spec + *pos), &end_ptr, 10) < 0)\n\t\t\t\treturn GIT_EINVALIDSPEC;\n\n\t\t\taccumulated += (parsed - 1);\n\t\t\t*pos = end_ptr - spec;\n\t\t}\n\n\t} while (spec[(*pos)] == kind && kind == '~');\n\n\t*n = accumulated;\n\n\treturn 0;\n}\n\nstatic int object_from_reference(git_object **object, git_reference *reference)\n{\n\tgit_reference *resolved = NULL;\n\tint error;\n\n\tif (git_reference_resolve(&resolved, reference) < 0)\n\t\treturn -1;\n\n\terror = git_object_lookup(object, reference->db->repo, git_reference_target(resolved), GIT_OBJECT_ANY);\n\tgit_reference_free(resolved);\n\n\treturn error;\n}\n\nstatic int ensure_base_rev_loaded(git_object **object, git_reference **reference, const char *spec, size_t identifier_len, git_repository *repo, bool allow_empty_identifier)\n{\n\tint error;\n\tgit_str identifier = GIT_STR_INIT;\n\n\tif (*object != NULL)\n\t\treturn 0;\n\n\tif (*reference != NULL)\n\t\treturn object_from_reference(object, *reference);\n\n\tif (!allow_empty_identifier && identifier_len == 0)\n\t\treturn GIT_EINVALIDSPEC;\n\n\tif (git_str_put(&identifier, spec, identifier_len) < 0)\n\t\treturn -1;\n\n\terror = revparse_lookup_object(object, reference, repo, git_str_cstr(&identifier));\n\tgit_str_dispose(&identifier);\n\n\treturn error;\n}\n\nstatic int ensure_base_rev_is_not_known_yet(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn 0;\n\n\treturn GIT_EINVALIDSPEC;\n}\n\nstatic bool any_left_hand_identifier(git_object *object, git_reference *reference, size_t identifier_len)\n{\n\tif (object != NULL)\n\t\treturn true;\n\n\tif (reference != NULL)\n\t\treturn true;\n\n\tif (identifier_len > 0)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int ensure_left_hand_identifier_is_not_known_yet(git_object *object, git_reference *reference)\n{\n\tif (!ensure_base_rev_is_not_known_yet(object) && reference == NULL)\n\t\treturn 0;\n\n\treturn GIT_EINVALIDSPEC;\n}\n\nstatic int revparse(\n\tgit_object **object_out,\n\tgit_reference **reference_out,\n\tsize_t *identifier_len_out,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tsize_t pos = 0, identifier_len = 0;\n\tint error = -1, n;\n\tgit_str buf = GIT_STR_INIT;\n\n\tgit_reference *reference = NULL;\n\tgit_object *base_rev = NULL;\n\n\tbool should_return_reference = true;\n\n\tGIT_ASSERT_ARG(object_out);\n\tGIT_ASSERT_ARG(reference_out);\n\tGIT_ASSERT_ARG(repo);\n\tGIT_ASSERT_ARG(spec);\n\n\t*object_out = NULL;\n\t*reference_out = NULL;\n\n\twhile (spec[pos]) {\n\t\tswitch (spec[pos]) {\n\t\tcase '^':\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (spec[pos+1] == '{') {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_curly_braces_content(&buf, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_caret_curly_syntax(&temp_object, base_rev, git_str_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tgit_object_free(base_rev);\n\t\t\t\tbase_rev = temp_object;\n\t\t\t} else {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_how_many(&n, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_caret_parent_syntax(&temp_object, base_rev, n)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tgit_object_free(base_rev);\n\t\t\t\tbase_rev = temp_object;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '~':\n\t\t{\n\t\t\tgit_object *temp_object = NULL;\n\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = extract_how_many(&n, spec, &pos)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif ((error = handle_linear_syntax(&temp_object, base_rev, n)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tgit_object_free(base_rev);\n\t\t\tbase_rev = temp_object;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase ':':\n\t\t{\n\t\t\tgit_object *temp_object = NULL;\n\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = extract_path(&buf, spec, &pos)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (any_left_hand_identifier(base_rev, reference, identifier_len)) {\n\t\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, true)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_colon_syntax(&temp_object, base_rev, git_str_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t} else {\n\t\t\t\tif (*git_str_cstr(&buf) == '/') {\n\t\t\t\t\tif ((error = handle_grep_syntax(&temp_object, repo, NULL, git_str_cstr(&buf) + 1)) < 0)\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t} else {\n\n\t\t\t\t\t/*\n\t\t\t\t\t * TODO: support merge-stage path lookup (\":2:Makefile\")\n\t\t\t\t\t * and plain index blob lookup (:i-am/a/blob)\n\t\t\t\t\t */\n\t\t\t\t\tgit_error_set(GIT_ERROR_INVALID, \"unimplemented\");\n\t\t\t\t\terror = GIT_ERROR;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgit_object_free(base_rev);\n\t\t\tbase_rev = temp_object;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase '@':\n\t\t\tif (spec[pos+1] == '{') {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_curly_braces_content(&buf, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = ensure_base_rev_is_not_known_yet(base_rev)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_at_syntax(&temp_object, &reference, spec, identifier_len, repo, git_str_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif (temp_object != NULL)\n\t\t\t\t\tbase_rev = temp_object;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall through */\n\n\t\tdefault:\n\t\t\tif ((error = ensure_left_hand_identifier_is_not_known_yet(base_rev, reference)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tpos++;\n\t\t\tidentifier_len++;\n\t\t}\n\t}\n\n\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\tgoto cleanup;\n\n\tif (!should_return_reference) {\n\t\tgit_reference_free(reference);\n\t\treference = NULL;\n\t}\n\n\t*object_out = base_rev;\n\t*reference_out = reference;\n\t*identifier_len_out = identifier_len;\n\terror = 0;\n\ncleanup:\n\tif (error) {\n\t\tif (error == GIT_EINVALIDSPEC)\n\t\t\tgit_error_set(GIT_ERROR_INVALID,\n\t\t\t\t\"failed to parse revision specifier - Invalid pattern '%s'\", spec);\n\n\t\tgit_object_free(base_rev);\n\t\tgit_reference_free(reference);\n\t}\n\n\tgit_str_dispose(&buf);\n\treturn error;\n}\n\nint git_revparse_ext(\n\tgit_object **object_out,\n\tgit_reference **reference_out,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tint error;\n\tsize_t identifier_len;\n\tgit_object *obj = NULL;\n\tgit_reference *ref = NULL;\n\n\tif ((error = revparse(&obj, &ref, &identifier_len, repo, spec)) < 0)\n\t\tgoto cleanup;\n\n\t*object_out = obj;\n\t*reference_out = ref;\n\tGIT_UNUSED(identifier_len);\n\n\treturn 0;\n\ncleanup:\n\tgit_object_free(obj);\n\tgit_reference_free(ref);\n\treturn error;\n}\n\nint git_revparse_single(git_object **out, git_repository *repo, const char *spec)\n{\n\tint error;\n\tgit_object *obj = NULL;\n\tgit_reference *ref = NULL;\n\n\t*out = NULL;\n\n\tif ((error = git_revparse_ext(&obj, &ref, repo, spec)) < 0)\n\t\tgoto cleanup;\n\n\tgit_reference_free(ref);\n\n\t*out = obj;\n\n\treturn 0;\n\ncleanup:\n\tgit_object_free(obj);\n\tgit_reference_free(ref);\n\treturn error;\n}\n\nint git_revparse(\n\tgit_revspec *revspec,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tconst char *dotdot;\n\tint error = 0;\n\n\tGIT_ASSERT_ARG(revspec);\n\tGIT_ASSERT_ARG(repo);\n\tGIT_ASSERT_ARG(spec);\n\n\tmemset(revspec, 0x0, sizeof(*revspec));\n\n\tif ((dotdot = strstr(spec, \"..\")) != NULL) {\n\t\tchar *lstr;\n\t\tconst char *rstr;\n\t\trevspec->flags = GIT_REVSPEC_RANGE;\n\n\t\t/*\n\t\t * Following git.git, don't allow '..' because it makes command line\n\t\t * arguments which can be either paths or revisions ambiguous when the\n\t\t * path is almost certainly intended. The empty range '...' is still\n\t\t * allowed.\n\t\t */\n\t\tif (!git__strcmp(spec, \"..\")) {\n\t\t\tgit_error_set(GIT_ERROR_INVALID, \"Invalid pattern '..'\");\n\t\t\treturn GIT_EINVALIDSPEC;\n\t\t}\n\n\t\tlstr = git__substrdup(spec, dotdot - spec);\n\t\trstr = dotdot + 2;\n\t\tif (dotdot[2] == '.') {\n\t\t\trevspec->flags |= GIT_REVSPEC_MERGE_BASE;\n\t\t\trstr++;\n\t\t}\n\n\t\terror = git_revparse_single(\n\t\t\t&revspec->from,\n\t\t\trepo,\n\t\t\t*lstr == '\\0' ? \"HEAD\" : lstr);\n\n\t\tif (!error) {\n\t\t\terror = git_revparse_single(\n\t\t\t\t&revspec->to,\n\t\t\t\trepo,\n\t\t\t\t*rstr == '\\0' ? \"HEAD\" : rstr);\n\t\t}\n\n\t\tgit__free((void*)lstr);\n\t} else {\n\t\trevspec->flags = GIT_REVSPEC_SINGLE;\n\t\terror = git_revparse_single(&revspec->from, repo, spec);\n\t}\n\n\treturn error;\n}\n", "#include \"clar_libgit2.h\"\n\n#include \"git2/revparse.h\"\n#include \"refs.h\"\n#include \"path.h\"\n\nstatic git_repository *g_repo;\nstatic git_object *g_obj;\n\n/* Helpers */\nstatic void test_object_and_ref_inrepo(\n\tconst char *spec,\n\tconst char *expected_oid,\n\tconst char *expected_refname,\n\tgit_repository *repo,\n\tbool assert_reference_retrieval)\n{\n\tchar objstr[64] = {0};\n\tgit_object *obj = NULL;\n\tgit_reference *ref = NULL;\n\tint error;\n\n\terror = git_revparse_ext(&obj, &ref, repo, spec);\n\n\tif (expected_oid != NULL) {\n\t\tcl_git_pass(error);\n\t\tgit_oid_fmt(objstr, git_object_id(obj));\n\t\tcl_assert_equal_s(objstr, expected_oid);\n\t} else\n\t\tcl_git_fail(error);\n\n\tif (assert_reference_retrieval) {\n\t\tif (expected_refname == NULL)\n\t\t\tcl_assert(NULL == ref);\n\t\telse\n\t\t\tcl_assert_equal_s(expected_refname, git_reference_name(ref));\n\t}\n\n\tgit_object_free(obj);\n\tgit_reference_free(ref);\n}\n\nstatic void test_object_inrepo(const char *spec, const char *expected_oid, git_repository *repo)\n{\n\ttest_object_and_ref_inrepo(spec, expected_oid, NULL, repo, false);\n}\n\nstatic void test_id_inrepo(\n\tconst char *spec,\n\tconst char *expected_left,\n\tconst char *expected_right,\n\tgit_revspec_t expected_flags,\n\tgit_repository *repo)\n{\n\tgit_revspec revspec;\n\tint error = git_revparse(&revspec, repo, spec);\n\n\tif (expected_left) {\n\t\tchar str[64] = {0};\n\t\tcl_assert_equal_i(0, error);\n\t\tgit_oid_fmt(str, git_object_id(revspec.from));\n\t\tcl_assert_equal_s(str, expected_left);\n\t\tgit_object_free(revspec.from);\n\t} else {\n\t\tcl_assert_equal_i(GIT_ENOTFOUND, error);\n\t}\n\n\tif (expected_right) {\n\t\tchar str[64] = {0};\n\t\tgit_oid_fmt(str, git_object_id(revspec.to));\n\t\tcl_assert_equal_s(str, expected_right);\n\t\tgit_object_free(revspec.to);\n\t}\n\n\tif (expected_flags)\n\t\tcl_assert_equal_i(expected_flags, revspec.flags);\n}\n\nstatic void test_object(const char *spec, const char *expected_oid)\n{\n\ttest_object_inrepo(spec, expected_oid, g_repo);\n}\n\nstatic void test_object_and_ref(const char *spec, const char *expected_oid, const char *expected_refname)\n{\n\ttest_object_and_ref_inrepo(spec, expected_oid, expected_refname, g_repo, true);\n}\n\nstatic void test_rangelike(const char *rangelike,\n\t\t\t\t\t\t   const char *expected_left,\n\t\t\t\t\t\t   const char *expected_right,\n\t\t\t\t\t\t   git_revspec_t expected_revparseflags)\n{\n\tchar objstr[64] = {0};\n\tgit_revspec revspec;\n\tint error;\n\n\terror = git_revparse(&revspec, g_repo, rangelike);\n\n\tif (expected_left != NULL) {\n\t\tcl_assert_equal_i(0, error);\n\t\tcl_assert_equal_i(revspec.flags, expected_revparseflags);\n\t\tgit_oid_fmt(objstr, git_object_id(revspec.from));\n\t\tcl_assert_equal_s(objstr, expected_left);\n\t\tgit_oid_fmt(objstr, git_object_id(revspec.to));\n\t\tcl_assert_equal_s(objstr, expected_right);\n\t} else\n\t\tcl_assert(error != 0);\n\n\tgit_object_free(revspec.from);\n\tgit_object_free(revspec.to);\n}\n\n\nstatic void test_id(\n\tconst char *spec,\n\tconst char *expected_left,\n\tconst char *expected_right,\n\tgit_revspec_t expected_flags)\n{\n\ttest_id_inrepo(spec, expected_left, expected_right, expected_flags, g_repo);\n}\n\nstatic void test_invalid_revspec(const char* invalid_spec)\n{\n\tgit_revspec revspec;\n\n\tcl_assert_equal_i(\n\t\tGIT_EINVALIDSPEC, git_revparse(&revspec, g_repo, invalid_spec));\n}\n\nvoid test_refs_revparse__initialize(void)\n{\n\tcl_git_pass(git_repository_open(&g_repo, cl_fixture(\"testrepo.git\")));\n}\n\nvoid test_refs_revparse__cleanup(void)\n{\n\tgit_repository_free(g_repo);\n}\n\nvoid test_refs_revparse__nonexistant_object(void)\n{\n\ttest_object(\"this-does-not-exist\", NULL);\n\ttest_object(\"this-does-not-exist^1\", NULL);\n\ttest_object(\"this-does-not-exist~2\", NULL);\n}\n\nstatic void assert_invalid_single_spec(const char *invalid_spec)\n{\n\tcl_assert_equal_i(\n\t\tGIT_EINVALIDSPEC, git_revparse_single(&g_obj, g_repo, invalid_spec));\n}\n\nvoid test_refs_revparse__invalid_reference_name(void)\n{\n\tassert_invalid_single_spec(\"this doesn't make sense\");\n\tassert_invalid_single_spec(\"Inv@{id\");\n\tassert_invalid_single_spec(\"\");\n}\n\nvoid test_refs_revparse__shas(void)\n{\n\ttest_object(\"c47800c7266a2be04c571c04d5a6614691ea99bd\", \"c47800c7266a2be04c571c04d5a6614691ea99bd\");\n\ttest_object(\"c47800c\", \"c47800c7266a2be04c571c04d5a6614691ea99bd\");\n}\n\nvoid test_refs_revparse__head(void)\n{\n\ttest_object(\"HEAD\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"HEAD^0\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"HEAD~0\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"master\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n}\n\nvoid test_refs_revparse__full_refs(void)\n{\n\ttest_object(\"refs/heads/master\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"refs/heads/test\", \"e90810b8df3e80c413d903f631643c716887138d\");\n\ttest_object(\"refs/tags/test\", \"b25fa35b38051e4ae45d4222e795f9df2e43f1d1\");\n}\n\nvoid test_refs_revparse__partial_refs(void)\n{\n\ttest_object(\"point_to_blob\", \"1385f264afb75a56a5bec74243be9b367ba4ca08\");\n\ttest_object(\"packed-test\", \"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\");\n\ttest_object(\"br2\", \"a4a7dce85cf63874e984719f4fdd239f5145052f\");\n}\n\nvoid test_refs_revparse__describe_output(void)\n{\n\ttest_object(\"blah-7-gc47800c\", \"c47800c7266a2be04c571c04d5a6614691ea99bd\");\n\ttest_object(\"not-good\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n}\n\nvoid test_refs_revparse__nth_parent(void)\n{\n\tassert_invalid_single_spec(\"be3563a^-1\");\n\tassert_invalid_single_spec(\"^\");\n\tassert_invalid_single_spec(\"be3563a^{tree}^\");\n\tassert_invalid_single_spec(\"point_to_blob^{blob}^\");\n\tassert_invalid_single_spec(\"this doesn't make sense^1\");\n\n\ttest_object(\"be3563a^1\", \"9fd738e8f7967c078dceed8190330fc8648ee56a\");\n\ttest_object(\"be3563a^\", \"9fd738e8f7967c078dceed8190330fc8648ee56a\");\n\ttest_object(\"be3563a^2\", \"c47800c7266a2be04c571c04d5a6614691ea99bd\");\n\ttest_object(\"be3563a^1^1\", \"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\");\n\ttest_object(\"be3563a^^\", \"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\");\n\ttest_object(\"be3563a^2^1\", \"5b5b025afb0b4c913b4c338a42934a3863bf3644\");\n\ttest_object(\"be3563a^0\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"be3563a^{commit}^\", \"9fd738e8f7967c078dceed8190330fc8648ee56a\");\n\n\ttest_object(\"be3563a^42\", NULL);\n}\n\nvoid test_refs_revparse__not_tag(void)\n{\n\ttest_object(\"point_to_blob^{}\", \"1385f264afb75a56a5bec74243be9b367ba4ca08\");\n\ttest_object(\"wrapped_tag^{}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"master^{}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"master^{tree}^{}\", \"944c0f6e4dfa41595e6eb3ceecdb14f50fe18162\");\n\ttest_object(\"e90810b^{}\", \"e90810b8df3e80c413d903f631643c716887138d\");\n\ttest_object(\"tags/e90810b^{}\", \"e90810b8df3e80c413d903f631643c716887138d\");\n\ttest_object(\"e908^{}\", \"e90810b8df3e80c413d903f631643c716887138d\");\n}\n\nvoid test_refs_revparse__to_type(void)\n{\n\tassert_invalid_single_spec(\"wrapped_tag^{trip}\");\n\ttest_object(\"point_to_blob^{commit}\", NULL);\n\tcl_assert_equal_i(\n\t\tGIT_EPEEL, git_revparse_single(&g_obj, g_repo, \"wrapped_tag^{blob}\"));\n\n\ttest_object(\"wrapped_tag^{commit}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"wrapped_tag^{tree}\", \"944c0f6e4dfa41595e6eb3ceecdb14f50fe18162\");\n\ttest_object(\"point_to_blob^{blob}\", \"1385f264afb75a56a5bec74243be9b367ba4ca08\");\n\ttest_object(\"master^{commit}^{commit}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n}\n\nvoid test_refs_revparse__linear_history(void)\n{\n\tassert_invalid_single_spec(\"~\");\n\ttest_object(\"foo~bar\", NULL);\n\n\tassert_invalid_single_spec(\"master~bar\");\n\tassert_invalid_single_spec(\"master~-1\");\n\tassert_invalid_single_spec(\"master~0bar\");\n\tassert_invalid_single_spec(\"this doesn't make sense~2\");\n\tassert_invalid_single_spec(\"be3563a^{tree}~\");\n\tassert_invalid_single_spec(\"point_to_blob^{blob}~\");\n\n\ttest_object(\"master~0\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"master~1\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"master~2\", \"9fd738e8f7967c078dceed8190330fc8648ee56a\");\n\ttest_object(\"master~1~1\", \"9fd738e8f7967c078dceed8190330fc8648ee56a\");\n\ttest_object(\"master~~\", \"9fd738e8f7967c078dceed8190330fc8648ee56a\");\n}\n\nvoid test_refs_revparse__chaining(void)\n{\n\tassert_invalid_single_spec(\"master@{0}@{0}\");\n\tassert_invalid_single_spec(\"@{u}@{-1}\");\n\tassert_invalid_single_spec(\"@{-1}@{-1}\");\n\tassert_invalid_single_spec(\"@{-3}@{0}\");\n\n\ttest_object(\"master@{0}~1^1\", \"9fd738e8f7967c078dceed8190330fc8648ee56a\");\n\ttest_object(\"@{u}@{0}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"@{-1}@{0}\", \"a4a7dce85cf63874e984719f4fdd239f5145052f\");\n\ttest_object(\"@{-4}@{1}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"master~1^1\", \"9fd738e8f7967c078dceed8190330fc8648ee56a\");\n\ttest_object(\"master~1^2\", \"c47800c7266a2be04c571c04d5a6614691ea99bd\");\n\ttest_object(\"master^1^2~1\", \"5b5b025afb0b4c913b4c338a42934a3863bf3644\");\n\ttest_object(\"master^^2^\", \"5b5b025afb0b4c913b4c338a42934a3863bf3644\");\n\ttest_object(\"master^1^1^1^1^1\", \"8496071c1b46c854b31185ea97743be6a8774479\");\n\ttest_object(\"master^^1^2^1\", NULL);\n}\n\nvoid test_refs_revparse__upstream(void)\n{\n\tassert_invalid_single_spec(\"e90810b@{u}\");\n\tassert_invalid_single_spec(\"refs/tags/e90810b@{u}\");\n\ttest_object(\"refs/heads/e90810b@{u}\", NULL);\n\n\ttest_object(\"master@{upstream}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"@{u}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"master@{u}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"heads/master@{u}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"refs/heads/master@{u}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n}\n\nvoid test_refs_revparse__ordinal(void)\n{\n\tassert_invalid_single_spec(\"master@{-2}\");\n\n\t/* TODO: make the test below actually fail\n\t * cl_git_fail(git_revparse_single(&g_obj, g_repo, \"master@{1a}\"));\n\t */\n\n\ttest_object(\"nope@{0}\", NULL);\n\ttest_object(\"master@{31415}\", NULL);\n\ttest_object(\"@{1000}\", NULL);\n\ttest_object(\"@{2}\", NULL);\n\n\ttest_object(\"@{0}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"@{1}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\n\ttest_object(\"master@{0}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"master@{1}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"heads/master@{1}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"refs/heads/master@{1}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n}\n\nvoid test_refs_revparse__previous_head(void)\n{\n\tassert_invalid_single_spec(\"@{-xyz}\");\n\tassert_invalid_single_spec(\"@{-0}\");\n\tassert_invalid_single_spec(\"@{-1b}\");\n\n\ttest_object(\"@{-42}\", NULL);\n\n\ttest_object(\"@{-2}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"@{-1}\", \"a4a7dce85cf63874e984719f4fdd239f5145052f\");\n}\n\nstatic void create_fake_stash_reference_and_reflog(git_repository *repo)\n{\n\tgit_reference *master, *new_master;\n\tgit_str log_path = GIT_STR_INIT;\n\n\tgit_str_joinpath(&log_path, git_repository_path(repo), \"logs/refs/fakestash\");\n\n\tcl_assert_equal_i(false, git_fs_path_isfile(git_str_cstr(&log_path)));\n\n\tcl_git_pass(git_reference_lookup(&master, repo, \"refs/heads/master\"));\n\tcl_git_pass(git_reference_rename(&new_master, master, \"refs/fakestash\", 0, NULL));\n\tgit_reference_free(master);\n\n\tcl_assert_equal_i(true, git_fs_path_isfile(git_str_cstr(&log_path)));\n\n\tgit_str_dispose(&log_path);\n\tgit_reference_free(new_master);\n}\n\nvoid test_refs_revparse__reflog_of_a_ref_under_refs(void)\n{\n\tgit_repository *repo = cl_git_sandbox_init(\"testrepo.git\");\n\n\ttest_object_inrepo(\"refs/fakestash\", NULL, repo);\n\n\tcreate_fake_stash_reference_and_reflog(repo);\n\n\t/*\n\t * $ git reflog -1 refs/fakestash\n\t * a65fedf refs/fakestash@{0}: commit: checking in\n\t *\n\t * $ git reflog -1 refs/fakestash@{0}\n\t * a65fedf refs/fakestash@{0}: commit: checking in\n\t *\n\t * $ git reflog -1 fakestash\n\t * a65fedf fakestash@{0}: commit: checking in\n\t *\n\t * $ git reflog -1 fakestash@{0}\n\t * a65fedf fakestash@{0}: commit: checking in\n\t */\n\ttest_object_inrepo(\"refs/fakestash\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", repo);\n\ttest_object_inrepo(\"refs/fakestash@{0}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", repo);\n\ttest_object_inrepo(\"fakestash\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", repo);\n\ttest_object_inrepo(\"fakestash@{0}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", repo);\n\n\tcl_git_sandbox_cleanup();\n}\n\nvoid test_refs_revparse__revwalk(void)\n{\n\ttest_object(\"master^{/not found in any commit}\", NULL);\n\ttest_object(\"master^{/merge}\", NULL);\n\tassert_invalid_single_spec(\"master^{/((}\");\n\n\ttest_object(\"master^{/anoth}\", \"5b5b025afb0b4c913b4c338a42934a3863bf3644\");\n\ttest_object(\"master^{/Merge}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"br2^{/Merge}\", \"a4a7dce85cf63874e984719f4fdd239f5145052f\");\n\ttest_object(\"master^{/fo.rth}\", \"9fd738e8f7967c078dceed8190330fc8648ee56a\");\n}\n\nvoid test_refs_revparse__date(void)\n{\n\t/*\n\t * $ git reflog HEAD --date=iso\n\t * a65fedf HEAD@{2012-04-30 08:23:41 -0900}: checkout: moving from br2 to master\n\t * a4a7dce HEAD@{2012-04-30 08:23:37 -0900}: commit: checking in\n\t * c47800c HEAD@{2012-04-30 08:23:28 -0900}: checkout: moving from master to br2\n\t * a65fedf HEAD@{2012-04-30 08:23:23 -0900}: commit:\n\t * be3563a HEAD@{2012-04-30 10:22:43 -0700}: clone: from /Users/ben/src/libgit2/tes\n\t *\n\t * $ git reflog HEAD --date=raw\n\t * a65fedf HEAD@{1335806621 -0900}: checkout: moving from br2 to master\n\t * a4a7dce HEAD@{1335806617 -0900}: commit: checking in\n\t * c47800c HEAD@{1335806608 -0900}: checkout: moving from master to br2\n\t * a65fedf HEAD@{1335806603 -0900}: commit:\n\t * be3563a HEAD@{1335806563 -0700}: clone: from /Users/ben/src/libgit2/tests/resour\n\t */\n\ttest_object(\"HEAD@{10 years ago}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\n\ttest_object(\"HEAD@{1 second}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"HEAD@{1 second ago}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"HEAD@{2 days ago}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\n\t/*\n\t * $ git reflog master --date=iso\n\t * a65fedf master@{2012-04-30 09:23:23 -0800}: commit: checking in\n\t * be3563a master@{2012-04-30 09:22:43 -0800}: clone: from /Users/ben/src...\n\t *\n\t * $ git reflog master --date=raw\n\t * a65fedf master@{1335806603 -0800}: commit: checking in\n\t * be3563a master@{1335806563 -0800}: clone: from /Users/ben/src/libgit2/tests/reso\n\t */\n\n\n\t/*\n\t * $ git rev-parse \"master@{2012-04-30 17:22:42 +0000}\"\n\t * warning: log for 'master' only goes back to Mon, 30 Apr 2012 09:22:43 -0800\n\t * be3563ae3f795b2b4353bcce3a527ad0a4f7f644\n\t */\n\ttest_object(\"master@{2012-04-30 17:22:42 +0000}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"master@{2012-04-30 09:22:42 -0800}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\n\t/*\n\t * $ git reflog -1 \"master@{2012-04-30 17:22:43 +0000}\"\n\t * be3563a master@{Mon Apr 30 09:22:43 2012 -0800}: clone: from /Users/ben/src/libg\n\t */\n\ttest_object(\"master@{2012-04-30 17:22:43 +0000}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"master@{2012-04-30 09:22:43 -0800}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\n\t/*\n\t * $ git reflog -1 \"master@{2012-4-30 09:23:27 -0800}\"\n\t * a65fedf master@{Mon Apr 30 09:23:23 2012 -0800}: commit: checking in\n\t */\n\ttest_object(\"master@{2012-4-30 09:23:27 -0800}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\n\t/*\n\t * $ git reflog -1 master@{2012-05-03}\n\t * a65fedf master@{Mon Apr 30 09:23:23 2012 -0800}: commit: checking in\n\t */\n\ttest_object(\"master@{2012-05-03}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\n\t/*\n\t * $ git reflog -1 \"master@{1335806603}\"\n\t * a65fedf\n\t *\n\t * $ git reflog -1 \"master@{1335806602}\"\n\t * be3563a\n\t */\n\ttest_object(\"master@{1335806603}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"master@{1335806602}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\n\t/*\n\t * $ git rev-parse \"with-empty-log@{2 days ago}\" --\n\t * fatal: log for refs/heads/with-empty-log is empty\n\t */\n\ttest_object(\"with-empty-log@{2 days ago}\", NULL);\n}\n\nvoid test_refs_revparse__invalid_date(void)\n{\n\t/*\n\t * $ git rev-parse HEAD@{} --\n\t * fatal: bad revision 'HEAD@{}'\n\t *\n\t * $ git rev-parse HEAD@{NEITHER_INTEGER_NOR_DATETIME} --\n\t * fatal: bad revision 'HEAD@{NEITHER_INTEGER_NOR_DATETIME}'\n\t */\n\ttest_object(\"HEAD@{}\", NULL);\n\ttest_object(\"HEAD@{NEITHER_INTEGER_NOR_DATETIME}\", NULL);\n}\n\nvoid test_refs_revparse__colon(void)\n{\n\tassert_invalid_single_spec(\":/\");\n\tassert_invalid_single_spec(\"point_to_blob:readme.txt\");\n\tcl_git_fail(git_revparse_single(&g_obj, g_repo, \":2:README\")); /* Not implemented  */\n\n\ttest_object(\":/not found in any commit\", NULL);\n\ttest_object(\"subtrees:ab/42.txt\", NULL);\n\ttest_object(\"subtrees:ab/4.txt/nope\", NULL);\n\ttest_object(\"subtrees:nope\", NULL);\n\ttest_object(\"test/master^1:branch_file.txt\", NULL);\n\n\t/* From tags */\n\ttest_object(\"test:readme.txt\", \"0266163a49e280c4f5ed1e08facd36a2bd716bcf\");\n\ttest_object(\"tags/test:readme.txt\", \"0266163a49e280c4f5ed1e08facd36a2bd716bcf\");\n\ttest_object(\"e90810b:readme.txt\", \"0266163a49e280c4f5ed1e08facd36a2bd716bcf\");\n\ttest_object(\"tags/e90810b:readme.txt\", \"0266163a49e280c4f5ed1e08facd36a2bd716bcf\");\n\n\t/* From commits */\n\ttest_object(\"a65f:branch_file.txt\", \"3697d64be941a53d4ae8f6a271e4e3fa56b022cc\");\n\n\t/* From trees */\n\ttest_object(\"a65f^{tree}:branch_file.txt\", \"3697d64be941a53d4ae8f6a271e4e3fa56b022cc\");\n\ttest_object(\"944c:branch_file.txt\", \"3697d64be941a53d4ae8f6a271e4e3fa56b022cc\");\n\n\t/* Retrieving trees */\n\ttest_object(\"master:\", \"944c0f6e4dfa41595e6eb3ceecdb14f50fe18162\");\n\ttest_object(\"subtrees:\", \"ae90f12eea699729ed24555e40b9fd669da12a12\");\n\ttest_object(\"subtrees:ab\", \"f1425cef211cc08caa31e7b545ffb232acb098c3\");\n\ttest_object(\"subtrees:ab/\", \"f1425cef211cc08caa31e7b545ffb232acb098c3\");\n\n\t/* Retrieving blobs */\n\ttest_object(\"subtrees:ab/4.txt\", \"d6c93164c249c8000205dd4ec5cbca1b516d487f\");\n\ttest_object(\"subtrees:ab/de/fgh/1.txt\", \"1f67fc4386b2d171e0d21be1c447e12660561f9b\");\n\ttest_object(\"master:README\", \"a8233120f6ad708f843d861ce2b7228ec4e3dec6\");\n\ttest_object(\"master:new.txt\", \"a71586c1dfe8a71c6cbf6c129f404c5642ff31bd\");\n\ttest_object(\":/Merge\", \"a4a7dce85cf63874e984719f4fdd239f5145052f\");\n\ttest_object(\":/one\", \"c47800c7266a2be04c571c04d5a6614691ea99bd\");\n\ttest_object(\":/packed commit t\", \"41bc8c69075bbdb46c5c6f0566cc8cc5b46e8bd9\");\n\ttest_object(\"test/master^2:branch_file.txt\", \"45b983be36b73c0788dc9cbcb76cbb80fc7bb057\");\n\ttest_object(\"test/master@{1}:branch_file.txt\", \"3697d64be941a53d4ae8f6a271e4e3fa56b022cc\");\n}\n\nvoid test_refs_revparse__disambiguation(void)\n{\n\t/*\n\t * $ git show e90810b\n\t * tag e90810b\n\t * Tagger: Vicent Marti <tanoku@gmail.com>\n\t * Date:   Thu Aug 12 03:59:17 2010 +0200\n\t *\n\t * This is a very simple tag.\n\t *\n\t * commit e90810b8df3e80c413d903f631643c716887138d\n\t * Author: Vicent Marti <tanoku@gmail.com>\n\t * Date:   Thu Aug 5 18:42:20 2010 +0200\n\t *\n\t *     Test commit 2\n\t *\n\t * diff --git a/readme.txt b/readme.txt\n\t * index 6336846..0266163 100644\n\t * --- a/readme.txt\n\t * +++ b/readme.txt\n\t * @@ -1 +1,2 @@\n\t *  Testing a readme.txt\n\t * +Now we add a single line here\n\t *\n\t * $ git show-ref e90810b\n\t * 7b4384978d2493e851f9cca7858815fac9b10980 refs/tags/e90810b\n\t *\n\t */\n\ttest_object(\"e90810b\", \"7b4384978d2493e851f9cca7858815fac9b10980\");\n\n\t/*\n\t * $ git show e90810\n\t * commit e90810b8df3e80c413d903f631643c716887138d\n\t * Author: Vicent Marti <tanoku@gmail.com>\n\t * Date:   Thu Aug 5 18:42:20 2010 +0200\n\t *\n\t *     Test commit 2\n\t *\n\t * diff --git a/readme.txt b/readme.txt\n\t * index 6336846..0266163 100644\n\t * --- a/readme.txt\n\t * +++ b/readme.txt\n\t * @@ -1 +1,2 @@\n\t *  Testing a readme.txt\n\t * +Now we add a single line here\n\t */\n\ttest_object(\"e90810\", \"e90810b8df3e80c413d903f631643c716887138d\");\n}\n\nvoid test_refs_revparse__a_too_short_objectid_returns_EAMBIGUOUS(void)\n{\n\tcl_assert_equal_i(\n\t\tGIT_EAMBIGUOUS, git_revparse_single(&g_obj, g_repo, \"e90\"));\n}\n\n/*\n * $ echo \"aabqhq\" | git hash-object -t blob --stdin\n * dea509d0b3cb8ee0650f6ca210bc83f4678851ba\n *\n * $ echo \"aaazvc\" | git hash-object -t blob --stdin\n * dea509d097ce692e167dfc6a48a7a280cc5e877e\n */\nvoid test_refs_revparse__a_not_precise_enough_objectid_returns_EAMBIGUOUS(void)\n{\n\tgit_repository *repo;\n\tgit_index *index;\n\tgit_object *obj;\n\n\trepo = cl_git_sandbox_init(\"testrepo\");\n\n\tcl_git_mkfile(\"testrepo/one.txt\", \"aabqhq\\n\");\n\tcl_git_mkfile(\"testrepo/two.txt\", \"aaazvc\\n\");\n\n\tcl_git_pass(git_repository_index(&index, repo));\n\tcl_git_pass(git_index_add_bypath(index, \"one.txt\"));\n\tcl_git_pass(git_index_add_bypath(index, \"two.txt\"));\n\n\tcl_git_fail_with(git_revparse_single(&obj, repo, \"dea509d0\"), GIT_EAMBIGUOUS);\n\n\tcl_git_pass(git_revparse_single(&obj, repo, \"dea509d09\"));\n\n\tgit_object_free(obj);\n\tgit_index_free(index);\n\tcl_git_sandbox_cleanup();\n}\n\nvoid test_refs_revparse__issue_994(void)\n{\n\tgit_repository *repo;\n\tgit_reference *head, *with_at;\n\tgit_object *target;\n\n\trepo = cl_git_sandbox_init(\"testrepo.git\");\n\n\tcl_assert_equal_i(GIT_ENOTFOUND,\n\t\tgit_revparse_single(&target, repo, \"origin/bim_with_3d@11296\"));\n\n\tcl_assert_equal_i(GIT_ENOTFOUND,\n\t\tgit_revparse_single(&target, repo, \"refs/remotes/origin/bim_with_3d@11296\"));\n\n\n\tcl_git_pass(git_repository_head(&head, repo));\n\tcl_git_pass(git_reference_create(\n\t\t&with_at,\n\t\trepo,\n\t\t\"refs/remotes/origin/bim_with_3d@11296\",\n\t\tgit_reference_target(head),\n\t\t0,\n\t\tNULL));\n\n\tcl_git_pass(git_revparse_single(&target, repo, \"origin/bim_with_3d@11296\"));\n\tgit_object_free(target);\n\n\tcl_git_pass(git_revparse_single(&target, repo, \"refs/remotes/origin/bim_with_3d@11296\"));\n\tgit_object_free(target);\n\n\tgit_reference_free(with_at);\n\tgit_reference_free(head);\n\tcl_git_sandbox_cleanup();\n}\n\n/**\n * $ git rev-parse blah-7-gc47800c\n * c47800c7266a2be04c571c04d5a6614691ea99bd\n *\n * $ git rev-parse HEAD~3\n * 4a202b346bb0fb0db7eff3cffeb3c70babbd2045\n *\n * $ git branch blah-7-gc47800c HEAD~3\n *\n * $ git rev-parse blah-7-gc47800c\n * 4a202b346bb0fb0db7eff3cffeb3c70babbd2045\n */\nvoid test_refs_revparse__try_to_retrieve_branch_before_described_tag(void)\n{\n\tgit_repository *repo;\n\tgit_reference *branch;\n\tgit_object *target;\n\tchar sha[GIT_OID_HEXSZ + 1];\n\n\trepo = cl_git_sandbox_init(\"testrepo.git\");\n\n\ttest_object_inrepo(\"blah-7-gc47800c\", \"c47800c7266a2be04c571c04d5a6614691ea99bd\", repo);\n\n\tcl_git_pass(git_revparse_single(&target, repo, \"HEAD~3\"));\n\tcl_git_pass(git_branch_create(&branch, repo, \"blah-7-gc47800c\", (git_commit *)target, 0));\n\n\tgit_oid_tostr(sha, GIT_OID_HEXSZ + 1, git_object_id(target));\n\n\ttest_object_inrepo(\"blah-7-gc47800c\", sha, repo);\n\n\tgit_reference_free(branch);\n\tgit_object_free(target);\n\tcl_git_sandbox_cleanup();\n}\n\n/**\n * $ git rev-parse a65fedf39aefe402d3bb6e24df4d4f5fe4547750\n * a65fedf39aefe402d3bb6e24df4d4f5fe4547750\n *\n * $ git rev-parse HEAD~3\n * 4a202b346bb0fb0db7eff3cffeb3c70babbd2045\n *\n * $ git branch a65fedf39aefe402d3bb6e24df4d4f5fe4547750 HEAD~3\n *\n * $ git rev-parse a65fedf39aefe402d3bb6e24df4d4f5fe4547750\n * a65fedf39aefe402d3bb6e24df4d4f5fe4547750\n *\n * $ git rev-parse heads/a65fedf39aefe402d3bb6e24df4d4f5fe4547750\n * 4a202b346bb0fb0db7eff3cffeb3c70babbd2045\n */\nvoid test_refs_revparse__try_to_retrieve_sha_before_branch(void)\n{\n\tgit_repository *repo;\n\tgit_reference *branch;\n\tgit_object *target;\n\tchar sha[GIT_OID_HEXSZ + 1];\n\n\trepo = cl_git_sandbox_init(\"testrepo.git\");\n\n\ttest_object_inrepo(\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", repo);\n\n\tcl_git_pass(git_revparse_single(&target, repo, \"HEAD~3\"));\n\tcl_git_pass(git_branch_create(&branch, repo, \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", (git_commit *)target, 0));\n\n\tgit_oid_tostr(sha, GIT_OID_HEXSZ + 1, git_object_id(target));\n\n\ttest_object_inrepo(\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", repo);\n\ttest_object_inrepo(\"heads/a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", sha, repo);\n\n\tgit_reference_free(branch);\n\tgit_object_free(target);\n\tcl_git_sandbox_cleanup();\n}\n\n/**\n * $ git rev-parse c47800\n * c47800c7266a2be04c571c04d5a6614691ea99bd\n *\n * $ git rev-parse HEAD~3\n * 4a202b346bb0fb0db7eff3cffeb3c70babbd2045\n *\n * $ git branch c47800 HEAD~3\n *\n * $ git rev-parse c47800\n * 4a202b346bb0fb0db7eff3cffeb3c70babbd2045\n */\nvoid test_refs_revparse__try_to_retrieve_branch_before_abbrev_sha(void)\n{\n\tgit_repository *repo;\n\tgit_reference *branch;\n\tgit_object *target;\n\tchar sha[GIT_OID_HEXSZ + 1];\n\n\trepo = cl_git_sandbox_init(\"testrepo.git\");\n\n\ttest_object_inrepo(\"c47800\", \"c47800c7266a2be04c571c04d5a6614691ea99bd\", repo);\n\n\tcl_git_pass(git_revparse_single(&target, repo, \"HEAD~3\"));\n\tcl_git_pass(git_branch_create(&branch, repo, \"c47800\", (git_commit *)target, 0));\n\n\tgit_oid_tostr(sha, GIT_OID_HEXSZ + 1, git_object_id(target));\n\n\ttest_object_inrepo(\"c47800\", sha, repo);\n\n\tgit_reference_free(branch);\n\tgit_object_free(target);\n\tcl_git_sandbox_cleanup();\n}\n\n\nvoid test_refs_revparse__range(void)\n{\n\tassert_invalid_single_spec(\"be3563a^1..be3563a\");\n\n\ttest_rangelike(\"be3563a^1..be3563a\",\n\t               \"9fd738e8f7967c078dceed8190330fc8648ee56a\",\n\t               \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\",\n\t               GIT_REVSPEC_RANGE);\n\n\ttest_rangelike(\"be3563a^1...be3563a\",\n\t               \"9fd738e8f7967c078dceed8190330fc8648ee56a\",\n\t               \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\",\n\t               GIT_REVSPEC_RANGE | GIT_REVSPEC_MERGE_BASE);\n\n\ttest_rangelike(\"be3563a^1.be3563a\", NULL, NULL, 0);\n}\n\nvoid test_refs_revparse__parses_range_operator(void)\n{\n\ttest_id(\"HEAD\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n\ttest_id(\"HEAD~3..HEAD\",\n\t\t\"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\tGIT_REVSPEC_RANGE);\n\n\ttest_id(\"HEAD~3...HEAD\",\n\t\t\"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\tGIT_REVSPEC_RANGE | GIT_REVSPEC_MERGE_BASE);\n\n\ttest_id(\"HEAD~3..\",\n\t\t\"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\tGIT_REVSPEC_RANGE);\n\n\ttest_id(\"HEAD~3...\",\n\t\t\"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\tGIT_REVSPEC_RANGE | GIT_REVSPEC_MERGE_BASE);\n\n\ttest_id(\"..HEAD~3\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\t\"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\",\n\t\tGIT_REVSPEC_RANGE);\n\n\ttest_id(\"...HEAD~3\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\t\"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\",\n\t\tGIT_REVSPEC_RANGE | GIT_REVSPEC_MERGE_BASE);\n\n\ttest_id(\"...\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\tGIT_REVSPEC_RANGE | GIT_REVSPEC_MERGE_BASE);\n\n\ttest_invalid_revspec(\"..\");\n}\n\nvoid test_refs_revparse__ext_retrieves_both_the_reference_and_its_target(void)\n{\n\ttest_object_and_ref(\n\t\t\"master@{upstream}\",\n\t\t\"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\",\n\t\t\"refs/remotes/test/master\");\n\n\ttest_object_and_ref(\n\t\t\"@{-1}\",\n\t\t\"a4a7dce85cf63874e984719f4fdd239f5145052f\",\n\t\t\"refs/heads/br2\");\n}\n\nvoid test_refs_revparse__ext_can_expand_short_reference_names(void)\n{\n\ttest_object_and_ref(\n\t\t\"master\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\t\"refs/heads/master\");\n\n\ttest_object_and_ref(\n\t\t\"HEAD\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\t\"refs/heads/master\");\n\n    test_object_and_ref(\n\t\t\"tags/test\",\n\t\t\"b25fa35b38051e4ae45d4222e795f9df2e43f1d1\",\n        \"refs/tags/test\");\n}\n\nvoid test_refs_revparse__ext_returns_NULL_reference_when_expression_points_at_a_revision(void)\n{\n    test_object_and_ref(\n        \"HEAD~3\",\n        \"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\",\n        NULL);\n\n    test_object_and_ref(\n        \"HEAD~0\",\n        \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n        NULL);\n\n    test_object_and_ref(\n        \"HEAD^0\",\n        \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n        NULL);\n\n    test_object_and_ref(\n\t\t\"@{-1}@{0}\",\n\t\t\"a4a7dce85cf63874e984719f4fdd239f5145052f\",\n\t\tNULL);\n}\n\nvoid test_refs_revparse__ext_returns_NULL_reference_when_expression_points_at_a_tree_content(void)\n{\n    test_object_and_ref(\n\t\t\"tags/test:readme.txt\",\n\t\t\"0266163a49e280c4f5ed1e08facd36a2bd716bcf\",\n        NULL);\n}\n\nvoid test_refs_revparse__uneven_sizes(void)\n{\n\ttest_object(\"a65fedf39aefe402d3bb6e24df4d4f5fe454775\",\n\t\t\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\n\ttest_object(\"a65fedf39aefe402d3bb6e24df4d4f5fe45477\",\n\t\t\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\n\ttest_object(\"a65fedf39aefe402d3bb6e24df4d4f5fe4547\",\n\t\t\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\n\ttest_object(\"a65fedf39aefe402d3bb6e24df4d\",\n\t\t\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n}\n"], "fixing_code": ["/*\n * Copyright (C) the libgit2 contributors. All rights reserved.\n *\n * This file is part of libgit2, distributed under the GNU GPL v2 with\n * a Linking Exception. For full terms see the included COPYING file.\n */\n\n#include \"common.h\"\n\n#include \"str.h\"\n#include \"tree.h\"\n#include \"refdb.h\"\n#include \"regexp.h\"\n#include \"date.h\"\n\n#include \"git2.h\"\n\nstatic int maybe_sha_or_abbrev(git_object **out, git_repository *repo, const char *spec, size_t speclen)\n{\n\tgit_oid oid;\n\n\tif (git_oid_fromstrn(&oid, spec, speclen) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn git_object_lookup_prefix(out, repo, &oid, speclen, GIT_OBJECT_ANY);\n}\n\nstatic int maybe_sha(git_object **out, git_repository *repo, const char *spec)\n{\n\tsize_t speclen = strlen(spec);\n\n\tif (speclen != GIT_OID_HEXSZ)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn maybe_sha_or_abbrev(out, repo, spec, speclen);\n}\n\nstatic int maybe_abbrev(git_object **out, git_repository *repo, const char *spec)\n{\n\tsize_t speclen = strlen(spec);\n\n\treturn maybe_sha_or_abbrev(out, repo, spec, speclen);\n}\n\nstatic int build_regex(git_regexp *regex, const char *pattern)\n{\n\tint error;\n\n\tif (*pattern == '\\0') {\n\t\tgit_error_set(GIT_ERROR_REGEX, \"empty pattern\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\terror = git_regexp_compile(regex, pattern, 0);\n\tif (!error)\n\t\treturn 0;\n\n\tgit_regexp_dispose(regex);\n\n\treturn error;\n}\n\nstatic int maybe_describe(git_object**out, git_repository *repo, const char *spec)\n{\n\tconst char *substr;\n\tint error;\n\tgit_regexp regex;\n\n\tsubstr = strstr(spec, \"-g\");\n\n\tif (substr == NULL)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (build_regex(&regex, \".+-[0-9]+-g[0-9a-fA-F]+\") < 0)\n\t\treturn -1;\n\n\terror = git_regexp_match(&regex, spec);\n\tgit_regexp_dispose(&regex);\n\n\tif (error)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn maybe_abbrev(out, repo, substr+2);\n}\n\nstatic int revparse_lookup_object(\n\tgit_object **object_out,\n\tgit_reference **reference_out,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = maybe_sha(object_out, repo, spec)) != GIT_ENOTFOUND)\n\t\treturn error;\n\n\terror = git_reference_dwim(&ref, repo, spec);\n\tif (!error) {\n\n\t\terror = git_object_lookup(\n\t\t\tobject_out, repo, git_reference_target(ref), GIT_OBJECT_ANY);\n\n\t\tif (!error)\n\t\t\t*reference_out = ref;\n\n\t\treturn error;\n\t}\n\n\tif (error != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tif ((strlen(spec) < GIT_OID_HEXSZ) &&\n\t\t((error = maybe_abbrev(object_out, repo, spec)) != GIT_ENOTFOUND))\n\t\t\treturn error;\n\n\tif ((error = maybe_describe(object_out, repo, spec)) != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tgit_error_set(GIT_ERROR_REFERENCE, \"revspec '%s' not found\", spec);\n\treturn GIT_ENOTFOUND;\n}\n\nstatic int try_parse_numeric(int *n, const char *curly_braces_content)\n{\n\tint32_t content;\n\tconst char *end_ptr;\n\n\tif (git__strntol32(&content, curly_braces_content, strlen(curly_braces_content),\n\t\t\t   &end_ptr, 10) < 0)\n\t\treturn -1;\n\n\tif (*end_ptr != '\\0')\n\t\treturn -1;\n\n\t*n = (int)content;\n\treturn 0;\n}\n\nstatic int retrieve_previously_checked_out_branch_or_revision(git_object **out, git_reference **base_ref, git_repository *repo, const char *identifier, size_t position)\n{\n\tgit_reference *ref = NULL;\n\tgit_reflog *reflog = NULL;\n\tgit_regexp preg;\n\tint error = -1;\n\tsize_t i, numentries, cur;\n\tconst git_reflog_entry *entry;\n\tconst char *msg;\n\tgit_str buf = GIT_STR_INIT;\n\n\tcur = position;\n\n\tif (*identifier != '\\0' || *base_ref != NULL)\n\t\treturn GIT_EINVALIDSPEC;\n\n\tif (build_regex(&preg, \"checkout: moving from (.*) to .*\") < 0)\n\t\treturn -1;\n\n\tif (git_reference_lookup(&ref, repo, GIT_HEAD_FILE) < 0)\n\t\tgoto cleanup;\n\n\tif (git_reflog_read(&reflog, repo, GIT_HEAD_FILE) < 0)\n\t\tgoto cleanup;\n\n\tnumentries  = git_reflog_entrycount(reflog);\n\n\tfor (i = 0; i < numentries; i++) {\n\t\tgit_regmatch regexmatches[2];\n\n\t\tentry = git_reflog_entry_byindex(reflog, i);\n\t\tmsg = git_reflog_entry_message(entry);\n\t\tif (!msg)\n\t\t\tcontinue;\n\n\t\tif (git_regexp_search(&preg, msg, 2, regexmatches) < 0)\n\t\t\tcontinue;\n\n\t\tcur--;\n\n\t\tif (cur > 0)\n\t\t\tcontinue;\n\n\t\tif ((git_str_put(&buf, msg+regexmatches[1].start, regexmatches[1].end - regexmatches[1].start)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif ((error = git_reference_dwim(base_ref, repo, git_str_cstr(&buf))) == 0)\n\t\t\tgoto cleanup;\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\n\t\terror = maybe_abbrev(out, repo, git_str_cstr(&buf));\n\n\t\tgoto cleanup;\n\t}\n\n\terror = GIT_ENOTFOUND;\n\ncleanup:\n\tgit_reference_free(ref);\n\tgit_str_dispose(&buf);\n\tgit_regexp_dispose(&preg);\n\tgit_reflog_free(reflog);\n\treturn error;\n}\n\nstatic int retrieve_oid_from_reflog(git_oid *oid, git_reference *ref, size_t identifier)\n{\n\tgit_reflog *reflog;\n\tsize_t numentries;\n\tconst git_reflog_entry *entry = NULL;\n\tbool search_by_pos = (identifier <= 100000000);\n\n\tif (git_reflog_read(&reflog, git_reference_owner(ref), git_reference_name(ref)) < 0)\n\t\treturn -1;\n\n\tnumentries = git_reflog_entrycount(reflog);\n\n\tif (search_by_pos) {\n\t\tif (numentries < identifier + 1)\n\t\t\tgoto notfound;\n\n\t\tentry = git_reflog_entry_byindex(reflog, identifier);\n\t\tgit_oid_cpy(oid, git_reflog_entry_id_new(entry));\n\t} else {\n\t\tsize_t i;\n\t\tgit_time commit_time;\n\n\t\tfor (i = 0; i < numentries; i++) {\n\t\t\tentry = git_reflog_entry_byindex(reflog, i);\n\t\t\tcommit_time = git_reflog_entry_committer(entry)->when;\n\n\t\t\tif (commit_time.time > (git_time_t)identifier)\n\t\t\t\tcontinue;\n\n\t\t\tgit_oid_cpy(oid, git_reflog_entry_id_new(entry));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i == numentries) {\n\t\t\tif (entry == NULL)\n\t\t\t\tgoto notfound;\n\n\t\t\t/*\n\t\t\t * TODO: emit a warning (log for 'branch' only goes back to ...)\n\t\t\t */\n\t\t\tgit_oid_cpy(oid, git_reflog_entry_id_new(entry));\n\t\t}\n\t}\n\n\tgit_reflog_free(reflog);\n\treturn 0;\n\nnotfound:\n\tgit_error_set(\n\t\tGIT_ERROR_REFERENCE,\n\t\t\"reflog for '%s' has only %\"PRIuZ\" entries, asked for %\"PRIuZ,\n\t\tgit_reference_name(ref), numentries, identifier);\n\n\tgit_reflog_free(reflog);\n\treturn GIT_ENOTFOUND;\n}\n\nstatic int retrieve_revobject_from_reflog(git_object **out, git_reference **base_ref, git_repository *repo, const char *identifier, size_t position)\n{\n\tgit_reference *ref;\n\tgit_oid oid;\n\tint error = -1;\n\n\tif (*base_ref == NULL) {\n\t\tif ((error = git_reference_dwim(&ref, repo, identifier)) < 0)\n\t\t\treturn error;\n\t} else {\n\t\tref = *base_ref;\n\t\t*base_ref = NULL;\n\t}\n\n\tif (position == 0) {\n\t\terror = git_object_lookup(out, repo, git_reference_target(ref), GIT_OBJECT_ANY);\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = retrieve_oid_from_reflog(&oid, ref, position)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_object_lookup(out, repo, &oid, GIT_OBJECT_ANY);\n\ncleanup:\n\tgit_reference_free(ref);\n\treturn error;\n}\n\nstatic int retrieve_remote_tracking_reference(git_reference **base_ref, const char *identifier, git_repository *repo)\n{\n\tgit_reference *tracking, *ref;\n\tint error = -1;\n\n\tif (*base_ref == NULL) {\n\t\tif ((error = git_reference_dwim(&ref, repo, identifier)) < 0)\n\t\t\treturn error;\n\t} else {\n\t\tref = *base_ref;\n\t\t*base_ref = NULL;\n\t}\n\n\tif (!git_reference_is_branch(ref)) {\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_branch_upstream(&tracking, ref)) < 0)\n\t\tgoto cleanup;\n\n\t*base_ref = tracking;\n\ncleanup:\n\tgit_reference_free(ref);\n\treturn error;\n}\n\nstatic int handle_at_syntax(git_object **out, git_reference **ref, const char *spec, size_t identifier_len, git_repository *repo, const char *curly_braces_content)\n{\n\tbool is_numeric;\n\tint parsed = 0, error = -1;\n\tgit_str identifier = GIT_STR_INIT;\n\tgit_time_t timestamp;\n\n\tGIT_ASSERT(*out == NULL);\n\n\tif (git_str_put(&identifier, spec, identifier_len) < 0)\n\t\treturn -1;\n\n\tis_numeric = !try_parse_numeric(&parsed, curly_braces_content);\n\n\tif (*curly_braces_content == '-' && (!is_numeric || parsed == 0)) {\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\tif (is_numeric) {\n\t\tif (parsed < 0)\n\t\t\terror = retrieve_previously_checked_out_branch_or_revision(out, ref, repo, git_str_cstr(&identifier), -parsed);\n\t\telse\n\t\t\terror = retrieve_revobject_from_reflog(out, ref, repo, git_str_cstr(&identifier), parsed);\n\n\t\tgoto cleanup;\n\t}\n\n\tif (!strcmp(curly_braces_content, \"u\") || !strcmp(curly_braces_content, \"upstream\")) {\n\t\terror = retrieve_remote_tracking_reference(ref, git_str_cstr(&identifier), repo);\n\n\t\tgoto cleanup;\n\t}\n\n\tif (git_date_parse(&timestamp, curly_braces_content) < 0) {\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = retrieve_revobject_from_reflog(out, ref, repo, git_str_cstr(&identifier), (size_t)timestamp);\n\ncleanup:\n\tgit_str_dispose(&identifier);\n\treturn error;\n}\n\nstatic git_object_t parse_obj_type(const char *str)\n{\n\tif (!strcmp(str, \"commit\"))\n\t\treturn GIT_OBJECT_COMMIT;\n\n\tif (!strcmp(str, \"tree\"))\n\t\treturn GIT_OBJECT_TREE;\n\n\tif (!strcmp(str, \"blob\"))\n\t\treturn GIT_OBJECT_BLOB;\n\n\tif (!strcmp(str, \"tag\"))\n\t\treturn GIT_OBJECT_TAG;\n\n\treturn GIT_OBJECT_INVALID;\n}\n\nstatic int dereference_to_non_tag(git_object **out, git_object *obj)\n{\n\tif (git_object_type(obj) == GIT_OBJECT_TAG)\n\t\treturn git_tag_peel(out, (git_tag *)obj);\n\n\treturn git_object_dup(out, obj);\n}\n\nstatic int handle_caret_parent_syntax(git_object **out, git_object *obj, int n)\n{\n\tgit_object *temp_commit = NULL;\n\tint error;\n\n\tif ((error = git_object_peel(&temp_commit, obj, GIT_OBJECT_COMMIT)) < 0)\n\t\treturn (error == GIT_EAMBIGUOUS || error == GIT_ENOTFOUND) ?\n\t\t\tGIT_EINVALIDSPEC : error;\n\n\tif (n == 0) {\n\t\t*out = temp_commit;\n\t\treturn 0;\n\t}\n\n\terror = git_commit_parent((git_commit **)out, (git_commit*)temp_commit, n - 1);\n\n\tgit_object_free(temp_commit);\n\treturn error;\n}\n\nstatic int handle_linear_syntax(git_object **out, git_object *obj, int n)\n{\n\tgit_object *temp_commit = NULL;\n\tint error;\n\n\tif ((error = git_object_peel(&temp_commit, obj, GIT_OBJECT_COMMIT)) < 0)\n\t\treturn (error == GIT_EAMBIGUOUS || error == GIT_ENOTFOUND) ?\n\t\t\tGIT_EINVALIDSPEC : error;\n\n\terror = git_commit_nth_gen_ancestor((git_commit **)out, (git_commit*)temp_commit, n);\n\n\tgit_object_free(temp_commit);\n\treturn error;\n}\n\nstatic int handle_colon_syntax(\n\tgit_object **out,\n\tgit_object *obj,\n\tconst char *path)\n{\n\tgit_object *tree;\n\tint error = -1;\n\tgit_tree_entry *entry = NULL;\n\n\tif ((error = git_object_peel(&tree, obj, GIT_OBJECT_TREE)) < 0)\n\t\treturn error == GIT_ENOTFOUND ? GIT_EINVALIDSPEC : error;\n\n\tif (*path == '\\0') {\n\t\t*out = tree;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * TODO: Handle the relative path syntax\n\t * (:./relative/path and :../relative/path)\n\t */\n\tif ((error = git_tree_entry_bypath(&entry, (git_tree *)tree, path)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_tree_entry_to_object(out, git_object_owner(tree), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_object_free(tree);\n\n\treturn error;\n}\n\nstatic int walk_and_search(git_object **out, git_revwalk *walk, git_regexp *regex)\n{\n\tint error;\n\tgit_oid oid;\n\tgit_object *obj;\n\n\twhile (!(error = git_revwalk_next(&oid, walk))) {\n\n\t\terror = git_object_lookup(&obj, git_revwalk_repository(walk), &oid, GIT_OBJECT_COMMIT);\n\t\tif ((error < 0) && (error != GIT_ENOTFOUND))\n\t\t\treturn -1;\n\n\t\tif (!git_regexp_match(regex, git_commit_message((git_commit*)obj))) {\n\t\t\t*out = obj;\n\t\t\treturn 0;\n\t\t}\n\n\t\tgit_object_free(obj);\n\t}\n\n\tif (error < 0 && error == GIT_ITEROVER)\n\t\terror = GIT_ENOTFOUND;\n\n\treturn error;\n}\n\nstatic int handle_grep_syntax(git_object **out, git_repository *repo, const git_oid *spec_oid, const char *pattern)\n{\n\tgit_regexp preg;\n\tgit_revwalk *walk = NULL;\n\tint error;\n\n\tif ((error = build_regex(&preg, pattern)) < 0)\n\t\treturn error;\n\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\tgoto cleanup;\n\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\n\tif (spec_oid == NULL) {\n\t\tif ((error = git_revwalk_push_glob(walk, \"refs/*\")) < 0)\n\t\t\tgoto cleanup;\n\t} else if ((error = git_revwalk_push(walk, spec_oid)) < 0)\n\t\t\tgoto cleanup;\n\n\terror = walk_and_search(out, walk, &preg);\n\ncleanup:\n\tgit_regexp_dispose(&preg);\n\tgit_revwalk_free(walk);\n\n\treturn error;\n}\n\nstatic int handle_caret_curly_syntax(git_object **out, git_object *obj, const char *curly_braces_content)\n{\n\tgit_object_t expected_type;\n\n\tif (*curly_braces_content == '\\0')\n\t\treturn dereference_to_non_tag(out, obj);\n\n\tif (*curly_braces_content == '/')\n\t\treturn handle_grep_syntax(out, git_object_owner(obj), git_object_id(obj), curly_braces_content + 1);\n\n\texpected_type = parse_obj_type(curly_braces_content);\n\n\tif (expected_type == GIT_OBJECT_INVALID)\n\t\treturn GIT_EINVALIDSPEC;\n\n\treturn git_object_peel(out, obj, expected_type);\n}\n\nstatic int extract_curly_braces_content(git_str *buf, const char *spec, size_t *pos)\n{\n\tgit_str_clear(buf);\n\n\tGIT_ASSERT_ARG(spec[*pos] == '^' || spec[*pos] == '@');\n\n\t(*pos)++;\n\n\tif (spec[*pos] == '\\0' || spec[*pos] != '{')\n\t\treturn GIT_EINVALIDSPEC;\n\n\t(*pos)++;\n\n\twhile (spec[*pos] != '}') {\n\t\tif (spec[*pos] == '\\0')\n\t\t\treturn GIT_EINVALIDSPEC;\n\n\t\tif (git_str_putc(buf, spec[(*pos)++]) < 0)\n\t\t\treturn -1;\n\t}\n\n\t(*pos)++;\n\n\treturn 0;\n}\n\nstatic int extract_path(git_str *buf, const char *spec, size_t *pos)\n{\n\tgit_str_clear(buf);\n\n\tGIT_ASSERT_ARG(spec[*pos] == ':');\n\n\t(*pos)++;\n\n\tif (git_str_puts(buf, spec + *pos) < 0)\n\t\treturn -1;\n\n\t*pos += git_str_len(buf);\n\n\treturn 0;\n}\n\nstatic int extract_how_many(int *n, const char *spec, size_t *pos)\n{\n\tconst char *end_ptr;\n\tint parsed, accumulated;\n\tchar kind = spec[*pos];\n\n\tGIT_ASSERT_ARG(spec[*pos] == '^' || spec[*pos] == '~');\n\n\taccumulated = 0;\n\n\tdo {\n\t\tdo {\n\t\t\t(*pos)++;\n\t\t\taccumulated++;\n\t\t} while (spec[(*pos)] == kind && kind == '~');\n\n\t\tif (git__isdigit(spec[*pos])) {\n\t\t\tif (git__strntol32(&parsed, spec + *pos, strlen(spec + *pos), &end_ptr, 10) < 0)\n\t\t\t\treturn GIT_EINVALIDSPEC;\n\n\t\t\taccumulated += (parsed - 1);\n\t\t\t*pos = end_ptr - spec;\n\t\t}\n\n\t} while (spec[(*pos)] == kind && kind == '~');\n\n\t*n = accumulated;\n\n\treturn 0;\n}\n\nstatic int object_from_reference(git_object **object, git_reference *reference)\n{\n\tgit_reference *resolved = NULL;\n\tint error;\n\n\tif (git_reference_resolve(&resolved, reference) < 0)\n\t\treturn -1;\n\n\terror = git_object_lookup(object, reference->db->repo, git_reference_target(resolved), GIT_OBJECT_ANY);\n\tgit_reference_free(resolved);\n\n\treturn error;\n}\n\nstatic int ensure_base_rev_loaded(git_object **object, git_reference **reference, const char *spec, size_t identifier_len, git_repository *repo, bool allow_empty_identifier)\n{\n\tint error;\n\tgit_str identifier = GIT_STR_INIT;\n\n\tif (*object != NULL)\n\t\treturn 0;\n\n\tif (*reference != NULL)\n\t\treturn object_from_reference(object, *reference);\n\n\tif (!allow_empty_identifier && identifier_len == 0)\n\t\treturn GIT_EINVALIDSPEC;\n\n\tif (git_str_put(&identifier, spec, identifier_len) < 0)\n\t\treturn -1;\n\n\terror = revparse_lookup_object(object, reference, repo, git_str_cstr(&identifier));\n\tgit_str_dispose(&identifier);\n\n\treturn error;\n}\n\nstatic int ensure_base_rev_is_not_known_yet(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn 0;\n\n\treturn GIT_EINVALIDSPEC;\n}\n\nstatic bool any_left_hand_identifier(git_object *object, git_reference *reference, size_t identifier_len)\n{\n\tif (object != NULL)\n\t\treturn true;\n\n\tif (reference != NULL)\n\t\treturn true;\n\n\tif (identifier_len > 0)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int ensure_left_hand_identifier_is_not_known_yet(git_object *object, git_reference *reference)\n{\n\tif (!ensure_base_rev_is_not_known_yet(object) && reference == NULL)\n\t\treturn 0;\n\n\treturn GIT_EINVALIDSPEC;\n}\n\nstatic int revparse(\n\tgit_object **object_out,\n\tgit_reference **reference_out,\n\tsize_t *identifier_len_out,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tsize_t pos = 0, identifier_len = 0;\n\tint error = -1, n;\n\tgit_str buf = GIT_STR_INIT;\n\n\tgit_reference *reference = NULL;\n\tgit_object *base_rev = NULL;\n\n\tbool should_return_reference = true;\n\n\tGIT_ASSERT_ARG(object_out);\n\tGIT_ASSERT_ARG(reference_out);\n\tGIT_ASSERT_ARG(repo);\n\tGIT_ASSERT_ARG(spec);\n\n\t*object_out = NULL;\n\t*reference_out = NULL;\n\n\twhile (spec[pos]) {\n\t\tswitch (spec[pos]) {\n\t\tcase '^':\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (spec[pos+1] == '{') {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_curly_braces_content(&buf, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_caret_curly_syntax(&temp_object, base_rev, git_str_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tgit_object_free(base_rev);\n\t\t\t\tbase_rev = temp_object;\n\t\t\t} else {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_how_many(&n, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_caret_parent_syntax(&temp_object, base_rev, n)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tgit_object_free(base_rev);\n\t\t\t\tbase_rev = temp_object;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '~':\n\t\t{\n\t\t\tgit_object *temp_object = NULL;\n\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = extract_how_many(&n, spec, &pos)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif ((error = handle_linear_syntax(&temp_object, base_rev, n)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tgit_object_free(base_rev);\n\t\t\tbase_rev = temp_object;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase ':':\n\t\t{\n\t\t\tgit_object *temp_object = NULL;\n\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = extract_path(&buf, spec, &pos)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (any_left_hand_identifier(base_rev, reference, identifier_len)) {\n\t\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, true)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_colon_syntax(&temp_object, base_rev, git_str_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t} else {\n\t\t\t\tif (*git_str_cstr(&buf) == '/') {\n\t\t\t\t\tif ((error = handle_grep_syntax(&temp_object, repo, NULL, git_str_cstr(&buf) + 1)) < 0)\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t} else {\n\n\t\t\t\t\t/*\n\t\t\t\t\t * TODO: support merge-stage path lookup (\":2:Makefile\")\n\t\t\t\t\t * and plain index blob lookup (:i-am/a/blob)\n\t\t\t\t\t */\n\t\t\t\t\tgit_error_set(GIT_ERROR_INVALID, \"unimplemented\");\n\t\t\t\t\terror = GIT_ERROR;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgit_object_free(base_rev);\n\t\t\tbase_rev = temp_object;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase '@':\n\t\t\tif (spec[pos+1] == '{') {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_curly_braces_content(&buf, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = ensure_base_rev_is_not_known_yet(base_rev)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_at_syntax(&temp_object, &reference, spec, identifier_len, repo, git_str_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif (temp_object != NULL)\n\t\t\t\t\tbase_rev = temp_object;\n\t\t\t\tbreak;\n\t\t\t} else if (spec[pos+1] == '\\0') {\n\t\t\t\tspec = \"HEAD\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall through */\n\n\t\tdefault:\n\t\t\tif ((error = ensure_left_hand_identifier_is_not_known_yet(base_rev, reference)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tpos++;\n\t\t\tidentifier_len++;\n\t\t}\n\t}\n\n\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\tgoto cleanup;\n\n\tif (!should_return_reference) {\n\t\tgit_reference_free(reference);\n\t\treference = NULL;\n\t}\n\n\t*object_out = base_rev;\n\t*reference_out = reference;\n\t*identifier_len_out = identifier_len;\n\terror = 0;\n\ncleanup:\n\tif (error) {\n\t\tif (error == GIT_EINVALIDSPEC)\n\t\t\tgit_error_set(GIT_ERROR_INVALID,\n\t\t\t\t\"failed to parse revision specifier - Invalid pattern '%s'\", spec);\n\n\t\tgit_object_free(base_rev);\n\t\tgit_reference_free(reference);\n\t}\n\n\tgit_str_dispose(&buf);\n\treturn error;\n}\n\nint git_revparse_ext(\n\tgit_object **object_out,\n\tgit_reference **reference_out,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tint error;\n\tsize_t identifier_len;\n\tgit_object *obj = NULL;\n\tgit_reference *ref = NULL;\n\n\tif ((error = revparse(&obj, &ref, &identifier_len, repo, spec)) < 0)\n\t\tgoto cleanup;\n\n\t*object_out = obj;\n\t*reference_out = ref;\n\tGIT_UNUSED(identifier_len);\n\n\treturn 0;\n\ncleanup:\n\tgit_object_free(obj);\n\tgit_reference_free(ref);\n\treturn error;\n}\n\nint git_revparse_single(git_object **out, git_repository *repo, const char *spec)\n{\n\tint error;\n\tgit_object *obj = NULL;\n\tgit_reference *ref = NULL;\n\n\t*out = NULL;\n\n\tif ((error = git_revparse_ext(&obj, &ref, repo, spec)) < 0)\n\t\tgoto cleanup;\n\n\tgit_reference_free(ref);\n\n\t*out = obj;\n\n\treturn 0;\n\ncleanup:\n\tgit_object_free(obj);\n\tgit_reference_free(ref);\n\treturn error;\n}\n\nint git_revparse(\n\tgit_revspec *revspec,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tconst char *dotdot;\n\tint error = 0;\n\n\tGIT_ASSERT_ARG(revspec);\n\tGIT_ASSERT_ARG(repo);\n\tGIT_ASSERT_ARG(spec);\n\n\tmemset(revspec, 0x0, sizeof(*revspec));\n\n\tif ((dotdot = strstr(spec, \"..\")) != NULL) {\n\t\tchar *lstr;\n\t\tconst char *rstr;\n\t\trevspec->flags = GIT_REVSPEC_RANGE;\n\n\t\t/*\n\t\t * Following git.git, don't allow '..' because it makes command line\n\t\t * arguments which can be either paths or revisions ambiguous when the\n\t\t * path is almost certainly intended. The empty range '...' is still\n\t\t * allowed.\n\t\t */\n\t\tif (!git__strcmp(spec, \"..\")) {\n\t\t\tgit_error_set(GIT_ERROR_INVALID, \"Invalid pattern '..'\");\n\t\t\treturn GIT_EINVALIDSPEC;\n\t\t}\n\n\t\tlstr = git__substrdup(spec, dotdot - spec);\n\t\trstr = dotdot + 2;\n\t\tif (dotdot[2] == '.') {\n\t\t\trevspec->flags |= GIT_REVSPEC_MERGE_BASE;\n\t\t\trstr++;\n\t\t}\n\n\t\terror = git_revparse_single(\n\t\t\t&revspec->from,\n\t\t\trepo,\n\t\t\t*lstr == '\\0' ? \"HEAD\" : lstr);\n\n\t\tif (!error) {\n\t\t\terror = git_revparse_single(\n\t\t\t\t&revspec->to,\n\t\t\t\trepo,\n\t\t\t\t*rstr == '\\0' ? \"HEAD\" : rstr);\n\t\t}\n\n\t\tgit__free((void*)lstr);\n\t} else {\n\t\trevspec->flags = GIT_REVSPEC_SINGLE;\n\t\terror = git_revparse_single(&revspec->from, repo, spec);\n\t}\n\n\treturn error;\n}\n", "#include \"clar_libgit2.h\"\n\n#include \"git2/revparse.h\"\n#include \"refs.h\"\n#include \"path.h\"\n\nstatic git_repository *g_repo;\nstatic git_object *g_obj;\n\n/* Helpers */\nstatic void test_object_and_ref_inrepo(\n\tconst char *spec,\n\tconst char *expected_oid,\n\tconst char *expected_refname,\n\tgit_repository *repo,\n\tbool assert_reference_retrieval)\n{\n\tchar objstr[64] = {0};\n\tgit_object *obj = NULL;\n\tgit_reference *ref = NULL;\n\tint error;\n\n\terror = git_revparse_ext(&obj, &ref, repo, spec);\n\n\tif (expected_oid != NULL) {\n\t\tcl_git_pass(error);\n\t\tgit_oid_fmt(objstr, git_object_id(obj));\n\t\tcl_assert_equal_s(objstr, expected_oid);\n\t} else\n\t\tcl_git_fail(error);\n\n\tif (assert_reference_retrieval) {\n\t\tif (expected_refname == NULL)\n\t\t\tcl_assert(NULL == ref);\n\t\telse\n\t\t\tcl_assert_equal_s(expected_refname, git_reference_name(ref));\n\t}\n\n\tgit_object_free(obj);\n\tgit_reference_free(ref);\n}\n\nstatic void test_object_inrepo(const char *spec, const char *expected_oid, git_repository *repo)\n{\n\ttest_object_and_ref_inrepo(spec, expected_oid, NULL, repo, false);\n}\n\nstatic void test_id_inrepo(\n\tconst char *spec,\n\tconst char *expected_left,\n\tconst char *expected_right,\n\tgit_revspec_t expected_flags,\n\tgit_repository *repo)\n{\n\tgit_revspec revspec;\n\tint error = git_revparse(&revspec, repo, spec);\n\n\tif (expected_left) {\n\t\tchar str[64] = {0};\n\t\tcl_assert_equal_i(0, error);\n\t\tgit_oid_fmt(str, git_object_id(revspec.from));\n\t\tcl_assert_equal_s(str, expected_left);\n\t\tgit_object_free(revspec.from);\n\t} else {\n\t\tcl_assert_equal_i(GIT_ENOTFOUND, error);\n\t}\n\n\tif (expected_right) {\n\t\tchar str[64] = {0};\n\t\tgit_oid_fmt(str, git_object_id(revspec.to));\n\t\tcl_assert_equal_s(str, expected_right);\n\t\tgit_object_free(revspec.to);\n\t}\n\n\tif (expected_flags)\n\t\tcl_assert_equal_i(expected_flags, revspec.flags);\n}\n\nstatic void test_object(const char *spec, const char *expected_oid)\n{\n\ttest_object_inrepo(spec, expected_oid, g_repo);\n}\n\nstatic void test_object_and_ref(const char *spec, const char *expected_oid, const char *expected_refname)\n{\n\ttest_object_and_ref_inrepo(spec, expected_oid, expected_refname, g_repo, true);\n}\n\nstatic void test_rangelike(const char *rangelike,\n\t\t\t\t\t\t   const char *expected_left,\n\t\t\t\t\t\t   const char *expected_right,\n\t\t\t\t\t\t   git_revspec_t expected_revparseflags)\n{\n\tchar objstr[64] = {0};\n\tgit_revspec revspec;\n\tint error;\n\n\terror = git_revparse(&revspec, g_repo, rangelike);\n\n\tif (expected_left != NULL) {\n\t\tcl_assert_equal_i(0, error);\n\t\tcl_assert_equal_i(revspec.flags, expected_revparseflags);\n\t\tgit_oid_fmt(objstr, git_object_id(revspec.from));\n\t\tcl_assert_equal_s(objstr, expected_left);\n\t\tgit_oid_fmt(objstr, git_object_id(revspec.to));\n\t\tcl_assert_equal_s(objstr, expected_right);\n\t} else\n\t\tcl_assert(error != 0);\n\n\tgit_object_free(revspec.from);\n\tgit_object_free(revspec.to);\n}\n\n\nstatic void test_id(\n\tconst char *spec,\n\tconst char *expected_left,\n\tconst char *expected_right,\n\tgit_revspec_t expected_flags)\n{\n\ttest_id_inrepo(spec, expected_left, expected_right, expected_flags, g_repo);\n}\n\nstatic void test_invalid_revspec(const char* invalid_spec)\n{\n\tgit_revspec revspec;\n\n\tcl_assert_equal_i(\n\t\tGIT_EINVALIDSPEC, git_revparse(&revspec, g_repo, invalid_spec));\n}\n\nvoid test_refs_revparse__initialize(void)\n{\n\tcl_git_pass(git_repository_open(&g_repo, cl_fixture(\"testrepo.git\")));\n}\n\nvoid test_refs_revparse__cleanup(void)\n{\n\tgit_repository_free(g_repo);\n}\n\nvoid test_refs_revparse__nonexistant_object(void)\n{\n\ttest_object(\"this-does-not-exist\", NULL);\n\ttest_object(\"this-does-not-exist^1\", NULL);\n\ttest_object(\"this-does-not-exist~2\", NULL);\n}\n\nstatic void assert_invalid_single_spec(const char *invalid_spec)\n{\n\tcl_assert_equal_i(\n\t\tGIT_EINVALIDSPEC, git_revparse_single(&g_obj, g_repo, invalid_spec));\n}\n\nvoid test_refs_revparse__invalid_reference_name(void)\n{\n\tassert_invalid_single_spec(\"this doesn't make sense\");\n\tassert_invalid_single_spec(\"Inv@{id\");\n\tassert_invalid_single_spec(\"\");\n}\n\nvoid test_refs_revparse__shas(void)\n{\n\ttest_object(\"c47800c7266a2be04c571c04d5a6614691ea99bd\", \"c47800c7266a2be04c571c04d5a6614691ea99bd\");\n\ttest_object(\"c47800c\", \"c47800c7266a2be04c571c04d5a6614691ea99bd\");\n}\n\nvoid test_refs_revparse__head(void)\n{\n\ttest_object(\"HEAD\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"HEAD^0\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"HEAD~0\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"master\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n}\n\nvoid test_refs_revparse__full_refs(void)\n{\n\ttest_object(\"refs/heads/master\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"refs/heads/test\", \"e90810b8df3e80c413d903f631643c716887138d\");\n\ttest_object(\"refs/tags/test\", \"b25fa35b38051e4ae45d4222e795f9df2e43f1d1\");\n}\n\nvoid test_refs_revparse__partial_refs(void)\n{\n\ttest_object(\"point_to_blob\", \"1385f264afb75a56a5bec74243be9b367ba4ca08\");\n\ttest_object(\"packed-test\", \"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\");\n\ttest_object(\"br2\", \"a4a7dce85cf63874e984719f4fdd239f5145052f\");\n}\n\nvoid test_refs_revparse__describe_output(void)\n{\n\ttest_object(\"blah-7-gc47800c\", \"c47800c7266a2be04c571c04d5a6614691ea99bd\");\n\ttest_object(\"not-good\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n}\n\nvoid test_refs_revparse__nth_parent(void)\n{\n\tassert_invalid_single_spec(\"be3563a^-1\");\n\tassert_invalid_single_spec(\"^\");\n\tassert_invalid_single_spec(\"be3563a^{tree}^\");\n\tassert_invalid_single_spec(\"point_to_blob^{blob}^\");\n\tassert_invalid_single_spec(\"this doesn't make sense^1\");\n\n\ttest_object(\"be3563a^1\", \"9fd738e8f7967c078dceed8190330fc8648ee56a\");\n\ttest_object(\"be3563a^\", \"9fd738e8f7967c078dceed8190330fc8648ee56a\");\n\ttest_object(\"be3563a^2\", \"c47800c7266a2be04c571c04d5a6614691ea99bd\");\n\ttest_object(\"be3563a^1^1\", \"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\");\n\ttest_object(\"be3563a^^\", \"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\");\n\ttest_object(\"be3563a^2^1\", \"5b5b025afb0b4c913b4c338a42934a3863bf3644\");\n\ttest_object(\"be3563a^0\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"be3563a^{commit}^\", \"9fd738e8f7967c078dceed8190330fc8648ee56a\");\n\n\ttest_object(\"be3563a^42\", NULL);\n}\n\nvoid test_refs_revparse__not_tag(void)\n{\n\ttest_object(\"point_to_blob^{}\", \"1385f264afb75a56a5bec74243be9b367ba4ca08\");\n\ttest_object(\"wrapped_tag^{}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"master^{}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"master^{tree}^{}\", \"944c0f6e4dfa41595e6eb3ceecdb14f50fe18162\");\n\ttest_object(\"e90810b^{}\", \"e90810b8df3e80c413d903f631643c716887138d\");\n\ttest_object(\"tags/e90810b^{}\", \"e90810b8df3e80c413d903f631643c716887138d\");\n\ttest_object(\"e908^{}\", \"e90810b8df3e80c413d903f631643c716887138d\");\n}\n\nvoid test_refs_revparse__to_type(void)\n{\n\tassert_invalid_single_spec(\"wrapped_tag^{trip}\");\n\ttest_object(\"point_to_blob^{commit}\", NULL);\n\tcl_assert_equal_i(\n\t\tGIT_EPEEL, git_revparse_single(&g_obj, g_repo, \"wrapped_tag^{blob}\"));\n\n\ttest_object(\"wrapped_tag^{commit}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"wrapped_tag^{tree}\", \"944c0f6e4dfa41595e6eb3ceecdb14f50fe18162\");\n\ttest_object(\"point_to_blob^{blob}\", \"1385f264afb75a56a5bec74243be9b367ba4ca08\");\n\ttest_object(\"master^{commit}^{commit}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n}\n\nvoid test_refs_revparse__linear_history(void)\n{\n\tassert_invalid_single_spec(\"~\");\n\ttest_object(\"foo~bar\", NULL);\n\n\tassert_invalid_single_spec(\"master~bar\");\n\tassert_invalid_single_spec(\"master~-1\");\n\tassert_invalid_single_spec(\"master~0bar\");\n\tassert_invalid_single_spec(\"this doesn't make sense~2\");\n\tassert_invalid_single_spec(\"be3563a^{tree}~\");\n\tassert_invalid_single_spec(\"point_to_blob^{blob}~\");\n\n\ttest_object(\"master~0\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"master~1\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"master~2\", \"9fd738e8f7967c078dceed8190330fc8648ee56a\");\n\ttest_object(\"master~1~1\", \"9fd738e8f7967c078dceed8190330fc8648ee56a\");\n\ttest_object(\"master~~\", \"9fd738e8f7967c078dceed8190330fc8648ee56a\");\n}\n\nvoid test_refs_revparse__chaining(void)\n{\n\tassert_invalid_single_spec(\"master@{0}@{0}\");\n\tassert_invalid_single_spec(\"@{u}@{-1}\");\n\tassert_invalid_single_spec(\"@{-1}@{-1}\");\n\tassert_invalid_single_spec(\"@{-3}@{0}\");\n\n\ttest_object(\"master@{0}~1^1\", \"9fd738e8f7967c078dceed8190330fc8648ee56a\");\n\ttest_object(\"@{u}@{0}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"@{-1}@{0}\", \"a4a7dce85cf63874e984719f4fdd239f5145052f\");\n\ttest_object(\"@{-4}@{1}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"master~1^1\", \"9fd738e8f7967c078dceed8190330fc8648ee56a\");\n\ttest_object(\"master~1^2\", \"c47800c7266a2be04c571c04d5a6614691ea99bd\");\n\ttest_object(\"master^1^2~1\", \"5b5b025afb0b4c913b4c338a42934a3863bf3644\");\n\ttest_object(\"master^^2^\", \"5b5b025afb0b4c913b4c338a42934a3863bf3644\");\n\ttest_object(\"master^1^1^1^1^1\", \"8496071c1b46c854b31185ea97743be6a8774479\");\n\ttest_object(\"master^^1^2^1\", NULL);\n}\n\nvoid test_refs_revparse__upstream(void)\n{\n\tassert_invalid_single_spec(\"e90810b@{u}\");\n\tassert_invalid_single_spec(\"refs/tags/e90810b@{u}\");\n\ttest_object(\"refs/heads/e90810b@{u}\", NULL);\n\n\ttest_object(\"master@{upstream}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"@{u}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"master@{u}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"heads/master@{u}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"refs/heads/master@{u}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n}\n\nvoid test_refs_revparse__ordinal(void)\n{\n\tassert_invalid_single_spec(\"master@{-2}\");\n\n\t/* TODO: make the test below actually fail\n\t * cl_git_fail(git_revparse_single(&g_obj, g_repo, \"master@{1a}\"));\n\t */\n\n\ttest_object(\"nope@{0}\", NULL);\n\ttest_object(\"master@{31415}\", NULL);\n\ttest_object(\"@{1000}\", NULL);\n\ttest_object(\"@{2}\", NULL);\n\n\ttest_object(\"@{0}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"@{1}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\n\ttest_object(\"master@{0}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"master@{1}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"heads/master@{1}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"refs/heads/master@{1}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n}\n\nvoid test_refs_revparse__previous_head(void)\n{\n\tassert_invalid_single_spec(\"@{-xyz}\");\n\tassert_invalid_single_spec(\"@{-0}\");\n\tassert_invalid_single_spec(\"@{-1b}\");\n\n\ttest_object(\"@{-42}\", NULL);\n\n\ttest_object(\"@{-2}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"@{-1}\", \"a4a7dce85cf63874e984719f4fdd239f5145052f\");\n}\n\nstatic void create_fake_stash_reference_and_reflog(git_repository *repo)\n{\n\tgit_reference *master, *new_master;\n\tgit_str log_path = GIT_STR_INIT;\n\n\tgit_str_joinpath(&log_path, git_repository_path(repo), \"logs/refs/fakestash\");\n\n\tcl_assert_equal_i(false, git_fs_path_isfile(git_str_cstr(&log_path)));\n\n\tcl_git_pass(git_reference_lookup(&master, repo, \"refs/heads/master\"));\n\tcl_git_pass(git_reference_rename(&new_master, master, \"refs/fakestash\", 0, NULL));\n\tgit_reference_free(master);\n\n\tcl_assert_equal_i(true, git_fs_path_isfile(git_str_cstr(&log_path)));\n\n\tgit_str_dispose(&log_path);\n\tgit_reference_free(new_master);\n}\n\nvoid test_refs_revparse__reflog_of_a_ref_under_refs(void)\n{\n\tgit_repository *repo = cl_git_sandbox_init(\"testrepo.git\");\n\n\ttest_object_inrepo(\"refs/fakestash\", NULL, repo);\n\n\tcreate_fake_stash_reference_and_reflog(repo);\n\n\t/*\n\t * $ git reflog -1 refs/fakestash\n\t * a65fedf refs/fakestash@{0}: commit: checking in\n\t *\n\t * $ git reflog -1 refs/fakestash@{0}\n\t * a65fedf refs/fakestash@{0}: commit: checking in\n\t *\n\t * $ git reflog -1 fakestash\n\t * a65fedf fakestash@{0}: commit: checking in\n\t *\n\t * $ git reflog -1 fakestash@{0}\n\t * a65fedf fakestash@{0}: commit: checking in\n\t */\n\ttest_object_inrepo(\"refs/fakestash\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", repo);\n\ttest_object_inrepo(\"refs/fakestash@{0}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", repo);\n\ttest_object_inrepo(\"fakestash\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", repo);\n\ttest_object_inrepo(\"fakestash@{0}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", repo);\n\n\tcl_git_sandbox_cleanup();\n}\n\nvoid test_refs_revparse__revwalk(void)\n{\n\ttest_object(\"master^{/not found in any commit}\", NULL);\n\ttest_object(\"master^{/merge}\", NULL);\n\tassert_invalid_single_spec(\"master^{/((}\");\n\n\ttest_object(\"master^{/anoth}\", \"5b5b025afb0b4c913b4c338a42934a3863bf3644\");\n\ttest_object(\"master^{/Merge}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"br2^{/Merge}\", \"a4a7dce85cf63874e984719f4fdd239f5145052f\");\n\ttest_object(\"master^{/fo.rth}\", \"9fd738e8f7967c078dceed8190330fc8648ee56a\");\n}\n\nvoid test_refs_revparse__date(void)\n{\n\t/*\n\t * $ git reflog HEAD --date=iso\n\t * a65fedf HEAD@{2012-04-30 08:23:41 -0900}: checkout: moving from br2 to master\n\t * a4a7dce HEAD@{2012-04-30 08:23:37 -0900}: commit: checking in\n\t * c47800c HEAD@{2012-04-30 08:23:28 -0900}: checkout: moving from master to br2\n\t * a65fedf HEAD@{2012-04-30 08:23:23 -0900}: commit:\n\t * be3563a HEAD@{2012-04-30 10:22:43 -0700}: clone: from /Users/ben/src/libgit2/tes\n\t *\n\t * $ git reflog HEAD --date=raw\n\t * a65fedf HEAD@{1335806621 -0900}: checkout: moving from br2 to master\n\t * a4a7dce HEAD@{1335806617 -0900}: commit: checking in\n\t * c47800c HEAD@{1335806608 -0900}: checkout: moving from master to br2\n\t * a65fedf HEAD@{1335806603 -0900}: commit:\n\t * be3563a HEAD@{1335806563 -0700}: clone: from /Users/ben/src/libgit2/tests/resour\n\t */\n\ttest_object(\"HEAD@{10 years ago}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\n\ttest_object(\"HEAD@{1 second}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"HEAD@{1 second ago}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"HEAD@{2 days ago}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\n\t/*\n\t * $ git reflog master --date=iso\n\t * a65fedf master@{2012-04-30 09:23:23 -0800}: commit: checking in\n\t * be3563a master@{2012-04-30 09:22:43 -0800}: clone: from /Users/ben/src...\n\t *\n\t * $ git reflog master --date=raw\n\t * a65fedf master@{1335806603 -0800}: commit: checking in\n\t * be3563a master@{1335806563 -0800}: clone: from /Users/ben/src/libgit2/tests/reso\n\t */\n\n\n\t/*\n\t * $ git rev-parse \"master@{2012-04-30 17:22:42 +0000}\"\n\t * warning: log for 'master' only goes back to Mon, 30 Apr 2012 09:22:43 -0800\n\t * be3563ae3f795b2b4353bcce3a527ad0a4f7f644\n\t */\n\ttest_object(\"master@{2012-04-30 17:22:42 +0000}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"master@{2012-04-30 09:22:42 -0800}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\n\t/*\n\t * $ git reflog -1 \"master@{2012-04-30 17:22:43 +0000}\"\n\t * be3563a master@{Mon Apr 30 09:22:43 2012 -0800}: clone: from /Users/ben/src/libg\n\t */\n\ttest_object(\"master@{2012-04-30 17:22:43 +0000}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\ttest_object(\"master@{2012-04-30 09:22:43 -0800}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\n\t/*\n\t * $ git reflog -1 \"master@{2012-4-30 09:23:27 -0800}\"\n\t * a65fedf master@{Mon Apr 30 09:23:23 2012 -0800}: commit: checking in\n\t */\n\ttest_object(\"master@{2012-4-30 09:23:27 -0800}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\n\t/*\n\t * $ git reflog -1 master@{2012-05-03}\n\t * a65fedf master@{Mon Apr 30 09:23:23 2012 -0800}: commit: checking in\n\t */\n\ttest_object(\"master@{2012-05-03}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\n\t/*\n\t * $ git reflog -1 \"master@{1335806603}\"\n\t * a65fedf\n\t *\n\t * $ git reflog -1 \"master@{1335806602}\"\n\t * be3563a\n\t */\n\ttest_object(\"master@{1335806603}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\ttest_object(\"master@{1335806602}\", \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\");\n\n\t/*\n\t * $ git rev-parse \"with-empty-log@{2 days ago}\" --\n\t * fatal: log for refs/heads/with-empty-log is empty\n\t */\n\ttest_object(\"with-empty-log@{2 days ago}\", NULL);\n}\n\nvoid test_refs_revparse__invalid_date(void)\n{\n\t/*\n\t * $ git rev-parse HEAD@{} --\n\t * fatal: bad revision 'HEAD@{}'\n\t *\n\t * $ git rev-parse HEAD@{NEITHER_INTEGER_NOR_DATETIME} --\n\t * fatal: bad revision 'HEAD@{NEITHER_INTEGER_NOR_DATETIME}'\n\t */\n\ttest_object(\"HEAD@{}\", NULL);\n\ttest_object(\"HEAD@{NEITHER_INTEGER_NOR_DATETIME}\", NULL);\n}\n\nvoid test_refs_revparse__colon(void)\n{\n\tassert_invalid_single_spec(\":/\");\n\tassert_invalid_single_spec(\"point_to_blob:readme.txt\");\n\tcl_git_fail(git_revparse_single(&g_obj, g_repo, \":2:README\")); /* Not implemented  */\n\n\ttest_object(\":/not found in any commit\", NULL);\n\ttest_object(\"subtrees:ab/42.txt\", NULL);\n\ttest_object(\"subtrees:ab/4.txt/nope\", NULL);\n\ttest_object(\"subtrees:nope\", NULL);\n\ttest_object(\"test/master^1:branch_file.txt\", NULL);\n\n\t/* From tags */\n\ttest_object(\"test:readme.txt\", \"0266163a49e280c4f5ed1e08facd36a2bd716bcf\");\n\ttest_object(\"tags/test:readme.txt\", \"0266163a49e280c4f5ed1e08facd36a2bd716bcf\");\n\ttest_object(\"e90810b:readme.txt\", \"0266163a49e280c4f5ed1e08facd36a2bd716bcf\");\n\ttest_object(\"tags/e90810b:readme.txt\", \"0266163a49e280c4f5ed1e08facd36a2bd716bcf\");\n\n\t/* From commits */\n\ttest_object(\"a65f:branch_file.txt\", \"3697d64be941a53d4ae8f6a271e4e3fa56b022cc\");\n\n\t/* From trees */\n\ttest_object(\"a65f^{tree}:branch_file.txt\", \"3697d64be941a53d4ae8f6a271e4e3fa56b022cc\");\n\ttest_object(\"944c:branch_file.txt\", \"3697d64be941a53d4ae8f6a271e4e3fa56b022cc\");\n\n\t/* Retrieving trees */\n\ttest_object(\"master:\", \"944c0f6e4dfa41595e6eb3ceecdb14f50fe18162\");\n\ttest_object(\"subtrees:\", \"ae90f12eea699729ed24555e40b9fd669da12a12\");\n\ttest_object(\"subtrees:ab\", \"f1425cef211cc08caa31e7b545ffb232acb098c3\");\n\ttest_object(\"subtrees:ab/\", \"f1425cef211cc08caa31e7b545ffb232acb098c3\");\n\n\t/* Retrieving blobs */\n\ttest_object(\"subtrees:ab/4.txt\", \"d6c93164c249c8000205dd4ec5cbca1b516d487f\");\n\ttest_object(\"subtrees:ab/de/fgh/1.txt\", \"1f67fc4386b2d171e0d21be1c447e12660561f9b\");\n\ttest_object(\"master:README\", \"a8233120f6ad708f843d861ce2b7228ec4e3dec6\");\n\ttest_object(\"master:new.txt\", \"a71586c1dfe8a71c6cbf6c129f404c5642ff31bd\");\n\ttest_object(\":/Merge\", \"a4a7dce85cf63874e984719f4fdd239f5145052f\");\n\ttest_object(\":/one\", \"c47800c7266a2be04c571c04d5a6614691ea99bd\");\n\ttest_object(\":/packed commit t\", \"41bc8c69075bbdb46c5c6f0566cc8cc5b46e8bd9\");\n\ttest_object(\"test/master^2:branch_file.txt\", \"45b983be36b73c0788dc9cbcb76cbb80fc7bb057\");\n\ttest_object(\"test/master@{1}:branch_file.txt\", \"3697d64be941a53d4ae8f6a271e4e3fa56b022cc\");\n}\n\nvoid test_refs_revparse__disambiguation(void)\n{\n\t/*\n\t * $ git show e90810b\n\t * tag e90810b\n\t * Tagger: Vicent Marti <tanoku@gmail.com>\n\t * Date:   Thu Aug 12 03:59:17 2010 +0200\n\t *\n\t * This is a very simple tag.\n\t *\n\t * commit e90810b8df3e80c413d903f631643c716887138d\n\t * Author: Vicent Marti <tanoku@gmail.com>\n\t * Date:   Thu Aug 5 18:42:20 2010 +0200\n\t *\n\t *     Test commit 2\n\t *\n\t * diff --git a/readme.txt b/readme.txt\n\t * index 6336846..0266163 100644\n\t * --- a/readme.txt\n\t * +++ b/readme.txt\n\t * @@ -1 +1,2 @@\n\t *  Testing a readme.txt\n\t * +Now we add a single line here\n\t *\n\t * $ git show-ref e90810b\n\t * 7b4384978d2493e851f9cca7858815fac9b10980 refs/tags/e90810b\n\t *\n\t */\n\ttest_object(\"e90810b\", \"7b4384978d2493e851f9cca7858815fac9b10980\");\n\n\t/*\n\t * $ git show e90810\n\t * commit e90810b8df3e80c413d903f631643c716887138d\n\t * Author: Vicent Marti <tanoku@gmail.com>\n\t * Date:   Thu Aug 5 18:42:20 2010 +0200\n\t *\n\t *     Test commit 2\n\t *\n\t * diff --git a/readme.txt b/readme.txt\n\t * index 6336846..0266163 100644\n\t * --- a/readme.txt\n\t * +++ b/readme.txt\n\t * @@ -1 +1,2 @@\n\t *  Testing a readme.txt\n\t * +Now we add a single line here\n\t */\n\ttest_object(\"e90810\", \"e90810b8df3e80c413d903f631643c716887138d\");\n}\n\nvoid test_refs_revparse__a_too_short_objectid_returns_EAMBIGUOUS(void)\n{\n\tcl_assert_equal_i(\n\t\tGIT_EAMBIGUOUS, git_revparse_single(&g_obj, g_repo, \"e90\"));\n}\n\n/*\n * $ echo \"aabqhq\" | git hash-object -t blob --stdin\n * dea509d0b3cb8ee0650f6ca210bc83f4678851ba\n *\n * $ echo \"aaazvc\" | git hash-object -t blob --stdin\n * dea509d097ce692e167dfc6a48a7a280cc5e877e\n */\nvoid test_refs_revparse__a_not_precise_enough_objectid_returns_EAMBIGUOUS(void)\n{\n\tgit_repository *repo;\n\tgit_index *index;\n\tgit_object *obj;\n\n\trepo = cl_git_sandbox_init(\"testrepo\");\n\n\tcl_git_mkfile(\"testrepo/one.txt\", \"aabqhq\\n\");\n\tcl_git_mkfile(\"testrepo/two.txt\", \"aaazvc\\n\");\n\n\tcl_git_pass(git_repository_index(&index, repo));\n\tcl_git_pass(git_index_add_bypath(index, \"one.txt\"));\n\tcl_git_pass(git_index_add_bypath(index, \"two.txt\"));\n\n\tcl_git_fail_with(git_revparse_single(&obj, repo, \"dea509d0\"), GIT_EAMBIGUOUS);\n\n\tcl_git_pass(git_revparse_single(&obj, repo, \"dea509d09\"));\n\n\tgit_object_free(obj);\n\tgit_index_free(index);\n\tcl_git_sandbox_cleanup();\n}\n\nvoid test_refs_revparse__issue_994(void)\n{\n\tgit_repository *repo;\n\tgit_reference *head, *with_at;\n\tgit_object *target;\n\n\trepo = cl_git_sandbox_init(\"testrepo.git\");\n\n\tcl_assert_equal_i(GIT_ENOTFOUND,\n\t\tgit_revparse_single(&target, repo, \"origin/bim_with_3d@11296\"));\n\n\tcl_assert_equal_i(GIT_ENOTFOUND,\n\t\tgit_revparse_single(&target, repo, \"refs/remotes/origin/bim_with_3d@11296\"));\n\n\n\tcl_git_pass(git_repository_head(&head, repo));\n\tcl_git_pass(git_reference_create(\n\t\t&with_at,\n\t\trepo,\n\t\t\"refs/remotes/origin/bim_with_3d@11296\",\n\t\tgit_reference_target(head),\n\t\t0,\n\t\tNULL));\n\n\tcl_git_pass(git_revparse_single(&target, repo, \"origin/bim_with_3d@11296\"));\n\tgit_object_free(target);\n\n\tcl_git_pass(git_revparse_single(&target, repo, \"refs/remotes/origin/bim_with_3d@11296\"));\n\tgit_object_free(target);\n\n\tgit_reference_free(with_at);\n\tgit_reference_free(head);\n\tcl_git_sandbox_cleanup();\n}\n\n/**\n * $ git rev-parse blah-7-gc47800c\n * c47800c7266a2be04c571c04d5a6614691ea99bd\n *\n * $ git rev-parse HEAD~3\n * 4a202b346bb0fb0db7eff3cffeb3c70babbd2045\n *\n * $ git branch blah-7-gc47800c HEAD~3\n *\n * $ git rev-parse blah-7-gc47800c\n * 4a202b346bb0fb0db7eff3cffeb3c70babbd2045\n */\nvoid test_refs_revparse__try_to_retrieve_branch_before_described_tag(void)\n{\n\tgit_repository *repo;\n\tgit_reference *branch;\n\tgit_object *target;\n\tchar sha[GIT_OID_HEXSZ + 1];\n\n\trepo = cl_git_sandbox_init(\"testrepo.git\");\n\n\ttest_object_inrepo(\"blah-7-gc47800c\", \"c47800c7266a2be04c571c04d5a6614691ea99bd\", repo);\n\n\tcl_git_pass(git_revparse_single(&target, repo, \"HEAD~3\"));\n\tcl_git_pass(git_branch_create(&branch, repo, \"blah-7-gc47800c\", (git_commit *)target, 0));\n\n\tgit_oid_tostr(sha, GIT_OID_HEXSZ + 1, git_object_id(target));\n\n\ttest_object_inrepo(\"blah-7-gc47800c\", sha, repo);\n\n\tgit_reference_free(branch);\n\tgit_object_free(target);\n\tcl_git_sandbox_cleanup();\n}\n\n/**\n * $ git rev-parse a65fedf39aefe402d3bb6e24df4d4f5fe4547750\n * a65fedf39aefe402d3bb6e24df4d4f5fe4547750\n *\n * $ git rev-parse HEAD~3\n * 4a202b346bb0fb0db7eff3cffeb3c70babbd2045\n *\n * $ git branch a65fedf39aefe402d3bb6e24df4d4f5fe4547750 HEAD~3\n *\n * $ git rev-parse a65fedf39aefe402d3bb6e24df4d4f5fe4547750\n * a65fedf39aefe402d3bb6e24df4d4f5fe4547750\n *\n * $ git rev-parse heads/a65fedf39aefe402d3bb6e24df4d4f5fe4547750\n * 4a202b346bb0fb0db7eff3cffeb3c70babbd2045\n */\nvoid test_refs_revparse__try_to_retrieve_sha_before_branch(void)\n{\n\tgit_repository *repo;\n\tgit_reference *branch;\n\tgit_object *target;\n\tchar sha[GIT_OID_HEXSZ + 1];\n\n\trepo = cl_git_sandbox_init(\"testrepo.git\");\n\n\ttest_object_inrepo(\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", repo);\n\n\tcl_git_pass(git_revparse_single(&target, repo, \"HEAD~3\"));\n\tcl_git_pass(git_branch_create(&branch, repo, \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", (git_commit *)target, 0));\n\n\tgit_oid_tostr(sha, GIT_OID_HEXSZ + 1, git_object_id(target));\n\n\ttest_object_inrepo(\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", repo);\n\ttest_object_inrepo(\"heads/a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", sha, repo);\n\n\tgit_reference_free(branch);\n\tgit_object_free(target);\n\tcl_git_sandbox_cleanup();\n}\n\n/**\n * $ git rev-parse c47800\n * c47800c7266a2be04c571c04d5a6614691ea99bd\n *\n * $ git rev-parse HEAD~3\n * 4a202b346bb0fb0db7eff3cffeb3c70babbd2045\n *\n * $ git branch c47800 HEAD~3\n *\n * $ git rev-parse c47800\n * 4a202b346bb0fb0db7eff3cffeb3c70babbd2045\n */\nvoid test_refs_revparse__try_to_retrieve_branch_before_abbrev_sha(void)\n{\n\tgit_repository *repo;\n\tgit_reference *branch;\n\tgit_object *target;\n\tchar sha[GIT_OID_HEXSZ + 1];\n\n\trepo = cl_git_sandbox_init(\"testrepo.git\");\n\n\ttest_object_inrepo(\"c47800\", \"c47800c7266a2be04c571c04d5a6614691ea99bd\", repo);\n\n\tcl_git_pass(git_revparse_single(&target, repo, \"HEAD~3\"));\n\tcl_git_pass(git_branch_create(&branch, repo, \"c47800\", (git_commit *)target, 0));\n\n\tgit_oid_tostr(sha, GIT_OID_HEXSZ + 1, git_object_id(target));\n\n\ttest_object_inrepo(\"c47800\", sha, repo);\n\n\tgit_reference_free(branch);\n\tgit_object_free(target);\n\tcl_git_sandbox_cleanup();\n}\n\n\nvoid test_refs_revparse__range(void)\n{\n\tassert_invalid_single_spec(\"be3563a^1..be3563a\");\n\n\ttest_rangelike(\"be3563a^1..be3563a\",\n\t               \"9fd738e8f7967c078dceed8190330fc8648ee56a\",\n\t               \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\",\n\t               GIT_REVSPEC_RANGE);\n\n\ttest_rangelike(\"be3563a^1...be3563a\",\n\t               \"9fd738e8f7967c078dceed8190330fc8648ee56a\",\n\t               \"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\",\n\t               GIT_REVSPEC_RANGE | GIT_REVSPEC_MERGE_BASE);\n\n\ttest_rangelike(\"be3563a^1.be3563a\", NULL, NULL, 0);\n}\n\nvoid test_refs_revparse__parses_range_operator(void)\n{\n\ttest_id(\"HEAD\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n\ttest_id(\"HEAD~3..HEAD\",\n\t\t\"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\tGIT_REVSPEC_RANGE);\n\n\ttest_id(\"HEAD~3...HEAD\",\n\t\t\"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\tGIT_REVSPEC_RANGE | GIT_REVSPEC_MERGE_BASE);\n\n\ttest_id(\"HEAD~3..\",\n\t\t\"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\tGIT_REVSPEC_RANGE);\n\n\ttest_id(\"HEAD~3...\",\n\t\t\"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\tGIT_REVSPEC_RANGE | GIT_REVSPEC_MERGE_BASE);\n\n\ttest_id(\"..HEAD~3\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\t\"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\",\n\t\tGIT_REVSPEC_RANGE);\n\n\ttest_id(\"...HEAD~3\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\t\"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\",\n\t\tGIT_REVSPEC_RANGE | GIT_REVSPEC_MERGE_BASE);\n\n\ttest_id(\"...\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\tGIT_REVSPEC_RANGE | GIT_REVSPEC_MERGE_BASE);\n\n\ttest_invalid_revspec(\"..\");\n}\n\nvoid test_refs_revparse__ext_retrieves_both_the_reference_and_its_target(void)\n{\n\ttest_object_and_ref(\n\t\t\"master@{upstream}\",\n\t\t\"be3563ae3f795b2b4353bcce3a527ad0a4f7f644\",\n\t\t\"refs/remotes/test/master\");\n\n\ttest_object_and_ref(\n\t\t\"@{-1}\",\n\t\t\"a4a7dce85cf63874e984719f4fdd239f5145052f\",\n\t\t\"refs/heads/br2\");\n}\n\nvoid test_refs_revparse__ext_can_expand_short_reference_names(void)\n{\n\ttest_object_and_ref(\n\t\t\"master\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\t\"refs/heads/master\");\n\n\ttest_object_and_ref(\n\t\t\"HEAD\",\n\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n\t\t\"refs/heads/master\");\n\n    test_object_and_ref(\n\t\t\"tags/test\",\n\t\t\"b25fa35b38051e4ae45d4222e795f9df2e43f1d1\",\n        \"refs/tags/test\");\n}\n\nvoid test_refs_revparse__ext_returns_NULL_reference_when_expression_points_at_a_revision(void)\n{\n    test_object_and_ref(\n        \"HEAD~3\",\n        \"4a202b346bb0fb0db7eff3cffeb3c70babbd2045\",\n        NULL);\n\n    test_object_and_ref(\n        \"HEAD~0\",\n        \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n        NULL);\n\n    test_object_and_ref(\n        \"HEAD^0\",\n        \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\",\n        NULL);\n\n    test_object_and_ref(\n\t\t\"@{-1}@{0}\",\n\t\t\"a4a7dce85cf63874e984719f4fdd239f5145052f\",\n\t\tNULL);\n}\n\nvoid test_refs_revparse__ext_returns_NULL_reference_when_expression_points_at_a_tree_content(void)\n{\n    test_object_and_ref(\n\t\t\"tags/test:readme.txt\",\n\t\t\"0266163a49e280c4f5ed1e08facd36a2bd716bcf\",\n        NULL);\n}\n\nvoid test_refs_revparse__uneven_sizes(void)\n{\n\ttest_object(\"a65fedf39aefe402d3bb6e24df4d4f5fe454775\",\n\t\t\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\n\ttest_object(\"a65fedf39aefe402d3bb6e24df4d4f5fe45477\",\n\t\t\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\n\ttest_object(\"a65fedf39aefe402d3bb6e24df4d4f5fe4547\",\n\t\t\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n\n\ttest_object(\"a65fedf39aefe402d3bb6e24df4d\",\n\t\t\t\t\"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\");\n}\n\nvoid test_refs_revparse__parses_at_head(void)\n{\n\ttest_id(\"HEAD\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n\ttest_id(\"@{0}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n\ttest_id(\"@\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n}\n"], "filenames": ["src/revparse.c", "tests/refs/revparse.c"], "buggy_code_start_loc": [800, 883], "buggy_code_end_loc": [800, 883], "fixing_code_start_loc": [801, 884], "fixing_code_end_loc": [804, 891], "type": "CWE-400", "message": "libgit2 is a portable C implementation of the Git core methods provided as a linkable library with a solid API, allowing to build Git functionality into your application. Using well-crafted inputs to `git_revparse_single` can cause the function to enter an infinite loop, potentially causing a Denial of Service attack in the calling application. The revparse function in `src/libgit2/revparse.c` uses a loop to parse the user-provided spec string. There is an edge-case during parsing that allows a bad actor to force the loop conditions to access arbitrary memory. Potentially, this could also leak memory if the extracted rev spec is reflected back to the attacker. As such, libgit2 versions before 1.4.0 are not affected. Users should upgrade to version 1.6.5 or 1.7.2.", "other": {"cve": {"id": "CVE-2024-24575", "sourceIdentifier": "security-advisories@github.com", "published": "2024-02-06T22:16:15.057", "lastModified": "2024-02-22T04:15:08.973", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "libgit2 is a portable C implementation of the Git core methods provided as a linkable library with a solid API, allowing to build Git functionality into your application. Using well-crafted inputs to `git_revparse_single` can cause the function to enter an infinite loop, potentially causing a Denial of Service attack in the calling application. The revparse function in `src/libgit2/revparse.c` uses a loop to parse the user-provided spec string. There is an edge-case during parsing that allows a bad actor to force the loop conditions to access arbitrary memory. Potentially, this could also leak memory if the extracted rev spec is reflected back to the attacker. As such, libgit2 versions before 1.4.0 are not affected. Users should upgrade to version 1.6.5 or 1.7.2."}, {"lang": "es", "value": "libgit2 es una implementaci\u00f3n C port\u00e1til de los m\u00e9todos principales de Git proporcionada como una librer\u00eda vinculable con una API s\u00f3lida, que permite incorporar la funcionalidad de Git en su aplicaci\u00f3n. El uso de entradas bien manipuladas para `git_revparse_single` puede hacer que la funci\u00f3n entre en un bucle infinito, lo que podr\u00eda provocar un ataque de denegaci\u00f3n de servicio en la aplicaci\u00f3n que realiza la llamada. La funci\u00f3n revparse en `src/libgit2/revparse.c` usa un bucle para analizar la cadena de especificaciones proporcionada por el usuario. Hay un caso l\u00edmite durante el an\u00e1lisis que permite a un mal actor forzar las condiciones del bucle para acceder a la memoria arbitraria. Potencialmente, esto tambi\u00e9n podr\u00eda perder memoria si la especificaci\u00f3n de rev extra\u00edda se refleja al atacante. Como tal, las versiones de libgit2 anteriores a 1.4.0 no se ven afectadas. Los usuarios deben actualizar a la versi\u00f3n 1.6.5 o 1.7.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libgit2:libgit2:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.4.0", "versionEndExcluding": "1.6.5", "matchCriteriaId": "D0B8863D-BE78-48DD-8B29-20548D8D8EB2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libgit2:libgit2:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.7.0", "versionEndExcluding": "1.7.2", "matchCriteriaId": "E036286C-1FDD-47D7-89BA-5A436B2E72DF"}]}]}], "references": [{"url": "https://github.com/libgit2/libgit2/commit/add2dabb3c16aa49b33904dcdc07cd915efc12fa", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/libgit2/libgit2/releases/tag/v1.6.5", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/libgit2/libgit2/releases/tag/v1.7.2", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/libgit2/libgit2/security/advisories/GHSA-54mf-x2rh-hq9v", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4M3P7WIEPXNRLBINQRJFXUSTNKBCHYC7/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7CNDW3PF6NHO7OXNM5GN6WSSGAMA7MZE/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/S635BGHHZUMRPI7QOXOJ45QHDD5FFZ3S/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/Z6MXOX7I43OWNN7R6M54XLG6U5RXY244/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZGNHOEE2RBLH7KCJUPUNYG4CDTW4HTBT/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/libgit2/libgit2/commit/add2dabb3c16aa49b33904dcdc07cd915efc12fa"}}