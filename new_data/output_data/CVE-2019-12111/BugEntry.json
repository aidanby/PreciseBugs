{"buggy_code": ["/* $Id: pcpserver.c,v 1.47 2018/03/13 10:21:19 nanard Exp $ */\n/* MiniUPnP project\n * Website : http://miniupnp.free.fr/\n * Author : Peter Tatrai\n\nCopyright (c) 2013 by Cisco Systems, Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n    * The name of the author may not be used to endorse or promote products\n      derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* Current assumptions:\n   - IPv4 is always NATted (internal -> external)\n   - IPv6 is always firewalled (this may need some work, NAT6* do exist)\n\n   - we make the judgement based on (in order, picking first one available):\n     - third party address\n     - internal client address\n\n   TODO : handle NAT46, NAT64, NPT66. In addition, beyond FW/NAT\n   choice, should also add for proxy (=as much as possible transparent\n   pass-through to one or more servers).\n\n   TODO: IPv6 permission handling (for the time being, we just assume\n   anyone on IPv6 is a good guy, but fixing that would include\n   upnppermissions rewrite to be AF neutral).\n*/\n\n#include \"config.h\"\n\n#ifdef ENABLE_PCP\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <time.h>\n#include <signal.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <syslog.h>\n\n#include \"pcpserver.h\"\n#include \"natpmp.h\"\n#include \"macros.h\"\n#include \"upnpglobalvars.h\"\n#include \"pcplearndscp.h\"\n#include \"upnpredirect.h\"\n#include \"commonrdr.h\"\n#include \"getifaddr.h\"\n#include \"asyncsendto.h\"\n#include \"upnputils.h\"\n#include \"portinuse.h\"\n#include \"pcp_msg_struct.h\"\n#ifdef ENABLE_UPNPPINHOLE\n#include \"upnppinhole.h\"\n#endif /* ENABLE_UPNPPINHOLE */\n\n\n#ifdef PCP_PEER\n/* TODO make this platform independent */\n#ifdef USE_NETFILTER\n#include \"netfilter/iptcrdr.h\"\n#else\n#error \"PCP Peer is only supported with NETFILTER\"\n#endif /* USE_NETFILTER */\n#endif /* PCP_PEER */\n\n/* server specific information */\nstruct pcp_server_info {\n\tuint8_t server_version;\n};\n\n/* default server settings, highest version supported is the default */\nstatic const struct pcp_server_info this_server_info = {2};\n\n/* structure holding information from PCP msg*/\n/* all variables are in host byte order except IP addresses */\ntypedef struct pcp_info {\n\tuint8_t     version;\n\tuint8_t     opcode;\n\tuint8_t     result_code;\n\tuint32_t    lifetime;             /* lifetime of the mapping */\n\tuint32_t    epochtime;\n\t/* both MAP and PEER opcode specific information */\n\tuint32_t\tnonce[3];\t/* random value generated by client */\n\tuint8_t     protocol;\n\tuint16_t    int_port;\n\tconst struct in6_addr    *int_ip; /* in network order */\n\tuint16_t    ext_port;\n\tconst struct in6_addr    *ext_ip; /* Suggested external IP in network order*/\n\t/* PEER specific information */\n#ifdef PCP_PEER\n\tuint16_t    peer_port;\n\tconst struct in6_addr    *peer_ip; /* Destination IP in network order */\n#endif /* PCP_PEER */\n\n#ifdef PCP_SADSCP\n\t/* SADSCP specific information */\n\tuint8_t delay_tolerance;\n\tuint8_t loss_tolerance;\n\tuint8_t jitter_tolerance;\n\tuint8_t app_name_len;\n\tconst char*   app_name;\n\tuint8_t sadscp_dscp;\n\tuint8_t matched_name;\n\tint8_t is_sadscp_op;\n#endif\n\n#ifdef PCP_FLOWP\n\tuint8_t dscp_up;\n\tuint8_t dscp_down;\n\tint flowp_present;\n#endif\n\tuint8_t is_map_op;\n\tuint8_t is_peer_op;\n\tconst struct in6_addr *thirdp_ip;\n\tconst struct in6_addr *mapped_ip;\n\tchar mapped_str[INET6_ADDRSTRLEN];\n\tint pfailure_present;\n\tstruct in6_addr sender_ip;\n\tint is_fw; /* is this firewall operation? if not, nat. */\n\tchar desc[64];\n} pcp_info_t;\n\n/* getPCPOpCodeStr()\n * return a string representation of the PCP OpCode\n * can be used for debug output */\nstatic const char * getPCPOpCodeStr(uint8_t opcode)\n{\n\tswitch(opcode) {\n\tcase PCP_OPCODE_ANNOUNCE:\n\t\treturn \"ANNOUNCE\";\n\tcase PCP_OPCODE_MAP:\n\t\treturn \"MAP\";\n\tcase PCP_OPCODE_PEER:\n\t\treturn \"PEER\";\n#ifdef  PCP_SADSCP\n\tcase PCP_OPCODE_SADSCP:\n\t\treturn \"SADSCP\";\n#endif\t/* PCP_SADSCP */\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\n/* useful to copy ext_ip only if needed, as request and response\n * buffers are same */\nstatic void copyIPv6IfDifferent(void * dest, const void * src)\n{\n\tif(dest != src) {\n\t\tmemcpy(dest, src, sizeof(struct in6_addr));\n\t}\n}\n\n#ifdef PCP_SADSCP\nint get_dscp_value(pcp_info_t *pcp_msg_info) {\n\n\tunsigned int ind;\n\n\tfor (ind = 0; ind < num_dscp_values; ind++) {\n\n\t\tif ((dscp_values_list[ind].app_name) &&\n\t\t    (!strcmp(dscp_values_list[ind].app_name,\n\t\t\t     pcp_msg_info->app_name)) &&\n\t\t    (pcp_msg_info->delay_tolerance == dscp_values_list[ind].delay) &&\n\t\t    (pcp_msg_info->loss_tolerance == dscp_values_list[ind].loss) &&\n\t\t    (pcp_msg_info->jitter_tolerance == dscp_values_list[ind].jitter)\n\t\t   )\n\t\t{\n\t\t\tpcp_msg_info->sadscp_dscp = dscp_values_list[ind].dscp_value;\n\t\t\tpcp_msg_info->matched_name = 1;\n\t\t\treturn 0;\n\t\t} else\n\t\t  if ((pcp_msg_info->app_name_len==0) &&\n\t\t      (dscp_values_list[ind].app_name_len==0) &&\n\t\t      (pcp_msg_info->delay_tolerance == dscp_values_list[ind].delay) &&\n\t\t      (pcp_msg_info->loss_tolerance == dscp_values_list[ind].loss) &&\n\t\t      (pcp_msg_info->jitter_tolerance == dscp_values_list[ind].jitter)\n\t\t     )\n\t\t{\n\t\t\tpcp_msg_info->sadscp_dscp = dscp_values_list[ind].dscp_value;\n\t\t\tpcp_msg_info->matched_name = 0;\n\t\t\treturn 0;\n\t\t} else\n\t\t  if ((dscp_values_list[ind].app_name_len==0) &&\n\t\t      (pcp_msg_info->delay_tolerance == dscp_values_list[ind].delay) &&\n\t\t      (pcp_msg_info->loss_tolerance == dscp_values_list[ind].loss) &&\n\t\t      (pcp_msg_info->jitter_tolerance == dscp_values_list[ind].jitter)\n\t\t     )\n\t\t{\n\t\t\tpcp_msg_info->sadscp_dscp = dscp_values_list[ind].dscp_value;\n\t\t\tpcp_msg_info->matched_name = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t//if nothing matched return Default value i.e. 0\n\tpcp_msg_info->sadscp_dscp = 0;\n\tpcp_msg_info->matched_name = 0;\n\treturn 0;\n}\n#endif\n/*\n * Function extracting information from common_req (common request header)\n * into pcp_msg_info.\n * @return : when no problem occurred 0 is returned, 1 otherwise and appropriate\n *          result code is assigned to pcp_msg_info->result_code to indicate\n *          what kind of error occurred\n */\nstatic int parseCommonRequestHeader(const uint8_t *common_req, pcp_info_t *pcp_msg_info)\n{\n\tpcp_msg_info->version = common_req[0] ;\n\tpcp_msg_info->opcode = common_req[1] & 0x7f;\n\tpcp_msg_info->lifetime = READNU32(common_req + 4);\n\tpcp_msg_info->int_ip = (struct in6_addr *)(common_req + 8);\n\tpcp_msg_info->mapped_ip = (struct in6_addr *)(common_req + 8);\n\n\n\tif ( (pcp_msg_info->version > this_server_info.server_version) ) {\n\t\tpcp_msg_info->result_code = PCP_ERR_UNSUPP_VERSION;\n\t\treturn 1;\n\t}\n\n\tif (pcp_msg_info->lifetime > max_lifetime ) {\n\t\tpcp_msg_info->lifetime = max_lifetime;\n\t}\n\n\tif ( (pcp_msg_info->lifetime < min_lifetime) && (pcp_msg_info->lifetime != 0) ) {\n\t\tpcp_msg_info->lifetime = min_lifetime;\n\t}\n\n\treturn 0;\n}\n\n#ifdef DEBUG\nstatic void printMAPOpcodeVersion1(const uint8_t *buf)\n{\n\tchar map_addr[INET6_ADDRSTRLEN];\n\tsyslog(LOG_DEBUG, \"PCP MAP: v1 Opcode specific information. \\n\");\n\tsyslog(LOG_DEBUG, \"MAP protocol: \\t\\t %d\\n\", (int)buf[0] );\n\tsyslog(LOG_DEBUG, \"MAP int port: \\t\\t %d\\n\", (int)READNU16(buf+4));\n\tsyslog(LOG_DEBUG, \"MAP ext port: \\t\\t %d\\n\", (int)READNU16(buf+6));\n\tsyslog(LOG_DEBUG, \"MAP Ext IP: \\t\\t %s\\n\", inet_ntop(AF_INET6,\n\t       buf+8, map_addr, INET6_ADDRSTRLEN));\n}\n\nstatic void printMAPOpcodeVersion2(const uint8_t *buf)\n{\n\tchar map_addr[INET6_ADDRSTRLEN];\n\tsyslog(LOG_DEBUG, \"PCP MAP: v2 Opcode specific information.\");\n\tsyslog(LOG_DEBUG, \"MAP nonce:   \\t%08x%08x%08x\",\n\t       READNU32(buf), READNU32(buf+4), READNU32(buf+8));\n\tsyslog(LOG_DEBUG, \"MAP protocol:\\t%d\", (int)buf[12]);\n\tsyslog(LOG_DEBUG, \"MAP int port:\\t%d\", (int)READNU16(buf+16));\n\tsyslog(LOG_DEBUG, \"MAP ext port:\\t%d\", (int)READNU16(buf+18));\n\tsyslog(LOG_DEBUG, \"MAP Ext IP:  \\t%s\", inet_ntop(AF_INET6,\n\t       buf+20, map_addr, INET6_ADDRSTRLEN));\n}\n#endif /* DEBUG */\n\nstatic void parsePCPMAP_version1(const uint8_t *map_v1,\n\t\tpcp_info_t *pcp_msg_info)\n{\n\tpcp_msg_info->is_map_op = 1;\n\tpcp_msg_info->protocol = map_v1[0];\n\tpcp_msg_info->int_port = READNU16(map_v1 + 4);\n\tpcp_msg_info->ext_port = READNU16(map_v1 + 6);\n\n\tpcp_msg_info->ext_ip = (struct in6_addr *)(map_v1 + 8);\n}\n\nstatic void parsePCPMAP_version2(const uint8_t *map_v2,\n\t\tpcp_info_t *pcp_msg_info)\n{\n\tpcp_msg_info->is_map_op = 1;\n\tmemcpy(pcp_msg_info->nonce, map_v2, 12);\n\tpcp_msg_info->protocol = map_v2[12];\n\tpcp_msg_info->int_port = READNU16(map_v2 + 16);\n\tpcp_msg_info->ext_port = READNU16(map_v2 + 18);\n\n\tpcp_msg_info->ext_ip = (struct in6_addr *)(map_v2 + 20);\n}\n\n#ifdef PCP_PEER\n#ifdef DEBUG\nstatic void printPEEROpcodeVersion1(const uint8_t *buf)\n{\n\tchar ext_addr[INET6_ADDRSTRLEN];\n\tchar peer_addr[INET6_ADDRSTRLEN];\n\tsyslog(LOG_DEBUG, \"PCP PEER: v1 Opcode specific information. \\n\");\n\tsyslog(LOG_DEBUG, \"Protocol: \\t\\t %d\\n\", (int)buf[0]);\n\tsyslog(LOG_DEBUG, \"Internal port: \\t\\t %d\\n\", READNU16(buf + 4));\n\tsyslog(LOG_DEBUG, \"External IP: \\t\\t %s\\n\", inet_ntop(AF_INET6, buf + 8,\n\t       ext_addr,INET6_ADDRSTRLEN));\n\tsyslog(LOG_DEBUG, \"External port port: \\t\\t %d\\n\", READNU16(buf + 6));\n\tsyslog(LOG_DEBUG, \"PEER IP: \\t\\t %s\\n\", inet_ntop(AF_INET6, buf + 28,\n\t       peer_addr,INET6_ADDRSTRLEN));\n\tsyslog(LOG_DEBUG, \"PEER port port: \\t\\t %d\\n\", READNU16(buf + 24));\n}\n\nstatic void printPEEROpcodeVersion2(const uint8_t *buf)\n{\n\tchar ext_addr[INET6_ADDRSTRLEN];\n\tchar peer_addr[INET6_ADDRSTRLEN];\n\n\tsyslog(LOG_DEBUG, \"PCP PEER: v2 Opcode specific information.\");\n\tsyslog(LOG_DEBUG, \"nonce:        \\t%08x%08x%08x\",\n\t       READNU32(buf), READNU32(buf+4), READNU32(buf+8));\n\tsyslog(LOG_DEBUG, \"Protocol:     \\t%d\", buf[12]);\n\tsyslog(LOG_DEBUG, \"Internal port:\\t%d\", READNU16(buf + 16));\n\tsyslog(LOG_DEBUG, \"External IP:  \\t%s\", inet_ntop(AF_INET6, buf + 20,\n\t       ext_addr, INET6_ADDRSTRLEN));\n\tsyslog(LOG_DEBUG, \"External port:\\t%d\", READNU16(buf + 18));\n\tsyslog(LOG_DEBUG, \"PEER IP:      \\t%s\", inet_ntop(AF_INET6, buf + 40,\n\t       peer_addr, INET6_ADDRSTRLEN));\n\tsyslog(LOG_DEBUG, \"PEER port:    \\t%d\", READNU16(buf + 36));\n}\n#endif /* DEBUG */\n\n/*\n * Function extracting information from peer_buf to pcp_msg_info\n * @return : when no problem occurred 0 is returned, 1 otherwise\n */\nstatic void parsePCPPEER_version1(const uint8_t *buf,\n\t\tpcp_info_t *pcp_msg_info)\n{\n\tpcp_msg_info->is_peer_op = 1;\n\tpcp_msg_info->protocol = buf[0];\n\tpcp_msg_info->int_port = READNU16(buf + 4);\n\tpcp_msg_info->ext_port = READNU16(buf + 6);\n\tpcp_msg_info->peer_port = READNU16(buf + 24);\n\n\tpcp_msg_info->ext_ip = (struct in6_addr *)(buf + 8);\n\tpcp_msg_info->peer_ip = (struct in6_addr *)(buf + 28);\n}\n\n/*\n * Function extracting information from peer_buf to pcp_msg_info\n * @return : when no problem occurred 0 is returned, 1 otherwise\n */\nstatic void parsePCPPEER_version2(const uint8_t *buf, pcp_info_t *pcp_msg_info)\n{\n\tpcp_msg_info->is_peer_op = 1;\n\tmemcpy(pcp_msg_info->nonce, buf, 12);\n\tpcp_msg_info->protocol = buf[12];\n\tpcp_msg_info->int_port = READNU16(buf + 16);\n\tpcp_msg_info->ext_port = READNU16(buf + 18);\n\tpcp_msg_info->peer_port = READNU16(buf + 36);\n\n\tpcp_msg_info->ext_ip = (struct in6_addr *)(buf + 20);\n\tpcp_msg_info->peer_ip = (struct in6_addr *)(buf + 40);\n}\n#endif /* PCP_PEER */\n\n#ifdef PCP_SADSCP\n#ifdef DEBUG\nstatic void printSADSCPOpcode(const uint8_t *buf)\n{\n\tunsigned char sadscp_tol;\n\tsadscp_tol = buf[12];\t/* tolerance_fields */\n\n\tsyslog(LOG_DEBUG, \"PCP SADSCP: Opcode specific information.\\n\");\n\tsyslog(LOG_DEBUG, \"Delay tolerance %d \\n\", (sadscp_tol>>6)&3);\n\tsyslog(LOG_DEBUG, \"Loss tolerance %d \\n\",  (sadscp_tol>>4)&3);\n\tsyslog(LOG_DEBUG, \"Jitter tolerance %d \\n\",  (sadscp_tol>>2)&3);\n\tsyslog(LOG_DEBUG, \"RRR %d \\n\", sadscp_tol&3);\n\tsyslog(LOG_DEBUG, \"AppName Length %d \\n\", buf[13]);\n\tsyslog(LOG_DEBUG, \"Application name %.*s \\n\", buf[13], buf + 14);\n}\n#endif //DEBUG\n\nstatic int parseSADSCP(const uint8_t *buf, pcp_info_t *pcp_msg_info)\n{\n\tpcp_msg_info->delay_tolerance = (buf[12]>>6)&3;\n\tpcp_msg_info->loss_tolerance = (buf[12]>>4)&3;\n\tpcp_msg_info->jitter_tolerance = (buf[12]>>2)&3;\n\n\tif (pcp_msg_info->delay_tolerance == 3 ||\n\t    pcp_msg_info->loss_tolerance == 3 ||\n\t    pcp_msg_info->jitter_tolerance == 3 ) {\n\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\treturn 1;\n\t}\n\n\tpcp_msg_info->app_name = (const char *)(buf + 14);\n\tpcp_msg_info->app_name_len = buf[13];\n\n\treturn 0;\n}\n#endif\t/* PCP_SADSCP */\n\n\nstatic int parsePCPOption(uint8_t* pcp_buf, int remain, pcp_info_t *pcp_msg_info)\n{\n#ifdef DEBUG\n\tchar third_addr[INET6_ADDRSTRLEN];\n#endif /* DEBUG */\n\tunsigned short option_length;\n\n\t/* Do centralized option sanity checks here. */\n\n\tif (remain < (int)PCP_OPTION_HDR_SIZE) {\n\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\treturn 0;\n\t}\n\n\toption_length = READNU16(pcp_buf + 2) + 4;\t/* len */\n\n\tif (remain < option_length) {\n\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\treturn 0;\n\t}\n\n\tswitch (pcp_buf[0]) { /* code */\n\n\tcase PCP_OPTION_3RD_PARTY:\n\n\t\tif (option_length != PCP_3RD_PARTY_OPTION_SIZE) {\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\t\treturn 0;\n\t\t}\n#ifdef DEBUG\n\t\tsyslog(LOG_DEBUG, \"PCP OPTION: \\t Third party\\n\");\n\t\tsyslog(LOG_DEBUG, \"Third PARTY IP: \\t %s\\n\", inet_ntop(AF_INET6,\n\t\t       pcp_buf + 4, third_addr, INET6_ADDRSTRLEN));\n#endif\n\t\tif (pcp_msg_info->thirdp_ip ) {\n\t\t\tsyslog(LOG_ERR, \"PCP: THIRD PARTY OPTION was already present. \\n\");\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpcp_msg_info->thirdp_ip = (struct in6_addr *)(pcp_buf + 4);\n\t\t\tpcp_msg_info->mapped_ip = (struct in6_addr *)(pcp_buf + 4);\n\t\t}\n\t\tbreak;\n\n\tcase PCP_OPTION_PREF_FAIL:\n\n\t\tif (option_length != PCP_PREFER_FAIL_OPTION_SIZE) {\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\t\treturn 0;\n\t\t}\n#ifdef DEBUG\n\t\tsyslog(LOG_DEBUG, \"PCP OPTION: \\t Prefer failure \\n\");\n#endif\n\t\tif (pcp_msg_info->opcode != PCP_OPCODE_MAP) {\n\t\t\tsyslog(LOG_DEBUG, \"PCP: Unsupported OPTION for given OPCODE.\\n\");\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t}\n\t\tif (pcp_msg_info->pfailure_present != 0 ) {\n\t\t\tsyslog(LOG_DEBUG, \"PCP: PREFER FAILURE OPTION was already present.\\n\");\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\t} else {\n\t\t\tpcp_msg_info->pfailure_present = 1;\n\t\t}\n\t\tbreak;\n\n\tcase PCP_OPTION_FILTER:\n\t\t/* TODO fully implement filter */\n\t\tif (option_length != PCP_FILTER_OPTION_SIZE) {\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\t\treturn 0;\n\t\t}\n#ifdef DEBUG\n\t\tsyslog(LOG_DEBUG, \"PCP OPTION: \\t Filter\\n\");\n#endif\n\t\tif (pcp_msg_info->opcode != PCP_OPCODE_MAP) {\n\t\t\tsyslog(LOG_ERR, \"PCP: Unsupported OPTION for given OPCODE.\\n\");\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n#ifdef PCP_FLOWP\n\tcase PCP_OPTION_FLOW_PRIORITY:\n\n#ifdef DEBUG\n\t\tsyslog(LOG_DEBUG, \"PCP OPTION: \\t Flow priority\\n\");\n#endif\n\t\tif (option_length != PCP_FLOW_PRIORITY_OPTION_SIZE) {\n\t\t\tsyslog(LOG_ERR, \"PCP: Error processing DSCP. sizeof %d and remaining %d. flow len %d \\n\",\n\t\t\t       PCP_FLOW_PRIORITY_OPTION_SIZE, remain, READNU16(pcp_buf + 2));\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\t\treturn 0;\n\t\t}\n\n#ifdef DEBUG\n\t\tsyslog(LOG_DEBUG, \"DSCP UP: \\t %d\\n\", pcp_buf[4]);\n\t\tsyslog(LOG_DEBUG, \"DSCP DOWN: \\t %d\\n\", pcp_buf[5]);\n#endif\n\t\tpcp_msg_info->dscp_up = pcp_buf[4];\n\t\tpcp_msg_info->dscp_down = pcp_buf[5];\n\t\tpcp_msg_info->flowp_present = 1;\n\n\t\tbreak;\n#endif\n\tdefault:\n\t\tif (pcp_buf[0] < 128) {\n\t\t\tsyslog(LOG_ERR, \"PCP: Unrecognized mandatory PCP OPTION: %d \\n\", (int)pcp_buf[0]);\n\t\t\t/* Mandatory to understand */\n\t\t\tpcp_msg_info->result_code = PCP_ERR_UNSUPP_OPTION;\n\t\t\tremain = 0;\n\t\t\tbreak;\n\t\t}\n\t\t/* TODO - log optional not understood options? */\n\t\tbreak;\n\t}\n\treturn option_length;\n}\n\n\nstatic void parsePCPOptions(void* pcp_buf, int remain, pcp_info_t *pcp_msg_info)\n{\n\tint option_length;\n\n\twhile (remain > 0) {\n\t\toption_length = parsePCPOption(pcp_buf, remain, pcp_msg_info);\n\t\tif (!option_length)\n\t\t\tbreak;\n\t\tremain -= option_length;\n\t\tpcp_buf += option_length;\n\t}\n\tif (remain > 0) {\n\t\tsyslog(LOG_WARNING, \"%s: remain=%d\", \"parsePCPOptions\", remain);\n\t}\n}\n\n\n/* CheckExternalAddress()\n * Check that suggested external address in request match a real external\n * IP address.\n * Suggested address can also be 0 IPv4 or IPv6 address.\n *  (see http://tools.ietf.org/html/rfc6887#section-10 )\n * return values :\n *   0 : check is OK\n *  -1 : check failed */\nstatic int CheckExternalAddress(pcp_info_t* pcp_msg_info)\n{\n\t/* can contain a IPv4-mapped IPv6 address */\n\tstatic struct in6_addr external_addr;\n\tint af;\n\n\taf = IN6_IS_ADDR_V4MAPPED(pcp_msg_info->mapped_ip)\n\t\t? AF_INET : AF_INET6;\n\n\tpcp_msg_info->is_fw = af == AF_INET6;\n\n\tif (pcp_msg_info->is_fw) {\n\t\texternal_addr = *pcp_msg_info->mapped_ip;\n\t} else {\n\t\t/* TODO : be able to handle case with multiple\n\t\t * external addresses */\n\t\tif(use_ext_ip_addr) {\n\t\t\tif (inet_pton(AF_INET, use_ext_ip_addr,\n\t\t\t\t      ((uint32_t*)external_addr.s6_addr)+3) == 1) {\n\t\t\t\t((uint32_t*)external_addr.s6_addr)[0] = 0;\n\t\t\t\t((uint32_t*)external_addr.s6_addr)[1] = 0;\n\t\t\t\t((uint32_t*)external_addr.s6_addr)[2] = htonl(0xFFFF);\n\t\t\t} else if (inet_pton(AF_INET6, use_ext_ip_addr, external_addr.s6_addr)\n\t\t\t\t   != 1) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_NETWORK_FAILURE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tif(!ext_if_name || ext_if_name[0]=='\\0') {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_NETWORK_FAILURE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(getifaddr_in6(ext_if_name, af, &external_addr) < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_NETWORK_FAILURE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (pcp_msg_info->ext_ip == NULL ||\n\t    IN6_IS_ADDR_UNSPECIFIED(pcp_msg_info->ext_ip) ||\n\t    (IN6_IS_ADDR_V4MAPPED(pcp_msg_info->ext_ip)\n\t      && ((uint32_t *)pcp_msg_info->ext_ip->s6_addr)[3] == INADDR_ANY)) {\n\t\t/* no suggested external address : use real external address */\n\t\tpcp_msg_info->ext_ip = &external_addr;\n\t\treturn 0;\n\t}\n\n\tif (!IN6_ARE_ADDR_EQUAL(pcp_msg_info->ext_ip, &external_addr)) {\n\t\tsyslog(LOG_ERR,\n\t\t       \"PCP: External IP in request didn't match interface IP \\n\");\n#ifdef DEBUG\n\t\t{\n\t\t\tchar s[INET6_ADDRSTRLEN];\n\t\t\tsyslog(LOG_DEBUG, \"Interface IP %s \\n\",\n\t\t\t       inet_ntop(AF_INET6, &external_addr.s6_addr, s, sizeof(s)));\n\t\t\tsyslog(LOG_DEBUG, \"IP in the PCP request %s \\n\",\n\t\t\t       inet_ntop(AF_INET6, pcp_msg_info->ext_ip, s, sizeof(s)));\n\t\t}\n#endif\n\n\t\tif (pcp_msg_info->pfailure_present) {\n\t\t\tpcp_msg_info->result_code = PCP_ERR_CANNOT_PROVIDE_EXTERNAL;\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tpcp_msg_info->ext_ip = &external_addr;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\n\nstatic const char* inet_n46top(const struct in6_addr* in,\n\t\t\t       char* buf, size_t buf_len)\n{\n\tif (IN6_IS_ADDR_V4MAPPED(in)) {\n\t\treturn inet_ntop(AF_INET, ((uint32_t*)(in->s6_addr))+3, buf, buf_len);\n\t} else {\n\t\treturn inet_ntop(AF_INET6, in, buf, buf_len);\n\t}\n}\n\n#ifdef PCP_PEER\nstatic void FillSA(struct sockaddr *sa, const struct in6_addr *in6,\n\t\tuint16_t port)\n{\n\tif (IN6_IS_ADDR_V4MAPPED(in6)) {\n\t\tstruct sockaddr_in *sa4 = (struct sockaddr_in *)sa;\n\t\tsa4->sin_family = AF_INET;\n\t\tsa4->sin_addr.s_addr = ((uint32_t*)(in6)->s6_addr)[3];\n\t\tsa4->sin_port = htons(port);\n\t} else {\n\t\tstruct sockaddr_in6 *sa6 = (struct sockaddr_in6 *)sa;\n\t\tsa6->sin6_family = AF_INET6;\n\t\tsa6->sin6_addr = *in6;\n\t\tsa6->sin6_port = htons(port);\n\t}\n}\n\nstatic const char* inet_satop(struct sockaddr* sa, char* buf, size_t buf_len)\n{\n\tif (sa->sa_family == AF_INET) {\n\t\treturn inet_ntop(AF_INET, &(((struct sockaddr_in*)sa)->sin_addr), buf, buf_len);\n\t} else {\n\t\treturn inet_ntop(AF_INET6, &(((struct sockaddr_in6*)sa)->sin6_addr), buf, buf_len);\n\t}\n}\n\nstatic int CreatePCPPeer_NAT(pcp_info_t *pcp_msg_info)\n{\n\tstruct sockaddr_storage intip;\n\tstruct sockaddr_storage peerip;\n\tstruct sockaddr_storage extip;\n\tstruct sockaddr_storage ret_extip;\n\n\tuint8_t  proto = pcp_msg_info->protocol;\n\n\tuint16_t eport = pcp_msg_info->ext_port;  /* public port */\n\n\tchar peerip_s[INET6_ADDRSTRLEN], extip_s[INET6_ADDRSTRLEN];\n\ttime_t timestamp = upnp_time() + pcp_msg_info->lifetime;\n\tint r;\n\n\tFillSA((struct sockaddr*)&intip, pcp_msg_info->mapped_ip,\n\t       pcp_msg_info->int_port);\n\tFillSA((struct sockaddr*)&peerip, pcp_msg_info->peer_ip,\n\t       pcp_msg_info->peer_port);\n\tFillSA((struct sockaddr*)&extip, pcp_msg_info->ext_ip,\n\t       eport);\n\n\tinet_satop((struct sockaddr*)&peerip, peerip_s, sizeof(peerip_s));\n\tinet_satop((struct sockaddr*)&extip, extip_s, sizeof(extip_s));\n\n\t/* check if connection with given peer exists, if it was */\n\t/* already established use this external port */\n\tif (get_nat_ext_addr( (struct sockaddr*)&intip, (struct sockaddr*)&peerip,\n\t\t\t      proto, (struct sockaddr*)&ret_extip) == 1) {\n\t\tif (ret_extip.ss_family == AF_INET) {\n\t\t\tstruct sockaddr_in* ret_ext4 = (struct sockaddr_in*)&ret_extip;\n\t\t\tuint16_t ret_eport = ntohs(ret_ext4->sin_port);\n\t\t\teport = ret_eport;\n\t\t} else if (ret_extip.ss_family == AF_INET6) {\n\t\t\tstruct sockaddr_in6* ret_ext6 = (struct sockaddr_in6*)&ret_extip;\n\t\t\tuint16_t ret_eport = ntohs(ret_ext6->sin6_port);\n\t\t\teport = ret_eport;\n\t\t} else {\n\t\t\treturn PCP_ERR_CANNOT_PROVIDE_EXTERNAL;\n\t\t}\n\t}\n\t/* Create Peer Mapping */\n\tif (eport == 0) {\n\t\teport = pcp_msg_info->int_port;\n\t}\n\n#ifdef PCP_FLOWP\n\tif (pcp_msg_info->flowp_present && pcp_msg_info->dscp_up) {\n\t\tif (add_peer_dscp_rule2(ext_if_name, peerip_s,\n\t\t\t\t\tpcp_msg_info->peer_port, pcp_msg_info->dscp_up,\n\t\t\t\t\tpcp_msg_info->mapped_str, pcp_msg_info->int_port,\n\t\t\t\t\tproto, pcp_msg_info->desc, timestamp) < 0 ) {\n\t\t\tsyslog(LOG_ERR, \"PCP: failed to add flowp upstream mapping %s:%hu->%s:%hu '%s'\",\n\t\t\t       pcp_msg_info->mapped_str,\n\t\t\t       pcp_msg_info->int_port,\n\t\t\t       peerip_s,\n\t\t\t       pcp_msg_info->peer_port,\n\t\t\t       pcp_msg_info->desc);\n\t\t\treturn PCP_ERR_NO_RESOURCES;\n\t\t}\n\t}\n\n\tif (pcp_msg_info->flowp_present && pcp_msg_info->dscp_down) {\n\t\tif (add_peer_dscp_rule2(ext_if_name,  pcp_msg_info->mapped_str,\n\t\t\t\t\tpcp_msg_info->int_port, pcp_msg_info->dscp_down,\n\t\t\t\t\tpeerip_s, pcp_msg_info->peer_port, proto, pcp_msg_info->desc, timestamp)\n\t\t    < 0 ) {\n\t\t\tsyslog(LOG_ERR, \"PCP: failed to add flowp downstream mapping %s:%hu->%s:%hu '%s'\",\n\t\t\t       pcp_msg_info->mapped_str,\n\t\t\t       pcp_msg_info->int_port,\n\t\t\t       peerip_s,\n\t\t\t       pcp_msg_info->peer_port,\n\t\t\t       pcp_msg_info->desc);\n\t\t\tpcp_msg_info->result_code = PCP_ERR_NO_RESOURCES;\n\t\t\treturn PCP_ERR_NO_RESOURCES;\n\t\t}\n\t}\n#endif\n\n\tr = add_peer_redirect_rule2(ext_if_name,\n\t\t\t\t    peerip_s,\n\t\t\t\t    pcp_msg_info->peer_port,\n\t\t\t\t    extip_s,\n\t\t\t\t    eport,\n\t\t\t\t    pcp_msg_info->mapped_str,\n\t\t\t\t    pcp_msg_info->int_port,\n\t\t\t\t    pcp_msg_info->protocol,\n\t\t\t\t    pcp_msg_info->desc,\n\t\t\t\t    timestamp);\n\tif (r < 0)\n\t\treturn PCP_ERR_NO_RESOURCES;\n\tpcp_msg_info->ext_port = eport;\n\treturn PCP_SUCCESS;\n}\n\nstatic void CreatePCPPeer(pcp_info_t *pcp_msg_info)\n{\n\tchar peerip_s[INET6_ADDRSTRLEN];\n\tint r = -1;\n\n\tif (!inet_n46top(pcp_msg_info->peer_ip, peerip_s, sizeof(peerip_s))) {\n\t\tsyslog(LOG_ERR, \"inet_n46top(peer_ip): %m\");\n\t\treturn;\n\t}\n\n\tif (pcp_msg_info->is_fw) {\n#if 0\n\t\t/* Someday, something like this is available.. and we're ready! */\n#ifdef ENABLE_UPNPPINHOLE\n\t\tpcp_msg_info->ext_port = pcp_msg_info->int_port;\n\t\tr = upnp_add_outbound_pinhole(peerip_s,\n\t\t\t\t\t      pcp_msg_info->peer_port,\n\t\t\t\t\t      pcp_msg_info->mapped_str,\n\t\t\t\t\t      pcp_msg_info->int_port,\n\t\t\t\t\t      pcp_msg_info->protocol,\n\t\t\t\t\t      pcp_msg_info->desc,\n\t\t\t\t\t      pcp_msg_info->lifetime, NULL);\n#endif /* ENABLE_UPNPPINHOLE */\n#else\n\t\tr = PCP_ERR_UNSUPP_OPCODE;\n#endif /* 0 */\n\t} else {\n\t\tr = CreatePCPPeer_NAT(pcp_msg_info);\n\t}\n\t/* TODO: add upnp function for PI */\n\tpcp_msg_info->result_code = r;\n\tsyslog(r == PCP_SUCCESS ? LOG_INFO : LOG_ERR,\n\t       \"PCP PEER: %s peer mapping %s %s:%hu(%hu)->%s:%hu '%s'\",\n\t       r == PCP_SUCCESS ? \"added\" : \"failed to add\",\n\t       (pcp_msg_info->protocol==IPPROTO_TCP)?\"TCP\":\"UDP\",\n\t       pcp_msg_info->mapped_str,\n\t       pcp_msg_info->int_port,\n\t       pcp_msg_info->ext_port,\n\t       peerip_s,\n\t       pcp_msg_info->peer_port,\n\t       pcp_msg_info->desc);\n}\n\nstatic void DeletePCPPeer(pcp_info_t *pcp_msg_info)\n{\n\tuint16_t iport = pcp_msg_info->int_port;  /* private port */\n\tuint16_t rport = pcp_msg_info->peer_port;  /* private port */\n\tuint8_t  proto = pcp_msg_info->protocol;\n\tchar rhost[INET6_ADDRSTRLEN];\n\tint r = -1;\n\n\t/* remove requested mappings for this client */\n\tint index = 0;\n\tunsigned short eport2, iport2, rport2;\n\tchar iaddr2[INET6_ADDRSTRLEN], rhost2[INET6_ADDRSTRLEN];\n\tint proto2;\n\tchar desc[64];\n\tunsigned int timestamp;\n#if 0\n\tint uid;\n#endif /* 0 */\n\n\tif (pcp_msg_info->is_fw) {\n\t\tpcp_msg_info->result_code = PCP_ERR_UNSUPP_OPCODE;\n\t\treturn;\n\t}\n\n\tinet_n46top((struct in6_addr*)pcp_msg_info->peer_ip, rhost, sizeof(rhost));\n\n\tfor (index = 0 ;\n\t     (!pcp_msg_info->is_fw &&\n\t      get_peer_rule_by_index(index, 0,\n\t\t\t\t     &eport2, iaddr2, sizeof(iaddr2),\n\t\t\t\t     &iport2, &proto2,\n\t\t\t\t     desc, sizeof(desc),\n\t\t\t\t     rhost2, sizeof(rhost2), &rport2,\n\t\t\t\t     &timestamp, 0, 0) >= 0)\n#if 0\n\t\t     /* Some day if outbound pinholes are supported.. */\n\t\t     ||\n\t\t     (pcp_msg_info->is_fw &&\n\t\t      (uid=upnp_get_pinhole_uid_by_index(index))>=0 &&\n\t\t      upnp_get_pinhole_info((unsigned short)uid,\n\t\t\t\t\t    rhost2, sizeof(rhost2), &rport2,\n\t\t\t\t\t    iaddr2, sizeof(iaddr2), &iport2,\n\t\t\t\t\t    &proto2, desc, sizeof(desc),\n\t\t\t\t\t    &timestamp, NULL) >= 0)\n#endif /* 0 */\n\t\t     ;\n\t     index++)\n\t\tif((0 == strcmp(iaddr2, pcp_msg_info->mapped_str))\n\t\t   && (0 == strcmp(rhost2, rhost))\n\t\t   && (proto2==proto)\n\t\t   && 0 == strcmp(desc, pcp_msg_info->desc)\n\t\t   && (iport2==iport) && (rport2==rport)) {\n\t\t\tif (!pcp_msg_info->is_fw)\n\t\t\t\tr = _upnp_delete_redir(eport2, proto2);\n#if 0\n\t\t\telse\n\t\t\t\tr = upnp_delete_outboundpinhole(uid);\n#endif /* 0 */\n\t\t\tif(r<0) {\n\t\t\t\tsyslog(LOG_ERR, \"PCP PEER: failed to remove peer mapping\");\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_INFO, \"PCP PEER: %s port %hu peer mapping removed\",\n\t\t\t\t       proto2==IPPROTO_TCP?\"TCP\":\"UDP\", eport2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\tif (r==-1) {\n\t\tsyslog(LOG_ERR, \"PCP PEER: Failed to find PCP mapping internal port %hu, protocol %s\",\n\t\t       iport, (pcp_msg_info->protocol == IPPROTO_TCP)?\"TCP\":\"UDP\");\n\t\tpcp_msg_info->result_code = PCP_ERR_NO_RESOURCES;\n\t}\n}\n#endif /* PCP_PEER */\n\nstatic int CreatePCPMap_NAT(pcp_info_t *pcp_msg_info)\n{\n\tint r = 0;\n\tchar iaddr_old[INET6_ADDRSTRLEN];\n\tuint16_t iport_old, eport_first = 0;\n\tint any_eport_allowed = 0;\n\tunsigned int timestamp = upnp_time() + pcp_msg_info->lifetime;\n\n\tif (pcp_msg_info->ext_port == 0) {\n\t\tpcp_msg_info->ext_port = pcp_msg_info->int_port;\n\t}\n\n\t/* TODO: Support non-TCP/UDP */\n\tif (pcp_msg_info->ext_port == 0) {\n\t\treturn PCP_ERR_MALFORMED_REQUEST;\n\t}\n\n\tdo {\n\t\tif (eport_first == 0) { /* first time in loop */\n\t\t\teport_first = pcp_msg_info->ext_port;\n\t\t} else if (pcp_msg_info->ext_port == eport_first) { /* no eport available */\n                        /* all eports rejected by permissions? */\n\t\t\tif (any_eport_allowed == 0)\n\t\t\t\treturn PCP_ERR_NOT_AUTHORIZED;\n\t\t\t/* at least one eport allowed (but none available) */\n\t\t\treturn PCP_ERR_NO_RESOURCES;\n\t\t}\n\t\tif ((IN6_IS_ADDR_V4MAPPED(pcp_msg_info->mapped_ip) &&\n\t\t     (!check_upnp_rule_against_permissions(upnppermlist,\n\t\t\t\t\t\t\t   num_upnpperm, pcp_msg_info->ext_port,\n\t\t\t\t\t\t\t   ((struct in_addr*)pcp_msg_info->mapped_ip->s6_addr)[3],\n\t\t\t\t\t\t\t   pcp_msg_info->int_port)))) {\n\t\t\tif (pcp_msg_info->pfailure_present) {\n\t\t\t\treturn PCP_ERR_CANNOT_PROVIDE_EXTERNAL;\n\t\t\t}\n\t\t\tpcp_msg_info->ext_port++;\n\t\t\tif (pcp_msg_info->ext_port == 0) { /* skip port zero */\n\t\t\t\tpcp_msg_info->ext_port++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tany_eport_allowed = 1;\n#ifdef CHECK_PORTINUSE\n\t\tif (port_in_use(ext_if_name, pcp_msg_info->ext_port, pcp_msg_info->protocol,\n\t\t\t\tpcp_msg_info->mapped_str, pcp_msg_info->int_port) > 0) {\n\t\t\tsyslog(LOG_INFO, \"port %hu protocol %s already in use\",\n\t\t\t       pcp_msg_info->ext_port,\n\t\t\t       (pcp_msg_info->protocol==IPPROTO_TCP)?\"tcp\":\"udp\");\n\t\t\tpcp_msg_info->ext_port++;\n\t\t\tif (pcp_msg_info->ext_port == 0) { /* skip port zero */\n\t\t\t\tpcp_msg_info->ext_port++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tr = get_redirect_rule(ext_if_name,\n\t\t\t\t      pcp_msg_info->ext_port,\n\t\t\t\t      pcp_msg_info->protocol,\n\t\t\t\t      iaddr_old, sizeof(iaddr_old),\n\t\t\t\t      &iport_old, 0, 0, 0, 0,\n\t\t\t\t      NULL/*&timestamp*/, 0, 0);\n\n\t\tif(r==0) {\n\t\t\tif((strcmp(pcp_msg_info->mapped_str, iaddr_old)!=0)\n\t\t\t   || (pcp_msg_info->int_port != iport_old)) {\n\t\t\t\t/* redirection already existing */\n\t\t\t\tif (pcp_msg_info->pfailure_present) {\n\t\t\t\t\treturn PCP_ERR_CANNOT_PROVIDE_EXTERNAL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_INFO, \"port %hu %s already redirected to %s:%hu, replacing\",\n\t\t\t\t       pcp_msg_info->ext_port, (pcp_msg_info->protocol==IPPROTO_TCP)?\"tcp\":\"udp\",\n\t\t\t\t       iaddr_old, iport_old);\n\t\t\t\t/* remove and then add again */\n\t\t\t\tif (_upnp_delete_redir(pcp_msg_info->ext_port,\n\t\t\t\t\t\t       pcp_msg_info->protocol)==0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (pcp_msg_info->pfailure_present) {\n\t\t\t\t\treturn PCP_ERR_CANNOT_PROVIDE_EXTERNAL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpcp_msg_info->ext_port++;\n\t\t\tif (pcp_msg_info->ext_port == 0) { /* skip port zero */\n\t\t\t\tpcp_msg_info->ext_port++;\n\t\t\t}\n\t\t}\n\t} while (r==0);\n\n\tr = upnp_redirect_internal(NULL,\n\t\t\t\t   pcp_msg_info->ext_port,\n\t\t\t\t   pcp_msg_info->mapped_str,\n\t\t\t\t   pcp_msg_info->int_port,\n\t\t\t\t   pcp_msg_info->protocol,\n\t\t\t\t   pcp_msg_info->desc,\n\t\t\t\t   timestamp);\n\tif (r < 0)\n\t\treturn PCP_ERR_NO_RESOURCES;\n\treturn PCP_SUCCESS;\n}\n\nstatic int CreatePCPMap_FW(pcp_info_t *pcp_msg_info)\n{\n#ifdef ENABLE_UPNPPINHOLE\n\tint uid;\n\tint r;\n\t/* first check if pinhole already exists */\n\tuid = upnp_find_inboundpinhole(NULL, 0,\n\t\t\t\t\tpcp_msg_info->mapped_str,\n\t\t\t\t\tpcp_msg_info->int_port,\n\t\t\t\t\tpcp_msg_info->protocol,\n\t\t\t\t\tNULL, 0, /* desc */\n\t\t\t\t\tNULL /* lifetime */);\n\tif(uid >= 0) {\n\t\t/* pinhole already exists, updating */\n\t\tsyslog(LOG_INFO, \"updating pinhole to %s:%hu %s\",\n\t\t       pcp_msg_info->mapped_str, pcp_msg_info->int_port,\n\t\t       (pcp_msg_info->protocol == IPPROTO_TCP)?\"TCP\":\"UDP\");\n\t\tr = upnp_update_inboundpinhole((unsigned short)uid, pcp_msg_info->lifetime);\n\t\treturn r >= 0 ? PCP_SUCCESS : PCP_ERR_NO_RESOURCES;\n\t} else {\n\t\tr = upnp_add_inboundpinhole(NULL, 0,\n\t\t\t\t\t\tpcp_msg_info->mapped_str,\n\t\t\t\t\t\tpcp_msg_info->int_port,\n\t\t\t\t\t\tpcp_msg_info->protocol,\n\t\t\t\t\t\tpcp_msg_info->desc,\n\t\t\t\t\t\tpcp_msg_info->lifetime,\n\t\t\t\t\t\t&uid);\n\t\tif (r < 0)\n\t\t\treturn PCP_ERR_NO_RESOURCES;\n\t\tpcp_msg_info->ext_port = pcp_msg_info->int_port;\n\t\treturn PCP_SUCCESS;\n\t}\n#else\n\tUNUSED(pcp_msg_info);\n\treturn PCP_ERR_NO_RESOURCES;\n#endif /* ENABLE_UPNPPINHOLE */\n}\n\n\n/*                internal  external  PCP remote peer  actual remote peer\n *                --------  -------   ---------------  ------------------\n * IPv4 firewall   IPv4      IPv4         IPv4              IPv4\n * IPv6 firewall   IPv6      IPv6         IPv6              IPv6\n *         NAT44   IPv4      IPv4         IPv4              IPv4\n *         NAT46   IPv4      IPv6         IPv4              IPv6\n *         NAT64   IPv6      IPv4         IPv6              IPv4\n *         NPTv6   IPv6      IPv6         IPv6              IPv6\n *\n *             Address Families with MAP and PEER\n *\n * The 'internal' address is implicitly the same as the source IP\n * address of the PCP request, except when the THIRD_PARTY option is\n * used.\n *\n * The 'external' address is the Suggested External Address field of the\n * MAP or PEER request, and its address family is usually the same as\n * the 'internal' address family, except when technologies like NAT64\n * are used.\n *\n * The 'remote peer' address is the remote peer IP address of the PEER\n * request or the FILTER option of the MAP request, and is always the\n * same address family as the 'internal' address, even when NAT64 is\n * used.  In NAT64, the IPv6 PCP client is not necessarily aware of the\n * NAT64 or aware of the actual IPv4 address of the remote peer, so it\n * expresses the IPv6 address from its perspective.     */\n\n/* TODO: Support more than basic NAT44 / IPv6 firewall cases. */\nstatic void CreatePCPMap(pcp_info_t *pcp_msg_info)\n{\n\tint r;\n\n\tif (pcp_msg_info->is_fw)\n\t\tr = CreatePCPMap_FW(pcp_msg_info);\n\telse\n\t\tr = CreatePCPMap_NAT(pcp_msg_info);\n\tpcp_msg_info->result_code = r;\n\tsyslog(r == PCP_SUCCESS ? LOG_INFO : LOG_ERR,\n\t      \"PCP MAP: %s mapping %s %hu->%s:%hu '%s'\",\n\t       r == PCP_SUCCESS ? \"added\" : \"failed to add\",\n\t       (pcp_msg_info->protocol==IPPROTO_TCP)?\"TCP\":\"UDP\",\n\t       pcp_msg_info->ext_port,\n\t       pcp_msg_info->mapped_str,\n\t       pcp_msg_info->int_port,\n\t       pcp_msg_info->desc);\n}\n\nstatic void DeletePCPMap(pcp_info_t *pcp_msg_info)\n{\n\tuint16_t iport = pcp_msg_info->int_port;  /* private port */\n\tuint8_t  proto = pcp_msg_info->protocol;\n\tint r=-1;\n\t/* remove the mapping */\n\t/* remove all the mappings for this client */\n\tint index;\n\tunsigned short eport2, iport2;\n\tchar iaddr2[INET6_ADDRSTRLEN];\n\tint proto2;\n\tchar desc[64];\n\tunsigned int timestamp;\n#ifdef ENABLE_UPNPPINHOLE\n\tint uid = -1;\n#endif /* ENABLE_UPNPPINHOLE */\n\n\t/* iterate through all rules and delete the requested ones */\n\tfor (index = 0 ;\n\t     (!pcp_msg_info->is_fw &&\n\t      get_redirect_rule_by_index(index, 0,\n\t\t\t\t\t &eport2, iaddr2, sizeof(iaddr2),\n\t\t\t\t\t &iport2, &proto2,\n\t\t\t\t\t desc, sizeof(desc),\n\t\t\t\t\t 0, 0, &timestamp, 0, 0) >= 0)\n#ifdef ENABLE_UPNPPINHOLE\n\t       ||\n\t     (pcp_msg_info->is_fw &&\n\t      (uid=upnp_get_pinhole_uid_by_index(index))>=0 &&\n\t      upnp_get_pinhole_info((unsigned short)uid,\n\t\t\t\t    NULL, 0, NULL,\n\t\t\t\t    iaddr2, sizeof(iaddr2), &iport2,\n\t\t\t\t    &proto2, desc, sizeof(desc),\n\t\t\t\t    &timestamp, NULL) >= 0)\n#endif /* ENABLE_UPNPPINHOLE */\n\t\t     ;\n\t     index++)\n\t\tif(0 == strcmp(iaddr2, pcp_msg_info->mapped_str)\n\t\t   && (proto2==proto)\n\t\t   && ((iport2==iport) || (iport==0))) {\n\t\t\tif(0 != strcmp(desc, pcp_msg_info->desc)) {\n\t\t\t\t/* nonce does not match */\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_NOT_AUTHORIZED;\n\t\t\t\tsyslog(LOG_ERR, \"Unauthorized to remove PCP mapping internal port %hu, protocol %s\",\n\t\t\t\t       iport, (pcp_msg_info->protocol == IPPROTO_TCP)?\"TCP\":\"UDP\");\n\t\t\t\treturn;\n\t\t\t} else if (!pcp_msg_info->is_fw) {\n\t\t\t\tr = _upnp_delete_redir(eport2, proto2);\n\t\t\t} else {\n#ifdef ENABLE_UPNPPINHOLE\n\t\t\t\tr = upnp_delete_inboundpinhole(uid);\n#endif /* ENABLE_UPNPPINHOLE */\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tif (r >= 0) {\n\t\tsyslog(LOG_INFO, \"PCP: %s port %hu mapping removed\",\n\t\t       proto2==IPPROTO_TCP?\"TCP\":\"UDP\", eport2);\n\t} else {\n\t\tsyslog(LOG_ERR, \"Failed to remove PCP mapping internal port %hu, protocol %s\",\n\t\t       iport, (pcp_msg_info->protocol == IPPROTO_TCP)?\"TCP\":\"UDP\");\n\t\tpcp_msg_info->result_code = PCP_ERR_NO_RESOURCES;\n\t}\n}\n\nstatic int ValidatePCPMsg(pcp_info_t *pcp_msg_info)\n{\n\tif (pcp_msg_info->result_code) {\n\t\treturn 0;\n\t}\n\n\t/* RFC 6887, section 8.2: MUST return address mismatch if NAT\n\t * in middle. */\n\tif (memcmp(pcp_msg_info->int_ip,\n\t\t   &pcp_msg_info->sender_ip,\n\t\t   sizeof(pcp_msg_info->sender_ip)) != 0) {\n\t\tpcp_msg_info->result_code = PCP_ERR_ADDRESS_MISMATCH;\n\t\treturn 0;\n\t}\n\n\tif (pcp_msg_info->thirdp_ip) {\n\t\tif (!GETFLAG(PCP_ALLOWTHIRDPARTYMASK)) {\n\t\t\tpcp_msg_info->result_code = PCP_ERR_UNSUPP_OPTION;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* RFC687, section 13.1 - if sender ip == THIRD_PARTY,\n\t\t * it's an error. */\n\t\tif (memcmp(pcp_msg_info->thirdp_ip,\n\t\t\t   &pcp_msg_info->sender_ip,\n\t\t\t   sizeof(pcp_msg_info->sender_ip)) == 0) {\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Produce mapped_str for future use. */\n\tif (!inet_n46top(pcp_msg_info->mapped_ip, pcp_msg_info->mapped_str,\n\t\t         sizeof(pcp_msg_info->mapped_str))) {\n\t\tsyslog(LOG_ERR, \"inet_ntop(pcpserver): %m\");\n\t\treturn 0;\n\t}\n\n\t/* protocol zero means 'all protocols' : internal port MUST be zero */\n\tif (pcp_msg_info->protocol == 0 && pcp_msg_info->int_port != 0) {\n\t\tsyslog(LOG_ERR, \"PCP %s: Protocol was ZERO, but internal port \"\n\t\t       \"has non-ZERO value.\", getPCPOpCodeStr(pcp_msg_info->opcode));\n\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\treturn 0;\n\t}\n\n\tif (pcp_msg_info->pfailure_present) {\n\t\tif ( (IN6_IS_ADDR_UNSPECIFIED(pcp_msg_info->ext_ip) ||\n\t\t      ((IN6_IS_ADDR_V4MAPPED(pcp_msg_info->ext_ip)) &&\n\t\t       (((uint32_t*)pcp_msg_info->ext_ip->s6_addr)[3] == 0))) &&\n\t\t     (pcp_msg_info->ext_port == 0)\n\t\t   )\n\t\t{\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (CheckExternalAddress(pcp_msg_info)) {\n\t\treturn 0;\n\t}\n\n\t/* Fill in the desc that describes uniquely what flow we're\n\t * dealing with (same code used in both create + delete of\n\t * MAP/PEER) */\n\tswitch (pcp_msg_info->opcode) {\n\tcase PCP_OPCODE_MAP:\n\tcase PCP_OPCODE_PEER:\n\t\tsnprintf(pcp_msg_info->desc, sizeof(pcp_msg_info->desc),\n\t\t\t \"PCP %s %08x%08x%08x\",\n\t\t\t getPCPOpCodeStr(pcp_msg_info->opcode),\n\t\t\t pcp_msg_info->nonce[0],\n\t\t\t pcp_msg_info->nonce[1], pcp_msg_info->nonce[2]);\n\t\tbreak;\n\t}\n\treturn 1;\n}\n\n/*\n * return value indicates whether the request is valid or not.\n * Based on the return value simple response can be formed.\n */\nstatic int processPCPRequest(void * req, int req_size, pcp_info_t *pcp_msg_info)\n{\n\tint remainingSize;\n\n\t/* start with PCP_SUCCESS as result code,\n\t * if everything is OK value will be unchanged */\n\tpcp_msg_info->result_code = PCP_SUCCESS;\n\n\tremainingSize = req_size;\n\n\t/* discard request that exceeds maximal length,\n\t   or that is shorter than PCP_MIN_LEN (=24)\n\t   or that is not the multiple of 4 */\n\tif (req_size < 3)\n\t\treturn 0; /* ignore msg */\n\n\tif (req_size < PCP_MIN_LEN) {\n\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\treturn 1; /* send response */\n\t}\n\n\tif ( (req_size > PCP_MAX_LEN) || ( (req_size & 3) != 0)) {\n\t\tsyslog(LOG_ERR, \"PCP: Size of PCP packet(%d) is larger than %d bytes or \"\n\t\t       \"the size is not multiple of 4.\\n\", req_size, PCP_MAX_LEN);\n\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\treturn 1; /* send response */\n\t}\n\n\t/* first parse request header */\n\tif (parseCommonRequestHeader(req, pcp_msg_info) ) {\n\t\treturn 1;\n\t}\n\n\tremainingSize -= PCP_COMMON_REQUEST_SIZE;\n\treq += PCP_COMMON_REQUEST_SIZE;\n\n\tif (pcp_msg_info->version == 1) {\n\t\t/* legacy PCP version 1 support */\n\t\tswitch (pcp_msg_info->opcode) {\n\t\tcase PCP_OPCODE_MAP:\n\n\t\t\tremainingSize -= PCP_MAP_V1_SIZE;\n\t\t\tif (remainingSize < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tprintMAPOpcodeVersion1(req);\n#endif /* DEBUG */\n\t\t\tparsePCPMAP_version1(req, pcp_msg_info);\n\n\t\t\treq += PCP_MAP_V1_SIZE;\n\n\t\t\tparsePCPOptions(req, remainingSize, pcp_msg_info);\n\t\t\tif (ValidatePCPMsg(pcp_msg_info)) {\n\t\t\t\tif (pcp_msg_info->lifetime == 0) {\n\t\t\t\t\tDeletePCPMap(pcp_msg_info);\n\t\t\t\t} else {\n\t\t\t\t\tCreatePCPMap(pcp_msg_info);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_ERR, \"PCP: Invalid PCP v1 MAP message.\");\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\t\t\tbreak;\n\n#ifdef PCP_PEER\n\t\tcase PCP_OPCODE_PEER:\n\n\t\t\tremainingSize -= PCP_PEER_V1_SIZE;\n\t\t\tif (remainingSize < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tprintPEEROpcodeVersion1(req);\n#endif /* DEBUG */\n\t\t\tparsePCPPEER_version1(req, pcp_msg_info);\n\n\t\t\treq += PCP_PEER_V1_SIZE;\n\n\t\t\tparsePCPOptions(req, remainingSize, pcp_msg_info);\n\n\t\t\tif (ValidatePCPMsg(pcp_msg_info)) {\n\t\t\t\tif (pcp_msg_info->lifetime == 0) {\n\t\t\t\t\tDeletePCPPeer(pcp_msg_info);\n\t\t\t\t} else {\n\t\t\t\t\tCreatePCPPeer(pcp_msg_info);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_ERR, \"PCP: Invalid PCP v1 PEER message.\");\n\t\t\t\t return pcp_msg_info->result_code;\n\t\t\t}\n\n\n\t\t\tbreak;\n#endif /* PCP_PEER */\n\t\tdefault:\n\t\t\tpcp_msg_info->result_code = PCP_ERR_UNSUPP_OPCODE;\n\t\t\tbreak;\n\t\t}\n\n\t} else if (pcp_msg_info->version == 2) {\n\t\t/* RFC 6887 PCP support\n\t\t * http://tools.ietf.org/html/rfc6887 */\n\t\tswitch (pcp_msg_info->opcode) {\n\t\tcase PCP_OPCODE_ANNOUNCE:\n\t\t\t/* should check PCP Client's IP Address in request */\n\t\t\t/* see http://tools.ietf.org/html/rfc6887#section-14.1 */\n\t\t\tbreak;\n\t\tcase PCP_OPCODE_MAP:\n\n\t\t\tremainingSize -= PCP_MAP_V2_SIZE;\n\t\t\tif (remainingSize < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tprintMAPOpcodeVersion2(req);\n#endif /* DEBUG */\n\t\t\tparsePCPMAP_version2(req, pcp_msg_info);\n\t\t\treq += PCP_MAP_V2_SIZE;\n\n\t\t\tparsePCPOptions(req, remainingSize, pcp_msg_info);\n\n\t\t\tif (ValidatePCPMsg(pcp_msg_info)) {\n\t\t\t\tif (pcp_msg_info->lifetime == 0) {\n\t\t\t\t\tDeletePCPMap(pcp_msg_info);\n\t\t\t\t} else {\n\t\t\t\t\tCreatePCPMap(pcp_msg_info);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_ERR, \"PCP: Invalid PCP v2 MAP message.\");\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n\n\t\t\tbreak;\n\n#ifdef PCP_PEER\n\t\tcase PCP_OPCODE_PEER:\n\n\t\t\tremainingSize -= PCP_PEER_V2_SIZE;\n\t\t\tif (remainingSize < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tprintPEEROpcodeVersion2(req);\n#endif /* DEBUG */\n\t\t\tparsePCPPEER_version2(req, pcp_msg_info);\n\t\t\treq += PCP_PEER_V2_SIZE;\n\n\t\t\tif (pcp_msg_info->result_code != 0) {\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n\t\t\tparsePCPOptions(req, remainingSize, pcp_msg_info);\n\n\t\t\tif (ValidatePCPMsg(pcp_msg_info)) {\n\t\t\t\tif (pcp_msg_info->lifetime == 0) {\n\t\t\t\t\tDeletePCPPeer(pcp_msg_info);\n\t\t\t\t} else {\n\t\t\t\t\tCreatePCPPeer(pcp_msg_info);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_ERR, \"PCP: Invalid PCP v2 PEER message.\");\n\t\t\t}\n\n\t\tbreak;\n#endif /* PCP_PEER */\n\n#ifdef PCP_SADSCP\n\t\tcase PCP_OPCODE_SADSCP:\n\t\t\tremainingSize -= PCP_SADSCP_REQ_SIZE;\n\t\t\tif (remainingSize < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n\t\t\tremainingSize -= ((uint8_t *)req)[13];\t/* app_name_length */\n\t\t\tif (remainingSize < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tprintSADSCPOpcode(req);\n#endif\n\t\t\tparseSADSCP(req, pcp_msg_info);\n\t\t\treq += PCP_SADSCP_REQ_SIZE;\n\t\t\tif (pcp_msg_info->result_code != 0) {\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\t\t\treq += pcp_msg_info->app_name_len;\n\n\t\t\tget_dscp_value(pcp_msg_info);\n\n\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tpcp_msg_info->result_code = PCP_ERR_UNSUPP_OPCODE;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tpcp_msg_info->result_code = PCP_ERR_UNSUPP_VERSION;\n\t\treturn pcp_msg_info->result_code;\n\t}\n\treturn 1;\n}\n\n\nstatic void createPCPResponse(unsigned char *response, const pcp_info_t *pcp_msg_info)\n{\n\tresponse[2] = 0;\t/* reserved */\n\tmemset(response + 12, 0, 12);\t/* reserved */\n\tif (pcp_msg_info->result_code == PCP_ERR_UNSUPP_VERSION ) {\n\t\t/* highest supported version */\n\t\tresponse[0] = this_server_info.server_version;\n\t} else {\n\t\tresponse[0] = pcp_msg_info->version;\n\t}\n\n\tresponse[1] = pcp_msg_info->opcode | 0x80;\t/* r_opcode */\n\tresponse[3] = pcp_msg_info->result_code;\n\tif(epoch_origin == 0) {\n\t\tepoch_origin = startup_time;\n\t}\n\tWRITENU32(response + 8, upnp_time() - epoch_origin); /* epochtime */\n\tswitch (pcp_msg_info->result_code) {\n\t/*long lifetime errors*/\n\tcase PCP_ERR_UNSUPP_VERSION:\n\tcase PCP_ERR_NOT_AUTHORIZED:\n\tcase PCP_ERR_MALFORMED_REQUEST:\n\tcase PCP_ERR_UNSUPP_OPCODE:\n\tcase PCP_ERR_UNSUPP_OPTION:\n\tcase PCP_ERR_MALFORMED_OPTION:\n\tcase PCP_ERR_UNSUPP_PROTOCOL:\n\tcase PCP_ERR_ADDRESS_MISMATCH:\n\tcase PCP_ERR_CANNOT_PROVIDE_EXTERNAL:\n\tcase PCP_ERR_EXCESSIVE_REMOTE_PEERS:\n\t\tWRITENU32(response + 4, 0);\t/* lifetime */\n\t\tbreak;\n\n\tcase PCP_ERR_NETWORK_FAILURE:\n\tcase PCP_ERR_NO_RESOURCES:\n\tcase PCP_ERR_USER_EX_QUOTA:\n\t\tWRITENU32(response + 4, 30);\t/* lifetime */\n\t\tbreak;\n\n\tcase PCP_SUCCESS:\n\tdefault:\n\t\tWRITENU32(response + 4, pcp_msg_info->lifetime);\t/* lifetime */\n\t\tbreak;\n\t}\n\n\tif (response[1] == 0x81) { /* MAP response */\n\t\tif (response[0] == 1) {\t/* version */\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 4, pcp_msg_info->int_port);\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 6, pcp_msg_info->ext_port);\n\t\t\tcopyIPv6IfDifferent(response + PCP_COMMON_RESPONSE_SIZE + 8,\n\t\t\t                    pcp_msg_info->ext_ip);\n\t\t}\n\t\telse if (response[0] == 2) {\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 16, pcp_msg_info->int_port);\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 18, pcp_msg_info->ext_port);\n\t\t\tcopyIPv6IfDifferent(response + PCP_COMMON_RESPONSE_SIZE + 20,\n\t\t\t                    pcp_msg_info->ext_ip);\n\t\t}\n\t}\n#ifdef PCP_PEER\n\telse if (response[1] == 0x82) { /* PEER response */\n\t\tif (response[0] == 1) {\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 4, pcp_msg_info->int_port);\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 6, pcp_msg_info->ext_port);\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 24, pcp_msg_info->peer_port);\n\t\t\tcopyIPv6IfDifferent(response + PCP_COMMON_RESPONSE_SIZE + 8,\n\t\t\t                    pcp_msg_info->ext_ip);\n\t\t}\n\t\telse if (response[0] == 2) {\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 16, pcp_msg_info->int_port);\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 18, pcp_msg_info->ext_port);\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 36, pcp_msg_info->peer_port);\n\t\t\tcopyIPv6IfDifferent(response + PCP_COMMON_RESPONSE_SIZE + 20,\n\t\t\t                    pcp_msg_info->ext_ip);\n\t\t}\n\t}\n#endif /* PCP_PEER */\n\n#ifdef PCP_SADSCP\n\telse if (response[1] == 0x83) { /*SADSCP response*/\n\t\tresponse[PCP_COMMON_RESPONSE_SIZE + 12]\n\t\t\t= ((pcp_msg_info->matched_name<<7) & ~(1<<6)) |\n\t\t\t  (pcp_msg_info->sadscp_dscp & PCP_SADSCP_MASK);\n\t\tmemset(response + PCP_COMMON_RESPONSE_SIZE + 13, 0, 3);\n\t}\n#endif /* PCP_SADSCP */\n}\n\nint ProcessIncomingPCPPacket(int s, unsigned char *buff, int len,\n                             const struct sockaddr *senderaddr,\n                             const struct sockaddr_in6 *receiveraddr)\n{\n\tpcp_info_t pcp_msg_info;\n\tstruct lan_addr_s * lan_addr;\n\tchar addr_str[64];\n\n\tmemset(&pcp_msg_info, 0, sizeof(pcp_info_t));\n\n\tif(senderaddr->sa_family == AF_INET) {\n\t\tconst struct sockaddr_in * senderaddr_v4 =\n\t\t\t(const struct sockaddr_in *)senderaddr;\n\t\tpcp_msg_info.sender_ip.s6_addr[11] = 0xff;\n\t\tpcp_msg_info.sender_ip.s6_addr[10] = 0xff;\n\t\tmemcpy(pcp_msg_info.sender_ip.s6_addr+12,\n\t\t       &senderaddr_v4->sin_addr, 4);\n\t} else if(senderaddr->sa_family == AF_INET6) {\n\t\tconst struct sockaddr_in6 * senderaddr_v6 =\n\t\t\t(const struct sockaddr_in6 *)senderaddr;\n\t\tpcp_msg_info.sender_ip = senderaddr_v6->sin6_addr;\n\t} else {\n\t\tsyslog(LOG_WARNING, \"unknown PCP packet sender address family %d\",\n\t\t       senderaddr->sa_family);\n\t\treturn 0;\n\t}\n\n\tif(sockaddr_to_string(senderaddr, addr_str, sizeof(addr_str)))\n\t\tsyslog(LOG_DEBUG, \"PCP request received from %s %dbytes\",\n\t\t       addr_str, len);\n\n\tif(buff[1] & 128) {\n\t\t/* discarding PCP responses silently */\n\t\treturn 0;\n\t}\n\n\t/* If we're in allow third party-mode, we probably don't care\n\t * about locality either. Let's hope firewall is ok. */\n\tif (!GETFLAG(PCP_ALLOWTHIRDPARTYMASK)) {\n\t\tlan_addr = get_lan_for_peer(senderaddr);\n\t\tif(lan_addr == NULL) {\n\t\t\tsyslog(LOG_WARNING, \"PCP packet sender %s not from a LAN, ignoring\",\n\t\t\t       addr_str);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (processPCPRequest(buff, len, &pcp_msg_info) ) {\n\n\t\tcreatePCPResponse(buff, &pcp_msg_info);\n\n\t\tif(len < PCP_MIN_LEN)\n\t\t\tlen = PCP_MIN_LEN;\n\t\telse\n\t\t\tlen = (len + 3) & ~3;\t/* round up resp. length to multiple of 4 */\n\t\tlen = sendto_or_schedule2(s, buff, len, 0, senderaddr,\n\t\t           (senderaddr->sa_family == AF_INET) ?\n\t\t                  sizeof(struct sockaddr_in) :\n\t\t                  sizeof(struct sockaddr_in6),\n\t\t           receiveraddr);\n\t\tif( len < 0 ) {\n\t\t\tsyslog(LOG_ERR, \"sendto(pcpserver): %m\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#ifdef ENABLE_IPV6\nint OpenAndConfPCPv6Socket(void)\n{\n\tint s;\n\tint i = 1;\n\tstruct sockaddr_in6 addr;\n\ts = socket(PF_INET6, SOCK_DGRAM, 0/*IPPROTO_UDP*/);\n\tif(s < 0) {\n\t\tsyslog(LOG_ERR, \"%s: socket(): %m\", \"OpenAndConfPCPv6Socket\");\n\t\treturn -1;\n\t}\n\tif(setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof(i)) < 0) {\n\t\tsyslog(LOG_WARNING, \"%s: setsockopt(SO_REUSEADDR): %m\",\n\t\t       \"OpenAndConfPCPv6Socket\");\n\t}\n#ifdef IPV6_V6ONLY\n\t/* force IPV6 only for IPV6 socket.\n\t * see http://www.ietf.org/rfc/rfc3493.txt section 5.3 */\n\tif(setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &i, sizeof(i)) < 0) {\n\t\tsyslog(LOG_WARNING, \"%s: setsockopt(IPV6_V6ONLY): %m\",\n\t\t       \"OpenAndConfPCPv6Socket\");\n\t}\n#endif\n#ifdef IPV6_RECVPKTINFO\n\t/* see RFC3542 */\n\tif(setsockopt(s, IPPROTO_IPV6, IPV6_RECVPKTINFO, &i, sizeof(i)) < 0) {\n\t\tsyslog(LOG_WARNING, \"%s: setsockopt(IPV6_RECVPKTINFO): %m\",\n\t\t       \"OpenAndConfPCPv6Socket\");\n\t}\n#endif\n\tif(!set_non_blocking(s)) {\n\t\tsyslog(LOG_WARNING, \"%s: set_non_blocking(): %m\",\n\t\t       \"OpenAndConfPCPv6Socket\");\n\t}\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin6_family = AF_INET6;\n\taddr.sin6_port = htons(NATPMP_PORT);\n\taddr.sin6_addr = ipv6_bind_addr;\n\tif(bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t\tsyslog(LOG_ERR, \"%s: bind(): %m\", \"OpenAndConfPCPv6Socket\");\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\treturn s;\n}\n#endif /*ENABLE_IPV6*/\n\n#ifdef ENABLE_IPV6\nvoid PCPSendUnsolicitedAnnounce(int * sockets, int n_sockets, int socket6)\n#else /* IPv4 only */\nvoid PCPSendUnsolicitedAnnounce(int * sockets, int n_sockets)\n#endif\n{\n\tint i;\n\tunsigned char buff[PCP_MIN_LEN];\n\tpcp_info_t info;\n\tssize_t len;\n\tstruct sockaddr_in addr;\n#ifdef ENABLE_IPV6\n\tstruct sockaddr_in6 addr6;\n#endif /* ENABLE_IPV6 */\n\t/* this is an Unsolicited ANNOUNCE response */\n\n\tinfo.version = this_server_info.server_version;\n\tinfo.opcode = PCP_OPCODE_ANNOUNCE;\n\tinfo.result_code = PCP_SUCCESS;\n\tinfo.lifetime = 0;\n\tcreatePCPResponse(buff, &info);\n\t/* Multicast PCP restart announcements are sent to\n\t * 224.0.0.1:5350 and/or [ff02::1]:5350 */\n\tmemset(&addr, 0, sizeof(struct sockaddr_in));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = inet_addr(\"224.0.0.1\");\n\taddr.sin_port = htons(5350);\n\tfor(i = 0; i < n_sockets; i++) {\n\t\tlen = sendto_or_schedule(sockets[i], buff, PCP_MIN_LEN, 0, (struct sockaddr *)&addr, sizeof(struct sockaddr_in));\n\t\tif( len < 0 ) {\n\t\t\tsyslog(LOG_ERR, \"PCPSendUnsolicitedAnnounce() sendto(): %m\");\n\t\t}\n\t}\n#ifdef ENABLE_IPV6\n\tmemset(&addr6, 0, sizeof(struct sockaddr_in6));\n\taddr6.sin6_family = AF_INET6;\n\tinet_pton(AF_INET6, \"FF02::1\", &(addr6.sin6_addr));\n\taddr6.sin6_port = htons(5350);\n\tlen = sendto_or_schedule(socket6, buff, PCP_MIN_LEN, 0, (struct sockaddr *)&addr6, sizeof(struct sockaddr_in6));\n\tif( len < 0 ) {\n\t\tsyslog(LOG_ERR, \"PCPSendUnsolicitedAnnounce() IPv6 sendto(): %m\");\n\t}\n#endif /* ENABLE_IPV6 */\n}\n\n#ifdef ENABLE_IPV6\nvoid PCPPublicAddressChanged(int * sockets, int n_sockets, int socket6)\n#else /* IPv4 only */\nvoid PCPPublicAddressChanged(int * sockets, int n_sockets)\n#endif\n{\n\t/* according to RFC 6887  8.5 :\n\t *   if the external IP address(es) of the NAT (controlled by\n\t *   the PCP server) changes, the Epoch time MUST be reset. */\n\tepoch_origin = upnp_time();\n#ifdef ENABLE_IPV6\n\tPCPSendUnsolicitedAnnounce(sockets, n_sockets, socket6);\n#else /* IPv4 Only */\n\tPCPSendUnsolicitedAnnounce(sockets, n_sockets);\n#endif\n}\n#endif /*ENABLE_PCP*/\n"], "fixing_code": ["/* $Id: pcpserver.c,v 1.47 2018/03/13 10:21:19 nanard Exp $ */\n/* MiniUPnP project\n * Website : http://miniupnp.free.fr/\n * Author : Peter Tatrai\n\nCopyright (c) 2013 by Cisco Systems, Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n    * The name of the author may not be used to endorse or promote products\n      derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* Current assumptions:\n   - IPv4 is always NATted (internal -> external)\n   - IPv6 is always firewalled (this may need some work, NAT6* do exist)\n\n   - we make the judgement based on (in order, picking first one available):\n     - third party address\n     - internal client address\n\n   TODO : handle NAT46, NAT64, NPT66. In addition, beyond FW/NAT\n   choice, should also add for proxy (=as much as possible transparent\n   pass-through to one or more servers).\n\n   TODO: IPv6 permission handling (for the time being, we just assume\n   anyone on IPv6 is a good guy, but fixing that would include\n   upnppermissions rewrite to be AF neutral).\n*/\n\n#include \"config.h\"\n\n#ifdef ENABLE_PCP\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <time.h>\n#include <signal.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <syslog.h>\n\n#include \"pcpserver.h\"\n#include \"natpmp.h\"\n#include \"macros.h\"\n#include \"upnpglobalvars.h\"\n#include \"pcplearndscp.h\"\n#include \"upnpredirect.h\"\n#include \"commonrdr.h\"\n#include \"getifaddr.h\"\n#include \"asyncsendto.h\"\n#include \"upnputils.h\"\n#include \"portinuse.h\"\n#include \"pcp_msg_struct.h\"\n#ifdef ENABLE_UPNPPINHOLE\n#include \"upnppinhole.h\"\n#endif /* ENABLE_UPNPPINHOLE */\n\n\n#ifdef PCP_PEER\n/* TODO make this platform independent */\n#ifdef USE_NETFILTER\n#include \"netfilter/iptcrdr.h\"\n#else\n#error \"PCP Peer is only supported with NETFILTER\"\n#endif /* USE_NETFILTER */\n#endif /* PCP_PEER */\n\n/* server specific information */\nstruct pcp_server_info {\n\tuint8_t server_version;\n};\n\n/* default server settings, highest version supported is the default */\nstatic const struct pcp_server_info this_server_info = {2};\n\n/* structure holding information from PCP msg*/\n/* all variables are in host byte order except IP addresses */\ntypedef struct pcp_info {\n\tuint8_t     version;\n\tuint8_t     opcode;\n\tuint8_t     result_code;\n\tuint32_t    lifetime;             /* lifetime of the mapping */\n\tuint32_t    epochtime;\n\t/* both MAP and PEER opcode specific information */\n\tuint32_t\tnonce[3];\t/* random value generated by client */\n\tuint8_t     protocol;\n\tuint16_t    int_port;\n\tconst struct in6_addr    *int_ip; /* in network order */\n\tuint16_t    ext_port;\n\tconst struct in6_addr    *ext_ip; /* Suggested external IP in network order*/\n\t/* PEER specific information */\n#ifdef PCP_PEER\n\tuint16_t    peer_port;\n\tconst struct in6_addr    *peer_ip; /* Destination IP in network order */\n#endif /* PCP_PEER */\n\n#ifdef PCP_SADSCP\n\t/* SADSCP specific information */\n\tuint8_t delay_tolerance;\n\tuint8_t loss_tolerance;\n\tuint8_t jitter_tolerance;\n\tuint8_t app_name_len;\n\tconst char*   app_name;\n\tuint8_t sadscp_dscp;\n\tuint8_t matched_name;\n\tint8_t is_sadscp_op;\n#endif\n\n#ifdef PCP_FLOWP\n\tuint8_t dscp_up;\n\tuint8_t dscp_down;\n\tint flowp_present;\n#endif\n\tuint8_t is_map_op;\n\tuint8_t is_peer_op;\n\tconst struct in6_addr *thirdp_ip;\n\tconst struct in6_addr *mapped_ip;\n\tchar mapped_str[INET6_ADDRSTRLEN];\n\tint pfailure_present;\n\tstruct in6_addr sender_ip;\n\tint is_fw; /* is this firewall operation? if not, nat. */\n\tchar desc[64];\n} pcp_info_t;\n\n/* getPCPOpCodeStr()\n * return a string representation of the PCP OpCode\n * can be used for debug output */\nstatic const char * getPCPOpCodeStr(uint8_t opcode)\n{\n\tswitch(opcode) {\n\tcase PCP_OPCODE_ANNOUNCE:\n\t\treturn \"ANNOUNCE\";\n\tcase PCP_OPCODE_MAP:\n\t\treturn \"MAP\";\n\tcase PCP_OPCODE_PEER:\n\t\treturn \"PEER\";\n#ifdef  PCP_SADSCP\n\tcase PCP_OPCODE_SADSCP:\n\t\treturn \"SADSCP\";\n#endif\t/* PCP_SADSCP */\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\n/* useful to copy ext_ip only if needed, as request and response\n * buffers are same */\nstatic void copyIPv6IfDifferent(void * dest, const void * src)\n{\n\tif(dest != src && src != NULL) {\n\t\tmemcpy(dest, src, sizeof(struct in6_addr));\n\t}\n}\n\n#ifdef PCP_SADSCP\nint get_dscp_value(pcp_info_t *pcp_msg_info) {\n\n\tunsigned int ind;\n\n\tfor (ind = 0; ind < num_dscp_values; ind++) {\n\n\t\tif ((dscp_values_list[ind].app_name) &&\n\t\t    (!strcmp(dscp_values_list[ind].app_name,\n\t\t\t     pcp_msg_info->app_name)) &&\n\t\t    (pcp_msg_info->delay_tolerance == dscp_values_list[ind].delay) &&\n\t\t    (pcp_msg_info->loss_tolerance == dscp_values_list[ind].loss) &&\n\t\t    (pcp_msg_info->jitter_tolerance == dscp_values_list[ind].jitter)\n\t\t   )\n\t\t{\n\t\t\tpcp_msg_info->sadscp_dscp = dscp_values_list[ind].dscp_value;\n\t\t\tpcp_msg_info->matched_name = 1;\n\t\t\treturn 0;\n\t\t} else\n\t\t  if ((pcp_msg_info->app_name_len==0) &&\n\t\t      (dscp_values_list[ind].app_name_len==0) &&\n\t\t      (pcp_msg_info->delay_tolerance == dscp_values_list[ind].delay) &&\n\t\t      (pcp_msg_info->loss_tolerance == dscp_values_list[ind].loss) &&\n\t\t      (pcp_msg_info->jitter_tolerance == dscp_values_list[ind].jitter)\n\t\t     )\n\t\t{\n\t\t\tpcp_msg_info->sadscp_dscp = dscp_values_list[ind].dscp_value;\n\t\t\tpcp_msg_info->matched_name = 0;\n\t\t\treturn 0;\n\t\t} else\n\t\t  if ((dscp_values_list[ind].app_name_len==0) &&\n\t\t      (pcp_msg_info->delay_tolerance == dscp_values_list[ind].delay) &&\n\t\t      (pcp_msg_info->loss_tolerance == dscp_values_list[ind].loss) &&\n\t\t      (pcp_msg_info->jitter_tolerance == dscp_values_list[ind].jitter)\n\t\t     )\n\t\t{\n\t\t\tpcp_msg_info->sadscp_dscp = dscp_values_list[ind].dscp_value;\n\t\t\tpcp_msg_info->matched_name = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t//if nothing matched return Default value i.e. 0\n\tpcp_msg_info->sadscp_dscp = 0;\n\tpcp_msg_info->matched_name = 0;\n\treturn 0;\n}\n#endif\n/*\n * Function extracting information from common_req (common request header)\n * into pcp_msg_info.\n * @return : when no problem occurred 0 is returned, 1 otherwise and appropriate\n *          result code is assigned to pcp_msg_info->result_code to indicate\n *          what kind of error occurred\n */\nstatic int parseCommonRequestHeader(const uint8_t *common_req, pcp_info_t *pcp_msg_info)\n{\n\tpcp_msg_info->version = common_req[0] ;\n\tpcp_msg_info->opcode = common_req[1] & 0x7f;\n\tpcp_msg_info->lifetime = READNU32(common_req + 4);\n\tpcp_msg_info->int_ip = (struct in6_addr *)(common_req + 8);\n\tpcp_msg_info->mapped_ip = (struct in6_addr *)(common_req + 8);\n\n\n\tif ( (pcp_msg_info->version > this_server_info.server_version) ) {\n\t\tpcp_msg_info->result_code = PCP_ERR_UNSUPP_VERSION;\n\t\treturn 1;\n\t}\n\n\tif (pcp_msg_info->lifetime > max_lifetime ) {\n\t\tpcp_msg_info->lifetime = max_lifetime;\n\t}\n\n\tif ( (pcp_msg_info->lifetime < min_lifetime) && (pcp_msg_info->lifetime != 0) ) {\n\t\tpcp_msg_info->lifetime = min_lifetime;\n\t}\n\n\treturn 0;\n}\n\n#ifdef DEBUG\nstatic void printMAPOpcodeVersion1(const uint8_t *buf)\n{\n\tchar map_addr[INET6_ADDRSTRLEN];\n\tsyslog(LOG_DEBUG, \"PCP MAP: v1 Opcode specific information. \\n\");\n\tsyslog(LOG_DEBUG, \"MAP protocol: \\t\\t %d\\n\", (int)buf[0] );\n\tsyslog(LOG_DEBUG, \"MAP int port: \\t\\t %d\\n\", (int)READNU16(buf+4));\n\tsyslog(LOG_DEBUG, \"MAP ext port: \\t\\t %d\\n\", (int)READNU16(buf+6));\n\tsyslog(LOG_DEBUG, \"MAP Ext IP: \\t\\t %s\\n\", inet_ntop(AF_INET6,\n\t       buf+8, map_addr, INET6_ADDRSTRLEN));\n}\n\nstatic void printMAPOpcodeVersion2(const uint8_t *buf)\n{\n\tchar map_addr[INET6_ADDRSTRLEN];\n\tsyslog(LOG_DEBUG, \"PCP MAP: v2 Opcode specific information.\");\n\tsyslog(LOG_DEBUG, \"MAP nonce:   \\t%08x%08x%08x\",\n\t       READNU32(buf), READNU32(buf+4), READNU32(buf+8));\n\tsyslog(LOG_DEBUG, \"MAP protocol:\\t%d\", (int)buf[12]);\n\tsyslog(LOG_DEBUG, \"MAP int port:\\t%d\", (int)READNU16(buf+16));\n\tsyslog(LOG_DEBUG, \"MAP ext port:\\t%d\", (int)READNU16(buf+18));\n\tsyslog(LOG_DEBUG, \"MAP Ext IP:  \\t%s\", inet_ntop(AF_INET6,\n\t       buf+20, map_addr, INET6_ADDRSTRLEN));\n}\n#endif /* DEBUG */\n\nstatic void parsePCPMAP_version1(const uint8_t *map_v1,\n\t\tpcp_info_t *pcp_msg_info)\n{\n\tpcp_msg_info->is_map_op = 1;\n\tpcp_msg_info->protocol = map_v1[0];\n\tpcp_msg_info->int_port = READNU16(map_v1 + 4);\n\tpcp_msg_info->ext_port = READNU16(map_v1 + 6);\n\n\tpcp_msg_info->ext_ip = (struct in6_addr *)(map_v1 + 8);\n}\n\nstatic void parsePCPMAP_version2(const uint8_t *map_v2,\n\t\tpcp_info_t *pcp_msg_info)\n{\n\tpcp_msg_info->is_map_op = 1;\n\tmemcpy(pcp_msg_info->nonce, map_v2, 12);\n\tpcp_msg_info->protocol = map_v2[12];\n\tpcp_msg_info->int_port = READNU16(map_v2 + 16);\n\tpcp_msg_info->ext_port = READNU16(map_v2 + 18);\n\n\tpcp_msg_info->ext_ip = (struct in6_addr *)(map_v2 + 20);\n}\n\n#ifdef PCP_PEER\n#ifdef DEBUG\nstatic void printPEEROpcodeVersion1(const uint8_t *buf)\n{\n\tchar ext_addr[INET6_ADDRSTRLEN];\n\tchar peer_addr[INET6_ADDRSTRLEN];\n\tsyslog(LOG_DEBUG, \"PCP PEER: v1 Opcode specific information. \\n\");\n\tsyslog(LOG_DEBUG, \"Protocol: \\t\\t %d\\n\", (int)buf[0]);\n\tsyslog(LOG_DEBUG, \"Internal port: \\t\\t %d\\n\", READNU16(buf + 4));\n\tsyslog(LOG_DEBUG, \"External IP: \\t\\t %s\\n\", inet_ntop(AF_INET6, buf + 8,\n\t       ext_addr,INET6_ADDRSTRLEN));\n\tsyslog(LOG_DEBUG, \"External port port: \\t\\t %d\\n\", READNU16(buf + 6));\n\tsyslog(LOG_DEBUG, \"PEER IP: \\t\\t %s\\n\", inet_ntop(AF_INET6, buf + 28,\n\t       peer_addr,INET6_ADDRSTRLEN));\n\tsyslog(LOG_DEBUG, \"PEER port port: \\t\\t %d\\n\", READNU16(buf + 24));\n}\n\nstatic void printPEEROpcodeVersion2(const uint8_t *buf)\n{\n\tchar ext_addr[INET6_ADDRSTRLEN];\n\tchar peer_addr[INET6_ADDRSTRLEN];\n\n\tsyslog(LOG_DEBUG, \"PCP PEER: v2 Opcode specific information.\");\n\tsyslog(LOG_DEBUG, \"nonce:        \\t%08x%08x%08x\",\n\t       READNU32(buf), READNU32(buf+4), READNU32(buf+8));\n\tsyslog(LOG_DEBUG, \"Protocol:     \\t%d\", buf[12]);\n\tsyslog(LOG_DEBUG, \"Internal port:\\t%d\", READNU16(buf + 16));\n\tsyslog(LOG_DEBUG, \"External IP:  \\t%s\", inet_ntop(AF_INET6, buf + 20,\n\t       ext_addr, INET6_ADDRSTRLEN));\n\tsyslog(LOG_DEBUG, \"External port:\\t%d\", READNU16(buf + 18));\n\tsyslog(LOG_DEBUG, \"PEER IP:      \\t%s\", inet_ntop(AF_INET6, buf + 40,\n\t       peer_addr, INET6_ADDRSTRLEN));\n\tsyslog(LOG_DEBUG, \"PEER port:    \\t%d\", READNU16(buf + 36));\n}\n#endif /* DEBUG */\n\n/*\n * Function extracting information from peer_buf to pcp_msg_info\n * @return : when no problem occurred 0 is returned, 1 otherwise\n */\nstatic void parsePCPPEER_version1(const uint8_t *buf,\n\t\tpcp_info_t *pcp_msg_info)\n{\n\tpcp_msg_info->is_peer_op = 1;\n\tpcp_msg_info->protocol = buf[0];\n\tpcp_msg_info->int_port = READNU16(buf + 4);\n\tpcp_msg_info->ext_port = READNU16(buf + 6);\n\tpcp_msg_info->peer_port = READNU16(buf + 24);\n\n\tpcp_msg_info->ext_ip = (struct in6_addr *)(buf + 8);\n\tpcp_msg_info->peer_ip = (struct in6_addr *)(buf + 28);\n}\n\n/*\n * Function extracting information from peer_buf to pcp_msg_info\n * @return : when no problem occurred 0 is returned, 1 otherwise\n */\nstatic void parsePCPPEER_version2(const uint8_t *buf, pcp_info_t *pcp_msg_info)\n{\n\tpcp_msg_info->is_peer_op = 1;\n\tmemcpy(pcp_msg_info->nonce, buf, 12);\n\tpcp_msg_info->protocol = buf[12];\n\tpcp_msg_info->int_port = READNU16(buf + 16);\n\tpcp_msg_info->ext_port = READNU16(buf + 18);\n\tpcp_msg_info->peer_port = READNU16(buf + 36);\n\n\tpcp_msg_info->ext_ip = (struct in6_addr *)(buf + 20);\n\tpcp_msg_info->peer_ip = (struct in6_addr *)(buf + 40);\n}\n#endif /* PCP_PEER */\n\n#ifdef PCP_SADSCP\n#ifdef DEBUG\nstatic void printSADSCPOpcode(const uint8_t *buf)\n{\n\tunsigned char sadscp_tol;\n\tsadscp_tol = buf[12];\t/* tolerance_fields */\n\n\tsyslog(LOG_DEBUG, \"PCP SADSCP: Opcode specific information.\\n\");\n\tsyslog(LOG_DEBUG, \"Delay tolerance %d \\n\", (sadscp_tol>>6)&3);\n\tsyslog(LOG_DEBUG, \"Loss tolerance %d \\n\",  (sadscp_tol>>4)&3);\n\tsyslog(LOG_DEBUG, \"Jitter tolerance %d \\n\",  (sadscp_tol>>2)&3);\n\tsyslog(LOG_DEBUG, \"RRR %d \\n\", sadscp_tol&3);\n\tsyslog(LOG_DEBUG, \"AppName Length %d \\n\", buf[13]);\n\tsyslog(LOG_DEBUG, \"Application name %.*s \\n\", buf[13], buf + 14);\n}\n#endif //DEBUG\n\nstatic int parseSADSCP(const uint8_t *buf, pcp_info_t *pcp_msg_info)\n{\n\tpcp_msg_info->delay_tolerance = (buf[12]>>6)&3;\n\tpcp_msg_info->loss_tolerance = (buf[12]>>4)&3;\n\tpcp_msg_info->jitter_tolerance = (buf[12]>>2)&3;\n\n\tif (pcp_msg_info->delay_tolerance == 3 ||\n\t    pcp_msg_info->loss_tolerance == 3 ||\n\t    pcp_msg_info->jitter_tolerance == 3 ) {\n\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\treturn 1;\n\t}\n\n\tpcp_msg_info->app_name = (const char *)(buf + 14);\n\tpcp_msg_info->app_name_len = buf[13];\n\n\treturn 0;\n}\n#endif\t/* PCP_SADSCP */\n\n\nstatic int parsePCPOption(uint8_t* pcp_buf, int remain, pcp_info_t *pcp_msg_info)\n{\n#ifdef DEBUG\n\tchar third_addr[INET6_ADDRSTRLEN];\n#endif /* DEBUG */\n\tunsigned short option_length;\n\n\t/* Do centralized option sanity checks here. */\n\n\tif (remain < (int)PCP_OPTION_HDR_SIZE) {\n\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\treturn 0;\n\t}\n\n\toption_length = READNU16(pcp_buf + 2) + 4;\t/* len */\n\n\tif (remain < option_length) {\n\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\treturn 0;\n\t}\n\n\tswitch (pcp_buf[0]) { /* code */\n\n\tcase PCP_OPTION_3RD_PARTY:\n\n\t\tif (option_length != PCP_3RD_PARTY_OPTION_SIZE) {\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\t\treturn 0;\n\t\t}\n#ifdef DEBUG\n\t\tsyslog(LOG_DEBUG, \"PCP OPTION: \\t Third party\\n\");\n\t\tsyslog(LOG_DEBUG, \"Third PARTY IP: \\t %s\\n\", inet_ntop(AF_INET6,\n\t\t       pcp_buf + 4, third_addr, INET6_ADDRSTRLEN));\n#endif\n\t\tif (pcp_msg_info->thirdp_ip ) {\n\t\t\tsyslog(LOG_ERR, \"PCP: THIRD PARTY OPTION was already present. \\n\");\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpcp_msg_info->thirdp_ip = (struct in6_addr *)(pcp_buf + 4);\n\t\t\tpcp_msg_info->mapped_ip = (struct in6_addr *)(pcp_buf + 4);\n\t\t}\n\t\tbreak;\n\n\tcase PCP_OPTION_PREF_FAIL:\n\n\t\tif (option_length != PCP_PREFER_FAIL_OPTION_SIZE) {\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\t\treturn 0;\n\t\t}\n#ifdef DEBUG\n\t\tsyslog(LOG_DEBUG, \"PCP OPTION: \\t Prefer failure \\n\");\n#endif\n\t\tif (pcp_msg_info->opcode != PCP_OPCODE_MAP) {\n\t\t\tsyslog(LOG_DEBUG, \"PCP: Unsupported OPTION for given OPCODE.\\n\");\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t}\n\t\tif (pcp_msg_info->pfailure_present != 0 ) {\n\t\t\tsyslog(LOG_DEBUG, \"PCP: PREFER FAILURE OPTION was already present.\\n\");\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\t} else {\n\t\t\tpcp_msg_info->pfailure_present = 1;\n\t\t}\n\t\tbreak;\n\n\tcase PCP_OPTION_FILTER:\n\t\t/* TODO fully implement filter */\n\t\tif (option_length != PCP_FILTER_OPTION_SIZE) {\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\t\treturn 0;\n\t\t}\n#ifdef DEBUG\n\t\tsyslog(LOG_DEBUG, \"PCP OPTION: \\t Filter\\n\");\n#endif\n\t\tif (pcp_msg_info->opcode != PCP_OPCODE_MAP) {\n\t\t\tsyslog(LOG_ERR, \"PCP: Unsupported OPTION for given OPCODE.\\n\");\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n#ifdef PCP_FLOWP\n\tcase PCP_OPTION_FLOW_PRIORITY:\n\n#ifdef DEBUG\n\t\tsyslog(LOG_DEBUG, \"PCP OPTION: \\t Flow priority\\n\");\n#endif\n\t\tif (option_length != PCP_FLOW_PRIORITY_OPTION_SIZE) {\n\t\t\tsyslog(LOG_ERR, \"PCP: Error processing DSCP. sizeof %d and remaining %d. flow len %d \\n\",\n\t\t\t       PCP_FLOW_PRIORITY_OPTION_SIZE, remain, READNU16(pcp_buf + 2));\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\t\treturn 0;\n\t\t}\n\n#ifdef DEBUG\n\t\tsyslog(LOG_DEBUG, \"DSCP UP: \\t %d\\n\", pcp_buf[4]);\n\t\tsyslog(LOG_DEBUG, \"DSCP DOWN: \\t %d\\n\", pcp_buf[5]);\n#endif\n\t\tpcp_msg_info->dscp_up = pcp_buf[4];\n\t\tpcp_msg_info->dscp_down = pcp_buf[5];\n\t\tpcp_msg_info->flowp_present = 1;\n\n\t\tbreak;\n#endif\n\tdefault:\n\t\tif (pcp_buf[0] < 128) {\n\t\t\tsyslog(LOG_ERR, \"PCP: Unrecognized mandatory PCP OPTION: %d \\n\", (int)pcp_buf[0]);\n\t\t\t/* Mandatory to understand */\n\t\t\tpcp_msg_info->result_code = PCP_ERR_UNSUPP_OPTION;\n\t\t\tremain = 0;\n\t\t\tbreak;\n\t\t}\n\t\t/* TODO - log optional not understood options? */\n\t\tbreak;\n\t}\n\treturn option_length;\n}\n\n\nstatic void parsePCPOptions(void* pcp_buf, int remain, pcp_info_t *pcp_msg_info)\n{\n\tint option_length;\n\n\twhile (remain > 0) {\n\t\toption_length = parsePCPOption(pcp_buf, remain, pcp_msg_info);\n\t\tif (!option_length)\n\t\t\tbreak;\n\t\tremain -= option_length;\n\t\tpcp_buf += option_length;\n\t}\n\tif (remain > 0) {\n\t\tsyslog(LOG_WARNING, \"%s: remain=%d\", \"parsePCPOptions\", remain);\n\t}\n}\n\n\n/* CheckExternalAddress()\n * Check that suggested external address in request match a real external\n * IP address.\n * Suggested address can also be 0 IPv4 or IPv6 address.\n *  (see http://tools.ietf.org/html/rfc6887#section-10 )\n * return values :\n *   0 : check is OK\n *  -1 : check failed */\nstatic int CheckExternalAddress(pcp_info_t* pcp_msg_info)\n{\n\t/* can contain a IPv4-mapped IPv6 address */\n\tstatic struct in6_addr external_addr;\n\tint af;\n\n\taf = IN6_IS_ADDR_V4MAPPED(pcp_msg_info->mapped_ip)\n\t\t? AF_INET : AF_INET6;\n\n\tpcp_msg_info->is_fw = af == AF_INET6;\n\n\tif (pcp_msg_info->is_fw) {\n\t\texternal_addr = *pcp_msg_info->mapped_ip;\n\t} else {\n\t\t/* TODO : be able to handle case with multiple\n\t\t * external addresses */\n\t\tif(use_ext_ip_addr) {\n\t\t\tif (inet_pton(AF_INET, use_ext_ip_addr,\n\t\t\t\t      ((uint32_t*)external_addr.s6_addr)+3) == 1) {\n\t\t\t\t((uint32_t*)external_addr.s6_addr)[0] = 0;\n\t\t\t\t((uint32_t*)external_addr.s6_addr)[1] = 0;\n\t\t\t\t((uint32_t*)external_addr.s6_addr)[2] = htonl(0xFFFF);\n\t\t\t} else if (inet_pton(AF_INET6, use_ext_ip_addr, external_addr.s6_addr)\n\t\t\t\t   != 1) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_NETWORK_FAILURE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tif(!ext_if_name || ext_if_name[0]=='\\0') {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_NETWORK_FAILURE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(getifaddr_in6(ext_if_name, af, &external_addr) < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_NETWORK_FAILURE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (pcp_msg_info->ext_ip == NULL ||\n\t    IN6_IS_ADDR_UNSPECIFIED(pcp_msg_info->ext_ip) ||\n\t    (IN6_IS_ADDR_V4MAPPED(pcp_msg_info->ext_ip)\n\t      && ((uint32_t *)pcp_msg_info->ext_ip->s6_addr)[3] == INADDR_ANY)) {\n\t\t/* no suggested external address : use real external address */\n\t\tpcp_msg_info->ext_ip = &external_addr;\n\t\treturn 0;\n\t}\n\n\tif (!IN6_ARE_ADDR_EQUAL(pcp_msg_info->ext_ip, &external_addr)) {\n\t\tsyslog(LOG_ERR,\n\t\t       \"PCP: External IP in request didn't match interface IP \\n\");\n#ifdef DEBUG\n\t\t{\n\t\t\tchar s[INET6_ADDRSTRLEN];\n\t\t\tsyslog(LOG_DEBUG, \"Interface IP %s \\n\",\n\t\t\t       inet_ntop(AF_INET6, &external_addr.s6_addr, s, sizeof(s)));\n\t\t\tsyslog(LOG_DEBUG, \"IP in the PCP request %s \\n\",\n\t\t\t       inet_ntop(AF_INET6, pcp_msg_info->ext_ip, s, sizeof(s)));\n\t\t}\n#endif\n\n\t\tif (pcp_msg_info->pfailure_present) {\n\t\t\tpcp_msg_info->result_code = PCP_ERR_CANNOT_PROVIDE_EXTERNAL;\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tpcp_msg_info->ext_ip = &external_addr;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\n\nstatic const char* inet_n46top(const struct in6_addr* in,\n\t\t\t       char* buf, size_t buf_len)\n{\n\tif (IN6_IS_ADDR_V4MAPPED(in)) {\n\t\treturn inet_ntop(AF_INET, ((uint32_t*)(in->s6_addr))+3, buf, buf_len);\n\t} else {\n\t\treturn inet_ntop(AF_INET6, in, buf, buf_len);\n\t}\n}\n\n#ifdef PCP_PEER\nstatic void FillSA(struct sockaddr *sa, const struct in6_addr *in6,\n\t\tuint16_t port)\n{\n\tif (IN6_IS_ADDR_V4MAPPED(in6)) {\n\t\tstruct sockaddr_in *sa4 = (struct sockaddr_in *)sa;\n\t\tsa4->sin_family = AF_INET;\n\t\tsa4->sin_addr.s_addr = ((uint32_t*)(in6)->s6_addr)[3];\n\t\tsa4->sin_port = htons(port);\n\t} else {\n\t\tstruct sockaddr_in6 *sa6 = (struct sockaddr_in6 *)sa;\n\t\tsa6->sin6_family = AF_INET6;\n\t\tsa6->sin6_addr = *in6;\n\t\tsa6->sin6_port = htons(port);\n\t}\n}\n\nstatic const char* inet_satop(struct sockaddr* sa, char* buf, size_t buf_len)\n{\n\tif (sa->sa_family == AF_INET) {\n\t\treturn inet_ntop(AF_INET, &(((struct sockaddr_in*)sa)->sin_addr), buf, buf_len);\n\t} else {\n\t\treturn inet_ntop(AF_INET6, &(((struct sockaddr_in6*)sa)->sin6_addr), buf, buf_len);\n\t}\n}\n\nstatic int CreatePCPPeer_NAT(pcp_info_t *pcp_msg_info)\n{\n\tstruct sockaddr_storage intip;\n\tstruct sockaddr_storage peerip;\n\tstruct sockaddr_storage extip;\n\tstruct sockaddr_storage ret_extip;\n\n\tuint8_t  proto = pcp_msg_info->protocol;\n\n\tuint16_t eport = pcp_msg_info->ext_port;  /* public port */\n\n\tchar peerip_s[INET6_ADDRSTRLEN], extip_s[INET6_ADDRSTRLEN];\n\ttime_t timestamp = upnp_time() + pcp_msg_info->lifetime;\n\tint r;\n\n\tFillSA((struct sockaddr*)&intip, pcp_msg_info->mapped_ip,\n\t       pcp_msg_info->int_port);\n\tFillSA((struct sockaddr*)&peerip, pcp_msg_info->peer_ip,\n\t       pcp_msg_info->peer_port);\n\tFillSA((struct sockaddr*)&extip, pcp_msg_info->ext_ip,\n\t       eport);\n\n\tinet_satop((struct sockaddr*)&peerip, peerip_s, sizeof(peerip_s));\n\tinet_satop((struct sockaddr*)&extip, extip_s, sizeof(extip_s));\n\n\t/* check if connection with given peer exists, if it was */\n\t/* already established use this external port */\n\tif (get_nat_ext_addr( (struct sockaddr*)&intip, (struct sockaddr*)&peerip,\n\t\t\t      proto, (struct sockaddr*)&ret_extip) == 1) {\n\t\tif (ret_extip.ss_family == AF_INET) {\n\t\t\tstruct sockaddr_in* ret_ext4 = (struct sockaddr_in*)&ret_extip;\n\t\t\tuint16_t ret_eport = ntohs(ret_ext4->sin_port);\n\t\t\teport = ret_eport;\n\t\t} else if (ret_extip.ss_family == AF_INET6) {\n\t\t\tstruct sockaddr_in6* ret_ext6 = (struct sockaddr_in6*)&ret_extip;\n\t\t\tuint16_t ret_eport = ntohs(ret_ext6->sin6_port);\n\t\t\teport = ret_eport;\n\t\t} else {\n\t\t\treturn PCP_ERR_CANNOT_PROVIDE_EXTERNAL;\n\t\t}\n\t}\n\t/* Create Peer Mapping */\n\tif (eport == 0) {\n\t\teport = pcp_msg_info->int_port;\n\t}\n\n#ifdef PCP_FLOWP\n\tif (pcp_msg_info->flowp_present && pcp_msg_info->dscp_up) {\n\t\tif (add_peer_dscp_rule2(ext_if_name, peerip_s,\n\t\t\t\t\tpcp_msg_info->peer_port, pcp_msg_info->dscp_up,\n\t\t\t\t\tpcp_msg_info->mapped_str, pcp_msg_info->int_port,\n\t\t\t\t\tproto, pcp_msg_info->desc, timestamp) < 0 ) {\n\t\t\tsyslog(LOG_ERR, \"PCP: failed to add flowp upstream mapping %s:%hu->%s:%hu '%s'\",\n\t\t\t       pcp_msg_info->mapped_str,\n\t\t\t       pcp_msg_info->int_port,\n\t\t\t       peerip_s,\n\t\t\t       pcp_msg_info->peer_port,\n\t\t\t       pcp_msg_info->desc);\n\t\t\treturn PCP_ERR_NO_RESOURCES;\n\t\t}\n\t}\n\n\tif (pcp_msg_info->flowp_present && pcp_msg_info->dscp_down) {\n\t\tif (add_peer_dscp_rule2(ext_if_name,  pcp_msg_info->mapped_str,\n\t\t\t\t\tpcp_msg_info->int_port, pcp_msg_info->dscp_down,\n\t\t\t\t\tpeerip_s, pcp_msg_info->peer_port, proto, pcp_msg_info->desc, timestamp)\n\t\t    < 0 ) {\n\t\t\tsyslog(LOG_ERR, \"PCP: failed to add flowp downstream mapping %s:%hu->%s:%hu '%s'\",\n\t\t\t       pcp_msg_info->mapped_str,\n\t\t\t       pcp_msg_info->int_port,\n\t\t\t       peerip_s,\n\t\t\t       pcp_msg_info->peer_port,\n\t\t\t       pcp_msg_info->desc);\n\t\t\tpcp_msg_info->result_code = PCP_ERR_NO_RESOURCES;\n\t\t\treturn PCP_ERR_NO_RESOURCES;\n\t\t}\n\t}\n#endif\n\n\tr = add_peer_redirect_rule2(ext_if_name,\n\t\t\t\t    peerip_s,\n\t\t\t\t    pcp_msg_info->peer_port,\n\t\t\t\t    extip_s,\n\t\t\t\t    eport,\n\t\t\t\t    pcp_msg_info->mapped_str,\n\t\t\t\t    pcp_msg_info->int_port,\n\t\t\t\t    pcp_msg_info->protocol,\n\t\t\t\t    pcp_msg_info->desc,\n\t\t\t\t    timestamp);\n\tif (r < 0)\n\t\treturn PCP_ERR_NO_RESOURCES;\n\tpcp_msg_info->ext_port = eport;\n\treturn PCP_SUCCESS;\n}\n\nstatic void CreatePCPPeer(pcp_info_t *pcp_msg_info)\n{\n\tchar peerip_s[INET6_ADDRSTRLEN];\n\tint r = -1;\n\n\tif (!inet_n46top(pcp_msg_info->peer_ip, peerip_s, sizeof(peerip_s))) {\n\t\tsyslog(LOG_ERR, \"inet_n46top(peer_ip): %m\");\n\t\treturn;\n\t}\n\n\tif (pcp_msg_info->is_fw) {\n#if 0\n\t\t/* Someday, something like this is available.. and we're ready! */\n#ifdef ENABLE_UPNPPINHOLE\n\t\tpcp_msg_info->ext_port = pcp_msg_info->int_port;\n\t\tr = upnp_add_outbound_pinhole(peerip_s,\n\t\t\t\t\t      pcp_msg_info->peer_port,\n\t\t\t\t\t      pcp_msg_info->mapped_str,\n\t\t\t\t\t      pcp_msg_info->int_port,\n\t\t\t\t\t      pcp_msg_info->protocol,\n\t\t\t\t\t      pcp_msg_info->desc,\n\t\t\t\t\t      pcp_msg_info->lifetime, NULL);\n#endif /* ENABLE_UPNPPINHOLE */\n#else\n\t\tr = PCP_ERR_UNSUPP_OPCODE;\n#endif /* 0 */\n\t} else {\n\t\tr = CreatePCPPeer_NAT(pcp_msg_info);\n\t}\n\t/* TODO: add upnp function for PI */\n\tpcp_msg_info->result_code = r;\n\tsyslog(r == PCP_SUCCESS ? LOG_INFO : LOG_ERR,\n\t       \"PCP PEER: %s peer mapping %s %s:%hu(%hu)->%s:%hu '%s'\",\n\t       r == PCP_SUCCESS ? \"added\" : \"failed to add\",\n\t       (pcp_msg_info->protocol==IPPROTO_TCP)?\"TCP\":\"UDP\",\n\t       pcp_msg_info->mapped_str,\n\t       pcp_msg_info->int_port,\n\t       pcp_msg_info->ext_port,\n\t       peerip_s,\n\t       pcp_msg_info->peer_port,\n\t       pcp_msg_info->desc);\n}\n\nstatic void DeletePCPPeer(pcp_info_t *pcp_msg_info)\n{\n\tuint16_t iport = pcp_msg_info->int_port;  /* private port */\n\tuint16_t rport = pcp_msg_info->peer_port;  /* private port */\n\tuint8_t  proto = pcp_msg_info->protocol;\n\tchar rhost[INET6_ADDRSTRLEN];\n\tint r = -1;\n\n\t/* remove requested mappings for this client */\n\tint index = 0;\n\tunsigned short eport2, iport2, rport2;\n\tchar iaddr2[INET6_ADDRSTRLEN], rhost2[INET6_ADDRSTRLEN];\n\tint proto2;\n\tchar desc[64];\n\tunsigned int timestamp;\n#if 0\n\tint uid;\n#endif /* 0 */\n\n\tif (pcp_msg_info->is_fw) {\n\t\tpcp_msg_info->result_code = PCP_ERR_UNSUPP_OPCODE;\n\t\treturn;\n\t}\n\n\tinet_n46top((struct in6_addr*)pcp_msg_info->peer_ip, rhost, sizeof(rhost));\n\n\tfor (index = 0 ;\n\t     (!pcp_msg_info->is_fw &&\n\t      get_peer_rule_by_index(index, 0,\n\t\t\t\t     &eport2, iaddr2, sizeof(iaddr2),\n\t\t\t\t     &iport2, &proto2,\n\t\t\t\t     desc, sizeof(desc),\n\t\t\t\t     rhost2, sizeof(rhost2), &rport2,\n\t\t\t\t     &timestamp, 0, 0) >= 0)\n#if 0\n\t\t     /* Some day if outbound pinholes are supported.. */\n\t\t     ||\n\t\t     (pcp_msg_info->is_fw &&\n\t\t      (uid=upnp_get_pinhole_uid_by_index(index))>=0 &&\n\t\t      upnp_get_pinhole_info((unsigned short)uid,\n\t\t\t\t\t    rhost2, sizeof(rhost2), &rport2,\n\t\t\t\t\t    iaddr2, sizeof(iaddr2), &iport2,\n\t\t\t\t\t    &proto2, desc, sizeof(desc),\n\t\t\t\t\t    &timestamp, NULL) >= 0)\n#endif /* 0 */\n\t\t     ;\n\t     index++)\n\t\tif((0 == strcmp(iaddr2, pcp_msg_info->mapped_str))\n\t\t   && (0 == strcmp(rhost2, rhost))\n\t\t   && (proto2==proto)\n\t\t   && 0 == strcmp(desc, pcp_msg_info->desc)\n\t\t   && (iport2==iport) && (rport2==rport)) {\n\t\t\tif (!pcp_msg_info->is_fw)\n\t\t\t\tr = _upnp_delete_redir(eport2, proto2);\n#if 0\n\t\t\telse\n\t\t\t\tr = upnp_delete_outboundpinhole(uid);\n#endif /* 0 */\n\t\t\tif(r<0) {\n\t\t\t\tsyslog(LOG_ERR, \"PCP PEER: failed to remove peer mapping\");\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_INFO, \"PCP PEER: %s port %hu peer mapping removed\",\n\t\t\t\t       proto2==IPPROTO_TCP?\"TCP\":\"UDP\", eport2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\tif (r==-1) {\n\t\tsyslog(LOG_ERR, \"PCP PEER: Failed to find PCP mapping internal port %hu, protocol %s\",\n\t\t       iport, (pcp_msg_info->protocol == IPPROTO_TCP)?\"TCP\":\"UDP\");\n\t\tpcp_msg_info->result_code = PCP_ERR_NO_RESOURCES;\n\t}\n}\n#endif /* PCP_PEER */\n\nstatic int CreatePCPMap_NAT(pcp_info_t *pcp_msg_info)\n{\n\tint r = 0;\n\tchar iaddr_old[INET6_ADDRSTRLEN];\n\tuint16_t iport_old, eport_first = 0;\n\tint any_eport_allowed = 0;\n\tunsigned int timestamp = upnp_time() + pcp_msg_info->lifetime;\n\n\tif (pcp_msg_info->ext_port == 0) {\n\t\tpcp_msg_info->ext_port = pcp_msg_info->int_port;\n\t}\n\n\t/* TODO: Support non-TCP/UDP */\n\tif (pcp_msg_info->ext_port == 0) {\n\t\treturn PCP_ERR_MALFORMED_REQUEST;\n\t}\n\n\tdo {\n\t\tif (eport_first == 0) { /* first time in loop */\n\t\t\teport_first = pcp_msg_info->ext_port;\n\t\t} else if (pcp_msg_info->ext_port == eport_first) { /* no eport available */\n                        /* all eports rejected by permissions? */\n\t\t\tif (any_eport_allowed == 0)\n\t\t\t\treturn PCP_ERR_NOT_AUTHORIZED;\n\t\t\t/* at least one eport allowed (but none available) */\n\t\t\treturn PCP_ERR_NO_RESOURCES;\n\t\t}\n\t\tif ((IN6_IS_ADDR_V4MAPPED(pcp_msg_info->mapped_ip) &&\n\t\t     (!check_upnp_rule_against_permissions(upnppermlist,\n\t\t\t\t\t\t\t   num_upnpperm, pcp_msg_info->ext_port,\n\t\t\t\t\t\t\t   ((struct in_addr*)pcp_msg_info->mapped_ip->s6_addr)[3],\n\t\t\t\t\t\t\t   pcp_msg_info->int_port)))) {\n\t\t\tif (pcp_msg_info->pfailure_present) {\n\t\t\t\treturn PCP_ERR_CANNOT_PROVIDE_EXTERNAL;\n\t\t\t}\n\t\t\tpcp_msg_info->ext_port++;\n\t\t\tif (pcp_msg_info->ext_port == 0) { /* skip port zero */\n\t\t\t\tpcp_msg_info->ext_port++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tany_eport_allowed = 1;\n#ifdef CHECK_PORTINUSE\n\t\tif (port_in_use(ext_if_name, pcp_msg_info->ext_port, pcp_msg_info->protocol,\n\t\t\t\tpcp_msg_info->mapped_str, pcp_msg_info->int_port) > 0) {\n\t\t\tsyslog(LOG_INFO, \"port %hu protocol %s already in use\",\n\t\t\t       pcp_msg_info->ext_port,\n\t\t\t       (pcp_msg_info->protocol==IPPROTO_TCP)?\"tcp\":\"udp\");\n\t\t\tpcp_msg_info->ext_port++;\n\t\t\tif (pcp_msg_info->ext_port == 0) { /* skip port zero */\n\t\t\t\tpcp_msg_info->ext_port++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tr = get_redirect_rule(ext_if_name,\n\t\t\t\t      pcp_msg_info->ext_port,\n\t\t\t\t      pcp_msg_info->protocol,\n\t\t\t\t      iaddr_old, sizeof(iaddr_old),\n\t\t\t\t      &iport_old, 0, 0, 0, 0,\n\t\t\t\t      NULL/*&timestamp*/, 0, 0);\n\n\t\tif(r==0) {\n\t\t\tif((strcmp(pcp_msg_info->mapped_str, iaddr_old)!=0)\n\t\t\t   || (pcp_msg_info->int_port != iport_old)) {\n\t\t\t\t/* redirection already existing */\n\t\t\t\tif (pcp_msg_info->pfailure_present) {\n\t\t\t\t\treturn PCP_ERR_CANNOT_PROVIDE_EXTERNAL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_INFO, \"port %hu %s already redirected to %s:%hu, replacing\",\n\t\t\t\t       pcp_msg_info->ext_port, (pcp_msg_info->protocol==IPPROTO_TCP)?\"tcp\":\"udp\",\n\t\t\t\t       iaddr_old, iport_old);\n\t\t\t\t/* remove and then add again */\n\t\t\t\tif (_upnp_delete_redir(pcp_msg_info->ext_port,\n\t\t\t\t\t\t       pcp_msg_info->protocol)==0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (pcp_msg_info->pfailure_present) {\n\t\t\t\t\treturn PCP_ERR_CANNOT_PROVIDE_EXTERNAL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpcp_msg_info->ext_port++;\n\t\t\tif (pcp_msg_info->ext_port == 0) { /* skip port zero */\n\t\t\t\tpcp_msg_info->ext_port++;\n\t\t\t}\n\t\t}\n\t} while (r==0);\n\n\tr = upnp_redirect_internal(NULL,\n\t\t\t\t   pcp_msg_info->ext_port,\n\t\t\t\t   pcp_msg_info->mapped_str,\n\t\t\t\t   pcp_msg_info->int_port,\n\t\t\t\t   pcp_msg_info->protocol,\n\t\t\t\t   pcp_msg_info->desc,\n\t\t\t\t   timestamp);\n\tif (r < 0)\n\t\treturn PCP_ERR_NO_RESOURCES;\n\treturn PCP_SUCCESS;\n}\n\nstatic int CreatePCPMap_FW(pcp_info_t *pcp_msg_info)\n{\n#ifdef ENABLE_UPNPPINHOLE\n\tint uid;\n\tint r;\n\t/* first check if pinhole already exists */\n\tuid = upnp_find_inboundpinhole(NULL, 0,\n\t\t\t\t\tpcp_msg_info->mapped_str,\n\t\t\t\t\tpcp_msg_info->int_port,\n\t\t\t\t\tpcp_msg_info->protocol,\n\t\t\t\t\tNULL, 0, /* desc */\n\t\t\t\t\tNULL /* lifetime */);\n\tif(uid >= 0) {\n\t\t/* pinhole already exists, updating */\n\t\tsyslog(LOG_INFO, \"updating pinhole to %s:%hu %s\",\n\t\t       pcp_msg_info->mapped_str, pcp_msg_info->int_port,\n\t\t       (pcp_msg_info->protocol == IPPROTO_TCP)?\"TCP\":\"UDP\");\n\t\tr = upnp_update_inboundpinhole((unsigned short)uid, pcp_msg_info->lifetime);\n\t\treturn r >= 0 ? PCP_SUCCESS : PCP_ERR_NO_RESOURCES;\n\t} else {\n\t\tr = upnp_add_inboundpinhole(NULL, 0,\n\t\t\t\t\t\tpcp_msg_info->mapped_str,\n\t\t\t\t\t\tpcp_msg_info->int_port,\n\t\t\t\t\t\tpcp_msg_info->protocol,\n\t\t\t\t\t\tpcp_msg_info->desc,\n\t\t\t\t\t\tpcp_msg_info->lifetime,\n\t\t\t\t\t\t&uid);\n\t\tif (r < 0)\n\t\t\treturn PCP_ERR_NO_RESOURCES;\n\t\tpcp_msg_info->ext_port = pcp_msg_info->int_port;\n\t\treturn PCP_SUCCESS;\n\t}\n#else\n\tUNUSED(pcp_msg_info);\n\treturn PCP_ERR_NO_RESOURCES;\n#endif /* ENABLE_UPNPPINHOLE */\n}\n\n\n/*                internal  external  PCP remote peer  actual remote peer\n *                --------  -------   ---------------  ------------------\n * IPv4 firewall   IPv4      IPv4         IPv4              IPv4\n * IPv6 firewall   IPv6      IPv6         IPv6              IPv6\n *         NAT44   IPv4      IPv4         IPv4              IPv4\n *         NAT46   IPv4      IPv6         IPv4              IPv6\n *         NAT64   IPv6      IPv4         IPv6              IPv4\n *         NPTv6   IPv6      IPv6         IPv6              IPv6\n *\n *             Address Families with MAP and PEER\n *\n * The 'internal' address is implicitly the same as the source IP\n * address of the PCP request, except when the THIRD_PARTY option is\n * used.\n *\n * The 'external' address is the Suggested External Address field of the\n * MAP or PEER request, and its address family is usually the same as\n * the 'internal' address family, except when technologies like NAT64\n * are used.\n *\n * The 'remote peer' address is the remote peer IP address of the PEER\n * request or the FILTER option of the MAP request, and is always the\n * same address family as the 'internal' address, even when NAT64 is\n * used.  In NAT64, the IPv6 PCP client is not necessarily aware of the\n * NAT64 or aware of the actual IPv4 address of the remote peer, so it\n * expresses the IPv6 address from its perspective.     */\n\n/* TODO: Support more than basic NAT44 / IPv6 firewall cases. */\nstatic void CreatePCPMap(pcp_info_t *pcp_msg_info)\n{\n\tint r;\n\n\tif (pcp_msg_info->is_fw)\n\t\tr = CreatePCPMap_FW(pcp_msg_info);\n\telse\n\t\tr = CreatePCPMap_NAT(pcp_msg_info);\n\tpcp_msg_info->result_code = r;\n\tsyslog(r == PCP_SUCCESS ? LOG_INFO : LOG_ERR,\n\t      \"PCP MAP: %s mapping %s %hu->%s:%hu '%s'\",\n\t       r == PCP_SUCCESS ? \"added\" : \"failed to add\",\n\t       (pcp_msg_info->protocol==IPPROTO_TCP)?\"TCP\":\"UDP\",\n\t       pcp_msg_info->ext_port,\n\t       pcp_msg_info->mapped_str,\n\t       pcp_msg_info->int_port,\n\t       pcp_msg_info->desc);\n}\n\nstatic void DeletePCPMap(pcp_info_t *pcp_msg_info)\n{\n\tuint16_t iport = pcp_msg_info->int_port;  /* private port */\n\tuint8_t  proto = pcp_msg_info->protocol;\n\tint r=-1;\n\t/* remove the mapping */\n\t/* remove all the mappings for this client */\n\tint index;\n\tunsigned short eport2, iport2;\n\tchar iaddr2[INET6_ADDRSTRLEN];\n\tint proto2;\n\tchar desc[64];\n\tunsigned int timestamp;\n#ifdef ENABLE_UPNPPINHOLE\n\tint uid = -1;\n#endif /* ENABLE_UPNPPINHOLE */\n\n\t/* iterate through all rules and delete the requested ones */\n\tfor (index = 0 ;\n\t     (!pcp_msg_info->is_fw &&\n\t      get_redirect_rule_by_index(index, 0,\n\t\t\t\t\t &eport2, iaddr2, sizeof(iaddr2),\n\t\t\t\t\t &iport2, &proto2,\n\t\t\t\t\t desc, sizeof(desc),\n\t\t\t\t\t 0, 0, &timestamp, 0, 0) >= 0)\n#ifdef ENABLE_UPNPPINHOLE\n\t       ||\n\t     (pcp_msg_info->is_fw &&\n\t      (uid=upnp_get_pinhole_uid_by_index(index))>=0 &&\n\t      upnp_get_pinhole_info((unsigned short)uid,\n\t\t\t\t    NULL, 0, NULL,\n\t\t\t\t    iaddr2, sizeof(iaddr2), &iport2,\n\t\t\t\t    &proto2, desc, sizeof(desc),\n\t\t\t\t    &timestamp, NULL) >= 0)\n#endif /* ENABLE_UPNPPINHOLE */\n\t\t     ;\n\t     index++)\n\t\tif(0 == strcmp(iaddr2, pcp_msg_info->mapped_str)\n\t\t   && (proto2==proto)\n\t\t   && ((iport2==iport) || (iport==0))) {\n\t\t\tif(0 != strcmp(desc, pcp_msg_info->desc)) {\n\t\t\t\t/* nonce does not match */\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_NOT_AUTHORIZED;\n\t\t\t\tsyslog(LOG_ERR, \"Unauthorized to remove PCP mapping internal port %hu, protocol %s\",\n\t\t\t\t       iport, (pcp_msg_info->protocol == IPPROTO_TCP)?\"TCP\":\"UDP\");\n\t\t\t\treturn;\n\t\t\t} else if (!pcp_msg_info->is_fw) {\n\t\t\t\tr = _upnp_delete_redir(eport2, proto2);\n\t\t\t} else {\n#ifdef ENABLE_UPNPPINHOLE\n\t\t\t\tr = upnp_delete_inboundpinhole(uid);\n#endif /* ENABLE_UPNPPINHOLE */\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tif (r >= 0) {\n\t\tsyslog(LOG_INFO, \"PCP: %s port %hu mapping removed\",\n\t\t       proto2==IPPROTO_TCP?\"TCP\":\"UDP\", eport2);\n\t} else {\n\t\tsyslog(LOG_ERR, \"Failed to remove PCP mapping internal port %hu, protocol %s\",\n\t\t       iport, (pcp_msg_info->protocol == IPPROTO_TCP)?\"TCP\":\"UDP\");\n\t\tpcp_msg_info->result_code = PCP_ERR_NO_RESOURCES;\n\t}\n}\n\nstatic int ValidatePCPMsg(pcp_info_t *pcp_msg_info)\n{\n\tif (pcp_msg_info->result_code) {\n\t\treturn 0;\n\t}\n\n\t/* RFC 6887, section 8.2: MUST return address mismatch if NAT\n\t * in middle. */\n\tif (memcmp(pcp_msg_info->int_ip,\n\t\t   &pcp_msg_info->sender_ip,\n\t\t   sizeof(pcp_msg_info->sender_ip)) != 0) {\n\t\tpcp_msg_info->result_code = PCP_ERR_ADDRESS_MISMATCH;\n\t\treturn 0;\n\t}\n\n\tif (pcp_msg_info->thirdp_ip) {\n\t\tif (!GETFLAG(PCP_ALLOWTHIRDPARTYMASK)) {\n\t\t\tpcp_msg_info->result_code = PCP_ERR_UNSUPP_OPTION;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* RFC687, section 13.1 - if sender ip == THIRD_PARTY,\n\t\t * it's an error. */\n\t\tif (memcmp(pcp_msg_info->thirdp_ip,\n\t\t\t   &pcp_msg_info->sender_ip,\n\t\t\t   sizeof(pcp_msg_info->sender_ip)) == 0) {\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Produce mapped_str for future use. */\n\tif (!inet_n46top(pcp_msg_info->mapped_ip, pcp_msg_info->mapped_str,\n\t\t         sizeof(pcp_msg_info->mapped_str))) {\n\t\tsyslog(LOG_ERR, \"inet_ntop(pcpserver): %m\");\n\t\treturn 0;\n\t}\n\n\t/* protocol zero means 'all protocols' : internal port MUST be zero */\n\tif (pcp_msg_info->protocol == 0 && pcp_msg_info->int_port != 0) {\n\t\tsyslog(LOG_ERR, \"PCP %s: Protocol was ZERO, but internal port \"\n\t\t       \"has non-ZERO value.\", getPCPOpCodeStr(pcp_msg_info->opcode));\n\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\treturn 0;\n\t}\n\n\tif (pcp_msg_info->pfailure_present) {\n\t\tif ( (IN6_IS_ADDR_UNSPECIFIED(pcp_msg_info->ext_ip) ||\n\t\t      ((IN6_IS_ADDR_V4MAPPED(pcp_msg_info->ext_ip)) &&\n\t\t       (((uint32_t*)pcp_msg_info->ext_ip->s6_addr)[3] == 0))) &&\n\t\t     (pcp_msg_info->ext_port == 0)\n\t\t   )\n\t\t{\n\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (CheckExternalAddress(pcp_msg_info)) {\n\t\treturn 0;\n\t}\n\n\t/* Fill in the desc that describes uniquely what flow we're\n\t * dealing with (same code used in both create + delete of\n\t * MAP/PEER) */\n\tswitch (pcp_msg_info->opcode) {\n\tcase PCP_OPCODE_MAP:\n\tcase PCP_OPCODE_PEER:\n\t\tsnprintf(pcp_msg_info->desc, sizeof(pcp_msg_info->desc),\n\t\t\t \"PCP %s %08x%08x%08x\",\n\t\t\t getPCPOpCodeStr(pcp_msg_info->opcode),\n\t\t\t pcp_msg_info->nonce[0],\n\t\t\t pcp_msg_info->nonce[1], pcp_msg_info->nonce[2]);\n\t\tbreak;\n\t}\n\treturn 1;\n}\n\n/*\n * return value indicates whether the request is valid or not.\n * Based on the return value simple response can be formed.\n */\nstatic int processPCPRequest(void * req, int req_size, pcp_info_t *pcp_msg_info)\n{\n\tint remainingSize;\n\n\t/* start with PCP_SUCCESS as result code,\n\t * if everything is OK value will be unchanged */\n\tpcp_msg_info->result_code = PCP_SUCCESS;\n\n\tremainingSize = req_size;\n\n\t/* discard request that exceeds maximal length,\n\t   or that is shorter than PCP_MIN_LEN (=24)\n\t   or that is not the multiple of 4 */\n\tif (req_size < 3)\n\t\treturn 0; /* ignore msg */\n\n\tif (req_size < PCP_MIN_LEN) {\n\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\treturn 1; /* send response */\n\t}\n\n\tif ( (req_size > PCP_MAX_LEN) || ( (req_size & 3) != 0)) {\n\t\tsyslog(LOG_ERR, \"PCP: Size of PCP packet(%d) is larger than %d bytes or \"\n\t\t       \"the size is not multiple of 4.\\n\", req_size, PCP_MAX_LEN);\n\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\treturn 1; /* send response */\n\t}\n\n\t/* first parse request header */\n\tif (parseCommonRequestHeader(req, pcp_msg_info) ) {\n\t\treturn 1;\n\t}\n\n\tremainingSize -= PCP_COMMON_REQUEST_SIZE;\n\treq += PCP_COMMON_REQUEST_SIZE;\n\n\tif (pcp_msg_info->version == 1) {\n\t\t/* legacy PCP version 1 support */\n\t\tswitch (pcp_msg_info->opcode) {\n\t\tcase PCP_OPCODE_MAP:\n\n\t\t\tremainingSize -= PCP_MAP_V1_SIZE;\n\t\t\tif (remainingSize < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tprintMAPOpcodeVersion1(req);\n#endif /* DEBUG */\n\t\t\tparsePCPMAP_version1(req, pcp_msg_info);\n\n\t\t\treq += PCP_MAP_V1_SIZE;\n\n\t\t\tparsePCPOptions(req, remainingSize, pcp_msg_info);\n\t\t\tif (ValidatePCPMsg(pcp_msg_info)) {\n\t\t\t\tif (pcp_msg_info->lifetime == 0) {\n\t\t\t\t\tDeletePCPMap(pcp_msg_info);\n\t\t\t\t} else {\n\t\t\t\t\tCreatePCPMap(pcp_msg_info);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_ERR, \"PCP: Invalid PCP v1 MAP message.\");\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\t\t\tbreak;\n\n#ifdef PCP_PEER\n\t\tcase PCP_OPCODE_PEER:\n\n\t\t\tremainingSize -= PCP_PEER_V1_SIZE;\n\t\t\tif (remainingSize < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tprintPEEROpcodeVersion1(req);\n#endif /* DEBUG */\n\t\t\tparsePCPPEER_version1(req, pcp_msg_info);\n\n\t\t\treq += PCP_PEER_V1_SIZE;\n\n\t\t\tparsePCPOptions(req, remainingSize, pcp_msg_info);\n\n\t\t\tif (ValidatePCPMsg(pcp_msg_info)) {\n\t\t\t\tif (pcp_msg_info->lifetime == 0) {\n\t\t\t\t\tDeletePCPPeer(pcp_msg_info);\n\t\t\t\t} else {\n\t\t\t\t\tCreatePCPPeer(pcp_msg_info);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_ERR, \"PCP: Invalid PCP v1 PEER message.\");\n\t\t\t\t return pcp_msg_info->result_code;\n\t\t\t}\n\n\n\t\t\tbreak;\n#endif /* PCP_PEER */\n\t\tdefault:\n\t\t\tpcp_msg_info->result_code = PCP_ERR_UNSUPP_OPCODE;\n\t\t\tbreak;\n\t\t}\n\n\t} else if (pcp_msg_info->version == 2) {\n\t\t/* RFC 6887 PCP support\n\t\t * http://tools.ietf.org/html/rfc6887 */\n\t\tswitch (pcp_msg_info->opcode) {\n\t\tcase PCP_OPCODE_ANNOUNCE:\n\t\t\t/* should check PCP Client's IP Address in request */\n\t\t\t/* see http://tools.ietf.org/html/rfc6887#section-14.1 */\n\t\t\tbreak;\n\t\tcase PCP_OPCODE_MAP:\n\n\t\t\tremainingSize -= PCP_MAP_V2_SIZE;\n\t\t\tif (remainingSize < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tprintMAPOpcodeVersion2(req);\n#endif /* DEBUG */\n\t\t\tparsePCPMAP_version2(req, pcp_msg_info);\n\t\t\treq += PCP_MAP_V2_SIZE;\n\n\t\t\tparsePCPOptions(req, remainingSize, pcp_msg_info);\n\n\t\t\tif (ValidatePCPMsg(pcp_msg_info)) {\n\t\t\t\tif (pcp_msg_info->lifetime == 0) {\n\t\t\t\t\tDeletePCPMap(pcp_msg_info);\n\t\t\t\t} else {\n\t\t\t\t\tCreatePCPMap(pcp_msg_info);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_ERR, \"PCP: Invalid PCP v2 MAP message.\");\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n\n\t\t\tbreak;\n\n#ifdef PCP_PEER\n\t\tcase PCP_OPCODE_PEER:\n\n\t\t\tremainingSize -= PCP_PEER_V2_SIZE;\n\t\t\tif (remainingSize < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tprintPEEROpcodeVersion2(req);\n#endif /* DEBUG */\n\t\t\tparsePCPPEER_version2(req, pcp_msg_info);\n\t\t\treq += PCP_PEER_V2_SIZE;\n\n\t\t\tif (pcp_msg_info->result_code != 0) {\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n\t\t\tparsePCPOptions(req, remainingSize, pcp_msg_info);\n\n\t\t\tif (ValidatePCPMsg(pcp_msg_info)) {\n\t\t\t\tif (pcp_msg_info->lifetime == 0) {\n\t\t\t\t\tDeletePCPPeer(pcp_msg_info);\n\t\t\t\t} else {\n\t\t\t\t\tCreatePCPPeer(pcp_msg_info);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_ERR, \"PCP: Invalid PCP v2 PEER message.\");\n\t\t\t}\n\n\t\tbreak;\n#endif /* PCP_PEER */\n\n#ifdef PCP_SADSCP\n\t\tcase PCP_OPCODE_SADSCP:\n\t\t\tremainingSize -= PCP_SADSCP_REQ_SIZE;\n\t\t\tif (remainingSize < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n\t\t\tremainingSize -= ((uint8_t *)req)[13];\t/* app_name_length */\n\t\t\tif (remainingSize < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tprintSADSCPOpcode(req);\n#endif\n\t\t\tparseSADSCP(req, pcp_msg_info);\n\t\t\treq += PCP_SADSCP_REQ_SIZE;\n\t\t\tif (pcp_msg_info->result_code != 0) {\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\t\t\treq += pcp_msg_info->app_name_len;\n\n\t\t\tget_dscp_value(pcp_msg_info);\n\n\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tpcp_msg_info->result_code = PCP_ERR_UNSUPP_OPCODE;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tpcp_msg_info->result_code = PCP_ERR_UNSUPP_VERSION;\n\t\treturn pcp_msg_info->result_code;\n\t}\n\treturn 1;\n}\n\n\nstatic void createPCPResponse(unsigned char *response, const pcp_info_t *pcp_msg_info)\n{\n\tresponse[2] = 0;\t/* reserved */\n\tmemset(response + 12, 0, 12);\t/* reserved */\n\tif (pcp_msg_info->result_code == PCP_ERR_UNSUPP_VERSION ) {\n\t\t/* highest supported version */\n\t\tresponse[0] = this_server_info.server_version;\n\t} else {\n\t\tresponse[0] = pcp_msg_info->version;\n\t}\n\n\tresponse[1] = pcp_msg_info->opcode | 0x80;\t/* r_opcode */\n\tresponse[3] = pcp_msg_info->result_code;\n\tif(epoch_origin == 0) {\n\t\tepoch_origin = startup_time;\n\t}\n\tWRITENU32(response + 8, upnp_time() - epoch_origin); /* epochtime */\n\tswitch (pcp_msg_info->result_code) {\n\t/*long lifetime errors*/\n\tcase PCP_ERR_UNSUPP_VERSION:\n\tcase PCP_ERR_NOT_AUTHORIZED:\n\tcase PCP_ERR_MALFORMED_REQUEST:\n\tcase PCP_ERR_UNSUPP_OPCODE:\n\tcase PCP_ERR_UNSUPP_OPTION:\n\tcase PCP_ERR_MALFORMED_OPTION:\n\tcase PCP_ERR_UNSUPP_PROTOCOL:\n\tcase PCP_ERR_ADDRESS_MISMATCH:\n\tcase PCP_ERR_CANNOT_PROVIDE_EXTERNAL:\n\tcase PCP_ERR_EXCESSIVE_REMOTE_PEERS:\n\t\tWRITENU32(response + 4, 0);\t/* lifetime */\n\t\tbreak;\n\n\tcase PCP_ERR_NETWORK_FAILURE:\n\tcase PCP_ERR_NO_RESOURCES:\n\tcase PCP_ERR_USER_EX_QUOTA:\n\t\tWRITENU32(response + 4, 30);\t/* lifetime */\n\t\tbreak;\n\n\tcase PCP_SUCCESS:\n\tdefault:\n\t\tWRITENU32(response + 4, pcp_msg_info->lifetime);\t/* lifetime */\n\t\tbreak;\n\t}\n\n\tif (response[1] == 0x81) { /* MAP response */\n\t\tif (response[0] == 1) {\t/* version */\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 4, pcp_msg_info->int_port);\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 6, pcp_msg_info->ext_port);\n\t\t\tcopyIPv6IfDifferent(response + PCP_COMMON_RESPONSE_SIZE + 8,\n\t\t\t                    pcp_msg_info->ext_ip);\n\t\t}\n\t\telse if (response[0] == 2) {\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 16, pcp_msg_info->int_port);\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 18, pcp_msg_info->ext_port);\n\t\t\tcopyIPv6IfDifferent(response + PCP_COMMON_RESPONSE_SIZE + 20,\n\t\t\t                    pcp_msg_info->ext_ip);\n\t\t}\n\t}\n#ifdef PCP_PEER\n\telse if (response[1] == 0x82) { /* PEER response */\n\t\tif (response[0] == 1) {\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 4, pcp_msg_info->int_port);\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 6, pcp_msg_info->ext_port);\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 24, pcp_msg_info->peer_port);\n\t\t\tcopyIPv6IfDifferent(response + PCP_COMMON_RESPONSE_SIZE + 8,\n\t\t\t                    pcp_msg_info->ext_ip);\n\t\t}\n\t\telse if (response[0] == 2) {\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 16, pcp_msg_info->int_port);\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 18, pcp_msg_info->ext_port);\n\t\t\tWRITENU16(response + PCP_COMMON_RESPONSE_SIZE + 36, pcp_msg_info->peer_port);\n\t\t\tcopyIPv6IfDifferent(response + PCP_COMMON_RESPONSE_SIZE + 20,\n\t\t\t                    pcp_msg_info->ext_ip);\n\t\t}\n\t}\n#endif /* PCP_PEER */\n\n#ifdef PCP_SADSCP\n\telse if (response[1] == 0x83) { /*SADSCP response*/\n\t\tresponse[PCP_COMMON_RESPONSE_SIZE + 12]\n\t\t\t= ((pcp_msg_info->matched_name<<7) & ~(1<<6)) |\n\t\t\t  (pcp_msg_info->sadscp_dscp & PCP_SADSCP_MASK);\n\t\tmemset(response + PCP_COMMON_RESPONSE_SIZE + 13, 0, 3);\n\t}\n#endif /* PCP_SADSCP */\n}\n\nint ProcessIncomingPCPPacket(int s, unsigned char *buff, int len,\n                             const struct sockaddr *senderaddr,\n                             const struct sockaddr_in6 *receiveraddr)\n{\n\tpcp_info_t pcp_msg_info;\n\tstruct lan_addr_s * lan_addr;\n\tchar addr_str[64];\n\n\tmemset(&pcp_msg_info, 0, sizeof(pcp_info_t));\n\n\tif(senderaddr->sa_family == AF_INET) {\n\t\tconst struct sockaddr_in * senderaddr_v4 =\n\t\t\t(const struct sockaddr_in *)senderaddr;\n\t\tpcp_msg_info.sender_ip.s6_addr[11] = 0xff;\n\t\tpcp_msg_info.sender_ip.s6_addr[10] = 0xff;\n\t\tmemcpy(pcp_msg_info.sender_ip.s6_addr+12,\n\t\t       &senderaddr_v4->sin_addr, 4);\n\t} else if(senderaddr->sa_family == AF_INET6) {\n\t\tconst struct sockaddr_in6 * senderaddr_v6 =\n\t\t\t(const struct sockaddr_in6 *)senderaddr;\n\t\tpcp_msg_info.sender_ip = senderaddr_v6->sin6_addr;\n\t} else {\n\t\tsyslog(LOG_WARNING, \"unknown PCP packet sender address family %d\",\n\t\t       senderaddr->sa_family);\n\t\treturn 0;\n\t}\n\n\tif(sockaddr_to_string(senderaddr, addr_str, sizeof(addr_str)))\n\t\tsyslog(LOG_DEBUG, \"PCP request received from %s %dbytes\",\n\t\t       addr_str, len);\n\n\tif(buff[1] & 128) {\n\t\t/* discarding PCP responses silently */\n\t\treturn 0;\n\t}\n\n\t/* If we're in allow third party-mode, we probably don't care\n\t * about locality either. Let's hope firewall is ok. */\n\tif (!GETFLAG(PCP_ALLOWTHIRDPARTYMASK)) {\n\t\tlan_addr = get_lan_for_peer(senderaddr);\n\t\tif(lan_addr == NULL) {\n\t\t\tsyslog(LOG_WARNING, \"PCP packet sender %s not from a LAN, ignoring\",\n\t\t\t       addr_str);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (processPCPRequest(buff, len, &pcp_msg_info) ) {\n\n\t\tcreatePCPResponse(buff, &pcp_msg_info);\n\n\t\tif(len < PCP_MIN_LEN)\n\t\t\tlen = PCP_MIN_LEN;\n\t\telse\n\t\t\tlen = (len + 3) & ~3;\t/* round up resp. length to multiple of 4 */\n\t\tlen = sendto_or_schedule2(s, buff, len, 0, senderaddr,\n\t\t           (senderaddr->sa_family == AF_INET) ?\n\t\t                  sizeof(struct sockaddr_in) :\n\t\t                  sizeof(struct sockaddr_in6),\n\t\t           receiveraddr);\n\t\tif( len < 0 ) {\n\t\t\tsyslog(LOG_ERR, \"sendto(pcpserver): %m\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#ifdef ENABLE_IPV6\nint OpenAndConfPCPv6Socket(void)\n{\n\tint s;\n\tint i = 1;\n\tstruct sockaddr_in6 addr;\n\ts = socket(PF_INET6, SOCK_DGRAM, 0/*IPPROTO_UDP*/);\n\tif(s < 0) {\n\t\tsyslog(LOG_ERR, \"%s: socket(): %m\", \"OpenAndConfPCPv6Socket\");\n\t\treturn -1;\n\t}\n\tif(setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof(i)) < 0) {\n\t\tsyslog(LOG_WARNING, \"%s: setsockopt(SO_REUSEADDR): %m\",\n\t\t       \"OpenAndConfPCPv6Socket\");\n\t}\n#ifdef IPV6_V6ONLY\n\t/* force IPV6 only for IPV6 socket.\n\t * see http://www.ietf.org/rfc/rfc3493.txt section 5.3 */\n\tif(setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &i, sizeof(i)) < 0) {\n\t\tsyslog(LOG_WARNING, \"%s: setsockopt(IPV6_V6ONLY): %m\",\n\t\t       \"OpenAndConfPCPv6Socket\");\n\t}\n#endif\n#ifdef IPV6_RECVPKTINFO\n\t/* see RFC3542 */\n\tif(setsockopt(s, IPPROTO_IPV6, IPV6_RECVPKTINFO, &i, sizeof(i)) < 0) {\n\t\tsyslog(LOG_WARNING, \"%s: setsockopt(IPV6_RECVPKTINFO): %m\",\n\t\t       \"OpenAndConfPCPv6Socket\");\n\t}\n#endif\n\tif(!set_non_blocking(s)) {\n\t\tsyslog(LOG_WARNING, \"%s: set_non_blocking(): %m\",\n\t\t       \"OpenAndConfPCPv6Socket\");\n\t}\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin6_family = AF_INET6;\n\taddr.sin6_port = htons(NATPMP_PORT);\n\taddr.sin6_addr = ipv6_bind_addr;\n\tif(bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t\tsyslog(LOG_ERR, \"%s: bind(): %m\", \"OpenAndConfPCPv6Socket\");\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\treturn s;\n}\n#endif /*ENABLE_IPV6*/\n\n#ifdef ENABLE_IPV6\nvoid PCPSendUnsolicitedAnnounce(int * sockets, int n_sockets, int socket6)\n#else /* IPv4 only */\nvoid PCPSendUnsolicitedAnnounce(int * sockets, int n_sockets)\n#endif\n{\n\tint i;\n\tunsigned char buff[PCP_MIN_LEN];\n\tpcp_info_t info;\n\tssize_t len;\n\tstruct sockaddr_in addr;\n#ifdef ENABLE_IPV6\n\tstruct sockaddr_in6 addr6;\n#endif /* ENABLE_IPV6 */\n\t/* this is an Unsolicited ANNOUNCE response */\n\n\tinfo.version = this_server_info.server_version;\n\tinfo.opcode = PCP_OPCODE_ANNOUNCE;\n\tinfo.result_code = PCP_SUCCESS;\n\tinfo.lifetime = 0;\n\tcreatePCPResponse(buff, &info);\n\t/* Multicast PCP restart announcements are sent to\n\t * 224.0.0.1:5350 and/or [ff02::1]:5350 */\n\tmemset(&addr, 0, sizeof(struct sockaddr_in));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = inet_addr(\"224.0.0.1\");\n\taddr.sin_port = htons(5350);\n\tfor(i = 0; i < n_sockets; i++) {\n\t\tlen = sendto_or_schedule(sockets[i], buff, PCP_MIN_LEN, 0, (struct sockaddr *)&addr, sizeof(struct sockaddr_in));\n\t\tif( len < 0 ) {\n\t\t\tsyslog(LOG_ERR, \"PCPSendUnsolicitedAnnounce() sendto(): %m\");\n\t\t}\n\t}\n#ifdef ENABLE_IPV6\n\tmemset(&addr6, 0, sizeof(struct sockaddr_in6));\n\taddr6.sin6_family = AF_INET6;\n\tinet_pton(AF_INET6, \"FF02::1\", &(addr6.sin6_addr));\n\taddr6.sin6_port = htons(5350);\n\tlen = sendto_or_schedule(socket6, buff, PCP_MIN_LEN, 0, (struct sockaddr *)&addr6, sizeof(struct sockaddr_in6));\n\tif( len < 0 ) {\n\t\tsyslog(LOG_ERR, \"PCPSendUnsolicitedAnnounce() IPv6 sendto(): %m\");\n\t}\n#endif /* ENABLE_IPV6 */\n}\n\n#ifdef ENABLE_IPV6\nvoid PCPPublicAddressChanged(int * sockets, int n_sockets, int socket6)\n#else /* IPv4 only */\nvoid PCPPublicAddressChanged(int * sockets, int n_sockets)\n#endif\n{\n\t/* according to RFC 6887  8.5 :\n\t *   if the external IP address(es) of the NAT (controlled by\n\t *   the PCP server) changes, the Epoch time MUST be reset. */\n\tepoch_origin = upnp_time();\n#ifdef ENABLE_IPV6\n\tPCPSendUnsolicitedAnnounce(sockets, n_sockets, socket6);\n#else /* IPv4 Only */\n\tPCPSendUnsolicitedAnnounce(sockets, n_sockets);\n#endif\n}\n#endif /*ENABLE_PCP*/\n"], "filenames": ["miniupnpd/pcpserver.c"], "buggy_code_start_loc": [180], "buggy_code_end_loc": [181], "fixing_code_start_loc": [180], "fixing_code_end_loc": [181], "type": "CWE-476", "message": "A Denial Of Service vulnerability in MiniUPnP MiniUPnPd through 2.1 exists due to a NULL pointer dereference in copyIPv6IfDifferent in pcpserver.c.", "other": {"cve": {"id": "CVE-2019-12111", "sourceIdentifier": "cve@mitre.org", "published": "2019-05-15T23:29:00.933", "lastModified": "2020-09-28T20:15:13.093", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A Denial Of Service vulnerability in MiniUPnP MiniUPnPd through 2.1 exists due to a NULL pointer dereference in copyIPv6IfDifferent in pcpserver.c."}, {"lang": "es", "value": "Existe una vulnerabilidad de Denegaci\u00f3n de Servicio en MiniUPnP MiniUPnPd hasta la versi\u00f3n 2.1, debido a una desreferencia de puntero NULL en copyIPv6IfDifferent en pcpserver.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:miniupnp_project:miniupnpd:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.1", "matchCriteriaId": "75C9C56C-3164-4A9D-8CEC-3325503527D0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "https://github.com/miniupnp/miniupnp/commit/cb8a02af7a5677cf608e86d57ab04241cf34e24f", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/05/msg00045.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4542-1/", "source": "cve@mitre.org"}, {"url": "https://www.vdoo.com/blog/security-issues-discovered-in-miniupnp", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/miniupnp/miniupnp/commit/cb8a02af7a5677cf608e86d57ab04241cf34e24f"}}