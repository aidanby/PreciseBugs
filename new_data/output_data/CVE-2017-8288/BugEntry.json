{"buggy_code": ["// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-\n\nconst Lang = imports.lang;\nconst Signals = imports.signals;\n\nconst GLib = imports.gi.GLib;\nconst Gio = imports.gi.Gio;\nconst St = imports.gi.St;\n\nconst ExtensionUtils = imports.misc.extensionUtils;\nconst Main = imports.ui.main;\n\nconst ExtensionState = {\n    ENABLED: 1,\n    DISABLED: 2,\n    ERROR: 3,\n    OUT_OF_DATE: 4,\n    DOWNLOADING: 5,\n    INITIALIZED: 6,\n\n    // Used as an error state for operations on unknown extensions,\n    // should never be in a real extensionMeta object.\n    UNINSTALLED: 99\n};\n\n// Arrays of uuids\nvar enabledExtensions;\n// Contains the order that extensions were enabled in.\nconst extensionOrder = [];\n\n// We don't really have a class to add signals on. So, create\n// a simple dummy object, add the signal methods, and export those\n// publically.\nvar _signals = {};\nSignals.addSignalMethods(_signals);\n\nconst connect = Lang.bind(_signals, _signals.connect);\nconst disconnect = Lang.bind(_signals, _signals.disconnect);\n\nconst ENABLED_EXTENSIONS_KEY = 'enabled-extensions';\nconst DISABLE_USER_EXTENSIONS_KEY = 'disable-user-extensions';\nconst EXTENSION_DISABLE_VERSION_CHECK_KEY = 'disable-extension-version-validation';\n\nvar initted = false;\nvar enabled;\n\nfunction disableExtension(uuid) {\n    let extension = ExtensionUtils.extensions[uuid];\n    if (!extension)\n        return;\n\n    if (extension.state != ExtensionState.ENABLED)\n        return;\n\n    // \"Rebase\" the extension order by disabling and then enabling extensions\n    // in order to help prevent conflicts.\n\n    // Example:\n    //   order = [A, B, C, D, E]\n    //   user disables C\n    //   this should: disable E, disable D, disable C, enable D, enable E\n\n    let orderIdx = extensionOrder.indexOf(uuid);\n    let order = extensionOrder.slice(orderIdx + 1);\n    let orderReversed = order.slice().reverse();\n\n    for (let i = 0; i < orderReversed.length; i++) {\n        let uuid = orderReversed[i];\n        try {\n            ExtensionUtils.extensions[uuid].stateObj.disable();\n        } catch(e) {\n            logExtensionError(uuid, e);\n        }\n    }\n\n    if (extension.stylesheet) {\n        let theme = St.ThemeContext.get_for_stage(global.stage).get_theme();\n        theme.unload_stylesheet(extension.stylesheet);\n    }\n\n    try {\n        extension.stateObj.disable();\n    } catch(e) {\n        logExtensionError(uuid, e);\n    }\n\n    for (let i = 0; i < order.length; i++) {\n        let uuid = order[i];\n        try {\n            ExtensionUtils.extensions[uuid].stateObj.enable();\n        } catch(e) {\n            logExtensionError(uuid, e);\n        }\n    }\n\n    extensionOrder.splice(orderIdx, 1);\n\n    if ( extension.state != ExtensionState.ERROR ) {\n        extension.state = ExtensionState.DISABLED;\n        _signals.emit('extension-state-changed', extension);\n    }\n}\n\nfunction enableExtension(uuid) {\n    let extension = ExtensionUtils.extensions[uuid];\n    if (!extension)\n        return;\n\n    if (extension.state == ExtensionState.INITIALIZED)\n        initExtension(uuid);\n\n    if (extension.state != ExtensionState.DISABLED)\n        return;\n\n    extensionOrder.push(uuid);\n\n    let stylesheetNames = [global.session_mode + '.css', 'stylesheet.css'];\n    for (let i = 0; i < stylesheetNames.length; i++) {\n        let stylesheetFile = extension.dir.get_child(stylesheetNames[i]);\n        if (stylesheetFile.query_exists(null)) {\n            let theme = St.ThemeContext.get_for_stage(global.stage).get_theme();\n            theme.load_stylesheet(stylesheetFile);\n            extension.stylesheet = stylesheetFile;\n            break;\n        }\n    }\n\n    try {\n        extension.stateObj.enable();\n        extension.state = ExtensionState.ENABLED;\n        _signals.emit('extension-state-changed', extension);\n        return;\n    } catch(e) {\n        logExtensionError(uuid, e);\n        return;\n    }\n}\n\nfunction logExtensionError(uuid, error) {\n    let extension = ExtensionUtils.extensions[uuid];\n    if (!extension)\n        return;\n\n    let message = '' + error;\n\n    extension.state = ExtensionState.ERROR;\n    if (!extension.errors)\n        extension.errors = [];\n    extension.errors.push(message);\n\n    log('Extension \"%s\" had error: %s'.format(uuid, message));\n    _signals.emit('extension-state-changed', { uuid: uuid,\n                                               error: message,\n                                               state: extension.state });\n}\n\nfunction loadExtension(extension) {\n    // Default to error, we set success as the last step\n    extension.state = ExtensionState.ERROR;\n\n    let checkVersion = !global.settings.get_boolean(EXTENSION_DISABLE_VERSION_CHECK_KEY);\n\n    if (checkVersion && ExtensionUtils.isOutOfDate(extension)) {\n        extension.state = ExtensionState.OUT_OF_DATE;\n    } else {\n        let enabled = enabledExtensions.indexOf(extension.uuid) != -1;\n        if (enabled) {\n            if (!initExtension(extension.uuid))\n                return;\n            if (extension.state == ExtensionState.DISABLED)\n                enableExtension(extension.uuid);\n        } else {\n            extension.state = ExtensionState.INITIALIZED;\n        }\n    }\n\n    _signals.emit('extension-state-changed', extension);\n}\n\nfunction unloadExtension(extension) {\n    // Try to disable it -- if it's ERROR'd, we can't guarantee that,\n    // but it will be removed on next reboot, and hopefully nothing\n    // broke too much.\n    disableExtension(extension.uuid);\n\n    extension.state = ExtensionState.UNINSTALLED;\n    _signals.emit('extension-state-changed', extension);\n\n    delete ExtensionUtils.extensions[extension.uuid];\n    return true;\n}\n\nfunction reloadExtension(oldExtension) {\n    // Grab the things we'll need to pass to createExtensionObject\n    // to reload it.\n    let { uuid: uuid, dir: dir, type: type } = oldExtension;\n\n    // Then unload the old extension.\n    unloadExtension(oldExtension);\n\n    // Now, recreate the extension and load it.\n    let newExtension = ExtensionUtils.createExtensionObject(uuid, dir, type);\n    loadExtension(newExtension);\n}\n\nfunction initExtension(uuid) {\n    let extension = ExtensionUtils.extensions[uuid];\n    let dir = extension.dir;\n\n    if (!extension)\n        throw new Error(\"Extension was not properly created. Call loadExtension first\");\n\n    let extensionJs = dir.get_child('extension.js');\n    if (!extensionJs.query_exists(null))\n        throw new Error('Missing extension.js');\n\n    let extensionModule;\n    let extensionState = null;\n\n    ExtensionUtils.installImporter(extension);\n    extensionModule = extension.imports.extension;\n\n    if (extensionModule.init) {\n        try {\n            extensionState = extensionModule.init(extension);\n        } catch(e) {\n            logExtensionError(uuid, e);\n            return false;\n        }\n    }\n\n    if (!extensionState)\n        extensionState = extensionModule;\n    extension.stateObj = extensionState;\n\n    extension.state = ExtensionState.DISABLED;\n    _signals.emit('extension-loaded', uuid);\n    return true;\n}\n\nfunction getEnabledExtensions() {\n    let extensions;\n    if (Array.isArray(Main.sessionMode.enabledExtensions))\n        extensions = Main.sessionMode.enabledExtensions;\n    else\n        extensions = [];\n\n    if (global.settings.get_boolean(DISABLE_USER_EXTENSIONS_KEY))\n        return extensions;\n\n    return extensions.concat(global.settings.get_strv(ENABLED_EXTENSIONS_KEY));\n}\n\nfunction onEnabledExtensionsChanged() {\n    let newEnabledExtensions = getEnabledExtensions();\n\n    if (!enabled)\n        return;\n\n    // Find and enable all the newly enabled extensions: UUIDs found in the\n    // new setting, but not in the old one.\n    newEnabledExtensions.filter(function(uuid) {\n        return enabledExtensions.indexOf(uuid) == -1;\n    }).forEach(function(uuid) {\n        enableExtension(uuid);\n    });\n\n    // Find and disable all the newly disabled extensions: UUIDs found in the\n    // old setting, but not in the new one.\n    enabledExtensions.filter(function(item) {\n        return newEnabledExtensions.indexOf(item) == -1;\n    }).forEach(function(uuid) {\n        disableExtension(uuid);\n    });\n\n    enabledExtensions = newEnabledExtensions;\n}\n\nfunction _onVersionValidationChanged() {\n    // we want to reload all extensions, but only enable\n    // extensions when allowed by the sessionMode, so\n    // temporarily disable them all\n    enabledExtensions = [];\n    for (let uuid in ExtensionUtils.extensions)\n        reloadExtension(ExtensionUtils.extensions[uuid]);\n    enabledExtensions = getEnabledExtensions();\n\n    if (Main.sessionMode.allowExtensions) {\n        enabledExtensions.forEach(function(uuid) {\n            enableExtension(uuid);\n        });\n    }\n}\n\nfunction _loadExtensions() {\n    global.settings.connect('changed::' + ENABLED_EXTENSIONS_KEY, onEnabledExtensionsChanged);\n    global.settings.connect('changed::' + DISABLE_USER_EXTENSIONS_KEY, onEnabledExtensionsChanged);\n    global.settings.connect('changed::' + EXTENSION_DISABLE_VERSION_CHECK_KEY, _onVersionValidationChanged);\n\n    enabledExtensions = getEnabledExtensions();\n\n    let finder = new ExtensionUtils.ExtensionFinder();\n    finder.connect('extension-found', function(finder, extension) {\n        loadExtension(extension);\n    });\n    finder.scanExtensions();\n}\n\nfunction enableAllExtensions() {\n    if (enabled)\n        return;\n\n    if (!initted) {\n        _loadExtensions();\n        initted = true;\n    } else {\n        enabledExtensions.forEach(function(uuid) {\n            enableExtension(uuid);\n        });\n    }\n    enabled = true;\n}\n\nfunction disableAllExtensions() {\n    if (!enabled)\n        return;\n\n    if (initted) {\n        extensionOrder.slice().reverse().forEach(function(uuid) {\n            disableExtension(uuid);\n        });\n    }\n\n    enabled = false;\n}\n\nfunction _sessionUpdated() {\n    // For now sessionMode.allowExtensions controls extensions from both the\n    // 'enabled-extensions' preference and the sessionMode.enabledExtensions\n    // property; it might make sense to make enabledExtensions independent\n    // from allowExtensions in the future\n    if (Main.sessionMode.allowExtensions) {\n        if (initted)\n            enabledExtensions = getEnabledExtensions();\n        enableAllExtensions();\n    } else {\n        disableAllExtensions();\n    }\n}\n\nfunction init() {\n    Main.sessionMode.connect('updated', _sessionUpdated);\n    _sessionUpdated();\n}\n"], "fixing_code": ["// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-\n\nconst Lang = imports.lang;\nconst Signals = imports.signals;\n\nconst GLib = imports.gi.GLib;\nconst Gio = imports.gi.Gio;\nconst St = imports.gi.St;\n\nconst ExtensionUtils = imports.misc.extensionUtils;\nconst Main = imports.ui.main;\n\nconst ExtensionState = {\n    ENABLED: 1,\n    DISABLED: 2,\n    ERROR: 3,\n    OUT_OF_DATE: 4,\n    DOWNLOADING: 5,\n    INITIALIZED: 6,\n\n    // Used as an error state for operations on unknown extensions,\n    // should never be in a real extensionMeta object.\n    UNINSTALLED: 99\n};\n\n// Arrays of uuids\nvar enabledExtensions;\n// Contains the order that extensions were enabled in.\nconst extensionOrder = [];\n\n// We don't really have a class to add signals on. So, create\n// a simple dummy object, add the signal methods, and export those\n// publically.\nvar _signals = {};\nSignals.addSignalMethods(_signals);\n\nconst connect = Lang.bind(_signals, _signals.connect);\nconst disconnect = Lang.bind(_signals, _signals.disconnect);\n\nconst ENABLED_EXTENSIONS_KEY = 'enabled-extensions';\nconst DISABLE_USER_EXTENSIONS_KEY = 'disable-user-extensions';\nconst EXTENSION_DISABLE_VERSION_CHECK_KEY = 'disable-extension-version-validation';\n\nvar initted = false;\nvar enabled;\n\nfunction disableExtension(uuid) {\n    let extension = ExtensionUtils.extensions[uuid];\n    if (!extension)\n        return;\n\n    if (extension.state != ExtensionState.ENABLED)\n        return;\n\n    // \"Rebase\" the extension order by disabling and then enabling extensions\n    // in order to help prevent conflicts.\n\n    // Example:\n    //   order = [A, B, C, D, E]\n    //   user disables C\n    //   this should: disable E, disable D, disable C, enable D, enable E\n\n    let orderIdx = extensionOrder.indexOf(uuid);\n    let order = extensionOrder.slice(orderIdx + 1);\n    let orderReversed = order.slice().reverse();\n\n    for (let i = 0; i < orderReversed.length; i++) {\n        let uuid = orderReversed[i];\n        try {\n            ExtensionUtils.extensions[uuid].stateObj.disable();\n        } catch(e) {\n            logExtensionError(uuid, e);\n        }\n    }\n\n    if (extension.stylesheet) {\n        let theme = St.ThemeContext.get_for_stage(global.stage).get_theme();\n        theme.unload_stylesheet(extension.stylesheet);\n    }\n\n    try {\n        extension.stateObj.disable();\n    } catch(e) {\n        logExtensionError(uuid, e);\n    }\n\n    for (let i = 0; i < order.length; i++) {\n        let uuid = order[i];\n        try {\n            ExtensionUtils.extensions[uuid].stateObj.enable();\n        } catch(e) {\n            logExtensionError(uuid, e);\n        }\n    }\n\n    extensionOrder.splice(orderIdx, 1);\n\n    if ( extension.state != ExtensionState.ERROR ) {\n        extension.state = ExtensionState.DISABLED;\n        _signals.emit('extension-state-changed', extension);\n    }\n}\n\nfunction enableExtension(uuid) {\n    let extension = ExtensionUtils.extensions[uuid];\n    if (!extension)\n        return;\n\n    if (extension.state == ExtensionState.INITIALIZED)\n        initExtension(uuid);\n\n    if (extension.state != ExtensionState.DISABLED)\n        return;\n\n    extensionOrder.push(uuid);\n\n    let stylesheetNames = [global.session_mode + '.css', 'stylesheet.css'];\n    for (let i = 0; i < stylesheetNames.length; i++) {\n        let stylesheetFile = extension.dir.get_child(stylesheetNames[i]);\n        if (stylesheetFile.query_exists(null)) {\n            let theme = St.ThemeContext.get_for_stage(global.stage).get_theme();\n            theme.load_stylesheet(stylesheetFile);\n            extension.stylesheet = stylesheetFile;\n            break;\n        }\n    }\n\n    try {\n        extension.stateObj.enable();\n        extension.state = ExtensionState.ENABLED;\n        _signals.emit('extension-state-changed', extension);\n        return;\n    } catch(e) {\n        logExtensionError(uuid, e);\n        return;\n    }\n}\n\nfunction logExtensionError(uuid, error) {\n    let extension = ExtensionUtils.extensions[uuid];\n    if (!extension)\n        return;\n\n    let message = '' + error;\n\n    extension.state = ExtensionState.ERROR;\n    if (!extension.errors)\n        extension.errors = [];\n    extension.errors.push(message);\n\n    log('Extension \"%s\" had error: %s'.format(uuid, message));\n    _signals.emit('extension-state-changed', { uuid: uuid,\n                                               error: message,\n                                               state: extension.state });\n}\n\nfunction loadExtension(extension) {\n    // Default to error, we set success as the last step\n    extension.state = ExtensionState.ERROR;\n\n    let checkVersion = !global.settings.get_boolean(EXTENSION_DISABLE_VERSION_CHECK_KEY);\n\n    if (checkVersion && ExtensionUtils.isOutOfDate(extension)) {\n        extension.state = ExtensionState.OUT_OF_DATE;\n    } else {\n        let enabled = enabledExtensions.indexOf(extension.uuid) != -1;\n        if (enabled) {\n            if (!initExtension(extension.uuid))\n                return;\n            if (extension.state == ExtensionState.DISABLED)\n                enableExtension(extension.uuid);\n        } else {\n            extension.state = ExtensionState.INITIALIZED;\n        }\n    }\n\n    _signals.emit('extension-state-changed', extension);\n}\n\nfunction unloadExtension(extension) {\n    // Try to disable it -- if it's ERROR'd, we can't guarantee that,\n    // but it will be removed on next reboot, and hopefully nothing\n    // broke too much.\n    disableExtension(extension.uuid);\n\n    extension.state = ExtensionState.UNINSTALLED;\n    _signals.emit('extension-state-changed', extension);\n\n    delete ExtensionUtils.extensions[extension.uuid];\n    return true;\n}\n\nfunction reloadExtension(oldExtension) {\n    // Grab the things we'll need to pass to createExtensionObject\n    // to reload it.\n    let { uuid: uuid, dir: dir, type: type } = oldExtension;\n\n    // Then unload the old extension.\n    unloadExtension(oldExtension);\n\n    // Now, recreate the extension and load it.\n    let newExtension = ExtensionUtils.createExtensionObject(uuid, dir, type);\n    loadExtension(newExtension);\n}\n\nfunction initExtension(uuid) {\n    let extension = ExtensionUtils.extensions[uuid];\n    let dir = extension.dir;\n\n    if (!extension)\n        throw new Error(\"Extension was not properly created. Call loadExtension first\");\n\n    let extensionJs = dir.get_child('extension.js');\n    if (!extensionJs.query_exists(null))\n        throw new Error('Missing extension.js');\n\n    let extensionModule;\n    let extensionState = null;\n\n    ExtensionUtils.installImporter(extension);\n    extensionModule = extension.imports.extension;\n\n    if (extensionModule.init) {\n        try {\n            extensionState = extensionModule.init(extension);\n        } catch(e) {\n            logExtensionError(uuid, e);\n            return false;\n        }\n    }\n\n    if (!extensionState)\n        extensionState = extensionModule;\n    extension.stateObj = extensionState;\n\n    extension.state = ExtensionState.DISABLED;\n    _signals.emit('extension-loaded', uuid);\n    return true;\n}\n\nfunction getEnabledExtensions() {\n    let extensions;\n    if (Array.isArray(Main.sessionMode.enabledExtensions))\n        extensions = Main.sessionMode.enabledExtensions;\n    else\n        extensions = [];\n\n    if (global.settings.get_boolean(DISABLE_USER_EXTENSIONS_KEY))\n        return extensions;\n\n    return extensions.concat(global.settings.get_strv(ENABLED_EXTENSIONS_KEY));\n}\n\nfunction onEnabledExtensionsChanged() {\n    let newEnabledExtensions = getEnabledExtensions();\n\n    if (!enabled)\n        return;\n\n    // Find and enable all the newly enabled extensions: UUIDs found in the\n    // new setting, but not in the old one.\n    newEnabledExtensions.filter(function(uuid) {\n        return enabledExtensions.indexOf(uuid) == -1;\n    }).forEach(function(uuid) {\n        enableExtension(uuid);\n    });\n\n    // Find and disable all the newly disabled extensions: UUIDs found in the\n    // old setting, but not in the new one.\n    enabledExtensions.filter(function(item) {\n        return newEnabledExtensions.indexOf(item) == -1;\n    }).forEach(function(uuid) {\n        disableExtension(uuid);\n    });\n\n    enabledExtensions = newEnabledExtensions;\n}\n\nfunction _onVersionValidationChanged() {\n    // we want to reload all extensions, but only enable\n    // extensions when allowed by the sessionMode, so\n    // temporarily disable them all\n    enabledExtensions = [];\n    for (let uuid in ExtensionUtils.extensions)\n        try {\n            reloadExtension(ExtensionUtils.extensions[uuid]);\n        } catch(e) {\n            logExtensionError(uuid, e);\n        }\n    enabledExtensions = getEnabledExtensions();\n\n    if (Main.sessionMode.allowExtensions) {\n        enabledExtensions.forEach(function(uuid) {\n            try {\n                enableExtension(uuid);\n            } catch(e) {\n                logExtensionError(uuid, e);\n            }\n        });\n    }\n}\n\nfunction _loadExtensions() {\n    global.settings.connect('changed::' + ENABLED_EXTENSIONS_KEY, onEnabledExtensionsChanged);\n    global.settings.connect('changed::' + DISABLE_USER_EXTENSIONS_KEY, onEnabledExtensionsChanged);\n    global.settings.connect('changed::' + EXTENSION_DISABLE_VERSION_CHECK_KEY, _onVersionValidationChanged);\n\n    enabledExtensions = getEnabledExtensions();\n\n    let finder = new ExtensionUtils.ExtensionFinder();\n    finder.connect('extension-found', function(finder, extension) {\n        loadExtension(extension);\n    });\n    finder.scanExtensions();\n}\n\nfunction enableAllExtensions() {\n    if (enabled)\n        return;\n\n    if (!initted) {\n        _loadExtensions();\n        initted = true;\n    } else {\n        enabledExtensions.forEach(function(uuid) {\n            enableExtension(uuid);\n        });\n    }\n    enabled = true;\n}\n\nfunction disableAllExtensions() {\n    if (!enabled)\n        return;\n\n    if (initted) {\n        extensionOrder.slice().reverse().forEach(function(uuid) {\n            disableExtension(uuid);\n        });\n    }\n\n    enabled = false;\n}\n\nfunction _sessionUpdated() {\n    // For now sessionMode.allowExtensions controls extensions from both the\n    // 'enabled-extensions' preference and the sessionMode.enabledExtensions\n    // property; it might make sense to make enabledExtensions independent\n    // from allowExtensions in the future\n    if (Main.sessionMode.allowExtensions) {\n        if (initted)\n            enabledExtensions = getEnabledExtensions();\n        enableAllExtensions();\n    } else {\n        disableAllExtensions();\n    }\n}\n\nfunction init() {\n    Main.sessionMode.connect('updated', _sessionUpdated);\n    _sessionUpdated();\n}\n"], "filenames": ["js/ui/extensionSystem.js"], "buggy_code_start_loc": [285], "buggy_code_end_loc": [291], "fixing_code_start_loc": [285], "fixing_code_end_loc": [299], "type": "CWE-20", "message": "gnome-shell 3.22 through 3.24.1 mishandles extensions that fail to reload, which can lead to leaving extensions enabled in the lock screen. With these extensions, a bystander could launch applications (but not interact with them), see information from the extensions (e.g., what applications you have opened or what music you were playing), or even execute arbitrary commands. It all depends on what extensions a user has enabled. The problem is caused by lack of exception handling in js/ui/extensionSystem.js.", "other": {"cve": {"id": "CVE-2017-8288", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-27T00:59:00.350", "lastModified": "2017-05-10T16:11:15.293", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "gnome-shell 3.22 through 3.24.1 mishandles extensions that fail to reload, which can lead to leaving extensions enabled in the lock screen. With these extensions, a bystander could launch applications (but not interact with them), see information from the extensions (e.g., what applications you have opened or what music you were playing), or even execute arbitrary commands. It all depends on what extensions a user has enabled. The problem is caused by lack of exception handling in js/ui/extensionSystem.js."}, {"lang": "es", "value": "Gnome-shell en las versiones 3.22 a la 3.24.1, no gestiona correctamente extensiones que fallan en la recarga, lo que puede llevar a dejar extensiones habilitadas en la pantalla de bloqueo. Con estas extensiones, un usuario puede iniciar aplicaciones (pero no interactuar con ellas). Ver informaci\u00f3n de las extensiones (por ejemplo, qu\u00e9 aplicaciones se han abierto o qu\u00e9 m\u00fasica se est\u00e1 reproduciendo) o incluso ejecutar comandos arbitrarios. Todo depende de las extensiones habiliadas por el usuario. El problema se debe a la falta de gesti\u00f3n de excepciones en js/ui/extensionSystem.js."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gnome:gnome-shell:3.22.0:*:*:*:*:*:*:*", "matchCriteriaId": "8198E17C-7E84-4C2C-BAF3-EC23C3AE06A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gnome:gnome-shell:3.22.1:*:*:*:*:*:*:*", "matchCriteriaId": "175A072B-5C22-4E7B-B424-D39EC494D2E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gnome:gnome-shell:3.22.2:*:*:*:*:*:*:*", "matchCriteriaId": "EFD7DE8C-2562-4869-9B71-CF589B657416"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gnome:gnome-shell:3.22.3:*:*:*:*:*:*:*", "matchCriteriaId": "73A9701D-8279-43A5-9C17-95F0E7AE393B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gnome:gnome-shell:3.23.1:*:*:*:*:*:*:*", "matchCriteriaId": "4A9F5C5E-A869-43C4-964A-53B5F86A1535"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gnome:gnome-shell:3.23.2:*:*:*:*:*:*:*", "matchCriteriaId": "54B578F8-126F-462C-ACA2-050DBA507D16"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gnome:gnome-shell:3.23.3:*:*:*:*:*:*:*", "matchCriteriaId": "28263BD0-7BD0-43FB-9B0C-E5EC76B26D98"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gnome:gnome-shell:3.23.90:*:*:*:*:*:*:*", "matchCriteriaId": "C7631BF2-04D3-43A9-A3CE-78A0BA6267D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gnome:gnome-shell:3.23.91:*:*:*:*:*:*:*", "matchCriteriaId": "CADB6B52-E0FB-4C7E-A713-8911363DF012"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gnome:gnome-shell:3.23.92:*:*:*:*:*:*:*", "matchCriteriaId": "3BAC1907-E75B-4063-B437-2809769D8CB8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gnome:gnome-shell:3.24.0:*:*:*:*:*:*:*", "matchCriteriaId": "94FEAFD5-762D-4AD8-B4D9-0EDAE4789D8C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gnome:gnome-shell:3.24.1:*:*:*:*:*:*:*", "matchCriteriaId": "963F3846-793E-4156-9CF8-DB7595BAB904"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/98070", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.kali.org/view.php?id=2513", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://bugzilla.gnome.org/show_bug.cgi?id=781728", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/EasyScreenCast/EasyScreenCast/issues/46", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/GNOME/gnome-shell/commit/ff425d1db7082e2755d2a405af53861552acf2a1", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/GNOME/gnome-shell/commit/ff425d1db7082e2755d2a405af53861552acf2a1"}}