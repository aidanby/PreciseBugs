{"buggy_code": ["var express = require('express');\nvar log4js = require('log4js');\nvar httpLogger = log4js.getLogger(\"http\");\nvar settings = require('../../utils/Settings');\nvar hooks = require('ep_etherpad-lite/static/js/pluginfw/hooks');\nvar ueberStore = require('../../db/SessionStore');\nvar stats = require('ep_etherpad-lite/node/stats');\nvar sessionModule = require('express-session');\nvar cookieParser = require('cookie-parser');\n\n//checks for basic http auth\nexports.basicAuth = function (req, res, next) {\n  var hookResultMangle = function (cb) {\n    return function (err, data) {\n      return cb(!err && data.length && data[0]);\n    }\n  }\n\n  var authorize = function (cb) {\n    // Do not require auth for static paths and the API...this could be a bit brittle\n    if (req.path.match(/^\\/(static|javascripts|pluginfw|api)/)) return cb(true);\n\n    if (req.path.indexOf('/admin') != 0) {\n      if (!settings.requireAuthentication) return cb(true);\n      if (!settings.requireAuthorization && req.session && req.session.user) return cb(true);\n    }\n\n    if (req.session && req.session.user && req.session.user.is_admin) return cb(true);\n\n    hooks.aCallFirst(\"authorize\", {req: req, res:res, next:next, resource: req.path}, hookResultMangle(cb));\n  }\n\n  var authenticate = function (cb) {\n    // If auth headers are present use them to authenticate...\n    if (req.headers.authorization && req.headers.authorization.search('Basic ') === 0) {\n      var userpass = new Buffer(req.headers.authorization.split(' ')[1], 'base64').toString().split(\":\")\n      var username = userpass.shift();\n      var password = userpass.join(':');\n\n      if (settings.users[username] != undefined && settings.users[username].password === password) {\n        settings.users[username].username = username;\n        req.session.user = settings.users[username];\n        return cb(true);\n      }\n      return hooks.aCallFirst(\"authenticate\", {req: req, res:res, next:next, username: username, password: password}, hookResultMangle(cb));\n    }\n    hooks.aCallFirst(\"authenticate\", {req: req, res:res, next:next}, hookResultMangle(cb));\n  }\n\n\n  /* Authentication OR authorization failed. */\n  var failure = function () {\n    return hooks.aCallFirst(\"authFailure\", {req: req, res:res, next:next}, hookResultMangle(function (ok) {\n    if (ok) return;\n      /* No plugin handler for invalid auth. Return Auth required\n       * Headers, delayed for 1 second, if authentication failed\n       * before. */\n      res.header('WWW-Authenticate', 'Basic realm=\"Protected Area\"');\n      if (req.headers.authorization) {\n        setTimeout(function () {\n          res.status(401).send('Authentication required');\n        }, 1000);\n      } else {\n        res.status(401).send('Authentication required');\n      }\n    }));\n  }\n\n\n  /* This is the actual authentication/authorization hoop. It is done in four steps:\n\n     1) Try to just access the thing\n     2) If not allowed using whatever creds are in the current session already, try to authenticate\n     3) If authentication using already supplied credentials succeeds, try to access the thing again\n     4) If all els fails, give the user a 401 to request new credentials\n\n     Note that the process could stop already in step 3 with a redirect to login page.\n\n  */\n\n  authorize(function (ok) {\n    if (ok) return next();\n    authenticate(function (ok) {\n      if (!ok) return failure();\n      authorize(function (ok) {\n        if (ok) return next();\n        failure();\n      });\n    });\n  });\n}\n\nexports.secret = null;\n\nexports.expressConfigure = function (hook_name, args, cb) {\n  // Measure response time\n  args.app.use(function(req, res, next) {\n    var stopWatch = stats.timer('httpRequests').start();\n    var sendFn = res.send\n    res.send = function() {\n      stopWatch.end()\n      sendFn.apply(res, arguments)\n    }\n    next()\n  })\n\n  // If the log level specified in the config file is WARN or ERROR the application server never starts listening to requests as reported in issue #158.\n  // Not installing the log4js connect logger when the log level has a higher severity than INFO since it would not log at that level anyway.\n  if (!(settings.loglevel === \"WARN\" || settings.loglevel == \"ERROR\"))\n    args.app.use(log4js.connectLogger(httpLogger, { level: log4js.levels.DEBUG, format: ':status, :method :url'}));\n\n  /* Do not let express create the session, so that we can retain a\n   * reference to it for socket.io to use. Also, set the key (cookie\n   * name) to a javascript identifier compatible string. Makes code\n   * handling it cleaner :) */\n\n  if (!exports.sessionStore) {\n    exports.sessionStore = new ueberStore();\n    exports.secret = settings.sessionKey;\n  }\n\n  args.app.sessionStore = exports.sessionStore;\n  args.app.use(sessionModule({secret: exports.secret, store: args.app.sessionStore, resave: true, saveUninitialized: true, name: 'express_sid', proxy: true, cookie: { secure: !!settings.ssl }}));\n\n  args.app.use(cookieParser(settings.sessionKey, {}));\n\n  args.app.use(exports.basicAuth);\n}\n\n"], "fixing_code": ["var express = require('express');\nvar log4js = require('log4js');\nvar httpLogger = log4js.getLogger(\"http\");\nvar settings = require('../../utils/Settings');\nvar hooks = require('ep_etherpad-lite/static/js/pluginfw/hooks');\nvar ueberStore = require('../../db/SessionStore');\nvar stats = require('ep_etherpad-lite/node/stats');\nvar sessionModule = require('express-session');\nvar cookieParser = require('cookie-parser');\n\n//checks for basic http auth\nexports.basicAuth = function (req, res, next) {\n  var hookResultMangle = function (cb) {\n    return function (err, data) {\n      return cb(!err && data.length && data[0]);\n    }\n  }\n\n  var authorize = function (cb) {\n    // Do not require auth for static paths and the API...this could be a bit brittle\n    if (req.path.match(/^\\/(static|javascripts|pluginfw|api)/)) return cb(true);\n\n    if (req.path.toLowerCase().indexOf('/admin') != 0) {\n      if (!settings.requireAuthentication) return cb(true);\n      if (!settings.requireAuthorization && req.session && req.session.user) return cb(true);\n    }\n\n    if (req.session && req.session.user && req.session.user.is_admin) return cb(true);\n\n    hooks.aCallFirst(\"authorize\", {req: req, res:res, next:next, resource: req.path}, hookResultMangle(cb));\n  }\n\n  var authenticate = function (cb) {\n    // If auth headers are present use them to authenticate...\n    if (req.headers.authorization && req.headers.authorization.search('Basic ') === 0) {\n      var userpass = new Buffer(req.headers.authorization.split(' ')[1], 'base64').toString().split(\":\")\n      var username = userpass.shift();\n      var password = userpass.join(':');\n\n      if (settings.users[username] != undefined && settings.users[username].password === password) {\n        settings.users[username].username = username;\n        req.session.user = settings.users[username];\n        return cb(true);\n      }\n      return hooks.aCallFirst(\"authenticate\", {req: req, res:res, next:next, username: username, password: password}, hookResultMangle(cb));\n    }\n    hooks.aCallFirst(\"authenticate\", {req: req, res:res, next:next}, hookResultMangle(cb));\n  }\n\n\n  /* Authentication OR authorization failed. */\n  var failure = function () {\n    return hooks.aCallFirst(\"authFailure\", {req: req, res:res, next:next}, hookResultMangle(function (ok) {\n    if (ok) return;\n      /* No plugin handler for invalid auth. Return Auth required\n       * Headers, delayed for 1 second, if authentication failed\n       * before. */\n      res.header('WWW-Authenticate', 'Basic realm=\"Protected Area\"');\n      if (req.headers.authorization) {\n        setTimeout(function () {\n          res.status(401).send('Authentication required');\n        }, 1000);\n      } else {\n        res.status(401).send('Authentication required');\n      }\n    }));\n  }\n\n\n  /* This is the actual authentication/authorization hoop. It is done in four steps:\n\n     1) Try to just access the thing\n     2) If not allowed using whatever creds are in the current session already, try to authenticate\n     3) If authentication using already supplied credentials succeeds, try to access the thing again\n     4) If all els fails, give the user a 401 to request new credentials\n\n     Note that the process could stop already in step 3 with a redirect to login page.\n\n  */\n\n  authorize(function (ok) {\n    if (ok) return next();\n    authenticate(function (ok) {\n      if (!ok) return failure();\n      authorize(function (ok) {\n        if (ok) return next();\n        failure();\n      });\n    });\n  });\n}\n\nexports.secret = null;\n\nexports.expressConfigure = function (hook_name, args, cb) {\n  // Measure response time\n  args.app.use(function(req, res, next) {\n    var stopWatch = stats.timer('httpRequests').start();\n    var sendFn = res.send\n    res.send = function() {\n      stopWatch.end()\n      sendFn.apply(res, arguments)\n    }\n    next()\n  })\n\n  // If the log level specified in the config file is WARN or ERROR the application server never starts listening to requests as reported in issue #158.\n  // Not installing the log4js connect logger when the log level has a higher severity than INFO since it would not log at that level anyway.\n  if (!(settings.loglevel === \"WARN\" || settings.loglevel == \"ERROR\"))\n    args.app.use(log4js.connectLogger(httpLogger, { level: log4js.levels.DEBUG, format: ':status, :method :url'}));\n\n  /* Do not let express create the session, so that we can retain a\n   * reference to it for socket.io to use. Also, set the key (cookie\n   * name) to a javascript identifier compatible string. Makes code\n   * handling it cleaner :) */\n\n  if (!exports.sessionStore) {\n    exports.sessionStore = new ueberStore();\n    exports.secret = settings.sessionKey;\n  }\n\n  args.app.sessionStore = exports.sessionStore;\n  args.app.use(sessionModule({secret: exports.secret, store: args.app.sessionStore, resave: true, saveUninitialized: true, name: 'express_sid', proxy: true, cookie: { secure: !!settings.ssl }}));\n\n  args.app.use(cookieParser(settings.sessionKey, {}));\n\n  args.app.use(exports.basicAuth);\n}\n\n"], "filenames": ["src/node/hooks/express/webaccess.js"], "buggy_code_start_loc": [23], "buggy_code_end_loc": [24], "fixing_code_start_loc": [23], "fixing_code_end_loc": [24], "type": "CWE-178", "message": "Etherpad Lite before 1.6.4 is exploitable for admin access.", "other": {"cve": {"id": "CVE-2018-9845", "sourceIdentifier": "cve@mitre.org", "published": "2018-04-29T18:29:00.223", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Etherpad Lite before 1.6.4 is exploitable for admin access."}, {"lang": "es", "value": "Etherpad Lite en versiones anteriores a la 1.6.4 es explotable para acceso de administrador."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-178"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:etherpad:etherpad_lite:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.6.4", "matchCriteriaId": "2DF30927-E1BF-44A1-A2ED-A7A81F662DF2"}]}]}], "references": [{"url": "https://github.com/ether/etherpad-lite/blob/develop/CHANGELOG.md", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/ether/etherpad-lite/commit/ffe24c3dd93efc73e0cbf924db9a0cc40be9511b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ether/etherpad-lite/commit/ffe24c3dd93efc73e0cbf924db9a0cc40be9511b"}}