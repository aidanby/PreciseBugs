{"buggy_code": ["// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strconv\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/projectcontour/contour/internal/controller\"\n\n\tenvoy_server_v3 \"github.com/envoyproxy/go-control-plane/pkg/server/v3\"\n\tcontour_api_v1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"\n\tcontour_api_v1alpha1 \"github.com/projectcontour/contour/apis/projectcontour/v1alpha1\"\n\t\"github.com/projectcontour/contour/internal/annotation\"\n\t\"github.com/projectcontour/contour/internal/contour\"\n\t\"github.com/projectcontour/contour/internal/dag\"\n\t\"github.com/projectcontour/contour/internal/debug\"\n\t\"github.com/projectcontour/contour/internal/health\"\n\t\"github.com/projectcontour/contour/internal/httpsvc\"\n\t\"github.com/projectcontour/contour/internal/k8s\"\n\t\"github.com/projectcontour/contour/internal/metrics\"\n\t\"github.com/projectcontour/contour/internal/timeout\"\n\t\"github.com/projectcontour/contour/internal/workgroup\"\n\t\"github.com/projectcontour/contour/internal/xds\"\n\tcontour_xds_v3 \"github.com/projectcontour/contour/internal/xds/v3\"\n\t\"github.com/projectcontour/contour/internal/xdscache\"\n\txdscache_v3 \"github.com/projectcontour/contour/internal/xdscache/v3\"\n\t\"github.com/projectcontour/contour/pkg/config\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/sirupsen/logrus\"\n\t\"gopkg.in/alecthomas/kingpin.v2\"\n\tcorev1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/client-go/dynamic\"\n\t\"k8s.io/client-go/tools/cache\"\n\tcontroller_config \"sigs.k8s.io/controller-runtime/pkg/client/config\"\n\t\"sigs.k8s.io/controller-runtime/pkg/manager\"\n\t\"sigs.k8s.io/controller-runtime/pkg/manager/signals\"\n\tgatewayapi_v1alpha1 \"sigs.k8s.io/gateway-api/apis/v1alpha1\"\n)\n\n// Add RBAC policy to support leader election.\n// +kubebuilder:rbac:groups=\"\",resources=configmaps,verbs=create;get;update\n\n// Add RBAC policy to support getting CRDs.\n// +kubebuilder:rbac:groups=\"apiextensions.k8s.io\",resources=customresourcedefinitions,verbs=list\n\n// registerServe registers the serve subcommand and flags\n// with the Application provided.\nfunc registerServe(app *kingpin.Application) (*kingpin.CmdClause, *serveContext) {\n\tserve := app.Command(\"serve\", \"Serve xDS API traffic.\")\n\n\t// The precedence of configuration for contour serve is as follows:\n\t// config file, overridden by env vars, overridden by cli flags.\n\t// however, as -c is a cli flag, we don't know its value til cli flags\n\t// have been parsed. To correct this ordering we assign a post parse\n\t// action to -c, then parse cli flags twice (see main.main). On the second\n\t// parse our action will return early, resulting in the precedence order\n\t// we want.\n\tvar (\n\t\tconfigFile string\n\t\tparsed     bool\n\t)\n\tctx := newServeContext()\n\n\tparseConfig := func(_ *kingpin.ParseContext) error {\n\t\tif parsed || configFile == \"\" {\n\t\t\t// if there is no config file supplied, or we've\n\t\t\t// already parsed it, return immediately.\n\t\t\treturn nil\n\t\t}\n\t\tf, err := os.Open(configFile)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer f.Close()\n\n\t\tparams, err := config.Parse(f)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := params.Validate(); err != nil {\n\t\t\treturn fmt.Errorf(\"invalid Contour configuration: %w\", err)\n\t\t}\n\n\t\tparsed = true\n\t\tctx.Config = *params\n\n\t\treturn nil\n\t}\n\n\tserve.Flag(\"config-path\", \"Path to base configuration.\").Short('c').PlaceHolder(\"/path/to/file\").Action(parseConfig).ExistingFileVar(&configFile)\n\n\tserve.Flag(\"incluster\", \"Use in cluster configuration.\").BoolVar(&ctx.Config.InCluster)\n\tserve.Flag(\"kubeconfig\", \"Path to kubeconfig (if not in running inside a cluster).\").PlaceHolder(\"/path/to/file\").StringVar(&ctx.Config.Kubeconfig)\n\n\tserve.Flag(\"xds-address\", \"xDS gRPC API address.\").PlaceHolder(\"<ipaddr>\").StringVar(&ctx.xdsAddr)\n\tserve.Flag(\"xds-port\", \"xDS gRPC API port.\").PlaceHolder(\"<port>\").IntVar(&ctx.xdsPort)\n\n\tserve.Flag(\"stats-address\", \"Envoy /stats interface address.\").PlaceHolder(\"<ipaddr>\").StringVar(&ctx.statsAddr)\n\tserve.Flag(\"stats-port\", \"Envoy /stats interface port.\").PlaceHolder(\"<port>\").IntVar(&ctx.statsPort)\n\n\tserve.Flag(\"debug-http-address\", \"Address the debug http endpoint will bind to.\").PlaceHolder(\"<ipaddr>\").StringVar(&ctx.debugAddr)\n\tserve.Flag(\"debug-http-port\", \"Port the debug http endpoint will bind to.\").PlaceHolder(\"<port>\").IntVar(&ctx.debugPort)\n\n\tserve.Flag(\"http-address\", \"Address the metrics HTTP endpoint will bind to.\").PlaceHolder(\"<ipaddr>\").StringVar(&ctx.metricsAddr)\n\tserve.Flag(\"http-port\", \"Port the metrics HTTP endpoint will bind to.\").PlaceHolder(\"<port>\").IntVar(&ctx.metricsPort)\n\tserve.Flag(\"health-address\", \"Address the health HTTP endpoint will bind to.\").PlaceHolder(\"<ipaddr>\").StringVar(&ctx.healthAddr)\n\tserve.Flag(\"health-port\", \"Port the health HTTP endpoint will bind to.\").PlaceHolder(\"<port>\").IntVar(&ctx.healthPort)\n\n\tserve.Flag(\"contour-cafile\", \"CA bundle file name for serving gRPC with TLS.\").Envar(\"CONTOUR_CAFILE\").StringVar(&ctx.caFile)\n\tserve.Flag(\"contour-cert-file\", \"Contour certificate file name for serving gRPC over TLS.\").PlaceHolder(\"/path/to/file\").Envar(\"CONTOUR_CERT_FILE\").StringVar(&ctx.contourCert)\n\tserve.Flag(\"contour-key-file\", \"Contour key file name for serving gRPC over TLS.\").PlaceHolder(\"/path/to/file\").Envar(\"CONTOUR_KEY_FILE\").StringVar(&ctx.contourKey)\n\tserve.Flag(\"insecure\", \"Allow serving without TLS secured gRPC.\").BoolVar(&ctx.PermitInsecureGRPC)\n\tserve.Flag(\"root-namespaces\", \"Restrict contour to searching these namespaces for root ingress routes.\").PlaceHolder(\"<ns,ns>\").StringVar(&ctx.rootNamespaces)\n\n\tserve.Flag(\"ingress-class-name\", \"Contour IngressClass name.\").PlaceHolder(\"<name>\").StringVar(&ctx.ingressClassName)\n\tserve.Flag(\"ingress-status-address\", \"Address to set in Ingress object status.\").PlaceHolder(\"<address>\").StringVar(&ctx.Config.IngressStatusAddress)\n\tserve.Flag(\"envoy-http-access-log\", \"Envoy HTTP access log.\").PlaceHolder(\"/path/to/file\").StringVar(&ctx.httpAccessLog)\n\tserve.Flag(\"envoy-https-access-log\", \"Envoy HTTPS access log.\").PlaceHolder(\"/path/to/file\").StringVar(&ctx.httpsAccessLog)\n\tserve.Flag(\"envoy-service-http-address\", \"Kubernetes Service address for HTTP requests.\").PlaceHolder(\"<ipaddr>\").StringVar(&ctx.httpAddr)\n\tserve.Flag(\"envoy-service-https-address\", \"Kubernetes Service address for HTTPS requests.\").PlaceHolder(\"<ipaddr>\").StringVar(&ctx.httpsAddr)\n\tserve.Flag(\"envoy-service-http-port\", \"Kubernetes Service port for HTTP requests.\").PlaceHolder(\"<port>\").IntVar(&ctx.httpPort)\n\tserve.Flag(\"envoy-service-https-port\", \"Kubernetes Service port for HTTPS requests.\").PlaceHolder(\"<port>\").IntVar(&ctx.httpsPort)\n\tserve.Flag(\"envoy-service-name\", \"Name of the Envoy service to inspect for Ingress status details.\").PlaceHolder(\"<name>\").StringVar(&ctx.Config.EnvoyServiceName)\n\tserve.Flag(\"envoy-service-namespace\", \"Envoy Service Namespace.\").PlaceHolder(\"<namespace>\").StringVar(&ctx.Config.EnvoyServiceNamespace)\n\tserve.Flag(\"use-proxy-protocol\", \"Use PROXY protocol for all listeners.\").BoolVar(&ctx.useProxyProto)\n\n\tserve.Flag(\"accesslog-format\", \"Format for Envoy access logs.\").PlaceHolder(\"<envoy|json>\").StringVar((*string)(&ctx.Config.AccessLogFormat))\n\tserve.Flag(\"disable-leader-election\", \"Disable leader election mechanism.\").BoolVar(&ctx.DisableLeaderElection)\n\n\tserve.Flag(\"debug\", \"Enable debug logging.\").Short('d').BoolVar(&ctx.Config.Debug)\n\tserve.Flag(\"kubernetes-debug\", \"Enable Kubernetes client debug logging with log level.\").PlaceHolder(\"<log level>\").UintVar(&ctx.KubernetesDebug)\n\treturn serve, ctx\n}\n\n// validateCRDs inspects all CRDs in the projectcontour.io group and logs a warning\n// if they have spec.preserveUnknownFields set to true, since this indicates that they\n// were created as v1beta1 and the user has not upgraded them to be fully v1-compatible.\nfunc validateCRDs(dynamicClient dynamic.Interface, log logrus.FieldLogger) {\n\tclient := dynamicClient.Resource(schema.GroupVersionResource{Group: \"apiextensions.k8s.io\", Version: \"v1\", Resource: \"customresourcedefinitions\"})\n\n\tcrds, err := client.List(context.TODO(), metav1.ListOptions{})\n\tif err != nil {\n\t\tlog.Warnf(\"error listing v1 custom resource definitions: %v\", err)\n\t\treturn\n\t}\n\n\tfor _, crd := range crds.Items {\n\t\tlog = log.WithField(\"crd\", crd.GetName())\n\n\t\tif group, _, _ := unstructured.NestedString(crd.Object, \"spec\", \"group\"); group != contour_api_v1.GroupName {\n\t\t\tlog.Debugf(\"CRD is not in projectcontour.io API group, ignoring\")\n\t\t\tcontinue\n\t\t}\n\n\t\tpreserveUnknownFields, found, err := unstructured.NestedBool(crd.Object, \"spec\", \"preserveUnknownFields\")\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"error getting CRD's spec.preserveUnknownFields value: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif found && preserveUnknownFields {\n\t\t\tlog.Warnf(\"CRD was created as v1beta1 since it has spec.preserveUnknownFields set to true; it should be upgraded to v1 per https://projectcontour.io/resources/upgrading/\")\n\t\t\tcontinue\n\t\t}\n\n\t\tlog.Debugf(\"CRD is fully v1-compatible since it has spec.preserveUnknownFields set to false\")\n\t}\n}\n\n// doServe runs the contour serve subcommand.\nfunc doServe(log logrus.FieldLogger, ctx *serveContext) error {\n\t// Establish k8s core & dynamic client connections.\n\tclients, err := k8s.NewClients(ctx.Config.Kubeconfig, ctx.Config.InCluster)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create Kubernetes clients: %w\", err)\n\t}\n\n\t// Validate that Contour CRDs have been updated to v1.\n\tvalidateCRDs(clients.DynamicClient(), log)\n\n\t// informerNamespaces is a list of namespaces that we should start informers for.\n\tvar informerNamespaces []string\n\n\tfallbackCert := namespacedNameOf(ctx.Config.TLS.FallbackCertificate)\n\tclientCert := namespacedNameOf(ctx.Config.TLS.ClientCertificate)\n\n\tif rootNamespaces := ctx.proxyRootNamespaces(); len(rootNamespaces) > 0 {\n\t\tinformerNamespaces = append(informerNamespaces, rootNamespaces...)\n\n\t\t// Add the FallbackCertificateNamespace to informerNamespaces if it isn't present.\n\t\tif !contains(informerNamespaces, ctx.Config.TLS.FallbackCertificate.Namespace) && fallbackCert != nil {\n\t\t\tinformerNamespaces = append(informerNamespaces, ctx.Config.TLS.FallbackCertificate.Namespace)\n\t\t\tlog.WithField(\"context\", \"fallback-certificate\").\n\t\t\t\tInfof(\"fallback certificate namespace %q not defined in 'root-namespaces', adding namespace to watch\",\n\t\t\t\t\tctx.Config.TLS.FallbackCertificate.Namespace)\n\t\t}\n\n\t\t// Add the client certificate namespace to informerNamespaces if it isn't present.\n\t\tif !contains(informerNamespaces, ctx.Config.TLS.ClientCertificate.Namespace) && clientCert != nil {\n\t\t\tinformerNamespaces = append(informerNamespaces, ctx.Config.TLS.ClientCertificate.Namespace)\n\t\t\tlog.WithField(\"context\", \"envoy-client-certificate\").\n\t\t\t\tInfof(\"client certificate namespace %q not defined in 'root-namespaces', adding namespace to watch\",\n\t\t\t\t\tctx.Config.TLS.ClientCertificate.Namespace)\n\t\t}\n\t}\n\n\t// Set up Prometheus registry and register base metrics.\n\tregistry := prometheus.NewRegistry()\n\tregistry.MustRegister(prometheus.NewProcessCollector(prometheus.ProcessCollectorOpts{}))\n\tregistry.MustRegister(prometheus.NewGoCollector())\n\n\t// Before we can build the event handler, we need to initialize the converter we'll\n\t// use to convert from Unstructured.\n\tconverter, err := k8s.NewUnstructuredConverter()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// XXX(jpeach) we know the config file validated, so all\n\t// the timeouts will parse. Shall we add a `timeout.MustParse()`\n\t// and use it here?\n\n\tconnectionIdleTimeout, err := timeout.Parse(ctx.Config.Timeouts.ConnectionIdleTimeout)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing connection idle timeout: %w\", err)\n\t}\n\tstreamIdleTimeout, err := timeout.Parse(ctx.Config.Timeouts.StreamIdleTimeout)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing stream idle timeout: %w\", err)\n\t}\n\tdelayedCloseTimeout, err := timeout.Parse(ctx.Config.Timeouts.DelayedCloseTimeout)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing delayed close timeout: %w\", err)\n\t}\n\tmaxConnectionDuration, err := timeout.Parse(ctx.Config.Timeouts.MaxConnectionDuration)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing max connection duration: %w\", err)\n\t}\n\tconnectionShutdownGracePeriod, err := timeout.Parse(ctx.Config.Timeouts.ConnectionShutdownGracePeriod)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing connection shutdown grace period: %w\", err)\n\t}\n\trequestTimeout, err := timeout.Parse(ctx.Config.Timeouts.RequestTimeout)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing request timeout: %w\", err)\n\t}\n\n\t// connection balancer\n\tif ok := ctx.Config.Listener.ConnectionBalancer == \"exact\" || ctx.Config.Listener.ConnectionBalancer == \"\"; !ok {\n\t\tlog.Warnf(\"Invalid listener connection balancer value %q. Only 'exact' connection balancing is supported for now.\", ctx.Config.Listener.ConnectionBalancer)\n\t\tctx.Config.Listener.ConnectionBalancer = \"\"\n\t}\n\n\tlistenerConfig := xdscache_v3.ListenerConfig{\n\t\tUseProxyProto: ctx.useProxyProto,\n\t\tHTTPListeners: map[string]xdscache_v3.Listener{\n\t\t\t\"ingress_http\": {\n\t\t\t\tName:    \"ingress_http\",\n\t\t\t\tAddress: ctx.httpAddr,\n\t\t\t\tPort:    ctx.httpPort,\n\t\t\t},\n\t\t},\n\t\tHTTPSListeners: map[string]xdscache_v3.Listener{\n\t\t\t\"ingress_https\": {\n\t\t\t\tName:    \"ingress_https\",\n\t\t\t\tAddress: ctx.httpsAddr,\n\t\t\t\tPort:    ctx.httpsPort,\n\t\t\t},\n\t\t},\n\t\tHTTPAccessLog:                 ctx.httpAccessLog,\n\t\tHTTPSAccessLog:                ctx.httpsAccessLog,\n\t\tAccessLogType:                 ctx.Config.AccessLogFormat,\n\t\tAccessLogFields:               ctx.Config.AccessLogFields,\n\t\tMinimumTLSVersion:             annotation.MinTLSVersion(ctx.Config.TLS.MinimumProtocolVersion, \"1.2\"),\n\t\tCipherSuites:                  config.SanitizeCipherSuites(ctx.Config.TLS.CipherSuites),\n\t\tRequestTimeout:                requestTimeout,\n\t\tConnectionIdleTimeout:         connectionIdleTimeout,\n\t\tStreamIdleTimeout:             streamIdleTimeout,\n\t\tDelayedCloseTimeout:           delayedCloseTimeout,\n\t\tMaxConnectionDuration:         maxConnectionDuration,\n\t\tConnectionShutdownGracePeriod: connectionShutdownGracePeriod,\n\t\tDefaultHTTPVersions:           parseDefaultHTTPVersions(ctx.Config.DefaultHTTPVersions),\n\t\tAllowChunkedLength:            !ctx.Config.DisableAllowChunkedLength,\n\t\tXffNumTrustedHops:             ctx.Config.Network.XffNumTrustedHops,\n\t\tConnectionBalancer:            ctx.Config.Listener.ConnectionBalancer,\n\t}\n\n\tif ctx.Config.RateLimitService.ExtensionService != \"\" {\n\t\tnamespacedName := k8s.NamespacedNameFrom(ctx.Config.RateLimitService.ExtensionService)\n\t\tclient := clients.DynamicClient().Resource(contour_api_v1alpha1.ExtensionServiceGVR).Namespace(namespacedName.Namespace)\n\n\t\t// ensure the specified ExtensionService exists\n\t\tres, err := client.Get(context.Background(), namespacedName.Name, metav1.GetOptions{})\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error getting rate limit extension service %s: %v\", namespacedName, err)\n\t\t}\n\t\tvar extensionSvc contour_api_v1alpha1.ExtensionService\n\t\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(res.Object, &extensionSvc); err != nil {\n\t\t\treturn fmt.Errorf(\"error converting rate limit extension service %s: %v\", namespacedName, err)\n\t\t}\n\t\t// get the response timeout from the ExtensionService\n\t\tvar responseTimeout timeout.Setting\n\t\tif tp := extensionSvc.Spec.TimeoutPolicy; tp != nil {\n\t\t\tresponseTimeout, err = timeout.Parse(tp.Response)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"error parsing rate limit extension service %s response timeout: %v\", namespacedName, err)\n\t\t\t}\n\t\t}\n\n\t\tlistenerConfig.RateLimitConfig = &xdscache_v3.RateLimitConfig{\n\t\t\tExtensionService:        namespacedName,\n\t\t\tDomain:                  ctx.Config.RateLimitService.Domain,\n\t\t\tTimeout:                 responseTimeout,\n\t\t\tFailOpen:                ctx.Config.RateLimitService.FailOpen,\n\t\t\tEnableXRateLimitHeaders: ctx.Config.RateLimitService.EnableXRateLimitHeaders,\n\t\t}\n\t}\n\n\tcontourMetrics := metrics.NewMetrics(registry)\n\n\t// Endpoints updates are handled directly by the EndpointsTranslator\n\t// due to their high update rate and their orthogonal nature.\n\tendpointHandler := xdscache_v3.NewEndpointsTranslator(log.WithField(\"context\", \"endpointstranslator\"))\n\n\tresources := []xdscache.ResourceCache{\n\t\txdscache_v3.NewListenerCache(listenerConfig, ctx.statsAddr, ctx.statsPort),\n\t\t&xdscache_v3.SecretCache{},\n\t\t&xdscache_v3.RouteCache{},\n\t\t&xdscache_v3.ClusterCache{},\n\t\tendpointHandler,\n\t}\n\n\t// snapshotHandler is used to produce new snapshots when the internal state changes for any xDS resource.\n\tsnapshotHandler := xdscache.NewSnapshotHandler(resources, log.WithField(\"context\", \"snapshotHandler\"))\n\n\t// register observer for endpoints updates.\n\tendpointHandler.Observer = contour.ComposeObservers(snapshotHandler)\n\n\t// Log that we're using the fallback certificate if configured.\n\tif fallbackCert != nil {\n\t\tlog.WithField(\"context\", \"fallback-certificate\").Infof(\"enabled fallback certificate with secret: %q\", fallbackCert)\n\t}\n\tif clientCert != nil {\n\t\tlog.WithField(\"context\", \"envoy-client-certificate\").Infof(\"enabled client certificate with secret: %q\", clientCert)\n\t}\n\n\t// Build the core Kubernetes event handler.\n\teventHandler := &contour.EventHandler{\n\t\tHoldoffDelay:    100 * time.Millisecond,\n\t\tHoldoffMaxDelay: 500 * time.Millisecond,\n\t\tObserver:        dag.ComposeObservers(append(xdscache.ObserversOf(resources), snapshotHandler)...),\n\t\tBuilder:         getDAGBuilder(ctx, clients, clientCert, fallbackCert, log),\n\t\tFieldLogger:     log.WithField(\"context\", \"contourEventHandler\"),\n\t}\n\n\t// Wrap eventHandler in a converter for objects from the dynamic client.\n\t// and an EventRecorder which tracks API server events.\n\tdynamicHandler := k8s.DynamicClientHandler{\n\t\tNext: &contour.EventRecorder{\n\t\t\tNext:    eventHandler,\n\t\t\tCounter: contourMetrics.EventHandlerOperations,\n\t\t},\n\t\tConverter: converter,\n\t\tLogger:    log.WithField(\"context\", \"dynamicHandler\"),\n\t}\n\n\t// Inform on DefaultResources.\n\tfor _, r := range k8s.DefaultResources() {\n\t\tinf, err := clients.InformerForResource(r)\n\t\tif err != nil {\n\t\t\tlog.WithError(err).WithField(\"resource\", r).Fatal(\"failed to create informer\")\n\t\t}\n\n\t\tinf.AddEventHandler(&dynamicHandler)\n\t}\n\n\tfor _, r := range k8s.IngressV1Resources() {\n\t\tif err := informOnResource(clients, r, &dynamicHandler); err != nil {\n\t\t\tlog.WithError(err).WithField(\"resource\", r).Fatal(\"failed to create informer\")\n\t\t}\n\t}\n\n\t// Set up workgroup runner and register informers.\n\tvar g workgroup.Group\n\n\t// Only inform on Gateway API resources if Gateway API is found.\n\tif ctx.Config.GatewayConfig != nil {\n\t\tif clients.ResourcesExist(k8s.GatewayAPIResources()...) {\n\n\t\t\t// Setup a Manager\n\t\t\tmgr, err := manager.New(controller_config.GetConfigOrDie(), manager.Options{})\n\t\t\tif err != nil {\n\t\t\t\tlog.WithError(err).Fatal(\"unable to set up controller manager\")\n\t\t\t}\n\n\t\t\t// Add the Gateway API Scheme.\n\t\t\terr = gatewayapi_v1alpha1.AddToScheme(mgr.GetScheme())\n\t\t\tif err != nil {\n\t\t\t\tlog.WithError(err).Fatal(\"unable to add Gateway API to scheme.\")\n\t\t\t}\n\n\t\t\t// Create and register the gatewayclass controller with the manager.\n\t\t\tgatewayClassControllerName := ctx.Config.GatewayConfig.ControllerName\n\t\t\tif _, err := controller.NewGatewayClassController(mgr, &dynamicHandler,\n\t\t\t\tlog.WithField(\"context\", \"gatewayclass-controller\"), gatewayClassControllerName); err != nil {\n\t\t\t\tlog.WithError(err).Fatal(\"failed to create gatewayclass-controller\")\n\t\t\t}\n\n\t\t\t// Create and register the NewGatewayController controller with the manager.\n\t\t\tif _, err := controller.NewGatewayController(mgr, &dynamicHandler,\n\t\t\t\tlog.WithField(\"context\", \"gateway-controller\"), gatewayClassControllerName); err != nil {\n\t\t\t\tlog.WithError(err).Fatal(\"failed to create gateway-controller\")\n\t\t\t}\n\n\t\t\t// Create and register the NewHTTPRouteController controller with the manager.\n\t\t\tif _, err := controller.NewHTTPRouteController(mgr, &dynamicHandler, log.WithField(\"context\", \"httproute-controller\")); err != nil {\n\t\t\t\tlog.WithError(err).Fatal(\"failed to create httproute-controller\")\n\t\t\t}\n\n\t\t\t// Create and register the NewTLSRouteController controller with the manager.\n\t\t\tif _, err := controller.NewTLSRouteController(mgr, &dynamicHandler, log.WithField(\"context\", \"tlsroute-controller\")); err != nil {\n\t\t\t\tlog.WithError(err).Fatal(\"failed to create tlsroute-controller\")\n\t\t\t}\n\n\t\t\t// Inform on Namespaces.\n\t\t\tif err := informOnResource(clients, k8s.NamespacesResource(), &dynamicHandler); err != nil {\n\t\t\t\tlog.WithError(err).WithField(\"resource\", k8s.NamespacesResource()).Fatal(\"failed to create informer\")\n\t\t\t}\n\n\t\t\t// Start Manager\n\t\t\tg.AddContext(func(taskCtx context.Context) error {\n\t\t\t\treturn mgr.Start(signals.SetupSignalHandler())\n\t\t\t})\n\t\t} else {\n\t\t\tlog.Fatalf(\"Gateway API Gateway configured but APIs not installed in cluster.\")\n\t\t}\n\t}\n\n\t// Inform on secrets, filtering by root namespaces.\n\tfor _, r := range k8s.SecretsResources() {\n\t\tvar handler cache.ResourceEventHandler = &dynamicHandler\n\n\t\t// If root namespaces are defined, filter for secrets in only those namespaces.\n\t\tif len(informerNamespaces) > 0 {\n\t\t\thandler = k8s.NewNamespaceFilter(informerNamespaces, &dynamicHandler)\n\t\t}\n\n\t\tif err := informOnResource(clients, r, handler); err != nil {\n\t\t\tlog.WithError(err).WithField(\"resource\", r).Fatal(\"failed to create informer\")\n\t\t}\n\t}\n\n\t// Inform on endpoints.\n\tfor _, r := range k8s.EndpointsResources() {\n\t\tif err := informOnResource(clients, r, &k8s.DynamicClientHandler{\n\t\t\tNext: &contour.EventRecorder{\n\t\t\t\tNext:    endpointHandler,\n\t\t\t\tCounter: contourMetrics.EventHandlerOperations,\n\t\t\t},\n\t\t\tConverter: converter,\n\t\t\tLogger:    log.WithField(\"context\", \"endpointstranslator\"),\n\t\t}); err != nil {\n\t\t\tlog.WithError(err).WithField(\"resource\", r).Fatal(\"failed to create informer\")\n\t\t}\n\t}\n\n\t// Register a task to start all the informers.\n\tg.AddContext(func(taskCtx context.Context) error {\n\t\tlog := log.WithField(\"context\", \"informers\")\n\n\t\tlog.Info(\"starting informers\")\n\t\tdefer log.Println(\"stopped informers\")\n\n\t\tif err := clients.StartInformers(taskCtx); err != nil {\n\t\t\tlog.WithError(err).Error(\"failed to start informers\")\n\t\t}\n\n\t\t<-taskCtx.Done()\n\t\treturn nil\n\t})\n\n\t// Register our event handler with the workgroup.\n\tg.Add(eventHandler.Start())\n\n\t// Create metrics service and register with workgroup.\n\tmetricsvc := httpsvc.Service{\n\t\tAddr:        ctx.metricsAddr,\n\t\tPort:        ctx.metricsPort,\n\t\tFieldLogger: log.WithField(\"context\", \"metricsvc\"),\n\t\tServeMux:    http.ServeMux{},\n\t}\n\n\tmetricsvc.ServeMux.Handle(\"/metrics\", metrics.Handler(registry))\n\n\tif ctx.healthAddr == ctx.metricsAddr && ctx.healthPort == ctx.metricsPort {\n\t\th := health.Handler(clients.ClientSet())\n\t\tmetricsvc.ServeMux.Handle(\"/health\", h)\n\t\tmetricsvc.ServeMux.Handle(\"/healthz\", h)\n\t}\n\n\tg.Add(metricsvc.Start)\n\n\t// Create a separate health service if required.\n\tif ctx.healthAddr != ctx.metricsAddr || ctx.healthPort != ctx.metricsPort {\n\t\thealthsvc := httpsvc.Service{\n\t\t\tAddr:        ctx.healthAddr,\n\t\t\tPort:        ctx.healthPort,\n\t\t\tFieldLogger: log.WithField(\"context\", \"healthsvc\"),\n\t\t}\n\n\t\th := health.Handler(clients.ClientSet())\n\t\thealthsvc.ServeMux.Handle(\"/health\", h)\n\t\thealthsvc.ServeMux.Handle(\"/healthz\", h)\n\n\t\tg.Add(healthsvc.Start)\n\t}\n\n\t// Create debug service and register with workgroup.\n\tdebugsvc := debug.Service{\n\t\tService: httpsvc.Service{\n\t\t\tAddr:        ctx.debugAddr,\n\t\t\tPort:        ctx.debugPort,\n\t\t\tFieldLogger: log.WithField(\"context\", \"debugsvc\"),\n\t\t},\n\t\tBuilder: &eventHandler.Builder,\n\t}\n\tg.Add(debugsvc.Start)\n\n\t// Register leadership election.\n\tif ctx.DisableLeaderElection {\n\t\teventHandler.IsLeader = disableLeaderElection(log)\n\t} else {\n\t\teventHandler.IsLeader = setupLeadershipElection(&g, log, &ctx.Config.LeaderElection, clients, eventHandler.UpdateNow)\n\t}\n\n\t// Once we have the leadership detection channel, we can\n\t// push DAG rebuild metrics onto the observer stack.\n\teventHandler.Observer = &contour.RebuildMetricsObserver{\n\t\tMetrics:      contourMetrics,\n\t\tIsLeader:     eventHandler.IsLeader,\n\t\tNextObserver: eventHandler.Observer,\n\t}\n\n\tsh := k8s.StatusUpdateHandler{\n\t\tLog:           log.WithField(\"context\", \"StatusUpdateHandler\"),\n\t\tClients:       clients,\n\t\tLeaderElected: eventHandler.IsLeader,\n\t\tConverter:     converter,\n\t}\n\tg.Add(sh.Start)\n\n\t// Now we have the statusUpdateHandler, we can create the event handler's StatusUpdater, which will take the\n\t// status updates from the DAG, and send them to the status update handler.\n\teventHandler.StatusUpdater = sh.Writer()\n\n\t// Set up ingress load balancer status writer.\n\tlbsw := loadBalancerStatusWriter{\n\t\tlog:              log.WithField(\"context\", \"loadBalancerStatusWriter\"),\n\t\tclients:          clients,\n\t\tisLeader:         eventHandler.IsLeader,\n\t\tlbStatus:         make(chan corev1.LoadBalancerStatus, 1),\n\t\tingressClassName: ctx.ingressClassName,\n\t\tstatusUpdater:    sh.Writer(),\n\t\tConverter:        converter,\n\t}\n\tg.Add(lbsw.Start)\n\n\t// Register an informer to watch envoy's service if we haven't been given static details.\n\tif lbAddr := ctx.Config.IngressStatusAddress; lbAddr != \"\" {\n\t\tlog.WithField(\"loadbalancer-address\", lbAddr).Info(\"Using supplied information for Ingress status\")\n\t\tlbsw.lbStatus <- parseStatusFlag(lbAddr)\n\t} else {\n\t\tdynamicServiceHandler := k8s.DynamicClientHandler{\n\t\t\tNext: &k8s.ServiceStatusLoadBalancerWatcher{\n\t\t\t\tServiceName: ctx.Config.EnvoyServiceName,\n\t\t\t\tLBStatus:    lbsw.lbStatus,\n\t\t\t\tLog:         log.WithField(\"context\", \"serviceStatusLoadBalancerWatcher\"),\n\t\t\t},\n\t\t\tConverter: converter,\n\t\t\tLogger:    log.WithField(\"context\", \"serviceStatusLoadBalancerWatcher\"),\n\t\t}\n\n\t\tfor _, r := range k8s.ServicesResources() {\n\t\t\tvar handler cache.ResourceEventHandler = &dynamicServiceHandler\n\n\t\t\tif ctx.Config.EnvoyServiceNamespace != \"\" {\n\t\t\t\thandler = k8s.NewNamespaceFilter([]string{ctx.Config.EnvoyServiceNamespace}, handler)\n\t\t\t}\n\n\t\t\tif err := informOnResource(clients, r, handler); err != nil {\n\t\t\t\tlog.WithError(err).WithField(\"resource\", r).Fatal(\"failed to create informer\")\n\t\t\t}\n\t\t}\n\n\t\tlog.WithField(\"envoy-service-name\", ctx.Config.EnvoyServiceName).\n\t\t\tWithField(\"envoy-service-namespace\", ctx.Config.EnvoyServiceNamespace).\n\t\t\tInfo(\"Watching Service for Ingress status\")\n\t}\n\n\tg.AddContext(func(taskCtx context.Context) error {\n\t\tlog := log.WithField(\"context\", \"xds\")\n\n\t\tlog.Printf(\"waiting for informer caches to sync\")\n\t\tif !clients.WaitForCacheSync(taskCtx) {\n\t\t\treturn errors.New(\"informer cache failed to sync\")\n\t\t}\n\t\tlog.Printf(\"informer caches synced\")\n\n\t\tgrpcServer := xds.NewServer(registry, ctx.grpcOptions(log)...)\n\n\t\tswitch ctx.Config.Server.XDSServerType {\n\t\tcase config.EnvoyServerType:\n\t\t\tv3cache := contour_xds_v3.NewSnapshotCache(false, log)\n\t\t\tsnapshotHandler.AddSnapshotter(v3cache)\n\t\t\tcontour_xds_v3.RegisterServer(envoy_server_v3.NewServer(taskCtx, v3cache, contour_xds_v3.NewRequestLoggingCallbacks(log)), grpcServer)\n\t\tcase config.ContourServerType:\n\t\t\tcontour_xds_v3.RegisterServer(contour_xds_v3.NewContourServer(log, xdscache.ResourcesOf(resources)...), grpcServer)\n\t\tdefault:\n\t\t\t// This can't happen due to config validation.\n\t\t\tlog.Fatalf(\"invalid xDS server type %q\", ctx.Config.Server.XDSServerType)\n\t\t}\n\n\t\taddr := net.JoinHostPort(ctx.xdsAddr, strconv.Itoa(ctx.xdsPort))\n\t\tl, err := net.Listen(\"tcp\", addr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tlog = log.WithField(\"address\", addr)\n\t\tif ctx.PermitInsecureGRPC {\n\t\t\tlog = log.WithField(\"insecure\", true)\n\t\t}\n\n\t\tlog.Infof(\"started xDS server type: %q\", ctx.Config.Server.XDSServerType)\n\t\tdefer log.Info(\"stopped xDS server\")\n\n\t\tgo func() {\n\t\t\t<-taskCtx.Done()\n\n\t\t\t// We don't use GracefulStop here because envoy\n\t\t\t// has long-lived hanging xDS requests. There's no\n\t\t\t// mechanism to make those pending requests fail,\n\t\t\t// so we forcibly terminate the TCP sessions.\n\t\t\tgrpcServer.Stop()\n\t\t}()\n\n\t\treturn grpcServer.Serve(l)\n\t})\n\n\t// Set up SIGTERM handler for graceful shutdown.\n\tg.Add(func(stop <-chan struct{}) error {\n\t\tc := make(chan os.Signal, 1)\n\t\tsignal.Notify(c, syscall.SIGTERM, syscall.SIGINT)\n\t\tselect {\n\t\tcase sig := <-c:\n\t\t\tlog.WithField(\"context\", \"sigterm-handler\").WithField(\"signal\", sig).Info(\"shutting down\")\n\t\tcase <-stop:\n\t\t\t// Do nothing. The group is shutting down.\n\t\t}\n\t\treturn nil\n\t})\n\n\t// GO!\n\treturn g.Run(context.Background())\n}\n\nfunc getDAGBuilder(ctx *serveContext, clients *k8s.Clients, clientCert, fallbackCert *types.NamespacedName, log logrus.FieldLogger) dag.Builder {\n\tvar requestHeadersPolicy dag.HeadersPolicy\n\tif ctx.Config.Policy.RequestHeadersPolicy.Set != nil {\n\t\trequestHeadersPolicy.Set = make(map[string]string)\n\t\tfor k, v := range ctx.Config.Policy.RequestHeadersPolicy.Set {\n\t\t\trequestHeadersPolicy.Set[k] = v\n\t\t}\n\t}\n\tif ctx.Config.Policy.RequestHeadersPolicy.Remove != nil {\n\t\trequestHeadersPolicy.Remove = make([]string, 0, len(ctx.Config.Policy.RequestHeadersPolicy.Remove))\n\t\trequestHeadersPolicy.Remove = append(requestHeadersPolicy.Remove, ctx.Config.Policy.RequestHeadersPolicy.Remove...)\n\t}\n\n\tvar responseHeadersPolicy dag.HeadersPolicy\n\tif ctx.Config.Policy.ResponseHeadersPolicy.Set != nil {\n\t\tresponseHeadersPolicy.Set = make(map[string]string)\n\t\tfor k, v := range ctx.Config.Policy.ResponseHeadersPolicy.Set {\n\t\t\tresponseHeadersPolicy.Set[k] = v\n\t\t}\n\t}\n\tif ctx.Config.Policy.ResponseHeadersPolicy.Remove != nil {\n\t\tresponseHeadersPolicy.Remove = make([]string, 0, len(ctx.Config.Policy.ResponseHeadersPolicy.Remove))\n\t\tresponseHeadersPolicy.Remove = append(responseHeadersPolicy.Remove, ctx.Config.Policy.ResponseHeadersPolicy.Remove...)\n\t}\n\n\t// Get the appropriate DAG processors.\n\tdagProcessors := []dag.Processor{\n\t\t&dag.IngressProcessor{\n\t\t\tFieldLogger:       log.WithField(\"context\", \"IngressProcessor\"),\n\t\t\tClientCertificate: clientCert,\n\t\t},\n\t\t&dag.ExtensionServiceProcessor{\n\t\t\tFieldLogger:       log.WithField(\"context\", \"ExtensionServiceProcessor\"),\n\t\t\tClientCertificate: clientCert,\n\t\t},\n\t\t&dag.HTTPProxyProcessor{\n\t\t\tDisablePermitInsecure: ctx.Config.DisablePermitInsecure,\n\t\t\tFallbackCertificate:   fallbackCert,\n\t\t\tDNSLookupFamily:       ctx.Config.Cluster.DNSLookupFamily,\n\t\t\tClientCertificate:     clientCert,\n\t\t\tRequestHeadersPolicy:  &requestHeadersPolicy,\n\t\t\tResponseHeadersPolicy: &responseHeadersPolicy,\n\t\t},\n\t}\n\n\tif ctx.Config.GatewayConfig != nil && clients.ResourcesExist(k8s.GatewayAPIResources()...) {\n\t\tdagProcessors = append(dagProcessors, &dag.GatewayAPIProcessor{\n\t\t\tFieldLogger: log.WithField(\"context\", \"GatewayAPIProcessor\"),\n\t\t})\n\t}\n\n\t// The listener processor has to go last since it looks at\n\t// the output of the other processors.\n\tdagProcessors = append(dagProcessors, &dag.ListenerProcessor{})\n\n\tvar configuredSecretRefs []*types.NamespacedName\n\tif fallbackCert != nil {\n\t\tconfiguredSecretRefs = append(configuredSecretRefs, fallbackCert)\n\t}\n\tif clientCert != nil {\n\t\tconfiguredSecretRefs = append(configuredSecretRefs, clientCert)\n\t}\n\n\tbuilder := dag.Builder{\n\t\tSource: dag.KubernetesCache{\n\t\t\tRootNamespaces:       ctx.proxyRootNamespaces(),\n\t\t\tIngressClassName:     ctx.ingressClassName,\n\t\t\tConfiguredSecretRefs: configuredSecretRefs,\n\t\t\tFieldLogger:          log.WithField(\"context\", \"KubernetesCache\"),\n\t\t},\n\t\tProcessors: dagProcessors,\n\t}\n\n\tif ctx.Config.GatewayConfig != nil {\n\n\t\t// Log warning that the Name/Namespace fields in the configuration file are deprecated.\n\t\tif len(ctx.Config.GatewayConfig.Name) > 0 || len(ctx.Config.GatewayConfig.Namespace) > 0 {\n\t\t\tlog.WithField(\"context\", \"configurationFile\").Warn(\"Gateway.Name & Gateway.Namespace have been deprecated and will be removed in Contour v1.18. Please use Gateway.ControllerName instead.\")\n\t\t}\n\n\t\tbuilder.Source.ConfiguredGateway = types.NamespacedName{\n\t\t\tName:      ctx.Config.GatewayConfig.Name,\n\t\t\tNamespace: ctx.Config.GatewayConfig.Namespace,\n\t\t}\n\t}\n\n\t// govet complains about copying the sync.Once that's in the dag.KubernetesCache\n\t// but it's safe to ignore since this function is only called once.\n\t// nolint:govet\n\treturn builder\n}\n\nfunc contains(namespaces []string, ns string) bool {\n\tfor _, namespace := range namespaces {\n\t\tif ns == namespace {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc informOnResource(clients *k8s.Clients, gvr schema.GroupVersionResource, handler cache.ResourceEventHandler) error {\n\tinf, err := clients.InformerForResource(gvr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tinf.AddEventHandler(handler)\n\treturn nil\n}\n", "---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: contour\n  namespace: projectcontour\ndata:\n  contour.yaml: |\n    #\n    # server:\n    #   determine which XDS Server implementation to utilize in Contour.\n    #   xds-server-type: contour\n    #\n    # Specify the Gateway API configuration.\n    # gateway:\n    #   controllerName: projectcontour.io/projectcontour/contour\n    #   name: contour\n    #   namespace: projectcontour\n    #\n    # should contour expect to be running inside a k8s cluster\n    # incluster: true\n    #\n    # path to kubeconfig (if not running inside a k8s cluster)\n    # kubeconfig: /path/to/.kube/config\n    #\n    # Disable RFC-compliant behavior to strip \"Content-Length\" header if\n    # \"Tranfer-Encoding: chunked\" is also set.\n    # disableAllowChunkedLength: false\n    # Disable HTTPProxy permitInsecure field\n    disablePermitInsecure: false\n    tls:\n    # minimum TLS version that Contour will negotiate\n    # minimum-protocol-version: \"1.2\"\n    # TLS ciphers to be supported by Envoy TLS listeners when negotiating\n    # TLS 1.2.\n    # cipher-suites:\n    # - '[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]'\n    # - '[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]'\n    # - 'ECDHE-ECDSA-AES256-GCM-SHA384'\n    # - 'ECDHE-RSA-AES256-GCM-SHA384'\n    # Defines the Kubernetes name/namespace matching a secret to use\n    # as the fallback certificate when requests which don't match the\n    # SNI defined for a vhost.\n      fallback-certificate:\n    #   name: fallback-secret-name\n    #   namespace: projectcontour\n      envoy-client-certificate:\n    #   name: envoy-client-cert-secret-name\n    #   namespace: projectcontour\n    # The following config shows the defaults for the leader election.\n    # leaderelection:\n    #   configmap-name: leader-elect\n    #   configmap-namespace: projectcontour\n    ### Logging options\n    # Default setting\n    accesslog-format: envoy\n    # To enable JSON logging in Envoy\n    # accesslog-format: json\n    # The default fields that will be logged are specified below.\n    # To customise this list, just add or remove entries.\n    # The canonical list is available at\n    # https://godoc.org/github.com/projectcontour/contour/internal/envoy#JSONFields\n    # json-fields:\n    #   - \"@timestamp\"\n    #   - \"authority\"\n    #   - \"bytes_received\"\n    #   - \"bytes_sent\"\n    #   - \"downstream_local_address\"\n    #   - \"downstream_remote_address\"\n    #   - \"duration\"\n    #   - \"method\"\n    #   - \"path\"\n    #   - \"protocol\"\n    #   - \"request_id\"\n    #   - \"requested_server_name\"\n    #   - \"response_code\"\n    #   - \"response_flags\"\n    #   - \"uber_trace_id\"\n    #   - \"upstream_cluster\"\n    #   - \"upstream_host\"\n    #   - \"upstream_local_address\"\n    #   - \"upstream_service_time\"\n    #   - \"user_agent\"\n    #   - \"x_forwarded_for\"\n    #\n    # default-http-versions:\n    # - \"HTTP/2\"\n    # - \"HTTP/1.1\"\n    #\n    # The following shows the default proxy timeout settings.\n    # timeouts:\n    #   request-timeout: infinity\n    #   connection-idle-timeout: 60s\n    #   stream-idle-timeout: 5m\n    #   max-connection-duration: infinity\n    #   delayed-close-timeout: 1s\n    #   connection-shutdown-grace-period: 5s\n    #\n    # Envoy cluster settings.\n    # cluster:\n    #   configure the cluster dns lookup family\n    #   valid options are: auto (default), v4, v6\n    #   dns-lookup-family: auto\n    #\n    # Envoy network settings.\n    # network:\n    #   Configure the number of additional ingress proxy hops from the\n    #   right side of the x-forwarded-for HTTP header to trust.\n    #   num-trusted-hops: 0\n    #\n    # Configure an optional global rate limit service.\n    # rateLimitService:\n    #   Identifies the extension service defining the rate limit service,\n    #   formatted as <namespace>/<name>.\n    #   extensionService: projectcontour/ratelimit\n    #   Defines the rate limit domain to pass to the rate limit service.\n    #   Acts as a container for a set of rate limit definitions within\n    #   the RLS.\n    #   domain: contour\n    #   Defines whether to allow requests to proceed when the rate limit\n    #   service fails to respond with a valid rate limit decision within\n    #   the timeout defined on the extension service.\n    #   failOpen: false\n    #   Defines whether to include the X-RateLimit headers X-RateLimit-Limit,\n    #   X-RateLimit-Remaining, and X-RateLimit-Reset (as defined by the IETF\n    #   Internet-Draft linked below), on responses to clients when the Rate\n    #   Limit Service is consulted for a request.\n    #   ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html\n    #   enableXRateLimitHeaders: false\n    #\n    # Global Policy settings.\n    # policy:\n    #   # Default headers to set on all requests (unless set/removed on the HTTPProxy object itself)\n    #   request-headers:\n    #     set:\n    #       # example: the hostname of the Envoy instance that proxied the request\n    #       X-Envoy-Hostname: %HOSTNAME%\n    #       # example: add a l5d-dst-override header to instruct Linkerd what service the request is destined for\n    #       l5d-dst-override: %CONTOUR_SERVICE_NAME%.%CONTOUR_NAMESPACE%.svc.cluster.local:%CONTOUR_SERVICE_PORT%\n    #   # default headers to set on all responses (unless set/removed on the HTTPProxy object itself)\n    #   response-headers:\n    #     set:\n    #       # example: Envoy flags that provide additional details about the response or connection\n    #       X-Envoy-Response-Flags: %RESPONSE_FLAGS%\n    #\n", "# This file is generated from the individual YAML files by generate-gateway-deployment.sh. Do not\n# edit this file directly but instead edit the source files and re-render.\n#\n# Generated from:\n#       examples/contour/00-common.yaml\n#       examples/contour/01-contour-config.yaml\n#       examples/contour/01-crds.yaml\n#       examples/contour/02-job-certgen.yaml\n#       examples/contour/02-rbac.yaml\n#       examples/contour/02-role-contour.yaml\n#       examples/contour/02-service-contour.yaml\n#       examples/contour/02-service-envoy.yaml\n#       examples/contour/03-contour.yaml\n#       examples/contour/03-envoy.yaml\n#       examples/gateway/00-crds.yaml\n#       examples/gateway/01-gatewayclass.yaml\n#       examples/gateway/02-gateway.yaml\n#\n\n---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: projectcontour\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: contour\n  namespace: projectcontour\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: envoy\n  namespace: projectcontour\n\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: contour\n  namespace: projectcontour\ndata:\n  contour.yaml: |\n    #\n    # server:\n    #   determine which XDS Server implementation to utilize in Contour.\n    #   xds-server-type: contour\n    #\n    # Specify the Gateway API configuration.\n    gateway:\n      controllerName: projectcontour.io/projectcontour/contour\n      name: contour\n      namespace: projectcontour\n    #\n    # should contour expect to be running inside a k8s cluster\n    # incluster: true\n    #\n    # path to kubeconfig (if not running inside a k8s cluster)\n    # kubeconfig: /path/to/.kube/config\n    #\n    # Disable RFC-compliant behavior to strip \"Content-Length\" header if\n    # \"Tranfer-Encoding: chunked\" is also set.\n    # disableAllowChunkedLength: false\n    # Disable HTTPProxy permitInsecure field\n    disablePermitInsecure: false\n    tls:\n    # minimum TLS version that Contour will negotiate\n    # minimum-protocol-version: \"1.2\"\n    # TLS ciphers to be supported by Envoy TLS listeners when negotiating\n    # TLS 1.2.\n    # cipher-suites:\n    # - '[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]'\n    # - '[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]'\n    # - 'ECDHE-ECDSA-AES256-GCM-SHA384'\n    # - 'ECDHE-RSA-AES256-GCM-SHA384'\n    # Defines the Kubernetes name/namespace matching a secret to use\n    # as the fallback certificate when requests which don't match the\n    # SNI defined for a vhost.\n      fallback-certificate:\n    #   name: fallback-secret-name\n      namespace: projectcontour\n      envoy-client-certificate:\n    #   name: envoy-client-cert-secret-name\n      namespace: projectcontour\n    # The following config shows the defaults for the leader election.\n    # leaderelection:\n    #   configmap-name: leader-elect\n    #   configmap-namespace: projectcontour\n    ### Logging options\n    # Default setting\n    accesslog-format: envoy\n    # To enable JSON logging in Envoy\n    # accesslog-format: json\n    # The default fields that will be logged are specified below.\n    # To customise this list, just add or remove entries.\n    # The canonical list is available at\n    # https://godoc.org/github.com/projectcontour/contour/internal/envoy#JSONFields\n    # json-fields:\n    #   - \"@timestamp\"\n    #   - \"authority\"\n    #   - \"bytes_received\"\n    #   - \"bytes_sent\"\n    #   - \"downstream_local_address\"\n    #   - \"downstream_remote_address\"\n    #   - \"duration\"\n    #   - \"method\"\n    #   - \"path\"\n    #   - \"protocol\"\n    #   - \"request_id\"\n    #   - \"requested_server_name\"\n    #   - \"response_code\"\n    #   - \"response_flags\"\n    #   - \"uber_trace_id\"\n    #   - \"upstream_cluster\"\n    #   - \"upstream_host\"\n    #   - \"upstream_local_address\"\n    #   - \"upstream_service_time\"\n    #   - \"user_agent\"\n    #   - \"x_forwarded_for\"\n    #\n    # default-http-versions:\n    # - \"HTTP/2\"\n    # - \"HTTP/1.1\"\n    #\n    # The following shows the default proxy timeout settings.\n    # timeouts:\n    #   request-timeout: infinity\n    #   connection-idle-timeout: 60s\n    #   stream-idle-timeout: 5m\n    #   max-connection-duration: infinity\n    #   delayed-close-timeout: 1s\n    #   connection-shutdown-grace-period: 5s\n    #\n    # Envoy cluster settings.\n    # cluster:\n    #   configure the cluster dns lookup family\n    #   valid options are: auto (default), v4, v6\n    #   dns-lookup-family: auto\n    #\n    # Envoy network settings.\n    # network:\n    #   Configure the number of additional ingress proxy hops from the\n    #   right side of the x-forwarded-for HTTP header to trust.\n    #   num-trusted-hops: 0\n    #\n    # Configure an optional global rate limit service.\n    # rateLimitService:\n    #   Identifies the extension service defining the rate limit service,\n    #   formatted as <namespace>/<name>.\n    #   extensionService: projectcontour/ratelimit\n    #   Defines the rate limit domain to pass to the rate limit service.\n    #   Acts as a container for a set of rate limit definitions within\n    #   the RLS.\n    #   domain: contour\n    #   Defines whether to allow requests to proceed when the rate limit\n    #   service fails to respond with a valid rate limit decision within\n    #   the timeout defined on the extension service.\n    #   failOpen: false\n    #   Defines whether to include the X-RateLimit headers X-RateLimit-Limit,\n    #   X-RateLimit-Remaining, and X-RateLimit-Reset (as defined by the IETF\n    #   Internet-Draft linked below), on responses to clients when the Rate\n    #   Limit Service is consulted for a request.\n    #   ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html\n    #   enableXRateLimitHeaders: false\n    #\n    # Global Policy settings.\n    # policy:\n    #   # Default headers to set on all requests (unless set/removed on the HTTPProxy object itself)\n    #   request-headers:\n    #     set:\n    #       # example: the hostname of the Envoy instance that proxied the request\n    #       X-Envoy-Hostname: %HOSTNAME%\n    #       # example: add a l5d-dst-override header to instruct Linkerd what service the request is destined for\n    #       l5d-dst-override: %CONTOUR_SERVICE_NAME%.%CONTOUR_NAMESPACE%.svc.cluster.local:%CONTOUR_SERVICE_PORT%\n    #   # default headers to set on all responses (unless set/removed on the HTTPProxy object itself)\n    #   response-headers:\n    #     set:\n    #       # example: Envoy flags that provide additional details about the response or connection\n    #       X-Envoy-Response-Flags: %RESPONSE_FLAGS%\n    #\n\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: extensionservices.projectcontour.io\nspec:\n  preserveUnknownFields: false\n  group: projectcontour.io\n  names:\n    kind: ExtensionService\n    listKind: ExtensionServiceList\n    plural: extensionservices\n    shortNames:\n    - extensionservice\n    - extensionservices\n    singular: extensionservice\n  scope: Namespaced\n  versions:\n  - name: v1alpha1\n    schema:\n      openAPIV3Schema:\n        description: ExtensionService is the schema for the Contour extension services\n          API. An ExtensionService resource binds a network service to the Contour\n          API so that Contour API features can be implemented by collaborating components.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: ExtensionServiceSpec defines the desired state of an ExtensionService\n              resource.\n            properties:\n              loadBalancerPolicy:\n                description: The policy for load balancing GRPC service requests.\n                  Note that the `Cookie` and `RequestHash` load balancing strategies\n                  cannot be used here.\n                properties:\n                  requestHashPolicies:\n                    description: RequestHashPolicies contains a list of hash policies\n                      to apply when the `RequestHash` load balancing strategy is chosen.\n                      If an element of the supplied list of hash policies is invalid,\n                      it will be ignored. If the list of hash policies is empty after\n                      validation, the load balancing strategy will fall back the the\n                      default `RoundRobin`.\n                    items:\n                      description: RequestHashPolicy contains configuration for an\n                        individual hash policy on a request attribute.\n                      properties:\n                        headerHashOptions:\n                          description: HeaderHashOptions should be set when request\n                            header hash based load balancing is desired. It must be\n                            the only hash option field set, otherwise this request\n                            hash policy object will be ignored.\n                          properties:\n                            headerName:\n                              description: HeaderName is the name of the HTTP request\n                                header that will be used to calculate the hash key.\n                                If the header specified is not present on a request,\n                                no hash will be produced.\n                              minLength: 1\n                              type: string\n                          type: object\n                        terminal:\n                          description: Terminal is a flag that allows for short-circuiting\n                            computing of a hash for a given request. If set to true,\n                            and the request attribute specified in the attribute hash\n                            options is present, no further hash policies will be used\n                            to calculate a hash for the request.\n                          type: boolean\n                      type: object\n                    type: array\n                  strategy:\n                    description: Strategy specifies the policy used to balance requests\n                      across the pool of backend pods. Valid policy names are `Random`,\n                      `RoundRobin`, `WeightedLeastRequest`, `Cookie`, and `RequestHash`.\n                      If an unknown strategy name is specified or no policy is supplied,\n                      the default `RoundRobin` policy is used.\n                    type: string\n                type: object\n              protocol:\n                description: Protocol may be used to specify (or override) the protocol\n                  used to reach this Service. Values may be h2 or h2c. If omitted,\n                  protocol-selection falls back on Service annotations.\n                enum:\n                - h2\n                - h2c\n                type: string\n              protocolVersion:\n                description: This field sets the version of the GRPC protocol that\n                  Envoy uses to send requests to the extension service. Since Contour\n                  always uses the v3 Envoy API, this is currently fixed at \"v3\". However,\n                  other protocol options will be available in future.\n                enum:\n                - v3\n                type: string\n              services:\n                description: Services specifies the set of Kubernetes Service resources\n                  that receive GRPC extension API requests. If no weights are specified\n                  for any of the entries in this array, traffic will be spread evenly\n                  across all the services. Otherwise, traffic is balanced proportionally\n                  to the Weight field in each entry.\n                items:\n                  description: ExtensionServiceTarget defines an Kubernetes Service\n                    to target with extension service traffic.\n                  properties:\n                    name:\n                      description: Name is the name of Kubernetes service that will\n                        accept service traffic.\n                      type: string\n                    port:\n                      description: Port (defined as Integer) to proxy traffic to since\n                        a service can have multiple defined.\n                      exclusiveMaximum: true\n                      maximum: 65536\n                      minimum: 1\n                      type: integer\n                    weight:\n                      description: Weight defines proportion of traffic to balance\n                        to the Kubernetes Service.\n                      format: int32\n                      type: integer\n                  required:\n                  - name\n                  - port\n                  type: object\n                minItems: 1\n                type: array\n              timeoutPolicy:\n                description: The timeout policy for requests to the services.\n                properties:\n                  idle:\n                    description: Timeout after which, if there are no active requests\n                      for this route, the connection between Envoy and the backend\n                      or Envoy and the external client will be closed. If not specified,\n                      there is no per-route idle timeout, though a connection manager-wide\n                      stream_idle_timeout default of 5m still applies.\n                    pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                    type: string\n                  response:\n                    description: Timeout for receiving a response from the server\n                      after processing a request from client. If not supplied, Envoy's\n                      default value of 15s applies.\n                    pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                    type: string\n                type: object\n              validation:\n                description: UpstreamValidation defines how to verify the backend\n                  service's certificate\n                properties:\n                  caSecret:\n                    description: Name of the Kubernetes secret be used to validate\n                      the certificate presented by the backend\n                    type: string\n                  subjectName:\n                    description: Key which is expected to be present in the 'subjectAltName'\n                      of the presented certificate\n                    type: string\n                required:\n                - caSecret\n                - subjectName\n                type: object\n            required:\n            - services\n            type: object\n          status:\n            description: ExtensionServiceStatus defines the observed state of an ExtensionService\n              resource.\n            properties:\n              conditions:\n                description: \"Conditions contains the current status of the ExtensionService\n                  resource. \\n Contour will update a single condition, `Valid`, that\n                  is in normal-true polarity. \\n Contour will not modify any other\n                  Conditions set in this block, in case some other controller wants\n                  to add a Condition.\"\n                items:\n                  description: \"DetailedCondition is an extension of the normal Kubernetes\n                    conditions, with two extra fields to hold sub-conditions, which\n                    provide more detailed reasons for the state (True or False) of\n                    the condition. \\n `errors` holds information about sub-conditions\n                    which are fatal to that condition and render its state False.\n                    \\n `warnings` holds information about sub-conditions which are\n                    not fatal to that condition and do not force the state to be False.\n                    \\n Remember that Conditions have a type, a status, and a reason.\n                    \\n The type is the type of the condition, the most important one\n                    in this CRD set is `Valid`. `Valid` is a positive-polarity condition:\n                    when it is `status: true` there are no problems. \\n In more detail,\n                    `status: true` means that the object is has been ingested into\n                    Contour with no errors. `warnings` may still be present, and will\n                    be indicated in the Reason field. There must be zero entries in\n                    the `errors` slice in this case. \\n `Valid`, `status: false` means\n                    that the object has had one or more fatal errors during processing\n                    into Contour.  The details of the errors will be present under\n                    the `errors` field. There must be at least one error in the `errors`\n                    slice if `status` is `false`. \\n For DetailedConditions of types\n                    other than `Valid`, the Condition must be in the negative polarity.\n                    When they have `status` `true`, there is an error. There must\n                    be at least one entry in the `errors` Subcondition slice. When\n                    they have `status` `false`, there are no serious errors, and there\n                    must be zero entries in the `errors` slice. In either case, there\n                    may be entries in the `warnings` slice. \\n Regardless of the polarity,\n                    the `reason` and `message` fields must be updated with either\n                    the detail of the reason (if there is one and only one entry in\n                    total across both the `errors` and `warnings` slices), or `MultipleReasons`\n                    if there is more than one entry.\"\n                  properties:\n                    errors:\n                      description: \"Errors contains a slice of relevant error subconditions\n                        for this object. \\n Subconditions are expected to appear when\n                        relevant (when there is a error), and disappear when not relevant.\n                        An empty slice here indicates no errors.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                    lastTransitionTime:\n                      description: lastTransitionTime is the last time the condition\n                        transitioned from one status to another. This should be when\n                        the underlying condition changed.  If that is not known, then\n                        using the time when the API field changed is acceptable.\n                      format: date-time\n                      type: string\n                    message:\n                      description: message is a human readable message indicating\n                        details about the transition. This may be an empty string.\n                      maxLength: 32768\n                      type: string\n                    observedGeneration:\n                      description: observedGeneration represents the .metadata.generation\n                        that the condition was set based upon. For instance, if .metadata.generation\n                        is currently 12, but the .status.conditions[x].observedGeneration\n                        is 9, the condition is out of date with respect to the current\n                        state of the instance.\n                      format: int64\n                      minimum: 0\n                      type: integer\n                    reason:\n                      description: reason contains a programmatic identifier indicating\n                        the reason for the condition's last transition. Producers\n                        of specific condition types may define expected values and\n                        meanings for this field, and whether the values are considered\n                        a guaranteed API. The value should be a CamelCase string.\n                        This field may not be empty.\n                      maxLength: 1024\n                      minLength: 1\n                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                      type: string\n                    status:\n                      description: status of the condition, one of True, False, Unknown.\n                      enum:\n                      - \"True\"\n                      - \"False\"\n                      - Unknown\n                      type: string\n                    type:\n                      description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                        --- Many .condition.type values are consistent across resources\n                        like Available, but because arbitrary conditions can be useful\n                        (see .node.status.conditions), the ability to deconflict is\n                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                      maxLength: 316\n                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                      type: string\n                    warnings:\n                      description: \"Warnings contains a slice of relevant warning\n                        subconditions for this object. \\n Subconditions are expected\n                        to appear when relevant (when there is a warning), and disappear\n                        when not relevant. An empty slice here indicates no warnings.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                  required:\n                  - lastTransitionTime\n                  - message\n                  - reason\n                  - status\n                  - type\n                  type: object\n                type: array\n                x-kubernetes-list-map-keys:\n                - type\n                x-kubernetes-list-type: map\n            type: object\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: httpproxies.projectcontour.io\nspec:\n  preserveUnknownFields: false\n  group: projectcontour.io\n  names:\n    kind: HTTPProxy\n    listKind: HTTPProxyList\n    plural: httpproxies\n    shortNames:\n    - proxy\n    - proxies\n    singular: httpproxy\n  scope: Namespaced\n  versions:\n  - additionalPrinterColumns:\n    - description: Fully qualified domain name\n      jsonPath: .spec.virtualhost.fqdn\n      name: FQDN\n      type: string\n    - description: Secret with TLS credentials\n      jsonPath: .spec.virtualhost.tls.secretName\n      name: TLS Secret\n      type: string\n    - description: The current status of the HTTPProxy\n      jsonPath: .status.currentStatus\n      name: Status\n      type: string\n    - description: Description of the current status\n      jsonPath: .status.description\n      name: Status Description\n      type: string\n    name: v1\n    schema:\n      openAPIV3Schema:\n        description: HTTPProxy is an Ingress CRD specification.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: HTTPProxySpec defines the spec of the CRD.\n            properties:\n              includes:\n                description: Includes allow for specific routing configuration to\n                  be included from another HTTPProxy, possibly in another namespace.\n                items:\n                  description: Include describes a set of policies that can be applied\n                    to an HTTPProxy in a namespace.\n                  properties:\n                    conditions:\n                      description: 'Conditions are a set of rules that are applied\n                        to included HTTPProxies. In effect, they are added onto the\n                        Conditions of included HTTPProxy Route structs. When applied,\n                        they are merged using AND, with one exception: There can be\n                        only one Prefix MatchCondition per Conditions slice. More\n                        than one Prefix, or contradictory Conditions, will make the\n                        include invalid.'\n                      items:\n                        description: MatchCondition are a general holder for matching\n                          rules for HTTPProxies. One of Prefix or Header must be provided.\n                        properties:\n                          header:\n                            description: Header specifies the header condition to\n                              match.\n                            properties:\n                              contains:\n                                description: Contains specifies a substring that must\n                                  be present in the header value.\n                                type: string\n                              exact:\n                                description: Exact specifies a string that the header\n                                  value must be equal to.\n                                type: string\n                              name:\n                                description: Name is the name of the header to match\n                                  against. Name is required. Header names are case\n                                  insensitive.\n                                type: string\n                              notcontains:\n                                description: NotContains specifies a substring that\n                                  must not be present in the header value.\n                                type: string\n                              notexact:\n                                description: NoExact specifies a string that the header\n                                  value must not be equal to. The condition is true\n                                  if the header has any other value.\n                                type: string\n                              notpresent:\n                                description: NotPresent specifies that condition is\n                                  true when the named header is not present. Note\n                                  that setting NotPresent to false does not make the\n                                  condition true if the named header is present.\n                                type: boolean\n                              present:\n                                description: Present specifies that condition is true\n                                  when the named header is present, regardless of\n                                  its value. Note that setting Present to false does\n                                  not make the condition true if the named header\n                                  is absent.\n                                type: boolean\n                            required:\n                            - name\n                            type: object\n                          prefix:\n                            description: Prefix defines a prefix match for a request.\n                            type: string\n                        type: object\n                      type: array\n                    name:\n                      description: Name of the HTTPProxy\n                      type: string\n                    namespace:\n                      description: Namespace of the HTTPProxy to include. Defaults\n                        to the current namespace if not supplied.\n                      type: string\n                  required:\n                  - name\n                  type: object\n                type: array\n              routes:\n                description: Routes are the ingress routes. If TCPProxy is present,\n                  Routes is ignored.\n                items:\n                  description: Route contains the set of routes for a virtual host.\n                  properties:\n                    authPolicy:\n                      description: AuthPolicy updates the authorization policy that\n                        was set on the root HTTPProxy object for client requests that\n                        match this route.\n                      properties:\n                        context:\n                          additionalProperties:\n                            type: string\n                          description: Context is a set of key/value pairs that are\n                            sent to the authentication server in the check request.\n                            If a context is provided at an enclosing scope, the entries\n                            are merged such that the inner scope overrides matching\n                            keys from the outer scope.\n                          type: object\n                        disabled:\n                          description: When true, this field disables client request\n                            authentication for the scope of the policy.\n                          type: boolean\n                      type: object\n                    conditions:\n                      description: 'Conditions are a set of rules that are applied\n                        to a Route. When applied, they are merged using AND, with\n                        one exception: There can be only one Prefix MatchCondition\n                        per Conditions slice. More than one Prefix, or contradictory\n                        Conditions, will make the route invalid.'\n                      items:\n                        description: MatchCondition are a general holder for matching\n                          rules for HTTPProxies. One of Prefix or Header must be provided.\n                        properties:\n                          header:\n                            description: Header specifies the header condition to\n                              match.\n                            properties:\n                              contains:\n                                description: Contains specifies a substring that must\n                                  be present in the header value.\n                                type: string\n                              exact:\n                                description: Exact specifies a string that the header\n                                  value must be equal to.\n                                type: string\n                              name:\n                                description: Name is the name of the header to match\n                                  against. Name is required. Header names are case\n                                  insensitive.\n                                type: string\n                              notcontains:\n                                description: NotContains specifies a substring that\n                                  must not be present in the header value.\n                                type: string\n                              notexact:\n                                description: NoExact specifies a string that the header\n                                  value must not be equal to. The condition is true\n                                  if the header has any other value.\n                                type: string\n                              notpresent:\n                                description: NotPresent specifies that condition is\n                                  true when the named header is not present. Note\n                                  that setting NotPresent to false does not make the\n                                  condition true if the named header is present.\n                                type: boolean\n                              present:\n                                description: Present specifies that condition is true\n                                  when the named header is present, regardless of\n                                  its value. Note that setting Present to false does\n                                  not make the condition true if the named header\n                                  is absent.\n                                type: boolean\n                            required:\n                            - name\n                            type: object\n                          prefix:\n                            description: Prefix defines a prefix match for a request.\n                            type: string\n                        type: object\n                      type: array\n                    enableWebsockets:\n                      description: Enables websocket support for the route.\n                      type: boolean\n                    healthCheckPolicy:\n                      description: The health check policy for this route.\n                      properties:\n                        healthyThresholdCount:\n                          description: The number of healthy health checks required\n                            before a host is marked healthy\n                          format: int64\n                          minimum: 0\n                          type: integer\n                        host:\n                          description: The value of the host header in the HTTP health\n                            check request. If left empty (default value), the name\n                            \"contour-envoy-healthcheck\" will be used.\n                          type: string\n                        intervalSeconds:\n                          description: The interval (seconds) between health checks\n                          format: int64\n                          type: integer\n                        path:\n                          description: HTTP endpoint used to perform health checks\n                            on upstream service\n                          type: string\n                        timeoutSeconds:\n                          description: The time to wait (seconds) for a health check\n                            response\n                          format: int64\n                          type: integer\n                        unhealthyThresholdCount:\n                          description: The number of unhealthy health checks required\n                            before a host is marked unhealthy\n                          format: int64\n                          minimum: 0\n                          type: integer\n                      required:\n                      - path\n                      type: object\n                    loadBalancerPolicy:\n                      description: The load balancing policy for this route.\n                      properties:\n                        requestHashPolicies:\n                          description: RequestHashPolicies contains a list of hash\n                            policies to apply when the `RequestHash` load balancing\n                            strategy is chosen. If an element of the supplied list\n                            of hash policies is invalid, it will be ignored. If the\n                            list of hash policies is empty after validation, the load\n                            balancing strategy will fall back the the default `RoundRobin`.\n                          items:\n                            description: RequestHashPolicy contains configuration\n                              for an individual hash policy on a request attribute.\n                            properties:\n                              headerHashOptions:\n                                description: HeaderHashOptions should be set when\n                                  request header hash based load balancing is desired.\n                                  It must be the only hash option field set, otherwise\n                                  this request hash policy object will be ignored.\n                                properties:\n                                  headerName:\n                                    description: HeaderName is the name of the HTTP\n                                      request header that will be used to calculate\n                                      the hash key. If the header specified is not\n                                      present on a request, no hash will be produced.\n                                    minLength: 1\n                                    type: string\n                                type: object\n                              terminal:\n                                description: Terminal is a flag that allows for short-circuiting\n                                  computing of a hash for a given request. If set\n                                  to true, and the request attribute specified in\n                                  the attribute hash options is present, no further\n                                  hash policies will be used to calculate a hash for\n                                  the request.\n                                type: boolean\n                            type: object\n                          type: array\n                        strategy:\n                          description: Strategy specifies the policy used to balance\n                            requests across the pool of backend pods. Valid policy\n                            names are `Random`, `RoundRobin`, `WeightedLeastRequest`,\n                            `Cookie`, and `RequestHash`. If an unknown strategy name\n                            is specified or no policy is supplied, the default `RoundRobin`\n                            policy is used.\n                          type: string\n                      type: object\n                    pathRewritePolicy:\n                      description: The policy for rewriting the path of the request\n                        URL after the request has been routed to a Service.\n                      properties:\n                        replacePrefix:\n                          description: ReplacePrefix describes how the path prefix\n                            should be replaced.\n                          items:\n                            description: ReplacePrefix describes a path prefix replacement.\n                            properties:\n                              prefix:\n                                description: \"Prefix specifies the URL path prefix\n                                  to be replaced. \\n If Prefix is specified, it must\n                                  exactly match the MatchCondition prefix that is\n                                  rendered by the chain of including HTTPProxies and\n                                  only that path prefix will be replaced by Replacement.\n                                  This allows HTTPProxies that are included through\n                                  multiple roots to only replace specific path prefixes,\n                                  leaving others unmodified. \\n If Prefix is not specified,\n                                  all routing prefixes rendered by the include chain\n                                  will be replaced.\"\n                                minLength: 1\n                                type: string\n                              replacement:\n                                description: Replacement is the string that the routing\n                                  path prefix will be replaced with. This must not\n                                  be empty.\n                                minLength: 1\n                                type: string\n                            required:\n                            - replacement\n                            type: object\n                          type: array\n                      type: object\n                    permitInsecure:\n                      description: Allow this path to respond to insecure requests\n                        over HTTP which are normally not permitted when a `virtualhost.tls`\n                        block is present.\n                      type: boolean\n                    rateLimitPolicy:\n                      description: The policy for rate limiting on the route.\n                      properties:\n                        global:\n                          description: Global defines global rate limiting parameters,\n                            i.e. parameters defining descriptors that are sent to\n                            an external rate limit service (RLS) for a rate limit\n                            decision on each request.\n                          properties:\n                            descriptors:\n                              description: Descriptors defines the list of descriptors\n                                that will be generated and sent to the rate limit\n                                service. Each descriptor contains 1+ key-value pair\n                                entries.\n                              items:\n                                description: RateLimitDescriptor defines a list of\n                                  key-value pair generators.\n                                properties:\n                                  entries:\n                                    description: Entries is the list of key-value\n                                      pair generators.\n                                    items:\n                                      description: RateLimitDescriptorEntry is a key-value\n                                        pair generator. Exactly one field on this\n                                        struct must be non-nil.\n                                      properties:\n                                        genericKey:\n                                          description: GenericKey defines a descriptor\n                                            entry with a static key and value.\n                                          properties:\n                                            key:\n                                              description: Key defines the key of\n                                                the descriptor entry. If not set,\n                                                the key is set to \"generic_key\".\n                                              type: string\n                                            value:\n                                              description: Value defines the value\n                                                of the descriptor entry.\n                                              minLength: 1\n                                              type: string\n                                          type: object\n                                        remoteAddress:\n                                          description: RemoteAddress defines a descriptor\n                                            entry with a key of \"remote_address\" and\n                                            a value equal to the client's IP address\n                                            (from x-forwarded-for).\n                                          type: object\n                                        requestHeader:\n                                          description: RequestHeader defines a descriptor\n                                            entry that's populated only if a given\n                                            header is present on the request. The\n                                            descriptor key is static, and the descriptor\n                                            value is equal to the value of the header.\n                                          properties:\n                                            descriptorKey:\n                                              description: DescriptorKey defines the\n                                                key to use on the descriptor entry.\n                                              minLength: 1\n                                              type: string\n                                            headerName:\n                                              description: HeaderName defines the\n                                                name of the header to look for on\n                                                the request.\n                                              minLength: 1\n                                              type: string\n                                          type: object\n                                        requestHeaderValueMatch:\n                                          description: RequestHeaderValueMatch defines\n                                            a descriptor entry that's populated if\n                                            the request's headers match a set of 1+\n                                            match criteria. The descriptor key is\n                                            \"header_match\", and the descriptor value\n                                            is static.\n                                          properties:\n                                            expectMatch:\n                                              default: true\n                                              description: ExpectMatch defines whether\n                                                the request must positively match\n                                                the match criteria in order to generate\n                                                a descriptor entry (i.e. true), or\n                                                not match the match criteria in order\n                                                to generate a descriptor entry (i.e.\n                                                false). The default is true.\n                                              type: boolean\n                                            headers:\n                                              description: Headers is a list of 1+\n                                                match criteria to apply against the\n                                                request to determine whether to populate\n                                                the descriptor entry or not.\n                                              items:\n                                                description: HeaderMatchCondition\n                                                  specifies how to conditionally match\n                                                  against HTTP headers. The Name field\n                                                  is required, but only one of the\n                                                  remaining fields should be be provided.\n                                                properties:\n                                                  contains:\n                                                    description: Contains specifies\n                                                      a substring that must be present\n                                                      in the header value.\n                                                    type: string\n                                                  exact:\n                                                    description: Exact specifies a\n                                                      string that the header value\n                                                      must be equal to.\n                                                    type: string\n                                                  name:\n                                                    description: Name is the name\n                                                      of the header to match against.\n                                                      Name is required. Header names\n                                                      are case insensitive.\n                                                    type: string\n                                                  notcontains:\n                                                    description: NotContains specifies\n                                                      a substring that must not be\n                                                      present in the header value.\n                                                    type: string\n                                                  notexact:\n                                                    description: NoExact specifies\n                                                      a string that the header value\n                                                      must not be equal to. The condition\n                                                      is true if the header has any\n                                                      other value.\n                                                    type: string\n                                                  notpresent:\n                                                    description: NotPresent specifies\n                                                      that condition is true when\n                                                      the named header is not present.\n                                                      Note that setting NotPresent\n                                                      to false does not make the condition\n                                                      true if the named header is\n                                                      present.\n                                                    type: boolean\n                                                  present:\n                                                    description: Present specifies\n                                                      that condition is true when\n                                                      the named header is present,\n                                                      regardless of its value. Note\n                                                      that setting Present to false\n                                                      does not make the condition\n                                                      true if the named header is\n                                                      absent.\n                                                    type: boolean\n                                                required:\n                                                - name\n                                                type: object\n                                              minItems: 1\n                                              type: array\n                                            value:\n                                              description: Value defines the value\n                                                of the descriptor entry.\n                                              minLength: 1\n                                              type: string\n                                          type: object\n                                      type: object\n                                    minItems: 1\n                                    type: array\n                                type: object\n                              minItems: 1\n                              type: array\n                          type: object\n                        local:\n                          description: Local defines local rate limiting parameters,\n                            i.e. parameters for rate limiting that occurs within each\n                            Envoy pod as requests are handled.\n                          properties:\n                            burst:\n                              description: Burst defines the number of requests above\n                                the requests per unit that should be allowed within\n                                a short period of time.\n                              format: int32\n                              type: integer\n                            requests:\n                              description: Requests defines how many requests per\n                                unit of time should be allowed before rate limiting\n                                occurs.\n                              format: int32\n                              minimum: 1\n                              type: integer\n                            responseHeadersToAdd:\n                              description: ResponseHeadersToAdd is an optional list\n                                of response headers to set when a request is rate-limited.\n                              items:\n                                description: HeaderValue represents a header name/value\n                                  pair\n                                properties:\n                                  name:\n                                    description: Name represents a key of a header\n                                    minLength: 1\n                                    type: string\n                                  value:\n                                    description: Value represents the value of a header\n                                      specified by a key\n                                    minLength: 1\n                                    type: string\n                                required:\n                                - name\n                                - value\n                                type: object\n                              type: array\n                            responseStatusCode:\n                              description: ResponseStatusCode is the HTTP status code\n                                to use for responses to rate-limited requests. Codes\n                                must be in the 400-599 range (inclusive). If not specified,\n                                the Envoy default of 429 (Too Many Requests) is used.\n                              format: int32\n                              maximum: 599\n                              minimum: 400\n                              type: integer\n                            unit:\n                              description: Unit defines the period of time within\n                                which requests over the limit will be rate limited.\n                                Valid values are \"second\", \"minute\" and \"hour\".\n                              enum:\n                              - second\n                              - minute\n                              - hour\n                              type: string\n                          required:\n                          - requests\n                          - unit\n                          type: object\n                      type: object\n                    requestHeadersPolicy:\n                      description: The policy for managing request headers during\n                        proxying.\n                      properties:\n                        remove:\n                          description: Remove specifies a list of HTTP header names\n                            to remove.\n                          items:\n                            type: string\n                          type: array\n                        set:\n                          description: Set specifies a list of HTTP header values\n                            that will be set in the HTTP header. If the header does\n                            not exist it will be added, otherwise it will be overwritten\n                            with the new value.\n                          items:\n                            description: HeaderValue represents a header name/value\n                              pair\n                            properties:\n                              name:\n                                description: Name represents a key of a header\n                                minLength: 1\n                                type: string\n                              value:\n                                description: Value represents the value of a header\n                                  specified by a key\n                                minLength: 1\n                                type: string\n                            required:\n                            - name\n                            - value\n                            type: object\n                          type: array\n                      type: object\n                    responseHeadersPolicy:\n                      description: The policy for managing response headers during\n                        proxying. Rewriting the 'Host' header is not supported.\n                      properties:\n                        remove:\n                          description: Remove specifies a list of HTTP header names\n                            to remove.\n                          items:\n                            type: string\n                          type: array\n                        set:\n                          description: Set specifies a list of HTTP header values\n                            that will be set in the HTTP header. If the header does\n                            not exist it will be added, otherwise it will be overwritten\n                            with the new value.\n                          items:\n                            description: HeaderValue represents a header name/value\n                              pair\n                            properties:\n                              name:\n                                description: Name represents a key of a header\n                                minLength: 1\n                                type: string\n                              value:\n                                description: Value represents the value of a header\n                                  specified by a key\n                                minLength: 1\n                                type: string\n                            required:\n                            - name\n                            - value\n                            type: object\n                          type: array\n                      type: object\n                    retryPolicy:\n                      description: The retry policy for this route.\n                      properties:\n                        count:\n                          description: NumRetries is maximum allowed number of retries.\n                            If not supplied, the number of retries is one.\n                          format: int64\n                          minimum: 0\n                          type: integer\n                        perTryTimeout:\n                          description: PerTryTimeout specifies the timeout per retry\n                            attempt. Ignored if NumRetries is not supplied.\n                          pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                          type: string\n                        retriableStatusCodes:\n                          description: \"RetriableStatusCodes specifies the HTTP status\n                            codes that should be retried. \\n This field is only respected\n                            when you include `retriable-status-codes` in the `RetryOn`\n                            field.\"\n                          items:\n                            format: int32\n                            type: integer\n                          type: array\n                        retryOn:\n                          description: \"RetryOn specifies the conditions on which\n                            to retry a request. \\n Supported [HTTP conditions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on):\n                            \\n - `5xx` - `gateway-error` - `reset` - `connect-failure`\n                            - `retriable-4xx` - `refused-stream` - `retriable-status-codes`\n                            - `retriable-headers` \\n Supported [gRPC conditions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-grpc-on):\n                            \\n - `cancelled` - `deadline-exceeded` - `internal` -\n                            `resource-exhausted` - `unavailable`\"\n                          items:\n                            description: RetryOn is a string type alias with validation\n                              to ensure that the value is valid.\n                            enum:\n                            - 5xx\n                            - gateway-error\n                            - reset\n                            - connect-failure\n                            - retriable-4xx\n                            - refused-stream\n                            - retriable-status-codes\n                            - retriable-headers\n                            - cancelled\n                            - deadline-exceeded\n                            - internal\n                            - resource-exhausted\n                            - unavailable\n                            type: string\n                          type: array\n                      type: object\n                    services:\n                      description: Services are the services to proxy traffic.\n                      items:\n                        description: Service defines an Kubernetes Service to proxy\n                          traffic.\n                        properties:\n                          mirror:\n                            description: If Mirror is true the Service will receive\n                              a read only mirror of the traffic for this route.\n                            type: boolean\n                          name:\n                            description: Name is the name of Kubernetes service to\n                              proxy traffic. Names defined here will be used to look\n                              up corresponding endpoints which contain the ips to\n                              route.\n                            type: string\n                          port:\n                            description: Port (defined as Integer) to proxy traffic\n                              to since a service can have multiple defined.\n                            exclusiveMaximum: true\n                            maximum: 65536\n                            minimum: 1\n                            type: integer\n                          protocol:\n                            description: Protocol may be used to specify (or override)\n                              the protocol used to reach this Service. Values may\n                              be tls, h2, h2c. If omitted, protocol-selection falls\n                              back on Service annotations.\n                            enum:\n                            - h2\n                            - h2c\n                            - tls\n                            type: string\n                          requestHeadersPolicy:\n                            description: The policy for managing request headers during\n                              proxying. Rewriting the 'Host' header is not supported.\n                            properties:\n                              remove:\n                                description: Remove specifies a list of HTTP header\n                                  names to remove.\n                                items:\n                                  type: string\n                                type: array\n                              set:\n                                description: Set specifies a list of HTTP header values\n                                  that will be set in the HTTP header. If the header\n                                  does not exist it will be added, otherwise it will\n                                  be overwritten with the new value.\n                                items:\n                                  description: HeaderValue represents a header name/value\n                                    pair\n                                  properties:\n                                    name:\n                                      description: Name represents a key of a header\n                                      minLength: 1\n                                      type: string\n                                    value:\n                                      description: Value represents the value of a\n                                        header specified by a key\n                                      minLength: 1\n                                      type: string\n                                  required:\n                                  - name\n                                  - value\n                                  type: object\n                                type: array\n                            type: object\n                          responseHeadersPolicy:\n                            description: The policy for managing response headers\n                              during proxying. Rewriting the 'Host' header is not\n                              supported.\n                            properties:\n                              remove:\n                                description: Remove specifies a list of HTTP header\n                                  names to remove.\n                                items:\n                                  type: string\n                                type: array\n                              set:\n                                description: Set specifies a list of HTTP header values\n                                  that will be set in the HTTP header. If the header\n                                  does not exist it will be added, otherwise it will\n                                  be overwritten with the new value.\n                                items:\n                                  description: HeaderValue represents a header name/value\n                                    pair\n                                  properties:\n                                    name:\n                                      description: Name represents a key of a header\n                                      minLength: 1\n                                      type: string\n                                    value:\n                                      description: Value represents the value of a\n                                        header specified by a key\n                                      minLength: 1\n                                      type: string\n                                  required:\n                                  - name\n                                  - value\n                                  type: object\n                                type: array\n                            type: object\n                          validation:\n                            description: UpstreamValidation defines how to verify\n                              the backend service's certificate\n                            properties:\n                              caSecret:\n                                description: Name of the Kubernetes secret be used\n                                  to validate the certificate presented by the backend\n                                type: string\n                              subjectName:\n                                description: Key which is expected to be present in\n                                  the 'subjectAltName' of the presented certificate\n                                type: string\n                            required:\n                            - caSecret\n                            - subjectName\n                            type: object\n                          weight:\n                            description: Weight defines percentage of traffic to balance\n                              traffic\n                            format: int64\n                            minimum: 0\n                            type: integer\n                        required:\n                        - name\n                        - port\n                        type: object\n                      minItems: 1\n                      type: array\n                    timeoutPolicy:\n                      description: The timeout policy for this route.\n                      properties:\n                        idle:\n                          description: Timeout after which, if there are no active\n                            requests for this route, the connection between Envoy\n                            and the backend or Envoy and the external client will\n                            be closed. If not specified, there is no per-route idle\n                            timeout, though a connection manager-wide stream_idle_timeout\n                            default of 5m still applies.\n                          pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                          type: string\n                        response:\n                          description: Timeout for receiving a response from the server\n                            after processing a request from client. If not supplied,\n                            Envoy's default value of 15s applies.\n                          pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                          type: string\n                      type: object\n                  required:\n                  - services\n                  type: object\n                type: array\n              tcpproxy:\n                description: TCPProxy holds TCP proxy information.\n                properties:\n                  healthCheckPolicy:\n                    description: The health check policy for this tcp proxy\n                    properties:\n                      healthyThresholdCount:\n                        description: The number of healthy health checks required\n                          before a host is marked healthy\n                        format: int32\n                        type: integer\n                      intervalSeconds:\n                        description: The interval (seconds) between health checks\n                        format: int64\n                        type: integer\n                      timeoutSeconds:\n                        description: The time to wait (seconds) for a health check\n                          response\n                        format: int64\n                        type: integer\n                      unhealthyThresholdCount:\n                        description: The number of unhealthy health checks required\n                          before a host is marked unhealthy\n                        format: int32\n                        type: integer\n                    type: object\n                  include:\n                    description: Include specifies that this tcpproxy should be delegated\n                      to another HTTPProxy.\n                    properties:\n                      name:\n                        description: Name of the child HTTPProxy\n                        type: string\n                      namespace:\n                        description: Namespace of the HTTPProxy to include. Defaults\n                          to the current namespace if not supplied.\n                        type: string\n                    required:\n                    - name\n                    type: object\n                  includes:\n                    description: \"IncludesDeprecated allow for specific routing configuration\n                      to be appended to another HTTPProxy in another namespace. \\n\n                      Exists due to a mistake when developing HTTPProxy and the field\n                      was marked plural when it should have been singular. This field\n                      should stay to not break backwards compatibility to v1 users.\"\n                    properties:\n                      name:\n                        description: Name of the child HTTPProxy\n                        type: string\n                      namespace:\n                        description: Namespace of the HTTPProxy to include. Defaults\n                          to the current namespace if not supplied.\n                        type: string\n                    required:\n                    - name\n                    type: object\n                  loadBalancerPolicy:\n                    description: The load balancing policy for the backend services.\n                      Note that the `Cookie` and `RequestHash` load balancing strategies\n                      cannot be used here.\n                    properties:\n                      requestHashPolicies:\n                        description: RequestHashPolicies contains a list of hash policies\n                          to apply when the `RequestHash` load balancing strategy\n                          is chosen. If an element of the supplied list of hash policies\n                          is invalid, it will be ignored. If the list of hash policies\n                          is empty after validation, the load balancing strategy will\n                          fall back the the default `RoundRobin`.\n                        items:\n                          description: RequestHashPolicy contains configuration for\n                            an individual hash policy on a request attribute.\n                          properties:\n                            headerHashOptions:\n                              description: HeaderHashOptions should be set when request\n                                header hash based load balancing is desired. It must\n                                be the only hash option field set, otherwise this\n                                request hash policy object will be ignored.\n                              properties:\n                                headerName:\n                                  description: HeaderName is the name of the HTTP\n                                    request header that will be used to calculate\n                                    the hash key. If the header specified is not present\n                                    on a request, no hash will be produced.\n                                  minLength: 1\n                                  type: string\n                              type: object\n                            terminal:\n                              description: Terminal is a flag that allows for short-circuiting\n                                computing of a hash for a given request. If set to\n                                true, and the request attribute specified in the attribute\n                                hash options is present, no further hash policies\n                                will be used to calculate a hash for the request.\n                              type: boolean\n                          type: object\n                        type: array\n                      strategy:\n                        description: Strategy specifies the policy used to balance\n                          requests across the pool of backend pods. Valid policy names\n                          are `Random`, `RoundRobin`, `WeightedLeastRequest`, `Cookie`,\n                          and `RequestHash`. If an unknown strategy name is specified\n                          or no policy is supplied, the default `RoundRobin` policy\n                          is used.\n                        type: string\n                    type: object\n                  services:\n                    description: Services are the services to proxy traffic\n                    items:\n                      description: Service defines an Kubernetes Service to proxy\n                        traffic.\n                      properties:\n                        mirror:\n                          description: If Mirror is true the Service will receive\n                            a read only mirror of the traffic for this route.\n                          type: boolean\n                        name:\n                          description: Name is the name of Kubernetes service to proxy\n                            traffic. Names defined here will be used to look up corresponding\n                            endpoints which contain the ips to route.\n                          type: string\n                        port:\n                          description: Port (defined as Integer) to proxy traffic\n                            to since a service can have multiple defined.\n                          exclusiveMaximum: true\n                          maximum: 65536\n                          minimum: 1\n                          type: integer\n                        protocol:\n                          description: Protocol may be used to specify (or override)\n                            the protocol used to reach this Service. Values may be\n                            tls, h2, h2c. If omitted, protocol-selection falls back\n                            on Service annotations.\n                          enum:\n                          - h2\n                          - h2c\n                          - tls\n                          type: string\n                        requestHeadersPolicy:\n                          description: The policy for managing request headers during\n                            proxying. Rewriting the 'Host' header is not supported.\n                          properties:\n                            remove:\n                              description: Remove specifies a list of HTTP header\n                                names to remove.\n                              items:\n                                type: string\n                              type: array\n                            set:\n                              description: Set specifies a list of HTTP header values\n                                that will be set in the HTTP header. If the header\n                                does not exist it will be added, otherwise it will\n                                be overwritten with the new value.\n                              items:\n                                description: HeaderValue represents a header name/value\n                                  pair\n                                properties:\n                                  name:\n                                    description: Name represents a key of a header\n                                    minLength: 1\n                                    type: string\n                                  value:\n                                    description: Value represents the value of a header\n                                      specified by a key\n                                    minLength: 1\n                                    type: string\n                                required:\n                                - name\n                                - value\n                                type: object\n                              type: array\n                          type: object\n                        responseHeadersPolicy:\n                          description: The policy for managing response headers during\n                            proxying. Rewriting the 'Host' header is not supported.\n                          properties:\n                            remove:\n                              description: Remove specifies a list of HTTP header\n                                names to remove.\n                              items:\n                                type: string\n                              type: array\n                            set:\n                              description: Set specifies a list of HTTP header values\n                                that will be set in the HTTP header. If the header\n                                does not exist it will be added, otherwise it will\n                                be overwritten with the new value.\n                              items:\n                                description: HeaderValue represents a header name/value\n                                  pair\n                                properties:\n                                  name:\n                                    description: Name represents a key of a header\n                                    minLength: 1\n                                    type: string\n                                  value:\n                                    description: Value represents the value of a header\n                                      specified by a key\n                                    minLength: 1\n                                    type: string\n                                required:\n                                - name\n                                - value\n                                type: object\n                              type: array\n                          type: object\n                        validation:\n                          description: UpstreamValidation defines how to verify the\n                            backend service's certificate\n                          properties:\n                            caSecret:\n                              description: Name of the Kubernetes secret be used to\n                                validate the certificate presented by the backend\n                              type: string\n                            subjectName:\n                              description: Key which is expected to be present in\n                                the 'subjectAltName' of the presented certificate\n                              type: string\n                          required:\n                          - caSecret\n                          - subjectName\n                          type: object\n                        weight:\n                          description: Weight defines percentage of traffic to balance\n                            traffic\n                          format: int64\n                          minimum: 0\n                          type: integer\n                      required:\n                      - name\n                      - port\n                      type: object\n                    type: array\n                type: object\n              virtualhost:\n                description: Virtualhost appears at most once. If it is present, the\n                  object is considered to be a \"root\" HTTPProxy.\n                properties:\n                  authorization:\n                    description: This field configures an extension service to perform\n                      authorization for this virtual host. Authorization can only\n                      be configured on virtual hosts that have TLS enabled. If the\n                      TLS configuration requires client certificate validation, the\n                      client certificate is always included in the authentication\n                      check request.\n                    properties:\n                      authPolicy:\n                        description: AuthPolicy sets a default authorization policy\n                          for client requests. This policy will be used unless overridden\n                          by individual routes.\n                        properties:\n                          context:\n                            additionalProperties:\n                              type: string\n                            description: Context is a set of key/value pairs that\n                              are sent to the authentication server in the check request.\n                              If a context is provided at an enclosing scope, the\n                              entries are merged such that the inner scope overrides\n                              matching keys from the outer scope.\n                            type: object\n                          disabled:\n                            description: When true, this field disables client request\n                              authentication for the scope of the policy.\n                            type: boolean\n                        type: object\n                      extensionRef:\n                        description: ExtensionServiceRef specifies the extension resource\n                          that will authorize client requests.\n                        properties:\n                          apiVersion:\n                            description: API version of the referent. If this field\n                              is not specified, the default \"projectcontour.io/v1alpha1\"\n                              will be used\n                            minLength: 1\n                            type: string\n                          name:\n                            description: \"Name of the referent. \\n More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\"\n                            minLength: 1\n                            type: string\n                          namespace:\n                            description: \"Namespace of the referent. If this field\n                              is not specifies, the namespace of the resource that\n                              targets the referent will be used. \\n More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/\"\n                            minLength: 1\n                            type: string\n                        type: object\n                      failOpen:\n                        description: If FailOpen is true, the client request is forwarded\n                          to the upstream service even if the authorization server\n                          fails to respond. This field should not be set in most cases.\n                          It is intended for use only while migrating applications\n                          from internal authorization to Contour external authorization.\n                        type: boolean\n                      responseTimeout:\n                        description: ResponseTimeout configures maximum time to wait\n                          for a check response from the authorization server. Timeout\n                          durations are expressed in the Go [Duration format](https://godoc.org/time#ParseDuration).\n                          Valid time units are \"ns\", \"us\" (or \"\u00b5s\"), \"ms\", \"s\", \"m\",\n                          \"h\". The string \"infinity\" is also a valid input and specifies\n                          no timeout.\n                        pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                        type: string\n                    required:\n                    - extensionRef\n                    type: object\n                  corsPolicy:\n                    description: Specifies the cross-origin policy to apply to the\n                      VirtualHost.\n                    properties:\n                      allowCredentials:\n                        description: Specifies whether the resource allows credentials.\n                        type: boolean\n                      allowHeaders:\n                        description: AllowHeaders specifies the content for the *access-control-allow-headers*\n                          header.\n                        items:\n                          description: CORSHeaderValue specifies the value of the\n                            string headers returned by a cross-domain request.\n                          pattern: ^[a-zA-Z0-9!#$%&'*+.^_`|~-]+$\n                          type: string\n                        type: array\n                      allowMethods:\n                        description: AllowMethods specifies the content for the *access-control-allow-methods*\n                          header.\n                        items:\n                          description: CORSHeaderValue specifies the value of the\n                            string headers returned by a cross-domain request.\n                          pattern: ^[a-zA-Z0-9!#$%&'*+.^_`|~-]+$\n                          type: string\n                        type: array\n                      allowOrigin:\n                        description: AllowOrigin specifies the origins that will be\n                          allowed to do CORS requests. \"*\" means allow any origin.\n                        items:\n                          type: string\n                        type: array\n                      exposeHeaders:\n                        description: ExposeHeaders Specifies the content for the *access-control-expose-headers*\n                          header.\n                        items:\n                          description: CORSHeaderValue specifies the value of the\n                            string headers returned by a cross-domain request.\n                          pattern: ^[a-zA-Z0-9!#$%&'*+.^_`|~-]+$\n                          type: string\n                        type: array\n                      maxAge:\n                        description: MaxAge indicates for how long the results of\n                          a preflight request can be cached. MaxAge durations are\n                          expressed in the Go [Duration format](https://godoc.org/time#ParseDuration).\n                          Valid time units are \"ns\", \"us\" (or \"\u00b5s\"), \"ms\", \"s\", \"m\",\n                          \"h\". Only positive values are allowed while 0 disables the\n                          cache requiring a preflight OPTIONS check for all cross-origin\n                          requests.\n                        type: string\n                    required:\n                    - allowMethods\n                    - allowOrigin\n                    type: object\n                  fqdn:\n                    description: The fully qualified domain name of the root of the\n                      ingress tree all leaves of the DAG rooted at this object relate\n                      to the fqdn.\n                    type: string\n                  rateLimitPolicy:\n                    description: The policy for rate limiting on the virtual host.\n                    properties:\n                      global:\n                        description: Global defines global rate limiting parameters,\n                          i.e. parameters defining descriptors that are sent to an\n                          external rate limit service (RLS) for a rate limit decision\n                          on each request.\n                        properties:\n                          descriptors:\n                            description: Descriptors defines the list of descriptors\n                              that will be generated and sent to the rate limit service.\n                              Each descriptor contains 1+ key-value pair entries.\n                            items:\n                              description: RateLimitDescriptor defines a list of key-value\n                                pair generators.\n                              properties:\n                                entries:\n                                  description: Entries is the list of key-value pair\n                                    generators.\n                                  items:\n                                    description: RateLimitDescriptorEntry is a key-value\n                                      pair generator. Exactly one field on this struct\n                                      must be non-nil.\n                                    properties:\n                                      genericKey:\n                                        description: GenericKey defines a descriptor\n                                          entry with a static key and value.\n                                        properties:\n                                          key:\n                                            description: Key defines the key of the\n                                              descriptor entry. If not set, the key\n                                              is set to \"generic_key\".\n                                            type: string\n                                          value:\n                                            description: Value defines the value of\n                                              the descriptor entry.\n                                            minLength: 1\n                                            type: string\n                                        type: object\n                                      remoteAddress:\n                                        description: RemoteAddress defines a descriptor\n                                          entry with a key of \"remote_address\" and\n                                          a value equal to the client's IP address\n                                          (from x-forwarded-for).\n                                        type: object\n                                      requestHeader:\n                                        description: RequestHeader defines a descriptor\n                                          entry that's populated only if a given header\n                                          is present on the request. The descriptor\n                                          key is static, and the descriptor value\n                                          is equal to the value of the header.\n                                        properties:\n                                          descriptorKey:\n                                            description: DescriptorKey defines the\n                                              key to use on the descriptor entry.\n                                            minLength: 1\n                                            type: string\n                                          headerName:\n                                            description: HeaderName defines the name\n                                              of the header to look for on the request.\n                                            minLength: 1\n                                            type: string\n                                        type: object\n                                      requestHeaderValueMatch:\n                                        description: RequestHeaderValueMatch defines\n                                          a descriptor entry that's populated if the\n                                          request's headers match a set of 1+ match\n                                          criteria. The descriptor key is \"header_match\",\n                                          and the descriptor value is static.\n                                        properties:\n                                          expectMatch:\n                                            default: true\n                                            description: ExpectMatch defines whether\n                                              the request must positively match the\n                                              match criteria in order to generate\n                                              a descriptor entry (i.e. true), or not\n                                              match the match criteria in order to\n                                              generate a descriptor entry (i.e. false).\n                                              The default is true.\n                                            type: boolean\n                                          headers:\n                                            description: Headers is a list of 1+ match\n                                              criteria to apply against the request\n                                              to determine whether to populate the\n                                              descriptor entry or not.\n                                            items:\n                                              description: HeaderMatchCondition specifies\n                                                how to conditionally match against\n                                                HTTP headers. The Name field is required,\n                                                but only one of the remaining fields\n                                                should be be provided.\n                                              properties:\n                                                contains:\n                                                  description: Contains specifies\n                                                    a substring that must be present\n                                                    in the header value.\n                                                  type: string\n                                                exact:\n                                                  description: Exact specifies a string\n                                                    that the header value must be\n                                                    equal to.\n                                                  type: string\n                                                name:\n                                                  description: Name is the name of\n                                                    the header to match against. Name\n                                                    is required. Header names are\n                                                    case insensitive.\n                                                  type: string\n                                                notcontains:\n                                                  description: NotContains specifies\n                                                    a substring that must not be present\n                                                    in the header value.\n                                                  type: string\n                                                notexact:\n                                                  description: NoExact specifies a\n                                                    string that the header value must\n                                                    not be equal to. The condition\n                                                    is true if the header has any\n                                                    other value.\n                                                  type: string\n                                                notpresent:\n                                                  description: NotPresent specifies\n                                                    that condition is true when the\n                                                    named header is not present. Note\n                                                    that setting NotPresent to false\n                                                    does not make the condition true\n                                                    if the named header is present.\n                                                  type: boolean\n                                                present:\n                                                  description: Present specifies that\n                                                    condition is true when the named\n                                                    header is present, regardless\n                                                    of its value. Note that setting\n                                                    Present to false does not make\n                                                    the condition true if the named\n                                                    header is absent.\n                                                  type: boolean\n                                              required:\n                                              - name\n                                              type: object\n                                            minItems: 1\n                                            type: array\n                                          value:\n                                            description: Value defines the value of\n                                              the descriptor entry.\n                                            minLength: 1\n                                            type: string\n                                        type: object\n                                    type: object\n                                  minItems: 1\n                                  type: array\n                              type: object\n                            minItems: 1\n                            type: array\n                        type: object\n                      local:\n                        description: Local defines local rate limiting parameters,\n                          i.e. parameters for rate limiting that occurs within each\n                          Envoy pod as requests are handled.\n                        properties:\n                          burst:\n                            description: Burst defines the number of requests above\n                              the requests per unit that should be allowed within\n                              a short period of time.\n                            format: int32\n                            type: integer\n                          requests:\n                            description: Requests defines how many requests per unit\n                              of time should be allowed before rate limiting occurs.\n                            format: int32\n                            minimum: 1\n                            type: integer\n                          responseHeadersToAdd:\n                            description: ResponseHeadersToAdd is an optional list\n                              of response headers to set when a request is rate-limited.\n                            items:\n                              description: HeaderValue represents a header name/value\n                                pair\n                              properties:\n                                name:\n                                  description: Name represents a key of a header\n                                  minLength: 1\n                                  type: string\n                                value:\n                                  description: Value represents the value of a header\n                                    specified by a key\n                                  minLength: 1\n                                  type: string\n                              required:\n                              - name\n                              - value\n                              type: object\n                            type: array\n                          responseStatusCode:\n                            description: ResponseStatusCode is the HTTP status code\n                              to use for responses to rate-limited requests. Codes\n                              must be in the 400-599 range (inclusive). If not specified,\n                              the Envoy default of 429 (Too Many Requests) is used.\n                            format: int32\n                            maximum: 599\n                            minimum: 400\n                            type: integer\n                          unit:\n                            description: Unit defines the period of time within which\n                              requests over the limit will be rate limited. Valid\n                              values are \"second\", \"minute\" and \"hour\".\n                            enum:\n                            - second\n                            - minute\n                            - hour\n                            type: string\n                        required:\n                        - requests\n                        - unit\n                        type: object\n                    type: object\n                  tls:\n                    description: If present the fields describes TLS properties of\n                      the virtual host. The SNI names that will be matched on are\n                      described in fqdn, the tls.secretName secret must contain a\n                      certificate that itself contains a name that matches the FQDN.\n                    properties:\n                      clientValidation:\n                        description: \"ClientValidation defines how to verify the client\n                          certificate when an external client establishes a TLS connection\n                          to Envoy. \\n This setting: \\n 1. Enables TLS client certificate\n                          validation. 2. Specifies how the client certificate will\n                          be validated (i.e.    validation required or skipped). \\n\n                          Note: Setting client certificate validation to be skipped\n                          should be only used in conjunction with an external authorization\n                          server that performs client validation as Contour will ensure\n                          client certificates are passed along.\"\n                        properties:\n                          caSecret:\n                            description: Name of a Kubernetes secret that contains\n                              a CA certificate bundle. The client certificate must\n                              validate against the certificates in the bundle. If\n                              specified and SkipClientCertValidation is true, client\n                              certificates will be required on requests.\n                            minLength: 1\n                            type: string\n                          skipClientCertValidation:\n                            description: SkipClientCertValidation disables downstream\n                              client certificate validation. Defaults to false. This\n                              field is intended to be used in conjunction with external\n                              authorization in order to enable the external authorization\n                              server to validate client certificates. When this field\n                              is set to true, client certificates are requested but\n                              not verified by Envoy. If CACertificate is specified,\n                              client certificates are required on requests, but not\n                              verified. If external authorization is in use, they\n                              are presented to the external authorization server.\n                            type: boolean\n                        type: object\n                      enableFallbackCertificate:\n                        description: EnableFallbackCertificate defines if the vhost\n                          should allow a default certificate to be applied which handles\n                          all requests which don't match the SNI defined in this vhost.\n                        type: boolean\n                      minimumProtocolVersion:\n                        description: MinimumProtocolVersion is the minimum TLS version\n                          this vhost should negotiate. Valid options are `1.2` (default)\n                          and `1.3`. Any other value defaults to TLS 1.2.\n                        type: string\n                      passthrough:\n                        description: Passthrough defines whether the encrypted TLS\n                          handshake will be passed through to the backing cluster.\n                          Either Passthrough or SecretName must be specified, but\n                          not both.\n                        type: boolean\n                      secretName:\n                        description: SecretName is the name of a TLS secret in the\n                          current namespace. Either SecretName or Passthrough must\n                          be specified, but not both. If specified, the named secret\n                          must contain a matching certificate for the virtual host's\n                          FQDN.\n                        type: string\n                    type: object\n                required:\n                - fqdn\n                type: object\n            type: object\n          status:\n            description: Status is a container for computed information about the\n              HTTPProxy.\n            properties:\n              conditions:\n                description: \"Conditions contains information about the current status\n                  of the HTTPProxy, in an upstream-friendly container. \\n Contour\n                  will update a single condition, `Valid`, that is in normal-true\n                  polarity. That is, when `currentStatus` is `valid`, the `Valid`\n                  condition will be `status: true`, and vice versa. \\n Contour will\n                  leave untouched any other Conditions set in this block, in case\n                  some other controller wants to add a Condition. \\n If you are another\n                  controller owner and wish to add a condition, you *should* namespace\n                  your condition with a label, like `controller.domain.com/ConditionName`.\"\n                items:\n                  description: \"DetailedCondition is an extension of the normal Kubernetes\n                    conditions, with two extra fields to hold sub-conditions, which\n                    provide more detailed reasons for the state (True or False) of\n                    the condition. \\n `errors` holds information about sub-conditions\n                    which are fatal to that condition and render its state False.\n                    \\n `warnings` holds information about sub-conditions which are\n                    not fatal to that condition and do not force the state to be False.\n                    \\n Remember that Conditions have a type, a status, and a reason.\n                    \\n The type is the type of the condition, the most important one\n                    in this CRD set is `Valid`. `Valid` is a positive-polarity condition:\n                    when it is `status: true` there are no problems. \\n In more detail,\n                    `status: true` means that the object is has been ingested into\n                    Contour with no errors. `warnings` may still be present, and will\n                    be indicated in the Reason field. There must be zero entries in\n                    the `errors` slice in this case. \\n `Valid`, `status: false` means\n                    that the object has had one or more fatal errors during processing\n                    into Contour.  The details of the errors will be present under\n                    the `errors` field. There must be at least one error in the `errors`\n                    slice if `status` is `false`. \\n For DetailedConditions of types\n                    other than `Valid`, the Condition must be in the negative polarity.\n                    When they have `status` `true`, there is an error. There must\n                    be at least one entry in the `errors` Subcondition slice. When\n                    they have `status` `false`, there are no serious errors, and there\n                    must be zero entries in the `errors` slice. In either case, there\n                    may be entries in the `warnings` slice. \\n Regardless of the polarity,\n                    the `reason` and `message` fields must be updated with either\n                    the detail of the reason (if there is one and only one entry in\n                    total across both the `errors` and `warnings` slices), or `MultipleReasons`\n                    if there is more than one entry.\"\n                  properties:\n                    errors:\n                      description: \"Errors contains a slice of relevant error subconditions\n                        for this object. \\n Subconditions are expected to appear when\n                        relevant (when there is a error), and disappear when not relevant.\n                        An empty slice here indicates no errors.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                    lastTransitionTime:\n                      description: lastTransitionTime is the last time the condition\n                        transitioned from one status to another. This should be when\n                        the underlying condition changed.  If that is not known, then\n                        using the time when the API field changed is acceptable.\n                      format: date-time\n                      type: string\n                    message:\n                      description: message is a human readable message indicating\n                        details about the transition. This may be an empty string.\n                      maxLength: 32768\n                      type: string\n                    observedGeneration:\n                      description: observedGeneration represents the .metadata.generation\n                        that the condition was set based upon. For instance, if .metadata.generation\n                        is currently 12, but the .status.conditions[x].observedGeneration\n                        is 9, the condition is out of date with respect to the current\n                        state of the instance.\n                      format: int64\n                      minimum: 0\n                      type: integer\n                    reason:\n                      description: reason contains a programmatic identifier indicating\n                        the reason for the condition's last transition. Producers\n                        of specific condition types may define expected values and\n                        meanings for this field, and whether the values are considered\n                        a guaranteed API. The value should be a CamelCase string.\n                        This field may not be empty.\n                      maxLength: 1024\n                      minLength: 1\n                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                      type: string\n                    status:\n                      description: status of the condition, one of True, False, Unknown.\n                      enum:\n                      - \"True\"\n                      - \"False\"\n                      - Unknown\n                      type: string\n                    type:\n                      description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                        --- Many .condition.type values are consistent across resources\n                        like Available, but because arbitrary conditions can be useful\n                        (see .node.status.conditions), the ability to deconflict is\n                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                      maxLength: 316\n                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                      type: string\n                    warnings:\n                      description: \"Warnings contains a slice of relevant warning\n                        subconditions for this object. \\n Subconditions are expected\n                        to appear when relevant (when there is a warning), and disappear\n                        when not relevant. An empty slice here indicates no warnings.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                  required:\n                  - lastTransitionTime\n                  - message\n                  - reason\n                  - status\n                  - type\n                  type: object\n                type: array\n                x-kubernetes-list-map-keys:\n                - type\n                x-kubernetes-list-type: map\n              currentStatus:\n                type: string\n              description:\n                type: string\n              loadBalancer:\n                description: LoadBalancer contains the current status of the load\n                  balancer.\n                properties:\n                  ingress:\n                    description: Ingress is a list containing ingress points for the\n                      load-balancer. Traffic intended for the service should be sent\n                      to these ingress points.\n                    items:\n                      description: 'LoadBalancerIngress represents the status of a\n                        load-balancer ingress point: traffic intended for the service\n                        should be sent to an ingress point.'\n                      properties:\n                        hostname:\n                          description: Hostname is set for load-balancer ingress points\n                            that are DNS based (typically AWS load-balancers)\n                          type: string\n                        ip:\n                          description: IP is set for load-balancer ingress points\n                            that are IP based (typically GCE or OpenStack load-balancers)\n                          type: string\n                        ports:\n                          description: Ports is a list of records of service ports\n                            If used, every port defined in the service should have\n                            an entry in it\n                          items:\n                            properties:\n                              error:\n                                description: 'Error is to record the problem with\n                                  the service port The format of the error shall comply\n                                  with the following rules: - built-in error values\n                                  shall be specified in this file and those shall\n                                  use   CamelCase names - cloud provider specific\n                                  error values must have names that comply with the   format\n                                  foo.example.com/CamelCase. --- The regex it matches\n                                  is (dns1123SubdomainFmt/)?(qualifiedNameFmt)'\n                                maxLength: 316\n                                pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                                type: string\n                              port:\n                                description: Port is the port number of the service\n                                  port of which status is recorded here\n                                format: int32\n                                type: integer\n                              protocol:\n                                default: TCP\n                                description: 'Protocol is the protocol of the service\n                                  port of which status is recorded here The supported\n                                  values are: \"TCP\", \"UDP\", \"SCTP\"'\n                                type: string\n                            required:\n                            - port\n                            - protocol\n                            type: object\n                          type: array\n                          x-kubernetes-list-type: atomic\n                      type: object\n                    type: array\n                type: object\n            type: object\n        required:\n        - metadata\n        - spec\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: tlscertificatedelegations.projectcontour.io\nspec:\n  preserveUnknownFields: false\n  group: projectcontour.io\n  names:\n    kind: TLSCertificateDelegation\n    listKind: TLSCertificateDelegationList\n    plural: tlscertificatedelegations\n    shortNames:\n    - tlscerts\n    singular: tlscertificatedelegation\n  scope: Namespaced\n  versions:\n  - name: v1\n    schema:\n      openAPIV3Schema:\n        description: TLSCertificateDelegation is an TLS Certificate Delegation CRD\n          specification. See design/tls-certificate-delegation.md for details.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: TLSCertificateDelegationSpec defines the spec of the CRD\n            properties:\n              delegations:\n                items:\n                  description: CertificateDelegation maps the authority to reference\n                    a secret in the current namespace to a set of namespaces.\n                  properties:\n                    secretName:\n                      description: required, the name of a secret in the current namespace.\n                      type: string\n                    targetNamespaces:\n                      description: required, the namespaces the authority to reference\n                        the the secret will be delegated to. If TargetNamespaces is\n                        nil or empty, the CertificateDelegation' is ignored. If the\n                        TargetNamespace list contains the character, \"*\" the secret\n                        will be delegated to all namespaces.\n                      items:\n                        type: string\n                      type: array\n                  required:\n                  - secretName\n                  - targetNamespaces\n                  type: object\n                type: array\n            required:\n            - delegations\n            type: object\n          status:\n            description: TLSCertificateDelegationStatus allows for the status of the\n              delegation to be presented to the user.\n            properties:\n              conditions:\n                description: \"Conditions contains information about the current status\n                  of the HTTPProxy, in an upstream-friendly container. \\n Contour\n                  will update a single condition, `Valid`, that is in normal-true\n                  polarity. That is, when `currentStatus` is `valid`, the `Valid`\n                  condition will be `status: true`, and vice versa. \\n Contour will\n                  leave untouched any other Conditions set in this block, in case\n                  some other controller wants to add a Condition. \\n If you are another\n                  controller owner and wish to add a condition, you *should* namespace\n                  your condition with a label, like `controller.domain.com\\\\ConditionName`.\"\n                items:\n                  description: \"DetailedCondition is an extension of the normal Kubernetes\n                    conditions, with two extra fields to hold sub-conditions, which\n                    provide more detailed reasons for the state (True or False) of\n                    the condition. \\n `errors` holds information about sub-conditions\n                    which are fatal to that condition and render its state False.\n                    \\n `warnings` holds information about sub-conditions which are\n                    not fatal to that condition and do not force the state to be False.\n                    \\n Remember that Conditions have a type, a status, and a reason.\n                    \\n The type is the type of the condition, the most important one\n                    in this CRD set is `Valid`. `Valid` is a positive-polarity condition:\n                    when it is `status: true` there are no problems. \\n In more detail,\n                    `status: true` means that the object is has been ingested into\n                    Contour with no errors. `warnings` may still be present, and will\n                    be indicated in the Reason field. There must be zero entries in\n                    the `errors` slice in this case. \\n `Valid`, `status: false` means\n                    that the object has had one or more fatal errors during processing\n                    into Contour.  The details of the errors will be present under\n                    the `errors` field. There must be at least one error in the `errors`\n                    slice if `status` is `false`. \\n For DetailedConditions of types\n                    other than `Valid`, the Condition must be in the negative polarity.\n                    When they have `status` `true`, there is an error. There must\n                    be at least one entry in the `errors` Subcondition slice. When\n                    they have `status` `false`, there are no serious errors, and there\n                    must be zero entries in the `errors` slice. In either case, there\n                    may be entries in the `warnings` slice. \\n Regardless of the polarity,\n                    the `reason` and `message` fields must be updated with either\n                    the detail of the reason (if there is one and only one entry in\n                    total across both the `errors` and `warnings` slices), or `MultipleReasons`\n                    if there is more than one entry.\"\n                  properties:\n                    errors:\n                      description: \"Errors contains a slice of relevant error subconditions\n                        for this object. \\n Subconditions are expected to appear when\n                        relevant (when there is a error), and disappear when not relevant.\n                        An empty slice here indicates no errors.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                    lastTransitionTime:\n                      description: lastTransitionTime is the last time the condition\n                        transitioned from one status to another. This should be when\n                        the underlying condition changed.  If that is not known, then\n                        using the time when the API field changed is acceptable.\n                      format: date-time\n                      type: string\n                    message:\n                      description: message is a human readable message indicating\n                        details about the transition. This may be an empty string.\n                      maxLength: 32768\n                      type: string\n                    observedGeneration:\n                      description: observedGeneration represents the .metadata.generation\n                        that the condition was set based upon. For instance, if .metadata.generation\n                        is currently 12, but the .status.conditions[x].observedGeneration\n                        is 9, the condition is out of date with respect to the current\n                        state of the instance.\n                      format: int64\n                      minimum: 0\n                      type: integer\n                    reason:\n                      description: reason contains a programmatic identifier indicating\n                        the reason for the condition's last transition. Producers\n                        of specific condition types may define expected values and\n                        meanings for this field, and whether the values are considered\n                        a guaranteed API. The value should be a CamelCase string.\n                        This field may not be empty.\n                      maxLength: 1024\n                      minLength: 1\n                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                      type: string\n                    status:\n                      description: status of the condition, one of True, False, Unknown.\n                      enum:\n                      - \"True\"\n                      - \"False\"\n                      - Unknown\n                      type: string\n                    type:\n                      description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                        --- Many .condition.type values are consistent across resources\n                        like Available, but because arbitrary conditions can be useful\n                        (see .node.status.conditions), the ability to deconflict is\n                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                      maxLength: 316\n                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                      type: string\n                    warnings:\n                      description: \"Warnings contains a slice of relevant warning\n                        subconditions for this object. \\n Subconditions are expected\n                        to appear when relevant (when there is a warning), and disappear\n                        when not relevant. An empty slice here indicates no warnings.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                  required:\n                  - lastTransitionTime\n                  - message\n                  - reason\n                  - status\n                  - type\n                  type: object\n                type: array\n                x-kubernetes-list-map-keys:\n                - type\n                x-kubernetes-list-type: map\n            type: object\n        required:\n        - metadata\n        - spec\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: contour-certgen\n  namespace: projectcontour\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: contour\n  namespace: projectcontour\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: contour-certgen\nsubjects:\n- kind: ServiceAccount\n  name: contour-certgen\n  namespace: projectcontour\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: contour-certgen\n  namespace: projectcontour\nrules:\n- apiGroups:\n  - \"\"\n  resources:\n  - secrets\n  verbs:\n  - create\n  - update\n---\napiVersion: batch/v1\nkind: Job\nmetadata:\n  name: contour-certgen-v1.17.0\n  namespace: projectcontour\nspec:\n  ttlSecondsAfterFinished: 0\n  template:\n    metadata:\n      labels:\n        app: \"contour-certgen\"\n    spec:\n      containers:\n      - name: contour\n        image: docker.io/projectcontour/contour:v1.17.0\n        imagePullPolicy: Always\n        command:\n        - contour\n        - certgen\n        - --kube\n        - --incluster\n        - --overwrite\n        - --secrets-format=compact\n        - --namespace=$(CONTOUR_NAMESPACE)\n        env:\n        - name: CONTOUR_NAMESPACE\n          valueFrom:\n            fieldRef:\n              fieldPath: metadata.namespace\n      restartPolicy: Never\n      serviceAccountName: contour-certgen\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 65534\n        runAsGroup: 65534\n  parallelism: 1\n  completions: 1\n  backoffLimit: 1\n\n---\n\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: contour\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: contour\nsubjects:\n- kind: ServiceAccount\n  name: contour\n  namespace: projectcontour\n\n# The following ClusterRole is generated from kubebuilder RBAC tags by\n# generate-rbac.sh. Do not edit this file directly but instead edit the source\n# files and re-render.\n\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  creationTimestamp: null\n  name: contour\nrules:\n- apiGroups:\n  - \"\"\n  resources:\n  - configmaps\n  verbs:\n  - create\n  - get\n  - update\n- apiGroups:\n  - \"\"\n  resources:\n  - endpoints\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - namespaces\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - secrets\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - services\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - apiextensions.k8s.io\n  resources:\n  - customresourcedefinitions\n  verbs:\n  - list\n- apiGroups:\n  - networking.k8s.io\n  resources:\n  - ingressclasses\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - networking.k8s.io\n  resources:\n  - ingresses\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - networking.k8s.io\n  resources:\n  - ingresses/status\n  verbs:\n  - create\n  - get\n  - update\n- apiGroups:\n  - networking.x-k8s.io\n  resources:\n  - backendpolicies\n  - gatewayclasses\n  - gateways\n  - httproutes\n  - tcproutes\n  - tlsroutes\n  - udproutes\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - networking.x-k8s.io\n  resources:\n  - backendpolicies/status\n  - gatewayclasses/status\n  - gateways/status\n  - httproutes/status\n  - tcproutes/status\n  - tlsroutes/status\n  - udproutes/status\n  verbs:\n  - update\n- apiGroups:\n  - projectcontour.io\n  resources:\n  - extensionservices\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - projectcontour.io\n  resources:\n  - extensionservices/status\n  verbs:\n  - create\n  - get\n  - update\n- apiGroups:\n  - projectcontour.io\n  resources:\n  - httpproxies\n  - tlscertificatedelegations\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - projectcontour.io\n  resources:\n  - httpproxies/status\n  verbs:\n  - create\n  - get\n  - update\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: contour\n  namespace: projectcontour\nspec:\n  ports:\n  - port: 8001\n    name: xds\n    protocol: TCP\n    targetPort: 8001\n  selector:\n    app: contour\n  type: ClusterIP\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: envoy\n  namespace: projectcontour\n  annotations:\n    # This annotation puts the AWS ELB into \"TCP\" mode so that it does not\n    # do HTTP negotiation for HTTPS connections at the ELB edge.\n    # The downside of this is the remote IP address of all connections will\n    # appear to be the internal address of the ELB. See docs/proxy-proto.md\n    # for information about enabling the PROXY protocol on the ELB to recover\n    # the original remote IP address.\n    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcp\nspec:\n  externalTrafficPolicy: Local\n  ports:\n  - port: 80\n    name: http\n    protocol: TCP\n    targetPort: 8080\n  - port: 443\n    name: https\n    protocol: TCP\n    targetPort: 8443\n  selector:\n    app: envoy\n  type: LoadBalancer\n\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: contour\n  name: contour\n  namespace: projectcontour\nspec:\n  replicas: 2\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      # This value of maxSurge means that during a rolling update\n      # the new ReplicaSet will be created first.\n      maxSurge: 50%\n  selector:\n    matchLabels:\n      app: contour\n  template:\n    metadata:\n      annotations:\n        prometheus.io/scrape: \"true\"\n        prometheus.io/port: \"8000\"\n      labels:\n        app: contour\n    spec:\n      affinity:\n        podAntiAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n          - podAffinityTerm:\n              labelSelector:\n                matchLabels:\n                  app: contour\n              topologyKey: kubernetes.io/hostname\n            weight: 100\n      containers:\n      - args:\n        - serve\n        - --incluster\n        - --xds-address=0.0.0.0\n        - --xds-port=8001\n        - --contour-cafile=/certs/ca.crt\n        - --contour-cert-file=/certs/tls.crt\n        - --contour-key-file=/certs/tls.key\n        - --config-path=/config/contour.yaml\n        command: [\"contour\"]\n        image: docker.io/projectcontour/contour:v1.17.0\n        imagePullPolicy: IfNotPresent\n        name: contour\n        ports:\n        - containerPort: 8001\n          name: xds\n          protocol: TCP\n        - containerPort: 8000\n          name: metrics\n          protocol: TCP\n        - containerPort: 6060\n          name: debug\n          protocol: TCP\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 8000\n        readinessProbe:\n          tcpSocket:\n            port: 8001\n          initialDelaySeconds: 15\n          periodSeconds: 10\n        volumeMounts:\n          - name: contourcert\n            mountPath: /certs\n            readOnly: true\n          - name: contour-config\n            mountPath: /config\n            readOnly: true\n        env:\n        - name: CONTOUR_NAMESPACE\n          valueFrom:\n            fieldRef:\n              apiVersion: v1\n              fieldPath: metadata.namespace\n        - name: POD_NAME\n          valueFrom:\n            fieldRef:\n              apiVersion: v1\n              fieldPath: metadata.name\n      dnsPolicy: ClusterFirst\n      serviceAccountName: contour\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 65534\n        runAsGroup: 65534\n      volumes:\n        - name: contourcert\n          secret:\n            secretName: contourcert\n        - name: contour-config\n          configMap:\n            name: contour\n            defaultMode: 0644\n            items:\n            - key: contour.yaml\n              path: contour.yaml\n\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  labels:\n    app: envoy\n  name: envoy\n  namespace: projectcontour\nspec:\n  updateStrategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 10%\n  selector:\n    matchLabels:\n      app: envoy\n  template:\n    metadata:\n      annotations:\n        prometheus.io/scrape: \"true\"\n        prometheus.io/port: \"8002\"\n        prometheus.io/path: \"/stats/prometheus\"\n      labels:\n        app: envoy\n    spec:\n      containers:\n      - command:\n        - /bin/contour\n        args:\n          - envoy\n          - shutdown-manager\n        image: docker.io/projectcontour/contour:v1.17.0\n        imagePullPolicy: IfNotPresent\n        lifecycle:\n          preStop:\n            exec:\n              command:\n                - /bin/contour\n                - envoy\n                - shutdown\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 8090\n          initialDelaySeconds: 3\n          periodSeconds: 10\n        name: shutdown-manager\n      - args:\n        - -c\n        - /config/envoy.json\n        - --service-cluster $(CONTOUR_NAMESPACE)\n        - --service-node $(ENVOY_POD_NAME)\n        - --log-level info\n        command:\n        - envoy\n        image: docker.io/envoyproxy/envoy:v1.18.3\n        imagePullPolicy: IfNotPresent\n        name: envoy\n        env:\n        - name: CONTOUR_NAMESPACE\n          valueFrom:\n            fieldRef:\n              apiVersion: v1\n              fieldPath: metadata.namespace\n        - name: ENVOY_POD_NAME\n          valueFrom:\n            fieldRef:\n              apiVersion: v1\n              fieldPath: metadata.name\n        ports:\n        - containerPort: 8080\n          hostPort: 80\n          name: http\n          protocol: TCP\n        - containerPort: 8443\n          hostPort: 443\n          name: https\n          protocol: TCP\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 8002\n          initialDelaySeconds: 3\n          periodSeconds: 4\n        volumeMounts:\n          - name: envoy-config\n            mountPath: /config\n            readOnly: true\n          - name: envoycert\n            mountPath: /certs\n            readOnly: true\n        lifecycle:\n          preStop:\n            httpGet:\n              path: /shutdown\n              port: 8090\n              scheme: HTTP\n      initContainers:\n      - args:\n        - bootstrap\n        - /config/envoy.json\n        - --xds-address=contour\n        - --xds-port=8001\n        - --xds-resource-version=v3\n        - --resources-dir=/config/resources\n        - --envoy-cafile=/certs/ca.crt\n        - --envoy-cert-file=/certs/tls.crt\n        - --envoy-key-file=/certs/tls.key\n        command:\n        - contour\n        image: docker.io/projectcontour/contour:v1.17.0\n        imagePullPolicy: IfNotPresent\n        name: envoy-initconfig\n        volumeMounts:\n        - name: envoy-config\n          mountPath: /config\n        - name: envoycert\n          mountPath: /certs\n          readOnly: true\n        env:\n        - name: CONTOUR_NAMESPACE\n          valueFrom:\n            fieldRef:\n              fieldPath: metadata.namespace\n      automountServiceAccountToken: false\n      serviceAccountName: envoy\n      terminationGracePeriodSeconds: 300\n      volumes:\n        - name: envoy-config\n          emptyDir: {}\n        - name: envoycert\n          secret:\n            secretName: envoycert\n      restartPolicy: Always\n\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: backendpolicies.networking.x-k8s.io\nspec:\n  group: networking.x-k8s.io\n  names:\n    categories:\n    - gateway-api\n    kind: BackendPolicy\n    listKind: BackendPolicyList\n    plural: backendpolicies\n    shortNames:\n    - bp\n    singular: backendpolicy\n  scope: Namespaced\n  versions:\n  - additionalPrinterColumns:\n    - jsonPath: .metadata.creationTimestamp\n      name: Age\n      type: date\n    name: v1alpha1\n    schema:\n      openAPIV3Schema:\n        description: BackendPolicy defines policies associated with backends. For\n          the purpose of this API, a backend is defined as any resource that a route\n          can forward traffic to. A common example of a backend is a Service. Configuration\n          that is implementation specific may be represented with similar implementation\n          specific custom resources.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: Spec defines the desired state of BackendPolicy.\n            properties:\n              backendRefs:\n                description: \"BackendRefs define which backends this policy should\n                  be applied to. This policy can only apply to backends within the\n                  same namespace. If more than one BackendPolicy targets the same\n                  backend, precedence must be given to the oldest BackendPolicy. \\n\n                  Support: Core\"\n                items:\n                  description: BackendRef identifies an API object within the same\n                    namespace as the BackendPolicy.\n                  properties:\n                    group:\n                      description: Group is the group of the referent.\n                      maxLength: 253\n                      type: string\n                    kind:\n                      description: Kind is the kind of the referent.\n                      maxLength: 253\n                      type: string\n                    name:\n                      description: Name is the name of the referent.\n                      maxLength: 253\n                      type: string\n                    port:\n                      description: Port is the port of the referent. If unspecified,\n                        this policy applies to all ports on the backend.\n                      format: int32\n                      maximum: 65535\n                      minimum: 1\n                      type: integer\n                  required:\n                  - group\n                  - kind\n                  - name\n                  type: object\n                maxItems: 16\n                type: array\n              tls:\n                description: \"TLS is the TLS configuration for these backends. \\n\n                  Support: Extended\"\n                properties:\n                  certificateAuthorityRef:\n                    description: \"CertificateAuthorityRef is a reference to a Kubernetes\n                      object that contains one or more trusted CA certificates. The\n                      CA certificates are used to establish a TLS handshake to backends\n                      listed in BackendRefs. The referenced object MUST reside in\n                      the same namespace as BackendPolicy. \\n CertificateAuthorityRef\n                      can reference a standard Kubernetes resource, i.e. ConfigMap,\n                      or an implementation-specific custom resource. \\n When stored\n                      in a Secret, certificates must be PEM encoded and specified\n                      within the \\\"ca.crt\\\" data field of the Secret. When multiple\n                      certificates are specified, the certificates MUST be concatenated\n                      by new lines. \\n CertificateAuthorityRef can also reference\n                      a standard Kubernetes resource, i.e. ConfigMap, or an implementation-specific\n                      custom resource. \\n Support: Extended\"\n                    properties:\n                      group:\n                        description: Group is the group of the referent.\n                        maxLength: 253\n                        minLength: 1\n                        type: string\n                      kind:\n                        description: Kind is kind of the referent.\n                        maxLength: 253\n                        minLength: 1\n                        type: string\n                      name:\n                        description: Name is the name of the referent.\n                        maxLength: 253\n                        minLength: 1\n                        type: string\n                    required:\n                    - group\n                    - kind\n                    - name\n                    type: object\n                  options:\n                    additionalProperties:\n                      type: string\n                    description: \"Options are a list of key/value pairs to give extended\n                      options to the provider. \\n Support: Implementation-specific\"\n                    type: object\n                type: object\n            required:\n            - backendRefs\n            type: object\n          status:\n            description: Status defines the current state of BackendPolicy.\n            properties:\n              conditions:\n                description: Conditions describe the current conditions of the BackendPolicy.\n                items:\n                  description: \"Condition contains details for one aspect of the current\n                    state of this API Resource. --- This struct is intended for direct\n                    use as an array at the field path .status.conditions.  For example,\n                    type FooStatus struct{     // Represents the observations of a\n                    foo's current state.     // Known .status.conditions.type are:\n                    \\\"Available\\\", \\\"Progressing\\\", and \\\"Degraded\\\"     // +patchMergeKey=type\n                    \\    // +patchStrategy=merge     // +listType=map     // +listMapKey=type\n                    \\    Conditions []metav1.Condition `json:\\\"conditions,omitempty\\\"\n                    patchStrategy:\\\"merge\\\" patchMergeKey:\\\"type\\\" protobuf:\\\"bytes,1,rep,name=conditions\\\"`\n                    \\n     // other fields }\"\n                  properties:\n                    lastTransitionTime:\n                      description: lastTransitionTime is the last time the condition\n                        transitioned from one status to another. This should be when\n                        the underlying condition changed.  If that is not known, then\n                        using the time when the API field changed is acceptable.\n                      format: date-time\n                      type: string\n                    message:\n                      description: message is a human readable message indicating\n                        details about the transition. This may be an empty string.\n                      maxLength: 32768\n                      type: string\n                    observedGeneration:\n                      description: observedGeneration represents the .metadata.generation\n                        that the condition was set based upon. For instance, if .metadata.generation\n                        is currently 12, but the .status.conditions[x].observedGeneration\n                        is 9, the condition is out of date with respect to the current\n                        state of the instance.\n                      format: int64\n                      minimum: 0\n                      type: integer\n                    reason:\n                      description: reason contains a programmatic identifier indicating\n                        the reason for the condition's last transition. Producers\n                        of specific condition types may define expected values and\n                        meanings for this field, and whether the values are considered\n                        a guaranteed API. The value should be a CamelCase string.\n                        This field may not be empty.\n                      maxLength: 1024\n                      minLength: 1\n                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                      type: string\n                    status:\n                      description: status of the condition, one of True, False, Unknown.\n                      enum:\n                      - \"True\"\n                      - \"False\"\n                      - Unknown\n                      type: string\n                    type:\n                      description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                        --- Many .condition.type values are consistent across resources\n                        like Available, but because arbitrary conditions can be useful\n                        (see .node.status.conditions), the ability to deconflict is\n                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                      maxLength: 316\n                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                      type: string\n                  required:\n                  - lastTransitionTime\n                  - message\n                  - reason\n                  - status\n                  - type\n                  type: object\n                maxItems: 8\n                type: array\n                x-kubernetes-list-map-keys:\n                - type\n                x-kubernetes-list-type: map\n            type: object\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: gatewayclasses.networking.x-k8s.io\nspec:\n  group: networking.x-k8s.io\n  names:\n    categories:\n    - gateway-api\n    kind: GatewayClass\n    listKind: GatewayClassList\n    plural: gatewayclasses\n    shortNames:\n    - gc\n    singular: gatewayclass\n  scope: Cluster\n  versions:\n  - additionalPrinterColumns:\n    - jsonPath: .spec.controller\n      name: Controller\n      type: string\n    - jsonPath: .metadata.creationTimestamp\n      name: Age\n      type: date\n    name: v1alpha1\n    schema:\n      openAPIV3Schema:\n        description: \"GatewayClass describes a class of Gateways available to the\n          user for creating Gateway resources. \\n GatewayClass is a Cluster level\n          resource.\"\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: Spec defines the desired state of GatewayClass.\n            properties:\n              controller:\n                description: \"Controller is a domain/path string that indicates the\n                  controller that is managing Gateways of this class. \\n Example:\n                  \\\"acme.io/gateway-controller\\\". \\n This field is not mutable and\n                  cannot be empty. \\n The format of this field is DOMAIN \\\"/\\\" PATH,\n                  where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).\n                  \\n Support: Core\"\n                maxLength: 253\n                type: string\n              parametersRef:\n                description: \"ParametersRef is a reference to a resource that contains\n                  the configuration parameters corresponding to the GatewayClass.\n                  This is optional if the controller does not require any additional\n                  configuration. \\n ParametersRef can reference a standard Kubernetes\n                  resource, i.e. ConfigMap, or an implementation-specific custom resource.\n                  The resource can be cluster-scoped or namespace-scoped. \\n If the\n                  referent cannot be found, the GatewayClass's \\\"InvalidParameters\\\"\n                  status condition will be true. \\n Support: Custom\"\n                properties:\n                  group:\n                    description: Group is the group of the referent.\n                    maxLength: 253\n                    minLength: 1\n                    type: string\n                  kind:\n                    description: Kind is kind of the referent.\n                    maxLength: 253\n                    minLength: 1\n                    type: string\n                  name:\n                    description: Name is the name of the referent.\n                    maxLength: 253\n                    minLength: 1\n                    type: string\n                  namespace:\n                    description: Namespace is the namespace of the referent. This\n                      field is required when scope is set to \"Namespace\" and ignored\n                      when scope is set to \"Cluster\".\n                    maxLength: 253\n                    minLength: 1\n                    type: string\n                  scope:\n                    default: Cluster\n                    description: Scope represents if the referent is a Cluster or\n                      Namespace scoped resource. This may be set to \"Cluster\" or \"Namespace\".\n                    enum:\n                    - Cluster\n                    - Namespace\n                    type: string\n                required:\n                - group\n                - kind\n                - name\n                type: object\n            required:\n            - controller\n            type: object\n          status:\n            default:\n              conditions:\n              - lastTransitionTime: \"1970-01-01T00:00:00Z\"\n                message: Waiting for controller\n                reason: Waiting\n                status: \"False\"\n                type: Admitted\n            description: Status defines the current state of GatewayClass.\n            properties:\n              conditions:\n                default:\n                - lastTransitionTime: \"1970-01-01T00:00:00Z\"\n                  message: Waiting for controller\n                  reason: Waiting\n                  status: \"False\"\n                  type: Admitted\n                description: \"Conditions is the current status from the controller\n                  for this GatewayClass. \\n Controllers should prefer to publish conditions\n                  using values of GatewayClassConditionType for the type of each Condition.\"\n                items:\n                  description: \"Condition contains details for one aspect of the current\n                    state of this API Resource. --- This struct is intended for direct\n                    use as an array at the field path .status.conditions.  For example,\n                    type FooStatus struct{     // Represents the observations of a\n                    foo's current state.     // Known .status.conditions.type are:\n                    \\\"Available\\\", \\\"Progressing\\\", and \\\"Degraded\\\"     // +patchMergeKey=type\n                    \\    // +patchStrategy=merge     // +listType=map     // +listMapKey=type\n                    \\    Conditions []metav1.Condition `json:\\\"conditions,omitempty\\\"\n                    patchStrategy:\\\"merge\\\" patchMergeKey:\\\"type\\\" protobuf:\\\"bytes,1,rep,name=conditions\\\"`\n                    \\n     // other fields }\"\n                  properties:\n                    lastTransitionTime:\n                      description: lastTransitionTime is the last time the condition\n                        transitioned from one status to another. This should be when\n                        the underlying condition changed.  If that is not known, then\n                        using the time when the API field changed is acceptable.\n                      format: date-time\n                      type: string\n                    message:\n                      description: message is a human readable message indicating\n                        details about the transition. This may be an empty string.\n                      maxLength: 32768\n                      type: string\n                    observedGeneration:\n                      description: observedGeneration represents the .metadata.generation\n                        that the condition was set based upon. For instance, if .metadata.generation\n                        is currently 12, but the .status.conditions[x].observedGeneration\n                        is 9, the condition is out of date with respect to the current\n                        state of the instance.\n                      format: int64\n                      minimum: 0\n                      type: integer\n                    reason:\n                      description: reason contains a programmatic identifier indicating\n                        the reason for the condition's last transition. Producers\n                        of specific condition types may define expected values and\n                        meanings for this field, and whether the values are considered\n                        a guaranteed API. The value should be a CamelCase string.\n                        This field may not be empty.\n                      maxLength: 1024\n                      minLength: 1\n                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                      type: string\n                    status:\n                      description: status of the condition, one of True, False, Unknown.\n                      enum:\n                      - \"True\"\n                      - \"False\"\n                      - Unknown\n                      type: string\n                    type:\n                      description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                        --- Many .condition.type values are consistent across resources\n                        like Available, but because arbitrary conditions can be useful\n                        (see .node.status.conditions), the ability to deconflict is\n                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                      maxLength: 316\n                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                      type: string\n                  required:\n                  - lastTransitionTime\n                  - message\n                  - reason\n                  - status\n                  - type\n                  type: object\n                maxItems: 8\n                type: array\n                x-kubernetes-list-map-keys:\n                - type\n                x-kubernetes-list-type: map\n            type: object\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: gateways.networking.x-k8s.io\nspec:\n  group: networking.x-k8s.io\n  names:\n    categories:\n    - gateway-api\n    kind: Gateway\n    listKind: GatewayList\n    plural: gateways\n    shortNames:\n    - gtw\n    singular: gateway\n  scope: Namespaced\n  versions:\n  - additionalPrinterColumns:\n    - jsonPath: .spec.gatewayClassName\n      name: Class\n      type: string\n    - jsonPath: .metadata.creationTimestamp\n      name: Age\n      type: date\n    name: v1alpha1\n    schema:\n      openAPIV3Schema:\n        description: \"Gateway represents an instantiation of a service-traffic handling\n          infrastructure by binding Listeners to a set of IP addresses. \\n Implementations\n          should add the `gateway-exists-finalizer.networking.x-k8s.io` finalizer\n          on the associated GatewayClass whenever Gateway(s) is running. This ensures\n          that a GatewayClass associated with a Gateway(s) is not deleted while in\n          use.\"\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: Spec defines the desired state of Gateway.\n            properties:\n              addresses:\n                description: \"Addresses requested for this gateway. This is optional\n                  and behavior can depend on the GatewayClass. If a value is set in\n                  the spec and the requested address is invalid, the GatewayClass\n                  MUST indicate this in the associated entry in GatewayStatus.Addresses.\n                  \\n If no Addresses are specified, the GatewayClass may schedule\n                  the Gateway in an implementation-defined manner, assigning an appropriate\n                  set of Addresses. \\n The GatewayClass MUST bind all Listeners to\n                  every GatewayAddress that it assigns to the Gateway. \\n Support:\n                  Core\"\n                items:\n                  description: GatewayAddress describes an address that can be bound\n                    to a Gateway.\n                  properties:\n                    type:\n                      default: IPAddress\n                      description: \"Type of the address. \\n Support: Extended\"\n                      enum:\n                      - IPAddress\n                      - NamedAddress\n                      type: string\n                    value:\n                      description: \"Value of the address. The validity of the values\n                        will depend on the type and support by the controller. \\n\n                        Examples: `1.2.3.4`, `128::1`, `my-ip-address`.\"\n                      maxLength: 253\n                      minLength: 1\n                      type: string\n                  required:\n                  - value\n                  type: object\n                maxItems: 16\n                type: array\n              gatewayClassName:\n                description: GatewayClassName used for this Gateway. This is the name\n                  of a GatewayClass resource.\n                maxLength: 253\n                minLength: 1\n                type: string\n              listeners:\n                description: \"Listeners associated with this Gateway. Listeners define\n                  logical endpoints that are bound on this Gateway's addresses. At\n                  least one Listener MUST be specified. \\n An implementation MAY group\n                  Listeners by Port and then collapse each group of Listeners into\n                  a single Listener if the implementation determines that the Listeners\n                  in the group are \\\"compatible\\\". An implementation MAY also group\n                  together and collapse compatible Listeners belonging to different\n                  Gateways. \\n For example, an implementation might consider Listeners\n                  to be compatible with each other if all of the following conditions\n                  are met: \\n 1. Either each Listener within the group specifies the\n                  \\\"HTTP\\\"    Protocol or each Listener within the group specifies\n                  either    the \\\"HTTPS\\\" or \\\"TLS\\\" Protocol. \\n 2. Each Listener\n                  within the group specifies a Hostname that is unique    within the\n                  group. \\n 3. As a special case, one Listener within a group may\n                  omit Hostname,    in which case this Listener matches when no other\n                  Listener    matches. \\n If the implementation does collapse compatible\n                  Listeners, the hostname provided in the incoming client request\n                  MUST be matched to a Listener to find the correct set of Routes.\n                  The incoming hostname MUST be matched using the Hostname field for\n                  each Listener in order of most to least specific. That is, exact\n                  matches must be processed before wildcard matches. \\n If this field\n                  specifies multiple Listeners that have the same Port value but are\n                  not compatible, the implementation must raise a \\\"Conflicted\\\" condition\n                  in the Listener status. \\n Support: Core\"\n                items:\n                  description: Listener embodies the concept of a logical endpoint\n                    where a Gateway can accept network connections. Each listener\n                    in a Gateway must have a unique combination of Hostname, Port,\n                    and Protocol. This will be enforced by a validating webhook.\n                  properties:\n                    hostname:\n                      description: \"Hostname specifies the virtual hostname to match\n                        for protocol types that define this concept. When unspecified,\n                        \\\"\\\", or `*`, all hostnames are matched. This field can be\n                        omitted for protocols that don't require hostname based matching.\n                        \\n Hostname is the fully qualified domain name of a network\n                        host, as defined by RFC 3986. Note the following deviations\n                        from the \\\"host\\\" part of the URI as defined in the RFC: \\n\n                        1. IP literals are not allowed. 2. The `:` delimiter is not\n                        respected because ports are not allowed. \\n Hostname can be\n                        \\\"precise\\\" which is a domain name without the terminating\n                        dot of a network host (e.g. \\\"foo.example.com\\\") or \\\"wildcard\\\",\n                        which is a domain name prefixed with a single wildcard label\n                        (e.g. `*.example.com`). The wildcard character `*` must appear\n                        by itself as the first DNS label and matches only a single\n                        label. \\n Support: Core\"\n                      maxLength: 253\n                      minLength: 1\n                      type: string\n                    port:\n                      description: \"Port is the network port. Multiple listeners may\n                        use the same port, subject to the Listener compatibility rules.\n                        \\n Support: Core\"\n                      format: int32\n                      maximum: 65535\n                      minimum: 1\n                      type: integer\n                    protocol:\n                      description: \"Protocol specifies the network protocol this listener\n                        expects to receive. The GatewayClass MUST apply the Hostname\n                        match appropriately for each protocol: \\n * For the \\\"TLS\\\"\n                        protocol, the Hostname match MUST be   applied to the [SNI](https://tools.ietf.org/html/rfc6066#section-3)\n                        \\  server name offered by the client. * For the \\\"HTTP\\\" protocol,\n                        the Hostname match MUST be   applied to the host portion of\n                        the   [effective request URI](https://tools.ietf.org/html/rfc7230#section-5.5)\n                        \\  or the [:authority pseudo-header](https://tools.ietf.org/html/rfc7540#section-8.1.2.3)\n                        * For the \\\"HTTPS\\\" protocol, the Hostname match MUST be   applied\n                        at both the TLS and HTTP protocol layers. \\n Support: Core\"\n                      type: string\n                    routes:\n                      description: \"Routes specifies a schema for associating routes\n                        with the Listener using selectors. A Route is a resource capable\n                        of servicing a request and allows a cluster operator to expose\n                        a cluster resource (i.e. Service) by externally-reachable\n                        URL, load-balance traffic and terminate SSL/TLS.  Typically,\n                        a route is a \\\"HTTPRoute\\\" or \\\"TCPRoute\\\" in group \\\"networking.x-k8s.io\\\",\n                        however, an implementation may support other types of resources.\n                        \\n The Routes selector MUST select a set of objects that are\n                        compatible with the application protocol specified in the\n                        Protocol field. \\n Although a client request may technically\n                        match multiple route rules, only one rule may ultimately receive\n                        the request. Matching precedence MUST be determined in order\n                        of the following criteria: \\n * The most specific match. For\n                        example, the most specific HTTPRoute match   is determined\n                        by the longest matching combination of hostname and path.\n                        * The oldest Route based on creation timestamp. For example,\n                        a Route with   a creation timestamp of \\\"2020-09-08 01:02:03\\\"\n                        is given precedence over   a Route with a creation timestamp\n                        of \\\"2020-09-08 01:02:04\\\". * If everything else is equivalent,\n                        the Route appearing first in   alphabetical order (namespace/name)\n                        should be given precedence. For   example, foo/bar is given\n                        precedence over foo/baz. \\n All valid portions of a Route\n                        selected by this field should be supported. Invalid portions\n                        of a Route can be ignored (sometimes that will mean the full\n                        Route). If a portion of a Route transitions from valid to\n                        invalid, support for that portion of the Route should be dropped\n                        to ensure consistency. For example, even if a filter specified\n                        by a Route is invalid, the rest of the Route should still\n                        be supported. \\n Support: Core\"\n                      properties:\n                        group:\n                          default: networking.x-k8s.io\n                          description: \"Group is the group of the route resource to\n                            select. Omitting the value or specifying the empty string\n                            indicates the networking.x-k8s.io API group. For example,\n                            use the following to select an HTTPRoute: \\n routes:   kind:\n                            HTTPRoute \\n Otherwise, if an alternative API group is\n                            desired, specify the desired group: \\n routes:   group:\n                            acme.io   kind: FooRoute \\n Support: Core\"\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                        kind:\n                          description: \"Kind is the kind of the route resource to\n                            select. \\n Kind MUST correspond to kinds of routes that\n                            are compatible with the application protocol specified\n                            in the Listener's Protocol field. \\n If an implementation\n                            does not support or recognize this resource type, it SHOULD\n                            set the \\\"ResolvedRefs\\\" condition to false for this listener\n                            with the \\\"InvalidRoutesRef\\\" reason. \\n Support: Core\"\n                          type: string\n                        namespaces:\n                          default:\n                            from: Same\n                          description: \"Namespaces indicates in which namespaces Routes\n                            should be selected for this Gateway. This is restricted\n                            to the namespace of this Gateway by default. \\n Support:\n                            Core\"\n                          properties:\n                            from:\n                              default: Same\n                              description: \"From indicates where Routes will be selected\n                                for this Gateway. Possible values are: * All: Routes\n                                in all namespaces may be used by this Gateway. * Selector:\n                                Routes in namespaces selected by the selector may\n                                be used by   this Gateway. * Same: Only Routes in\n                                the same namespace may be used by this Gateway. \\n\n                                Support: Core\"\n                              enum:\n                              - All\n                              - Selector\n                              - Same\n                              type: string\n                            selector:\n                              description: \"Selector must be specified when From is\n                                set to \\\"Selector\\\". In that case, only Routes in\n                                Namespaces matching this Selector will be selected\n                                by this Gateway. This field is ignored for other values\n                                of \\\"From\\\". \\n Support: Core\"\n                              properties:\n                                matchExpressions:\n                                  description: matchExpressions is a list of label\n                                    selector requirements. The requirements are ANDed.\n                                  items:\n                                    description: A label selector requirement is a\n                                      selector that contains values, a key, and an\n                                      operator that relates the key and values.\n                                    properties:\n                                      key:\n                                        description: key is the label key that the\n                                          selector applies to.\n                                        type: string\n                                      operator:\n                                        description: operator represents a key's relationship\n                                          to a set of values. Valid operators are\n                                          In, NotIn, Exists and DoesNotExist.\n                                        type: string\n                                      values:\n                                        description: values is an array of string\n                                          values. If the operator is In or NotIn,\n                                          the values array must be non-empty. If the\n                                          operator is Exists or DoesNotExist, the\n                                          values array must be empty. This array is\n                                          replaced during a strategic merge patch.\n                                        items:\n                                          type: string\n                                        type: array\n                                    required:\n                                    - key\n                                    - operator\n                                    type: object\n                                  type: array\n                                matchLabels:\n                                  additionalProperties:\n                                    type: string\n                                  description: matchLabels is a map of {key,value}\n                                    pairs. A single {key,value} in the matchLabels\n                                    map is equivalent to an element of matchExpressions,\n                                    whose key field is \"key\", the operator is \"In\",\n                                    and the values array contains only \"value\". The\n                                    requirements are ANDed.\n                                  type: object\n                              type: object\n                          type: object\n                        selector:\n                          description: \"Selector specifies a set of route labels used\n                            for selecting routes to associate with the Gateway. If\n                            this Selector is defined, only routes matching the Selector\n                            are associated with the Gateway. An empty Selector matches\n                            all routes. \\n Support: Core\"\n                          properties:\n                            matchExpressions:\n                              description: matchExpressions is a list of label selector\n                                requirements. The requirements are ANDed.\n                              items:\n                                description: A label selector requirement is a selector\n                                  that contains values, a key, and an operator that\n                                  relates the key and values.\n                                properties:\n                                  key:\n                                    description: key is the label key that the selector\n                                      applies to.\n                                    type: string\n                                  operator:\n                                    description: operator represents a key's relationship\n                                      to a set of values. Valid operators are In,\n                                      NotIn, Exists and DoesNotExist.\n                                    type: string\n                                  values:\n                                    description: values is an array of string values.\n                                      If the operator is In or NotIn, the values array\n                                      must be non-empty. If the operator is Exists\n                                      or DoesNotExist, the values array must be empty.\n                                      This array is replaced during a strategic merge\n                                      patch.\n                                    items:\n                                      type: string\n                                    type: array\n                                required:\n                                - key\n                                - operator\n                                type: object\n                              type: array\n                            matchLabels:\n                              additionalProperties:\n                                type: string\n                              description: matchLabels is a map of {key,value} pairs.\n                                A single {key,value} in the matchLabels map is equivalent\n                                to an element of matchExpressions, whose key field\n                                is \"key\", the operator is \"In\", and the values array\n                                contains only \"value\". The requirements are ANDed.\n                              type: object\n                          type: object\n                      required:\n                      - kind\n                      type: object\n                    tls:\n                      description: \"TLS is the TLS configuration for the Listener.\n                        This field is required if the Protocol field is \\\"HTTPS\\\"\n                        or \\\"TLS\\\" and ignored otherwise. \\n The association of SNIs\n                        to Certificate defined in GatewayTLSConfig is defined based\n                        on the Hostname field for this listener. \\n The GatewayClass\n                        MUST use the longest matching SNI out of all available certificates\n                        for any TLS handshake. \\n Support: Core\"\n                      properties:\n                        certificateRef:\n                          description: \"CertificateRef is a reference to a Kubernetes\n                            object that contains a TLS certificate and private key.\n                            This certificate is used to establish a TLS handshake\n                            for requests that match the hostname of the associated\n                            listener. The referenced object MUST reside in the same\n                            namespace as Gateway. \\n This field is required when mode\n                            is set to \\\"Terminate\\\" (default) and optional otherwise.\n                            \\n CertificateRef can reference a standard Kubernetes\n                            resource, i.e. Secret, or an implementation-specific custom\n                            resource. \\n Support: Core (Kubernetes Secrets) \\n Support:\n                            Implementation-specific (Other resource types)\"\n                          properties:\n                            group:\n                              description: Group is the group of the referent.\n                              maxLength: 253\n                              minLength: 1\n                              type: string\n                            kind:\n                              description: Kind is kind of the referent.\n                              maxLength: 253\n                              minLength: 1\n                              type: string\n                            name:\n                              description: Name is the name of the referent.\n                              maxLength: 253\n                              minLength: 1\n                              type: string\n                          required:\n                          - group\n                          - kind\n                          - name\n                          type: object\n                        mode:\n                          default: Terminate\n                          description: \"Mode defines the TLS behavior for the TLS\n                            session initiated by the client. There are two possible\n                            modes: - Terminate: The TLS session between the downstream\n                            client   and the Gateway is terminated at the Gateway.\n                            This mode requires   certificateRef to be set. - Passthrough:\n                            The TLS session is NOT terminated by the Gateway. This\n                            \\  implies that the Gateway can't decipher the TLS stream\n                            except for   the ClientHello message of the TLS protocol.\n                            \\  CertificateRef field is ignored in this mode. \\n Support:\n                            Core\"\n                          enum:\n                          - Terminate\n                          - Passthrough\n                          type: string\n                        options:\n                          additionalProperties:\n                            type: string\n                          description: \"Options are a list of key/value pairs to give\n                            extended options to the provider. \\n There variation among\n                            providers as to how ciphersuites are expressed. If there\n                            is a common subset for expressing ciphers then it will\n                            make sense to loft that as a core API construct. \\n Support:\n                            Implementation-specific\"\n                          type: object\n                        routeOverride:\n                          default:\n                            certificate: Deny\n                          description: \"RouteOverride dictates if TLS settings can\n                            be configured via Routes or not. \\n CertificateRef must\n                            be defined even if `routeOverride.certificate` is set\n                            to 'Allow' as it will be used as the default certificate\n                            for the listener. \\n Support: Core\"\n                          properties:\n                            certificate:\n                              default: Deny\n                              description: \"Certificate dictates if TLS certificates\n                                can be configured via Routes. If set to 'Allow', a\n                                TLS certificate for a hostname defined in a Route\n                                takes precedence over the certificate defined in Gateway.\n                                \\n Support: Core\"\n                              enum:\n                              - Allow\n                              - Deny\n                              type: string\n                          type: object\n                      type: object\n                  required:\n                  - port\n                  - protocol\n                  - routes\n                  type: object\n                maxItems: 64\n                minItems: 1\n                type: array\n            required:\n            - gatewayClassName\n            - listeners\n            type: object\n          status:\n            default:\n              conditions:\n              - lastTransitionTime: \"1970-01-01T00:00:00Z\"\n                message: Waiting for controller\n                reason: NotReconciled\n                status: \"False\"\n                type: Scheduled\n            description: Status defines the current state of Gateway.\n            properties:\n              addresses:\n                description: \"Addresses lists the IP addresses that have actually\n                  been bound to the Gateway. These addresses may differ from the addresses\n                  in the Spec, e.g. if the Gateway automatically assigns an address\n                  from a reserved pool. \\n These addresses should all be of type \\\"IPAddress\\\".\"\n                items:\n                  description: GatewayAddress describes an address that can be bound\n                    to a Gateway.\n                  properties:\n                    type:\n                      default: IPAddress\n                      description: \"Type of the address. \\n Support: Extended\"\n                      enum:\n                      - IPAddress\n                      - NamedAddress\n                      type: string\n                    value:\n                      description: \"Value of the address. The validity of the values\n                        will depend on the type and support by the controller. \\n\n                        Examples: `1.2.3.4`, `128::1`, `my-ip-address`.\"\n                      maxLength: 253\n                      minLength: 1\n                      type: string\n                  required:\n                  - value\n                  type: object\n                maxItems: 16\n                type: array\n              conditions:\n                default:\n                - lastTransitionTime: \"1970-01-01T00:00:00Z\"\n                  message: Waiting for controller\n                  reason: NotReconciled\n                  status: \"False\"\n                  type: Scheduled\n                description: \"Conditions describe the current conditions of the Gateway.\n                  \\n Implementations should prefer to express Gateway conditions using\n                  the `GatewayConditionType` and `GatewayConditionReason` constants\n                  so that operators and tools can converge on a common vocabulary\n                  to describe Gateway state. \\n Known condition types are: \\n * \\\"Scheduled\\\"\n                  * \\\"Ready\\\"\"\n                items:\n                  description: \"Condition contains details for one aspect of the current\n                    state of this API Resource. --- This struct is intended for direct\n                    use as an array at the field path .status.conditions.  For example,\n                    type FooStatus struct{     // Represents the observations of a\n                    foo's current state.     // Known .status.conditions.type are:\n                    \\\"Available\\\", \\\"Progressing\\\", and \\\"Degraded\\\"     // +patchMergeKey=type\n                    \\    // +patchStrategy=merge     // +listType=map     // +listMapKey=type\n                    \\    Conditions []metav1.Condition `json:\\\"conditions,omitempty\\\"\n                    patchStrategy:\\\"merge\\\" patchMergeKey:\\\"type\\\" protobuf:\\\"bytes,1,rep,name=conditions\\\"`\n                    \\n     // other fields }\"\n                  properties:\n                    lastTransitionTime:\n                      description: lastTransitionTime is the last time the condition\n                        transitioned from one status to another. This should be when\n                        the underlying condition changed.  If that is not known, then\n                        using the time when the API field changed is acceptable.\n                      format: date-time\n                      type: string\n                    message:\n                      description: message is a human readable message indicating\n                        details about the transition. This may be an empty string.\n                      maxLength: 32768\n                      type: string\n                    observedGeneration:\n                      description: observedGeneration represents the .metadata.generation\n                        that the condition was set based upon. For instance, if .metadata.generation\n                        is currently 12, but the .status.conditions[x].observedGeneration\n                        is 9, the condition is out of date with respect to the current\n                        state of the instance.\n                      format: int64\n                      minimum: 0\n                      type: integer\n                    reason:\n                      description: reason contains a programmatic identifier indicating\n                        the reason for the condition's last transition. Producers\n                        of specific condition types may define expected values and\n                        meanings for this field, and whether the values are considered\n                        a guaranteed API. The value should be a CamelCase string.\n                        This field may not be empty.\n                      maxLength: 1024\n                      minLength: 1\n                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                      type: string\n                    status:\n                      description: status of the condition, one of True, False, Unknown.\n                      enum:\n                      - \"True\"\n                      - \"False\"\n                      - Unknown\n                      type: string\n                    type:\n                      description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                        --- Many .condition.type values are consistent across resources\n                        like Available, but because arbitrary conditions can be useful\n                        (see .node.status.conditions), the ability to deconflict is\n                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                      maxLength: 316\n                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                      type: string\n                  required:\n                  - lastTransitionTime\n                  - message\n                  - reason\n                  - status\n                  - type\n                  type: object\n                maxItems: 8\n                type: array\n                x-kubernetes-list-map-keys:\n                - type\n                x-kubernetes-list-type: map\n              listeners:\n                description: Listeners provide status for each unique listener port\n                  defined in the Spec.\n                items:\n                  description: ListenerStatus is the status associated with a Listener.\n                  properties:\n                    conditions:\n                      description: Conditions describe the current condition of this\n                        listener.\n                      items:\n                        description: \"Condition contains details for one aspect of\n                          the current state of this API Resource. --- This struct\n                          is intended for direct use as an array at the field path\n                          .status.conditions.  For example, type FooStatus struct{\n                          \\    // Represents the observations of a foo's current state.\n                          \\    // Known .status.conditions.type are: \\\"Available\\\",\n                          \\\"Progressing\\\", and \\\"Degraded\\\"     // +patchMergeKey=type\n                          \\    // +patchStrategy=merge     // +listType=map     //\n                          +listMapKey=type     Conditions []metav1.Condition `json:\\\"conditions,omitempty\\\"\n                          patchStrategy:\\\"merge\\\" patchMergeKey:\\\"type\\\" protobuf:\\\"bytes,1,rep,name=conditions\\\"`\n                          \\n     // other fields }\"\n                        properties:\n                          lastTransitionTime:\n                            description: lastTransitionTime is the last time the condition\n                              transitioned from one status to another. This should\n                              be when the underlying condition changed.  If that is\n                              not known, then using the time when the API field changed\n                              is acceptable.\n                            format: date-time\n                            type: string\n                          message:\n                            description: message is a human readable message indicating\n                              details about the transition. This may be an empty string.\n                            maxLength: 32768\n                            type: string\n                          observedGeneration:\n                            description: observedGeneration represents the .metadata.generation\n                              that the condition was set based upon. For instance,\n                              if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration\n                              is 9, the condition is out of date with respect to the\n                              current state of the instance.\n                            format: int64\n                            minimum: 0\n                            type: integer\n                          reason:\n                            description: reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. The value should\n                              be a CamelCase string. This field may not be empty.\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                              --- Many .condition.type values are consistent across\n                              resources like Available, but because arbitrary conditions\n                              can be useful (see .node.status.conditions), the ability\n                              to deconflict is important. The regex it matches is\n                              (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - lastTransitionTime\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      maxItems: 8\n                      type: array\n                      x-kubernetes-list-map-keys:\n                      - type\n                      x-kubernetes-list-type: map\n                    hostname:\n                      description: Hostname is the Listener hostname value for which\n                        this message is reporting the status.\n                      maxLength: 253\n                      minLength: 1\n                      type: string\n                    port:\n                      description: Port is the unique Listener port value for which\n                        this message is reporting the status.\n                      format: int32\n                      maximum: 65535\n                      minimum: 1\n                      type: integer\n                    protocol:\n                      description: Protocol is the Listener protocol value for which\n                        this message is reporting the status.\n                      type: string\n                  required:\n                  - conditions\n                  - port\n                  - protocol\n                  type: object\n                maxItems: 64\n                type: array\n                x-kubernetes-list-map-keys:\n                - port\n                x-kubernetes-list-type: map\n            type: object\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: httproutes.networking.x-k8s.io\nspec:\n  group: networking.x-k8s.io\n  names:\n    categories:\n    - gateway-api\n    kind: HTTPRoute\n    listKind: HTTPRouteList\n    plural: httproutes\n    singular: httproute\n  scope: Namespaced\n  versions:\n  - additionalPrinterColumns:\n    - jsonPath: .spec.hostnames\n      name: Hostnames\n      type: string\n    - jsonPath: .metadata.creationTimestamp\n      name: Age\n      type: date\n    name: v1alpha1\n    schema:\n      openAPIV3Schema:\n        description: HTTPRoute is the Schema for the HTTPRoute resource.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: Spec defines the desired state of HTTPRoute.\n            properties:\n              gateways:\n                default:\n                  allow: SameNamespace\n                description: Gateways defines which Gateways can use this Route.\n                properties:\n                  allow:\n                    default: SameNamespace\n                    description: 'Allow indicates which Gateways will be allowed to\n                      use this route. Possible values are: * All: Gateways in any\n                      namespace can use this route. * FromList: Only Gateways specified\n                      in GatewayRefs may use this route. * SameNamespace: Only Gateways\n                      in the same namespace may use this route.'\n                    enum:\n                    - All\n                    - FromList\n                    - SameNamespace\n                    type: string\n                  gatewayRefs:\n                    description: GatewayRefs must be specified when Allow is set to\n                      \"FromList\". In that case, only Gateways referenced in this list\n                      will be allowed to use this route. This field is ignored for\n                      other values of \"Allow\".\n                    items:\n                      description: GatewayReference identifies a Gateway in a specified\n                        namespace.\n                      properties:\n                        name:\n                          description: Name is the name of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                        namespace:\n                          description: Namespace is the namespace of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                      required:\n                      - name\n                      - namespace\n                      type: object\n                    type: array\n                type: object\n              hostnames:\n                description: \"Hostnames defines a set of hostname that should match\n                  against the HTTP Host header to select a HTTPRoute to process the\n                  request. Hostname is the fully qualified domain name of a network\n                  host, as defined by RFC 3986. Note the following deviations from\n                  the \\\"host\\\" part of the URI as defined in the RFC: \\n 1. IPs are\n                  not allowed. 2. The `:` delimiter is not respected because ports\n                  are not allowed. \\n Incoming requests are matched against the hostnames\n                  before the HTTPRoute rules. If no hostname is specified, traffic\n                  is routed based on the HTTPRouteRules. \\n Hostname can be \\\"precise\\\"\n                  which is a domain name without the terminating dot of a network\n                  host (e.g. \\\"foo.example.com\\\") or \\\"wildcard\\\", which is a domain\n                  name prefixed with a single wildcard label (e.g. `*.example.com`).\n                  The wildcard character `*` must appear by itself as the first DNS\n                  label and matches only a single label. You cannot have a wildcard\n                  label by itself (e.g. Host == `*`). Requests will be matched against\n                  the Host field in the following order: \\n 1. If Host is precise,\n                  the request matches this rule if    the HTTP Host header is equal\n                  to Host. 2. If Host is a wildcard, then the request matches this\n                  rule if    the HTTP Host header is to equal to the suffix    (removing\n                  the first label) of the wildcard rule. \\n Support: Core\"\n                items:\n                  description: Hostname is used to specify a hostname that should\n                    be matched.\n                  maxLength: 253\n                  minLength: 1\n                  type: string\n                maxItems: 16\n                type: array\n              rules:\n                default:\n                - matches:\n                  - path:\n                      type: Prefix\n                      value: /\n                description: Rules are a list of HTTP matchers, filters and actions.\n                items:\n                  description: HTTPRouteRule defines semantics for matching an HTTP\n                    request based on conditions, optionally executing additional processing\n                    steps, and forwarding the request to an API object.\n                  properties:\n                    filters:\n                      description: \"Filters define the filters that are applied to\n                        requests that match this rule. \\n The effects of ordering\n                        of multiple behaviors are currently unspecified. This can\n                        change in the future based on feedback during the alpha stage.\n                        \\n Conformance-levels at this level are defined based on the\n                        type of filter: \\n - ALL core filters MUST be supported by\n                        all implementations. - Implementers are encouraged to support\n                        extended filters. - Implementation-specific custom filters\n                        have no API guarantees across   implementations. \\n Specifying\n                        a core filter multiple times has unspecified or custom conformance.\n                        \\n Support: Core\"\n                      items:\n                        description: 'HTTPRouteFilter defines additional processing\n                          steps that must be completed during the request or response\n                          lifecycle. HTTPRouteFilters are meant as an extension point\n                          to express additional processing that may be done in Gateway\n                          implementations. Some examples include request or response\n                          modification, implementing authentication strategies, rate-limiting,\n                          and traffic shaping. API guarantee/conformance is defined\n                          based on the type of the filter. TODO(hbagdi): re-render\n                          CRDs once controller-tools supports union tags: - https://github.com/kubernetes-sigs/controller-tools/pull/298\n                          - https://github.com/kubernetes-sigs/controller-tools/issues/461'\n                        properties:\n                          extensionRef:\n                            description: \"ExtensionRef is an optional, implementation-specific\n                              extension to the \\\"filter\\\" behavior.  For example,\n                              resource \\\"myroutefilter\\\" in group \\\"networking.acme.io\\\").\n                              ExtensionRef MUST NOT be used for core and extended\n                              filters. \\n Support: Implementation-specific\"\n                            properties:\n                              group:\n                                description: Group is the group of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              kind:\n                                description: Kind is kind of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              name:\n                                description: Name is the name of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                            required:\n                            - group\n                            - kind\n                            - name\n                            type: object\n                          requestHeaderModifier:\n                            description: \"RequestHeaderModifier defines a schema for\n                              a filter that modifies request headers. \\n Support:\n                              Core\"\n                            properties:\n                              add:\n                                additionalProperties:\n                                  type: string\n                                description: \"Add adds the given header (name, value)\n                                  to the request before the action. It appends to\n                                  any existing values associated with the header name.\n                                  \\n Input:   GET /foo HTTP/1.1   my-header: foo \\n\n                                  Config:   add: {\\\"my-header\\\": \\\"bar\\\"} \\n Output:\n                                  \\  GET /foo HTTP/1.1   my-header: foo   my-header:\n                                  bar \\n Support: Extended\"\n                                type: object\n                              remove:\n                                description: \"Remove the given header(s) from the\n                                  HTTP request before the action. The value of RemoveHeader\n                                  is a list of HTTP header names. Note that the header\n                                  names are case-insensitive [RFC-2616 4.2]. \\n Input:\n                                  \\  GET /foo HTTP/1.1   my-header1: foo   my-header2:\n                                  bar   my-header3: baz \\n Config:   remove: [\\\"my-header1\\\",\n                                  \\\"my-header3\\\"] \\n Output:   GET /foo HTTP/1.1   my-header2:\n                                  bar \\n Support: Extended\"\n                                items:\n                                  type: string\n                                maxItems: 16\n                                type: array\n                              set:\n                                additionalProperties:\n                                  type: string\n                                description: \"Set overwrites the request with the\n                                  given header (name, value) before the action. \\n\n                                  Input:   GET /foo HTTP/1.1   my-header: foo \\n Config:\n                                  \\  set: {\\\"my-header\\\": \\\"bar\\\"} \\n Output:   GET\n                                  /foo HTTP/1.1   my-header: bar \\n Support: Extended\"\n                                type: object\n                            type: object\n                          requestMirror:\n                            description: \"RequestMirror defines a schema for a filter\n                              that mirrors requests. \\n Support: Extended\"\n                            properties:\n                              backendRef:\n                                description: \"BackendRef is a local object reference\n                                  to mirror matched requests to. If both BackendRef\n                                  and ServiceName are specified, ServiceName will\n                                  be given precedence. \\n If the referent cannot be\n                                  found, the rule is not included in the route. The\n                                  controller should raise the \\\"ResolvedRefs\\\" condition\n                                  on the Gateway with the \\\"DegradedRoutes\\\" reason.\n                                  The gateway status for this route should be updated\n                                  with a condition that describes the error more specifically.\n                                  \\n Support: Custom\"\n                                properties:\n                                  group:\n                                    description: Group is the group of the referent.\n                                    maxLength: 253\n                                    minLength: 1\n                                    type: string\n                                  kind:\n                                    description: Kind is kind of the referent.\n                                    maxLength: 253\n                                    minLength: 1\n                                    type: string\n                                  name:\n                                    description: Name is the name of the referent.\n                                    maxLength: 253\n                                    minLength: 1\n                                    type: string\n                                required:\n                                - group\n                                - kind\n                                - name\n                                type: object\n                              port:\n                                description: \"Port specifies the destination port\n                                  number to use for the backend referenced by the\n                                  ServiceName or BackendRef field. \\n If unspecified,\n                                  the destination port in the request is used when\n                                  forwarding to a backendRef or serviceName.\"\n                                format: int32\n                                maximum: 65535\n                                minimum: 1\n                                type: integer\n                              serviceName:\n                                description: \"ServiceName refers to the name of the\n                                  Service to mirror matched requests to. When specified,\n                                  this takes the place of BackendRef. If both BackendRef\n                                  and ServiceName are specified, ServiceName will\n                                  be given precedence. \\n If the referent cannot be\n                                  found, the rule is not included in the route. The\n                                  controller should raise the \\\"ResolvedRefs\\\" condition\n                                  on the Gateway with the \\\"DegradedRoutes\\\" reason.\n                                  The gateway status for this route should be updated\n                                  with a condition that describes the error more specifically.\n                                  \\n Support: Core\"\n                                maxLength: 253\n                                type: string\n                            type: object\n                          type:\n                            description: \"Type identifies the type of filter to apply.\n                              As with other API fields, types are classified into\n                              three conformance levels: \\n - Core: Filter types and\n                              their corresponding configuration defined by   \\\"Support:\n                              Core\\\" in this package, e.g. \\\"RequestHeaderModifier\\\".\n                              All   implementations must support core filters. \\n\n                              - Extended: Filter types and their corresponding configuration\n                              defined by   \\\"Support: Extended\\\" in this package,\n                              e.g. \\\"RequestMirror\\\". Implementers   are encouraged\n                              to support extended filters. \\n - Custom: Filters that\n                              are defined and supported by specific vendors.   In\n                              the future, filters showing convergence in behavior\n                              across multiple   implementations will be considered\n                              for inclusion in extended or core   conformance levels.\n                              Filter-specific configuration for such filters   is\n                              specified using the ExtensionRef field. `Type` should\n                              be set to   \\\"ExtensionRef\\\" for custom filters. \\n\n                              Implementers are encouraged to define custom implementation\n                              types to extend the core API with implementation-specific\n                              behavior.\"\n                            enum:\n                            - RequestHeaderModifier\n                            - RequestMirror\n                            - ExtensionRef\n                            type: string\n                        required:\n                        - type\n                        type: object\n                      maxItems: 16\n                      type: array\n                    forwardTo:\n                      description: ForwardTo defines the backend(s) where matching\n                        requests should be sent. If unspecified, the rule performs\n                        no forwarding. If unspecified and no filters are specified\n                        that would result in a response being sent, a 503 error code\n                        is returned.\n                      items:\n                        description: HTTPRouteForwardTo defines how a HTTPRoute should\n                          forward a request.\n                        properties:\n                          backendRef:\n                            description: \"BackendRef is a reference to a backend to\n                              forward matched requests to. If both BackendRef and\n                              ServiceName are specified, ServiceName will be given\n                              precedence. \\n If the referent cannot be found, the\n                              route must be dropped from the Gateway. The controller\n                              should raise the \\\"ResolvedRefs\\\" condition on the Gateway\n                              with the \\\"DegradedRoutes\\\" reason. The gateway status\n                              for this route should be updated with a condition that\n                              describes the error more specifically. \\n Support: Custom\"\n                            properties:\n                              group:\n                                description: Group is the group of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              kind:\n                                description: Kind is kind of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              name:\n                                description: Name is the name of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                            required:\n                            - group\n                            - kind\n                            - name\n                            type: object\n                          filters:\n                            description: \"Filters defined at this-level should be\n                              executed if and only if the request is being forwarded\n                              to the backend defined here. \\n Support: Custom (For\n                              broader support of filters, use the Filters field in\n                              HTTPRouteRule.)\"\n                            items:\n                              description: 'HTTPRouteFilter defines additional processing\n                                steps that must be completed during the request or\n                                response lifecycle. HTTPRouteFilters are meant as\n                                an extension point to express additional processing\n                                that may be done in Gateway implementations. Some\n                                examples include request or response modification,\n                                implementing authentication strategies, rate-limiting,\n                                and traffic shaping. API guarantee/conformance is\n                                defined based on the type of the filter. TODO(hbagdi):\n                                re-render CRDs once controller-tools supports union\n                                tags: - https://github.com/kubernetes-sigs/controller-tools/pull/298\n                                - https://github.com/kubernetes-sigs/controller-tools/issues/461'\n                              properties:\n                                extensionRef:\n                                  description: \"ExtensionRef is an optional, implementation-specific\n                                    extension to the \\\"filter\\\" behavior.  For example,\n                                    resource \\\"myroutefilter\\\" in group \\\"networking.acme.io\\\").\n                                    ExtensionRef MUST NOT be used for core and extended\n                                    filters. \\n Support: Implementation-specific\"\n                                  properties:\n                                    group:\n                                      description: Group is the group of the referent.\n                                      maxLength: 253\n                                      minLength: 1\n                                      type: string\n                                    kind:\n                                      description: Kind is kind of the referent.\n                                      maxLength: 253\n                                      minLength: 1\n                                      type: string\n                                    name:\n                                      description: Name is the name of the referent.\n                                      maxLength: 253\n                                      minLength: 1\n                                      type: string\n                                  required:\n                                  - group\n                                  - kind\n                                  - name\n                                  type: object\n                                requestHeaderModifier:\n                                  description: \"RequestHeaderModifier defines a schema\n                                    for a filter that modifies request headers. \\n\n                                    Support: Core\"\n                                  properties:\n                                    add:\n                                      additionalProperties:\n                                        type: string\n                                      description: \"Add adds the given header (name,\n                                        value) to the request before the action. It\n                                        appends to any existing values associated\n                                        with the header name. \\n Input:   GET /foo\n                                        HTTP/1.1   my-header: foo \\n Config:   add:\n                                        {\\\"my-header\\\": \\\"bar\\\"} \\n Output:   GET\n                                        /foo HTTP/1.1   my-header: foo   my-header:\n                                        bar \\n Support: Extended\"\n                                      type: object\n                                    remove:\n                                      description: \"Remove the given header(s) from\n                                        the HTTP request before the action. The value\n                                        of RemoveHeader is a list of HTTP header names.\n                                        Note that the header names are case-insensitive\n                                        [RFC-2616 4.2]. \\n Input:   GET /foo HTTP/1.1\n                                        \\  my-header1: foo   my-header2: bar   my-header3:\n                                        baz \\n Config:   remove: [\\\"my-header1\\\",\n                                        \\\"my-header3\\\"] \\n Output:   GET /foo HTTP/1.1\n                                        \\  my-header2: bar \\n Support: Extended\"\n                                      items:\n                                        type: string\n                                      maxItems: 16\n                                      type: array\n                                    set:\n                                      additionalProperties:\n                                        type: string\n                                      description: \"Set overwrites the request with\n                                        the given header (name, value) before the\n                                        action. \\n Input:   GET /foo HTTP/1.1   my-header:\n                                        foo \\n Config:   set: {\\\"my-header\\\": \\\"bar\\\"}\n                                        \\n Output:   GET /foo HTTP/1.1   my-header:\n                                        bar \\n Support: Extended\"\n                                      type: object\n                                  type: object\n                                requestMirror:\n                                  description: \"RequestMirror defines a schema for\n                                    a filter that mirrors requests. \\n Support: Extended\"\n                                  properties:\n                                    backendRef:\n                                      description: \"BackendRef is a local object reference\n                                        to mirror matched requests to. If both BackendRef\n                                        and ServiceName are specified, ServiceName\n                                        will be given precedence. \\n If the referent\n                                        cannot be found, the rule is not included\n                                        in the route. The controller should raise\n                                        the \\\"ResolvedRefs\\\" condition on the Gateway\n                                        with the \\\"DegradedRoutes\\\" reason. The gateway\n                                        status for this route should be updated with\n                                        a condition that describes the error more\n                                        specifically. \\n Support: Custom\"\n                                      properties:\n                                        group:\n                                          description: Group is the group of the referent.\n                                          maxLength: 253\n                                          minLength: 1\n                                          type: string\n                                        kind:\n                                          description: Kind is kind of the referent.\n                                          maxLength: 253\n                                          minLength: 1\n                                          type: string\n                                        name:\n                                          description: Name is the name of the referent.\n                                          maxLength: 253\n                                          minLength: 1\n                                          type: string\n                                      required:\n                                      - group\n                                      - kind\n                                      - name\n                                      type: object\n                                    port:\n                                      description: \"Port specifies the destination\n                                        port number to use for the backend referenced\n                                        by the ServiceName or BackendRef field. \\n\n                                        If unspecified, the destination port in the\n                                        request is used when forwarding to a backendRef\n                                        or serviceName.\"\n                                      format: int32\n                                      maximum: 65535\n                                      minimum: 1\n                                      type: integer\n                                    serviceName:\n                                      description: \"ServiceName refers to the name\n                                        of the Service to mirror matched requests\n                                        to. When specified, this takes the place of\n                                        BackendRef. If both BackendRef and ServiceName\n                                        are specified, ServiceName will be given precedence.\n                                        \\n If the referent cannot be found, the rule\n                                        is not included in the route. The controller\n                                        should raise the \\\"ResolvedRefs\\\" condition\n                                        on the Gateway with the \\\"DegradedRoutes\\\"\n                                        reason. The gateway status for this route\n                                        should be updated with a condition that describes\n                                        the error more specifically. \\n Support: Core\"\n                                      maxLength: 253\n                                      type: string\n                                  type: object\n                                type:\n                                  description: \"Type identifies the type of filter\n                                    to apply. As with other API fields, types are\n                                    classified into three conformance levels: \\n -\n                                    Core: Filter types and their corresponding configuration\n                                    defined by   \\\"Support: Core\\\" in this package,\n                                    e.g. \\\"RequestHeaderModifier\\\". All   implementations\n                                    must support core filters. \\n - Extended: Filter\n                                    types and their corresponding configuration defined\n                                    by   \\\"Support: Extended\\\" in this package, e.g.\n                                    \\\"RequestMirror\\\". Implementers   are encouraged\n                                    to support extended filters. \\n - Custom: Filters\n                                    that are defined and supported by specific vendors.\n                                    \\  In the future, filters showing convergence\n                                    in behavior across multiple   implementations\n                                    will be considered for inclusion in extended or\n                                    core   conformance levels. Filter-specific configuration\n                                    for such filters   is specified using the ExtensionRef\n                                    field. `Type` should be set to   \\\"ExtensionRef\\\"\n                                    for custom filters. \\n Implementers are encouraged\n                                    to define custom implementation types to extend\n                                    the core API with implementation-specific behavior.\"\n                                  enum:\n                                  - RequestHeaderModifier\n                                  - RequestMirror\n                                  - ExtensionRef\n                                  type: string\n                              required:\n                              - type\n                              type: object\n                            maxItems: 16\n                            type: array\n                          port:\n                            description: \"Port specifies the destination port number\n                              to use for the backend referenced by the ServiceName\n                              or BackendRef field. If unspecified, the destination\n                              port in the request is used when forwarding to a backendRef\n                              or serviceName. \\n Support: Core\"\n                            format: int32\n                            maximum: 65535\n                            minimum: 1\n                            type: integer\n                          serviceName:\n                            description: \"ServiceName refers to the name of the Service\n                              to forward matched requests to. When specified, this\n                              takes the place of BackendRef. If both BackendRef and\n                              ServiceName are specified, ServiceName will be given\n                              precedence. \\n If the referent cannot be found, the\n                              route must be dropped from the Gateway. The controller\n                              should raise the \\\"ResolvedRefs\\\" condition on the Gateway\n                              with the \\\"DegradedRoutes\\\" reason. The gateway status\n                              for this route should be updated with a condition that\n                              describes the error more specifically. \\n The protocol\n                              to use should be specified with the AppProtocol field\n                              on Service resources. This field was introduced in Kubernetes\n                              1.18. If using an earlier version of Kubernetes, a `networking.x-k8s.io/app-protocol`\n                              annotation on the BackendPolicy resource may be used\n                              to define the protocol. If the AppProtocol field is\n                              available, this annotation should not be used. The AppProtocol\n                              field, when populated, takes precedence over the annotation\n                              in the BackendPolicy resource. For custom backends,\n                              it is encouraged to add a semantically-equivalent field\n                              in the Custom Resource Definition. \\n Support: Core\"\n                            maxLength: 253\n                            type: string\n                          weight:\n                            default: 1\n                            description: \"Weight specifies the proportion of HTTP\n                              requests forwarded to the backend referenced by the\n                              ServiceName or BackendRef field. This is computed as\n                              weight/(sum of all weights in this ForwardTo list).\n                              For non-zero values, there may be some epsilon from\n                              the exact proportion defined here depending on the precision\n                              an implementation supports. Weight is not a percentage\n                              and the sum of weights does not need to equal 100. \\n\n                              If only one backend is specified and it has a weight\n                              greater than 0, 100% of the traffic is forwarded to\n                              that backend. If weight is set to 0, no traffic should\n                              be forwarded for this entry. If unspecified, weight\n                              defaults to 1. \\n Support: Core\"\n                            format: int32\n                            maximum: 1000000\n                            minimum: 0\n                            type: integer\n                        type: object\n                      maxItems: 16\n                      type: array\n                    matches:\n                      default:\n                      - path:\n                          type: Prefix\n                          value: /\n                      description: \"Matches define conditions used for matching the\n                        rule against incoming HTTP requests. Each match is independent,\n                        i.e. this rule will be matched if **any** one of the matches\n                        is satisfied. \\n For example, take the following matches configuration:\n                        \\n ``` matches: - path:     value: \\\"/foo\\\"   headers:     values:\n                        \\      version: \\\"2\\\" - path:     value: \\\"/v2/foo\\\" ``` \\n\n                        For a request to match against this rule, a request should\n                        satisfy EITHER of the two conditions: \\n - path prefixed with\n                        `/foo` AND contains the header `version: \\\"2\\\"` - path prefix\n                        of `/v2/foo` \\n See the documentation for HTTPRouteMatch on\n                        how to specify multiple match conditions that should be ANDed\n                        together. \\n If no matches are specified, the default is a\n                        prefix path match on \\\"/\\\", which has the effect of matching\n                        every HTTP request. \\n Each client request MUST map to a maximum\n                        of one route rule. If a request matches multiple rules, matching\n                        precedence MUST be determined in order of the following criteria,\n                        continuing on ties: \\n * The longest matching hostname. *\n                        The longest matching path. * The largest number of header\n                        matches. \\n If ties still exist across multiple Routes, matching\n                        precedence MUST be determined in order of the following criteria,\n                        continuing on ties: \\n * The oldest Route based on creation\n                        timestamp. For example, a Route with   a creation timestamp\n                        of \\\"2020-09-08 01:02:03\\\" is given precedence over   a Route\n                        with a creation timestamp of \\\"2020-09-08 01:02:04\\\". * The\n                        Route appearing first in alphabetical order by   \\\"<namespace>/<name>\\\".\n                        For example, foo/bar is given precedence over   foo/baz. \\n\n                        If ties still exist within the Route that has been given precedence,\n                        matching precedence MUST be granted to the first matching\n                        rule meeting the above criteria.\"\n                      items:\n                        description: \"HTTPRouteMatch defines the predicate used to\n                          match requests to a given action. Multiple match types are\n                          ANDed together, i.e. the match will evaluate to true only\n                          if all conditions are satisfied. \\n For example, the match\n                          below will match a HTTP request only if its path starts\n                          with `/foo` AND it contains the `version: \\\"1\\\"` header:\n                          \\n ``` match:   path:     value: \\\"/foo\\\"   headers:     values:\n                          \\      version: \\\"1\\\" ```\"\n                        properties:\n                          extensionRef:\n                            description: \"ExtensionRef is an optional, implementation-specific\n                              extension to the \\\"match\\\" behavior. For example, resource\n                              \\\"myroutematcher\\\" in group \\\"networking.acme.io\\\".\n                              If the referent cannot be found, the rule is not included\n                              in the route. The controller should raise the \\\"ResolvedRefs\\\"\n                              condition on the Gateway with the \\\"DegradedRoutes\\\"\n                              reason. The gateway status for this route should be\n                              updated with a condition that describes the error more\n                              specifically. \\n Support: Custom\"\n                            properties:\n                              group:\n                                description: Group is the group of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              kind:\n                                description: Kind is kind of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              name:\n                                description: Name is the name of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                            required:\n                            - group\n                            - kind\n                            - name\n                            type: object\n                          headers:\n                            description: Headers specifies a HTTP request header matcher.\n                            properties:\n                              type:\n                                default: Exact\n                                description: \"Type specifies how to match against\n                                  the value of the header. \\n Support: Core (Exact)\n                                  \\n Support: Custom (RegularExpression, ImplementationSpecific)\n                                  \\n Since RegularExpression PathType has custom conformance,\n                                  implementations can support POSIX, PCRE or any other\n                                  dialects of regular expressions. Please read the\n                                  implementation's documentation to determine the\n                                  supported dialect. \\n HTTP Header name matching\n                                  MUST be case-insensitive (RFC 2616 - section 4.2).\"\n                                enum:\n                                - Exact\n                                - RegularExpression\n                                - ImplementationSpecific\n                                type: string\n                              values:\n                                additionalProperties:\n                                  type: string\n                                description: \"Values is a map of HTTP Headers to be\n                                  matched. It MUST contain at least one entry. \\n\n                                  The HTTP header field name to match is the map key,\n                                  and the value of the HTTP header is the map value.\n                                  HTTP header field name matching MUST be case-insensitive.\n                                  \\n Multiple match values are ANDed together, meaning,\n                                  a request must match all the specified headers to\n                                  select the route.\"\n                                type: object\n                            required:\n                            - values\n                            type: object\n                          path:\n                            default:\n                              type: Prefix\n                              value: /\n                            description: Path specifies a HTTP request path matcher.\n                              If this field is not specified, a default prefix match\n                              on the \"/\" path is provided.\n                            properties:\n                              type:\n                                default: Prefix\n                                description: \"Type specifies how to match against\n                                  the path Value. \\n Support: Core (Exact, Prefix)\n                                  \\n Support: Custom (RegularExpression, ImplementationSpecific)\n                                  \\n Since RegularExpression PathType has custom conformance,\n                                  implementations can support POSIX, PCRE or any other\n                                  dialects of regular expressions. Please read the\n                                  implementation's documentation to determine the\n                                  supported dialect.\"\n                                enum:\n                                - Exact\n                                - Prefix\n                                - RegularExpression\n                                - ImplementationSpecific\n                                type: string\n                              value:\n                                default: /\n                                description: Value of the HTTP path to match against.\n                                type: string\n                            type: object\n                          queryParams:\n                            description: QueryParams specifies a HTTP query parameter\n                              matcher.\n                            properties:\n                              type:\n                                default: Exact\n                                description: \"Type specifies how to match against\n                                  the value of the query parameter. \\n Support: Extended\n                                  (Exact) \\n Support: Custom (RegularExpression, ImplementationSpecific)\n                                  \\n Since RegularExpression QueryParamMatchType has\n                                  custom conformance, implementations can support\n                                  POSIX, PCRE or any other dialects of regular expressions.\n                                  Please read the implementation's documentation to\n                                  determine the supported dialect.\"\n                                enum:\n                                - Exact\n                                - RegularExpression\n                                - ImplementationSpecific\n                                type: string\n                              values:\n                                additionalProperties:\n                                  type: string\n                                description: \"Values is a map of HTTP query parameters\n                                  to be matched. It MUST contain at least one entry.\n                                  \\n The query parameter name to match is the map\n                                  key, and the value of the query parameter is the\n                                  map value. \\n Multiple match values are ANDed together,\n                                  meaning, a request must match all the specified\n                                  query parameters to select the route. \\n HTTP query\n                                  parameter matching MUST be case-sensitive for both\n                                  keys and values. (See https://tools.ietf.org/html/rfc7230#section-2.7.3).\n                                  \\n Note that the query parameter key MUST always\n                                  be an exact match by string comparison.\"\n                                type: object\n                            required:\n                            - values\n                            type: object\n                        type: object\n                      maxItems: 8\n                      type: array\n                  type: object\n                maxItems: 16\n                type: array\n              tls:\n                description: \"TLS defines the TLS certificate to use for Hostnames\n                  defined in this Route. This configuration only takes effect if the\n                  AllowRouteOverride field is set to true in the associated Gateway\n                  resource. \\n Collisions can happen if multiple HTTPRoutes define\n                  a TLS certificate for the same hostname. In such a case, conflict\n                  resolution guiding principles apply, specifically, if hostnames\n                  are same and two different certificates are specified then the certificate\n                  in the oldest resource wins. \\n Please note that HTTP Route-selection\n                  takes place after the TLS Handshake (ClientHello). Due to this,\n                  TLS certificate defined here will take precedence even if the request\n                  has the potential to match multiple routes (in case multiple HTTPRoutes\n                  share the same hostname). \\n Support: Core\"\n                properties:\n                  certificateRef:\n                    description: \"CertificateRef is a reference to a Kubernetes object\n                      that contains a TLS certificate and private key. This certificate\n                      is used to establish a TLS handshake for requests that match\n                      the hostname of the associated HTTPRoute. The referenced object\n                      MUST reside in the same namespace as HTTPRoute. \\n This field\n                      is required when the TLS configuration mode of the associated\n                      Gateway listener is set to \\\"Passthrough\\\". \\n CertificateRef\n                      can reference a standard Kubernetes resource, i.e. Secret, or\n                      an implementation-specific custom resource. \\n Support: Core\n                      (Kubernetes Secrets) \\n Support: Implementation-specific (Other\n                      resource types)\"\n                    properties:\n                      group:\n                        description: Group is the group of the referent.\n                        maxLength: 253\n                        minLength: 1\n                        type: string\n                      kind:\n                        description: Kind is kind of the referent.\n                        maxLength: 253\n                        minLength: 1\n                        type: string\n                      name:\n                        description: Name is the name of the referent.\n                        maxLength: 253\n                        minLength: 1\n                        type: string\n                    required:\n                    - group\n                    - kind\n                    - name\n                    type: object\n                required:\n                - certificateRef\n                type: object\n            type: object\n          status:\n            description: Status defines the current state of HTTPRoute.\n            properties:\n              gateways:\n                description: \"Gateways is a list of Gateways that are associated with\n                  the route, and the status of the route with respect to each Gateway.\n                  When a Gateway selects this route, the controller that manages the\n                  Gateway must add an entry to this list when the controller first\n                  sees the route and should update the entry as appropriate when the\n                  route is modified. \\n A maximum of 100 Gateways will be represented\n                  in this list. If this list is full, there may be additional Gateways\n                  using this Route that are not included in the list. An empty list\n                  means the route has not been admitted by any Gateway.\"\n                items:\n                  description: RouteGatewayStatus describes the status of a route\n                    with respect to an associated Gateway.\n                  properties:\n                    conditions:\n                      description: Conditions describes the status of the route with\n                        respect to the Gateway. The \"Admitted\" condition must always\n                        be specified by controllers to indicate whether the route\n                        has been admitted or rejected by the Gateway, and why. Note\n                        that the route's availability is also subject to the Gateway's\n                        own status conditions and listener status.\n                      items:\n                        description: \"Condition contains details for one aspect of\n                          the current state of this API Resource. --- This struct\n                          is intended for direct use as an array at the field path\n                          .status.conditions.  For example, type FooStatus struct{\n                          \\    // Represents the observations of a foo's current state.\n                          \\    // Known .status.conditions.type are: \\\"Available\\\",\n                          \\\"Progressing\\\", and \\\"Degraded\\\"     // +patchMergeKey=type\n                          \\    // +patchStrategy=merge     // +listType=map     //\n                          +listMapKey=type     Conditions []metav1.Condition `json:\\\"conditions,omitempty\\\"\n                          patchStrategy:\\\"merge\\\" patchMergeKey:\\\"type\\\" protobuf:\\\"bytes,1,rep,name=conditions\\\"`\n                          \\n     // other fields }\"\n                        properties:\n                          lastTransitionTime:\n                            description: lastTransitionTime is the last time the condition\n                              transitioned from one status to another. This should\n                              be when the underlying condition changed.  If that is\n                              not known, then using the time when the API field changed\n                              is acceptable.\n                            format: date-time\n                            type: string\n                          message:\n                            description: message is a human readable message indicating\n                              details about the transition. This may be an empty string.\n                            maxLength: 32768\n                            type: string\n                          observedGeneration:\n                            description: observedGeneration represents the .metadata.generation\n                              that the condition was set based upon. For instance,\n                              if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration\n                              is 9, the condition is out of date with respect to the\n                              current state of the instance.\n                            format: int64\n                            minimum: 0\n                            type: integer\n                          reason:\n                            description: reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. The value should\n                              be a CamelCase string. This field may not be empty.\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                              --- Many .condition.type values are consistent across\n                              resources like Available, but because arbitrary conditions\n                              can be useful (see .node.status.conditions), the ability\n                              to deconflict is important. The regex it matches is\n                              (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - lastTransitionTime\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      maxItems: 8\n                      type: array\n                      x-kubernetes-list-map-keys:\n                      - type\n                      x-kubernetes-list-type: map\n                    gatewayRef:\n                      description: GatewayRef is a reference to a Gateway object that\n                        is associated with the route.\n                      properties:\n                        controller:\n                          description: \"Controller is a domain/path string that indicates\n                            the controller implementing the Gateway. This corresponds\n                            with the controller field on GatewayClass. \\n Example:\n                            \\\"acme.io/gateway-controller\\\". \\n The format of this\n                            field is DOMAIN \\\"/\\\" PATH, where DOMAIN and PATH are\n                            valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).\"\n                          maxLength: 253\n                          type: string\n                        name:\n                          description: Name is the name of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                        namespace:\n                          description: Namespace is the namespace of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                      required:\n                      - name\n                      - namespace\n                      type: object\n                  required:\n                  - gatewayRef\n                  type: object\n                maxItems: 100\n                type: array\n            required:\n            - gateways\n            type: object\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: tcproutes.networking.x-k8s.io\nspec:\n  group: networking.x-k8s.io\n  names:\n    categories:\n    - gateway-api\n    kind: TCPRoute\n    listKind: TCPRouteList\n    plural: tcproutes\n    singular: tcproute\n  scope: Namespaced\n  versions:\n  - additionalPrinterColumns:\n    - jsonPath: .metadata.creationTimestamp\n      name: Age\n      type: date\n    name: v1alpha1\n    schema:\n      openAPIV3Schema:\n        description: TCPRoute is the Schema for the TCPRoute resource.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: Spec defines the desired state of TCPRoute.\n            properties:\n              gateways:\n                default:\n                  allow: SameNamespace\n                description: Gateways defines which Gateways can use this Route.\n                properties:\n                  allow:\n                    default: SameNamespace\n                    description: 'Allow indicates which Gateways will be allowed to\n                      use this route. Possible values are: * All: Gateways in any\n                      namespace can use this route. * FromList: Only Gateways specified\n                      in GatewayRefs may use this route. * SameNamespace: Only Gateways\n                      in the same namespace may use this route.'\n                    enum:\n                    - All\n                    - FromList\n                    - SameNamespace\n                    type: string\n                  gatewayRefs:\n                    description: GatewayRefs must be specified when Allow is set to\n                      \"FromList\". In that case, only Gateways referenced in this list\n                      will be allowed to use this route. This field is ignored for\n                      other values of \"Allow\".\n                    items:\n                      description: GatewayReference identifies a Gateway in a specified\n                        namespace.\n                      properties:\n                        name:\n                          description: Name is the name of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                        namespace:\n                          description: Namespace is the namespace of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                      required:\n                      - name\n                      - namespace\n                      type: object\n                    type: array\n                type: object\n              rules:\n                description: Rules are a list of TCP matchers and actions.\n                items:\n                  description: TCPRouteRule is the configuration for a given rule.\n                  properties:\n                    forwardTo:\n                      description: ForwardTo defines the backend(s) where matching\n                        requests should be sent.\n                      items:\n                        description: RouteForwardTo defines how a Route should forward\n                          a request.\n                        properties:\n                          backendRef:\n                            description: \"BackendRef is a reference to a backend to\n                              forward matched requests to. If both BackendRef and\n                              ServiceName are specified, ServiceName will be given\n                              precedence. \\n If the referent cannot be found, the\n                              rule is not included in the route. The controller should\n                              raise the \\\"ResolvedRefs\\\" condition on the Gateway\n                              with the \\\"DegradedRoutes\\\" reason. The gateway status\n                              for this route should be updated with a condition that\n                              describes the error more specifically. \\n Support: Custom\"\n                            properties:\n                              group:\n                                description: Group is the group of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              kind:\n                                description: Kind is kind of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              name:\n                                description: Name is the name of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                            required:\n                            - group\n                            - kind\n                            - name\n                            type: object\n                          port:\n                            description: \"Port specifies the destination port number\n                              to use for the backend referenced by the ServiceName\n                              or BackendRef field. If unspecified, the destination\n                              port in the request is used when forwarding to a backendRef\n                              or serviceName. \\n Support: Core\"\n                            format: int32\n                            maximum: 65535\n                            minimum: 1\n                            type: integer\n                          serviceName:\n                            description: \"ServiceName refers to the name of the Service\n                              to forward matched requests to. When specified, this\n                              takes the place of BackendRef. If both BackendRef and\n                              ServiceName are specified, ServiceName will be given\n                              precedence. \\n If the referent cannot be found, the\n                              rule is not included in the route. The controller should\n                              raise the \\\"ResolvedRefs\\\" condition on the Gateway\n                              with the \\\"DegradedRoutes\\\" reason. The gateway status\n                              for this route should be updated with a condition that\n                              describes the error more specifically. \\n The protocol\n                              to use is defined using AppProtocol field (introduced\n                              in Kubernetes 1.18) in the Service resource. In the\n                              absence of the AppProtocol field a `networking.x-k8s.io/app-protocol`\n                              annotation on the BackendPolicy resource may be used\n                              to define the protocol. If the AppProtocol field is\n                              available, this annotation should not be used. The AppProtocol\n                              field, when populated, takes precedence over the annotation\n                              in the BackendPolicy resource. For custom backends,\n                              it is encouraged to add a semantically-equivalent field\n                              in the Custom Resource Definition. \\n Support: Core\"\n                            maxLength: 253\n                            type: string\n                          weight:\n                            default: 1\n                            description: \"Weight specifies the proportion of HTTP\n                              requests forwarded to the backend referenced by the\n                              ServiceName or BackendRef field. This is computed as\n                              weight/(sum of all weights in this ForwardTo list).\n                              For non-zero values, there may be some epsilon from\n                              the exact proportion defined here depending on the precision\n                              an implementation supports. Weight is not a percentage\n                              and the sum of weights does not need to equal 100. \\n\n                              If only one backend is specified and it has a weight\n                              greater than 0, 100% of the traffic is forwarded to\n                              that backend. If weight is set to 0, no traffic should\n                              be forwarded for this entry. If unspecified, weight\n                              defaults to 1. \\n Support: Extended\"\n                            format: int32\n                            maximum: 1000000\n                            minimum: 0\n                            type: integer\n                        type: object\n                      maxItems: 16\n                      minItems: 1\n                      type: array\n                    matches:\n                      description: \"Matches define conditions used for matching the\n                        rule against incoming TCP connections. Each match is independent,\n                        i.e. this rule will be matched if **any** one of the matches\n                        is satisfied. If unspecified (i.e. empty), this Rule will\n                        match all requests for the associated Listener. \\n Each client\n                        request MUST map to a maximum of one route rule. If a request\n                        matches multiple rules, matching precedence MUST be determined\n                        in order of the following criteria, continuing on ties: \\n\n                        * The most specific match specified by ExtensionRef. Each\n                        implementation   that supports ExtensionRef may have different\n                        ways of determining the   specificity of the referenced extension.\n                        \\n If ties still exist across multiple Routes, matching precedence\n                        MUST be determined in order of the following criteria, continuing\n                        on ties: \\n * The oldest Route based on creation timestamp.\n                        For example, a Route with   a creation timestamp of \\\"2020-09-08\n                        01:02:03\\\" is given precedence over   a Route with a creation\n                        timestamp of \\\"2020-09-08 01:02:04\\\". * The Route appearing\n                        first in alphabetical order by   \\\"<namespace>/<name>\\\". For\n                        example, foo/bar is given precedence over   foo/baz. \\n If\n                        ties still exist within the Route that has been given precedence,\n                        matching precedence MUST be granted to the first matching\n                        rule meeting the above criteria.\"\n                      items:\n                        description: TCPRouteMatch defines the predicate used to match\n                          connections to a given action.\n                        properties:\n                          extensionRef:\n                            description: \"ExtensionRef is an optional, implementation-specific\n                              extension to the \\\"match\\\" behavior.  For example, resource\n                              \\\"mytcproutematcher\\\" in group \\\"networking.acme.io\\\".\n                              If the referent cannot be found, the rule is not included\n                              in the route. The controller should raise the \\\"ResolvedRefs\\\"\n                              condition on the Gateway with the \\\"DegradedRoutes\\\"\n                              reason. The gateway status for this route should be\n                              updated with a condition that describes the error more\n                              specifically. \\n Support: Custom\"\n                            properties:\n                              group:\n                                description: Group is the group of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              kind:\n                                description: Kind is kind of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              name:\n                                description: Name is the name of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                            required:\n                            - group\n                            - kind\n                            - name\n                            type: object\n                        type: object\n                      maxItems: 8\n                      type: array\n                  required:\n                  - forwardTo\n                  type: object\n                maxItems: 16\n                minItems: 1\n                type: array\n            required:\n            - rules\n            type: object\n          status:\n            description: Status defines the current state of TCPRoute.\n            properties:\n              gateways:\n                description: \"Gateways is a list of Gateways that are associated with\n                  the route, and the status of the route with respect to each Gateway.\n                  When a Gateway selects this route, the controller that manages the\n                  Gateway must add an entry to this list when the controller first\n                  sees the route and should update the entry as appropriate when the\n                  route is modified. \\n A maximum of 100 Gateways will be represented\n                  in this list. If this list is full, there may be additional Gateways\n                  using this Route that are not included in the list. An empty list\n                  means the route has not been admitted by any Gateway.\"\n                items:\n                  description: RouteGatewayStatus describes the status of a route\n                    with respect to an associated Gateway.\n                  properties:\n                    conditions:\n                      description: Conditions describes the status of the route with\n                        respect to the Gateway. The \"Admitted\" condition must always\n                        be specified by controllers to indicate whether the route\n                        has been admitted or rejected by the Gateway, and why. Note\n                        that the route's availability is also subject to the Gateway's\n                        own status conditions and listener status.\n                      items:\n                        description: \"Condition contains details for one aspect of\n                          the current state of this API Resource. --- This struct\n                          is intended for direct use as an array at the field path\n                          .status.conditions.  For example, type FooStatus struct{\n                          \\    // Represents the observations of a foo's current state.\n                          \\    // Known .status.conditions.type are: \\\"Available\\\",\n                          \\\"Progressing\\\", and \\\"Degraded\\\"     // +patchMergeKey=type\n                          \\    // +patchStrategy=merge     // +listType=map     //\n                          +listMapKey=type     Conditions []metav1.Condition `json:\\\"conditions,omitempty\\\"\n                          patchStrategy:\\\"merge\\\" patchMergeKey:\\\"type\\\" protobuf:\\\"bytes,1,rep,name=conditions\\\"`\n                          \\n     // other fields }\"\n                        properties:\n                          lastTransitionTime:\n                            description: lastTransitionTime is the last time the condition\n                              transitioned from one status to another. This should\n                              be when the underlying condition changed.  If that is\n                              not known, then using the time when the API field changed\n                              is acceptable.\n                            format: date-time\n                            type: string\n                          message:\n                            description: message is a human readable message indicating\n                              details about the transition. This may be an empty string.\n                            maxLength: 32768\n                            type: string\n                          observedGeneration:\n                            description: observedGeneration represents the .metadata.generation\n                              that the condition was set based upon. For instance,\n                              if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration\n                              is 9, the condition is out of date with respect to the\n                              current state of the instance.\n                            format: int64\n                            minimum: 0\n                            type: integer\n                          reason:\n                            description: reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. The value should\n                              be a CamelCase string. This field may not be empty.\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                              --- Many .condition.type values are consistent across\n                              resources like Available, but because arbitrary conditions\n                              can be useful (see .node.status.conditions), the ability\n                              to deconflict is important. The regex it matches is\n                              (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - lastTransitionTime\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      maxItems: 8\n                      type: array\n                      x-kubernetes-list-map-keys:\n                      - type\n                      x-kubernetes-list-type: map\n                    gatewayRef:\n                      description: GatewayRef is a reference to a Gateway object that\n                        is associated with the route.\n                      properties:\n                        controller:\n                          description: \"Controller is a domain/path string that indicates\n                            the controller implementing the Gateway. This corresponds\n                            with the controller field on GatewayClass. \\n Example:\n                            \\\"acme.io/gateway-controller\\\". \\n The format of this\n                            field is DOMAIN \\\"/\\\" PATH, where DOMAIN and PATH are\n                            valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).\"\n                          maxLength: 253\n                          type: string\n                        name:\n                          description: Name is the name of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                        namespace:\n                          description: Namespace is the namespace of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                      required:\n                      - name\n                      - namespace\n                      type: object\n                  required:\n                  - gatewayRef\n                  type: object\n                maxItems: 100\n                type: array\n            required:\n            - gateways\n            type: object\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: tlsroutes.networking.x-k8s.io\nspec:\n  group: networking.x-k8s.io\n  names:\n    categories:\n    - gateway-api\n    kind: TLSRoute\n    listKind: TLSRouteList\n    plural: tlsroutes\n    singular: tlsroute\n  scope: Namespaced\n  versions:\n  - additionalPrinterColumns:\n    - jsonPath: .metadata.creationTimestamp\n      name: Age\n      type: date\n    name: v1alpha1\n    schema:\n      openAPIV3Schema:\n        description: \"The TLSRoute resource is similar to TCPRoute, but can be configured\n          to match against TLS-specific metadata. This allows more flexibility in\n          matching streams for a given TLS listener. \\n If you need to forward traffic\n          to a single target for a TLS listener, you could choose to use a TCPRoute\n          with a TLS listener.\"\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: Spec defines the desired state of TLSRoute.\n            properties:\n              gateways:\n                default:\n                  allow: SameNamespace\n                description: Gateways defines which Gateways can use this Route.\n                properties:\n                  allow:\n                    default: SameNamespace\n                    description: 'Allow indicates which Gateways will be allowed to\n                      use this route. Possible values are: * All: Gateways in any\n                      namespace can use this route. * FromList: Only Gateways specified\n                      in GatewayRefs may use this route. * SameNamespace: Only Gateways\n                      in the same namespace may use this route.'\n                    enum:\n                    - All\n                    - FromList\n                    - SameNamespace\n                    type: string\n                  gatewayRefs:\n                    description: GatewayRefs must be specified when Allow is set to\n                      \"FromList\". In that case, only Gateways referenced in this list\n                      will be allowed to use this route. This field is ignored for\n                      other values of \"Allow\".\n                    items:\n                      description: GatewayReference identifies a Gateway in a specified\n                        namespace.\n                      properties:\n                        name:\n                          description: Name is the name of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                        namespace:\n                          description: Namespace is the namespace of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                      required:\n                      - name\n                      - namespace\n                      type: object\n                    type: array\n                type: object\n              rules:\n                description: Rules are a list of TLS matchers and actions.\n                items:\n                  description: TLSRouteRule is the configuration for a given rule.\n                  properties:\n                    forwardTo:\n                      description: ForwardTo defines the backend(s) where matching\n                        requests should be sent.\n                      items:\n                        description: RouteForwardTo defines how a Route should forward\n                          a request.\n                        properties:\n                          backendRef:\n                            description: \"BackendRef is a reference to a backend to\n                              forward matched requests to. If both BackendRef and\n                              ServiceName are specified, ServiceName will be given\n                              precedence. \\n If the referent cannot be found, the\n                              rule is not included in the route. The controller should\n                              raise the \\\"ResolvedRefs\\\" condition on the Gateway\n                              with the \\\"DegradedRoutes\\\" reason. The gateway status\n                              for this route should be updated with a condition that\n                              describes the error more specifically. \\n Support: Custom\"\n                            properties:\n                              group:\n                                description: Group is the group of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              kind:\n                                description: Kind is kind of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              name:\n                                description: Name is the name of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                            required:\n                            - group\n                            - kind\n                            - name\n                            type: object\n                          port:\n                            description: \"Port specifies the destination port number\n                              to use for the backend referenced by the ServiceName\n                              or BackendRef field. If unspecified, the destination\n                              port in the request is used when forwarding to a backendRef\n                              or serviceName. \\n Support: Core\"\n                            format: int32\n                            maximum: 65535\n                            minimum: 1\n                            type: integer\n                          serviceName:\n                            description: \"ServiceName refers to the name of the Service\n                              to forward matched requests to. When specified, this\n                              takes the place of BackendRef. If both BackendRef and\n                              ServiceName are specified, ServiceName will be given\n                              precedence. \\n If the referent cannot be found, the\n                              rule is not included in the route. The controller should\n                              raise the \\\"ResolvedRefs\\\" condition on the Gateway\n                              with the \\\"DegradedRoutes\\\" reason. The gateway status\n                              for this route should be updated with a condition that\n                              describes the error more specifically. \\n The protocol\n                              to use is defined using AppProtocol field (introduced\n                              in Kubernetes 1.18) in the Service resource. In the\n                              absence of the AppProtocol field a `networking.x-k8s.io/app-protocol`\n                              annotation on the BackendPolicy resource may be used\n                              to define the protocol. If the AppProtocol field is\n                              available, this annotation should not be used. The AppProtocol\n                              field, when populated, takes precedence over the annotation\n                              in the BackendPolicy resource. For custom backends,\n                              it is encouraged to add a semantically-equivalent field\n                              in the Custom Resource Definition. \\n Support: Core\"\n                            maxLength: 253\n                            type: string\n                          weight:\n                            default: 1\n                            description: \"Weight specifies the proportion of HTTP\n                              requests forwarded to the backend referenced by the\n                              ServiceName or BackendRef field. This is computed as\n                              weight/(sum of all weights in this ForwardTo list).\n                              For non-zero values, there may be some epsilon from\n                              the exact proportion defined here depending on the precision\n                              an implementation supports. Weight is not a percentage\n                              and the sum of weights does not need to equal 100. \\n\n                              If only one backend is specified and it has a weight\n                              greater than 0, 100% of the traffic is forwarded to\n                              that backend. If weight is set to 0, no traffic should\n                              be forwarded for this entry. If unspecified, weight\n                              defaults to 1. \\n Support: Extended\"\n                            format: int32\n                            maximum: 1000000\n                            minimum: 0\n                            type: integer\n                        type: object\n                      maxItems: 16\n                      minItems: 1\n                      type: array\n                    matches:\n                      description: \"Matches define conditions used for matching the\n                        rule against incoming TLS connections. Each match is independent,\n                        i.e. this rule will be matched if **any** one of the matches\n                        is satisfied. If unspecified (i.e. empty), this Rule will\n                        match all requests for the associated Listener. \\n Each client\n                        request MUST map to a maximum of one route rule. If a request\n                        matches multiple rules, matching precedence MUST be determined\n                        in order of the following criteria, continuing on ties: \\n\n                        * The longest matching SNI. * The longest matching precise\n                        SNI (without a wildcard). This means that   \\\"b.example.com\\\"\n                        should be given precedence over \\\"*.example.com\\\". * The most\n                        specific match specified by ExtensionRef. Each implementation\n                        \\  that supports ExtensionRef may have different ways of determining\n                        the   specificity of the referenced extension. \\n If ties\n                        still exist across multiple Routes, matching precedence MUST\n                        be determined in order of the following criteria, continuing\n                        on ties: \\n * The oldest Route based on creation timestamp.\n                        For example, a Route with   a creation timestamp of \\\"2020-09-08\n                        01:02:03\\\" is given precedence over   a Route with a creation\n                        timestamp of \\\"2020-09-08 01:02:04\\\". * The Route appearing\n                        first in alphabetical order by   \\\"<namespace>/<name>\\\". For\n                        example, foo/bar is given precedence over   foo/baz. \\n If\n                        ties still exist within the Route that has been given precedence,\n                        matching precedence MUST be granted to the first matching\n                        rule meeting the above criteria.\"\n                      items:\n                        description: TLSRouteMatch defines the predicate used to match\n                          connections to a given action.\n                        properties:\n                          extensionRef:\n                            description: \"ExtensionRef is an optional, implementation-specific\n                              extension to the \\\"match\\\" behavior.  For example, resource\n                              \\\"mytlsroutematcher\\\" in group \\\"networking.acme.io\\\".\n                              If the referent cannot be found, the rule is not included\n                              in the route. The controller should raise the \\\"ResolvedRefs\\\"\n                              condition on the Gateway with the \\\"DegradedRoutes\\\"\n                              reason. The gateway status for this route should be\n                              updated with a condition that describes the error more\n                              specifically. \\n Support: Custom\"\n                            properties:\n                              group:\n                                description: Group is the group of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              kind:\n                                description: Kind is kind of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              name:\n                                description: Name is the name of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                            required:\n                            - group\n                            - kind\n                            - name\n                            type: object\n                          snis:\n                            description: \"SNIs defines a set of SNI names that should\n                              match against the SNI attribute of TLS ClientHello message\n                              in TLS handshake. \\n SNI can be \\\"precise\\\" which is\n                              a domain name without the terminating dot of a network\n                              host (e.g. \\\"foo.example.com\\\") or \\\"wildcard\\\", which\n                              is a domain name prefixed with a single wildcard label\n                              (e.g. `*.example.com`). The wildcard character `*` must\n                              appear by itself as the first DNS label and matches\n                              only a single label. You cannot have a wildcard label\n                              by itself (e.g. Host == `*`). \\n Requests will be matched\n                              against the Host field in the following order: \\n 1.\n                              If SNI is precise, the request matches this rule if\n                              the SNI in    ClientHello is equal to one of the defined\n                              SNIs. 2. If SNI is a wildcard, then the request matches\n                              this rule if the    SNI is to equal to the suffix (removing\n                              the first label) of the    wildcard rule. 3. If SNIs\n                              is unspecified, all requests associated with the gateway\n                              TLS    listener will match. This can be used to define\n                              a default backend    for a TLS listener. \\n Support:\n                              Core\"\n                            items:\n                              description: Hostname is used to specify a hostname\n                                that should be matched.\n                              maxLength: 253\n                              minLength: 1\n                              type: string\n                            maxItems: 16\n                            type: array\n                        type: object\n                      maxItems: 8\n                      type: array\n                  required:\n                  - forwardTo\n                  type: object\n                maxItems: 16\n                minItems: 1\n                type: array\n            required:\n            - rules\n            type: object\n          status:\n            description: Status defines the current state of TLSRoute.\n            properties:\n              gateways:\n                description: \"Gateways is a list of Gateways that are associated with\n                  the route, and the status of the route with respect to each Gateway.\n                  When a Gateway selects this route, the controller that manages the\n                  Gateway must add an entry to this list when the controller first\n                  sees the route and should update the entry as appropriate when the\n                  route is modified. \\n A maximum of 100 Gateways will be represented\n                  in this list. If this list is full, there may be additional Gateways\n                  using this Route that are not included in the list. An empty list\n                  means the route has not been admitted by any Gateway.\"\n                items:\n                  description: RouteGatewayStatus describes the status of a route\n                    with respect to an associated Gateway.\n                  properties:\n                    conditions:\n                      description: Conditions describes the status of the route with\n                        respect to the Gateway. The \"Admitted\" condition must always\n                        be specified by controllers to indicate whether the route\n                        has been admitted or rejected by the Gateway, and why. Note\n                        that the route's availability is also subject to the Gateway's\n                        own status conditions and listener status.\n                      items:\n                        description: \"Condition contains details for one aspect of\n                          the current state of this API Resource. --- This struct\n                          is intended for direct use as an array at the field path\n                          .status.conditions.  For example, type FooStatus struct{\n                          \\    // Represents the observations of a foo's current state.\n                          \\    // Known .status.conditions.type are: \\\"Available\\\",\n                          \\\"Progressing\\\", and \\\"Degraded\\\"     // +patchMergeKey=type\n                          \\    // +patchStrategy=merge     // +listType=map     //\n                          +listMapKey=type     Conditions []metav1.Condition `json:\\\"conditions,omitempty\\\"\n                          patchStrategy:\\\"merge\\\" patchMergeKey:\\\"type\\\" protobuf:\\\"bytes,1,rep,name=conditions\\\"`\n                          \\n     // other fields }\"\n                        properties:\n                          lastTransitionTime:\n                            description: lastTransitionTime is the last time the condition\n                              transitioned from one status to another. This should\n                              be when the underlying condition changed.  If that is\n                              not known, then using the time when the API field changed\n                              is acceptable.\n                            format: date-time\n                            type: string\n                          message:\n                            description: message is a human readable message indicating\n                              details about the transition. This may be an empty string.\n                            maxLength: 32768\n                            type: string\n                          observedGeneration:\n                            description: observedGeneration represents the .metadata.generation\n                              that the condition was set based upon. For instance,\n                              if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration\n                              is 9, the condition is out of date with respect to the\n                              current state of the instance.\n                            format: int64\n                            minimum: 0\n                            type: integer\n                          reason:\n                            description: reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. The value should\n                              be a CamelCase string. This field may not be empty.\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                              --- Many .condition.type values are consistent across\n                              resources like Available, but because arbitrary conditions\n                              can be useful (see .node.status.conditions), the ability\n                              to deconflict is important. The regex it matches is\n                              (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - lastTransitionTime\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      maxItems: 8\n                      type: array\n                      x-kubernetes-list-map-keys:\n                      - type\n                      x-kubernetes-list-type: map\n                    gatewayRef:\n                      description: GatewayRef is a reference to a Gateway object that\n                        is associated with the route.\n                      properties:\n                        controller:\n                          description: \"Controller is a domain/path string that indicates\n                            the controller implementing the Gateway. This corresponds\n                            with the controller field on GatewayClass. \\n Example:\n                            \\\"acme.io/gateway-controller\\\". \\n The format of this\n                            field is DOMAIN \\\"/\\\" PATH, where DOMAIN and PATH are\n                            valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).\"\n                          maxLength: 253\n                          type: string\n                        name:\n                          description: Name is the name of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                        namespace:\n                          description: Namespace is the namespace of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                      required:\n                      - name\n                      - namespace\n                      type: object\n                  required:\n                  - gatewayRef\n                  type: object\n                maxItems: 100\n                type: array\n            required:\n            - gateways\n            type: object\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: udproutes.networking.x-k8s.io\nspec:\n  group: networking.x-k8s.io\n  names:\n    categories:\n    - gateway-api\n    kind: UDPRoute\n    listKind: UDPRouteList\n    plural: udproutes\n    singular: udproute\n  scope: Namespaced\n  versions:\n  - additionalPrinterColumns:\n    - jsonPath: .metadata.creationTimestamp\n      name: Age\n      type: date\n    name: v1alpha1\n    schema:\n      openAPIV3Schema:\n        description: UDPRoute is a resource that specifies how a Gateway should forward\n          UDP traffic.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: Spec defines the desired state of UDPRoute.\n            properties:\n              gateways:\n                default:\n                  allow: SameNamespace\n                description: Gateways defines which Gateways can use this Route.\n                properties:\n                  allow:\n                    default: SameNamespace\n                    description: 'Allow indicates which Gateways will be allowed to\n                      use this route. Possible values are: * All: Gateways in any\n                      namespace can use this route. * FromList: Only Gateways specified\n                      in GatewayRefs may use this route. * SameNamespace: Only Gateways\n                      in the same namespace may use this route.'\n                    enum:\n                    - All\n                    - FromList\n                    - SameNamespace\n                    type: string\n                  gatewayRefs:\n                    description: GatewayRefs must be specified when Allow is set to\n                      \"FromList\". In that case, only Gateways referenced in this list\n                      will be allowed to use this route. This field is ignored for\n                      other values of \"Allow\".\n                    items:\n                      description: GatewayReference identifies a Gateway in a specified\n                        namespace.\n                      properties:\n                        name:\n                          description: Name is the name of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                        namespace:\n                          description: Namespace is the namespace of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                      required:\n                      - name\n                      - namespace\n                      type: object\n                    type: array\n                type: object\n              rules:\n                description: Rules are a list of UDP matchers and actions.\n                items:\n                  description: UDPRouteRule is the configuration for a given rule.\n                  properties:\n                    forwardTo:\n                      description: ForwardTo defines the backend(s) where matching\n                        requests should be sent.\n                      items:\n                        description: RouteForwardTo defines how a Route should forward\n                          a request.\n                        properties:\n                          backendRef:\n                            description: \"BackendRef is a reference to a backend to\n                              forward matched requests to. If both BackendRef and\n                              ServiceName are specified, ServiceName will be given\n                              precedence. \\n If the referent cannot be found, the\n                              rule is not included in the route. The controller should\n                              raise the \\\"ResolvedRefs\\\" condition on the Gateway\n                              with the \\\"DegradedRoutes\\\" reason. The gateway status\n                              for this route should be updated with a condition that\n                              describes the error more specifically. \\n Support: Custom\"\n                            properties:\n                              group:\n                                description: Group is the group of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              kind:\n                                description: Kind is kind of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              name:\n                                description: Name is the name of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                            required:\n                            - group\n                            - kind\n                            - name\n                            type: object\n                          port:\n                            description: \"Port specifies the destination port number\n                              to use for the backend referenced by the ServiceName\n                              or BackendRef field. If unspecified, the destination\n                              port in the request is used when forwarding to a backendRef\n                              or serviceName. \\n Support: Core\"\n                            format: int32\n                            maximum: 65535\n                            minimum: 1\n                            type: integer\n                          serviceName:\n                            description: \"ServiceName refers to the name of the Service\n                              to forward matched requests to. When specified, this\n                              takes the place of BackendRef. If both BackendRef and\n                              ServiceName are specified, ServiceName will be given\n                              precedence. \\n If the referent cannot be found, the\n                              rule is not included in the route. The controller should\n                              raise the \\\"ResolvedRefs\\\" condition on the Gateway\n                              with the \\\"DegradedRoutes\\\" reason. The gateway status\n                              for this route should be updated with a condition that\n                              describes the error more specifically. \\n The protocol\n                              to use is defined using AppProtocol field (introduced\n                              in Kubernetes 1.18) in the Service resource. In the\n                              absence of the AppProtocol field a `networking.x-k8s.io/app-protocol`\n                              annotation on the BackendPolicy resource may be used\n                              to define the protocol. If the AppProtocol field is\n                              available, this annotation should not be used. The AppProtocol\n                              field, when populated, takes precedence over the annotation\n                              in the BackendPolicy resource. For custom backends,\n                              it is encouraged to add a semantically-equivalent field\n                              in the Custom Resource Definition. \\n Support: Core\"\n                            maxLength: 253\n                            type: string\n                          weight:\n                            default: 1\n                            description: \"Weight specifies the proportion of HTTP\n                              requests forwarded to the backend referenced by the\n                              ServiceName or BackendRef field. This is computed as\n                              weight/(sum of all weights in this ForwardTo list).\n                              For non-zero values, there may be some epsilon from\n                              the exact proportion defined here depending on the precision\n                              an implementation supports. Weight is not a percentage\n                              and the sum of weights does not need to equal 100. \\n\n                              If only one backend is specified and it has a weight\n                              greater than 0, 100% of the traffic is forwarded to\n                              that backend. If weight is set to 0, no traffic should\n                              be forwarded for this entry. If unspecified, weight\n                              defaults to 1. \\n Support: Extended\"\n                            format: int32\n                            maximum: 1000000\n                            minimum: 0\n                            type: integer\n                        type: object\n                      maxItems: 16\n                      minItems: 1\n                      type: array\n                    matches:\n                      description: \"Matches define conditions used for matching the\n                        rule against incoming UDP connections. Each match is independent,\n                        i.e. this rule will be matched if **any** one of the matches\n                        is satisfied. If unspecified (i.e. empty), this Rule will\n                        match all requests for the associated Listener. \\n Each client\n                        request MUST map to a maximum of one route rule. If a request\n                        matches multiple rules, matching precedence MUST be determined\n                        in order of the following criteria, continuing on ties: \\n\n                        * The most specific match specified by ExtensionRef. Each\n                        implementation   that supports ExtensionRef may have different\n                        ways of determining the   specificity of the referenced extension.\n                        \\n If ties still exist across multiple Routes, matching precedence\n                        MUST be determined in order of the following criteria, continuing\n                        on ties: \\n * The oldest Route based on creation timestamp.\n                        For example, a Route with   a creation timestamp of \\\"2020-09-08\n                        01:02:03\\\" is given precedence over   a Route with a creation\n                        timestamp of \\\"2020-09-08 01:02:04\\\". * The Route appearing\n                        first in alphabetical order by   \\\"<namespace>/<name>\\\". For\n                        example, foo/bar is given precedence over   foo/baz. \\n If\n                        ties still exist within the Route that has been given precedence,\n                        matching precedence MUST be granted to the first matching\n                        rule meeting the above criteria.\"\n                      items:\n                        description: UDPRouteMatch defines the predicate used to match\n                          packets to a given action.\n                        properties:\n                          extensionRef:\n                            description: \"ExtensionRef is an optional, implementation-specific\n                              extension to the \\\"match\\\" behavior.  For example, resource\n                              \\\"myudproutematcher\\\" in group \\\"networking.acme.io\\\".\n                              If the referent cannot be found, the rule is not included\n                              in the route. The controller should raise the \\\"ResolvedRefs\\\"\n                              condition on the Gateway with the \\\"DegradedRoutes\\\"\n                              reason. The gateway status for this route should be\n                              updated with a condition that describes the error more\n                              specifically. \\n Support: Custom\"\n                            properties:\n                              group:\n                                description: Group is the group of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              kind:\n                                description: Kind is kind of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              name:\n                                description: Name is the name of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                            required:\n                            - group\n                            - kind\n                            - name\n                            type: object\n                        type: object\n                      maxItems: 8\n                      type: array\n                  required:\n                  - forwardTo\n                  type: object\n                maxItems: 16\n                minItems: 1\n                type: array\n            required:\n            - rules\n            type: object\n          status:\n            description: Status defines the current state of UDPRoute.\n            properties:\n              gateways:\n                description: \"Gateways is a list of Gateways that are associated with\n                  the route, and the status of the route with respect to each Gateway.\n                  When a Gateway selects this route, the controller that manages the\n                  Gateway must add an entry to this list when the controller first\n                  sees the route and should update the entry as appropriate when the\n                  route is modified. \\n A maximum of 100 Gateways will be represented\n                  in this list. If this list is full, there may be additional Gateways\n                  using this Route that are not included in the list. An empty list\n                  means the route has not been admitted by any Gateway.\"\n                items:\n                  description: RouteGatewayStatus describes the status of a route\n                    with respect to an associated Gateway.\n                  properties:\n                    conditions:\n                      description: Conditions describes the status of the route with\n                        respect to the Gateway. The \"Admitted\" condition must always\n                        be specified by controllers to indicate whether the route\n                        has been admitted or rejected by the Gateway, and why. Note\n                        that the route's availability is also subject to the Gateway's\n                        own status conditions and listener status.\n                      items:\n                        description: \"Condition contains details for one aspect of\n                          the current state of this API Resource. --- This struct\n                          is intended for direct use as an array at the field path\n                          .status.conditions.  For example, type FooStatus struct{\n                          \\    // Represents the observations of a foo's current state.\n                          \\    // Known .status.conditions.type are: \\\"Available\\\",\n                          \\\"Progressing\\\", and \\\"Degraded\\\"     // +patchMergeKey=type\n                          \\    // +patchStrategy=merge     // +listType=map     //\n                          +listMapKey=type     Conditions []metav1.Condition `json:\\\"conditions,omitempty\\\"\n                          patchStrategy:\\\"merge\\\" patchMergeKey:\\\"type\\\" protobuf:\\\"bytes,1,rep,name=conditions\\\"`\n                          \\n     // other fields }\"\n                        properties:\n                          lastTransitionTime:\n                            description: lastTransitionTime is the last time the condition\n                              transitioned from one status to another. This should\n                              be when the underlying condition changed.  If that is\n                              not known, then using the time when the API field changed\n                              is acceptable.\n                            format: date-time\n                            type: string\n                          message:\n                            description: message is a human readable message indicating\n                              details about the transition. This may be an empty string.\n                            maxLength: 32768\n                            type: string\n                          observedGeneration:\n                            description: observedGeneration represents the .metadata.generation\n                              that the condition was set based upon. For instance,\n                              if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration\n                              is 9, the condition is out of date with respect to the\n                              current state of the instance.\n                            format: int64\n                            minimum: 0\n                            type: integer\n                          reason:\n                            description: reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. The value should\n                              be a CamelCase string. This field may not be empty.\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                              --- Many .condition.type values are consistent across\n                              resources like Available, but because arbitrary conditions\n                              can be useful (see .node.status.conditions), the ability\n                              to deconflict is important. The regex it matches is\n                              (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - lastTransitionTime\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      maxItems: 8\n                      type: array\n                      x-kubernetes-list-map-keys:\n                      - type\n                      x-kubernetes-list-type: map\n                    gatewayRef:\n                      description: GatewayRef is a reference to a Gateway object that\n                        is associated with the route.\n                      properties:\n                        controller:\n                          description: \"Controller is a domain/path string that indicates\n                            the controller implementing the Gateway. This corresponds\n                            with the controller field on GatewayClass. \\n Example:\n                            \\\"acme.io/gateway-controller\\\". \\n The format of this\n                            field is DOMAIN \\\"/\\\" PATH, where DOMAIN and PATH are\n                            valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).\"\n                          maxLength: 253\n                          type: string\n                        name:\n                          description: Name is the name of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                        namespace:\n                          description: Namespace is the namespace of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                      required:\n                      - name\n                      - namespace\n                      type: object\n                  required:\n                  - gatewayRef\n                  type: object\n                maxItems: 100\n                type: array\n            required:\n            - gateways\n            type: object\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n\n---\nkind: GatewayClass\napiVersion: networking.x-k8s.io/v1alpha1\nmetadata:\n  name: example\nspec:\n  controller: projectcontour.io/projectcontour/contour\n\n---\nkind: Gateway\napiVersion: networking.x-k8s.io/v1alpha1\nmetadata:\n  name: contour\n  namespace: projectcontour\nspec:\n  gatewayClassName: example\n  listeners:\n    - protocol: HTTP\n      port: 80\n      routes:\n        kind: HTTPRoute\n        selector:\n          matchLabels:\n            app: kuard\n", "# This file is generated from the individual YAML files by generate-deployment.sh. Do not\n# edit this file directly but instead edit the source files and re-render.\n#\n# Generated from:\n#       examples/contour/00-common.yaml\n#       examples/contour/01-contour-config.yaml\n#       examples/contour/01-crds.yaml\n#       examples/contour/02-job-certgen.yaml\n#       examples/contour/02-rbac.yaml\n#       examples/contour/02-role-contour.yaml\n#       examples/contour/02-service-contour.yaml\n#       examples/contour/02-service-envoy.yaml\n#       examples/contour/03-contour.yaml\n#       examples/contour/03-envoy.yaml\n#\n\n---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: projectcontour\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: contour\n  namespace: projectcontour\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: envoy\n  namespace: projectcontour\n\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: contour\n  namespace: projectcontour\ndata:\n  contour.yaml: |\n    #\n    # server:\n    #   determine which XDS Server implementation to utilize in Contour.\n    #   xds-server-type: contour\n    #\n    # Specify the Gateway API configuration.\n    # gateway:\n    #   controllerName: projectcontour.io/projectcontour/contour\n    #   name: contour\n    #   namespace: projectcontour\n    #\n    # should contour expect to be running inside a k8s cluster\n    # incluster: true\n    #\n    # path to kubeconfig (if not running inside a k8s cluster)\n    # kubeconfig: /path/to/.kube/config\n    #\n    # Disable RFC-compliant behavior to strip \"Content-Length\" header if\n    # \"Tranfer-Encoding: chunked\" is also set.\n    # disableAllowChunkedLength: false\n    # Disable HTTPProxy permitInsecure field\n    disablePermitInsecure: false\n    tls:\n    # minimum TLS version that Contour will negotiate\n    # minimum-protocol-version: \"1.2\"\n    # TLS ciphers to be supported by Envoy TLS listeners when negotiating\n    # TLS 1.2.\n    # cipher-suites:\n    # - '[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]'\n    # - '[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]'\n    # - 'ECDHE-ECDSA-AES256-GCM-SHA384'\n    # - 'ECDHE-RSA-AES256-GCM-SHA384'\n    # Defines the Kubernetes name/namespace matching a secret to use\n    # as the fallback certificate when requests which don't match the\n    # SNI defined for a vhost.\n      fallback-certificate:\n    #   name: fallback-secret-name\n    #   namespace: projectcontour\n      envoy-client-certificate:\n    #   name: envoy-client-cert-secret-name\n    #   namespace: projectcontour\n    # The following config shows the defaults for the leader election.\n    # leaderelection:\n    #   configmap-name: leader-elect\n    #   configmap-namespace: projectcontour\n    ### Logging options\n    # Default setting\n    accesslog-format: envoy\n    # To enable JSON logging in Envoy\n    # accesslog-format: json\n    # The default fields that will be logged are specified below.\n    # To customise this list, just add or remove entries.\n    # The canonical list is available at\n    # https://godoc.org/github.com/projectcontour/contour/internal/envoy#JSONFields\n    # json-fields:\n    #   - \"@timestamp\"\n    #   - \"authority\"\n    #   - \"bytes_received\"\n    #   - \"bytes_sent\"\n    #   - \"downstream_local_address\"\n    #   - \"downstream_remote_address\"\n    #   - \"duration\"\n    #   - \"method\"\n    #   - \"path\"\n    #   - \"protocol\"\n    #   - \"request_id\"\n    #   - \"requested_server_name\"\n    #   - \"response_code\"\n    #   - \"response_flags\"\n    #   - \"uber_trace_id\"\n    #   - \"upstream_cluster\"\n    #   - \"upstream_host\"\n    #   - \"upstream_local_address\"\n    #   - \"upstream_service_time\"\n    #   - \"user_agent\"\n    #   - \"x_forwarded_for\"\n    #\n    # default-http-versions:\n    # - \"HTTP/2\"\n    # - \"HTTP/1.1\"\n    #\n    # The following shows the default proxy timeout settings.\n    # timeouts:\n    #   request-timeout: infinity\n    #   connection-idle-timeout: 60s\n    #   stream-idle-timeout: 5m\n    #   max-connection-duration: infinity\n    #   delayed-close-timeout: 1s\n    #   connection-shutdown-grace-period: 5s\n    #\n    # Envoy cluster settings.\n    # cluster:\n    #   configure the cluster dns lookup family\n    #   valid options are: auto (default), v4, v6\n    #   dns-lookup-family: auto\n    #\n    # Envoy network settings.\n    # network:\n    #   Configure the number of additional ingress proxy hops from the\n    #   right side of the x-forwarded-for HTTP header to trust.\n    #   num-trusted-hops: 0\n    #\n    # Configure an optional global rate limit service.\n    # rateLimitService:\n    #   Identifies the extension service defining the rate limit service,\n    #   formatted as <namespace>/<name>.\n    #   extensionService: projectcontour/ratelimit\n    #   Defines the rate limit domain to pass to the rate limit service.\n    #   Acts as a container for a set of rate limit definitions within\n    #   the RLS.\n    #   domain: contour\n    #   Defines whether to allow requests to proceed when the rate limit\n    #   service fails to respond with a valid rate limit decision within\n    #   the timeout defined on the extension service.\n    #   failOpen: false\n    #   Defines whether to include the X-RateLimit headers X-RateLimit-Limit,\n    #   X-RateLimit-Remaining, and X-RateLimit-Reset (as defined by the IETF\n    #   Internet-Draft linked below), on responses to clients when the Rate\n    #   Limit Service is consulted for a request.\n    #   ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html\n    #   enableXRateLimitHeaders: false\n    #\n    # Global Policy settings.\n    # policy:\n    #   # Default headers to set on all requests (unless set/removed on the HTTPProxy object itself)\n    #   request-headers:\n    #     set:\n    #       # example: the hostname of the Envoy instance that proxied the request\n    #       X-Envoy-Hostname: %HOSTNAME%\n    #       # example: add a l5d-dst-override header to instruct Linkerd what service the request is destined for\n    #       l5d-dst-override: %CONTOUR_SERVICE_NAME%.%CONTOUR_NAMESPACE%.svc.cluster.local:%CONTOUR_SERVICE_PORT%\n    #   # default headers to set on all responses (unless set/removed on the HTTPProxy object itself)\n    #   response-headers:\n    #     set:\n    #       # example: Envoy flags that provide additional details about the response or connection\n    #       X-Envoy-Response-Flags: %RESPONSE_FLAGS%\n    #\n\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: extensionservices.projectcontour.io\nspec:\n  preserveUnknownFields: false\n  group: projectcontour.io\n  names:\n    kind: ExtensionService\n    listKind: ExtensionServiceList\n    plural: extensionservices\n    shortNames:\n    - extensionservice\n    - extensionservices\n    singular: extensionservice\n  scope: Namespaced\n  versions:\n  - name: v1alpha1\n    schema:\n      openAPIV3Schema:\n        description: ExtensionService is the schema for the Contour extension services\n          API. An ExtensionService resource binds a network service to the Contour\n          API so that Contour API features can be implemented by collaborating components.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: ExtensionServiceSpec defines the desired state of an ExtensionService\n              resource.\n            properties:\n              loadBalancerPolicy:\n                description: The policy for load balancing GRPC service requests.\n                  Note that the `Cookie` and `RequestHash` load balancing strategies\n                  cannot be used here.\n                properties:\n                  requestHashPolicies:\n                    description: RequestHashPolicies contains a list of hash policies\n                      to apply when the `RequestHash` load balancing strategy is chosen.\n                      If an element of the supplied list of hash policies is invalid,\n                      it will be ignored. If the list of hash policies is empty after\n                      validation, the load balancing strategy will fall back the the\n                      default `RoundRobin`.\n                    items:\n                      description: RequestHashPolicy contains configuration for an\n                        individual hash policy on a request attribute.\n                      properties:\n                        headerHashOptions:\n                          description: HeaderHashOptions should be set when request\n                            header hash based load balancing is desired. It must be\n                            the only hash option field set, otherwise this request\n                            hash policy object will be ignored.\n                          properties:\n                            headerName:\n                              description: HeaderName is the name of the HTTP request\n                                header that will be used to calculate the hash key.\n                                If the header specified is not present on a request,\n                                no hash will be produced.\n                              minLength: 1\n                              type: string\n                          type: object\n                        terminal:\n                          description: Terminal is a flag that allows for short-circuiting\n                            computing of a hash for a given request. If set to true,\n                            and the request attribute specified in the attribute hash\n                            options is present, no further hash policies will be used\n                            to calculate a hash for the request.\n                          type: boolean\n                      type: object\n                    type: array\n                  strategy:\n                    description: Strategy specifies the policy used to balance requests\n                      across the pool of backend pods. Valid policy names are `Random`,\n                      `RoundRobin`, `WeightedLeastRequest`, `Cookie`, and `RequestHash`.\n                      If an unknown strategy name is specified or no policy is supplied,\n                      the default `RoundRobin` policy is used.\n                    type: string\n                type: object\n              protocol:\n                description: Protocol may be used to specify (or override) the protocol\n                  used to reach this Service. Values may be h2 or h2c. If omitted,\n                  protocol-selection falls back on Service annotations.\n                enum:\n                - h2\n                - h2c\n                type: string\n              protocolVersion:\n                description: This field sets the version of the GRPC protocol that\n                  Envoy uses to send requests to the extension service. Since Contour\n                  always uses the v3 Envoy API, this is currently fixed at \"v3\". However,\n                  other protocol options will be available in future.\n                enum:\n                - v3\n                type: string\n              services:\n                description: Services specifies the set of Kubernetes Service resources\n                  that receive GRPC extension API requests. If no weights are specified\n                  for any of the entries in this array, traffic will be spread evenly\n                  across all the services. Otherwise, traffic is balanced proportionally\n                  to the Weight field in each entry.\n                items:\n                  description: ExtensionServiceTarget defines an Kubernetes Service\n                    to target with extension service traffic.\n                  properties:\n                    name:\n                      description: Name is the name of Kubernetes service that will\n                        accept service traffic.\n                      type: string\n                    port:\n                      description: Port (defined as Integer) to proxy traffic to since\n                        a service can have multiple defined.\n                      exclusiveMaximum: true\n                      maximum: 65536\n                      minimum: 1\n                      type: integer\n                    weight:\n                      description: Weight defines proportion of traffic to balance\n                        to the Kubernetes Service.\n                      format: int32\n                      type: integer\n                  required:\n                  - name\n                  - port\n                  type: object\n                minItems: 1\n                type: array\n              timeoutPolicy:\n                description: The timeout policy for requests to the services.\n                properties:\n                  idle:\n                    description: Timeout after which, if there are no active requests\n                      for this route, the connection between Envoy and the backend\n                      or Envoy and the external client will be closed. If not specified,\n                      there is no per-route idle timeout, though a connection manager-wide\n                      stream_idle_timeout default of 5m still applies.\n                    pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                    type: string\n                  response:\n                    description: Timeout for receiving a response from the server\n                      after processing a request from client. If not supplied, Envoy's\n                      default value of 15s applies.\n                    pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                    type: string\n                type: object\n              validation:\n                description: UpstreamValidation defines how to verify the backend\n                  service's certificate\n                properties:\n                  caSecret:\n                    description: Name of the Kubernetes secret be used to validate\n                      the certificate presented by the backend\n                    type: string\n                  subjectName:\n                    description: Key which is expected to be present in the 'subjectAltName'\n                      of the presented certificate\n                    type: string\n                required:\n                - caSecret\n                - subjectName\n                type: object\n            required:\n            - services\n            type: object\n          status:\n            description: ExtensionServiceStatus defines the observed state of an ExtensionService\n              resource.\n            properties:\n              conditions:\n                description: \"Conditions contains the current status of the ExtensionService\n                  resource. \\n Contour will update a single condition, `Valid`, that\n                  is in normal-true polarity. \\n Contour will not modify any other\n                  Conditions set in this block, in case some other controller wants\n                  to add a Condition.\"\n                items:\n                  description: \"DetailedCondition is an extension of the normal Kubernetes\n                    conditions, with two extra fields to hold sub-conditions, which\n                    provide more detailed reasons for the state (True or False) of\n                    the condition. \\n `errors` holds information about sub-conditions\n                    which are fatal to that condition and render its state False.\n                    \\n `warnings` holds information about sub-conditions which are\n                    not fatal to that condition and do not force the state to be False.\n                    \\n Remember that Conditions have a type, a status, and a reason.\n                    \\n The type is the type of the condition, the most important one\n                    in this CRD set is `Valid`. `Valid` is a positive-polarity condition:\n                    when it is `status: true` there are no problems. \\n In more detail,\n                    `status: true` means that the object is has been ingested into\n                    Contour with no errors. `warnings` may still be present, and will\n                    be indicated in the Reason field. There must be zero entries in\n                    the `errors` slice in this case. \\n `Valid`, `status: false` means\n                    that the object has had one or more fatal errors during processing\n                    into Contour.  The details of the errors will be present under\n                    the `errors` field. There must be at least one error in the `errors`\n                    slice if `status` is `false`. \\n For DetailedConditions of types\n                    other than `Valid`, the Condition must be in the negative polarity.\n                    When they have `status` `true`, there is an error. There must\n                    be at least one entry in the `errors` Subcondition slice. When\n                    they have `status` `false`, there are no serious errors, and there\n                    must be zero entries in the `errors` slice. In either case, there\n                    may be entries in the `warnings` slice. \\n Regardless of the polarity,\n                    the `reason` and `message` fields must be updated with either\n                    the detail of the reason (if there is one and only one entry in\n                    total across both the `errors` and `warnings` slices), or `MultipleReasons`\n                    if there is more than one entry.\"\n                  properties:\n                    errors:\n                      description: \"Errors contains a slice of relevant error subconditions\n                        for this object. \\n Subconditions are expected to appear when\n                        relevant (when there is a error), and disappear when not relevant.\n                        An empty slice here indicates no errors.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                    lastTransitionTime:\n                      description: lastTransitionTime is the last time the condition\n                        transitioned from one status to another. This should be when\n                        the underlying condition changed.  If that is not known, then\n                        using the time when the API field changed is acceptable.\n                      format: date-time\n                      type: string\n                    message:\n                      description: message is a human readable message indicating\n                        details about the transition. This may be an empty string.\n                      maxLength: 32768\n                      type: string\n                    observedGeneration:\n                      description: observedGeneration represents the .metadata.generation\n                        that the condition was set based upon. For instance, if .metadata.generation\n                        is currently 12, but the .status.conditions[x].observedGeneration\n                        is 9, the condition is out of date with respect to the current\n                        state of the instance.\n                      format: int64\n                      minimum: 0\n                      type: integer\n                    reason:\n                      description: reason contains a programmatic identifier indicating\n                        the reason for the condition's last transition. Producers\n                        of specific condition types may define expected values and\n                        meanings for this field, and whether the values are considered\n                        a guaranteed API. The value should be a CamelCase string.\n                        This field may not be empty.\n                      maxLength: 1024\n                      minLength: 1\n                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                      type: string\n                    status:\n                      description: status of the condition, one of True, False, Unknown.\n                      enum:\n                      - \"True\"\n                      - \"False\"\n                      - Unknown\n                      type: string\n                    type:\n                      description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                        --- Many .condition.type values are consistent across resources\n                        like Available, but because arbitrary conditions can be useful\n                        (see .node.status.conditions), the ability to deconflict is\n                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                      maxLength: 316\n                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                      type: string\n                    warnings:\n                      description: \"Warnings contains a slice of relevant warning\n                        subconditions for this object. \\n Subconditions are expected\n                        to appear when relevant (when there is a warning), and disappear\n                        when not relevant. An empty slice here indicates no warnings.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                  required:\n                  - lastTransitionTime\n                  - message\n                  - reason\n                  - status\n                  - type\n                  type: object\n                type: array\n                x-kubernetes-list-map-keys:\n                - type\n                x-kubernetes-list-type: map\n            type: object\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: httpproxies.projectcontour.io\nspec:\n  preserveUnknownFields: false\n  group: projectcontour.io\n  names:\n    kind: HTTPProxy\n    listKind: HTTPProxyList\n    plural: httpproxies\n    shortNames:\n    - proxy\n    - proxies\n    singular: httpproxy\n  scope: Namespaced\n  versions:\n  - additionalPrinterColumns:\n    - description: Fully qualified domain name\n      jsonPath: .spec.virtualhost.fqdn\n      name: FQDN\n      type: string\n    - description: Secret with TLS credentials\n      jsonPath: .spec.virtualhost.tls.secretName\n      name: TLS Secret\n      type: string\n    - description: The current status of the HTTPProxy\n      jsonPath: .status.currentStatus\n      name: Status\n      type: string\n    - description: Description of the current status\n      jsonPath: .status.description\n      name: Status Description\n      type: string\n    name: v1\n    schema:\n      openAPIV3Schema:\n        description: HTTPProxy is an Ingress CRD specification.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: HTTPProxySpec defines the spec of the CRD.\n            properties:\n              includes:\n                description: Includes allow for specific routing configuration to\n                  be included from another HTTPProxy, possibly in another namespace.\n                items:\n                  description: Include describes a set of policies that can be applied\n                    to an HTTPProxy in a namespace.\n                  properties:\n                    conditions:\n                      description: 'Conditions are a set of rules that are applied\n                        to included HTTPProxies. In effect, they are added onto the\n                        Conditions of included HTTPProxy Route structs. When applied,\n                        they are merged using AND, with one exception: There can be\n                        only one Prefix MatchCondition per Conditions slice. More\n                        than one Prefix, or contradictory Conditions, will make the\n                        include invalid.'\n                      items:\n                        description: MatchCondition are a general holder for matching\n                          rules for HTTPProxies. One of Prefix or Header must be provided.\n                        properties:\n                          header:\n                            description: Header specifies the header condition to\n                              match.\n                            properties:\n                              contains:\n                                description: Contains specifies a substring that must\n                                  be present in the header value.\n                                type: string\n                              exact:\n                                description: Exact specifies a string that the header\n                                  value must be equal to.\n                                type: string\n                              name:\n                                description: Name is the name of the header to match\n                                  against. Name is required. Header names are case\n                                  insensitive.\n                                type: string\n                              notcontains:\n                                description: NotContains specifies a substring that\n                                  must not be present in the header value.\n                                type: string\n                              notexact:\n                                description: NoExact specifies a string that the header\n                                  value must not be equal to. The condition is true\n                                  if the header has any other value.\n                                type: string\n                              notpresent:\n                                description: NotPresent specifies that condition is\n                                  true when the named header is not present. Note\n                                  that setting NotPresent to false does not make the\n                                  condition true if the named header is present.\n                                type: boolean\n                              present:\n                                description: Present specifies that condition is true\n                                  when the named header is present, regardless of\n                                  its value. Note that setting Present to false does\n                                  not make the condition true if the named header\n                                  is absent.\n                                type: boolean\n                            required:\n                            - name\n                            type: object\n                          prefix:\n                            description: Prefix defines a prefix match for a request.\n                            type: string\n                        type: object\n                      type: array\n                    name:\n                      description: Name of the HTTPProxy\n                      type: string\n                    namespace:\n                      description: Namespace of the HTTPProxy to include. Defaults\n                        to the current namespace if not supplied.\n                      type: string\n                  required:\n                  - name\n                  type: object\n                type: array\n              routes:\n                description: Routes are the ingress routes. If TCPProxy is present,\n                  Routes is ignored.\n                items:\n                  description: Route contains the set of routes for a virtual host.\n                  properties:\n                    authPolicy:\n                      description: AuthPolicy updates the authorization policy that\n                        was set on the root HTTPProxy object for client requests that\n                        match this route.\n                      properties:\n                        context:\n                          additionalProperties:\n                            type: string\n                          description: Context is a set of key/value pairs that are\n                            sent to the authentication server in the check request.\n                            If a context is provided at an enclosing scope, the entries\n                            are merged such that the inner scope overrides matching\n                            keys from the outer scope.\n                          type: object\n                        disabled:\n                          description: When true, this field disables client request\n                            authentication for the scope of the policy.\n                          type: boolean\n                      type: object\n                    conditions:\n                      description: 'Conditions are a set of rules that are applied\n                        to a Route. When applied, they are merged using AND, with\n                        one exception: There can be only one Prefix MatchCondition\n                        per Conditions slice. More than one Prefix, or contradictory\n                        Conditions, will make the route invalid.'\n                      items:\n                        description: MatchCondition are a general holder for matching\n                          rules for HTTPProxies. One of Prefix or Header must be provided.\n                        properties:\n                          header:\n                            description: Header specifies the header condition to\n                              match.\n                            properties:\n                              contains:\n                                description: Contains specifies a substring that must\n                                  be present in the header value.\n                                type: string\n                              exact:\n                                description: Exact specifies a string that the header\n                                  value must be equal to.\n                                type: string\n                              name:\n                                description: Name is the name of the header to match\n                                  against. Name is required. Header names are case\n                                  insensitive.\n                                type: string\n                              notcontains:\n                                description: NotContains specifies a substring that\n                                  must not be present in the header value.\n                                type: string\n                              notexact:\n                                description: NoExact specifies a string that the header\n                                  value must not be equal to. The condition is true\n                                  if the header has any other value.\n                                type: string\n                              notpresent:\n                                description: NotPresent specifies that condition is\n                                  true when the named header is not present. Note\n                                  that setting NotPresent to false does not make the\n                                  condition true if the named header is present.\n                                type: boolean\n                              present:\n                                description: Present specifies that condition is true\n                                  when the named header is present, regardless of\n                                  its value. Note that setting Present to false does\n                                  not make the condition true if the named header\n                                  is absent.\n                                type: boolean\n                            required:\n                            - name\n                            type: object\n                          prefix:\n                            description: Prefix defines a prefix match for a request.\n                            type: string\n                        type: object\n                      type: array\n                    enableWebsockets:\n                      description: Enables websocket support for the route.\n                      type: boolean\n                    healthCheckPolicy:\n                      description: The health check policy for this route.\n                      properties:\n                        healthyThresholdCount:\n                          description: The number of healthy health checks required\n                            before a host is marked healthy\n                          format: int64\n                          minimum: 0\n                          type: integer\n                        host:\n                          description: The value of the host header in the HTTP health\n                            check request. If left empty (default value), the name\n                            \"contour-envoy-healthcheck\" will be used.\n                          type: string\n                        intervalSeconds:\n                          description: The interval (seconds) between health checks\n                          format: int64\n                          type: integer\n                        path:\n                          description: HTTP endpoint used to perform health checks\n                            on upstream service\n                          type: string\n                        timeoutSeconds:\n                          description: The time to wait (seconds) for a health check\n                            response\n                          format: int64\n                          type: integer\n                        unhealthyThresholdCount:\n                          description: The number of unhealthy health checks required\n                            before a host is marked unhealthy\n                          format: int64\n                          minimum: 0\n                          type: integer\n                      required:\n                      - path\n                      type: object\n                    loadBalancerPolicy:\n                      description: The load balancing policy for this route.\n                      properties:\n                        requestHashPolicies:\n                          description: RequestHashPolicies contains a list of hash\n                            policies to apply when the `RequestHash` load balancing\n                            strategy is chosen. If an element of the supplied list\n                            of hash policies is invalid, it will be ignored. If the\n                            list of hash policies is empty after validation, the load\n                            balancing strategy will fall back the the default `RoundRobin`.\n                          items:\n                            description: RequestHashPolicy contains configuration\n                              for an individual hash policy on a request attribute.\n                            properties:\n                              headerHashOptions:\n                                description: HeaderHashOptions should be set when\n                                  request header hash based load balancing is desired.\n                                  It must be the only hash option field set, otherwise\n                                  this request hash policy object will be ignored.\n                                properties:\n                                  headerName:\n                                    description: HeaderName is the name of the HTTP\n                                      request header that will be used to calculate\n                                      the hash key. If the header specified is not\n                                      present on a request, no hash will be produced.\n                                    minLength: 1\n                                    type: string\n                                type: object\n                              terminal:\n                                description: Terminal is a flag that allows for short-circuiting\n                                  computing of a hash for a given request. If set\n                                  to true, and the request attribute specified in\n                                  the attribute hash options is present, no further\n                                  hash policies will be used to calculate a hash for\n                                  the request.\n                                type: boolean\n                            type: object\n                          type: array\n                        strategy:\n                          description: Strategy specifies the policy used to balance\n                            requests across the pool of backend pods. Valid policy\n                            names are `Random`, `RoundRobin`, `WeightedLeastRequest`,\n                            `Cookie`, and `RequestHash`. If an unknown strategy name\n                            is specified or no policy is supplied, the default `RoundRobin`\n                            policy is used.\n                          type: string\n                      type: object\n                    pathRewritePolicy:\n                      description: The policy for rewriting the path of the request\n                        URL after the request has been routed to a Service.\n                      properties:\n                        replacePrefix:\n                          description: ReplacePrefix describes how the path prefix\n                            should be replaced.\n                          items:\n                            description: ReplacePrefix describes a path prefix replacement.\n                            properties:\n                              prefix:\n                                description: \"Prefix specifies the URL path prefix\n                                  to be replaced. \\n If Prefix is specified, it must\n                                  exactly match the MatchCondition prefix that is\n                                  rendered by the chain of including HTTPProxies and\n                                  only that path prefix will be replaced by Replacement.\n                                  This allows HTTPProxies that are included through\n                                  multiple roots to only replace specific path prefixes,\n                                  leaving others unmodified. \\n If Prefix is not specified,\n                                  all routing prefixes rendered by the include chain\n                                  will be replaced.\"\n                                minLength: 1\n                                type: string\n                              replacement:\n                                description: Replacement is the string that the routing\n                                  path prefix will be replaced with. This must not\n                                  be empty.\n                                minLength: 1\n                                type: string\n                            required:\n                            - replacement\n                            type: object\n                          type: array\n                      type: object\n                    permitInsecure:\n                      description: Allow this path to respond to insecure requests\n                        over HTTP which are normally not permitted when a `virtualhost.tls`\n                        block is present.\n                      type: boolean\n                    rateLimitPolicy:\n                      description: The policy for rate limiting on the route.\n                      properties:\n                        global:\n                          description: Global defines global rate limiting parameters,\n                            i.e. parameters defining descriptors that are sent to\n                            an external rate limit service (RLS) for a rate limit\n                            decision on each request.\n                          properties:\n                            descriptors:\n                              description: Descriptors defines the list of descriptors\n                                that will be generated and sent to the rate limit\n                                service. Each descriptor contains 1+ key-value pair\n                                entries.\n                              items:\n                                description: RateLimitDescriptor defines a list of\n                                  key-value pair generators.\n                                properties:\n                                  entries:\n                                    description: Entries is the list of key-value\n                                      pair generators.\n                                    items:\n                                      description: RateLimitDescriptorEntry is a key-value\n                                        pair generator. Exactly one field on this\n                                        struct must be non-nil.\n                                      properties:\n                                        genericKey:\n                                          description: GenericKey defines a descriptor\n                                            entry with a static key and value.\n                                          properties:\n                                            key:\n                                              description: Key defines the key of\n                                                the descriptor entry. If not set,\n                                                the key is set to \"generic_key\".\n                                              type: string\n                                            value:\n                                              description: Value defines the value\n                                                of the descriptor entry.\n                                              minLength: 1\n                                              type: string\n                                          type: object\n                                        remoteAddress:\n                                          description: RemoteAddress defines a descriptor\n                                            entry with a key of \"remote_address\" and\n                                            a value equal to the client's IP address\n                                            (from x-forwarded-for).\n                                          type: object\n                                        requestHeader:\n                                          description: RequestHeader defines a descriptor\n                                            entry that's populated only if a given\n                                            header is present on the request. The\n                                            descriptor key is static, and the descriptor\n                                            value is equal to the value of the header.\n                                          properties:\n                                            descriptorKey:\n                                              description: DescriptorKey defines the\n                                                key to use on the descriptor entry.\n                                              minLength: 1\n                                              type: string\n                                            headerName:\n                                              description: HeaderName defines the\n                                                name of the header to look for on\n                                                the request.\n                                              minLength: 1\n                                              type: string\n                                          type: object\n                                        requestHeaderValueMatch:\n                                          description: RequestHeaderValueMatch defines\n                                            a descriptor entry that's populated if\n                                            the request's headers match a set of 1+\n                                            match criteria. The descriptor key is\n                                            \"header_match\", and the descriptor value\n                                            is static.\n                                          properties:\n                                            expectMatch:\n                                              default: true\n                                              description: ExpectMatch defines whether\n                                                the request must positively match\n                                                the match criteria in order to generate\n                                                a descriptor entry (i.e. true), or\n                                                not match the match criteria in order\n                                                to generate a descriptor entry (i.e.\n                                                false). The default is true.\n                                              type: boolean\n                                            headers:\n                                              description: Headers is a list of 1+\n                                                match criteria to apply against the\n                                                request to determine whether to populate\n                                                the descriptor entry or not.\n                                              items:\n                                                description: HeaderMatchCondition\n                                                  specifies how to conditionally match\n                                                  against HTTP headers. The Name field\n                                                  is required, but only one of the\n                                                  remaining fields should be be provided.\n                                                properties:\n                                                  contains:\n                                                    description: Contains specifies\n                                                      a substring that must be present\n                                                      in the header value.\n                                                    type: string\n                                                  exact:\n                                                    description: Exact specifies a\n                                                      string that the header value\n                                                      must be equal to.\n                                                    type: string\n                                                  name:\n                                                    description: Name is the name\n                                                      of the header to match against.\n                                                      Name is required. Header names\n                                                      are case insensitive.\n                                                    type: string\n                                                  notcontains:\n                                                    description: NotContains specifies\n                                                      a substring that must not be\n                                                      present in the header value.\n                                                    type: string\n                                                  notexact:\n                                                    description: NoExact specifies\n                                                      a string that the header value\n                                                      must not be equal to. The condition\n                                                      is true if the header has any\n                                                      other value.\n                                                    type: string\n                                                  notpresent:\n                                                    description: NotPresent specifies\n                                                      that condition is true when\n                                                      the named header is not present.\n                                                      Note that setting NotPresent\n                                                      to false does not make the condition\n                                                      true if the named header is\n                                                      present.\n                                                    type: boolean\n                                                  present:\n                                                    description: Present specifies\n                                                      that condition is true when\n                                                      the named header is present,\n                                                      regardless of its value. Note\n                                                      that setting Present to false\n                                                      does not make the condition\n                                                      true if the named header is\n                                                      absent.\n                                                    type: boolean\n                                                required:\n                                                - name\n                                                type: object\n                                              minItems: 1\n                                              type: array\n                                            value:\n                                              description: Value defines the value\n                                                of the descriptor entry.\n                                              minLength: 1\n                                              type: string\n                                          type: object\n                                      type: object\n                                    minItems: 1\n                                    type: array\n                                type: object\n                              minItems: 1\n                              type: array\n                          type: object\n                        local:\n                          description: Local defines local rate limiting parameters,\n                            i.e. parameters for rate limiting that occurs within each\n                            Envoy pod as requests are handled.\n                          properties:\n                            burst:\n                              description: Burst defines the number of requests above\n                                the requests per unit that should be allowed within\n                                a short period of time.\n                              format: int32\n                              type: integer\n                            requests:\n                              description: Requests defines how many requests per\n                                unit of time should be allowed before rate limiting\n                                occurs.\n                              format: int32\n                              minimum: 1\n                              type: integer\n                            responseHeadersToAdd:\n                              description: ResponseHeadersToAdd is an optional list\n                                of response headers to set when a request is rate-limited.\n                              items:\n                                description: HeaderValue represents a header name/value\n                                  pair\n                                properties:\n                                  name:\n                                    description: Name represents a key of a header\n                                    minLength: 1\n                                    type: string\n                                  value:\n                                    description: Value represents the value of a header\n                                      specified by a key\n                                    minLength: 1\n                                    type: string\n                                required:\n                                - name\n                                - value\n                                type: object\n                              type: array\n                            responseStatusCode:\n                              description: ResponseStatusCode is the HTTP status code\n                                to use for responses to rate-limited requests. Codes\n                                must be in the 400-599 range (inclusive). If not specified,\n                                the Envoy default of 429 (Too Many Requests) is used.\n                              format: int32\n                              maximum: 599\n                              minimum: 400\n                              type: integer\n                            unit:\n                              description: Unit defines the period of time within\n                                which requests over the limit will be rate limited.\n                                Valid values are \"second\", \"minute\" and \"hour\".\n                              enum:\n                              - second\n                              - minute\n                              - hour\n                              type: string\n                          required:\n                          - requests\n                          - unit\n                          type: object\n                      type: object\n                    requestHeadersPolicy:\n                      description: The policy for managing request headers during\n                        proxying.\n                      properties:\n                        remove:\n                          description: Remove specifies a list of HTTP header names\n                            to remove.\n                          items:\n                            type: string\n                          type: array\n                        set:\n                          description: Set specifies a list of HTTP header values\n                            that will be set in the HTTP header. If the header does\n                            not exist it will be added, otherwise it will be overwritten\n                            with the new value.\n                          items:\n                            description: HeaderValue represents a header name/value\n                              pair\n                            properties:\n                              name:\n                                description: Name represents a key of a header\n                                minLength: 1\n                                type: string\n                              value:\n                                description: Value represents the value of a header\n                                  specified by a key\n                                minLength: 1\n                                type: string\n                            required:\n                            - name\n                            - value\n                            type: object\n                          type: array\n                      type: object\n                    responseHeadersPolicy:\n                      description: The policy for managing response headers during\n                        proxying. Rewriting the 'Host' header is not supported.\n                      properties:\n                        remove:\n                          description: Remove specifies a list of HTTP header names\n                            to remove.\n                          items:\n                            type: string\n                          type: array\n                        set:\n                          description: Set specifies a list of HTTP header values\n                            that will be set in the HTTP header. If the header does\n                            not exist it will be added, otherwise it will be overwritten\n                            with the new value.\n                          items:\n                            description: HeaderValue represents a header name/value\n                              pair\n                            properties:\n                              name:\n                                description: Name represents a key of a header\n                                minLength: 1\n                                type: string\n                              value:\n                                description: Value represents the value of a header\n                                  specified by a key\n                                minLength: 1\n                                type: string\n                            required:\n                            - name\n                            - value\n                            type: object\n                          type: array\n                      type: object\n                    retryPolicy:\n                      description: The retry policy for this route.\n                      properties:\n                        count:\n                          description: NumRetries is maximum allowed number of retries.\n                            If not supplied, the number of retries is one.\n                          format: int64\n                          minimum: 0\n                          type: integer\n                        perTryTimeout:\n                          description: PerTryTimeout specifies the timeout per retry\n                            attempt. Ignored if NumRetries is not supplied.\n                          pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                          type: string\n                        retriableStatusCodes:\n                          description: \"RetriableStatusCodes specifies the HTTP status\n                            codes that should be retried. \\n This field is only respected\n                            when you include `retriable-status-codes` in the `RetryOn`\n                            field.\"\n                          items:\n                            format: int32\n                            type: integer\n                          type: array\n                        retryOn:\n                          description: \"RetryOn specifies the conditions on which\n                            to retry a request. \\n Supported [HTTP conditions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on):\n                            \\n - `5xx` - `gateway-error` - `reset` - `connect-failure`\n                            - `retriable-4xx` - `refused-stream` - `retriable-status-codes`\n                            - `retriable-headers` \\n Supported [gRPC conditions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-grpc-on):\n                            \\n - `cancelled` - `deadline-exceeded` - `internal` -\n                            `resource-exhausted` - `unavailable`\"\n                          items:\n                            description: RetryOn is a string type alias with validation\n                              to ensure that the value is valid.\n                            enum:\n                            - 5xx\n                            - gateway-error\n                            - reset\n                            - connect-failure\n                            - retriable-4xx\n                            - refused-stream\n                            - retriable-status-codes\n                            - retriable-headers\n                            - cancelled\n                            - deadline-exceeded\n                            - internal\n                            - resource-exhausted\n                            - unavailable\n                            type: string\n                          type: array\n                      type: object\n                    services:\n                      description: Services are the services to proxy traffic.\n                      items:\n                        description: Service defines an Kubernetes Service to proxy\n                          traffic.\n                        properties:\n                          mirror:\n                            description: If Mirror is true the Service will receive\n                              a read only mirror of the traffic for this route.\n                            type: boolean\n                          name:\n                            description: Name is the name of Kubernetes service to\n                              proxy traffic. Names defined here will be used to look\n                              up corresponding endpoints which contain the ips to\n                              route.\n                            type: string\n                          port:\n                            description: Port (defined as Integer) to proxy traffic\n                              to since a service can have multiple defined.\n                            exclusiveMaximum: true\n                            maximum: 65536\n                            minimum: 1\n                            type: integer\n                          protocol:\n                            description: Protocol may be used to specify (or override)\n                              the protocol used to reach this Service. Values may\n                              be tls, h2, h2c. If omitted, protocol-selection falls\n                              back on Service annotations.\n                            enum:\n                            - h2\n                            - h2c\n                            - tls\n                            type: string\n                          requestHeadersPolicy:\n                            description: The policy for managing request headers during\n                              proxying. Rewriting the 'Host' header is not supported.\n                            properties:\n                              remove:\n                                description: Remove specifies a list of HTTP header\n                                  names to remove.\n                                items:\n                                  type: string\n                                type: array\n                              set:\n                                description: Set specifies a list of HTTP header values\n                                  that will be set in the HTTP header. If the header\n                                  does not exist it will be added, otherwise it will\n                                  be overwritten with the new value.\n                                items:\n                                  description: HeaderValue represents a header name/value\n                                    pair\n                                  properties:\n                                    name:\n                                      description: Name represents a key of a header\n                                      minLength: 1\n                                      type: string\n                                    value:\n                                      description: Value represents the value of a\n                                        header specified by a key\n                                      minLength: 1\n                                      type: string\n                                  required:\n                                  - name\n                                  - value\n                                  type: object\n                                type: array\n                            type: object\n                          responseHeadersPolicy:\n                            description: The policy for managing response headers\n                              during proxying. Rewriting the 'Host' header is not\n                              supported.\n                            properties:\n                              remove:\n                                description: Remove specifies a list of HTTP header\n                                  names to remove.\n                                items:\n                                  type: string\n                                type: array\n                              set:\n                                description: Set specifies a list of HTTP header values\n                                  that will be set in the HTTP header. If the header\n                                  does not exist it will be added, otherwise it will\n                                  be overwritten with the new value.\n                                items:\n                                  description: HeaderValue represents a header name/value\n                                    pair\n                                  properties:\n                                    name:\n                                      description: Name represents a key of a header\n                                      minLength: 1\n                                      type: string\n                                    value:\n                                      description: Value represents the value of a\n                                        header specified by a key\n                                      minLength: 1\n                                      type: string\n                                  required:\n                                  - name\n                                  - value\n                                  type: object\n                                type: array\n                            type: object\n                          validation:\n                            description: UpstreamValidation defines how to verify\n                              the backend service's certificate\n                            properties:\n                              caSecret:\n                                description: Name of the Kubernetes secret be used\n                                  to validate the certificate presented by the backend\n                                type: string\n                              subjectName:\n                                description: Key which is expected to be present in\n                                  the 'subjectAltName' of the presented certificate\n                                type: string\n                            required:\n                            - caSecret\n                            - subjectName\n                            type: object\n                          weight:\n                            description: Weight defines percentage of traffic to balance\n                              traffic\n                            format: int64\n                            minimum: 0\n                            type: integer\n                        required:\n                        - name\n                        - port\n                        type: object\n                      minItems: 1\n                      type: array\n                    timeoutPolicy:\n                      description: The timeout policy for this route.\n                      properties:\n                        idle:\n                          description: Timeout after which, if there are no active\n                            requests for this route, the connection between Envoy\n                            and the backend or Envoy and the external client will\n                            be closed. If not specified, there is no per-route idle\n                            timeout, though a connection manager-wide stream_idle_timeout\n                            default of 5m still applies.\n                          pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                          type: string\n                        response:\n                          description: Timeout for receiving a response from the server\n                            after processing a request from client. If not supplied,\n                            Envoy's default value of 15s applies.\n                          pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                          type: string\n                      type: object\n                  required:\n                  - services\n                  type: object\n                type: array\n              tcpproxy:\n                description: TCPProxy holds TCP proxy information.\n                properties:\n                  healthCheckPolicy:\n                    description: The health check policy for this tcp proxy\n                    properties:\n                      healthyThresholdCount:\n                        description: The number of healthy health checks required\n                          before a host is marked healthy\n                        format: int32\n                        type: integer\n                      intervalSeconds:\n                        description: The interval (seconds) between health checks\n                        format: int64\n                        type: integer\n                      timeoutSeconds:\n                        description: The time to wait (seconds) for a health check\n                          response\n                        format: int64\n                        type: integer\n                      unhealthyThresholdCount:\n                        description: The number of unhealthy health checks required\n                          before a host is marked unhealthy\n                        format: int32\n                        type: integer\n                    type: object\n                  include:\n                    description: Include specifies that this tcpproxy should be delegated\n                      to another HTTPProxy.\n                    properties:\n                      name:\n                        description: Name of the child HTTPProxy\n                        type: string\n                      namespace:\n                        description: Namespace of the HTTPProxy to include. Defaults\n                          to the current namespace if not supplied.\n                        type: string\n                    required:\n                    - name\n                    type: object\n                  includes:\n                    description: \"IncludesDeprecated allow for specific routing configuration\n                      to be appended to another HTTPProxy in another namespace. \\n\n                      Exists due to a mistake when developing HTTPProxy and the field\n                      was marked plural when it should have been singular. This field\n                      should stay to not break backwards compatibility to v1 users.\"\n                    properties:\n                      name:\n                        description: Name of the child HTTPProxy\n                        type: string\n                      namespace:\n                        description: Namespace of the HTTPProxy to include. Defaults\n                          to the current namespace if not supplied.\n                        type: string\n                    required:\n                    - name\n                    type: object\n                  loadBalancerPolicy:\n                    description: The load balancing policy for the backend services.\n                      Note that the `Cookie` and `RequestHash` load balancing strategies\n                      cannot be used here.\n                    properties:\n                      requestHashPolicies:\n                        description: RequestHashPolicies contains a list of hash policies\n                          to apply when the `RequestHash` load balancing strategy\n                          is chosen. If an element of the supplied list of hash policies\n                          is invalid, it will be ignored. If the list of hash policies\n                          is empty after validation, the load balancing strategy will\n                          fall back the the default `RoundRobin`.\n                        items:\n                          description: RequestHashPolicy contains configuration for\n                            an individual hash policy on a request attribute.\n                          properties:\n                            headerHashOptions:\n                              description: HeaderHashOptions should be set when request\n                                header hash based load balancing is desired. It must\n                                be the only hash option field set, otherwise this\n                                request hash policy object will be ignored.\n                              properties:\n                                headerName:\n                                  description: HeaderName is the name of the HTTP\n                                    request header that will be used to calculate\n                                    the hash key. If the header specified is not present\n                                    on a request, no hash will be produced.\n                                  minLength: 1\n                                  type: string\n                              type: object\n                            terminal:\n                              description: Terminal is a flag that allows for short-circuiting\n                                computing of a hash for a given request. If set to\n                                true, and the request attribute specified in the attribute\n                                hash options is present, no further hash policies\n                                will be used to calculate a hash for the request.\n                              type: boolean\n                          type: object\n                        type: array\n                      strategy:\n                        description: Strategy specifies the policy used to balance\n                          requests across the pool of backend pods. Valid policy names\n                          are `Random`, `RoundRobin`, `WeightedLeastRequest`, `Cookie`,\n                          and `RequestHash`. If an unknown strategy name is specified\n                          or no policy is supplied, the default `RoundRobin` policy\n                          is used.\n                        type: string\n                    type: object\n                  services:\n                    description: Services are the services to proxy traffic\n                    items:\n                      description: Service defines an Kubernetes Service to proxy\n                        traffic.\n                      properties:\n                        mirror:\n                          description: If Mirror is true the Service will receive\n                            a read only mirror of the traffic for this route.\n                          type: boolean\n                        name:\n                          description: Name is the name of Kubernetes service to proxy\n                            traffic. Names defined here will be used to look up corresponding\n                            endpoints which contain the ips to route.\n                          type: string\n                        port:\n                          description: Port (defined as Integer) to proxy traffic\n                            to since a service can have multiple defined.\n                          exclusiveMaximum: true\n                          maximum: 65536\n                          minimum: 1\n                          type: integer\n                        protocol:\n                          description: Protocol may be used to specify (or override)\n                            the protocol used to reach this Service. Values may be\n                            tls, h2, h2c. If omitted, protocol-selection falls back\n                            on Service annotations.\n                          enum:\n                          - h2\n                          - h2c\n                          - tls\n                          type: string\n                        requestHeadersPolicy:\n                          description: The policy for managing request headers during\n                            proxying. Rewriting the 'Host' header is not supported.\n                          properties:\n                            remove:\n                              description: Remove specifies a list of HTTP header\n                                names to remove.\n                              items:\n                                type: string\n                              type: array\n                            set:\n                              description: Set specifies a list of HTTP header values\n                                that will be set in the HTTP header. If the header\n                                does not exist it will be added, otherwise it will\n                                be overwritten with the new value.\n                              items:\n                                description: HeaderValue represents a header name/value\n                                  pair\n                                properties:\n                                  name:\n                                    description: Name represents a key of a header\n                                    minLength: 1\n                                    type: string\n                                  value:\n                                    description: Value represents the value of a header\n                                      specified by a key\n                                    minLength: 1\n                                    type: string\n                                required:\n                                - name\n                                - value\n                                type: object\n                              type: array\n                          type: object\n                        responseHeadersPolicy:\n                          description: The policy for managing response headers during\n                            proxying. Rewriting the 'Host' header is not supported.\n                          properties:\n                            remove:\n                              description: Remove specifies a list of HTTP header\n                                names to remove.\n                              items:\n                                type: string\n                              type: array\n                            set:\n                              description: Set specifies a list of HTTP header values\n                                that will be set in the HTTP header. If the header\n                                does not exist it will be added, otherwise it will\n                                be overwritten with the new value.\n                              items:\n                                description: HeaderValue represents a header name/value\n                                  pair\n                                properties:\n                                  name:\n                                    description: Name represents a key of a header\n                                    minLength: 1\n                                    type: string\n                                  value:\n                                    description: Value represents the value of a header\n                                      specified by a key\n                                    minLength: 1\n                                    type: string\n                                required:\n                                - name\n                                - value\n                                type: object\n                              type: array\n                          type: object\n                        validation:\n                          description: UpstreamValidation defines how to verify the\n                            backend service's certificate\n                          properties:\n                            caSecret:\n                              description: Name of the Kubernetes secret be used to\n                                validate the certificate presented by the backend\n                              type: string\n                            subjectName:\n                              description: Key which is expected to be present in\n                                the 'subjectAltName' of the presented certificate\n                              type: string\n                          required:\n                          - caSecret\n                          - subjectName\n                          type: object\n                        weight:\n                          description: Weight defines percentage of traffic to balance\n                            traffic\n                          format: int64\n                          minimum: 0\n                          type: integer\n                      required:\n                      - name\n                      - port\n                      type: object\n                    type: array\n                type: object\n              virtualhost:\n                description: Virtualhost appears at most once. If it is present, the\n                  object is considered to be a \"root\" HTTPProxy.\n                properties:\n                  authorization:\n                    description: This field configures an extension service to perform\n                      authorization for this virtual host. Authorization can only\n                      be configured on virtual hosts that have TLS enabled. If the\n                      TLS configuration requires client certificate validation, the\n                      client certificate is always included in the authentication\n                      check request.\n                    properties:\n                      authPolicy:\n                        description: AuthPolicy sets a default authorization policy\n                          for client requests. This policy will be used unless overridden\n                          by individual routes.\n                        properties:\n                          context:\n                            additionalProperties:\n                              type: string\n                            description: Context is a set of key/value pairs that\n                              are sent to the authentication server in the check request.\n                              If a context is provided at an enclosing scope, the\n                              entries are merged such that the inner scope overrides\n                              matching keys from the outer scope.\n                            type: object\n                          disabled:\n                            description: When true, this field disables client request\n                              authentication for the scope of the policy.\n                            type: boolean\n                        type: object\n                      extensionRef:\n                        description: ExtensionServiceRef specifies the extension resource\n                          that will authorize client requests.\n                        properties:\n                          apiVersion:\n                            description: API version of the referent. If this field\n                              is not specified, the default \"projectcontour.io/v1alpha1\"\n                              will be used\n                            minLength: 1\n                            type: string\n                          name:\n                            description: \"Name of the referent. \\n More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\"\n                            minLength: 1\n                            type: string\n                          namespace:\n                            description: \"Namespace of the referent. If this field\n                              is not specifies, the namespace of the resource that\n                              targets the referent will be used. \\n More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/\"\n                            minLength: 1\n                            type: string\n                        type: object\n                      failOpen:\n                        description: If FailOpen is true, the client request is forwarded\n                          to the upstream service even if the authorization server\n                          fails to respond. This field should not be set in most cases.\n                          It is intended for use only while migrating applications\n                          from internal authorization to Contour external authorization.\n                        type: boolean\n                      responseTimeout:\n                        description: ResponseTimeout configures maximum time to wait\n                          for a check response from the authorization server. Timeout\n                          durations are expressed in the Go [Duration format](https://godoc.org/time#ParseDuration).\n                          Valid time units are \"ns\", \"us\" (or \"\u00b5s\"), \"ms\", \"s\", \"m\",\n                          \"h\". The string \"infinity\" is also a valid input and specifies\n                          no timeout.\n                        pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                        type: string\n                    required:\n                    - extensionRef\n                    type: object\n                  corsPolicy:\n                    description: Specifies the cross-origin policy to apply to the\n                      VirtualHost.\n                    properties:\n                      allowCredentials:\n                        description: Specifies whether the resource allows credentials.\n                        type: boolean\n                      allowHeaders:\n                        description: AllowHeaders specifies the content for the *access-control-allow-headers*\n                          header.\n                        items:\n                          description: CORSHeaderValue specifies the value of the\n                            string headers returned by a cross-domain request.\n                          pattern: ^[a-zA-Z0-9!#$%&'*+.^_`|~-]+$\n                          type: string\n                        type: array\n                      allowMethods:\n                        description: AllowMethods specifies the content for the *access-control-allow-methods*\n                          header.\n                        items:\n                          description: CORSHeaderValue specifies the value of the\n                            string headers returned by a cross-domain request.\n                          pattern: ^[a-zA-Z0-9!#$%&'*+.^_`|~-]+$\n                          type: string\n                        type: array\n                      allowOrigin:\n                        description: AllowOrigin specifies the origins that will be\n                          allowed to do CORS requests. \"*\" means allow any origin.\n                        items:\n                          type: string\n                        type: array\n                      exposeHeaders:\n                        description: ExposeHeaders Specifies the content for the *access-control-expose-headers*\n                          header.\n                        items:\n                          description: CORSHeaderValue specifies the value of the\n                            string headers returned by a cross-domain request.\n                          pattern: ^[a-zA-Z0-9!#$%&'*+.^_`|~-]+$\n                          type: string\n                        type: array\n                      maxAge:\n                        description: MaxAge indicates for how long the results of\n                          a preflight request can be cached. MaxAge durations are\n                          expressed in the Go [Duration format](https://godoc.org/time#ParseDuration).\n                          Valid time units are \"ns\", \"us\" (or \"\u00b5s\"), \"ms\", \"s\", \"m\",\n                          \"h\". Only positive values are allowed while 0 disables the\n                          cache requiring a preflight OPTIONS check for all cross-origin\n                          requests.\n                        type: string\n                    required:\n                    - allowMethods\n                    - allowOrigin\n                    type: object\n                  fqdn:\n                    description: The fully qualified domain name of the root of the\n                      ingress tree all leaves of the DAG rooted at this object relate\n                      to the fqdn.\n                    type: string\n                  rateLimitPolicy:\n                    description: The policy for rate limiting on the virtual host.\n                    properties:\n                      global:\n                        description: Global defines global rate limiting parameters,\n                          i.e. parameters defining descriptors that are sent to an\n                          external rate limit service (RLS) for a rate limit decision\n                          on each request.\n                        properties:\n                          descriptors:\n                            description: Descriptors defines the list of descriptors\n                              that will be generated and sent to the rate limit service.\n                              Each descriptor contains 1+ key-value pair entries.\n                            items:\n                              description: RateLimitDescriptor defines a list of key-value\n                                pair generators.\n                              properties:\n                                entries:\n                                  description: Entries is the list of key-value pair\n                                    generators.\n                                  items:\n                                    description: RateLimitDescriptorEntry is a key-value\n                                      pair generator. Exactly one field on this struct\n                                      must be non-nil.\n                                    properties:\n                                      genericKey:\n                                        description: GenericKey defines a descriptor\n                                          entry with a static key and value.\n                                        properties:\n                                          key:\n                                            description: Key defines the key of the\n                                              descriptor entry. If not set, the key\n                                              is set to \"generic_key\".\n                                            type: string\n                                          value:\n                                            description: Value defines the value of\n                                              the descriptor entry.\n                                            minLength: 1\n                                            type: string\n                                        type: object\n                                      remoteAddress:\n                                        description: RemoteAddress defines a descriptor\n                                          entry with a key of \"remote_address\" and\n                                          a value equal to the client's IP address\n                                          (from x-forwarded-for).\n                                        type: object\n                                      requestHeader:\n                                        description: RequestHeader defines a descriptor\n                                          entry that's populated only if a given header\n                                          is present on the request. The descriptor\n                                          key is static, and the descriptor value\n                                          is equal to the value of the header.\n                                        properties:\n                                          descriptorKey:\n                                            description: DescriptorKey defines the\n                                              key to use on the descriptor entry.\n                                            minLength: 1\n                                            type: string\n                                          headerName:\n                                            description: HeaderName defines the name\n                                              of the header to look for on the request.\n                                            minLength: 1\n                                            type: string\n                                        type: object\n                                      requestHeaderValueMatch:\n                                        description: RequestHeaderValueMatch defines\n                                          a descriptor entry that's populated if the\n                                          request's headers match a set of 1+ match\n                                          criteria. The descriptor key is \"header_match\",\n                                          and the descriptor value is static.\n                                        properties:\n                                          expectMatch:\n                                            default: true\n                                            description: ExpectMatch defines whether\n                                              the request must positively match the\n                                              match criteria in order to generate\n                                              a descriptor entry (i.e. true), or not\n                                              match the match criteria in order to\n                                              generate a descriptor entry (i.e. false).\n                                              The default is true.\n                                            type: boolean\n                                          headers:\n                                            description: Headers is a list of 1+ match\n                                              criteria to apply against the request\n                                              to determine whether to populate the\n                                              descriptor entry or not.\n                                            items:\n                                              description: HeaderMatchCondition specifies\n                                                how to conditionally match against\n                                                HTTP headers. The Name field is required,\n                                                but only one of the remaining fields\n                                                should be be provided.\n                                              properties:\n                                                contains:\n                                                  description: Contains specifies\n                                                    a substring that must be present\n                                                    in the header value.\n                                                  type: string\n                                                exact:\n                                                  description: Exact specifies a string\n                                                    that the header value must be\n                                                    equal to.\n                                                  type: string\n                                                name:\n                                                  description: Name is the name of\n                                                    the header to match against. Name\n                                                    is required. Header names are\n                                                    case insensitive.\n                                                  type: string\n                                                notcontains:\n                                                  description: NotContains specifies\n                                                    a substring that must not be present\n                                                    in the header value.\n                                                  type: string\n                                                notexact:\n                                                  description: NoExact specifies a\n                                                    string that the header value must\n                                                    not be equal to. The condition\n                                                    is true if the header has any\n                                                    other value.\n                                                  type: string\n                                                notpresent:\n                                                  description: NotPresent specifies\n                                                    that condition is true when the\n                                                    named header is not present. Note\n                                                    that setting NotPresent to false\n                                                    does not make the condition true\n                                                    if the named header is present.\n                                                  type: boolean\n                                                present:\n                                                  description: Present specifies that\n                                                    condition is true when the named\n                                                    header is present, regardless\n                                                    of its value. Note that setting\n                                                    Present to false does not make\n                                                    the condition true if the named\n                                                    header is absent.\n                                                  type: boolean\n                                              required:\n                                              - name\n                                              type: object\n                                            minItems: 1\n                                            type: array\n                                          value:\n                                            description: Value defines the value of\n                                              the descriptor entry.\n                                            minLength: 1\n                                            type: string\n                                        type: object\n                                    type: object\n                                  minItems: 1\n                                  type: array\n                              type: object\n                            minItems: 1\n                            type: array\n                        type: object\n                      local:\n                        description: Local defines local rate limiting parameters,\n                          i.e. parameters for rate limiting that occurs within each\n                          Envoy pod as requests are handled.\n                        properties:\n                          burst:\n                            description: Burst defines the number of requests above\n                              the requests per unit that should be allowed within\n                              a short period of time.\n                            format: int32\n                            type: integer\n                          requests:\n                            description: Requests defines how many requests per unit\n                              of time should be allowed before rate limiting occurs.\n                            format: int32\n                            minimum: 1\n                            type: integer\n                          responseHeadersToAdd:\n                            description: ResponseHeadersToAdd is an optional list\n                              of response headers to set when a request is rate-limited.\n                            items:\n                              description: HeaderValue represents a header name/value\n                                pair\n                              properties:\n                                name:\n                                  description: Name represents a key of a header\n                                  minLength: 1\n                                  type: string\n                                value:\n                                  description: Value represents the value of a header\n                                    specified by a key\n                                  minLength: 1\n                                  type: string\n                              required:\n                              - name\n                              - value\n                              type: object\n                            type: array\n                          responseStatusCode:\n                            description: ResponseStatusCode is the HTTP status code\n                              to use for responses to rate-limited requests. Codes\n                              must be in the 400-599 range (inclusive). If not specified,\n                              the Envoy default of 429 (Too Many Requests) is used.\n                            format: int32\n                            maximum: 599\n                            minimum: 400\n                            type: integer\n                          unit:\n                            description: Unit defines the period of time within which\n                              requests over the limit will be rate limited. Valid\n                              values are \"second\", \"minute\" and \"hour\".\n                            enum:\n                            - second\n                            - minute\n                            - hour\n                            type: string\n                        required:\n                        - requests\n                        - unit\n                        type: object\n                    type: object\n                  tls:\n                    description: If present the fields describes TLS properties of\n                      the virtual host. The SNI names that will be matched on are\n                      described in fqdn, the tls.secretName secret must contain a\n                      certificate that itself contains a name that matches the FQDN.\n                    properties:\n                      clientValidation:\n                        description: \"ClientValidation defines how to verify the client\n                          certificate when an external client establishes a TLS connection\n                          to Envoy. \\n This setting: \\n 1. Enables TLS client certificate\n                          validation. 2. Specifies how the client certificate will\n                          be validated (i.e.    validation required or skipped). \\n\n                          Note: Setting client certificate validation to be skipped\n                          should be only used in conjunction with an external authorization\n                          server that performs client validation as Contour will ensure\n                          client certificates are passed along.\"\n                        properties:\n                          caSecret:\n                            description: Name of a Kubernetes secret that contains\n                              a CA certificate bundle. The client certificate must\n                              validate against the certificates in the bundle. If\n                              specified and SkipClientCertValidation is true, client\n                              certificates will be required on requests.\n                            minLength: 1\n                            type: string\n                          skipClientCertValidation:\n                            description: SkipClientCertValidation disables downstream\n                              client certificate validation. Defaults to false. This\n                              field is intended to be used in conjunction with external\n                              authorization in order to enable the external authorization\n                              server to validate client certificates. When this field\n                              is set to true, client certificates are requested but\n                              not verified by Envoy. If CACertificate is specified,\n                              client certificates are required on requests, but not\n                              verified. If external authorization is in use, they\n                              are presented to the external authorization server.\n                            type: boolean\n                        type: object\n                      enableFallbackCertificate:\n                        description: EnableFallbackCertificate defines if the vhost\n                          should allow a default certificate to be applied which handles\n                          all requests which don't match the SNI defined in this vhost.\n                        type: boolean\n                      minimumProtocolVersion:\n                        description: MinimumProtocolVersion is the minimum TLS version\n                          this vhost should negotiate. Valid options are `1.2` (default)\n                          and `1.3`. Any other value defaults to TLS 1.2.\n                        type: string\n                      passthrough:\n                        description: Passthrough defines whether the encrypted TLS\n                          handshake will be passed through to the backing cluster.\n                          Either Passthrough or SecretName must be specified, but\n                          not both.\n                        type: boolean\n                      secretName:\n                        description: SecretName is the name of a TLS secret in the\n                          current namespace. Either SecretName or Passthrough must\n                          be specified, but not both. If specified, the named secret\n                          must contain a matching certificate for the virtual host's\n                          FQDN.\n                        type: string\n                    type: object\n                required:\n                - fqdn\n                type: object\n            type: object\n          status:\n            description: Status is a container for computed information about the\n              HTTPProxy.\n            properties:\n              conditions:\n                description: \"Conditions contains information about the current status\n                  of the HTTPProxy, in an upstream-friendly container. \\n Contour\n                  will update a single condition, `Valid`, that is in normal-true\n                  polarity. That is, when `currentStatus` is `valid`, the `Valid`\n                  condition will be `status: true`, and vice versa. \\n Contour will\n                  leave untouched any other Conditions set in this block, in case\n                  some other controller wants to add a Condition. \\n If you are another\n                  controller owner and wish to add a condition, you *should* namespace\n                  your condition with a label, like `controller.domain.com/ConditionName`.\"\n                items:\n                  description: \"DetailedCondition is an extension of the normal Kubernetes\n                    conditions, with two extra fields to hold sub-conditions, which\n                    provide more detailed reasons for the state (True or False) of\n                    the condition. \\n `errors` holds information about sub-conditions\n                    which are fatal to that condition and render its state False.\n                    \\n `warnings` holds information about sub-conditions which are\n                    not fatal to that condition and do not force the state to be False.\n                    \\n Remember that Conditions have a type, a status, and a reason.\n                    \\n The type is the type of the condition, the most important one\n                    in this CRD set is `Valid`. `Valid` is a positive-polarity condition:\n                    when it is `status: true` there are no problems. \\n In more detail,\n                    `status: true` means that the object is has been ingested into\n                    Contour with no errors. `warnings` may still be present, and will\n                    be indicated in the Reason field. There must be zero entries in\n                    the `errors` slice in this case. \\n `Valid`, `status: false` means\n                    that the object has had one or more fatal errors during processing\n                    into Contour.  The details of the errors will be present under\n                    the `errors` field. There must be at least one error in the `errors`\n                    slice if `status` is `false`. \\n For DetailedConditions of types\n                    other than `Valid`, the Condition must be in the negative polarity.\n                    When they have `status` `true`, there is an error. There must\n                    be at least one entry in the `errors` Subcondition slice. When\n                    they have `status` `false`, there are no serious errors, and there\n                    must be zero entries in the `errors` slice. In either case, there\n                    may be entries in the `warnings` slice. \\n Regardless of the polarity,\n                    the `reason` and `message` fields must be updated with either\n                    the detail of the reason (if there is one and only one entry in\n                    total across both the `errors` and `warnings` slices), or `MultipleReasons`\n                    if there is more than one entry.\"\n                  properties:\n                    errors:\n                      description: \"Errors contains a slice of relevant error subconditions\n                        for this object. \\n Subconditions are expected to appear when\n                        relevant (when there is a error), and disappear when not relevant.\n                        An empty slice here indicates no errors.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                    lastTransitionTime:\n                      description: lastTransitionTime is the last time the condition\n                        transitioned from one status to another. This should be when\n                        the underlying condition changed.  If that is not known, then\n                        using the time when the API field changed is acceptable.\n                      format: date-time\n                      type: string\n                    message:\n                      description: message is a human readable message indicating\n                        details about the transition. This may be an empty string.\n                      maxLength: 32768\n                      type: string\n                    observedGeneration:\n                      description: observedGeneration represents the .metadata.generation\n                        that the condition was set based upon. For instance, if .metadata.generation\n                        is currently 12, but the .status.conditions[x].observedGeneration\n                        is 9, the condition is out of date with respect to the current\n                        state of the instance.\n                      format: int64\n                      minimum: 0\n                      type: integer\n                    reason:\n                      description: reason contains a programmatic identifier indicating\n                        the reason for the condition's last transition. Producers\n                        of specific condition types may define expected values and\n                        meanings for this field, and whether the values are considered\n                        a guaranteed API. The value should be a CamelCase string.\n                        This field may not be empty.\n                      maxLength: 1024\n                      minLength: 1\n                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                      type: string\n                    status:\n                      description: status of the condition, one of True, False, Unknown.\n                      enum:\n                      - \"True\"\n                      - \"False\"\n                      - Unknown\n                      type: string\n                    type:\n                      description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                        --- Many .condition.type values are consistent across resources\n                        like Available, but because arbitrary conditions can be useful\n                        (see .node.status.conditions), the ability to deconflict is\n                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                      maxLength: 316\n                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                      type: string\n                    warnings:\n                      description: \"Warnings contains a slice of relevant warning\n                        subconditions for this object. \\n Subconditions are expected\n                        to appear when relevant (when there is a warning), and disappear\n                        when not relevant. An empty slice here indicates no warnings.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                  required:\n                  - lastTransitionTime\n                  - message\n                  - reason\n                  - status\n                  - type\n                  type: object\n                type: array\n                x-kubernetes-list-map-keys:\n                - type\n                x-kubernetes-list-type: map\n              currentStatus:\n                type: string\n              description:\n                type: string\n              loadBalancer:\n                description: LoadBalancer contains the current status of the load\n                  balancer.\n                properties:\n                  ingress:\n                    description: Ingress is a list containing ingress points for the\n                      load-balancer. Traffic intended for the service should be sent\n                      to these ingress points.\n                    items:\n                      description: 'LoadBalancerIngress represents the status of a\n                        load-balancer ingress point: traffic intended for the service\n                        should be sent to an ingress point.'\n                      properties:\n                        hostname:\n                          description: Hostname is set for load-balancer ingress points\n                            that are DNS based (typically AWS load-balancers)\n                          type: string\n                        ip:\n                          description: IP is set for load-balancer ingress points\n                            that are IP based (typically GCE or OpenStack load-balancers)\n                          type: string\n                        ports:\n                          description: Ports is a list of records of service ports\n                            If used, every port defined in the service should have\n                            an entry in it\n                          items:\n                            properties:\n                              error:\n                                description: 'Error is to record the problem with\n                                  the service port The format of the error shall comply\n                                  with the following rules: - built-in error values\n                                  shall be specified in this file and those shall\n                                  use   CamelCase names - cloud provider specific\n                                  error values must have names that comply with the   format\n                                  foo.example.com/CamelCase. --- The regex it matches\n                                  is (dns1123SubdomainFmt/)?(qualifiedNameFmt)'\n                                maxLength: 316\n                                pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                                type: string\n                              port:\n                                description: Port is the port number of the service\n                                  port of which status is recorded here\n                                format: int32\n                                type: integer\n                              protocol:\n                                default: TCP\n                                description: 'Protocol is the protocol of the service\n                                  port of which status is recorded here The supported\n                                  values are: \"TCP\", \"UDP\", \"SCTP\"'\n                                type: string\n                            required:\n                            - port\n                            - protocol\n                            type: object\n                          type: array\n                          x-kubernetes-list-type: atomic\n                      type: object\n                    type: array\n                type: object\n            type: object\n        required:\n        - metadata\n        - spec\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: tlscertificatedelegations.projectcontour.io\nspec:\n  preserveUnknownFields: false\n  group: projectcontour.io\n  names:\n    kind: TLSCertificateDelegation\n    listKind: TLSCertificateDelegationList\n    plural: tlscertificatedelegations\n    shortNames:\n    - tlscerts\n    singular: tlscertificatedelegation\n  scope: Namespaced\n  versions:\n  - name: v1\n    schema:\n      openAPIV3Schema:\n        description: TLSCertificateDelegation is an TLS Certificate Delegation CRD\n          specification. See design/tls-certificate-delegation.md for details.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: TLSCertificateDelegationSpec defines the spec of the CRD\n            properties:\n              delegations:\n                items:\n                  description: CertificateDelegation maps the authority to reference\n                    a secret in the current namespace to a set of namespaces.\n                  properties:\n                    secretName:\n                      description: required, the name of a secret in the current namespace.\n                      type: string\n                    targetNamespaces:\n                      description: required, the namespaces the authority to reference\n                        the the secret will be delegated to. If TargetNamespaces is\n                        nil or empty, the CertificateDelegation' is ignored. If the\n                        TargetNamespace list contains the character, \"*\" the secret\n                        will be delegated to all namespaces.\n                      items:\n                        type: string\n                      type: array\n                  required:\n                  - secretName\n                  - targetNamespaces\n                  type: object\n                type: array\n            required:\n            - delegations\n            type: object\n          status:\n            description: TLSCertificateDelegationStatus allows for the status of the\n              delegation to be presented to the user.\n            properties:\n              conditions:\n                description: \"Conditions contains information about the current status\n                  of the HTTPProxy, in an upstream-friendly container. \\n Contour\n                  will update a single condition, `Valid`, that is in normal-true\n                  polarity. That is, when `currentStatus` is `valid`, the `Valid`\n                  condition will be `status: true`, and vice versa. \\n Contour will\n                  leave untouched any other Conditions set in this block, in case\n                  some other controller wants to add a Condition. \\n If you are another\n                  controller owner and wish to add a condition, you *should* namespace\n                  your condition with a label, like `controller.domain.com\\\\ConditionName`.\"\n                items:\n                  description: \"DetailedCondition is an extension of the normal Kubernetes\n                    conditions, with two extra fields to hold sub-conditions, which\n                    provide more detailed reasons for the state (True or False) of\n                    the condition. \\n `errors` holds information about sub-conditions\n                    which are fatal to that condition and render its state False.\n                    \\n `warnings` holds information about sub-conditions which are\n                    not fatal to that condition and do not force the state to be False.\n                    \\n Remember that Conditions have a type, a status, and a reason.\n                    \\n The type is the type of the condition, the most important one\n                    in this CRD set is `Valid`. `Valid` is a positive-polarity condition:\n                    when it is `status: true` there are no problems. \\n In more detail,\n                    `status: true` means that the object is has been ingested into\n                    Contour with no errors. `warnings` may still be present, and will\n                    be indicated in the Reason field. There must be zero entries in\n                    the `errors` slice in this case. \\n `Valid`, `status: false` means\n                    that the object has had one or more fatal errors during processing\n                    into Contour.  The details of the errors will be present under\n                    the `errors` field. There must be at least one error in the `errors`\n                    slice if `status` is `false`. \\n For DetailedConditions of types\n                    other than `Valid`, the Condition must be in the negative polarity.\n                    When they have `status` `true`, there is an error. There must\n                    be at least one entry in the `errors` Subcondition slice. When\n                    they have `status` `false`, there are no serious errors, and there\n                    must be zero entries in the `errors` slice. In either case, there\n                    may be entries in the `warnings` slice. \\n Regardless of the polarity,\n                    the `reason` and `message` fields must be updated with either\n                    the detail of the reason (if there is one and only one entry in\n                    total across both the `errors` and `warnings` slices), or `MultipleReasons`\n                    if there is more than one entry.\"\n                  properties:\n                    errors:\n                      description: \"Errors contains a slice of relevant error subconditions\n                        for this object. \\n Subconditions are expected to appear when\n                        relevant (when there is a error), and disappear when not relevant.\n                        An empty slice here indicates no errors.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                    lastTransitionTime:\n                      description: lastTransitionTime is the last time the condition\n                        transitioned from one status to another. This should be when\n                        the underlying condition changed.  If that is not known, then\n                        using the time when the API field changed is acceptable.\n                      format: date-time\n                      type: string\n                    message:\n                      description: message is a human readable message indicating\n                        details about the transition. This may be an empty string.\n                      maxLength: 32768\n                      type: string\n                    observedGeneration:\n                      description: observedGeneration represents the .metadata.generation\n                        that the condition was set based upon. For instance, if .metadata.generation\n                        is currently 12, but the .status.conditions[x].observedGeneration\n                        is 9, the condition is out of date with respect to the current\n                        state of the instance.\n                      format: int64\n                      minimum: 0\n                      type: integer\n                    reason:\n                      description: reason contains a programmatic identifier indicating\n                        the reason for the condition's last transition. Producers\n                        of specific condition types may define expected values and\n                        meanings for this field, and whether the values are considered\n                        a guaranteed API. The value should be a CamelCase string.\n                        This field may not be empty.\n                      maxLength: 1024\n                      minLength: 1\n                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                      type: string\n                    status:\n                      description: status of the condition, one of True, False, Unknown.\n                      enum:\n                      - \"True\"\n                      - \"False\"\n                      - Unknown\n                      type: string\n                    type:\n                      description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                        --- Many .condition.type values are consistent across resources\n                        like Available, but because arbitrary conditions can be useful\n                        (see .node.status.conditions), the ability to deconflict is\n                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                      maxLength: 316\n                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                      type: string\n                    warnings:\n                      description: \"Warnings contains a slice of relevant warning\n                        subconditions for this object. \\n Subconditions are expected\n                        to appear when relevant (when there is a warning), and disappear\n                        when not relevant. An empty slice here indicates no warnings.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                  required:\n                  - lastTransitionTime\n                  - message\n                  - reason\n                  - status\n                  - type\n                  type: object\n                type: array\n                x-kubernetes-list-map-keys:\n                - type\n                x-kubernetes-list-type: map\n            type: object\n        required:\n        - metadata\n        - spec\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: contour-certgen\n  namespace: projectcontour\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: contour\n  namespace: projectcontour\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: contour-certgen\nsubjects:\n- kind: ServiceAccount\n  name: contour-certgen\n  namespace: projectcontour\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: contour-certgen\n  namespace: projectcontour\nrules:\n- apiGroups:\n  - \"\"\n  resources:\n  - secrets\n  verbs:\n  - create\n  - update\n---\napiVersion: batch/v1\nkind: Job\nmetadata:\n  name: contour-certgen-v1.17.0\n  namespace: projectcontour\nspec:\n  ttlSecondsAfterFinished: 0\n  template:\n    metadata:\n      labels:\n        app: \"contour-certgen\"\n    spec:\n      containers:\n      - name: contour\n        image: docker.io/projectcontour/contour:v1.17.0\n        imagePullPolicy: Always\n        command:\n        - contour\n        - certgen\n        - --kube\n        - --incluster\n        - --overwrite\n        - --secrets-format=compact\n        - --namespace=$(CONTOUR_NAMESPACE)\n        env:\n        - name: CONTOUR_NAMESPACE\n          valueFrom:\n            fieldRef:\n              fieldPath: metadata.namespace\n      restartPolicy: Never\n      serviceAccountName: contour-certgen\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 65534\n        runAsGroup: 65534\n  parallelism: 1\n  completions: 1\n  backoffLimit: 1\n\n---\n\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: contour\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: contour\nsubjects:\n- kind: ServiceAccount\n  name: contour\n  namespace: projectcontour\n\n# The following ClusterRole is generated from kubebuilder RBAC tags by\n# generate-rbac.sh. Do not edit this file directly but instead edit the source\n# files and re-render.\n\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  creationTimestamp: null\n  name: contour\nrules:\n- apiGroups:\n  - \"\"\n  resources:\n  - configmaps\n  verbs:\n  - create\n  - get\n  - update\n- apiGroups:\n  - \"\"\n  resources:\n  - endpoints\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - namespaces\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - secrets\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - services\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - apiextensions.k8s.io\n  resources:\n  - customresourcedefinitions\n  verbs:\n  - list\n- apiGroups:\n  - networking.k8s.io\n  resources:\n  - ingressclasses\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - networking.k8s.io\n  resources:\n  - ingresses\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - networking.k8s.io\n  resources:\n  - ingresses/status\n  verbs:\n  - create\n  - get\n  - update\n- apiGroups:\n  - networking.x-k8s.io\n  resources:\n  - backendpolicies\n  - gatewayclasses\n  - gateways\n  - httproutes\n  - tcproutes\n  - tlsroutes\n  - udproutes\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - networking.x-k8s.io\n  resources:\n  - backendpolicies/status\n  - gatewayclasses/status\n  - gateways/status\n  - httproutes/status\n  - tcproutes/status\n  - tlsroutes/status\n  - udproutes/status\n  verbs:\n  - update\n- apiGroups:\n  - projectcontour.io\n  resources:\n  - extensionservices\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - projectcontour.io\n  resources:\n  - extensionservices/status\n  verbs:\n  - create\n  - get\n  - update\n- apiGroups:\n  - projectcontour.io\n  resources:\n  - httpproxies\n  - tlscertificatedelegations\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - projectcontour.io\n  resources:\n  - httpproxies/status\n  verbs:\n  - create\n  - get\n  - update\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: contour\n  namespace: projectcontour\nspec:\n  ports:\n  - port: 8001\n    name: xds\n    protocol: TCP\n    targetPort: 8001\n  selector:\n    app: contour\n  type: ClusterIP\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: envoy\n  namespace: projectcontour\n  annotations:\n    # This annotation puts the AWS ELB into \"TCP\" mode so that it does not\n    # do HTTP negotiation for HTTPS connections at the ELB edge.\n    # The downside of this is the remote IP address of all connections will\n    # appear to be the internal address of the ELB. See docs/proxy-proto.md\n    # for information about enabling the PROXY protocol on the ELB to recover\n    # the original remote IP address.\n    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcp\nspec:\n  externalTrafficPolicy: Local\n  ports:\n  - port: 80\n    name: http\n    protocol: TCP\n    targetPort: 8080\n  - port: 443\n    name: https\n    protocol: TCP\n    targetPort: 8443\n  selector:\n    app: envoy\n  type: LoadBalancer\n\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: contour\n  name: contour\n  namespace: projectcontour\nspec:\n  replicas: 2\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      # This value of maxSurge means that during a rolling update\n      # the new ReplicaSet will be created first.\n      maxSurge: 50%\n  selector:\n    matchLabels:\n      app: contour\n  template:\n    metadata:\n      annotations:\n        prometheus.io/scrape: \"true\"\n        prometheus.io/port: \"8000\"\n      labels:\n        app: contour\n    spec:\n      affinity:\n        podAntiAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n          - podAffinityTerm:\n              labelSelector:\n                matchLabels:\n                  app: contour\n              topologyKey: kubernetes.io/hostname\n            weight: 100\n      containers:\n      - args:\n        - serve\n        - --incluster\n        - --xds-address=0.0.0.0\n        - --xds-port=8001\n        - --contour-cafile=/certs/ca.crt\n        - --contour-cert-file=/certs/tls.crt\n        - --contour-key-file=/certs/tls.key\n        - --config-path=/config/contour.yaml\n        command: [\"contour\"]\n        image: docker.io/projectcontour/contour:v1.17.0\n        imagePullPolicy: IfNotPresent\n        name: contour\n        ports:\n        - containerPort: 8001\n          name: xds\n          protocol: TCP\n        - containerPort: 8000\n          name: metrics\n          protocol: TCP\n        - containerPort: 6060\n          name: debug\n          protocol: TCP\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 8000\n        readinessProbe:\n          tcpSocket:\n            port: 8001\n          initialDelaySeconds: 15\n          periodSeconds: 10\n        volumeMounts:\n          - name: contourcert\n            mountPath: /certs\n            readOnly: true\n          - name: contour-config\n            mountPath: /config\n            readOnly: true\n        env:\n        - name: CONTOUR_NAMESPACE\n          valueFrom:\n            fieldRef:\n              apiVersion: v1\n              fieldPath: metadata.namespace\n        - name: POD_NAME\n          valueFrom:\n            fieldRef:\n              apiVersion: v1\n              fieldPath: metadata.name\n      dnsPolicy: ClusterFirst\n      serviceAccountName: contour\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 65534\n        runAsGroup: 65534\n      volumes:\n        - name: contourcert\n          secret:\n            secretName: contourcert\n        - name: contour-config\n          configMap:\n            name: contour\n            defaultMode: 0644\n            items:\n            - key: contour.yaml\n              path: contour.yaml\n\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  labels:\n    app: envoy\n  name: envoy\n  namespace: projectcontour\nspec:\n  updateStrategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 10%\n  selector:\n    matchLabels:\n      app: envoy\n  template:\n    metadata:\n      annotations:\n        prometheus.io/scrape: \"true\"\n        prometheus.io/port: \"8002\"\n        prometheus.io/path: \"/stats/prometheus\"\n      labels:\n        app: envoy\n    spec:\n      containers:\n      - command:\n        - /bin/contour\n        args:\n          - envoy\n          - shutdown-manager\n        image: docker.io/projectcontour/contour:v1.17.0\n        imagePullPolicy: IfNotPresent\n        lifecycle:\n          preStop:\n            exec:\n              command:\n                - /bin/contour\n                - envoy\n                - shutdown\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 8090\n          initialDelaySeconds: 3\n          periodSeconds: 10\n        name: shutdown-manager\n      - args:\n        - -c\n        - /config/envoy.json\n        - --service-cluster $(CONTOUR_NAMESPACE)\n        - --service-node $(ENVOY_POD_NAME)\n        - --log-level info\n        command:\n        - envoy\n        image: docker.io/envoyproxy/envoy:v1.18.3\n        imagePullPolicy: IfNotPresent\n        name: envoy\n        env:\n        - name: CONTOUR_NAMESPACE\n          valueFrom:\n            fieldRef:\n              apiVersion: v1\n              fieldPath: metadata.namespace\n        - name: ENVOY_POD_NAME\n          valueFrom:\n            fieldRef:\n              apiVersion: v1\n              fieldPath: metadata.name\n        ports:\n        - containerPort: 8080\n          hostPort: 80\n          name: http\n          protocol: TCP\n        - containerPort: 8443\n          hostPort: 443\n          name: https\n          protocol: TCP\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 8002\n          initialDelaySeconds: 3\n          periodSeconds: 4\n        volumeMounts:\n          - name: envoy-config\n            mountPath: /config\n            readOnly: true\n          - name: envoycert\n            mountPath: /certs\n            readOnly: true\n        lifecycle:\n          preStop:\n            httpGet:\n              path: /shutdown\n              port: 8090\n              scheme: HTTP\n      initContainers:\n      - args:\n        - bootstrap\n        - /config/envoy.json\n        - --xds-address=contour\n        - --xds-port=8001\n        - --xds-resource-version=v3\n        - --resources-dir=/config/resources\n        - --envoy-cafile=/certs/ca.crt\n        - --envoy-cert-file=/certs/tls.crt\n        - --envoy-key-file=/certs/tls.key\n        command:\n        - contour\n        image: docker.io/projectcontour/contour:v1.17.0\n        imagePullPolicy: IfNotPresent\n        name: envoy-initconfig\n        volumeMounts:\n        - name: envoy-config\n          mountPath: /config\n        - name: envoycert\n          mountPath: /certs\n          readOnly: true\n        env:\n        - name: CONTOUR_NAMESPACE\n          valueFrom:\n            fieldRef:\n              fieldPath: metadata.namespace\n      automountServiceAccountToken: false\n      serviceAccountName: envoy\n      terminationGracePeriodSeconds: 300\n      volumes:\n        - name: envoy-config\n          emptyDir: {}\n        - name: envoycert\n          secret:\n            secretName: envoycert\n      restartPolicy: Always\n", "module github.com/projectcontour/contour\n\ngo 1.15\n\nrequire (\n\tgithub.com/ahmetb/gen-crd-api-reference-docs v0.3.0\n\tgithub.com/bombsimon/logrusr v1.0.0\n\tgithub.com/envoyproxy/go-control-plane v0.9.9-0.20210111201334-f1f47757da33\n\tgithub.com/go-logr/logr v0.4.0\n\tgithub.com/golang/protobuf v1.5.2\n\tgithub.com/google/go-cmp v0.5.5\n\tgithub.com/google/uuid v1.1.2\n\tgithub.com/grpc-ecosystem/go-grpc-prometheus v1.2.0\n\tgithub.com/jetstack/cert-manager v1.3.0\n\tgithub.com/onsi/ginkgo v1.16.4\n\tgithub.com/onsi/gomega v1.13.0\n\tgithub.com/prometheus/client_golang v1.9.0\n\tgithub.com/prometheus/client_model v0.2.0\n\tgithub.com/prometheus/common v0.15.0\n\tgithub.com/sirupsen/logrus v1.7.0\n\tgithub.com/stretchr/testify v1.6.1\n\tgoogle.golang.org/genproto v0.0.0-20201110150050-8816d57aaa9a\n\tgoogle.golang.org/grpc v1.27.1\n\tgoogle.golang.org/protobuf v1.26.0\n\tgopkg.in/alecthomas/kingpin.v2 v2.2.6\n\tgopkg.in/yaml.v2 v2.4.0\n\tk8s.io/api v0.21.0\n\tk8s.io/apiextensions-apiserver v0.21.0\n\tk8s.io/apimachinery v0.21.0\n\tk8s.io/client-go v0.21.0\n\tk8s.io/klog/v2 v2.8.1-0.20210504170414-0cc9b8363efc\n\tk8s.io/utils v0.0.0-20210305010621-2afb4311ab10\n\tsigs.k8s.io/controller-runtime v0.9.0-beta.1\n\tsigs.k8s.io/controller-tools v0.5.0\n\tsigs.k8s.io/gateway-api v0.3.0\n\tsigs.k8s.io/kustomize/kyaml v0.1.1\n)\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dag\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\n\t\"github.com/projectcontour/contour/internal/annotation\"\n\t\"github.com/projectcontour/contour/internal/k8s\"\n\tv1 \"k8s.io/api/core/v1\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n)\n\n// RouteServiceName identifies a service used in a route.\ntype RouteServiceName struct {\n\tName      string\n\tNamespace string\n\tPort      int32\n}\n\n// GetServices returns all services in the DAG.\nfunc (dag *DAG) GetServices() map[RouteServiceName]*Service {\n\tgetter := serviceGetter(map[RouteServiceName]*Service{})\n\tdag.Visit(getter.visit)\n\treturn getter\n}\n\n// GetService returns the service in the DAG that matches the provided\n// namespace, name and port, or nil if no matching service is found.\nfunc (dag *DAG) GetService(meta types.NamespacedName, port int32) *Service {\n\treturn dag.GetServices()[RouteServiceName{\n\t\tName:      meta.Name,\n\t\tNamespace: meta.Namespace,\n\t\tPort:      port,\n\t}]\n}\n\n// EnsureService looks for a Kubernetes service in the cache matching the provided\n// namespace, name and port, and returns a DAG service for it. If a matching service\n// cannot be found in the cache, an error is returned.\nfunc (dag *DAG) EnsureService(meta types.NamespacedName, port intstr.IntOrString, cache *KubernetesCache) (*Service, error) {\n\tsvc, svcPort, err := cache.LookupService(meta, port)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif dagSvc := dag.GetService(k8s.NamespacedNameOf(svc), svcPort.Port); dagSvc != nil {\n\t\treturn dagSvc, nil\n\t}\n\n\tdagSvc := &Service{\n\t\tWeighted: WeightedService{\n\t\t\tServiceName:      svc.Name,\n\t\t\tServiceNamespace: svc.Namespace,\n\t\t\tServicePort:      svcPort,\n\t\t\tWeight:           1,\n\t\t},\n\t\tProtocol:           upstreamProtocol(svc, svcPort),\n\t\tMaxConnections:     annotation.MaxConnections(svc),\n\t\tMaxPendingRequests: annotation.MaxPendingRequests(svc),\n\t\tMaxRequests:        annotation.MaxRequests(svc),\n\t\tMaxRetries:         annotation.MaxRetries(svc),\n\t\tExternalName:       externalName(svc),\n\t}\n\treturn dagSvc, nil\n}\n\nfunc upstreamProtocol(svc *v1.Service, port v1.ServicePort) string {\n\tup := annotation.ParseUpstreamProtocols(svc.Annotations)\n\tprotocol := up[port.Name]\n\tif protocol == \"\" {\n\t\tprotocol = up[strconv.Itoa(int(port.Port))]\n\t}\n\treturn protocol\n}\n\nfunc externalName(svc *v1.Service) string {\n\tif svc.Spec.Type != v1.ServiceTypeExternalName {\n\t\treturn \"\"\n\t}\n\treturn svc.Spec.ExternalName\n}\n\n// serviceGetter is a visitor that gets all services\n// in the DAG.\ntype serviceGetter map[RouteServiceName]*Service\n\nfunc (s serviceGetter) visit(vertex Vertex) {\n\tswitch obj := vertex.(type) {\n\tcase *Service:\n\t\ts[RouteServiceName{\n\t\t\tName:      obj.Weighted.ServiceName,\n\t\t\tNamespace: obj.Weighted.ServiceNamespace,\n\t\t\tPort:      obj.Weighted.ServicePort.Port,\n\t\t}] = obj\n\tdefault:\n\t\tvertex.Visit(s.visit)\n\t}\n}\n\n// GetSecureVirtualHosts returns all secure virtual hosts in the DAG.\nfunc (dag *DAG) GetSecureVirtualHosts() map[ListenerName]*SecureVirtualHost {\n\tgetter := svhostGetter(map[ListenerName]*SecureVirtualHost{})\n\tdag.Visit(getter.visit)\n\treturn getter\n}\n\n// GetSecureVirtualHost returns the secure virtual host in the DAG that\n// matches the provided name, or nil if no matching secure virtual host\n// is found.\nfunc (dag *DAG) GetSecureVirtualHost(ln ListenerName) *SecureVirtualHost {\n\treturn dag.GetSecureVirtualHosts()[ln]\n}\n\n// EnsureSecureVirtualHost adds a secure virtual host with the provided\n// name to the DAG if it does not already exist, and returns it.\nfunc (dag *DAG) EnsureSecureVirtualHost(ln ListenerName) *SecureVirtualHost {\n\tif svh := dag.GetSecureVirtualHost(ln); svh != nil {\n\t\treturn svh\n\t}\n\n\tsvh := &SecureVirtualHost{\n\t\tVirtualHost: VirtualHost{\n\t\t\tName:         ln.Name,\n\t\t\tListenerName: ln.ListenerName,\n\t\t},\n\t}\n\tdag.AddRoot(svh)\n\treturn svh\n}\n\n// svhostGetter is a visitor that gets all secure virtual hosts\n// in the DAG.\ntype svhostGetter map[ListenerName]*SecureVirtualHost\n\nfunc (s svhostGetter) visit(vertex Vertex) {\n\tswitch obj := vertex.(type) {\n\tcase *SecureVirtualHost:\n\t\ts[ListenerName{Name: obj.Name, ListenerName: obj.VirtualHost.ListenerName}] = obj\n\tdefault:\n\t\tvertex.Visit(s.visit)\n\t}\n}\n\n// GetVirtualHosts returns all virtual hosts in the DAG.\nfunc (dag *DAG) GetVirtualHosts() map[ListenerName]*VirtualHost {\n\tgetter := vhostGetter(map[ListenerName]*VirtualHost{})\n\tdag.Visit(getter.visit)\n\treturn getter\n}\n\n// GetVirtualHost returns the virtual host in the DAG that matches the\n// provided name, or nil if no matching virtual host is found.\nfunc (dag *DAG) GetVirtualHost(ln ListenerName) *VirtualHost {\n\treturn dag.GetVirtualHosts()[ln]\n}\n\n// EnsureVirtualHost adds a virtual host with the provided name to the\n// DAG if it does not already exist, and returns it.\nfunc (dag *DAG) EnsureVirtualHost(ln ListenerName) *VirtualHost {\n\tif vhost := dag.GetVirtualHost(ln); vhost != nil {\n\t\treturn vhost\n\t}\n\n\tvhost := &VirtualHost{\n\t\tName:         ln.Name,\n\t\tListenerName: ln.ListenerName,\n\t}\n\tdag.AddRoot(vhost)\n\treturn vhost\n}\n\n// vhostGetter is a visitor that gets all virtual hosts\n// in the DAG.\ntype vhostGetter map[ListenerName]*VirtualHost\n\nfunc (v vhostGetter) visit(vertex Vertex) {\n\tswitch obj := vertex.(type) {\n\tcase *VirtualHost:\n\t\tv[ListenerName{Name: obj.Name, ListenerName: obj.ListenerName}] = obj\n\tdefault:\n\t\tvertex.Visit(v.visit)\n\t}\n}\n\n// GetExtensionClusters returns all extension clusters in the DAG.\nfunc (dag *DAG) GetExtensionClusters() map[string]*ExtensionCluster {\n\tgetter := extensionClusterGetter(map[string]*ExtensionCluster{})\n\tdag.Visit(getter.visit)\n\treturn getter\n}\n\n// GetExtensionCluster returns the extension cluster in the DAG that\n// matches the provided name, or nil if no matching extension cluster\n//is found.\nfunc (dag *DAG) GetExtensionCluster(name string) *ExtensionCluster {\n\treturn dag.GetExtensionClusters()[name]\n}\n\n// extensionClusterGetter is a visitor that gets all extension clusters\n// in the DAG.\ntype extensionClusterGetter map[string]*ExtensionCluster\n\nfunc (v extensionClusterGetter) visit(vertex Vertex) {\n\tswitch obj := vertex.(type) {\n\tcase *ExtensionCluster:\n\t\tv[obj.Name] = obj\n\tdefault:\n\t\tvertex.Visit(v.visit)\n\t}\n}\n\n// validSecret returns true if the Secret contains certificate and private key material.\nfunc validSecret(s *v1.Secret) error {\n\tif s.Type != v1.SecretTypeTLS {\n\t\treturn fmt.Errorf(\"Secret type is not %q\", v1.SecretTypeTLS)\n\t}\n\n\tif len(s.Data[v1.TLSCertKey]) == 0 {\n\t\treturn fmt.Errorf(\"empty %q key\", v1.TLSCertKey)\n\t}\n\n\tif len(s.Data[v1.TLSPrivateKeyKey]) == 0 {\n\t\treturn fmt.Errorf(\"empty %q key\", v1.TLSPrivateKeyKey)\n\t}\n\n\treturn nil\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dag\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/projectcontour/contour/internal/fixture\"\n\t\"github.com/stretchr/testify/assert\"\n\tv1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n)\n\nfunc TestBuilderLookupService(t *testing.T) {\n\ts1 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\tservices := map[types.NamespacedName]*v1.Service{\n\t\t{Name: \"service1\", Namespace: \"default\"}: s1,\n\t}\n\n\ttests := map[string]struct {\n\t\ttypes.NamespacedName\n\t\tport    intstr.IntOrString\n\t\twant    *Service\n\t\twantErr error\n\t}{\n\t\t\"lookup service by port number\": {\n\t\t\tNamespacedName: types.NamespacedName{Name: \"service1\", Namespace: \"default\"},\n\t\t\tport:           intstr.FromInt(8080),\n\t\t\twant:           service(s1),\n\t\t},\n\t\t\"lookup service by port name\": {\n\t\t\tNamespacedName: types.NamespacedName{Name: \"service1\", Namespace: \"default\"},\n\t\t\tport:           intstr.FromString(\"http\"),\n\t\t\twant:           service(s1),\n\t\t},\n\t\t\"lookup service by port number (as string)\": {\n\t\t\tNamespacedName: types.NamespacedName{Name: \"service1\", Namespace: \"default\"},\n\t\t\tport:           intstr.Parse(\"8080\"),\n\t\t\twant:           service(s1),\n\t\t},\n\t\t\"lookup service by port number (from string)\": {\n\t\t\tNamespacedName: types.NamespacedName{Name: \"service1\", Namespace: \"default\"},\n\t\t\tport:           intstr.FromString(\"8080\"),\n\t\t\twant:           service(s1),\n\t\t},\n\t\t\"when service does not exist an error is returned\": {\n\t\t\tNamespacedName: types.NamespacedName{Name: \"nonexistent-service\", Namespace: \"default\"},\n\t\t\tport:           intstr.FromString(\"8080\"),\n\t\t\twantErr:        errors.New(`service \"default/nonexistent-service\" not found`),\n\t\t},\n\t\t\"when port does not exist an error is returned\": {\n\t\t\tNamespacedName: types.NamespacedName{Name: \"service1\", Namespace: \"default\"},\n\t\t\tport:           intstr.FromString(\"9999\"),\n\t\t\twantErr:        errors.New(`port \"9999\" on service \"default/service1\" not matched`),\n\t\t},\n\t}\n\n\tfor name, tc := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tb := Builder{\n\t\t\t\tSource: KubernetesCache{\n\t\t\t\t\tservices:    services,\n\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tvar dag DAG\n\n\t\t\tgot, gotErr := dag.EnsureService(tc.NamespacedName, tc.port, &b.Source)\n\t\t\tassert.Equal(t, tc.want, got)\n\t\t\tassert.Equal(t, tc.wantErr, gotErr)\n\t\t})\n\t}\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dag\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\tcontour_api_v1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"\n\t\"github.com/projectcontour/contour/internal/fixture\"\n\t\"github.com/projectcontour/contour/internal/timeout\"\n\t\"github.com/stretchr/testify/assert\"\n\tv1 \"k8s.io/api/core/v1\"\n\tnetworking_v1 \"k8s.io/api/networking/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n\t\"k8s.io/utils/pointer\"\n\tgatewayapi_v1alpha1 \"sigs.k8s.io/gateway-api/apis/v1alpha1\"\n)\n\nvar sec1 = &v1.Secret{\n\tObjectMeta: metav1.ObjectMeta{\n\t\tName:      \"secret\",\n\t\tNamespace: \"default\",\n\t},\n\tType: v1.SecretTypeTLS,\n\tData: secretdata(fixture.CERTIFICATE, fixture.RSA_PRIVATE_KEY),\n}\n\n// Invalid cert in the secret\nvar secInvalid = &v1.Secret{\n\tObjectMeta: metav1.ObjectMeta{\n\t\tName:      \"secret\",\n\t\tNamespace: \"default\",\n\t},\n\tType: v1.SecretTypeTLS,\n\tData: secretdata(\"wrong\", \"wronger\"),\n}\n\nfunc gatewayPort(port int) *gatewayapi_v1alpha1.PortNumber {\n\tp := gatewayapi_v1alpha1.PortNumber(port)\n\treturn &p\n}\n\nfunc TestDAGInsertGatewayAPI(t *testing.T) {\n\n\tkuardService := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\tkuardService2 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard2\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\tkuardService3 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard3\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\tkuardServiceCustomNs := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"custom\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\tblogService := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"blogsvc\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       80,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\tvalidClass := &gatewayapi_v1alpha1.GatewayClass{\n\t\tTypeMeta: metav1.TypeMeta{},\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName: \"test-validClass\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewayClassSpec{\n\t\t\tController: \"projectcontour.io/contour\",\n\t\t},\n\t\tStatus: gatewayapi_v1alpha1.GatewayClassStatus{\n\t\t\tConditions: []metav1.Condition{\n\t\t\t\t{\n\t\t\t\t\tType:   string(gatewayapi_v1alpha1.GatewayClassConditionStatusAdmitted),\n\t\t\t\t\tStatus: metav1.ConditionTrue,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tgatewayWithSelector := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectSame),\n\t\t\t\t\t},\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{\n\t\t\t\t\t\t\tKey:      \"type\",\n\t\t\t\t\t\t\tOperator: \"In\",\n\t\t\t\t\t\t\tValues:   []string{\"controller\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tsec1 := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"tlscert\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tType: v1.SecretTypeTLS,\n\t\tData: secretdata(fixture.CERTIFICATE, fixture.RSA_PRIVATE_KEY),\n\t}\n\n\thostname := gatewayapi_v1alpha1.Hostname(\"gateway.projectcontour.io\")\n\twildcardHostname := gatewayapi_v1alpha1.Hostname(\"*.projectcontour.io\")\n\n\tgatewayWithHostname := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tHostname: &hostname,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectSame),\n\t\t\t\t\t},\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{\n\t\t\t\t\t\t\tKey:      \"type\",\n\t\t\t\t\t\t\tOperator: \"In\",\n\t\t\t\t\t\t\tValues:   []string{\"controller\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayWithWildcardHostname := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tHostname: &wildcardHostname,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectSame),\n\t\t\t\t\t},\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{\n\t\t\t\t\t\t\tKey:      \"type\",\n\t\t\t\t\t\t\tOperator: \"In\",\n\t\t\t\t\t\t\tValues:   []string{\"controller\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayWithAddresses := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tAddresses: []gatewayapi_v1alpha1.GatewayAddress{\n\t\t\t\t{\n\t\t\t\t\tType:  gatewayAddressTypePtr(gatewayapi_v1alpha1.IPAddressType),\n\t\t\t\t\tValue: \"1.2.3.4\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayTLSRouteNoSelector := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.TLSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\tMode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModePassthrough),\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindTLSRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayTLSRouteModePassthrough := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.TLSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\tMode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModePassthrough),\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindTLSRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayTLSRouteModeTerminate := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     443,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.TLSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\tMode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModeTerminate),\n\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\tKind:  \"Secret\",\n\t\t\t\t\t\tName:  sec1.Name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindTLSRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayWithSameNamespace := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectSame),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayWithTLSRouteSelector := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.TLSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\tMode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModePassthrough),\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindTLSRoute,\n\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectSame),\n\t\t\t\t\t},\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{\n\t\t\t\t\t\t\tKey:      \"type\",\n\t\t\t\t\t\t\tOperator: \"In\",\n\t\t\t\t\t\t\tValues:   []string{\"controller\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayWithOnlyTLS := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     443,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\tKind:  \"Secret\",\n\t\t\t\t\t\tName:  sec1.Name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayWithTLSandHTTP := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\tPort:     443,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\tKind:  \"Secret\",\n\t\t\t\t\t\tName:  sec1.Name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewaywithtlsDifferentselectors := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{\n\t\t\t\t\t\t\tKey:      \"protocol\",\n\t\t\t\t\t\t\tOperator: \"In\",\n\t\t\t\t\t\t\tValues:   []string{\"http\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\tPort:     443,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\tKind:  \"Secret\",\n\t\t\t\t\t\tName:  sec1.Name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{\n\t\t\t\t\t\t\tKey:      \"protocol\",\n\t\t\t\t\t\t\tOperator: \"In\",\n\t\t\t\t\t\t\tValues:   []string{\"https\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgenericHTTPRoute := &gatewayapi_v1alpha1.HTTPRoute{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"basic\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"app\":      \"contour\",\n\t\t\t\t\"type\":     \"controller\",\n\t\t\t\t\"protocol\": \"http\",\n\t\t\t},\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t},\n\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\"test.projectcontour.io\",\n\t\t\t},\n\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t}},\n\t\t},\n\t}\n\n\thttpRouteProtocolHTTPS := &gatewayapi_v1alpha1.HTTPRoute{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"basictls\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"app\":      \"contour\",\n\t\t\t\t\"type\":     \"controller\",\n\t\t\t\t\"protocol\": \"https\",\n\t\t\t},\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t},\n\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\"test.projectcontour.io\",\n\t\t\t},\n\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\tForwardTo: httpRouteForwardTo(\"blogsvc\", 80, 1),\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayWithAllNamespace := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayWithNamespaceSelector := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectSelector),\n\t\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{\n\t\t\t\t\t\t\t\tKey:      \"type\",\n\t\t\t\t\t\t\t\tOperator: \"In\",\n\t\t\t\t\t\t\t\tValues:   []string{\"controller\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayWithNamespaceSelectorNotMatching := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectSelector),\n\t\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{\n\t\t\t\t\t\t\t\tKey:      \"type\",\n\t\t\t\t\t\t\t\tOperator: \"In\",\n\t\t\t\t\t\t\t\tValues:   []string{\"controller\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayNoSelector := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewaySelectorNotMatching := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\"not\": \"matching\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{\n\t\t\t\t\t\t\tKey:      \"something\",\n\t\t\t\t\t\t\tOperator: \"In\",\n\t\t\t\t\t\t\tValues:   []string{\"else\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ttests := map[string]struct {\n\t\tobjs                         []interface{}\n\t\tdisablePermitInsecure        bool\n\t\tfallbackCertificateName      string\n\t\tfallbackCertificateNamespace string\n\t\tgatewayclass                 *gatewayapi_v1alpha1.GatewayClass\n\t\tgateway                      *gatewayapi_v1alpha1.Gateway\n\t\twant                         []Vertex\n\t}{\n\t\t\"insert basic single route, single hostname\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"gateway with unsupported addresses\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithAddresses,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"gateway without a gatewayclass\": {\n\t\t\tgateway: gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t// Test that a gateway without a Selector will select objects.\n\t\t\"insert basic single route, single hostname, gateway no selector\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// Test that a gateway without a Selector will select objects.\n\t\t\"insert basic single route, single hostname, gateway same namespace selector\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSameNamespace,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway same namespace selector, route different namespace\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSameNamespace,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway All namespace selector\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithAllNamespace,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardServiceCustomNs))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway From namespace selector\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithNamespaceSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardServiceCustomNs))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// HTTPRoute is in a different namespace than the Gateway,\n\t\t// but will be allowed since \"All\" is set.\n\t\t\"HTTPRoute: RouteGateways with GatewayAllowType: All\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardServiceCustomNs))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// HTTPRoute is in a different namespace than the Gateway,\n\t\t// and is rejected since \"SameNamespace\" is set.\n\t\t\"HTTPRoute doesn't match with RouteGateways.GatewayAllowType: SameNamespace\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t// HTTPRoute is in the same namespace of the Gateway,\n\t\t// and is allowed since \"SameNamespace\" is set.\n\t\t\"HTTPRoute matches with RouteGateways.GatewayAllowType: SameNamespace\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// HTTPRoute references same Gateway is configured with\n\t\t// in the FromList.\n\t\t\"HTTPRoute matches with RouteGateways.GatewayAllowType: FromList\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowFromList),\n\t\t\t\t\t\t\tGatewayRefs: []gatewayapi_v1alpha1.GatewayReference{{\n\t\t\t\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardServiceCustomNs))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// HTTPRoute references different Gateway is configured with\n\t\t// in the FromList.\n\t\t\"HTTPRoute doesn't match with RouteGateways.GatewayAllowType: FromList\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowFromList),\n\t\t\t\t\t\t\tGatewayRefs: []gatewayapi_v1alpha1.GatewayReference{{\n\t\t\t\t\t\t\t\tName:      \"wrong\",\n\t\t\t\t\t\t\t\tNamespace: \"reference\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"TLSRoute with TLS.Mode=Passthrough is valid\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayTLSRouteModePassthrough,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"test.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardServiceCustomNs)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"TLSRoute with TLS.Mode=Passthrough is invalid if certificateRef is specified\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     80,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.TLSProtocolType,\n\t\t\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\t\t\tMode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModePassthrough),\n\t\t\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\t\t\tKind:  \"Secret\",\n\t\t\t\t\t\t\t\tName:  sec1.Name,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindTLSRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"TLSRoute with TLS.Mode=Terminate is invalid when TLS certificate reference is not defined\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayTLSRouteModeTerminate,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"TLSRoute with TLS not defined is invalid\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     80,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.TLSProtocolType,\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindTLSRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"TLSRoute with invalid listener protocol of HTTP\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     80,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\t\t\tMode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModePassthrough),\n\t\t\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\t\t\tKind:  \"Secret\",\n\t\t\t\t\t\t\t\tName:  sec1.Name,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindTLSRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"TLSRoute with invalid listener kind\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t// TLSRoute is in a different namespace than the Gateway,\n\t\t// but will be allowed since \"All\" is set.\n\t\t\"TLSRoute: RouteGateways with GatewayAllowType: All\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayTLSRouteNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"test.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardServiceCustomNs)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// TLSRoute is in a different namespace than the Gateway,\n\t\t// and is rejected since \"SameNamespace\" is set.\n\t\t\"TLSRoute doesn't match with RouteGateways.GatewayAllowType: SameNamespace\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t// TLSRoute is in the same namespace of the Gateway,\n\t\t// and is allowed since \"SameNamespace\" is set.\n\t\t\"TLSRoute matches with RouteGateways.GatewayAllowType: SameNamespace\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayTLSRouteNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"test.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardService)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// TLSRoute references same Gateway is configured with\n\t\t// in the FromList.\n\t\t\"TLSRoute matches with RouteGateways.GatewayAllowType: FromList\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayTLSRouteNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowFromList),\n\t\t\t\t\t\t\tGatewayRefs: []gatewayapi_v1alpha1.GatewayReference{{\n\t\t\t\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"test.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardServiceCustomNs)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// TLSRoute references different Gateway is configured with\n\t\t// in the FromList.\n\t\t\"TLSRoute doesn't match with RouteGateways.GatewayAllowType: FromList\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowFromList),\n\t\t\t\t\t\t\tGatewayRefs: []gatewayapi_v1alpha1.GatewayReference{{\n\t\t\t\t\t\t\t\tName:      \"wrong\",\n\t\t\t\t\t\t\t\tNamespace: \"reference\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t// Issue: https://github.com/projectcontour/contour/issues/3591\n\t\t\"one gateway with two httproutes, different hostnames\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithNamespaceSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic-two\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"another.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"another.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardServiceCustomNs))),\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardServiceCustomNs))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway From namespace selector, not matching\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithNamespaceSelectorNotMatching,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"notmatch\",\n\t\t\t\t\t\t\t\"type\": \"someother\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t// Test that a gateway selector doesn't select routes that do not match.\n\t\t\"insert basic single route, single hostname which doesn't match gateway's selector\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewaySelectorNotMatching,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t// Test that a gateway selector kind that doesn't match.\n\t\t\"insert gateway with selector kind that doesn't match\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     80,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: \"INVALID\",\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t// Test that a gateway selector group that doesn't match.\n\t\t\"insert gateway with selector group that doesn't match\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     80,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind:  \"HTTPRoute\",\n\t\t\t\t\t\t\tGroup: pointer.StringPtr(\"INVALID\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert basic multiple routes, single hostname\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\tblogService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/blog\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"blogsvc\", 80, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t\tprefixrouteHTTPRoute(\"/\", service(kuardService)), prefixrouteHTTPRoute(\"/blog\", service(blogService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"multiple hosts\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\"test2.projectcontour.io\",\n\t\t\t\t\t\t\t\"test3.projectcontour.io\",\n\t\t\t\t\t\t\t\"test4.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t\tvirtualhost(\"test2.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t\tvirtualhost(\"test3.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t\tvirtualhost(\"test4.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"no host defined\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"wildcard hostname\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"*.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(virtualhost(\"*.projectcontour.io\",\n\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \":authority\", Value: \"^[a-z0-9]([-a-z0-9]*[a-z0-9])?\\\\.projectcontour\\\\.io\", MatchType: \"regex\", Invert: false},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clustersWeight(service(kuardService)),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"invalid hostnames - IP\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"192.168.122.1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"invalid hostnames - with port\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io:80\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"invalid hostnames - wildcard label by itself\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"*\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t// If the ServiceName referenced from an HTTPRoute is missing,\n\t\t// the route should return an HTTP503.\n\t\t\"missing service\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", directResponseRoute(\"/\", http.StatusServiceUnavailable)),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// If port is not defined the route will be marked as invalid (#3352).\n\t\t\"missing port\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\t\tPort:        nil,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert basic single route with exact path match\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchExact, \"/blog\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t\texactrouteHTTPRoute(\"/blog\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// Single host with single route containing multiple prefixes to the same service.\n\t\t\"insert basic single route with multiple prefixes, single hostname\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.HTTPRouteMatch{{\n\t\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(gatewayapi_v1alpha1.PathMatchPrefix),\n\t\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(gatewayapi_v1alpha1.PathMatchPrefix),\n\t\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/blog\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(gatewayapi_v1alpha1.PathMatchPrefix),\n\t\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/tech\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t\tprefixrouteHTTPRoute(\"/\", service(kuardService)),\n\t\t\t\t\t\t\tprefixrouteHTTPRoute(\"/blog\", service(kuardService)),\n\t\t\t\t\t\t\tprefixrouteHTTPRoute(\"/tech\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway with TLS, HTTP protocol is ignored\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     443,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\t\t\tKind:  \"Secret\",\n\t\t\t\t\t\t\t\tName:  sec1.Name,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\tkuardService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t\tprefixrouteHTTPRoute(\"/\", service(kuardService)),\n\t\t\t\t\t\t)),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway with TLS, HTTPS protocol missing certificateRef\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     443,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPSProtocolType,\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\tkuardService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway with TLS\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithOnlyTLS,\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\tkuardService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"test.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tSecret: secret(sec1),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway with missing TLS certificate\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithOnlyTLS,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway with invalid TLS certificate\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithOnlyTLS,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Secret{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"tlscert\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tType: v1.SecretTypeTLS,\n\t\t\t\t\tData: secretdata(\"wrong\", \"wronger\"),\n\t\t\t\t},\n\t\t\t\tkuardService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway with TLS & Insecure Listeners\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithTLSandHTTP,\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\tblogService,\n\t\t\t\thttpRouteProtocolHTTPS,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"test.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(prefixrouteHTTPRoute(\"/\", service(blogService))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tSecret: secret(sec1),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(blogService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"TLS Listener Gateway CertificateRef must be type core.Secret\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     443,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPSProtocolType,\n\t\t\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\t\t\tGroup: \"custom\",\n\t\t\t\t\t\t\t\tKind:  \"shhhh\",\n\t\t\t\t\t\t\t\tName:  sec1.Name,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\tblogService,\n\t\t\t\thttpRouteProtocolHTTPS,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"TLS Listener Gateway CertificateRef must be specified\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     443,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPSProtocolType,\n\t\t\t\t\t\tTLS:      &gatewayapi_v1alpha1.GatewayTLSConfig{},\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\tblogService,\n\t\t\t\thttpRouteProtocolHTTPS,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"No valid hostnames defined\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithAllNamespace,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":      \"contour\",\n\t\t\t\t\t\t\t\"type\":     \"controller\",\n\t\t\t\t\t\t\t\"protocol\": \"https\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"*.*.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"blogsvc\", 80, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"Invalid listener protocol type (TCP)\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     80,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.TCPProtocolType,\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{genericHTTPRoute},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"Invalid listener protocol type (UDP)\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     80,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.UDPProtocolType,\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{genericHTTPRoute},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"Invalid listener protocol type (custom)\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     80,\n\t\t\t\t\t\tProtocol: \"projectcontour.io/HTTPUDP\",\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{genericHTTPRoute},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway with TLS & Insecure Listeners, different selectors\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewaywithtlsDifferentselectors,\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\tkuardService,\n\t\t\t\tblogService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t\thttpRouteProtocolHTTPS,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"test.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(prefixrouteHTTPRoute(\"/\", service(blogService))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tSecret: secret(sec1),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert basic single route with single header match and path match\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.HTTPRouteMatch{{\n\t\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(gatewayapi_v1alpha1.PathMatchPrefix),\n\t\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tHeaders: &gatewayapi_v1alpha1.HTTPHeaderMatch{\n\t\t\t\t\t\t\t\t\tType:   headerMatchTypePtr(gatewayapi_v1alpha1.HeaderMatchExact),\n\t\t\t\t\t\t\t\t\tValues: map[string]string{\"foo\": \"bar\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(virtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \"foo\", Value: \"bar\", MatchType: \"exact\", Invert: false},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clustersWeight(service(kuardService)),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert two routes with single header match, path match and header match\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.HTTPRouteMatch{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(gatewayapi_v1alpha1.PathMatchPrefix),\n\t\t\t\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/blog\"),\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(gatewayapi_v1alpha1.PathMatchPrefix),\n\t\t\t\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/tech\"),\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tHeaders: &gatewayapi_v1alpha1.HTTPHeaderMatch{\n\t\t\t\t\t\t\t\t\t\t\tType:   headerMatchTypePtr(gatewayapi_v1alpha1.HeaderMatchExact),\n\t\t\t\t\t\t\t\t\t\t\tValues: map[string]string{\"foo\": \"bar\"},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(virtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/blog\"),\n\t\t\t\t\t\t\tClusters:           clustersWeight(service(kuardService)),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/tech\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \"foo\", Value: \"bar\", MatchType: \"exact\", Invert: false},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clustersWeight(service(kuardService)),\n\t\t\t\t\t\t},\n\t\t\t\t\t)),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert two routes with single header match without explicit path match\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.HTTPRouteMatch{{\n\t\t\t\t\t\t\t\tHeaders: &gatewayapi_v1alpha1.HTTPHeaderMatch{\n\t\t\t\t\t\t\t\t\tType:   headerMatchTypePtr(gatewayapi_v1alpha1.HeaderMatchExact),\n\t\t\t\t\t\t\t\t\tValues: map[string]string{\"foo\": \"bar\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(virtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \"foo\", Value: \"bar\", MatchType: \"exact\", Invert: false},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clustersWeight(service(kuardService)),\n\t\t\t\t\t\t},\n\t\t\t\t\t)),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"Route rule with request header modifier\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t\tFilters: []gatewayapi_v1alpha1.HTTPRouteFilter{{\n\t\t\t\t\t\t\t\tType: gatewayapi_v1alpha1.HTTPRouteFilterRequestHeaderModifier,\n\t\t\t\t\t\t\t\tRequestHeaderModifier: &gatewayapi_v1alpha1.HTTPRequestHeaderFilter{\n\t\t\t\t\t\t\t\t\tSet: map[string]string{\"custom-header-set\": \"foo-bar\", \"Host\": \"bar.com\"},\n\t\t\t\t\t\t\t\t\tAdd: map[string]string{\"custom-header-add\": \"foo-bar\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(virtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustersWeight(service(kuardService)),\n\t\t\t\t\t\t\tRequestHeadersPolicy: &HeadersPolicy{\n\t\t\t\t\t\t\t\tSet: map[string]string{\n\t\t\t\t\t\t\t\t\t\"Custom-Header-Set\": \"foo-bar\", // Verify the header key is canonicalized.\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tAdd: map[string]string{\n\t\t\t\t\t\t\t\t\t\"Custom-Header-Add\": \"foo-bar\", // Verify the header key is canonicalized.\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tHostRewrite: \"bar.com\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t)),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"HTTP forward with request header modifier\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\t\tFilters: []gatewayapi_v1alpha1.HTTPRouteFilter{{\n\t\t\t\t\t\t\t\t\tType: gatewayapi_v1alpha1.HTTPRouteFilterRequestHeaderModifier,\n\t\t\t\t\t\t\t\t\tRequestHeaderModifier: &gatewayapi_v1alpha1.HTTPRequestHeaderFilter{\n\t\t\t\t\t\t\t\t\t\tSet: map[string]string{\"custom-header-set\": \"foo-bar\", \"Host\": \"bar.com\"},\n\t\t\t\t\t\t\t\t\t\tAdd: map[string]string{\"custom-header-add\": \"foo-bar\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(virtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clusterHeaders(map[string]string{\"Custom-Header-Set\": \"foo-bar\"}, map[string]string{\"Custom-Header-Add\": \"foo-bar\"}, nil, \"bar.com\", service(kuardService)),\n\t\t\t\t\t\t},\n\t\t\t\t\t)),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"Route rule with invalid request header modifier\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t\t\tFilters: []gatewayapi_v1alpha1.HTTPRouteFilter{{\n\t\t\t\t\t\t\t\t\tType: gatewayapi_v1alpha1.HTTPRouteFilterRequestHeaderModifier,\n\t\t\t\t\t\t\t\t\tRequestHeaderModifier: &gatewayapi_v1alpha1.HTTPRequestHeaderFilter{\n\t\t\t\t\t\t\t\t\t\tSet: map[string]string{\"custom-header-set\": \"foo-bar\", \"Host\": \"bar.com\"},\n\t\t\t\t\t\t\t\t\t\tAdd: map[string]string{\"!invalid-header-add\": \"foo-bar\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(virtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustersWeight(service(kuardService)),\n\t\t\t\t\t\t\tRequestHeadersPolicy: &HeadersPolicy{\n\t\t\t\t\t\t\t\tSet:         map[string]string{\"Custom-Header-Set\": \"foo-bar\"},\n\t\t\t\t\t\t\t\tAdd:         map[string]string{}, // Invalid header should not be set.\n\t\t\t\t\t\t\t\tHostRewrite: \"bar.com\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t)),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"HTTP forward with invalid request header modifier\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\t\t\tFilters: []gatewayapi_v1alpha1.HTTPRouteFilter{{\n\t\t\t\t\t\t\t\t\t\tType: gatewayapi_v1alpha1.HTTPRouteFilterRequestHeaderModifier,\n\t\t\t\t\t\t\t\t\t\tRequestHeaderModifier: &gatewayapi_v1alpha1.HTTPRequestHeaderFilter{\n\t\t\t\t\t\t\t\t\t\t\tSet: map[string]string{\"custom-header-set\": \"foo-bar\", \"Host\": \"bar.com\"},\n\t\t\t\t\t\t\t\t\t\t\tAdd: map[string]string{\"!invalid-header-add\": \"foo-bar\"},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(virtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clusterHeaders(map[string]string{\"Custom-Header-Set\": \"foo-bar\"}, map[string]string{}, nil, \"bar.com\", service(kuardService)),\n\t\t\t\t\t\t},\n\t\t\t\t\t)),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"different weights for multiple forwardTos\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\tkuardService2,\n\t\t\t\tkuardService3,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwards(\n\t\t\t\t\t\t\t\thttpRouteForwardTo(\"kuard\", 8080, 5),\n\t\t\t\t\t\t\t\thttpRouteForwardTo(\"kuard2\", 8080, 10),\n\t\t\t\t\t\t\t\thttpRouteForwardTo(\"kuard3\", 8080, 15),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixrouteHTTPRoute(\"/\",\n\t\t\t\t\t\t\t&Service{\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           5,\n\t\t\t\t\t\t\t\t\tServiceName:      kuardService.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: kuardService.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      kuardService.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Service{\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           10,\n\t\t\t\t\t\t\t\t\tServiceName:      kuardService2.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: kuardService2.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      kuardService2.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Service{\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           15,\n\t\t\t\t\t\t\t\t\tServiceName:      kuardService3.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: kuardService3.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      kuardService3.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"one service weight zero w/weights for other forwardTos\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\tkuardService2,\n\t\t\t\tkuardService3,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwards(\n\t\t\t\t\t\t\t\thttpRouteForwardTo(\"kuard\", 8080, 5),\n\t\t\t\t\t\t\t\thttpRouteForwardTo(\"kuard2\", 8080, 0),\n\t\t\t\t\t\t\t\thttpRouteForwardTo(\"kuard3\", 8080, 15),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixrouteHTTPRoute(\"/\",\n\t\t\t\t\t\t\t&Service{\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           5,\n\t\t\t\t\t\t\t\t\tServiceName:      kuardService.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: kuardService.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      kuardService.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Service{\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           0,\n\t\t\t\t\t\t\t\t\tServiceName:      kuardService2.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: kuardService2.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      kuardService2.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Service{\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           15,\n\t\t\t\t\t\t\t\t\tServiceName:      kuardService3.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: kuardService3.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      kuardService3.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"weight of zero for a single forwardTo results in 503\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\tkuardService2,\n\t\t\t\tkuardService3,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", directResponseRouteService(\"/\", http.StatusServiceUnavailable, &Service{\n\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\tWeight:           0,\n\t\t\t\t\t\t\t\tServiceName:      kuardService.Name,\n\t\t\t\t\t\t\t\tServiceNamespace: kuardService.Namespace,\n\t\t\t\t\t\t\t\tServicePort:      kuardService.Spec.Ports[0],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t})),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"basic TLSRoute\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithTLSRouteSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"tcp.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"tcp.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardService)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"TLSRoute with multiple SNIs\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithTLSRouteSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"tcp.projectcontour.io\",\n\t\t\t\t\t\t\t\t\t\"another.projectcontour.io\",\n\t\t\t\t\t\t\t\t\t\"thing.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"another.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardService)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"tcp.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardService)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"thing.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardService)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"TLSRoute with multiple SNIs, one is invalid\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithTLSRouteSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"tcp.projectcontour.io\",\n\t\t\t\t\t\t\t\t\t\"*.*.another.projectcontour.io\",\n\t\t\t\t\t\t\t\t\t\"thing.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"tcp.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardService)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"thing.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardService)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"TLSRoute with multiple SNIs, all are invalid\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"tcp.*.projectcontour.io\",\n\t\t\t\t\t\t\t\t\t\"*.*.another.projectcontour.io\",\n\t\t\t\t\t\t\t\t\t\"!!thing.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"TLSRoute without any hostnames specified results in '*' match all\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithTLSRouteSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches:   []gatewayapi_v1alpha1.TLSRouteMatch{{}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"*\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardService)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"TLSRoute with missing forwardTo service\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"tcp.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert gateway listener with host\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithHostname,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchExact, \"/blog\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"gateway.projectcontour.io\",\n\t\t\t\t\t\t\texactrouteHTTPRoute(\"/blog\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert gateway listener with host, httproute with host\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithWildcardHostname,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"http.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchExact, \"/blog\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"http.projectcontour.io\",\n\t\t\t\t\t\t\texactrouteHTTPRoute(\"/blog\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t}\n\n\tfor name, tc := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\n\t\t\tbuilder := Builder{\n\t\t\t\tSource: KubernetesCache{\n\t\t\t\t\tConfiguredGateway: types.NamespacedName{\n\t\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tgatewayclass: tc.gatewayclass,\n\t\t\t\t\tgateway:      tc.gateway,\n\t\t\t\t\tFieldLogger:  fixture.NewTestLogger(t),\n\t\t\t\t},\n\t\t\t\tProcessors: []Processor{\n\t\t\t\t\t&IngressProcessor{\n\t\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t\t},\n\t\t\t\t\t&HTTPProxyProcessor{\n\t\t\t\t\t\tDisablePermitInsecure: tc.disablePermitInsecure,\n\t\t\t\t\t\tFallbackCertificate: &types.NamespacedName{\n\t\t\t\t\t\t\tName:      tc.fallbackCertificateName,\n\t\t\t\t\t\t\tNamespace: tc.fallbackCertificateNamespace,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t&GatewayAPIProcessor{\n\t\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t\t},\n\t\t\t\t\t&ListenerProcessor{},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, o := range tc.objs {\n\t\t\t\tbuilder.Source.Insert(o)\n\t\t\t}\n\t\t\tdag := builder.Build()\n\n\t\t\tgot := make(map[int]*Listener)\n\t\t\tdag.Visit(listenerMap(got).Visit)\n\n\t\t\twant := make(map[int]*Listener)\n\t\t\tfor _, v := range tc.want {\n\t\t\t\tif l, ok := v.(*Listener); ok {\n\t\t\t\t\twant[l.Port] = l\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert.Equal(t, want, got)\n\t\t})\n\t}\n}\n\nfunc TestDAGInsert(t *testing.T) {\n\t// The DAG is sensitive to ordering, adding an ingress, then a service,\n\t// should have the same result as adding a service, then an ingress.\n\n\t// weird secret with a blank ca.crt that\n\t// cert manager creates. #1644\n\tsec3 := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"secret\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tType: v1.SecretTypeTLS,\n\t\tData: map[string][]byte{\n\t\t\tCACertificateKey:    []byte(\"\"),\n\t\t\tv1.TLSCertKey:       []byte(fixture.CERTIFICATE),\n\t\t\tv1.TLSPrivateKeyKey: []byte(fixture.RSA_PRIVATE_KEY),\n\t\t},\n\t}\n\n\tsec4 := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"secret\",\n\t\t\tNamespace: \"root\",\n\t\t},\n\t\tType: v1.SecretTypeTLS,\n\t\tData: secretdata(fixture.CERTIFICATE, fixture.RSA_PRIVATE_KEY),\n\t}\n\n\tfallbackCertificateSecret := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"fallbacksecret\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tType: v1.SecretTypeTLS,\n\t\tData: secretdata(fixture.CERTIFICATE, fixture.RSA_PRIVATE_KEY),\n\t}\n\n\tfallbackCertificateSecretRootNamespace := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"fallbacksecret\",\n\t\t\tNamespace: \"root\",\n\t\t},\n\t\tType: v1.SecretTypeTLS,\n\t\tData: secretdata(fixture.CERTIFICATE, fixture.RSA_PRIVATE_KEY),\n\t}\n\n\tcert1 := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"ca\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\tCACertificateKey: []byte(fixture.CERTIFICATE),\n\t\t},\n\t}\n\n\ti1V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromInt(8080)),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti1aV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"kubernetes.io/ingress.allow-http\": \"false\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromInt(8080)),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i2V1 is functionally identical to i1V1\n\ti2V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromInt(8080))),\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i2aV1 is missing a http key from the spec.rule.\n\t// see issue 606\n\ti2aV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost: \"test1.test.com\",\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i3V1 is similar to i2V1 but includes a hostname on the ingress rule\n\ti3V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"kuard.example.com\"},\n\t\t\t\tSecretName: sec1.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost:             \"kuard.example.com\",\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromInt(8080))),\n\t\t\t}},\n\t\t},\n\t}\n\t// i4V1 is like i1V1 except it uses a named service port\n\ti4V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i5V1 is functionally identical to i2V1\n\ti5V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromString(\"http\"))),\n\t\t\t}},\n\t\t},\n\t}\n\t// i6V1 contains two named vhosts which point to the same service\n\t// one of those has TLS\n\ti6V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"two-vhosts\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"b.example.com\"},\n\t\t\t\tSecretName: sec1.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost:             \"a.example.com\",\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromInt(8080))),\n\t\t\t}, {\n\t\t\t\tHost:             \"b.example.com\",\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromString(\"http\"))),\n\t\t\t}},\n\t\t},\n\t}\n\ti6aV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"two-vhosts\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"kubernetes.io/ingress.allow-http\": \"false\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"b.example.com\"},\n\t\t\t\tSecretName: sec1.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost:             \"a.example.com\",\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromInt(8080))),\n\t\t\t}, {\n\t\t\t\tHost:             \"b.example.com\",\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromString(\"http\"))),\n\t\t\t}},\n\t\t},\n\t}\n\n\ti6bV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"two-vhosts\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"ingress.kubernetes.io/force-ssl-redirect\": \"true\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"b.example.com\"},\n\t\t\t\tSecretName: sec1.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost:             \"b.example.com\",\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromString(\"http\"))),\n\t\t\t}},\n\t\t},\n\t}\n\n\ti6cV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"two-vhosts\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"ingress.kubernetes.io/force-ssl-redirect\": \"true\",\n\t\t\t\t\"kubernetes.io/ingress.allow-http\":         \"false\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"b.example.com\"},\n\t\t\t\tSecretName: sec1.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost:             \"b.example.com\",\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromString(\"http\"))),\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i7V1 contains a single vhost with two paths\n\ti7V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"two-paths\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"b.example.com\"},\n\t\t\t\tSecretName: sec1.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost: \"b.example.com\",\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\tPath:    \"/kuarder\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuarder\", intstr.FromInt(8080)),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i8V1 is identical to i7V1 but uses multiple IngressRules\n\ti8V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"two-rules\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"b.example.com\"},\n\t\t\t\tSecretName: sec1.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost: \"b.example.com\",\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\tHost: \"b.example.com\",\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/kuarder\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuarder\", intstr.FromInt(8080)),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\t// i9V1 is identical to i8V1 but disables non TLS connections\n\ti9V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"two-rules\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"kubernetes.io/ingress.allow-http\": \"false\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"b.example.com\"},\n\t\t\t\tSecretName: sec1.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost: \"b.example.com\",\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\tHost: \"b.example.com\",\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/kuarder\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuarder\", intstr.FromInt(8080)),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti10aV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"two-rules\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/tls-minimum-protocol-version\": \"1.3\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"b.example.com\"},\n\t\t\t\tSecretName: sec1.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost: \"b.example.com\",\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i11V1 has a websocket route\n\ti11V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"websocket\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/websocket-routes\": \"/ws1 , /ws2\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\tPath:    \"/ws1\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i12aV1 has an invalid timeout\n\ti12aV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"timeout\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/request-timeout\": \"peanut\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i12bV1 has a reasonable timeout\n\ti12bV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"timeout\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/request-timeout\": \"1m30s\", // 90 seconds y'all\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i12cV1 has an unreasonable timeout\n\ti12cV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"timeout\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/request-timeout\": \"infinite\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{HTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{Path: \"/\",\n\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t}}},\n\t\t\t\t}}}},\n\t}\n\n\ti12dV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"timeout\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/response-timeout\": \"peanut\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti12eV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"timeout\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/response-timeout\": \"1m30s\", // 90 seconds y'all\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti12fV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"timeout\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/response-timeout\": \"infinite\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{HTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{Path: \"/\",\n\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t}}},\n\t\t\t\t}}}},\n\t}\n\n\t// i13_v1 a and b are a pair of ingressesv1 for the same vhost\n\t// they represent a tricky way over 'overlaying' routes from one\n\t// ingress onto another\n\ti13aV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"app\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"ingress.kubernetes.io/force-ssl-redirect\": \"true\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"example.com\"},\n\t\t\t\tSecretName: \"example-tls\",\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost: \"example.com\",\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"app-service\", intstr.FromInt(8080)),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti13bV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{Name: \"challenge\", Namespace: \"nginx-ingress\"},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost: \"example.com\",\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/.well-known/acme-challenge/gVJl5NWL2owUqZekjHkt_bo3OHYC2XNDURRRgLI5JTk\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"challenge-service\", intstr.FromInt(8009)),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti3aV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromInt(80))),\n\t\t\t}},\n\t\t},\n\t}\n\n\ti14V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"timeout\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/retry-on\":        \"gateway-error\",\n\t\t\t\t\"projectcontour.io/num-retries\":     \"6\",\n\t\t\t\t\"projectcontour.io/per-try-timeout\": \"10s\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti15V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"regex\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/[^/]+/invoices(/.*|/?)\", // issue 1243\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti15InvalidRegexV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"regex\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"^\\\\/(?!\\\\/)(.*?)\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti16V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"wildcards\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\t// No hostname.\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\t// Allow wildcard as first label.\n\t\t\t\t// K8s will only allow hostnames with wildcards of this form.\n\t\t\t\tHost: \"*.example.com\",\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti17V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost:             \"example.com\",\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromInt(8080))),\n\t\t\t}},\n\t\t},\n\t}\n\n\tiPathMatchTypesV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"pathmatchtypes\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tPathType: (*networking_v1.PathType)(pointer.StringPtr(\"Exact\")),\n\t\t\t\t\t\t\t\tPath:     \"/exact\",\n\t\t\t\t\t\t\t\tBackend:  *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tPathType: (*networking_v1.PathType)(pointer.StringPtr(\"Exact\")),\n\t\t\t\t\t\t\t\tPath:     \"/exact_with_regex/.*\",\n\t\t\t\t\t\t\t\tBackend:  *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tPathType: (*networking_v1.PathType)(pointer.StringPtr(\"Prefix\")),\n\t\t\t\t\t\t\t\tPath:     \"/prefix\",\n\t\t\t\t\t\t\t\tBackend:  *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tPathType: (*networking_v1.PathType)(pointer.StringPtr(\"Prefix\")),\n\t\t\t\t\t\t\t\tPath:     \"/prefix_trailing_slash/\",\n\t\t\t\t\t\t\t\tBackend:  *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tPathType: (*networking_v1.PathType)(pointer.StringPtr(\"Prefix\")),\n\t\t\t\t\t\t\t\tPath:     \"/prefix_with_regex/.*\",\n\t\t\t\t\t\t\t\tBackend:  *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tPathType: (*networking_v1.PathType)(pointer.StringPtr(\"ImplementationSpecific\")),\n\t\t\t\t\t\t\t\tPath:     \"/implementation_specific\",\n\t\t\t\t\t\t\t\tBackend:  *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tPathType: (*networking_v1.PathType)(pointer.StringPtr(\"ImplementationSpecific\")),\n\t\t\t\t\t\t\t\tPath:     \"/implementation_specific_with_regex/.*\",\n\t\t\t\t\t\t\t\tBackend:  *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// s3a and b have http/2 protocol annotations\n\ts3a := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/upstream-protocol.h2c\": \"80,http\",\n\t\t\t},\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       80,\n\t\t\t\tTargetPort: intstr.FromInt(8888),\n\t\t\t}},\n\t\t},\n\t}\n\n\ts3b := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      s3a.Name,\n\t\t\tNamespace: s3a.Namespace,\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/upstream-protocol.h2\": \"80,http\",\n\t\t\t},\n\t\t},\n\t\tSpec: s3a.Spec,\n\t}\n\n\ts3c := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      s3b.Name,\n\t\t\tNamespace: s3b.Namespace,\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/upstream-protocol.tls\": \"80,http\",\n\t\t\t},\n\t\t},\n\t\tSpec: s3b.Spec,\n\t}\n\n\tsec13 := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-tls\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tType: v1.SecretTypeTLS,\n\t\tData: secretdata(fixture.CERTIFICATE, fixture.RSA_PRIVATE_KEY),\n\t}\n\n\ts13a := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"app-service\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\ts13b := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"challenge-service\",\n\t\t\tNamespace: \"nginx-ingress\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8009,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyMultipleBackends := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}, {\n\t\t\t\t\tName: \"kuarder\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyMinTLS12 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"foo.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName:             sec1.Name,\n\t\t\t\t\tMinimumProtocolVersion: \"1.2\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyMinTLS13 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"foo.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName:             sec1.Name,\n\t\t\t\t\tMinimumProtocolVersion: \"1.3\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyMinTLSInvalid := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"foo.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName:             sec1.Name,\n\t\t\t\t\tMinimumProtocolVersion: \"0.999\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyWeightsTwoRoutesDiffWeights := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/a\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName:   \"kuard\",\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tWeight: 90,\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/b\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName:   \"kuard\",\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tWeight: 60,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyWeightsOneRouteDiffWeights := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/a\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName:   \"kuard\",\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tWeight: 90,\n\t\t\t\t}, {\n\t\t\t\t\tName:   \"kuard\",\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tWeight: 60,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyRetryPolicyValidTimeout := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"bar-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"bar.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tRetryPolicy: &contour_api_v1.RetryPolicy{\n\t\t\t\t\tNumRetries:    6,\n\t\t\t\t\tPerTryTimeout: \"10s\",\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyRetryPolicyInvalidTimeout := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"bar-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"bar.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tRetryPolicy: &contour_api_v1.RetryPolicy{\n\t\t\t\t\tNumRetries:    6,\n\t\t\t\t\tPerTryTimeout: \"please\",\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyRetryPolicyZeroRetries := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"bar-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"bar.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tRetryPolicy: &contour_api_v1.RetryPolicy{\n\t\t\t\t\tNumRetries:    0,\n\t\t\t\t\tPerTryTimeout: \"10s\",\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyTimeoutPolicyInvalidResponse := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"bar-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"bar.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tTimeoutPolicy: &contour_api_v1.TimeoutPolicy{\n\t\t\t\t\tResponse: \"peanut\",\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyTimeoutPolicyValidResponse := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"bar-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"bar.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tTimeoutPolicy: &contour_api_v1.TimeoutPolicy{\n\t\t\t\t\tResponse: \"1m30s\",\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyTimeoutPolicyInfiniteResponse := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"bar-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"bar.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tTimeoutPolicy: &contour_api_v1.TimeoutPolicy{\n\t\t\t\t\tResponse: \"infinite\",\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\ts1 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\t// s1a carries the tls annotation\n\ts1a := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/upstream-protocol.tls\": \"8080\",\n\t\t\t},\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\t// s1b carries all four ingress annotations{\n\ts1b := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/max-connections\":      \"9000\",\n\t\t\t\t\"projectcontour.io/max-pending-requests\": \"4096\",\n\t\t\t\t\"projectcontour.io/max-requests\":         \"404\",\n\t\t\t\t\"projectcontour.io/max-retries\":          \"7\",\n\t\t\t},\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\t// s2 is like s1 but with a different name\n\ts2 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuarder\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\t// s2a is like s1 but with a different name again.\n\t// used in testing override priority.\n\ts2a := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuardest\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\t// s3 is like s1 but has a different port\n\ts3 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       9999,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\ts4 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"blog\",\n\t\t\tNamespace: \"marketing\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\ts9 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"nginx\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tProtocol: \"TCP\",\n\t\t\t\tPort:     80,\n\t\t\t}},\n\t\t},\n\t}\n\n\ts10 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"tls-passthrough\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"https\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       443,\n\t\t\t\tTargetPort: intstr.FromInt(443),\n\t\t\t}, {\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       80,\n\t\t\t\tTargetPort: intstr.FromInt(80),\n\t\t\t}},\n\t\t},\n\t}\n\n\ts11 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"blog\",\n\t\t\tNamespace: \"it\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:     \"blog\",\n\t\t\t\tProtocol: \"TCP\",\n\t\t\t\tPort:     8080,\n\t\t\t}},\n\t\t},\n\t}\n\n\ts12 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"teama\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\ts13 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"teamb\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\ts14 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"nginx\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tExternalName: \"externalservice.io\",\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tProtocol: \"TCP\",\n\t\t\t\tPort:     80,\n\t\t\t}},\n\t\t\tType: v1.ServiceTypeExternalName,\n\t\t},\n\t}\n\n\tproxyDelegatedTLSSecret := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"app-with-tls-delegation\",\n\t\t\tNamespace: s10.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"app-with-tls-delegation.127.0.0.1.nip.io\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: \"projectcontour/ssl-cert\", // not delegated\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s10.Name,\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy1 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy1a tcp forwards traffic to default/kuard:8080 by TLS pass-through it.\n\tproxy1a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard-tcp\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"kuard.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t// proxy1b is a straight HTTP forward, no conditions.\n\tproxy1b := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy1c is a straight forward, with prefix and header conditions.\n\tproxy1c := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:    \"x-request-id\",\n\t\t\t\t\t\tPresent: true,\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tPrefix: \"/kuard\",\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"e-tag\",\n\t\t\t\t\t\tContains: \"abcdef\",\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:        \"x-timeout\",\n\t\t\t\t\t\tNotContains: \"infinity\",\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:  \"digest-auth\",\n\t\t\t\t\t\tExact: \"scott\",\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"digest-password\",\n\t\t\t\t\t\tNotExact: \"tiger\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy1d tcp forwards secure traffic to default/kuard:8080 by TLS pass-through it,\n\t// insecure traffic is 301 upgraded.\n\tproxy1d := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard-tcp\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"kuard.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t// proxy1e tcp forwards secure traffic to default/kuard:8080 by TLS pass-through it,\n\t// insecure traffic is not 301 upgraded because of the permitInsecure: true annotation.\n\tproxy1e := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard-tcp\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"kuard.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tPermitInsecure: true,\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s10.Name,\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s10.Name,\n\t\t\t\t\tPort: 443,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t//proxy1f is identical to proxy1 and ir1, except for a different service.\n\t// Used to test priority when importing ir then httproxy.\n\tproxy1f := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s2a.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy2a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"kubesystem\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:    \"x-request-id\",\n\t\t\t\t\t\tPresent: true,\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:        \"x-timeout\",\n\t\t\t\t\t\tNotContains: \"infinity\",\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:  \"digest-auth\",\n\t\t\t\t\t\tExact: \"scott\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\tName:      \"kuard\",\n\t\t\t\tNamespace: \"default\",\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy2b := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/kuard\",\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"e-tag\",\n\t\t\t\t\t\tContains: \"abcdef\",\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"digest-password\",\n\t\t\t\t\t\tNotExact: \"tiger\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy2c := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tHealthCheckPolicy: &contour_api_v1.HTTPHealthCheckPolicy{\n\t\t\t\t\tPath: \"/healthz\",\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy2d is a proxy with two routes that have the same prefix and a Contains header\n\t// condition on the same header, differing only in the value of the condition.\n\tproxy2d := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{\n\t\t\t\t{\n\t\t\t\t\tConditions: []contour_api_v1.MatchCondition{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\t\t\tName:     \"e-tag\",\n\t\t\t\t\t\t\t\tContains: \"abc\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\t\tPort: 8080,\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tConditions: []contour_api_v1.MatchCondition{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\t\t\tName:     \"e-tag\",\n\t\t\t\t\t\t\t\tContains: \"def\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\t\tPort: 8080,\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t// proxy2e is a proxy with two routes that both have a condition on the same\n\t// header, one using Contains and one using NotContains.\n\tproxy2e := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{\n\t\t\t\t{\n\t\t\t\t\tConditions: []contour_api_v1.MatchCondition{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\t\t\tName:     \"e-tag\",\n\t\t\t\t\t\t\t\tContains: \"abc\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\t\tPort: 8080,\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tConditions: []contour_api_v1.MatchCondition{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\t\t\tName:        \"e-tag\",\n\t\t\t\t\t\t\t\tNotContains: \"abc\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\t\tPort: 8080,\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t// proxy6 has TLS and does not specify min tls version\n\tproxy6 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"foo.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: sec1.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy17 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t\tUpstreamValidation: &contour_api_v1.UpstreamValidation{\n\t\t\t\t\t\tCACertificate: cert1.Name,\n\t\t\t\t\t\tSubjectName:   \"example.com\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\tprotocolh2 := \"h2\"\n\tproxy17h2 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName:     \"kuard\",\n\t\t\t\t\tPort:     8080,\n\t\t\t\t\tProtocol: &protocolh2,\n\t\t\t\t\tUpstreamValidation: &contour_api_v1.UpstreamValidation{\n\t\t\t\t\t\tCACertificate: cert1.Name,\n\t\t\t\t\t\tSubjectName:   \"example.com\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy18 is downstream validation, HTTP route\n\tproxy18 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: sec1.Name,\n\t\t\t\t\tClientValidation: &contour_api_v1.DownstreamValidation{\n\t\t\t\t\t\tCACertificate: cert1.Name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy19 is downstream validation, TCP proxying\n\tproxy19 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: sec1.Name,\n\t\t\t\t\tClientValidation: &contour_api_v1.DownstreamValidation{\n\t\t\t\t\t\tCACertificate: cert1.Name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t// proxy10 has a websocket route\n\tproxy10 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/websocket\",\n\t\t\t\t}},\n\t\t\t\tEnableWebsockets: true,\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy10b has a websocket route w/multiple upstreams\n\tproxy10b := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/websocket\",\n\t\t\t\t}},\n\t\t\t\tEnableWebsockets: true,\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy12 tests mirroring\n\tproxy12 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}, {\n\t\t\t\t\tName:   s2.Name,\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tMirror: true,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy13 has two mirrors, invalid.\n\tproxy13 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}, {\n\t\t\t\t\tName:   s2.Name,\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tMirror: true,\n\t\t\t\t}, {\n\t\t\t\t\t// it is legal to mention a service more that\n\t\t\t\t\t// once, however it is not legal for more than one\n\t\t\t\t\t// service to be marked as mirror.\n\t\t\t\t\tName:   s2.Name,\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tMirror: true,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy20 is downstream validation, skip cert validation\n\tproxy20 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: sec1.Name,\n\t\t\t\t\tClientValidation: &contour_api_v1.DownstreamValidation{\n\t\t\t\t\t\tSkipClientCertValidation: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy21 is downstream validation, skip cert validation, with a CA\n\tproxy21 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: sec1.Name,\n\t\t\t\t\tClientValidation: &contour_api_v1.DownstreamValidation{\n\t\t\t\t\t\tSkipClientCertValidation: true,\n\t\t\t\t\t\tCACertificate:            cert1.Name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// invalid because tcpproxy both includes another and\n\t// has a list of services.\n\tproxy37 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"simple\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"passthrough.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tInclude: &contour_api_v1.TCPProxyInclude{\n\t\t\t\t\tName:      \"foo\",\n\t\t\t\t\tNamespace: \"roots\",\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t// Invalid because tcpproxy neither includes another httpproxy\n\t// nor has a list of services.\n\tproxy37a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"simple\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"passthrough.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{},\n\t\t},\n\t}\n\n\t// proxy38 is invalid when combined with proxy39\n\t// as the latter is a root.\n\tproxy38 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"simple\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"passthrough.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tInclude: &contour_api_v1.TCPProxyInclude{\n\t\t\t\t\tName:      \"foo\",\n\t\t\t\t\tNamespace: s1.Namespace,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tproxy39 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"foo\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"www.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t// proxy39broot is a valid TCPProxy which includes to another TCPProxy\n\tproxy39broot := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"root\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"www.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tInclude: &contour_api_v1.TCPProxyInclude{\n\t\t\t\t\tName:      \"foo\",\n\t\t\t\t\tNamespace: s1.Namespace,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tproxy39brootplural := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"root\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"www.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tIncludesDeprecated: &contour_api_v1.TCPProxyInclude{\n\t\t\t\t\tName:      \"foo\",\n\t\t\t\t\tNamespace: s1.Namespace,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tproxy39bchild := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"foo\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\tproxy40 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"foo\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t// issue 2309, each route must have at least one service\n\tproxy41 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"missing-service\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"missing-service.example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: nil, // missing\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy100 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"marketingwww\",\n\t\t\t\tNamespace: \"marketing\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy100a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"marketingwww\",\n\t\t\tNamespace: \"marketing\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"blog\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy100b := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"marketingwww\",\n\t\t\tNamespace: \"marketing\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/infotech\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"blog\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy100c := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"marketingwww\",\n\t\t\tNamespace: \"marketing\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"marketingit\",\n\t\t\t\tNamespace: \"it\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/it\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/infotech\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"blog\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"blog\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy100d := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"marketingit\",\n\t\t\tNamespace: \"it\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"blog\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy101 and proxy101a test inclusion without a specified namespace.\n\tproxy101 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName: \"kuarder\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/kuarder\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy101a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuarder\",\n\t\t\tNamespace: proxy101.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s2.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// invalid because two prefix conditions on route.\n\tproxy102 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/v1\",\n\t\t\t\t}, {\n\t\t\t\t\tPrefix: \"/api\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// invalid because two prefix conditions on include.\n\tproxy103 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"www\",\n\t\t\t\tNamespace: \"teama\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/v1\",\n\t\t\t\t}, {\n\t\t\t\t\tPrefix: \"/api\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy103a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"www\",\n\t\t\tNamespace: \"teama\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/v1\",\n\t\t\t\t}, {\n\t\t\t\t\tPrefix: \"/api\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy104 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName: \"kuarder\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/kuarder\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy104a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuarder\",\n\t\t\tNamespace: proxy104.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s2.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy105 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName: \"kuarder\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/kuarder\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy105a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuarder\",\n\t\t\tNamespace: proxy105.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s2.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy106 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName: \"kuarder\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/kuarder/\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy106a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuarder\",\n\t\t\tNamespace: proxy105.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s2.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy107 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName: \"kuarder\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/kuarder\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy107a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuarder\",\n\t\t\tNamespace: proxy105.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/withavengeance\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s2.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy108 and proxy108a test duplicate conditions on include\n\tproxy108 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"root\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"blogteama\",\n\t\t\t\tNamespace: \"teama\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"x-header\",\n\t\t\t\t\t\tContains: \"abc\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tName:      \"blogteama\",\n\t\t\t\tNamespace: \"teamb\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"x-header\",\n\t\t\t\t\t\tContains: \"abc\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy108a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"blogteama\",\n\t\t\tNamespace: \"teama\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s12.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy108b := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"blogteamb\",\n\t\t\tNamespace: \"teamb\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s13.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyReplaceHostHeaderRoute := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\tValue: \"bar.com\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyReplaceHostHeaderService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\t\tValue: \"bar.com\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyReplaceHostHeaderMultiple := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\tValue: \"bar.com\",\n\t\t\t\t\t}, {\n\t\t\t\t\t\tName:  \"x-header\",\n\t\t\t\t\t\tValue: \"bar.com\",\n\t\t\t\t\t}, {\n\t\t\t\t\t\tName:  \"y-header\",\n\t\t\t\t\t\tValue: \"zed.com\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyReplaceNonHostHeader := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"x-header\",\n\t\t\t\t\t\tValue: \"bar.com\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyReplaceHeaderEmptyValue := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName: \"x-header\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyCookieLoadBalancer := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tLoadBalancerPolicy: &contour_api_v1.LoadBalancerPolicy{\n\t\t\t\t\tStrategy: \"Cookie\",\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyLoadBalancerHashPolicyHeader := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tLoadBalancerPolicy: &contour_api_v1.LoadBalancerPolicy{\n\t\t\t\t\tStrategy: \"RequestHash\",\n\t\t\t\t\tRequestHashPolicies: []contour_api_v1.RequestHashPolicy{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTerminal: true,\n\t\t\t\t\t\t\tHeaderHashOptions: &contour_api_v1.HeaderHashOptions{\n\t\t\t\t\t\t\t\tHeaderName: \"X-Some-Header\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Lower case but duplicated, should be ignored.\n\t\t\t\t\t\t\tHeaderHashOptions: &contour_api_v1.HeaderHashOptions{\n\t\t\t\t\t\t\t\tHeaderName: \"x-some-header\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHeaderHashOptions: nil,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHeaderHashOptions: &contour_api_v1.HeaderHashOptions{\n\t\t\t\t\t\t\t\tHeaderName: \"X-Some-Other-Header\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHeaderHashOptions: &contour_api_v1.HeaderHashOptions{\n\t\t\t\t\t\t\t\tHeaderName: \"\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyLoadBalancerHashPolicyHeaderAllInvalid := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tLoadBalancerPolicy: &contour_api_v1.LoadBalancerPolicy{\n\t\t\t\t\tStrategy: \"RequestHash\",\n\t\t\t\t\tRequestHashPolicies: []contour_api_v1.RequestHashPolicy{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHeaderHashOptions: nil,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHeaderHashOptions: &contour_api_v1.HeaderHashOptions{\n\t\t\t\t\t\t\t\tHeaderName: \"\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy109 has a route that rewrites headers.\n\tproxy109 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"In-Foo\",\n\t\t\t\t\t\tValue: \"bar\",\n\t\t\t\t\t}},\n\t\t\t\t\tRemove: []string{\n\t\t\t\t\t\t\"In-Baz\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tResponseHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Out-Foo\",\n\t\t\t\t\t\tValue: \"bar\",\n\t\t\t\t\t}},\n\t\t\t\t\tRemove: []string{\n\t\t\t\t\t\t\"Out-Baz\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\t// proxy111 has a route that rewrites headers.\n\tproxy111 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t\tResponseHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\tValue: \"bar.baz\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\t// proxy112 has a route that rewrites headers.\n\tproxy112 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t\tResponseHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\t\tValue: \"bar.baz\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\tprotocol := \"h2c\"\n\tproxy110 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName:     \"kuard\",\n\t\t\t\t\tPort:     8080,\n\t\t\t\t\tProtocol: &protocol,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyExternalNameService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s14.GetName(),\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\ttcpProxyExternalNameService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: sec1.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName:     s14.GetName(),\n\t\t\t\t\tPort:     80,\n\t\t\t\t\tProtocol: pointer.StringPtr(\"tls\"),\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\ttests := map[string]struct {\n\t\tobjs                         []interface{}\n\t\tdisablePermitInsecure        bool\n\t\tfallbackCertificateName      string\n\t\tfallbackCertificateNamespace string\n\t\twant                         []Vertex\n\t}{\n\t\t\"ingressv1: insert ingress w/ default backend w/o matching service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti1V1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ default backend\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti1V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ single unnamed backend w/o matching service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti2V1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ single unnamed backend\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti2V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress with missing spec.rule.http key\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti2aV1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ host name and single backend w/o matching service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti3V1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ host name and single backend\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti3V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"kuard.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert non matching service then ingress w/ default backend\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts2,\n\t\t\t\ti1V1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ default backend then matching service with wrong port\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti1V1,\n\t\t\t\ts3,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert unnamed ingress w/ single backend then matching service with wrong port\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti2V1,\n\t\t\t\ts3,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ default backend then matching service w/ named port\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti4V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert service w/ named port then ingress w/ default backend\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\ti4V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ single unnamed backend w/ named service port then service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti5V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert service then ingress w/ single unnamed backend w/ named service port\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\ti5V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert secret\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert secret then ingress w/o tls\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ti1V1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert service, secret then ingress w/o tls\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\tsec1,\n\t\t\t\ti1V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert secret then ingress w/ tls\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ti3V1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert service, secret then ingress w/ tls\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\tsec1,\n\t\t\t\ti3V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"kuard.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"kuard.example.com\", sec1, prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert service w/ secret with w/ blank ca.crt\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\tsec3, // issue 1644\n\t\t\t\ti3V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"kuard.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"kuard.example.com\", sec3, prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert invalid secret then ingress w/o tls\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tsecInvalid,\n\t\t\t\ti1V1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert service, invalid secret then ingress w/o tls\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\tsecInvalid,\n\t\t\t\ti1V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert invalid secret then ingress w/ tls\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tsecInvalid,\n\t\t\t\ti3V1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert service, invalid secret then ingress w/ tls\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\tsecInvalid,\n\t\t\t\ti3V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"kuard.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ two vhosts\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti6V1,\n\t\t\t},\n\t\t\twant: nil, // no matching service\n\t\t},\n\t\t\"ingressv1: insert ingress w/ two vhosts then matching service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti6V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"a.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t\tvirtualhost(\"b.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert service then ingress w/ two vhosts\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\ti6V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"a.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t\tvirtualhost(\"b.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ two vhosts then service then secret\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti6V1,\n\t\t\t\ts1,\n\t\t\t\tsec1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"a.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t\tvirtualhost(\"b.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"b.example.com\", sec1, prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert service then secret then ingress w/ two vhosts\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\tsec1,\n\t\t\t\ti6V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"a.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t\tvirtualhost(\"b.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"b.example.com\", sec1, prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ two paths then one service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti7V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"b.example.com\",\n\t\t\t\t\t\t\tprefixroute(\"/\", service(s1)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ two paths then services\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti7V1,\n\t\t\t\ts2,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"b.example.com\",\n\t\t\t\t\t\t\tprefixroute(\"/\", service(s1)),\n\t\t\t\t\t\t\tprefixroute(\"/kuarder\", service(s2)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert two services then ingress w/ two ingress rules\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1, s2, i8V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"b.example.com\",\n\t\t\t\t\t\t\tprefixroute(\"/\", service(s1)),\n\t\t\t\t\t\t\tprefixroute(\"/kuarder\", service(s2)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ two paths httpAllowed: false\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti9V1,\n\t\t\t},\n\t\t\twant: []Vertex{},\n\t\t},\n\t\t\"ingressv1: insert ingress w/ two paths httpAllowed: false then tls and service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti9V1,\n\t\t\t\tsec1,\n\t\t\t\ts1, s2,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"b.example.com\", sec1,\n\t\t\t\t\t\t\tprefixroute(\"/\", service(s1)),\n\t\t\t\t\t\t\tprefixroute(\"/kuarder\", service(s2)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert default ingress httpAllowed: false\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti1aV1,\n\t\t\t},\n\t\t\twant: []Vertex{},\n\t\t},\n\t\t\"ingressv1: insert default ingress httpAllowed: false then tls and service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti1aV1, sec1, s1,\n\t\t\t},\n\t\t\twant: []Vertex{}, // default ingress cannot be tls\n\t\t},\n\t\t\"ingressv1: insert ingress w/ two vhosts httpAllowed: false\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti6aV1,\n\t\t\t},\n\t\t\twant: []Vertex{},\n\t\t},\n\t\t\"ingressv1: insert ingress w/ two vhosts httpAllowed: false then tls and service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti6aV1, sec1, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"b.example.com\", sec1, prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ force-ssl-redirect: true\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti6bV1, sec1, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"b.example.com\", routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"b.example.com\", sec1, routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\n\t\t\"ingressv1: insert ingress w/ force-ssl-redirect: true and allow-http: false\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti6cV1, sec1, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"b.example.com\", routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"b.example.com\", sec1, routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with tls version 1.2\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyMinTLS12, s1, sec1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"foo.com\", routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"foo.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes: routes(\n\t\t\t\t\t\t\t\t\trouteUpgrade(\"/\", service(s1)),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.2\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with tls version 1.3\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyMinTLS13, s1, sec1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"foo.com\", routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"foo.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes: routes(\n\t\t\t\t\t\t\t\t\trouteUpgrade(\"/\", service(s1)),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.3\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with invalid tls version\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyMinTLSInvalid, s1, sec1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"foo.com\", routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"foo.com\", sec1, routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy referencing two backends, one missing\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyMultipleBackends, s2,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert httpproxy referencing two backends\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyMultipleBackends, s1, s2,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", prefixroute(\"/\", service(s1), service(s2))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ tls min proto annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti10aV1,\n\t\t\t\tsec1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"b.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"b.example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes: routes(\n\t\t\t\t\t\t\t\t\tprefixroute(\"/\", service(s1)),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.3\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ websocket route annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti11V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\",\n\t\t\t\t\t\t\tprefixroute(\"/\", service(s1)),\n\t\t\t\t\t\t\trouteWebsocket(\"/ws1\", service(s1)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ invalid legacy timeout annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti12aV1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ invalid timeout annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti12dV1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy w/ invalid timeoutpolicy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyTimeoutPolicyInvalidResponse,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ valid legacy timeout annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti12bV1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tTimeoutPolicy: TimeoutPolicy{\n\t\t\t\t\t\t\t\tResponseTimeout: timeout.DurationSetting(90 * time.Second),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ valid timeout annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti12eV1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tTimeoutPolicy: TimeoutPolicy{\n\t\t\t\t\t\t\t\tResponseTimeout: timeout.DurationSetting(90 * time.Second),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy w/ valid timeoutpolicy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyTimeoutPolicyValidResponse,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"bar.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tTimeoutPolicy: TimeoutPolicy{\n\t\t\t\t\t\t\t\tResponseTimeout: timeout.DurationSetting(90 * time.Second),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ legacy infinite timeout annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti12cV1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tTimeoutPolicy: TimeoutPolicy{\n\t\t\t\t\t\t\t\tResponseTimeout: timeout.DisabledSetting(),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ infinite timeout annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti12fV1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tTimeoutPolicy: TimeoutPolicy{\n\t\t\t\t\t\t\t\tResponseTimeout: timeout.DisabledSetting(),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy w/ infinite timeoutpolicy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyTimeoutPolicyInfiniteResponse,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"bar.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tTimeoutPolicy: TimeoutPolicy{\n\t\t\t\t\t\t\t\tResponseTimeout: timeout.DisabledSetting(),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with missing tls delegation should not present port 80\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts10, proxyDelegatedTLSSecret,\n\t\t\t},\n\t\t\twant: listeners(), // no listeners, ir19 is invalid\n\t\t},\n\t\t\"insert httpproxy with retry annotations\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyRetryPolicyValidTimeout,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"bar.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tRetryPolicy: &RetryPolicy{\n\t\t\t\t\t\t\t\tRetryOn:       \"5xx\",\n\t\t\t\t\t\t\t\tNumRetries:    6,\n\t\t\t\t\t\t\t\tPerTryTimeout: timeout.DurationSetting(10 * time.Second),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with invalid PerTryTimeout\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyRetryPolicyInvalidTimeout,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"bar.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tRetryPolicy: &RetryPolicy{\n\t\t\t\t\t\t\t\tRetryOn:       \"5xx\",\n\t\t\t\t\t\t\t\tNumRetries:    6,\n\t\t\t\t\t\t\t\tPerTryTimeout: timeout.DefaultSetting(),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with zero retry count\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyRetryPolicyZeroRetries,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"bar.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tRetryPolicy: &RetryPolicy{\n\t\t\t\t\t\t\t\tRetryOn:       \"5xx\",\n\t\t\t\t\t\t\t\tNumRetries:    1,\n\t\t\t\t\t\t\t\tPerTryTimeout: timeout.DurationSetting(10 * time.Second),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress with timeout policy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti14V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tRetryPolicy: &RetryPolicy{\n\t\t\t\t\t\t\t\tRetryOn:       \"gateway-error\",\n\t\t\t\t\t\t\t\tNumRetries:    6,\n\t\t\t\t\t\t\t\tPerTryTimeout: timeout.DurationSetting(10 * time.Second),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress with regex route\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti15V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: regex(\"/[^/]+/invoices(/.*|/?)\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress with invalid regex route\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti15InvalidRegexV1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert ingress with various path match types\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tiPathMatchTypesV1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\",\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\tPathMatchCondition: exact(\"/exact\"),\n\t\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\tPathMatchCondition: exact(\"/exact_with_regex/.*\"),\n\t\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\tPathMatchCondition: prefixSegment(\"/prefix\"),\n\t\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\t// Trailing slash is stripped.\n\t\t\t\t\t\t\t\tPathMatchCondition: prefixSegment(\"/prefix_trailing_slash\"),\n\t\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\tPathMatchCondition: prefixSegment(\"/prefix_with_regex/.*\"),\n\t\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/implementation_specific\"),\n\t\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\tPathMatchCondition: regex(\"/implementation_specific_with_regex/.*\"),\n\t\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress with wildcard hostnames\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\ti16V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t\tvirtualhost(\"*.example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: &PrefixMatchCondition{Prefix: \"/\"},\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tName:      \":authority\",\n\t\t\t\t\t\t\t\t\tMatchType: HeaderMatchTypeRegex,\n\t\t\t\t\t\t\t\t\tValue:     \"^[a-z0-9]([-a-z0-9]*[a-z0-9])?\\\\.example\\\\.com\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clusters(service(s1)),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress overlay\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti13aV1, i13bV1, sec13, s13a, s13b,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteUpgrade(\"/\", service(s13a)),\n\t\t\t\t\t\t\tprefixroute(\"/.well-known/acme-challenge/gVJl5NWL2owUqZekjHkt_bo3OHYC2XNDURRRgLI5JTk\", service(s13b)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"example.com\", sec13,\n\t\t\t\t\t\t\trouteUpgrade(\"/\", service(s13a)),\n\t\t\t\t\t\t\tprefixroute(\"/.well-known/acme-challenge/gVJl5NWL2owUqZekjHkt_bo3OHYC2XNDURRRgLI5JTk\", service(s13b)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: h2c service annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti3aV1, s3a,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\",\n\t\t\t\t\t\t\tprefixroute(\"/\", &Service{\n\t\t\t\t\t\t\t\tProtocol: \"h2c\",\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\tServiceName:      s3a.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: s3a.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      s3a.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: h2 service annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti3aV1, s3b,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\",\n\t\t\t\t\t\t\tprefixroute(\"/\", &Service{\n\t\t\t\t\t\t\t\tProtocol: \"h2\",\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\tServiceName:      s3b.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: s3b.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      s3b.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: tls service annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti3aV1, s3c,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\",\n\t\t\t\t\t\t\tprefixroute(\"/\", &Service{\n\t\t\t\t\t\t\t\tProtocol: \"tls\",\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\tServiceName:      s3c.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: s3c.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      s3c.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress then service w/ upstream annotations\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti1V1,\n\t\t\t\ts1b,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\",\n\t\t\t\t\t\t\tprefixroute(\"/\", &Service{\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\tServiceName:      s1b.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: s1b.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      s1b.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tMaxConnections:     9000,\n\t\t\t\t\t\t\t\tMaxPendingRequests: 4096,\n\t\t\t\t\t\t\t\tMaxRequests:        404,\n\t\t\t\t\t\t\t\tMaxRetries:         7,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with two routes to the same service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyWeightsTwoRoutesDiffWeights, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/a\", &Cluster{\n\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tWeight: 90,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\trouteCluster(\"/b\", &Cluster{\n\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tWeight: 60,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with one routes to the same service with two different weights\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyWeightsOneRouteDiffWeights, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/a\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tWeight: 90,\n\t\t\t\t\t\t\t\t}, &Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tWeight: 60,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httproxy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy1, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httproxy w/o condition\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy1b, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httproxy with invalid include\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tName:      \"example-com\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\t\t\t\tPrefix: \"/finance\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tName:      \"non-existent\",\n\t\t\t\t\t\t\tNamespace: \"non-existent\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: nil, // no listener created\n\t\t},\n\t\t\"insert httproxy w/ conditions\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy1c, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/kuard\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \"x-request-id\", MatchType: \"present\"},\n\t\t\t\t\t\t\t\t{Name: \"e-tag\", Value: \"abcdef\", MatchType: \"contains\"},\n\t\t\t\t\t\t\t\t{Name: \"x-timeout\", Value: \"infinity\", MatchType: \"contains\", Invert: true},\n\t\t\t\t\t\t\t\t{Name: \"digest-auth\", Value: \"scott\", MatchType: \"exact\"},\n\t\t\t\t\t\t\t\t{Name: \"digest-password\", Value: \"tiger\", MatchType: \"exact\", Invert: true},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clusters(service(s1)),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httproxy w/ multiple routes with a Contains condition on the same header\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy2d, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \"e-tag\", Value: \"abc\", MatchType: \"contains\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clusters(service(s1)),\n\t\t\t\t\t\t}, &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \"e-tag\", Value: \"def\", MatchType: \"contains\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clusters(service(s1)),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httproxy w/ multiple routes with condition on the same header, one Contains and one NotContains\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy2e, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \"e-tag\", Value: \"abc\", MatchType: \"contains\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clusters(service(s1)),\n\t\t\t\t\t\t}, &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \"e-tag\", Value: \"abc\", MatchType: \"contains\", Invert: true},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clusters(service(s1)),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httproxy w/ included conditions\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy2a, proxy2b, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/kuard\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \"x-request-id\", MatchType: \"present\"},\n\t\t\t\t\t\t\t\t{Name: \"x-timeout\", Value: \"infinity\", MatchType: \"contains\", Invert: true},\n\t\t\t\t\t\t\t\t{Name: \"digest-auth\", Value: \"scott\", MatchType: \"exact\"},\n\t\t\t\t\t\t\t\t{Name: \"e-tag\", Value: \"abcdef\", MatchType: \"contains\"},\n\t\t\t\t\t\t\t\t{Name: \"digest-password\", Value: \"tiger\", MatchType: \"exact\", Invert: true},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clusters(service(s1)),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy w/ healthcheck\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy2c, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\", &Cluster{\n\t\t\t\t\t\t\t\tUpstream: service(s1),\n\t\t\t\t\t\t\t\tHTTPHealthCheckPolicy: &HTTPHealthCheckPolicy{\n\t\t\t\t\t\t\t\t\tPath: \"/healthz\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with mirroring route\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy12, s1, s2,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\twithMirror(prefixroute(\"/\", service(s1)), service(s2)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with two mirrors\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy13, s1, s2,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert httpproxy with websocket route and prefix rewrite\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy10, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\tprefixroute(\"/\", service(s1)),\n\t\t\t\t\t\t\trouteWebsocket(\"/websocket\", service(s1)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with multiple upstreams prefix rewrite route and websockets along one path\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy10b, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\tprefixroute(\"/\", service(s1)),\n\t\t\t\t\t\t\trouteWebsocket(\"/websocket\", service(s1)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\n\t\t\"insert httpproxy with protocol and service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy110, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteProtocol(\"/\", protocol, service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\n\t\t\"insert httpproxy without tls version\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy6, s1, sec1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"foo.com\", routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"foo.com\", sec1, routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy expecting upstream verification\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tcert1, proxy17, s1a,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tProtocol: \"tls\",\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1a.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1a.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1a.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tProtocol: \"tls\",\n\t\t\t\t\t\t\t\t\tUpstreamValidation: &PeerValidationContext{\n\t\t\t\t\t\t\t\t\t\tCACertificate: secret(cert1),\n\t\t\t\t\t\t\t\t\t\tSubjectName:   \"example.com\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with h2 expecting upstream verification\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tcert1, proxy17h2, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1a.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1a.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1a.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tProtocol: \"h2\",\n\t\t\t\t\t\t\t\t\tUpstreamValidation: &PeerValidationContext{\n\t\t\t\t\t\t\t\t\t\tCACertificate: secret(cert1),\n\t\t\t\t\t\t\t\t\t\tSubjectName:   \"example.com\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy expecting upstream verification, no certificate\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy17, s1a,\n\t\t\t},\n\t\t\twant: listeners(), //no listeners, missing certificate\n\t\t},\n\t\t\"insert httpproxy expecting upstream verification, no annotation on service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tcert1, proxy17, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\tprefixroute(\"/\", service(s1)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with downstream verification\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tcert1, proxy18, s1, sec1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes: routes(\n\t\t\t\t\t\t\t\t\trouteUpgrade(\"/\", service(s1))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.2\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t\tDownstreamValidation: &PeerValidationContext{\n\t\t\t\t\t\t\t\tCACertificate: &Secret{Object: cert1},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy w/ tcpproxy in tls termination mode w/ downstream verification\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tcert1, proxy19, s1, sec1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(\n\t\t\t\t\t\t\t\t\tservice(s1),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.2\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t\tDownstreamValidation: &PeerValidationContext{\n\t\t\t\t\t\t\t\tCACertificate: &Secret{Object: cert1},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy w/ tls termination mode w/ skip cert verification\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy20, s1, sec1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes: routes(\n\t\t\t\t\t\t\t\t\trouteUpgrade(\"/\", service(s1))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.2\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t\tDownstreamValidation: &PeerValidationContext{\n\t\t\t\t\t\t\t\tSkipClientCertValidation: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy w/ tls termination mode w/ skip cert verification and a ca\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy21, s1, sec1, cert1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes: routes(\n\t\t\t\t\t\t\t\t\trouteUpgrade(\"/\", service(s1))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.2\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t\tDownstreamValidation: &PeerValidationContext{\n\t\t\t\t\t\t\t\tSkipClientCertValidation: true,\n\t\t\t\t\t\t\t\tCACertificate:            &Secret{Object: cert1},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with downstream verification, missing ca certificate\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy18, s1, sec1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert httpproxy with invalid tcpproxy\": {\n\t\t\tobjs: []interface{}{proxy37, s1},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert httpproxy with empty tcpproxy\": {\n\t\t\tobjs: []interface{}{proxy37a, s1},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert httpproxy w/ tcpproxy w/ missing include\": {\n\t\t\tobjs: []interface{}{proxy38, s1},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert httpproxy w/ tcpproxy w/ includes another root\": {\n\t\t\tobjs: []interface{}{proxy38, proxy39, s1},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"www.example.com\", // this is proxy39, not proxy38\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(\n\t\t\t\t\t\t\t\t\tservice(s1),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy w/tcpproxy w/include\": {\n\t\t\tobjs: []interface{}{proxy39broot, proxy39bchild, s1},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"www.example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(\n\t\t\t\t\t\t\t\t\tservice(s1),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// Issue #2218\n\t\t\"insert httpproxy w/tcpproxy w/include plural\": {\n\t\t\tobjs: []interface{}{proxy39brootplural, proxy39bchild, s1},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"www.example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(\n\t\t\t\t\t\t\t\t\tservice(s1),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy w/ tcpproxy w/ includes valid child\": {\n\t\t\tobjs: []interface{}{proxy38, proxy40, s1},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"passthrough.example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(\n\t\t\t\t\t\t\t\t\tservice(s1),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httproxy w/ route w/ no services\": {\n\t\t\tobjs: []interface{}{proxy41, s1},\n\t\t\twant: listeners(), // expect empty, route is invalid so vhost is invalid\n\t\t},\n\t\t\"insert httpproxy with pathPrefix include\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy100, proxy100a, s1, s4,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trouteCluster(\"/blog\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s4.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s4.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s4.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with pathPrefix include, child adds to pathPrefix\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy100, proxy100b, s1, s4,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/blog/infotech\"),\n\t\t\t\t\t\t\t\tClusters: []*Cluster{{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s4.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s4.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s4.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with pathPrefix include, child adds to pathPrefix, delegates again\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy100, proxy100c, proxy100d, s1, s4, s11,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/blog/infotech\"),\n\t\t\t\t\t\t\t\tClusters: []*Cluster{{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s4.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s4.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s4.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trouteCluster(\"/blog\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s4.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s4.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s4.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/blog/it/foo\"),\n\t\t\t\t\t\t\t\tClusters: []*Cluster{{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s11.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s11.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s11.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with no namespace for include\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy101, proxy101a, s1, s2,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trouteCluster(\"/kuarder\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s2.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s2.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s2.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with include, no prefix condition on included proxy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy104, proxy104a, s1, s2,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trouteCluster(\"/kuarder\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s2.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s2.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s2.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with include, / on included proxy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy105, proxy105a, s1, s2,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trouteCluster(\"/kuarder/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s2.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s2.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s2.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with include, full prefix on included proxy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy107, proxy107a, s1, s2,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trouteCluster(\"/kuarder/withavengeance\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s2.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s2.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s2.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with include ending with /, / on included proxy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy106, proxy106a, s1, s2,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trouteCluster(\"/kuarder/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s2.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s2.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s2.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with multiple prefix conditions on route\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy102, s1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert httpproxy with multiple prefix conditions on include\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy103, proxy103a, s1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert httpproxy duplicate conditions on include\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy108, proxy108a, proxy108b, s1, s12, s13,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert proxy with tcp forward without TLS termination w/ passthrough\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy1a, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"kuard.example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(\n\t\t\t\t\t\t\t\t\tservice(s1),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// issue 1952\n\t\t\"insert proxy with tcp forward without TLS termination w/ passthrough and 301 upgrade of port 80\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy1d, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"kuard.example.com\",\n\t\t\t\t\t\t\trouteUpgrade(\"/\", service(s1)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"kuard.example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(\n\t\t\t\t\t\t\t\t\tservice(s1),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert proxy with tcp forward without TLS termination w/ passthrough without 301 upgrade of port 80\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy1e, s10,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"kuard.example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s10.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s10.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s10.Spec.Ports[1],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"kuard.example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(\n\t\t\t\t\t\t\t\t\tservice(s10),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"\", // tls passthrough does not specify a TLS version; that's the domain of the backend\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with route-level header manipulation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy109, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteHeaders(\"/\", map[string]string{\n\t\t\t\t\t\t\t\t\"In-Foo\": \"bar\",\n\t\t\t\t\t\t\t}, []string{\"In-Baz\"}, map[string]string{\n\t\t\t\t\t\t\t\t\"Out-Foo\": \"bar\",\n\t\t\t\t\t\t\t}, []string{\"Out-Baz\"}, service(s1)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\n\t\t// issue 1399\n\t\t\"service shared across ingress and httpproxy tcpproxy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\t&networking_v1.Ingress{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: networking_v1.IngressSpec{\n\t\t\t\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\t\t\t\tHosts:      []string{\"example.com\"},\n\t\t\t\t\t\t\tSecretName: s1.Name,\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\t\t\t\tHost:             \"example.com\",\n\t\t\t\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(s9.Name, intstr.FromInt(80))),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName: sec1.Name,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: s9.Name,\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", prefixroute(\"/\", service(s9))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.2\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(s9)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// issue 1954\n\t\t\"httpproxy tcpproxy + permitinsecure\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName: sec1.Name,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tPermitInsecure: true,\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: s9.Name,\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: s9.Name,\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t// not upgraded because the route is permitInsecure: true\n\t\t\t\t\t\tvirtualhost(\"example.com\", prefixroute(\"/\", service(s9))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.2\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(s9)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// issue 1954\n\t\t\"httpproxy tcpproxy + tlspassthrough + permitinsecure\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts9,\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tPassthrough: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tPermitInsecure: true,\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: s9.Name,\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: s9.Name,\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t// not upgraded because the route is permitInsecure: true\n\t\t\t\t\t\tvirtualhost(\"example.com\", prefixroute(\"/\", service(s9))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"\",\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(s9)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: Ingress then HTTPProxy with identical details, except referencing s2a\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti17V1,\n\t\t\t\tproxy1f,\n\t\t\t\ts1,\n\t\t\t\ts2a,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", prefixroute(\"/\", service(s2a))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert proxy with externalName service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyExternalNameService,\n\t\t\t\ts14,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters: []*Cluster{{\n\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\tExternalName: \"externalservice.io\",\n\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\tServiceName:      s14.Name,\n\t\t\t\t\t\t\t\t\t\tServiceNamespace: s14.Namespace,\n\t\t\t\t\t\t\t\t\t\tServicePort:      s14.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tSNI: \"externalservice.io\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert tcp proxy with externalName service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ttcpProxyExternalNameService,\n\t\t\t\ts14,\n\t\t\t\tsec1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: []*Cluster{{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tExternalName: \"externalservice.io\",\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s14.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s14.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s14.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tProtocol: \"tls\",\n\t\t\t\t\t\t\t\t\tSNI:      \"externalservice.io\",\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.2\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert proxy with replace header policy - route - host header\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyReplaceHostHeaderRoute,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters: []*Cluster{{\n\t\t\t\t\t\t\t\tUpstream: service(s9),\n\t\t\t\t\t\t\t\tSNI:      \"bar.com\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tRequestHeadersPolicy: &HeadersPolicy{\n\t\t\t\t\t\t\t\tHostRewrite: \"bar.com\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert proxy with replace header policy - route - host header - externalName\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyReplaceHostHeaderRoute,\n\t\t\t\ts14,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters: []*Cluster{{\n\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\tExternalName: \"externalservice.io\",\n\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\tServiceName:      s14.Name,\n\t\t\t\t\t\t\t\t\t\tServiceNamespace: s14.Namespace,\n\t\t\t\t\t\t\t\t\t\tServicePort:      s14.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tSNI: \"bar.com\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tRequestHeadersPolicy: &HeadersPolicy{\n\t\t\t\t\t\t\t\tHostRewrite: \"bar.com\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert proxy with replace header policy - service - host header\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyReplaceHostHeaderService,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert proxy with replace header policy - service - host header - externalName\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyReplaceHostHeaderService,\n\t\t\t\ts14,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert proxy with response header policy - route - host header\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy111,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert proxy with response header policy - service - host header\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy112,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert proxy with replace header policy - host header multiple\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyReplaceHostHeaderMultiple,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters: []*Cluster{{\n\t\t\t\t\t\t\t\tUpstream: service(s9),\n\t\t\t\t\t\t\t\tSNI:      \"bar.com\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tRequestHeadersPolicy: &HeadersPolicy{\n\t\t\t\t\t\t\t\tHostRewrite: \"bar.com\",\n\t\t\t\t\t\t\t\tSet: map[string]string{\n\t\t\t\t\t\t\t\t\t\"X-Header\": \"bar.com\",\n\t\t\t\t\t\t\t\t\t\"Y-Header\": \"zed.com\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert proxy with request headers policy - not host header\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyReplaceNonHostHeader,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s9),\n\t\t\t\t\t\t\tRequestHeadersPolicy: &HeadersPolicy{\n\t\t\t\t\t\t\t\tSet: map[string]string{\n\t\t\t\t\t\t\t\t\t\"X-Header\": \"bar.com\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert proxy with request headers policy - empty value\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyReplaceHeaderEmptyValue,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s9),\n\t\t\t\t\t\t\tRequestHeadersPolicy: &HeadersPolicy{\n\t\t\t\t\t\t\t\tSet: map[string]string{\n\t\t\t\t\t\t\t\t\t\"X-Header\": \"\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert proxy with cookie load balancing strategy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyCookieLoadBalancer,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters: []*Cluster{\n\t\t\t\t\t\t\t\t{Upstream: service(s9), LoadBalancerPolicy: \"Cookie\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRequestHashPolicies: []RequestHashPolicy{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tCookieHashOptions: &CookieHashOptions{\n\t\t\t\t\t\t\t\t\t\tCookieName: \"X-Contour-Session-Affinity\",\n\t\t\t\t\t\t\t\t\t\tTTL:        time.Duration(0),\n\t\t\t\t\t\t\t\t\t\tPath:       \"/\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert proxy with load balancer request header hash policies\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyLoadBalancerHashPolicyHeader,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters: []*Cluster{\n\t\t\t\t\t\t\t\t{Upstream: service(s9), LoadBalancerPolicy: \"RequestHash\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRequestHashPolicies: []RequestHashPolicy{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tTerminal: true,\n\t\t\t\t\t\t\t\t\tHeaderHashOptions: &HeaderHashOptions{\n\t\t\t\t\t\t\t\t\t\tHeaderName: \"X-Some-Header\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tHeaderHashOptions: &HeaderHashOptions{\n\t\t\t\t\t\t\t\t\t\tHeaderName: \"X-Some-Other-Header\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert proxy with all invalid request header hash policies\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyLoadBalancerHashPolicyHeaderAllInvalid,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters: []*Cluster{\n\t\t\t\t\t\t\t\t{Upstream: service(s9), LoadBalancerPolicy: \"RoundRobin\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"httpproxy with fallback certificate enabled\": {\n\t\t\tfallbackCertificateName:      \"fallbacksecret\",\n\t\t\tfallbackCertificateNamespace: \"default\",\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\tfallbackCertificateSecret,\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName:                sec1.Name,\n\t\t\t\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion:       \"1.2\",\n\t\t\t\t\t\t\tSecret:              secret(sec1),\n\t\t\t\t\t\t\tFallbackCertificate: secret(fallbackCertificateSecret),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"httpproxy with fallback certificate enabled - cert delegation not configured\": {\n\t\t\tfallbackCertificateName:      \"fallbacksecret\",\n\t\t\tfallbackCertificateNamespace: \"root\",\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec4,\n\t\t\t\ts9,\n\t\t\t\tfallbackCertificateSecret,\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName:                sec1.Name,\n\t\t\t\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"httpproxy with fallback certificate enabled - cert delegation configured all namespaces\": {\n\t\t\tfallbackCertificateName:      \"fallbacksecret\",\n\t\t\tfallbackCertificateNamespace: \"root\",\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\tfallbackCertificateSecretRootNamespace,\n\t\t\t\t&contour_api_v1.TLSCertificateDelegation{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"fallbackcertdelegation\",\n\t\t\t\t\t\tNamespace: \"root\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.TLSCertificateDelegationSpec{\n\t\t\t\t\t\tDelegations: []contour_api_v1.CertificateDelegation{{\n\t\t\t\t\t\t\tSecretName:       \"fallbacksecret\",\n\t\t\t\t\t\t\tTargetNamespaces: []string{\"*\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName:                sec1.Name,\n\t\t\t\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion:       \"1.2\",\n\t\t\t\t\t\t\tSecret:              secret(sec1),\n\t\t\t\t\t\t\tFallbackCertificate: secret(fallbackCertificateSecretRootNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"httpproxy with fallback certificate enabled - cert delegation configured single namespaces\": {\n\t\t\tfallbackCertificateName:      \"fallbacksecret\",\n\t\t\tfallbackCertificateNamespace: \"root\",\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\tfallbackCertificateSecretRootNamespace,\n\t\t\t\t&contour_api_v1.TLSCertificateDelegation{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"fallbackcertdelegation\",\n\t\t\t\t\t\tNamespace: \"root\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.TLSCertificateDelegationSpec{\n\t\t\t\t\t\tDelegations: []contour_api_v1.CertificateDelegation{{\n\t\t\t\t\t\t\tSecretName:       \"fallbacksecret\",\n\t\t\t\t\t\t\tTargetNamespaces: []string{\"default\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName:                sec1.Name,\n\t\t\t\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion:       \"1.2\",\n\t\t\t\t\t\t\tSecret:              secret(sec1),\n\t\t\t\t\t\t\tFallbackCertificate: secret(fallbackCertificateSecretRootNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"httpproxy with fallback certificate enabled - no tls secret\": {\n\t\t\tfallbackCertificateName:      \"fallbacksecret\",\n\t\t\tfallbackCertificateNamespace: \"default\",\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\tfallbackCertificateSecret,\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t\"httpproxy with fallback certificate enabled along with ClientValidation\": {\n\t\t\tfallbackCertificateName:      \"fallbacksecret\",\n\t\t\tfallbackCertificateNamespace: \"default\",\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\tfallbackCertificateSecret,\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t\t\t\t\tClientValidation: &contour_api_v1.DownstreamValidation{\n\t\t\t\t\t\t\t\t\tCACertificate: cert1.Name,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t\"httpproxy with fallback certificate enabled - another not enabled\": {\n\t\t\tfallbackCertificateName:      \"fallbacksecret\",\n\t\t\tfallbackCertificateNamespace: \"default\",\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\tfallbackCertificateSecret,\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName:                sec1.Name,\n\t\t\t\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx-disabled\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"projectcontour.io\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName:                sec1.Name,\n\t\t\t\t\t\t\t\tEnableFallbackCertificate: false,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t\tvirtualhost(\"projectcontour.io\", routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion:       \"1.2\",\n\t\t\t\t\t\t\tSecret:              secret(sec1),\n\t\t\t\t\t\t\tFallbackCertificate: secret(fallbackCertificateSecret),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion:       \"1.2\",\n\t\t\t\t\t\t\tSecret:              secret(sec1),\n\t\t\t\t\t\t\tFallbackCertificate: nil,\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"httpproxy with fallback certificate enabled - bad fallback cert\": {\n\t\t\tfallbackCertificateName:      \"fallbacksecret\",\n\t\t\tfallbackCertificateNamespace: \"badnamespaces\",\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\tfallbackCertificateSecret,\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName: sec1.Name,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion:       \"1.2\",\n\t\t\t\t\t\t\tSecret:              secret(sec1),\n\t\t\t\t\t\t\tFallbackCertificate: nil,\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"httpproxy with fallback certificate disabled - fallback cert specified\": {\n\t\t\tfallbackCertificateName:      \"fallbacksecret\",\n\t\t\tfallbackCertificateNamespace: \"default\",\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\tfallbackCertificateSecret,\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName:                sec1.Name,\n\t\t\t\t\t\t\t\tEnableFallbackCertificate: false,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion:       \"1.2\",\n\t\t\t\t\t\t\tSecret:              secret(sec1),\n\t\t\t\t\t\t\tFallbackCertificate: nil,\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t}\n\n\tfor name, tc := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tbuilder := Builder{\n\t\t\t\tSource: KubernetesCache{\n\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t},\n\t\t\t\tProcessors: []Processor{\n\t\t\t\t\t&IngressProcessor{\n\t\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t\t},\n\t\t\t\t\t&HTTPProxyProcessor{\n\t\t\t\t\t\tDisablePermitInsecure: tc.disablePermitInsecure,\n\t\t\t\t\t\tFallbackCertificate: &types.NamespacedName{\n\t\t\t\t\t\t\tName:      tc.fallbackCertificateName,\n\t\t\t\t\t\t\tNamespace: tc.fallbackCertificateNamespace,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t&ListenerProcessor{},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, o := range tc.objs {\n\t\t\t\tbuilder.Source.Insert(o)\n\t\t\t}\n\t\t\tdag := builder.Build()\n\n\t\t\tgot := make(map[int]*Listener)\n\t\t\tdag.Visit(listenerMap(got).Visit)\n\n\t\t\twant := make(map[int]*Listener)\n\t\t\tfor _, v := range tc.want {\n\t\t\t\tif l, ok := v.(*Listener); ok {\n\t\t\t\t\twant[l.Port] = l\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert.Equal(t, want, got)\n\t\t})\n\t}\n}\n\ntype listenerMap map[int]*Listener\n\nfunc (lm listenerMap) Visit(v Vertex) {\n\tif l, ok := v.(*Listener); ok {\n\t\tlm[l.Port] = l\n\t}\n}\n\nfunc backendv1(name string, port intstr.IntOrString) *networking_v1.IngressBackend {\n\n\tvar v1port networking_v1.ServiceBackendPort\n\n\tswitch port.Type {\n\tcase intstr.Int:\n\t\tv1port = networking_v1.ServiceBackendPort{\n\t\t\tNumber: port.IntVal,\n\t\t}\n\tcase intstr.String:\n\t\tv1port = networking_v1.ServiceBackendPort{\n\t\t\tName: port.StrVal,\n\t\t}\n\t}\n\n\treturn &networking_v1.IngressBackend{\n\t\tService: &networking_v1.IngressServiceBackend{\n\t\t\tName: name,\n\t\t\tPort: v1port,\n\t\t},\n\t}\n}\n\nfunc ingressrulev1value(backend *networking_v1.IngressBackend) networking_v1.IngressRuleValue {\n\treturn networking_v1.IngressRuleValue{\n\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\tBackend: *backend,\n\t\t\t}},\n\t\t},\n\t}\n}\n\nfunc TestDAGRootNamespaces(t *testing.T) {\n\tproxy1 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"allowed1\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy2 is like proxy1, but in a different namespace\n\tproxy2 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"allowed2\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example2.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\ts2 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"allowed1\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:     \"http\",\n\t\t\t\tProtocol: \"TCP\",\n\t\t\t\tPort:     8080,\n\t\t\t}},\n\t\t},\n\t}\n\n\ts3 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"allowed2\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:     \"http\",\n\t\t\t\tProtocol: \"TCP\",\n\t\t\t\tPort:     8080,\n\t\t\t}},\n\t\t},\n\t}\n\n\ttests := map[string]struct {\n\t\trootNamespaces []string\n\t\tobjs           []interface{}\n\t\twant           int\n\t}{\n\t\t\"nil root httpproxy namespaces\": {\n\t\t\tobjs: []interface{}{proxy1, s2},\n\t\t\twant: 1,\n\t\t},\n\t\t\"empty root httpproxy namespaces\": {\n\t\t\tobjs: []interface{}{proxy1, s2},\n\t\t\twant: 1,\n\t\t},\n\t\t\"single root namespace with root httpproxy\": {\n\t\t\trootNamespaces: []string{\"allowed1\"},\n\t\t\tobjs:           []interface{}{proxy1, s2},\n\t\t\twant:           1,\n\t\t},\n\t\t\"multiple root namespaces, one with a root httpproxy\": {\n\t\t\trootNamespaces: []string{\"foo\", \"allowed1\", \"bar\"},\n\t\t\tobjs:           []interface{}{proxy1, s2},\n\t\t\twant:           1,\n\t\t},\n\t\t\"multiple root namespaces, each with a root httpproxy\": {\n\t\t\trootNamespaces: []string{\"foo\", \"allowed1\", \"allowed2\"},\n\t\t\tobjs:           []interface{}{proxy1, proxy2, s2, s3},\n\t\t\twant:           2,\n\t\t},\n\t\t\"root httpproxy defined outside single root namespaces\": {\n\t\t\trootNamespaces: []string{\"foo\"},\n\t\t\tobjs:           []interface{}{proxy1},\n\t\t\twant:           0,\n\t\t},\n\t\t\"root httpproxy defined outside multiple root namespaces\": {\n\t\t\trootNamespaces: []string{\"foo\", \"bar\"},\n\t\t\tobjs:           []interface{}{proxy1},\n\t\t\twant:           0,\n\t\t},\n\t\t\"two root httpproxy, one inside root namespace, one outside\": {\n\t\t\trootNamespaces: []string{\"foo\", \"allowed2\"},\n\t\t\tobjs:           []interface{}{proxy1, proxy2, s3},\n\t\t\twant:           1,\n\t\t},\n\t}\n\n\tfor name, tc := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tbuilder := Builder{\n\t\t\t\tSource: KubernetesCache{\n\t\t\t\t\tRootNamespaces: tc.rootNamespaces,\n\t\t\t\t\tFieldLogger:    fixture.NewTestLogger(t),\n\t\t\t\t},\n\t\t\t\tProcessors: []Processor{\n\t\t\t\t\t&IngressProcessor{\n\t\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t\t},\n\t\t\t\t\t&HTTPProxyProcessor{},\n\t\t\t\t\t&ListenerProcessor{},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, o := range tc.objs {\n\t\t\t\tbuilder.Source.Insert(o)\n\t\t\t}\n\t\t\tdag := builder.Build()\n\n\t\t\tvar count int\n\t\t\tdag.Visit(func(v Vertex) {\n\t\t\t\tv.Visit(func(v Vertex) {\n\t\t\t\t\tif _, ok := v.(*VirtualHost); ok {\n\t\t\t\t\t\tcount++\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\n\t\t\tif tc.want != count {\n\t\t\t\tt.Errorf(\"wanted %d vertices, but got %d\", tc.want, count)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestHttpPaths(t *testing.T) {\n\ttests := map[string]struct {\n\t\trule networking_v1.IngressRule\n\t\twant []networking_v1.HTTPIngressPath\n\t}{\n\t\t\"zero value\": {\n\t\t\trule: networking_v1.IngressRule{},\n\t\t\twant: nil,\n\t\t},\n\t\t\"empty paths\": {\n\t\t\trule: networking_v1.IngressRule{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t\"several paths\": {\n\t\t\trule: networking_v1.IngressRule{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\tPath:    \"/kuarder\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuarder\", intstr.FromInt(8080)),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []networking_v1.HTTPIngressPath{{\n\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t}, {\n\t\t\t\tPath:    \"/kuarder\",\n\t\t\t\tBackend: *backendv1(\"kuarder\", intstr.FromInt(8080)),\n\t\t\t}},\n\t\t},\n\t}\n\n\tfor name, tc := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tgot := httppaths(tc.rule)\n\t\t\tassert.Equal(t, tc.want, got)\n\t\t})\n\t}\n}\n\nfunc TestDetermineSNI(t *testing.T) {\n\ttests := map[string]struct {\n\t\trouteRequestHeaders   *HeadersPolicy\n\t\tclusterRequestHeaders *HeadersPolicy\n\t\tservice               *Service\n\t\twant                  string\n\t}{\n\t\t\"default SNI\": {\n\t\t\trouteRequestHeaders:   nil,\n\t\t\tclusterRequestHeaders: nil,\n\t\t\tservice:               &Service{},\n\t\t\twant:                  \"\",\n\t\t},\n\t\t\"route request headers set\": {\n\t\t\trouteRequestHeaders: &HeadersPolicy{\n\t\t\t\tHostRewrite: \"containersteve.com\",\n\t\t\t},\n\t\t\tclusterRequestHeaders: nil,\n\t\t\tservice:               &Service{},\n\t\t\twant:                  \"containersteve.com\",\n\t\t},\n\t\t\"service request headers set\": {\n\t\t\trouteRequestHeaders: nil,\n\t\t\tclusterRequestHeaders: &HeadersPolicy{\n\t\t\t\tHostRewrite: \"containersteve.com\",\n\t\t\t},\n\t\t\tservice: &Service{},\n\t\t\twant:    \"containersteve.com\",\n\t\t},\n\t\t\"service request headers set overrides route\": {\n\t\t\trouteRequestHeaders: &HeadersPolicy{\n\t\t\t\tHostRewrite: \"incorrect.com\",\n\t\t\t},\n\t\t\tclusterRequestHeaders: &HeadersPolicy{\n\t\t\t\tHostRewrite: \"containersteve.com\",\n\t\t\t},\n\t\t\tservice: &Service{},\n\t\t\twant:    \"containersteve.com\",\n\t\t},\n\t\t\"route request headers override externalName\": {\n\t\t\trouteRequestHeaders: &HeadersPolicy{\n\t\t\t\tHostRewrite: \"containersteve.com\",\n\t\t\t},\n\t\t\tclusterRequestHeaders: nil,\n\t\t\tservice: &Service{\n\t\t\t\tExternalName: \"externalname.com\",\n\t\t\t},\n\t\t\twant: \"containersteve.com\",\n\t\t},\n\t\t\"service request headers override externalName\": {\n\t\t\trouteRequestHeaders: nil,\n\t\t\tclusterRequestHeaders: &HeadersPolicy{\n\t\t\t\tHostRewrite: \"containersteve.com\",\n\t\t\t},\n\t\t\tservice: &Service{\n\t\t\t\tExternalName: \"externalname.com\",\n\t\t\t},\n\t\t\twant: \"containersteve.com\",\n\t\t},\n\t\t\"only externalName set\": {\n\t\t\trouteRequestHeaders:   nil,\n\t\t\tclusterRequestHeaders: nil,\n\t\t\tservice: &Service{\n\t\t\t\tExternalName: \"externalname.com\",\n\t\t\t},\n\t\t\twant: \"externalname.com\",\n\t\t},\n\t}\n\n\tfor name, tc := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tgot := determineSNI(tc.routeRequestHeaders, tc.clusterRequestHeaders, tc.service)\n\t\t\tassert.Equal(t, tc.want, got)\n\t\t})\n\t}\n}\n\nfunc TestEnforceRoute(t *testing.T) {\n\ttests := map[string]struct {\n\t\ttlsEnabled     bool\n\t\tpermitInsecure bool\n\t\twant           bool\n\t}{\n\t\t\"tls not enabled\": {\n\t\t\ttlsEnabled:     false,\n\t\t\tpermitInsecure: false,\n\t\t\twant:           false,\n\t\t},\n\t\t\"tls enabled\": {\n\t\t\ttlsEnabled:     true,\n\t\t\tpermitInsecure: false,\n\t\t\twant:           true,\n\t\t},\n\t\t\"tls enabled but insecure requested\": {\n\t\t\ttlsEnabled:     true,\n\t\t\tpermitInsecure: true,\n\t\t\twant:           false,\n\t\t},\n\t\t\"tls not enabled but insecure requested\": {\n\t\t\ttlsEnabled:     false,\n\t\t\tpermitInsecure: true,\n\t\t\twant:           false,\n\t\t},\n\t}\n\n\tfor name, tc := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tgot := routeEnforceTLS(tc.tlsEnabled, tc.permitInsecure)\n\t\t\tassert.Equal(t, tc.want, got)\n\t\t})\n\t}\n}\n\nfunc TestValidateHeaderAlteration(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tin      *contour_api_v1.HeadersPolicy\n\t\tdyn     map[string]string\n\t\tdhp     *HeadersPolicy\n\t\twant    *HeadersPolicy\n\t\twantErr error\n\t}{{\n\t\tname: \"empty is fine\",\n\t}, {\n\t\tname: \"set two, remove one\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"K-Foo\",\n\t\t\t\tValue: \"bar\",\n\t\t\t}, {\n\t\t\t\tName:  \"k-baz\", // This gets canonicalized\n\t\t\t\tValue: \"blah\",\n\t\t\t}},\n\t\t\tRemove: []string{\"K-Nada\"},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp: nil,\n\t\twant: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"K-Foo\": \"bar\",\n\t\t\t\t\"K-Baz\": \"blah\",\n\t\t\t},\n\t\t\tRemove: []string{\"K-Nada\"},\n\t\t},\n\t}, {\n\t\tname: \"duplicate set\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"K-Foo\",\n\t\t\t\tValue: \"bar\",\n\t\t\t}, {\n\t\t\t\tName:  \"k-foo\", // This gets canonicalized\n\t\t\t\tValue: \"blah\",\n\t\t\t}},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp:     nil,\n\t\twantErr: errors.New(`duplicate header addition: \"K-Foo\"`),\n\t}, {\n\t\tname: \"duplicate remove\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tRemove: []string{\"K-Foo\", \"k-foo\"},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp:     nil,\n\t\twantErr: errors.New(`duplicate header removal: \"K-Foo\"`),\n\t}, {\n\t\tname: \"invalid set header\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"  K-Foo\",\n\t\t\t\tValue: \"bar\",\n\t\t\t}},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp:     nil,\n\t\twantErr: errors.New(`invalid set header \"  K-Foo\": [a valid HTTP header must consist of alphanumeric characters or '-' (e.g. 'X-Header-Name', regex used for validation is '[-A-Za-z0-9]+')]`),\n\t}, {\n\t\tname: \"invalid set default header\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"  K-Foo\": \"bar\",\n\t\t\t},\n\t\t},\n\t\twantErr: errors.New(`invalid set header \"  K-Foo\": [a valid HTTP header must consist of alphanumeric characters or '-' (e.g. 'X-Header-Name', regex used for validation is '[-A-Za-z0-9]+')]`),\n\t}, {\n\t\tname: \"invalid remove header\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tRemove: []string{\"  K-Foo\"},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp:     nil,\n\t\twantErr: errors.New(`invalid remove header \"  K-Foo\": [a valid HTTP header must consist of alphanumeric characters or '-' (e.g. 'X-Header-Name', regex used for validation is '[-A-Za-z0-9]+')]`),\n\t}, {\n\t\tname: \"invalid remove default header\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tRemove: []string{\"  K-Foo\"},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp: &HeadersPolicy{\n\t\t\tRemove: []string{\"  K-Foo\"},\n\t\t},\n\t\twantErr: errors.New(`invalid remove header \"  K-Foo\": [a valid HTTP header must consist of alphanumeric characters or '-' (e.g. 'X-Header-Name', regex used for validation is '[-A-Za-z0-9]+')]`),\n\t}, {\n\t\tname: \"invalid set header (special headers)\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"Host\",\n\t\t\t\tValue: \"bar\",\n\t\t\t}},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp:     nil,\n\t\twantErr: errors.New(`rewriting \"Host\" header is not supported`),\n\t}, {\n\t\tname: \"invalid set default header (special headers)\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"K-Foo\",\n\t\t\t\tValue: \"ook?\",\n\t\t\t}},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"Host\": \"bar\",\n\t\t\t},\n\t\t},\n\t\twantErr: errors.New(`rewriting \"Host\" header is not supported`),\n\t}, {\n\t\tname: \"percents are escaped\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"K-Foo\",\n\t\t\t\tValue: \"100%\",\n\t\t\t}, {\n\t\t\t\tName:  \"Lot-Of-Percents\",\n\t\t\t\tValue: \"%%%%%\",\n\t\t\t}, {\n\t\t\t\tName:  \"k-baz\",                      // This gets canonicalized\n\t\t\t\tValue: \"%DOWNSTREAM_LOCAL_ADDRESS%\", // This is a known Envoy dynamic header\n\t\t\t}},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp: nil,\n\t\twant: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"K-Foo\":           \"100%%\",\n\t\t\t\t\"K-Baz\":           \"%DOWNSTREAM_LOCAL_ADDRESS%\",\n\t\t\t\t\"Lot-Of-Percents\": \"%%%%%%%%%%\",\n\t\t\t},\n\t\t},\n\t}, {\n\t\tname: \"dynamic service headers\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"l5d-dst-override\",\n\t\t\t\tValue: \"%CONTOUR_SERVICE_NAME%.%CONTOUR_NAMESPACE%.svc.cluster.local:%CONTOUR_SERVICE_PORT%\",\n\t\t\t}},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\":    \"myns\",\n\t\t\t\"CONTOUR_SERVICE_NAME\": \"myservice\",\n\t\t\t\"CONTOUR_SERVICE_PORT\": \"80\",\n\t\t},\n\t\tdhp: nil,\n\t\twant: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"L5d-Dst-Override\": \"myservice.myns.svc.cluster.local:80\",\n\t\t\t},\n\t\t},\n\t}, {\n\t\tname: \"dynamic service headers without service name and port\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"l5d-dst-override\",\n\t\t\t\tValue: \"%CONTOUR_SERVICE_NAME%.%CONTOUR_NAMESPACE%.svc.cluster.local:%CONTOUR_SERVICE_PORT%\",\n\t\t\t}},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp: nil,\n\t\twant: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"L5d-Dst-Override\": \"%%CONTOUR_SERVICE_NAME%%.myns.svc.cluster.local:%%CONTOUR_SERVICE_PORT%%\",\n\t\t\t},\n\t\t},\n\t}, {\n\t\tname: \"default headers are combined with given headers and escaped\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"K-Foo\",\n\t\t\t\tValue: \"100%\",\n\t\t\t}},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"k-baz\":           \"%DOWNSTREAM_LOCAL_ADDRESS%\", // This gets canonicalized\n\t\t\t\t\"Lot-Of-Percents\": \"%%%%%\",\n\t\t\t},\n\t\t},\n\t\twant: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"K-Foo\":           \"100%%\",\n\t\t\t\t\"K-Baz\":           \"%DOWNSTREAM_LOCAL_ADDRESS%\",\n\t\t\t\t\"Lot-Of-Percents\": \"%%%%%%%%%%\",\n\t\t\t},\n\t\t},\n\t}, {\n\t\tname: \"default headers do not replace given headers\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"K-Foo\",\n\t\t\t\tValue: \"100%\",\n\t\t\t}},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"K-Foo\": \"50%\",\n\t\t\t},\n\t\t},\n\t\twant: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"K-Foo\": \"100%%\",\n\t\t\t},\n\t\t},\n\t}}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot, gotErr := headersPolicyService(test.dhp, test.in, test.dyn)\n\t\t\tassert.Equal(t, test.want, got)\n\t\t\tassert.Equal(t, test.wantErr, gotErr)\n\t\t})\n\t}\n}\n\nfunc TestBuilderRunsProcessorsInOrder(t *testing.T) {\n\tvar got []string\n\n\tb := Builder{\n\t\tProcessors: []Processor{\n\t\t\tProcessorFunc(func(*DAG, *KubernetesCache) { got = append(got, \"foo\") }),\n\t\t\tProcessorFunc(func(*DAG, *KubernetesCache) { got = append(got, \"bar\") }),\n\t\t\tProcessorFunc(func(*DAG, *KubernetesCache) { got = append(got, \"baz\") }),\n\t\t\tProcessorFunc(func(*DAG, *KubernetesCache) { got = append(got, \"abc\") }),\n\t\t\tProcessorFunc(func(*DAG, *KubernetesCache) { got = append(got, \"def\") }),\n\t\t},\n\t}\n\n\tb.Build()\n\n\tassert.Equal(t, []string{\"foo\", \"bar\", \"baz\", \"abc\", \"def\"}, got)\n}\n\nfunc routes(routes ...*Route) map[string]*Route {\n\tif len(routes) == 0 {\n\t\treturn nil\n\t}\n\tm := make(map[string]*Route)\n\tfor _, r := range routes {\n\t\tm[conditionsToString(r)] = r\n\t}\n\treturn m\n}\n\nfunc directResponseRoute(prefix string, statusCode uint32) *Route {\n\treturn &Route{\n\t\tPathMatchCondition: prefixString(prefix),\n\t\tDirectResponse:     &DirectResponse{StatusCode: statusCode},\n\t}\n}\n\nfunc directResponseRouteService(prefix string, statusCode uint32, first *Service, rest ...*Service) *Route {\n\tservices := append([]*Service{first}, rest...)\n\treturn &Route{\n\t\tPathMatchCondition: prefixString(prefix),\n\t\tDirectResponse:     &DirectResponse{StatusCode: statusCode},\n\t\tClusters:           clustersWeight(services...),\n\t}\n}\n\nfunc httpRouteMatch(pathType gatewayapi_v1alpha1.PathMatchType, value string) []gatewayapi_v1alpha1.HTTPRouteMatch {\n\treturn []gatewayapi_v1alpha1.HTTPRouteMatch{{\n\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\tType:  pathMatchTypePtr(pathType),\n\t\t\tValue: pointer.StringPtr(value),\n\t\t},\n\t}}\n}\n\nfunc httpRouteForwards(forwards ...[]gatewayapi_v1alpha1.HTTPRouteForwardTo) []gatewayapi_v1alpha1.HTTPRouteForwardTo {\n\tvar fwds []gatewayapi_v1alpha1.HTTPRouteForwardTo\n\n\tfor _, f := range forwards {\n\t\tfwds = append(fwds, f...)\n\t}\n\treturn fwds\n}\n\nfunc httpRouteForwardTo(serviceName string, port int, weight int32) []gatewayapi_v1alpha1.HTTPRouteForwardTo {\n\treturn []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\tServiceName: pointer.StringPtr(serviceName),\n\t\tPort:        gatewayPort(port),\n\t\tWeight:      pointer.Int32Ptr(weight),\n\t}}\n}\n\nfunc tcpRouteForwardTo(serviceName string, port int, weight int32) []gatewayapi_v1alpha1.RouteForwardTo {\n\treturn []gatewayapi_v1alpha1.RouteForwardTo{{\n\t\tServiceName: pointer.StringPtr(serviceName),\n\t\tPort:        gatewayPort(port),\n\t\tWeight:      pointer.Int32Ptr(weight),\n\t}}\n}\n\nfunc prefixroute(prefix string, first *Service, rest ...*Service) *Route {\n\tservices := append([]*Service{first}, rest...)\n\treturn &Route{\n\t\tPathMatchCondition: prefixString(prefix),\n\t\tClusters:           clusters(services...),\n\t}\n}\n\nfunc prefixrouteHTTPRoute(prefix string, first *Service, rest ...*Service) *Route {\n\tservices := append([]*Service{first}, rest...)\n\treturn &Route{\n\t\tPathMatchCondition: prefixString(prefix),\n\t\tClusters:           clustersWeight(services...),\n\t}\n}\n\nfunc exactrouteHTTPRoute(path string, first *Service, rest ...*Service) *Route {\n\tservices := append([]*Service{first}, rest...)\n\treturn &Route{\n\t\tPathMatchCondition: &ExactMatchCondition{Path: path},\n\t\tClusters:           clustersWeight(services...),\n\t}\n}\n\nfunc routeProtocol(prefix string, protocol string, first *Service, rest ...*Service) *Route {\n\tservices := append([]*Service{first}, rest...)\n\n\tcs := clusters(services...)\n\tfor _, c := range cs {\n\t\tc.Protocol = protocol\n\t}\n\treturn &Route{\n\t\tPathMatchCondition: prefixString(prefix),\n\t\tClusters:           cs,\n\t}\n}\n\nfunc routeCluster(prefix string, first *Cluster, rest ...*Cluster) *Route {\n\treturn &Route{\n\t\tPathMatchCondition: prefixString(prefix),\n\t\tClusters:           append([]*Cluster{first}, rest...),\n\t}\n}\n\nfunc routeUpgrade(prefix string, first *Service, rest ...*Service) *Route {\n\tr := prefixroute(prefix, first, rest...)\n\tr.HTTPSUpgrade = true\n\treturn r\n}\n\nfunc routeWebsocket(prefix string, first *Service, rest ...*Service) *Route {\n\tr := prefixroute(prefix, first, rest...)\n\tr.Websocket = true\n\treturn r\n}\n\nfunc routeHeaders(prefix string, requestSet map[string]string, requestRemove []string, responseSet map[string]string, responseRemove []string, first *Service, rest ...*Service) *Route {\n\tr := prefixroute(prefix, first, rest...)\n\tr.RequestHeadersPolicy = &HeadersPolicy{\n\t\tSet:    requestSet,\n\t\tRemove: requestRemove,\n\t}\n\tr.ResponseHeadersPolicy = &HeadersPolicy{\n\t\tSet:    responseSet,\n\t\tRemove: responseRemove,\n\t}\n\treturn r\n}\n\nfunc clusterHeaders(requestSet map[string]string, requestAdd map[string]string, requestRemove []string, hostRewrite string, services ...*Service) (c []*Cluster) {\n\tfor _, s := range services {\n\t\tc = append(c, &Cluster{\n\t\t\tUpstream: s,\n\t\t\tProtocol: s.Protocol,\n\t\t\tRequestHeadersPolicy: &HeadersPolicy{\n\t\t\t\tSet:         requestSet,\n\t\t\t\tAdd:         requestAdd,\n\t\t\t\tRemove:      requestRemove,\n\t\t\t\tHostRewrite: hostRewrite,\n\t\t\t},\n\t\t\tWeight: s.Weighted.Weight,\n\t\t})\n\t}\n\treturn c\n}\n\nfunc clusters(services ...*Service) (c []*Cluster) {\n\tfor _, s := range services {\n\t\tc = append(c, &Cluster{\n\t\t\tUpstream: s,\n\t\t\tProtocol: s.Protocol,\n\t\t})\n\t}\n\treturn c\n}\n\nfunc clustersWeight(services ...*Service) (c []*Cluster) {\n\tfor _, s := range services {\n\t\tc = append(c, &Cluster{\n\t\t\tUpstream: s,\n\t\t\tProtocol: s.Protocol,\n\t\t\tWeight:   s.Weighted.Weight,\n\t\t})\n\t}\n\treturn c\n}\n\nfunc service(s *v1.Service) *Service {\n\treturn &Service{\n\t\tWeighted: WeightedService{\n\t\t\tWeight:           1,\n\t\t\tServiceName:      s.Name,\n\t\t\tServiceNamespace: s.Namespace,\n\t\t\tServicePort:      s.Spec.Ports[0],\n\t\t},\n\t}\n}\n\nfunc clustermap(services ...*v1.Service) []*Cluster {\n\tvar c []*Cluster\n\tfor _, s := range services {\n\t\tc = append(c, &Cluster{\n\t\t\tUpstream: service(s),\n\t\t})\n\t}\n\treturn c\n}\n\nfunc secret(s *v1.Secret) *Secret {\n\treturn &Secret{\n\t\tObject: s,\n\t}\n}\n\nfunc virtualhosts(vx ...Vertex) []Vertex {\n\treturn vx\n}\n\nfunc virtualhost(name string, first *Route, rest ...*Route) *VirtualHost {\n\treturn &VirtualHost{\n\t\tName:         name,\n\t\tListenerName: \"ingress_http\",\n\t\troutes:       routes(append([]*Route{first}, rest...)...),\n\t}\n}\n\nfunc securevirtualhost(name string, sec *v1.Secret, first *Route, rest ...*Route) *SecureVirtualHost {\n\treturn &SecureVirtualHost{\n\t\tVirtualHost: VirtualHost{\n\t\t\tName:         name,\n\t\t\tListenerName: \"ingress_https\",\n\t\t\troutes:       routes(append([]*Route{first}, rest...)...),\n\t\t},\n\t\tMinTLSVersion: \"1.2\",\n\t\tSecret:        secret(sec),\n\t}\n}\n\nfunc listeners(ls ...*Listener) []Vertex {\n\tvar v []Vertex\n\tfor _, l := range ls {\n\t\tv = append(v, l)\n\t}\n\treturn v\n}\n\nfunc prefixString(prefix string) MatchCondition {\n\treturn &PrefixMatchCondition{Prefix: prefix, PrefixMatchType: PrefixMatchString}\n}\nfunc prefixSegment(prefix string) MatchCondition {\n\treturn &PrefixMatchCondition{Prefix: prefix, PrefixMatchType: PrefixMatchSegment}\n}\nfunc exact(path string) MatchCondition  { return &ExactMatchCondition{Path: path} }\nfunc regex(regex string) MatchCondition { return &RegexMatchCondition{Regex: regex} }\n\nfunc withMirror(r *Route, mirror *Service) *Route {\n\tr.MirrorPolicy = &MirrorPolicy{\n\t\tCluster: &Cluster{\n\t\t\tUpstream: mirror,\n\t\t},\n\t}\n\treturn r\n}\n\nfunc gatewayAddressTypePtr(addr gatewayapi_v1alpha1.AddressType) *gatewayapi_v1alpha1.AddressType {\n\treturn &addr\n}\n\nfunc routeSelectTypePtr(rst gatewayapi_v1alpha1.RouteSelectType) *gatewayapi_v1alpha1.RouteSelectType {\n\treturn &rst\n}\n\nfunc tlsModeTypePtr(mode gatewayapi_v1alpha1.TLSModeType) *gatewayapi_v1alpha1.TLSModeType {\n\treturn &mode\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dag\n\nimport (\n\t\"path\"\n\t\"strings\"\n\n\tcontour_api_v1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"\n\tcontour_api_v1alpha1 \"github.com/projectcontour/contour/apis/projectcontour/v1alpha1\"\n\t\"github.com/projectcontour/contour/internal/k8s\"\n\t\"github.com/projectcontour/contour/internal/status\"\n\t\"github.com/projectcontour/contour/internal/xds\"\n\t\"github.com/sirupsen/logrus\"\n\tcorev1 \"k8s.io/api/core/v1\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n)\n\ntype ExtensionServiceProcessor struct {\n\tlogrus.FieldLogger\n\n\t// ClientCertificate is the optional identifier of the TLS\n\t// secret containing client certificate and private key to be\n\t// used when establishing TLS connection to upstream cluster.\n\tClientCertificate *types.NamespacedName\n}\n\nvar _ Processor = &ExtensionServiceProcessor{}\n\nfunc (p *ExtensionServiceProcessor) Run(dag *DAG, cache *KubernetesCache) {\n\tfor _, e := range cache.extensions {\n\t\textStatus, commit := status.ExtensionAccessor(&dag.StatusCache, e)\n\t\tvalidCondition := extStatus.ConditionFor(status.ValidCondition)\n\n\t\tif ext := p.buildExtensionService(cache, e, validCondition); ext != nil {\n\t\t\tif len(validCondition.Errors) == 0 {\n\t\t\t\tdag.AddRoot(ext)\n\t\t\t}\n\t\t}\n\n\t\tif len(validCondition.Errors) == 0 {\n\t\t\tvalidCondition.Status = contour_api_v1.ConditionTrue\n\t\t\tvalidCondition.Reason = \"Valid\"\n\t\t\tvalidCondition.Message = \"Valid ExtensionService\"\n\t\t}\n\n\t\tcommit()\n\t}\n}\n\n// ExtensionClusterName generates a unique Envoy cluster name\n// for an ExtensionCluster.\n// The namespaced name of an ExtensionCluster is globally\n// unique, so we can simply use that as the cluster name. As\n// long as we scope the context with the \"extension\" prefix\n// there can't be a conflict. Note that the name doesn't include\n// a hash of the contents because we want a 1-1 mapping between\n// ExtensionServices and Envoy Clusters; we don't want a new\n// Envoy Cluster just because a field changed.\nfunc ExtensionClusterName(meta types.NamespacedName) string {\n\treturn strings.Join([]string{\"extension\", meta.Namespace, meta.Name}, \"/\")\n}\n\n// buildExtensionService builds one ExtensionCluster record based\n// on the corresponding CRD.\nfunc (p *ExtensionServiceProcessor) buildExtensionService(\n\tcache *KubernetesCache,\n\text *contour_api_v1alpha1.ExtensionService,\n\tvalidCondition *contour_api_v1.DetailedCondition,\n) *ExtensionCluster {\n\ttp, err := timeoutPolicy(ext.Spec.TimeoutPolicy)\n\tif err != nil {\n\t\tvalidCondition.AddErrorf(contour_api_v1.ConditionTypeSpecError, \"TimeoutPolicyNotValid\",\n\t\t\t\"spec.timeoutPolicy failed to parse: %s\", err)\n\t}\n\n\tvar clientCertSecret *Secret\n\tif p.ClientCertificate != nil {\n\t\tclientCertSecret, err = cache.LookupSecret(*p.ClientCertificate, validSecret)\n\t\tif err != nil {\n\t\t\tvalidCondition.AddErrorf(contour_api_v1.ConditionTypeTLSError, \"SecretNotValid\",\n\t\t\t\t\"tls.envoy-client-certificate Secret %q is invalid: %s\", p.ClientCertificate, err)\n\t\t}\n\t}\n\n\textension := ExtensionCluster{\n\t\tName: ExtensionClusterName(k8s.NamespacedNameOf(ext)),\n\t\tUpstream: ServiceCluster{\n\t\t\tClusterName: path.Join(\n\t\t\t\t\"extension\",\n\t\t\t\txds.ClusterLoadAssignmentName(k8s.NamespacedNameOf(ext), \"\"),\n\t\t\t),\n\t\t},\n\t\tProtocol:           \"h2\",\n\t\tUpstreamValidation: nil,\n\t\tTimeoutPolicy:      tp,\n\t\tSNI:                \"\",\n\t\tClientCertificate:  clientCertSecret,\n\t}\n\n\tlbPolicy := loadBalancerPolicy(ext.Spec.LoadBalancerPolicy)\n\tswitch lbPolicy {\n\tcase LoadBalancerPolicyCookie, LoadBalancerPolicyRequestHash:\n\t\tvalidCondition.AddWarningf(contour_api_v1.ConditionTypeSpecError, \"IgnoredField\",\n\t\t\t\"ignoring field %q; %s load balancer policy is not supported for ExtensionClusters\",\n\t\t\t\".Spec.LoadBalancerPolicy\", lbPolicy)\n\t\t// Reset load balancer policy to ensure the default.\n\t\tlbPolicy = \"\"\n\t}\n\textension.LoadBalancerPolicy = lbPolicy\n\n\t// Timeouts are specified above the cluster (e.g.\n\t// in the ext_authz filter). The ext_authz filter\n\t// doesn't have an idle timeout (only a request\n\t// timeout), so validate that it is not provided here.\n\tif timeouts := ext.Spec.TimeoutPolicy; timeouts != nil && timeouts.Idle != \"\" {\n\t\tvalidCondition.AddWarningf(\"SpecError\", \"IgnoredField\",\n\t\t\t\"ignoring field %q; idle timeouts are not supported for ExtensionClusters\",\n\t\t\t\".Spec.TimeoutPolicy.Idle\")\n\t}\n\n\t// API server validation ensures that the protocol is \"h2\" or \"h2c\".\n\tif ext.Spec.Protocol != nil {\n\t\textension.Protocol = stringOrDefault(*ext.Spec.Protocol, extension.Protocol)\n\t}\n\n\tif v := ext.Spec.UpstreamValidation; v != nil {\n\t\tif uv, err := cache.LookupUpstreamValidation(v, ext.GetNamespace()); err != nil {\n\t\t\tvalidCondition.AddErrorf(contour_api_v1.ConditionTypeSpecError, \"TLSUpstreamValidation\",\n\t\t\t\t\"TLS upstream validation policy error: %s\", err.Error())\n\t\t} else {\n\t\t\textension.UpstreamValidation = uv\n\n\t\t\t// Default the SNI server name to the name\n\t\t\t// we need to validate. It is a bit onerous\n\t\t\t// to also have to provide a CA bundle here,\n\t\t\t// but maybe we can make that optional in the\n\t\t\t// future.\n\t\t\t//\n\t\t\t// TODO(jpeach): expose SNI in the API, https://github.com/projectcontour/contour/issues/2893.\n\t\t\textension.SNI = uv.SubjectName\n\t\t}\n\n\t\tif extension.Protocol != \"h2\" {\n\t\t\tvalidCondition.AddErrorf(contour_api_v1.ConditionTypeSpecError, \"InconsistentProtocol\",\n\t\t\t\t\"upstream TLS validation not supported for %q protocol\", extension.Protocol)\n\t\t}\n\t}\n\n\tfor _, target := range ext.Spec.Services {\n\t\t// Note that ExtensionServices only expose Kubernetes\n\t\t// Service resources that are in the same namespace.\n\t\t// This prevent using a cross-namespace reference to\n\t\t// subvert the Contour installation.\n\t\tsvcName := types.NamespacedName{\n\t\t\tNamespace: ext.GetNamespace(),\n\t\t\tName:      target.Name,\n\t\t}\n\n\t\tsvc, port, err := cache.LookupService(svcName, intstr.FromInt(target.Port))\n\t\tif err != nil {\n\t\t\tvalidCondition.AddErrorf(contour_api_v1.ConditionTypeServiceError, \"ServiceUnresolvedReference\",\n\t\t\t\t\"unresolved service %q: %s\", svcName, err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// TODO(jpeach): Add ExternalName support in https://github.com/projectcontour/contour/issues/2875.\n\t\tif svc.Spec.ExternalName != \"\" {\n\t\t\tvalidCondition.AddErrorf(contour_api_v1.ConditionTypeServiceError, \"UnsupportedServiceType\",\n\t\t\t\t\"Service %q is of unsupported type %q.\", svcName, corev1.ServiceTypeExternalName)\n\t\t\tcontinue\n\t\t}\n\n\t\textension.Upstream.AddWeightedService(target.Weight, svcName, port)\n\t}\n\n\treturn &extension\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dag\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/projectcontour/contour/internal/errors\"\n\t\"github.com/projectcontour/contour/internal/k8s\"\n\t\"github.com/projectcontour/contour/internal/status\"\n\n\t\"github.com/sirupsen/logrus\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/labels\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n\t\"k8s.io/apimachinery/pkg/util/validation\"\n\t\"k8s.io/apimachinery/pkg/util/validation/field\"\n\t\"k8s.io/utils/pointer\"\n\tgatewayapi_v1alpha1 \"sigs.k8s.io/gateway-api/apis/v1alpha1\"\n)\n\nconst (\n\tKindHTTPRoute = \"HTTPRoute\"\n\tKindTLSRoute  = \"TLSRoute\"\n)\n\n// GatewayAPIProcessor translates Gateway API types into DAG\n// objects and adds them to the DAG.\ntype GatewayAPIProcessor struct {\n\tlogrus.FieldLogger\n\n\tdag    *DAG\n\tsource *KubernetesCache\n}\n\n// matchConditions holds match rules.\ntype matchConditions struct {\n\tpathMatchConditions  []MatchCondition\n\theaderMatchCondition []HeaderMatchCondition\n}\n\n// Run translates Service APIs into DAG objects and\n// adds them to the DAG.\nfunc (p *GatewayAPIProcessor) Run(dag *DAG, source *KubernetesCache) {\n\tvar errs field.ErrorList\n\tpath := field.NewPath(\"spec\")\n\n\tp.dag = dag\n\tp.source = source\n\n\t// reset the processor when we're done\n\tdefer func() {\n\t\tp.dag = nil\n\t\tp.source = nil\n\t}()\n\n\t// Gateway and GatewayClass must be defined for resources to be processed.\n\tif p.source.gateway == nil {\n\t\tp.Info(\"Gateway not found in cache.\")\n\t\treturn\n\t}\n\tif p.source.gatewayclass == nil {\n\t\tp.Info(\"Gatewayclass not found in cache.\")\n\t\treturn\n\t}\n\n\tif len(p.source.gateway.Spec.Addresses) > 0 {\n\t\tp.Error(\"Spec.Addresses is unsupported\")\n\t\terrs = append(errs, field.NotSupported(path, p.source.gateway.Spec.Addresses, []string{}))\n\t}\n\n\tfor _, listener := range p.source.gateway.Spec.Listeners {\n\n\t\tvar matchingHTTPRoutes []*gatewayapi_v1alpha1.HTTPRoute\n\t\tvar matchingTLSRoutes []*gatewayapi_v1alpha1.TLSRoute\n\t\tvar listenerSecret *Secret\n\n\t\t// Validate the Protocol on the selector is a supported type.\n\t\tswitch listener.Protocol {\n\t\tcase gatewayapi_v1alpha1.HTTPSProtocolType:\n\t\t\t// Validate that if protocol is type HTTPS, that TLS is defined.\n\t\t\tif listener.TLS == nil {\n\t\t\t\tp.Errorf(\"Listener.TLS is required when protocol is %q.\", listener.Protocol)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Check for TLS on the Gateway.\n\t\t\tif listenerSecret = p.validGatewayTLS(listener); listenerSecret == nil {\n\t\t\t\t// If TLS was configured on the Listener, but it's invalid, don't allow any\n\t\t\t\t// routes to be bound to this listener since it can't serve TLS traffic.\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase gatewayapi_v1alpha1.TLSProtocolType:\n\n\t\t\t// TLS is required for the type TLS.\n\t\t\tif listener.TLS == nil {\n\t\t\t\tp.Errorf(\"Listener.TLS is required when protocol is %q.\", listener.Protocol)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif listener.TLS.Mode != nil {\n\t\t\t\tswitch *listener.TLS.Mode {\n\t\t\t\tcase gatewayapi_v1alpha1.TLSModeTerminate:\n\t\t\t\t\t// Check for TLS on the Gateway.\n\t\t\t\t\tif listenerSecret = p.validGatewayTLS(listener); listenerSecret == nil {\n\t\t\t\t\t\t// If TLS was configured on the Listener, but it's invalid, don't allow any\n\t\t\t\t\t\t// routes to be bound to this listener since it can't serve TLS traffic.\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\tcase gatewayapi_v1alpha1.TLSModePassthrough:\n\t\t\t\t\tif listener.TLS.CertificateRef != nil {\n\t\t\t\t\t\tp.Errorf(\"Listener.TLS.CertificateRef cannot be defined when TLS Mode is %q.\", *listener.TLS.Mode)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tcase gatewayapi_v1alpha1.HTTPProtocolType:\n\t\t\tbreak\n\t\tdefault:\n\t\t\tp.Errorf(\"Listener.Protocol %q is not supported.\", listener.Protocol)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Validate the Group on the selector is a supported type.\n\t\tif listener.Routes.Group != nil {\n\t\t\tif *listener.Routes.Group != gatewayapi_v1alpha1.GroupName {\n\t\t\t\tp.Errorf(\"Listener.Routes.Group %q is not supported.\", listener.Routes.Group)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// Validate the Kind on the selector is a supported type.\n\t\tif listener.Routes.Kind != KindHTTPRoute && listener.Routes.Kind != KindTLSRoute {\n\t\t\tp.Errorf(\"Listener.Routes.Kind %q is not supported.\", listener.Routes.Kind)\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch listener.Routes.Kind {\n\t\tcase KindHTTPRoute:\n\t\t\tfor _, route := range p.source.httproutes {\n\n\t\t\t\t// Filter the HTTPRoutes that match the gateway which Contour is configured to watch.\n\t\t\t\t// RouteBindingSelector defines a schema for associating routes with the Gateway.\n\t\t\t\t// If Namespaces and Selector are defined, only routes matching both selectors are associated with the Gateway.\n\n\t\t\t\t// ## RouteBindingSelector ##\n\t\t\t\t//\n\t\t\t\t// Selector specifies a set of route labels used for selecting routes to associate\n\t\t\t\t// with the Gateway. If this Selector is defined, only routes matching the Selector\n\t\t\t\t// are associated with the Gateway. An empty Selector matches all routes.\n\n\t\t\t\tnsMatches, err := p.namespaceMatches(listener.Routes.Namespaces, route.Namespace)\n\t\t\t\tif err != nil {\n\t\t\t\t\tp.Errorf(\"error validating namespaces against Listener.Routes.Namespaces: %s\", err)\n\t\t\t\t}\n\n\t\t\t\tselMatches, err := selectorMatches(listener.Routes.Selector, route.Labels)\n\t\t\t\tif err != nil {\n\t\t\t\t\tp.Errorf(\"error validating routes against Listener.Routes.Selector: %s\", err)\n\t\t\t\t}\n\n\t\t\t\t// If all the match criteria for this HTTPRoute match the Gateway, then add\n\t\t\t\t// the route to the set of matchingRoutes.\n\t\t\t\tif selMatches && nsMatches {\n\n\t\t\t\t\tif !p.gatewayMatches(route.Spec.Gateways, route.Namespace) {\n\n\t\t\t\t\t\t// If a label selector or namespace selector matches, but the gateway Allow doesn't\n\t\t\t\t\t\t// then set the \"Admitted: false\" for the route.\n\t\t\t\t\t\trouteAccessor, commit := p.dag.StatusCache.RouteConditionsAccessor(k8s.NamespacedNameOf(route), route.Generation, status.ResourceHTTPRoute, route.Status.Gateways)\n\t\t\t\t\t\trouteAccessor.AddCondition(gatewayapi_v1alpha1.ConditionRouteAdmitted, metav1.ConditionFalse, status.ReasonGatewayAllowMismatch, \"Gateway RouteSelector matches, but GatewayAllow has mismatch.\")\n\t\t\t\t\t\tcommit()\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\t// Empty Selector matches all routes.\n\t\t\t\t\tmatchingHTTPRoutes = append(matchingHTTPRoutes, route)\n\t\t\t\t}\n\t\t\t}\n\t\tcase KindTLSRoute:\n\n\t\t\t// Validate the listener protocol is type=TLS.\n\t\t\tif listener.Protocol != gatewayapi_v1alpha1.TLSProtocolType {\n\t\t\t\tp.Errorf(\"invalid listener protocol %q for Kind: TLSRoute\", listener.Protocol)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor _, route := range p.source.tlsroutes {\n\t\t\t\t// Filter the TLSRoutes that match the gateway which Contour is configured to watch.\n\t\t\t\t// RouteBindingSelector defines a schema for associating routes with the Gateway.\n\t\t\t\t// If Namespaces and Selector are defined, only routes matching both selectors are associated with the Gateway.\n\n\t\t\t\t// ## RouteBindingSelector ##\n\t\t\t\t//\n\t\t\t\t// Selector specifies a set of route labels used for selecting routes to associate\n\t\t\t\t// with the Gateway. If this Selector is defined, only routes matching the Selector\n\t\t\t\t// are associated with the Gateway. An empty Selector matches all routes.\n\n\t\t\t\tnsMatches, err := p.namespaceMatches(listener.Routes.Namespaces, route.Namespace)\n\t\t\t\tif err != nil {\n\t\t\t\t\tp.Errorf(\"error validating namespaces against Listener.Routes.Namespaces: %s\", err)\n\t\t\t\t}\n\n\t\t\t\tselMatches, err := selectorMatches(listener.Routes.Selector, route.Labels)\n\t\t\t\tif err != nil {\n\t\t\t\t\tp.Errorf(\"error validating routes against Listener.Routes.Selector: %s\", err)\n\t\t\t\t}\n\n\t\t\t\tif selMatches && nsMatches {\n\n\t\t\t\t\tif !p.gatewayMatches(route.Spec.Gateways, route.Namespace) {\n\n\t\t\t\t\t\t// If a label selector or namespace selector matches, but the gateway Allow doesn't\n\t\t\t\t\t\t// then set the \"Admitted: false\" for the route.\n\t\t\t\t\t\trouteAccessor, commit := p.dag.StatusCache.RouteConditionsAccessor(k8s.NamespacedNameOf(route), route.Generation, status.ResourceTLSRoute, route.Status.Gateways)\n\t\t\t\t\t\trouteAccessor.AddCondition(gatewayapi_v1alpha1.ConditionRouteAdmitted, metav1.ConditionFalse, status.ReasonGatewayAllowMismatch, \"Gateway RouteSelector matches, but GatewayAllow has mismatch.\")\n\t\t\t\t\t\tcommit()\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\t// Empty Selector matches all routes.\n\t\t\t\t\tmatchingTLSRoutes = append(matchingTLSRoutes, route)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvalidGateway := len(errs) == 0\n\n\t\t// Process all the HTTPRoutes that match this Gateway.\n\t\tfor _, matchingRoute := range matchingHTTPRoutes {\n\t\t\tp.computeHTTPRoute(matchingRoute, listenerSecret, listener.Hostname, validGateway)\n\t\t}\n\n\t\t// Process all the routes that match this Gateway.\n\t\tfor _, matchingRoute := range matchingTLSRoutes {\n\t\t\tp.computeTLSRoute(matchingRoute, validGateway, listenerSecret)\n\t\t}\n\t}\n\n\tp.computeGateway(p.source.gateway, errs)\n}\n\nfunc (p *GatewayAPIProcessor) validGatewayTLS(listener gatewayapi_v1alpha1.Listener) *Secret {\n\n\t// Validate the CertificateRef is configured.\n\tif listener.TLS == nil || listener.TLS.CertificateRef == nil {\n\t\tp.Errorf(\"Spec.VirtualHost.TLS.CertificateRef is not configured.\")\n\t\treturn nil\n\t}\n\n\t// Validate a v1.Secret is referenced which can be kind: secret & group: core.\n\t// ref: https://github.com/kubernetes-sigs/gateway-api/pull/562\n\tif !isSecretRef(listener.TLS.CertificateRef) {\n\t\tp.Error(\"Spec.VirtualHost.TLS Secret must be type core.Secret\")\n\t\treturn nil\n\t}\n\n\tlistenerSecret, err := p.source.LookupSecret(types.NamespacedName{Name: listener.TLS.CertificateRef.Name, Namespace: p.source.gateway.Namespace}, validSecret)\n\tif err != nil {\n\t\tp.Errorf(\"Spec.VirtualHost.TLS Secret %q is invalid: %s\", listener.TLS.CertificateRef.Name, err)\n\t\treturn nil\n\t}\n\treturn listenerSecret\n}\n\nfunc isSecretRef(certificateRef *gatewayapi_v1alpha1.LocalObjectReference) bool {\n\treturn strings.ToLower(certificateRef.Kind) == \"secret\" && strings.ToLower(certificateRef.Group) == \"core\"\n}\n\n// computeHosts validates the hostnames for a HTTPRoute as well as validating\n// that the hostname on the HTTPRoute matches what is optionally defined on the\n// listener.hostname.\nfunc (p *GatewayAPIProcessor) computeHosts(hostnames []gatewayapi_v1alpha1.Hostname, listenerHostname *gatewayapi_v1alpha1.Hostname) (map[string]struct{}, []error) {\n\n\thosts := make(map[string]struct{})\n\tvar errors []error\n\n\t// Determine the hosts on the hostnames, if no hosts\n\t// are defined, then set to \"*\". If the listenerHostname is defined,\n\t// then the route must match the Gateway hostname.\n\tif len(hostnames) == 0 && listenerHostname == nil {\n\t\thosts[\"*\"] = struct{}{}\n\t\treturn hosts, nil\n\t}\n\n\tif listenerHostname != nil {\n\t\tif string(*listenerHostname) != \"*\" {\n\n\t\t\t// Validate listener hostname.\n\t\t\tif err := validHostName(string(*listenerHostname)); err != nil {\n\t\t\t\treturn hosts, []error{err}\n\t\t\t}\n\n\t\t\tif len(hostnames) == 0 {\n\t\t\t\thosts[string(*listenerHostname)] = struct{}{}\n\t\t\t\treturn hosts, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, host := range hostnames {\n\n\t\thostname := string(host)\n\n\t\t// Validate the hostname.\n\t\tif err := validHostName(hostname); err != nil {\n\t\t\terrors = append(errors, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif listenerHostname != nil {\n\t\t\tlhn := string(*listenerHostname)\n\n\t\t\t// A \"*\" hostname matches anything.\n\t\t\tif lhn == \"*\" {\n\t\t\t\thosts[hostname] = struct{}{}\n\t\t\t\tcontinue\n\t\t\t} else if lhn == hostname {\n\t\t\t\t// If the listener.hostname matches then no need to\n\t\t\t\t// do any other validation.\n\t\t\t\thosts[hostname] = struct{}{}\n\t\t\t\tcontinue\n\t\t\t} else if strings.Contains(lhn, \"*\") {\n\n\t\t\t\tif removeFirstDNSLabel(lhn) != removeFirstDNSLabel(hostname) {\n\t\t\t\t\terrors = append(errors, fmt.Errorf(\"gateway hostname %q does not match route hostname %q\", lhn, hostname))\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Validate the gateway listener hostname matches the hostnames hostname.\n\t\t\t\terrors = append(errors, fmt.Errorf(\"gateway hostname %q does not match route hostname %q\", lhn, hostname))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\thosts[hostname] = struct{}{}\n\t}\n\treturn hosts, errors\n}\n\nfunc removeFirstDNSLabel(input string) string {\n\tif strings.Contains(input, \".\") {\n\t\treturn input[strings.IndexAny(input, \".\"):]\n\t}\n\treturn input\n}\n\nfunc validHostName(hostname string) error {\n\tif isIP := net.ParseIP(hostname) != nil; isIP {\n\t\treturn fmt.Errorf(\"hostname %q must be a DNS name, not an IP address\", hostname)\n\t}\n\tif strings.Contains(hostname, \"*\") {\n\t\tif errs := validation.IsWildcardDNS1123Subdomain(hostname); errs != nil {\n\t\t\treturn fmt.Errorf(\"invalid hostname %q: %v\", hostname, errs)\n\t\t}\n\t} else {\n\t\tif errs := validation.IsDNS1123Subdomain(hostname); errs != nil {\n\t\t\treturn fmt.Errorf(\"invalid hostname %q: %v\", hostname, errs)\n\t\t}\n\t}\n\treturn nil\n}\n\n// namespaceMatches returns true if the namespaces selector matches\n// the HTTPRoute that is being processed.\nfunc (p *GatewayAPIProcessor) namespaceMatches(namespaces *gatewayapi_v1alpha1.RouteNamespaces, namespace string) (bool, error) {\n\t// From indicates where Routes will be selected for this Gateway.\n\t// Possible values are:\n\t//   * All: Routes in all namespaces may be used by this Gateway.\n\t//   * Selector: Routes in namespaces selected by the selector may be used by\n\t//     this Gateway.\n\t//   * Same: Only Routes in the same namespace may be used by this Gateway.\n\n\tif namespaces == nil {\n\t\treturn true, nil\n\t}\n\n\tif namespaces.From == nil {\n\t\treturn true, nil\n\t}\n\n\tswitch *namespaces.From {\n\tcase gatewayapi_v1alpha1.RouteSelectAll:\n\t\treturn true, nil\n\tcase gatewayapi_v1alpha1.RouteSelectSame:\n\t\treturn p.source.ConfiguredGateway.Namespace == namespace, nil\n\tcase gatewayapi_v1alpha1.RouteSelectSelector:\n\t\tif len(namespaces.Selector.MatchLabels) == 0 && len(namespaces.Selector.MatchExpressions) == 0 {\n\t\t\treturn false, fmt.Errorf(\"RouteNamespaces selector must be specified when `RouteSelectType=Selector`\")\n\t\t}\n\n\t\t// Look up the HTTPRoute's namespace in the list of cached namespaces.\n\t\tif ns := p.source.namespaces[namespace]; ns != nil {\n\n\t\t\t// Check that the route's namespace is included in the Gateway's\n\t\t\t// namespace selector/expression.\n\t\t\tl, err := metav1.LabelSelectorAsSelector(namespaces.Selector)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\t// Look for matching labels on Selector.\n\t\t\treturn l.Matches(labels.Set(ns.Labels)), nil\n\t\t}\n\t}\n\treturn true, nil\n}\n\n// gatewayMatches returns true if \"AllowAll\" is set, the \"SameNamespace\" is set and the HTTPRoute\n// matches the Gateway's namespace, or the \"FromList\" is set and the gateway Contour is watching\n// matches one from the list.\nfunc (p *GatewayAPIProcessor) gatewayMatches(routeGateways *gatewayapi_v1alpha1.RouteGateways, namespace string) bool {\n\n\tif routeGateways == nil || routeGateways.Allow == nil {\n\t\treturn true\n\t}\n\n\tswitch *routeGateways.Allow {\n\tcase gatewayapi_v1alpha1.GatewayAllowAll:\n\t\treturn true\n\tcase gatewayapi_v1alpha1.GatewayAllowFromList:\n\t\tfor _, gateway := range routeGateways.GatewayRefs {\n\t\t\tif gateway.Name == p.source.ConfiguredGateway.Name && gateway.Namespace == p.source.ConfiguredGateway.Namespace {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\tcase gatewayapi_v1alpha1.GatewayAllowSameNamespace:\n\t\treturn p.source.ConfiguredGateway.Namespace == namespace\n\t}\n\treturn false\n}\n\n// selectorMatches returns true if the selector matches the labels on the object or is not defined.\nfunc selectorMatches(selector *metav1.LabelSelector, objLabels map[string]string) (bool, error) {\n\n\tif selector == nil {\n\t\treturn true, nil\n\t}\n\n\t// If a selector is defined then check that it matches the labels on the object.\n\tif len(selector.MatchLabels) > 0 || len(selector.MatchExpressions) > 0 {\n\t\tl, err := metav1.LabelSelectorAsSelector(selector)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\t// Look for matching labels on Selector.\n\t\treturn l.Matches(labels.Set(objLabels)), nil\n\t}\n\t// If no selector is defined then it matches by default.\n\treturn true, nil\n}\n\nfunc (p *GatewayAPIProcessor) computeGateway(gateway *gatewayapi_v1alpha1.Gateway, fieldErrs field.ErrorList) {\n\n\tgwAccessor, commit := p.dag.StatusCache.GatewayConditionsAccessor(k8s.NamespacedNameOf(gateway), gateway.Generation, status.ResourceGateway, &gateway.Status)\n\tdefer commit()\n\n\t// Determine the gateway status based on fieldErrs.\n\tswitch len(fieldErrs) {\n\tcase 0:\n\t\tgwAccessor.AddCondition(gatewayapi_v1alpha1.GatewayConditionReady, metav1.ConditionTrue, status.ReasonValidGateway, \"Valid Gateway\")\n\tdefault:\n\t\tgwAccessor.AddCondition(gatewayapi_v1alpha1.GatewayConditionReady, metav1.ConditionFalse, status.ReasonInvalidGateway, errors.ParseFieldErrors(fieldErrs))\n\t}\n}\n\nfunc (p *GatewayAPIProcessor) computeTLSRoute(route *gatewayapi_v1alpha1.TLSRoute, validGateway bool, listenerSecret *Secret) {\n\n\trouteAccessor, commit := p.dag.StatusCache.RouteConditionsAccessor(k8s.NamespacedNameOf(route), route.Generation, status.ResourceTLSRoute, route.Status.Gateways)\n\tdefer commit()\n\n\t// If the Gateway is invalid, set status on the route.\n\tif !validGateway {\n\t\trouteAccessor.AddCondition(gatewayapi_v1alpha1.ConditionRouteAdmitted, metav1.ConditionFalse, status.ReasonInvalidGateway, \"Invalid Gateway\")\n\t\treturn\n\t}\n\n\tfor _, rule := range route.Spec.Rules {\n\t\tvar hosts []string\n\t\tvar matchErrors []error\n\t\ttotalSnis := 0\n\n\t\t// Build the set of SNIs that are applied to this TLSRoute.\n\t\tfor _, match := range rule.Matches {\n\t\t\tfor _, snis := range match.SNIs {\n\t\t\t\ttotalSnis++\n\t\t\t\tif err := validHostName(string(snis)); err != nil {\n\t\t\t\t\tmatchErrors = append(matchErrors, err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\thosts = append(hosts, string(snis))\n\t\t\t}\n\t\t}\n\n\t\t// If there are any errors with the supplied hostnames, then\n\t\t// add a condition to the route.\n\t\tfor _, err := range matchErrors {\n\t\t\trouteAccessor.AddCondition(status.ConditionResolvedRefs, metav1.ConditionFalse, status.ReasonDegraded, err.Error())\n\t\t}\n\n\t\t// If all the supplied SNIs are invalid, then this route is invalid\n\t\t// and should be dropped.\n\t\tif len(matchErrors) != 0 && len(matchErrors) == totalSnis {\n\t\t\tcontinue\n\t\t}\n\n\t\t// If SNIs is unspecified, then all\n\t\t// requests associated with the gateway TLS listener will match.\n\t\t// This can be used to define a default backend for a TLS listener.\n\t\tif len(hosts) == 0 {\n\t\t\thosts = []string{\"*\"}\n\t\t}\n\n\t\tif len(rule.ForwardTo) == 0 {\n\t\t\trouteAccessor.AddCondition(status.ConditionResolvedRefs, metav1.ConditionFalse, status.ReasonDegraded, \"At least one Spec.Rules.ForwardTo must be specified.\")\n\t\t\tcontinue\n\t\t}\n\n\t\tvar proxy TCPProxy\n\t\tfor _, forward := range rule.ForwardTo {\n\n\t\t\tservice, err := p.validateForwardTo(forward.ServiceName, forward.Port, route.Namespace)\n\t\t\tif err != nil {\n\t\t\t\trouteAccessor.AddCondition(status.ConditionResolvedRefs, metav1.ConditionFalse, status.ReasonDegraded, err.Error())\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tproxy.Clusters = append(proxy.Clusters, &Cluster{\n\t\t\t\tUpstream: service,\n\t\t\t\tSNI:      service.ExternalName,\n\t\t\t})\n\t\t}\n\n\t\tif len(proxy.Clusters) == 0 {\n\t\t\t// No valid clusters so the route should get rejected.\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, host := range hosts {\n\t\t\tsecure := p.dag.EnsureSecureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_https\"})\n\n\t\t\tif listenerSecret != nil {\n\t\t\t\tsecure.Secret = listenerSecret\n\t\t\t}\n\n\t\t\tsecure.TCPProxy = &proxy\n\t\t}\n\n\t}\n\n\t// Determine if any errors exist in conditions and set the \"Admitted\"\n\t// condition accordingly.\n\tswitch len(routeAccessor.Conditions) {\n\tcase 0:\n\t\trouteAccessor.AddCondition(gatewayapi_v1alpha1.ConditionRouteAdmitted, metav1.ConditionTrue, status.ReasonValid, \"Valid TLSRoute\")\n\tdefault:\n\t\trouteAccessor.AddCondition(gatewayapi_v1alpha1.ConditionRouteAdmitted, metav1.ConditionFalse, status.ReasonErrorsExist, \"Errors found, check other Conditions for details.\")\n\t}\n}\n\nfunc (p *GatewayAPIProcessor) computeHTTPRoute(route *gatewayapi_v1alpha1.HTTPRoute, listenerSecret *Secret, listenerHostname *gatewayapi_v1alpha1.Hostname, validGateway bool) {\n\trouteAccessor, commit := p.dag.StatusCache.RouteConditionsAccessor(k8s.NamespacedNameOf(route), route.Generation, status.ResourceHTTPRoute, route.Status.Gateways)\n\tdefer commit()\n\n\t// If the Gateway is invalid, set status on the route.\n\tif !validGateway {\n\t\trouteAccessor.AddCondition(gatewayapi_v1alpha1.ConditionRouteAdmitted, metav1.ConditionFalse, status.ReasonInvalidGateway, \"Invalid Gateway\")\n\t\treturn\n\t}\n\n\thosts, errs := p.computeHosts(route.Spec.Hostnames, listenerHostname)\n\tfor _, err := range errs {\n\t\trouteAccessor.AddCondition(status.ConditionResolvedRefs, metav1.ConditionFalse, status.ReasonDegraded, err.Error())\n\t}\n\n\t// Check if all the hostnames are invalid.\n\tif len(hosts) == 0 {\n\t\trouteAccessor.AddCondition(gatewayapi_v1alpha1.ConditionRouteAdmitted, metav1.ConditionFalse, status.ReasonErrorsExist, \"Errors found, check other Conditions for details.\")\n\t\treturn\n\t}\n\n\t// Validate TLS Configuration\n\tif route.Spec.TLS != nil {\n\t\trouteAccessor.AddCondition(status.ConditionNotImplemented, metav1.ConditionTrue, status.ReasonNotImplemented, \"HTTPRoute.Spec.TLS: Not yet implemented.\")\n\t}\n\n\tfor _, rule := range route.Spec.Rules {\n\n\t\tvar matchconditions []*matchConditions\n\n\t\tfor _, match := range rule.Matches {\n\t\t\tmc := &matchConditions{}\n\t\t\tif err := pathMatchCondition(mc, match.Path); err != nil {\n\t\t\t\trouteAccessor.AddCondition(status.ConditionNotImplemented, metav1.ConditionTrue, status.ReasonPathMatchType, \"HTTPRoute.Spec.Rules.PathMatch: Only Prefix match type and Exact match type are supported.\")\n\t\t\t}\n\n\t\t\tif err := headerMatchCondition(mc, match.Headers); err != nil {\n\t\t\t\trouteAccessor.AddCondition(status.ConditionNotImplemented, metav1.ConditionTrue, status.ReasonHeaderMatchType, \"HTTPRoute.Spec.Rules.HeaderMatch: Only Exact match type is supported.\")\n\t\t\t}\n\t\t\tmatchconditions = append(matchconditions, mc)\n\t\t}\n\n\t\tif len(rule.ForwardTo) == 0 {\n\t\t\trouteAccessor.AddCondition(status.ConditionResolvedRefs, metav1.ConditionFalse, status.ReasonDegraded, \"At least one Spec.Rules.ForwardTo must be specified.\")\n\t\t\tcontinue\n\t\t}\n\n\t\tvar clusters []*Cluster\n\n\t\t// Validate the ForwardTos.\n\t\ttotalWeight := uint32(0)\n\t\tfor _, forward := range rule.ForwardTo {\n\n\t\t\tservice, err := p.validateForwardTo(forward.ServiceName, forward.Port, route.Namespace)\n\t\t\tif err != nil {\n\t\t\t\trouteAccessor.AddCondition(status.ConditionResolvedRefs, metav1.ConditionFalse, status.ReasonDegraded, err.Error())\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvar headerPolicy *HeadersPolicy\n\t\t\tfor _, filter := range forward.Filters {\n\t\t\t\tswitch filter.Type {\n\t\t\t\tcase gatewayapi_v1alpha1.HTTPRouteFilterRequestHeaderModifier:\n\t\t\t\t\tvar err error\n\t\t\t\t\theaderPolicy, err = headersPolicyGatewayAPI(filter.RequestHeaderModifier)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\trouteAccessor.AddCondition(status.ConditionResolvedRefs, metav1.ConditionFalse, status.ReasonDegraded, fmt.Sprintf(\"%s on request headers\", err))\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\trouteAccessor.AddCondition(status.ConditionNotImplemented, metav1.ConditionTrue, status.ReasonHTTPRouteFilterType, \"HTTPRoute.Spec.Rules.ForwardTo.Filters: Only RequestHeaderModifier type is supported.\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Route defaults to a weight of \"1\" unless otherwise specified.\n\t\t\trouteWeight := uint32(1)\n\t\t\tif forward.Weight != nil {\n\t\t\t\trouteWeight = uint32(*forward.Weight)\n\t\t\t}\n\n\t\t\t// Keep track of all the weights for this set of forwardTos. This will be\n\t\t\t// used later to understand if all the weights are set to zero.\n\t\t\ttotalWeight += routeWeight\n\n\t\t\t// https://github.com/projectcontour/contour/issues/3593\n\t\t\tservice.Weighted.Weight = routeWeight\n\t\t\tclusters = append(clusters, p.cluster(headerPolicy, service, routeWeight))\n\t\t}\n\n\t\tvar headerPolicy *HeadersPolicy\n\t\tfor _, filter := range rule.Filters {\n\t\t\tswitch filter.Type {\n\t\t\tcase gatewayapi_v1alpha1.HTTPRouteFilterRequestHeaderModifier:\n\t\t\t\tvar err error\n\t\t\t\theaderPolicy, err = headersPolicyGatewayAPI(filter.RequestHeaderModifier)\n\t\t\t\tif err != nil {\n\t\t\t\t\trouteAccessor.AddCondition(status.ConditionResolvedRefs, metav1.ConditionFalse, status.ReasonDegraded, fmt.Sprintf(\"%s on request headers\", err))\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\trouteAccessor.AddCondition(status.ConditionNotImplemented, metav1.ConditionTrue, status.ReasonHTTPRouteFilterType, \"HTTPRoute.Spec.Rules.Filters: Only RequestHeaderModifier type is supported.\")\n\t\t\t}\n\t\t}\n\n\t\troutes := p.routes(matchconditions, headerPolicy, clusters)\n\t\tfor host := range hosts {\n\t\t\tfor _, route := range routes {\n\t\t\t\t// If there aren't any valid services, or the total weight of all of\n\t\t\t\t// them equal zero, then return 503 responses to the caller.\n\t\t\t\tif len(clusters) == 0 || totalWeight == 0 {\n\t\t\t\t\t// Configure a direct response HTTP status code of 503 so the\n\t\t\t\t\t// route still matches the configured conditions since the\n\t\t\t\t\t// service is missing or invalid.\n\t\t\t\t\troute.DirectResponse = &DirectResponse{\n\t\t\t\t\t\tStatusCode: http.StatusServiceUnavailable,\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If we have a wildcard match, add a header match regex rule to match the\n\t\t\t\t// hostname so we can be sure to only match one DNS label. This is required\n\t\t\t\t// as Envoy's virtualhost hostname wildcard matching can match multiple\n\t\t\t\t// labels. This match ignores a port in the hostname in case it is present.\n\t\t\t\tif strings.HasPrefix(host, \"*.\") {\n\t\t\t\t\troute.HeaderMatchConditions = append(route.HeaderMatchConditions, HeaderMatchCondition{\n\t\t\t\t\t\t// Internally Envoy uses the HTTP/2 \":authority\" header in\n\t\t\t\t\t\t// place of the HTTP/1 \"host\" header.\n\t\t\t\t\t\t// See: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#config-route-v3-headermatcher\n\t\t\t\t\t\tName:      \":authority\",\n\t\t\t\t\t\tMatchType: HeaderMatchTypeRegex,\n\t\t\t\t\t\tValue:     singleDNSLabelWildcardRegex + regexp.QuoteMeta(host[1:]),\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tswitch {\n\t\t\t\tcase listenerSecret != nil:\n\t\t\t\t\tsvhost := p.dag.EnsureSecureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_https\"})\n\t\t\t\t\tsvhost.Secret = listenerSecret\n\t\t\t\t\tsvhost.addRoute(route)\n\t\t\t\tdefault:\n\t\t\t\t\tvhost := p.dag.EnsureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_http\"})\n\t\t\t\t\tvhost.addRoute(route)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Determine if any errors exist in conditions and set the \"Admitted\"\n\t// condition accordingly.\n\tswitch len(routeAccessor.Conditions) {\n\tcase 0:\n\t\trouteAccessor.AddCondition(gatewayapi_v1alpha1.ConditionRouteAdmitted, metav1.ConditionTrue, status.ReasonValid, \"Valid HTTPRoute\")\n\tdefault:\n\t\trouteAccessor.AddCondition(gatewayapi_v1alpha1.ConditionRouteAdmitted, metav1.ConditionFalse, status.ReasonErrorsExist, \"Errors found, check other Conditions for details.\")\n\t}\n}\n\n// validateForwardTo verifies that the specified forwardTo is valid.\n// Returns an error if not or the service found in the cache.\nfunc (p *GatewayAPIProcessor) validateForwardTo(serviceName *string, port *gatewayapi_v1alpha1.PortNumber, namespace string) (*Service, error) {\n\t// Verify the service is valid\n\tif serviceName == nil {\n\t\treturn nil, fmt.Errorf(\"Spec.Rules.ForwardTo.ServiceName must be specified\")\n\t}\n\n\t// TODO: Do not require port to be present (#3352).\n\tif port == nil {\n\t\treturn nil, fmt.Errorf(\"Spec.Rules.ForwardTo.ServicePort must be specified\")\n\t}\n\n\tmeta := types.NamespacedName{Name: *serviceName, Namespace: namespace}\n\n\t// TODO: Refactor EnsureService to take an int32 so conversion to intstr is not needed.\n\tservice, err := p.dag.EnsureService(meta, intstr.FromInt(int(*port)), p.source)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"service %q does not exist\", meta.Name)\n\t}\n\n\treturn service, nil\n}\n\nfunc pathMatchCondition(mc *matchConditions, match *gatewayapi_v1alpha1.HTTPPathMatch) error {\n\n\tif match == nil {\n\t\tmc.pathMatchConditions = append(mc.pathMatchConditions, &PrefixMatchCondition{Prefix: \"/\"})\n\t\treturn nil\n\t}\n\n\tpath := pointer.StringDeref(match.Value, \"/\")\n\n\tif match.Type == nil {\n\t\t// If path match type is not defined, default to 'PrefixMatch'.\n\t\tmc.pathMatchConditions = append(mc.pathMatchConditions, &PrefixMatchCondition{Prefix: path})\n\t} else {\n\t\tswitch *match.Type {\n\t\tcase gatewayapi_v1alpha1.PathMatchPrefix:\n\t\t\tmc.pathMatchConditions = append(mc.pathMatchConditions, &PrefixMatchCondition{Prefix: path})\n\t\tcase gatewayapi_v1alpha1.PathMatchExact:\n\t\t\tmc.pathMatchConditions = append(mc.pathMatchConditions, &ExactMatchCondition{Path: path})\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"HTTPRoute.Spec.Rules.PathMatch: Only Prefix match type and Exact match type are supported\")\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc headerMatchCondition(mc *matchConditions, match *gatewayapi_v1alpha1.HTTPHeaderMatch) error {\n\tif match == nil {\n\t\treturn nil\n\t}\n\n\t// HeaderMatchTypeExact is the default if not defined in the object.\n\theaderMatchType := HeaderMatchTypeExact\n\tif match.Type != nil {\n\t\tswitch *match.Type {\n\t\tcase gatewayapi_v1alpha1.HeaderMatchExact:\n\t\t\theaderMatchType = HeaderMatchTypeExact\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"HTTPRoute.Spec.Rules.HeaderMatch: Only Exact match type is supported\")\n\t\t}\n\t}\n\n\tfor k, v := range match.Values {\n\t\tmc.headerMatchCondition = append(mc.headerMatchCondition, HeaderMatchCondition{MatchType: headerMatchType, Name: k, Value: v})\n\t}\n\n\treturn nil\n}\n\n// routes builds a []*dag.Route for the supplied set of matchConditions, headerPolicy and clusters.\nfunc (p *GatewayAPIProcessor) routes(matchConditions []*matchConditions, headerPolicy *HeadersPolicy, clusters []*Cluster) []*Route {\n\tvar routes []*Route\n\n\tfor _, mc := range matchConditions {\n\t\tfor _, pathMatch := range mc.pathMatchConditions {\n\t\t\tr := &Route{\n\t\t\t\tClusters: clusters,\n\t\t\t}\n\t\t\tr.PathMatchCondition = pathMatch\n\t\t\tr.HeaderMatchConditions = mc.headerMatchCondition\n\t\t\tr.RequestHeadersPolicy = headerPolicy\n\t\t\troutes = append(routes, r)\n\t\t}\n\t}\n\n\treturn routes\n}\n\n// cluster builds a *dag.Cluster for the supplied set of headerPolicy and service.\nfunc (p *GatewayAPIProcessor) cluster(headerPolicy *HeadersPolicy, service *Service, weight uint32) *Cluster {\n\treturn &Cluster{\n\t\tUpstream:             service,\n\t\tWeight:               weight,\n\t\tProtocol:             service.Protocol,\n\t\tRequestHeadersPolicy: headerPolicy,\n\t}\n}\n\nfunc pathMatchTypePtr(pmt gatewayapi_v1alpha1.PathMatchType) *gatewayapi_v1alpha1.PathMatchType {\n\treturn &pmt\n}\n\nfunc headerMatchTypePtr(hmt gatewayapi_v1alpha1.HeaderMatchType) *gatewayapi_v1alpha1.HeaderMatchType {\n\treturn &hmt\n}\n\nfunc gatewayAllowTypePtr(gwType gatewayapi_v1alpha1.GatewayAllowType) *gatewayapi_v1alpha1.GatewayAllowType {\n\treturn &gwType\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dag\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\n\tcontour_api_v1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"\n\tcontour_api_v1alpha1 \"github.com/projectcontour/contour/apis/projectcontour/v1alpha1\"\n\t\"github.com/projectcontour/contour/internal/annotation\"\n\t\"github.com/projectcontour/contour/internal/k8s\"\n\t\"github.com/projectcontour/contour/internal/status\"\n\t\"github.com/projectcontour/contour/internal/timeout\"\n\t\"github.com/projectcontour/contour/pkg/config\"\n\t\"k8s.io/apimachinery/pkg/api/equality\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n)\n\n// defaultExtensionRef populates the unset fields in ref with default values.\nfunc defaultExtensionRef(ref contour_api_v1.ExtensionServiceReference) contour_api_v1.ExtensionServiceReference {\n\tif ref.APIVersion == \"\" {\n\t\tref.APIVersion = contour_api_v1alpha1.GroupVersion.String()\n\n\t}\n\n\treturn ref\n}\n\n// HTTPProxyProcessor translates HTTPProxies into DAG\n// objects and adds them to the DAG.\ntype HTTPProxyProcessor struct {\n\tdag      *DAG\n\tsource   *KubernetesCache\n\torphaned map[types.NamespacedName]bool\n\n\t// DisablePermitInsecure disables the use of the\n\t// permitInsecure field in HTTPProxy.\n\tDisablePermitInsecure bool\n\n\t// FallbackCertificate is the optional identifier of the\n\t// TLS secret to use by default when SNI is not set on a\n\t// request.\n\tFallbackCertificate *types.NamespacedName\n\n\t// DNSLookupFamily defines how external names are looked up\n\t// When configured as V4, the DNS resolver will only perform a lookup\n\t// for addresses in the IPv4 family. If V6 is configured, the DNS resolver\n\t// will only perform a lookup for addresses in the IPv6 family.\n\t// If AUTO is configured, the DNS resolver will first perform a lookup\n\t// for addresses in the IPv6 family and fallback to a lookup for addresses\n\t// in the IPv4 family.\n\t// Note: This only applies to externalName clusters.\n\tDNSLookupFamily config.ClusterDNSFamilyType\n\n\t// ClientCertificate is the optional identifier of the TLS secret containing client certificate and\n\t// private key to be used when establishing TLS connection to upstream cluster.\n\tClientCertificate *types.NamespacedName\n\n\t// Request headers that will be set on all routes (optional).\n\tRequestHeadersPolicy *HeadersPolicy\n\n\t// Response headers that will be set on all routes (optional).\n\tResponseHeadersPolicy *HeadersPolicy\n}\n\n// Run translates HTTPProxies into DAG objects and\n// adds them to the DAG.\nfunc (p *HTTPProxyProcessor) Run(dag *DAG, source *KubernetesCache) {\n\tp.dag = dag\n\tp.source = source\n\tp.orphaned = make(map[types.NamespacedName]bool, len(p.orphaned))\n\n\t// reset the processor when we're done\n\tdefer func() {\n\t\tp.dag = nil\n\t\tp.source = nil\n\t\tp.orphaned = nil\n\t}()\n\n\tfor _, proxy := range p.validHTTPProxies() {\n\t\tp.computeHTTPProxy(proxy)\n\t}\n\n\tfor meta := range p.orphaned {\n\t\tproxy, ok := p.source.httpproxies[meta]\n\t\tif ok {\n\t\t\tpa, commit := p.dag.StatusCache.ProxyAccessor(proxy)\n\t\t\tpa.ConditionFor(status.ValidCondition).AddError(contour_api_v1.ConditionTypeOrphanedError,\n\t\t\t\t\"Orphaned\",\n\t\t\t\t\"this HTTPProxy is not part of a delegation chain from a root HTTPProxy\")\n\t\t\tcommit()\n\t\t}\n\t}\n}\n\nfunc (p *HTTPProxyProcessor) computeHTTPProxy(proxy *contour_api_v1.HTTPProxy) {\n\tpa, commit := p.dag.StatusCache.ProxyAccessor(proxy)\n\tvalidCond := pa.ConditionFor(status.ValidCondition)\n\n\tdefer commit()\n\n\tif proxy.Spec.VirtualHost == nil {\n\t\t// mark HTTPProxy as orphaned.\n\t\tp.orphaned[k8s.NamespacedNameOf(proxy)] = true\n\t\treturn\n\t}\n\n\thost := proxy.Spec.VirtualHost.Fqdn\n\tif isBlank(host) {\n\t\tvalidCond.AddError(contour_api_v1.ConditionTypeVirtualHostError, \"FQDNNotSpecified\",\n\t\t\t\"Spec.VirtualHost.Fqdn must be specified\")\n\t\treturn\n\t}\n\tpa.Vhost = host\n\n\t// Ensure root httpproxy lives in allowed namespace.\n\t// This check must be after we can determine the vhost in order to be able to calculate metrics correctly.\n\tif !p.rootAllowed(proxy.Namespace) {\n\t\tvalidCond.AddError(contour_api_v1.ConditionTypeRootNamespaceError, \"RootProxyNotAllowedInNamespace\",\n\t\t\t\"root HTTPProxy cannot be defined in this namespace\")\n\t\treturn\n\t}\n\n\tif strings.Contains(host, \"*\") {\n\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeVirtualHostError, \"WildCardNotAllowed\",\n\t\t\t\"Spec.VirtualHost.Fqdn %q cannot use wildcards\", host)\n\t\treturn\n\t}\n\n\tif len(proxy.Spec.Routes) == 0 && len(proxy.Spec.Includes) == 0 && proxy.Spec.TCPProxy == nil {\n\t\tvalidCond.AddError(contour_api_v1.ConditionTypeSpecError, \"NothingDefined\",\n\t\t\t\"HTTPProxy.Spec must have at least one Route, Include, or a TCPProxy\")\n\t\treturn\n\t}\n\n\tvar tlsEnabled bool\n\tif tls := proxy.Spec.VirtualHost.TLS; tls != nil {\n\t\tif tls.Passthrough && tls.EnableFallbackCertificate {\n\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTLSError, \"TLSIncompatibleFeatures\",\n\t\t\t\t\"Spec.VirtualHost.TLS: both Passthrough and enableFallbackCertificate were specified\")\n\t\t}\n\t\tif !isBlank(tls.SecretName) && tls.Passthrough {\n\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTLSError, \"TLSConfigNotValid\",\n\t\t\t\t\"Spec.VirtualHost.TLS: both Passthrough and SecretName were specified\")\n\t\t\treturn\n\t\t}\n\n\t\tif isBlank(tls.SecretName) && !tls.Passthrough {\n\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTLSError, \"TLSConfigNotValid\",\n\t\t\t\t\"Spec.VirtualHost.TLS: neither Passthrough nor SecretName were specified\")\n\t\t\treturn\n\t\t}\n\n\t\tif tls.Passthrough && tls.ClientValidation != nil {\n\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTLSError, \"TLSIncompatibleFeatures\",\n\t\t\t\t\"Spec.VirtualHost.TLS passthrough cannot be combined with tls.clientValidation\")\n\t\t\treturn\n\t\t}\n\n\t\ttlsEnabled = true\n\n\t\t// Attach secrets to TLS enabled vhosts.\n\t\tif !tls.Passthrough {\n\t\t\tsecretName := k8s.NamespacedNameFrom(tls.SecretName, k8s.DefaultNamespace(proxy.Namespace))\n\t\t\tsec, err := p.source.LookupSecret(secretName, validSecret)\n\t\t\tif err != nil {\n\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTLSError, \"SecretNotValid\",\n\t\t\t\t\t\"Spec.VirtualHost.TLS Secret %q is invalid: %s\", tls.SecretName, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !p.source.DelegationPermitted(secretName, proxy.Namespace) {\n\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTLSError, \"DelegationNotPermitted\",\n\t\t\t\t\t\"Spec.VirtualHost.TLS Secret %q certificate delegation not permitted\", tls.SecretName)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tsvhost := p.dag.EnsureSecureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_https\"})\n\t\t\tsvhost.Secret = sec\n\t\t\t// default to a minimum TLS version of 1.2 if it's not specified\n\t\t\tsvhost.MinTLSVersion = annotation.MinTLSVersion(tls.MinimumProtocolVersion, \"1.2\")\n\n\t\t\t// Check if FallbackCertificate && ClientValidation are both enabled in the same vhost\n\t\t\tif tls.EnableFallbackCertificate && tls.ClientValidation != nil {\n\t\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTLSError, \"TLSIncompatibleFeatures\",\n\t\t\t\t\t\"Spec.Virtualhost.TLS fallback & client validation are incompatible\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Fallback certificates and authorization are\n\t\t\t// incompatible because fallback installs the routes on\n\t\t\t// a separate HTTPConnectionManager. We can't have the\n\t\t\t// same routes installed on multiple managers with\n\t\t\t// inconsistent authorization settings.\n\t\t\tif tls.EnableFallbackCertificate && proxy.Spec.VirtualHost.AuthorizationConfigured() {\n\t\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTLSError, \"TLSIncompatibleFeatures\",\n\t\t\t\t\t\"Spec.Virtualhost.TLS fallback & client authorization are incompatible\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// If FallbackCertificate is enabled, but no cert passed, set error\n\t\t\tif tls.EnableFallbackCertificate {\n\t\t\t\tif p.FallbackCertificate == nil {\n\t\t\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTLSError, \"FallbackNotPresent\",\n\t\t\t\t\t\t\"Spec.Virtualhost.TLS enabled fallback but the fallback Certificate Secret is not configured in Contour configuration file\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tsec, err = p.source.LookupSecret(*p.FallbackCertificate, validSecret)\n\t\t\t\tif err != nil {\n\t\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTLSError, \"FallbackNotValid\",\n\t\t\t\t\t\t\"Spec.Virtualhost.TLS Secret %q fallback certificate is invalid: %s\", p.FallbackCertificate, err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif !p.source.DelegationPermitted(*p.FallbackCertificate, proxy.Namespace) {\n\t\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTLSError, \"FallbackNotDelegated\",\n\t\t\t\t\t\t\"Spec.VirtualHost.TLS fallback Secret %q is not configured for certificate delegation\", p.FallbackCertificate)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tsvhost.FallbackCertificate = sec\n\t\t\t}\n\n\t\t\t// Fill in DownstreamValidation when external client validation is enabled.\n\t\t\tif tls.ClientValidation != nil {\n\t\t\t\tdv := &PeerValidationContext{\n\t\t\t\t\tSkipClientCertValidation: tls.ClientValidation.SkipClientCertValidation,\n\t\t\t\t}\n\t\t\t\tif tls.ClientValidation.CACertificate != \"\" {\n\t\t\t\t\tsecretName := k8s.NamespacedNameFrom(tls.ClientValidation.CACertificate, k8s.DefaultNamespace(proxy.Namespace))\n\t\t\t\t\tcacert, err := p.source.LookupSecret(secretName, validCA)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t// PeerValidationContext is requested, but cert is missing or not configured.\n\t\t\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTLSError, \"ClientValidationInvalid\",\n\t\t\t\t\t\t\t\"Spec.VirtualHost.TLS client validation is invalid: invalid CA Secret %q: %s\", secretName, err)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tdv.CACertificate = cacert\n\t\t\t\t} else if !tls.ClientValidation.SkipClientCertValidation {\n\t\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTLSError, \"ClientValidationInvalid\",\n\t\t\t\t\t\t\"Spec.VirtualHost.TLS client validation is invalid: CA Secret must be specified\")\n\t\t\t\t}\n\t\t\t\tsvhost.DownstreamValidation = dv\n\t\t\t}\n\n\t\t\tif proxy.Spec.VirtualHost.AuthorizationConfigured() {\n\t\t\t\tauth := proxy.Spec.VirtualHost.Authorization\n\t\t\t\tref := defaultExtensionRef(auth.ExtensionServiceRef)\n\n\t\t\t\tif ref.APIVersion != contour_api_v1alpha1.GroupVersion.String() {\n\t\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeAuthError, \"AuthBadResourceVersion\",\n\t\t\t\t\t\t\"Spec.Virtualhost.Authorization.extensionRef specifies an unsupported resource version %q\", auth.ExtensionServiceRef.APIVersion)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// Lookup the extension service reference.\n\t\t\t\textensionName := types.NamespacedName{\n\t\t\t\t\tName:      ref.Name,\n\t\t\t\t\tNamespace: stringOrDefault(ref.Namespace, proxy.Namespace),\n\t\t\t\t}\n\n\t\t\t\text := p.dag.GetExtensionCluster(ExtensionClusterName(extensionName))\n\t\t\t\tif ext == nil {\n\t\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeAuthError, \"ExtensionServiceNotFound\",\n\t\t\t\t\t\t\"Spec.Virtualhost.Authorization.ServiceRef extension service %q not found\", extensionName)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tsvhost.AuthorizationService = ext\n\t\t\t\tsvhost.AuthorizationFailOpen = auth.FailOpen\n\n\t\t\t\ttimeout, err := timeout.Parse(auth.ResponseTimeout)\n\t\t\t\tif err != nil {\n\t\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeAuthError, \"AuthResponseTimeoutInvalid\",\n\t\t\t\t\t\t\"Spec.Virtualhost.Authorization.ResponseTimeout is invalid: %s\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif timeout.UseDefault() {\n\t\t\t\t\tsvhost.AuthorizationResponseTimeout = ext.TimeoutPolicy.ResponseTimeout\n\t\t\t\t} else {\n\t\t\t\t\tsvhost.AuthorizationResponseTimeout = timeout\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif proxy.Spec.TCPProxy != nil {\n\t\tif !tlsEnabled {\n\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTCPProxyError, \"TLSMustBeConfigured\",\n\t\t\t\t\"Spec.TCPProxy requires that either Spec.TLS.Passthrough or Spec.TLS.SecretName be set\")\n\t\t\treturn\n\t\t}\n\t\tif !p.processHTTPProxyTCPProxy(validCond, proxy, nil, host) {\n\t\t\treturn\n\t\t}\n\t}\n\n\troutes := p.computeRoutes(validCond, proxy, proxy, nil, nil, tlsEnabled)\n\tinsecure := p.dag.EnsureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_http\"})\n\tcp, err := toCORSPolicy(proxy.Spec.VirtualHost.CORSPolicy)\n\tif err != nil {\n\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeCORSError, \"PolicyDidNotParse\",\n\t\t\t\"Spec.VirtualHost.CORSPolicy: %s\", err)\n\t\treturn\n\t}\n\tinsecure.CORSPolicy = cp\n\n\trlp, err := rateLimitPolicy(proxy.Spec.VirtualHost.RateLimitPolicy)\n\tif err != nil {\n\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeRouteError, \"RateLimitPolicyNotValid\",\n\t\t\t\"Spec.VirtualHost.RateLimitPolicy is invalid: %s\", err)\n\t\treturn\n\t}\n\tinsecure.RateLimitPolicy = rlp\n\n\taddRoutes(insecure, routes)\n\n\t// if TLS is enabled for this virtual host and there is no tcp proxy defined,\n\t// then add routes to the secure virtualhost definition.\n\tif tlsEnabled && proxy.Spec.TCPProxy == nil {\n\t\tsecure := p.dag.EnsureSecureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_https\"})\n\t\tsecure.CORSPolicy = cp\n\n\t\trlp, err := rateLimitPolicy(proxy.Spec.VirtualHost.RateLimitPolicy)\n\t\tif err != nil {\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeRouteError, \"RateLimitPolicyNotValid\",\n\t\t\t\t\"Spec.VirtualHost.RateLimitPolicy is invalid: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tsecure.RateLimitPolicy = rlp\n\n\t\taddRoutes(secure, routes)\n\t}\n}\n\ntype vhost interface {\n\taddRoute(*Route)\n}\n\n// addRoutes adds all routes to the vhost supplied.\nfunc addRoutes(vhost vhost, routes []*Route) {\n\tfor _, route := range routes {\n\t\tvhost.addRoute(route)\n\t}\n}\n\nfunc (p *HTTPProxyProcessor) computeRoutes(\n\tvalidCond *contour_api_v1.DetailedCondition,\n\trootProxy *contour_api_v1.HTTPProxy,\n\tproxy *contour_api_v1.HTTPProxy,\n\tconditions []contour_api_v1.MatchCondition,\n\tvisited []*contour_api_v1.HTTPProxy,\n\tenforceTLS bool,\n) []*Route {\n\tfor _, v := range visited {\n\t\t// ensure we are not following an edge that produces a cycle\n\t\tvar path []string\n\t\tfor _, vir := range visited {\n\t\t\tpath = append(path, fmt.Sprintf(\"%s/%s\", vir.Namespace, vir.Name))\n\t\t}\n\t\tif v.Name == proxy.Name && v.Namespace == proxy.Namespace {\n\t\t\tpath = append(path, fmt.Sprintf(\"%s/%s\", proxy.Namespace, proxy.Name))\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeIncludeError, \"IncludeCreatesCycle\",\n\t\t\t\t\"include creates an include cycle: %s\", strings.Join(path, \" -> \"))\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tvisited = append(visited, proxy)\n\tvar routes []*Route\n\n\t// Check for duplicate conditions on the includes\n\tif includeMatchConditionsIdentical(proxy.Spec.Includes) {\n\t\tvalidCond.AddError(contour_api_v1.ConditionTypeIncludeError, \"DuplicateMatchConditions\",\n\t\t\t\"duplicate conditions defined on an include\")\n\t\treturn nil\n\t}\n\n\t// Loop over and process all includes\n\tfor _, include := range proxy.Spec.Includes {\n\t\tnamespace := include.Namespace\n\t\tif namespace == \"\" {\n\t\t\tnamespace = proxy.Namespace\n\t\t}\n\n\t\tincludedProxy, ok := p.source.httpproxies[types.NamespacedName{Name: include.Name, Namespace: namespace}]\n\t\tif !ok {\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeIncludeError, \"IncludeNotFound\",\n\t\t\t\t\"include %s/%s not found\", namespace, include.Name)\n\t\t\treturn nil\n\t\t}\n\t\tif includedProxy.Spec.VirtualHost != nil {\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeIncludeError, \"RootIncludesRoot\",\n\t\t\t\t\"root httpproxy cannot include another root httpproxy\")\n\t\t\treturn nil\n\t\t}\n\n\t\tif err := pathMatchConditionsValid(include.Conditions); err != nil {\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeIncludeError, \"PathMatchConditionsNotValid\",\n\t\t\t\t\"include: %s\", err)\n\t\t\treturn nil\n\t\t}\n\n\t\tinc, incCommit := p.dag.StatusCache.ProxyAccessor(includedProxy)\n\t\tincValidCond := inc.ConditionFor(status.ValidCondition)\n\t\troutes = append(routes, p.computeRoutes(incValidCond, rootProxy, includedProxy, append(conditions, include.Conditions...), visited, enforceTLS)...)\n\t\tincCommit()\n\n\t\t// dest is not an orphaned httpproxy, as there is an httpproxy that points to it\n\t\tdelete(p.orphaned, types.NamespacedName{Name: includedProxy.Name, Namespace: includedProxy.Namespace})\n\t}\n\n\tdynamicHeaders := map[string]string{\n\t\t\"CONTOUR_NAMESPACE\": proxy.Namespace,\n\t}\n\n\tfor _, route := range proxy.Spec.Routes {\n\t\tif err := pathMatchConditionsValid(route.Conditions); err != nil {\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeRouteError, \"PathMatchConditionsNotValid\",\n\t\t\t\t\"route: %s\", err)\n\t\t\treturn nil\n\t\t}\n\n\t\tconds := append(conditions, route.Conditions...)\n\n\t\t// Look for invalid header conditions on this route\n\t\tif err := headerMatchConditionsValid(conds); err != nil {\n\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeRouteError, \"HeaderMatchConditionsNotValid\",\n\t\t\t\terr.Error())\n\t\t\treturn nil\n\t\t}\n\n\t\treqHP, err := headersPolicyRoute(route.RequestHeadersPolicy, true /* allow Host */, dynamicHeaders)\n\t\tif err != nil {\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeRouteError, \"RequestHeadersPolicyInvalid\",\n\t\t\t\t\"%s on request headers\", err)\n\t\t\treturn nil\n\t\t}\n\n\t\trespHP, err := headersPolicyRoute(route.ResponseHeadersPolicy, false /* disallow Host */, dynamicHeaders)\n\t\tif err != nil {\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeRouteError, \"ResponseHeaderPolicyInvalid\",\n\t\t\t\t\"%s on response headers\", err)\n\t\t\treturn nil\n\t\t}\n\n\t\tif len(route.Services) < 1 {\n\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeRouteError, \"NoServicesPresent\",\n\t\t\t\t\"route.services must have at least one entry\")\n\t\t\treturn nil\n\t\t}\n\n\t\ttp, err := timeoutPolicy(route.TimeoutPolicy)\n\t\tif err != nil {\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeRouteError, \"TimeoutPolicyNotValid\",\n\t\t\t\t\"route.timeoutPolicy failed to parse: %s\", err)\n\t\t\treturn nil\n\t\t}\n\n\t\trlp, err := rateLimitPolicy(route.RateLimitPolicy)\n\t\tif err != nil {\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeRouteError, \"RateLimitPolicyNotValid\",\n\t\t\t\t\"route.rateLimitPolicy is invalid: %s\", err)\n\t\t\treturn nil\n\t\t}\n\n\t\trequestHashPolicies, lbPolicy := loadBalancerRequestHashPolicies(route.LoadBalancerPolicy, validCond)\n\n\t\tr := &Route{\n\t\t\tPathMatchCondition:    mergePathMatchConditions(conds),\n\t\t\tHeaderMatchConditions: mergeHeaderMatchConditions(conds),\n\t\t\tWebsocket:             route.EnableWebsockets,\n\t\t\tHTTPSUpgrade:          routeEnforceTLS(enforceTLS, route.PermitInsecure && !p.DisablePermitInsecure),\n\t\t\tTimeoutPolicy:         tp,\n\t\t\tRetryPolicy:           retryPolicy(route.RetryPolicy),\n\t\t\tRequestHeadersPolicy:  reqHP,\n\t\t\tResponseHeadersPolicy: respHP,\n\t\t\tRateLimitPolicy:       rlp,\n\t\t\tRequestHashPolicies:   requestHashPolicies,\n\t\t}\n\n\t\t// If the enclosing root proxy enabled authorization,\n\t\t// enable it on the route and propagate defaults\n\t\t// downwards.\n\t\tif rootProxy.Spec.VirtualHost.AuthorizationConfigured() {\n\t\t\t// When the ext_authz filter is added to a\n\t\t\t// vhost, it is in enabled state, but we can\n\t\t\t// disable it per route. We emulate disabling\n\t\t\t// it at the vhost layer by defaulting the state\n\t\t\t// from the root proxy.\n\t\t\tdisabled := rootProxy.Spec.VirtualHost.DisableAuthorization()\n\n\t\t\t// Take the default for enabling authorization\n\t\t\t// from the virtual host. If this route has a\n\t\t\t// policy, let that override.\n\t\t\tif route.AuthPolicy != nil {\n\t\t\t\tdisabled = route.AuthPolicy.Disabled\n\t\t\t}\n\n\t\t\tr.AuthDisabled = disabled\n\t\t\tr.AuthContext = route.AuthorizationContext(rootProxy.Spec.VirtualHost.AuthorizationContext())\n\t\t}\n\n\t\tif len(route.GetPrefixReplacements()) > 0 {\n\t\t\tif !r.HasPathPrefix() {\n\t\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypePrefixReplaceError, \"MustHavePrefix\",\n\t\t\t\t\t\"cannot specify prefix replacements without a prefix condition\")\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tif reason, err := prefixReplacementsAreValid(route.GetPrefixReplacements()); err != nil {\n\t\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypePrefixReplaceError, reason, err.Error())\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Note that we are guaranteed to always have a prefix\n\t\t\t// condition. Even if the CRD user didn't specify a\n\t\t\t// prefix condition, mergePathConditions() guarantees\n\t\t\t// a prefix of '/'.\n\t\t\troutingPrefix := r.PathMatchCondition.(*PrefixMatchCondition).Prefix\n\n\t\t\t// First, try to apply an exact prefix match.\n\t\t\tfor _, prefix := range route.GetPrefixReplacements() {\n\t\t\t\tif len(prefix.Prefix) > 0 && routingPrefix == prefix.Prefix {\n\t\t\t\t\tr.PrefixRewrite = prefix.Replacement\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there wasn't a match, we can apply the default replacement.\n\t\t\tif len(r.PrefixRewrite) == 0 {\n\t\t\t\tfor _, prefix := range route.GetPrefixReplacements() {\n\t\t\t\t\tif len(prefix.Prefix) == 0 {\n\t\t\t\t\t\tr.PrefixRewrite = prefix.Replacement\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tfor _, service := range route.Services {\n\t\t\tif service.Port < 1 || service.Port > 65535 {\n\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeServiceError, \"ServicePortInvalid\",\n\t\t\t\t\t\"service %q: port must be in the range 1-65535\", service.Name)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tm := types.NamespacedName{Name: service.Name, Namespace: proxy.Namespace}\n\t\t\ts, err := p.dag.EnsureService(m, intstr.FromInt(service.Port), p.source)\n\t\t\tif err != nil {\n\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeServiceError, \"ServiceUnresolvedReference\",\n\t\t\t\t\t\"Spec.Routes unresolved service reference: %s\", err)\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Determine the protocol to use to speak to this Cluster.\n\t\t\tprotocol, err := getProtocol(service, s)\n\t\t\tif err != nil {\n\t\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeServiceError, \"UnsupportedProtocol\", err.Error())\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tvar uv *PeerValidationContext\n\t\t\tif protocol == \"tls\" || protocol == \"h2\" {\n\t\t\t\t// we can only validate TLS connections to services that talk TLS\n\t\t\t\tuv, err = p.source.LookupUpstreamValidation(service.UpstreamValidation, proxy.Namespace)\n\t\t\t\tif err != nil {\n\t\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeServiceError, \"TLSUpstreamValidation\",\n\t\t\t\t\t\t\"Service [%s:%d] TLS upstream validation policy error: %s\", service.Name, service.Port, err)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdynamicHeaders[\"CONTOUR_SERVICE_NAME\"] = service.Name\n\t\t\tdynamicHeaders[\"CONTOUR_SERVICE_PORT\"] = strconv.Itoa(service.Port)\n\n\t\t\treqHP, err := headersPolicyService(p.RequestHeadersPolicy, service.RequestHeadersPolicy, dynamicHeaders)\n\t\t\tif err != nil {\n\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeServiceError, \"RequestHeadersPolicyInvalid\",\n\t\t\t\t\t\"%s on request headers\", err)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\trespHP, err := headersPolicyService(p.ResponseHeadersPolicy, service.ResponseHeadersPolicy, dynamicHeaders)\n\t\t\tif err != nil {\n\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeServiceError, \"ResponseHeadersPolicyInvalid\",\n\t\t\t\t\t\"%s on response headers\", err)\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tvar clientCertSecret *Secret\n\t\t\tif p.ClientCertificate != nil {\n\t\t\t\tclientCertSecret, err = p.source.LookupSecret(*p.ClientCertificate, validSecret)\n\t\t\t\tif err != nil {\n\t\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTLSError, \"SecretNotValid\",\n\t\t\t\t\t\t\"tls.envoy-client-certificate Secret %q is invalid: %s\", p.ClientCertificate, err)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc := &Cluster{\n\t\t\t\tUpstream:              s,\n\t\t\t\tLoadBalancerPolicy:    lbPolicy,\n\t\t\t\tWeight:                uint32(service.Weight),\n\t\t\t\tHTTPHealthCheckPolicy: httpHealthCheckPolicy(route.HealthCheckPolicy),\n\t\t\t\tUpstreamValidation:    uv,\n\t\t\t\tRequestHeadersPolicy:  reqHP,\n\t\t\t\tResponseHeadersPolicy: respHP,\n\t\t\t\tProtocol:              protocol,\n\t\t\t\tSNI:                   determineSNI(r.RequestHeadersPolicy, reqHP, s),\n\t\t\t\tDNSLookupFamily:       string(p.DNSLookupFamily),\n\t\t\t\tClientCertificate:     clientCertSecret,\n\t\t\t}\n\t\t\tif service.Mirror && r.MirrorPolicy != nil {\n\t\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeServiceError, \"OnlyOneMirror\",\n\t\t\t\t\t\"only one service per route may be nominated as mirror\")\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif service.Mirror {\n\t\t\t\tr.MirrorPolicy = &MirrorPolicy{\n\t\t\t\t\tCluster: c,\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr.Clusters = append(r.Clusters, c)\n\t\t\t}\n\t\t}\n\t\troutes = append(routes, r)\n\t}\n\n\troutes = expandPrefixMatches(routes)\n\n\treturn routes\n}\n\n// processHTTPProxyTCPProxy processes the spec.tcpproxy stanza in a HTTPProxy document\n// following the chain of spec.tcpproxy.include references. It returns true if processing\n// was successful, otherwise false if an error was encountered. The details of the error\n// will be recorded on the status of the relevant HTTPProxy object,\nfunc (p *HTTPProxyProcessor) processHTTPProxyTCPProxy(validCond *contour_api_v1.DetailedCondition, httpproxy *contour_api_v1.HTTPProxy, visited []*contour_api_v1.HTTPProxy, host string) bool {\n\ttcpproxy := httpproxy.Spec.TCPProxy\n\tif tcpproxy == nil {\n\t\t// nothing to do\n\t\treturn true\n\t}\n\n\tvisited = append(visited, httpproxy)\n\n\t// #2218 Allow support for both plural and singular \"Include\" for TCPProxy for the v1 API Spec\n\t// Prefer configurations for singular over the plural version\n\ttcpProxyInclude := tcpproxy.Include\n\tif tcpproxy.Include == nil {\n\t\ttcpProxyInclude = tcpproxy.IncludesDeprecated\n\t}\n\n\tif len(tcpproxy.Services) > 0 && tcpProxyInclude != nil {\n\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTCPProxyError, \"NoServicesAndInclude\",\n\t\t\t\"cannot specify services and include in the same httpproxy\")\n\t\treturn false\n\t}\n\n\tlbPolicy := loadBalancerPolicy(tcpproxy.LoadBalancerPolicy)\n\tswitch lbPolicy {\n\tcase LoadBalancerPolicyCookie, LoadBalancerPolicyRequestHash:\n\t\tvalidCond.AddWarningf(contour_api_v1.ConditionTypeTCPProxyError, \"IgnoredField\",\n\t\t\t\"ignoring field %q; %s load balancer policy is not supported for TCPProxies\",\n\t\t\t\"Spec.TCPProxy.LoadBalancerPolicy\", lbPolicy)\n\t\t// Reset load balancer policy to ensure the default.\n\t\tlbPolicy = \"\"\n\t}\n\n\tif len(tcpproxy.Services) > 0 {\n\t\tvar proxy TCPProxy\n\t\tfor _, service := range httpproxy.Spec.TCPProxy.Services {\n\t\t\tm := types.NamespacedName{Name: service.Name, Namespace: httpproxy.Namespace}\n\t\t\ts, err := p.dag.EnsureService(m, intstr.FromInt(service.Port), p.source)\n\t\t\tif err != nil {\n\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTCPProxyError, \"UnresolvedServiceRef\",\n\t\t\t\t\t\"Spec.TCPProxy unresolved service reference: %s\", err)\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\t// Determine the protocol to use to speak to this Cluster.\n\t\t\tprotocol, err := getProtocol(service, s)\n\t\t\tif err != nil {\n\t\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeServiceError, \"UnsupportedProtocol\", err.Error())\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tproxy.Clusters = append(proxy.Clusters, &Cluster{\n\t\t\t\tUpstream:             s,\n\t\t\t\tProtocol:             protocol,\n\t\t\t\tLoadBalancerPolicy:   lbPolicy,\n\t\t\t\tTCPHealthCheckPolicy: tcpHealthCheckPolicy(tcpproxy.HealthCheckPolicy),\n\t\t\t\tSNI:                  s.ExternalName,\n\t\t\t})\n\t\t}\n\t\tsecure := p.dag.EnsureSecureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_https\"})\n\t\tsecure.TCPProxy = &proxy\n\n\t\treturn true\n\t}\n\n\tif tcpProxyInclude == nil {\n\t\t// We don't allow an empty TCPProxy object.\n\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTCPProxyError, \"NothingDefined\",\n\t\t\t\"either services or inclusion must be specified\")\n\t\treturn false\n\t}\n\n\tnamespace := tcpProxyInclude.Namespace\n\tif namespace == \"\" {\n\t\t// we are delegating to another HTTPProxy in the same namespace\n\t\tnamespace = httpproxy.Namespace\n\t}\n\n\tm := types.NamespacedName{Name: tcpProxyInclude.Name, Namespace: namespace}\n\tdest, ok := p.source.httpproxies[m]\n\tif !ok {\n\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTCPProxyIncludeError, \"IncludeNotFound\",\n\t\t\t\"include %s/%s not found\", m.Namespace, m.Name)\n\t\treturn false\n\t}\n\n\tif dest.Spec.VirtualHost != nil {\n\n\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTCPProxyIncludeError, \"RootIncludesRoot\",\n\t\t\t\"root httpproxy cannot include another root httpproxy\")\n\t\treturn false\n\t}\n\n\t// dest is no longer an orphan\n\tdelete(p.orphaned, k8s.NamespacedNameOf(dest))\n\n\t// ensure we are not following an edge that produces a cycle\n\tvar path []string\n\tfor _, hp := range visited {\n\t\tpath = append(path, fmt.Sprintf(\"%s/%s\", hp.Namespace, hp.Name))\n\t}\n\tfor _, hp := range visited {\n\t\tif dest.Name == hp.Name && dest.Namespace == hp.Namespace {\n\t\t\tpath = append(path, fmt.Sprintf(\"%s/%s\", dest.Namespace, dest.Name))\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTCPProxyIncludeError, \"IncludeCreatesCycle\",\n\t\t\t\t\"include creates a cycle: %s\", strings.Join(path, \" -> \"))\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// follow the link and process the target tcpproxy\n\tinc, commit := p.dag.StatusCache.ProxyAccessor(dest)\n\tincValidCond := inc.ConditionFor(status.ValidCondition)\n\tdefer commit()\n\tok = p.processHTTPProxyTCPProxy(incValidCond, dest, visited, host)\n\treturn ok\n}\n\n// validHTTPProxies returns a slice of *contour_api_v1.HTTPProxy objects.\n// invalid HTTPProxy objects are excluded from the slice and their status\n// updated accordingly.\nfunc (p *HTTPProxyProcessor) validHTTPProxies() []*contour_api_v1.HTTPProxy {\n\t// ensure that a given fqdn is only referenced in a single HTTPProxy resource\n\tvar valid []*contour_api_v1.HTTPProxy\n\tfqdnHTTPProxies := make(map[string][]*contour_api_v1.HTTPProxy)\n\tfor _, proxy := range p.source.httpproxies {\n\t\tif proxy.Spec.VirtualHost == nil {\n\t\t\tvalid = append(valid, proxy)\n\t\t\tcontinue\n\t\t}\n\t\tfqdn := strings.ToLower(proxy.Spec.VirtualHost.Fqdn)\n\t\tfqdnHTTPProxies[fqdn] = append(fqdnHTTPProxies[fqdn], proxy)\n\t}\n\n\tfor fqdn, proxies := range fqdnHTTPProxies {\n\t\tswitch len(proxies) {\n\t\tcase 1:\n\t\t\tvalid = append(valid, proxies[0])\n\t\tdefault:\n\t\t\t// multiple proxies use the same fqdn. mark them as invalid.\n\t\t\tvar conflicting []string\n\t\t\tfor _, proxy := range proxies {\n\t\t\t\tconflicting = append(conflicting, proxy.Namespace+\"/\"+proxy.Name)\n\t\t\t}\n\t\t\tsort.Strings(conflicting) // sort for test stability\n\t\t\tmsg := fmt.Sprintf(\"fqdn %q is used in multiple HTTPProxies: %s\", fqdn, strings.Join(conflicting, \", \"))\n\t\t\tfor _, proxy := range proxies {\n\t\t\t\tpa, commit := p.dag.StatusCache.ProxyAccessor(proxy)\n\t\t\t\tpa.Vhost = fqdn\n\t\t\t\tpa.ConditionFor(status.ValidCondition).AddError(contour_api_v1.ConditionTypeVirtualHostError,\n\t\t\t\t\t\"DuplicateVhost\",\n\t\t\t\t\tmsg)\n\t\t\t\tcommit()\n\t\t\t}\n\t\t}\n\t}\n\treturn valid\n}\n\n// rootAllowed returns true if the HTTPProxy lives in a permitted root namespace.\nfunc (p *HTTPProxyProcessor) rootAllowed(namespace string) bool {\n\tif len(p.source.RootNamespaces) == 0 {\n\t\treturn true\n\t}\n\tfor _, ns := range p.source.RootNamespaces {\n\t\tif ns == namespace {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// expandPrefixMatches adds new Routes to account for the difference\n// between prefix replacement when matching on '/foo' and '/foo/'.\n//\n// The table below shows the behavior of Envoy prefix rewrite. If we\n// match on only `/foo` or `/foo/`, then the unwanted rewrites marked\n// with X can result. This means that we need to generate separate\n// prefix matches (and replacements) for these cases.\n//\n// | Matching Prefix | Replacement | Client Path | Rewritten Path |\n// |-----------------|-------------|-------------|----------------|\n// | `/foo`          | `/bar`      | `/foosball` |   `/barsball`  |\n// | `/foo`          | `/`         | `/foo/v1`   | X `//v1`       |\n// | `/foo/`         | `/bar`      | `/foo/type` | X `/bartype`   |\n// | `/foo`          | `/bar/`     | `/foosball` | X `/bar/sball` |\n// | `/foo/`         | `/bar/`     | `/foo/type` |   `/bar/type`  |\nfunc expandPrefixMatches(routes []*Route) []*Route {\n\tprefixedRoutes := map[string][]*Route{}\n\n\texpandedRoutes := []*Route{}\n\n\t// First, we group the Routes by their slash-consistent prefix match condition.\n\tfor _, r := range routes {\n\t\t// If there is no path prefix, we won't do any expansion, so skip it.\n\t\tif !r.HasPathPrefix() {\n\t\t\texpandedRoutes = append(expandedRoutes, r)\n\t\t}\n\n\t\troutingPrefix := r.PathMatchCondition.(*PrefixMatchCondition).Prefix\n\n\t\tif routingPrefix != \"/\" {\n\t\t\troutingPrefix = strings.TrimRight(routingPrefix, \"/\")\n\t\t}\n\n\t\tprefixedRoutes[routingPrefix] = append(prefixedRoutes[routingPrefix], r)\n\t}\n\n\tfor prefix, routes := range prefixedRoutes {\n\t\t// Propagate the Routes into the expanded set. Since\n\t\t// we have a slice of pointers, we can propagate here\n\t\t// prior to any Route modifications.\n\t\texpandedRoutes = append(expandedRoutes, routes...)\n\n\t\tswitch len(routes) {\n\t\tcase 1:\n\t\t\t// Don't modify if we are not doing a replacement.\n\t\t\tif len(routes[0].PrefixRewrite) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\troutingPrefix := routes[0].PathMatchCondition.(*PrefixMatchCondition).Prefix\n\n\t\t\t// There's no alternate forms for '/' :)\n\t\t\tif routingPrefix == \"/\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Shallow copy the Route. TODO(jpeach) deep copying would be more robust.\n\t\t\tnewRoute := *routes[0]\n\n\t\t\t// Now, make the original route handle '/foo' and the new route handle '/foo'.\n\t\t\troutes[0].PrefixRewrite = strings.TrimRight(routes[0].PrefixRewrite, \"/\")\n\t\t\troutes[0].PathMatchCondition = &PrefixMatchCondition{Prefix: prefix}\n\n\t\t\tnewRoute.PrefixRewrite = routes[0].PrefixRewrite + \"/\"\n\t\t\tnewRoute.PathMatchCondition = &PrefixMatchCondition{Prefix: prefix + \"/\"}\n\n\t\t\t// Since we trimmed trailing '/', it's possible that\n\t\t\t// we made the replacement empty. There's no such\n\t\t\t// thing as an empty rewrite; it's the same as\n\t\t\t// rewriting to '/'.\n\t\t\tif len(routes[0].PrefixRewrite) == 0 {\n\t\t\t\troutes[0].PrefixRewrite = \"/\"\n\t\t\t}\n\n\t\t\texpandedRoutes = append(expandedRoutes, &newRoute)\n\t\tcase 2:\n\t\t\t// This group routes on both '/foo' and\n\t\t\t// '/foo/' so we can't add any implicit prefix\n\t\t\t// matches. This is why we didn't filter out\n\t\t\t// routes that don't have replacements earlier.\n\t\t\tcontinue\n\t\tdefault:\n\t\t\t// This can't happen unless there are routes\n\t\t\t// with duplicate prefix paths.\n\t\t}\n\n\t}\n\n\treturn expandedRoutes\n}\n\nfunc getProtocol(service contour_api_v1.Service, s *Service) (string, error) {\n\t// Determine the protocol to use to speak to this Cluster.\n\tvar protocol string\n\tif service.Protocol != nil {\n\t\tprotocol = *service.Protocol\n\t\tswitch protocol {\n\t\tcase \"h2c\", \"h2\", \"tls\":\n\t\tdefault:\n\t\t\treturn \"\", fmt.Errorf(\"unsupported protocol: %v\", protocol)\n\t\t}\n\t} else {\n\t\tprotocol = s.Protocol\n\t}\n\n\treturn protocol, nil\n}\n\n// determineSNI decides what the SNI should be on the request. It is configured via RequestHeadersPolicy.Host key.\n// Policies set on service are used before policies set on a route. Otherwise the value of the externalService\n// is used if the route is configured to proxy to an externalService type.\nfunc determineSNI(routeRequestHeaders *HeadersPolicy, clusterRequestHeaders *HeadersPolicy, service *Service) string {\n\n\t// Service RequestHeadersPolicy take precedence\n\tif clusterRequestHeaders != nil {\n\t\tif clusterRequestHeaders.HostRewrite != \"\" {\n\t\t\treturn clusterRequestHeaders.HostRewrite\n\t\t}\n\t}\n\n\t// Route RequestHeadersPolicy take precedence after service\n\tif routeRequestHeaders != nil {\n\t\tif routeRequestHeaders.HostRewrite != \"\" {\n\t\t\treturn routeRequestHeaders.HostRewrite\n\t\t}\n\t}\n\n\treturn service.ExternalName\n}\n\nfunc toCORSPolicy(policy *contour_api_v1.CORSPolicy) (*CORSPolicy, error) {\n\tif policy == nil {\n\t\treturn nil, nil\n\t}\n\tmaxAge, err := timeout.ParseMaxAge(policy.MaxAge)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif maxAge.Duration().Seconds() < 0 {\n\t\treturn nil, fmt.Errorf(\"invalid max age value %q\", policy.MaxAge)\n\t}\n\treturn &CORSPolicy{\n\t\tAllowCredentials: policy.AllowCredentials,\n\t\tAllowHeaders:     toStringSlice(policy.AllowHeaders),\n\t\tAllowMethods:     toStringSlice(policy.AllowMethods),\n\t\tAllowOrigin:      policy.AllowOrigin,\n\t\tExposeHeaders:    toStringSlice(policy.ExposeHeaders),\n\t\tMaxAge:           maxAge,\n\t}, nil\n}\n\nfunc toStringSlice(hvs []contour_api_v1.CORSHeaderValue) []string {\n\ts := make([]string, len(hvs))\n\tfor i, v := range hvs {\n\t\ts[i] = string(v)\n\t}\n\treturn s\n}\n\nfunc includeMatchConditionsIdentical(includes []contour_api_v1.Include) bool {\n\tj := 0\n\tfor i := 1; i < len(includes); i++ {\n\t\t// Now compare each include's set of conditions\n\t\tfor _, cA := range includes[i].Conditions {\n\t\t\tfor _, cB := range includes[j].Conditions {\n\t\t\t\tif (cA.Prefix == cB.Prefix) && equality.Semantic.DeepEqual(cA.Header, cB.Header) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tj++\n\t}\n\treturn false\n}\n\n// isBlank indicates if a string contains nothing but blank characters.\nfunc isBlank(s string) bool {\n\treturn len(strings.TrimSpace(s)) == 0\n}\n\n// routeEnforceTLS determines if the route should redirect the user to a secure TLS listener\nfunc routeEnforceTLS(enforceTLS, permitInsecure bool) bool {\n\treturn enforceTLS && !permitInsecure\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dag\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n\n\t\"github.com/projectcontour/contour/internal/annotation\"\n\t\"github.com/projectcontour/contour/internal/k8s\"\n\t\"github.com/sirupsen/logrus\"\n\tnetworking_v1 \"k8s.io/api/networking/v1\"\n\t\"k8s.io/apimachinery/pkg/types\"\n)\n\n// IngressProcessor translates Ingresses into DAG\n// objects and adds them to the DAG.\ntype IngressProcessor struct {\n\tlogrus.FieldLogger\n\n\tdag    *DAG\n\tsource *KubernetesCache\n\n\t// ClientCertificate is the optional identifier of the TLS secret containing client certificate and\n\t// private key to be used when establishing TLS connection to upstream cluster.\n\tClientCertificate *types.NamespacedName\n}\n\n// Run translates Ingresses into DAG objects and\n// adds them to the DAG.\nfunc (p *IngressProcessor) Run(dag *DAG, source *KubernetesCache) {\n\tp.dag = dag\n\tp.source = source\n\n\t// reset the processor when we're done\n\tdefer func() {\n\t\tp.dag = nil\n\t\tp.source = nil\n\t}()\n\n\t// setup secure vhosts if there is a matching secret\n\t// we do this first so that the set of active secure vhosts is stable\n\t// during computeIngresses.\n\tp.computeSecureVirtualhosts()\n\tp.computeIngresses()\n}\n\n// computeSecureVirtualhosts populates tls parameters of\n// secure virtual hosts.\nfunc (p *IngressProcessor) computeSecureVirtualhosts() {\n\tfor _, ing := range p.source.ingresses {\n\t\tfor _, tls := range ing.Spec.TLS {\n\t\t\tsecretName := k8s.NamespacedNameFrom(tls.SecretName, k8s.DefaultNamespace(ing.GetNamespace()))\n\t\t\tsec, err := p.source.LookupSecret(secretName, validSecret)\n\t\t\tif err != nil {\n\t\t\t\tp.WithError(err).\n\t\t\t\t\tWithField(\"name\", ing.GetName()).\n\t\t\t\t\tWithField(\"namespace\", ing.GetNamespace()).\n\t\t\t\t\tWithField(\"secret\", secretName).\n\t\t\t\t\tError(\"unresolved secret reference\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !p.source.DelegationPermitted(secretName, ing.GetNamespace()) {\n\t\t\t\tp.WithError(err).\n\t\t\t\t\tWithField(\"name\", ing.GetName()).\n\t\t\t\t\tWithField(\"namespace\", ing.GetNamespace()).\n\t\t\t\t\tWithField(\"secret\", secretName).\n\t\t\t\t\tError(\"certificate delegation not permitted\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// We have validated the TLS secrets, so we can go\n\t\t\t// ahead and create the SecureVirtualHost for this\n\t\t\t// Ingress.\n\t\t\tfor _, host := range tls.Hosts {\n\t\t\t\tsvhost := p.dag.EnsureSecureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_https\"})\n\t\t\t\tsvhost.Secret = sec\n\t\t\t\t// default to a minimum TLS version of 1.2 if it's not specified\n\t\t\t\tsvhost.MinTLSVersion = annotation.MinTLSVersion(annotation.ContourAnnotation(ing, \"tls-minimum-protocol-version\"), \"1.2\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *IngressProcessor) computeIngresses() {\n\t// deconstruct each ingress into routes and virtualhost entries\n\tfor _, ing := range p.source.ingresses {\n\n\t\t// rewrite the default ingress to a stock ingress rule.\n\t\trules := rulesFromSpec(ing.Spec)\n\t\tfor _, rule := range rules {\n\t\t\tp.computeIngressRule(ing, rule)\n\t\t}\n\t}\n}\n\nfunc (p *IngressProcessor) computeIngressRule(ing *networking_v1.Ingress, rule networking_v1.IngressRule) {\n\thost := rule.Host\n\n\t// If host name is blank, rewrite to Envoy's * default host.\n\tif host == \"\" {\n\t\thost = \"*\"\n\t}\n\n\tvar clientCertSecret *Secret\n\tvar err error\n\tif p.ClientCertificate != nil {\n\t\tclientCertSecret, err = p.source.LookupSecret(*p.ClientCertificate, validSecret)\n\t\tif err != nil {\n\t\t\tp.WithError(err).\n\t\t\t\tWithField(\"name\", ing.GetName()).\n\t\t\t\tWithField(\"namespace\", ing.GetNamespace()).\n\t\t\t\tWithField(\"secret\", p.ClientCertificate).\n\t\t\t\tError(\"tls.envoy-client-certificate contains unresolved secret reference\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tfor _, httppath := range httppaths(rule) {\n\t\tpath := stringOrDefault(httppath.Path, \"/\")\n\t\t// Default to implementation specific path matching if not set.\n\t\tpathType := derefPathTypeOr(httppath.PathType, networking_v1.PathTypeImplementationSpecific)\n\t\tbe := httppath.Backend\n\t\tm := types.NamespacedName{Name: be.Service.Name, Namespace: ing.Namespace}\n\n\t\tvar port intstr.IntOrString\n\t\tif len(be.Service.Port.Name) > 0 {\n\t\t\tport = intstr.FromString(be.Service.Port.Name)\n\t\t} else {\n\t\t\tport = intstr.FromInt(int(be.Service.Port.Number))\n\t\t}\n\n\t\ts, err := p.dag.EnsureService(m, port, p.source)\n\t\tif err != nil {\n\t\t\tp.WithError(err).\n\t\t\t\tWithField(\"name\", ing.GetName()).\n\t\t\t\tWithField(\"namespace\", ing.GetNamespace()).\n\t\t\t\tWithField(\"service\", be.Service.Name).\n\t\t\t\tError(\"unresolved service reference\")\n\t\t\tcontinue\n\t\t}\n\n\t\tr, err := route(ing, rule.Host, path, pathType, s, clientCertSecret, p.FieldLogger)\n\t\tif err != nil {\n\t\t\tp.WithError(err).\n\t\t\t\tWithField(\"name\", ing.GetName()).\n\t\t\t\tWithField(\"namespace\", ing.GetNamespace()).\n\t\t\t\tWithField(\"regex\", path).\n\t\t\t\tErrorf(\"path regex is not valid\")\n\t\t\treturn\n\t\t}\n\n\t\t// should we create port 80 routes for this ingress\n\t\tif annotation.TLSRequired(ing) || annotation.HTTPAllowed(ing) {\n\t\t\tvhost := p.dag.EnsureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_http\"})\n\t\t\tvhost.addRoute(r)\n\t\t}\n\n\t\t// computeSecureVirtualhosts will have populated b.securevirtualhosts\n\t\t// with the names of tls enabled ingress objects. If host exists then\n\t\t// it is correctly configured for TLS.\n\t\tif svh := p.dag.GetSecureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_https\"}); svh != nil && host != \"*\" {\n\t\t\tsvh.addRoute(r)\n\t\t}\n\t}\n}\n\nconst singleDNSLabelWildcardRegex = \"^[a-z0-9]([-a-z0-9]*[a-z0-9])?\"\n\nvar _ = regexp.MustCompile(singleDNSLabelWildcardRegex)\n\n// route builds a dag.Route for the supplied Ingress.\nfunc route(ingress *networking_v1.Ingress, host string, path string, pathType networking_v1.PathType, service *Service, clientCertSecret *Secret, log logrus.FieldLogger) (*Route, error) {\n\tlog = log.WithFields(logrus.Fields{\n\t\t\"name\":      ingress.Name,\n\t\t\"namespace\": ingress.Namespace,\n\t})\n\n\tr := &Route{\n\t\tHTTPSUpgrade:  annotation.TLSRequired(ingress),\n\t\tWebsocket:     annotation.WebsocketRoutes(ingress)[path],\n\t\tTimeoutPolicy: ingressTimeoutPolicy(ingress, log),\n\t\tRetryPolicy:   ingressRetryPolicy(ingress, log),\n\t\tClusters: []*Cluster{{\n\t\t\tUpstream:          service,\n\t\t\tProtocol:          service.Protocol,\n\t\t\tClientCertificate: clientCertSecret,\n\t\t}},\n\t}\n\n\tswitch pathType {\n\tcase networking_v1.PathTypePrefix:\n\t\tprefixMatchType := PrefixMatchSegment\n\t\t// An \"all paths\" prefix should be treated as a generic string prefix\n\t\t// match.\n\t\tif path == \"/\" {\n\t\t\tprefixMatchType = PrefixMatchString\n\t\t} else {\n\t\t\t// Strip trailing slashes. Ensures /foo matches prefix /foo/\n\t\t\tpath = strings.TrimRight(path, \"/\")\n\t\t}\n\t\tr.PathMatchCondition = &PrefixMatchCondition{Prefix: path, PrefixMatchType: prefixMatchType}\n\tcase networking_v1.PathTypeExact:\n\t\tr.PathMatchCondition = &ExactMatchCondition{Path: path}\n\tcase networking_v1.PathTypeImplementationSpecific:\n\t\t// If a path \"looks like\" a regex we give a regex path match.\n\t\t// Otherwise you get a string prefix match.\n\t\tif strings.ContainsAny(path, \"^+*[]%\") {\n\t\t\t// validate the regex\n\t\t\tif err := ValidateRegex(path); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tr.PathMatchCondition = &RegexMatchCondition{Regex: path}\n\t\t} else {\n\t\t\tr.PathMatchCondition = &PrefixMatchCondition{Prefix: path, PrefixMatchType: PrefixMatchString}\n\t\t}\n\t}\n\n\t// If we have a wildcard match, add a header match regex rule to match the\n\t// hostname so we can be sure to only match one DNS label. This is required\n\t// as Envoy's virtualhost hostname wildcard matching can match multiple\n\t// labels. This match ignores a port in the hostname in case it is present.\n\tif strings.HasPrefix(host, \"*.\") {\n\t\tr.HeaderMatchConditions = []HeaderMatchCondition{\n\t\t\t{\n\t\t\t\t// Internally Envoy uses the HTTP/2 \":authority\" header in\n\t\t\t\t// place of the HTTP/1 \"host\" header.\n\t\t\t\t// See: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#config-route-v3-headermatcher\n\t\t\t\tName:      \":authority\",\n\t\t\t\tMatchType: HeaderMatchTypeRegex,\n\t\t\t\tValue:     singleDNSLabelWildcardRegex + regexp.QuoteMeta(host[1:]),\n\t\t\t},\n\t\t}\n\t}\n\n\treturn r, nil\n}\n\n// rulesFromSpec merges the IngressSpec's Rules with a synthetic\n// rule representing the default backend.\n// Prepend the default backend so it can be overridden by later rules.\nfunc rulesFromSpec(spec networking_v1.IngressSpec) []networking_v1.IngressRule {\n\trules := spec.Rules\n\tif backend := spec.DefaultBackend; backend != nil {\n\t\trule := defaultBackendRule(backend)\n\t\trules = append([]networking_v1.IngressRule{rule}, rules...)\n\t}\n\treturn rules\n}\n\n// defaultBackendRule returns an IngressRule that represents the IngressBackend.\nfunc defaultBackendRule(be *networking_v1.IngressBackend) networking_v1.IngressRule {\n\treturn networking_v1.IngressRule{\n\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\tBackend: networking_v1.IngressBackend{\n\t\t\t\t\t\tService: &networking_v1.IngressServiceBackend{\n\t\t\t\t\t\t\tName: be.Service.Name,\n\t\t\t\t\t\t\tPort: be.Service.Port,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc stringOrDefault(s, def string) string {\n\tif s == \"\" {\n\t\treturn def\n\t}\n\treturn s\n}\n\nfunc derefPathTypeOr(ptr *networking_v1.PathType, def networking_v1.PathType) networking_v1.PathType {\n\tif ptr != nil {\n\t\treturn *ptr\n\t}\n\treturn def\n}\n\n// httppaths returns a slice of HTTPIngressPath values for a given IngressRule.\n// In the case that the IngressRule contains no valid HTTPIngressPaths, a\n// nil slice is returned.\nfunc httppaths(rule networking_v1.IngressRule) []networking_v1.HTTPIngressPath {\n\tif rule.IngressRuleValue.HTTP == nil {\n\t\t// rule.IngressRuleValue.HTTP value is optional.\n\t\treturn nil\n\t}\n\treturn rule.IngressRuleValue.HTTP.Paths\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dag\n\nimport (\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-cmp/cmp/cmpopts\"\n\tcontour_api_v1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"\n\t\"github.com/projectcontour/contour/internal/fixture\"\n\t\"github.com/projectcontour/contour/internal/status\"\n\t\"github.com/stretchr/testify/assert\"\n\tv1 \"k8s.io/api/core/v1\"\n\tnetworking_v1 \"k8s.io/api/networking/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n\t\"k8s.io/utils/pointer\"\n\tgatewayapi_v1alpha1 \"sigs.k8s.io/gateway-api/apis/v1alpha1\"\n)\n\nfunc TestDAGStatus(t *testing.T) {\n\n\ttype testcase struct {\n\t\tobjs                []interface{}\n\t\tfallbackCertificate *types.NamespacedName\n\t\twant                map[types.NamespacedName]contour_api_v1.DetailedCondition\n\t}\n\n\trun := func(t *testing.T, desc string, tc testcase) {\n\t\tt.Helper()\n\t\tt.Run(desc, func(t *testing.T) {\n\t\t\tt.Helper()\n\t\t\tbuilder := Builder{\n\t\t\t\tSource: KubernetesCache{\n\t\t\t\t\tRootNamespaces: []string{\"roots\", \"marketing\"},\n\t\t\t\t\tFieldLogger:    fixture.NewTestLogger(t),\n\t\t\t\t},\n\t\t\t\tProcessors: []Processor{\n\t\t\t\t\t&IngressProcessor{\n\t\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t\t},\n\t\t\t\t\t&HTTPProxyProcessor{\n\t\t\t\t\t\tFallbackCertificate: tc.fallbackCertificate,\n\t\t\t\t\t},\n\t\t\t\t\t&GatewayAPIProcessor{\n\t\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t\t},\n\t\t\t\t\t&ListenerProcessor{},\n\t\t\t\t},\n\t\t\t}\n\t\t\tfor _, o := range tc.objs {\n\t\t\t\tbuilder.Source.Insert(o)\n\t\t\t}\n\t\t\tdag := builder.Build()\n\t\t\tt.Logf(\"%#v\\n\", dag.StatusCache)\n\n\t\t\tgot := make(map[types.NamespacedName]contour_api_v1.DetailedCondition)\n\t\t\tfor _, pu := range dag.StatusCache.GetProxyUpdates() {\n\t\t\t\tgot[pu.Fullname] = *pu.Conditions[status.ValidCondition]\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.want, got)\n\t\t})\n\t}\n\n\t// proxyNoFQDN is invalid because it does not specify and FQDN\n\tproxyNoFQDN := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace:  \"roots\",\n\t\t\tName:       \"parent\",\n\t\t\tGeneration: 23,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"foo\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// Tests using common fixtures\n\trun(t, \"root proxy does not specify FQDN\", testcase{\n\t\tobjs: []interface{}{proxyNoFQDN},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyNoFQDN.Name, Namespace: proxyNoFQDN.Namespace}: fixture.NewValidCondition().WithGeneration(proxyNoFQDN.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"FQDNNotSpecified\", \"Spec.VirtualHost.Fqdn must be specified\"),\n\t\t},\n\t})\n\n\t// Simple Valid HTTPProxy\n\tproxyValidHomeService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace:  \"roots\",\n\t\t\tName:       \"example\",\n\t\t\tGeneration: 24,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"valid proxy\", testcase{\n\t\tobjs: []interface{}{proxyValidHomeService, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyValidHomeService.Name, Namespace: proxyValidHomeService.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyValidHomeService.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n\n\t// Multiple Includes, one invalid\n\tproxyMultiIncludeOneInvalid := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace:  \"roots\",\n\t\t\tName:       \"parent\",\n\t\t\tGeneration: 45,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName: \"validChild\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tName: \"invalidChild\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/bar\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyIncludeValidChild := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"parentvalidchild\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName: \"validChild\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyChildValidFoo2 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace:  \"roots\",\n\t\t\tName:       \"validChild\",\n\t\t\tGeneration: 1,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"foo2\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyChildInvalidBadPort := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"invalidChild\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"foo3\",\n\t\t\t\t\tPort: 12345678,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy has multiple includes, one is invalid\", testcase{\n\t\tobjs: []interface{}{proxyMultiIncludeOneInvalid, proxyChildValidFoo2, proxyChildInvalidBadPort, fixture.ServiceRootsFoo2, fixture.ServiceRootsFoo3InvalidPort},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyChildValidFoo2.Name, Namespace: proxyChildValidFoo2.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyChildValidFoo2.Generation).\n\t\t\t\tValid(),\n\t\t\t{Name: proxyChildInvalidBadPort.Name, Namespace: proxyChildInvalidBadPort.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyChildInvalidBadPort.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeServiceError, \"ServicePortInvalid\", `service \"foo3\": port must be in the range 1-65535`),\n\t\t\t{Name: proxyMultiIncludeOneInvalid.Name, Namespace: proxyMultiIncludeOneInvalid.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyMultiIncludeOneInvalid.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n\n\trun(t, \"multi-parent child is not orphaned when one of the parents is invalid\", testcase{\n\t\tobjs: []interface{}{proxyNoFQDN, proxyChildValidFoo2, proxyIncludeValidChild, fixture.ServiceRootsKuard, fixture.ServiceRootsFoo2},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyNoFQDN.Name, Namespace: proxyNoFQDN.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyNoFQDN.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"FQDNNotSpecified\", \"Spec.VirtualHost.Fqdn must be specified\"),\n\t\t\t{Name: proxyChildValidFoo2.Name, Namespace: proxyChildValidFoo2.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyChildValidFoo2.Generation).\n\t\t\t\tValid(),\n\t\t\t{Name: proxyIncludeValidChild.Name, Namespace: proxyIncludeValidChild.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyIncludeValidChild.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n\n\tingressSharedService := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"nginx\",\n\t\t\tNamespace: fixture.ServiceRootsNginx.Namespace,\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"example.com\"},\n\t\t\t\tSecretName: fixture.SecretRootsCert.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost:             \"example.com\",\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(fixture.ServiceRootsNginx.Name, intstr.FromInt(80))),\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyTCPSharedService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"nginx\",\n\t\t\tNamespace: fixture.ServiceRootsNginx.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: fixture.SecretRootsCert.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsNginx.Name,\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t// issue 1399\n\trun(t, \"service shared across ingress and httpproxy tcpproxy\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tfixture.SecretRootsCert, fixture.ServiceRootsNginx, ingressSharedService, proxyTCPSharedService,\n\t\t},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPSharedService.Name, Namespace: proxyTCPSharedService.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyTCPSharedService.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n\n\tproxyDelegatedTCPTLS := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"app-with-tls-delegation\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"app-with-tls-delegation.127.0.0.1.nip.io\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: fixture.SecretProjectContourCert.Namespace + \"/\" + fixture.SecretProjectContourCert.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"sample-app\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t// issue 1347\n\trun(t, \"tcpproxy with tls delegation failure\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tfixture.SecretProjectContourCert,\n\t\t\tproxyDelegatedTCPTLS,\n\t\t},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyDelegatedTCPTLS.Name, Namespace: proxyDelegatedTCPTLS.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyDelegatedTCPTLS.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"DelegationNotPermitted\", `Spec.VirtualHost.TLS Secret \"projectcontour/default-ssl-cert\" certificate delegation not permitted`),\n\t\t},\n\t})\n\n\tproxyDelegatedTLS := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"app-with-tls-delegation\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"app-with-tls-delegation.127.0.0.1.nip.io\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: fixture.SecretProjectContourCert.Namespace + \"/\" + fixture.SecretProjectContourCert.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"sample-app\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// issue 1348\n\trun(t, \"routes with tls delegation failure\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tfixture.SecretProjectContourCert,\n\t\t\tproxyDelegatedTLS,\n\t\t},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyDelegatedTLS.Name, Namespace: proxyDelegatedTLS.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyDelegatedTCPTLS.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"DelegationNotPermitted\", `Spec.VirtualHost.TLS Secret \"projectcontour/default-ssl-cert\" certificate delegation not permitted`),\n\t\t},\n\t})\n\n\tserviceTLSPassthrough := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"tls-passthrough\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"https\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       443,\n\t\t\t\tTargetPort: intstr.FromInt(443),\n\t\t\t}, {\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       80,\n\t\t\t\tTargetPort: intstr.FromInt(80),\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyPassthroughProxyNonSecure := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard-tcp\",\n\t\t\tNamespace: serviceTLSPassthrough.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"kuard.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: serviceTLSPassthrough.Name,\n\t\t\t\t\tPort: 80, // proxy non secure traffic to port 80\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: serviceTLSPassthrough.Name,\n\t\t\t\t\tPort: 443, // ssl passthrough to secure port\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t// issue 910\n\trun(t, \"non tls routes can be combined with tcp proxy\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tserviceTLSPassthrough,\n\t\t\tproxyPassthroughProxyNonSecure,\n\t\t},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyPassthroughProxyNonSecure.Name, Namespace: proxyPassthroughProxyNonSecure.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyPassthroughProxyNonSecure.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n\n\tproxyMultipleIncludersSite1 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"site1\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"site1.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"www\",\n\t\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyMultipleIncludersSite2 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"site2\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"site2.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"www\",\n\t\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyMultiIncludeChild := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"www\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"two root httpproxies with different hostnames delegated to the same object are valid\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tfixture.ServiceRootsKuard, proxyMultipleIncludersSite1, proxyMultipleIncludersSite2, proxyMultiIncludeChild,\n\t\t},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyMultipleIncludersSite1.Name, Namespace: proxyMultipleIncludersSite1.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyMultipleIncludersSite1.Generation).\n\t\t\t\tValid(),\n\t\t\t{Name: proxyMultipleIncludersSite2.Name, Namespace: proxyMultipleIncludersSite2.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyMultipleIncludersSite2.Generation).\n\t\t\t\tValid(),\n\t\t\t{Name: proxyMultiIncludeChild.Name, Namespace: proxyMultiIncludeChild.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyMultiIncludeChild.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n\n\t// proxyInvalidNegativePortHomeService is invalid because it contains a service with negative port\n\tproxyInvalidNegativePortHomeService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: -80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"invalid port in service\", testcase{\n\t\tobjs: []interface{}{proxyInvalidNegativePortHomeService},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidNegativePortHomeService.Name, Namespace: proxyInvalidNegativePortHomeService.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidNegativePortHomeService.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeServiceError, \"ServicePortInvalid\", `service \"home\": port must be in the range 1-65535`),\n\t\t},\n\t})\n\n\t// proxyInvalidOutsideRootNamespace is invalid because it lives outside the roots namespace\n\tproxyInvalidOutsideRootNamespace := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"finance\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foobar\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"root proxy outside of roots namespace\", testcase{\n\t\tobjs: []interface{}{proxyInvalidOutsideRootNamespace},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidOutsideRootNamespace.Name, Namespace: proxyInvalidOutsideRootNamespace.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidNegativePortHomeService.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeRootNamespaceError, \"RootProxyNotAllowedInNamespace\", \"root HTTPProxy cannot be defined in this namespace\"),\n\t\t},\n\t})\n\n\t// proxyInvalidIncludeCycle is invalid because it delegates to itself, producing a cycle\n\tproxyInvalidIncludeCycle := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"self\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"self\",\n\t\t\t\tNamespace: \"roots\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"green\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy self-edge produces a cycle\", testcase{\n\t\tobjs: []interface{}{proxyInvalidIncludeCycle, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidIncludeCycle.Name, Namespace: proxyInvalidIncludeCycle.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidIncludeCycle.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeIncludeError, \"RootIncludesRoot\", \"root httpproxy cannot include another root httpproxy\"),\n\t\t},\n\t})\n\n\t// proxyIncludesProxyWithIncludeCycle delegates to proxy8, which is invalid because proxy8 delegates back to proxy8\n\tproxyIncludesProxyWithIncludeCycle := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"parent\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"child\",\n\t\t\t\tNamespace: \"roots\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyIncludedChildInvalidIncludeCycle := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"child\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"child\",\n\t\t\t\tNamespace: \"roots\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy child delegates to itself, producing a cycle\", testcase{\n\t\tobjs: []interface{}{proxyIncludesProxyWithIncludeCycle, proxyIncludedChildInvalidIncludeCycle},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyIncludesProxyWithIncludeCycle.Name, Namespace: proxyIncludesProxyWithIncludeCycle.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyIncludesProxyWithIncludeCycle.Generation).Valid(),\n\t\t\t{Name: proxyIncludedChildInvalidIncludeCycle.Name, Namespace: proxyIncludedChildInvalidIncludeCycle.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyIncludedChildInvalidIncludeCycle.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeIncludeError, \"IncludeCreatesCycle\", \"include creates an include cycle: roots/parent -> roots/child -> roots/child\"),\n\t\t},\n\t})\n\n\trun(t, \"proxy orphaned route\", testcase{\n\t\tobjs: []interface{}{proxyIncludedChildInvalidIncludeCycle},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyIncludedChildInvalidIncludeCycle.Name, Namespace: proxyIncludedChildInvalidIncludeCycle.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyIncludedChildInvalidIncludeCycle.Generation).\n\t\t\t\tOrphaned(),\n\t\t},\n\t})\n\n\tproxyIncludedChildValid := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"validChild\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"foo2\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxyNotRootIncludeRootProxy delegates to proxyWildCardFQDN but it is invalid because it is missing fqdn\n\tproxyNotRootIncludeRootProxy := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"invalidParent\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"validChild\",\n\t\t\t\tNamespace: \"roots\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy invalid parent orphans child\", testcase{\n\t\tobjs: []interface{}{proxyNotRootIncludeRootProxy, proxyIncludedChildValid},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyNotRootIncludeRootProxy.Name, Namespace: proxyNotRootIncludeRootProxy.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyNotRootIncludeRootProxy.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"FQDNNotSpecified\", \"Spec.VirtualHost.Fqdn must be specified\"),\n\t\t\t{Name: proxyIncludedChildValid.Name, Namespace: proxyIncludedChildValid.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyIncludedChildValid.Generation).\n\t\t\t\tOrphaned(),\n\t\t},\n\t})\n\n\t// proxyWildCardFQDN is invalid because it contains a wildcarded fqdn\n\tproxyWildCardFQDN := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.*.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy invalid FQDN contains wildcard\", testcase{\n\t\tobjs: []interface{}{proxyWildCardFQDN},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyWildCardFQDN.Name, Namespace: proxyWildCardFQDN.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyWildCardFQDN.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"WildCardNotAllowed\", `Spec.VirtualHost.Fqdn \"example.*.com\" cannot use wildcards`),\n\t\t},\n\t})\n\n\t// proxyInvalidServiceInvalid is invalid because it references an invalid service\n\tproxyInvalidServiceInvalid := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"invalidir\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"invalid\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy missing service is invalid\", testcase{\n\t\tobjs: []interface{}{proxyInvalidServiceInvalid},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidServiceInvalid.Name, Namespace: proxyInvalidServiceInvalid.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidServiceInvalid.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeServiceError, \"ServiceUnresolvedReference\", `Spec.Routes unresolved service reference: service \"roots/invalid\" not found`),\n\t\t},\n\t})\n\n\t// proxyInvalidServicePortInvalid is invalid because it references an invalid port on a service\n\tproxyInvalidServicePortInvalid := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"invalidir\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 9999,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy with service missing port is invalid\", testcase{\n\t\tobjs: []interface{}{proxyInvalidServicePortInvalid, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidServicePortInvalid.Name, Namespace: proxyInvalidServicePortInvalid.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidServiceInvalid.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeServiceError, \"ServiceUnresolvedReference\", `Spec.Routes unresolved service reference: port \"9999\" on service \"roots/home\" not matched`),\n\t\t},\n\t})\n\n\tproxyValidExampleCom := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyValidReuseExampleCom := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"other-example\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyValidReuseCaseExampleCom := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"case-example\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"EXAMPLE.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"conflicting proxies due to fqdn reuse\", testcase{\n\t\tobjs: []interface{}{proxyValidExampleCom, proxyValidReuseExampleCom},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyValidExampleCom.Name, Namespace: proxyValidExampleCom.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyValidExampleCom.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"DuplicateVhost\", `fqdn \"example.com\" is used in multiple HTTPProxies: roots/example-com, roots/other-example`),\n\t\t\t{Name: proxyValidReuseExampleCom.Name, Namespace: proxyValidReuseExampleCom.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyValidReuseExampleCom.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"DuplicateVhost\", `fqdn \"example.com\" is used in multiple HTTPProxies: roots/example-com, roots/other-example`),\n\t\t},\n\t})\n\n\trun(t, \"conflicting proxies due to fqdn reuse with uppercase/lowercase\", testcase{\n\t\tobjs: []interface{}{proxyValidExampleCom, proxyValidReuseCaseExampleCom},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyValidExampleCom.Name, Namespace: proxyValidExampleCom.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyValidExampleCom.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"DuplicateVhost\", `fqdn \"example.com\" is used in multiple HTTPProxies: roots/case-example, roots/example-com`),\n\t\t\t{Name: proxyValidReuseCaseExampleCom.Name, Namespace: proxyValidReuseCaseExampleCom.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyValidReuseCaseExampleCom.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"DuplicateVhost\", `fqdn \"example.com\" is used in multiple HTTPProxies: roots/case-example, roots/example-com`),\n\t\t},\n\t})\n\n\tproxyRootIncludesRoot := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"root-blog\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"blog.containersteve.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: \"blog-containersteve-com\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"blog\",\n\t\t\t\tNamespace: \"marketing\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyRootIncludedByRoot := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"blog\",\n\t\t\tNamespace: fixture.ServiceMarketingGreen.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"blog.containersteve.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: \"blog-containersteve-com\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceMarketingGreen.Name,\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"root proxy including another root\", testcase{\n\t\tobjs: []interface{}{proxyRootIncludesRoot, proxyRootIncludedByRoot},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyRootIncludesRoot.Name, Namespace: proxyRootIncludesRoot.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyRootIncludesRoot.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"DuplicateVhost\", `fqdn \"blog.containersteve.com\" is used in multiple HTTPProxies: marketing/blog, roots/root-blog`),\n\t\t\t{Name: proxyRootIncludedByRoot.Name, Namespace: proxyRootIncludedByRoot.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyRootIncludedByRoot.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"DuplicateVhost\", `fqdn \"blog.containersteve.com\" is used in multiple HTTPProxies: marketing/blog, roots/root-blog`),\n\t\t},\n\t})\n\n\tproxyIncludesRootDifferentFQDN := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"root-blog\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"blog.containersteve.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"blog\",\n\t\t\t\tNamespace: \"marketing\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyRootIncludedByRootDiffFQDN := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"blog\",\n\t\t\tNamespace: fixture.ServiceMarketingGreen.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"www.containersteve.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceMarketingGreen.Name,\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"root proxy including another root w/ different hostname\", testcase{\n\t\tobjs: []interface{}{proxyIncludesRootDifferentFQDN, proxyRootIncludedByRootDiffFQDN, fixture.ServiceMarketingGreen},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyIncludesRootDifferentFQDN.Name, Namespace: proxyIncludesRootDifferentFQDN.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyIncludesRootDifferentFQDN.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeIncludeError, \"RootIncludesRoot\", \"root httpproxy cannot include another root httpproxy\"),\n\t\t\t{Name: proxyRootIncludedByRootDiffFQDN.Name, Namespace: proxyRootIncludedByRootDiffFQDN.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyRootIncludedByRootDiffFQDN.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n\n\tproxyValidIncludeBlogMarketing := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"blog\",\n\t\t\tNamespace: fixture.ServiceMarketingGreen.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceMarketingGreen.Name,\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyRootValidIncludesBlogMarketing := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"root-blog\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      proxyValidIncludeBlogMarketing.Name,\n\t\t\t\tNamespace: proxyValidIncludeBlogMarketing.Namespace,\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy includes another\", testcase{\n\t\tobjs: []interface{}{proxyValidIncludeBlogMarketing, proxyRootValidIncludesBlogMarketing, fixture.ServiceRootsKuard, fixture.ServiceMarketingGreen},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyValidIncludeBlogMarketing.Name, Namespace: proxyValidIncludeBlogMarketing.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyValidIncludeBlogMarketing.Generation).\n\t\t\t\tValid(),\n\t\t\t{Name: proxyRootValidIncludesBlogMarketing.Name, Namespace: proxyRootValidIncludesBlogMarketing.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyRootValidIncludesBlogMarketing.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n\n\tproxyValidWithMirror := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"www\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}, {\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}, {\n\t\t\t\t\tName:   fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tMirror: true,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy with mirror\", testcase{\n\t\tobjs: []interface{}{proxyValidWithMirror, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyValidWithMirror.Name, Namespace: proxyValidWithMirror.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyValidWithMirror.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n\n\tproxyInvalidTwoMirrors := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"www\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}, {\n\t\t\t\t\tName:   fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tMirror: true,\n\t\t\t\t}, {\n\t\t\t\t\tName:   fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tMirror: true,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy with two mirrors\", testcase{\n\t\tobjs: []interface{}{proxyInvalidTwoMirrors, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidTwoMirrors.Name, Namespace: proxyInvalidTwoMirrors.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidTwoMirrors.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeServiceError, \"OnlyOneMirror\", \"only one service per route may be nominated as mirror\"),\n\t\t},\n\t})\n\n\tproxyInvalidDuplicateMatchConditionHeaders := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:  \"x-header\",\n\t\t\t\t\t\tExact: \"abc\",\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:  \"x-header\",\n\t\t\t\t\t\tExact: \"1234\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"duplicate route condition headers\", testcase{\n\t\tobjs: []interface{}{proxyInvalidDuplicateMatchConditionHeaders, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidDuplicateMatchConditionHeaders.Name, Namespace: proxyInvalidDuplicateMatchConditionHeaders.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidDuplicateMatchConditionHeaders.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeRouteError, \"HeaderMatchConditionsNotValid\", \"cannot specify duplicate header 'exact match' conditions in the same route\"),\n\t\t},\n\t})\n\n\tproxyInvalidDuplicateIncludeCondtionHeaders := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"delegated\",\n\t\t\t\tNamespace: \"roots\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:  \"x-header\",\n\t\t\t\t\t\tExact: \"abc\",\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:  \"x-header\",\n\t\t\t\t\t\tExact: \"1234\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\tproxyValidDelegatedRoots := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"delegated\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"duplicate include condition headers\", testcase{\n\t\tobjs: []interface{}{proxyInvalidDuplicateIncludeCondtionHeaders, proxyValidDelegatedRoots, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidDuplicateIncludeCondtionHeaders.Name,\n\t\t\t\tNamespace: proxyInvalidDuplicateIncludeCondtionHeaders.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidDuplicateIncludeCondtionHeaders.Generation).Valid(),\n\t\t\t{Name: proxyValidDelegatedRoots.Name,\n\t\t\t\tNamespace: proxyValidDelegatedRoots.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyValidDelegatedRoots.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeRouteError, \"HeaderMatchConditionsNotValid\", \"cannot specify duplicate header 'exact match' conditions in the same route\"),\n\t\t},\n\t})\n\n\tproxyInvalidRouteConditionHeaders := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"x-header\",\n\t\t\t\t\t\tNotExact: \"abc\",\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"x-header\",\n\t\t\t\t\t\tNotExact: \"1234\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"duplicate valid route condition headers\", testcase{\n\t\tobjs: []interface{}{proxyInvalidRouteConditionHeaders, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidRouteConditionHeaders.Name, Namespace: proxyInvalidRouteConditionHeaders.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidRouteConditionHeaders.Generation).Valid(),\n\t\t},\n\t})\n\n\tproxyInvalidMultiplePrefixes := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"www\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{\n\t\t\t\t\t{\n\t\t\t\t\t\tPrefix: \"/api\",\n\t\t\t\t\t}, {\n\t\t\t\t\t\tPrefix: \"/v1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy with two prefix conditions on route\", testcase{\n\t\tobjs: []interface{}{proxyInvalidMultiplePrefixes, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidMultiplePrefixes.Name, Namespace: proxyInvalidMultiplePrefixes.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidMultiplePrefixes.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeRouteError, \"PathMatchConditionsNotValid\", \"route: more than one prefix is not allowed in a condition block\"),\n\t\t},\n\t})\n\n\tproxyInvalidTwoPrefixesWithInclude := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"www\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"child\",\n\t\t\t\tNamespace: \"teama\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{\n\t\t\t\t\t{\n\t\t\t\t\t\tPrefix: \"/api\",\n\t\t\t\t\t}, {\n\t\t\t\t\t\tPrefix: \"/v1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyValidChildTeamA := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"child\",\n\t\t\tNamespace: \"teama\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy with two prefix conditions orphans include\", testcase{\n\t\tobjs: []interface{}{proxyInvalidTwoPrefixesWithInclude, proxyValidChildTeamA, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidTwoPrefixesWithInclude.Name, Namespace: proxyInvalidTwoPrefixesWithInclude.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidTwoPrefixesWithInclude.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeIncludeError, \"PathMatchConditionsNotValid\", \"include: more than one prefix is not allowed in a condition block\"),\n\t\t\t{Name: proxyValidChildTeamA.Name, Namespace: proxyValidChildTeamA.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyValidChildTeamA.Generation).\n\t\t\t\tOrphaned(),\n\t\t},\n\t})\n\n\tproxyInvalidPrefixNoSlash := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"www\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{\n\t\t\t\t\t{\n\t\t\t\t\t\tPrefix: \"api\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy with prefix conditions on route that does not start with slash\", testcase{\n\t\tobjs: []interface{}{proxyInvalidPrefixNoSlash, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidPrefixNoSlash.Name, Namespace: proxyInvalidPrefixNoSlash.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidPrefixNoSlash.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeRouteError, \"PathMatchConditionsNotValid\", \"route: prefix conditions must start with /, api was supplied\"),\n\t\t},\n\t})\n\n\tproxyInvalidIncludePrefixNoSlash := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"www\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"child\",\n\t\t\t\tNamespace: \"teama\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{\n\t\t\t\t\t{\n\t\t\t\t\t\tPrefix: \"api\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy with include prefix that does not start with slash\", testcase{\n\t\tobjs: []interface{}{proxyInvalidIncludePrefixNoSlash, proxyValidChildTeamA, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidIncludePrefixNoSlash.Name, Namespace: proxyInvalidIncludePrefixNoSlash.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeIncludeError, \"PathMatchConditionsNotValid\", \"include: prefix conditions must start with /, api was supplied\"),\n\t\t\t{Name: proxyValidChildTeamA.Name, Namespace: proxyValidChildTeamA.Namespace}: fixture.NewValidCondition().\n\t\t\t\tOrphaned(),\n\t\t},\n\t})\n\n\tproxyInvalidTCPProxyIncludeAndService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"simple\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"passthrough.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tInclude: &contour_api_v1.TCPProxyInclude{\n\t\t\t\t\tName:      \"foo\",\n\t\t\t\t\tNamespace: \"roots\",\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"tcpproxy cannot specify services and include\", testcase{\n\t\tobjs: []interface{}{proxyInvalidTCPProxyIncludeAndService, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidTCPProxyIncludeAndService.Name, Namespace: proxyInvalidTCPProxyIncludeAndService.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTCPProxyError, \"NoServicesAndInclude\", \"cannot specify services and include in the same httpproxy\"),\n\t\t},\n\t})\n\n\tproxyTCPNoServiceOrInclusion := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"simple\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"passthrough.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{},\n\t\t},\n\t}\n\n\trun(t, \"tcpproxy empty\", testcase{\n\t\tobjs: []interface{}{proxyTCPNoServiceOrInclusion, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPNoServiceOrInclusion.Name, Namespace: proxyTCPNoServiceOrInclusion.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTCPProxyError, \"NothingDefined\", \"either services or inclusion must be specified\"),\n\t\t},\n\t})\n\n\tproxyTCPIncludesFoo := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"simple\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"passthrough.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tInclude: &contour_api_v1.TCPProxyInclude{\n\t\t\t\t\tName:      \"foo\",\n\t\t\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"tcpproxy w/ missing include\", testcase{\n\t\tobjs: []interface{}{proxyTCPIncludesFoo, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPIncludesFoo.Name, Namespace: proxyTCPIncludesFoo.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTCPProxyIncludeError, \"IncludeNotFound\", \"include roots/foo not found\"),\n\t\t},\n\t})\n\n\tproxyValidTCPRoot := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"foo\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"www.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"tcpproxy includes another root\", testcase{\n\t\tobjs: []interface{}{proxyTCPIncludesFoo, proxyValidTCPRoot, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPIncludesFoo.Name, Namespace: proxyTCPIncludesFoo.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTCPProxyIncludeError, \"RootIncludesRoot\", \"root httpproxy cannot include another root httpproxy\"),\n\t\t\t{Name: proxyValidTCPRoot.Name, Namespace: proxyValidTCPRoot.Namespace}: fixture.NewValidCondition().Valid(),\n\t\t},\n\t})\n\n\tproxyTCPValidChildFoo := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"foo\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"tcpproxy includes valid child\", testcase{\n\t\tobjs: []interface{}{proxyTCPIncludesFoo, proxyTCPValidChildFoo, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPIncludesFoo.Name, Namespace: proxyTCPIncludesFoo.Namespace}:     fixture.NewValidCondition().Valid(),\n\t\t\t{Name: proxyTCPValidChildFoo.Name, Namespace: proxyTCPValidChildFoo.Namespace}: fixture.NewValidCondition().Valid(),\n\t\t},\n\t})\n\n\tproxyInvalidConflictingIncludeConditions := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"blogteama\",\n\t\t\t\tNamespace: \"teama\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tName:      \"blogteamb\",\n\t\t\t\tNamespace: \"teamb\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyValidBlogTeamA := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"blogteama\",\n\t\t\tName:      \"teama\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceTeamAKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyValidBlogTeamB := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"blogteamb\",\n\t\t\tName:      \"teamb\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceTeamBKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"duplicate path conditions on an include\", testcase{\n\t\tobjs: []interface{}{proxyInvalidConflictingIncludeConditions, proxyValidBlogTeamA, proxyValidBlogTeamB, fixture.ServiceRootsHome, fixture.ServiceTeamAKuard, fixture.ServiceTeamBKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidConflictingIncludeConditions.Name,\n\t\t\t\tNamespace: proxyInvalidConflictingIncludeConditions.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeIncludeError, \"DuplicateMatchConditions\", \"duplicate conditions defined on an include\"),\n\t\t\t{Name: proxyValidBlogTeamA.Name, Namespace: proxyValidBlogTeamA.Namespace}: fixture.NewValidCondition().\n\t\t\t\tOrphaned(),\n\t\t\t{Name: proxyValidBlogTeamB.Name, Namespace: proxyValidBlogTeamB.Namespace}: fixture.NewValidCondition().\n\t\t\t\tOrphaned(),\n\t\t},\n\t})\n\n\tproxyInvalidConflictHeaderConditions := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"blogteama\",\n\t\t\t\tNamespace: \"teama\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"x-header\",\n\t\t\t\t\t\tContains: \"abc\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tName:      \"blogteamb\",\n\t\t\t\tNamespace: \"teamb\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"x-header\",\n\t\t\t\t\t\tContains: \"abc\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"duplicate header conditions on an include\", testcase{\n\t\tobjs: []interface{}{proxyInvalidConflictHeaderConditions, proxyValidBlogTeamA, proxyValidBlogTeamB, fixture.ServiceRootsHome, fixture.ServiceTeamAKuard, fixture.ServiceTeamBKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidConflictHeaderConditions.Name,\n\t\t\t\tNamespace: proxyInvalidConflictHeaderConditions.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeIncludeError, \"DuplicateMatchConditions\", \"duplicate conditions defined on an include\"),\n\t\t\t{Name: proxyValidBlogTeamA.Name,\n\t\t\t\tNamespace: proxyValidBlogTeamA.Namespace}: fixture.NewValidCondition().Orphaned(),\n\t\t\t{Name: proxyValidBlogTeamB.Name,\n\t\t\t\tNamespace: proxyValidBlogTeamB.Namespace}: fixture.NewValidCondition().Orphaned(),\n\t\t},\n\t})\n\n\tproxyInvalidDuplicateHeaderAndPathConditions := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"blogteama\",\n\t\t\t\tNamespace: \"teama\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"x-header\",\n\t\t\t\t\t\tContains: \"abc\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tName:      \"blogteamb\",\n\t\t\t\tNamespace: \"teamb\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"x-header\",\n\t\t\t\t\t\tContains: \"abc\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"duplicate header+path conditions on an include\", testcase{\n\t\tobjs: []interface{}{proxyInvalidDuplicateHeaderAndPathConditions, proxyValidBlogTeamA, proxyValidBlogTeamB, fixture.ServiceRootsHome, fixture.ServiceTeamAKuard, fixture.ServiceTeamBKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidDuplicateHeaderAndPathConditions.Name,\n\t\t\t\tNamespace: proxyInvalidDuplicateHeaderAndPathConditions.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeIncludeError, \"DuplicateMatchConditions\", \"duplicate conditions defined on an include\"),\n\t\t\t{Name: proxyValidBlogTeamA.Name,\n\t\t\t\tNamespace: proxyValidBlogTeamA.Namespace}: fixture.NewValidCondition().\n\t\t\t\tOrphaned(),\n\t\t\t{Name: proxyValidBlogTeamB.Name,\n\t\t\t\tNamespace: proxyValidBlogTeamB.Namespace}: fixture.NewValidCondition().\n\t\t\t\tOrphaned(),\n\t\t},\n\t})\n\n\tproxyInvalidMissingInclude := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName: \"child\",\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"httpproxy w/ missing include\", testcase{\n\t\tobjs: []interface{}{proxyInvalidMissingInclude, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidMissingInclude.Name, Namespace: proxyInvalidMissingInclude.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeIncludeError, \"IncludeNotFound\", \"include roots/child not found\"),\n\t\t},\n\t})\n\n\tproxyTCPInvalidMissingService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"missing-tcp-proxy-service\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"not-found\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"httpproxy w/ tcpproxy w/ missing service\", testcase{\n\t\tobjs: []interface{}{proxyTCPInvalidMissingService},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPInvalidMissingService.Name, Namespace: proxyTCPInvalidMissingService.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTCPProxyError, \"UnresolvedServiceRef\", `Spec.TCPProxy unresolved service reference: service \"roots/not-found\" not found`),\n\t\t},\n\t})\n\n\tproxyTCPInvalidPortNotMatched := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"tcp-proxy-service-missing-port\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 9999,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"httpproxy w/ tcpproxy w/ service missing port\", testcase{\n\t\tobjs: []interface{}{proxyTCPInvalidPortNotMatched, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPInvalidPortNotMatched.Name, Namespace: proxyTCPInvalidPortNotMatched.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTCPProxyError, \"UnresolvedServiceRef\", `Spec.TCPProxy unresolved service reference: port \"9999\" on service \"roots/kuard\" not matched`),\n\t\t},\n\t})\n\n\tproxyTCPInvalidMissingTLS := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"missing-tls\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"httpproxy w/ tcpproxy missing tls\", testcase{\n\t\tobjs: []interface{}{proxyTCPInvalidMissingTLS},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPInvalidMissingTLS.Name, Namespace: proxyTCPInvalidMissingTLS.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTCPProxyError, \"TLSMustBeConfigured\", \"Spec.TCPProxy requires that either Spec.TLS.Passthrough or Spec.TLS.SecretName be set\"),\n\t\t},\n\t})\n\n\tproxyInvalidMissingServiceWithTCPProxy := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"missing-route-service\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: fixture.SecretRootsCert.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{\n\t\t\t\t\t{Name: \"missing\", Port: 9000},\n\t\t\t\t},\n\t\t\t}},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"httpproxy w/ tcpproxy missing service\", testcase{\n\t\tobjs: []interface{}{fixture.SecretRootsCert, fixture.ServiceRootsKuard, proxyInvalidMissingServiceWithTCPProxy},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidMissingServiceWithTCPProxy.Name, Namespace: proxyInvalidMissingServiceWithTCPProxy.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeServiceError, \"ServiceUnresolvedReference\", `Spec.Routes unresolved service reference: service \"roots/missing\" not found`),\n\t\t},\n\t})\n\n\tproxyRoutePortNotMatchedWithTCP := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"missing-route-service-port\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: fixture.SecretRootsCert.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{\n\t\t\t\t\t{Name: fixture.ServiceRootsKuard.Name, Port: 9999},\n\t\t\t\t},\n\t\t\t}},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"tcpproxy route unmatched service port\", testcase{\n\t\tobjs: []interface{}{fixture.SecretRootsCert, fixture.ServiceRootsKuard, proxyRoutePortNotMatchedWithTCP},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyRoutePortNotMatchedWithTCP.Name, Namespace: proxyRoutePortNotMatchedWithTCP.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeServiceError, \"ServiceUnresolvedReference\", `Spec.Routes unresolved service reference: port \"9999\" on service \"roots/kuard\" not matched`),\n\t\t},\n\t})\n\n\tproxyTCPValidIncludeChild := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"validtcpproxy\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: fixture.SecretRootsCert.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tInclude: &contour_api_v1.TCPProxyInclude{\n\t\t\t\t\tName:      \"child\",\n\t\t\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tproxyTCPValidIncludesChild := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"validtcpproxy\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: fixture.SecretRootsCert.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tIncludesDeprecated: &contour_api_v1.TCPProxyInclude{\n\t\t\t\t\tName:      \"child\",\n\t\t\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tproxyTCPValidChild := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"child\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"valid HTTPProxy.TCPProxy - plural\", testcase{\n\t\tobjs: []interface{}{proxyTCPValidIncludesChild, proxyTCPValidChild, fixture.ServiceRootsKuard, fixture.SecretRootsCert},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPValidIncludesChild.Name,\n\t\t\t\tNamespace: proxyTCPValidIncludesChild.Namespace}: fixture.NewValidCondition().Valid(),\n\t\t\t{Name: proxyTCPValidChild.Name,\n\t\t\t\tNamespace: proxyTCPValidChild.Namespace}: fixture.NewValidCondition().Valid(),\n\t\t},\n\t})\n\n\trun(t, \"valid HTTPProxy.TCPProxy\", testcase{\n\t\tobjs: []interface{}{proxyTCPValidIncludeChild, proxyTCPValidChild, fixture.ServiceRootsKuard, fixture.SecretRootsCert},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPValidIncludeChild.Name,\n\t\t\t\tNamespace: proxyTCPValidIncludeChild.Namespace}: fixture.NewValidCondition().Valid(),\n\t\t\t{Name: proxyTCPValidChild.Name,\n\t\t\t\tNamespace: proxyTCPValidChild.Namespace}: fixture.NewValidCondition().Valid(),\n\t\t},\n\t})\n\n\t// issue 2309\n\tproxyInvalidNoServices := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"missing-service\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"missing-service.example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: nil, // missing\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"invalid HTTPProxy due to empty route.service\", testcase{\n\t\tobjs: []interface{}{proxyInvalidNoServices, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidNoServices.Name, Namespace: proxyInvalidNoServices.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeRouteError, \"NoServicesPresent\", \"route.services must have at least one entry\"),\n\t\t},\n\t})\n\n\tfallbackCertificate := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName:                \"ssl-cert\",\n\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"invalid fallback certificate passed to contour\", testcase{\n\t\tfallbackCertificate: &types.NamespacedName{\n\t\t\tName:      \"invalid\",\n\t\t\tNamespace: \"invalid\",\n\t\t},\n\t\tobjs: []interface{}{fallbackCertificate, fixture.SecretRootsFallback, fixture.SecretRootsCert, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: fallbackCertificate.Name,\n\t\t\t\tNamespace: fallbackCertificate.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"FallbackNotValid\", `Spec.Virtualhost.TLS Secret \"invalid/invalid\" fallback certificate is invalid: Secret not found`),\n\t\t},\n\t})\n\n\trun(t, \"fallback certificate requested but cert not configured in contour\", testcase{\n\t\tobjs: []interface{}{fallbackCertificate, fixture.SecretRootsFallback, fixture.SecretRootsCert, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: fallbackCertificate.Name,\n\t\t\t\tNamespace: fallbackCertificate.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"FallbackNotPresent\", \"Spec.Virtualhost.TLS enabled fallback but the fallback Certificate Secret is not configured in Contour configuration file\"),\n\t\t},\n\t})\n\n\tfallbackCertificateWithClientValidationNoCA := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName:       \"ssl-cert\",\n\t\t\t\t\tClientValidation: &contour_api_v1.DownstreamValidation{},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"clientValidation missing CA\", testcase{\n\t\tobjs: []interface{}{fallbackCertificateWithClientValidationNoCA, fixture.SecretRootsFallback, fixture.SecretRootsCert, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: fallbackCertificateWithClientValidationNoCA.Name,\n\t\t\t\tNamespace: fallbackCertificateWithClientValidationNoCA.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"ClientValidationInvalid\", \"Spec.VirtualHost.TLS client validation is invalid: CA Secret must be specified\"),\n\t\t},\n\t})\n\n\tfallbackCertificateWithClientValidation := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName:                \"ssl-cert\",\n\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t\tClientValidation: &contour_api_v1.DownstreamValidation{\n\t\t\t\t\t\tCACertificate: \"something\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"fallback certificate requested and clientValidation also configured\", testcase{\n\t\tobjs: []interface{}{fallbackCertificateWithClientValidation, fixture.SecretRootsFallback, fixture.SecretRootsCert, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: fallbackCertificateWithClientValidation.Name,\n\t\t\t\tNamespace: fallbackCertificateWithClientValidation.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"TLSIncompatibleFeatures\", \"Spec.Virtualhost.TLS fallback & client validation are incompatible\"),\n\t\t},\n\t})\n\n\ttlsPassthroughAndValidation := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"invalid\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t\tClientValidation: &contour_api_v1.DownstreamValidation{\n\t\t\t\t\t\tCACertificate: \"aCAcert\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{},\n\t\t},\n\t}\n\n\trun(t, \"passthrough and client auth are incompatible tlsPassthroughAndValidation\", testcase{\n\t\tobjs: []interface{}{fixture.SecretRootsCert, tlsPassthroughAndValidation},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: tlsPassthroughAndValidation.Name, Namespace: tlsPassthroughAndValidation.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"TLSIncompatibleFeatures\", \"Spec.VirtualHost.TLS passthrough cannot be combined with tls.clientValidation\"),\n\t\t},\n\t})\n\n\ttlsPassthroughAndSecretName := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"invalid\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t\tSecretName:  fixture.SecretRootsCert.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{},\n\t\t},\n\t}\n\n\trun(t, \"tcpproxy with TLS passthrough and secret name both specified\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tfixture.SecretRootsCert,\n\t\t\ttlsPassthroughAndSecretName,\n\t\t},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: \"invalid\", Namespace: fixture.ServiceRootsKuard.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"TLSConfigNotValid\", \"Spec.VirtualHost.TLS: both Passthrough and SecretName were specified\"),\n\t\t},\n\t})\n\n\ttlsNoPassthroughOrSecretName := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"invalid\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: false,\n\t\t\t\t\tSecretName:  \"\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{},\n\t\t},\n\t}\n\n\trun(t, \"httpproxy w/ tcpproxy with neither TLS passthrough nor secret name specified\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tfixture.SecretRootsCert,\n\t\t\ttlsNoPassthroughOrSecretName,\n\t\t},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: \"invalid\", Namespace: fixture.ServiceRootsKuard.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"TLSConfigNotValid\", \"Spec.VirtualHost.TLS: neither Passthrough nor SecretName were specified\"),\n\t\t},\n\t})\n\n\temptyProxy := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"empty\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"proxy with no routes, includes, or tcpproxy is invalid\", testcase{\n\t\tobjs: []interface{}{emptyProxy},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: emptyProxy.Name, Namespace: emptyProxy.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeSpecError, \"NothingDefined\", \"HTTPProxy.Spec must have at least one Route, Include, or a TCPProxy\"),\n\t\t},\n\t})\n\n\tinvalidRequestHeadersPolicyService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"invalidRHPService\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\t\tPort: 8080,\n\t\t\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\t\t\tValue: \"external.com\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"requestHeadersPolicy, Host header invalid on Service\", testcase{\n\t\tobjs: []interface{}{invalidRequestHeadersPolicyService, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: invalidRequestHeadersPolicyService.Name, Namespace: invalidRequestHeadersPolicyService.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeServiceError, \"RequestHeadersPolicyInvalid\", `rewriting \"Host\" header is not supported on request headers`),\n\t\t},\n\t})\n\n\tinvalidResponseHeadersPolicyService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"invalidRHPService\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\t\tPort: 8080,\n\t\t\t\t\t\tResponseHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\t\t\tValue: \"external.com\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"responseHeadersPolicy, Host header invalid on Service\", testcase{\n\t\tobjs: []interface{}{invalidResponseHeadersPolicyService, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: invalidResponseHeadersPolicyService.Name, Namespace: invalidResponseHeadersPolicyService.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeServiceError, \"ResponseHeadersPolicyInvalid\", `rewriting \"Host\" header is not supported on response headers`),\n\t\t},\n\t})\n\n\tinvalidResponseHeadersPolicyRoute := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"invalidRHPRoute\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\t\tPort: 8080,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tResponseHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\tValue: \"external.com\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"responseHeadersPolicy, Host header invalid on Route\", testcase{\n\t\tobjs: []interface{}{invalidResponseHeadersPolicyRoute, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: invalidResponseHeadersPolicyRoute.Name, Namespace: invalidResponseHeadersPolicyRoute.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeRouteError, \"ResponseHeaderPolicyInvalid\", `rewriting \"Host\" header is not supported on response headers`),\n\t\t},\n\t})\n\n\tproxyAuthFallback := fixture.NewProxy(\"roots/fallback-incompat\").\n\t\tWithSpec(contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"invalid.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName:                \"ssl-cert\",\n\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t},\n\t\t\t\tAuthorization: &contour_api_v1.AuthorizationServer{\n\t\t\t\t\tExtensionServiceRef: contour_api_v1.ExtensionServiceReference{\n\t\t\t\t\t\tNamespace: \"auth\",\n\t\t\t\t\t\tName:      \"extension\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{Name: \"app-server\", Port: 80}},\n\t\t\t}},\n\t\t})\n\n\trun(t, \"fallback and client auth is invalid\", testcase{\n\t\tobjs: []interface{}{fixture.SecretRootsCert, proxyAuthFallback},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyAuthFallback.Name, Namespace: proxyAuthFallback.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"TLSIncompatibleFeatures\", \"Spec.Virtualhost.TLS fallback & client authorization are incompatible\"),\n\t\t},\n\t})\n\n\tinvalidResponseTimeout := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t\tName:      \"invalid-timeouts\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{\n\t\t\t\t{\n\t\t\t\t\tServices: []contour_api_v1.Service{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tTimeoutPolicy: &contour_api_v1.TimeoutPolicy{\n\t\t\t\t\t\tResponse: \"invalid-val\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"proxy with invalid response timeout value is invalid\", testcase{\n\t\tobjs: []interface{}{invalidResponseTimeout, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{\n\t\t\t\tName:      invalidResponseTimeout.Name,\n\t\t\t\tNamespace: invalidResponseTimeout.Namespace,\n\t\t\t}: fixture.NewValidCondition().WithError(contour_api_v1.ConditionTypeRouteError, \"TimeoutPolicyNotValid\",\n\t\t\t\t`route.timeoutPolicy failed to parse: error parsing response timeout: unable to parse timeout string \"invalid-val\": time: invalid duration \"invalid-val\"`),\n\t\t},\n\t})\n\n\tinvalidIdleTimeout := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t\tName:      \"invalid-timeouts\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{\n\t\t\t\t{\n\t\t\t\t\tServices: []contour_api_v1.Service{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tTimeoutPolicy: &contour_api_v1.TimeoutPolicy{\n\t\t\t\t\t\tIdle: \"invalid-val\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"proxy with invalid idle timeout value is invalid\", testcase{\n\t\tobjs: []interface{}{invalidIdleTimeout, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{\n\t\t\t\tName:      invalidIdleTimeout.Name,\n\t\t\t\tNamespace: invalidIdleTimeout.Namespace,\n\t\t\t}: fixture.NewValidCondition().WithError(contour_api_v1.ConditionTypeRouteError, \"TimeoutPolicyNotValid\",\n\t\t\t\t`route.timeoutPolicy failed to parse: error parsing idle timeout: unable to parse timeout string \"invalid-val\": time: invalid duration \"invalid-val\"`),\n\t\t},\n\t})\n\n\t// issue 3197: Fallback and passthrough HTTPProxy directive should emit a config error\n\ttlsPassthroughAndFallback := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace:  \"roots\",\n\t\t\tName:       \"example\",\n\t\t\tGeneration: 24,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough:               true,\n\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t},\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"TLS with passthrough and fallback cert enabled is invalid\", testcase{\n\t\tobjs: []interface{}{tlsPassthroughAndFallback, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: tlsPassthroughAndFallback.Name, Namespace: tlsPassthroughAndFallback.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(tlsPassthroughAndFallback.Generation).WithError(\n\t\t\t\tcontour_api_v1.ConditionTypeTLSError, \"TLSIncompatibleFeatures\",\n\t\t\t\t`Spec.VirtualHost.TLS: both Passthrough and enableFallbackCertificate were specified`,\n\t\t\t),\n\t\t},\n\t})\n\ttlsPassthrough := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace:  \"roots\",\n\t\t\tName:       \"example\",\n\t\t\tGeneration: 24,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough:               true,\n\t\t\t\t\tEnableFallbackCertificate: false,\n\t\t\t\t},\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"valid TLS passthrough\", testcase{\n\t\tobjs: []interface{}{tlsPassthrough, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: tlsPassthrough.Name, Namespace: tlsPassthrough.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(tlsPassthrough.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n}\n\nfunc TestGatewayAPIHTTPRouteDAGStatus(t *testing.T) {\n\n\ttype testcase struct {\n\t\tobjs []interface{}\n\t\twant []*status.RouteConditionsUpdate\n\t}\n\n\trun := func(t *testing.T, desc string, tc testcase) {\n\t\tt.Helper()\n\t\tt.Run(desc, func(t *testing.T) {\n\t\t\tt.Helper()\n\t\t\tbuilder := Builder{\n\t\t\t\tSource: KubernetesCache{\n\t\t\t\t\tRootNamespaces: []string{\"roots\", \"marketing\"},\n\t\t\t\t\tFieldLogger:    fixture.NewTestLogger(t),\n\t\t\t\t\tConfiguredGateway: types.NamespacedName{\n\t\t\t\t\t\tNamespace: \"contour\",\n\t\t\t\t\t\tName:      \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tgatewayclass: &gatewayapi_v1alpha1.GatewayClass{\n\t\t\t\t\t\tTypeMeta: metav1.TypeMeta{},\n\t\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\t\tName: \"test-gc\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tSpec: gatewayapi_v1alpha1.GatewayClassSpec{\n\t\t\t\t\t\t\tController: \"projectcontour.io/contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tStatus: gatewayapi_v1alpha1.GatewayClassStatus{\n\t\t\t\t\t\t\tConditions: []metav1.Condition{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tType:   string(gatewayapi_v1alpha1.GatewayClassConditionStatusAdmitted),\n\t\t\t\t\t\t\t\t\tStatus: metav1.ConditionTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\t\t\tPort:     80,\n\t\t\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tProcessors: []Processor{\n\t\t\t\t\t&IngressProcessor{\n\t\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t\t},\n\t\t\t\t\t&HTTPProxyProcessor{},\n\t\t\t\t\t&GatewayAPIProcessor{\n\t\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t\t},\n\t\t\t\t\t&ListenerProcessor{},\n\t\t\t\t},\n\t\t\t}\n\t\t\tfor _, o := range tc.objs {\n\t\t\t\tbuilder.Source.Insert(o)\n\t\t\t}\n\t\t\tdag := builder.Build()\n\t\t\tgotUpdates := dag.StatusCache.GetRouteUpdates()\n\n\t\t\tops := []cmp.Option{\n\t\t\t\tcmpopts.IgnoreFields(metav1.Condition{}, \"LastTransitionTime\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"ExistingConditions\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"GatewayRef\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"Generation\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"TransitionTime\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"Resource\"),\n\t\t\t\tcmpopts.SortSlices(func(i, j metav1.Condition) bool {\n\t\t\t\t\treturn i.Message < j.Message\n\t\t\t\t}),\n\t\t\t}\n\n\t\t\tif diff := cmp.Diff(tc.want, gotUpdates, ops...); diff != \"\" {\n\t\t\t\tt.Fatalf(\"expected: %v, got %v\", tc.want, diff)\n\t\t\t}\n\n\t\t})\n\t}\n\n\tkuardService := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"simple httproute\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionTrue,\n\t\t\t\t\tReason:  string(status.ValidCondition),\n\t\t\t\t\tMessage: \"Valid HTTPRoute\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"invalid prefix match for httproute\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.HTTPRouteMatch{{\n\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(\"UNKNOWN\"), // <---- unknown type to break the test\n\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t\tstatus.ConditionNotImplemented: {\n\t\t\t\t\tType:    string(status.ConditionNotImplemented),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionTrue,\n\t\t\t\t\tReason:  string(status.ReasonPathMatchType),\n\t\t\t\t\tMessage: \"HTTPRoute.Spec.Rules.PathMatch: Only Prefix match type and Exact match type are supported.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"regular expression match not yet supported for httproute\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchRegularExpression, \"/\"),\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t\tstatus.ConditionNotImplemented: {\n\t\t\t\t\tType:    string(status.ConditionNotImplemented),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionTrue,\n\t\t\t\t\tReason:  string(status.ReasonPathMatchType),\n\t\t\t\t\tMessage: \"HTTPRoute.Spec.Rules.PathMatch: Only Prefix match type and Exact match type are supported.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"RegularExpression header match not yet supported for httproute\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.HTTPRouteMatch{{\n\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(gatewayapi_v1alpha1.PathMatchPrefix),\n\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tHeaders: &gatewayapi_v1alpha1.HTTPHeaderMatch{\n\t\t\t\t\t\t\t\tType:   headerMatchTypePtr(gatewayapi_v1alpha1.HeaderMatchRegularExpression), // <---- RegularExpression type not yet supported\n\t\t\t\t\t\t\t\tValues: map[string]string{\"foo\": \"bar\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t\tstatus.ConditionNotImplemented: {\n\t\t\t\t\tType:    string(status.ConditionNotImplemented),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionTrue,\n\t\t\t\t\tReason:  string(status.ReasonHeaderMatchType),\n\t\t\t\t\tMessage: \"HTTPRoute.Spec.Rules.HeaderMatch: Only Exact match type is supported.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"spec.tls not yet supported for httproute\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tTLS: &gatewayapi_v1alpha1.RouteTLSConfig{\n\t\t\t\t\t\tCertificateRef: gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\t\tKind:  \"secret\",\n\t\t\t\t\t\t\tName:  \"someSecret\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t\tstatus.ConditionNotImplemented: {\n\t\t\t\t\tType:    string(status.ConditionNotImplemented),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionTrue,\n\t\t\t\t\tReason:  string(status.ReasonNotImplemented),\n\t\t\t\t\tMessage: \"HTTPRoute.Spec.TLS: Not yet implemented.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"spec.rules.forwardTo.serviceName not specified\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: nil,\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\tMessage: \"Spec.Rules.ForwardTo.ServiceName must be specified\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"spec.rules.forwardTo.serviceName invalid on two matches\", testcase{\n\t\tobjs: []interface{}{\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.HTTPRouteMatch{{\n\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(gatewayapi_v1alpha1.PathMatchPrefix),\n\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"invalid-one\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t}, {\n\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.HTTPRouteMatch{{\n\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(gatewayapi_v1alpha1.PathMatchPrefix),\n\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/blog\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"invalid-two\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\tMessage: \"service \\\"invalid-one\\\" does not exist, service \\\"invalid-two\\\" does not exist\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"spec.rules.forwardTo.servicePort not specified\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        nil,\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\tMessage: \"Spec.Rules.ForwardTo.ServicePort must be specified\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"spec.rules.forwardTo not specified\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\tMessage: \"At least one Spec.Rules.ForwardTo must be specified.\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"spec.rules.hostname: invalid wildcard\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"*.*.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\tMessage: \"invalid hostname \\\"*.*.projectcontour.io\\\": [a wildcard DNS-1123 subdomain must start with '*.', followed by a valid DNS subdomain, which must consist of lower case alphanumeric characters, '-' or '.' and end with an alphanumeric character (e.g. '*.example.com', regex used for validation is '\\\\*\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*')]\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"spec.rules.hostname: invalid hostname\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"#projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\tMessage: \"invalid hostname \\\"#projectcontour.io\\\": [a lowercase RFC 1123 subdomain must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character (e.g. 'example.com', regex used for validation is '[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*')]\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"spec.rules.hostname: invalid hostname, ip address\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"1.2.3.4\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\tMessage: \"hostname \\\"1.2.3.4\\\" must be a DNS name, not an IP address\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"HTTPRouteFilterRequestMirror not yet supported for httproute rule\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tFilters: []gatewayapi_v1alpha1.HTTPRouteFilter{{\n\t\t\t\t\t\t\tType: gatewayapi_v1alpha1.HTTPRouteFilterRequestMirror, // HTTPRouteFilterRequestMirror is not supported yet.\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionNotImplemented: {\n\t\t\t\t\tType:    string(status.ConditionNotImplemented),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionTrue,\n\t\t\t\t\tReason:  string(status.ReasonHTTPRouteFilterType),\n\t\t\t\t\tMessage: \"HTTPRoute.Spec.Rules.Filters: Only RequestHeaderModifier type is supported.\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"HTTPRouteFilterRequestMirror not yet supported for httproute forwardto\", testcase{\n\t\tobjs: []interface{}{\n\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\tFilters: []gatewayapi_v1alpha1.HTTPRouteFilter{{\n\t\t\t\t\t\t\t\tType: gatewayapi_v1alpha1.HTTPRouteFilterRequestMirror, // HTTPRouteFilterRequestMirror is not supported yet.\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionNotImplemented: {\n\t\t\t\t\tType:    string(status.ConditionNotImplemented),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionTrue,\n\t\t\t\t\tReason:  string(status.ReasonHTTPRouteFilterType),\n\t\t\t\t\tMessage: \"HTTPRoute.Spec.Rules.ForwardTo.Filters: Only RequestHeaderModifier type is supported.\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"Invalid RequestHeaderModifier due to duplicated headers\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tFilters: []gatewayapi_v1alpha1.HTTPRouteFilter{{\n\t\t\t\t\t\t\tType: gatewayapi_v1alpha1.HTTPRouteFilterRequestHeaderModifier,\n\t\t\t\t\t\t\tRequestHeaderModifier: &gatewayapi_v1alpha1.HTTPRequestHeaderFilter{\n\t\t\t\t\t\t\t\tSet: map[string]string{\"custom\": \"duplicated\", \"Custom\": \"duplicated\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\tMessage: \"duplicate header addition: \\\"Custom\\\" on request headers\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"Invalid RequestHeaderModifier after forward due to invalid headers\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\tFilters: []gatewayapi_v1alpha1.HTTPRouteFilter{{\n\t\t\t\t\t\t\t\tType: gatewayapi_v1alpha1.HTTPRouteFilterRequestHeaderModifier,\n\t\t\t\t\t\t\t\tRequestHeaderModifier: &gatewayapi_v1alpha1.HTTPRequestHeaderFilter{\n\t\t\t\t\t\t\t\t\tSet: map[string]string{\"!invalid-header\": \"foo\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\tMessage: \"invalid set header \\\"!invalid-Header\\\": [a valid HTTP header must consist of alphanumeric characters or '-' (e.g. 'X-Header-Name', regex used for validation is '[-A-Za-z0-9]+')] on request headers\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"gateway selectors match but spec.gateways.allowtype doesn't\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonGatewayAllowMismatch),\n\t\t\t\t\tMessage: \"Gateway RouteSelector matches, but GatewayAllow has mismatch.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n}\n\nfunc TestGatewayAPITLSRouteDAGStatus(t *testing.T) {\n\n\ttype testcase struct {\n\t\tobjs    []interface{}\n\t\tgateway *gatewayapi_v1alpha1.Gateway\n\t\twant    []*status.RouteConditionsUpdate\n\t}\n\n\trun := func(t *testing.T, desc string, tc testcase) {\n\t\tt.Helper()\n\t\tt.Run(desc, func(t *testing.T) {\n\t\t\tt.Helper()\n\t\t\tbuilder := Builder{\n\t\t\t\tSource: KubernetesCache{\n\t\t\t\t\tRootNamespaces: []string{\"roots\", \"marketing\"},\n\t\t\t\t\tFieldLogger:    fixture.NewTestLogger(t),\n\t\t\t\t\tConfiguredGateway: types.NamespacedName{\n\t\t\t\t\t\tNamespace: \"contour\",\n\t\t\t\t\t\tName:      \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tgateway: tc.gateway,\n\t\t\t\t\tgatewayclass: &gatewayapi_v1alpha1.GatewayClass{\n\t\t\t\t\t\tTypeMeta: metav1.TypeMeta{},\n\t\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\t\tName: \"test-gc\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tSpec: gatewayapi_v1alpha1.GatewayClassSpec{\n\t\t\t\t\t\t\tController: \"projectcontour.io/contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tStatus: gatewayapi_v1alpha1.GatewayClassStatus{\n\t\t\t\t\t\t\tConditions: []metav1.Condition{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tType:   string(gatewayapi_v1alpha1.GatewayClassConditionStatusAdmitted),\n\t\t\t\t\t\t\t\t\tStatus: metav1.ConditionTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tProcessors: []Processor{\n\t\t\t\t\t&IngressProcessor{\n\t\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t\t},\n\t\t\t\t\t&HTTPProxyProcessor{},\n\t\t\t\t\t&GatewayAPIProcessor{\n\t\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t\t},\n\t\t\t\t\t&ListenerProcessor{},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\t// Add a default cert to be used in tests with TLS.\n\t\t\tbuilder.Source.Insert(fixture.SecretProjectContourCert)\n\n\t\t\tfor _, o := range tc.objs {\n\t\t\t\tbuilder.Source.Insert(o)\n\t\t\t}\n\t\t\tdag := builder.Build()\n\t\t\tgotUpdates := dag.StatusCache.GetRouteUpdates()\n\n\t\t\tops := []cmp.Option{\n\t\t\t\tcmpopts.IgnoreFields(metav1.Condition{}, \"LastTransitionTime\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"ExistingConditions\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"GatewayRef\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"Generation\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"TransitionTime\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"Resource\"),\n\t\t\t\tcmpopts.SortSlices(func(i, j metav1.Condition) bool {\n\t\t\t\t\treturn i.Message < j.Message\n\t\t\t\t}),\n\t\t\t}\n\n\t\t\tif diff := cmp.Diff(tc.want, gotUpdates, ops...); diff != \"\" {\n\t\t\t\tt.Fatalf(\"expected: %v, got %v\", tc.want, diff)\n\t\t\t}\n\n\t\t})\n\t}\n\n\tgateways := []*gatewayapi_v1alpha1.Gateway{{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     443,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.TLSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\t// Mode is not defined and should default to \"Terminate\".\n\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\tKind:  \"Secret\",\n\t\t\t\t\t\tName:  fixture.SecretProjectContourCert.Name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tKind: KindTLSRoute,\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}, {\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     443,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.TLSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\tMode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModeTerminate),\n\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\tKind:  \"Secret\",\n\t\t\t\t\t\tName:  fixture.SecretProjectContourCert.Name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tKind: KindTLSRoute,\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}, {\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     443,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.TLSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\tMode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModePassthrough),\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tKind: KindTLSRoute,\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}}\n\n\tkuardService := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\t// Both a \"mode: terminate\" & a \"mode: passthrough\" should return the same\n\t// valid status. This loops through all three types (Not Defined, Terminate, Passthrough)\n\t// and validates the proper status is set. Note when not defined, the default is \"terminate\".\n\tfor _, gw := range gateways {\n\n\t\trun(t, \"TLSRoute: spec.rules.forwardTo.serviceName not specified\", testcase{\n\t\t\tgateway: gw,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\"test.projectcontour.io\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{\n\t\t\t\t\t\t\t\tServiceName: nil,\n\t\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\t\tMessage: \"Spec.Rules.ForwardTo.ServiceName must be specified\",\n\t\t\t\t\t},\n\t\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  \"ErrorsExist\",\n\t\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t})\n\n\t\trun(t, \"TLSRoute: spec.rules.forwardTo.serviceName invalid on two matches\", testcase{\n\t\t\tgateway: gw,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\"test.projectcontour.io\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{\n\t\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"invalid-one\"),\n\t\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\"another.projectcontour.io\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{\n\t\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"invalid-two\"),\n\t\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\t\tMessage: \"service \\\"invalid-one\\\" does not exist, service \\\"invalid-two\\\" does not exist\",\n\t\t\t\t\t},\n\t\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  \"ErrorsExist\",\n\t\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t})\n\n\t\trun(t, \"TLSRoute: spec.rules.forwardTo.servicePort not specified\", testcase{\n\t\t\tgateway: gw,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\"test.projectcontour.io\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{\n\t\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\t\tPort:        nil,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\t\tMessage: \"Spec.Rules.ForwardTo.ServicePort must be specified\",\n\t\t\t\t\t},\n\t\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  \"ErrorsExist\",\n\t\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t})\n\n\t\trun(t, \"TLSRoute: spec.rules.forwardTo not specified\", testcase{\n\t\t\tgateway: gw,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\"test.projectcontour.io\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\t\tMessage: \"At least one Spec.Rules.ForwardTo must be specified.\",\n\t\t\t\t\t},\n\t\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  \"ErrorsExist\",\n\t\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t})\n\n\t\trun(t, \"TLSRoute: spec.rules.hostname: invalid wildcard\", testcase{\n\t\t\tgateway: gw,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\"*.*.projectcontour.io\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{\n\t\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\t\tMessage: \"invalid hostname \\\"*.*.projectcontour.io\\\": [a wildcard DNS-1123 subdomain must start with '*.', followed by a valid DNS subdomain, which must consist of lower case alphanumeric characters, '-' or '.' and end with an alphanumeric character (e.g. '*.example.com', regex used for validation is '\\\\*\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*')]\",\n\t\t\t\t\t},\n\t\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  \"ErrorsExist\",\n\t\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t})\n\n\t\trun(t, \"TLSRoute: spec.rules.hostname: invalid hostname\", testcase{\n\t\t\tgateway: gw,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\"#projectcontour.io\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{\n\t\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\t\tMessage: \"invalid hostname \\\"#projectcontour.io\\\": [a lowercase RFC 1123 subdomain must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character (e.g. 'example.com', regex used for validation is '[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*')]\",\n\t\t\t\t\t},\n\t\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  \"ErrorsExist\",\n\t\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t})\n\n\t\trun(t, \"TLSRoute: spec.rules.hostname: invalid hostname, ip address\", testcase{\n\t\t\tgateway: gw,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\"1.2.3.4\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{\n\t\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\t\tMessage: \"hostname \\\"1.2.3.4\\\" must be a DNS name, not an IP address\",\n\t\t\t\t\t},\n\t\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  \"ErrorsExist\",\n\t\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t})\n\t}\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage v3\n\nimport (\n\t\"testing\"\n\n\t\"github.com/projectcontour/contour/internal/featuretests\"\n\n\tenvoy_cluster_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3\"\n\tenvoy_route_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/route/v3\"\n\tenvoy_extensions_upstream_http_v3 \"github.com/envoyproxy/go-control-plane/envoy/extensions/upstreams/http/v3\"\n\tenvoy_discovery_v3 \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"\n\t\"github.com/golang/protobuf/ptypes/any\"\n\tcontour_api_v1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"\n\tenvoy_v3 \"github.com/projectcontour/contour/internal/envoy/v3\"\n\t\"github.com/projectcontour/contour/internal/fixture\"\n\t\"github.com/projectcontour/contour/internal/protobuf\"\n\tv1 \"k8s.io/api/core/v1\"\n\tnetworking_v1 \"k8s.io/api/networking/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n\t\"k8s.io/utils/pointer\"\n)\n\n// Assert that services of type v1.ServiceTypeExternalName can be\n// referenced by an Ingress, or HTTPProxy document.\nfunc TestExternalNameService(t *testing.T) {\n\trh, c, done := setup(t)\n\tdefer done()\n\n\ts1 := fixture.NewService(\"kuard\").\n\t\tWithSpec(v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tPort:       80,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t\tExternalName: \"foo.io\",\n\t\t\tType:         v1.ServiceTypeExternalName,\n\t\t})\n\n\ti1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tDefaultBackend: featuretests.IngressBackend(s1),\n\t\t},\n\t}\n\trh.OnAdd(s1)\n\trh.OnAdd(i1)\n\n\tc.Request(routeType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tResources: resources(t,\n\t\t\tenvoy_v3.RouteConfiguration(\"ingress_http\",\n\t\t\t\tenvoy_v3.VirtualHost(\"*\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch:  routePrefix(\"/\"),\n\t\t\t\t\t\tAction: routeCluster(\"default/kuard/80/da39a3ee5e\"),\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t\tTypeUrl: routeType,\n\t})\n\n\tc.Request(clusterType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tResources: resources(t,\n\t\t\texternalNameCluster(\"default/kuard/80/da39a3ee5e\", \"default/kuard\", \"default_kuard_80\", \"foo.io\", 80),\n\t\t),\n\t\tTypeUrl: clusterType,\n\t})\n\n\trh.OnDelete(i1)\n\n\trh.OnAdd(fixture.NewProxy(\"kuard\").\n\t\tWithFQDN(\"kuard.projectcontour.io\").\n\t\tWithSpec(contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t}),\n\t)\n\n\tc.Request(routeType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tResources: resources(t,\n\t\t\tenvoy_v3.RouteConfiguration(\"ingress_http\",\n\t\t\t\tenvoy_v3.VirtualHost(\"kuard.projectcontour.io\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch:  routePrefix(\"/\"),\n\t\t\t\t\t\tAction: routeCluster(\"default/kuard/80/da39a3ee5e\"),\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t\tTypeUrl: routeType,\n\t})\n\n\tc.Request(clusterType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tResources: resources(t,\n\t\t\texternalNameCluster(\"default/kuard/80/da39a3ee5e\", \"default/kuard\", \"default_kuard_80\", \"foo.io\", 80),\n\t\t),\n\t\tTypeUrl: clusterType,\n\t})\n\n\t// After we set the Host header, the cluster should remain\n\t// the same, but the Route should do update the Host header.\n\trh.OnDelete(fixture.NewProxy(\"kuard\").WithSpec(contour_api_v1.HTTPProxySpec{}))\n\trh.OnAdd(fixture.NewProxy(\"kuard\").\n\t\tWithFQDN(\"kuard.projectcontour.io\").\n\t\tWithSpec(contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\tValue: \"external.address\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t}),\n\t)\n\n\tc.Request(routeType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tTypeUrl: routeType,\n\t\tResources: resources(t,\n\t\t\tenvoy_v3.RouteConfiguration(\"ingress_http\",\n\t\t\t\tenvoy_v3.VirtualHost(\"kuard.projectcontour.io\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch:  routePrefix(\"/\"),\n\t\t\t\t\t\tAction: routeHostRewrite(\"default/kuard/80/da39a3ee5e\", \"external.address\"),\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t})\n\n\tc.Request(clusterType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tTypeUrl: clusterType,\n\t\tResources: resources(t,\n\t\t\texternalNameCluster(\"default/kuard/80/da39a3ee5e\", \"default/kuard\", \"default_kuard_80\", \"foo.io\", 80),\n\t\t),\n\t})\n\n\t// Now try the same configuration, but enable HTTP/2. We\n\t// should still find that the same configuration applies, but\n\t// TLS is enabled and the SNI server name is overwritten from\n\t// the Host header.\n\trh.OnDelete(fixture.NewProxy(\"kuard\").WithSpec(contour_api_v1.HTTPProxySpec{}))\n\trh.OnAdd(fixture.NewProxy(\"kuard\").\n\t\tWithFQDN(\"kuard.projectcontour.io\").\n\t\tWithSpec(contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tProtocol: pointer.StringPtr(\"h2\"),\n\t\t\t\t\tName:     s1.Name,\n\t\t\t\t\tPort:     80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\tValue: \"external.address\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t}),\n\t)\n\n\tc.Request(routeType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tTypeUrl: routeType,\n\t\tResources: resources(t,\n\t\t\tenvoy_v3.RouteConfiguration(\"ingress_http\",\n\t\t\t\tenvoy_v3.VirtualHost(\"kuard.projectcontour.io\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch:  routePrefix(\"/\"),\n\t\t\t\t\t\tAction: routeHostRewrite(\"default/kuard/80/da39a3ee5e\", \"external.address\"),\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t})\n\n\tc.Request(clusterType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tTypeUrl: clusterType,\n\t\tResources: resources(t,\n\t\t\tDefaultCluster(\n\t\t\t\texternalNameCluster(\"default/kuard/80/da39a3ee5e\", \"default/kuard\", \"default_kuard_80\", \"foo.io\", 80),\n\t\t\t\t&envoy_cluster_v3.Cluster{\n\t\t\t\t\tTypedExtensionProtocolOptions: map[string]*any.Any{\n\t\t\t\t\t\t\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\": protobuf.MustMarshalAny(\n\t\t\t\t\t\t\t&envoy_extensions_upstream_http_v3.HttpProtocolOptions{\n\t\t\t\t\t\t\t\tUpstreamProtocolOptions: &envoy_extensions_upstream_http_v3.HttpProtocolOptions_ExplicitHttpConfig_{\n\t\t\t\t\t\t\t\t\tExplicitHttpConfig: &envoy_extensions_upstream_http_v3.HttpProtocolOptions_ExplicitHttpConfig{\n\t\t\t\t\t\t\t\t\t\tProtocolConfig: &envoy_extensions_upstream_http_v3.HttpProtocolOptions_ExplicitHttpConfig_Http2ProtocolOptions{},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t&envoy_cluster_v3.Cluster{\n\t\t\t\t\tTransportSocket: envoy_v3.UpstreamTLSTransportSocket(\n\t\t\t\t\t\tenvoy_v3.UpstreamTLSContext(nil, \"external.address\", nil, \"h2\"),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t),\n\t})\n\n\t// Now try the same configuration, but enable TLS (which\n\t// means HTTP/1.1 over TLS) rather than HTTP/2. We should get\n\t// TLS enabled with the overridden SNI name. but no HTTP/2\n\t// protocol config.\n\trh.OnDelete(fixture.NewProxy(\"kuard\").WithSpec(contour_api_v1.HTTPProxySpec{}))\n\trh.OnAdd(fixture.NewProxy(\"kuard\").\n\t\tWithFQDN(\"kuard.projectcontour.io\").\n\t\tWithSpec(contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tProtocol: pointer.StringPtr(\"tls\"),\n\t\t\t\t\tName:     s1.Name,\n\t\t\t\t\tPort:     80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\tValue: \"external.address\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t}),\n\t)\n\n\tc.Request(routeType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tTypeUrl: routeType,\n\t\tResources: resources(t,\n\t\t\tenvoy_v3.RouteConfiguration(\"ingress_http\",\n\t\t\t\tenvoy_v3.VirtualHost(\"kuard.projectcontour.io\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch:  routePrefix(\"/\"),\n\t\t\t\t\t\tAction: routeHostRewrite(\"default/kuard/80/da39a3ee5e\", \"external.address\"),\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t})\n\n\tc.Request(clusterType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tTypeUrl: clusterType,\n\t\tResources: resources(t,\n\t\t\tDefaultCluster(\n\t\t\t\texternalNameCluster(\"default/kuard/80/da39a3ee5e\", \"default/kuard\", \"default_kuard_80\", \"foo.io\", 80),\n\t\t\t\t&envoy_cluster_v3.Cluster{\n\t\t\t\t\tTransportSocket: envoy_v3.UpstreamTLSTransportSocket(\n\t\t\t\t\t\tenvoy_v3.UpstreamTLSContext(nil, \"external.address\", nil),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t),\n\t})\n\n\tsec1 := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"secret\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tType: \"kubernetes.io/tls\",\n\t\tData: featuretests.Secretdata(featuretests.CERTIFICATE, featuretests.RSA_PRIVATE_KEY),\n\t}\n\n\t// Create TCPProxy with upstream protocol 'tls' to an externalName type service\n\t// and verify that the SNI on the upstream request matches the externalName value.\n\trh.OnDelete(fixture.NewProxy(\"kuard\").WithSpec(contour_api_v1.HTTPProxySpec{}))\n\trh.OnAdd(sec1)\n\trh.OnAdd(fixture.NewProxy(\"kuard\").\n\t\tWithFQDN(\"kuard.projectcontour.io\").\n\t\tWithCertificate(sec1.Name).\n\t\tWithSpec(contour_api_v1.HTTPProxySpec{\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tProtocol: pointer.StringPtr(\"tls\"),\n\t\t\t\t\tName:     s1.Name,\n\t\t\t\t\tPort:     80,\n\t\t\t\t}},\n\t\t\t},\n\t\t}),\n\t)\n\n\tc.Request(clusterType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tTypeUrl: clusterType,\n\t\tResources: resources(t,\n\t\t\tDefaultCluster(\n\t\t\t\texternalNameCluster(\"default/kuard/80/da39a3ee5e\", \"default/kuard\", \"default_kuard_80\", \"foo.io\", 80),\n\t\t\t\t&envoy_cluster_v3.Cluster{\n\t\t\t\t\tTransportSocket: envoy_v3.UpstreamTLSTransportSocket(\n\t\t\t\t\t\tenvoy_v3.UpstreamTLSContext(nil, \"foo.io\", nil),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t),\n\t})\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage v3\n\nimport (\n\t\"testing\"\n\n\tenvoy_core_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/core/v3\"\n\tenvoy_route_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/route/v3\"\n\tenvoy_discovery_v3 \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"\n\t\"github.com/golang/protobuf/ptypes/wrappers\"\n\tcontour_api_v1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"\n\tenvoy_v3 \"github.com/projectcontour/contour/internal/envoy/v3\"\n\t\"github.com/projectcontour/contour/internal/featuretests\"\n\t\"github.com/projectcontour/contour/internal/fixture\"\n\tv1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n)\n\nfunc TestHeaderPolicy_ReplaceHeader_HTTProxy(t *testing.T) {\n\trh, c, done := setup(t)\n\tdefer done()\n\n\trh.OnAdd(fixture.NewService(\"svc1\").\n\t\tWithPorts(v1.ServicePort{Port: 80, TargetPort: intstr.FromInt(8080)}),\n\t)\n\n\trh.OnAdd(fixture.NewProxy(\"simple\").WithSpec(\n\t\tcontour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{Fqdn: \"hello.world\"},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"svc1\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\tValue: \"goodbye.planet\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t}),\n\t)\n\n\tc.Request(routeType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tResources: resources(t,\n\t\t\tenvoy_v3.RouteConfiguration(\"ingress_http\",\n\t\t\t\tenvoy_v3.VirtualHost(\"hello.world\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch:  routePrefix(\"/\"),\n\t\t\t\t\t\tAction: routeHostRewrite(\"default/svc1/80/da39a3ee5e\", \"goodbye.planet\"),\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t\tTypeUrl: routeType,\n\t})\n\n\t// Non-Host header\n\trh.OnAdd(fixture.NewProxy(\"simple\").WithSpec(\n\t\tcontour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{Fqdn: \"hello.world\"},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"svc1\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"x-header\",\n\t\t\t\t\t\tValue: \"goodbye.planet\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t}),\n\t)\n\n\tc.Request(routeType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tResources: resources(t,\n\t\t\tenvoy_v3.RouteConfiguration(\"ingress_http\",\n\t\t\t\tenvoy_v3.VirtualHost(\"hello.world\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch:  routePrefix(\"/\"),\n\t\t\t\t\t\tAction: routeCluster(\"default/svc1/80/da39a3ee5e\"),\n\t\t\t\t\t\tRequestHeadersToAdd: []*envoy_core_v3.HeaderValueOption{{\n\t\t\t\t\t\t\tHeader: &envoy_core_v3.HeaderValue{\n\t\t\t\t\t\t\t\tKey:   \"X-Header\",\n\t\t\t\t\t\t\t\tValue: \"goodbye.planet\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tAppend: &wrappers.BoolValue{\n\t\t\t\t\t\t\t\tValue: false,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t\tTypeUrl: routeType,\n\t})\n\n\t// Empty value for replaceHeader in HeadersPolicy\n\trh.OnAdd(fixture.NewProxy(\"simple\").WithSpec(\n\t\tcontour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{Fqdn: \"hello.world\"},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"svc1\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName: \"Host\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t}),\n\t)\n\n\tc.Request(routeType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tResources: resources(t,\n\t\t\tenvoy_v3.RouteConfiguration(\"ingress_http\",\n\t\t\t\tenvoy_v3.VirtualHost(\"hello.world\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch:  routePrefix(\"/\"),\n\t\t\t\t\t\tAction: routeCluster(\"default/svc1/80/da39a3ee5e\"),\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t\tTypeUrl: routeType,\n\t})\n\n\trh.OnAdd(fixture.NewService(\"externalname\").\n\t\tAnnotate(\"projectcontour.io/upstream-protocol.tls\", \"https,443\").\n\t\tWithSpec(v1.ServiceSpec{\n\t\t\tExternalName: \"goodbye.planet\",\n\t\t\tType:         v1.ServiceTypeExternalName,\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tPort: 443,\n\t\t\t\tName: \"https\",\n\t\t\t}},\n\t\t}),\n\t)\n\n\trh.OnAdd(&v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"foo\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tType: \"kubernetes.io/tls\",\n\t\tData: featuretests.Secretdata(featuretests.CERTIFICATE, featuretests.RSA_PRIVATE_KEY),\n\t})\n\n\t// Proxy with SNI\n\trh.OnAdd(fixture.NewProxy(\"simple\").WithSpec(\n\t\tcontour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"hello.world\",\n\t\t\t\tTLS:  &contour_api_v1.TLS{SecretName: \"foo\"},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"externalname\",\n\t\t\t\t\tPort: 443,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\tValue: \"goodbye.planet\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t}),\n\t)\n\n\tc.Request(routeType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tResources: routeResources(t,\n\t\t\tenvoy_v3.RouteConfiguration(\"ingress_http\",\n\t\t\t\tenvoy_v3.VirtualHost(\"hello.world\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch: routePrefix(\"/\"),\n\t\t\t\t\t\tAction: &envoy_route_v3.Route_Redirect{\n\t\t\t\t\t\t\tRedirect: &envoy_route_v3.RedirectAction{\n\t\t\t\t\t\t\t\tSchemeRewriteSpecifier: &envoy_route_v3.RedirectAction_HttpsRedirect{\n\t\t\t\t\t\t\t\t\tHttpsRedirect: true,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t),\n\t\t\tenvoy_v3.RouteConfiguration(\"https/hello.world\",\n\t\t\t\tenvoy_v3.VirtualHost(\"hello.world\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch:  routePrefix(\"/\"),\n\t\t\t\t\t\tAction: routeHostRewrite(\"default/externalname/443/da39a3ee5e\", \"goodbye.planet\"),\n\t\t\t\t\t},\n\t\t\t\t)),\n\t\t),\n\t\tTypeUrl: routeType,\n\t})\n\n\tc.Request(clusterType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tResources: resources(t,\n\t\t\ttlsCluster(externalNameCluster(\"default/externalname/443/da39a3ee5e\", \"default/externalname/https\", \"default_externalname_443\", \"goodbye.planet\", 443), nil, \"goodbye.planet\", \"goodbye.planet\", nil),\n\t\t),\n\t\tTypeUrl: clusterType,\n\t})\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage config\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gopkg.in/yaml.v2\"\n\t\"k8s.io/apimachinery/pkg/util/validation\"\n)\n\n// ServerType is the name of a xDS server implementation.\ntype ServerType string\n\nconst ContourServerType ServerType = \"contour\"\nconst EnvoyServerType ServerType = \"envoy\"\n\n// Validate the xDS server type.\nfunc (s ServerType) Validate() error {\n\tswitch s {\n\tcase ContourServerType, EnvoyServerType:\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid xDS server type %q\", s)\n\t}\n}\n\n// Validate the GatewayConfig.\nfunc (g *GatewayParameters) Validate() error {\n\n\tvar errorString string\n\tif g == nil {\n\t\treturn nil\n\t}\n\n\tif len(g.Name) == 0 && len(g.Namespace) == 0 && len(g.ControllerName) == 0 {\n\t\treturn nil\n\t}\n\n\tif len(g.Name) == 0 {\n\t\terrorString = \"name required\"\n\t}\n\tif len(g.Namespace) == 0 {\n\t\tif len(errorString) > 0 {\n\t\t\terrorString += \",\"\n\t\t}\n\t\terrorString = strings.TrimSpace(fmt.Sprintf(\"%s namespace required\", errorString))\n\t}\n\tif len(g.ControllerName) == 0 {\n\t\tif len(errorString) > 0 {\n\t\t\terrorString += \",\"\n\t\t}\n\t\terrorString = strings.TrimSpace(fmt.Sprintf(\"%s controllerName required\", errorString))\n\t}\n\n\tif len(errorString) > 0 {\n\t\treturn fmt.Errorf(\"invalid Gateway parameters specified: %s\", errorString)\n\t}\n\treturn nil\n}\n\n// ResourceVersion is a version of an xDS server.\ntype ResourceVersion string\n\nconst XDSv3 ResourceVersion = \"v3\"\n\n// Validate the xDS server versions.\nfunc (s ResourceVersion) Validate() error {\n\tswitch s {\n\tcase XDSv3:\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid xDS version %q\", s)\n\t}\n}\n\n// ClusterDNSFamilyType is the Ip family to use for resolving DNS\n// names in an Envoy cluster configuration.\ntype ClusterDNSFamilyType string\n\nfunc (c ClusterDNSFamilyType) Validate() error {\n\tswitch c {\n\tcase AutoClusterDNSFamily, IPv4ClusterDNSFamily, IPv6ClusterDNSFamily:\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid cluster DNS lookup family %q\", c)\n\t}\n}\n\nconst AutoClusterDNSFamily ClusterDNSFamilyType = \"auto\"\nconst IPv4ClusterDNSFamily ClusterDNSFamilyType = \"v4\"\nconst IPv6ClusterDNSFamily ClusterDNSFamilyType = \"v6\"\n\n// AccessLogType is the name of a supported access logging mechanism.\ntype AccessLogType string\n\nfunc (a AccessLogType) Validate() error {\n\tswitch a {\n\tcase EnvoyAccessLog, JSONAccessLog:\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid access log format %q\", a)\n\t}\n}\n\nconst EnvoyAccessLog AccessLogType = \"envoy\"\nconst JSONAccessLog AccessLogType = \"json\"\n\ntype AccessLogFields []string\n\nfunc (a AccessLogFields) Validate() error {\n\t// Capture Groups:\n\t// Given string \"the start time is %START_TIME(%s):3% wow!\"\n\t//\n\t//   0. Whole match \"%START_TIME(%s):3%\"\n\t//   1. Full operator: \"START_TIME(%s):3%\"\n\t//   2. Operator Name: \"START_TIME\"\n\t//   3. Arguments: \"(%s)\"\n\t//   4. Truncation length: \":3\"\n\tre := regexp.MustCompile(`%(([A-Z_]+)(\\([^)]+\\)(:[0-9]+)?)?%)?`)\n\n\tfor key, val := range a.AsFieldMap() {\n\t\tif val == \"\" {\n\t\t\treturn fmt.Errorf(\"invalid JSON log field name %s\", key)\n\t\t}\n\n\t\tif jsonFields[key] == val {\n\t\t\tcontinue\n\t\t}\n\n\t\t// FindAllStringSubmatch will always return a slice with matches where every slice is a slice\n\t\t// of submatches with length of 5 (number of capture groups + 1).\n\t\ttokens := re.FindAllStringSubmatch(val, -1)\n\t\tif len(tokens) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, f := range tokens {\n\t\t\top := f[2]\n\t\t\tif op == \"\" {\n\t\t\t\treturn fmt.Errorf(\"invalid JSON field: %s, invalid Envoy format: %s\", val, f)\n\t\t\t}\n\n\t\t\t_, okSimple := envoySimpleOperators[op]\n\t\t\t_, okComplex := envoyComplexOperators[op]\n\t\t\tif !okSimple && !okComplex {\n\t\t\t\treturn fmt.Errorf(\"invalid JSON field: %s, invalid Envoy format: %s, invalid Envoy operator: %s\", val, f, op)\n\t\t\t}\n\n\t\t\tif (op == \"REQ\" || op == \"RESP\" || op == \"TRAILER\") && f[3] == \"\" {\n\t\t\t\treturn fmt.Errorf(\"invalid JSON field: %s, invalid Envoy format: %s, arguments required for operator: %s\", val, f, op)\n\t\t\t}\n\n\t\t\t// START_TIME cannot not have truncation length.\n\t\t\tif op == \"START_TIME\" && f[4] != \"\" {\n\t\t\t\treturn fmt.Errorf(\"invalid JSON field: %s, invalid Envoy format: %s, operator %s cannot have truncation length\", val, f, op)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (a AccessLogFields) AsFieldMap() map[string]string {\n\tfieldMap := map[string]string{}\n\n\tfor _, val := range a {\n\t\tparts := strings.SplitN(val, \"=\", 2)\n\n\t\tif len(parts) == 1 {\n\t\t\toperator, foundInFieldMapping := jsonFields[val]\n\t\t\t_, isSimpleOperator := envoySimpleOperators[strings.ToUpper(val)]\n\n\t\t\tif isSimpleOperator && !foundInFieldMapping {\n\t\t\t\t// Operator name is known to be simple, upcase and wrap it in percents.\n\t\t\t\tfieldMap[val] = fmt.Sprintf(\"%%%s%%\", strings.ToUpper(val))\n\t\t\t} else if foundInFieldMapping {\n\t\t\t\t// Operator name has a known mapping, store the result of the mapping.\n\t\t\t\tfieldMap[val] = operator\n\t\t\t} else {\n\t\t\t\t// Operator name not found, save as emptystring and let validation catch it later.\n\t\t\t\tfieldMap[val] = \"\"\n\t\t\t}\n\t\t} else {\n\t\t\t// Value is a full key:value pair, store it as is.\n\t\t\tfieldMap[parts[0]] = parts[1]\n\t\t}\n\t}\n\n\treturn fieldMap\n}\n\n// HTTPVersionType is the name of a supported HTTP version.\ntype HTTPVersionType string\n\nfunc (h HTTPVersionType) Validate() error {\n\tswitch h {\n\tcase HTTPVersion1, HTTPVersion2:\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid HTTP version %q\", h)\n\t}\n}\n\nconst HTTPVersion1 HTTPVersionType = \"http/1.1\"\nconst HTTPVersion2 HTTPVersionType = \"http/2\"\n\n// NamespacedName defines the namespace/name of the Kubernetes resource referred from the configuration file.\n// Used for Contour configuration YAML file parsing, otherwise we could use K8s types.NamespacedName.\ntype NamespacedName struct {\n\tName      string `yaml:\"name\"`\n\tNamespace string `yaml:\"namespace\"`\n}\n\n// Validate that both name fields are present, or neither are.\nfunc (n NamespacedName) Validate() error {\n\tif len(strings.TrimSpace(n.Name)) == 0 && len(strings.TrimSpace(n.Namespace)) == 0 {\n\t\treturn nil\n\t}\n\n\tif len(strings.TrimSpace(n.Namespace)) == 0 {\n\t\treturn errors.New(\"namespace must be defined\")\n\t}\n\n\tif len(strings.TrimSpace(n.Name)) == 0 {\n\t\treturn errors.New(\"name must be defined\")\n\t}\n\n\treturn nil\n}\n\n// TLSParameters holds configuration file TLS configuration details.\ntype TLSParameters struct {\n\tMinimumProtocolVersion string `yaml:\"minimum-protocol-version\"`\n\n\t// FallbackCertificate defines the namespace/name of the Kubernetes secret to\n\t// use as fallback when a non-SNI request is received.\n\tFallbackCertificate NamespacedName `yaml:\"fallback-certificate,omitempty\"`\n\n\t// ClientCertificate defines the namespace/name of the Kubernetes\n\t// secret containing the client certificate and private key\n\t// to be used when establishing TLS connection to upstream\n\t// cluster.\n\tClientCertificate NamespacedName `yaml:\"envoy-client-certificate,omitempty\"`\n\n\t// CipherSuites defines the TLS ciphers to be supported by Envoy TLS\n\t// listeners when negotiating TLS 1.2. Ciphers are validated against the\n\t// set that Envoy supports by default. This parameter should only be used\n\t// by advanced users. Note that these will be ignored when TLS 1.3 is in\n\t// use.\n\tCipherSuites TLSCiphers `yaml:\"cipher-suites,omitempty\"`\n}\n\n// Validate TLS fallback certificate, client certificate, and cipher suites\nfunc (t TLSParameters) Validate() error {\n\t// Check TLS secret names.\n\tif err := t.FallbackCertificate.Validate(); err != nil {\n\t\treturn fmt.Errorf(\"invalid TLS fallback certificate: %w\", err)\n\t}\n\n\tif err := t.ClientCertificate.Validate(); err != nil {\n\t\treturn fmt.Errorf(\"invalid TLS client certificate: %w\", err)\n\t}\n\n\tif err := t.CipherSuites.Validate(); err != nil {\n\t\treturn fmt.Errorf(\"invalid TLS cipher suites: %w\", err)\n\t}\n\n\treturn nil\n}\n\n// ServerParameters holds the configuration for the Contour xDS server.\ntype ServerParameters struct {\n\t// Defines the XDSServer to use for `contour serve`.\n\t// Defaults to \"contour\"\n\tXDSServerType ServerType `yaml:\"xds-server-type,omitempty\"`\n}\n\n// GatewayParameters holds the configuration for Gateway API controllers.\ntype GatewayParameters struct {\n\t// ControllerName is used to determine whether Contour should reconcile a\n\t// GatewayClass. The string takes the form of \"projectcontour.io/<namespace>/contour\".\n\t// If unset, the gatewayclass controller will not be started.\n\tControllerName string `yaml:\"controllerName,omitempty\"`\n\t// Name is the Gateway name that Contour should reconcile.\n\t// Deprecated: Name is deprecated and will be removed in Contour v1.18. Configure \"ControllerName\" instead.\n\tName string `yaml:\"name,omitempty\"`\n\t// Namespace is the Gateway namespace that Contour should reconcile.\n\t// Deprecated: Namespace is deprecated will be removed in Contour v1.18. Configure \"ControllerName\" instead.\n\tNamespace string `yaml:\"namespace,omitempty\"`\n}\n\n// LeaderElectionParameters holds the config bits for leader election\n// inside the  configuration file.\ntype LeaderElectionParameters struct {\n\tLeaseDuration time.Duration `yaml:\"lease-duration,omitempty\"`\n\tRenewDeadline time.Duration `yaml:\"renew-deadline,omitempty\"`\n\tRetryPeriod   time.Duration `yaml:\"retry-period,omitempty\"`\n\tNamespace     string        `yaml:\"configmap-namespace,omitempty\"`\n\tName          string        `yaml:\"configmap-name,omitempty\"`\n}\n\n// TimeoutParameters holds various configurable proxy timeout values.\ntype TimeoutParameters struct {\n\t// RequestTimeout sets the client request timeout globally for Contour. Note that\n\t// this is a timeout for the entire request, not an idle timeout. Omit or set to\n\t// \"infinity\" to disable the timeout entirely.\n\t//\n\t// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-request-timeout\n\t// for more information.\n\tRequestTimeout string `yaml:\"request-timeout,omitempty\"`\n\n\t// ConnectionIdleTimeout defines how long the proxy should wait while there are\n\t// no active requests (for HTTP/1.1) or streams (for HTTP/2) before terminating\n\t// an HTTP connection. Set to \"infinity\" to disable the timeout entirely.\n\t//\n\t// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-idle-timeout\n\t// for more information.\n\tConnectionIdleTimeout string `yaml:\"connection-idle-timeout,omitempty\"`\n\n\t// StreamIdleTimeout defines how long the proxy should wait while there is no\n\t// request activity (for HTTP/1.1) or stream activity (for HTTP/2) before\n\t// terminating the HTTP request or stream. Set to \"infinity\" to disable the\n\t// timeout entirely.\n\t//\n\t// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-stream-idle-timeout\n\t// for more information.\n\tStreamIdleTimeout string `yaml:\"stream-idle-timeout,omitempty\"`\n\n\t// MaxConnectionDuration defines the maximum period of time after an HTTP connection\n\t// has been established from the client to the proxy before it is closed by the proxy,\n\t// regardless of whether there has been activity or not. Omit or set to \"infinity\" for\n\t// no max duration.\n\t//\n\t// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-max-connection-duration\n\t// for more information.\n\tMaxConnectionDuration string `yaml:\"max-connection-duration,omitempty\"`\n\n\t// DelayedCloseTimeout defines how long envoy will wait, once connection\n\t// close processing has been initiated, for the downstream peer to close\n\t// the connection before Envoy closes the socket associated with the connection.\n\t//\n\t// Setting this timeout to 'infinity' will disable it, equivalent to setting it to '0'\n\t// in Envoy. Leaving it unset will result in the Envoy default value being used.\n\t//\n\t// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-delayed-close-timeout\n\t// for more information.\n\tDelayedCloseTimeout string `yaml:\"delayed-close-timeout,omitempty\"`\n\n\t// ConnectionShutdownGracePeriod defines how long the proxy will wait between sending an\n\t// initial GOAWAY frame and a second, final GOAWAY frame when terminating an HTTP/2 connection.\n\t// During this grace period, the proxy will continue to respond to new streams. After the final\n\t// GOAWAY frame has been sent, the proxy will refuse new streams.\n\t//\n\t// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-drain-timeout\n\t// for more information.\n\tConnectionShutdownGracePeriod string `yaml:\"connection-shutdown-grace-period,omitempty\"`\n}\n\n// Validate the timeout parameters.\nfunc (t TimeoutParameters) Validate() error {\n\t// We can't use `timeout.Parse` for validation here because\n\t// that would make an exported package depend on an internal\n\t// package.\n\tv := func(str string) error {\n\t\tswitch str {\n\t\tcase \"\", \"infinity\", \"infinite\":\n\t\t\treturn nil\n\t\tdefault:\n\t\t\t_, err := time.ParseDuration(str)\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := v(t.RequestTimeout); err != nil {\n\t\treturn fmt.Errorf(\"invalid request timeout %q: %w\", t.RequestTimeout, err)\n\t}\n\n\tif err := v(t.ConnectionIdleTimeout); err != nil {\n\t\treturn fmt.Errorf(\"connection idle timeout %q: %w\", t.ConnectionIdleTimeout, err)\n\t}\n\n\tif err := v(t.StreamIdleTimeout); err != nil {\n\t\treturn fmt.Errorf(\"stream idle timeout %q: %w\", t.StreamIdleTimeout, err)\n\t}\n\n\tif err := v(t.MaxConnectionDuration); err != nil {\n\t\treturn fmt.Errorf(\"max connection duration %q: %w\", t.MaxConnectionDuration, err)\n\t}\n\n\tif err := v(t.DelayedCloseTimeout); err != nil {\n\t\treturn fmt.Errorf(\"delayed close timeout %q: %w\", t.DelayedCloseTimeout, err)\n\t}\n\n\tif err := v(t.ConnectionShutdownGracePeriod); err != nil {\n\t\treturn fmt.Errorf(\"connection shutdown grace period %q: %w\", t.ConnectionShutdownGracePeriod, err)\n\t}\n\n\treturn nil\n}\n\ntype HeadersPolicy struct {\n\tSet    map[string]string `yaml:\"set,omitempty\"`\n\tRemove []string          `yaml:\"remove,omitempty\"`\n}\n\nfunc (h HeadersPolicy) Validate() error {\n\tfor key := range h.Set {\n\t\tif msgs := validation.IsHTTPHeaderName(key); len(msgs) != 0 {\n\t\t\treturn fmt.Errorf(\"invalid header name %q: %v\", key, msgs)\n\t\t}\n\t}\n\tfor _, val := range h.Remove {\n\t\tif msgs := validation.IsHTTPHeaderName(val); len(msgs) != 0 {\n\t\t\treturn fmt.Errorf(\"invalid header name %q: %v\", val, msgs)\n\t\t}\n\t}\n\treturn nil\n}\n\n// PolicyParameters holds default policy used if not explicitly set by the user\ntype PolicyParameters struct {\n\t// RequestHeadersPolicy defines the request headers set/removed on all routes\n\tRequestHeadersPolicy HeadersPolicy `yaml:\"request-headers,omitempty\"`\n\n\t// ResponseHeadersPolicy defines the response headers set/removed on all routes\n\tResponseHeadersPolicy HeadersPolicy `yaml:\"response-headers,omitempty\"`\n}\n\n// Validate the header parameters.\nfunc (h PolicyParameters) Validate() error {\n\tif err := h.RequestHeadersPolicy.Validate(); err != nil {\n\t\treturn err\n\t}\n\tif err := h.ResponseHeadersPolicy.Validate(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// ClusterParameters holds various configurable cluster values.\ntype ClusterParameters struct {\n\t// DNSLookupFamily defines how external names are looked up\n\t// When configured as V4, the DNS resolver will only perform a lookup\n\t// for addresses in the IPv4 family. If V6 is configured, the DNS resolver\n\t// will only perform a lookup for addresses in the IPv6 family.\n\t// If AUTO is configured, the DNS resolver will first perform a lookup\n\t// for addresses in the IPv6 family and fallback to a lookup for addresses\n\t// in the IPv4 family.\n\t// Note: This only applies to externalName clusters.\n\t//\n\t// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-enum-config-cluster-v3-cluster-dnslookupfamily\n\t// for more information.\n\tDNSLookupFamily ClusterDNSFamilyType `yaml:\"dns-lookup-family\"`\n}\n\n// NetworkParameters hold various configurable network values.\ntype NetworkParameters struct {\n\t// XffNumTrustedHops defines the number of additional ingress proxy hops from the\n\t// right side of the x-forwarded-for HTTP header to trust when determining the origin\n\t// client\u2019s IP address.\n\t//\n\t// See https://www.envoyproxy.io/docs/envoy/v1.17.0/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto?highlight=xff_num_trusted_hops\n\t// for more information.\n\tXffNumTrustedHops uint32 `yaml:\"num-trusted-hops\"`\n}\n\n// ListenerParameters hold various configurable listener values.\ntype ListenerParameters struct {\n\t// ConnectionBalancer. If the value is exact, the listener will use the exact connection balancer\n\t// See https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/listener.proto#envoy-api-msg-listener-connectionbalanceconfig\n\t// for more information.\n\tConnectionBalancer string `yaml:\"connection-balancer\"`\n}\n\n// Parameters contains the configuration file parameters for the\n// Contour ingress controller.\ntype Parameters struct {\n\t// Enable debug logging\n\tDebug bool\n\n\t// Kubernetes client parameters.\n\tInCluster  bool   `yaml:\"incluster,omitempty\"`\n\tKubeconfig string `yaml:\"kubeconfig,omitempty\"`\n\n\t// Server contains parameters for the xDS server.\n\tServer ServerParameters `yaml:\"server,omitempty\"`\n\n\t// GatewayConfig contains parameters for the gateway-api Gateway that Contour\n\t// is configured to serve traffic.\n\tGatewayConfig *GatewayParameters `yaml:\"gateway,omitempty\"`\n\n\t// Address to be placed in status.loadbalancer field of Ingress objects.\n\t// May be either a literal IP address or a host name.\n\t// The value will be placed directly into the relevant field inside the status.loadBalancer struct.\n\tIngressStatusAddress string `yaml:\"ingress-status-address,omitempty\"`\n\n\t// AccessLogFormat sets the global access log format.\n\t// Valid options are 'envoy' or 'json'\n\tAccessLogFormat AccessLogType `yaml:\"accesslog-format,omitempty\"`\n\n\t// AccessLogFields sets the fields that JSON logging will\n\t// output when AccessLogFormat is json.\n\tAccessLogFields AccessLogFields `yaml:\"json-fields,omitempty\"`\n\n\t// TLS contains TLS policy parameters.\n\tTLS TLSParameters `yaml:\"tls,omitempty\"`\n\n\t// DisablePermitInsecure disables the use of the\n\t// permitInsecure field in HTTPProxy.\n\tDisablePermitInsecure bool `yaml:\"disablePermitInsecure,omitempty\"`\n\n\t// DisableAllowChunkedLength disables the RFC-compliant Envoy behavior to\n\t// strip the \"Content-Length\" header if \"Transfer-Encoding: chunked\" is\n\t// also set. This is an emergency off-switch to revert back to Envoy's\n\t// default behavior in case of failures. Please file an issue if failures\n\t// are encountered.\n\t// See: https://github.com/projectcontour/contour/issues/3221\n\tDisableAllowChunkedLength bool `yaml:\"disableAllowChunkedLength,omitempty\"`\n\n\t// LeaderElection contains leader election parameters.\n\tLeaderElection LeaderElectionParameters `yaml:\"leaderelection,omitempty\"`\n\n\t// Timeouts holds various configurable timeouts that can\n\t// be set in the config file.\n\tTimeouts TimeoutParameters `yaml:\"timeouts,omitempty\"`\n\n\t// Policy specifies default policy applied if not overridden by the user\n\tPolicy PolicyParameters `yaml:\"policy,omitempty\"`\n\n\t// Namespace of the envoy service to inspect for Ingress status details.\n\tEnvoyServiceNamespace string `yaml:\"envoy-service-namespace,omitempty\"`\n\n\t// Name of the envoy service to inspect for Ingress status details.\n\tEnvoyServiceName string `yaml:\"envoy-service-name,omitempty\"`\n\n\t// DefaultHTTPVersions defines the default set of HTTPS\n\t// versions the proxy should accept. HTTP versions are\n\t// strings of the form \"HTTP/xx\". Supported versions are\n\t// \"HTTP/1.1\" and \"HTTP/2\".\n\t//\n\t// If this field not specified, all supported versions are accepted.\n\tDefaultHTTPVersions []HTTPVersionType `yaml:\"default-http-versions\"`\n\n\t// Cluster holds various configurable Envoy cluster values that can\n\t// be set in the config file.\n\tCluster ClusterParameters `yaml:\"cluster,omitempty\"`\n\n\t// Network holds various configurable Envoy network values.\n\tNetwork NetworkParameters `yaml:\"network,omitempty\"`\n\n\t// Listener holds various configurable Envoy Listener values.\n\tListener ListenerParameters `yaml:\"listener,omitempty\"`\n\t// RateLimitService optionally holds properties of the Rate Limit Service\n\t// to be used for global rate limiting.\n\tRateLimitService RateLimitService `yaml:\"rateLimitService,omitempty\"`\n}\n\n// RateLimitService defines properties of a global Rate Limit Service.\ntype RateLimitService struct {\n\t// ExtensionService identifies the extension service defining the RLS,\n\t// formatted as <namespace>/<name>.\n\tExtensionService string `yaml:\"extensionService,omitempty\"`\n\n\t// Domain is passed to the Rate Limit Service.\n\tDomain string `yaml:\"domain,omitempty\"`\n\n\t// FailOpen defines whether to allow requests to proceed when the\n\t// Rate Limit Service fails to respond with a valid rate limit\n\t// decision within the timeout defined on the extension service.\n\tFailOpen bool `yaml:\"failOpen,omitempty\"`\n\n\t// EnableXRateLimitHeaders defines whether to include the X-RateLimit\n\t// headers X-RateLimit-Limit, X-RateLimit-Remaining, and X-RateLimit-Reset\n\t// (as defined by the IETF Internet-Draft linked below), on responses\n\t// to clients when the Rate Limit Service is consulted for a request.\n\t//\n\t// ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html\n\tEnableXRateLimitHeaders bool `yaml:\"enableXRateLimitHeaders,omitempty\"`\n}\n\n// Validate verifies that the parameter values do not have any syntax errors.\nfunc (p *Parameters) Validate() error {\n\tif err := p.Cluster.DNSLookupFamily.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := p.Server.XDSServerType.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := p.GatewayConfig.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := p.AccessLogFormat.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := p.AccessLogFields.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := p.TLS.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := p.Timeouts.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := p.Policy.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, v := range p.DefaultHTTPVersions {\n\t\tif err := v.Validate(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Defaults returns the default set of parameters.\nfunc Defaults() Parameters {\n\tcontourNamespace := GetenvOr(\"CONTOUR_NAMESPACE\", \"projectcontour\")\n\n\treturn Parameters{\n\t\tDebug:      false,\n\t\tInCluster:  false,\n\t\tKubeconfig: filepath.Join(os.Getenv(\"HOME\"), \".kube\", \"config\"),\n\t\tServer: ServerParameters{\n\t\t\tXDSServerType: ContourServerType,\n\t\t},\n\t\tIngressStatusAddress:      \"\",\n\t\tAccessLogFormat:           DEFAULT_ACCESS_LOG_TYPE,\n\t\tAccessLogFields:           DefaultFields,\n\t\tTLS:                       TLSParameters{},\n\t\tDisablePermitInsecure:     false,\n\t\tDisableAllowChunkedLength: false,\n\t\tLeaderElection: LeaderElectionParameters{\n\t\t\tLeaseDuration: time.Second * 15,\n\t\t\tRenewDeadline: time.Second * 10,\n\t\t\tRetryPeriod:   time.Second * 2,\n\t\t\tName:          \"leader-elect\",\n\t\t\tNamespace:     contourNamespace,\n\t\t},\n\t\tTimeouts: TimeoutParameters{\n\t\t\t// This is chosen as a rough default to stop idle connections wasting resources,\n\t\t\t// without stopping slow connections from being terminated too quickly.\n\t\t\tConnectionIdleTimeout: \"60s\",\n\t\t},\n\t\tPolicy: PolicyParameters{\n\t\t\tRequestHeadersPolicy:  HeadersPolicy{},\n\t\t\tResponseHeadersPolicy: HeadersPolicy{},\n\t\t},\n\t\tEnvoyServiceName:      \"envoy\",\n\t\tEnvoyServiceNamespace: contourNamespace,\n\t\tDefaultHTTPVersions:   []HTTPVersionType{},\n\t\tCluster: ClusterParameters{\n\t\t\tDNSLookupFamily: AutoClusterDNSFamily,\n\t\t},\n\t\tNetwork: NetworkParameters{\n\t\t\tXffNumTrustedHops: 0,\n\t\t},\n\t\tListener: ListenerParameters{\n\t\t\tConnectionBalancer: \"\",\n\t\t},\n\t}\n}\n\n// Parse reads parameters from a YAML input stream. Any parameters\n// not specified by the input are according to Defaults().\nfunc Parse(in io.Reader) (*Parameters, error) {\n\tconf := Defaults()\n\tdecoder := yaml.NewDecoder(in)\n\n\tdecoder.SetStrict(true)\n\n\tif err := decoder.Decode(&conf); err != nil {\n\t\t// The YAML decoder will return EOF if there are\n\t\t// no YAML nodes in the results. In this case, we just\n\t\t// want to succeed and return the defaults.\n\t\tif err != io.EOF {\n\t\t\treturn nil, fmt.Errorf(\"failed to parse configuration: %w\", err)\n\t\t}\n\t}\n\n\t// Force the version string to match the lowercase version\n\t// constants (assuming that it will match).\n\tfor i, v := range conf.DefaultHTTPVersions {\n\t\tconf.DefaultHTTPVersions[i] = HTTPVersionType(strings.ToLower(string(v)))\n\t}\n\n\treturn &conf, nil\n}\n\n// GetenvOr reads an environment or return a default value\nfunc GetenvOr(key string, defaultVal string) string {\n\tif value, exists := os.LookupEnv(key); exists {\n\t\treturn value\n\t}\n\n\treturn defaultVal\n}\n", "# Contour Configuration Reference\n\n- [Serve Flags](#serve-flags)\n- [Configuration File](#configuration-file)\n- [Environment Variables](#environment-variables)\n- [Bootstrap Config File](#bootstrap-config-file)\n\n## Overview\n\nThere are various ways to configure Contour, flags, the configuration file, as well as environment variables.\nContour has a precedence of configuration for contour serve, meaning anything configured in the config file is overridden by environment vars which are overridden by cli flags.\n\n## Serve Flags\n\nThe `contour serve` command is the main command which is used to watch for Kubernetes resource and process them into Envoy configuration which is then streamed to any Envoy via its xDS gRPC connection.\nThere are a number of flags that can be passed to this command which further configures how Contour operates. \nMany of these flags are mirrored in the [Contour Configuration File](#configuration-file).\n\n| Flag Name         | Description        |\n|-------------------|--------------------|\n| `--config-path`       | Path to base configuration |\n| `--incluster`         | Use in cluster configuration |\n| `--kubeconfig=</path/to/file>` |    Path to kubeconfig (if not in running inside a cluster) |\n| `--xds-address=<ipaddr>` | xDS gRPC API address |\n| `--xds-port=<port>`       | xDS gRPC API port |\n| `--stats-address=<ipaddr>` | Envoy /stats interface address |\n| `--stats-port=<port>`  |  Envoy /stats interface port |\n| `--debug-http-address=<address>` | Address the debug http endpoint will bind to. |\n| `--debug-http-port=<port>`  | Port the debug http endpoint will bind to |\n| `--http-address=<ipaddr>`  | Address the metrics HTTP endpoint will bind to |\n| `--http-port=<port>`  |    Port the metrics HTTP endpoint will bind to. |\n| `--health-address=<ipaddr>` |   Address the health HTTP endpoint will bind to |\n| `--health-port=<port>` | Port the health HTTP endpoint will bind to |\n| `--contour-cafile=</path/to/file\\|CONTOUR_CERT_FILE>` | CA bundle file name for serving gRPC with TLS |\n| `--contour-cert-file=</path/to/file\\|CONTOUR_CERT_FILE>`  | Contour certificate file name for serving gRPC over TLS |\n| `--contour-key-file=</path/to/file\\|CONTOUR_KEY_FILE>` | Contour key file name for serving gRPC over TLS |\n| `--insecure`  |               Allow serving without TLS secured gRPC |\n| `--root-namespaces=<ns,ns>` | Restrict contour to searching these namespaces for root ingress routes |\n| `--ingress-class-name=<name>` | Contour IngressClass name |\n| `--ingress-status-address=<address>`  | Address to set in Ingress object status |\n| `--envoy-http-access-log=</path/to/file>`  | Envoy HTTP access log |\n| `--envoy-https-access-log=</path/to/file>`  | Envoy HTTPS access log |\n| `--envoy-service-http-address=<ipaddr>`  | Kubernetes Service address for HTTP requests |\n| `--envoy-service-https-address=<ipaddr>` | Kubernetes Service address for HTTPS requests |\n| `--envoy-service-http-port=<port>` | Kubernetes Service port for HTTP requests |\n| `--envoy-service-https-port=<port>` |  Kubernetes Service port for HTTPS requests |\n| `--envoy-service-name=<name>` | Name of the Envoy service to inspect for Ingress status details. |\n| `--envoy-service-namespace=<namespace>` | Envoy Service Namespace  |\n| `--use-proxy-protocol`  |     Use PROXY protocol for all listeners |\n| `--accesslog-format=<envoy\\|json>` | Format for Envoy access logs |\n| `--disable-leader-election` | Disable leader election mechanism |\n| `-d, --debug`   |                  Enable debug logging |\n| `--kubernetes-debug=<log level>`  | Enable Kubernetes client debug logging |\n\n## Configuration File\n\nA configuration file can be passed to the `--config-path` argument of the `contour serve` command to specify additional configuration to Contour.\nIn most deployments, this file is passed to Contour via a ConfigMap which is mounted as a volume to the Contour pod.\n\nThe Contour configuration file is optional.\nIn its absence, Contour will operate with reasonable defaults.\nWhere Contour settings can also be specified with command-line flags, the command-line value takes precedence over the configuration file.\n\n| Field Name | Type | Default | Description |\n|------------|------|---------|-------------|\n| accesslog-format | string | `envoy` | This key sets the global [access log format][2] for Envoy. Valid options are `envoy` or `json`. |\n| debug | boolean | `false` | Enables debug logging. |\n| default-http-versions | string array | <code style=\"white-space:nowrap\">HTTP/1.1</code> <br> <code style=\"white-space:nowrap\">HTTP/2</code> | This array specifies the HTTP versions that Contour should program Envoy to serve. HTTP versions are specified as strings of the form \"HTTP/x\", where \"x\" represents the version number. |\n| disableAllowChunkedLength | boolean | `false` | If this field is true, Contour will disable the RFC-compliant Envoy behavior to strip the `Content-Length` header if `Transfer-Encoding: chunked` is also set. This is an emergency off-switch to revert back to Envoy's default behavior in case of failures. |\n| disablePermitInsecure | boolean | `false` | If this field is true, Contour will ignore `PermitInsecure` field in HTTPProxy documents. |\n| envoy-service-name | string | `envoy` | This sets the service name that will be inspected for address details to be applied to Ingress objects. |\n| envoy-service-namespace | string | `projectcontour` | This sets the namespace of the service that will be inspected for address details to be applied to Ingress objects. If the `CONTOUR_NAMESPACE` environment variable is present, Contour will populate this field with its value. |\n| ingress-status-address | string | None | If present, this specifies the address that will be copied into the Ingress status for each Ingress that Contour manages. It is exclusive with `envoy-service-name` and `envoy-service-namespace`.|\n| incluster | boolean | `false` | This field specifies that Contour is running in a Kubernetes cluster and should use the in-cluster client access configuration.  |\n| json-fields | string array | [fields][5]| This is the list the field names to include in the JSON [access log format][2]. |\n| kubeconfig | string | `$HOME/.kube/config` | Path to a Kubernetes [kubeconfig file][3] for when Contour is executed outside a cluster. |\n| leaderelection | leaderelection | | The [leader election configuration](#leader-election-configuration). |\n| policy | PolicyConfig | | The default [policy configuration](#policy-configuration). |\n| tls | TLS | | The default [TLS configuration](#tls-configuration). |\n| timeouts | TimeoutConfig | | The [timeout configuration](#timeout-configuration). |\n| cluster | ClusterConfig | | The [cluster configuration](#cluster-configuration). |\n| network | NetworkConfig | | The [network configuration](#network-configuration). |\n| listener | ListenerConfig | | The [listener configuration](#listener-configuration). |\n| server | ServerConfig |  | The [server configuration](#server-configuration) for `contour serve` command. |\n| gateway | GatewayConfig |  | The [gateway-api Gateway configuration](#gateway-configuration). |\n| rateLimitService | RateLimitServiceConfig | | The [rate limit service configuration](#rate-limit-service-configuration). |\n\n### TLS Configuration\n\nThe TLS configuration block can be used to configure default values for how\nContour should provision TLS hosts.\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| minimum-protocol-version| string | `1.2` | This field specifies the minimum TLS protocol version that is allowed. Valid options are `1.2` (default) and `1.3`. Any other value defaults to TLS 1.2. |\n| fallback-certificate | | | [Fallback certificate configuration](#fallback-certificate). |\n| envoy-client-certificate | | | [Client certificate configuration for Envoy](#envoy-client-certificate). |\n| cipher-suites | []string | See [config package documentation](https://pkg.go.dev/github.com/projectcontour/contour/pkg/config#pkg-variables) | This field specifies the TLS ciphers to be supported by TLS listeners when negotiating TLS 1.2. This parameter should only be used by advanced users. Note that this is ignored when TLS 1.3 is in use. The set of ciphers that are allowed is a superset of those supported by default in stock, non-FIPS Envoy builds and FIPS builds as specified [here](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto#envoy-v3-api-field-extensions-transport-sockets-tls-v3-tlsparameters-cipher-suites). Custom ciphers not accepted by Envoy in a standard build are not supported. |\n\n### Fallback Certificate\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| name       | string | `\"\"` | This field specifies the name of the Kubernetes secret to use as the fallback certificate.      |\n| namespace  | string | `\"\"` | This field specifies the namespace of the Kubernetes secret to use as the fallback certificate. |\n\n\n### Envoy Client Certificate\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| name       | string | `\"\"` | This field specifies the name of the Kubernetes secret to use as the client certificate and private key when establishing TLS connections to the backend service. |\n| namespace  | string | `\"\"` | This field specifies the namespace of the Kubernetes secret to use as the client certificate and private key when establishing TLS connections to the backend service. |\n\n### Leader Election Configuration\n\nThe leader election configuration block configures how a deployment with more than one Contour pod elects a leader.\nThe Contour leader is responsible for updating the status field on Ingress and HTTPProxy documents.\nIn the vast majority of deployments, only the `configmap-name` and `configmap-namespace` fields should require any configuration.\n\n| Field Name | Type | Default | Description |\n|------------|------|---------|-------------|\n| configmap-name | string | `leader-elect` | The name of the ConfigMap that Contour leader election will lease. |\n| configmap-namespace | string | `projectcontour` | The namespace of the ConfigMap that Contour leader election will lease. If the `CONTOUR_NAMESPACE` environment variable is present, Contour will populate this field with its value. |\n| lease-duration | [duration][4] | `15s` | The duration of the leadership lease. |\n| renew-deadline | [duration][4] | `10s` | The length of time that the leader will retry refreshing leadership before giving up. |\n| retry-period | [duration][4] | `2s` | The interval at which Contour will attempt to the acquire leadership lease. |\n\n### Timeout Configuration\n\nThe timeout configuration block can be used to configure various timeouts for the proxies. All fields are optional; Contour/Envoy defaults apply if a field is not specified.\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| request-timeout | string | none* | This field specifies the default request timeout. Note that this is a timeout for the entire request, not an idle timeout. Must be a [valid Go duration string][4], or omitted or set to `infinity` to disable the timeout entirely. See [the Envoy documentation][12] for more information.<br /><br />_Note: A value of `0s` previously disabled this timeout entirely. This is no longer the case. Use `infinity` or omit this field to disable the timeout._  |\n| connection-idle-timeout| string | `60s` | This field defines how long the proxy should wait while there are no active requests (for HTTP/1.1) or streams (for HTTP/2) before terminating an HTTP connection. Must be a [valid Go duration string][4], or `infinity` to disable the timeout entirely. See [the Envoy documentation][8] for more information. |\n| stream-idle-timeout| string | `5m`* |This field defines how long the proxy should wait while there is no request activity (for HTTP/1.1) or stream activity (for HTTP/2) before terminating the HTTP request or stream. Must be a [valid Go duration string][4], or `infinity` to disable the timeout entirely. See [the Envoy documentation][9] for more information. |\n| max-connection-duration | string | none* | This field defines the maximum period of time after an HTTP connection has been established from the client to the proxy before it is closed by the proxy, regardless of whether there has been activity or not. Must be a [valid Go duration string][4], or omitted or set to `infinity` for no max duration. See [the Envoy documentation][10] for more information. |\n| delayed-close-timeout | string | `1s`* | *Note: this is an advanced setting that should not normally need to be tuned.* <br /><br /> This field defines how long envoy will wait, once connection close processing has been initiated, for the downstream peer to close the connection before Envoy closes the socket associated with the connection. Setting this timeout to 'infinity' will disable it.  See [the Envoy documentation][13] for more information. |\n| connection-shutdown-grace-period | string | `5s`* | This field defines how long the proxy will wait between sending an initial GOAWAY frame and a second, final GOAWAY frame when terminating an HTTP/2 connection. During this grace period, the proxy will continue to respond to new streams. After the final GOAWAY frame has been sent, the proxy will refuse new streams. Must be a [valid Go duration string][4]. See [the Envoy documentation][11] for more information. |\n\n_This is Envoy's default setting value and is not explicitly configured by Contour._\n\n### Cluster Configuration\n\nThe cluster configuration block can be used to configure various parameters for Envoy clusters.\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| dns-lookup-family | string | auto | This field specifies the dns-lookup-family to use for upstream requests to externalName type Kubernetes services from an HTTPProxy route. Values are: `auto`, `v4, `v6` |\n\n### Network Configuration\n\nThe network configuration block can be used to configure various parameters network connections.\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| num-trusted-hops | int | 0 | Configures the number of additional ingress proxy hops from the right side of the x-forwarded-for HTTP header to trust. |\n\n### Listener Configuration\n\nThe listener configuration block can be used to configure various parameters for Envoy listener.\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| connection-balancer | string | `\"\"` | This field specifies the listener connection balancer. If the value is `exact`, the listener will use the exact connection balancer to balance connections between threads in a single Envoy process. See [the Envoy documentation][14] for more information. |\n\n### Server Configuration\n\nThe server configuration block can be used to configure various settings for the `contour serve` command.\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| xds-server-type | string | contour | This field specifies the xDS Server to use. Options are `contour` or `envoy`.  |\n\n### Gateway Configuration\n\nThe gateway configuration block is used to configure which gateway-api Gateway Contour should configure:\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| controllerName | string |  | Gateway Class controller name (i.e. projectcontour.io/projectcontour/contour).  |\n| name (Deprecated) | string | contour | DEPRECATED: This field specifies the name of a Gateway.  |\n| namespace (Deprecated) | string | projectcontour | DEPRECATED: This field specifies the namespace of a Gateway.  |\n\n_NOTE: The fields `name` and `namespace` have been deprecated and will be removed in Contour v1.18.\nPlease use the `controllerName` field going forward to configure which Gateway Contour should process._\n\n### Policy Configuration\n\nThe Policy configuration block can be used to configure default policy values\nthat are set if not overridden by the user.\n\nThe `request-headers` field is used to rewrite headers on a HTTP request, and\nthe `response-headers` field is used to rewrite headers on a HTTP response.\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| request-headers | HeaderPolicy | none | The default request headers set or removed on all service routes if not overridden in the object |\n| response-headers | HeaderPolicy | none | The default response headers set or removed on all service routes if not overridden in the object |\n\n#### HeaderPolicy\n\nThe `set` field sets an HTTP header value, creating it if it doesn't already exist but not overwriting it if it does.\nThe `remove` field removes an HTTP header.\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| set | map[string]string | none | Map of headers to set on all service routes if not overridden in the object |\n| remove | []string | none | List of headers to remove on all service routes if not overridden in the object |\n\nNote: the values of entries in the `set` and `remove` fields can be overridden in HTTPProxy objects but it it not possible to remove these entries.\n\n### Rate Limit Service Configuration\n\nThe rate limit service configuration block is used to configure an optional global rate limit service:\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| extensionService | string | <none> | This field identifies the extension service defining the rate limit service, formatted as <namespace>/<name>.  |\n| domain | string | contour | This field defines the rate limit domain value to pass to the rate limit service. Acts as a container for a set of rate limit definitions within the RLS.  |\n| failOpen | bool | false | This field defines whether to allow requests to proceed when the rate limit service fails to respond with a valid rate limit decision within the timeout defined on the extension service.  |\n| enableXRateLimitHeaders | bool | false | This field defines whether to include the X-RateLimit headers X-RateLimit-Limit, X-RateLimit-Remaining, and X-RateLimit-Reset (as defined by the IETF Internet-Draft https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html), on responses to clients when the Rate Limit Service is consulted for a request. |\n\n### Configuration Example\n\nThe following is an example ConfigMap with configuration file included:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: contour\n  namespace: projectcontour\ndata:\n  contour.yaml: |\n    #\n    # server:\n    #   determine which XDS Server implementation to utilize in Contour.\n    #   xds-server-type: contour\n    #\n    # specify the gateway-api Gateway Contour should configure\n    # gateway:\n    #   controllerName: projectcontour.io/projectcontour/contour\n    #   name: contour\n    #   namespace: projectcontour\n    #\n    # should contour expect to be running inside a k8s cluster\n    # incluster: true\n    #\n    # path to kubeconfig (if not running inside a k8s cluster)\n    # kubeconfig: /path/to/.kube/config\n    #\n    # Disable RFC-compliant behavior to strip \"Content-Length\" header if\n    # \"Tranfer-Encoding: chunked\" is also set.\n    # disableAllowChunkedLength: false\n    # Disable HTTPProxy permitInsecure field\n    disablePermitInsecure: false\n    tls:\n    # minimum TLS version that Contour will negotiate\n    # minimum-protocol-version: \"1.2\"\n    # TLS ciphers to be supported by Envoy TLS listeners when negotiating\n    # TLS 1.2.\n    # cipher-suites:\n    # - '[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]'\n    # - '[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]'\n    # - 'ECDHE-ECDSA-AES256-GCM-SHA384'\n    # - 'ECDHE-RSA-AES256-GCM-SHA384'\n    # Defines the Kubernetes name/namespace matching a secret to use\n    # as the fallback certificate when requests which don't match the\n    # SNI defined for a vhost.\n      fallback-certificate:\n    #   name: fallback-secret-name\n    #   namespace: projectcontour\n      envoy-client-certificate:\n    #   name: envoy-client-cert-secret-name\n    #   namespace: projectcontour\n    # The following config shows the defaults for the leader election.\n    # leaderelection:\n    #   configmap-name: leader-elect\n    #   configmap-namespace: projectcontour\n    ### Logging options\n    # Default setting\n    accesslog-format: envoy\n    # To enable JSON logging in Envoy\n    # accesslog-format: json\n    # The default fields that will be logged are specified below.\n    # To customise this list, just add or remove entries.\n    # The canonical list is available at\n    # https://godoc.org/github.com/projectcontour/contour/internal/envoy#JSONFields\n    # json-fields:\n    #   - \"@timestamp\"\n    #   - \"authority\"\n    #   - \"bytes_received\"\n    #   - \"bytes_sent\"\n    #   - \"downstream_local_address\"\n    #   - \"downstream_remote_address\"\n    #   - \"duration\"\n    #   - \"method\"\n    #   - \"path\"\n    #   - \"protocol\"\n    #   - \"request_id\"\n    #   - \"requested_server_name\"\n    #   - \"response_code\"\n    #   - \"response_flags\"\n    #   - \"uber_trace_id\"\n    #   - \"upstream_cluster\"\n    #   - \"upstream_host\"\n    #   - \"upstream_local_address\"\n    #   - \"upstream_service_time\"\n    #   - \"user_agent\"\n    #   - \"x_forwarded_for\"\n    #\n    # default-http-versions:\n    # - \"HTTP/2\"\n    # - \"HTTP/1.1\"\n    #\n    # The following shows the default proxy timeout settings.\n    # timeouts:\n    #   request-timeout: infinity\n    #   connection-idle-timeout: 60s\n    #   stream-idle-timeout: 5m\n    #   max-connection-duration: infinity\n    #   connection-shutdown-grace-period: 5s\n    #\n    # Envoy cluster settings.\n    # cluster:\n    #   configure the cluster dns lookup family\n    #   valid options are: auto (default), v4, v6\n    #   dns-lookup-family: auto   \n    #\n    # network:\n    #   Configure the number of additional ingress proxy hops from the\n    #   right side of the x-forwarded-for HTTP header to trust.\n    #   num-trusted-hops: 0\n    #\n    # Configure an optional global rate limit service.\n    # rateLimitService:\n    #   Identifies the extension service defining the rate limit service,\n    #   formatted as <namespace>/<name>.\n    #   extensionService: projectcontour/ratelimit\n    #   Defines the rate limit domain to pass to the rate limit service.\n    #   Acts as a container for a set of rate limit definitions within\n    #   the RLS.\n    #   domain: contour\n    #   Defines whether to allow requests to proceed when the rate limit\n    #   service fails to respond with a valid rate limit decision within\n    #   the timeout defined on the extension service.\n    #   failOpen: false\n    # Defines whether to include the X-RateLimit headers X-RateLimit-Limit,\n    # X-RateLimit-Remaining, and X-RateLimit-Reset (as defined by the IETF\n    # Internet-Draft linked below), on responses to clients when the Rate\n    # Limit Service is consulted for a request.\n    # ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html\n    #   enableXRateLimitHeaders: false\n    #\n    # Global Policy settings.\n    # policy:\n    #   # Default headers to set on all requests (unless set/removed on the HTTPProxy object itself)\n    #   request-headers:\n    #     set:\n    #       # example: the hostname of the Envoy instance that proxied the request\n    #       X-Envoy-Hostname: %HOSTNAME%\n    #       # example: add a l5d-dst-override header to instruct Linkerd what service the request is destined for\n    #       l5d-dst-override: %CONTOUR_SERVICE_NAME%.%CONTOUR_NAMESPACE%.svc.cluster.local:%CONTOUR_SERVICE_PORT%\n    #   # default headers to set on all responses (unless set/removed on the HTTPProxy object itself)\n    #   response-headers:\n    #     set:\n    #       # example: Envoy flags that provide additional details about the response or connection\n    #       X-Envoy-Response-Flags: %RESPONSE_FLAGS%\n    #\n```\n\n_Note:_ The default example `contour` includes this [file][1] for easy deployment of Contour.\n\n## Environment Variables\n\n### CONTOUR_NAMESPACE\n\nIf present, the value of the `CONTOUR_NAMESPACE` environment variable is used as:\n\n1. The value for the `contour bootstrap --namespace` flag unless otherwise specified.\n1. The value for the `contour certgen --namespace` flag unless otherwise specified.\n1. The value for the `contour serve --envoy-service-namespace` flag unless otherwise specified.\n1. The value for the `leaderelection.configmap-namespace` config file setting for `contour serve` unless otherwise specified.\n\nThe `CONTOUR_NAMESPACE` environment variable is set via the [Downward API][6] in the Contour [example manifests][7].\n\n## Bootstrap Config File\n\nThe bootstrap configuration file is generated by an initContainer in the Envoy daemonset which runs the `contour bootstrap` command to generate the file.\nThis configuration file configures the Envoy container to connect to Contour and receive configuration via xDS.\n\nThe next section outlines all the available flags that can be passed to the `contour bootstrap` command which are used to customize\nthe configuration file to match the environment in which Envoy is deployed. \n\n### Flags\n\nThere are flags that can be passed to `contour bootstrap` that help configure how Envoy\nconnects to Contour:\n\n| Flag | Default  | Description |\n|------------|----------|-------------|\n| <nobr>--resources-dir</nobr> | \"\" | Directory where resource files will be written.  |\n| <nobr>--admin-address</nobr> | 127.0.0.1 | Address the Envoy admin webpage will listen on.  |\n| <nobr>--admin-port</nobr> | 9001 | Port the Envoy admin webpage will listen on.  |\n| <nobr>--xds-address</nobr> | 127.0.0.1 | Address to connect to Contour xDS server on.  |\n| <nobr>--xds-port</nobr> | 8001 | Port to connect to Contour xDS server on. |\n| <nobr>--envoy-cafile</nobr> | \"\" | CA filename for Envoy secure xDS gRPC communication.  |\n| <nobr>--envoy-cert-file</nobr> | \"\" | Client certificate filename for Envoy secure xDS gRPC communication.  |\n| <nobr>--envoy-key-file</nobr> | \"\" | Client key filename for Envoy secure xDS gRPC communication.  |\n| <nobr>--namespace</nobr> | projectcontour | Namespace the Envoy container will run, also configured via ENV variable \"CONTOUR_NAMESPACE\". Namespace is used as part of the metric names on static resources defined in the bootstrap configuration file.    |\n| <nobr>--xds-resource-version</nobr> | v3 | Currently, the only valid xDS API resource version is `v3`.  |\n| <nobr>--dns-lookup-family</nobr> | auto | Defines what DNS Resolution Policy to use for Envoy -> Contour cluster name lookup. Either v4, v6 or auto.  |\n\n\n[1]: {{< param github_url>}}/tree/{{< param version >}}/examples/contour/01-contour-config.yaml\n[2]: /guides/structured-logs\n[3]: https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/\n[4]: https://golang.org/pkg/time/#ParseDuration\n[5]: https://godoc.org/github.com/projectcontour/contour/internal/envoy#DefaultFields\n[6]: https://kubernetes.io/docs/tasks/inject-data-application/environment-variable-expose-pod-information/\n[7]: {{< param github_url>}}/tree/{{< param version >}}/examples/contour\n[8]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-idle-timeout\n[9]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-stream-idle-timeout\n[10]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-max-connection-duration\n[11]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-drain-timeout\n[12]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-request-timeout\n[13]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-delayed-close-timeout\n[14]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/listener/v3/listener.proto#config-listener-v3-listener-connectionbalanceconfig\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// +build e2e\n\npackage httpproxy\n\nimport (\n\t\"context\"\n\n\t. \"github.com/onsi/ginkgo\"\n\tcontourv1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"\n\t\"github.com/projectcontour/contour/test/e2e\"\n\t\"github.com/stretchr/testify/require\"\n\tcorev1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n\nfunc testExternalNameServiceInsecure(namespace string) {\n\tSpecify(\"external name services work over http\", func() {\n\t\tt := f.T()\n\n\t\tf.Fixtures.Echo.Deploy(namespace, \"ingress-conformance-echo\")\n\n\t\texternalNameService := &corev1.Service{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tNamespace: namespace,\n\t\t\t\tName:      \"external-name-service\",\n\t\t\t},\n\t\t\tSpec: corev1.ServiceSpec{\n\t\t\t\tType:         corev1.ServiceTypeExternalName,\n\t\t\t\tExternalName: \"ingress-conformance-echo.\" + namespace,\n\t\t\t\tPorts: []corev1.ServicePort{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"http\",\n\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\trequire.NoError(t, f.Client.Create(context.TODO(), externalNameService))\n\n\t\tp := &contourv1.HTTPProxy{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tNamespace: namespace,\n\t\t\t\tName:      \"external-name-proxy\",\n\t\t\t},\n\t\t\tSpec: contourv1.HTTPProxySpec{\n\t\t\t\tVirtualHost: &contourv1.VirtualHost{\n\t\t\t\t\tFqdn: \"externalnameservice.projectcontour.io\",\n\t\t\t\t},\n\t\t\t\tRoutes: []contourv1.Route{\n\t\t\t\t\t{\n\t\t\t\t\t\tServices: []contourv1.Service{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName: externalNameService.Name,\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRequestHeadersPolicy: &contourv1.HeadersPolicy{\n\t\t\t\t\t\t\tSet: []contourv1.HeaderValue{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\t\t\t\tValue: externalNameService.Spec.ExternalName,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tf.CreateHTTPProxyAndWaitFor(p, httpProxyValid)\n\n\t\tres, ok := f.HTTP.RequestUntil(&e2e.HTTPRequestOpts{\n\t\t\tHost:      p.Spec.VirtualHost.Fqdn,\n\t\t\tCondition: e2e.HasStatusCode(200),\n\t\t})\n\t\trequire.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)\n\t})\n}\n\nfunc testExternalNameServiceTLS(namespace string) {\n\tSpecify(\"external name services work over https\", func() {\n\t\tt := f.T()\n\n\t\tf.Certs.CreateSelfSignedCert(namespace, \"backend-server-cert\", \"backend-server-cert\", \"echo\")\n\n\t\tf.Fixtures.EchoSecure.Deploy(namespace, \"echo-tls\")\n\n\t\texternalNameService := &corev1.Service{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tNamespace: namespace,\n\t\t\t\tName:      \"external-name-service-tls\",\n\t\t\t},\n\t\t\tSpec: corev1.ServiceSpec{\n\t\t\t\tType:         corev1.ServiceTypeExternalName,\n\t\t\t\tExternalName: \"echo-tls.\" + namespace,\n\t\t\t\tPorts: []corev1.ServicePort{\n\t\t\t\t\t{\n\t\t\t\t\t\tName:     \"https\",\n\t\t\t\t\t\tPort:     443,\n\t\t\t\t\t\tProtocol: corev1.ProtocolTCP,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\trequire.NoError(t, f.Client.Create(context.TODO(), externalNameService))\n\n\t\tp := &contourv1.HTTPProxy{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tNamespace: namespace,\n\t\t\t\tName:      \"external-name-proxy-tls\",\n\t\t\t},\n\t\t\tSpec: contourv1.HTTPProxySpec{\n\t\t\t\tVirtualHost: &contourv1.VirtualHost{\n\t\t\t\t\tFqdn: \"tls.externalnameservice.projectcontour.io\",\n\t\t\t\t},\n\t\t\t\tRoutes: []contourv1.Route{\n\t\t\t\t\t{\n\t\t\t\t\t\tServices: []contourv1.Service{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName:     externalNameService.Name,\n\t\t\t\t\t\t\t\tPort:     443,\n\t\t\t\t\t\t\t\tProtocol: stringPtr(\"tls\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRequestHeadersPolicy: &contourv1.HeadersPolicy{\n\t\t\t\t\t\t\tSet: []contourv1.HeaderValue{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\t\t\t\tValue: externalNameService.Spec.ExternalName,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tf.CreateHTTPProxyAndWaitFor(p, httpProxyValid)\n\n\t\tres, ok := f.HTTP.RequestUntil(&e2e.HTTPRequestOpts{\n\t\t\tHost:      p.Spec.VirtualHost.Fqdn,\n\t\t\tCondition: e2e.HasStatusCode(200),\n\t\t})\n\t\trequire.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)\n\t})\n}\n\nfunc stringPtr(s string) *string {\n\treturn &s\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// +build e2e\n\npackage httpproxy\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\tcertmanagerv1 \"github.com/jetstack/cert-manager/pkg/apis/certmanager/v1\"\n\tcertmanagermetav1 \"github.com/jetstack/cert-manager/pkg/apis/meta/v1\"\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\t\"github.com/onsi/gomega/gexec\"\n\tcontourv1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"\n\t\"github.com/projectcontour/contour/pkg/config\"\n\t\"github.com/projectcontour/contour/test/e2e\"\n\t\"github.com/stretchr/testify/require\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n\nvar f = e2e.NewFramework(false)\n\nfunc TestHTTPProxy(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"HTTPProxy tests\")\n}\n\nvar _ = BeforeSuite(func() {\n\trequire.NoError(f.T(), f.Deployment.EnsureResourcesForLocalContour())\n})\n\nvar _ = AfterSuite(func() {\n\tf.DeleteNamespace(f.Deployment.Namespace.Name, true)\n\tgexec.CleanupBuildArtifacts()\n})\n\nvar _ = Describe(\"HTTPProxy\", func() {\n\tvar (\n\t\tcontourCmd            *gexec.Session\n\t\tcontourConfig         *config.Parameters\n\t\tcontourConfigFile     string\n\t\tadditionalContourArgs []string\n\t)\n\n\tBeforeEach(func() {\n\t\t// Contour config file contents, can be modified in nested\n\t\t// BeforeEach.\n\t\tcontourConfig = &config.Parameters{}\n\n\t\t// Default contour serve command line arguments can be appended to in\n\t\t// nested BeforeEach.\n\t\tadditionalContourArgs = []string{}\n\t})\n\n\t// JustBeforeEach is called after each of the nested BeforeEach are\n\t// called, so it is a final setup step before running a test.\n\t// A nested BeforeEach may have modified Contour config, so we wait\n\t// until here to start Contour.\n\tJustBeforeEach(func() {\n\t\tvar err error\n\t\tcontourCmd, contourConfigFile, err = f.Deployment.StartLocalContour(contourConfig, additionalContourArgs...)\n\t\trequire.NoError(f.T(), err)\n\n\t\t// Wait for Envoy to be healthy.\n\t\trequire.NoError(f.T(), f.Deployment.WaitForEnvoyDaemonSetUpdated())\n\t})\n\n\tAfterEach(func() {\n\t\trequire.NoError(f.T(), f.Deployment.StopLocalContour(contourCmd, contourConfigFile))\n\t})\n\n\tf.NamespacedTest(\"001-required-field-validation\", testRequiredFieldValidation)\n\n\tf.NamespacedTest(\"002-header-condition-match\", testHeaderConditionMatch)\n\n\tf.NamespacedTest(\"003-path-condition-match\", testPathConditionMatch)\n\n\tf.NamespacedTest(\"004-https-sni-enforcement\", testHTTPSSNIEnforcement)\n\n\tf.NamespacedTest(\"005-pod-restart\", testPodRestart)\n\n\tf.NamespacedTest(\"006-merge-slash\", testMergeSlash)\n\n\tf.NamespacedTest(\"007-client-cert-auth\", testClientCertAuth)\n\n\tf.NamespacedTest(\"008-tcproute-https-termination\", testTCPRouteHTTPSTermination)\n\n\tf.NamespacedTest(\"009-https-misdirected-request\", testHTTPSMisdirectedRequest)\n\n\tf.NamespacedTest(\"010-include-prefix-condition\", testIncludePrefixCondition)\n\n\tf.NamespacedTest(\"011-retry-policy-validation\", testRetryPolicyValidation)\n\n\tf.NamespacedTest(\"012-https-fallback-certificate\", func(namespace string) {\n\t\tContext(\"with fallback certificate\", func() {\n\t\t\tBeforeEach(func() {\n\t\t\t\tcontourConfig.TLS = config.TLSParameters{\n\t\t\t\t\tFallbackCertificate: config.NamespacedName{\n\t\t\t\t\t\tName:      \"fallback-cert\",\n\t\t\t\t\t\tNamespace: namespace,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\tf.Certs.CreateSelfSignedCert(namespace, \"fallback-cert\", \"fallback-cert\", \"fallback.projectcontour.io\")\n\t\t\t})\n\n\t\t\ttestHTTPSFallbackCertificate(namespace)\n\t\t})\n\t})\n\n\tf.NamespacedTest(\"backend-tls\", func(namespace string) {\n\t\tContext(\"with backend tls\", func() {\n\t\t\tBeforeEach(func() {\n\t\t\t\t// Top level issuer.\n\t\t\t\tselfSignedIssuer := &certmanagerv1.Issuer{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tNamespace: namespace,\n\t\t\t\t\t\tName:      \"selfsigned\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: certmanagerv1.IssuerSpec{\n\t\t\t\t\t\tIssuerConfig: certmanagerv1.IssuerConfig{\n\t\t\t\t\t\t\tSelfSigned: &certmanagerv1.SelfSignedIssuer{},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\trequire.NoError(f.T(), f.Client.Create(context.TODO(), selfSignedIssuer))\n\n\t\t\t\t// CA to sign backend certs with.\n\t\t\t\tcaCertificate := &certmanagerv1.Certificate{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tNamespace: namespace,\n\t\t\t\t\t\tName:      \"ca-cert\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: certmanagerv1.CertificateSpec{\n\t\t\t\t\t\tIsCA: true,\n\t\t\t\t\t\tUsages: []certmanagerv1.KeyUsage{\n\t\t\t\t\t\t\tcertmanagerv1.UsageSigning,\n\t\t\t\t\t\t\tcertmanagerv1.UsageCertSign,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tCommonName: \"ca-cert\",\n\t\t\t\t\t\tSecretName: \"ca-cert\",\n\t\t\t\t\t\tIssuerRef: certmanagermetav1.ObjectReference{\n\t\t\t\t\t\t\tName: \"selfsigned\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\trequire.NoError(f.T(), f.Client.Create(context.TODO(), caCertificate))\n\n\t\t\t\t// Issuer based on CA to generate new certs with.\n\t\t\t\tbasedOnCAIssuer := &certmanagerv1.Issuer{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tNamespace: namespace,\n\t\t\t\t\t\tName:      \"ca-issuer\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: certmanagerv1.IssuerSpec{\n\t\t\t\t\t\tIssuerConfig: certmanagerv1.IssuerConfig{\n\t\t\t\t\t\t\tCA: &certmanagerv1.CAIssuer{\n\t\t\t\t\t\t\t\tSecretName: \"ca-cert\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\trequire.NoError(f.T(), f.Client.Create(context.TODO(), basedOnCAIssuer))\n\n\t\t\t\t// Backend client cert, can use for upstream validation as well.\n\t\t\t\tbackendClientCert := &certmanagerv1.Certificate{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tNamespace: namespace,\n\t\t\t\t\t\tName:      \"backend-client-cert\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: certmanagerv1.CertificateSpec{\n\t\t\t\t\t\tUsages: []certmanagerv1.KeyUsage{\n\t\t\t\t\t\t\tcertmanagerv1.UsageClientAuth,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tCommonName: \"client\",\n\t\t\t\t\t\tSecretName: \"backend-client-cert\",\n\t\t\t\t\t\tIssuerRef: certmanagermetav1.ObjectReference{\n\t\t\t\t\t\t\tName: \"ca-issuer\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\trequire.NoError(f.T(), f.Client.Create(context.TODO(), backendClientCert))\n\n\t\t\t\tcontourConfig.TLS = config.TLSParameters{\n\t\t\t\t\tClientCertificate: config.NamespacedName{\n\t\t\t\t\t\tNamespace: namespace,\n\t\t\t\t\t\tName:      \"backend-client-cert\",\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t})\n\n\t\t\ttestBackendTLS(namespace)\n\t\t})\n\t})\n\n\tf.NamespacedTest(\"014-external-auth\", testExternalAuth)\n\n\tf.NamespacedTest(\"015-http-health-checks\", testHTTPHealthChecks)\n\n\tf.NamespacedTest(\"016-dynamic-headers\", testDynamicHeaders)\n\n\tf.NamespacedTest(\"017-host-header-rewrite\", testHostHeaderRewrite)\n\n\tf.NamespacedTest(\"018-external-name-service-insecure\", testExternalNameServiceInsecure)\n\n\tf.NamespacedTest(\"018-external-name-service-tls\", testExternalNameServiceTLS)\n\n\tf.NamespacedTest(\"019-local-rate-limiting-vhost\", testLocalRateLimitingVirtualHost)\n\n\tf.NamespacedTest(\"019-local-rate-limiting-route\", testLocalRateLimitingRoute)\n\n\tContext(\"global rate limiting\", func() {\n\t\twithRateLimitService := func(body e2e.NamespacedTestBody) e2e.NamespacedTestBody {\n\t\t\treturn func(namespace string) {\n\t\t\t\tContext(\"with rate limit service\", func() {\n\t\t\t\t\tBeforeEach(func() {\n\t\t\t\t\t\tcontourConfig.RateLimitService = config.RateLimitService{\n\t\t\t\t\t\t\tExtensionService: fmt.Sprintf(\"%s/%s\", namespace, f.Deployment.RateLimitExtensionService.Name),\n\t\t\t\t\t\t\tDomain:           \"contour\",\n\t\t\t\t\t\t\tFailOpen:         false,\n\t\t\t\t\t\t}\n\t\t\t\t\t\trequire.NoError(f.T(),\n\t\t\t\t\t\t\tf.Deployment.EnsureRateLimitResources(\n\t\t\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\t\t\t`\ndomain: contour\ndescriptors:\n  - key: generic_key\n    value: vhostlimit\n    rate_limit:\n      unit: hour\n      requests_per_unit: 1\n  - key: route_limit_key\n    value: routelimit\n    rate_limit:\n      unit: hour\n      requests_per_unit: 1\n  - key: generic_key\n    value: tlsvhostlimit\n    rate_limit:\n      unit: hour\n      requests_per_unit: 1\n  - key: generic_key\n    value: tlsroutelimit\n    rate_limit:\n      unit: hour\n      requests_per_unit: 1`))\n\t\t\t\t\t})\n\n\t\t\t\t\tbody(namespace)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tf.NamespacedTest(\"020-global-rate-limiting-vhost-non-tls\", withRateLimitService(testGlobalRateLimitingVirtualHostNonTLS))\n\n\t\tf.NamespacedTest(\"020-global-rate-limiting-route-non-tls\", withRateLimitService(testGlobalRateLimitingRouteNonTLS))\n\n\t\tf.NamespacedTest(\"020-global-rate-limiting-vhost-tls\", withRateLimitService(testGlobalRateLimitingVirtualHostTLS))\n\n\t\tf.NamespacedTest(\"020-global-rate-limiting-route-tls\", withRateLimitService(testGlobalRateLimitingRouteTLS))\n\t})\n})\n\n// httpProxyValid returns true if the proxy has a .status.currentStatus\n// of \"valid\".\nfunc httpProxyValid(proxy *contourv1.HTTPProxy) bool {\n\treturn proxy != nil && proxy.Status.CurrentStatus == \"valid\"\n}\n"], "fixing_code": ["// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strconv\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/projectcontour/contour/internal/controller\"\n\n\tenvoy_server_v3 \"github.com/envoyproxy/go-control-plane/pkg/server/v3\"\n\tcontour_api_v1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"\n\tcontour_api_v1alpha1 \"github.com/projectcontour/contour/apis/projectcontour/v1alpha1\"\n\t\"github.com/projectcontour/contour/internal/annotation\"\n\t\"github.com/projectcontour/contour/internal/contour\"\n\t\"github.com/projectcontour/contour/internal/dag\"\n\t\"github.com/projectcontour/contour/internal/debug\"\n\t\"github.com/projectcontour/contour/internal/health\"\n\t\"github.com/projectcontour/contour/internal/httpsvc\"\n\t\"github.com/projectcontour/contour/internal/k8s\"\n\t\"github.com/projectcontour/contour/internal/metrics\"\n\t\"github.com/projectcontour/contour/internal/timeout\"\n\t\"github.com/projectcontour/contour/internal/workgroup\"\n\t\"github.com/projectcontour/contour/internal/xds\"\n\tcontour_xds_v3 \"github.com/projectcontour/contour/internal/xds/v3\"\n\t\"github.com/projectcontour/contour/internal/xdscache\"\n\txdscache_v3 \"github.com/projectcontour/contour/internal/xdscache/v3\"\n\t\"github.com/projectcontour/contour/pkg/config\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/sirupsen/logrus\"\n\t\"gopkg.in/alecthomas/kingpin.v2\"\n\tcorev1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/client-go/dynamic\"\n\t\"k8s.io/client-go/tools/cache\"\n\tcontroller_config \"sigs.k8s.io/controller-runtime/pkg/client/config\"\n\t\"sigs.k8s.io/controller-runtime/pkg/manager\"\n\t\"sigs.k8s.io/controller-runtime/pkg/manager/signals\"\n\tgatewayapi_v1alpha1 \"sigs.k8s.io/gateway-api/apis/v1alpha1\"\n)\n\n// Add RBAC policy to support leader election.\n// +kubebuilder:rbac:groups=\"\",resources=configmaps,verbs=create;get;update\n\n// Add RBAC policy to support getting CRDs.\n// +kubebuilder:rbac:groups=\"apiextensions.k8s.io\",resources=customresourcedefinitions,verbs=list\n\n// registerServe registers the serve subcommand and flags\n// with the Application provided.\nfunc registerServe(app *kingpin.Application) (*kingpin.CmdClause, *serveContext) {\n\tserve := app.Command(\"serve\", \"Serve xDS API traffic.\")\n\n\t// The precedence of configuration for contour serve is as follows:\n\t// config file, overridden by env vars, overridden by cli flags.\n\t// however, as -c is a cli flag, we don't know its value til cli flags\n\t// have been parsed. To correct this ordering we assign a post parse\n\t// action to -c, then parse cli flags twice (see main.main). On the second\n\t// parse our action will return early, resulting in the precedence order\n\t// we want.\n\tvar (\n\t\tconfigFile string\n\t\tparsed     bool\n\t)\n\tctx := newServeContext()\n\n\tparseConfig := func(_ *kingpin.ParseContext) error {\n\t\tif parsed || configFile == \"\" {\n\t\t\t// if there is no config file supplied, or we've\n\t\t\t// already parsed it, return immediately.\n\t\t\treturn nil\n\t\t}\n\t\tf, err := os.Open(configFile)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer f.Close()\n\n\t\tparams, err := config.Parse(f)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := params.Validate(); err != nil {\n\t\t\treturn fmt.Errorf(\"invalid Contour configuration: %w\", err)\n\t\t}\n\n\t\tparsed = true\n\t\tctx.Config = *params\n\n\t\treturn nil\n\t}\n\n\tserve.Flag(\"config-path\", \"Path to base configuration.\").Short('c').PlaceHolder(\"/path/to/file\").Action(parseConfig).ExistingFileVar(&configFile)\n\n\tserve.Flag(\"incluster\", \"Use in cluster configuration.\").BoolVar(&ctx.Config.InCluster)\n\tserve.Flag(\"kubeconfig\", \"Path to kubeconfig (if not in running inside a cluster).\").PlaceHolder(\"/path/to/file\").StringVar(&ctx.Config.Kubeconfig)\n\n\tserve.Flag(\"xds-address\", \"xDS gRPC API address.\").PlaceHolder(\"<ipaddr>\").StringVar(&ctx.xdsAddr)\n\tserve.Flag(\"xds-port\", \"xDS gRPC API port.\").PlaceHolder(\"<port>\").IntVar(&ctx.xdsPort)\n\n\tserve.Flag(\"stats-address\", \"Envoy /stats interface address.\").PlaceHolder(\"<ipaddr>\").StringVar(&ctx.statsAddr)\n\tserve.Flag(\"stats-port\", \"Envoy /stats interface port.\").PlaceHolder(\"<port>\").IntVar(&ctx.statsPort)\n\n\tserve.Flag(\"debug-http-address\", \"Address the debug http endpoint will bind to.\").PlaceHolder(\"<ipaddr>\").StringVar(&ctx.debugAddr)\n\tserve.Flag(\"debug-http-port\", \"Port the debug http endpoint will bind to.\").PlaceHolder(\"<port>\").IntVar(&ctx.debugPort)\n\n\tserve.Flag(\"http-address\", \"Address the metrics HTTP endpoint will bind to.\").PlaceHolder(\"<ipaddr>\").StringVar(&ctx.metricsAddr)\n\tserve.Flag(\"http-port\", \"Port the metrics HTTP endpoint will bind to.\").PlaceHolder(\"<port>\").IntVar(&ctx.metricsPort)\n\tserve.Flag(\"health-address\", \"Address the health HTTP endpoint will bind to.\").PlaceHolder(\"<ipaddr>\").StringVar(&ctx.healthAddr)\n\tserve.Flag(\"health-port\", \"Port the health HTTP endpoint will bind to.\").PlaceHolder(\"<port>\").IntVar(&ctx.healthPort)\n\n\tserve.Flag(\"contour-cafile\", \"CA bundle file name for serving gRPC with TLS.\").Envar(\"CONTOUR_CAFILE\").StringVar(&ctx.caFile)\n\tserve.Flag(\"contour-cert-file\", \"Contour certificate file name for serving gRPC over TLS.\").PlaceHolder(\"/path/to/file\").Envar(\"CONTOUR_CERT_FILE\").StringVar(&ctx.contourCert)\n\tserve.Flag(\"contour-key-file\", \"Contour key file name for serving gRPC over TLS.\").PlaceHolder(\"/path/to/file\").Envar(\"CONTOUR_KEY_FILE\").StringVar(&ctx.contourKey)\n\tserve.Flag(\"insecure\", \"Allow serving without TLS secured gRPC.\").BoolVar(&ctx.PermitInsecureGRPC)\n\tserve.Flag(\"root-namespaces\", \"Restrict contour to searching these namespaces for root ingress routes.\").PlaceHolder(\"<ns,ns>\").StringVar(&ctx.rootNamespaces)\n\n\tserve.Flag(\"ingress-class-name\", \"Contour IngressClass name.\").PlaceHolder(\"<name>\").StringVar(&ctx.ingressClassName)\n\tserve.Flag(\"ingress-status-address\", \"Address to set in Ingress object status.\").PlaceHolder(\"<address>\").StringVar(&ctx.Config.IngressStatusAddress)\n\tserve.Flag(\"envoy-http-access-log\", \"Envoy HTTP access log.\").PlaceHolder(\"/path/to/file\").StringVar(&ctx.httpAccessLog)\n\tserve.Flag(\"envoy-https-access-log\", \"Envoy HTTPS access log.\").PlaceHolder(\"/path/to/file\").StringVar(&ctx.httpsAccessLog)\n\tserve.Flag(\"envoy-service-http-address\", \"Kubernetes Service address for HTTP requests.\").PlaceHolder(\"<ipaddr>\").StringVar(&ctx.httpAddr)\n\tserve.Flag(\"envoy-service-https-address\", \"Kubernetes Service address for HTTPS requests.\").PlaceHolder(\"<ipaddr>\").StringVar(&ctx.httpsAddr)\n\tserve.Flag(\"envoy-service-http-port\", \"Kubernetes Service port for HTTP requests.\").PlaceHolder(\"<port>\").IntVar(&ctx.httpPort)\n\tserve.Flag(\"envoy-service-https-port\", \"Kubernetes Service port for HTTPS requests.\").PlaceHolder(\"<port>\").IntVar(&ctx.httpsPort)\n\tserve.Flag(\"envoy-service-name\", \"Name of the Envoy service to inspect for Ingress status details.\").PlaceHolder(\"<name>\").StringVar(&ctx.Config.EnvoyServiceName)\n\tserve.Flag(\"envoy-service-namespace\", \"Envoy Service Namespace.\").PlaceHolder(\"<namespace>\").StringVar(&ctx.Config.EnvoyServiceNamespace)\n\tserve.Flag(\"use-proxy-protocol\", \"Use PROXY protocol for all listeners.\").BoolVar(&ctx.useProxyProto)\n\n\tserve.Flag(\"accesslog-format\", \"Format for Envoy access logs.\").PlaceHolder(\"<envoy|json>\").StringVar((*string)(&ctx.Config.AccessLogFormat))\n\tserve.Flag(\"disable-leader-election\", \"Disable leader election mechanism.\").BoolVar(&ctx.DisableLeaderElection)\n\n\tserve.Flag(\"debug\", \"Enable debug logging.\").Short('d').BoolVar(&ctx.Config.Debug)\n\tserve.Flag(\"kubernetes-debug\", \"Enable Kubernetes client debug logging with log level.\").PlaceHolder(\"<log level>\").UintVar(&ctx.KubernetesDebug)\n\treturn serve, ctx\n}\n\n// validateCRDs inspects all CRDs in the projectcontour.io group and logs a warning\n// if they have spec.preserveUnknownFields set to true, since this indicates that they\n// were created as v1beta1 and the user has not upgraded them to be fully v1-compatible.\nfunc validateCRDs(dynamicClient dynamic.Interface, log logrus.FieldLogger) {\n\tclient := dynamicClient.Resource(schema.GroupVersionResource{Group: \"apiextensions.k8s.io\", Version: \"v1\", Resource: \"customresourcedefinitions\"})\n\n\tcrds, err := client.List(context.TODO(), metav1.ListOptions{})\n\tif err != nil {\n\t\tlog.Warnf(\"error listing v1 custom resource definitions: %v\", err)\n\t\treturn\n\t}\n\n\tfor _, crd := range crds.Items {\n\t\tlog = log.WithField(\"crd\", crd.GetName())\n\n\t\tif group, _, _ := unstructured.NestedString(crd.Object, \"spec\", \"group\"); group != contour_api_v1.GroupName {\n\t\t\tlog.Debugf(\"CRD is not in projectcontour.io API group, ignoring\")\n\t\t\tcontinue\n\t\t}\n\n\t\tpreserveUnknownFields, found, err := unstructured.NestedBool(crd.Object, \"spec\", \"preserveUnknownFields\")\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"error getting CRD's spec.preserveUnknownFields value: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif found && preserveUnknownFields {\n\t\t\tlog.Warnf(\"CRD was created as v1beta1 since it has spec.preserveUnknownFields set to true; it should be upgraded to v1 per https://projectcontour.io/resources/upgrading/\")\n\t\t\tcontinue\n\t\t}\n\n\t\tlog.Debugf(\"CRD is fully v1-compatible since it has spec.preserveUnknownFields set to false\")\n\t}\n}\n\n// doServe runs the contour serve subcommand.\nfunc doServe(log logrus.FieldLogger, ctx *serveContext) error {\n\t// Establish k8s core & dynamic client connections.\n\tclients, err := k8s.NewClients(ctx.Config.Kubeconfig, ctx.Config.InCluster)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create Kubernetes clients: %w\", err)\n\t}\n\n\t// Validate that Contour CRDs have been updated to v1.\n\tvalidateCRDs(clients.DynamicClient(), log)\n\n\t// informerNamespaces is a list of namespaces that we should start informers for.\n\tvar informerNamespaces []string\n\n\tfallbackCert := namespacedNameOf(ctx.Config.TLS.FallbackCertificate)\n\tclientCert := namespacedNameOf(ctx.Config.TLS.ClientCertificate)\n\n\tif rootNamespaces := ctx.proxyRootNamespaces(); len(rootNamespaces) > 0 {\n\t\tinformerNamespaces = append(informerNamespaces, rootNamespaces...)\n\n\t\t// Add the FallbackCertificateNamespace to informerNamespaces if it isn't present.\n\t\tif !contains(informerNamespaces, ctx.Config.TLS.FallbackCertificate.Namespace) && fallbackCert != nil {\n\t\t\tinformerNamespaces = append(informerNamespaces, ctx.Config.TLS.FallbackCertificate.Namespace)\n\t\t\tlog.WithField(\"context\", \"fallback-certificate\").\n\t\t\t\tInfof(\"fallback certificate namespace %q not defined in 'root-namespaces', adding namespace to watch\",\n\t\t\t\t\tctx.Config.TLS.FallbackCertificate.Namespace)\n\t\t}\n\n\t\t// Add the client certificate namespace to informerNamespaces if it isn't present.\n\t\tif !contains(informerNamespaces, ctx.Config.TLS.ClientCertificate.Namespace) && clientCert != nil {\n\t\t\tinformerNamespaces = append(informerNamespaces, ctx.Config.TLS.ClientCertificate.Namespace)\n\t\t\tlog.WithField(\"context\", \"envoy-client-certificate\").\n\t\t\t\tInfof(\"client certificate namespace %q not defined in 'root-namespaces', adding namespace to watch\",\n\t\t\t\t\tctx.Config.TLS.ClientCertificate.Namespace)\n\t\t}\n\t}\n\n\t// Set up Prometheus registry and register base metrics.\n\tregistry := prometheus.NewRegistry()\n\tregistry.MustRegister(prometheus.NewProcessCollector(prometheus.ProcessCollectorOpts{}))\n\tregistry.MustRegister(prometheus.NewGoCollector())\n\n\t// Before we can build the event handler, we need to initialize the converter we'll\n\t// use to convert from Unstructured.\n\tconverter, err := k8s.NewUnstructuredConverter()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// XXX(jpeach) we know the config file validated, so all\n\t// the timeouts will parse. Shall we add a `timeout.MustParse()`\n\t// and use it here?\n\n\tconnectionIdleTimeout, err := timeout.Parse(ctx.Config.Timeouts.ConnectionIdleTimeout)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing connection idle timeout: %w\", err)\n\t}\n\tstreamIdleTimeout, err := timeout.Parse(ctx.Config.Timeouts.StreamIdleTimeout)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing stream idle timeout: %w\", err)\n\t}\n\tdelayedCloseTimeout, err := timeout.Parse(ctx.Config.Timeouts.DelayedCloseTimeout)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing delayed close timeout: %w\", err)\n\t}\n\tmaxConnectionDuration, err := timeout.Parse(ctx.Config.Timeouts.MaxConnectionDuration)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing max connection duration: %w\", err)\n\t}\n\tconnectionShutdownGracePeriod, err := timeout.Parse(ctx.Config.Timeouts.ConnectionShutdownGracePeriod)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing connection shutdown grace period: %w\", err)\n\t}\n\trequestTimeout, err := timeout.Parse(ctx.Config.Timeouts.RequestTimeout)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing request timeout: %w\", err)\n\t}\n\n\t// connection balancer\n\tif ok := ctx.Config.Listener.ConnectionBalancer == \"exact\" || ctx.Config.Listener.ConnectionBalancer == \"\"; !ok {\n\t\tlog.Warnf(\"Invalid listener connection balancer value %q. Only 'exact' connection balancing is supported for now.\", ctx.Config.Listener.ConnectionBalancer)\n\t\tctx.Config.Listener.ConnectionBalancer = \"\"\n\t}\n\n\tlistenerConfig := xdscache_v3.ListenerConfig{\n\t\tUseProxyProto: ctx.useProxyProto,\n\t\tHTTPListeners: map[string]xdscache_v3.Listener{\n\t\t\t\"ingress_http\": {\n\t\t\t\tName:    \"ingress_http\",\n\t\t\t\tAddress: ctx.httpAddr,\n\t\t\t\tPort:    ctx.httpPort,\n\t\t\t},\n\t\t},\n\t\tHTTPSListeners: map[string]xdscache_v3.Listener{\n\t\t\t\"ingress_https\": {\n\t\t\t\tName:    \"ingress_https\",\n\t\t\t\tAddress: ctx.httpsAddr,\n\t\t\t\tPort:    ctx.httpsPort,\n\t\t\t},\n\t\t},\n\t\tHTTPAccessLog:                 ctx.httpAccessLog,\n\t\tHTTPSAccessLog:                ctx.httpsAccessLog,\n\t\tAccessLogType:                 ctx.Config.AccessLogFormat,\n\t\tAccessLogFields:               ctx.Config.AccessLogFields,\n\t\tMinimumTLSVersion:             annotation.MinTLSVersion(ctx.Config.TLS.MinimumProtocolVersion, \"1.2\"),\n\t\tCipherSuites:                  config.SanitizeCipherSuites(ctx.Config.TLS.CipherSuites),\n\t\tRequestTimeout:                requestTimeout,\n\t\tConnectionIdleTimeout:         connectionIdleTimeout,\n\t\tStreamIdleTimeout:             streamIdleTimeout,\n\t\tDelayedCloseTimeout:           delayedCloseTimeout,\n\t\tMaxConnectionDuration:         maxConnectionDuration,\n\t\tConnectionShutdownGracePeriod: connectionShutdownGracePeriod,\n\t\tDefaultHTTPVersions:           parseDefaultHTTPVersions(ctx.Config.DefaultHTTPVersions),\n\t\tAllowChunkedLength:            !ctx.Config.DisableAllowChunkedLength,\n\t\tXffNumTrustedHops:             ctx.Config.Network.XffNumTrustedHops,\n\t\tConnectionBalancer:            ctx.Config.Listener.ConnectionBalancer,\n\t}\n\n\tif ctx.Config.RateLimitService.ExtensionService != \"\" {\n\t\tnamespacedName := k8s.NamespacedNameFrom(ctx.Config.RateLimitService.ExtensionService)\n\t\tclient := clients.DynamicClient().Resource(contour_api_v1alpha1.ExtensionServiceGVR).Namespace(namespacedName.Namespace)\n\n\t\t// ensure the specified ExtensionService exists\n\t\tres, err := client.Get(context.Background(), namespacedName.Name, metav1.GetOptions{})\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error getting rate limit extension service %s: %v\", namespacedName, err)\n\t\t}\n\t\tvar extensionSvc contour_api_v1alpha1.ExtensionService\n\t\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(res.Object, &extensionSvc); err != nil {\n\t\t\treturn fmt.Errorf(\"error converting rate limit extension service %s: %v\", namespacedName, err)\n\t\t}\n\t\t// get the response timeout from the ExtensionService\n\t\tvar responseTimeout timeout.Setting\n\t\tif tp := extensionSvc.Spec.TimeoutPolicy; tp != nil {\n\t\t\tresponseTimeout, err = timeout.Parse(tp.Response)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"error parsing rate limit extension service %s response timeout: %v\", namespacedName, err)\n\t\t\t}\n\t\t}\n\n\t\tlistenerConfig.RateLimitConfig = &xdscache_v3.RateLimitConfig{\n\t\t\tExtensionService:        namespacedName,\n\t\t\tDomain:                  ctx.Config.RateLimitService.Domain,\n\t\t\tTimeout:                 responseTimeout,\n\t\t\tFailOpen:                ctx.Config.RateLimitService.FailOpen,\n\t\t\tEnableXRateLimitHeaders: ctx.Config.RateLimitService.EnableXRateLimitHeaders,\n\t\t}\n\t}\n\n\tcontourMetrics := metrics.NewMetrics(registry)\n\n\t// Endpoints updates are handled directly by the EndpointsTranslator\n\t// due to their high update rate and their orthogonal nature.\n\tendpointHandler := xdscache_v3.NewEndpointsTranslator(log.WithField(\"context\", \"endpointstranslator\"))\n\n\tresources := []xdscache.ResourceCache{\n\t\txdscache_v3.NewListenerCache(listenerConfig, ctx.statsAddr, ctx.statsPort),\n\t\t&xdscache_v3.SecretCache{},\n\t\t&xdscache_v3.RouteCache{},\n\t\t&xdscache_v3.ClusterCache{},\n\t\tendpointHandler,\n\t}\n\n\t// snapshotHandler is used to produce new snapshots when the internal state changes for any xDS resource.\n\tsnapshotHandler := xdscache.NewSnapshotHandler(resources, log.WithField(\"context\", \"snapshotHandler\"))\n\n\t// register observer for endpoints updates.\n\tendpointHandler.Observer = contour.ComposeObservers(snapshotHandler)\n\n\t// Log that we're using the fallback certificate if configured.\n\tif fallbackCert != nil {\n\t\tlog.WithField(\"context\", \"fallback-certificate\").Infof(\"enabled fallback certificate with secret: %q\", fallbackCert)\n\t}\n\tif clientCert != nil {\n\t\tlog.WithField(\"context\", \"envoy-client-certificate\").Infof(\"enabled client certificate with secret: %q\", clientCert)\n\t}\n\n\t// Build the core Kubernetes event handler.\n\teventHandler := &contour.EventHandler{\n\t\tHoldoffDelay:    100 * time.Millisecond,\n\t\tHoldoffMaxDelay: 500 * time.Millisecond,\n\t\tObserver:        dag.ComposeObservers(append(xdscache.ObserversOf(resources), snapshotHandler)...),\n\t\tBuilder:         getDAGBuilder(ctx, clients, clientCert, fallbackCert, log),\n\t\tFieldLogger:     log.WithField(\"context\", \"contourEventHandler\"),\n\t}\n\n\t// Wrap eventHandler in a converter for objects from the dynamic client.\n\t// and an EventRecorder which tracks API server events.\n\tdynamicHandler := k8s.DynamicClientHandler{\n\t\tNext: &contour.EventRecorder{\n\t\t\tNext:    eventHandler,\n\t\t\tCounter: contourMetrics.EventHandlerOperations,\n\t\t},\n\t\tConverter: converter,\n\t\tLogger:    log.WithField(\"context\", \"dynamicHandler\"),\n\t}\n\n\t// Inform on DefaultResources.\n\tfor _, r := range k8s.DefaultResources() {\n\t\tinf, err := clients.InformerForResource(r)\n\t\tif err != nil {\n\t\t\tlog.WithError(err).WithField(\"resource\", r).Fatal(\"failed to create informer\")\n\t\t}\n\n\t\tinf.AddEventHandler(&dynamicHandler)\n\t}\n\n\tfor _, r := range k8s.IngressV1Resources() {\n\t\tif err := informOnResource(clients, r, &dynamicHandler); err != nil {\n\t\t\tlog.WithError(err).WithField(\"resource\", r).Fatal(\"failed to create informer\")\n\t\t}\n\t}\n\n\t// Set up workgroup runner and register informers.\n\tvar g workgroup.Group\n\n\t// Only inform on Gateway API resources if Gateway API is found.\n\tif ctx.Config.GatewayConfig != nil {\n\t\tif clients.ResourcesExist(k8s.GatewayAPIResources()...) {\n\n\t\t\t// Setup a Manager\n\t\t\tmgr, err := manager.New(controller_config.GetConfigOrDie(), manager.Options{})\n\t\t\tif err != nil {\n\t\t\t\tlog.WithError(err).Fatal(\"unable to set up controller manager\")\n\t\t\t}\n\n\t\t\t// Add the Gateway API Scheme.\n\t\t\terr = gatewayapi_v1alpha1.AddToScheme(mgr.GetScheme())\n\t\t\tif err != nil {\n\t\t\t\tlog.WithError(err).Fatal(\"unable to add Gateway API to scheme.\")\n\t\t\t}\n\n\t\t\t// Create and register the gatewayclass controller with the manager.\n\t\t\tgatewayClassControllerName := ctx.Config.GatewayConfig.ControllerName\n\t\t\tif _, err := controller.NewGatewayClassController(mgr, &dynamicHandler,\n\t\t\t\tlog.WithField(\"context\", \"gatewayclass-controller\"), gatewayClassControllerName); err != nil {\n\t\t\t\tlog.WithError(err).Fatal(\"failed to create gatewayclass-controller\")\n\t\t\t}\n\n\t\t\t// Create and register the NewGatewayController controller with the manager.\n\t\t\tif _, err := controller.NewGatewayController(mgr, &dynamicHandler,\n\t\t\t\tlog.WithField(\"context\", \"gateway-controller\"), gatewayClassControllerName); err != nil {\n\t\t\t\tlog.WithError(err).Fatal(\"failed to create gateway-controller\")\n\t\t\t}\n\n\t\t\t// Create and register the NewHTTPRouteController controller with the manager.\n\t\t\tif _, err := controller.NewHTTPRouteController(mgr, &dynamicHandler, log.WithField(\"context\", \"httproute-controller\")); err != nil {\n\t\t\t\tlog.WithError(err).Fatal(\"failed to create httproute-controller\")\n\t\t\t}\n\n\t\t\t// Create and register the NewTLSRouteController controller with the manager.\n\t\t\tif _, err := controller.NewTLSRouteController(mgr, &dynamicHandler, log.WithField(\"context\", \"tlsroute-controller\")); err != nil {\n\t\t\t\tlog.WithError(err).Fatal(\"failed to create tlsroute-controller\")\n\t\t\t}\n\n\t\t\t// Inform on Namespaces.\n\t\t\tif err := informOnResource(clients, k8s.NamespacesResource(), &dynamicHandler); err != nil {\n\t\t\t\tlog.WithError(err).WithField(\"resource\", k8s.NamespacesResource()).Fatal(\"failed to create informer\")\n\t\t\t}\n\n\t\t\t// Start Manager\n\t\t\tg.AddContext(func(taskCtx context.Context) error {\n\t\t\t\treturn mgr.Start(signals.SetupSignalHandler())\n\t\t\t})\n\t\t} else {\n\t\t\tlog.Fatalf(\"Gateway API Gateway configured but APIs not installed in cluster.\")\n\t\t}\n\t}\n\n\t// Inform on secrets, filtering by root namespaces.\n\tfor _, r := range k8s.SecretsResources() {\n\t\tvar handler cache.ResourceEventHandler = &dynamicHandler\n\n\t\t// If root namespaces are defined, filter for secrets in only those namespaces.\n\t\tif len(informerNamespaces) > 0 {\n\t\t\thandler = k8s.NewNamespaceFilter(informerNamespaces, &dynamicHandler)\n\t\t}\n\n\t\tif err := informOnResource(clients, r, handler); err != nil {\n\t\t\tlog.WithError(err).WithField(\"resource\", r).Fatal(\"failed to create informer\")\n\t\t}\n\t}\n\n\t// Inform on endpoints.\n\tfor _, r := range k8s.EndpointsResources() {\n\t\tif err := informOnResource(clients, r, &k8s.DynamicClientHandler{\n\t\t\tNext: &contour.EventRecorder{\n\t\t\t\tNext:    endpointHandler,\n\t\t\t\tCounter: contourMetrics.EventHandlerOperations,\n\t\t\t},\n\t\t\tConverter: converter,\n\t\t\tLogger:    log.WithField(\"context\", \"endpointstranslator\"),\n\t\t}); err != nil {\n\t\t\tlog.WithError(err).WithField(\"resource\", r).Fatal(\"failed to create informer\")\n\t\t}\n\t}\n\n\t// Register a task to start all the informers.\n\tg.AddContext(func(taskCtx context.Context) error {\n\t\tlog := log.WithField(\"context\", \"informers\")\n\n\t\tlog.Info(\"starting informers\")\n\t\tdefer log.Println(\"stopped informers\")\n\n\t\tif err := clients.StartInformers(taskCtx); err != nil {\n\t\t\tlog.WithError(err).Error(\"failed to start informers\")\n\t\t}\n\n\t\t<-taskCtx.Done()\n\t\treturn nil\n\t})\n\n\t// Register our event handler with the workgroup.\n\tg.Add(eventHandler.Start())\n\n\t// Create metrics service and register with workgroup.\n\tmetricsvc := httpsvc.Service{\n\t\tAddr:        ctx.metricsAddr,\n\t\tPort:        ctx.metricsPort,\n\t\tFieldLogger: log.WithField(\"context\", \"metricsvc\"),\n\t\tServeMux:    http.ServeMux{},\n\t}\n\n\tmetricsvc.ServeMux.Handle(\"/metrics\", metrics.Handler(registry))\n\n\tif ctx.healthAddr == ctx.metricsAddr && ctx.healthPort == ctx.metricsPort {\n\t\th := health.Handler(clients.ClientSet())\n\t\tmetricsvc.ServeMux.Handle(\"/health\", h)\n\t\tmetricsvc.ServeMux.Handle(\"/healthz\", h)\n\t}\n\n\tg.Add(metricsvc.Start)\n\n\t// Create a separate health service if required.\n\tif ctx.healthAddr != ctx.metricsAddr || ctx.healthPort != ctx.metricsPort {\n\t\thealthsvc := httpsvc.Service{\n\t\t\tAddr:        ctx.healthAddr,\n\t\t\tPort:        ctx.healthPort,\n\t\t\tFieldLogger: log.WithField(\"context\", \"healthsvc\"),\n\t\t}\n\n\t\th := health.Handler(clients.ClientSet())\n\t\thealthsvc.ServeMux.Handle(\"/health\", h)\n\t\thealthsvc.ServeMux.Handle(\"/healthz\", h)\n\n\t\tg.Add(healthsvc.Start)\n\t}\n\n\t// Create debug service and register with workgroup.\n\tdebugsvc := debug.Service{\n\t\tService: httpsvc.Service{\n\t\t\tAddr:        ctx.debugAddr,\n\t\t\tPort:        ctx.debugPort,\n\t\t\tFieldLogger: log.WithField(\"context\", \"debugsvc\"),\n\t\t},\n\t\tBuilder: &eventHandler.Builder,\n\t}\n\tg.Add(debugsvc.Start)\n\n\t// Register leadership election.\n\tif ctx.DisableLeaderElection {\n\t\teventHandler.IsLeader = disableLeaderElection(log)\n\t} else {\n\t\teventHandler.IsLeader = setupLeadershipElection(&g, log, &ctx.Config.LeaderElection, clients, eventHandler.UpdateNow)\n\t}\n\n\t// Once we have the leadership detection channel, we can\n\t// push DAG rebuild metrics onto the observer stack.\n\teventHandler.Observer = &contour.RebuildMetricsObserver{\n\t\tMetrics:      contourMetrics,\n\t\tIsLeader:     eventHandler.IsLeader,\n\t\tNextObserver: eventHandler.Observer,\n\t}\n\n\tsh := k8s.StatusUpdateHandler{\n\t\tLog:           log.WithField(\"context\", \"StatusUpdateHandler\"),\n\t\tClients:       clients,\n\t\tLeaderElected: eventHandler.IsLeader,\n\t\tConverter:     converter,\n\t}\n\tg.Add(sh.Start)\n\n\t// Now we have the statusUpdateHandler, we can create the event handler's StatusUpdater, which will take the\n\t// status updates from the DAG, and send them to the status update handler.\n\teventHandler.StatusUpdater = sh.Writer()\n\n\t// Set up ingress load balancer status writer.\n\tlbsw := loadBalancerStatusWriter{\n\t\tlog:              log.WithField(\"context\", \"loadBalancerStatusWriter\"),\n\t\tclients:          clients,\n\t\tisLeader:         eventHandler.IsLeader,\n\t\tlbStatus:         make(chan corev1.LoadBalancerStatus, 1),\n\t\tingressClassName: ctx.ingressClassName,\n\t\tstatusUpdater:    sh.Writer(),\n\t\tConverter:        converter,\n\t}\n\tg.Add(lbsw.Start)\n\n\t// Register an informer to watch envoy's service if we haven't been given static details.\n\tif lbAddr := ctx.Config.IngressStatusAddress; lbAddr != \"\" {\n\t\tlog.WithField(\"loadbalancer-address\", lbAddr).Info(\"Using supplied information for Ingress status\")\n\t\tlbsw.lbStatus <- parseStatusFlag(lbAddr)\n\t} else {\n\t\tdynamicServiceHandler := k8s.DynamicClientHandler{\n\t\t\tNext: &k8s.ServiceStatusLoadBalancerWatcher{\n\t\t\t\tServiceName: ctx.Config.EnvoyServiceName,\n\t\t\t\tLBStatus:    lbsw.lbStatus,\n\t\t\t\tLog:         log.WithField(\"context\", \"serviceStatusLoadBalancerWatcher\"),\n\t\t\t},\n\t\t\tConverter: converter,\n\t\t\tLogger:    log.WithField(\"context\", \"serviceStatusLoadBalancerWatcher\"),\n\t\t}\n\n\t\tfor _, r := range k8s.ServicesResources() {\n\t\t\tvar handler cache.ResourceEventHandler = &dynamicServiceHandler\n\n\t\t\tif ctx.Config.EnvoyServiceNamespace != \"\" {\n\t\t\t\thandler = k8s.NewNamespaceFilter([]string{ctx.Config.EnvoyServiceNamespace}, handler)\n\t\t\t}\n\n\t\t\tif err := informOnResource(clients, r, handler); err != nil {\n\t\t\t\tlog.WithError(err).WithField(\"resource\", r).Fatal(\"failed to create informer\")\n\t\t\t}\n\t\t}\n\n\t\tlog.WithField(\"envoy-service-name\", ctx.Config.EnvoyServiceName).\n\t\t\tWithField(\"envoy-service-namespace\", ctx.Config.EnvoyServiceNamespace).\n\t\t\tInfo(\"Watching Service for Ingress status\")\n\t}\n\n\tg.AddContext(func(taskCtx context.Context) error {\n\t\tlog := log.WithField(\"context\", \"xds\")\n\n\t\tlog.Printf(\"waiting for informer caches to sync\")\n\t\tif !clients.WaitForCacheSync(taskCtx) {\n\t\t\treturn errors.New(\"informer cache failed to sync\")\n\t\t}\n\t\tlog.Printf(\"informer caches synced\")\n\n\t\tgrpcServer := xds.NewServer(registry, ctx.grpcOptions(log)...)\n\n\t\tswitch ctx.Config.Server.XDSServerType {\n\t\tcase config.EnvoyServerType:\n\t\t\tv3cache := contour_xds_v3.NewSnapshotCache(false, log)\n\t\t\tsnapshotHandler.AddSnapshotter(v3cache)\n\t\t\tcontour_xds_v3.RegisterServer(envoy_server_v3.NewServer(taskCtx, v3cache, contour_xds_v3.NewRequestLoggingCallbacks(log)), grpcServer)\n\t\tcase config.ContourServerType:\n\t\t\tcontour_xds_v3.RegisterServer(contour_xds_v3.NewContourServer(log, xdscache.ResourcesOf(resources)...), grpcServer)\n\t\tdefault:\n\t\t\t// This can't happen due to config validation.\n\t\t\tlog.Fatalf(\"invalid xDS server type %q\", ctx.Config.Server.XDSServerType)\n\t\t}\n\n\t\taddr := net.JoinHostPort(ctx.xdsAddr, strconv.Itoa(ctx.xdsPort))\n\t\tl, err := net.Listen(\"tcp\", addr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tlog = log.WithField(\"address\", addr)\n\t\tif ctx.PermitInsecureGRPC {\n\t\t\tlog = log.WithField(\"insecure\", true)\n\t\t}\n\n\t\tlog.Infof(\"started xDS server type: %q\", ctx.Config.Server.XDSServerType)\n\t\tdefer log.Info(\"stopped xDS server\")\n\n\t\tgo func() {\n\t\t\t<-taskCtx.Done()\n\n\t\t\t// We don't use GracefulStop here because envoy\n\t\t\t// has long-lived hanging xDS requests. There's no\n\t\t\t// mechanism to make those pending requests fail,\n\t\t\t// so we forcibly terminate the TCP sessions.\n\t\t\tgrpcServer.Stop()\n\t\t}()\n\n\t\treturn grpcServer.Serve(l)\n\t})\n\n\t// Set up SIGTERM handler for graceful shutdown.\n\tg.Add(func(stop <-chan struct{}) error {\n\t\tc := make(chan os.Signal, 1)\n\t\tsignal.Notify(c, syscall.SIGTERM, syscall.SIGINT)\n\t\tselect {\n\t\tcase sig := <-c:\n\t\t\tlog.WithField(\"context\", \"sigterm-handler\").WithField(\"signal\", sig).Info(\"shutting down\")\n\t\tcase <-stop:\n\t\t\t// Do nothing. The group is shutting down.\n\t\t}\n\t\treturn nil\n\t})\n\n\t// GO!\n\treturn g.Run(context.Background())\n}\n\nfunc getDAGBuilder(ctx *serveContext, clients *k8s.Clients, clientCert, fallbackCert *types.NamespacedName, log logrus.FieldLogger) dag.Builder {\n\tvar requestHeadersPolicy dag.HeadersPolicy\n\tif ctx.Config.Policy.RequestHeadersPolicy.Set != nil {\n\t\trequestHeadersPolicy.Set = make(map[string]string)\n\t\tfor k, v := range ctx.Config.Policy.RequestHeadersPolicy.Set {\n\t\t\trequestHeadersPolicy.Set[k] = v\n\t\t}\n\t}\n\tif ctx.Config.Policy.RequestHeadersPolicy.Remove != nil {\n\t\trequestHeadersPolicy.Remove = make([]string, 0, len(ctx.Config.Policy.RequestHeadersPolicy.Remove))\n\t\trequestHeadersPolicy.Remove = append(requestHeadersPolicy.Remove, ctx.Config.Policy.RequestHeadersPolicy.Remove...)\n\t}\n\n\tvar responseHeadersPolicy dag.HeadersPolicy\n\tif ctx.Config.Policy.ResponseHeadersPolicy.Set != nil {\n\t\tresponseHeadersPolicy.Set = make(map[string]string)\n\t\tfor k, v := range ctx.Config.Policy.ResponseHeadersPolicy.Set {\n\t\t\tresponseHeadersPolicy.Set[k] = v\n\t\t}\n\t}\n\tif ctx.Config.Policy.ResponseHeadersPolicy.Remove != nil {\n\t\tresponseHeadersPolicy.Remove = make([]string, 0, len(ctx.Config.Policy.ResponseHeadersPolicy.Remove))\n\t\tresponseHeadersPolicy.Remove = append(responseHeadersPolicy.Remove, ctx.Config.Policy.ResponseHeadersPolicy.Remove...)\n\t}\n\n\tlog.Debugf(\"EnableExternalNameService is set to %t\", ctx.Config.EnableExternalNameService)\n\t// Get the appropriate DAG processors.\n\tdagProcessors := []dag.Processor{\n\t\t&dag.IngressProcessor{\n\t\t\tEnableExternalNameService: ctx.Config.EnableExternalNameService,\n\t\t\tFieldLogger:               log.WithField(\"context\", \"IngressProcessor\"),\n\t\t\tClientCertificate:         clientCert,\n\t\t},\n\t\t&dag.ExtensionServiceProcessor{\n\t\t\t// Note that ExtensionService does not support ExternalName, if it does get added,\n\t\t\t// need to bring EnableExternalNameService in here too.\n\t\t\tFieldLogger:       log.WithField(\"context\", \"ExtensionServiceProcessor\"),\n\t\t\tClientCertificate: clientCert,\n\t\t},\n\t\t&dag.HTTPProxyProcessor{\n\t\t\tEnableExternalNameService: ctx.Config.EnableExternalNameService,\n\t\t\tDisablePermitInsecure:     ctx.Config.DisablePermitInsecure,\n\t\t\tFallbackCertificate:       fallbackCert,\n\t\t\tDNSLookupFamily:           ctx.Config.Cluster.DNSLookupFamily,\n\t\t\tClientCertificate:         clientCert,\n\t\t\tRequestHeadersPolicy:      &requestHeadersPolicy,\n\t\t\tResponseHeadersPolicy:     &responseHeadersPolicy,\n\t\t},\n\t}\n\n\tif ctx.Config.GatewayConfig != nil && clients.ResourcesExist(k8s.GatewayAPIResources()...) {\n\t\tdagProcessors = append(dagProcessors, &dag.GatewayAPIProcessor{\n\t\t\tEnableExternalNameService: ctx.Config.EnableExternalNameService,\n\t\t\tFieldLogger:               log.WithField(\"context\", \"GatewayAPIProcessor\"),\n\t\t})\n\t}\n\n\t// The listener processor has to go last since it looks at\n\t// the output of the other processors.\n\tdagProcessors = append(dagProcessors, &dag.ListenerProcessor{})\n\n\tvar configuredSecretRefs []*types.NamespacedName\n\tif fallbackCert != nil {\n\t\tconfiguredSecretRefs = append(configuredSecretRefs, fallbackCert)\n\t}\n\tif clientCert != nil {\n\t\tconfiguredSecretRefs = append(configuredSecretRefs, clientCert)\n\t}\n\n\tbuilder := dag.Builder{\n\t\tSource: dag.KubernetesCache{\n\t\t\tRootNamespaces:       ctx.proxyRootNamespaces(),\n\t\t\tIngressClassName:     ctx.ingressClassName,\n\t\t\tConfiguredSecretRefs: configuredSecretRefs,\n\t\t\tFieldLogger:          log.WithField(\"context\", \"KubernetesCache\"),\n\t\t},\n\t\tProcessors: dagProcessors,\n\t}\n\n\tif ctx.Config.GatewayConfig != nil {\n\n\t\t// Log warning that the Name/Namespace fields in the configuration file are deprecated.\n\t\tif len(ctx.Config.GatewayConfig.Name) > 0 || len(ctx.Config.GatewayConfig.Namespace) > 0 {\n\t\t\tlog.WithField(\"context\", \"configurationFile\").Warn(\"Gateway.Name & Gateway.Namespace have been deprecated and will be removed in Contour v1.18. Please use Gateway.ControllerName instead.\")\n\t\t}\n\n\t\tbuilder.Source.ConfiguredGateway = types.NamespacedName{\n\t\t\tName:      ctx.Config.GatewayConfig.Name,\n\t\t\tNamespace: ctx.Config.GatewayConfig.Namespace,\n\t\t}\n\t}\n\n\t// govet complains about copying the sync.Once that's in the dag.KubernetesCache\n\t// but it's safe to ignore since this function is only called once.\n\t// nolint:govet\n\treturn builder\n}\n\nfunc contains(namespaces []string, ns string) bool {\n\tfor _, namespace := range namespaces {\n\t\tif ns == namespace {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc informOnResource(clients *k8s.Clients, gvr schema.GroupVersionResource, handler cache.ResourceEventHandler) error {\n\tinf, err := clients.InformerForResource(gvr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tinf.AddEventHandler(handler)\n\treturn nil\n}\n", "---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: contour\n  namespace: projectcontour\ndata:\n  contour.yaml: |\n    #\n    # server:\n    #   determine which XDS Server implementation to utilize in Contour.\n    #   xds-server-type: contour\n    #\n    # Specify the Gateway API configuration.\n    # gateway:\n    #   controllerName: projectcontour.io/projectcontour/contour\n    #   name: contour\n    #   namespace: projectcontour\n    #\n    # should contour expect to be running inside a k8s cluster\n    # incluster: true\n    #\n    # path to kubeconfig (if not running inside a k8s cluster)\n    # kubeconfig: /path/to/.kube/config\n    #\n    # Disable RFC-compliant behavior to strip \"Content-Length\" header if\n    # \"Tranfer-Encoding: chunked\" is also set.\n    # disableAllowChunkedLength: false\n    # Disable HTTPProxy permitInsecure field\n    disablePermitInsecure: false\n    tls:\n    # minimum TLS version that Contour will negotiate\n    # minimum-protocol-version: \"1.2\"\n    # TLS ciphers to be supported by Envoy TLS listeners when negotiating\n    # TLS 1.2.\n    # cipher-suites:\n    # - '[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]'\n    # - '[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]'\n    # - 'ECDHE-ECDSA-AES256-GCM-SHA384'\n    # - 'ECDHE-RSA-AES256-GCM-SHA384'\n    # Defines the Kubernetes name/namespace matching a secret to use\n    # as the fallback certificate when requests which don't match the\n    # SNI defined for a vhost.\n      fallback-certificate:\n    #   name: fallback-secret-name\n    #   namespace: projectcontour\n      envoy-client-certificate:\n    #   name: envoy-client-cert-secret-name\n    #   namespace: projectcontour\n    # The following config shows the defaults for the leader election.\n    # leaderelection:\n    #   configmap-name: leader-elect\n    #   configmap-namespace: projectcontour\n    ####\n    # ExternalName Services are disabled by default due to CVE-2021-XXXXX\n    # You can re-enable them by setting this setting to `true`.\n    # This is not recommended without understanding the security implications.\n    # Please see the advisory at https://github.com/projectcontour/contour/security/advisories/GHSA-5ph6-qq5x-7jwc for the details.\n    # enableExternalNameService: false\n    ## \n    ### Logging options\n    # Default setting\n    accesslog-format: envoy\n    # To enable JSON logging in Envoy\n    # accesslog-format: json\n    # The default fields that will be logged are specified below.\n    # To customise this list, just add or remove entries.\n    # The canonical list is available at\n    # https://godoc.org/github.com/projectcontour/contour/internal/envoy#JSONFields\n    # json-fields:\n    #   - \"@timestamp\"\n    #   - \"authority\"\n    #   - \"bytes_received\"\n    #   - \"bytes_sent\"\n    #   - \"downstream_local_address\"\n    #   - \"downstream_remote_address\"\n    #   - \"duration\"\n    #   - \"method\"\n    #   - \"path\"\n    #   - \"protocol\"\n    #   - \"request_id\"\n    #   - \"requested_server_name\"\n    #   - \"response_code\"\n    #   - \"response_flags\"\n    #   - \"uber_trace_id\"\n    #   - \"upstream_cluster\"\n    #   - \"upstream_host\"\n    #   - \"upstream_local_address\"\n    #   - \"upstream_service_time\"\n    #   - \"user_agent\"\n    #   - \"x_forwarded_for\"\n    #\n    # default-http-versions:\n    # - \"HTTP/2\"\n    # - \"HTTP/1.1\"\n    #\n    # The following shows the default proxy timeout settings.\n    # timeouts:\n    #   request-timeout: infinity\n    #   connection-idle-timeout: 60s\n    #   stream-idle-timeout: 5m\n    #   max-connection-duration: infinity\n    #   delayed-close-timeout: 1s\n    #   connection-shutdown-grace-period: 5s\n    #\n    # Envoy cluster settings.\n    # cluster:\n    #   configure the cluster dns lookup family\n    #   valid options are: auto (default), v4, v6\n    #   dns-lookup-family: auto\n    #\n    # Envoy network settings.\n    # network:\n    #   Configure the number of additional ingress proxy hops from the\n    #   right side of the x-forwarded-for HTTP header to trust.\n    #   num-trusted-hops: 0\n    #\n    # Configure an optional global rate limit service.\n    # rateLimitService:\n    #   Identifies the extension service defining the rate limit service,\n    #   formatted as <namespace>/<name>.\n    #   extensionService: projectcontour/ratelimit\n    #   Defines the rate limit domain to pass to the rate limit service.\n    #   Acts as a container for a set of rate limit definitions within\n    #   the RLS.\n    #   domain: contour\n    #   Defines whether to allow requests to proceed when the rate limit\n    #   service fails to respond with a valid rate limit decision within\n    #   the timeout defined on the extension service.\n    #   failOpen: false\n    #   Defines whether to include the X-RateLimit headers X-RateLimit-Limit,\n    #   X-RateLimit-Remaining, and X-RateLimit-Reset (as defined by the IETF\n    #   Internet-Draft linked below), on responses to clients when the Rate\n    #   Limit Service is consulted for a request.\n    #   ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html\n    #   enableXRateLimitHeaders: false\n    #\n    # Global Policy settings.\n    # policy:\n    #   # Default headers to set on all requests (unless set/removed on the HTTPProxy object itself)\n    #   request-headers:\n    #     set:\n    #       # example: the hostname of the Envoy instance that proxied the request\n    #       X-Envoy-Hostname: %HOSTNAME%\n    #       # example: add a l5d-dst-override header to instruct Linkerd what service the request is destined for\n    #       l5d-dst-override: %CONTOUR_SERVICE_NAME%.%CONTOUR_NAMESPACE%.svc.cluster.local:%CONTOUR_SERVICE_PORT%\n    #   # default headers to set on all responses (unless set/removed on the HTTPProxy object itself)\n    #   response-headers:\n    #     set:\n    #       # example: Envoy flags that provide additional details about the response or connection\n    #       X-Envoy-Response-Flags: %RESPONSE_FLAGS%\n    #\n", "# This file is generated from the individual YAML files by generate-gateway-deployment.sh. Do not\n# edit this file directly but instead edit the source files and re-render.\n#\n# Generated from:\n#       examples/contour/00-common.yaml\n#       examples/contour/01-contour-config.yaml\n#       examples/contour/01-crds.yaml\n#       examples/contour/02-job-certgen.yaml\n#       examples/contour/02-rbac.yaml\n#       examples/contour/02-role-contour.yaml\n#       examples/contour/02-service-contour.yaml\n#       examples/contour/02-service-envoy.yaml\n#       examples/contour/03-contour.yaml\n#       examples/contour/03-envoy.yaml\n#       examples/gateway/00-crds.yaml\n#       examples/gateway/01-gatewayclass.yaml\n#       examples/gateway/02-gateway.yaml\n#\n\n---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: projectcontour\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: contour\n  namespace: projectcontour\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: envoy\n  namespace: projectcontour\n\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: contour\n  namespace: projectcontour\ndata:\n  contour.yaml: |\n    #\n    # server:\n    #   determine which XDS Server implementation to utilize in Contour.\n    #   xds-server-type: contour\n    #\n    # Specify the Gateway API configuration.\n    gateway:\n      controllerName: projectcontour.io/projectcontour/contour\n      name: contour\n      namespace: projectcontour\n    #\n    # should contour expect to be running inside a k8s cluster\n    # incluster: true\n    #\n    # path to kubeconfig (if not running inside a k8s cluster)\n    # kubeconfig: /path/to/.kube/config\n    #\n    # Disable RFC-compliant behavior to strip \"Content-Length\" header if\n    # \"Tranfer-Encoding: chunked\" is also set.\n    # disableAllowChunkedLength: false\n    # Disable HTTPProxy permitInsecure field\n    disablePermitInsecure: false\n    tls:\n    # minimum TLS version that Contour will negotiate\n    # minimum-protocol-version: \"1.2\"\n    # TLS ciphers to be supported by Envoy TLS listeners when negotiating\n    # TLS 1.2.\n    # cipher-suites:\n    # - '[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]'\n    # - '[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]'\n    # - 'ECDHE-ECDSA-AES256-GCM-SHA384'\n    # - 'ECDHE-RSA-AES256-GCM-SHA384'\n    # Defines the Kubernetes name/namespace matching a secret to use\n    # as the fallback certificate when requests which don't match the\n    # SNI defined for a vhost.\n      fallback-certificate:\n    #   name: fallback-secret-name\n      namespace: projectcontour\n      envoy-client-certificate:\n    #   name: envoy-client-cert-secret-name\n      namespace: projectcontour\n    # The following config shows the defaults for the leader election.\n    # leaderelection:\n    #   configmap-name: leader-elect\n    #   configmap-namespace: projectcontour\n    ####\n    # ExternalName Services are disabled by default due to CVE-2021-XXXXX\n    # You can re-enable them by setting this setting to `true`.\n    # This is not recommended without understanding the security implications.\n    # Please see the advisory at https://github.com/projectcontour/contour/security/advisories/GHSA-5ph6-qq5x-7jwc for the details.\n    # enableExternalNameService: false\n    ##\n    ### Logging options\n    # Default setting\n    accesslog-format: envoy\n    # To enable JSON logging in Envoy\n    # accesslog-format: json\n    # The default fields that will be logged are specified below.\n    # To customise this list, just add or remove entries.\n    # The canonical list is available at\n    # https://godoc.org/github.com/projectcontour/contour/internal/envoy#JSONFields\n    # json-fields:\n    #   - \"@timestamp\"\n    #   - \"authority\"\n    #   - \"bytes_received\"\n    #   - \"bytes_sent\"\n    #   - \"downstream_local_address\"\n    #   - \"downstream_remote_address\"\n    #   - \"duration\"\n    #   - \"method\"\n    #   - \"path\"\n    #   - \"protocol\"\n    #   - \"request_id\"\n    #   - \"requested_server_name\"\n    #   - \"response_code\"\n    #   - \"response_flags\"\n    #   - \"uber_trace_id\"\n    #   - \"upstream_cluster\"\n    #   - \"upstream_host\"\n    #   - \"upstream_local_address\"\n    #   - \"upstream_service_time\"\n    #   - \"user_agent\"\n    #   - \"x_forwarded_for\"\n    #\n    # default-http-versions:\n    # - \"HTTP/2\"\n    # - \"HTTP/1.1\"\n    #\n    # The following shows the default proxy timeout settings.\n    # timeouts:\n    #   request-timeout: infinity\n    #   connection-idle-timeout: 60s\n    #   stream-idle-timeout: 5m\n    #   max-connection-duration: infinity\n    #   delayed-close-timeout: 1s\n    #   connection-shutdown-grace-period: 5s\n    #\n    # Envoy cluster settings.\n    # cluster:\n    #   configure the cluster dns lookup family\n    #   valid options are: auto (default), v4, v6\n    #   dns-lookup-family: auto\n    #\n    # Envoy network settings.\n    # network:\n    #   Configure the number of additional ingress proxy hops from the\n    #   right side of the x-forwarded-for HTTP header to trust.\n    #   num-trusted-hops: 0\n    #\n    # Configure an optional global rate limit service.\n    # rateLimitService:\n    #   Identifies the extension service defining the rate limit service,\n    #   formatted as <namespace>/<name>.\n    #   extensionService: projectcontour/ratelimit\n    #   Defines the rate limit domain to pass to the rate limit service.\n    #   Acts as a container for a set of rate limit definitions within\n    #   the RLS.\n    #   domain: contour\n    #   Defines whether to allow requests to proceed when the rate limit\n    #   service fails to respond with a valid rate limit decision within\n    #   the timeout defined on the extension service.\n    #   failOpen: false\n    #   Defines whether to include the X-RateLimit headers X-RateLimit-Limit,\n    #   X-RateLimit-Remaining, and X-RateLimit-Reset (as defined by the IETF\n    #   Internet-Draft linked below), on responses to clients when the Rate\n    #   Limit Service is consulted for a request.\n    #   ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html\n    #   enableXRateLimitHeaders: false\n    #\n    # Global Policy settings.\n    # policy:\n    #   # Default headers to set on all requests (unless set/removed on the HTTPProxy object itself)\n    #   request-headers:\n    #     set:\n    #       # example: the hostname of the Envoy instance that proxied the request\n    #       X-Envoy-Hostname: %HOSTNAME%\n    #       # example: add a l5d-dst-override header to instruct Linkerd what service the request is destined for\n    #       l5d-dst-override: %CONTOUR_SERVICE_NAME%.%CONTOUR_NAMESPACE%.svc.cluster.local:%CONTOUR_SERVICE_PORT%\n    #   # default headers to set on all responses (unless set/removed on the HTTPProxy object itself)\n    #   response-headers:\n    #     set:\n    #       # example: Envoy flags that provide additional details about the response or connection\n    #       X-Envoy-Response-Flags: %RESPONSE_FLAGS%\n    #\n\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: extensionservices.projectcontour.io\nspec:\n  preserveUnknownFields: false\n  group: projectcontour.io\n  names:\n    kind: ExtensionService\n    listKind: ExtensionServiceList\n    plural: extensionservices\n    shortNames:\n    - extensionservice\n    - extensionservices\n    singular: extensionservice\n  scope: Namespaced\n  versions:\n  - name: v1alpha1\n    schema:\n      openAPIV3Schema:\n        description: ExtensionService is the schema for the Contour extension services\n          API. An ExtensionService resource binds a network service to the Contour\n          API so that Contour API features can be implemented by collaborating components.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: ExtensionServiceSpec defines the desired state of an ExtensionService\n              resource.\n            properties:\n              loadBalancerPolicy:\n                description: The policy for load balancing GRPC service requests.\n                  Note that the `Cookie` and `RequestHash` load balancing strategies\n                  cannot be used here.\n                properties:\n                  requestHashPolicies:\n                    description: RequestHashPolicies contains a list of hash policies\n                      to apply when the `RequestHash` load balancing strategy is chosen.\n                      If an element of the supplied list of hash policies is invalid,\n                      it will be ignored. If the list of hash policies is empty after\n                      validation, the load balancing strategy will fall back the the\n                      default `RoundRobin`.\n                    items:\n                      description: RequestHashPolicy contains configuration for an\n                        individual hash policy on a request attribute.\n                      properties:\n                        headerHashOptions:\n                          description: HeaderHashOptions should be set when request\n                            header hash based load balancing is desired. It must be\n                            the only hash option field set, otherwise this request\n                            hash policy object will be ignored.\n                          properties:\n                            headerName:\n                              description: HeaderName is the name of the HTTP request\n                                header that will be used to calculate the hash key.\n                                If the header specified is not present on a request,\n                                no hash will be produced.\n                              minLength: 1\n                              type: string\n                          type: object\n                        terminal:\n                          description: Terminal is a flag that allows for short-circuiting\n                            computing of a hash for a given request. If set to true,\n                            and the request attribute specified in the attribute hash\n                            options is present, no further hash policies will be used\n                            to calculate a hash for the request.\n                          type: boolean\n                      type: object\n                    type: array\n                  strategy:\n                    description: Strategy specifies the policy used to balance requests\n                      across the pool of backend pods. Valid policy names are `Random`,\n                      `RoundRobin`, `WeightedLeastRequest`, `Cookie`, and `RequestHash`.\n                      If an unknown strategy name is specified or no policy is supplied,\n                      the default `RoundRobin` policy is used.\n                    type: string\n                type: object\n              protocol:\n                description: Protocol may be used to specify (or override) the protocol\n                  used to reach this Service. Values may be h2 or h2c. If omitted,\n                  protocol-selection falls back on Service annotations.\n                enum:\n                - h2\n                - h2c\n                type: string\n              protocolVersion:\n                description: This field sets the version of the GRPC protocol that\n                  Envoy uses to send requests to the extension service. Since Contour\n                  always uses the v3 Envoy API, this is currently fixed at \"v3\". However,\n                  other protocol options will be available in future.\n                enum:\n                - v3\n                type: string\n              services:\n                description: Services specifies the set of Kubernetes Service resources\n                  that receive GRPC extension API requests. If no weights are specified\n                  for any of the entries in this array, traffic will be spread evenly\n                  across all the services. Otherwise, traffic is balanced proportionally\n                  to the Weight field in each entry.\n                items:\n                  description: ExtensionServiceTarget defines an Kubernetes Service\n                    to target with extension service traffic.\n                  properties:\n                    name:\n                      description: Name is the name of Kubernetes service that will\n                        accept service traffic.\n                      type: string\n                    port:\n                      description: Port (defined as Integer) to proxy traffic to since\n                        a service can have multiple defined.\n                      exclusiveMaximum: true\n                      maximum: 65536\n                      minimum: 1\n                      type: integer\n                    weight:\n                      description: Weight defines proportion of traffic to balance\n                        to the Kubernetes Service.\n                      format: int32\n                      type: integer\n                  required:\n                  - name\n                  - port\n                  type: object\n                minItems: 1\n                type: array\n              timeoutPolicy:\n                description: The timeout policy for requests to the services.\n                properties:\n                  idle:\n                    description: Timeout after which, if there are no active requests\n                      for this route, the connection between Envoy and the backend\n                      or Envoy and the external client will be closed. If not specified,\n                      there is no per-route idle timeout, though a connection manager-wide\n                      stream_idle_timeout default of 5m still applies.\n                    pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                    type: string\n                  response:\n                    description: Timeout for receiving a response from the server\n                      after processing a request from client. If not supplied, Envoy's\n                      default value of 15s applies.\n                    pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                    type: string\n                type: object\n              validation:\n                description: UpstreamValidation defines how to verify the backend\n                  service's certificate\n                properties:\n                  caSecret:\n                    description: Name of the Kubernetes secret be used to validate\n                      the certificate presented by the backend\n                    type: string\n                  subjectName:\n                    description: Key which is expected to be present in the 'subjectAltName'\n                      of the presented certificate\n                    type: string\n                required:\n                - caSecret\n                - subjectName\n                type: object\n            required:\n            - services\n            type: object\n          status:\n            description: ExtensionServiceStatus defines the observed state of an ExtensionService\n              resource.\n            properties:\n              conditions:\n                description: \"Conditions contains the current status of the ExtensionService\n                  resource. \\n Contour will update a single condition, `Valid`, that\n                  is in normal-true polarity. \\n Contour will not modify any other\n                  Conditions set in this block, in case some other controller wants\n                  to add a Condition.\"\n                items:\n                  description: \"DetailedCondition is an extension of the normal Kubernetes\n                    conditions, with two extra fields to hold sub-conditions, which\n                    provide more detailed reasons for the state (True or False) of\n                    the condition. \\n `errors` holds information about sub-conditions\n                    which are fatal to that condition and render its state False.\n                    \\n `warnings` holds information about sub-conditions which are\n                    not fatal to that condition and do not force the state to be False.\n                    \\n Remember that Conditions have a type, a status, and a reason.\n                    \\n The type is the type of the condition, the most important one\n                    in this CRD set is `Valid`. `Valid` is a positive-polarity condition:\n                    when it is `status: true` there are no problems. \\n In more detail,\n                    `status: true` means that the object is has been ingested into\n                    Contour with no errors. `warnings` may still be present, and will\n                    be indicated in the Reason field. There must be zero entries in\n                    the `errors` slice in this case. \\n `Valid`, `status: false` means\n                    that the object has had one or more fatal errors during processing\n                    into Contour.  The details of the errors will be present under\n                    the `errors` field. There must be at least one error in the `errors`\n                    slice if `status` is `false`. \\n For DetailedConditions of types\n                    other than `Valid`, the Condition must be in the negative polarity.\n                    When they have `status` `true`, there is an error. There must\n                    be at least one entry in the `errors` Subcondition slice. When\n                    they have `status` `false`, there are no serious errors, and there\n                    must be zero entries in the `errors` slice. In either case, there\n                    may be entries in the `warnings` slice. \\n Regardless of the polarity,\n                    the `reason` and `message` fields must be updated with either\n                    the detail of the reason (if there is one and only one entry in\n                    total across both the `errors` and `warnings` slices), or `MultipleReasons`\n                    if there is more than one entry.\"\n                  properties:\n                    errors:\n                      description: \"Errors contains a slice of relevant error subconditions\n                        for this object. \\n Subconditions are expected to appear when\n                        relevant (when there is a error), and disappear when not relevant.\n                        An empty slice here indicates no errors.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                    lastTransitionTime:\n                      description: lastTransitionTime is the last time the condition\n                        transitioned from one status to another. This should be when\n                        the underlying condition changed.  If that is not known, then\n                        using the time when the API field changed is acceptable.\n                      format: date-time\n                      type: string\n                    message:\n                      description: message is a human readable message indicating\n                        details about the transition. This may be an empty string.\n                      maxLength: 32768\n                      type: string\n                    observedGeneration:\n                      description: observedGeneration represents the .metadata.generation\n                        that the condition was set based upon. For instance, if .metadata.generation\n                        is currently 12, but the .status.conditions[x].observedGeneration\n                        is 9, the condition is out of date with respect to the current\n                        state of the instance.\n                      format: int64\n                      minimum: 0\n                      type: integer\n                    reason:\n                      description: reason contains a programmatic identifier indicating\n                        the reason for the condition's last transition. Producers\n                        of specific condition types may define expected values and\n                        meanings for this field, and whether the values are considered\n                        a guaranteed API. The value should be a CamelCase string.\n                        This field may not be empty.\n                      maxLength: 1024\n                      minLength: 1\n                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                      type: string\n                    status:\n                      description: status of the condition, one of True, False, Unknown.\n                      enum:\n                      - \"True\"\n                      - \"False\"\n                      - Unknown\n                      type: string\n                    type:\n                      description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                        --- Many .condition.type values are consistent across resources\n                        like Available, but because arbitrary conditions can be useful\n                        (see .node.status.conditions), the ability to deconflict is\n                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                      maxLength: 316\n                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                      type: string\n                    warnings:\n                      description: \"Warnings contains a slice of relevant warning\n                        subconditions for this object. \\n Subconditions are expected\n                        to appear when relevant (when there is a warning), and disappear\n                        when not relevant. An empty slice here indicates no warnings.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                  required:\n                  - lastTransitionTime\n                  - message\n                  - reason\n                  - status\n                  - type\n                  type: object\n                type: array\n                x-kubernetes-list-map-keys:\n                - type\n                x-kubernetes-list-type: map\n            type: object\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: httpproxies.projectcontour.io\nspec:\n  preserveUnknownFields: false\n  group: projectcontour.io\n  names:\n    kind: HTTPProxy\n    listKind: HTTPProxyList\n    plural: httpproxies\n    shortNames:\n    - proxy\n    - proxies\n    singular: httpproxy\n  scope: Namespaced\n  versions:\n  - additionalPrinterColumns:\n    - description: Fully qualified domain name\n      jsonPath: .spec.virtualhost.fqdn\n      name: FQDN\n      type: string\n    - description: Secret with TLS credentials\n      jsonPath: .spec.virtualhost.tls.secretName\n      name: TLS Secret\n      type: string\n    - description: The current status of the HTTPProxy\n      jsonPath: .status.currentStatus\n      name: Status\n      type: string\n    - description: Description of the current status\n      jsonPath: .status.description\n      name: Status Description\n      type: string\n    name: v1\n    schema:\n      openAPIV3Schema:\n        description: HTTPProxy is an Ingress CRD specification.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: HTTPProxySpec defines the spec of the CRD.\n            properties:\n              includes:\n                description: Includes allow for specific routing configuration to\n                  be included from another HTTPProxy, possibly in another namespace.\n                items:\n                  description: Include describes a set of policies that can be applied\n                    to an HTTPProxy in a namespace.\n                  properties:\n                    conditions:\n                      description: 'Conditions are a set of rules that are applied\n                        to included HTTPProxies. In effect, they are added onto the\n                        Conditions of included HTTPProxy Route structs. When applied,\n                        they are merged using AND, with one exception: There can be\n                        only one Prefix MatchCondition per Conditions slice. More\n                        than one Prefix, or contradictory Conditions, will make the\n                        include invalid.'\n                      items:\n                        description: MatchCondition are a general holder for matching\n                          rules for HTTPProxies. One of Prefix or Header must be provided.\n                        properties:\n                          header:\n                            description: Header specifies the header condition to\n                              match.\n                            properties:\n                              contains:\n                                description: Contains specifies a substring that must\n                                  be present in the header value.\n                                type: string\n                              exact:\n                                description: Exact specifies a string that the header\n                                  value must be equal to.\n                                type: string\n                              name:\n                                description: Name is the name of the header to match\n                                  against. Name is required. Header names are case\n                                  insensitive.\n                                type: string\n                              notcontains:\n                                description: NotContains specifies a substring that\n                                  must not be present in the header value.\n                                type: string\n                              notexact:\n                                description: NoExact specifies a string that the header\n                                  value must not be equal to. The condition is true\n                                  if the header has any other value.\n                                type: string\n                              notpresent:\n                                description: NotPresent specifies that condition is\n                                  true when the named header is not present. Note\n                                  that setting NotPresent to false does not make the\n                                  condition true if the named header is present.\n                                type: boolean\n                              present:\n                                description: Present specifies that condition is true\n                                  when the named header is present, regardless of\n                                  its value. Note that setting Present to false does\n                                  not make the condition true if the named header\n                                  is absent.\n                                type: boolean\n                            required:\n                            - name\n                            type: object\n                          prefix:\n                            description: Prefix defines a prefix match for a request.\n                            type: string\n                        type: object\n                      type: array\n                    name:\n                      description: Name of the HTTPProxy\n                      type: string\n                    namespace:\n                      description: Namespace of the HTTPProxy to include. Defaults\n                        to the current namespace if not supplied.\n                      type: string\n                  required:\n                  - name\n                  type: object\n                type: array\n              routes:\n                description: Routes are the ingress routes. If TCPProxy is present,\n                  Routes is ignored.\n                items:\n                  description: Route contains the set of routes for a virtual host.\n                  properties:\n                    authPolicy:\n                      description: AuthPolicy updates the authorization policy that\n                        was set on the root HTTPProxy object for client requests that\n                        match this route.\n                      properties:\n                        context:\n                          additionalProperties:\n                            type: string\n                          description: Context is a set of key/value pairs that are\n                            sent to the authentication server in the check request.\n                            If a context is provided at an enclosing scope, the entries\n                            are merged such that the inner scope overrides matching\n                            keys from the outer scope.\n                          type: object\n                        disabled:\n                          description: When true, this field disables client request\n                            authentication for the scope of the policy.\n                          type: boolean\n                      type: object\n                    conditions:\n                      description: 'Conditions are a set of rules that are applied\n                        to a Route. When applied, they are merged using AND, with\n                        one exception: There can be only one Prefix MatchCondition\n                        per Conditions slice. More than one Prefix, or contradictory\n                        Conditions, will make the route invalid.'\n                      items:\n                        description: MatchCondition are a general holder for matching\n                          rules for HTTPProxies. One of Prefix or Header must be provided.\n                        properties:\n                          header:\n                            description: Header specifies the header condition to\n                              match.\n                            properties:\n                              contains:\n                                description: Contains specifies a substring that must\n                                  be present in the header value.\n                                type: string\n                              exact:\n                                description: Exact specifies a string that the header\n                                  value must be equal to.\n                                type: string\n                              name:\n                                description: Name is the name of the header to match\n                                  against. Name is required. Header names are case\n                                  insensitive.\n                                type: string\n                              notcontains:\n                                description: NotContains specifies a substring that\n                                  must not be present in the header value.\n                                type: string\n                              notexact:\n                                description: NoExact specifies a string that the header\n                                  value must not be equal to. The condition is true\n                                  if the header has any other value.\n                                type: string\n                              notpresent:\n                                description: NotPresent specifies that condition is\n                                  true when the named header is not present. Note\n                                  that setting NotPresent to false does not make the\n                                  condition true if the named header is present.\n                                type: boolean\n                              present:\n                                description: Present specifies that condition is true\n                                  when the named header is present, regardless of\n                                  its value. Note that setting Present to false does\n                                  not make the condition true if the named header\n                                  is absent.\n                                type: boolean\n                            required:\n                            - name\n                            type: object\n                          prefix:\n                            description: Prefix defines a prefix match for a request.\n                            type: string\n                        type: object\n                      type: array\n                    enableWebsockets:\n                      description: Enables websocket support for the route.\n                      type: boolean\n                    healthCheckPolicy:\n                      description: The health check policy for this route.\n                      properties:\n                        healthyThresholdCount:\n                          description: The number of healthy health checks required\n                            before a host is marked healthy\n                          format: int64\n                          minimum: 0\n                          type: integer\n                        host:\n                          description: The value of the host header in the HTTP health\n                            check request. If left empty (default value), the name\n                            \"contour-envoy-healthcheck\" will be used.\n                          type: string\n                        intervalSeconds:\n                          description: The interval (seconds) between health checks\n                          format: int64\n                          type: integer\n                        path:\n                          description: HTTP endpoint used to perform health checks\n                            on upstream service\n                          type: string\n                        timeoutSeconds:\n                          description: The time to wait (seconds) for a health check\n                            response\n                          format: int64\n                          type: integer\n                        unhealthyThresholdCount:\n                          description: The number of unhealthy health checks required\n                            before a host is marked unhealthy\n                          format: int64\n                          minimum: 0\n                          type: integer\n                      required:\n                      - path\n                      type: object\n                    loadBalancerPolicy:\n                      description: The load balancing policy for this route.\n                      properties:\n                        requestHashPolicies:\n                          description: RequestHashPolicies contains a list of hash\n                            policies to apply when the `RequestHash` load balancing\n                            strategy is chosen. If an element of the supplied list\n                            of hash policies is invalid, it will be ignored. If the\n                            list of hash policies is empty after validation, the load\n                            balancing strategy will fall back the the default `RoundRobin`.\n                          items:\n                            description: RequestHashPolicy contains configuration\n                              for an individual hash policy on a request attribute.\n                            properties:\n                              headerHashOptions:\n                                description: HeaderHashOptions should be set when\n                                  request header hash based load balancing is desired.\n                                  It must be the only hash option field set, otherwise\n                                  this request hash policy object will be ignored.\n                                properties:\n                                  headerName:\n                                    description: HeaderName is the name of the HTTP\n                                      request header that will be used to calculate\n                                      the hash key. If the header specified is not\n                                      present on a request, no hash will be produced.\n                                    minLength: 1\n                                    type: string\n                                type: object\n                              terminal:\n                                description: Terminal is a flag that allows for short-circuiting\n                                  computing of a hash for a given request. If set\n                                  to true, and the request attribute specified in\n                                  the attribute hash options is present, no further\n                                  hash policies will be used to calculate a hash for\n                                  the request.\n                                type: boolean\n                            type: object\n                          type: array\n                        strategy:\n                          description: Strategy specifies the policy used to balance\n                            requests across the pool of backend pods. Valid policy\n                            names are `Random`, `RoundRobin`, `WeightedLeastRequest`,\n                            `Cookie`, and `RequestHash`. If an unknown strategy name\n                            is specified or no policy is supplied, the default `RoundRobin`\n                            policy is used.\n                          type: string\n                      type: object\n                    pathRewritePolicy:\n                      description: The policy for rewriting the path of the request\n                        URL after the request has been routed to a Service.\n                      properties:\n                        replacePrefix:\n                          description: ReplacePrefix describes how the path prefix\n                            should be replaced.\n                          items:\n                            description: ReplacePrefix describes a path prefix replacement.\n                            properties:\n                              prefix:\n                                description: \"Prefix specifies the URL path prefix\n                                  to be replaced. \\n If Prefix is specified, it must\n                                  exactly match the MatchCondition prefix that is\n                                  rendered by the chain of including HTTPProxies and\n                                  only that path prefix will be replaced by Replacement.\n                                  This allows HTTPProxies that are included through\n                                  multiple roots to only replace specific path prefixes,\n                                  leaving others unmodified. \\n If Prefix is not specified,\n                                  all routing prefixes rendered by the include chain\n                                  will be replaced.\"\n                                minLength: 1\n                                type: string\n                              replacement:\n                                description: Replacement is the string that the routing\n                                  path prefix will be replaced with. This must not\n                                  be empty.\n                                minLength: 1\n                                type: string\n                            required:\n                            - replacement\n                            type: object\n                          type: array\n                      type: object\n                    permitInsecure:\n                      description: Allow this path to respond to insecure requests\n                        over HTTP which are normally not permitted when a `virtualhost.tls`\n                        block is present.\n                      type: boolean\n                    rateLimitPolicy:\n                      description: The policy for rate limiting on the route.\n                      properties:\n                        global:\n                          description: Global defines global rate limiting parameters,\n                            i.e. parameters defining descriptors that are sent to\n                            an external rate limit service (RLS) for a rate limit\n                            decision on each request.\n                          properties:\n                            descriptors:\n                              description: Descriptors defines the list of descriptors\n                                that will be generated and sent to the rate limit\n                                service. Each descriptor contains 1+ key-value pair\n                                entries.\n                              items:\n                                description: RateLimitDescriptor defines a list of\n                                  key-value pair generators.\n                                properties:\n                                  entries:\n                                    description: Entries is the list of key-value\n                                      pair generators.\n                                    items:\n                                      description: RateLimitDescriptorEntry is a key-value\n                                        pair generator. Exactly one field on this\n                                        struct must be non-nil.\n                                      properties:\n                                        genericKey:\n                                          description: GenericKey defines a descriptor\n                                            entry with a static key and value.\n                                          properties:\n                                            key:\n                                              description: Key defines the key of\n                                                the descriptor entry. If not set,\n                                                the key is set to \"generic_key\".\n                                              type: string\n                                            value:\n                                              description: Value defines the value\n                                                of the descriptor entry.\n                                              minLength: 1\n                                              type: string\n                                          type: object\n                                        remoteAddress:\n                                          description: RemoteAddress defines a descriptor\n                                            entry with a key of \"remote_address\" and\n                                            a value equal to the client's IP address\n                                            (from x-forwarded-for).\n                                          type: object\n                                        requestHeader:\n                                          description: RequestHeader defines a descriptor\n                                            entry that's populated only if a given\n                                            header is present on the request. The\n                                            descriptor key is static, and the descriptor\n                                            value is equal to the value of the header.\n                                          properties:\n                                            descriptorKey:\n                                              description: DescriptorKey defines the\n                                                key to use on the descriptor entry.\n                                              minLength: 1\n                                              type: string\n                                            headerName:\n                                              description: HeaderName defines the\n                                                name of the header to look for on\n                                                the request.\n                                              minLength: 1\n                                              type: string\n                                          type: object\n                                        requestHeaderValueMatch:\n                                          description: RequestHeaderValueMatch defines\n                                            a descriptor entry that's populated if\n                                            the request's headers match a set of 1+\n                                            match criteria. The descriptor key is\n                                            \"header_match\", and the descriptor value\n                                            is static.\n                                          properties:\n                                            expectMatch:\n                                              default: true\n                                              description: ExpectMatch defines whether\n                                                the request must positively match\n                                                the match criteria in order to generate\n                                                a descriptor entry (i.e. true), or\n                                                not match the match criteria in order\n                                                to generate a descriptor entry (i.e.\n                                                false). The default is true.\n                                              type: boolean\n                                            headers:\n                                              description: Headers is a list of 1+\n                                                match criteria to apply against the\n                                                request to determine whether to populate\n                                                the descriptor entry or not.\n                                              items:\n                                                description: HeaderMatchCondition\n                                                  specifies how to conditionally match\n                                                  against HTTP headers. The Name field\n                                                  is required, but only one of the\n                                                  remaining fields should be be provided.\n                                                properties:\n                                                  contains:\n                                                    description: Contains specifies\n                                                      a substring that must be present\n                                                      in the header value.\n                                                    type: string\n                                                  exact:\n                                                    description: Exact specifies a\n                                                      string that the header value\n                                                      must be equal to.\n                                                    type: string\n                                                  name:\n                                                    description: Name is the name\n                                                      of the header to match against.\n                                                      Name is required. Header names\n                                                      are case insensitive.\n                                                    type: string\n                                                  notcontains:\n                                                    description: NotContains specifies\n                                                      a substring that must not be\n                                                      present in the header value.\n                                                    type: string\n                                                  notexact:\n                                                    description: NoExact specifies\n                                                      a string that the header value\n                                                      must not be equal to. The condition\n                                                      is true if the header has any\n                                                      other value.\n                                                    type: string\n                                                  notpresent:\n                                                    description: NotPresent specifies\n                                                      that condition is true when\n                                                      the named header is not present.\n                                                      Note that setting NotPresent\n                                                      to false does not make the condition\n                                                      true if the named header is\n                                                      present.\n                                                    type: boolean\n                                                  present:\n                                                    description: Present specifies\n                                                      that condition is true when\n                                                      the named header is present,\n                                                      regardless of its value. Note\n                                                      that setting Present to false\n                                                      does not make the condition\n                                                      true if the named header is\n                                                      absent.\n                                                    type: boolean\n                                                required:\n                                                - name\n                                                type: object\n                                              minItems: 1\n                                              type: array\n                                            value:\n                                              description: Value defines the value\n                                                of the descriptor entry.\n                                              minLength: 1\n                                              type: string\n                                          type: object\n                                      type: object\n                                    minItems: 1\n                                    type: array\n                                type: object\n                              minItems: 1\n                              type: array\n                          type: object\n                        local:\n                          description: Local defines local rate limiting parameters,\n                            i.e. parameters for rate limiting that occurs within each\n                            Envoy pod as requests are handled.\n                          properties:\n                            burst:\n                              description: Burst defines the number of requests above\n                                the requests per unit that should be allowed within\n                                a short period of time.\n                              format: int32\n                              type: integer\n                            requests:\n                              description: Requests defines how many requests per\n                                unit of time should be allowed before rate limiting\n                                occurs.\n                              format: int32\n                              minimum: 1\n                              type: integer\n                            responseHeadersToAdd:\n                              description: ResponseHeadersToAdd is an optional list\n                                of response headers to set when a request is rate-limited.\n                              items:\n                                description: HeaderValue represents a header name/value\n                                  pair\n                                properties:\n                                  name:\n                                    description: Name represents a key of a header\n                                    minLength: 1\n                                    type: string\n                                  value:\n                                    description: Value represents the value of a header\n                                      specified by a key\n                                    minLength: 1\n                                    type: string\n                                required:\n                                - name\n                                - value\n                                type: object\n                              type: array\n                            responseStatusCode:\n                              description: ResponseStatusCode is the HTTP status code\n                                to use for responses to rate-limited requests. Codes\n                                must be in the 400-599 range (inclusive). If not specified,\n                                the Envoy default of 429 (Too Many Requests) is used.\n                              format: int32\n                              maximum: 599\n                              minimum: 400\n                              type: integer\n                            unit:\n                              description: Unit defines the period of time within\n                                which requests over the limit will be rate limited.\n                                Valid values are \"second\", \"minute\" and \"hour\".\n                              enum:\n                              - second\n                              - minute\n                              - hour\n                              type: string\n                          required:\n                          - requests\n                          - unit\n                          type: object\n                      type: object\n                    requestHeadersPolicy:\n                      description: The policy for managing request headers during\n                        proxying.\n                      properties:\n                        remove:\n                          description: Remove specifies a list of HTTP header names\n                            to remove.\n                          items:\n                            type: string\n                          type: array\n                        set:\n                          description: Set specifies a list of HTTP header values\n                            that will be set in the HTTP header. If the header does\n                            not exist it will be added, otherwise it will be overwritten\n                            with the new value.\n                          items:\n                            description: HeaderValue represents a header name/value\n                              pair\n                            properties:\n                              name:\n                                description: Name represents a key of a header\n                                minLength: 1\n                                type: string\n                              value:\n                                description: Value represents the value of a header\n                                  specified by a key\n                                minLength: 1\n                                type: string\n                            required:\n                            - name\n                            - value\n                            type: object\n                          type: array\n                      type: object\n                    responseHeadersPolicy:\n                      description: The policy for managing response headers during\n                        proxying. Rewriting the 'Host' header is not supported.\n                      properties:\n                        remove:\n                          description: Remove specifies a list of HTTP header names\n                            to remove.\n                          items:\n                            type: string\n                          type: array\n                        set:\n                          description: Set specifies a list of HTTP header values\n                            that will be set in the HTTP header. If the header does\n                            not exist it will be added, otherwise it will be overwritten\n                            with the new value.\n                          items:\n                            description: HeaderValue represents a header name/value\n                              pair\n                            properties:\n                              name:\n                                description: Name represents a key of a header\n                                minLength: 1\n                                type: string\n                              value:\n                                description: Value represents the value of a header\n                                  specified by a key\n                                minLength: 1\n                                type: string\n                            required:\n                            - name\n                            - value\n                            type: object\n                          type: array\n                      type: object\n                    retryPolicy:\n                      description: The retry policy for this route.\n                      properties:\n                        count:\n                          description: NumRetries is maximum allowed number of retries.\n                            If not supplied, the number of retries is one.\n                          format: int64\n                          minimum: 0\n                          type: integer\n                        perTryTimeout:\n                          description: PerTryTimeout specifies the timeout per retry\n                            attempt. Ignored if NumRetries is not supplied.\n                          pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                          type: string\n                        retriableStatusCodes:\n                          description: \"RetriableStatusCodes specifies the HTTP status\n                            codes that should be retried. \\n This field is only respected\n                            when you include `retriable-status-codes` in the `RetryOn`\n                            field.\"\n                          items:\n                            format: int32\n                            type: integer\n                          type: array\n                        retryOn:\n                          description: \"RetryOn specifies the conditions on which\n                            to retry a request. \\n Supported [HTTP conditions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on):\n                            \\n - `5xx` - `gateway-error` - `reset` - `connect-failure`\n                            - `retriable-4xx` - `refused-stream` - `retriable-status-codes`\n                            - `retriable-headers` \\n Supported [gRPC conditions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-grpc-on):\n                            \\n - `cancelled` - `deadline-exceeded` - `internal` -\n                            `resource-exhausted` - `unavailable`\"\n                          items:\n                            description: RetryOn is a string type alias with validation\n                              to ensure that the value is valid.\n                            enum:\n                            - 5xx\n                            - gateway-error\n                            - reset\n                            - connect-failure\n                            - retriable-4xx\n                            - refused-stream\n                            - retriable-status-codes\n                            - retriable-headers\n                            - cancelled\n                            - deadline-exceeded\n                            - internal\n                            - resource-exhausted\n                            - unavailable\n                            type: string\n                          type: array\n                      type: object\n                    services:\n                      description: Services are the services to proxy traffic.\n                      items:\n                        description: Service defines an Kubernetes Service to proxy\n                          traffic.\n                        properties:\n                          mirror:\n                            description: If Mirror is true the Service will receive\n                              a read only mirror of the traffic for this route.\n                            type: boolean\n                          name:\n                            description: Name is the name of Kubernetes service to\n                              proxy traffic. Names defined here will be used to look\n                              up corresponding endpoints which contain the ips to\n                              route.\n                            type: string\n                          port:\n                            description: Port (defined as Integer) to proxy traffic\n                              to since a service can have multiple defined.\n                            exclusiveMaximum: true\n                            maximum: 65536\n                            minimum: 1\n                            type: integer\n                          protocol:\n                            description: Protocol may be used to specify (or override)\n                              the protocol used to reach this Service. Values may\n                              be tls, h2, h2c. If omitted, protocol-selection falls\n                              back on Service annotations.\n                            enum:\n                            - h2\n                            - h2c\n                            - tls\n                            type: string\n                          requestHeadersPolicy:\n                            description: The policy for managing request headers during\n                              proxying. Rewriting the 'Host' header is not supported.\n                            properties:\n                              remove:\n                                description: Remove specifies a list of HTTP header\n                                  names to remove.\n                                items:\n                                  type: string\n                                type: array\n                              set:\n                                description: Set specifies a list of HTTP header values\n                                  that will be set in the HTTP header. If the header\n                                  does not exist it will be added, otherwise it will\n                                  be overwritten with the new value.\n                                items:\n                                  description: HeaderValue represents a header name/value\n                                    pair\n                                  properties:\n                                    name:\n                                      description: Name represents a key of a header\n                                      minLength: 1\n                                      type: string\n                                    value:\n                                      description: Value represents the value of a\n                                        header specified by a key\n                                      minLength: 1\n                                      type: string\n                                  required:\n                                  - name\n                                  - value\n                                  type: object\n                                type: array\n                            type: object\n                          responseHeadersPolicy:\n                            description: The policy for managing response headers\n                              during proxying. Rewriting the 'Host' header is not\n                              supported.\n                            properties:\n                              remove:\n                                description: Remove specifies a list of HTTP header\n                                  names to remove.\n                                items:\n                                  type: string\n                                type: array\n                              set:\n                                description: Set specifies a list of HTTP header values\n                                  that will be set in the HTTP header. If the header\n                                  does not exist it will be added, otherwise it will\n                                  be overwritten with the new value.\n                                items:\n                                  description: HeaderValue represents a header name/value\n                                    pair\n                                  properties:\n                                    name:\n                                      description: Name represents a key of a header\n                                      minLength: 1\n                                      type: string\n                                    value:\n                                      description: Value represents the value of a\n                                        header specified by a key\n                                      minLength: 1\n                                      type: string\n                                  required:\n                                  - name\n                                  - value\n                                  type: object\n                                type: array\n                            type: object\n                          validation:\n                            description: UpstreamValidation defines how to verify\n                              the backend service's certificate\n                            properties:\n                              caSecret:\n                                description: Name of the Kubernetes secret be used\n                                  to validate the certificate presented by the backend\n                                type: string\n                              subjectName:\n                                description: Key which is expected to be present in\n                                  the 'subjectAltName' of the presented certificate\n                                type: string\n                            required:\n                            - caSecret\n                            - subjectName\n                            type: object\n                          weight:\n                            description: Weight defines percentage of traffic to balance\n                              traffic\n                            format: int64\n                            minimum: 0\n                            type: integer\n                        required:\n                        - name\n                        - port\n                        type: object\n                      minItems: 1\n                      type: array\n                    timeoutPolicy:\n                      description: The timeout policy for this route.\n                      properties:\n                        idle:\n                          description: Timeout after which, if there are no active\n                            requests for this route, the connection between Envoy\n                            and the backend or Envoy and the external client will\n                            be closed. If not specified, there is no per-route idle\n                            timeout, though a connection manager-wide stream_idle_timeout\n                            default of 5m still applies.\n                          pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                          type: string\n                        response:\n                          description: Timeout for receiving a response from the server\n                            after processing a request from client. If not supplied,\n                            Envoy's default value of 15s applies.\n                          pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                          type: string\n                      type: object\n                  required:\n                  - services\n                  type: object\n                type: array\n              tcpproxy:\n                description: TCPProxy holds TCP proxy information.\n                properties:\n                  healthCheckPolicy:\n                    description: The health check policy for this tcp proxy\n                    properties:\n                      healthyThresholdCount:\n                        description: The number of healthy health checks required\n                          before a host is marked healthy\n                        format: int32\n                        type: integer\n                      intervalSeconds:\n                        description: The interval (seconds) between health checks\n                        format: int64\n                        type: integer\n                      timeoutSeconds:\n                        description: The time to wait (seconds) for a health check\n                          response\n                        format: int64\n                        type: integer\n                      unhealthyThresholdCount:\n                        description: The number of unhealthy health checks required\n                          before a host is marked unhealthy\n                        format: int32\n                        type: integer\n                    type: object\n                  include:\n                    description: Include specifies that this tcpproxy should be delegated\n                      to another HTTPProxy.\n                    properties:\n                      name:\n                        description: Name of the child HTTPProxy\n                        type: string\n                      namespace:\n                        description: Namespace of the HTTPProxy to include. Defaults\n                          to the current namespace if not supplied.\n                        type: string\n                    required:\n                    - name\n                    type: object\n                  includes:\n                    description: \"IncludesDeprecated allow for specific routing configuration\n                      to be appended to another HTTPProxy in another namespace. \\n\n                      Exists due to a mistake when developing HTTPProxy and the field\n                      was marked plural when it should have been singular. This field\n                      should stay to not break backwards compatibility to v1 users.\"\n                    properties:\n                      name:\n                        description: Name of the child HTTPProxy\n                        type: string\n                      namespace:\n                        description: Namespace of the HTTPProxy to include. Defaults\n                          to the current namespace if not supplied.\n                        type: string\n                    required:\n                    - name\n                    type: object\n                  loadBalancerPolicy:\n                    description: The load balancing policy for the backend services.\n                      Note that the `Cookie` and `RequestHash` load balancing strategies\n                      cannot be used here.\n                    properties:\n                      requestHashPolicies:\n                        description: RequestHashPolicies contains a list of hash policies\n                          to apply when the `RequestHash` load balancing strategy\n                          is chosen. If an element of the supplied list of hash policies\n                          is invalid, it will be ignored. If the list of hash policies\n                          is empty after validation, the load balancing strategy will\n                          fall back the the default `RoundRobin`.\n                        items:\n                          description: RequestHashPolicy contains configuration for\n                            an individual hash policy on a request attribute.\n                          properties:\n                            headerHashOptions:\n                              description: HeaderHashOptions should be set when request\n                                header hash based load balancing is desired. It must\n                                be the only hash option field set, otherwise this\n                                request hash policy object will be ignored.\n                              properties:\n                                headerName:\n                                  description: HeaderName is the name of the HTTP\n                                    request header that will be used to calculate\n                                    the hash key. If the header specified is not present\n                                    on a request, no hash will be produced.\n                                  minLength: 1\n                                  type: string\n                              type: object\n                            terminal:\n                              description: Terminal is a flag that allows for short-circuiting\n                                computing of a hash for a given request. If set to\n                                true, and the request attribute specified in the attribute\n                                hash options is present, no further hash policies\n                                will be used to calculate a hash for the request.\n                              type: boolean\n                          type: object\n                        type: array\n                      strategy:\n                        description: Strategy specifies the policy used to balance\n                          requests across the pool of backend pods. Valid policy names\n                          are `Random`, `RoundRobin`, `WeightedLeastRequest`, `Cookie`,\n                          and `RequestHash`. If an unknown strategy name is specified\n                          or no policy is supplied, the default `RoundRobin` policy\n                          is used.\n                        type: string\n                    type: object\n                  services:\n                    description: Services are the services to proxy traffic\n                    items:\n                      description: Service defines an Kubernetes Service to proxy\n                        traffic.\n                      properties:\n                        mirror:\n                          description: If Mirror is true the Service will receive\n                            a read only mirror of the traffic for this route.\n                          type: boolean\n                        name:\n                          description: Name is the name of Kubernetes service to proxy\n                            traffic. Names defined here will be used to look up corresponding\n                            endpoints which contain the ips to route.\n                          type: string\n                        port:\n                          description: Port (defined as Integer) to proxy traffic\n                            to since a service can have multiple defined.\n                          exclusiveMaximum: true\n                          maximum: 65536\n                          minimum: 1\n                          type: integer\n                        protocol:\n                          description: Protocol may be used to specify (or override)\n                            the protocol used to reach this Service. Values may be\n                            tls, h2, h2c. If omitted, protocol-selection falls back\n                            on Service annotations.\n                          enum:\n                          - h2\n                          - h2c\n                          - tls\n                          type: string\n                        requestHeadersPolicy:\n                          description: The policy for managing request headers during\n                            proxying. Rewriting the 'Host' header is not supported.\n                          properties:\n                            remove:\n                              description: Remove specifies a list of HTTP header\n                                names to remove.\n                              items:\n                                type: string\n                              type: array\n                            set:\n                              description: Set specifies a list of HTTP header values\n                                that will be set in the HTTP header. If the header\n                                does not exist it will be added, otherwise it will\n                                be overwritten with the new value.\n                              items:\n                                description: HeaderValue represents a header name/value\n                                  pair\n                                properties:\n                                  name:\n                                    description: Name represents a key of a header\n                                    minLength: 1\n                                    type: string\n                                  value:\n                                    description: Value represents the value of a header\n                                      specified by a key\n                                    minLength: 1\n                                    type: string\n                                required:\n                                - name\n                                - value\n                                type: object\n                              type: array\n                          type: object\n                        responseHeadersPolicy:\n                          description: The policy for managing response headers during\n                            proxying. Rewriting the 'Host' header is not supported.\n                          properties:\n                            remove:\n                              description: Remove specifies a list of HTTP header\n                                names to remove.\n                              items:\n                                type: string\n                              type: array\n                            set:\n                              description: Set specifies a list of HTTP header values\n                                that will be set in the HTTP header. If the header\n                                does not exist it will be added, otherwise it will\n                                be overwritten with the new value.\n                              items:\n                                description: HeaderValue represents a header name/value\n                                  pair\n                                properties:\n                                  name:\n                                    description: Name represents a key of a header\n                                    minLength: 1\n                                    type: string\n                                  value:\n                                    description: Value represents the value of a header\n                                      specified by a key\n                                    minLength: 1\n                                    type: string\n                                required:\n                                - name\n                                - value\n                                type: object\n                              type: array\n                          type: object\n                        validation:\n                          description: UpstreamValidation defines how to verify the\n                            backend service's certificate\n                          properties:\n                            caSecret:\n                              description: Name of the Kubernetes secret be used to\n                                validate the certificate presented by the backend\n                              type: string\n                            subjectName:\n                              description: Key which is expected to be present in\n                                the 'subjectAltName' of the presented certificate\n                              type: string\n                          required:\n                          - caSecret\n                          - subjectName\n                          type: object\n                        weight:\n                          description: Weight defines percentage of traffic to balance\n                            traffic\n                          format: int64\n                          minimum: 0\n                          type: integer\n                      required:\n                      - name\n                      - port\n                      type: object\n                    type: array\n                type: object\n              virtualhost:\n                description: Virtualhost appears at most once. If it is present, the\n                  object is considered to be a \"root\" HTTPProxy.\n                properties:\n                  authorization:\n                    description: This field configures an extension service to perform\n                      authorization for this virtual host. Authorization can only\n                      be configured on virtual hosts that have TLS enabled. If the\n                      TLS configuration requires client certificate validation, the\n                      client certificate is always included in the authentication\n                      check request.\n                    properties:\n                      authPolicy:\n                        description: AuthPolicy sets a default authorization policy\n                          for client requests. This policy will be used unless overridden\n                          by individual routes.\n                        properties:\n                          context:\n                            additionalProperties:\n                              type: string\n                            description: Context is a set of key/value pairs that\n                              are sent to the authentication server in the check request.\n                              If a context is provided at an enclosing scope, the\n                              entries are merged such that the inner scope overrides\n                              matching keys from the outer scope.\n                            type: object\n                          disabled:\n                            description: When true, this field disables client request\n                              authentication for the scope of the policy.\n                            type: boolean\n                        type: object\n                      extensionRef:\n                        description: ExtensionServiceRef specifies the extension resource\n                          that will authorize client requests.\n                        properties:\n                          apiVersion:\n                            description: API version of the referent. If this field\n                              is not specified, the default \"projectcontour.io/v1alpha1\"\n                              will be used\n                            minLength: 1\n                            type: string\n                          name:\n                            description: \"Name of the referent. \\n More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\"\n                            minLength: 1\n                            type: string\n                          namespace:\n                            description: \"Namespace of the referent. If this field\n                              is not specifies, the namespace of the resource that\n                              targets the referent will be used. \\n More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/\"\n                            minLength: 1\n                            type: string\n                        type: object\n                      failOpen:\n                        description: If FailOpen is true, the client request is forwarded\n                          to the upstream service even if the authorization server\n                          fails to respond. This field should not be set in most cases.\n                          It is intended for use only while migrating applications\n                          from internal authorization to Contour external authorization.\n                        type: boolean\n                      responseTimeout:\n                        description: ResponseTimeout configures maximum time to wait\n                          for a check response from the authorization server. Timeout\n                          durations are expressed in the Go [Duration format](https://godoc.org/time#ParseDuration).\n                          Valid time units are \"ns\", \"us\" (or \"\u00b5s\"), \"ms\", \"s\", \"m\",\n                          \"h\". The string \"infinity\" is also a valid input and specifies\n                          no timeout.\n                        pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                        type: string\n                    required:\n                    - extensionRef\n                    type: object\n                  corsPolicy:\n                    description: Specifies the cross-origin policy to apply to the\n                      VirtualHost.\n                    properties:\n                      allowCredentials:\n                        description: Specifies whether the resource allows credentials.\n                        type: boolean\n                      allowHeaders:\n                        description: AllowHeaders specifies the content for the *access-control-allow-headers*\n                          header.\n                        items:\n                          description: CORSHeaderValue specifies the value of the\n                            string headers returned by a cross-domain request.\n                          pattern: ^[a-zA-Z0-9!#$%&'*+.^_`|~-]+$\n                          type: string\n                        type: array\n                      allowMethods:\n                        description: AllowMethods specifies the content for the *access-control-allow-methods*\n                          header.\n                        items:\n                          description: CORSHeaderValue specifies the value of the\n                            string headers returned by a cross-domain request.\n                          pattern: ^[a-zA-Z0-9!#$%&'*+.^_`|~-]+$\n                          type: string\n                        type: array\n                      allowOrigin:\n                        description: AllowOrigin specifies the origins that will be\n                          allowed to do CORS requests. \"*\" means allow any origin.\n                        items:\n                          type: string\n                        type: array\n                      exposeHeaders:\n                        description: ExposeHeaders Specifies the content for the *access-control-expose-headers*\n                          header.\n                        items:\n                          description: CORSHeaderValue specifies the value of the\n                            string headers returned by a cross-domain request.\n                          pattern: ^[a-zA-Z0-9!#$%&'*+.^_`|~-]+$\n                          type: string\n                        type: array\n                      maxAge:\n                        description: MaxAge indicates for how long the results of\n                          a preflight request can be cached. MaxAge durations are\n                          expressed in the Go [Duration format](https://godoc.org/time#ParseDuration).\n                          Valid time units are \"ns\", \"us\" (or \"\u00b5s\"), \"ms\", \"s\", \"m\",\n                          \"h\". Only positive values are allowed while 0 disables the\n                          cache requiring a preflight OPTIONS check for all cross-origin\n                          requests.\n                        type: string\n                    required:\n                    - allowMethods\n                    - allowOrigin\n                    type: object\n                  fqdn:\n                    description: The fully qualified domain name of the root of the\n                      ingress tree all leaves of the DAG rooted at this object relate\n                      to the fqdn.\n                    type: string\n                  rateLimitPolicy:\n                    description: The policy for rate limiting on the virtual host.\n                    properties:\n                      global:\n                        description: Global defines global rate limiting parameters,\n                          i.e. parameters defining descriptors that are sent to an\n                          external rate limit service (RLS) for a rate limit decision\n                          on each request.\n                        properties:\n                          descriptors:\n                            description: Descriptors defines the list of descriptors\n                              that will be generated and sent to the rate limit service.\n                              Each descriptor contains 1+ key-value pair entries.\n                            items:\n                              description: RateLimitDescriptor defines a list of key-value\n                                pair generators.\n                              properties:\n                                entries:\n                                  description: Entries is the list of key-value pair\n                                    generators.\n                                  items:\n                                    description: RateLimitDescriptorEntry is a key-value\n                                      pair generator. Exactly one field on this struct\n                                      must be non-nil.\n                                    properties:\n                                      genericKey:\n                                        description: GenericKey defines a descriptor\n                                          entry with a static key and value.\n                                        properties:\n                                          key:\n                                            description: Key defines the key of the\n                                              descriptor entry. If not set, the key\n                                              is set to \"generic_key\".\n                                            type: string\n                                          value:\n                                            description: Value defines the value of\n                                              the descriptor entry.\n                                            minLength: 1\n                                            type: string\n                                        type: object\n                                      remoteAddress:\n                                        description: RemoteAddress defines a descriptor\n                                          entry with a key of \"remote_address\" and\n                                          a value equal to the client's IP address\n                                          (from x-forwarded-for).\n                                        type: object\n                                      requestHeader:\n                                        description: RequestHeader defines a descriptor\n                                          entry that's populated only if a given header\n                                          is present on the request. The descriptor\n                                          key is static, and the descriptor value\n                                          is equal to the value of the header.\n                                        properties:\n                                          descriptorKey:\n                                            description: DescriptorKey defines the\n                                              key to use on the descriptor entry.\n                                            minLength: 1\n                                            type: string\n                                          headerName:\n                                            description: HeaderName defines the name\n                                              of the header to look for on the request.\n                                            minLength: 1\n                                            type: string\n                                        type: object\n                                      requestHeaderValueMatch:\n                                        description: RequestHeaderValueMatch defines\n                                          a descriptor entry that's populated if the\n                                          request's headers match a set of 1+ match\n                                          criteria. The descriptor key is \"header_match\",\n                                          and the descriptor value is static.\n                                        properties:\n                                          expectMatch:\n                                            default: true\n                                            description: ExpectMatch defines whether\n                                              the request must positively match the\n                                              match criteria in order to generate\n                                              a descriptor entry (i.e. true), or not\n                                              match the match criteria in order to\n                                              generate a descriptor entry (i.e. false).\n                                              The default is true.\n                                            type: boolean\n                                          headers:\n                                            description: Headers is a list of 1+ match\n                                              criteria to apply against the request\n                                              to determine whether to populate the\n                                              descriptor entry or not.\n                                            items:\n                                              description: HeaderMatchCondition specifies\n                                                how to conditionally match against\n                                                HTTP headers. The Name field is required,\n                                                but only one of the remaining fields\n                                                should be be provided.\n                                              properties:\n                                                contains:\n                                                  description: Contains specifies\n                                                    a substring that must be present\n                                                    in the header value.\n                                                  type: string\n                                                exact:\n                                                  description: Exact specifies a string\n                                                    that the header value must be\n                                                    equal to.\n                                                  type: string\n                                                name:\n                                                  description: Name is the name of\n                                                    the header to match against. Name\n                                                    is required. Header names are\n                                                    case insensitive.\n                                                  type: string\n                                                notcontains:\n                                                  description: NotContains specifies\n                                                    a substring that must not be present\n                                                    in the header value.\n                                                  type: string\n                                                notexact:\n                                                  description: NoExact specifies a\n                                                    string that the header value must\n                                                    not be equal to. The condition\n                                                    is true if the header has any\n                                                    other value.\n                                                  type: string\n                                                notpresent:\n                                                  description: NotPresent specifies\n                                                    that condition is true when the\n                                                    named header is not present. Note\n                                                    that setting NotPresent to false\n                                                    does not make the condition true\n                                                    if the named header is present.\n                                                  type: boolean\n                                                present:\n                                                  description: Present specifies that\n                                                    condition is true when the named\n                                                    header is present, regardless\n                                                    of its value. Note that setting\n                                                    Present to false does not make\n                                                    the condition true if the named\n                                                    header is absent.\n                                                  type: boolean\n                                              required:\n                                              - name\n                                              type: object\n                                            minItems: 1\n                                            type: array\n                                          value:\n                                            description: Value defines the value of\n                                              the descriptor entry.\n                                            minLength: 1\n                                            type: string\n                                        type: object\n                                    type: object\n                                  minItems: 1\n                                  type: array\n                              type: object\n                            minItems: 1\n                            type: array\n                        type: object\n                      local:\n                        description: Local defines local rate limiting parameters,\n                          i.e. parameters for rate limiting that occurs within each\n                          Envoy pod as requests are handled.\n                        properties:\n                          burst:\n                            description: Burst defines the number of requests above\n                              the requests per unit that should be allowed within\n                              a short period of time.\n                            format: int32\n                            type: integer\n                          requests:\n                            description: Requests defines how many requests per unit\n                              of time should be allowed before rate limiting occurs.\n                            format: int32\n                            minimum: 1\n                            type: integer\n                          responseHeadersToAdd:\n                            description: ResponseHeadersToAdd is an optional list\n                              of response headers to set when a request is rate-limited.\n                            items:\n                              description: HeaderValue represents a header name/value\n                                pair\n                              properties:\n                                name:\n                                  description: Name represents a key of a header\n                                  minLength: 1\n                                  type: string\n                                value:\n                                  description: Value represents the value of a header\n                                    specified by a key\n                                  minLength: 1\n                                  type: string\n                              required:\n                              - name\n                              - value\n                              type: object\n                            type: array\n                          responseStatusCode:\n                            description: ResponseStatusCode is the HTTP status code\n                              to use for responses to rate-limited requests. Codes\n                              must be in the 400-599 range (inclusive). If not specified,\n                              the Envoy default of 429 (Too Many Requests) is used.\n                            format: int32\n                            maximum: 599\n                            minimum: 400\n                            type: integer\n                          unit:\n                            description: Unit defines the period of time within which\n                              requests over the limit will be rate limited. Valid\n                              values are \"second\", \"minute\" and \"hour\".\n                            enum:\n                            - second\n                            - minute\n                            - hour\n                            type: string\n                        required:\n                        - requests\n                        - unit\n                        type: object\n                    type: object\n                  tls:\n                    description: If present the fields describes TLS properties of\n                      the virtual host. The SNI names that will be matched on are\n                      described in fqdn, the tls.secretName secret must contain a\n                      certificate that itself contains a name that matches the FQDN.\n                    properties:\n                      clientValidation:\n                        description: \"ClientValidation defines how to verify the client\n                          certificate when an external client establishes a TLS connection\n                          to Envoy. \\n This setting: \\n 1. Enables TLS client certificate\n                          validation. 2. Specifies how the client certificate will\n                          be validated (i.e.    validation required or skipped). \\n\n                          Note: Setting client certificate validation to be skipped\n                          should be only used in conjunction with an external authorization\n                          server that performs client validation as Contour will ensure\n                          client certificates are passed along.\"\n                        properties:\n                          caSecret:\n                            description: Name of a Kubernetes secret that contains\n                              a CA certificate bundle. The client certificate must\n                              validate against the certificates in the bundle. If\n                              specified and SkipClientCertValidation is true, client\n                              certificates will be required on requests.\n                            minLength: 1\n                            type: string\n                          skipClientCertValidation:\n                            description: SkipClientCertValidation disables downstream\n                              client certificate validation. Defaults to false. This\n                              field is intended to be used in conjunction with external\n                              authorization in order to enable the external authorization\n                              server to validate client certificates. When this field\n                              is set to true, client certificates are requested but\n                              not verified by Envoy. If CACertificate is specified,\n                              client certificates are required on requests, but not\n                              verified. If external authorization is in use, they\n                              are presented to the external authorization server.\n                            type: boolean\n                        type: object\n                      enableFallbackCertificate:\n                        description: EnableFallbackCertificate defines if the vhost\n                          should allow a default certificate to be applied which handles\n                          all requests which don't match the SNI defined in this vhost.\n                        type: boolean\n                      minimumProtocolVersion:\n                        description: MinimumProtocolVersion is the minimum TLS version\n                          this vhost should negotiate. Valid options are `1.2` (default)\n                          and `1.3`. Any other value defaults to TLS 1.2.\n                        type: string\n                      passthrough:\n                        description: Passthrough defines whether the encrypted TLS\n                          handshake will be passed through to the backing cluster.\n                          Either Passthrough or SecretName must be specified, but\n                          not both.\n                        type: boolean\n                      secretName:\n                        description: SecretName is the name of a TLS secret in the\n                          current namespace. Either SecretName or Passthrough must\n                          be specified, but not both. If specified, the named secret\n                          must contain a matching certificate for the virtual host's\n                          FQDN.\n                        type: string\n                    type: object\n                required:\n                - fqdn\n                type: object\n            type: object\n          status:\n            description: Status is a container for computed information about the\n              HTTPProxy.\n            properties:\n              conditions:\n                description: \"Conditions contains information about the current status\n                  of the HTTPProxy, in an upstream-friendly container. \\n Contour\n                  will update a single condition, `Valid`, that is in normal-true\n                  polarity. That is, when `currentStatus` is `valid`, the `Valid`\n                  condition will be `status: true`, and vice versa. \\n Contour will\n                  leave untouched any other Conditions set in this block, in case\n                  some other controller wants to add a Condition. \\n If you are another\n                  controller owner and wish to add a condition, you *should* namespace\n                  your condition with a label, like `controller.domain.com/ConditionName`.\"\n                items:\n                  description: \"DetailedCondition is an extension of the normal Kubernetes\n                    conditions, with two extra fields to hold sub-conditions, which\n                    provide more detailed reasons for the state (True or False) of\n                    the condition. \\n `errors` holds information about sub-conditions\n                    which are fatal to that condition and render its state False.\n                    \\n `warnings` holds information about sub-conditions which are\n                    not fatal to that condition and do not force the state to be False.\n                    \\n Remember that Conditions have a type, a status, and a reason.\n                    \\n The type is the type of the condition, the most important one\n                    in this CRD set is `Valid`. `Valid` is a positive-polarity condition:\n                    when it is `status: true` there are no problems. \\n In more detail,\n                    `status: true` means that the object is has been ingested into\n                    Contour with no errors. `warnings` may still be present, and will\n                    be indicated in the Reason field. There must be zero entries in\n                    the `errors` slice in this case. \\n `Valid`, `status: false` means\n                    that the object has had one or more fatal errors during processing\n                    into Contour.  The details of the errors will be present under\n                    the `errors` field. There must be at least one error in the `errors`\n                    slice if `status` is `false`. \\n For DetailedConditions of types\n                    other than `Valid`, the Condition must be in the negative polarity.\n                    When they have `status` `true`, there is an error. There must\n                    be at least one entry in the `errors` Subcondition slice. When\n                    they have `status` `false`, there are no serious errors, and there\n                    must be zero entries in the `errors` slice. In either case, there\n                    may be entries in the `warnings` slice. \\n Regardless of the polarity,\n                    the `reason` and `message` fields must be updated with either\n                    the detail of the reason (if there is one and only one entry in\n                    total across both the `errors` and `warnings` slices), or `MultipleReasons`\n                    if there is more than one entry.\"\n                  properties:\n                    errors:\n                      description: \"Errors contains a slice of relevant error subconditions\n                        for this object. \\n Subconditions are expected to appear when\n                        relevant (when there is a error), and disappear when not relevant.\n                        An empty slice here indicates no errors.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                    lastTransitionTime:\n                      description: lastTransitionTime is the last time the condition\n                        transitioned from one status to another. This should be when\n                        the underlying condition changed.  If that is not known, then\n                        using the time when the API field changed is acceptable.\n                      format: date-time\n                      type: string\n                    message:\n                      description: message is a human readable message indicating\n                        details about the transition. This may be an empty string.\n                      maxLength: 32768\n                      type: string\n                    observedGeneration:\n                      description: observedGeneration represents the .metadata.generation\n                        that the condition was set based upon. For instance, if .metadata.generation\n                        is currently 12, but the .status.conditions[x].observedGeneration\n                        is 9, the condition is out of date with respect to the current\n                        state of the instance.\n                      format: int64\n                      minimum: 0\n                      type: integer\n                    reason:\n                      description: reason contains a programmatic identifier indicating\n                        the reason for the condition's last transition. Producers\n                        of specific condition types may define expected values and\n                        meanings for this field, and whether the values are considered\n                        a guaranteed API. The value should be a CamelCase string.\n                        This field may not be empty.\n                      maxLength: 1024\n                      minLength: 1\n                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                      type: string\n                    status:\n                      description: status of the condition, one of True, False, Unknown.\n                      enum:\n                      - \"True\"\n                      - \"False\"\n                      - Unknown\n                      type: string\n                    type:\n                      description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                        --- Many .condition.type values are consistent across resources\n                        like Available, but because arbitrary conditions can be useful\n                        (see .node.status.conditions), the ability to deconflict is\n                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                      maxLength: 316\n                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                      type: string\n                    warnings:\n                      description: \"Warnings contains a slice of relevant warning\n                        subconditions for this object. \\n Subconditions are expected\n                        to appear when relevant (when there is a warning), and disappear\n                        when not relevant. An empty slice here indicates no warnings.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                  required:\n                  - lastTransitionTime\n                  - message\n                  - reason\n                  - status\n                  - type\n                  type: object\n                type: array\n                x-kubernetes-list-map-keys:\n                - type\n                x-kubernetes-list-type: map\n              currentStatus:\n                type: string\n              description:\n                type: string\n              loadBalancer:\n                description: LoadBalancer contains the current status of the load\n                  balancer.\n                properties:\n                  ingress:\n                    description: Ingress is a list containing ingress points for the\n                      load-balancer. Traffic intended for the service should be sent\n                      to these ingress points.\n                    items:\n                      description: 'LoadBalancerIngress represents the status of a\n                        load-balancer ingress point: traffic intended for the service\n                        should be sent to an ingress point.'\n                      properties:\n                        hostname:\n                          description: Hostname is set for load-balancer ingress points\n                            that are DNS based (typically AWS load-balancers)\n                          type: string\n                        ip:\n                          description: IP is set for load-balancer ingress points\n                            that are IP based (typically GCE or OpenStack load-balancers)\n                          type: string\n                        ports:\n                          description: Ports is a list of records of service ports\n                            If used, every port defined in the service should have\n                            an entry in it\n                          items:\n                            properties:\n                              error:\n                                description: 'Error is to record the problem with\n                                  the service port The format of the error shall comply\n                                  with the following rules: - built-in error values\n                                  shall be specified in this file and those shall\n                                  use   CamelCase names - cloud provider specific\n                                  error values must have names that comply with the   format\n                                  foo.example.com/CamelCase. --- The regex it matches\n                                  is (dns1123SubdomainFmt/)?(qualifiedNameFmt)'\n                                maxLength: 316\n                                pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                                type: string\n                              port:\n                                description: Port is the port number of the service\n                                  port of which status is recorded here\n                                format: int32\n                                type: integer\n                              protocol:\n                                default: TCP\n                                description: 'Protocol is the protocol of the service\n                                  port of which status is recorded here The supported\n                                  values are: \"TCP\", \"UDP\", \"SCTP\"'\n                                type: string\n                            required:\n                            - port\n                            - protocol\n                            type: object\n                          type: array\n                          x-kubernetes-list-type: atomic\n                      type: object\n                    type: array\n                type: object\n            type: object\n        required:\n        - metadata\n        - spec\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: tlscertificatedelegations.projectcontour.io\nspec:\n  preserveUnknownFields: false\n  group: projectcontour.io\n  names:\n    kind: TLSCertificateDelegation\n    listKind: TLSCertificateDelegationList\n    plural: tlscertificatedelegations\n    shortNames:\n    - tlscerts\n    singular: tlscertificatedelegation\n  scope: Namespaced\n  versions:\n  - name: v1\n    schema:\n      openAPIV3Schema:\n        description: TLSCertificateDelegation is an TLS Certificate Delegation CRD\n          specification. See design/tls-certificate-delegation.md for details.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: TLSCertificateDelegationSpec defines the spec of the CRD\n            properties:\n              delegations:\n                items:\n                  description: CertificateDelegation maps the authority to reference\n                    a secret in the current namespace to a set of namespaces.\n                  properties:\n                    secretName:\n                      description: required, the name of a secret in the current namespace.\n                      type: string\n                    targetNamespaces:\n                      description: required, the namespaces the authority to reference\n                        the the secret will be delegated to. If TargetNamespaces is\n                        nil or empty, the CertificateDelegation' is ignored. If the\n                        TargetNamespace list contains the character, \"*\" the secret\n                        will be delegated to all namespaces.\n                      items:\n                        type: string\n                      type: array\n                  required:\n                  - secretName\n                  - targetNamespaces\n                  type: object\n                type: array\n            required:\n            - delegations\n            type: object\n          status:\n            description: TLSCertificateDelegationStatus allows for the status of the\n              delegation to be presented to the user.\n            properties:\n              conditions:\n                description: \"Conditions contains information about the current status\n                  of the HTTPProxy, in an upstream-friendly container. \\n Contour\n                  will update a single condition, `Valid`, that is in normal-true\n                  polarity. That is, when `currentStatus` is `valid`, the `Valid`\n                  condition will be `status: true`, and vice versa. \\n Contour will\n                  leave untouched any other Conditions set in this block, in case\n                  some other controller wants to add a Condition. \\n If you are another\n                  controller owner and wish to add a condition, you *should* namespace\n                  your condition with a label, like `controller.domain.com\\\\ConditionName`.\"\n                items:\n                  description: \"DetailedCondition is an extension of the normal Kubernetes\n                    conditions, with two extra fields to hold sub-conditions, which\n                    provide more detailed reasons for the state (True or False) of\n                    the condition. \\n `errors` holds information about sub-conditions\n                    which are fatal to that condition and render its state False.\n                    \\n `warnings` holds information about sub-conditions which are\n                    not fatal to that condition and do not force the state to be False.\n                    \\n Remember that Conditions have a type, a status, and a reason.\n                    \\n The type is the type of the condition, the most important one\n                    in this CRD set is `Valid`. `Valid` is a positive-polarity condition:\n                    when it is `status: true` there are no problems. \\n In more detail,\n                    `status: true` means that the object is has been ingested into\n                    Contour with no errors. `warnings` may still be present, and will\n                    be indicated in the Reason field. There must be zero entries in\n                    the `errors` slice in this case. \\n `Valid`, `status: false` means\n                    that the object has had one or more fatal errors during processing\n                    into Contour.  The details of the errors will be present under\n                    the `errors` field. There must be at least one error in the `errors`\n                    slice if `status` is `false`. \\n For DetailedConditions of types\n                    other than `Valid`, the Condition must be in the negative polarity.\n                    When they have `status` `true`, there is an error. There must\n                    be at least one entry in the `errors` Subcondition slice. When\n                    they have `status` `false`, there are no serious errors, and there\n                    must be zero entries in the `errors` slice. In either case, there\n                    may be entries in the `warnings` slice. \\n Regardless of the polarity,\n                    the `reason` and `message` fields must be updated with either\n                    the detail of the reason (if there is one and only one entry in\n                    total across both the `errors` and `warnings` slices), or `MultipleReasons`\n                    if there is more than one entry.\"\n                  properties:\n                    errors:\n                      description: \"Errors contains a slice of relevant error subconditions\n                        for this object. \\n Subconditions are expected to appear when\n                        relevant (when there is a error), and disappear when not relevant.\n                        An empty slice here indicates no errors.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                    lastTransitionTime:\n                      description: lastTransitionTime is the last time the condition\n                        transitioned from one status to another. This should be when\n                        the underlying condition changed.  If that is not known, then\n                        using the time when the API field changed is acceptable.\n                      format: date-time\n                      type: string\n                    message:\n                      description: message is a human readable message indicating\n                        details about the transition. This may be an empty string.\n                      maxLength: 32768\n                      type: string\n                    observedGeneration:\n                      description: observedGeneration represents the .metadata.generation\n                        that the condition was set based upon. For instance, if .metadata.generation\n                        is currently 12, but the .status.conditions[x].observedGeneration\n                        is 9, the condition is out of date with respect to the current\n                        state of the instance.\n                      format: int64\n                      minimum: 0\n                      type: integer\n                    reason:\n                      description: reason contains a programmatic identifier indicating\n                        the reason for the condition's last transition. Producers\n                        of specific condition types may define expected values and\n                        meanings for this field, and whether the values are considered\n                        a guaranteed API. The value should be a CamelCase string.\n                        This field may not be empty.\n                      maxLength: 1024\n                      minLength: 1\n                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                      type: string\n                    status:\n                      description: status of the condition, one of True, False, Unknown.\n                      enum:\n                      - \"True\"\n                      - \"False\"\n                      - Unknown\n                      type: string\n                    type:\n                      description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                        --- Many .condition.type values are consistent across resources\n                        like Available, but because arbitrary conditions can be useful\n                        (see .node.status.conditions), the ability to deconflict is\n                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                      maxLength: 316\n                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                      type: string\n                    warnings:\n                      description: \"Warnings contains a slice of relevant warning\n                        subconditions for this object. \\n Subconditions are expected\n                        to appear when relevant (when there is a warning), and disappear\n                        when not relevant. An empty slice here indicates no warnings.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                  required:\n                  - lastTransitionTime\n                  - message\n                  - reason\n                  - status\n                  - type\n                  type: object\n                type: array\n                x-kubernetes-list-map-keys:\n                - type\n                x-kubernetes-list-type: map\n            type: object\n        required:\n        - metadata\n        - spec\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: contour-certgen\n  namespace: projectcontour\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: contour\n  namespace: projectcontour\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: contour-certgen\nsubjects:\n- kind: ServiceAccount\n  name: contour-certgen\n  namespace: projectcontour\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: contour-certgen\n  namespace: projectcontour\nrules:\n- apiGroups:\n  - \"\"\n  resources:\n  - secrets\n  verbs:\n  - create\n  - update\n---\napiVersion: batch/v1\nkind: Job\nmetadata:\n  name: contour-certgen-v1.17.0\n  namespace: projectcontour\nspec:\n  ttlSecondsAfterFinished: 0\n  template:\n    metadata:\n      labels:\n        app: \"contour-certgen\"\n    spec:\n      containers:\n      - name: contour\n        image: docker.io/projectcontour/contour:v1.17.0\n        imagePullPolicy: Always\n        command:\n        - contour\n        - certgen\n        - --kube\n        - --incluster\n        - --overwrite\n        - --secrets-format=compact\n        - --namespace=$(CONTOUR_NAMESPACE)\n        env:\n        - name: CONTOUR_NAMESPACE\n          valueFrom:\n            fieldRef:\n              fieldPath: metadata.namespace\n      restartPolicy: Never\n      serviceAccountName: contour-certgen\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 65534\n        runAsGroup: 65534\n  parallelism: 1\n  completions: 1\n  backoffLimit: 1\n\n---\n\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: contour\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: contour\nsubjects:\n- kind: ServiceAccount\n  name: contour\n  namespace: projectcontour\n\n# The following ClusterRole is generated from kubebuilder RBAC tags by\n# generate-rbac.sh. Do not edit this file directly but instead edit the source\n# files and re-render.\n\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  creationTimestamp: null\n  name: contour\nrules:\n- apiGroups:\n  - \"\"\n  resources:\n  - configmaps\n  verbs:\n  - create\n  - get\n  - update\n- apiGroups:\n  - \"\"\n  resources:\n  - endpoints\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - namespaces\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - secrets\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - services\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - apiextensions.k8s.io\n  resources:\n  - customresourcedefinitions\n  verbs:\n  - list\n- apiGroups:\n  - networking.k8s.io\n  resources:\n  - ingressclasses\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - networking.k8s.io\n  resources:\n  - ingresses\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - networking.k8s.io\n  resources:\n  - ingresses/status\n  verbs:\n  - create\n  - get\n  - update\n- apiGroups:\n  - networking.x-k8s.io\n  resources:\n  - backendpolicies\n  - gatewayclasses\n  - gateways\n  - httproutes\n  - tcproutes\n  - tlsroutes\n  - udproutes\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - networking.x-k8s.io\n  resources:\n  - backendpolicies/status\n  - gatewayclasses/status\n  - gateways/status\n  - httproutes/status\n  - tcproutes/status\n  - tlsroutes/status\n  - udproutes/status\n  verbs:\n  - update\n- apiGroups:\n  - projectcontour.io\n  resources:\n  - extensionservices\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - projectcontour.io\n  resources:\n  - extensionservices/status\n  verbs:\n  - create\n  - get\n  - update\n- apiGroups:\n  - projectcontour.io\n  resources:\n  - httpproxies\n  - tlscertificatedelegations\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - projectcontour.io\n  resources:\n  - httpproxies/status\n  verbs:\n  - create\n  - get\n  - update\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: contour\n  namespace: projectcontour\nspec:\n  ports:\n  - port: 8001\n    name: xds\n    protocol: TCP\n    targetPort: 8001\n  selector:\n    app: contour\n  type: ClusterIP\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: envoy\n  namespace: projectcontour\n  annotations:\n    # This annotation puts the AWS ELB into \"TCP\" mode so that it does not\n    # do HTTP negotiation for HTTPS connections at the ELB edge.\n    # The downside of this is the remote IP address of all connections will\n    # appear to be the internal address of the ELB. See docs/proxy-proto.md\n    # for information about enabling the PROXY protocol on the ELB to recover\n    # the original remote IP address.\n    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcp\nspec:\n  externalTrafficPolicy: Local\n  ports:\n  - port: 80\n    name: http\n    protocol: TCP\n    targetPort: 8080\n  - port: 443\n    name: https\n    protocol: TCP\n    targetPort: 8443\n  selector:\n    app: envoy\n  type: LoadBalancer\n\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: contour\n  name: contour\n  namespace: projectcontour\nspec:\n  replicas: 2\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      # This value of maxSurge means that during a rolling update\n      # the new ReplicaSet will be created first.\n      maxSurge: 50%\n  selector:\n    matchLabels:\n      app: contour\n  template:\n    metadata:\n      annotations:\n        prometheus.io/scrape: \"true\"\n        prometheus.io/port: \"8000\"\n      labels:\n        app: contour\n    spec:\n      affinity:\n        podAntiAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n          - podAffinityTerm:\n              labelSelector:\n                matchLabels:\n                  app: contour\n              topologyKey: kubernetes.io/hostname\n            weight: 100\n      containers:\n      - args:\n        - serve\n        - --incluster\n        - --xds-address=0.0.0.0\n        - --xds-port=8001\n        - --contour-cafile=/certs/ca.crt\n        - --contour-cert-file=/certs/tls.crt\n        - --contour-key-file=/certs/tls.key\n        - --config-path=/config/contour.yaml\n        command: [\"contour\"]\n        image: docker.io/projectcontour/contour:v1.17.0\n        imagePullPolicy: IfNotPresent\n        name: contour\n        ports:\n        - containerPort: 8001\n          name: xds\n          protocol: TCP\n        - containerPort: 8000\n          name: metrics\n          protocol: TCP\n        - containerPort: 6060\n          name: debug\n          protocol: TCP\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 8000\n        readinessProbe:\n          tcpSocket:\n            port: 8001\n          initialDelaySeconds: 15\n          periodSeconds: 10\n        volumeMounts:\n          - name: contourcert\n            mountPath: /certs\n            readOnly: true\n          - name: contour-config\n            mountPath: /config\n            readOnly: true\n        env:\n        - name: CONTOUR_NAMESPACE\n          valueFrom:\n            fieldRef:\n              apiVersion: v1\n              fieldPath: metadata.namespace\n        - name: POD_NAME\n          valueFrom:\n            fieldRef:\n              apiVersion: v1\n              fieldPath: metadata.name\n      dnsPolicy: ClusterFirst\n      serviceAccountName: contour\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 65534\n        runAsGroup: 65534\n      volumes:\n        - name: contourcert\n          secret:\n            secretName: contourcert\n        - name: contour-config\n          configMap:\n            name: contour\n            defaultMode: 0644\n            items:\n            - key: contour.yaml\n              path: contour.yaml\n\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  labels:\n    app: envoy\n  name: envoy\n  namespace: projectcontour\nspec:\n  updateStrategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 10%\n  selector:\n    matchLabels:\n      app: envoy\n  template:\n    metadata:\n      annotations:\n        prometheus.io/scrape: \"true\"\n        prometheus.io/port: \"8002\"\n        prometheus.io/path: \"/stats/prometheus\"\n      labels:\n        app: envoy\n    spec:\n      containers:\n      - command:\n        - /bin/contour\n        args:\n          - envoy\n          - shutdown-manager\n        image: docker.io/projectcontour/contour:v1.17.0\n        imagePullPolicy: IfNotPresent\n        lifecycle:\n          preStop:\n            exec:\n              command:\n                - /bin/contour\n                - envoy\n                - shutdown\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 8090\n          initialDelaySeconds: 3\n          periodSeconds: 10\n        name: shutdown-manager\n      - args:\n        - -c\n        - /config/envoy.json\n        - --service-cluster $(CONTOUR_NAMESPACE)\n        - --service-node $(ENVOY_POD_NAME)\n        - --log-level info\n        command:\n        - envoy\n        image: docker.io/envoyproxy/envoy:v1.18.3\n        imagePullPolicy: IfNotPresent\n        name: envoy\n        env:\n        - name: CONTOUR_NAMESPACE\n          valueFrom:\n            fieldRef:\n              apiVersion: v1\n              fieldPath: metadata.namespace\n        - name: ENVOY_POD_NAME\n          valueFrom:\n            fieldRef:\n              apiVersion: v1\n              fieldPath: metadata.name\n        ports:\n        - containerPort: 8080\n          hostPort: 80\n          name: http\n          protocol: TCP\n        - containerPort: 8443\n          hostPort: 443\n          name: https\n          protocol: TCP\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 8002\n          initialDelaySeconds: 3\n          periodSeconds: 4\n        volumeMounts:\n          - name: envoy-config\n            mountPath: /config\n            readOnly: true\n          - name: envoycert\n            mountPath: /certs\n            readOnly: true\n        lifecycle:\n          preStop:\n            httpGet:\n              path: /shutdown\n              port: 8090\n              scheme: HTTP\n      initContainers:\n      - args:\n        - bootstrap\n        - /config/envoy.json\n        - --xds-address=contour\n        - --xds-port=8001\n        - --xds-resource-version=v3\n        - --resources-dir=/config/resources\n        - --envoy-cafile=/certs/ca.crt\n        - --envoy-cert-file=/certs/tls.crt\n        - --envoy-key-file=/certs/tls.key\n        command:\n        - contour\n        image: docker.io/projectcontour/contour:v1.17.0\n        imagePullPolicy: IfNotPresent\n        name: envoy-initconfig\n        volumeMounts:\n        - name: envoy-config\n          mountPath: /config\n        - name: envoycert\n          mountPath: /certs\n          readOnly: true\n        env:\n        - name: CONTOUR_NAMESPACE\n          valueFrom:\n            fieldRef:\n              fieldPath: metadata.namespace\n      automountServiceAccountToken: false\n      serviceAccountName: envoy\n      terminationGracePeriodSeconds: 300\n      volumes:\n        - name: envoy-config\n          emptyDir: {}\n        - name: envoycert\n          secret:\n            secretName: envoycert\n      restartPolicy: Always\n\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: backendpolicies.networking.x-k8s.io\nspec:\n  group: networking.x-k8s.io\n  names:\n    categories:\n    - gateway-api\n    kind: BackendPolicy\n    listKind: BackendPolicyList\n    plural: backendpolicies\n    shortNames:\n    - bp\n    singular: backendpolicy\n  scope: Namespaced\n  versions:\n  - additionalPrinterColumns:\n    - jsonPath: .metadata.creationTimestamp\n      name: Age\n      type: date\n    name: v1alpha1\n    schema:\n      openAPIV3Schema:\n        description: BackendPolicy defines policies associated with backends. For\n          the purpose of this API, a backend is defined as any resource that a route\n          can forward traffic to. A common example of a backend is a Service. Configuration\n          that is implementation specific may be represented with similar implementation\n          specific custom resources.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: Spec defines the desired state of BackendPolicy.\n            properties:\n              backendRefs:\n                description: \"BackendRefs define which backends this policy should\n                  be applied to. This policy can only apply to backends within the\n                  same namespace. If more than one BackendPolicy targets the same\n                  backend, precedence must be given to the oldest BackendPolicy. \\n\n                  Support: Core\"\n                items:\n                  description: BackendRef identifies an API object within the same\n                    namespace as the BackendPolicy.\n                  properties:\n                    group:\n                      description: Group is the group of the referent.\n                      maxLength: 253\n                      type: string\n                    kind:\n                      description: Kind is the kind of the referent.\n                      maxLength: 253\n                      type: string\n                    name:\n                      description: Name is the name of the referent.\n                      maxLength: 253\n                      type: string\n                    port:\n                      description: Port is the port of the referent. If unspecified,\n                        this policy applies to all ports on the backend.\n                      format: int32\n                      maximum: 65535\n                      minimum: 1\n                      type: integer\n                  required:\n                  - group\n                  - kind\n                  - name\n                  type: object\n                maxItems: 16\n                type: array\n              tls:\n                description: \"TLS is the TLS configuration for these backends. \\n\n                  Support: Extended\"\n                properties:\n                  certificateAuthorityRef:\n                    description: \"CertificateAuthorityRef is a reference to a Kubernetes\n                      object that contains one or more trusted CA certificates. The\n                      CA certificates are used to establish a TLS handshake to backends\n                      listed in BackendRefs. The referenced object MUST reside in\n                      the same namespace as BackendPolicy. \\n CertificateAuthorityRef\n                      can reference a standard Kubernetes resource, i.e. ConfigMap,\n                      or an implementation-specific custom resource. \\n When stored\n                      in a Secret, certificates must be PEM encoded and specified\n                      within the \\\"ca.crt\\\" data field of the Secret. When multiple\n                      certificates are specified, the certificates MUST be concatenated\n                      by new lines. \\n CertificateAuthorityRef can also reference\n                      a standard Kubernetes resource, i.e. ConfigMap, or an implementation-specific\n                      custom resource. \\n Support: Extended\"\n                    properties:\n                      group:\n                        description: Group is the group of the referent.\n                        maxLength: 253\n                        minLength: 1\n                        type: string\n                      kind:\n                        description: Kind is kind of the referent.\n                        maxLength: 253\n                        minLength: 1\n                        type: string\n                      name:\n                        description: Name is the name of the referent.\n                        maxLength: 253\n                        minLength: 1\n                        type: string\n                    required:\n                    - group\n                    - kind\n                    - name\n                    type: object\n                  options:\n                    additionalProperties:\n                      type: string\n                    description: \"Options are a list of key/value pairs to give extended\n                      options to the provider. \\n Support: Implementation-specific\"\n                    type: object\n                type: object\n            required:\n            - backendRefs\n            type: object\n          status:\n            description: Status defines the current state of BackendPolicy.\n            properties:\n              conditions:\n                description: Conditions describe the current conditions of the BackendPolicy.\n                items:\n                  description: \"Condition contains details for one aspect of the current\n                    state of this API Resource. --- This struct is intended for direct\n                    use as an array at the field path .status.conditions.  For example,\n                    type FooStatus struct{     // Represents the observations of a\n                    foo's current state.     // Known .status.conditions.type are:\n                    \\\"Available\\\", \\\"Progressing\\\", and \\\"Degraded\\\"     // +patchMergeKey=type\n                    \\    // +patchStrategy=merge     // +listType=map     // +listMapKey=type\n                    \\    Conditions []metav1.Condition `json:\\\"conditions,omitempty\\\"\n                    patchStrategy:\\\"merge\\\" patchMergeKey:\\\"type\\\" protobuf:\\\"bytes,1,rep,name=conditions\\\"`\n                    \\n     // other fields }\"\n                  properties:\n                    lastTransitionTime:\n                      description: lastTransitionTime is the last time the condition\n                        transitioned from one status to another. This should be when\n                        the underlying condition changed.  If that is not known, then\n                        using the time when the API field changed is acceptable.\n                      format: date-time\n                      type: string\n                    message:\n                      description: message is a human readable message indicating\n                        details about the transition. This may be an empty string.\n                      maxLength: 32768\n                      type: string\n                    observedGeneration:\n                      description: observedGeneration represents the .metadata.generation\n                        that the condition was set based upon. For instance, if .metadata.generation\n                        is currently 12, but the .status.conditions[x].observedGeneration\n                        is 9, the condition is out of date with respect to the current\n                        state of the instance.\n                      format: int64\n                      minimum: 0\n                      type: integer\n                    reason:\n                      description: reason contains a programmatic identifier indicating\n                        the reason for the condition's last transition. Producers\n                        of specific condition types may define expected values and\n                        meanings for this field, and whether the values are considered\n                        a guaranteed API. The value should be a CamelCase string.\n                        This field may not be empty.\n                      maxLength: 1024\n                      minLength: 1\n                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                      type: string\n                    status:\n                      description: status of the condition, one of True, False, Unknown.\n                      enum:\n                      - \"True\"\n                      - \"False\"\n                      - Unknown\n                      type: string\n                    type:\n                      description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                        --- Many .condition.type values are consistent across resources\n                        like Available, but because arbitrary conditions can be useful\n                        (see .node.status.conditions), the ability to deconflict is\n                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                      maxLength: 316\n                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                      type: string\n                  required:\n                  - lastTransitionTime\n                  - message\n                  - reason\n                  - status\n                  - type\n                  type: object\n                maxItems: 8\n                type: array\n                x-kubernetes-list-map-keys:\n                - type\n                x-kubernetes-list-type: map\n            type: object\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: gatewayclasses.networking.x-k8s.io\nspec:\n  group: networking.x-k8s.io\n  names:\n    categories:\n    - gateway-api\n    kind: GatewayClass\n    listKind: GatewayClassList\n    plural: gatewayclasses\n    shortNames:\n    - gc\n    singular: gatewayclass\n  scope: Cluster\n  versions:\n  - additionalPrinterColumns:\n    - jsonPath: .spec.controller\n      name: Controller\n      type: string\n    - jsonPath: .metadata.creationTimestamp\n      name: Age\n      type: date\n    name: v1alpha1\n    schema:\n      openAPIV3Schema:\n        description: \"GatewayClass describes a class of Gateways available to the\n          user for creating Gateway resources. \\n GatewayClass is a Cluster level\n          resource.\"\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: Spec defines the desired state of GatewayClass.\n            properties:\n              controller:\n                description: \"Controller is a domain/path string that indicates the\n                  controller that is managing Gateways of this class. \\n Example:\n                  \\\"acme.io/gateway-controller\\\". \\n This field is not mutable and\n                  cannot be empty. \\n The format of this field is DOMAIN \\\"/\\\" PATH,\n                  where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).\n                  \\n Support: Core\"\n                maxLength: 253\n                type: string\n              parametersRef:\n                description: \"ParametersRef is a reference to a resource that contains\n                  the configuration parameters corresponding to the GatewayClass.\n                  This is optional if the controller does not require any additional\n                  configuration. \\n ParametersRef can reference a standard Kubernetes\n                  resource, i.e. ConfigMap, or an implementation-specific custom resource.\n                  The resource can be cluster-scoped or namespace-scoped. \\n If the\n                  referent cannot be found, the GatewayClass's \\\"InvalidParameters\\\"\n                  status condition will be true. \\n Support: Custom\"\n                properties:\n                  group:\n                    description: Group is the group of the referent.\n                    maxLength: 253\n                    minLength: 1\n                    type: string\n                  kind:\n                    description: Kind is kind of the referent.\n                    maxLength: 253\n                    minLength: 1\n                    type: string\n                  name:\n                    description: Name is the name of the referent.\n                    maxLength: 253\n                    minLength: 1\n                    type: string\n                  namespace:\n                    description: Namespace is the namespace of the referent. This\n                      field is required when scope is set to \"Namespace\" and ignored\n                      when scope is set to \"Cluster\".\n                    maxLength: 253\n                    minLength: 1\n                    type: string\n                  scope:\n                    default: Cluster\n                    description: Scope represents if the referent is a Cluster or\n                      Namespace scoped resource. This may be set to \"Cluster\" or \"Namespace\".\n                    enum:\n                    - Cluster\n                    - Namespace\n                    type: string\n                required:\n                - group\n                - kind\n                - name\n                type: object\n            required:\n            - controller\n            type: object\n          status:\n            default:\n              conditions:\n              - lastTransitionTime: \"1970-01-01T00:00:00Z\"\n                message: Waiting for controller\n                reason: Waiting\n                status: \"False\"\n                type: Admitted\n            description: Status defines the current state of GatewayClass.\n            properties:\n              conditions:\n                default:\n                - lastTransitionTime: \"1970-01-01T00:00:00Z\"\n                  message: Waiting for controller\n                  reason: Waiting\n                  status: \"False\"\n                  type: Admitted\n                description: \"Conditions is the current status from the controller\n                  for this GatewayClass. \\n Controllers should prefer to publish conditions\n                  using values of GatewayClassConditionType for the type of each Condition.\"\n                items:\n                  description: \"Condition contains details for one aspect of the current\n                    state of this API Resource. --- This struct is intended for direct\n                    use as an array at the field path .status.conditions.  For example,\n                    type FooStatus struct{     // Represents the observations of a\n                    foo's current state.     // Known .status.conditions.type are:\n                    \\\"Available\\\", \\\"Progressing\\\", and \\\"Degraded\\\"     // +patchMergeKey=type\n                    \\    // +patchStrategy=merge     // +listType=map     // +listMapKey=type\n                    \\    Conditions []metav1.Condition `json:\\\"conditions,omitempty\\\"\n                    patchStrategy:\\\"merge\\\" patchMergeKey:\\\"type\\\" protobuf:\\\"bytes,1,rep,name=conditions\\\"`\n                    \\n     // other fields }\"\n                  properties:\n                    lastTransitionTime:\n                      description: lastTransitionTime is the last time the condition\n                        transitioned from one status to another. This should be when\n                        the underlying condition changed.  If that is not known, then\n                        using the time when the API field changed is acceptable.\n                      format: date-time\n                      type: string\n                    message:\n                      description: message is a human readable message indicating\n                        details about the transition. This may be an empty string.\n                      maxLength: 32768\n                      type: string\n                    observedGeneration:\n                      description: observedGeneration represents the .metadata.generation\n                        that the condition was set based upon. For instance, if .metadata.generation\n                        is currently 12, but the .status.conditions[x].observedGeneration\n                        is 9, the condition is out of date with respect to the current\n                        state of the instance.\n                      format: int64\n                      minimum: 0\n                      type: integer\n                    reason:\n                      description: reason contains a programmatic identifier indicating\n                        the reason for the condition's last transition. Producers\n                        of specific condition types may define expected values and\n                        meanings for this field, and whether the values are considered\n                        a guaranteed API. The value should be a CamelCase string.\n                        This field may not be empty.\n                      maxLength: 1024\n                      minLength: 1\n                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                      type: string\n                    status:\n                      description: status of the condition, one of True, False, Unknown.\n                      enum:\n                      - \"True\"\n                      - \"False\"\n                      - Unknown\n                      type: string\n                    type:\n                      description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                        --- Many .condition.type values are consistent across resources\n                        like Available, but because arbitrary conditions can be useful\n                        (see .node.status.conditions), the ability to deconflict is\n                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                      maxLength: 316\n                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                      type: string\n                  required:\n                  - lastTransitionTime\n                  - message\n                  - reason\n                  - status\n                  - type\n                  type: object\n                maxItems: 8\n                type: array\n                x-kubernetes-list-map-keys:\n                - type\n                x-kubernetes-list-type: map\n            type: object\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: gateways.networking.x-k8s.io\nspec:\n  group: networking.x-k8s.io\n  names:\n    categories:\n    - gateway-api\n    kind: Gateway\n    listKind: GatewayList\n    plural: gateways\n    shortNames:\n    - gtw\n    singular: gateway\n  scope: Namespaced\n  versions:\n  - additionalPrinterColumns:\n    - jsonPath: .spec.gatewayClassName\n      name: Class\n      type: string\n    - jsonPath: .metadata.creationTimestamp\n      name: Age\n      type: date\n    name: v1alpha1\n    schema:\n      openAPIV3Schema:\n        description: \"Gateway represents an instantiation of a service-traffic handling\n          infrastructure by binding Listeners to a set of IP addresses. \\n Implementations\n          should add the `gateway-exists-finalizer.networking.x-k8s.io` finalizer\n          on the associated GatewayClass whenever Gateway(s) is running. This ensures\n          that a GatewayClass associated with a Gateway(s) is not deleted while in\n          use.\"\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: Spec defines the desired state of Gateway.\n            properties:\n              addresses:\n                description: \"Addresses requested for this gateway. This is optional\n                  and behavior can depend on the GatewayClass. If a value is set in\n                  the spec and the requested address is invalid, the GatewayClass\n                  MUST indicate this in the associated entry in GatewayStatus.Addresses.\n                  \\n If no Addresses are specified, the GatewayClass may schedule\n                  the Gateway in an implementation-defined manner, assigning an appropriate\n                  set of Addresses. \\n The GatewayClass MUST bind all Listeners to\n                  every GatewayAddress that it assigns to the Gateway. \\n Support:\n                  Core\"\n                items:\n                  description: GatewayAddress describes an address that can be bound\n                    to a Gateway.\n                  properties:\n                    type:\n                      default: IPAddress\n                      description: \"Type of the address. \\n Support: Extended\"\n                      enum:\n                      - IPAddress\n                      - NamedAddress\n                      type: string\n                    value:\n                      description: \"Value of the address. The validity of the values\n                        will depend on the type and support by the controller. \\n\n                        Examples: `1.2.3.4`, `128::1`, `my-ip-address`.\"\n                      maxLength: 253\n                      minLength: 1\n                      type: string\n                  required:\n                  - value\n                  type: object\n                maxItems: 16\n                type: array\n              gatewayClassName:\n                description: GatewayClassName used for this Gateway. This is the name\n                  of a GatewayClass resource.\n                maxLength: 253\n                minLength: 1\n                type: string\n              listeners:\n                description: \"Listeners associated with this Gateway. Listeners define\n                  logical endpoints that are bound on this Gateway's addresses. At\n                  least one Listener MUST be specified. \\n An implementation MAY group\n                  Listeners by Port and then collapse each group of Listeners into\n                  a single Listener if the implementation determines that the Listeners\n                  in the group are \\\"compatible\\\". An implementation MAY also group\n                  together and collapse compatible Listeners belonging to different\n                  Gateways. \\n For example, an implementation might consider Listeners\n                  to be compatible with each other if all of the following conditions\n                  are met: \\n 1. Either each Listener within the group specifies the\n                  \\\"HTTP\\\"    Protocol or each Listener within the group specifies\n                  either    the \\\"HTTPS\\\" or \\\"TLS\\\" Protocol. \\n 2. Each Listener\n                  within the group specifies a Hostname that is unique    within the\n                  group. \\n 3. As a special case, one Listener within a group may\n                  omit Hostname,    in which case this Listener matches when no other\n                  Listener    matches. \\n If the implementation does collapse compatible\n                  Listeners, the hostname provided in the incoming client request\n                  MUST be matched to a Listener to find the correct set of Routes.\n                  The incoming hostname MUST be matched using the Hostname field for\n                  each Listener in order of most to least specific. That is, exact\n                  matches must be processed before wildcard matches. \\n If this field\n                  specifies multiple Listeners that have the same Port value but are\n                  not compatible, the implementation must raise a \\\"Conflicted\\\" condition\n                  in the Listener status. \\n Support: Core\"\n                items:\n                  description: Listener embodies the concept of a logical endpoint\n                    where a Gateway can accept network connections. Each listener\n                    in a Gateway must have a unique combination of Hostname, Port,\n                    and Protocol. This will be enforced by a validating webhook.\n                  properties:\n                    hostname:\n                      description: \"Hostname specifies the virtual hostname to match\n                        for protocol types that define this concept. When unspecified,\n                        \\\"\\\", or `*`, all hostnames are matched. This field can be\n                        omitted for protocols that don't require hostname based matching.\n                        \\n Hostname is the fully qualified domain name of a network\n                        host, as defined by RFC 3986. Note the following deviations\n                        from the \\\"host\\\" part of the URI as defined in the RFC: \\n\n                        1. IP literals are not allowed. 2. The `:` delimiter is not\n                        respected because ports are not allowed. \\n Hostname can be\n                        \\\"precise\\\" which is a domain name without the terminating\n                        dot of a network host (e.g. \\\"foo.example.com\\\") or \\\"wildcard\\\",\n                        which is a domain name prefixed with a single wildcard label\n                        (e.g. `*.example.com`). The wildcard character `*` must appear\n                        by itself as the first DNS label and matches only a single\n                        label. \\n Support: Core\"\n                      maxLength: 253\n                      minLength: 1\n                      type: string\n                    port:\n                      description: \"Port is the network port. Multiple listeners may\n                        use the same port, subject to the Listener compatibility rules.\n                        \\n Support: Core\"\n                      format: int32\n                      maximum: 65535\n                      minimum: 1\n                      type: integer\n                    protocol:\n                      description: \"Protocol specifies the network protocol this listener\n                        expects to receive. The GatewayClass MUST apply the Hostname\n                        match appropriately for each protocol: \\n * For the \\\"TLS\\\"\n                        protocol, the Hostname match MUST be   applied to the [SNI](https://tools.ietf.org/html/rfc6066#section-3)\n                        \\  server name offered by the client. * For the \\\"HTTP\\\" protocol,\n                        the Hostname match MUST be   applied to the host portion of\n                        the   [effective request URI](https://tools.ietf.org/html/rfc7230#section-5.5)\n                        \\  or the [:authority pseudo-header](https://tools.ietf.org/html/rfc7540#section-8.1.2.3)\n                        * For the \\\"HTTPS\\\" protocol, the Hostname match MUST be   applied\n                        at both the TLS and HTTP protocol layers. \\n Support: Core\"\n                      type: string\n                    routes:\n                      description: \"Routes specifies a schema for associating routes\n                        with the Listener using selectors. A Route is a resource capable\n                        of servicing a request and allows a cluster operator to expose\n                        a cluster resource (i.e. Service) by externally-reachable\n                        URL, load-balance traffic and terminate SSL/TLS.  Typically,\n                        a route is a \\\"HTTPRoute\\\" or \\\"TCPRoute\\\" in group \\\"networking.x-k8s.io\\\",\n                        however, an implementation may support other types of resources.\n                        \\n The Routes selector MUST select a set of objects that are\n                        compatible with the application protocol specified in the\n                        Protocol field. \\n Although a client request may technically\n                        match multiple route rules, only one rule may ultimately receive\n                        the request. Matching precedence MUST be determined in order\n                        of the following criteria: \\n * The most specific match. For\n                        example, the most specific HTTPRoute match   is determined\n                        by the longest matching combination of hostname and path.\n                        * The oldest Route based on creation timestamp. For example,\n                        a Route with   a creation timestamp of \\\"2020-09-08 01:02:03\\\"\n                        is given precedence over   a Route with a creation timestamp\n                        of \\\"2020-09-08 01:02:04\\\". * If everything else is equivalent,\n                        the Route appearing first in   alphabetical order (namespace/name)\n                        should be given precedence. For   example, foo/bar is given\n                        precedence over foo/baz. \\n All valid portions of a Route\n                        selected by this field should be supported. Invalid portions\n                        of a Route can be ignored (sometimes that will mean the full\n                        Route). If a portion of a Route transitions from valid to\n                        invalid, support for that portion of the Route should be dropped\n                        to ensure consistency. For example, even if a filter specified\n                        by a Route is invalid, the rest of the Route should still\n                        be supported. \\n Support: Core\"\n                      properties:\n                        group:\n                          default: networking.x-k8s.io\n                          description: \"Group is the group of the route resource to\n                            select. Omitting the value or specifying the empty string\n                            indicates the networking.x-k8s.io API group. For example,\n                            use the following to select an HTTPRoute: \\n routes:   kind:\n                            HTTPRoute \\n Otherwise, if an alternative API group is\n                            desired, specify the desired group: \\n routes:   group:\n                            acme.io   kind: FooRoute \\n Support: Core\"\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                        kind:\n                          description: \"Kind is the kind of the route resource to\n                            select. \\n Kind MUST correspond to kinds of routes that\n                            are compatible with the application protocol specified\n                            in the Listener's Protocol field. \\n If an implementation\n                            does not support or recognize this resource type, it SHOULD\n                            set the \\\"ResolvedRefs\\\" condition to false for this listener\n                            with the \\\"InvalidRoutesRef\\\" reason. \\n Support: Core\"\n                          type: string\n                        namespaces:\n                          default:\n                            from: Same\n                          description: \"Namespaces indicates in which namespaces Routes\n                            should be selected for this Gateway. This is restricted\n                            to the namespace of this Gateway by default. \\n Support:\n                            Core\"\n                          properties:\n                            from:\n                              default: Same\n                              description: \"From indicates where Routes will be selected\n                                for this Gateway. Possible values are: * All: Routes\n                                in all namespaces may be used by this Gateway. * Selector:\n                                Routes in namespaces selected by the selector may\n                                be used by   this Gateway. * Same: Only Routes in\n                                the same namespace may be used by this Gateway. \\n\n                                Support: Core\"\n                              enum:\n                              - All\n                              - Selector\n                              - Same\n                              type: string\n                            selector:\n                              description: \"Selector must be specified when From is\n                                set to \\\"Selector\\\". In that case, only Routes in\n                                Namespaces matching this Selector will be selected\n                                by this Gateway. This field is ignored for other values\n                                of \\\"From\\\". \\n Support: Core\"\n                              properties:\n                                matchExpressions:\n                                  description: matchExpressions is a list of label\n                                    selector requirements. The requirements are ANDed.\n                                  items:\n                                    description: A label selector requirement is a\n                                      selector that contains values, a key, and an\n                                      operator that relates the key and values.\n                                    properties:\n                                      key:\n                                        description: key is the label key that the\n                                          selector applies to.\n                                        type: string\n                                      operator:\n                                        description: operator represents a key's relationship\n                                          to a set of values. Valid operators are\n                                          In, NotIn, Exists and DoesNotExist.\n                                        type: string\n                                      values:\n                                        description: values is an array of string\n                                          values. If the operator is In or NotIn,\n                                          the values array must be non-empty. If the\n                                          operator is Exists or DoesNotExist, the\n                                          values array must be empty. This array is\n                                          replaced during a strategic merge patch.\n                                        items:\n                                          type: string\n                                        type: array\n                                    required:\n                                    - key\n                                    - operator\n                                    type: object\n                                  type: array\n                                matchLabels:\n                                  additionalProperties:\n                                    type: string\n                                  description: matchLabels is a map of {key,value}\n                                    pairs. A single {key,value} in the matchLabels\n                                    map is equivalent to an element of matchExpressions,\n                                    whose key field is \"key\", the operator is \"In\",\n                                    and the values array contains only \"value\". The\n                                    requirements are ANDed.\n                                  type: object\n                              type: object\n                          type: object\n                        selector:\n                          description: \"Selector specifies a set of route labels used\n                            for selecting routes to associate with the Gateway. If\n                            this Selector is defined, only routes matching the Selector\n                            are associated with the Gateway. An empty Selector matches\n                            all routes. \\n Support: Core\"\n                          properties:\n                            matchExpressions:\n                              description: matchExpressions is a list of label selector\n                                requirements. The requirements are ANDed.\n                              items:\n                                description: A label selector requirement is a selector\n                                  that contains values, a key, and an operator that\n                                  relates the key and values.\n                                properties:\n                                  key:\n                                    description: key is the label key that the selector\n                                      applies to.\n                                    type: string\n                                  operator:\n                                    description: operator represents a key's relationship\n                                      to a set of values. Valid operators are In,\n                                      NotIn, Exists and DoesNotExist.\n                                    type: string\n                                  values:\n                                    description: values is an array of string values.\n                                      If the operator is In or NotIn, the values array\n                                      must be non-empty. If the operator is Exists\n                                      or DoesNotExist, the values array must be empty.\n                                      This array is replaced during a strategic merge\n                                      patch.\n                                    items:\n                                      type: string\n                                    type: array\n                                required:\n                                - key\n                                - operator\n                                type: object\n                              type: array\n                            matchLabels:\n                              additionalProperties:\n                                type: string\n                              description: matchLabels is a map of {key,value} pairs.\n                                A single {key,value} in the matchLabels map is equivalent\n                                to an element of matchExpressions, whose key field\n                                is \"key\", the operator is \"In\", and the values array\n                                contains only \"value\". The requirements are ANDed.\n                              type: object\n                          type: object\n                      required:\n                      - kind\n                      type: object\n                    tls:\n                      description: \"TLS is the TLS configuration for the Listener.\n                        This field is required if the Protocol field is \\\"HTTPS\\\"\n                        or \\\"TLS\\\" and ignored otherwise. \\n The association of SNIs\n                        to Certificate defined in GatewayTLSConfig is defined based\n                        on the Hostname field for this listener. \\n The GatewayClass\n                        MUST use the longest matching SNI out of all available certificates\n                        for any TLS handshake. \\n Support: Core\"\n                      properties:\n                        certificateRef:\n                          description: \"CertificateRef is a reference to a Kubernetes\n                            object that contains a TLS certificate and private key.\n                            This certificate is used to establish a TLS handshake\n                            for requests that match the hostname of the associated\n                            listener. The referenced object MUST reside in the same\n                            namespace as Gateway. \\n This field is required when mode\n                            is set to \\\"Terminate\\\" (default) and optional otherwise.\n                            \\n CertificateRef can reference a standard Kubernetes\n                            resource, i.e. Secret, or an implementation-specific custom\n                            resource. \\n Support: Core (Kubernetes Secrets) \\n Support:\n                            Implementation-specific (Other resource types)\"\n                          properties:\n                            group:\n                              description: Group is the group of the referent.\n                              maxLength: 253\n                              minLength: 1\n                              type: string\n                            kind:\n                              description: Kind is kind of the referent.\n                              maxLength: 253\n                              minLength: 1\n                              type: string\n                            name:\n                              description: Name is the name of the referent.\n                              maxLength: 253\n                              minLength: 1\n                              type: string\n                          required:\n                          - group\n                          - kind\n                          - name\n                          type: object\n                        mode:\n                          default: Terminate\n                          description: \"Mode defines the TLS behavior for the TLS\n                            session initiated by the client. There are two possible\n                            modes: - Terminate: The TLS session between the downstream\n                            client   and the Gateway is terminated at the Gateway.\n                            This mode requires   certificateRef to be set. - Passthrough:\n                            The TLS session is NOT terminated by the Gateway. This\n                            \\  implies that the Gateway can't decipher the TLS stream\n                            except for   the ClientHello message of the TLS protocol.\n                            \\  CertificateRef field is ignored in this mode. \\n Support:\n                            Core\"\n                          enum:\n                          - Terminate\n                          - Passthrough\n                          type: string\n                        options:\n                          additionalProperties:\n                            type: string\n                          description: \"Options are a list of key/value pairs to give\n                            extended options to the provider. \\n There variation among\n                            providers as to how ciphersuites are expressed. If there\n                            is a common subset for expressing ciphers then it will\n                            make sense to loft that as a core API construct. \\n Support:\n                            Implementation-specific\"\n                          type: object\n                        routeOverride:\n                          default:\n                            certificate: Deny\n                          description: \"RouteOverride dictates if TLS settings can\n                            be configured via Routes or not. \\n CertificateRef must\n                            be defined even if `routeOverride.certificate` is set\n                            to 'Allow' as it will be used as the default certificate\n                            for the listener. \\n Support: Core\"\n                          properties:\n                            certificate:\n                              default: Deny\n                              description: \"Certificate dictates if TLS certificates\n                                can be configured via Routes. If set to 'Allow', a\n                                TLS certificate for a hostname defined in a Route\n                                takes precedence over the certificate defined in Gateway.\n                                \\n Support: Core\"\n                              enum:\n                              - Allow\n                              - Deny\n                              type: string\n                          type: object\n                      type: object\n                  required:\n                  - port\n                  - protocol\n                  - routes\n                  type: object\n                maxItems: 64\n                minItems: 1\n                type: array\n            required:\n            - gatewayClassName\n            - listeners\n            type: object\n          status:\n            default:\n              conditions:\n              - lastTransitionTime: \"1970-01-01T00:00:00Z\"\n                message: Waiting for controller\n                reason: NotReconciled\n                status: \"False\"\n                type: Scheduled\n            description: Status defines the current state of Gateway.\n            properties:\n              addresses:\n                description: \"Addresses lists the IP addresses that have actually\n                  been bound to the Gateway. These addresses may differ from the addresses\n                  in the Spec, e.g. if the Gateway automatically assigns an address\n                  from a reserved pool. \\n These addresses should all be of type \\\"IPAddress\\\".\"\n                items:\n                  description: GatewayAddress describes an address that can be bound\n                    to a Gateway.\n                  properties:\n                    type:\n                      default: IPAddress\n                      description: \"Type of the address. \\n Support: Extended\"\n                      enum:\n                      - IPAddress\n                      - NamedAddress\n                      type: string\n                    value:\n                      description: \"Value of the address. The validity of the values\n                        will depend on the type and support by the controller. \\n\n                        Examples: `1.2.3.4`, `128::1`, `my-ip-address`.\"\n                      maxLength: 253\n                      minLength: 1\n                      type: string\n                  required:\n                  - value\n                  type: object\n                maxItems: 16\n                type: array\n              conditions:\n                default:\n                - lastTransitionTime: \"1970-01-01T00:00:00Z\"\n                  message: Waiting for controller\n                  reason: NotReconciled\n                  status: \"False\"\n                  type: Scheduled\n                description: \"Conditions describe the current conditions of the Gateway.\n                  \\n Implementations should prefer to express Gateway conditions using\n                  the `GatewayConditionType` and `GatewayConditionReason` constants\n                  so that operators and tools can converge on a common vocabulary\n                  to describe Gateway state. \\n Known condition types are: \\n * \\\"Scheduled\\\"\n                  * \\\"Ready\\\"\"\n                items:\n                  description: \"Condition contains details for one aspect of the current\n                    state of this API Resource. --- This struct is intended for direct\n                    use as an array at the field path .status.conditions.  For example,\n                    type FooStatus struct{     // Represents the observations of a\n                    foo's current state.     // Known .status.conditions.type are:\n                    \\\"Available\\\", \\\"Progressing\\\", and \\\"Degraded\\\"     // +patchMergeKey=type\n                    \\    // +patchStrategy=merge     // +listType=map     // +listMapKey=type\n                    \\    Conditions []metav1.Condition `json:\\\"conditions,omitempty\\\"\n                    patchStrategy:\\\"merge\\\" patchMergeKey:\\\"type\\\" protobuf:\\\"bytes,1,rep,name=conditions\\\"`\n                    \\n     // other fields }\"\n                  properties:\n                    lastTransitionTime:\n                      description: lastTransitionTime is the last time the condition\n                        transitioned from one status to another. This should be when\n                        the underlying condition changed.  If that is not known, then\n                        using the time when the API field changed is acceptable.\n                      format: date-time\n                      type: string\n                    message:\n                      description: message is a human readable message indicating\n                        details about the transition. This may be an empty string.\n                      maxLength: 32768\n                      type: string\n                    observedGeneration:\n                      description: observedGeneration represents the .metadata.generation\n                        that the condition was set based upon. For instance, if .metadata.generation\n                        is currently 12, but the .status.conditions[x].observedGeneration\n                        is 9, the condition is out of date with respect to the current\n                        state of the instance.\n                      format: int64\n                      minimum: 0\n                      type: integer\n                    reason:\n                      description: reason contains a programmatic identifier indicating\n                        the reason for the condition's last transition. Producers\n                        of specific condition types may define expected values and\n                        meanings for this field, and whether the values are considered\n                        a guaranteed API. The value should be a CamelCase string.\n                        This field may not be empty.\n                      maxLength: 1024\n                      minLength: 1\n                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                      type: string\n                    status:\n                      description: status of the condition, one of True, False, Unknown.\n                      enum:\n                      - \"True\"\n                      - \"False\"\n                      - Unknown\n                      type: string\n                    type:\n                      description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                        --- Many .condition.type values are consistent across resources\n                        like Available, but because arbitrary conditions can be useful\n                        (see .node.status.conditions), the ability to deconflict is\n                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                      maxLength: 316\n                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                      type: string\n                  required:\n                  - lastTransitionTime\n                  - message\n                  - reason\n                  - status\n                  - type\n                  type: object\n                maxItems: 8\n                type: array\n                x-kubernetes-list-map-keys:\n                - type\n                x-kubernetes-list-type: map\n              listeners:\n                description: Listeners provide status for each unique listener port\n                  defined in the Spec.\n                items:\n                  description: ListenerStatus is the status associated with a Listener.\n                  properties:\n                    conditions:\n                      description: Conditions describe the current condition of this\n                        listener.\n                      items:\n                        description: \"Condition contains details for one aspect of\n                          the current state of this API Resource. --- This struct\n                          is intended for direct use as an array at the field path\n                          .status.conditions.  For example, type FooStatus struct{\n                          \\    // Represents the observations of a foo's current state.\n                          \\    // Known .status.conditions.type are: \\\"Available\\\",\n                          \\\"Progressing\\\", and \\\"Degraded\\\"     // +patchMergeKey=type\n                          \\    // +patchStrategy=merge     // +listType=map     //\n                          +listMapKey=type     Conditions []metav1.Condition `json:\\\"conditions,omitempty\\\"\n                          patchStrategy:\\\"merge\\\" patchMergeKey:\\\"type\\\" protobuf:\\\"bytes,1,rep,name=conditions\\\"`\n                          \\n     // other fields }\"\n                        properties:\n                          lastTransitionTime:\n                            description: lastTransitionTime is the last time the condition\n                              transitioned from one status to another. This should\n                              be when the underlying condition changed.  If that is\n                              not known, then using the time when the API field changed\n                              is acceptable.\n                            format: date-time\n                            type: string\n                          message:\n                            description: message is a human readable message indicating\n                              details about the transition. This may be an empty string.\n                            maxLength: 32768\n                            type: string\n                          observedGeneration:\n                            description: observedGeneration represents the .metadata.generation\n                              that the condition was set based upon. For instance,\n                              if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration\n                              is 9, the condition is out of date with respect to the\n                              current state of the instance.\n                            format: int64\n                            minimum: 0\n                            type: integer\n                          reason:\n                            description: reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. The value should\n                              be a CamelCase string. This field may not be empty.\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                              --- Many .condition.type values are consistent across\n                              resources like Available, but because arbitrary conditions\n                              can be useful (see .node.status.conditions), the ability\n                              to deconflict is important. The regex it matches is\n                              (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - lastTransitionTime\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      maxItems: 8\n                      type: array\n                      x-kubernetes-list-map-keys:\n                      - type\n                      x-kubernetes-list-type: map\n                    hostname:\n                      description: Hostname is the Listener hostname value for which\n                        this message is reporting the status.\n                      maxLength: 253\n                      minLength: 1\n                      type: string\n                    port:\n                      description: Port is the unique Listener port value for which\n                        this message is reporting the status.\n                      format: int32\n                      maximum: 65535\n                      minimum: 1\n                      type: integer\n                    protocol:\n                      description: Protocol is the Listener protocol value for which\n                        this message is reporting the status.\n                      type: string\n                  required:\n                  - conditions\n                  - port\n                  - protocol\n                  type: object\n                maxItems: 64\n                type: array\n                x-kubernetes-list-map-keys:\n                - port\n                x-kubernetes-list-type: map\n            type: object\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: httproutes.networking.x-k8s.io\nspec:\n  group: networking.x-k8s.io\n  names:\n    categories:\n    - gateway-api\n    kind: HTTPRoute\n    listKind: HTTPRouteList\n    plural: httproutes\n    singular: httproute\n  scope: Namespaced\n  versions:\n  - additionalPrinterColumns:\n    - jsonPath: .spec.hostnames\n      name: Hostnames\n      type: string\n    - jsonPath: .metadata.creationTimestamp\n      name: Age\n      type: date\n    name: v1alpha1\n    schema:\n      openAPIV3Schema:\n        description: HTTPRoute is the Schema for the HTTPRoute resource.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: Spec defines the desired state of HTTPRoute.\n            properties:\n              gateways:\n                default:\n                  allow: SameNamespace\n                description: Gateways defines which Gateways can use this Route.\n                properties:\n                  allow:\n                    default: SameNamespace\n                    description: 'Allow indicates which Gateways will be allowed to\n                      use this route. Possible values are: * All: Gateways in any\n                      namespace can use this route. * FromList: Only Gateways specified\n                      in GatewayRefs may use this route. * SameNamespace: Only Gateways\n                      in the same namespace may use this route.'\n                    enum:\n                    - All\n                    - FromList\n                    - SameNamespace\n                    type: string\n                  gatewayRefs:\n                    description: GatewayRefs must be specified when Allow is set to\n                      \"FromList\". In that case, only Gateways referenced in this list\n                      will be allowed to use this route. This field is ignored for\n                      other values of \"Allow\".\n                    items:\n                      description: GatewayReference identifies a Gateway in a specified\n                        namespace.\n                      properties:\n                        name:\n                          description: Name is the name of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                        namespace:\n                          description: Namespace is the namespace of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                      required:\n                      - name\n                      - namespace\n                      type: object\n                    type: array\n                type: object\n              hostnames:\n                description: \"Hostnames defines a set of hostname that should match\n                  against the HTTP Host header to select a HTTPRoute to process the\n                  request. Hostname is the fully qualified domain name of a network\n                  host, as defined by RFC 3986. Note the following deviations from\n                  the \\\"host\\\" part of the URI as defined in the RFC: \\n 1. IPs are\n                  not allowed. 2. The `:` delimiter is not respected because ports\n                  are not allowed. \\n Incoming requests are matched against the hostnames\n                  before the HTTPRoute rules. If no hostname is specified, traffic\n                  is routed based on the HTTPRouteRules. \\n Hostname can be \\\"precise\\\"\n                  which is a domain name without the terminating dot of a network\n                  host (e.g. \\\"foo.example.com\\\") or \\\"wildcard\\\", which is a domain\n                  name prefixed with a single wildcard label (e.g. `*.example.com`).\n                  The wildcard character `*` must appear by itself as the first DNS\n                  label and matches only a single label. You cannot have a wildcard\n                  label by itself (e.g. Host == `*`). Requests will be matched against\n                  the Host field in the following order: \\n 1. If Host is precise,\n                  the request matches this rule if    the HTTP Host header is equal\n                  to Host. 2. If Host is a wildcard, then the request matches this\n                  rule if    the HTTP Host header is to equal to the suffix    (removing\n                  the first label) of the wildcard rule. \\n Support: Core\"\n                items:\n                  description: Hostname is used to specify a hostname that should\n                    be matched.\n                  maxLength: 253\n                  minLength: 1\n                  type: string\n                maxItems: 16\n                type: array\n              rules:\n                default:\n                - matches:\n                  - path:\n                      type: Prefix\n                      value: /\n                description: Rules are a list of HTTP matchers, filters and actions.\n                items:\n                  description: HTTPRouteRule defines semantics for matching an HTTP\n                    request based on conditions, optionally executing additional processing\n                    steps, and forwarding the request to an API object.\n                  properties:\n                    filters:\n                      description: \"Filters define the filters that are applied to\n                        requests that match this rule. \\n The effects of ordering\n                        of multiple behaviors are currently unspecified. This can\n                        change in the future based on feedback during the alpha stage.\n                        \\n Conformance-levels at this level are defined based on the\n                        type of filter: \\n - ALL core filters MUST be supported by\n                        all implementations. - Implementers are encouraged to support\n                        extended filters. - Implementation-specific custom filters\n                        have no API guarantees across   implementations. \\n Specifying\n                        a core filter multiple times has unspecified or custom conformance.\n                        \\n Support: Core\"\n                      items:\n                        description: 'HTTPRouteFilter defines additional processing\n                          steps that must be completed during the request or response\n                          lifecycle. HTTPRouteFilters are meant as an extension point\n                          to express additional processing that may be done in Gateway\n                          implementations. Some examples include request or response\n                          modification, implementing authentication strategies, rate-limiting,\n                          and traffic shaping. API guarantee/conformance is defined\n                          based on the type of the filter. TODO(hbagdi): re-render\n                          CRDs once controller-tools supports union tags: - https://github.com/kubernetes-sigs/controller-tools/pull/298\n                          - https://github.com/kubernetes-sigs/controller-tools/issues/461'\n                        properties:\n                          extensionRef:\n                            description: \"ExtensionRef is an optional, implementation-specific\n                              extension to the \\\"filter\\\" behavior.  For example,\n                              resource \\\"myroutefilter\\\" in group \\\"networking.acme.io\\\").\n                              ExtensionRef MUST NOT be used for core and extended\n                              filters. \\n Support: Implementation-specific\"\n                            properties:\n                              group:\n                                description: Group is the group of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              kind:\n                                description: Kind is kind of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              name:\n                                description: Name is the name of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                            required:\n                            - group\n                            - kind\n                            - name\n                            type: object\n                          requestHeaderModifier:\n                            description: \"RequestHeaderModifier defines a schema for\n                              a filter that modifies request headers. \\n Support:\n                              Core\"\n                            properties:\n                              add:\n                                additionalProperties:\n                                  type: string\n                                description: \"Add adds the given header (name, value)\n                                  to the request before the action. It appends to\n                                  any existing values associated with the header name.\n                                  \\n Input:   GET /foo HTTP/1.1   my-header: foo \\n\n                                  Config:   add: {\\\"my-header\\\": \\\"bar\\\"} \\n Output:\n                                  \\  GET /foo HTTP/1.1   my-header: foo   my-header:\n                                  bar \\n Support: Extended\"\n                                type: object\n                              remove:\n                                description: \"Remove the given header(s) from the\n                                  HTTP request before the action. The value of RemoveHeader\n                                  is a list of HTTP header names. Note that the header\n                                  names are case-insensitive [RFC-2616 4.2]. \\n Input:\n                                  \\  GET /foo HTTP/1.1   my-header1: foo   my-header2:\n                                  bar   my-header3: baz \\n Config:   remove: [\\\"my-header1\\\",\n                                  \\\"my-header3\\\"] \\n Output:   GET /foo HTTP/1.1   my-header2:\n                                  bar \\n Support: Extended\"\n                                items:\n                                  type: string\n                                maxItems: 16\n                                type: array\n                              set:\n                                additionalProperties:\n                                  type: string\n                                description: \"Set overwrites the request with the\n                                  given header (name, value) before the action. \\n\n                                  Input:   GET /foo HTTP/1.1   my-header: foo \\n Config:\n                                  \\  set: {\\\"my-header\\\": \\\"bar\\\"} \\n Output:   GET\n                                  /foo HTTP/1.1   my-header: bar \\n Support: Extended\"\n                                type: object\n                            type: object\n                          requestMirror:\n                            description: \"RequestMirror defines a schema for a filter\n                              that mirrors requests. \\n Support: Extended\"\n                            properties:\n                              backendRef:\n                                description: \"BackendRef is a local object reference\n                                  to mirror matched requests to. If both BackendRef\n                                  and ServiceName are specified, ServiceName will\n                                  be given precedence. \\n If the referent cannot be\n                                  found, the rule is not included in the route. The\n                                  controller should raise the \\\"ResolvedRefs\\\" condition\n                                  on the Gateway with the \\\"DegradedRoutes\\\" reason.\n                                  The gateway status for this route should be updated\n                                  with a condition that describes the error more specifically.\n                                  \\n Support: Custom\"\n                                properties:\n                                  group:\n                                    description: Group is the group of the referent.\n                                    maxLength: 253\n                                    minLength: 1\n                                    type: string\n                                  kind:\n                                    description: Kind is kind of the referent.\n                                    maxLength: 253\n                                    minLength: 1\n                                    type: string\n                                  name:\n                                    description: Name is the name of the referent.\n                                    maxLength: 253\n                                    minLength: 1\n                                    type: string\n                                required:\n                                - group\n                                - kind\n                                - name\n                                type: object\n                              port:\n                                description: \"Port specifies the destination port\n                                  number to use for the backend referenced by the\n                                  ServiceName or BackendRef field. \\n If unspecified,\n                                  the destination port in the request is used when\n                                  forwarding to a backendRef or serviceName.\"\n                                format: int32\n                                maximum: 65535\n                                minimum: 1\n                                type: integer\n                              serviceName:\n                                description: \"ServiceName refers to the name of the\n                                  Service to mirror matched requests to. When specified,\n                                  this takes the place of BackendRef. If both BackendRef\n                                  and ServiceName are specified, ServiceName will\n                                  be given precedence. \\n If the referent cannot be\n                                  found, the rule is not included in the route. The\n                                  controller should raise the \\\"ResolvedRefs\\\" condition\n                                  on the Gateway with the \\\"DegradedRoutes\\\" reason.\n                                  The gateway status for this route should be updated\n                                  with a condition that describes the error more specifically.\n                                  \\n Support: Core\"\n                                maxLength: 253\n                                type: string\n                            type: object\n                          type:\n                            description: \"Type identifies the type of filter to apply.\n                              As with other API fields, types are classified into\n                              three conformance levels: \\n - Core: Filter types and\n                              their corresponding configuration defined by   \\\"Support:\n                              Core\\\" in this package, e.g. \\\"RequestHeaderModifier\\\".\n                              All   implementations must support core filters. \\n\n                              - Extended: Filter types and their corresponding configuration\n                              defined by   \\\"Support: Extended\\\" in this package,\n                              e.g. \\\"RequestMirror\\\". Implementers   are encouraged\n                              to support extended filters. \\n - Custom: Filters that\n                              are defined and supported by specific vendors.   In\n                              the future, filters showing convergence in behavior\n                              across multiple   implementations will be considered\n                              for inclusion in extended or core   conformance levels.\n                              Filter-specific configuration for such filters   is\n                              specified using the ExtensionRef field. `Type` should\n                              be set to   \\\"ExtensionRef\\\" for custom filters. \\n\n                              Implementers are encouraged to define custom implementation\n                              types to extend the core API with implementation-specific\n                              behavior.\"\n                            enum:\n                            - RequestHeaderModifier\n                            - RequestMirror\n                            - ExtensionRef\n                            type: string\n                        required:\n                        - type\n                        type: object\n                      maxItems: 16\n                      type: array\n                    forwardTo:\n                      description: ForwardTo defines the backend(s) where matching\n                        requests should be sent. If unspecified, the rule performs\n                        no forwarding. If unspecified and no filters are specified\n                        that would result in a response being sent, a 503 error code\n                        is returned.\n                      items:\n                        description: HTTPRouteForwardTo defines how a HTTPRoute should\n                          forward a request.\n                        properties:\n                          backendRef:\n                            description: \"BackendRef is a reference to a backend to\n                              forward matched requests to. If both BackendRef and\n                              ServiceName are specified, ServiceName will be given\n                              precedence. \\n If the referent cannot be found, the\n                              route must be dropped from the Gateway. The controller\n                              should raise the \\\"ResolvedRefs\\\" condition on the Gateway\n                              with the \\\"DegradedRoutes\\\" reason. The gateway status\n                              for this route should be updated with a condition that\n                              describes the error more specifically. \\n Support: Custom\"\n                            properties:\n                              group:\n                                description: Group is the group of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              kind:\n                                description: Kind is kind of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              name:\n                                description: Name is the name of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                            required:\n                            - group\n                            - kind\n                            - name\n                            type: object\n                          filters:\n                            description: \"Filters defined at this-level should be\n                              executed if and only if the request is being forwarded\n                              to the backend defined here. \\n Support: Custom (For\n                              broader support of filters, use the Filters field in\n                              HTTPRouteRule.)\"\n                            items:\n                              description: 'HTTPRouteFilter defines additional processing\n                                steps that must be completed during the request or\n                                response lifecycle. HTTPRouteFilters are meant as\n                                an extension point to express additional processing\n                                that may be done in Gateway implementations. Some\n                                examples include request or response modification,\n                                implementing authentication strategies, rate-limiting,\n                                and traffic shaping. API guarantee/conformance is\n                                defined based on the type of the filter. TODO(hbagdi):\n                                re-render CRDs once controller-tools supports union\n                                tags: - https://github.com/kubernetes-sigs/controller-tools/pull/298\n                                - https://github.com/kubernetes-sigs/controller-tools/issues/461'\n                              properties:\n                                extensionRef:\n                                  description: \"ExtensionRef is an optional, implementation-specific\n                                    extension to the \\\"filter\\\" behavior.  For example,\n                                    resource \\\"myroutefilter\\\" in group \\\"networking.acme.io\\\").\n                                    ExtensionRef MUST NOT be used for core and extended\n                                    filters. \\n Support: Implementation-specific\"\n                                  properties:\n                                    group:\n                                      description: Group is the group of the referent.\n                                      maxLength: 253\n                                      minLength: 1\n                                      type: string\n                                    kind:\n                                      description: Kind is kind of the referent.\n                                      maxLength: 253\n                                      minLength: 1\n                                      type: string\n                                    name:\n                                      description: Name is the name of the referent.\n                                      maxLength: 253\n                                      minLength: 1\n                                      type: string\n                                  required:\n                                  - group\n                                  - kind\n                                  - name\n                                  type: object\n                                requestHeaderModifier:\n                                  description: \"RequestHeaderModifier defines a schema\n                                    for a filter that modifies request headers. \\n\n                                    Support: Core\"\n                                  properties:\n                                    add:\n                                      additionalProperties:\n                                        type: string\n                                      description: \"Add adds the given header (name,\n                                        value) to the request before the action. It\n                                        appends to any existing values associated\n                                        with the header name. \\n Input:   GET /foo\n                                        HTTP/1.1   my-header: foo \\n Config:   add:\n                                        {\\\"my-header\\\": \\\"bar\\\"} \\n Output:   GET\n                                        /foo HTTP/1.1   my-header: foo   my-header:\n                                        bar \\n Support: Extended\"\n                                      type: object\n                                    remove:\n                                      description: \"Remove the given header(s) from\n                                        the HTTP request before the action. The value\n                                        of RemoveHeader is a list of HTTP header names.\n                                        Note that the header names are case-insensitive\n                                        [RFC-2616 4.2]. \\n Input:   GET /foo HTTP/1.1\n                                        \\  my-header1: foo   my-header2: bar   my-header3:\n                                        baz \\n Config:   remove: [\\\"my-header1\\\",\n                                        \\\"my-header3\\\"] \\n Output:   GET /foo HTTP/1.1\n                                        \\  my-header2: bar \\n Support: Extended\"\n                                      items:\n                                        type: string\n                                      maxItems: 16\n                                      type: array\n                                    set:\n                                      additionalProperties:\n                                        type: string\n                                      description: \"Set overwrites the request with\n                                        the given header (name, value) before the\n                                        action. \\n Input:   GET /foo HTTP/1.1   my-header:\n                                        foo \\n Config:   set: {\\\"my-header\\\": \\\"bar\\\"}\n                                        \\n Output:   GET /foo HTTP/1.1   my-header:\n                                        bar \\n Support: Extended\"\n                                      type: object\n                                  type: object\n                                requestMirror:\n                                  description: \"RequestMirror defines a schema for\n                                    a filter that mirrors requests. \\n Support: Extended\"\n                                  properties:\n                                    backendRef:\n                                      description: \"BackendRef is a local object reference\n                                        to mirror matched requests to. If both BackendRef\n                                        and ServiceName are specified, ServiceName\n                                        will be given precedence. \\n If the referent\n                                        cannot be found, the rule is not included\n                                        in the route. The controller should raise\n                                        the \\\"ResolvedRefs\\\" condition on the Gateway\n                                        with the \\\"DegradedRoutes\\\" reason. The gateway\n                                        status for this route should be updated with\n                                        a condition that describes the error more\n                                        specifically. \\n Support: Custom\"\n                                      properties:\n                                        group:\n                                          description: Group is the group of the referent.\n                                          maxLength: 253\n                                          minLength: 1\n                                          type: string\n                                        kind:\n                                          description: Kind is kind of the referent.\n                                          maxLength: 253\n                                          minLength: 1\n                                          type: string\n                                        name:\n                                          description: Name is the name of the referent.\n                                          maxLength: 253\n                                          minLength: 1\n                                          type: string\n                                      required:\n                                      - group\n                                      - kind\n                                      - name\n                                      type: object\n                                    port:\n                                      description: \"Port specifies the destination\n                                        port number to use for the backend referenced\n                                        by the ServiceName or BackendRef field. \\n\n                                        If unspecified, the destination port in the\n                                        request is used when forwarding to a backendRef\n                                        or serviceName.\"\n                                      format: int32\n                                      maximum: 65535\n                                      minimum: 1\n                                      type: integer\n                                    serviceName:\n                                      description: \"ServiceName refers to the name\n                                        of the Service to mirror matched requests\n                                        to. When specified, this takes the place of\n                                        BackendRef. If both BackendRef and ServiceName\n                                        are specified, ServiceName will be given precedence.\n                                        \\n If the referent cannot be found, the rule\n                                        is not included in the route. The controller\n                                        should raise the \\\"ResolvedRefs\\\" condition\n                                        on the Gateway with the \\\"DegradedRoutes\\\"\n                                        reason. The gateway status for this route\n                                        should be updated with a condition that describes\n                                        the error more specifically. \\n Support: Core\"\n                                      maxLength: 253\n                                      type: string\n                                  type: object\n                                type:\n                                  description: \"Type identifies the type of filter\n                                    to apply. As with other API fields, types are\n                                    classified into three conformance levels: \\n -\n                                    Core: Filter types and their corresponding configuration\n                                    defined by   \\\"Support: Core\\\" in this package,\n                                    e.g. \\\"RequestHeaderModifier\\\". All   implementations\n                                    must support core filters. \\n - Extended: Filter\n                                    types and their corresponding configuration defined\n                                    by   \\\"Support: Extended\\\" in this package, e.g.\n                                    \\\"RequestMirror\\\". Implementers   are encouraged\n                                    to support extended filters. \\n - Custom: Filters\n                                    that are defined and supported by specific vendors.\n                                    \\  In the future, filters showing convergence\n                                    in behavior across multiple   implementations\n                                    will be considered for inclusion in extended or\n                                    core   conformance levels. Filter-specific configuration\n                                    for such filters   is specified using the ExtensionRef\n                                    field. `Type` should be set to   \\\"ExtensionRef\\\"\n                                    for custom filters. \\n Implementers are encouraged\n                                    to define custom implementation types to extend\n                                    the core API with implementation-specific behavior.\"\n                                  enum:\n                                  - RequestHeaderModifier\n                                  - RequestMirror\n                                  - ExtensionRef\n                                  type: string\n                              required:\n                              - type\n                              type: object\n                            maxItems: 16\n                            type: array\n                          port:\n                            description: \"Port specifies the destination port number\n                              to use for the backend referenced by the ServiceName\n                              or BackendRef field. If unspecified, the destination\n                              port in the request is used when forwarding to a backendRef\n                              or serviceName. \\n Support: Core\"\n                            format: int32\n                            maximum: 65535\n                            minimum: 1\n                            type: integer\n                          serviceName:\n                            description: \"ServiceName refers to the name of the Service\n                              to forward matched requests to. When specified, this\n                              takes the place of BackendRef. If both BackendRef and\n                              ServiceName are specified, ServiceName will be given\n                              precedence. \\n If the referent cannot be found, the\n                              route must be dropped from the Gateway. The controller\n                              should raise the \\\"ResolvedRefs\\\" condition on the Gateway\n                              with the \\\"DegradedRoutes\\\" reason. The gateway status\n                              for this route should be updated with a condition that\n                              describes the error more specifically. \\n The protocol\n                              to use should be specified with the AppProtocol field\n                              on Service resources. This field was introduced in Kubernetes\n                              1.18. If using an earlier version of Kubernetes, a `networking.x-k8s.io/app-protocol`\n                              annotation on the BackendPolicy resource may be used\n                              to define the protocol. If the AppProtocol field is\n                              available, this annotation should not be used. The AppProtocol\n                              field, when populated, takes precedence over the annotation\n                              in the BackendPolicy resource. For custom backends,\n                              it is encouraged to add a semantically-equivalent field\n                              in the Custom Resource Definition. \\n Support: Core\"\n                            maxLength: 253\n                            type: string\n                          weight:\n                            default: 1\n                            description: \"Weight specifies the proportion of HTTP\n                              requests forwarded to the backend referenced by the\n                              ServiceName or BackendRef field. This is computed as\n                              weight/(sum of all weights in this ForwardTo list).\n                              For non-zero values, there may be some epsilon from\n                              the exact proportion defined here depending on the precision\n                              an implementation supports. Weight is not a percentage\n                              and the sum of weights does not need to equal 100. \\n\n                              If only one backend is specified and it has a weight\n                              greater than 0, 100% of the traffic is forwarded to\n                              that backend. If weight is set to 0, no traffic should\n                              be forwarded for this entry. If unspecified, weight\n                              defaults to 1. \\n Support: Core\"\n                            format: int32\n                            maximum: 1000000\n                            minimum: 0\n                            type: integer\n                        type: object\n                      maxItems: 16\n                      type: array\n                    matches:\n                      default:\n                      - path:\n                          type: Prefix\n                          value: /\n                      description: \"Matches define conditions used for matching the\n                        rule against incoming HTTP requests. Each match is independent,\n                        i.e. this rule will be matched if **any** one of the matches\n                        is satisfied. \\n For example, take the following matches configuration:\n                        \\n ``` matches: - path:     value: \\\"/foo\\\"   headers:     values:\n                        \\      version: \\\"2\\\" - path:     value: \\\"/v2/foo\\\" ``` \\n\n                        For a request to match against this rule, a request should\n                        satisfy EITHER of the two conditions: \\n - path prefixed with\n                        `/foo` AND contains the header `version: \\\"2\\\"` - path prefix\n                        of `/v2/foo` \\n See the documentation for HTTPRouteMatch on\n                        how to specify multiple match conditions that should be ANDed\n                        together. \\n If no matches are specified, the default is a\n                        prefix path match on \\\"/\\\", which has the effect of matching\n                        every HTTP request. \\n Each client request MUST map to a maximum\n                        of one route rule. If a request matches multiple rules, matching\n                        precedence MUST be determined in order of the following criteria,\n                        continuing on ties: \\n * The longest matching hostname. *\n                        The longest matching path. * The largest number of header\n                        matches. \\n If ties still exist across multiple Routes, matching\n                        precedence MUST be determined in order of the following criteria,\n                        continuing on ties: \\n * The oldest Route based on creation\n                        timestamp. For example, a Route with   a creation timestamp\n                        of \\\"2020-09-08 01:02:03\\\" is given precedence over   a Route\n                        with a creation timestamp of \\\"2020-09-08 01:02:04\\\". * The\n                        Route appearing first in alphabetical order by   \\\"<namespace>/<name>\\\".\n                        For example, foo/bar is given precedence over   foo/baz. \\n\n                        If ties still exist within the Route that has been given precedence,\n                        matching precedence MUST be granted to the first matching\n                        rule meeting the above criteria.\"\n                      items:\n                        description: \"HTTPRouteMatch defines the predicate used to\n                          match requests to a given action. Multiple match types are\n                          ANDed together, i.e. the match will evaluate to true only\n                          if all conditions are satisfied. \\n For example, the match\n                          below will match a HTTP request only if its path starts\n                          with `/foo` AND it contains the `version: \\\"1\\\"` header:\n                          \\n ``` match:   path:     value: \\\"/foo\\\"   headers:     values:\n                          \\      version: \\\"1\\\" ```\"\n                        properties:\n                          extensionRef:\n                            description: \"ExtensionRef is an optional, implementation-specific\n                              extension to the \\\"match\\\" behavior. For example, resource\n                              \\\"myroutematcher\\\" in group \\\"networking.acme.io\\\".\n                              If the referent cannot be found, the rule is not included\n                              in the route. The controller should raise the \\\"ResolvedRefs\\\"\n                              condition on the Gateway with the \\\"DegradedRoutes\\\"\n                              reason. The gateway status for this route should be\n                              updated with a condition that describes the error more\n                              specifically. \\n Support: Custom\"\n                            properties:\n                              group:\n                                description: Group is the group of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              kind:\n                                description: Kind is kind of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              name:\n                                description: Name is the name of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                            required:\n                            - group\n                            - kind\n                            - name\n                            type: object\n                          headers:\n                            description: Headers specifies a HTTP request header matcher.\n                            properties:\n                              type:\n                                default: Exact\n                                description: \"Type specifies how to match against\n                                  the value of the header. \\n Support: Core (Exact)\n                                  \\n Support: Custom (RegularExpression, ImplementationSpecific)\n                                  \\n Since RegularExpression PathType has custom conformance,\n                                  implementations can support POSIX, PCRE or any other\n                                  dialects of regular expressions. Please read the\n                                  implementation's documentation to determine the\n                                  supported dialect. \\n HTTP Header name matching\n                                  MUST be case-insensitive (RFC 2616 - section 4.2).\"\n                                enum:\n                                - Exact\n                                - RegularExpression\n                                - ImplementationSpecific\n                                type: string\n                              values:\n                                additionalProperties:\n                                  type: string\n                                description: \"Values is a map of HTTP Headers to be\n                                  matched. It MUST contain at least one entry. \\n\n                                  The HTTP header field name to match is the map key,\n                                  and the value of the HTTP header is the map value.\n                                  HTTP header field name matching MUST be case-insensitive.\n                                  \\n Multiple match values are ANDed together, meaning,\n                                  a request must match all the specified headers to\n                                  select the route.\"\n                                type: object\n                            required:\n                            - values\n                            type: object\n                          path:\n                            default:\n                              type: Prefix\n                              value: /\n                            description: Path specifies a HTTP request path matcher.\n                              If this field is not specified, a default prefix match\n                              on the \"/\" path is provided.\n                            properties:\n                              type:\n                                default: Prefix\n                                description: \"Type specifies how to match against\n                                  the path Value. \\n Support: Core (Exact, Prefix)\n                                  \\n Support: Custom (RegularExpression, ImplementationSpecific)\n                                  \\n Since RegularExpression PathType has custom conformance,\n                                  implementations can support POSIX, PCRE or any other\n                                  dialects of regular expressions. Please read the\n                                  implementation's documentation to determine the\n                                  supported dialect.\"\n                                enum:\n                                - Exact\n                                - Prefix\n                                - RegularExpression\n                                - ImplementationSpecific\n                                type: string\n                              value:\n                                default: /\n                                description: Value of the HTTP path to match against.\n                                type: string\n                            type: object\n                          queryParams:\n                            description: QueryParams specifies a HTTP query parameter\n                              matcher.\n                            properties:\n                              type:\n                                default: Exact\n                                description: \"Type specifies how to match against\n                                  the value of the query parameter. \\n Support: Extended\n                                  (Exact) \\n Support: Custom (RegularExpression, ImplementationSpecific)\n                                  \\n Since RegularExpression QueryParamMatchType has\n                                  custom conformance, implementations can support\n                                  POSIX, PCRE or any other dialects of regular expressions.\n                                  Please read the implementation's documentation to\n                                  determine the supported dialect.\"\n                                enum:\n                                - Exact\n                                - RegularExpression\n                                - ImplementationSpecific\n                                type: string\n                              values:\n                                additionalProperties:\n                                  type: string\n                                description: \"Values is a map of HTTP query parameters\n                                  to be matched. It MUST contain at least one entry.\n                                  \\n The query parameter name to match is the map\n                                  key, and the value of the query parameter is the\n                                  map value. \\n Multiple match values are ANDed together,\n                                  meaning, a request must match all the specified\n                                  query parameters to select the route. \\n HTTP query\n                                  parameter matching MUST be case-sensitive for both\n                                  keys and values. (See https://tools.ietf.org/html/rfc7230#section-2.7.3).\n                                  \\n Note that the query parameter key MUST always\n                                  be an exact match by string comparison.\"\n                                type: object\n                            required:\n                            - values\n                            type: object\n                        type: object\n                      maxItems: 8\n                      type: array\n                  type: object\n                maxItems: 16\n                type: array\n              tls:\n                description: \"TLS defines the TLS certificate to use for Hostnames\n                  defined in this Route. This configuration only takes effect if the\n                  AllowRouteOverride field is set to true in the associated Gateway\n                  resource. \\n Collisions can happen if multiple HTTPRoutes define\n                  a TLS certificate for the same hostname. In such a case, conflict\n                  resolution guiding principles apply, specifically, if hostnames\n                  are same and two different certificates are specified then the certificate\n                  in the oldest resource wins. \\n Please note that HTTP Route-selection\n                  takes place after the TLS Handshake (ClientHello). Due to this,\n                  TLS certificate defined here will take precedence even if the request\n                  has the potential to match multiple routes (in case multiple HTTPRoutes\n                  share the same hostname). \\n Support: Core\"\n                properties:\n                  certificateRef:\n                    description: \"CertificateRef is a reference to a Kubernetes object\n                      that contains a TLS certificate and private key. This certificate\n                      is used to establish a TLS handshake for requests that match\n                      the hostname of the associated HTTPRoute. The referenced object\n                      MUST reside in the same namespace as HTTPRoute. \\n This field\n                      is required when the TLS configuration mode of the associated\n                      Gateway listener is set to \\\"Passthrough\\\". \\n CertificateRef\n                      can reference a standard Kubernetes resource, i.e. Secret, or\n                      an implementation-specific custom resource. \\n Support: Core\n                      (Kubernetes Secrets) \\n Support: Implementation-specific (Other\n                      resource types)\"\n                    properties:\n                      group:\n                        description: Group is the group of the referent.\n                        maxLength: 253\n                        minLength: 1\n                        type: string\n                      kind:\n                        description: Kind is kind of the referent.\n                        maxLength: 253\n                        minLength: 1\n                        type: string\n                      name:\n                        description: Name is the name of the referent.\n                        maxLength: 253\n                        minLength: 1\n                        type: string\n                    required:\n                    - group\n                    - kind\n                    - name\n                    type: object\n                required:\n                - certificateRef\n                type: object\n            type: object\n          status:\n            description: Status defines the current state of HTTPRoute.\n            properties:\n              gateways:\n                description: \"Gateways is a list of Gateways that are associated with\n                  the route, and the status of the route with respect to each Gateway.\n                  When a Gateway selects this route, the controller that manages the\n                  Gateway must add an entry to this list when the controller first\n                  sees the route and should update the entry as appropriate when the\n                  route is modified. \\n A maximum of 100 Gateways will be represented\n                  in this list. If this list is full, there may be additional Gateways\n                  using this Route that are not included in the list. An empty list\n                  means the route has not been admitted by any Gateway.\"\n                items:\n                  description: RouteGatewayStatus describes the status of a route\n                    with respect to an associated Gateway.\n                  properties:\n                    conditions:\n                      description: Conditions describes the status of the route with\n                        respect to the Gateway. The \"Admitted\" condition must always\n                        be specified by controllers to indicate whether the route\n                        has been admitted or rejected by the Gateway, and why. Note\n                        that the route's availability is also subject to the Gateway's\n                        own status conditions and listener status.\n                      items:\n                        description: \"Condition contains details for one aspect of\n                          the current state of this API Resource. --- This struct\n                          is intended for direct use as an array at the field path\n                          .status.conditions.  For example, type FooStatus struct{\n                          \\    // Represents the observations of a foo's current state.\n                          \\    // Known .status.conditions.type are: \\\"Available\\\",\n                          \\\"Progressing\\\", and \\\"Degraded\\\"     // +patchMergeKey=type\n                          \\    // +patchStrategy=merge     // +listType=map     //\n                          +listMapKey=type     Conditions []metav1.Condition `json:\\\"conditions,omitempty\\\"\n                          patchStrategy:\\\"merge\\\" patchMergeKey:\\\"type\\\" protobuf:\\\"bytes,1,rep,name=conditions\\\"`\n                          \\n     // other fields }\"\n                        properties:\n                          lastTransitionTime:\n                            description: lastTransitionTime is the last time the condition\n                              transitioned from one status to another. This should\n                              be when the underlying condition changed.  If that is\n                              not known, then using the time when the API field changed\n                              is acceptable.\n                            format: date-time\n                            type: string\n                          message:\n                            description: message is a human readable message indicating\n                              details about the transition. This may be an empty string.\n                            maxLength: 32768\n                            type: string\n                          observedGeneration:\n                            description: observedGeneration represents the .metadata.generation\n                              that the condition was set based upon. For instance,\n                              if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration\n                              is 9, the condition is out of date with respect to the\n                              current state of the instance.\n                            format: int64\n                            minimum: 0\n                            type: integer\n                          reason:\n                            description: reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. The value should\n                              be a CamelCase string. This field may not be empty.\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                              --- Many .condition.type values are consistent across\n                              resources like Available, but because arbitrary conditions\n                              can be useful (see .node.status.conditions), the ability\n                              to deconflict is important. The regex it matches is\n                              (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - lastTransitionTime\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      maxItems: 8\n                      type: array\n                      x-kubernetes-list-map-keys:\n                      - type\n                      x-kubernetes-list-type: map\n                    gatewayRef:\n                      description: GatewayRef is a reference to a Gateway object that\n                        is associated with the route.\n                      properties:\n                        controller:\n                          description: \"Controller is a domain/path string that indicates\n                            the controller implementing the Gateway. This corresponds\n                            with the controller field on GatewayClass. \\n Example:\n                            \\\"acme.io/gateway-controller\\\". \\n The format of this\n                            field is DOMAIN \\\"/\\\" PATH, where DOMAIN and PATH are\n                            valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).\"\n                          maxLength: 253\n                          type: string\n                        name:\n                          description: Name is the name of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                        namespace:\n                          description: Namespace is the namespace of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                      required:\n                      - name\n                      - namespace\n                      type: object\n                  required:\n                  - gatewayRef\n                  type: object\n                maxItems: 100\n                type: array\n            required:\n            - gateways\n            type: object\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: tcproutes.networking.x-k8s.io\nspec:\n  group: networking.x-k8s.io\n  names:\n    categories:\n    - gateway-api\n    kind: TCPRoute\n    listKind: TCPRouteList\n    plural: tcproutes\n    singular: tcproute\n  scope: Namespaced\n  versions:\n  - additionalPrinterColumns:\n    - jsonPath: .metadata.creationTimestamp\n      name: Age\n      type: date\n    name: v1alpha1\n    schema:\n      openAPIV3Schema:\n        description: TCPRoute is the Schema for the TCPRoute resource.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: Spec defines the desired state of TCPRoute.\n            properties:\n              gateways:\n                default:\n                  allow: SameNamespace\n                description: Gateways defines which Gateways can use this Route.\n                properties:\n                  allow:\n                    default: SameNamespace\n                    description: 'Allow indicates which Gateways will be allowed to\n                      use this route. Possible values are: * All: Gateways in any\n                      namespace can use this route. * FromList: Only Gateways specified\n                      in GatewayRefs may use this route. * SameNamespace: Only Gateways\n                      in the same namespace may use this route.'\n                    enum:\n                    - All\n                    - FromList\n                    - SameNamespace\n                    type: string\n                  gatewayRefs:\n                    description: GatewayRefs must be specified when Allow is set to\n                      \"FromList\". In that case, only Gateways referenced in this list\n                      will be allowed to use this route. This field is ignored for\n                      other values of \"Allow\".\n                    items:\n                      description: GatewayReference identifies a Gateway in a specified\n                        namespace.\n                      properties:\n                        name:\n                          description: Name is the name of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                        namespace:\n                          description: Namespace is the namespace of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                      required:\n                      - name\n                      - namespace\n                      type: object\n                    type: array\n                type: object\n              rules:\n                description: Rules are a list of TCP matchers and actions.\n                items:\n                  description: TCPRouteRule is the configuration for a given rule.\n                  properties:\n                    forwardTo:\n                      description: ForwardTo defines the backend(s) where matching\n                        requests should be sent.\n                      items:\n                        description: RouteForwardTo defines how a Route should forward\n                          a request.\n                        properties:\n                          backendRef:\n                            description: \"BackendRef is a reference to a backend to\n                              forward matched requests to. If both BackendRef and\n                              ServiceName are specified, ServiceName will be given\n                              precedence. \\n If the referent cannot be found, the\n                              rule is not included in the route. The controller should\n                              raise the \\\"ResolvedRefs\\\" condition on the Gateway\n                              with the \\\"DegradedRoutes\\\" reason. The gateway status\n                              for this route should be updated with a condition that\n                              describes the error more specifically. \\n Support: Custom\"\n                            properties:\n                              group:\n                                description: Group is the group of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              kind:\n                                description: Kind is kind of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              name:\n                                description: Name is the name of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                            required:\n                            - group\n                            - kind\n                            - name\n                            type: object\n                          port:\n                            description: \"Port specifies the destination port number\n                              to use for the backend referenced by the ServiceName\n                              or BackendRef field. If unspecified, the destination\n                              port in the request is used when forwarding to a backendRef\n                              or serviceName. \\n Support: Core\"\n                            format: int32\n                            maximum: 65535\n                            minimum: 1\n                            type: integer\n                          serviceName:\n                            description: \"ServiceName refers to the name of the Service\n                              to forward matched requests to. When specified, this\n                              takes the place of BackendRef. If both BackendRef and\n                              ServiceName are specified, ServiceName will be given\n                              precedence. \\n If the referent cannot be found, the\n                              rule is not included in the route. The controller should\n                              raise the \\\"ResolvedRefs\\\" condition on the Gateway\n                              with the \\\"DegradedRoutes\\\" reason. The gateway status\n                              for this route should be updated with a condition that\n                              describes the error more specifically. \\n The protocol\n                              to use is defined using AppProtocol field (introduced\n                              in Kubernetes 1.18) in the Service resource. In the\n                              absence of the AppProtocol field a `networking.x-k8s.io/app-protocol`\n                              annotation on the BackendPolicy resource may be used\n                              to define the protocol. If the AppProtocol field is\n                              available, this annotation should not be used. The AppProtocol\n                              field, when populated, takes precedence over the annotation\n                              in the BackendPolicy resource. For custom backends,\n                              it is encouraged to add a semantically-equivalent field\n                              in the Custom Resource Definition. \\n Support: Core\"\n                            maxLength: 253\n                            type: string\n                          weight:\n                            default: 1\n                            description: \"Weight specifies the proportion of HTTP\n                              requests forwarded to the backend referenced by the\n                              ServiceName or BackendRef field. This is computed as\n                              weight/(sum of all weights in this ForwardTo list).\n                              For non-zero values, there may be some epsilon from\n                              the exact proportion defined here depending on the precision\n                              an implementation supports. Weight is not a percentage\n                              and the sum of weights does not need to equal 100. \\n\n                              If only one backend is specified and it has a weight\n                              greater than 0, 100% of the traffic is forwarded to\n                              that backend. If weight is set to 0, no traffic should\n                              be forwarded for this entry. If unspecified, weight\n                              defaults to 1. \\n Support: Extended\"\n                            format: int32\n                            maximum: 1000000\n                            minimum: 0\n                            type: integer\n                        type: object\n                      maxItems: 16\n                      minItems: 1\n                      type: array\n                    matches:\n                      description: \"Matches define conditions used for matching the\n                        rule against incoming TCP connections. Each match is independent,\n                        i.e. this rule will be matched if **any** one of the matches\n                        is satisfied. If unspecified (i.e. empty), this Rule will\n                        match all requests for the associated Listener. \\n Each client\n                        request MUST map to a maximum of one route rule. If a request\n                        matches multiple rules, matching precedence MUST be determined\n                        in order of the following criteria, continuing on ties: \\n\n                        * The most specific match specified by ExtensionRef. Each\n                        implementation   that supports ExtensionRef may have different\n                        ways of determining the   specificity of the referenced extension.\n                        \\n If ties still exist across multiple Routes, matching precedence\n                        MUST be determined in order of the following criteria, continuing\n                        on ties: \\n * The oldest Route based on creation timestamp.\n                        For example, a Route with   a creation timestamp of \\\"2020-09-08\n                        01:02:03\\\" is given precedence over   a Route with a creation\n                        timestamp of \\\"2020-09-08 01:02:04\\\". * The Route appearing\n                        first in alphabetical order by   \\\"<namespace>/<name>\\\". For\n                        example, foo/bar is given precedence over   foo/baz. \\n If\n                        ties still exist within the Route that has been given precedence,\n                        matching precedence MUST be granted to the first matching\n                        rule meeting the above criteria.\"\n                      items:\n                        description: TCPRouteMatch defines the predicate used to match\n                          connections to a given action.\n                        properties:\n                          extensionRef:\n                            description: \"ExtensionRef is an optional, implementation-specific\n                              extension to the \\\"match\\\" behavior.  For example, resource\n                              \\\"mytcproutematcher\\\" in group \\\"networking.acme.io\\\".\n                              If the referent cannot be found, the rule is not included\n                              in the route. The controller should raise the \\\"ResolvedRefs\\\"\n                              condition on the Gateway with the \\\"DegradedRoutes\\\"\n                              reason. The gateway status for this route should be\n                              updated with a condition that describes the error more\n                              specifically. \\n Support: Custom\"\n                            properties:\n                              group:\n                                description: Group is the group of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              kind:\n                                description: Kind is kind of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              name:\n                                description: Name is the name of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                            required:\n                            - group\n                            - kind\n                            - name\n                            type: object\n                        type: object\n                      maxItems: 8\n                      type: array\n                  required:\n                  - forwardTo\n                  type: object\n                maxItems: 16\n                minItems: 1\n                type: array\n            required:\n            - rules\n            type: object\n          status:\n            description: Status defines the current state of TCPRoute.\n            properties:\n              gateways:\n                description: \"Gateways is a list of Gateways that are associated with\n                  the route, and the status of the route with respect to each Gateway.\n                  When a Gateway selects this route, the controller that manages the\n                  Gateway must add an entry to this list when the controller first\n                  sees the route and should update the entry as appropriate when the\n                  route is modified. \\n A maximum of 100 Gateways will be represented\n                  in this list. If this list is full, there may be additional Gateways\n                  using this Route that are not included in the list. An empty list\n                  means the route has not been admitted by any Gateway.\"\n                items:\n                  description: RouteGatewayStatus describes the status of a route\n                    with respect to an associated Gateway.\n                  properties:\n                    conditions:\n                      description: Conditions describes the status of the route with\n                        respect to the Gateway. The \"Admitted\" condition must always\n                        be specified by controllers to indicate whether the route\n                        has been admitted or rejected by the Gateway, and why. Note\n                        that the route's availability is also subject to the Gateway's\n                        own status conditions and listener status.\n                      items:\n                        description: \"Condition contains details for one aspect of\n                          the current state of this API Resource. --- This struct\n                          is intended for direct use as an array at the field path\n                          .status.conditions.  For example, type FooStatus struct{\n                          \\    // Represents the observations of a foo's current state.\n                          \\    // Known .status.conditions.type are: \\\"Available\\\",\n                          \\\"Progressing\\\", and \\\"Degraded\\\"     // +patchMergeKey=type\n                          \\    // +patchStrategy=merge     // +listType=map     //\n                          +listMapKey=type     Conditions []metav1.Condition `json:\\\"conditions,omitempty\\\"\n                          patchStrategy:\\\"merge\\\" patchMergeKey:\\\"type\\\" protobuf:\\\"bytes,1,rep,name=conditions\\\"`\n                          \\n     // other fields }\"\n                        properties:\n                          lastTransitionTime:\n                            description: lastTransitionTime is the last time the condition\n                              transitioned from one status to another. This should\n                              be when the underlying condition changed.  If that is\n                              not known, then using the time when the API field changed\n                              is acceptable.\n                            format: date-time\n                            type: string\n                          message:\n                            description: message is a human readable message indicating\n                              details about the transition. This may be an empty string.\n                            maxLength: 32768\n                            type: string\n                          observedGeneration:\n                            description: observedGeneration represents the .metadata.generation\n                              that the condition was set based upon. For instance,\n                              if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration\n                              is 9, the condition is out of date with respect to the\n                              current state of the instance.\n                            format: int64\n                            minimum: 0\n                            type: integer\n                          reason:\n                            description: reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. The value should\n                              be a CamelCase string. This field may not be empty.\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                              --- Many .condition.type values are consistent across\n                              resources like Available, but because arbitrary conditions\n                              can be useful (see .node.status.conditions), the ability\n                              to deconflict is important. The regex it matches is\n                              (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - lastTransitionTime\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      maxItems: 8\n                      type: array\n                      x-kubernetes-list-map-keys:\n                      - type\n                      x-kubernetes-list-type: map\n                    gatewayRef:\n                      description: GatewayRef is a reference to a Gateway object that\n                        is associated with the route.\n                      properties:\n                        controller:\n                          description: \"Controller is a domain/path string that indicates\n                            the controller implementing the Gateway. This corresponds\n                            with the controller field on GatewayClass. \\n Example:\n                            \\\"acme.io/gateway-controller\\\". \\n The format of this\n                            field is DOMAIN \\\"/\\\" PATH, where DOMAIN and PATH are\n                            valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).\"\n                          maxLength: 253\n                          type: string\n                        name:\n                          description: Name is the name of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                        namespace:\n                          description: Namespace is the namespace of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                      required:\n                      - name\n                      - namespace\n                      type: object\n                  required:\n                  - gatewayRef\n                  type: object\n                maxItems: 100\n                type: array\n            required:\n            - gateways\n            type: object\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: tlsroutes.networking.x-k8s.io\nspec:\n  group: networking.x-k8s.io\n  names:\n    categories:\n    - gateway-api\n    kind: TLSRoute\n    listKind: TLSRouteList\n    plural: tlsroutes\n    singular: tlsroute\n  scope: Namespaced\n  versions:\n  - additionalPrinterColumns:\n    - jsonPath: .metadata.creationTimestamp\n      name: Age\n      type: date\n    name: v1alpha1\n    schema:\n      openAPIV3Schema:\n        description: \"The TLSRoute resource is similar to TCPRoute, but can be configured\n          to match against TLS-specific metadata. This allows more flexibility in\n          matching streams for a given TLS listener. \\n If you need to forward traffic\n          to a single target for a TLS listener, you could choose to use a TCPRoute\n          with a TLS listener.\"\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: Spec defines the desired state of TLSRoute.\n            properties:\n              gateways:\n                default:\n                  allow: SameNamespace\n                description: Gateways defines which Gateways can use this Route.\n                properties:\n                  allow:\n                    default: SameNamespace\n                    description: 'Allow indicates which Gateways will be allowed to\n                      use this route. Possible values are: * All: Gateways in any\n                      namespace can use this route. * FromList: Only Gateways specified\n                      in GatewayRefs may use this route. * SameNamespace: Only Gateways\n                      in the same namespace may use this route.'\n                    enum:\n                    - All\n                    - FromList\n                    - SameNamespace\n                    type: string\n                  gatewayRefs:\n                    description: GatewayRefs must be specified when Allow is set to\n                      \"FromList\". In that case, only Gateways referenced in this list\n                      will be allowed to use this route. This field is ignored for\n                      other values of \"Allow\".\n                    items:\n                      description: GatewayReference identifies a Gateway in a specified\n                        namespace.\n                      properties:\n                        name:\n                          description: Name is the name of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                        namespace:\n                          description: Namespace is the namespace of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                      required:\n                      - name\n                      - namespace\n                      type: object\n                    type: array\n                type: object\n              rules:\n                description: Rules are a list of TLS matchers and actions.\n                items:\n                  description: TLSRouteRule is the configuration for a given rule.\n                  properties:\n                    forwardTo:\n                      description: ForwardTo defines the backend(s) where matching\n                        requests should be sent.\n                      items:\n                        description: RouteForwardTo defines how a Route should forward\n                          a request.\n                        properties:\n                          backendRef:\n                            description: \"BackendRef is a reference to a backend to\n                              forward matched requests to. If both BackendRef and\n                              ServiceName are specified, ServiceName will be given\n                              precedence. \\n If the referent cannot be found, the\n                              rule is not included in the route. The controller should\n                              raise the \\\"ResolvedRefs\\\" condition on the Gateway\n                              with the \\\"DegradedRoutes\\\" reason. The gateway status\n                              for this route should be updated with a condition that\n                              describes the error more specifically. \\n Support: Custom\"\n                            properties:\n                              group:\n                                description: Group is the group of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              kind:\n                                description: Kind is kind of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              name:\n                                description: Name is the name of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                            required:\n                            - group\n                            - kind\n                            - name\n                            type: object\n                          port:\n                            description: \"Port specifies the destination port number\n                              to use for the backend referenced by the ServiceName\n                              or BackendRef field. If unspecified, the destination\n                              port in the request is used when forwarding to a backendRef\n                              or serviceName. \\n Support: Core\"\n                            format: int32\n                            maximum: 65535\n                            minimum: 1\n                            type: integer\n                          serviceName:\n                            description: \"ServiceName refers to the name of the Service\n                              to forward matched requests to. When specified, this\n                              takes the place of BackendRef. If both BackendRef and\n                              ServiceName are specified, ServiceName will be given\n                              precedence. \\n If the referent cannot be found, the\n                              rule is not included in the route. The controller should\n                              raise the \\\"ResolvedRefs\\\" condition on the Gateway\n                              with the \\\"DegradedRoutes\\\" reason. The gateway status\n                              for this route should be updated with a condition that\n                              describes the error more specifically. \\n The protocol\n                              to use is defined using AppProtocol field (introduced\n                              in Kubernetes 1.18) in the Service resource. In the\n                              absence of the AppProtocol field a `networking.x-k8s.io/app-protocol`\n                              annotation on the BackendPolicy resource may be used\n                              to define the protocol. If the AppProtocol field is\n                              available, this annotation should not be used. The AppProtocol\n                              field, when populated, takes precedence over the annotation\n                              in the BackendPolicy resource. For custom backends,\n                              it is encouraged to add a semantically-equivalent field\n                              in the Custom Resource Definition. \\n Support: Core\"\n                            maxLength: 253\n                            type: string\n                          weight:\n                            default: 1\n                            description: \"Weight specifies the proportion of HTTP\n                              requests forwarded to the backend referenced by the\n                              ServiceName or BackendRef field. This is computed as\n                              weight/(sum of all weights in this ForwardTo list).\n                              For non-zero values, there may be some epsilon from\n                              the exact proportion defined here depending on the precision\n                              an implementation supports. Weight is not a percentage\n                              and the sum of weights does not need to equal 100. \\n\n                              If only one backend is specified and it has a weight\n                              greater than 0, 100% of the traffic is forwarded to\n                              that backend. If weight is set to 0, no traffic should\n                              be forwarded for this entry. If unspecified, weight\n                              defaults to 1. \\n Support: Extended\"\n                            format: int32\n                            maximum: 1000000\n                            minimum: 0\n                            type: integer\n                        type: object\n                      maxItems: 16\n                      minItems: 1\n                      type: array\n                    matches:\n                      description: \"Matches define conditions used for matching the\n                        rule against incoming TLS connections. Each match is independent,\n                        i.e. this rule will be matched if **any** one of the matches\n                        is satisfied. If unspecified (i.e. empty), this Rule will\n                        match all requests for the associated Listener. \\n Each client\n                        request MUST map to a maximum of one route rule. If a request\n                        matches multiple rules, matching precedence MUST be determined\n                        in order of the following criteria, continuing on ties: \\n\n                        * The longest matching SNI. * The longest matching precise\n                        SNI (without a wildcard). This means that   \\\"b.example.com\\\"\n                        should be given precedence over \\\"*.example.com\\\". * The most\n                        specific match specified by ExtensionRef. Each implementation\n                        \\  that supports ExtensionRef may have different ways of determining\n                        the   specificity of the referenced extension. \\n If ties\n                        still exist across multiple Routes, matching precedence MUST\n                        be determined in order of the following criteria, continuing\n                        on ties: \\n * The oldest Route based on creation timestamp.\n                        For example, a Route with   a creation timestamp of \\\"2020-09-08\n                        01:02:03\\\" is given precedence over   a Route with a creation\n                        timestamp of \\\"2020-09-08 01:02:04\\\". * The Route appearing\n                        first in alphabetical order by   \\\"<namespace>/<name>\\\". For\n                        example, foo/bar is given precedence over   foo/baz. \\n If\n                        ties still exist within the Route that has been given precedence,\n                        matching precedence MUST be granted to the first matching\n                        rule meeting the above criteria.\"\n                      items:\n                        description: TLSRouteMatch defines the predicate used to match\n                          connections to a given action.\n                        properties:\n                          extensionRef:\n                            description: \"ExtensionRef is an optional, implementation-specific\n                              extension to the \\\"match\\\" behavior.  For example, resource\n                              \\\"mytlsroutematcher\\\" in group \\\"networking.acme.io\\\".\n                              If the referent cannot be found, the rule is not included\n                              in the route. The controller should raise the \\\"ResolvedRefs\\\"\n                              condition on the Gateway with the \\\"DegradedRoutes\\\"\n                              reason. The gateway status for this route should be\n                              updated with a condition that describes the error more\n                              specifically. \\n Support: Custom\"\n                            properties:\n                              group:\n                                description: Group is the group of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              kind:\n                                description: Kind is kind of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              name:\n                                description: Name is the name of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                            required:\n                            - group\n                            - kind\n                            - name\n                            type: object\n                          snis:\n                            description: \"SNIs defines a set of SNI names that should\n                              match against the SNI attribute of TLS ClientHello message\n                              in TLS handshake. \\n SNI can be \\\"precise\\\" which is\n                              a domain name without the terminating dot of a network\n                              host (e.g. \\\"foo.example.com\\\") or \\\"wildcard\\\", which\n                              is a domain name prefixed with a single wildcard label\n                              (e.g. `*.example.com`). The wildcard character `*` must\n                              appear by itself as the first DNS label and matches\n                              only a single label. You cannot have a wildcard label\n                              by itself (e.g. Host == `*`). \\n Requests will be matched\n                              against the Host field in the following order: \\n 1.\n                              If SNI is precise, the request matches this rule if\n                              the SNI in    ClientHello is equal to one of the defined\n                              SNIs. 2. If SNI is a wildcard, then the request matches\n                              this rule if the    SNI is to equal to the suffix (removing\n                              the first label) of the    wildcard rule. 3. If SNIs\n                              is unspecified, all requests associated with the gateway\n                              TLS    listener will match. This can be used to define\n                              a default backend    for a TLS listener. \\n Support:\n                              Core\"\n                            items:\n                              description: Hostname is used to specify a hostname\n                                that should be matched.\n                              maxLength: 253\n                              minLength: 1\n                              type: string\n                            maxItems: 16\n                            type: array\n                        type: object\n                      maxItems: 8\n                      type: array\n                  required:\n                  - forwardTo\n                  type: object\n                maxItems: 16\n                minItems: 1\n                type: array\n            required:\n            - rules\n            type: object\n          status:\n            description: Status defines the current state of TLSRoute.\n            properties:\n              gateways:\n                description: \"Gateways is a list of Gateways that are associated with\n                  the route, and the status of the route with respect to each Gateway.\n                  When a Gateway selects this route, the controller that manages the\n                  Gateway must add an entry to this list when the controller first\n                  sees the route and should update the entry as appropriate when the\n                  route is modified. \\n A maximum of 100 Gateways will be represented\n                  in this list. If this list is full, there may be additional Gateways\n                  using this Route that are not included in the list. An empty list\n                  means the route has not been admitted by any Gateway.\"\n                items:\n                  description: RouteGatewayStatus describes the status of a route\n                    with respect to an associated Gateway.\n                  properties:\n                    conditions:\n                      description: Conditions describes the status of the route with\n                        respect to the Gateway. The \"Admitted\" condition must always\n                        be specified by controllers to indicate whether the route\n                        has been admitted or rejected by the Gateway, and why. Note\n                        that the route's availability is also subject to the Gateway's\n                        own status conditions and listener status.\n                      items:\n                        description: \"Condition contains details for one aspect of\n                          the current state of this API Resource. --- This struct\n                          is intended for direct use as an array at the field path\n                          .status.conditions.  For example, type FooStatus struct{\n                          \\    // Represents the observations of a foo's current state.\n                          \\    // Known .status.conditions.type are: \\\"Available\\\",\n                          \\\"Progressing\\\", and \\\"Degraded\\\"     // +patchMergeKey=type\n                          \\    // +patchStrategy=merge     // +listType=map     //\n                          +listMapKey=type     Conditions []metav1.Condition `json:\\\"conditions,omitempty\\\"\n                          patchStrategy:\\\"merge\\\" patchMergeKey:\\\"type\\\" protobuf:\\\"bytes,1,rep,name=conditions\\\"`\n                          \\n     // other fields }\"\n                        properties:\n                          lastTransitionTime:\n                            description: lastTransitionTime is the last time the condition\n                              transitioned from one status to another. This should\n                              be when the underlying condition changed.  If that is\n                              not known, then using the time when the API field changed\n                              is acceptable.\n                            format: date-time\n                            type: string\n                          message:\n                            description: message is a human readable message indicating\n                              details about the transition. This may be an empty string.\n                            maxLength: 32768\n                            type: string\n                          observedGeneration:\n                            description: observedGeneration represents the .metadata.generation\n                              that the condition was set based upon. For instance,\n                              if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration\n                              is 9, the condition is out of date with respect to the\n                              current state of the instance.\n                            format: int64\n                            minimum: 0\n                            type: integer\n                          reason:\n                            description: reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. The value should\n                              be a CamelCase string. This field may not be empty.\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                              --- Many .condition.type values are consistent across\n                              resources like Available, but because arbitrary conditions\n                              can be useful (see .node.status.conditions), the ability\n                              to deconflict is important. The regex it matches is\n                              (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - lastTransitionTime\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      maxItems: 8\n                      type: array\n                      x-kubernetes-list-map-keys:\n                      - type\n                      x-kubernetes-list-type: map\n                    gatewayRef:\n                      description: GatewayRef is a reference to a Gateway object that\n                        is associated with the route.\n                      properties:\n                        controller:\n                          description: \"Controller is a domain/path string that indicates\n                            the controller implementing the Gateway. This corresponds\n                            with the controller field on GatewayClass. \\n Example:\n                            \\\"acme.io/gateway-controller\\\". \\n The format of this\n                            field is DOMAIN \\\"/\\\" PATH, where DOMAIN and PATH are\n                            valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).\"\n                          maxLength: 253\n                          type: string\n                        name:\n                          description: Name is the name of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                        namespace:\n                          description: Namespace is the namespace of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                      required:\n                      - name\n                      - namespace\n                      type: object\n                  required:\n                  - gatewayRef\n                  type: object\n                maxItems: 100\n                type: array\n            required:\n            - gateways\n            type: object\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: udproutes.networking.x-k8s.io\nspec:\n  group: networking.x-k8s.io\n  names:\n    categories:\n    - gateway-api\n    kind: UDPRoute\n    listKind: UDPRouteList\n    plural: udproutes\n    singular: udproute\n  scope: Namespaced\n  versions:\n  - additionalPrinterColumns:\n    - jsonPath: .metadata.creationTimestamp\n      name: Age\n      type: date\n    name: v1alpha1\n    schema:\n      openAPIV3Schema:\n        description: UDPRoute is a resource that specifies how a Gateway should forward\n          UDP traffic.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: Spec defines the desired state of UDPRoute.\n            properties:\n              gateways:\n                default:\n                  allow: SameNamespace\n                description: Gateways defines which Gateways can use this Route.\n                properties:\n                  allow:\n                    default: SameNamespace\n                    description: 'Allow indicates which Gateways will be allowed to\n                      use this route. Possible values are: * All: Gateways in any\n                      namespace can use this route. * FromList: Only Gateways specified\n                      in GatewayRefs may use this route. * SameNamespace: Only Gateways\n                      in the same namespace may use this route.'\n                    enum:\n                    - All\n                    - FromList\n                    - SameNamespace\n                    type: string\n                  gatewayRefs:\n                    description: GatewayRefs must be specified when Allow is set to\n                      \"FromList\". In that case, only Gateways referenced in this list\n                      will be allowed to use this route. This field is ignored for\n                      other values of \"Allow\".\n                    items:\n                      description: GatewayReference identifies a Gateway in a specified\n                        namespace.\n                      properties:\n                        name:\n                          description: Name is the name of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                        namespace:\n                          description: Namespace is the namespace of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                      required:\n                      - name\n                      - namespace\n                      type: object\n                    type: array\n                type: object\n              rules:\n                description: Rules are a list of UDP matchers and actions.\n                items:\n                  description: UDPRouteRule is the configuration for a given rule.\n                  properties:\n                    forwardTo:\n                      description: ForwardTo defines the backend(s) where matching\n                        requests should be sent.\n                      items:\n                        description: RouteForwardTo defines how a Route should forward\n                          a request.\n                        properties:\n                          backendRef:\n                            description: \"BackendRef is a reference to a backend to\n                              forward matched requests to. If both BackendRef and\n                              ServiceName are specified, ServiceName will be given\n                              precedence. \\n If the referent cannot be found, the\n                              rule is not included in the route. The controller should\n                              raise the \\\"ResolvedRefs\\\" condition on the Gateway\n                              with the \\\"DegradedRoutes\\\" reason. The gateway status\n                              for this route should be updated with a condition that\n                              describes the error more specifically. \\n Support: Custom\"\n                            properties:\n                              group:\n                                description: Group is the group of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              kind:\n                                description: Kind is kind of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              name:\n                                description: Name is the name of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                            required:\n                            - group\n                            - kind\n                            - name\n                            type: object\n                          port:\n                            description: \"Port specifies the destination port number\n                              to use for the backend referenced by the ServiceName\n                              or BackendRef field. If unspecified, the destination\n                              port in the request is used when forwarding to a backendRef\n                              or serviceName. \\n Support: Core\"\n                            format: int32\n                            maximum: 65535\n                            minimum: 1\n                            type: integer\n                          serviceName:\n                            description: \"ServiceName refers to the name of the Service\n                              to forward matched requests to. When specified, this\n                              takes the place of BackendRef. If both BackendRef and\n                              ServiceName are specified, ServiceName will be given\n                              precedence. \\n If the referent cannot be found, the\n                              rule is not included in the route. The controller should\n                              raise the \\\"ResolvedRefs\\\" condition on the Gateway\n                              with the \\\"DegradedRoutes\\\" reason. The gateway status\n                              for this route should be updated with a condition that\n                              describes the error more specifically. \\n The protocol\n                              to use is defined using AppProtocol field (introduced\n                              in Kubernetes 1.18) in the Service resource. In the\n                              absence of the AppProtocol field a `networking.x-k8s.io/app-protocol`\n                              annotation on the BackendPolicy resource may be used\n                              to define the protocol. If the AppProtocol field is\n                              available, this annotation should not be used. The AppProtocol\n                              field, when populated, takes precedence over the annotation\n                              in the BackendPolicy resource. For custom backends,\n                              it is encouraged to add a semantically-equivalent field\n                              in the Custom Resource Definition. \\n Support: Core\"\n                            maxLength: 253\n                            type: string\n                          weight:\n                            default: 1\n                            description: \"Weight specifies the proportion of HTTP\n                              requests forwarded to the backend referenced by the\n                              ServiceName or BackendRef field. This is computed as\n                              weight/(sum of all weights in this ForwardTo list).\n                              For non-zero values, there may be some epsilon from\n                              the exact proportion defined here depending on the precision\n                              an implementation supports. Weight is not a percentage\n                              and the sum of weights does not need to equal 100. \\n\n                              If only one backend is specified and it has a weight\n                              greater than 0, 100% of the traffic is forwarded to\n                              that backend. If weight is set to 0, no traffic should\n                              be forwarded for this entry. If unspecified, weight\n                              defaults to 1. \\n Support: Extended\"\n                            format: int32\n                            maximum: 1000000\n                            minimum: 0\n                            type: integer\n                        type: object\n                      maxItems: 16\n                      minItems: 1\n                      type: array\n                    matches:\n                      description: \"Matches define conditions used for matching the\n                        rule against incoming UDP connections. Each match is independent,\n                        i.e. this rule will be matched if **any** one of the matches\n                        is satisfied. If unspecified (i.e. empty), this Rule will\n                        match all requests for the associated Listener. \\n Each client\n                        request MUST map to a maximum of one route rule. If a request\n                        matches multiple rules, matching precedence MUST be determined\n                        in order of the following criteria, continuing on ties: \\n\n                        * The most specific match specified by ExtensionRef. Each\n                        implementation   that supports ExtensionRef may have different\n                        ways of determining the   specificity of the referenced extension.\n                        \\n If ties still exist across multiple Routes, matching precedence\n                        MUST be determined in order of the following criteria, continuing\n                        on ties: \\n * The oldest Route based on creation timestamp.\n                        For example, a Route with   a creation timestamp of \\\"2020-09-08\n                        01:02:03\\\" is given precedence over   a Route with a creation\n                        timestamp of \\\"2020-09-08 01:02:04\\\". * The Route appearing\n                        first in alphabetical order by   \\\"<namespace>/<name>\\\". For\n                        example, foo/bar is given precedence over   foo/baz. \\n If\n                        ties still exist within the Route that has been given precedence,\n                        matching precedence MUST be granted to the first matching\n                        rule meeting the above criteria.\"\n                      items:\n                        description: UDPRouteMatch defines the predicate used to match\n                          packets to a given action.\n                        properties:\n                          extensionRef:\n                            description: \"ExtensionRef is an optional, implementation-specific\n                              extension to the \\\"match\\\" behavior.  For example, resource\n                              \\\"myudproutematcher\\\" in group \\\"networking.acme.io\\\".\n                              If the referent cannot be found, the rule is not included\n                              in the route. The controller should raise the \\\"ResolvedRefs\\\"\n                              condition on the Gateway with the \\\"DegradedRoutes\\\"\n                              reason. The gateway status for this route should be\n                              updated with a condition that describes the error more\n                              specifically. \\n Support: Custom\"\n                            properties:\n                              group:\n                                description: Group is the group of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              kind:\n                                description: Kind is kind of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                              name:\n                                description: Name is the name of the referent.\n                                maxLength: 253\n                                minLength: 1\n                                type: string\n                            required:\n                            - group\n                            - kind\n                            - name\n                            type: object\n                        type: object\n                      maxItems: 8\n                      type: array\n                  required:\n                  - forwardTo\n                  type: object\n                maxItems: 16\n                minItems: 1\n                type: array\n            required:\n            - rules\n            type: object\n          status:\n            description: Status defines the current state of UDPRoute.\n            properties:\n              gateways:\n                description: \"Gateways is a list of Gateways that are associated with\n                  the route, and the status of the route with respect to each Gateway.\n                  When a Gateway selects this route, the controller that manages the\n                  Gateway must add an entry to this list when the controller first\n                  sees the route and should update the entry as appropriate when the\n                  route is modified. \\n A maximum of 100 Gateways will be represented\n                  in this list. If this list is full, there may be additional Gateways\n                  using this Route that are not included in the list. An empty list\n                  means the route has not been admitted by any Gateway.\"\n                items:\n                  description: RouteGatewayStatus describes the status of a route\n                    with respect to an associated Gateway.\n                  properties:\n                    conditions:\n                      description: Conditions describes the status of the route with\n                        respect to the Gateway. The \"Admitted\" condition must always\n                        be specified by controllers to indicate whether the route\n                        has been admitted or rejected by the Gateway, and why. Note\n                        that the route's availability is also subject to the Gateway's\n                        own status conditions and listener status.\n                      items:\n                        description: \"Condition contains details for one aspect of\n                          the current state of this API Resource. --- This struct\n                          is intended for direct use as an array at the field path\n                          .status.conditions.  For example, type FooStatus struct{\n                          \\    // Represents the observations of a foo's current state.\n                          \\    // Known .status.conditions.type are: \\\"Available\\\",\n                          \\\"Progressing\\\", and \\\"Degraded\\\"     // +patchMergeKey=type\n                          \\    // +patchStrategy=merge     // +listType=map     //\n                          +listMapKey=type     Conditions []metav1.Condition `json:\\\"conditions,omitempty\\\"\n                          patchStrategy:\\\"merge\\\" patchMergeKey:\\\"type\\\" protobuf:\\\"bytes,1,rep,name=conditions\\\"`\n                          \\n     // other fields }\"\n                        properties:\n                          lastTransitionTime:\n                            description: lastTransitionTime is the last time the condition\n                              transitioned from one status to another. This should\n                              be when the underlying condition changed.  If that is\n                              not known, then using the time when the API field changed\n                              is acceptable.\n                            format: date-time\n                            type: string\n                          message:\n                            description: message is a human readable message indicating\n                              details about the transition. This may be an empty string.\n                            maxLength: 32768\n                            type: string\n                          observedGeneration:\n                            description: observedGeneration represents the .metadata.generation\n                              that the condition was set based upon. For instance,\n                              if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration\n                              is 9, the condition is out of date with respect to the\n                              current state of the instance.\n                            format: int64\n                            minimum: 0\n                            type: integer\n                          reason:\n                            description: reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. The value should\n                              be a CamelCase string. This field may not be empty.\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                              --- Many .condition.type values are consistent across\n                              resources like Available, but because arbitrary conditions\n                              can be useful (see .node.status.conditions), the ability\n                              to deconflict is important. The regex it matches is\n                              (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - lastTransitionTime\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      maxItems: 8\n                      type: array\n                      x-kubernetes-list-map-keys:\n                      - type\n                      x-kubernetes-list-type: map\n                    gatewayRef:\n                      description: GatewayRef is a reference to a Gateway object that\n                        is associated with the route.\n                      properties:\n                        controller:\n                          description: \"Controller is a domain/path string that indicates\n                            the controller implementing the Gateway. This corresponds\n                            with the controller field on GatewayClass. \\n Example:\n                            \\\"acme.io/gateway-controller\\\". \\n The format of this\n                            field is DOMAIN \\\"/\\\" PATH, where DOMAIN and PATH are\n                            valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).\"\n                          maxLength: 253\n                          type: string\n                        name:\n                          description: Name is the name of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                        namespace:\n                          description: Namespace is the namespace of the referent.\n                          maxLength: 253\n                          minLength: 1\n                          type: string\n                      required:\n                      - name\n                      - namespace\n                      type: object\n                  required:\n                  - gatewayRef\n                  type: object\n                maxItems: 100\n                type: array\n            required:\n            - gateways\n            type: object\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n\n---\nkind: GatewayClass\napiVersion: networking.x-k8s.io/v1alpha1\nmetadata:\n  name: example\nspec:\n  controller: projectcontour.io/projectcontour/contour\n\n---\nkind: Gateway\napiVersion: networking.x-k8s.io/v1alpha1\nmetadata:\n  name: contour\n  namespace: projectcontour\nspec:\n  gatewayClassName: example\n  listeners:\n    - protocol: HTTP\n      port: 80\n      routes:\n        kind: HTTPRoute\n        selector:\n          matchLabels:\n            app: kuard\n", "# This file is generated from the individual YAML files by generate-deployment.sh. Do not\n# edit this file directly but instead edit the source files and re-render.\n#\n# Generated from:\n#       examples/contour/00-common.yaml\n#       examples/contour/01-contour-config.yaml\n#       examples/contour/01-crds.yaml\n#       examples/contour/02-job-certgen.yaml\n#       examples/contour/02-rbac.yaml\n#       examples/contour/02-role-contour.yaml\n#       examples/contour/02-service-contour.yaml\n#       examples/contour/02-service-envoy.yaml\n#       examples/contour/03-contour.yaml\n#       examples/contour/03-envoy.yaml\n#\n\n---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: projectcontour\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: contour\n  namespace: projectcontour\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: envoy\n  namespace: projectcontour\n\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: contour\n  namespace: projectcontour\ndata:\n  contour.yaml: |\n    #\n    # server:\n    #   determine which XDS Server implementation to utilize in Contour.\n    #   xds-server-type: contour\n    #\n    # Specify the Gateway API configuration.\n    # gateway:\n    #   controllerName: projectcontour.io/projectcontour/contour\n    #   name: contour\n    #   namespace: projectcontour\n    #\n    # should contour expect to be running inside a k8s cluster\n    # incluster: true\n    #\n    # path to kubeconfig (if not running inside a k8s cluster)\n    # kubeconfig: /path/to/.kube/config\n    #\n    # Disable RFC-compliant behavior to strip \"Content-Length\" header if\n    # \"Tranfer-Encoding: chunked\" is also set.\n    # disableAllowChunkedLength: false\n    # Disable HTTPProxy permitInsecure field\n    disablePermitInsecure: false\n    tls:\n    # minimum TLS version that Contour will negotiate\n    # minimum-protocol-version: \"1.2\"\n    # TLS ciphers to be supported by Envoy TLS listeners when negotiating\n    # TLS 1.2.\n    # cipher-suites:\n    # - '[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]'\n    # - '[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]'\n    # - 'ECDHE-ECDSA-AES256-GCM-SHA384'\n    # - 'ECDHE-RSA-AES256-GCM-SHA384'\n    # Defines the Kubernetes name/namespace matching a secret to use\n    # as the fallback certificate when requests which don't match the\n    # SNI defined for a vhost.\n      fallback-certificate:\n    #   name: fallback-secret-name\n    #   namespace: projectcontour\n      envoy-client-certificate:\n    #   name: envoy-client-cert-secret-name\n    #   namespace: projectcontour\n    # The following config shows the defaults for the leader election.\n    # leaderelection:\n    #   configmap-name: leader-elect\n    #   configmap-namespace: projectcontour\n    ####\n    # ExternalName Services are disabled by default due to CVE-2021-XXXXX\n    # You can re-enable them by setting this setting to `true`.\n    # This is not recommended without understanding the security implications.\n    # Please see the advisory at https://github.com/projectcontour/contour/security/advisories/GHSA-5ph6-qq5x-7jwc for the details.\n    # enableExternalNameService: false\n    ##\n    ### Logging options\n    # Default setting\n    accesslog-format: envoy\n    # To enable JSON logging in Envoy\n    # accesslog-format: json\n    # The default fields that will be logged are specified below.\n    # To customise this list, just add or remove entries.\n    # The canonical list is available at\n    # https://godoc.org/github.com/projectcontour/contour/internal/envoy#JSONFields\n    # json-fields:\n    #   - \"@timestamp\"\n    #   - \"authority\"\n    #   - \"bytes_received\"\n    #   - \"bytes_sent\"\n    #   - \"downstream_local_address\"\n    #   - \"downstream_remote_address\"\n    #   - \"duration\"\n    #   - \"method\"\n    #   - \"path\"\n    #   - \"protocol\"\n    #   - \"request_id\"\n    #   - \"requested_server_name\"\n    #   - \"response_code\"\n    #   - \"response_flags\"\n    #   - \"uber_trace_id\"\n    #   - \"upstream_cluster\"\n    #   - \"upstream_host\"\n    #   - \"upstream_local_address\"\n    #   - \"upstream_service_time\"\n    #   - \"user_agent\"\n    #   - \"x_forwarded_for\"\n    #\n    # default-http-versions:\n    # - \"HTTP/2\"\n    # - \"HTTP/1.1\"\n    #\n    # The following shows the default proxy timeout settings.\n    # timeouts:\n    #   request-timeout: infinity\n    #   connection-idle-timeout: 60s\n    #   stream-idle-timeout: 5m\n    #   max-connection-duration: infinity\n    #   delayed-close-timeout: 1s\n    #   connection-shutdown-grace-period: 5s\n    #\n    # Envoy cluster settings.\n    # cluster:\n    #   configure the cluster dns lookup family\n    #   valid options are: auto (default), v4, v6\n    #   dns-lookup-family: auto\n    #\n    # Envoy network settings.\n    # network:\n    #   Configure the number of additional ingress proxy hops from the\n    #   right side of the x-forwarded-for HTTP header to trust.\n    #   num-trusted-hops: 0\n    #\n    # Configure an optional global rate limit service.\n    # rateLimitService:\n    #   Identifies the extension service defining the rate limit service,\n    #   formatted as <namespace>/<name>.\n    #   extensionService: projectcontour/ratelimit\n    #   Defines the rate limit domain to pass to the rate limit service.\n    #   Acts as a container for a set of rate limit definitions within\n    #   the RLS.\n    #   domain: contour\n    #   Defines whether to allow requests to proceed when the rate limit\n    #   service fails to respond with a valid rate limit decision within\n    #   the timeout defined on the extension service.\n    #   failOpen: false\n    #   Defines whether to include the X-RateLimit headers X-RateLimit-Limit,\n    #   X-RateLimit-Remaining, and X-RateLimit-Reset (as defined by the IETF\n    #   Internet-Draft linked below), on responses to clients when the Rate\n    #   Limit Service is consulted for a request.\n    #   ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html\n    #   enableXRateLimitHeaders: false\n    #\n    # Global Policy settings.\n    # policy:\n    #   # Default headers to set on all requests (unless set/removed on the HTTPProxy object itself)\n    #   request-headers:\n    #     set:\n    #       # example: the hostname of the Envoy instance that proxied the request\n    #       X-Envoy-Hostname: %HOSTNAME%\n    #       # example: add a l5d-dst-override header to instruct Linkerd what service the request is destined for\n    #       l5d-dst-override: %CONTOUR_SERVICE_NAME%.%CONTOUR_NAMESPACE%.svc.cluster.local:%CONTOUR_SERVICE_PORT%\n    #   # default headers to set on all responses (unless set/removed on the HTTPProxy object itself)\n    #   response-headers:\n    #     set:\n    #       # example: Envoy flags that provide additional details about the response or connection\n    #       X-Envoy-Response-Flags: %RESPONSE_FLAGS%\n    #\n\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: extensionservices.projectcontour.io\nspec:\n  preserveUnknownFields: false\n  group: projectcontour.io\n  names:\n    kind: ExtensionService\n    listKind: ExtensionServiceList\n    plural: extensionservices\n    shortNames:\n    - extensionservice\n    - extensionservices\n    singular: extensionservice\n  scope: Namespaced\n  versions:\n  - name: v1alpha1\n    schema:\n      openAPIV3Schema:\n        description: ExtensionService is the schema for the Contour extension services\n          API. An ExtensionService resource binds a network service to the Contour\n          API so that Contour API features can be implemented by collaborating components.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: ExtensionServiceSpec defines the desired state of an ExtensionService\n              resource.\n            properties:\n              loadBalancerPolicy:\n                description: The policy for load balancing GRPC service requests.\n                  Note that the `Cookie` and `RequestHash` load balancing strategies\n                  cannot be used here.\n                properties:\n                  requestHashPolicies:\n                    description: RequestHashPolicies contains a list of hash policies\n                      to apply when the `RequestHash` load balancing strategy is chosen.\n                      If an element of the supplied list of hash policies is invalid,\n                      it will be ignored. If the list of hash policies is empty after\n                      validation, the load balancing strategy will fall back the the\n                      default `RoundRobin`.\n                    items:\n                      description: RequestHashPolicy contains configuration for an\n                        individual hash policy on a request attribute.\n                      properties:\n                        headerHashOptions:\n                          description: HeaderHashOptions should be set when request\n                            header hash based load balancing is desired. It must be\n                            the only hash option field set, otherwise this request\n                            hash policy object will be ignored.\n                          properties:\n                            headerName:\n                              description: HeaderName is the name of the HTTP request\n                                header that will be used to calculate the hash key.\n                                If the header specified is not present on a request,\n                                no hash will be produced.\n                              minLength: 1\n                              type: string\n                          type: object\n                        terminal:\n                          description: Terminal is a flag that allows for short-circuiting\n                            computing of a hash for a given request. If set to true,\n                            and the request attribute specified in the attribute hash\n                            options is present, no further hash policies will be used\n                            to calculate a hash for the request.\n                          type: boolean\n                      type: object\n                    type: array\n                  strategy:\n                    description: Strategy specifies the policy used to balance requests\n                      across the pool of backend pods. Valid policy names are `Random`,\n                      `RoundRobin`, `WeightedLeastRequest`, `Cookie`, and `RequestHash`.\n                      If an unknown strategy name is specified or no policy is supplied,\n                      the default `RoundRobin` policy is used.\n                    type: string\n                type: object\n              protocol:\n                description: Protocol may be used to specify (or override) the protocol\n                  used to reach this Service. Values may be h2 or h2c. If omitted,\n                  protocol-selection falls back on Service annotations.\n                enum:\n                - h2\n                - h2c\n                type: string\n              protocolVersion:\n                description: This field sets the version of the GRPC protocol that\n                  Envoy uses to send requests to the extension service. Since Contour\n                  always uses the v3 Envoy API, this is currently fixed at \"v3\". However,\n                  other protocol options will be available in future.\n                enum:\n                - v3\n                type: string\n              services:\n                description: Services specifies the set of Kubernetes Service resources\n                  that receive GRPC extension API requests. If no weights are specified\n                  for any of the entries in this array, traffic will be spread evenly\n                  across all the services. Otherwise, traffic is balanced proportionally\n                  to the Weight field in each entry.\n                items:\n                  description: ExtensionServiceTarget defines an Kubernetes Service\n                    to target with extension service traffic.\n                  properties:\n                    name:\n                      description: Name is the name of Kubernetes service that will\n                        accept service traffic.\n                      type: string\n                    port:\n                      description: Port (defined as Integer) to proxy traffic to since\n                        a service can have multiple defined.\n                      exclusiveMaximum: true\n                      maximum: 65536\n                      minimum: 1\n                      type: integer\n                    weight:\n                      description: Weight defines proportion of traffic to balance\n                        to the Kubernetes Service.\n                      format: int32\n                      type: integer\n                  required:\n                  - name\n                  - port\n                  type: object\n                minItems: 1\n                type: array\n              timeoutPolicy:\n                description: The timeout policy for requests to the services.\n                properties:\n                  idle:\n                    description: Timeout after which, if there are no active requests\n                      for this route, the connection between Envoy and the backend\n                      or Envoy and the external client will be closed. If not specified,\n                      there is no per-route idle timeout, though a connection manager-wide\n                      stream_idle_timeout default of 5m still applies.\n                    pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                    type: string\n                  response:\n                    description: Timeout for receiving a response from the server\n                      after processing a request from client. If not supplied, Envoy's\n                      default value of 15s applies.\n                    pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                    type: string\n                type: object\n              validation:\n                description: UpstreamValidation defines how to verify the backend\n                  service's certificate\n                properties:\n                  caSecret:\n                    description: Name of the Kubernetes secret be used to validate\n                      the certificate presented by the backend\n                    type: string\n                  subjectName:\n                    description: Key which is expected to be present in the 'subjectAltName'\n                      of the presented certificate\n                    type: string\n                required:\n                - caSecret\n                - subjectName\n                type: object\n            required:\n            - services\n            type: object\n          status:\n            description: ExtensionServiceStatus defines the observed state of an ExtensionService\n              resource.\n            properties:\n              conditions:\n                description: \"Conditions contains the current status of the ExtensionService\n                  resource. \\n Contour will update a single condition, `Valid`, that\n                  is in normal-true polarity. \\n Contour will not modify any other\n                  Conditions set in this block, in case some other controller wants\n                  to add a Condition.\"\n                items:\n                  description: \"DetailedCondition is an extension of the normal Kubernetes\n                    conditions, with two extra fields to hold sub-conditions, which\n                    provide more detailed reasons for the state (True or False) of\n                    the condition. \\n `errors` holds information about sub-conditions\n                    which are fatal to that condition and render its state False.\n                    \\n `warnings` holds information about sub-conditions which are\n                    not fatal to that condition and do not force the state to be False.\n                    \\n Remember that Conditions have a type, a status, and a reason.\n                    \\n The type is the type of the condition, the most important one\n                    in this CRD set is `Valid`. `Valid` is a positive-polarity condition:\n                    when it is `status: true` there are no problems. \\n In more detail,\n                    `status: true` means that the object is has been ingested into\n                    Contour with no errors. `warnings` may still be present, and will\n                    be indicated in the Reason field. There must be zero entries in\n                    the `errors` slice in this case. \\n `Valid`, `status: false` means\n                    that the object has had one or more fatal errors during processing\n                    into Contour.  The details of the errors will be present under\n                    the `errors` field. There must be at least one error in the `errors`\n                    slice if `status` is `false`. \\n For DetailedConditions of types\n                    other than `Valid`, the Condition must be in the negative polarity.\n                    When they have `status` `true`, there is an error. There must\n                    be at least one entry in the `errors` Subcondition slice. When\n                    they have `status` `false`, there are no serious errors, and there\n                    must be zero entries in the `errors` slice. In either case, there\n                    may be entries in the `warnings` slice. \\n Regardless of the polarity,\n                    the `reason` and `message` fields must be updated with either\n                    the detail of the reason (if there is one and only one entry in\n                    total across both the `errors` and `warnings` slices), or `MultipleReasons`\n                    if there is more than one entry.\"\n                  properties:\n                    errors:\n                      description: \"Errors contains a slice of relevant error subconditions\n                        for this object. \\n Subconditions are expected to appear when\n                        relevant (when there is a error), and disappear when not relevant.\n                        An empty slice here indicates no errors.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                    lastTransitionTime:\n                      description: lastTransitionTime is the last time the condition\n                        transitioned from one status to another. This should be when\n                        the underlying condition changed.  If that is not known, then\n                        using the time when the API field changed is acceptable.\n                      format: date-time\n                      type: string\n                    message:\n                      description: message is a human readable message indicating\n                        details about the transition. This may be an empty string.\n                      maxLength: 32768\n                      type: string\n                    observedGeneration:\n                      description: observedGeneration represents the .metadata.generation\n                        that the condition was set based upon. For instance, if .metadata.generation\n                        is currently 12, but the .status.conditions[x].observedGeneration\n                        is 9, the condition is out of date with respect to the current\n                        state of the instance.\n                      format: int64\n                      minimum: 0\n                      type: integer\n                    reason:\n                      description: reason contains a programmatic identifier indicating\n                        the reason for the condition's last transition. Producers\n                        of specific condition types may define expected values and\n                        meanings for this field, and whether the values are considered\n                        a guaranteed API. The value should be a CamelCase string.\n                        This field may not be empty.\n                      maxLength: 1024\n                      minLength: 1\n                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                      type: string\n                    status:\n                      description: status of the condition, one of True, False, Unknown.\n                      enum:\n                      - \"True\"\n                      - \"False\"\n                      - Unknown\n                      type: string\n                    type:\n                      description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                        --- Many .condition.type values are consistent across resources\n                        like Available, but because arbitrary conditions can be useful\n                        (see .node.status.conditions), the ability to deconflict is\n                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                      maxLength: 316\n                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                      type: string\n                    warnings:\n                      description: \"Warnings contains a slice of relevant warning\n                        subconditions for this object. \\n Subconditions are expected\n                        to appear when relevant (when there is a warning), and disappear\n                        when not relevant. An empty slice here indicates no warnings.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                  required:\n                  - lastTransitionTime\n                  - message\n                  - reason\n                  - status\n                  - type\n                  type: object\n                type: array\n                x-kubernetes-list-map-keys:\n                - type\n                x-kubernetes-list-type: map\n            type: object\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: httpproxies.projectcontour.io\nspec:\n  preserveUnknownFields: false\n  group: projectcontour.io\n  names:\n    kind: HTTPProxy\n    listKind: HTTPProxyList\n    plural: httpproxies\n    shortNames:\n    - proxy\n    - proxies\n    singular: httpproxy\n  scope: Namespaced\n  versions:\n  - additionalPrinterColumns:\n    - description: Fully qualified domain name\n      jsonPath: .spec.virtualhost.fqdn\n      name: FQDN\n      type: string\n    - description: Secret with TLS credentials\n      jsonPath: .spec.virtualhost.tls.secretName\n      name: TLS Secret\n      type: string\n    - description: The current status of the HTTPProxy\n      jsonPath: .status.currentStatus\n      name: Status\n      type: string\n    - description: Description of the current status\n      jsonPath: .status.description\n      name: Status Description\n      type: string\n    name: v1\n    schema:\n      openAPIV3Schema:\n        description: HTTPProxy is an Ingress CRD specification.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: HTTPProxySpec defines the spec of the CRD.\n            properties:\n              includes:\n                description: Includes allow for specific routing configuration to\n                  be included from another HTTPProxy, possibly in another namespace.\n                items:\n                  description: Include describes a set of policies that can be applied\n                    to an HTTPProxy in a namespace.\n                  properties:\n                    conditions:\n                      description: 'Conditions are a set of rules that are applied\n                        to included HTTPProxies. In effect, they are added onto the\n                        Conditions of included HTTPProxy Route structs. When applied,\n                        they are merged using AND, with one exception: There can be\n                        only one Prefix MatchCondition per Conditions slice. More\n                        than one Prefix, or contradictory Conditions, will make the\n                        include invalid.'\n                      items:\n                        description: MatchCondition are a general holder for matching\n                          rules for HTTPProxies. One of Prefix or Header must be provided.\n                        properties:\n                          header:\n                            description: Header specifies the header condition to\n                              match.\n                            properties:\n                              contains:\n                                description: Contains specifies a substring that must\n                                  be present in the header value.\n                                type: string\n                              exact:\n                                description: Exact specifies a string that the header\n                                  value must be equal to.\n                                type: string\n                              name:\n                                description: Name is the name of the header to match\n                                  against. Name is required. Header names are case\n                                  insensitive.\n                                type: string\n                              notcontains:\n                                description: NotContains specifies a substring that\n                                  must not be present in the header value.\n                                type: string\n                              notexact:\n                                description: NoExact specifies a string that the header\n                                  value must not be equal to. The condition is true\n                                  if the header has any other value.\n                                type: string\n                              notpresent:\n                                description: NotPresent specifies that condition is\n                                  true when the named header is not present. Note\n                                  that setting NotPresent to false does not make the\n                                  condition true if the named header is present.\n                                type: boolean\n                              present:\n                                description: Present specifies that condition is true\n                                  when the named header is present, regardless of\n                                  its value. Note that setting Present to false does\n                                  not make the condition true if the named header\n                                  is absent.\n                                type: boolean\n                            required:\n                            - name\n                            type: object\n                          prefix:\n                            description: Prefix defines a prefix match for a request.\n                            type: string\n                        type: object\n                      type: array\n                    name:\n                      description: Name of the HTTPProxy\n                      type: string\n                    namespace:\n                      description: Namespace of the HTTPProxy to include. Defaults\n                        to the current namespace if not supplied.\n                      type: string\n                  required:\n                  - name\n                  type: object\n                type: array\n              routes:\n                description: Routes are the ingress routes. If TCPProxy is present,\n                  Routes is ignored.\n                items:\n                  description: Route contains the set of routes for a virtual host.\n                  properties:\n                    authPolicy:\n                      description: AuthPolicy updates the authorization policy that\n                        was set on the root HTTPProxy object for client requests that\n                        match this route.\n                      properties:\n                        context:\n                          additionalProperties:\n                            type: string\n                          description: Context is a set of key/value pairs that are\n                            sent to the authentication server in the check request.\n                            If a context is provided at an enclosing scope, the entries\n                            are merged such that the inner scope overrides matching\n                            keys from the outer scope.\n                          type: object\n                        disabled:\n                          description: When true, this field disables client request\n                            authentication for the scope of the policy.\n                          type: boolean\n                      type: object\n                    conditions:\n                      description: 'Conditions are a set of rules that are applied\n                        to a Route. When applied, they are merged using AND, with\n                        one exception: There can be only one Prefix MatchCondition\n                        per Conditions slice. More than one Prefix, or contradictory\n                        Conditions, will make the route invalid.'\n                      items:\n                        description: MatchCondition are a general holder for matching\n                          rules for HTTPProxies. One of Prefix or Header must be provided.\n                        properties:\n                          header:\n                            description: Header specifies the header condition to\n                              match.\n                            properties:\n                              contains:\n                                description: Contains specifies a substring that must\n                                  be present in the header value.\n                                type: string\n                              exact:\n                                description: Exact specifies a string that the header\n                                  value must be equal to.\n                                type: string\n                              name:\n                                description: Name is the name of the header to match\n                                  against. Name is required. Header names are case\n                                  insensitive.\n                                type: string\n                              notcontains:\n                                description: NotContains specifies a substring that\n                                  must not be present in the header value.\n                                type: string\n                              notexact:\n                                description: NoExact specifies a string that the header\n                                  value must not be equal to. The condition is true\n                                  if the header has any other value.\n                                type: string\n                              notpresent:\n                                description: NotPresent specifies that condition is\n                                  true when the named header is not present. Note\n                                  that setting NotPresent to false does not make the\n                                  condition true if the named header is present.\n                                type: boolean\n                              present:\n                                description: Present specifies that condition is true\n                                  when the named header is present, regardless of\n                                  its value. Note that setting Present to false does\n                                  not make the condition true if the named header\n                                  is absent.\n                                type: boolean\n                            required:\n                            - name\n                            type: object\n                          prefix:\n                            description: Prefix defines a prefix match for a request.\n                            type: string\n                        type: object\n                      type: array\n                    enableWebsockets:\n                      description: Enables websocket support for the route.\n                      type: boolean\n                    healthCheckPolicy:\n                      description: The health check policy for this route.\n                      properties:\n                        healthyThresholdCount:\n                          description: The number of healthy health checks required\n                            before a host is marked healthy\n                          format: int64\n                          minimum: 0\n                          type: integer\n                        host:\n                          description: The value of the host header in the HTTP health\n                            check request. If left empty (default value), the name\n                            \"contour-envoy-healthcheck\" will be used.\n                          type: string\n                        intervalSeconds:\n                          description: The interval (seconds) between health checks\n                          format: int64\n                          type: integer\n                        path:\n                          description: HTTP endpoint used to perform health checks\n                            on upstream service\n                          type: string\n                        timeoutSeconds:\n                          description: The time to wait (seconds) for a health check\n                            response\n                          format: int64\n                          type: integer\n                        unhealthyThresholdCount:\n                          description: The number of unhealthy health checks required\n                            before a host is marked unhealthy\n                          format: int64\n                          minimum: 0\n                          type: integer\n                      required:\n                      - path\n                      type: object\n                    loadBalancerPolicy:\n                      description: The load balancing policy for this route.\n                      properties:\n                        requestHashPolicies:\n                          description: RequestHashPolicies contains a list of hash\n                            policies to apply when the `RequestHash` load balancing\n                            strategy is chosen. If an element of the supplied list\n                            of hash policies is invalid, it will be ignored. If the\n                            list of hash policies is empty after validation, the load\n                            balancing strategy will fall back the the default `RoundRobin`.\n                          items:\n                            description: RequestHashPolicy contains configuration\n                              for an individual hash policy on a request attribute.\n                            properties:\n                              headerHashOptions:\n                                description: HeaderHashOptions should be set when\n                                  request header hash based load balancing is desired.\n                                  It must be the only hash option field set, otherwise\n                                  this request hash policy object will be ignored.\n                                properties:\n                                  headerName:\n                                    description: HeaderName is the name of the HTTP\n                                      request header that will be used to calculate\n                                      the hash key. If the header specified is not\n                                      present on a request, no hash will be produced.\n                                    minLength: 1\n                                    type: string\n                                type: object\n                              terminal:\n                                description: Terminal is a flag that allows for short-circuiting\n                                  computing of a hash for a given request. If set\n                                  to true, and the request attribute specified in\n                                  the attribute hash options is present, no further\n                                  hash policies will be used to calculate a hash for\n                                  the request.\n                                type: boolean\n                            type: object\n                          type: array\n                        strategy:\n                          description: Strategy specifies the policy used to balance\n                            requests across the pool of backend pods. Valid policy\n                            names are `Random`, `RoundRobin`, `WeightedLeastRequest`,\n                            `Cookie`, and `RequestHash`. If an unknown strategy name\n                            is specified or no policy is supplied, the default `RoundRobin`\n                            policy is used.\n                          type: string\n                      type: object\n                    pathRewritePolicy:\n                      description: The policy for rewriting the path of the request\n                        URL after the request has been routed to a Service.\n                      properties:\n                        replacePrefix:\n                          description: ReplacePrefix describes how the path prefix\n                            should be replaced.\n                          items:\n                            description: ReplacePrefix describes a path prefix replacement.\n                            properties:\n                              prefix:\n                                description: \"Prefix specifies the URL path prefix\n                                  to be replaced. \\n If Prefix is specified, it must\n                                  exactly match the MatchCondition prefix that is\n                                  rendered by the chain of including HTTPProxies and\n                                  only that path prefix will be replaced by Replacement.\n                                  This allows HTTPProxies that are included through\n                                  multiple roots to only replace specific path prefixes,\n                                  leaving others unmodified. \\n If Prefix is not specified,\n                                  all routing prefixes rendered by the include chain\n                                  will be replaced.\"\n                                minLength: 1\n                                type: string\n                              replacement:\n                                description: Replacement is the string that the routing\n                                  path prefix will be replaced with. This must not\n                                  be empty.\n                                minLength: 1\n                                type: string\n                            required:\n                            - replacement\n                            type: object\n                          type: array\n                      type: object\n                    permitInsecure:\n                      description: Allow this path to respond to insecure requests\n                        over HTTP which are normally not permitted when a `virtualhost.tls`\n                        block is present.\n                      type: boolean\n                    rateLimitPolicy:\n                      description: The policy for rate limiting on the route.\n                      properties:\n                        global:\n                          description: Global defines global rate limiting parameters,\n                            i.e. parameters defining descriptors that are sent to\n                            an external rate limit service (RLS) for a rate limit\n                            decision on each request.\n                          properties:\n                            descriptors:\n                              description: Descriptors defines the list of descriptors\n                                that will be generated and sent to the rate limit\n                                service. Each descriptor contains 1+ key-value pair\n                                entries.\n                              items:\n                                description: RateLimitDescriptor defines a list of\n                                  key-value pair generators.\n                                properties:\n                                  entries:\n                                    description: Entries is the list of key-value\n                                      pair generators.\n                                    items:\n                                      description: RateLimitDescriptorEntry is a key-value\n                                        pair generator. Exactly one field on this\n                                        struct must be non-nil.\n                                      properties:\n                                        genericKey:\n                                          description: GenericKey defines a descriptor\n                                            entry with a static key and value.\n                                          properties:\n                                            key:\n                                              description: Key defines the key of\n                                                the descriptor entry. If not set,\n                                                the key is set to \"generic_key\".\n                                              type: string\n                                            value:\n                                              description: Value defines the value\n                                                of the descriptor entry.\n                                              minLength: 1\n                                              type: string\n                                          type: object\n                                        remoteAddress:\n                                          description: RemoteAddress defines a descriptor\n                                            entry with a key of \"remote_address\" and\n                                            a value equal to the client's IP address\n                                            (from x-forwarded-for).\n                                          type: object\n                                        requestHeader:\n                                          description: RequestHeader defines a descriptor\n                                            entry that's populated only if a given\n                                            header is present on the request. The\n                                            descriptor key is static, and the descriptor\n                                            value is equal to the value of the header.\n                                          properties:\n                                            descriptorKey:\n                                              description: DescriptorKey defines the\n                                                key to use on the descriptor entry.\n                                              minLength: 1\n                                              type: string\n                                            headerName:\n                                              description: HeaderName defines the\n                                                name of the header to look for on\n                                                the request.\n                                              minLength: 1\n                                              type: string\n                                          type: object\n                                        requestHeaderValueMatch:\n                                          description: RequestHeaderValueMatch defines\n                                            a descriptor entry that's populated if\n                                            the request's headers match a set of 1+\n                                            match criteria. The descriptor key is\n                                            \"header_match\", and the descriptor value\n                                            is static.\n                                          properties:\n                                            expectMatch:\n                                              default: true\n                                              description: ExpectMatch defines whether\n                                                the request must positively match\n                                                the match criteria in order to generate\n                                                a descriptor entry (i.e. true), or\n                                                not match the match criteria in order\n                                                to generate a descriptor entry (i.e.\n                                                false). The default is true.\n                                              type: boolean\n                                            headers:\n                                              description: Headers is a list of 1+\n                                                match criteria to apply against the\n                                                request to determine whether to populate\n                                                the descriptor entry or not.\n                                              items:\n                                                description: HeaderMatchCondition\n                                                  specifies how to conditionally match\n                                                  against HTTP headers. The Name field\n                                                  is required, but only one of the\n                                                  remaining fields should be be provided.\n                                                properties:\n                                                  contains:\n                                                    description: Contains specifies\n                                                      a substring that must be present\n                                                      in the header value.\n                                                    type: string\n                                                  exact:\n                                                    description: Exact specifies a\n                                                      string that the header value\n                                                      must be equal to.\n                                                    type: string\n                                                  name:\n                                                    description: Name is the name\n                                                      of the header to match against.\n                                                      Name is required. Header names\n                                                      are case insensitive.\n                                                    type: string\n                                                  notcontains:\n                                                    description: NotContains specifies\n                                                      a substring that must not be\n                                                      present in the header value.\n                                                    type: string\n                                                  notexact:\n                                                    description: NoExact specifies\n                                                      a string that the header value\n                                                      must not be equal to. The condition\n                                                      is true if the header has any\n                                                      other value.\n                                                    type: string\n                                                  notpresent:\n                                                    description: NotPresent specifies\n                                                      that condition is true when\n                                                      the named header is not present.\n                                                      Note that setting NotPresent\n                                                      to false does not make the condition\n                                                      true if the named header is\n                                                      present.\n                                                    type: boolean\n                                                  present:\n                                                    description: Present specifies\n                                                      that condition is true when\n                                                      the named header is present,\n                                                      regardless of its value. Note\n                                                      that setting Present to false\n                                                      does not make the condition\n                                                      true if the named header is\n                                                      absent.\n                                                    type: boolean\n                                                required:\n                                                - name\n                                                type: object\n                                              minItems: 1\n                                              type: array\n                                            value:\n                                              description: Value defines the value\n                                                of the descriptor entry.\n                                              minLength: 1\n                                              type: string\n                                          type: object\n                                      type: object\n                                    minItems: 1\n                                    type: array\n                                type: object\n                              minItems: 1\n                              type: array\n                          type: object\n                        local:\n                          description: Local defines local rate limiting parameters,\n                            i.e. parameters for rate limiting that occurs within each\n                            Envoy pod as requests are handled.\n                          properties:\n                            burst:\n                              description: Burst defines the number of requests above\n                                the requests per unit that should be allowed within\n                                a short period of time.\n                              format: int32\n                              type: integer\n                            requests:\n                              description: Requests defines how many requests per\n                                unit of time should be allowed before rate limiting\n                                occurs.\n                              format: int32\n                              minimum: 1\n                              type: integer\n                            responseHeadersToAdd:\n                              description: ResponseHeadersToAdd is an optional list\n                                of response headers to set when a request is rate-limited.\n                              items:\n                                description: HeaderValue represents a header name/value\n                                  pair\n                                properties:\n                                  name:\n                                    description: Name represents a key of a header\n                                    minLength: 1\n                                    type: string\n                                  value:\n                                    description: Value represents the value of a header\n                                      specified by a key\n                                    minLength: 1\n                                    type: string\n                                required:\n                                - name\n                                - value\n                                type: object\n                              type: array\n                            responseStatusCode:\n                              description: ResponseStatusCode is the HTTP status code\n                                to use for responses to rate-limited requests. Codes\n                                must be in the 400-599 range (inclusive). If not specified,\n                                the Envoy default of 429 (Too Many Requests) is used.\n                              format: int32\n                              maximum: 599\n                              minimum: 400\n                              type: integer\n                            unit:\n                              description: Unit defines the period of time within\n                                which requests over the limit will be rate limited.\n                                Valid values are \"second\", \"minute\" and \"hour\".\n                              enum:\n                              - second\n                              - minute\n                              - hour\n                              type: string\n                          required:\n                          - requests\n                          - unit\n                          type: object\n                      type: object\n                    requestHeadersPolicy:\n                      description: The policy for managing request headers during\n                        proxying.\n                      properties:\n                        remove:\n                          description: Remove specifies a list of HTTP header names\n                            to remove.\n                          items:\n                            type: string\n                          type: array\n                        set:\n                          description: Set specifies a list of HTTP header values\n                            that will be set in the HTTP header. If the header does\n                            not exist it will be added, otherwise it will be overwritten\n                            with the new value.\n                          items:\n                            description: HeaderValue represents a header name/value\n                              pair\n                            properties:\n                              name:\n                                description: Name represents a key of a header\n                                minLength: 1\n                                type: string\n                              value:\n                                description: Value represents the value of a header\n                                  specified by a key\n                                minLength: 1\n                                type: string\n                            required:\n                            - name\n                            - value\n                            type: object\n                          type: array\n                      type: object\n                    responseHeadersPolicy:\n                      description: The policy for managing response headers during\n                        proxying. Rewriting the 'Host' header is not supported.\n                      properties:\n                        remove:\n                          description: Remove specifies a list of HTTP header names\n                            to remove.\n                          items:\n                            type: string\n                          type: array\n                        set:\n                          description: Set specifies a list of HTTP header values\n                            that will be set in the HTTP header. If the header does\n                            not exist it will be added, otherwise it will be overwritten\n                            with the new value.\n                          items:\n                            description: HeaderValue represents a header name/value\n                              pair\n                            properties:\n                              name:\n                                description: Name represents a key of a header\n                                minLength: 1\n                                type: string\n                              value:\n                                description: Value represents the value of a header\n                                  specified by a key\n                                minLength: 1\n                                type: string\n                            required:\n                            - name\n                            - value\n                            type: object\n                          type: array\n                      type: object\n                    retryPolicy:\n                      description: The retry policy for this route.\n                      properties:\n                        count:\n                          description: NumRetries is maximum allowed number of retries.\n                            If not supplied, the number of retries is one.\n                          format: int64\n                          minimum: 0\n                          type: integer\n                        perTryTimeout:\n                          description: PerTryTimeout specifies the timeout per retry\n                            attempt. Ignored if NumRetries is not supplied.\n                          pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                          type: string\n                        retriableStatusCodes:\n                          description: \"RetriableStatusCodes specifies the HTTP status\n                            codes that should be retried. \\n This field is only respected\n                            when you include `retriable-status-codes` in the `RetryOn`\n                            field.\"\n                          items:\n                            format: int32\n                            type: integer\n                          type: array\n                        retryOn:\n                          description: \"RetryOn specifies the conditions on which\n                            to retry a request. \\n Supported [HTTP conditions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on):\n                            \\n - `5xx` - `gateway-error` - `reset` - `connect-failure`\n                            - `retriable-4xx` - `refused-stream` - `retriable-status-codes`\n                            - `retriable-headers` \\n Supported [gRPC conditions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-grpc-on):\n                            \\n - `cancelled` - `deadline-exceeded` - `internal` -\n                            `resource-exhausted` - `unavailable`\"\n                          items:\n                            description: RetryOn is a string type alias with validation\n                              to ensure that the value is valid.\n                            enum:\n                            - 5xx\n                            - gateway-error\n                            - reset\n                            - connect-failure\n                            - retriable-4xx\n                            - refused-stream\n                            - retriable-status-codes\n                            - retriable-headers\n                            - cancelled\n                            - deadline-exceeded\n                            - internal\n                            - resource-exhausted\n                            - unavailable\n                            type: string\n                          type: array\n                      type: object\n                    services:\n                      description: Services are the services to proxy traffic.\n                      items:\n                        description: Service defines an Kubernetes Service to proxy\n                          traffic.\n                        properties:\n                          mirror:\n                            description: If Mirror is true the Service will receive\n                              a read only mirror of the traffic for this route.\n                            type: boolean\n                          name:\n                            description: Name is the name of Kubernetes service to\n                              proxy traffic. Names defined here will be used to look\n                              up corresponding endpoints which contain the ips to\n                              route.\n                            type: string\n                          port:\n                            description: Port (defined as Integer) to proxy traffic\n                              to since a service can have multiple defined.\n                            exclusiveMaximum: true\n                            maximum: 65536\n                            minimum: 1\n                            type: integer\n                          protocol:\n                            description: Protocol may be used to specify (or override)\n                              the protocol used to reach this Service. Values may\n                              be tls, h2, h2c. If omitted, protocol-selection falls\n                              back on Service annotations.\n                            enum:\n                            - h2\n                            - h2c\n                            - tls\n                            type: string\n                          requestHeadersPolicy:\n                            description: The policy for managing request headers during\n                              proxying. Rewriting the 'Host' header is not supported.\n                            properties:\n                              remove:\n                                description: Remove specifies a list of HTTP header\n                                  names to remove.\n                                items:\n                                  type: string\n                                type: array\n                              set:\n                                description: Set specifies a list of HTTP header values\n                                  that will be set in the HTTP header. If the header\n                                  does not exist it will be added, otherwise it will\n                                  be overwritten with the new value.\n                                items:\n                                  description: HeaderValue represents a header name/value\n                                    pair\n                                  properties:\n                                    name:\n                                      description: Name represents a key of a header\n                                      minLength: 1\n                                      type: string\n                                    value:\n                                      description: Value represents the value of a\n                                        header specified by a key\n                                      minLength: 1\n                                      type: string\n                                  required:\n                                  - name\n                                  - value\n                                  type: object\n                                type: array\n                            type: object\n                          responseHeadersPolicy:\n                            description: The policy for managing response headers\n                              during proxying. Rewriting the 'Host' header is not\n                              supported.\n                            properties:\n                              remove:\n                                description: Remove specifies a list of HTTP header\n                                  names to remove.\n                                items:\n                                  type: string\n                                type: array\n                              set:\n                                description: Set specifies a list of HTTP header values\n                                  that will be set in the HTTP header. If the header\n                                  does not exist it will be added, otherwise it will\n                                  be overwritten with the new value.\n                                items:\n                                  description: HeaderValue represents a header name/value\n                                    pair\n                                  properties:\n                                    name:\n                                      description: Name represents a key of a header\n                                      minLength: 1\n                                      type: string\n                                    value:\n                                      description: Value represents the value of a\n                                        header specified by a key\n                                      minLength: 1\n                                      type: string\n                                  required:\n                                  - name\n                                  - value\n                                  type: object\n                                type: array\n                            type: object\n                          validation:\n                            description: UpstreamValidation defines how to verify\n                              the backend service's certificate\n                            properties:\n                              caSecret:\n                                description: Name of the Kubernetes secret be used\n                                  to validate the certificate presented by the backend\n                                type: string\n                              subjectName:\n                                description: Key which is expected to be present in\n                                  the 'subjectAltName' of the presented certificate\n                                type: string\n                            required:\n                            - caSecret\n                            - subjectName\n                            type: object\n                          weight:\n                            description: Weight defines percentage of traffic to balance\n                              traffic\n                            format: int64\n                            minimum: 0\n                            type: integer\n                        required:\n                        - name\n                        - port\n                        type: object\n                      minItems: 1\n                      type: array\n                    timeoutPolicy:\n                      description: The timeout policy for this route.\n                      properties:\n                        idle:\n                          description: Timeout after which, if there are no active\n                            requests for this route, the connection between Envoy\n                            and the backend or Envoy and the external client will\n                            be closed. If not specified, there is no per-route idle\n                            timeout, though a connection manager-wide stream_idle_timeout\n                            default of 5m still applies.\n                          pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                          type: string\n                        response:\n                          description: Timeout for receiving a response from the server\n                            after processing a request from client. If not supplied,\n                            Envoy's default value of 15s applies.\n                          pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                          type: string\n                      type: object\n                  required:\n                  - services\n                  type: object\n                type: array\n              tcpproxy:\n                description: TCPProxy holds TCP proxy information.\n                properties:\n                  healthCheckPolicy:\n                    description: The health check policy for this tcp proxy\n                    properties:\n                      healthyThresholdCount:\n                        description: The number of healthy health checks required\n                          before a host is marked healthy\n                        format: int32\n                        type: integer\n                      intervalSeconds:\n                        description: The interval (seconds) between health checks\n                        format: int64\n                        type: integer\n                      timeoutSeconds:\n                        description: The time to wait (seconds) for a health check\n                          response\n                        format: int64\n                        type: integer\n                      unhealthyThresholdCount:\n                        description: The number of unhealthy health checks required\n                          before a host is marked unhealthy\n                        format: int32\n                        type: integer\n                    type: object\n                  include:\n                    description: Include specifies that this tcpproxy should be delegated\n                      to another HTTPProxy.\n                    properties:\n                      name:\n                        description: Name of the child HTTPProxy\n                        type: string\n                      namespace:\n                        description: Namespace of the HTTPProxy to include. Defaults\n                          to the current namespace if not supplied.\n                        type: string\n                    required:\n                    - name\n                    type: object\n                  includes:\n                    description: \"IncludesDeprecated allow for specific routing configuration\n                      to be appended to another HTTPProxy in another namespace. \\n\n                      Exists due to a mistake when developing HTTPProxy and the field\n                      was marked plural when it should have been singular. This field\n                      should stay to not break backwards compatibility to v1 users.\"\n                    properties:\n                      name:\n                        description: Name of the child HTTPProxy\n                        type: string\n                      namespace:\n                        description: Namespace of the HTTPProxy to include. Defaults\n                          to the current namespace if not supplied.\n                        type: string\n                    required:\n                    - name\n                    type: object\n                  loadBalancerPolicy:\n                    description: The load balancing policy for the backend services.\n                      Note that the `Cookie` and `RequestHash` load balancing strategies\n                      cannot be used here.\n                    properties:\n                      requestHashPolicies:\n                        description: RequestHashPolicies contains a list of hash policies\n                          to apply when the `RequestHash` load balancing strategy\n                          is chosen. If an element of the supplied list of hash policies\n                          is invalid, it will be ignored. If the list of hash policies\n                          is empty after validation, the load balancing strategy will\n                          fall back the the default `RoundRobin`.\n                        items:\n                          description: RequestHashPolicy contains configuration for\n                            an individual hash policy on a request attribute.\n                          properties:\n                            headerHashOptions:\n                              description: HeaderHashOptions should be set when request\n                                header hash based load balancing is desired. It must\n                                be the only hash option field set, otherwise this\n                                request hash policy object will be ignored.\n                              properties:\n                                headerName:\n                                  description: HeaderName is the name of the HTTP\n                                    request header that will be used to calculate\n                                    the hash key. If the header specified is not present\n                                    on a request, no hash will be produced.\n                                  minLength: 1\n                                  type: string\n                              type: object\n                            terminal:\n                              description: Terminal is a flag that allows for short-circuiting\n                                computing of a hash for a given request. If set to\n                                true, and the request attribute specified in the attribute\n                                hash options is present, no further hash policies\n                                will be used to calculate a hash for the request.\n                              type: boolean\n                          type: object\n                        type: array\n                      strategy:\n                        description: Strategy specifies the policy used to balance\n                          requests across the pool of backend pods. Valid policy names\n                          are `Random`, `RoundRobin`, `WeightedLeastRequest`, `Cookie`,\n                          and `RequestHash`. If an unknown strategy name is specified\n                          or no policy is supplied, the default `RoundRobin` policy\n                          is used.\n                        type: string\n                    type: object\n                  services:\n                    description: Services are the services to proxy traffic\n                    items:\n                      description: Service defines an Kubernetes Service to proxy\n                        traffic.\n                      properties:\n                        mirror:\n                          description: If Mirror is true the Service will receive\n                            a read only mirror of the traffic for this route.\n                          type: boolean\n                        name:\n                          description: Name is the name of Kubernetes service to proxy\n                            traffic. Names defined here will be used to look up corresponding\n                            endpoints which contain the ips to route.\n                          type: string\n                        port:\n                          description: Port (defined as Integer) to proxy traffic\n                            to since a service can have multiple defined.\n                          exclusiveMaximum: true\n                          maximum: 65536\n                          minimum: 1\n                          type: integer\n                        protocol:\n                          description: Protocol may be used to specify (or override)\n                            the protocol used to reach this Service. Values may be\n                            tls, h2, h2c. If omitted, protocol-selection falls back\n                            on Service annotations.\n                          enum:\n                          - h2\n                          - h2c\n                          - tls\n                          type: string\n                        requestHeadersPolicy:\n                          description: The policy for managing request headers during\n                            proxying. Rewriting the 'Host' header is not supported.\n                          properties:\n                            remove:\n                              description: Remove specifies a list of HTTP header\n                                names to remove.\n                              items:\n                                type: string\n                              type: array\n                            set:\n                              description: Set specifies a list of HTTP header values\n                                that will be set in the HTTP header. If the header\n                                does not exist it will be added, otherwise it will\n                                be overwritten with the new value.\n                              items:\n                                description: HeaderValue represents a header name/value\n                                  pair\n                                properties:\n                                  name:\n                                    description: Name represents a key of a header\n                                    minLength: 1\n                                    type: string\n                                  value:\n                                    description: Value represents the value of a header\n                                      specified by a key\n                                    minLength: 1\n                                    type: string\n                                required:\n                                - name\n                                - value\n                                type: object\n                              type: array\n                          type: object\n                        responseHeadersPolicy:\n                          description: The policy for managing response headers during\n                            proxying. Rewriting the 'Host' header is not supported.\n                          properties:\n                            remove:\n                              description: Remove specifies a list of HTTP header\n                                names to remove.\n                              items:\n                                type: string\n                              type: array\n                            set:\n                              description: Set specifies a list of HTTP header values\n                                that will be set in the HTTP header. If the header\n                                does not exist it will be added, otherwise it will\n                                be overwritten with the new value.\n                              items:\n                                description: HeaderValue represents a header name/value\n                                  pair\n                                properties:\n                                  name:\n                                    description: Name represents a key of a header\n                                    minLength: 1\n                                    type: string\n                                  value:\n                                    description: Value represents the value of a header\n                                      specified by a key\n                                    minLength: 1\n                                    type: string\n                                required:\n                                - name\n                                - value\n                                type: object\n                              type: array\n                          type: object\n                        validation:\n                          description: UpstreamValidation defines how to verify the\n                            backend service's certificate\n                          properties:\n                            caSecret:\n                              description: Name of the Kubernetes secret be used to\n                                validate the certificate presented by the backend\n                              type: string\n                            subjectName:\n                              description: Key which is expected to be present in\n                                the 'subjectAltName' of the presented certificate\n                              type: string\n                          required:\n                          - caSecret\n                          - subjectName\n                          type: object\n                        weight:\n                          description: Weight defines percentage of traffic to balance\n                            traffic\n                          format: int64\n                          minimum: 0\n                          type: integer\n                      required:\n                      - name\n                      - port\n                      type: object\n                    type: array\n                type: object\n              virtualhost:\n                description: Virtualhost appears at most once. If it is present, the\n                  object is considered to be a \"root\" HTTPProxy.\n                properties:\n                  authorization:\n                    description: This field configures an extension service to perform\n                      authorization for this virtual host. Authorization can only\n                      be configured on virtual hosts that have TLS enabled. If the\n                      TLS configuration requires client certificate validation, the\n                      client certificate is always included in the authentication\n                      check request.\n                    properties:\n                      authPolicy:\n                        description: AuthPolicy sets a default authorization policy\n                          for client requests. This policy will be used unless overridden\n                          by individual routes.\n                        properties:\n                          context:\n                            additionalProperties:\n                              type: string\n                            description: Context is a set of key/value pairs that\n                              are sent to the authentication server in the check request.\n                              If a context is provided at an enclosing scope, the\n                              entries are merged such that the inner scope overrides\n                              matching keys from the outer scope.\n                            type: object\n                          disabled:\n                            description: When true, this field disables client request\n                              authentication for the scope of the policy.\n                            type: boolean\n                        type: object\n                      extensionRef:\n                        description: ExtensionServiceRef specifies the extension resource\n                          that will authorize client requests.\n                        properties:\n                          apiVersion:\n                            description: API version of the referent. If this field\n                              is not specified, the default \"projectcontour.io/v1alpha1\"\n                              will be used\n                            minLength: 1\n                            type: string\n                          name:\n                            description: \"Name of the referent. \\n More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\"\n                            minLength: 1\n                            type: string\n                          namespace:\n                            description: \"Namespace of the referent. If this field\n                              is not specifies, the namespace of the resource that\n                              targets the referent will be used. \\n More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/\"\n                            minLength: 1\n                            type: string\n                        type: object\n                      failOpen:\n                        description: If FailOpen is true, the client request is forwarded\n                          to the upstream service even if the authorization server\n                          fails to respond. This field should not be set in most cases.\n                          It is intended for use only while migrating applications\n                          from internal authorization to Contour external authorization.\n                        type: boolean\n                      responseTimeout:\n                        description: ResponseTimeout configures maximum time to wait\n                          for a check response from the authorization server. Timeout\n                          durations are expressed in the Go [Duration format](https://godoc.org/time#ParseDuration).\n                          Valid time units are \"ns\", \"us\" (or \"\u00b5s\"), \"ms\", \"s\", \"m\",\n                          \"h\". The string \"infinity\" is also a valid input and specifies\n                          no timeout.\n                        pattern: ^(((\\d*(\\.\\d*)?h)|(\\d*(\\.\\d*)?m)|(\\d*(\\.\\d*)?s)|(\\d*(\\.\\d*)?ms)|(\\d*(\\.\\d*)?us)|(\\d*(\\.\\d*)?\u00b5s)|(\\d*(\\.\\d*)?ns))+|infinity|infinite)$\n                        type: string\n                    required:\n                    - extensionRef\n                    type: object\n                  corsPolicy:\n                    description: Specifies the cross-origin policy to apply to the\n                      VirtualHost.\n                    properties:\n                      allowCredentials:\n                        description: Specifies whether the resource allows credentials.\n                        type: boolean\n                      allowHeaders:\n                        description: AllowHeaders specifies the content for the *access-control-allow-headers*\n                          header.\n                        items:\n                          description: CORSHeaderValue specifies the value of the\n                            string headers returned by a cross-domain request.\n                          pattern: ^[a-zA-Z0-9!#$%&'*+.^_`|~-]+$\n                          type: string\n                        type: array\n                      allowMethods:\n                        description: AllowMethods specifies the content for the *access-control-allow-methods*\n                          header.\n                        items:\n                          description: CORSHeaderValue specifies the value of the\n                            string headers returned by a cross-domain request.\n                          pattern: ^[a-zA-Z0-9!#$%&'*+.^_`|~-]+$\n                          type: string\n                        type: array\n                      allowOrigin:\n                        description: AllowOrigin specifies the origins that will be\n                          allowed to do CORS requests. \"*\" means allow any origin.\n                        items:\n                          type: string\n                        type: array\n                      exposeHeaders:\n                        description: ExposeHeaders Specifies the content for the *access-control-expose-headers*\n                          header.\n                        items:\n                          description: CORSHeaderValue specifies the value of the\n                            string headers returned by a cross-domain request.\n                          pattern: ^[a-zA-Z0-9!#$%&'*+.^_`|~-]+$\n                          type: string\n                        type: array\n                      maxAge:\n                        description: MaxAge indicates for how long the results of\n                          a preflight request can be cached. MaxAge durations are\n                          expressed in the Go [Duration format](https://godoc.org/time#ParseDuration).\n                          Valid time units are \"ns\", \"us\" (or \"\u00b5s\"), \"ms\", \"s\", \"m\",\n                          \"h\". Only positive values are allowed while 0 disables the\n                          cache requiring a preflight OPTIONS check for all cross-origin\n                          requests.\n                        type: string\n                    required:\n                    - allowMethods\n                    - allowOrigin\n                    type: object\n                  fqdn:\n                    description: The fully qualified domain name of the root of the\n                      ingress tree all leaves of the DAG rooted at this object relate\n                      to the fqdn.\n                    type: string\n                  rateLimitPolicy:\n                    description: The policy for rate limiting on the virtual host.\n                    properties:\n                      global:\n                        description: Global defines global rate limiting parameters,\n                          i.e. parameters defining descriptors that are sent to an\n                          external rate limit service (RLS) for a rate limit decision\n                          on each request.\n                        properties:\n                          descriptors:\n                            description: Descriptors defines the list of descriptors\n                              that will be generated and sent to the rate limit service.\n                              Each descriptor contains 1+ key-value pair entries.\n                            items:\n                              description: RateLimitDescriptor defines a list of key-value\n                                pair generators.\n                              properties:\n                                entries:\n                                  description: Entries is the list of key-value pair\n                                    generators.\n                                  items:\n                                    description: RateLimitDescriptorEntry is a key-value\n                                      pair generator. Exactly one field on this struct\n                                      must be non-nil.\n                                    properties:\n                                      genericKey:\n                                        description: GenericKey defines a descriptor\n                                          entry with a static key and value.\n                                        properties:\n                                          key:\n                                            description: Key defines the key of the\n                                              descriptor entry. If not set, the key\n                                              is set to \"generic_key\".\n                                            type: string\n                                          value:\n                                            description: Value defines the value of\n                                              the descriptor entry.\n                                            minLength: 1\n                                            type: string\n                                        type: object\n                                      remoteAddress:\n                                        description: RemoteAddress defines a descriptor\n                                          entry with a key of \"remote_address\" and\n                                          a value equal to the client's IP address\n                                          (from x-forwarded-for).\n                                        type: object\n                                      requestHeader:\n                                        description: RequestHeader defines a descriptor\n                                          entry that's populated only if a given header\n                                          is present on the request. The descriptor\n                                          key is static, and the descriptor value\n                                          is equal to the value of the header.\n                                        properties:\n                                          descriptorKey:\n                                            description: DescriptorKey defines the\n                                              key to use on the descriptor entry.\n                                            minLength: 1\n                                            type: string\n                                          headerName:\n                                            description: HeaderName defines the name\n                                              of the header to look for on the request.\n                                            minLength: 1\n                                            type: string\n                                        type: object\n                                      requestHeaderValueMatch:\n                                        description: RequestHeaderValueMatch defines\n                                          a descriptor entry that's populated if the\n                                          request's headers match a set of 1+ match\n                                          criteria. The descriptor key is \"header_match\",\n                                          and the descriptor value is static.\n                                        properties:\n                                          expectMatch:\n                                            default: true\n                                            description: ExpectMatch defines whether\n                                              the request must positively match the\n                                              match criteria in order to generate\n                                              a descriptor entry (i.e. true), or not\n                                              match the match criteria in order to\n                                              generate a descriptor entry (i.e. false).\n                                              The default is true.\n                                            type: boolean\n                                          headers:\n                                            description: Headers is a list of 1+ match\n                                              criteria to apply against the request\n                                              to determine whether to populate the\n                                              descriptor entry or not.\n                                            items:\n                                              description: HeaderMatchCondition specifies\n                                                how to conditionally match against\n                                                HTTP headers. The Name field is required,\n                                                but only one of the remaining fields\n                                                should be be provided.\n                                              properties:\n                                                contains:\n                                                  description: Contains specifies\n                                                    a substring that must be present\n                                                    in the header value.\n                                                  type: string\n                                                exact:\n                                                  description: Exact specifies a string\n                                                    that the header value must be\n                                                    equal to.\n                                                  type: string\n                                                name:\n                                                  description: Name is the name of\n                                                    the header to match against. Name\n                                                    is required. Header names are\n                                                    case insensitive.\n                                                  type: string\n                                                notcontains:\n                                                  description: NotContains specifies\n                                                    a substring that must not be present\n                                                    in the header value.\n                                                  type: string\n                                                notexact:\n                                                  description: NoExact specifies a\n                                                    string that the header value must\n                                                    not be equal to. The condition\n                                                    is true if the header has any\n                                                    other value.\n                                                  type: string\n                                                notpresent:\n                                                  description: NotPresent specifies\n                                                    that condition is true when the\n                                                    named header is not present. Note\n                                                    that setting NotPresent to false\n                                                    does not make the condition true\n                                                    if the named header is present.\n                                                  type: boolean\n                                                present:\n                                                  description: Present specifies that\n                                                    condition is true when the named\n                                                    header is present, regardless\n                                                    of its value. Note that setting\n                                                    Present to false does not make\n                                                    the condition true if the named\n                                                    header is absent.\n                                                  type: boolean\n                                              required:\n                                              - name\n                                              type: object\n                                            minItems: 1\n                                            type: array\n                                          value:\n                                            description: Value defines the value of\n                                              the descriptor entry.\n                                            minLength: 1\n                                            type: string\n                                        type: object\n                                    type: object\n                                  minItems: 1\n                                  type: array\n                              type: object\n                            minItems: 1\n                            type: array\n                        type: object\n                      local:\n                        description: Local defines local rate limiting parameters,\n                          i.e. parameters for rate limiting that occurs within each\n                          Envoy pod as requests are handled.\n                        properties:\n                          burst:\n                            description: Burst defines the number of requests above\n                              the requests per unit that should be allowed within\n                              a short period of time.\n                            format: int32\n                            type: integer\n                          requests:\n                            description: Requests defines how many requests per unit\n                              of time should be allowed before rate limiting occurs.\n                            format: int32\n                            minimum: 1\n                            type: integer\n                          responseHeadersToAdd:\n                            description: ResponseHeadersToAdd is an optional list\n                              of response headers to set when a request is rate-limited.\n                            items:\n                              description: HeaderValue represents a header name/value\n                                pair\n                              properties:\n                                name:\n                                  description: Name represents a key of a header\n                                  minLength: 1\n                                  type: string\n                                value:\n                                  description: Value represents the value of a header\n                                    specified by a key\n                                  minLength: 1\n                                  type: string\n                              required:\n                              - name\n                              - value\n                              type: object\n                            type: array\n                          responseStatusCode:\n                            description: ResponseStatusCode is the HTTP status code\n                              to use for responses to rate-limited requests. Codes\n                              must be in the 400-599 range (inclusive). If not specified,\n                              the Envoy default of 429 (Too Many Requests) is used.\n                            format: int32\n                            maximum: 599\n                            minimum: 400\n                            type: integer\n                          unit:\n                            description: Unit defines the period of time within which\n                              requests over the limit will be rate limited. Valid\n                              values are \"second\", \"minute\" and \"hour\".\n                            enum:\n                            - second\n                            - minute\n                            - hour\n                            type: string\n                        required:\n                        - requests\n                        - unit\n                        type: object\n                    type: object\n                  tls:\n                    description: If present the fields describes TLS properties of\n                      the virtual host. The SNI names that will be matched on are\n                      described in fqdn, the tls.secretName secret must contain a\n                      certificate that itself contains a name that matches the FQDN.\n                    properties:\n                      clientValidation:\n                        description: \"ClientValidation defines how to verify the client\n                          certificate when an external client establishes a TLS connection\n                          to Envoy. \\n This setting: \\n 1. Enables TLS client certificate\n                          validation. 2. Specifies how the client certificate will\n                          be validated (i.e.    validation required or skipped). \\n\n                          Note: Setting client certificate validation to be skipped\n                          should be only used in conjunction with an external authorization\n                          server that performs client validation as Contour will ensure\n                          client certificates are passed along.\"\n                        properties:\n                          caSecret:\n                            description: Name of a Kubernetes secret that contains\n                              a CA certificate bundle. The client certificate must\n                              validate against the certificates in the bundle. If\n                              specified and SkipClientCertValidation is true, client\n                              certificates will be required on requests.\n                            minLength: 1\n                            type: string\n                          skipClientCertValidation:\n                            description: SkipClientCertValidation disables downstream\n                              client certificate validation. Defaults to false. This\n                              field is intended to be used in conjunction with external\n                              authorization in order to enable the external authorization\n                              server to validate client certificates. When this field\n                              is set to true, client certificates are requested but\n                              not verified by Envoy. If CACertificate is specified,\n                              client certificates are required on requests, but not\n                              verified. If external authorization is in use, they\n                              are presented to the external authorization server.\n                            type: boolean\n                        type: object\n                      enableFallbackCertificate:\n                        description: EnableFallbackCertificate defines if the vhost\n                          should allow a default certificate to be applied which handles\n                          all requests which don't match the SNI defined in this vhost.\n                        type: boolean\n                      minimumProtocolVersion:\n                        description: MinimumProtocolVersion is the minimum TLS version\n                          this vhost should negotiate. Valid options are `1.2` (default)\n                          and `1.3`. Any other value defaults to TLS 1.2.\n                        type: string\n                      passthrough:\n                        description: Passthrough defines whether the encrypted TLS\n                          handshake will be passed through to the backing cluster.\n                          Either Passthrough or SecretName must be specified, but\n                          not both.\n                        type: boolean\n                      secretName:\n                        description: SecretName is the name of a TLS secret in the\n                          current namespace. Either SecretName or Passthrough must\n                          be specified, but not both. If specified, the named secret\n                          must contain a matching certificate for the virtual host's\n                          FQDN.\n                        type: string\n                    type: object\n                required:\n                - fqdn\n                type: object\n            type: object\n          status:\n            description: Status is a container for computed information about the\n              HTTPProxy.\n            properties:\n              conditions:\n                description: \"Conditions contains information about the current status\n                  of the HTTPProxy, in an upstream-friendly container. \\n Contour\n                  will update a single condition, `Valid`, that is in normal-true\n                  polarity. That is, when `currentStatus` is `valid`, the `Valid`\n                  condition will be `status: true`, and vice versa. \\n Contour will\n                  leave untouched any other Conditions set in this block, in case\n                  some other controller wants to add a Condition. \\n If you are another\n                  controller owner and wish to add a condition, you *should* namespace\n                  your condition with a label, like `controller.domain.com/ConditionName`.\"\n                items:\n                  description: \"DetailedCondition is an extension of the normal Kubernetes\n                    conditions, with two extra fields to hold sub-conditions, which\n                    provide more detailed reasons for the state (True or False) of\n                    the condition. \\n `errors` holds information about sub-conditions\n                    which are fatal to that condition and render its state False.\n                    \\n `warnings` holds information about sub-conditions which are\n                    not fatal to that condition and do not force the state to be False.\n                    \\n Remember that Conditions have a type, a status, and a reason.\n                    \\n The type is the type of the condition, the most important one\n                    in this CRD set is `Valid`. `Valid` is a positive-polarity condition:\n                    when it is `status: true` there are no problems. \\n In more detail,\n                    `status: true` means that the object is has been ingested into\n                    Contour with no errors. `warnings` may still be present, and will\n                    be indicated in the Reason field. There must be zero entries in\n                    the `errors` slice in this case. \\n `Valid`, `status: false` means\n                    that the object has had one or more fatal errors during processing\n                    into Contour.  The details of the errors will be present under\n                    the `errors` field. There must be at least one error in the `errors`\n                    slice if `status` is `false`. \\n For DetailedConditions of types\n                    other than `Valid`, the Condition must be in the negative polarity.\n                    When they have `status` `true`, there is an error. There must\n                    be at least one entry in the `errors` Subcondition slice. When\n                    they have `status` `false`, there are no serious errors, and there\n                    must be zero entries in the `errors` slice. In either case, there\n                    may be entries in the `warnings` slice. \\n Regardless of the polarity,\n                    the `reason` and `message` fields must be updated with either\n                    the detail of the reason (if there is one and only one entry in\n                    total across both the `errors` and `warnings` slices), or `MultipleReasons`\n                    if there is more than one entry.\"\n                  properties:\n                    errors:\n                      description: \"Errors contains a slice of relevant error subconditions\n                        for this object. \\n Subconditions are expected to appear when\n                        relevant (when there is a error), and disappear when not relevant.\n                        An empty slice here indicates no errors.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                    lastTransitionTime:\n                      description: lastTransitionTime is the last time the condition\n                        transitioned from one status to another. This should be when\n                        the underlying condition changed.  If that is not known, then\n                        using the time when the API field changed is acceptable.\n                      format: date-time\n                      type: string\n                    message:\n                      description: message is a human readable message indicating\n                        details about the transition. This may be an empty string.\n                      maxLength: 32768\n                      type: string\n                    observedGeneration:\n                      description: observedGeneration represents the .metadata.generation\n                        that the condition was set based upon. For instance, if .metadata.generation\n                        is currently 12, but the .status.conditions[x].observedGeneration\n                        is 9, the condition is out of date with respect to the current\n                        state of the instance.\n                      format: int64\n                      minimum: 0\n                      type: integer\n                    reason:\n                      description: reason contains a programmatic identifier indicating\n                        the reason for the condition's last transition. Producers\n                        of specific condition types may define expected values and\n                        meanings for this field, and whether the values are considered\n                        a guaranteed API. The value should be a CamelCase string.\n                        This field may not be empty.\n                      maxLength: 1024\n                      minLength: 1\n                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                      type: string\n                    status:\n                      description: status of the condition, one of True, False, Unknown.\n                      enum:\n                      - \"True\"\n                      - \"False\"\n                      - Unknown\n                      type: string\n                    type:\n                      description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                        --- Many .condition.type values are consistent across resources\n                        like Available, but because arbitrary conditions can be useful\n                        (see .node.status.conditions), the ability to deconflict is\n                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                      maxLength: 316\n                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                      type: string\n                    warnings:\n                      description: \"Warnings contains a slice of relevant warning\n                        subconditions for this object. \\n Subconditions are expected\n                        to appear when relevant (when there is a warning), and disappear\n                        when not relevant. An empty slice here indicates no warnings.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                  required:\n                  - lastTransitionTime\n                  - message\n                  - reason\n                  - status\n                  - type\n                  type: object\n                type: array\n                x-kubernetes-list-map-keys:\n                - type\n                x-kubernetes-list-type: map\n              currentStatus:\n                type: string\n              description:\n                type: string\n              loadBalancer:\n                description: LoadBalancer contains the current status of the load\n                  balancer.\n                properties:\n                  ingress:\n                    description: Ingress is a list containing ingress points for the\n                      load-balancer. Traffic intended for the service should be sent\n                      to these ingress points.\n                    items:\n                      description: 'LoadBalancerIngress represents the status of a\n                        load-balancer ingress point: traffic intended for the service\n                        should be sent to an ingress point.'\n                      properties:\n                        hostname:\n                          description: Hostname is set for load-balancer ingress points\n                            that are DNS based (typically AWS load-balancers)\n                          type: string\n                        ip:\n                          description: IP is set for load-balancer ingress points\n                            that are IP based (typically GCE or OpenStack load-balancers)\n                          type: string\n                        ports:\n                          description: Ports is a list of records of service ports\n                            If used, every port defined in the service should have\n                            an entry in it\n                          items:\n                            properties:\n                              error:\n                                description: 'Error is to record the problem with\n                                  the service port The format of the error shall comply\n                                  with the following rules: - built-in error values\n                                  shall be specified in this file and those shall\n                                  use   CamelCase names - cloud provider specific\n                                  error values must have names that comply with the   format\n                                  foo.example.com/CamelCase. --- The regex it matches\n                                  is (dns1123SubdomainFmt/)?(qualifiedNameFmt)'\n                                maxLength: 316\n                                pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                                type: string\n                              port:\n                                description: Port is the port number of the service\n                                  port of which status is recorded here\n                                format: int32\n                                type: integer\n                              protocol:\n                                default: TCP\n                                description: 'Protocol is the protocol of the service\n                                  port of which status is recorded here The supported\n                                  values are: \"TCP\", \"UDP\", \"SCTP\"'\n                                type: string\n                            required:\n                            - port\n                            - protocol\n                            type: object\n                          type: array\n                          x-kubernetes-list-type: atomic\n                      type: object\n                    type: array\n                type: object\n            type: object\n        required:\n        - metadata\n        - spec\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version: v0.5.0\n  creationTimestamp: null\n  name: tlscertificatedelegations.projectcontour.io\nspec:\n  preserveUnknownFields: false\n  group: projectcontour.io\n  names:\n    kind: TLSCertificateDelegation\n    listKind: TLSCertificateDelegationList\n    plural: tlscertificatedelegations\n    shortNames:\n    - tlscerts\n    singular: tlscertificatedelegation\n  scope: Namespaced\n  versions:\n  - name: v1\n    schema:\n      openAPIV3Schema:\n        description: TLSCertificateDelegation is an TLS Certificate Delegation CRD\n          specification. See design/tls-certificate-delegation.md for details.\n        properties:\n          apiVersion:\n            description: 'APIVersion defines the versioned schema of this representation\n              of an object. Servers should convert recognized schemas to the latest\n              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n            type: string\n          kind:\n            description: 'Kind is a string value representing the REST resource this\n              object represents. Servers may infer this from the endpoint the client\n              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n            type: string\n          metadata:\n            type: object\n          spec:\n            description: TLSCertificateDelegationSpec defines the spec of the CRD\n            properties:\n              delegations:\n                items:\n                  description: CertificateDelegation maps the authority to reference\n                    a secret in the current namespace to a set of namespaces.\n                  properties:\n                    secretName:\n                      description: required, the name of a secret in the current namespace.\n                      type: string\n                    targetNamespaces:\n                      description: required, the namespaces the authority to reference\n                        the the secret will be delegated to. If TargetNamespaces is\n                        nil or empty, the CertificateDelegation' is ignored. If the\n                        TargetNamespace list contains the character, \"*\" the secret\n                        will be delegated to all namespaces.\n                      items:\n                        type: string\n                      type: array\n                  required:\n                  - secretName\n                  - targetNamespaces\n                  type: object\n                type: array\n            required:\n            - delegations\n            type: object\n          status:\n            description: TLSCertificateDelegationStatus allows for the status of the\n              delegation to be presented to the user.\n            properties:\n              conditions:\n                description: \"Conditions contains information about the current status\n                  of the HTTPProxy, in an upstream-friendly container. \\n Contour\n                  will update a single condition, `Valid`, that is in normal-true\n                  polarity. That is, when `currentStatus` is `valid`, the `Valid`\n                  condition will be `status: true`, and vice versa. \\n Contour will\n                  leave untouched any other Conditions set in this block, in case\n                  some other controller wants to add a Condition. \\n If you are another\n                  controller owner and wish to add a condition, you *should* namespace\n                  your condition with a label, like `controller.domain.com\\\\ConditionName`.\"\n                items:\n                  description: \"DetailedCondition is an extension of the normal Kubernetes\n                    conditions, with two extra fields to hold sub-conditions, which\n                    provide more detailed reasons for the state (True or False) of\n                    the condition. \\n `errors` holds information about sub-conditions\n                    which are fatal to that condition and render its state False.\n                    \\n `warnings` holds information about sub-conditions which are\n                    not fatal to that condition and do not force the state to be False.\n                    \\n Remember that Conditions have a type, a status, and a reason.\n                    \\n The type is the type of the condition, the most important one\n                    in this CRD set is `Valid`. `Valid` is a positive-polarity condition:\n                    when it is `status: true` there are no problems. \\n In more detail,\n                    `status: true` means that the object is has been ingested into\n                    Contour with no errors. `warnings` may still be present, and will\n                    be indicated in the Reason field. There must be zero entries in\n                    the `errors` slice in this case. \\n `Valid`, `status: false` means\n                    that the object has had one or more fatal errors during processing\n                    into Contour.  The details of the errors will be present under\n                    the `errors` field. There must be at least one error in the `errors`\n                    slice if `status` is `false`. \\n For DetailedConditions of types\n                    other than `Valid`, the Condition must be in the negative polarity.\n                    When they have `status` `true`, there is an error. There must\n                    be at least one entry in the `errors` Subcondition slice. When\n                    they have `status` `false`, there are no serious errors, and there\n                    must be zero entries in the `errors` slice. In either case, there\n                    may be entries in the `warnings` slice. \\n Regardless of the polarity,\n                    the `reason` and `message` fields must be updated with either\n                    the detail of the reason (if there is one and only one entry in\n                    total across both the `errors` and `warnings` slices), or `MultipleReasons`\n                    if there is more than one entry.\"\n                  properties:\n                    errors:\n                      description: \"Errors contains a slice of relevant error subconditions\n                        for this object. \\n Subconditions are expected to appear when\n                        relevant (when there is a error), and disappear when not relevant.\n                        An empty slice here indicates no errors.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                    lastTransitionTime:\n                      description: lastTransitionTime is the last time the condition\n                        transitioned from one status to another. This should be when\n                        the underlying condition changed.  If that is not known, then\n                        using the time when the API field changed is acceptable.\n                      format: date-time\n                      type: string\n                    message:\n                      description: message is a human readable message indicating\n                        details about the transition. This may be an empty string.\n                      maxLength: 32768\n                      type: string\n                    observedGeneration:\n                      description: observedGeneration represents the .metadata.generation\n                        that the condition was set based upon. For instance, if .metadata.generation\n                        is currently 12, but the .status.conditions[x].observedGeneration\n                        is 9, the condition is out of date with respect to the current\n                        state of the instance.\n                      format: int64\n                      minimum: 0\n                      type: integer\n                    reason:\n                      description: reason contains a programmatic identifier indicating\n                        the reason for the condition's last transition. Producers\n                        of specific condition types may define expected values and\n                        meanings for this field, and whether the values are considered\n                        a guaranteed API. The value should be a CamelCase string.\n                        This field may not be empty.\n                      maxLength: 1024\n                      minLength: 1\n                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                      type: string\n                    status:\n                      description: status of the condition, one of True, False, Unknown.\n                      enum:\n                      - \"True\"\n                      - \"False\"\n                      - Unknown\n                      type: string\n                    type:\n                      description: type of condition in CamelCase or in foo.example.com/CamelCase.\n                        --- Many .condition.type values are consistent across resources\n                        like Available, but because arbitrary conditions can be useful\n                        (see .node.status.conditions), the ability to deconflict is\n                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n                      maxLength: 316\n                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                      type: string\n                    warnings:\n                      description: \"Warnings contains a slice of relevant warning\n                        subconditions for this object. \\n Subconditions are expected\n                        to appear when relevant (when there is a warning), and disappear\n                        when not relevant. An empty slice here indicates no warnings.\"\n                      items:\n                        description: \"SubCondition is a Condition-like type intended\n                          for use as a subcondition inside a DetailedCondition. \\n\n                          It contains a subset of the Condition fields. \\n It is intended\n                          for warnings and errors, so `type` names should use abnormal-true\n                          polarity, that is, they should be of the form \\\"ErrorPresent:\n                          true\\\". \\n The expected lifecycle for these errors is that\n                          they should only be present when the error or warning is,\n                          and should be removed when they are not relevant.\"\n                        properties:\n                          message:\n                            description: \"Message is a human readable message indicating\n                              details about the transition. \\n This may be an empty\n                              string.\"\n                            maxLength: 32768\n                            type: string\n                          reason:\n                            description: \"Reason contains a programmatic identifier\n                              indicating the reason for the condition's last transition.\n                              Producers of specific condition types may define expected\n                              values and meanings for this field, and whether the\n                              values are considered a guaranteed API. \\n The value\n                              should be a CamelCase string. \\n This field may not\n                              be empty.\"\n                            maxLength: 1024\n                            minLength: 1\n                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$\n                            type: string\n                          status:\n                            description: Status of the condition, one of True, False,\n                              Unknown.\n                            enum:\n                            - \"True\"\n                            - \"False\"\n                            - Unknown\n                            type: string\n                          type:\n                            description: \"Type of condition in `CamelCase` or in `foo.example.com/CamelCase`.\n                              \\n This must be in abnormal-true polarity, that is,\n                              `ErrorFound` or `controller.io/ErrorFound`. \\n The regex\n                              it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\"\n                            maxLength: 316\n                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n                            type: string\n                        required:\n                        - message\n                        - reason\n                        - status\n                        - type\n                        type: object\n                      type: array\n                  required:\n                  - lastTransitionTime\n                  - message\n                  - reason\n                  - status\n                  - type\n                  type: object\n                type: array\n                x-kubernetes-list-map-keys:\n                - type\n                x-kubernetes-list-type: map\n            type: object\n        required:\n        - metadata\n        - spec\n        type: object\n    served: true\n    storage: true\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: contour-certgen\n  namespace: projectcontour\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: contour\n  namespace: projectcontour\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: contour-certgen\nsubjects:\n- kind: ServiceAccount\n  name: contour-certgen\n  namespace: projectcontour\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: contour-certgen\n  namespace: projectcontour\nrules:\n- apiGroups:\n  - \"\"\n  resources:\n  - secrets\n  verbs:\n  - create\n  - update\n---\napiVersion: batch/v1\nkind: Job\nmetadata:\n  name: contour-certgen-v1.17.0\n  namespace: projectcontour\nspec:\n  ttlSecondsAfterFinished: 0\n  template:\n    metadata:\n      labels:\n        app: \"contour-certgen\"\n    spec:\n      containers:\n      - name: contour\n        image: docker.io/projectcontour/contour:v1.17.0\n        imagePullPolicy: Always\n        command:\n        - contour\n        - certgen\n        - --kube\n        - --incluster\n        - --overwrite\n        - --secrets-format=compact\n        - --namespace=$(CONTOUR_NAMESPACE)\n        env:\n        - name: CONTOUR_NAMESPACE\n          valueFrom:\n            fieldRef:\n              fieldPath: metadata.namespace\n      restartPolicy: Never\n      serviceAccountName: contour-certgen\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 65534\n        runAsGroup: 65534\n  parallelism: 1\n  completions: 1\n  backoffLimit: 1\n\n---\n\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: contour\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: contour\nsubjects:\n- kind: ServiceAccount\n  name: contour\n  namespace: projectcontour\n\n# The following ClusterRole is generated from kubebuilder RBAC tags by\n# generate-rbac.sh. Do not edit this file directly but instead edit the source\n# files and re-render.\n\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  creationTimestamp: null\n  name: contour\nrules:\n- apiGroups:\n  - \"\"\n  resources:\n  - configmaps\n  verbs:\n  - create\n  - get\n  - update\n- apiGroups:\n  - \"\"\n  resources:\n  - endpoints\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - namespaces\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - secrets\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - services\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - apiextensions.k8s.io\n  resources:\n  - customresourcedefinitions\n  verbs:\n  - list\n- apiGroups:\n  - networking.k8s.io\n  resources:\n  - ingressclasses\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - networking.k8s.io\n  resources:\n  - ingresses\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - networking.k8s.io\n  resources:\n  - ingresses/status\n  verbs:\n  - create\n  - get\n  - update\n- apiGroups:\n  - networking.x-k8s.io\n  resources:\n  - backendpolicies\n  - gatewayclasses\n  - gateways\n  - httproutes\n  - tcproutes\n  - tlsroutes\n  - udproutes\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - networking.x-k8s.io\n  resources:\n  - backendpolicies/status\n  - gatewayclasses/status\n  - gateways/status\n  - httproutes/status\n  - tcproutes/status\n  - tlsroutes/status\n  - udproutes/status\n  verbs:\n  - update\n- apiGroups:\n  - projectcontour.io\n  resources:\n  - extensionservices\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - projectcontour.io\n  resources:\n  - extensionservices/status\n  verbs:\n  - create\n  - get\n  - update\n- apiGroups:\n  - projectcontour.io\n  resources:\n  - httpproxies\n  - tlscertificatedelegations\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - projectcontour.io\n  resources:\n  - httpproxies/status\n  verbs:\n  - create\n  - get\n  - update\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: contour\n  namespace: projectcontour\nspec:\n  ports:\n  - port: 8001\n    name: xds\n    protocol: TCP\n    targetPort: 8001\n  selector:\n    app: contour\n  type: ClusterIP\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: envoy\n  namespace: projectcontour\n  annotations:\n    # This annotation puts the AWS ELB into \"TCP\" mode so that it does not\n    # do HTTP negotiation for HTTPS connections at the ELB edge.\n    # The downside of this is the remote IP address of all connections will\n    # appear to be the internal address of the ELB. See docs/proxy-proto.md\n    # for information about enabling the PROXY protocol on the ELB to recover\n    # the original remote IP address.\n    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcp\nspec:\n  externalTrafficPolicy: Local\n  ports:\n  - port: 80\n    name: http\n    protocol: TCP\n    targetPort: 8080\n  - port: 443\n    name: https\n    protocol: TCP\n    targetPort: 8443\n  selector:\n    app: envoy\n  type: LoadBalancer\n\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: contour\n  name: contour\n  namespace: projectcontour\nspec:\n  replicas: 2\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      # This value of maxSurge means that during a rolling update\n      # the new ReplicaSet will be created first.\n      maxSurge: 50%\n  selector:\n    matchLabels:\n      app: contour\n  template:\n    metadata:\n      annotations:\n        prometheus.io/scrape: \"true\"\n        prometheus.io/port: \"8000\"\n      labels:\n        app: contour\n    spec:\n      affinity:\n        podAntiAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n          - podAffinityTerm:\n              labelSelector:\n                matchLabels:\n                  app: contour\n              topologyKey: kubernetes.io/hostname\n            weight: 100\n      containers:\n      - args:\n        - serve\n        - --incluster\n        - --xds-address=0.0.0.0\n        - --xds-port=8001\n        - --contour-cafile=/certs/ca.crt\n        - --contour-cert-file=/certs/tls.crt\n        - --contour-key-file=/certs/tls.key\n        - --config-path=/config/contour.yaml\n        command: [\"contour\"]\n        image: docker.io/projectcontour/contour:v1.17.0\n        imagePullPolicy: IfNotPresent\n        name: contour\n        ports:\n        - containerPort: 8001\n          name: xds\n          protocol: TCP\n        - containerPort: 8000\n          name: metrics\n          protocol: TCP\n        - containerPort: 6060\n          name: debug\n          protocol: TCP\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 8000\n        readinessProbe:\n          tcpSocket:\n            port: 8001\n          initialDelaySeconds: 15\n          periodSeconds: 10\n        volumeMounts:\n          - name: contourcert\n            mountPath: /certs\n            readOnly: true\n          - name: contour-config\n            mountPath: /config\n            readOnly: true\n        env:\n        - name: CONTOUR_NAMESPACE\n          valueFrom:\n            fieldRef:\n              apiVersion: v1\n              fieldPath: metadata.namespace\n        - name: POD_NAME\n          valueFrom:\n            fieldRef:\n              apiVersion: v1\n              fieldPath: metadata.name\n      dnsPolicy: ClusterFirst\n      serviceAccountName: contour\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 65534\n        runAsGroup: 65534\n      volumes:\n        - name: contourcert\n          secret:\n            secretName: contourcert\n        - name: contour-config\n          configMap:\n            name: contour\n            defaultMode: 0644\n            items:\n            - key: contour.yaml\n              path: contour.yaml\n\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  labels:\n    app: envoy\n  name: envoy\n  namespace: projectcontour\nspec:\n  updateStrategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 10%\n  selector:\n    matchLabels:\n      app: envoy\n  template:\n    metadata:\n      annotations:\n        prometheus.io/scrape: \"true\"\n        prometheus.io/port: \"8002\"\n        prometheus.io/path: \"/stats/prometheus\"\n      labels:\n        app: envoy\n    spec:\n      containers:\n      - command:\n        - /bin/contour\n        args:\n          - envoy\n          - shutdown-manager\n        image: docker.io/projectcontour/contour:v1.17.0\n        imagePullPolicy: IfNotPresent\n        lifecycle:\n          preStop:\n            exec:\n              command:\n                - /bin/contour\n                - envoy\n                - shutdown\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 8090\n          initialDelaySeconds: 3\n          periodSeconds: 10\n        name: shutdown-manager\n      - args:\n        - -c\n        - /config/envoy.json\n        - --service-cluster $(CONTOUR_NAMESPACE)\n        - --service-node $(ENVOY_POD_NAME)\n        - --log-level info\n        command:\n        - envoy\n        image: docker.io/envoyproxy/envoy:v1.18.3\n        imagePullPolicy: IfNotPresent\n        name: envoy\n        env:\n        - name: CONTOUR_NAMESPACE\n          valueFrom:\n            fieldRef:\n              apiVersion: v1\n              fieldPath: metadata.namespace\n        - name: ENVOY_POD_NAME\n          valueFrom:\n            fieldRef:\n              apiVersion: v1\n              fieldPath: metadata.name\n        ports:\n        - containerPort: 8080\n          hostPort: 80\n          name: http\n          protocol: TCP\n        - containerPort: 8443\n          hostPort: 443\n          name: https\n          protocol: TCP\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 8002\n          initialDelaySeconds: 3\n          periodSeconds: 4\n        volumeMounts:\n          - name: envoy-config\n            mountPath: /config\n            readOnly: true\n          - name: envoycert\n            mountPath: /certs\n            readOnly: true\n        lifecycle:\n          preStop:\n            httpGet:\n              path: /shutdown\n              port: 8090\n              scheme: HTTP\n      initContainers:\n      - args:\n        - bootstrap\n        - /config/envoy.json\n        - --xds-address=contour\n        - --xds-port=8001\n        - --xds-resource-version=v3\n        - --resources-dir=/config/resources\n        - --envoy-cafile=/certs/ca.crt\n        - --envoy-cert-file=/certs/tls.crt\n        - --envoy-key-file=/certs/tls.key\n        command:\n        - contour\n        image: docker.io/projectcontour/contour:v1.17.0\n        imagePullPolicy: IfNotPresent\n        name: envoy-initconfig\n        volumeMounts:\n        - name: envoy-config\n          mountPath: /config\n        - name: envoycert\n          mountPath: /certs\n          readOnly: true\n        env:\n        - name: CONTOUR_NAMESPACE\n          valueFrom:\n            fieldRef:\n              fieldPath: metadata.namespace\n      automountServiceAccountToken: false\n      serviceAccountName: envoy\n      terminationGracePeriodSeconds: 300\n      volumes:\n        - name: envoy-config\n          emptyDir: {}\n        - name: envoycert\n          secret:\n            secretName: envoycert\n      restartPolicy: Always\n", "module github.com/projectcontour/contour\n\ngo 1.15\n\nrequire (\n\tgithub.com/ahmetb/gen-crd-api-reference-docs v0.3.0\n\tgithub.com/bombsimon/logrusr v1.0.0\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/envoyproxy/go-control-plane v0.9.9-0.20210111201334-f1f47757da33\n\tgithub.com/go-logr/logr v0.4.0\n\tgithub.com/golang/protobuf v1.5.2\n\tgithub.com/google/go-cmp v0.5.5\n\tgithub.com/google/uuid v1.1.2\n\tgithub.com/grpc-ecosystem/go-grpc-prometheus v1.2.0\n\tgithub.com/jetstack/cert-manager v1.3.0\n\tgithub.com/onsi/ginkgo v1.16.4\n\tgithub.com/onsi/gomega v1.13.0\n\tgithub.com/prometheus/client_golang v1.9.0\n\tgithub.com/prometheus/client_model v0.2.0\n\tgithub.com/prometheus/common v0.15.0\n\tgithub.com/sirupsen/logrus v1.7.0\n\tgithub.com/stretchr/testify v1.6.1\n\tgoogle.golang.org/genproto v0.0.0-20201110150050-8816d57aaa9a\n\tgoogle.golang.org/grpc v1.27.1\n\tgoogle.golang.org/protobuf v1.26.0\n\tgopkg.in/alecthomas/kingpin.v2 v2.2.6\n\tgopkg.in/yaml.v2 v2.4.0\n\tk8s.io/api v0.21.0\n\tk8s.io/apiextensions-apiserver v0.21.0\n\tk8s.io/apimachinery v0.21.0\n\tk8s.io/client-go v0.21.0\n\tk8s.io/klog/v2 v2.8.1-0.20210504170414-0cc9b8363efc\n\tk8s.io/utils v0.0.0-20210305010621-2afb4311ab10\n\tsigs.k8s.io/controller-runtime v0.9.0-beta.1\n\tsigs.k8s.io/controller-tools v0.5.0\n\tsigs.k8s.io/gateway-api v0.3.0\n\tsigs.k8s.io/kustomize/kyaml v0.1.1\n)\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dag\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\n\t\"github.com/projectcontour/contour/internal/annotation\"\n\t\"github.com/projectcontour/contour/internal/k8s\"\n\tv1 \"k8s.io/api/core/v1\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n)\n\n// RouteServiceName identifies a service used in a route.\ntype RouteServiceName struct {\n\tName      string\n\tNamespace string\n\tPort      int32\n}\n\n// GetServices returns all services in the DAG.\nfunc (dag *DAG) GetServices() map[RouteServiceName]*Service {\n\tgetter := serviceGetter(map[RouteServiceName]*Service{})\n\tdag.Visit(getter.visit)\n\treturn getter\n}\n\n// GetService returns the service in the DAG that matches the provided\n// namespace, name and port, or nil if no matching service is found.\nfunc (dag *DAG) GetService(meta types.NamespacedName, port int32) *Service {\n\treturn dag.GetServices()[RouteServiceName{\n\t\tName:      meta.Name,\n\t\tNamespace: meta.Namespace,\n\t\tPort:      port,\n\t}]\n}\n\n// EnsureService looks for a Kubernetes service in the cache matching the provided\n// namespace, name and port, and returns a DAG service for it. If a matching service\n// cannot be found in the cache, an error is returned.\nfunc (dag *DAG) EnsureService(meta types.NamespacedName, port intstr.IntOrString, cache *KubernetesCache, enableExternalNameSvc bool) (*Service, error) {\n\tsvc, svcPort, err := cache.LookupService(meta, port)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = validateExternalName(svc, enableExternalNameSvc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif dagSvc := dag.GetService(k8s.NamespacedNameOf(svc), svcPort.Port); dagSvc != nil {\n\t\treturn dagSvc, nil\n\t}\n\n\tdagSvc := &Service{\n\t\tWeighted: WeightedService{\n\t\t\tServiceName:      svc.Name,\n\t\t\tServiceNamespace: svc.Namespace,\n\t\t\tServicePort:      svcPort,\n\t\t\tWeight:           1,\n\t\t},\n\t\tProtocol:           upstreamProtocol(svc, svcPort),\n\t\tMaxConnections:     annotation.MaxConnections(svc),\n\t\tMaxPendingRequests: annotation.MaxPendingRequests(svc),\n\t\tMaxRequests:        annotation.MaxRequests(svc),\n\t\tMaxRetries:         annotation.MaxRetries(svc),\n\t\tExternalName:       externalName(svc),\n\t}\n\treturn dagSvc, nil\n}\n\nfunc validateExternalName(svc *v1.Service, enableExternalNameSvc bool) error {\n\n\t// If this isn't an ExternalName Service, we're all good here.\n\ten := externalName(svc)\n\tif en == \"\" {\n\t\treturn nil\n\t}\n\n\t// If ExternalNames are disabled, then we don't want to add this to the DAG.\n\tif !enableExternalNameSvc {\n\t\treturn fmt.Errorf(\"%s/%s is an ExternalName service, these are not currently enabled. See the config.enableExternalNameService config file setting\", svc.Namespace, svc.Name)\n\t}\n\n\t// Check against a list of known localhost names, using a map to approximate a set.\n\t// TODO(youngnick) This is a very porous hack, and we should probably look into doing a DNS\n\t// lookup to check what the externalName resolves to, but I'm worried about the\n\t// performance impact of doing one or more DNS lookups per DAG run, so we're\n\t// going to go with a specific blocklist for now.\n\tlocalhostNames := map[string]struct{}{\n\t\t\"localhost\":               {},\n\t\t\"localhost.localdomain\":   {},\n\t\t\"local.projectcontour.io\": {},\n\t}\n\n\t_, localhost := localhostNames[en]\n\tif localhost {\n\t\treturn fmt.Errorf(\"%s/%s is an ExternalName service that points to localhost, this is not allowed\", svc.Namespace, svc.Name)\n\t}\n\n\treturn nil\n}\n\nfunc upstreamProtocol(svc *v1.Service, port v1.ServicePort) string {\n\tup := annotation.ParseUpstreamProtocols(svc.Annotations)\n\tprotocol := up[port.Name]\n\tif protocol == \"\" {\n\t\tprotocol = up[strconv.Itoa(int(port.Port))]\n\t}\n\treturn protocol\n}\n\nfunc externalName(svc *v1.Service) string {\n\tif svc.Spec.Type != v1.ServiceTypeExternalName {\n\t\treturn \"\"\n\t}\n\treturn svc.Spec.ExternalName\n}\n\n// serviceGetter is a visitor that gets all services\n// in the DAG.\ntype serviceGetter map[RouteServiceName]*Service\n\nfunc (s serviceGetter) visit(vertex Vertex) {\n\tswitch obj := vertex.(type) {\n\tcase *Service:\n\t\ts[RouteServiceName{\n\t\t\tName:      obj.Weighted.ServiceName,\n\t\t\tNamespace: obj.Weighted.ServiceNamespace,\n\t\t\tPort:      obj.Weighted.ServicePort.Port,\n\t\t}] = obj\n\tdefault:\n\t\tvertex.Visit(s.visit)\n\t}\n}\n\n// GetSecureVirtualHosts returns all secure virtual hosts in the DAG.\nfunc (dag *DAG) GetSecureVirtualHosts() map[ListenerName]*SecureVirtualHost {\n\tgetter := svhostGetter(map[ListenerName]*SecureVirtualHost{})\n\tdag.Visit(getter.visit)\n\treturn getter\n}\n\n// GetSecureVirtualHost returns the secure virtual host in the DAG that\n// matches the provided name, or nil if no matching secure virtual host\n// is found.\nfunc (dag *DAG) GetSecureVirtualHost(ln ListenerName) *SecureVirtualHost {\n\treturn dag.GetSecureVirtualHosts()[ln]\n}\n\n// EnsureSecureVirtualHost adds a secure virtual host with the provided\n// name to the DAG if it does not already exist, and returns it.\nfunc (dag *DAG) EnsureSecureVirtualHost(ln ListenerName) *SecureVirtualHost {\n\tif svh := dag.GetSecureVirtualHost(ln); svh != nil {\n\t\treturn svh\n\t}\n\n\tsvh := &SecureVirtualHost{\n\t\tVirtualHost: VirtualHost{\n\t\t\tName:         ln.Name,\n\t\t\tListenerName: ln.ListenerName,\n\t\t},\n\t}\n\tdag.AddRoot(svh)\n\treturn svh\n}\n\n// svhostGetter is a visitor that gets all secure virtual hosts\n// in the DAG.\ntype svhostGetter map[ListenerName]*SecureVirtualHost\n\nfunc (s svhostGetter) visit(vertex Vertex) {\n\tswitch obj := vertex.(type) {\n\tcase *SecureVirtualHost:\n\t\ts[ListenerName{Name: obj.Name, ListenerName: obj.VirtualHost.ListenerName}] = obj\n\tdefault:\n\t\tvertex.Visit(s.visit)\n\t}\n}\n\n// GetVirtualHosts returns all virtual hosts in the DAG.\nfunc (dag *DAG) GetVirtualHosts() map[ListenerName]*VirtualHost {\n\tgetter := vhostGetter(map[ListenerName]*VirtualHost{})\n\tdag.Visit(getter.visit)\n\treturn getter\n}\n\n// GetVirtualHost returns the virtual host in the DAG that matches the\n// provided name, or nil if no matching virtual host is found.\nfunc (dag *DAG) GetVirtualHost(ln ListenerName) *VirtualHost {\n\treturn dag.GetVirtualHosts()[ln]\n}\n\n// EnsureVirtualHost adds a virtual host with the provided name to the\n// DAG if it does not already exist, and returns it.\nfunc (dag *DAG) EnsureVirtualHost(ln ListenerName) *VirtualHost {\n\tif vhost := dag.GetVirtualHost(ln); vhost != nil {\n\t\treturn vhost\n\t}\n\n\tvhost := &VirtualHost{\n\t\tName:         ln.Name,\n\t\tListenerName: ln.ListenerName,\n\t}\n\tdag.AddRoot(vhost)\n\treturn vhost\n}\n\n// vhostGetter is a visitor that gets all virtual hosts\n// in the DAG.\ntype vhostGetter map[ListenerName]*VirtualHost\n\nfunc (v vhostGetter) visit(vertex Vertex) {\n\tswitch obj := vertex.(type) {\n\tcase *VirtualHost:\n\t\tv[ListenerName{Name: obj.Name, ListenerName: obj.ListenerName}] = obj\n\tdefault:\n\t\tvertex.Visit(v.visit)\n\t}\n}\n\n// GetExtensionClusters returns all extension clusters in the DAG.\nfunc (dag *DAG) GetExtensionClusters() map[string]*ExtensionCluster {\n\tgetter := extensionClusterGetter(map[string]*ExtensionCluster{})\n\tdag.Visit(getter.visit)\n\treturn getter\n}\n\n// GetExtensionCluster returns the extension cluster in the DAG that\n// matches the provided name, or nil if no matching extension cluster\n//is found.\nfunc (dag *DAG) GetExtensionCluster(name string) *ExtensionCluster {\n\treturn dag.GetExtensionClusters()[name]\n}\n\n// extensionClusterGetter is a visitor that gets all extension clusters\n// in the DAG.\ntype extensionClusterGetter map[string]*ExtensionCluster\n\nfunc (v extensionClusterGetter) visit(vertex Vertex) {\n\tswitch obj := vertex.(type) {\n\tcase *ExtensionCluster:\n\t\tv[obj.Name] = obj\n\tdefault:\n\t\tvertex.Visit(v.visit)\n\t}\n}\n\n// validSecret returns true if the Secret contains certificate and private key material.\nfunc validSecret(s *v1.Secret) error {\n\tif s.Type != v1.SecretTypeTLS {\n\t\treturn fmt.Errorf(\"Secret type is not %q\", v1.SecretTypeTLS)\n\t}\n\n\tif len(s.Data[v1.TLSCertKey]) == 0 {\n\t\treturn fmt.Errorf(\"empty %q key\", v1.TLSCertKey)\n\t}\n\n\tif len(s.Data[v1.TLSPrivateKeyKey]) == 0 {\n\t\treturn fmt.Errorf(\"empty %q key\", v1.TLSPrivateKeyKey)\n\t}\n\n\treturn nil\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dag\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/projectcontour/contour/internal/fixture\"\n\t\"github.com/stretchr/testify/assert\"\n\tv1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n)\n\nfunc TestBuilderLookupService(t *testing.T) {\n\ts1 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\texternalNameValid := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"externalnamevalid\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tType:         v1.ServiceTypeExternalName,\n\t\t\tExternalName: \"external.projectcontour.io\",\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       80,\n\t\t\t\tTargetPort: intstr.FromInt(80),\n\t\t\t}},\n\t\t},\n\t}\n\n\texternalNameLocalhost := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"externalnamelocalhost\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tType:         v1.ServiceTypeExternalName,\n\t\t\tExternalName: \"localhost\",\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       80,\n\t\t\t\tTargetPort: intstr.FromInt(80),\n\t\t\t}},\n\t\t},\n\t}\n\n\tservices := map[types.NamespacedName]*v1.Service{\n\t\t{Name: \"service1\", Namespace: \"default\"}:              s1,\n\t\t{Name: \"externalnamevalid\", Namespace: \"default\"}:     externalNameValid,\n\t\t{Name: \"externalnamelocalhost\", Namespace: \"default\"}: externalNameLocalhost,\n\t}\n\n\ttests := map[string]struct {\n\t\ttypes.NamespacedName\n\t\tport                  intstr.IntOrString\n\t\tenableExternalNameSvc bool\n\t\twant                  *Service\n\t\twantErr               error\n\t}{\n\t\t\"lookup service by port number\": {\n\t\t\tNamespacedName: types.NamespacedName{Name: \"service1\", Namespace: \"default\"},\n\t\t\tport:           intstr.FromInt(8080),\n\t\t\twant:           service(s1),\n\t\t},\n\t\t\"lookup service by port name\": {\n\t\t\tNamespacedName: types.NamespacedName{Name: \"service1\", Namespace: \"default\"},\n\t\t\tport:           intstr.FromString(\"http\"),\n\t\t\twant:           service(s1),\n\t\t},\n\t\t\"lookup service by port number (as string)\": {\n\t\t\tNamespacedName: types.NamespacedName{Name: \"service1\", Namespace: \"default\"},\n\t\t\tport:           intstr.Parse(\"8080\"),\n\t\t\twant:           service(s1),\n\t\t},\n\t\t\"lookup service by port number (from string)\": {\n\t\t\tNamespacedName: types.NamespacedName{Name: \"service1\", Namespace: \"default\"},\n\t\t\tport:           intstr.FromString(\"8080\"),\n\t\t\twant:           service(s1),\n\t\t},\n\t\t\"when service does not exist an error is returned\": {\n\t\t\tNamespacedName: types.NamespacedName{Name: \"nonexistent-service\", Namespace: \"default\"},\n\t\t\tport:           intstr.FromString(\"8080\"),\n\t\t\twantErr:        errors.New(`service \"default/nonexistent-service\" not found`),\n\t\t},\n\t\t\"when port does not exist an error is returned\": {\n\t\t\tNamespacedName: types.NamespacedName{Name: \"service1\", Namespace: \"default\"},\n\t\t\tport:           intstr.FromString(\"9999\"),\n\t\t\twantErr:        errors.New(`port \"9999\" on service \"default/service1\" not matched`),\n\t\t},\n\t\t\"When ExternalName Services are not disabled no error is returned\": {\n\t\t\tNamespacedName: types.NamespacedName{Name: \"externalnamevalid\", Namespace: \"default\"},\n\t\t\tport:           intstr.FromString(\"80\"),\n\t\t\twant: &Service{\n\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\tWeight:           1,\n\t\t\t\t\tServiceName:      \"externalnamevalid\",\n\t\t\t\t\tServiceNamespace: \"default\",\n\t\t\t\t\tServicePort: v1.ServicePort{\n\t\t\t\t\t\tName:       \"http\",\n\t\t\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\t\t\tPort:       80,\n\t\t\t\t\t\tTargetPort: intstr.FromInt(80),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tExternalName: \"external.projectcontour.io\",\n\t\t\t},\n\t\t\tenableExternalNameSvc: true,\n\t\t},\n\t\t\"When ExternalName Services are disabled an error is returned\": {\n\t\t\tNamespacedName: types.NamespacedName{Name: \"externalnamevalid\", Namespace: \"default\"},\n\t\t\tport:           intstr.FromString(\"80\"),\n\t\t\twantErr:        errors.New(`default/externalnamevalid is an ExternalName service, these are not currently enabled. See the config.enableExternalNameService config file setting`),\n\t\t},\n\t\t\"When ExternalName Services are enabled but a localhost ExternalName is used an error is returned\": {\n\t\t\tNamespacedName:        types.NamespacedName{Name: \"externalnamelocalhost\", Namespace: \"default\"},\n\t\t\tport:                  intstr.FromString(\"80\"),\n\t\t\twantErr:               errors.New(`default/externalnamelocalhost is an ExternalName service that points to localhost, this is not allowed`),\n\t\t\tenableExternalNameSvc: true,\n\t\t},\n\t}\n\n\tfor name, tc := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tb := Builder{\n\t\t\t\tSource: KubernetesCache{\n\t\t\t\t\tservices:    services,\n\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tvar dag DAG\n\n\t\t\tgot, gotErr := dag.EnsureService(tc.NamespacedName, tc.port, &b.Source, tc.enableExternalNameSvc)\n\t\t\tassert.Equal(t, tc.want, got)\n\t\t\tassert.Equal(t, tc.wantErr, gotErr)\n\t\t})\n\t}\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dag\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\tcontour_api_v1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"\n\t\"github.com/projectcontour/contour/internal/fixture\"\n\t\"github.com/projectcontour/contour/internal/timeout\"\n\t\"github.com/stretchr/testify/assert\"\n\tv1 \"k8s.io/api/core/v1\"\n\tnetworking_v1 \"k8s.io/api/networking/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n\t\"k8s.io/utils/pointer\"\n\tgatewayapi_v1alpha1 \"sigs.k8s.io/gateway-api/apis/v1alpha1\"\n)\n\nvar sec1 = &v1.Secret{\n\tObjectMeta: metav1.ObjectMeta{\n\t\tName:      \"secret\",\n\t\tNamespace: \"default\",\n\t},\n\tType: v1.SecretTypeTLS,\n\tData: secretdata(fixture.CERTIFICATE, fixture.RSA_PRIVATE_KEY),\n}\n\n// Invalid cert in the secret\nvar secInvalid = &v1.Secret{\n\tObjectMeta: metav1.ObjectMeta{\n\t\tName:      \"secret\",\n\t\tNamespace: \"default\",\n\t},\n\tType: v1.SecretTypeTLS,\n\tData: secretdata(\"wrong\", \"wronger\"),\n}\n\nfunc gatewayPort(port int) *gatewayapi_v1alpha1.PortNumber {\n\tp := gatewayapi_v1alpha1.PortNumber(port)\n\treturn &p\n}\n\nfunc TestDAGInsertGatewayAPI(t *testing.T) {\n\n\tkuardService := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\tkuardService2 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard2\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\tkuardService3 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard3\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\tkuardServiceCustomNs := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"custom\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\tblogService := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"blogsvc\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       80,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\tvalidClass := &gatewayapi_v1alpha1.GatewayClass{\n\t\tTypeMeta: metav1.TypeMeta{},\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName: \"test-validClass\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewayClassSpec{\n\t\t\tController: \"projectcontour.io/contour\",\n\t\t},\n\t\tStatus: gatewayapi_v1alpha1.GatewayClassStatus{\n\t\t\tConditions: []metav1.Condition{\n\t\t\t\t{\n\t\t\t\t\tType:   string(gatewayapi_v1alpha1.GatewayClassConditionStatusAdmitted),\n\t\t\t\t\tStatus: metav1.ConditionTrue,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tgatewayWithSelector := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectSame),\n\t\t\t\t\t},\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{\n\t\t\t\t\t\t\tKey:      \"type\",\n\t\t\t\t\t\t\tOperator: \"In\",\n\t\t\t\t\t\t\tValues:   []string{\"controller\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tsec1 := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"tlscert\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tType: v1.SecretTypeTLS,\n\t\tData: secretdata(fixture.CERTIFICATE, fixture.RSA_PRIVATE_KEY),\n\t}\n\n\thostname := gatewayapi_v1alpha1.Hostname(\"gateway.projectcontour.io\")\n\twildcardHostname := gatewayapi_v1alpha1.Hostname(\"*.projectcontour.io\")\n\n\tgatewayWithHostname := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tHostname: &hostname,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectSame),\n\t\t\t\t\t},\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{\n\t\t\t\t\t\t\tKey:      \"type\",\n\t\t\t\t\t\t\tOperator: \"In\",\n\t\t\t\t\t\t\tValues:   []string{\"controller\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayWithWildcardHostname := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tHostname: &wildcardHostname,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectSame),\n\t\t\t\t\t},\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{\n\t\t\t\t\t\t\tKey:      \"type\",\n\t\t\t\t\t\t\tOperator: \"In\",\n\t\t\t\t\t\t\tValues:   []string{\"controller\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayWithAddresses := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tAddresses: []gatewayapi_v1alpha1.GatewayAddress{\n\t\t\t\t{\n\t\t\t\t\tType:  gatewayAddressTypePtr(gatewayapi_v1alpha1.IPAddressType),\n\t\t\t\t\tValue: \"1.2.3.4\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayTLSRouteNoSelector := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.TLSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\tMode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModePassthrough),\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindTLSRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayTLSRouteModePassthrough := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.TLSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\tMode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModePassthrough),\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindTLSRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayTLSRouteModeTerminate := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     443,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.TLSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\tMode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModeTerminate),\n\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\tKind:  \"Secret\",\n\t\t\t\t\t\tName:  sec1.Name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindTLSRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayWithSameNamespace := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectSame),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayWithTLSRouteSelector := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.TLSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\tMode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModePassthrough),\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindTLSRoute,\n\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectSame),\n\t\t\t\t\t},\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{\n\t\t\t\t\t\t\tKey:      \"type\",\n\t\t\t\t\t\t\tOperator: \"In\",\n\t\t\t\t\t\t\tValues:   []string{\"controller\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayWithOnlyTLS := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     443,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\tKind:  \"Secret\",\n\t\t\t\t\t\tName:  sec1.Name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayWithTLSandHTTP := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\tPort:     443,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\tKind:  \"Secret\",\n\t\t\t\t\t\tName:  sec1.Name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewaywithtlsDifferentselectors := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{\n\t\t\t\t\t\t\tKey:      \"protocol\",\n\t\t\t\t\t\t\tOperator: \"In\",\n\t\t\t\t\t\t\tValues:   []string{\"http\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\tPort:     443,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\tKind:  \"Secret\",\n\t\t\t\t\t\tName:  sec1.Name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{\n\t\t\t\t\t\t\tKey:      \"protocol\",\n\t\t\t\t\t\t\tOperator: \"In\",\n\t\t\t\t\t\t\tValues:   []string{\"https\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgenericHTTPRoute := &gatewayapi_v1alpha1.HTTPRoute{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"basic\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"app\":      \"contour\",\n\t\t\t\t\"type\":     \"controller\",\n\t\t\t\t\"protocol\": \"http\",\n\t\t\t},\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t},\n\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\"test.projectcontour.io\",\n\t\t\t},\n\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t}},\n\t\t},\n\t}\n\n\thttpRouteProtocolHTTPS := &gatewayapi_v1alpha1.HTTPRoute{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"basictls\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"app\":      \"contour\",\n\t\t\t\t\"type\":     \"controller\",\n\t\t\t\t\"protocol\": \"https\",\n\t\t\t},\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t},\n\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\"test.projectcontour.io\",\n\t\t\t},\n\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\tForwardTo: httpRouteForwardTo(\"blogsvc\", 80, 1),\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayWithAllNamespace := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayWithNamespaceSelector := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectSelector),\n\t\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{\n\t\t\t\t\t\t\t\tKey:      \"type\",\n\t\t\t\t\t\t\t\tOperator: \"In\",\n\t\t\t\t\t\t\t\tValues:   []string{\"controller\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayWithNamespaceSelectorNotMatching := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectSelector),\n\t\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{\n\t\t\t\t\t\t\t\tKey:      \"type\",\n\t\t\t\t\t\t\t\tOperator: \"In\",\n\t\t\t\t\t\t\t\tValues:   []string{\"controller\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewayNoSelector := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tgatewaySelectorNotMatching := &gatewayapi_v1alpha1.Gateway{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tGatewayClassName: validClass.Name,\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     80,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\"not\": \"matching\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{\n\t\t\t\t\t\t\tKey:      \"something\",\n\t\t\t\t\t\t\tOperator: \"In\",\n\t\t\t\t\t\t\tValues:   []string{\"else\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ttests := map[string]struct {\n\t\tobjs                         []interface{}\n\t\tdisablePermitInsecure        bool\n\t\tfallbackCertificateName      string\n\t\tfallbackCertificateNamespace string\n\t\tgatewayclass                 *gatewayapi_v1alpha1.GatewayClass\n\t\tgateway                      *gatewayapi_v1alpha1.Gateway\n\t\twant                         []Vertex\n\t}{\n\t\t\"insert basic single route, single hostname\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"gateway with unsupported addresses\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithAddresses,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"gateway without a gatewayclass\": {\n\t\t\tgateway: gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t// Test that a gateway without a Selector will select objects.\n\t\t\"insert basic single route, single hostname, gateway no selector\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// Test that a gateway without a Selector will select objects.\n\t\t\"insert basic single route, single hostname, gateway same namespace selector\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSameNamespace,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway same namespace selector, route different namespace\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSameNamespace,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway All namespace selector\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithAllNamespace,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardServiceCustomNs))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway From namespace selector\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithNamespaceSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardServiceCustomNs))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// HTTPRoute is in a different namespace than the Gateway,\n\t\t// but will be allowed since \"All\" is set.\n\t\t\"HTTPRoute: RouteGateways with GatewayAllowType: All\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardServiceCustomNs))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// HTTPRoute is in a different namespace than the Gateway,\n\t\t// and is rejected since \"SameNamespace\" is set.\n\t\t\"HTTPRoute doesn't match with RouteGateways.GatewayAllowType: SameNamespace\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t// HTTPRoute is in the same namespace of the Gateway,\n\t\t// and is allowed since \"SameNamespace\" is set.\n\t\t\"HTTPRoute matches with RouteGateways.GatewayAllowType: SameNamespace\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// HTTPRoute references same Gateway is configured with\n\t\t// in the FromList.\n\t\t\"HTTPRoute matches with RouteGateways.GatewayAllowType: FromList\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowFromList),\n\t\t\t\t\t\t\tGatewayRefs: []gatewayapi_v1alpha1.GatewayReference{{\n\t\t\t\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardServiceCustomNs))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// HTTPRoute references different Gateway is configured with\n\t\t// in the FromList.\n\t\t\"HTTPRoute doesn't match with RouteGateways.GatewayAllowType: FromList\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowFromList),\n\t\t\t\t\t\t\tGatewayRefs: []gatewayapi_v1alpha1.GatewayReference{{\n\t\t\t\t\t\t\t\tName:      \"wrong\",\n\t\t\t\t\t\t\t\tNamespace: \"reference\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"TLSRoute with TLS.Mode=Passthrough is valid\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayTLSRouteModePassthrough,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"test.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardServiceCustomNs)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"TLSRoute with TLS.Mode=Passthrough is invalid if certificateRef is specified\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     80,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.TLSProtocolType,\n\t\t\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\t\t\tMode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModePassthrough),\n\t\t\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\t\t\tKind:  \"Secret\",\n\t\t\t\t\t\t\t\tName:  sec1.Name,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindTLSRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"TLSRoute with TLS.Mode=Terminate is invalid when TLS certificate reference is not defined\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayTLSRouteModeTerminate,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"TLSRoute with TLS not defined is invalid\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     80,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.TLSProtocolType,\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindTLSRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"TLSRoute with invalid listener protocol of HTTP\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     80,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\t\t\tMode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModePassthrough),\n\t\t\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\t\t\tKind:  \"Secret\",\n\t\t\t\t\t\t\t\tName:  sec1.Name,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindTLSRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"TLSRoute with invalid listener kind\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t// TLSRoute is in a different namespace than the Gateway,\n\t\t// but will be allowed since \"All\" is set.\n\t\t\"TLSRoute: RouteGateways with GatewayAllowType: All\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayTLSRouteNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"test.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardServiceCustomNs)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// TLSRoute is in a different namespace than the Gateway,\n\t\t// and is rejected since \"SameNamespace\" is set.\n\t\t\"TLSRoute doesn't match with RouteGateways.GatewayAllowType: SameNamespace\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t// TLSRoute is in the same namespace of the Gateway,\n\t\t// and is allowed since \"SameNamespace\" is set.\n\t\t\"TLSRoute matches with RouteGateways.GatewayAllowType: SameNamespace\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayTLSRouteNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"test.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardService)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// TLSRoute references same Gateway is configured with\n\t\t// in the FromList.\n\t\t\"TLSRoute matches with RouteGateways.GatewayAllowType: FromList\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayTLSRouteNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowFromList),\n\t\t\t\t\t\t\tGatewayRefs: []gatewayapi_v1alpha1.GatewayReference{{\n\t\t\t\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"test.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardServiceCustomNs)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// TLSRoute references different Gateway is configured with\n\t\t// in the FromList.\n\t\t\"TLSRoute doesn't match with RouteGateways.GatewayAllowType: FromList\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayNoSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowFromList),\n\t\t\t\t\t\t\tGatewayRefs: []gatewayapi_v1alpha1.GatewayReference{{\n\t\t\t\t\t\t\t\tName:      \"wrong\",\n\t\t\t\t\t\t\t\tNamespace: \"reference\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t// Issue: https://github.com/projectcontour/contour/issues/3591\n\t\t\"one gateway with two httproutes, different hostnames\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithNamespaceSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic-two\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"another.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"another.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardServiceCustomNs))),\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardServiceCustomNs))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway From namespace selector, not matching\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithNamespaceSelectorNotMatching,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Namespace{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"notmatch\",\n\t\t\t\t\t\t\t\"type\": \"someother\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t// Test that a gateway selector doesn't select routes that do not match.\n\t\t\"insert basic single route, single hostname which doesn't match gateway's selector\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewaySelectorNotMatching,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardServiceCustomNs,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"custom\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t// Test that a gateway selector kind that doesn't match.\n\t\t\"insert gateway with selector kind that doesn't match\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     80,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: \"INVALID\",\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t// Test that a gateway selector group that doesn't match.\n\t\t\"insert gateway with selector group that doesn't match\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     80,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind:  \"HTTPRoute\",\n\t\t\t\t\t\t\tGroup: pointer.StringPtr(\"INVALID\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert basic multiple routes, single hostname\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\tblogService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/blog\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"blogsvc\", 80, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t\tprefixrouteHTTPRoute(\"/\", service(kuardService)), prefixrouteHTTPRoute(\"/blog\", service(blogService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"multiple hosts\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t\t\"test2.projectcontour.io\",\n\t\t\t\t\t\t\t\"test3.projectcontour.io\",\n\t\t\t\t\t\t\t\"test4.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t\tvirtualhost(\"test2.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t\tvirtualhost(\"test3.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t\tvirtualhost(\"test4.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"no host defined\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"wildcard hostname\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"*.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(virtualhost(\"*.projectcontour.io\",\n\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \":authority\", Value: \"^[a-z0-9]([-a-z0-9]*[a-z0-9])?\\\\.projectcontour\\\\.io\", MatchType: \"regex\", Invert: false},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clustersWeight(service(kuardService)),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"invalid hostnames - IP\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"192.168.122.1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"invalid hostnames - with port\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io:80\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"invalid hostnames - wildcard label by itself\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"*\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t// If the ServiceName referenced from an HTTPRoute is missing,\n\t\t// the route should return an HTTP503.\n\t\t\"missing service\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", directResponseRoute(\"/\", http.StatusServiceUnavailable)),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// If port is not defined the route will be marked as invalid (#3352).\n\t\t\"missing port\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\t\tPort:        nil,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert basic single route with exact path match\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchExact, \"/blog\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t\texactrouteHTTPRoute(\"/blog\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// Single host with single route containing multiple prefixes to the same service.\n\t\t\"insert basic single route with multiple prefixes, single hostname\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.HTTPRouteMatch{{\n\t\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(gatewayapi_v1alpha1.PathMatchPrefix),\n\t\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(gatewayapi_v1alpha1.PathMatchPrefix),\n\t\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/blog\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(gatewayapi_v1alpha1.PathMatchPrefix),\n\t\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/tech\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t\tprefixrouteHTTPRoute(\"/\", service(kuardService)),\n\t\t\t\t\t\t\tprefixrouteHTTPRoute(\"/blog\", service(kuardService)),\n\t\t\t\t\t\t\tprefixrouteHTTPRoute(\"/tech\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway with TLS, HTTP protocol is ignored\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     443,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\t\t\tKind:  \"Secret\",\n\t\t\t\t\t\t\t\tName:  sec1.Name,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\tkuardService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t\tprefixrouteHTTPRoute(\"/\", service(kuardService)),\n\t\t\t\t\t\t)),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway with TLS, HTTPS protocol missing certificateRef\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     443,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPSProtocolType,\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\tkuardService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway with TLS\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithOnlyTLS,\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\tkuardService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"test.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tSecret: secret(sec1),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway with missing TLS certificate\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithOnlyTLS,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway with invalid TLS certificate\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithOnlyTLS,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&v1.Secret{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"tlscert\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tType: v1.SecretTypeTLS,\n\t\t\t\t\tData: secretdata(\"wrong\", \"wronger\"),\n\t\t\t\t},\n\t\t\t\tkuardService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway with TLS & Insecure Listeners\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithTLSandHTTP,\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\tblogService,\n\t\t\t\thttpRouteProtocolHTTPS,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"test.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(prefixrouteHTTPRoute(\"/\", service(blogService))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tSecret: secret(sec1),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(blogService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"TLS Listener Gateway CertificateRef must be type core.Secret\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     443,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPSProtocolType,\n\t\t\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\t\t\tGroup: \"custom\",\n\t\t\t\t\t\t\t\tKind:  \"shhhh\",\n\t\t\t\t\t\t\t\tName:  sec1.Name,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\tblogService,\n\t\t\t\thttpRouteProtocolHTTPS,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"TLS Listener Gateway CertificateRef must be specified\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     443,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPSProtocolType,\n\t\t\t\t\t\tTLS:      &gatewayapi_v1alpha1.GatewayTLSConfig{},\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\tblogService,\n\t\t\t\thttpRouteProtocolHTTPS,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"No valid hostnames defined\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithAllNamespace,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":      \"contour\",\n\t\t\t\t\t\t\t\"type\":     \"controller\",\n\t\t\t\t\t\t\t\"protocol\": \"https\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"*.*.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"blogsvc\", 80, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"Invalid listener protocol type (TCP)\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     80,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.TCPProtocolType,\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{genericHTTPRoute},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"Invalid listener protocol type (UDP)\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     80,\n\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.UDPProtocolType,\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{genericHTTPRoute},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"Invalid listener protocol type (custom)\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\tPort:     80,\n\t\t\t\t\t\tProtocol: \"projectcontour.io/HTTPUDP\",\n\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\t\t\tNamespaces: &gatewayapi_v1alpha1.RouteNamespaces{\n\t\t\t\t\t\t\t\tFrom: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tobjs: []interface{}{genericHTTPRoute},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert basic single route, single hostname, gateway with TLS & Insecure Listeners, different selectors\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewaywithtlsDifferentselectors,\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\tkuardService,\n\t\t\t\tblogService,\n\t\t\t\tgenericHTTPRoute,\n\t\t\t\thttpRouteProtocolHTTPS,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"test.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(prefixrouteHTTPRoute(\"/\", service(blogService))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tSecret: secret(sec1),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"test.projectcontour.io\", prefixrouteHTTPRoute(\"/\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert basic single route with single header match and path match\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.HTTPRouteMatch{{\n\t\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(gatewayapi_v1alpha1.PathMatchPrefix),\n\t\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tHeaders: &gatewayapi_v1alpha1.HTTPHeaderMatch{\n\t\t\t\t\t\t\t\t\tType:   headerMatchTypePtr(gatewayapi_v1alpha1.HeaderMatchExact),\n\t\t\t\t\t\t\t\t\tValues: map[string]string{\"foo\": \"bar\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(virtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \"foo\", Value: \"bar\", MatchType: \"exact\", Invert: false},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clustersWeight(service(kuardService)),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert two routes with single header match, path match and header match\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.HTTPRouteMatch{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(gatewayapi_v1alpha1.PathMatchPrefix),\n\t\t\t\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/blog\"),\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(gatewayapi_v1alpha1.PathMatchPrefix),\n\t\t\t\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/tech\"),\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tHeaders: &gatewayapi_v1alpha1.HTTPHeaderMatch{\n\t\t\t\t\t\t\t\t\t\t\tType:   headerMatchTypePtr(gatewayapi_v1alpha1.HeaderMatchExact),\n\t\t\t\t\t\t\t\t\t\t\tValues: map[string]string{\"foo\": \"bar\"},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(virtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/blog\"),\n\t\t\t\t\t\t\tClusters:           clustersWeight(service(kuardService)),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/tech\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \"foo\", Value: \"bar\", MatchType: \"exact\", Invert: false},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clustersWeight(service(kuardService)),\n\t\t\t\t\t\t},\n\t\t\t\t\t)),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert two routes with single header match without explicit path match\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.HTTPRouteMatch{{\n\t\t\t\t\t\t\t\tHeaders: &gatewayapi_v1alpha1.HTTPHeaderMatch{\n\t\t\t\t\t\t\t\t\tType:   headerMatchTypePtr(gatewayapi_v1alpha1.HeaderMatchExact),\n\t\t\t\t\t\t\t\t\tValues: map[string]string{\"foo\": \"bar\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(virtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \"foo\", Value: \"bar\", MatchType: \"exact\", Invert: false},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clustersWeight(service(kuardService)),\n\t\t\t\t\t\t},\n\t\t\t\t\t)),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"Route rule with request header modifier\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t\tFilters: []gatewayapi_v1alpha1.HTTPRouteFilter{{\n\t\t\t\t\t\t\t\tType: gatewayapi_v1alpha1.HTTPRouteFilterRequestHeaderModifier,\n\t\t\t\t\t\t\t\tRequestHeaderModifier: &gatewayapi_v1alpha1.HTTPRequestHeaderFilter{\n\t\t\t\t\t\t\t\t\tSet: map[string]string{\"custom-header-set\": \"foo-bar\", \"Host\": \"bar.com\"},\n\t\t\t\t\t\t\t\t\tAdd: map[string]string{\"custom-header-add\": \"foo-bar\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(virtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustersWeight(service(kuardService)),\n\t\t\t\t\t\t\tRequestHeadersPolicy: &HeadersPolicy{\n\t\t\t\t\t\t\t\tSet: map[string]string{\n\t\t\t\t\t\t\t\t\t\"Custom-Header-Set\": \"foo-bar\", // Verify the header key is canonicalized.\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tAdd: map[string]string{\n\t\t\t\t\t\t\t\t\t\"Custom-Header-Add\": \"foo-bar\", // Verify the header key is canonicalized.\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tHostRewrite: \"bar.com\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t)),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"HTTP forward with request header modifier\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\t\tFilters: []gatewayapi_v1alpha1.HTTPRouteFilter{{\n\t\t\t\t\t\t\t\t\tType: gatewayapi_v1alpha1.HTTPRouteFilterRequestHeaderModifier,\n\t\t\t\t\t\t\t\t\tRequestHeaderModifier: &gatewayapi_v1alpha1.HTTPRequestHeaderFilter{\n\t\t\t\t\t\t\t\t\t\tSet: map[string]string{\"custom-header-set\": \"foo-bar\", \"Host\": \"bar.com\"},\n\t\t\t\t\t\t\t\t\t\tAdd: map[string]string{\"custom-header-add\": \"foo-bar\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(virtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clusterHeaders(map[string]string{\"Custom-Header-Set\": \"foo-bar\"}, map[string]string{\"Custom-Header-Add\": \"foo-bar\"}, nil, \"bar.com\", service(kuardService)),\n\t\t\t\t\t\t},\n\t\t\t\t\t)),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"Route rule with invalid request header modifier\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t\t\tFilters: []gatewayapi_v1alpha1.HTTPRouteFilter{{\n\t\t\t\t\t\t\t\t\tType: gatewayapi_v1alpha1.HTTPRouteFilterRequestHeaderModifier,\n\t\t\t\t\t\t\t\t\tRequestHeaderModifier: &gatewayapi_v1alpha1.HTTPRequestHeaderFilter{\n\t\t\t\t\t\t\t\t\t\tSet: map[string]string{\"custom-header-set\": \"foo-bar\", \"Host\": \"bar.com\"},\n\t\t\t\t\t\t\t\t\t\tAdd: map[string]string{\"!invalid-header-add\": \"foo-bar\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(virtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustersWeight(service(kuardService)),\n\t\t\t\t\t\t\tRequestHeadersPolicy: &HeadersPolicy{\n\t\t\t\t\t\t\t\tSet:         map[string]string{\"Custom-Header-Set\": \"foo-bar\"},\n\t\t\t\t\t\t\t\tAdd:         map[string]string{}, // Invalid header should not be set.\n\t\t\t\t\t\t\t\tHostRewrite: \"bar.com\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t)),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"HTTP forward with invalid request header modifier\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\t\t\tFilters: []gatewayapi_v1alpha1.HTTPRouteFilter{{\n\t\t\t\t\t\t\t\t\t\tType: gatewayapi_v1alpha1.HTTPRouteFilterRequestHeaderModifier,\n\t\t\t\t\t\t\t\t\t\tRequestHeaderModifier: &gatewayapi_v1alpha1.HTTPRequestHeaderFilter{\n\t\t\t\t\t\t\t\t\t\t\tSet: map[string]string{\"custom-header-set\": \"foo-bar\", \"Host\": \"bar.com\"},\n\t\t\t\t\t\t\t\t\t\t\tAdd: map[string]string{\"!invalid-header-add\": \"foo-bar\"},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(virtualhost(\"test.projectcontour.io\",\n\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clusterHeaders(map[string]string{\"Custom-Header-Set\": \"foo-bar\"}, map[string]string{}, nil, \"bar.com\", service(kuardService)),\n\t\t\t\t\t\t},\n\t\t\t\t\t)),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"different weights for multiple forwardTos\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\tkuardService2,\n\t\t\t\tkuardService3,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwards(\n\t\t\t\t\t\t\t\thttpRouteForwardTo(\"kuard\", 8080, 5),\n\t\t\t\t\t\t\t\thttpRouteForwardTo(\"kuard2\", 8080, 10),\n\t\t\t\t\t\t\t\thttpRouteForwardTo(\"kuard3\", 8080, 15),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixrouteHTTPRoute(\"/\",\n\t\t\t\t\t\t\t&Service{\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           5,\n\t\t\t\t\t\t\t\t\tServiceName:      kuardService.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: kuardService.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      kuardService.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Service{\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           10,\n\t\t\t\t\t\t\t\t\tServiceName:      kuardService2.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: kuardService2.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      kuardService2.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Service{\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           15,\n\t\t\t\t\t\t\t\t\tServiceName:      kuardService3.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: kuardService3.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      kuardService3.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"one service weight zero w/weights for other forwardTos\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\tkuardService2,\n\t\t\t\tkuardService3,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwards(\n\t\t\t\t\t\t\t\thttpRouteForwardTo(\"kuard\", 8080, 5),\n\t\t\t\t\t\t\t\thttpRouteForwardTo(\"kuard2\", 8080, 0),\n\t\t\t\t\t\t\t\thttpRouteForwardTo(\"kuard3\", 8080, 15),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixrouteHTTPRoute(\"/\",\n\t\t\t\t\t\t\t&Service{\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           5,\n\t\t\t\t\t\t\t\t\tServiceName:      kuardService.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: kuardService.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      kuardService.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Service{\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           0,\n\t\t\t\t\t\t\t\t\tServiceName:      kuardService2.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: kuardService2.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      kuardService2.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Service{\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           15,\n\t\t\t\t\t\t\t\t\tServiceName:      kuardService3.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: kuardService3.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      kuardService3.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t)),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"weight of zero for a single forwardTo results in 503\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\tkuardService2,\n\t\t\t\tkuardService3,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", directResponseRouteService(\"/\", http.StatusServiceUnavailable, &Service{\n\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\tWeight:           0,\n\t\t\t\t\t\t\t\tServiceName:      kuardService.Name,\n\t\t\t\t\t\t\t\tServiceNamespace: kuardService.Namespace,\n\t\t\t\t\t\t\t\tServicePort:      kuardService.Spec.Ports[0],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t})),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"basic TLSRoute\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithTLSRouteSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"tcp.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"tcp.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardService)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"TLSRoute with multiple SNIs\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithTLSRouteSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"tcp.projectcontour.io\",\n\t\t\t\t\t\t\t\t\t\"another.projectcontour.io\",\n\t\t\t\t\t\t\t\t\t\"thing.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"another.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardService)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"tcp.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardService)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"thing.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardService)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"TLSRoute with multiple SNIs, one is invalid\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithTLSRouteSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"tcp.projectcontour.io\",\n\t\t\t\t\t\t\t\t\t\"*.*.another.projectcontour.io\",\n\t\t\t\t\t\t\t\t\t\"thing.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"tcp.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardService)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"thing.projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardService)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"TLSRoute with multiple SNIs, all are invalid\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"tcp.*.projectcontour.io\",\n\t\t\t\t\t\t\t\t\t\"*.*.another.projectcontour.io\",\n\t\t\t\t\t\t\t\t\t\"!!thing.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"TLSRoute without any hostnames specified results in '*' match all\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithTLSRouteSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches:   []gatewayapi_v1alpha1.TLSRouteMatch{{}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"*\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(kuardService)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"TLSRoute with missing forwardTo service\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithSelector,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\t\t\"tcp.projectcontour.io\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert gateway listener with host\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithHostname,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchExact, \"/blog\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"gateway.projectcontour.io\",\n\t\t\t\t\t\t\texactrouteHTTPRoute(\"/blog\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert gateway listener with host, httproute with host\": {\n\t\t\tgatewayclass: validClass,\n\t\t\tgateway:      gatewayWithWildcardHostname,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\":  \"contour\",\n\t\t\t\t\t\t\t\"type\": \"controller\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\t\"http.projectcontour.io\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\t\tMatches:   httpRouteMatch(gatewayapi_v1alpha1.PathMatchExact, \"/blog\"),\n\t\t\t\t\t\t\tForwardTo: httpRouteForwardTo(\"kuard\", 8080, 1),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"http.projectcontour.io\",\n\t\t\t\t\t\t\texactrouteHTTPRoute(\"/blog\", service(kuardService))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t}\n\n\tfor name, tc := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\n\t\t\tbuilder := Builder{\n\t\t\t\tSource: KubernetesCache{\n\t\t\t\t\tConfiguredGateway: types.NamespacedName{\n\t\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tgatewayclass: tc.gatewayclass,\n\t\t\t\t\tgateway:      tc.gateway,\n\t\t\t\t\tFieldLogger:  fixture.NewTestLogger(t),\n\t\t\t\t},\n\t\t\t\tProcessors: []Processor{\n\t\t\t\t\t&IngressProcessor{\n\t\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t\t},\n\t\t\t\t\t&HTTPProxyProcessor{\n\t\t\t\t\t\tDisablePermitInsecure: tc.disablePermitInsecure,\n\t\t\t\t\t\tFallbackCertificate: &types.NamespacedName{\n\t\t\t\t\t\t\tName:      tc.fallbackCertificateName,\n\t\t\t\t\t\t\tNamespace: tc.fallbackCertificateNamespace,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t&GatewayAPIProcessor{\n\t\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t\t},\n\t\t\t\t\t&ListenerProcessor{},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, o := range tc.objs {\n\t\t\t\tbuilder.Source.Insert(o)\n\t\t\t}\n\t\t\tdag := builder.Build()\n\n\t\t\tgot := make(map[int]*Listener)\n\t\t\tdag.Visit(listenerMap(got).Visit)\n\n\t\t\twant := make(map[int]*Listener)\n\t\t\tfor _, v := range tc.want {\n\t\t\t\tif l, ok := v.(*Listener); ok {\n\t\t\t\t\twant[l.Port] = l\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert.Equal(t, want, got)\n\t\t})\n\t}\n}\n\nfunc TestDAGInsert(t *testing.T) {\n\t// The DAG is sensitive to ordering, adding an ingress, then a service,\n\t// should have the same result as adding a service, then an ingress.\n\n\t// weird secret with a blank ca.crt that\n\t// cert manager creates. #1644\n\tsec3 := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"secret\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tType: v1.SecretTypeTLS,\n\t\tData: map[string][]byte{\n\t\t\tCACertificateKey:    []byte(\"\"),\n\t\t\tv1.TLSCertKey:       []byte(fixture.CERTIFICATE),\n\t\t\tv1.TLSPrivateKeyKey: []byte(fixture.RSA_PRIVATE_KEY),\n\t\t},\n\t}\n\n\tsec4 := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"secret\",\n\t\t\tNamespace: \"root\",\n\t\t},\n\t\tType: v1.SecretTypeTLS,\n\t\tData: secretdata(fixture.CERTIFICATE, fixture.RSA_PRIVATE_KEY),\n\t}\n\n\tfallbackCertificateSecret := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"fallbacksecret\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tType: v1.SecretTypeTLS,\n\t\tData: secretdata(fixture.CERTIFICATE, fixture.RSA_PRIVATE_KEY),\n\t}\n\n\tfallbackCertificateSecretRootNamespace := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"fallbacksecret\",\n\t\t\tNamespace: \"root\",\n\t\t},\n\t\tType: v1.SecretTypeTLS,\n\t\tData: secretdata(fixture.CERTIFICATE, fixture.RSA_PRIVATE_KEY),\n\t}\n\n\tcert1 := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"ca\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\tCACertificateKey: []byte(fixture.CERTIFICATE),\n\t\t},\n\t}\n\n\ti1V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromInt(8080)),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti1aV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"kubernetes.io/ingress.allow-http\": \"false\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromInt(8080)),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i2V1 is functionally identical to i1V1\n\ti2V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromInt(8080))),\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i2aV1 is missing a http key from the spec.rule.\n\t// see issue 606\n\ti2aV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost: \"test1.test.com\",\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i3V1 is similar to i2V1 but includes a hostname on the ingress rule\n\ti3V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"kuard.example.com\"},\n\t\t\t\tSecretName: sec1.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost:             \"kuard.example.com\",\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromInt(8080))),\n\t\t\t}},\n\t\t},\n\t}\n\t// i4V1 is like i1V1 except it uses a named service port\n\ti4V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i5V1 is functionally identical to i2V1\n\ti5V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromString(\"http\"))),\n\t\t\t}},\n\t\t},\n\t}\n\t// i6V1 contains two named vhosts which point to the same service\n\t// one of those has TLS\n\ti6V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"two-vhosts\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"b.example.com\"},\n\t\t\t\tSecretName: sec1.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost:             \"a.example.com\",\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromInt(8080))),\n\t\t\t}, {\n\t\t\t\tHost:             \"b.example.com\",\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromString(\"http\"))),\n\t\t\t}},\n\t\t},\n\t}\n\ti6aV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"two-vhosts\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"kubernetes.io/ingress.allow-http\": \"false\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"b.example.com\"},\n\t\t\t\tSecretName: sec1.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost:             \"a.example.com\",\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromInt(8080))),\n\t\t\t}, {\n\t\t\t\tHost:             \"b.example.com\",\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromString(\"http\"))),\n\t\t\t}},\n\t\t},\n\t}\n\n\ti6bV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"two-vhosts\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"ingress.kubernetes.io/force-ssl-redirect\": \"true\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"b.example.com\"},\n\t\t\t\tSecretName: sec1.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost:             \"b.example.com\",\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromString(\"http\"))),\n\t\t\t}},\n\t\t},\n\t}\n\n\ti6cV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"two-vhosts\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"ingress.kubernetes.io/force-ssl-redirect\": \"true\",\n\t\t\t\t\"kubernetes.io/ingress.allow-http\":         \"false\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"b.example.com\"},\n\t\t\t\tSecretName: sec1.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost:             \"b.example.com\",\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromString(\"http\"))),\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i7V1 contains a single vhost with two paths\n\ti7V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"two-paths\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"b.example.com\"},\n\t\t\t\tSecretName: sec1.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost: \"b.example.com\",\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\tPath:    \"/kuarder\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuarder\", intstr.FromInt(8080)),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i8V1 is identical to i7V1 but uses multiple IngressRules\n\ti8V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"two-rules\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"b.example.com\"},\n\t\t\t\tSecretName: sec1.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost: \"b.example.com\",\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\tHost: \"b.example.com\",\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/kuarder\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuarder\", intstr.FromInt(8080)),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\t// i9V1 is identical to i8V1 but disables non TLS connections\n\ti9V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"two-rules\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"kubernetes.io/ingress.allow-http\": \"false\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"b.example.com\"},\n\t\t\t\tSecretName: sec1.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost: \"b.example.com\",\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\tHost: \"b.example.com\",\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/kuarder\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuarder\", intstr.FromInt(8080)),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti10aV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"two-rules\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/tls-minimum-protocol-version\": \"1.3\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"b.example.com\"},\n\t\t\t\tSecretName: sec1.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost: \"b.example.com\",\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i11V1 has a websocket route\n\ti11V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"websocket\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/websocket-routes\": \"/ws1 , /ws2\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\tPath:    \"/ws1\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i12aV1 has an invalid timeout\n\ti12aV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"timeout\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/request-timeout\": \"peanut\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i12bV1 has a reasonable timeout\n\ti12bV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"timeout\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/request-timeout\": \"1m30s\", // 90 seconds y'all\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// i12cV1 has an unreasonable timeout\n\ti12cV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"timeout\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/request-timeout\": \"infinite\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{HTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{Path: \"/\",\n\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t}}},\n\t\t\t\t}}}},\n\t}\n\n\ti12dV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"timeout\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/response-timeout\": \"peanut\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti12eV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"timeout\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/response-timeout\": \"1m30s\", // 90 seconds y'all\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti12fV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"timeout\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/response-timeout\": \"infinite\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{HTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{Path: \"/\",\n\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t}}},\n\t\t\t\t}}}},\n\t}\n\n\t// i13_v1 a and b are a pair of ingressesv1 for the same vhost\n\t// they represent a tricky way over 'overlaying' routes from one\n\t// ingress onto another\n\ti13aV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"app\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"ingress.kubernetes.io/force-ssl-redirect\": \"true\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"example.com\"},\n\t\t\t\tSecretName: \"example-tls\",\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost: \"example.com\",\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"app-service\", intstr.FromInt(8080)),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti13bV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{Name: \"challenge\", Namespace: \"nginx-ingress\"},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost: \"example.com\",\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/.well-known/acme-challenge/gVJl5NWL2owUqZekjHkt_bo3OHYC2XNDURRRgLI5JTk\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"challenge-service\", intstr.FromInt(8009)),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti3aV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromInt(80))),\n\t\t\t}},\n\t\t},\n\t}\n\n\ti14V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"timeout\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/retry-on\":        \"gateway-error\",\n\t\t\t\t\"projectcontour.io/num-retries\":     \"6\",\n\t\t\t\t\"projectcontour.io/per-try-timeout\": \"10s\",\n\t\t\t},\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti15V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"regex\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"/[^/]+/invoices(/.*|/?)\", // issue 1243\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti15InvalidRegexV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"regex\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath:    \"^\\\\/(?!\\\\/)(.*?)\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti16V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"wildcards\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\t// No hostname.\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\t// Allow wildcard as first label.\n\t\t\t\t// K8s will only allow hostnames with wildcards of this form.\n\t\t\t\tHost: \"*.example.com\",\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\ti17V1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost:             \"example.com\",\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(\"kuard\", intstr.FromInt(8080))),\n\t\t\t}},\n\t\t},\n\t}\n\n\tiPathMatchTypesV1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"pathmatchtypes\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tPathType: (*networking_v1.PathType)(pointer.StringPtr(\"Exact\")),\n\t\t\t\t\t\t\t\tPath:     \"/exact\",\n\t\t\t\t\t\t\t\tBackend:  *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tPathType: (*networking_v1.PathType)(pointer.StringPtr(\"Exact\")),\n\t\t\t\t\t\t\t\tPath:     \"/exact_with_regex/.*\",\n\t\t\t\t\t\t\t\tBackend:  *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tPathType: (*networking_v1.PathType)(pointer.StringPtr(\"Prefix\")),\n\t\t\t\t\t\t\t\tPath:     \"/prefix\",\n\t\t\t\t\t\t\t\tBackend:  *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tPathType: (*networking_v1.PathType)(pointer.StringPtr(\"Prefix\")),\n\t\t\t\t\t\t\t\tPath:     \"/prefix_trailing_slash/\",\n\t\t\t\t\t\t\t\tBackend:  *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tPathType: (*networking_v1.PathType)(pointer.StringPtr(\"Prefix\")),\n\t\t\t\t\t\t\t\tPath:     \"/prefix_with_regex/.*\",\n\t\t\t\t\t\t\t\tBackend:  *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tPathType: (*networking_v1.PathType)(pointer.StringPtr(\"ImplementationSpecific\")),\n\t\t\t\t\t\t\t\tPath:     \"/implementation_specific\",\n\t\t\t\t\t\t\t\tBackend:  *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tPathType: (*networking_v1.PathType)(pointer.StringPtr(\"ImplementationSpecific\")),\n\t\t\t\t\t\t\t\tPath:     \"/implementation_specific_with_regex/.*\",\n\t\t\t\t\t\t\t\tBackend:  *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// s3a and b have http/2 protocol annotations\n\ts3a := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/upstream-protocol.h2c\": \"80,http\",\n\t\t\t},\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       80,\n\t\t\t\tTargetPort: intstr.FromInt(8888),\n\t\t\t}},\n\t\t},\n\t}\n\n\ts3b := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      s3a.Name,\n\t\t\tNamespace: s3a.Namespace,\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/upstream-protocol.h2\": \"80,http\",\n\t\t\t},\n\t\t},\n\t\tSpec: s3a.Spec,\n\t}\n\n\ts3c := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      s3b.Name,\n\t\t\tNamespace: s3b.Namespace,\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/upstream-protocol.tls\": \"80,http\",\n\t\t\t},\n\t\t},\n\t\tSpec: s3b.Spec,\n\t}\n\n\tsec13 := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-tls\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tType: v1.SecretTypeTLS,\n\t\tData: secretdata(fixture.CERTIFICATE, fixture.RSA_PRIVATE_KEY),\n\t}\n\n\ts13a := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"app-service\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\ts13b := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"challenge-service\",\n\t\t\tNamespace: \"nginx-ingress\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8009,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyMultipleBackends := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}, {\n\t\t\t\t\tName: \"kuarder\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyMinTLS12 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"foo.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName:             sec1.Name,\n\t\t\t\t\tMinimumProtocolVersion: \"1.2\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyMinTLS13 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"foo.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName:             sec1.Name,\n\t\t\t\t\tMinimumProtocolVersion: \"1.3\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyMinTLSInvalid := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"foo.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName:             sec1.Name,\n\t\t\t\t\tMinimumProtocolVersion: \"0.999\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyWeightsTwoRoutesDiffWeights := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/a\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName:   \"kuard\",\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tWeight: 90,\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/b\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName:   \"kuard\",\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tWeight: 60,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyWeightsOneRouteDiffWeights := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/a\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName:   \"kuard\",\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tWeight: 90,\n\t\t\t\t}, {\n\t\t\t\t\tName:   \"kuard\",\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tWeight: 60,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyRetryPolicyValidTimeout := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"bar-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"bar.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tRetryPolicy: &contour_api_v1.RetryPolicy{\n\t\t\t\t\tNumRetries:    6,\n\t\t\t\t\tPerTryTimeout: \"10s\",\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyRetryPolicyInvalidTimeout := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"bar-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"bar.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tRetryPolicy: &contour_api_v1.RetryPolicy{\n\t\t\t\t\tNumRetries:    6,\n\t\t\t\t\tPerTryTimeout: \"please\",\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyRetryPolicyZeroRetries := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"bar-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"bar.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tRetryPolicy: &contour_api_v1.RetryPolicy{\n\t\t\t\t\tNumRetries:    0,\n\t\t\t\t\tPerTryTimeout: \"10s\",\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyTimeoutPolicyInvalidResponse := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"bar-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"bar.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tTimeoutPolicy: &contour_api_v1.TimeoutPolicy{\n\t\t\t\t\tResponse: \"peanut\",\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyTimeoutPolicyValidResponse := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"bar-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"bar.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tTimeoutPolicy: &contour_api_v1.TimeoutPolicy{\n\t\t\t\t\tResponse: \"1m30s\",\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyTimeoutPolicyInfiniteResponse := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"bar-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"bar.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tTimeoutPolicy: &contour_api_v1.TimeoutPolicy{\n\t\t\t\t\tResponse: \"infinite\",\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\ts1 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\t// s1a carries the tls annotation\n\ts1a := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/upstream-protocol.tls\": \"8080\",\n\t\t\t},\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\t// s1b carries all four ingress annotations{\n\ts1b := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"projectcontour.io/max-connections\":      \"9000\",\n\t\t\t\t\"projectcontour.io/max-pending-requests\": \"4096\",\n\t\t\t\t\"projectcontour.io/max-requests\":         \"404\",\n\t\t\t\t\"projectcontour.io/max-retries\":          \"7\",\n\t\t\t},\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\t// s2 is like s1 but with a different name\n\ts2 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuarder\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\t// s2a is like s1 but with a different name again.\n\t// used in testing override priority.\n\ts2a := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuardest\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\t// s3 is like s1 but has a different port\n\ts3 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       9999,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\ts4 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"blog\",\n\t\t\tNamespace: \"marketing\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\ts9 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"nginx\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tProtocol: \"TCP\",\n\t\t\t\tPort:     80,\n\t\t\t}},\n\t\t},\n\t}\n\n\ts10 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"tls-passthrough\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"https\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       443,\n\t\t\t\tTargetPort: intstr.FromInt(443),\n\t\t\t}, {\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       80,\n\t\t\t\tTargetPort: intstr.FromInt(80),\n\t\t\t}},\n\t\t},\n\t}\n\n\ts11 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"blog\",\n\t\t\tNamespace: \"it\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:     \"blog\",\n\t\t\t\tProtocol: \"TCP\",\n\t\t\t\tPort:     8080,\n\t\t\t}},\n\t\t},\n\t}\n\n\ts12 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"teama\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\ts13 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"teamb\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\ts14 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"nginx\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tExternalName: \"externalservice.io\",\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tProtocol: \"TCP\",\n\t\t\t\tPort:     80,\n\t\t\t}},\n\t\t\tType: v1.ServiceTypeExternalName,\n\t\t},\n\t}\n\n\tproxyDelegatedTLSSecret := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"app-with-tls-delegation\",\n\t\t\tNamespace: s10.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"app-with-tls-delegation.127.0.0.1.nip.io\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: \"projectcontour/ssl-cert\", // not delegated\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s10.Name,\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy1 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy1a tcp forwards traffic to default/kuard:8080 by TLS pass-through it.\n\tproxy1a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard-tcp\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"kuard.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t// proxy1b is a straight HTTP forward, no conditions.\n\tproxy1b := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy1c is a straight forward, with prefix and header conditions.\n\tproxy1c := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:    \"x-request-id\",\n\t\t\t\t\t\tPresent: true,\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tPrefix: \"/kuard\",\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"e-tag\",\n\t\t\t\t\t\tContains: \"abcdef\",\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:        \"x-timeout\",\n\t\t\t\t\t\tNotContains: \"infinity\",\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:  \"digest-auth\",\n\t\t\t\t\t\tExact: \"scott\",\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"digest-password\",\n\t\t\t\t\t\tNotExact: \"tiger\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy1d tcp forwards secure traffic to default/kuard:8080 by TLS pass-through it,\n\t// insecure traffic is 301 upgraded.\n\tproxy1d := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard-tcp\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"kuard.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t// proxy1e tcp forwards secure traffic to default/kuard:8080 by TLS pass-through it,\n\t// insecure traffic is not 301 upgraded because of the permitInsecure: true annotation.\n\tproxy1e := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard-tcp\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"kuard.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tPermitInsecure: true,\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s10.Name,\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s10.Name,\n\t\t\t\t\tPort: 443,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t//proxy1f is identical to proxy1 and ir1, except for a different service.\n\t// Used to test priority when importing ir then httproxy.\n\tproxy1f := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s2a.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy2a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"kubesystem\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:    \"x-request-id\",\n\t\t\t\t\t\tPresent: true,\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:        \"x-timeout\",\n\t\t\t\t\t\tNotContains: \"infinity\",\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:  \"digest-auth\",\n\t\t\t\t\t\tExact: \"scott\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\tName:      \"kuard\",\n\t\t\t\tNamespace: \"default\",\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy2b := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/kuard\",\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"e-tag\",\n\t\t\t\t\t\tContains: \"abcdef\",\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"digest-password\",\n\t\t\t\t\t\tNotExact: \"tiger\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy2c := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tHealthCheckPolicy: &contour_api_v1.HTTPHealthCheckPolicy{\n\t\t\t\t\tPath: \"/healthz\",\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy2d is a proxy with two routes that have the same prefix and a Contains header\n\t// condition on the same header, differing only in the value of the condition.\n\tproxy2d := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{\n\t\t\t\t{\n\t\t\t\t\tConditions: []contour_api_v1.MatchCondition{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\t\t\tName:     \"e-tag\",\n\t\t\t\t\t\t\t\tContains: \"abc\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\t\tPort: 8080,\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tConditions: []contour_api_v1.MatchCondition{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\t\t\tName:     \"e-tag\",\n\t\t\t\t\t\t\t\tContains: \"def\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\t\tPort: 8080,\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t// proxy2e is a proxy with two routes that both have a condition on the same\n\t// header, one using Contains and one using NotContains.\n\tproxy2e := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{\n\t\t\t\t{\n\t\t\t\t\tConditions: []contour_api_v1.MatchCondition{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\t\t\tName:     \"e-tag\",\n\t\t\t\t\t\t\t\tContains: \"abc\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\t\tPort: 8080,\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tConditions: []contour_api_v1.MatchCondition{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\t\t\tName:        \"e-tag\",\n\t\t\t\t\t\t\t\tNotContains: \"abc\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\t\tPort: 8080,\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t// proxy6 has TLS and does not specify min tls version\n\tproxy6 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"foo.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: sec1.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy17 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t\tUpstreamValidation: &contour_api_v1.UpstreamValidation{\n\t\t\t\t\t\tCACertificate: cert1.Name,\n\t\t\t\t\t\tSubjectName:   \"example.com\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\tprotocolh2 := \"h2\"\n\tproxy17h2 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName:     \"kuard\",\n\t\t\t\t\tPort:     8080,\n\t\t\t\t\tProtocol: &protocolh2,\n\t\t\t\t\tUpstreamValidation: &contour_api_v1.UpstreamValidation{\n\t\t\t\t\t\tCACertificate: cert1.Name,\n\t\t\t\t\t\tSubjectName:   \"example.com\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy18 is downstream validation, HTTP route\n\tproxy18 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: sec1.Name,\n\t\t\t\t\tClientValidation: &contour_api_v1.DownstreamValidation{\n\t\t\t\t\t\tCACertificate: cert1.Name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy19 is downstream validation, TCP proxying\n\tproxy19 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: sec1.Name,\n\t\t\t\t\tClientValidation: &contour_api_v1.DownstreamValidation{\n\t\t\t\t\t\tCACertificate: cert1.Name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t// proxy10 has a websocket route\n\tproxy10 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/websocket\",\n\t\t\t\t}},\n\t\t\t\tEnableWebsockets: true,\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy10b has a websocket route w/multiple upstreams\n\tproxy10b := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/websocket\",\n\t\t\t\t}},\n\t\t\t\tEnableWebsockets: true,\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy12 tests mirroring\n\tproxy12 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}, {\n\t\t\t\t\tName:   s2.Name,\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tMirror: true,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy13 has two mirrors, invalid.\n\tproxy13 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}, {\n\t\t\t\t\tName:   s2.Name,\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tMirror: true,\n\t\t\t\t}, {\n\t\t\t\t\t// it is legal to mention a service more that\n\t\t\t\t\t// once, however it is not legal for more than one\n\t\t\t\t\t// service to be marked as mirror.\n\t\t\t\t\tName:   s2.Name,\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tMirror: true,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy20 is downstream validation, skip cert validation\n\tproxy20 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: sec1.Name,\n\t\t\t\t\tClientValidation: &contour_api_v1.DownstreamValidation{\n\t\t\t\t\t\tSkipClientCertValidation: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy21 is downstream validation, skip cert validation, with a CA\n\tproxy21 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: sec1.Name,\n\t\t\t\t\tClientValidation: &contour_api_v1.DownstreamValidation{\n\t\t\t\t\t\tSkipClientCertValidation: true,\n\t\t\t\t\t\tCACertificate:            cert1.Name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// invalid because tcpproxy both includes another and\n\t// has a list of services.\n\tproxy37 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"simple\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"passthrough.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tInclude: &contour_api_v1.TCPProxyInclude{\n\t\t\t\t\tName:      \"foo\",\n\t\t\t\t\tNamespace: \"roots\",\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t// Invalid because tcpproxy neither includes another httpproxy\n\t// nor has a list of services.\n\tproxy37a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"simple\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"passthrough.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{},\n\t\t},\n\t}\n\n\t// proxy38 is invalid when combined with proxy39\n\t// as the latter is a root.\n\tproxy38 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"simple\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"passthrough.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tInclude: &contour_api_v1.TCPProxyInclude{\n\t\t\t\t\tName:      \"foo\",\n\t\t\t\t\tNamespace: s1.Namespace,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tproxy39 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"foo\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"www.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t// proxy39broot is a valid TCPProxy which includes to another TCPProxy\n\tproxy39broot := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"root\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"www.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tInclude: &contour_api_v1.TCPProxyInclude{\n\t\t\t\t\tName:      \"foo\",\n\t\t\t\t\tNamespace: s1.Namespace,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tproxy39brootplural := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"root\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"www.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tIncludesDeprecated: &contour_api_v1.TCPProxyInclude{\n\t\t\t\t\tName:      \"foo\",\n\t\t\t\t\tNamespace: s1.Namespace,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tproxy39bchild := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"foo\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\tproxy40 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"foo\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t// issue 2309, each route must have at least one service\n\tproxy41 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"missing-service\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"missing-service.example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: nil, // missing\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy100 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"marketingwww\",\n\t\t\t\tNamespace: \"marketing\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy100a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"marketingwww\",\n\t\t\tNamespace: \"marketing\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"blog\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy100b := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"marketingwww\",\n\t\t\tNamespace: \"marketing\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/infotech\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"blog\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy100c := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"marketingwww\",\n\t\t\tNamespace: \"marketing\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"marketingit\",\n\t\t\t\tNamespace: \"it\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/it\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/infotech\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"blog\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"blog\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy100d := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"marketingit\",\n\t\t\tNamespace: \"it\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"blog\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy101 and proxy101a test inclusion without a specified namespace.\n\tproxy101 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName: \"kuarder\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/kuarder\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy101a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuarder\",\n\t\t\tNamespace: proxy101.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s2.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// invalid because two prefix conditions on route.\n\tproxy102 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/v1\",\n\t\t\t\t}, {\n\t\t\t\t\tPrefix: \"/api\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// invalid because two prefix conditions on include.\n\tproxy103 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"www\",\n\t\t\t\tNamespace: \"teama\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/v1\",\n\t\t\t\t}, {\n\t\t\t\t\tPrefix: \"/api\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy103a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"www\",\n\t\t\tNamespace: \"teama\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/v1\",\n\t\t\t\t}, {\n\t\t\t\t\tPrefix: \"/api\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy104 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName: \"kuarder\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/kuarder\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy104a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuarder\",\n\t\t\tNamespace: proxy104.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s2.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy105 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName: \"kuarder\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/kuarder\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy105a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuarder\",\n\t\t\tNamespace: proxy105.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s2.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy106 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName: \"kuarder\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/kuarder/\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy106a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuarder\",\n\t\t\tNamespace: proxy105.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s2.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy107 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName: \"kuarder\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/kuarder\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy107a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuarder\",\n\t\t\tNamespace: proxy105.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/withavengeance\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s2.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy108 and proxy108a test duplicate conditions on include\n\tproxy108 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"root\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"blogteama\",\n\t\t\t\tNamespace: \"teama\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"x-header\",\n\t\t\t\t\t\tContains: \"abc\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tName:      \"blogteama\",\n\t\t\t\tNamespace: \"teamb\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"x-header\",\n\t\t\t\t\t\tContains: \"abc\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy108a := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"blogteama\",\n\t\t\tNamespace: \"teama\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s12.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxy108b := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"blogteamb\",\n\t\t\tNamespace: \"teamb\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s13.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyReplaceHostHeaderRoute := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\tValue: \"bar.com\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyReplaceHostHeaderService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\t\tValue: \"bar.com\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyReplaceHostHeaderMultiple := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\tValue: \"bar.com\",\n\t\t\t\t\t}, {\n\t\t\t\t\t\tName:  \"x-header\",\n\t\t\t\t\t\tValue: \"bar.com\",\n\t\t\t\t\t}, {\n\t\t\t\t\t\tName:  \"y-header\",\n\t\t\t\t\t\tValue: \"zed.com\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyReplaceNonHostHeader := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"x-header\",\n\t\t\t\t\t\tValue: \"bar.com\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyReplaceHeaderEmptyValue := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName: \"x-header\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyCookieLoadBalancer := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tLoadBalancerPolicy: &contour_api_v1.LoadBalancerPolicy{\n\t\t\t\t\tStrategy: \"Cookie\",\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyLoadBalancerHashPolicyHeader := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tLoadBalancerPolicy: &contour_api_v1.LoadBalancerPolicy{\n\t\t\t\t\tStrategy: \"RequestHash\",\n\t\t\t\t\tRequestHashPolicies: []contour_api_v1.RequestHashPolicy{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTerminal: true,\n\t\t\t\t\t\t\tHeaderHashOptions: &contour_api_v1.HeaderHashOptions{\n\t\t\t\t\t\t\t\tHeaderName: \"X-Some-Header\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Lower case but duplicated, should be ignored.\n\t\t\t\t\t\t\tHeaderHashOptions: &contour_api_v1.HeaderHashOptions{\n\t\t\t\t\t\t\t\tHeaderName: \"x-some-header\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHeaderHashOptions: nil,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHeaderHashOptions: &contour_api_v1.HeaderHashOptions{\n\t\t\t\t\t\t\t\tHeaderName: \"X-Some-Other-Header\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHeaderHashOptions: &contour_api_v1.HeaderHashOptions{\n\t\t\t\t\t\t\t\tHeaderName: \"\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyLoadBalancerHashPolicyHeaderAllInvalid := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tLoadBalancerPolicy: &contour_api_v1.LoadBalancerPolicy{\n\t\t\t\t\tStrategy: \"RequestHash\",\n\t\t\t\t\tRequestHashPolicies: []contour_api_v1.RequestHashPolicy{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHeaderHashOptions: nil,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHeaderHashOptions: &contour_api_v1.HeaderHashOptions{\n\t\t\t\t\t\t\t\tHeaderName: \"\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy109 has a route that rewrites headers.\n\tproxy109 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"In-Foo\",\n\t\t\t\t\t\tValue: \"bar\",\n\t\t\t\t\t}},\n\t\t\t\t\tRemove: []string{\n\t\t\t\t\t\t\"In-Baz\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tResponseHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Out-Foo\",\n\t\t\t\t\t\tValue: \"bar\",\n\t\t\t\t\t}},\n\t\t\t\t\tRemove: []string{\n\t\t\t\t\t\t\"Out-Baz\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\t// proxy111 has a route that rewrites headers.\n\tproxy111 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t\tResponseHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\tValue: \"bar.baz\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\t// proxy112 has a route that rewrites headers.\n\tproxy112 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t\tResponseHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\t\tValue: \"bar.baz\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\tprotocol := \"h2c\"\n\tproxy110 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName:     \"kuard\",\n\t\t\t\t\tPort:     8080,\n\t\t\t\t\tProtocol: &protocol,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tingressExternalNameService := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"externalname\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost: \"example.com\",\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(s14.GetName(), intstr.FromInt(80)),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyExternalNameService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s14.GetName(),\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\ttcpProxyExternalNameService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: sec1.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName:     s14.GetName(),\n\t\t\t\t\tPort:     80,\n\t\t\t\t\tProtocol: pointer.StringPtr(\"tls\"),\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\ttests := map[string]struct {\n\t\tobjs                         []interface{}\n\t\tdisablePermitInsecure        bool\n\t\tenableExternalNameSvc        bool\n\t\tfallbackCertificateName      string\n\t\tfallbackCertificateNamespace string\n\t\twant                         []Vertex\n\t}{\n\t\t\"ingressv1: insert ingress w/ default backend w/o matching service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti1V1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ default backend\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti1V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ single unnamed backend w/o matching service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti2V1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ single unnamed backend\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti2V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress with missing spec.rule.http key\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti2aV1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ host name and single backend w/o matching service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti3V1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ host name and single backend\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti3V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"kuard.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert non matching service then ingress w/ default backend\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts2,\n\t\t\t\ti1V1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ default backend then matching service with wrong port\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti1V1,\n\t\t\t\ts3,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert unnamed ingress w/ single backend then matching service with wrong port\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti2V1,\n\t\t\t\ts3,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ default backend then matching service w/ named port\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti4V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert service w/ named port then ingress w/ default backend\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\ti4V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ single unnamed backend w/ named service port then service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti5V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert service then ingress w/ single unnamed backend w/ named service port\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\ti5V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert secret\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert secret then ingress w/o tls\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ti1V1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert service, secret then ingress w/o tls\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\tsec1,\n\t\t\t\ti1V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert secret then ingress w/ tls\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ti3V1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert service, secret then ingress w/ tls\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\tsec1,\n\t\t\t\ti3V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"kuard.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"kuard.example.com\", sec1, prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert service w/ secret with w/ blank ca.crt\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\tsec3, // issue 1644\n\t\t\t\ti3V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"kuard.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"kuard.example.com\", sec3, prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert invalid secret then ingress w/o tls\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tsecInvalid,\n\t\t\t\ti1V1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert service, invalid secret then ingress w/o tls\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\tsecInvalid,\n\t\t\t\ti1V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert invalid secret then ingress w/ tls\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tsecInvalid,\n\t\t\t\ti3V1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert service, invalid secret then ingress w/ tls\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\tsecInvalid,\n\t\t\t\ti3V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"kuard.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ two vhosts\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti6V1,\n\t\t\t},\n\t\t\twant: nil, // no matching service\n\t\t},\n\t\t\"ingressv1: insert ingress w/ two vhosts then matching service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti6V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"a.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t\tvirtualhost(\"b.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert service then ingress w/ two vhosts\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\ti6V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"a.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t\tvirtualhost(\"b.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ two vhosts then service then secret\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti6V1,\n\t\t\t\ts1,\n\t\t\t\tsec1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"a.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t\tvirtualhost(\"b.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"b.example.com\", sec1, prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert service then secret then ingress w/ two vhosts\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\tsec1,\n\t\t\t\ti6V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"a.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t\tvirtualhost(\"b.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"b.example.com\", sec1, prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ two paths then one service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti7V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"b.example.com\",\n\t\t\t\t\t\t\tprefixroute(\"/\", service(s1)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ two paths then services\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti7V1,\n\t\t\t\ts2,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"b.example.com\",\n\t\t\t\t\t\t\tprefixroute(\"/\", service(s1)),\n\t\t\t\t\t\t\tprefixroute(\"/kuarder\", service(s2)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert two services then ingress w/ two ingress rules\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1, s2, i8V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"b.example.com\",\n\t\t\t\t\t\t\tprefixroute(\"/\", service(s1)),\n\t\t\t\t\t\t\tprefixroute(\"/kuarder\", service(s2)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ two paths httpAllowed: false\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti9V1,\n\t\t\t},\n\t\t\twant: []Vertex{},\n\t\t},\n\t\t\"ingressv1: insert ingress w/ two paths httpAllowed: false then tls and service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti9V1,\n\t\t\t\tsec1,\n\t\t\t\ts1, s2,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"b.example.com\", sec1,\n\t\t\t\t\t\t\tprefixroute(\"/\", service(s1)),\n\t\t\t\t\t\t\tprefixroute(\"/kuarder\", service(s2)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert default ingress httpAllowed: false\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti1aV1,\n\t\t\t},\n\t\t\twant: []Vertex{},\n\t\t},\n\t\t\"ingressv1: insert default ingress httpAllowed: false then tls and service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti1aV1, sec1, s1,\n\t\t\t},\n\t\t\twant: []Vertex{}, // default ingress cannot be tls\n\t\t},\n\t\t\"ingressv1: insert ingress w/ two vhosts httpAllowed: false\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti6aV1,\n\t\t\t},\n\t\t\twant: []Vertex{},\n\t\t},\n\t\t\"ingressv1: insert ingress w/ two vhosts httpAllowed: false then tls and service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti6aV1, sec1, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"b.example.com\", sec1, prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ force-ssl-redirect: true\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti6bV1, sec1, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"b.example.com\", routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"b.example.com\", sec1, routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\n\t\t\"ingressv1: insert ingress w/ force-ssl-redirect: true and allow-http: false\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti6cV1, sec1, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"b.example.com\", routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"b.example.com\", sec1, routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with tls version 1.2\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyMinTLS12, s1, sec1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"foo.com\", routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"foo.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes: routes(\n\t\t\t\t\t\t\t\t\trouteUpgrade(\"/\", service(s1)),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.2\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with tls version 1.3\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyMinTLS13, s1, sec1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"foo.com\", routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"foo.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes: routes(\n\t\t\t\t\t\t\t\t\trouteUpgrade(\"/\", service(s1)),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.3\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with invalid tls version\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyMinTLSInvalid, s1, sec1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"foo.com\", routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"foo.com\", sec1, routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy referencing two backends, one missing\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyMultipleBackends, s2,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert httpproxy referencing two backends\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyMultipleBackends, s1, s2,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", prefixroute(\"/\", service(s1), service(s2))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ tls min proto annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti10aV1,\n\t\t\t\tsec1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"b.example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"b.example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes: routes(\n\t\t\t\t\t\t\t\t\tprefixroute(\"/\", service(s1)),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.3\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ websocket route annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti11V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\",\n\t\t\t\t\t\t\tprefixroute(\"/\", service(s1)),\n\t\t\t\t\t\t\trouteWebsocket(\"/ws1\", service(s1)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ invalid legacy timeout annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti12aV1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ invalid timeout annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti12dV1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy w/ invalid timeoutpolicy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyTimeoutPolicyInvalidResponse,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ valid legacy timeout annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti12bV1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tTimeoutPolicy: TimeoutPolicy{\n\t\t\t\t\t\t\t\tResponseTimeout: timeout.DurationSetting(90 * time.Second),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ valid timeout annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti12eV1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tTimeoutPolicy: TimeoutPolicy{\n\t\t\t\t\t\t\t\tResponseTimeout: timeout.DurationSetting(90 * time.Second),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy w/ valid timeoutpolicy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyTimeoutPolicyValidResponse,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"bar.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tTimeoutPolicy: TimeoutPolicy{\n\t\t\t\t\t\t\t\tResponseTimeout: timeout.DurationSetting(90 * time.Second),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ legacy infinite timeout annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti12cV1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tTimeoutPolicy: TimeoutPolicy{\n\t\t\t\t\t\t\t\tResponseTimeout: timeout.DisabledSetting(),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress w/ infinite timeout annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti12fV1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tTimeoutPolicy: TimeoutPolicy{\n\t\t\t\t\t\t\t\tResponseTimeout: timeout.DisabledSetting(),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy w/ infinite timeoutpolicy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyTimeoutPolicyInfiniteResponse,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"bar.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tTimeoutPolicy: TimeoutPolicy{\n\t\t\t\t\t\t\t\tResponseTimeout: timeout.DisabledSetting(),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with missing tls delegation should not present port 80\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts10, proxyDelegatedTLSSecret,\n\t\t\t},\n\t\t\twant: listeners(), // no listeners, ir19 is invalid\n\t\t},\n\t\t\"insert httpproxy with retry annotations\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyRetryPolicyValidTimeout,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"bar.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tRetryPolicy: &RetryPolicy{\n\t\t\t\t\t\t\t\tRetryOn:       \"5xx\",\n\t\t\t\t\t\t\t\tNumRetries:    6,\n\t\t\t\t\t\t\t\tPerTryTimeout: timeout.DurationSetting(10 * time.Second),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with invalid PerTryTimeout\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyRetryPolicyInvalidTimeout,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"bar.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tRetryPolicy: &RetryPolicy{\n\t\t\t\t\t\t\t\tRetryOn:       \"5xx\",\n\t\t\t\t\t\t\t\tNumRetries:    6,\n\t\t\t\t\t\t\t\tPerTryTimeout: timeout.DefaultSetting(),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with zero retry count\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyRetryPolicyZeroRetries,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"bar.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tRetryPolicy: &RetryPolicy{\n\t\t\t\t\t\t\t\tRetryOn:       \"5xx\",\n\t\t\t\t\t\t\t\tNumRetries:    1,\n\t\t\t\t\t\t\t\tPerTryTimeout: timeout.DurationSetting(10 * time.Second),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress with timeout policy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti14V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\tRetryPolicy: &RetryPolicy{\n\t\t\t\t\t\t\t\tRetryOn:       \"gateway-error\",\n\t\t\t\t\t\t\t\tNumRetries:    6,\n\t\t\t\t\t\t\t\tPerTryTimeout: timeout.DurationSetting(10 * time.Second),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress with regex route\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti15V1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: regex(\"/[^/]+/invoices(/.*|/?)\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress with invalid regex route\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti15InvalidRegexV1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"ingressv1: insert ingress with various path match types\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tiPathMatchTypesV1,\n\t\t\t\ts1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\",\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\tPathMatchCondition: exact(\"/exact\"),\n\t\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\tPathMatchCondition: exact(\"/exact_with_regex/.*\"),\n\t\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\tPathMatchCondition: prefixSegment(\"/prefix\"),\n\t\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\t// Trailing slash is stripped.\n\t\t\t\t\t\t\t\tPathMatchCondition: prefixSegment(\"/prefix_trailing_slash\"),\n\t\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\tPathMatchCondition: prefixSegment(\"/prefix_with_regex/.*\"),\n\t\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/implementation_specific\"),\n\t\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\tPathMatchCondition: regex(\"/implementation_specific_with_regex/.*\"),\n\t\t\t\t\t\t\t\tClusters:           clustermap(s1),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress with wildcard hostnames\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts1,\n\t\t\t\ti16V1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t\tvirtualhost(\"*.example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: &PrefixMatchCondition{Prefix: \"/\"},\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tName:      \":authority\",\n\t\t\t\t\t\t\t\t\tMatchType: HeaderMatchTypeRegex,\n\t\t\t\t\t\t\t\t\tValue:     \"^[a-z0-9]([-a-z0-9]*[a-z0-9])?\\\\.example\\\\.com\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clusters(service(s1)),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress overlay\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti13aV1, i13bV1, sec13, s13a, s13b,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteUpgrade(\"/\", service(s13a)),\n\t\t\t\t\t\t\tprefixroute(\"/.well-known/acme-challenge/gVJl5NWL2owUqZekjHkt_bo3OHYC2XNDURRRgLI5JTk\", service(s13b)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"example.com\", sec13,\n\t\t\t\t\t\t\trouteUpgrade(\"/\", service(s13a)),\n\t\t\t\t\t\t\tprefixroute(\"/.well-known/acme-challenge/gVJl5NWL2owUqZekjHkt_bo3OHYC2XNDURRRgLI5JTk\", service(s13b)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: h2c service annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti3aV1, s3a,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\",\n\t\t\t\t\t\t\tprefixroute(\"/\", &Service{\n\t\t\t\t\t\t\t\tProtocol: \"h2c\",\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\tServiceName:      s3a.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: s3a.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      s3a.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: h2 service annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti3aV1, s3b,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\",\n\t\t\t\t\t\t\tprefixroute(\"/\", &Service{\n\t\t\t\t\t\t\t\tProtocol: \"h2\",\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\tServiceName:      s3b.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: s3b.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      s3b.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: tls service annotation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti3aV1, s3c,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\",\n\t\t\t\t\t\t\tprefixroute(\"/\", &Service{\n\t\t\t\t\t\t\t\tProtocol: \"tls\",\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\tServiceName:      s3c.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: s3c.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      s3c.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: insert ingress then service w/ upstream annotations\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti1V1,\n\t\t\t\ts1b,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"*\",\n\t\t\t\t\t\t\tprefixroute(\"/\", &Service{\n\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\tServiceName:      s1b.Name,\n\t\t\t\t\t\t\t\t\tServiceNamespace: s1b.Namespace,\n\t\t\t\t\t\t\t\t\tServicePort:      s1b.Spec.Ports[0],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tMaxConnections:     9000,\n\t\t\t\t\t\t\t\tMaxPendingRequests: 4096,\n\t\t\t\t\t\t\t\tMaxRequests:        404,\n\t\t\t\t\t\t\t\tMaxRetries:         7,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with two routes to the same service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyWeightsTwoRoutesDiffWeights, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/a\", &Cluster{\n\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tWeight: 90,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\trouteCluster(\"/b\", &Cluster{\n\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tWeight: 60,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with one routes to the same service with two different weights\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyWeightsOneRouteDiffWeights, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/a\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tWeight: 90,\n\t\t\t\t\t\t\t\t}, &Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tWeight: 60,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httproxy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy1, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httproxy w/o condition\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy1b, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", prefixroute(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httproxy with invalid include\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tName:      \"example-com\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\t\t\t\tPrefix: \"/finance\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tName:      \"non-existent\",\n\t\t\t\t\t\t\tNamespace: \"non-existent\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: nil, // no listener created\n\t\t},\n\t\t\"insert httproxy w/ conditions\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy1c, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/kuard\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \"x-request-id\", MatchType: \"present\"},\n\t\t\t\t\t\t\t\t{Name: \"e-tag\", Value: \"abcdef\", MatchType: \"contains\"},\n\t\t\t\t\t\t\t\t{Name: \"x-timeout\", Value: \"infinity\", MatchType: \"contains\", Invert: true},\n\t\t\t\t\t\t\t\t{Name: \"digest-auth\", Value: \"scott\", MatchType: \"exact\"},\n\t\t\t\t\t\t\t\t{Name: \"digest-password\", Value: \"tiger\", MatchType: \"exact\", Invert: true},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clusters(service(s1)),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httproxy w/ multiple routes with a Contains condition on the same header\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy2d, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \"e-tag\", Value: \"abc\", MatchType: \"contains\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clusters(service(s1)),\n\t\t\t\t\t\t}, &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \"e-tag\", Value: \"def\", MatchType: \"contains\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clusters(service(s1)),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httproxy w/ multiple routes with condition on the same header, one Contains and one NotContains\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy2e, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \"e-tag\", Value: \"abc\", MatchType: \"contains\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clusters(service(s1)),\n\t\t\t\t\t\t}, &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \"e-tag\", Value: \"abc\", MatchType: \"contains\", Invert: true},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clusters(service(s1)),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httproxy w/ included conditions\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy2a, proxy2b, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/kuard\"),\n\t\t\t\t\t\t\tHeaderMatchConditions: []HeaderMatchCondition{\n\t\t\t\t\t\t\t\t{Name: \"x-request-id\", MatchType: \"present\"},\n\t\t\t\t\t\t\t\t{Name: \"x-timeout\", Value: \"infinity\", MatchType: \"contains\", Invert: true},\n\t\t\t\t\t\t\t\t{Name: \"digest-auth\", Value: \"scott\", MatchType: \"exact\"},\n\t\t\t\t\t\t\t\t{Name: \"e-tag\", Value: \"abcdef\", MatchType: \"contains\"},\n\t\t\t\t\t\t\t\t{Name: \"digest-password\", Value: \"tiger\", MatchType: \"exact\", Invert: true},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tClusters: clusters(service(s1)),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy w/ healthcheck\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy2c, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\", &Cluster{\n\t\t\t\t\t\t\t\tUpstream: service(s1),\n\t\t\t\t\t\t\t\tHTTPHealthCheckPolicy: &HTTPHealthCheckPolicy{\n\t\t\t\t\t\t\t\t\tPath: \"/healthz\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with mirroring route\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy12, s1, s2,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\twithMirror(prefixroute(\"/\", service(s1)), service(s2)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with two mirrors\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy13, s1, s2,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert httpproxy with websocket route and prefix rewrite\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy10, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\tprefixroute(\"/\", service(s1)),\n\t\t\t\t\t\t\trouteWebsocket(\"/websocket\", service(s1)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with multiple upstreams prefix rewrite route and websockets along one path\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy10b, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\tprefixroute(\"/\", service(s1)),\n\t\t\t\t\t\t\trouteWebsocket(\"/websocket\", service(s1)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\n\t\t\"insert httpproxy with protocol and service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy110, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteProtocol(\"/\", protocol, service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\n\t\t\"insert httpproxy without tls version\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy6, s1, sec1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"foo.com\", routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tsecurevirtualhost(\"foo.com\", sec1, routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy expecting upstream verification\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tcert1, proxy17, s1a,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tProtocol: \"tls\",\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1a.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1a.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1a.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tProtocol: \"tls\",\n\t\t\t\t\t\t\t\t\tUpstreamValidation: &PeerValidationContext{\n\t\t\t\t\t\t\t\t\t\tCACertificate: secret(cert1),\n\t\t\t\t\t\t\t\t\t\tSubjectName:   \"example.com\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with h2 expecting upstream verification\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tcert1, proxy17h2, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1a.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1a.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1a.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tProtocol: \"h2\",\n\t\t\t\t\t\t\t\t\tUpstreamValidation: &PeerValidationContext{\n\t\t\t\t\t\t\t\t\t\tCACertificate: secret(cert1),\n\t\t\t\t\t\t\t\t\t\tSubjectName:   \"example.com\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy expecting upstream verification, no certificate\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy17, s1a,\n\t\t\t},\n\t\t\twant: listeners(), //no listeners, missing certificate\n\t\t},\n\t\t\"insert httpproxy expecting upstream verification, no annotation on service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tcert1, proxy17, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\tprefixroute(\"/\", service(s1)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with downstream verification\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tcert1, proxy18, s1, sec1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes: routes(\n\t\t\t\t\t\t\t\t\trouteUpgrade(\"/\", service(s1))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.2\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t\tDownstreamValidation: &PeerValidationContext{\n\t\t\t\t\t\t\t\tCACertificate: &Secret{Object: cert1},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy w/ tcpproxy in tls termination mode w/ downstream verification\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tcert1, proxy19, s1, sec1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(\n\t\t\t\t\t\t\t\t\tservice(s1),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.2\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t\tDownstreamValidation: &PeerValidationContext{\n\t\t\t\t\t\t\t\tCACertificate: &Secret{Object: cert1},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy w/ tls termination mode w/ skip cert verification\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy20, s1, sec1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes: routes(\n\t\t\t\t\t\t\t\t\trouteUpgrade(\"/\", service(s1))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.2\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t\tDownstreamValidation: &PeerValidationContext{\n\t\t\t\t\t\t\t\tSkipClientCertValidation: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy w/ tls termination mode w/ skip cert verification and a ca\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy21, s1, sec1, cert1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", routeUpgrade(\"/\", service(s1))),\n\t\t\t\t\t),\n\t\t\t\t}, &Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes: routes(\n\t\t\t\t\t\t\t\t\trouteUpgrade(\"/\", service(s1))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.2\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t\tDownstreamValidation: &PeerValidationContext{\n\t\t\t\t\t\t\t\tSkipClientCertValidation: true,\n\t\t\t\t\t\t\t\tCACertificate:            &Secret{Object: cert1},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with downstream verification, missing ca certificate\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy18, s1, sec1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert httpproxy with invalid tcpproxy\": {\n\t\t\tobjs: []interface{}{proxy37, s1},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert httpproxy with empty tcpproxy\": {\n\t\t\tobjs: []interface{}{proxy37a, s1},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert httpproxy w/ tcpproxy w/ missing include\": {\n\t\t\tobjs: []interface{}{proxy38, s1},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert httpproxy w/ tcpproxy w/ includes another root\": {\n\t\t\tobjs: []interface{}{proxy38, proxy39, s1},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"www.example.com\", // this is proxy39, not proxy38\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(\n\t\t\t\t\t\t\t\t\tservice(s1),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy w/tcpproxy w/include\": {\n\t\t\tobjs: []interface{}{proxy39broot, proxy39bchild, s1},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"www.example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(\n\t\t\t\t\t\t\t\t\tservice(s1),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// Issue #2218\n\t\t\"insert httpproxy w/tcpproxy w/include plural\": {\n\t\t\tobjs: []interface{}{proxy39brootplural, proxy39bchild, s1},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"www.example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(\n\t\t\t\t\t\t\t\t\tservice(s1),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy w/ tcpproxy w/ includes valid child\": {\n\t\t\tobjs: []interface{}{proxy38, proxy40, s1},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"passthrough.example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(\n\t\t\t\t\t\t\t\t\tservice(s1),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httproxy w/ route w/ no services\": {\n\t\t\tobjs: []interface{}{proxy41, s1},\n\t\t\twant: listeners(), // expect empty, route is invalid so vhost is invalid\n\t\t},\n\t\t\"insert httpproxy with pathPrefix include\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy100, proxy100a, s1, s4,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trouteCluster(\"/blog\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s4.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s4.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s4.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with pathPrefix include, child adds to pathPrefix\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy100, proxy100b, s1, s4,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/blog/infotech\"),\n\t\t\t\t\t\t\t\tClusters: []*Cluster{{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s4.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s4.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s4.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with pathPrefix include, child adds to pathPrefix, delegates again\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy100, proxy100c, proxy100d, s1, s4, s11,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/blog/infotech\"),\n\t\t\t\t\t\t\t\tClusters: []*Cluster{{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s4.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s4.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s4.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trouteCluster(\"/blog\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s4.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s4.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s4.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t&Route{\n\t\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/blog/it/foo\"),\n\t\t\t\t\t\t\t\tClusters: []*Cluster{{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s11.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s11.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s11.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with no namespace for include\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy101, proxy101a, s1, s2,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trouteCluster(\"/kuarder\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s2.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s2.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s2.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with include, no prefix condition on included proxy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy104, proxy104a, s1, s2,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trouteCluster(\"/kuarder\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s2.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s2.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s2.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with include, / on included proxy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy105, proxy105a, s1, s2,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trouteCluster(\"/kuarder/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s2.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s2.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s2.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with include, full prefix on included proxy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy107, proxy107a, s1, s2,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trouteCluster(\"/kuarder/withavengeance\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s2.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s2.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s2.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with include ending with /, / on included proxy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy106, proxy106a, s1, s2,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s1.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s1.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s1.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trouteCluster(\"/kuarder/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s2.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s2.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s2.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with multiple prefix conditions on route\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy102, s1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert httpproxy with multiple prefix conditions on include\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy103, proxy103a, s1,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert httpproxy duplicate conditions on include\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy108, proxy108a, proxy108b, s1, s12, s13,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert proxy with tcp forward without TLS termination w/ passthrough\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy1a, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"kuard.example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(\n\t\t\t\t\t\t\t\t\tservice(s1),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// issue 1952\n\t\t\"insert proxy with tcp forward without TLS termination w/ passthrough and 301 upgrade of port 80\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy1d, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"kuard.example.com\",\n\t\t\t\t\t\t\trouteUpgrade(\"/\", service(s1)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"kuard.example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(\n\t\t\t\t\t\t\t\t\tservice(s1),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert proxy with tcp forward without TLS termination w/ passthrough without 301 upgrade of port 80\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy1e, s10,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"kuard.example.com\",\n\t\t\t\t\t\t\trouteCluster(\"/\",\n\t\t\t\t\t\t\t\t&Cluster{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s10.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s10.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s10.Spec.Ports[1],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"kuard.example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(\n\t\t\t\t\t\t\t\t\tservice(s10),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"\", // tls passthrough does not specify a TLS version; that's the domain of the backend\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert httpproxy with route-level header manipulation\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy109, s1,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\",\n\t\t\t\t\t\t\trouteHeaders(\"/\", map[string]string{\n\t\t\t\t\t\t\t\t\"In-Foo\": \"bar\",\n\t\t\t\t\t\t\t}, []string{\"In-Baz\"}, map[string]string{\n\t\t\t\t\t\t\t\t\"Out-Foo\": \"bar\",\n\t\t\t\t\t\t\t}, []string{\"Out-Baz\"}, service(s1)),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\n\t\t// issue 1399\n\t\t\"service shared across ingress and httpproxy tcpproxy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\t&networking_v1.Ingress{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: networking_v1.IngressSpec{\n\t\t\t\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\t\t\t\tHosts:      []string{\"example.com\"},\n\t\t\t\t\t\t\tSecretName: s1.Name,\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\t\t\t\tHost:             \"example.com\",\n\t\t\t\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(s9.Name, intstr.FromInt(80))),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName: sec1.Name,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: s9.Name,\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", prefixroute(\"/\", service(s9))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.2\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(s9)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// issue 1954\n\t\t\"httpproxy tcpproxy + permitinsecure\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName: sec1.Name,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tPermitInsecure: true,\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: s9.Name,\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: s9.Name,\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t// not upgraded because the route is permitInsecure: true\n\t\t\t\t\t\tvirtualhost(\"example.com\", prefixroute(\"/\", service(s9))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.2\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(s9)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t// issue 1954\n\t\t\"httpproxy tcpproxy + tlspassthrough + permitinsecure\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ts9,\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tPassthrough: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tPermitInsecure: true,\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: s9.Name,\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: s9.Name,\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t// not upgraded because the route is permitInsecure: true\n\t\t\t\t\t\tvirtualhost(\"example.com\", prefixroute(\"/\", service(s9))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"\",\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: clusters(service(s9)),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"ingressv1: Ingress then HTTPProxy with identical details, except referencing s2a\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ti17V1,\n\t\t\t\tproxy1f,\n\t\t\t\ts1,\n\t\t\t\ts2a,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", prefixroute(\"/\", service(s2a))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert ingress with externalName service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tingressExternalNameService,\n\t\t\t\ts14,\n\t\t\t},\n\t\t\tenableExternalNameSvc: true,\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters: []*Cluster{{\n\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\tExternalName: \"externalservice.io\",\n\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\tServiceName:      s14.Name,\n\t\t\t\t\t\t\t\t\t\tServiceNamespace: s14.Namespace,\n\t\t\t\t\t\t\t\t\t\tServicePort:      s14.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert ingress with externalName service, but externalName services disabled\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tingressExternalNameService,\n\t\t\t\ts14,\n\t\t\t},\n\t\t\tenableExternalNameSvc: false,\n\t\t\twant:                  listeners(),\n\t\t},\n\t\t\"insert proxy with externalName service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyExternalNameService,\n\t\t\t\ts14,\n\t\t\t},\n\t\t\tenableExternalNameSvc: true,\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters: []*Cluster{{\n\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\tExternalName: \"externalservice.io\",\n\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\tServiceName:      s14.Name,\n\t\t\t\t\t\t\t\t\t\tServiceNamespace: s14.Namespace,\n\t\t\t\t\t\t\t\t\t\tServicePort:      s14.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tSNI: \"externalservice.io\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert tcp proxy with externalName service\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\ttcpProxyExternalNameService,\n\t\t\t\ts14,\n\t\t\t\tsec1,\n\t\t\t},\n\t\t\tenableExternalNameSvc: true,\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTCPProxy: &TCPProxy{\n\t\t\t\t\t\t\t\tClusters: []*Cluster{{\n\t\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\t\tExternalName: \"externalservice.io\",\n\t\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\t\tServiceName:      s14.Name,\n\t\t\t\t\t\t\t\t\t\t\tServiceNamespace: s14.Namespace,\n\t\t\t\t\t\t\t\t\t\t\tServicePort:      s14.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tProtocol: \"tls\",\n\t\t\t\t\t\t\t\t\tSNI:      \"externalservice.io\",\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion: \"1.2\",\n\t\t\t\t\t\t\tSecret:        secret(sec1),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert proxy with replace header policy - route - host header\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyReplaceHostHeaderRoute,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters: []*Cluster{{\n\t\t\t\t\t\t\t\tUpstream: service(s9),\n\t\t\t\t\t\t\t\tSNI:      \"bar.com\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tRequestHeadersPolicy: &HeadersPolicy{\n\t\t\t\t\t\t\t\tHostRewrite: \"bar.com\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert proxy with replace header policy - route - host header - externalName\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyReplaceHostHeaderRoute,\n\t\t\t\ts14,\n\t\t\t},\n\t\t\tenableExternalNameSvc: true,\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters: []*Cluster{{\n\t\t\t\t\t\t\t\tUpstream: &Service{\n\t\t\t\t\t\t\t\t\tExternalName: \"externalservice.io\",\n\t\t\t\t\t\t\t\t\tWeighted: WeightedService{\n\t\t\t\t\t\t\t\t\t\tWeight:           1,\n\t\t\t\t\t\t\t\t\t\tServiceName:      s14.Name,\n\t\t\t\t\t\t\t\t\t\tServiceNamespace: s14.Namespace,\n\t\t\t\t\t\t\t\t\t\tServicePort:      s14.Spec.Ports[0],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tSNI: \"bar.com\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tRequestHeadersPolicy: &HeadersPolicy{\n\t\t\t\t\t\t\t\tHostRewrite: \"bar.com\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert proxy with replace header policy - service - host header\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyReplaceHostHeaderService,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert proxy with replace header policy - service - host header - externalName\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyReplaceHostHeaderService,\n\t\t\t\ts14,\n\t\t\t},\n\t\t\tenableExternalNameSvc: true,\n\t\t\twant:                  listeners(),\n\t\t},\n\t\t\"insert proxy with response header policy - route - host header\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy111,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert proxy with response header policy - service - host header\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxy112,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"insert proxy with replace header policy - host header multiple\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyReplaceHostHeaderMultiple,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters: []*Cluster{{\n\t\t\t\t\t\t\t\tUpstream: service(s9),\n\t\t\t\t\t\t\t\tSNI:      \"bar.com\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tRequestHeadersPolicy: &HeadersPolicy{\n\t\t\t\t\t\t\t\tHostRewrite: \"bar.com\",\n\t\t\t\t\t\t\t\tSet: map[string]string{\n\t\t\t\t\t\t\t\t\t\"X-Header\": \"bar.com\",\n\t\t\t\t\t\t\t\t\t\"Y-Header\": \"zed.com\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert proxy with request headers policy - not host header\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyReplaceNonHostHeader,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s9),\n\t\t\t\t\t\t\tRequestHeadersPolicy: &HeadersPolicy{\n\t\t\t\t\t\t\t\tSet: map[string]string{\n\t\t\t\t\t\t\t\t\t\"X-Header\": \"bar.com\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert proxy with request headers policy - empty value\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyReplaceHeaderEmptyValue,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters:           clustermap(s9),\n\t\t\t\t\t\t\tRequestHeadersPolicy: &HeadersPolicy{\n\t\t\t\t\t\t\t\tSet: map[string]string{\n\t\t\t\t\t\t\t\t\t\"X-Header\": \"\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert proxy with cookie load balancing strategy\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyCookieLoadBalancer,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters: []*Cluster{\n\t\t\t\t\t\t\t\t{Upstream: service(s9), LoadBalancerPolicy: \"Cookie\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRequestHashPolicies: []RequestHashPolicy{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tCookieHashOptions: &CookieHashOptions{\n\t\t\t\t\t\t\t\t\t\tCookieName: \"X-Contour-Session-Affinity\",\n\t\t\t\t\t\t\t\t\t\tTTL:        time.Duration(0),\n\t\t\t\t\t\t\t\t\t\tPath:       \"/\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert proxy with load balancer request header hash policies\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyLoadBalancerHashPolicyHeader,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters: []*Cluster{\n\t\t\t\t\t\t\t\t{Upstream: service(s9), LoadBalancerPolicy: \"RequestHash\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRequestHashPolicies: []RequestHashPolicy{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tTerminal: true,\n\t\t\t\t\t\t\t\t\tHeaderHashOptions: &HeaderHashOptions{\n\t\t\t\t\t\t\t\t\t\tHeaderName: \"X-Some-Header\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tHeaderHashOptions: &HeaderHashOptions{\n\t\t\t\t\t\t\t\t\t\tHeaderName: \"X-Some-Other-Header\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"insert proxy with all invalid request header hash policies\": {\n\t\t\tobjs: []interface{}{\n\t\t\t\tproxyLoadBalancerHashPolicyHeaderAllInvalid,\n\t\t\t\ts9,\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", &Route{\n\t\t\t\t\t\t\tPathMatchCondition: prefixString(\"/\"),\n\t\t\t\t\t\t\tClusters: []*Cluster{\n\t\t\t\t\t\t\t\t{Upstream: service(s9), LoadBalancerPolicy: \"RoundRobin\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"httpproxy with fallback certificate enabled\": {\n\t\t\tfallbackCertificateName:      \"fallbacksecret\",\n\t\t\tfallbackCertificateNamespace: \"default\",\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\tfallbackCertificateSecret,\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName:                sec1.Name,\n\t\t\t\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion:       \"1.2\",\n\t\t\t\t\t\t\tSecret:              secret(sec1),\n\t\t\t\t\t\t\tFallbackCertificate: secret(fallbackCertificateSecret),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"httpproxy with fallback certificate enabled - cert delegation not configured\": {\n\t\t\tfallbackCertificateName:      \"fallbacksecret\",\n\t\t\tfallbackCertificateNamespace: \"root\",\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec4,\n\t\t\t\ts9,\n\t\t\t\tfallbackCertificateSecret,\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName:                sec1.Name,\n\t\t\t\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(),\n\t\t},\n\t\t\"httpproxy with fallback certificate enabled - cert delegation configured all namespaces\": {\n\t\t\tfallbackCertificateName:      \"fallbacksecret\",\n\t\t\tfallbackCertificateNamespace: \"root\",\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\tfallbackCertificateSecretRootNamespace,\n\t\t\t\t&contour_api_v1.TLSCertificateDelegation{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"fallbackcertdelegation\",\n\t\t\t\t\t\tNamespace: \"root\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.TLSCertificateDelegationSpec{\n\t\t\t\t\t\tDelegations: []contour_api_v1.CertificateDelegation{{\n\t\t\t\t\t\t\tSecretName:       \"fallbacksecret\",\n\t\t\t\t\t\t\tTargetNamespaces: []string{\"*\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName:                sec1.Name,\n\t\t\t\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion:       \"1.2\",\n\t\t\t\t\t\t\tSecret:              secret(sec1),\n\t\t\t\t\t\t\tFallbackCertificate: secret(fallbackCertificateSecretRootNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"httpproxy with fallback certificate enabled - cert delegation configured single namespaces\": {\n\t\t\tfallbackCertificateName:      \"fallbacksecret\",\n\t\t\tfallbackCertificateNamespace: \"root\",\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\tfallbackCertificateSecretRootNamespace,\n\t\t\t\t&contour_api_v1.TLSCertificateDelegation{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"fallbackcertdelegation\",\n\t\t\t\t\t\tNamespace: \"root\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.TLSCertificateDelegationSpec{\n\t\t\t\t\t\tDelegations: []contour_api_v1.CertificateDelegation{{\n\t\t\t\t\t\t\tSecretName:       \"fallbacksecret\",\n\t\t\t\t\t\t\tTargetNamespaces: []string{\"default\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName:                sec1.Name,\n\t\t\t\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion:       \"1.2\",\n\t\t\t\t\t\t\tSecret:              secret(sec1),\n\t\t\t\t\t\t\tFallbackCertificate: secret(fallbackCertificateSecretRootNamespace),\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"httpproxy with fallback certificate enabled - no tls secret\": {\n\t\t\tfallbackCertificateName:      \"fallbacksecret\",\n\t\t\tfallbackCertificateNamespace: \"default\",\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\tfallbackCertificateSecret,\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t\"httpproxy with fallback certificate enabled along with ClientValidation\": {\n\t\t\tfallbackCertificateName:      \"fallbacksecret\",\n\t\t\tfallbackCertificateNamespace: \"default\",\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\tfallbackCertificateSecret,\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t\t\t\t\tClientValidation: &contour_api_v1.DownstreamValidation{\n\t\t\t\t\t\t\t\t\tCACertificate: cert1.Name,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t\"httpproxy with fallback certificate enabled - another not enabled\": {\n\t\t\tfallbackCertificateName:      \"fallbacksecret\",\n\t\t\tfallbackCertificateNamespace: \"default\",\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\tfallbackCertificateSecret,\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName:                sec1.Name,\n\t\t\t\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx-disabled\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"projectcontour.io\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName:                sec1.Name,\n\t\t\t\t\t\t\t\tEnableFallbackCertificate: false,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t\tvirtualhost(\"projectcontour.io\", routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion:       \"1.2\",\n\t\t\t\t\t\t\tSecret:              secret(sec1),\n\t\t\t\t\t\t\tFallbackCertificate: secret(fallbackCertificateSecret),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"projectcontour.io\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion:       \"1.2\",\n\t\t\t\t\t\t\tSecret:              secret(sec1),\n\t\t\t\t\t\t\tFallbackCertificate: nil,\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"httpproxy with fallback certificate enabled - bad fallback cert\": {\n\t\t\tfallbackCertificateName:      \"fallbacksecret\",\n\t\t\tfallbackCertificateNamespace: \"badnamespaces\",\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\tfallbackCertificateSecret,\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName: sec1.Name,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion:       \"1.2\",\n\t\t\t\t\t\t\tSecret:              secret(sec1),\n\t\t\t\t\t\t\tFallbackCertificate: nil,\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t\t\"httpproxy with fallback certificate disabled - fallback cert specified\": {\n\t\t\tfallbackCertificateName:      \"fallbacksecret\",\n\t\t\tfallbackCertificateNamespace: \"default\",\n\t\t\tobjs: []interface{}{\n\t\t\t\tsec1,\n\t\t\t\ts9,\n\t\t\t\tfallbackCertificateSecret,\n\t\t\t\t&contour_api_v1.HTTPProxy{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"nginx\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\t\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\t\t\t\tFqdn: \"example.com\",\n\t\t\t\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\t\t\t\tSecretName:                sec1.Name,\n\t\t\t\t\t\t\t\tEnableFallbackCertificate: false,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\t\t\t\tName: \"nginx\",\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: listeners(\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 80,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\tvirtualhost(\"example.com\", routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\t&Listener{\n\t\t\t\t\tPort: 443,\n\t\t\t\t\tVirtualHosts: virtualhosts(\n\t\t\t\t\t\t&SecureVirtualHost{\n\t\t\t\t\t\t\tVirtualHost: VirtualHost{\n\t\t\t\t\t\t\t\tName:         \"example.com\",\n\t\t\t\t\t\t\t\tListenerName: \"ingress_https\",\n\t\t\t\t\t\t\t\troutes:       routes(routeUpgrade(\"/\", service(s9))),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMinTLSVersion:       \"1.2\",\n\t\t\t\t\t\t\tSecret:              secret(sec1),\n\t\t\t\t\t\t\tFallbackCertificate: nil,\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t},\n\t}\n\n\tfor name, tc := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tbuilder := Builder{\n\t\t\t\tSource: KubernetesCache{\n\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t},\n\t\t\t\tProcessors: []Processor{\n\t\t\t\t\t&IngressProcessor{\n\t\t\t\t\t\tFieldLogger:               fixture.NewTestLogger(t),\n\t\t\t\t\t\tEnableExternalNameService: tc.enableExternalNameSvc,\n\t\t\t\t\t},\n\t\t\t\t\t&HTTPProxyProcessor{\n\t\t\t\t\t\tEnableExternalNameService: tc.enableExternalNameSvc,\n\t\t\t\t\t\tDisablePermitInsecure:     tc.disablePermitInsecure,\n\t\t\t\t\t\tFallbackCertificate: &types.NamespacedName{\n\t\t\t\t\t\t\tName:      tc.fallbackCertificateName,\n\t\t\t\t\t\t\tNamespace: tc.fallbackCertificateNamespace,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t&ListenerProcessor{},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, o := range tc.objs {\n\t\t\t\tbuilder.Source.Insert(o)\n\t\t\t}\n\t\t\tdag := builder.Build()\n\n\t\t\tgot := make(map[int]*Listener)\n\t\t\tdag.Visit(listenerMap(got).Visit)\n\n\t\t\twant := make(map[int]*Listener)\n\t\t\tfor _, v := range tc.want {\n\t\t\t\tif l, ok := v.(*Listener); ok {\n\t\t\t\t\twant[l.Port] = l\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert.Equal(t, want, got)\n\t\t})\n\t}\n}\n\ntype listenerMap map[int]*Listener\n\nfunc (lm listenerMap) Visit(v Vertex) {\n\tif l, ok := v.(*Listener); ok {\n\t\tlm[l.Port] = l\n\t}\n}\n\nfunc backendv1(name string, port intstr.IntOrString) *networking_v1.IngressBackend {\n\n\tvar v1port networking_v1.ServiceBackendPort\n\n\tswitch port.Type {\n\tcase intstr.Int:\n\t\tv1port = networking_v1.ServiceBackendPort{\n\t\t\tNumber: port.IntVal,\n\t\t}\n\tcase intstr.String:\n\t\tv1port = networking_v1.ServiceBackendPort{\n\t\t\tName: port.StrVal,\n\t\t}\n\t}\n\n\treturn &networking_v1.IngressBackend{\n\t\tService: &networking_v1.IngressServiceBackend{\n\t\t\tName: name,\n\t\t\tPort: v1port,\n\t\t},\n\t}\n}\n\nfunc ingressrulev1value(backend *networking_v1.IngressBackend) networking_v1.IngressRuleValue {\n\treturn networking_v1.IngressRuleValue{\n\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\tBackend: *backend,\n\t\t\t}},\n\t\t},\n\t}\n}\n\nfunc TestDAGRootNamespaces(t *testing.T) {\n\tproxy1 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"allowed1\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxy2 is like proxy1, but in a different namespace\n\tproxy2 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"allowed2\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example2.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\ts2 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"allowed1\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:     \"http\",\n\t\t\t\tProtocol: \"TCP\",\n\t\t\t\tPort:     8080,\n\t\t\t}},\n\t\t},\n\t}\n\n\ts3 := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"allowed2\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:     \"http\",\n\t\t\t\tProtocol: \"TCP\",\n\t\t\t\tPort:     8080,\n\t\t\t}},\n\t\t},\n\t}\n\n\ttests := map[string]struct {\n\t\trootNamespaces []string\n\t\tobjs           []interface{}\n\t\twant           int\n\t}{\n\t\t\"nil root httpproxy namespaces\": {\n\t\t\tobjs: []interface{}{proxy1, s2},\n\t\t\twant: 1,\n\t\t},\n\t\t\"empty root httpproxy namespaces\": {\n\t\t\tobjs: []interface{}{proxy1, s2},\n\t\t\twant: 1,\n\t\t},\n\t\t\"single root namespace with root httpproxy\": {\n\t\t\trootNamespaces: []string{\"allowed1\"},\n\t\t\tobjs:           []interface{}{proxy1, s2},\n\t\t\twant:           1,\n\t\t},\n\t\t\"multiple root namespaces, one with a root httpproxy\": {\n\t\t\trootNamespaces: []string{\"foo\", \"allowed1\", \"bar\"},\n\t\t\tobjs:           []interface{}{proxy1, s2},\n\t\t\twant:           1,\n\t\t},\n\t\t\"multiple root namespaces, each with a root httpproxy\": {\n\t\t\trootNamespaces: []string{\"foo\", \"allowed1\", \"allowed2\"},\n\t\t\tobjs:           []interface{}{proxy1, proxy2, s2, s3},\n\t\t\twant:           2,\n\t\t},\n\t\t\"root httpproxy defined outside single root namespaces\": {\n\t\t\trootNamespaces: []string{\"foo\"},\n\t\t\tobjs:           []interface{}{proxy1},\n\t\t\twant:           0,\n\t\t},\n\t\t\"root httpproxy defined outside multiple root namespaces\": {\n\t\t\trootNamespaces: []string{\"foo\", \"bar\"},\n\t\t\tobjs:           []interface{}{proxy1},\n\t\t\twant:           0,\n\t\t},\n\t\t\"two root httpproxy, one inside root namespace, one outside\": {\n\t\t\trootNamespaces: []string{\"foo\", \"allowed2\"},\n\t\t\tobjs:           []interface{}{proxy1, proxy2, s3},\n\t\t\twant:           1,\n\t\t},\n\t}\n\n\tfor name, tc := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tbuilder := Builder{\n\t\t\t\tSource: KubernetesCache{\n\t\t\t\t\tRootNamespaces: tc.rootNamespaces,\n\t\t\t\t\tFieldLogger:    fixture.NewTestLogger(t),\n\t\t\t\t},\n\t\t\t\tProcessors: []Processor{\n\t\t\t\t\t&IngressProcessor{\n\t\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t\t},\n\t\t\t\t\t&HTTPProxyProcessor{},\n\t\t\t\t\t&ListenerProcessor{},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, o := range tc.objs {\n\t\t\t\tbuilder.Source.Insert(o)\n\t\t\t}\n\t\t\tdag := builder.Build()\n\n\t\t\tvar count int\n\t\t\tdag.Visit(func(v Vertex) {\n\t\t\t\tv.Visit(func(v Vertex) {\n\t\t\t\t\tif _, ok := v.(*VirtualHost); ok {\n\t\t\t\t\t\tcount++\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\n\t\t\tif tc.want != count {\n\t\t\t\tt.Errorf(\"wanted %d vertices, but got %d\", tc.want, count)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestHttpPaths(t *testing.T) {\n\ttests := map[string]struct {\n\t\trule networking_v1.IngressRule\n\t\twant []networking_v1.HTTPIngressPath\n\t}{\n\t\t\"zero value\": {\n\t\t\trule: networking_v1.IngressRule{},\n\t\t\twant: nil,\n\t\t},\n\t\t\"empty paths\": {\n\t\t\trule: networking_v1.IngressRule{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t\"several paths\": {\n\t\t\trule: networking_v1.IngressRule{\n\t\t\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\tPath:    \"/kuarder\",\n\t\t\t\t\t\t\tBackend: *backendv1(\"kuarder\", intstr.FromInt(8080)),\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []networking_v1.HTTPIngressPath{{\n\t\t\t\tBackend: *backendv1(\"kuard\", intstr.FromString(\"http\")),\n\t\t\t}, {\n\t\t\t\tPath:    \"/kuarder\",\n\t\t\t\tBackend: *backendv1(\"kuarder\", intstr.FromInt(8080)),\n\t\t\t}},\n\t\t},\n\t}\n\n\tfor name, tc := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tgot := httppaths(tc.rule)\n\t\t\tassert.Equal(t, tc.want, got)\n\t\t})\n\t}\n}\n\nfunc TestDetermineSNI(t *testing.T) {\n\ttests := map[string]struct {\n\t\trouteRequestHeaders   *HeadersPolicy\n\t\tclusterRequestHeaders *HeadersPolicy\n\t\tservice               *Service\n\t\twant                  string\n\t}{\n\t\t\"default SNI\": {\n\t\t\trouteRequestHeaders:   nil,\n\t\t\tclusterRequestHeaders: nil,\n\t\t\tservice:               &Service{},\n\t\t\twant:                  \"\",\n\t\t},\n\t\t\"route request headers set\": {\n\t\t\trouteRequestHeaders: &HeadersPolicy{\n\t\t\t\tHostRewrite: \"containersteve.com\",\n\t\t\t},\n\t\t\tclusterRequestHeaders: nil,\n\t\t\tservice:               &Service{},\n\t\t\twant:                  \"containersteve.com\",\n\t\t},\n\t\t\"service request headers set\": {\n\t\t\trouteRequestHeaders: nil,\n\t\t\tclusterRequestHeaders: &HeadersPolicy{\n\t\t\t\tHostRewrite: \"containersteve.com\",\n\t\t\t},\n\t\t\tservice: &Service{},\n\t\t\twant:    \"containersteve.com\",\n\t\t},\n\t\t\"service request headers set overrides route\": {\n\t\t\trouteRequestHeaders: &HeadersPolicy{\n\t\t\t\tHostRewrite: \"incorrect.com\",\n\t\t\t},\n\t\t\tclusterRequestHeaders: &HeadersPolicy{\n\t\t\t\tHostRewrite: \"containersteve.com\",\n\t\t\t},\n\t\t\tservice: &Service{},\n\t\t\twant:    \"containersteve.com\",\n\t\t},\n\t\t\"route request headers override externalName\": {\n\t\t\trouteRequestHeaders: &HeadersPolicy{\n\t\t\t\tHostRewrite: \"containersteve.com\",\n\t\t\t},\n\t\t\tclusterRequestHeaders: nil,\n\t\t\tservice: &Service{\n\t\t\t\tExternalName: \"externalname.com\",\n\t\t\t},\n\t\t\twant: \"containersteve.com\",\n\t\t},\n\t\t\"service request headers override externalName\": {\n\t\t\trouteRequestHeaders: nil,\n\t\t\tclusterRequestHeaders: &HeadersPolicy{\n\t\t\t\tHostRewrite: \"containersteve.com\",\n\t\t\t},\n\t\t\tservice: &Service{\n\t\t\t\tExternalName: \"externalname.com\",\n\t\t\t},\n\t\t\twant: \"containersteve.com\",\n\t\t},\n\t\t\"only externalName set\": {\n\t\t\trouteRequestHeaders:   nil,\n\t\t\tclusterRequestHeaders: nil,\n\t\t\tservice: &Service{\n\t\t\t\tExternalName: \"externalname.com\",\n\t\t\t},\n\t\t\twant: \"externalname.com\",\n\t\t},\n\t}\n\n\tfor name, tc := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tgot := determineSNI(tc.routeRequestHeaders, tc.clusterRequestHeaders, tc.service)\n\t\t\tassert.Equal(t, tc.want, got)\n\t\t})\n\t}\n}\n\nfunc TestEnforceRoute(t *testing.T) {\n\ttests := map[string]struct {\n\t\ttlsEnabled     bool\n\t\tpermitInsecure bool\n\t\twant           bool\n\t}{\n\t\t\"tls not enabled\": {\n\t\t\ttlsEnabled:     false,\n\t\t\tpermitInsecure: false,\n\t\t\twant:           false,\n\t\t},\n\t\t\"tls enabled\": {\n\t\t\ttlsEnabled:     true,\n\t\t\tpermitInsecure: false,\n\t\t\twant:           true,\n\t\t},\n\t\t\"tls enabled but insecure requested\": {\n\t\t\ttlsEnabled:     true,\n\t\t\tpermitInsecure: true,\n\t\t\twant:           false,\n\t\t},\n\t\t\"tls not enabled but insecure requested\": {\n\t\t\ttlsEnabled:     false,\n\t\t\tpermitInsecure: true,\n\t\t\twant:           false,\n\t\t},\n\t}\n\n\tfor name, tc := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tgot := routeEnforceTLS(tc.tlsEnabled, tc.permitInsecure)\n\t\t\tassert.Equal(t, tc.want, got)\n\t\t})\n\t}\n}\n\nfunc TestValidateHeaderAlteration(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tin      *contour_api_v1.HeadersPolicy\n\t\tdyn     map[string]string\n\t\tdhp     *HeadersPolicy\n\t\twant    *HeadersPolicy\n\t\twantErr error\n\t}{{\n\t\tname: \"empty is fine\",\n\t}, {\n\t\tname: \"set two, remove one\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"K-Foo\",\n\t\t\t\tValue: \"bar\",\n\t\t\t}, {\n\t\t\t\tName:  \"k-baz\", // This gets canonicalized\n\t\t\t\tValue: \"blah\",\n\t\t\t}},\n\t\t\tRemove: []string{\"K-Nada\"},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp: nil,\n\t\twant: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"K-Foo\": \"bar\",\n\t\t\t\t\"K-Baz\": \"blah\",\n\t\t\t},\n\t\t\tRemove: []string{\"K-Nada\"},\n\t\t},\n\t}, {\n\t\tname: \"duplicate set\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"K-Foo\",\n\t\t\t\tValue: \"bar\",\n\t\t\t}, {\n\t\t\t\tName:  \"k-foo\", // This gets canonicalized\n\t\t\t\tValue: \"blah\",\n\t\t\t}},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp:     nil,\n\t\twantErr: errors.New(`duplicate header addition: \"K-Foo\"`),\n\t}, {\n\t\tname: \"duplicate remove\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tRemove: []string{\"K-Foo\", \"k-foo\"},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp:     nil,\n\t\twantErr: errors.New(`duplicate header removal: \"K-Foo\"`),\n\t}, {\n\t\tname: \"invalid set header\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"  K-Foo\",\n\t\t\t\tValue: \"bar\",\n\t\t\t}},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp:     nil,\n\t\twantErr: errors.New(`invalid set header \"  K-Foo\": [a valid HTTP header must consist of alphanumeric characters or '-' (e.g. 'X-Header-Name', regex used for validation is '[-A-Za-z0-9]+')]`),\n\t}, {\n\t\tname: \"invalid set default header\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"  K-Foo\": \"bar\",\n\t\t\t},\n\t\t},\n\t\twantErr: errors.New(`invalid set header \"  K-Foo\": [a valid HTTP header must consist of alphanumeric characters or '-' (e.g. 'X-Header-Name', regex used for validation is '[-A-Za-z0-9]+')]`),\n\t}, {\n\t\tname: \"invalid remove header\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tRemove: []string{\"  K-Foo\"},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp:     nil,\n\t\twantErr: errors.New(`invalid remove header \"  K-Foo\": [a valid HTTP header must consist of alphanumeric characters or '-' (e.g. 'X-Header-Name', regex used for validation is '[-A-Za-z0-9]+')]`),\n\t}, {\n\t\tname: \"invalid remove default header\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tRemove: []string{\"  K-Foo\"},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp: &HeadersPolicy{\n\t\t\tRemove: []string{\"  K-Foo\"},\n\t\t},\n\t\twantErr: errors.New(`invalid remove header \"  K-Foo\": [a valid HTTP header must consist of alphanumeric characters or '-' (e.g. 'X-Header-Name', regex used for validation is '[-A-Za-z0-9]+')]`),\n\t}, {\n\t\tname: \"invalid set header (special headers)\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"Host\",\n\t\t\t\tValue: \"bar\",\n\t\t\t}},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp:     nil,\n\t\twantErr: errors.New(`rewriting \"Host\" header is not supported`),\n\t}, {\n\t\tname: \"invalid set default header (special headers)\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"K-Foo\",\n\t\t\t\tValue: \"ook?\",\n\t\t\t}},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"Host\": \"bar\",\n\t\t\t},\n\t\t},\n\t\twantErr: errors.New(`rewriting \"Host\" header is not supported`),\n\t}, {\n\t\tname: \"percents are escaped\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"K-Foo\",\n\t\t\t\tValue: \"100%\",\n\t\t\t}, {\n\t\t\t\tName:  \"Lot-Of-Percents\",\n\t\t\t\tValue: \"%%%%%\",\n\t\t\t}, {\n\t\t\t\tName:  \"k-baz\",                      // This gets canonicalized\n\t\t\t\tValue: \"%DOWNSTREAM_LOCAL_ADDRESS%\", // This is a known Envoy dynamic header\n\t\t\t}},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp: nil,\n\t\twant: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"K-Foo\":           \"100%%\",\n\t\t\t\t\"K-Baz\":           \"%DOWNSTREAM_LOCAL_ADDRESS%\",\n\t\t\t\t\"Lot-Of-Percents\": \"%%%%%%%%%%\",\n\t\t\t},\n\t\t},\n\t}, {\n\t\tname: \"dynamic service headers\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"l5d-dst-override\",\n\t\t\t\tValue: \"%CONTOUR_SERVICE_NAME%.%CONTOUR_NAMESPACE%.svc.cluster.local:%CONTOUR_SERVICE_PORT%\",\n\t\t\t}},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\":    \"myns\",\n\t\t\t\"CONTOUR_SERVICE_NAME\": \"myservice\",\n\t\t\t\"CONTOUR_SERVICE_PORT\": \"80\",\n\t\t},\n\t\tdhp: nil,\n\t\twant: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"L5d-Dst-Override\": \"myservice.myns.svc.cluster.local:80\",\n\t\t\t},\n\t\t},\n\t}, {\n\t\tname: \"dynamic service headers without service name and port\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"l5d-dst-override\",\n\t\t\t\tValue: \"%CONTOUR_SERVICE_NAME%.%CONTOUR_NAMESPACE%.svc.cluster.local:%CONTOUR_SERVICE_PORT%\",\n\t\t\t}},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp: nil,\n\t\twant: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"L5d-Dst-Override\": \"%%CONTOUR_SERVICE_NAME%%.myns.svc.cluster.local:%%CONTOUR_SERVICE_PORT%%\",\n\t\t\t},\n\t\t},\n\t}, {\n\t\tname: \"default headers are combined with given headers and escaped\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"K-Foo\",\n\t\t\t\tValue: \"100%\",\n\t\t\t}},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"k-baz\":           \"%DOWNSTREAM_LOCAL_ADDRESS%\", // This gets canonicalized\n\t\t\t\t\"Lot-Of-Percents\": \"%%%%%\",\n\t\t\t},\n\t\t},\n\t\twant: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"K-Foo\":           \"100%%\",\n\t\t\t\t\"K-Baz\":           \"%DOWNSTREAM_LOCAL_ADDRESS%\",\n\t\t\t\t\"Lot-Of-Percents\": \"%%%%%%%%%%\",\n\t\t\t},\n\t\t},\n\t}, {\n\t\tname: \"default headers do not replace given headers\",\n\t\tin: &contour_api_v1.HeadersPolicy{\n\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\tName:  \"K-Foo\",\n\t\t\t\tValue: \"100%\",\n\t\t\t}},\n\t\t},\n\t\tdyn: map[string]string{\n\t\t\t\"CONTOUR_NAMESPACE\": \"myns\",\n\t\t},\n\t\tdhp: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"K-Foo\": \"50%\",\n\t\t\t},\n\t\t},\n\t\twant: &HeadersPolicy{\n\t\t\tSet: map[string]string{\n\t\t\t\t\"K-Foo\": \"100%%\",\n\t\t\t},\n\t\t},\n\t}}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot, gotErr := headersPolicyService(test.dhp, test.in, test.dyn)\n\t\t\tassert.Equal(t, test.want, got)\n\t\t\tassert.Equal(t, test.wantErr, gotErr)\n\t\t})\n\t}\n}\n\nfunc TestBuilderRunsProcessorsInOrder(t *testing.T) {\n\tvar got []string\n\n\tb := Builder{\n\t\tProcessors: []Processor{\n\t\t\tProcessorFunc(func(*DAG, *KubernetesCache) { got = append(got, \"foo\") }),\n\t\t\tProcessorFunc(func(*DAG, *KubernetesCache) { got = append(got, \"bar\") }),\n\t\t\tProcessorFunc(func(*DAG, *KubernetesCache) { got = append(got, \"baz\") }),\n\t\t\tProcessorFunc(func(*DAG, *KubernetesCache) { got = append(got, \"abc\") }),\n\t\t\tProcessorFunc(func(*DAG, *KubernetesCache) { got = append(got, \"def\") }),\n\t\t},\n\t}\n\n\tb.Build()\n\n\tassert.Equal(t, []string{\"foo\", \"bar\", \"baz\", \"abc\", \"def\"}, got)\n}\n\nfunc routes(routes ...*Route) map[string]*Route {\n\tif len(routes) == 0 {\n\t\treturn nil\n\t}\n\tm := make(map[string]*Route)\n\tfor _, r := range routes {\n\t\tm[conditionsToString(r)] = r\n\t}\n\treturn m\n}\n\nfunc directResponseRoute(prefix string, statusCode uint32) *Route {\n\treturn &Route{\n\t\tPathMatchCondition: prefixString(prefix),\n\t\tDirectResponse:     &DirectResponse{StatusCode: statusCode},\n\t}\n}\n\nfunc directResponseRouteService(prefix string, statusCode uint32, first *Service, rest ...*Service) *Route {\n\tservices := append([]*Service{first}, rest...)\n\treturn &Route{\n\t\tPathMatchCondition: prefixString(prefix),\n\t\tDirectResponse:     &DirectResponse{StatusCode: statusCode},\n\t\tClusters:           clustersWeight(services...),\n\t}\n}\n\nfunc httpRouteMatch(pathType gatewayapi_v1alpha1.PathMatchType, value string) []gatewayapi_v1alpha1.HTTPRouteMatch {\n\treturn []gatewayapi_v1alpha1.HTTPRouteMatch{{\n\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\tType:  pathMatchTypePtr(pathType),\n\t\t\tValue: pointer.StringPtr(value),\n\t\t},\n\t}}\n}\n\nfunc httpRouteForwards(forwards ...[]gatewayapi_v1alpha1.HTTPRouteForwardTo) []gatewayapi_v1alpha1.HTTPRouteForwardTo {\n\tvar fwds []gatewayapi_v1alpha1.HTTPRouteForwardTo\n\n\tfor _, f := range forwards {\n\t\tfwds = append(fwds, f...)\n\t}\n\treturn fwds\n}\n\nfunc httpRouteForwardTo(serviceName string, port int, weight int32) []gatewayapi_v1alpha1.HTTPRouteForwardTo {\n\treturn []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\tServiceName: pointer.StringPtr(serviceName),\n\t\tPort:        gatewayPort(port),\n\t\tWeight:      pointer.Int32Ptr(weight),\n\t}}\n}\n\nfunc tcpRouteForwardTo(serviceName string, port int, weight int32) []gatewayapi_v1alpha1.RouteForwardTo {\n\treturn []gatewayapi_v1alpha1.RouteForwardTo{{\n\t\tServiceName: pointer.StringPtr(serviceName),\n\t\tPort:        gatewayPort(port),\n\t\tWeight:      pointer.Int32Ptr(weight),\n\t}}\n}\n\nfunc prefixroute(prefix string, first *Service, rest ...*Service) *Route {\n\tservices := append([]*Service{first}, rest...)\n\treturn &Route{\n\t\tPathMatchCondition: prefixString(prefix),\n\t\tClusters:           clusters(services...),\n\t}\n}\n\nfunc prefixrouteHTTPRoute(prefix string, first *Service, rest ...*Service) *Route {\n\tservices := append([]*Service{first}, rest...)\n\treturn &Route{\n\t\tPathMatchCondition: prefixString(prefix),\n\t\tClusters:           clustersWeight(services...),\n\t}\n}\n\nfunc exactrouteHTTPRoute(path string, first *Service, rest ...*Service) *Route {\n\tservices := append([]*Service{first}, rest...)\n\treturn &Route{\n\t\tPathMatchCondition: &ExactMatchCondition{Path: path},\n\t\tClusters:           clustersWeight(services...),\n\t}\n}\n\nfunc routeProtocol(prefix string, protocol string, first *Service, rest ...*Service) *Route {\n\tservices := append([]*Service{first}, rest...)\n\n\tcs := clusters(services...)\n\tfor _, c := range cs {\n\t\tc.Protocol = protocol\n\t}\n\treturn &Route{\n\t\tPathMatchCondition: prefixString(prefix),\n\t\tClusters:           cs,\n\t}\n}\n\nfunc routeCluster(prefix string, first *Cluster, rest ...*Cluster) *Route {\n\treturn &Route{\n\t\tPathMatchCondition: prefixString(prefix),\n\t\tClusters:           append([]*Cluster{first}, rest...),\n\t}\n}\n\nfunc routeUpgrade(prefix string, first *Service, rest ...*Service) *Route {\n\tr := prefixroute(prefix, first, rest...)\n\tr.HTTPSUpgrade = true\n\treturn r\n}\n\nfunc routeWebsocket(prefix string, first *Service, rest ...*Service) *Route {\n\tr := prefixroute(prefix, first, rest...)\n\tr.Websocket = true\n\treturn r\n}\n\nfunc routeHeaders(prefix string, requestSet map[string]string, requestRemove []string, responseSet map[string]string, responseRemove []string, first *Service, rest ...*Service) *Route {\n\tr := prefixroute(prefix, first, rest...)\n\tr.RequestHeadersPolicy = &HeadersPolicy{\n\t\tSet:    requestSet,\n\t\tRemove: requestRemove,\n\t}\n\tr.ResponseHeadersPolicy = &HeadersPolicy{\n\t\tSet:    responseSet,\n\t\tRemove: responseRemove,\n\t}\n\treturn r\n}\n\nfunc clusterHeaders(requestSet map[string]string, requestAdd map[string]string, requestRemove []string, hostRewrite string, services ...*Service) (c []*Cluster) {\n\tfor _, s := range services {\n\t\tc = append(c, &Cluster{\n\t\t\tUpstream: s,\n\t\t\tProtocol: s.Protocol,\n\t\t\tRequestHeadersPolicy: &HeadersPolicy{\n\t\t\t\tSet:         requestSet,\n\t\t\t\tAdd:         requestAdd,\n\t\t\t\tRemove:      requestRemove,\n\t\t\t\tHostRewrite: hostRewrite,\n\t\t\t},\n\t\t\tWeight: s.Weighted.Weight,\n\t\t})\n\t}\n\treturn c\n}\n\nfunc clusters(services ...*Service) (c []*Cluster) {\n\tfor _, s := range services {\n\t\tc = append(c, &Cluster{\n\t\t\tUpstream: s,\n\t\t\tProtocol: s.Protocol,\n\t\t})\n\t}\n\treturn c\n}\n\nfunc clustersWeight(services ...*Service) (c []*Cluster) {\n\tfor _, s := range services {\n\t\tc = append(c, &Cluster{\n\t\t\tUpstream: s,\n\t\t\tProtocol: s.Protocol,\n\t\t\tWeight:   s.Weighted.Weight,\n\t\t})\n\t}\n\treturn c\n}\n\nfunc service(s *v1.Service) *Service {\n\treturn &Service{\n\t\tWeighted: WeightedService{\n\t\t\tWeight:           1,\n\t\t\tServiceName:      s.Name,\n\t\t\tServiceNamespace: s.Namespace,\n\t\t\tServicePort:      s.Spec.Ports[0],\n\t\t},\n\t}\n}\n\nfunc clustermap(services ...*v1.Service) []*Cluster {\n\tvar c []*Cluster\n\tfor _, s := range services {\n\t\tc = append(c, &Cluster{\n\t\t\tUpstream: service(s),\n\t\t})\n\t}\n\treturn c\n}\n\nfunc secret(s *v1.Secret) *Secret {\n\treturn &Secret{\n\t\tObject: s,\n\t}\n}\n\nfunc virtualhosts(vx ...Vertex) []Vertex {\n\treturn vx\n}\n\nfunc virtualhost(name string, first *Route, rest ...*Route) *VirtualHost {\n\treturn &VirtualHost{\n\t\tName:         name,\n\t\tListenerName: \"ingress_http\",\n\t\troutes:       routes(append([]*Route{first}, rest...)...),\n\t}\n}\n\nfunc securevirtualhost(name string, sec *v1.Secret, first *Route, rest ...*Route) *SecureVirtualHost {\n\treturn &SecureVirtualHost{\n\t\tVirtualHost: VirtualHost{\n\t\t\tName:         name,\n\t\t\tListenerName: \"ingress_https\",\n\t\t\troutes:       routes(append([]*Route{first}, rest...)...),\n\t\t},\n\t\tMinTLSVersion: \"1.2\",\n\t\tSecret:        secret(sec),\n\t}\n}\n\nfunc listeners(ls ...*Listener) []Vertex {\n\tvar v []Vertex\n\tfor _, l := range ls {\n\t\tv = append(v, l)\n\t}\n\treturn v\n}\n\nfunc prefixString(prefix string) MatchCondition {\n\treturn &PrefixMatchCondition{Prefix: prefix, PrefixMatchType: PrefixMatchString}\n}\nfunc prefixSegment(prefix string) MatchCondition {\n\treturn &PrefixMatchCondition{Prefix: prefix, PrefixMatchType: PrefixMatchSegment}\n}\nfunc exact(path string) MatchCondition  { return &ExactMatchCondition{Path: path} }\nfunc regex(regex string) MatchCondition { return &RegexMatchCondition{Regex: regex} }\n\nfunc withMirror(r *Route, mirror *Service) *Route {\n\tr.MirrorPolicy = &MirrorPolicy{\n\t\tCluster: &Cluster{\n\t\t\tUpstream: mirror,\n\t\t},\n\t}\n\treturn r\n}\n\nfunc gatewayAddressTypePtr(addr gatewayapi_v1alpha1.AddressType) *gatewayapi_v1alpha1.AddressType {\n\treturn &addr\n}\n\nfunc routeSelectTypePtr(rst gatewayapi_v1alpha1.RouteSelectType) *gatewayapi_v1alpha1.RouteSelectType {\n\treturn &rst\n}\n\nfunc tlsModeTypePtr(mode gatewayapi_v1alpha1.TLSModeType) *gatewayapi_v1alpha1.TLSModeType {\n\treturn &mode\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dag\n\nimport (\n\t\"path\"\n\t\"strings\"\n\n\tcontour_api_v1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"\n\tcontour_api_v1alpha1 \"github.com/projectcontour/contour/apis/projectcontour/v1alpha1\"\n\t\"github.com/projectcontour/contour/internal/k8s\"\n\t\"github.com/projectcontour/contour/internal/status\"\n\t\"github.com/projectcontour/contour/internal/xds\"\n\t\"github.com/sirupsen/logrus\"\n\tcorev1 \"k8s.io/api/core/v1\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n)\n\ntype ExtensionServiceProcessor struct {\n\tlogrus.FieldLogger\n\n\t// ClientCertificate is the optional identifier of the TLS\n\t// secret containing client certificate and private key to be\n\t// used when establishing TLS connection to upstream cluster.\n\tClientCertificate *types.NamespacedName\n}\n\nvar _ Processor = &ExtensionServiceProcessor{}\n\nfunc (p *ExtensionServiceProcessor) Run(dag *DAG, cache *KubernetesCache) {\n\tfor _, e := range cache.extensions {\n\t\textStatus, commit := status.ExtensionAccessor(&dag.StatusCache, e)\n\t\tvalidCondition := extStatus.ConditionFor(status.ValidCondition)\n\n\t\tif ext := p.buildExtensionService(cache, e, validCondition); ext != nil {\n\t\t\tif len(validCondition.Errors) == 0 {\n\t\t\t\tdag.AddRoot(ext)\n\t\t\t}\n\t\t}\n\n\t\tif len(validCondition.Errors) == 0 {\n\t\t\tvalidCondition.Status = contour_api_v1.ConditionTrue\n\t\t\tvalidCondition.Reason = \"Valid\"\n\t\t\tvalidCondition.Message = \"Valid ExtensionService\"\n\t\t}\n\n\t\tcommit()\n\t}\n}\n\n// ExtensionClusterName generates a unique Envoy cluster name\n// for an ExtensionCluster.\n// The namespaced name of an ExtensionCluster is globally\n// unique, so we can simply use that as the cluster name. As\n// long as we scope the context with the \"extension\" prefix\n// there can't be a conflict. Note that the name doesn't include\n// a hash of the contents because we want a 1-1 mapping between\n// ExtensionServices and Envoy Clusters; we don't want a new\n// Envoy Cluster just because a field changed.\nfunc ExtensionClusterName(meta types.NamespacedName) string {\n\treturn strings.Join([]string{\"extension\", meta.Namespace, meta.Name}, \"/\")\n}\n\n// buildExtensionService builds one ExtensionCluster record based\n// on the corresponding CRD.\nfunc (p *ExtensionServiceProcessor) buildExtensionService(\n\tcache *KubernetesCache,\n\text *contour_api_v1alpha1.ExtensionService,\n\tvalidCondition *contour_api_v1.DetailedCondition,\n) *ExtensionCluster {\n\ttp, err := timeoutPolicy(ext.Spec.TimeoutPolicy)\n\tif err != nil {\n\t\tvalidCondition.AddErrorf(contour_api_v1.ConditionTypeSpecError, \"TimeoutPolicyNotValid\",\n\t\t\t\"spec.timeoutPolicy failed to parse: %s\", err)\n\t}\n\n\tvar clientCertSecret *Secret\n\tif p.ClientCertificate != nil {\n\t\tclientCertSecret, err = cache.LookupSecret(*p.ClientCertificate, validSecret)\n\t\tif err != nil {\n\t\t\tvalidCondition.AddErrorf(contour_api_v1.ConditionTypeTLSError, \"SecretNotValid\",\n\t\t\t\t\"tls.envoy-client-certificate Secret %q is invalid: %s\", p.ClientCertificate, err)\n\t\t}\n\t}\n\n\textension := ExtensionCluster{\n\t\tName: ExtensionClusterName(k8s.NamespacedNameOf(ext)),\n\t\tUpstream: ServiceCluster{\n\t\t\tClusterName: path.Join(\n\t\t\t\t\"extension\",\n\t\t\t\txds.ClusterLoadAssignmentName(k8s.NamespacedNameOf(ext), \"\"),\n\t\t\t),\n\t\t},\n\t\tProtocol:           \"h2\",\n\t\tUpstreamValidation: nil,\n\t\tTimeoutPolicy:      tp,\n\t\tSNI:                \"\",\n\t\tClientCertificate:  clientCertSecret,\n\t}\n\n\tlbPolicy := loadBalancerPolicy(ext.Spec.LoadBalancerPolicy)\n\tswitch lbPolicy {\n\tcase LoadBalancerPolicyCookie, LoadBalancerPolicyRequestHash:\n\t\tvalidCondition.AddWarningf(contour_api_v1.ConditionTypeSpecError, \"IgnoredField\",\n\t\t\t\"ignoring field %q; %s load balancer policy is not supported for ExtensionClusters\",\n\t\t\t\".Spec.LoadBalancerPolicy\", lbPolicy)\n\t\t// Reset load balancer policy to ensure the default.\n\t\tlbPolicy = \"\"\n\t}\n\textension.LoadBalancerPolicy = lbPolicy\n\n\t// Timeouts are specified above the cluster (e.g.\n\t// in the ext_authz filter). The ext_authz filter\n\t// doesn't have an idle timeout (only a request\n\t// timeout), so validate that it is not provided here.\n\tif timeouts := ext.Spec.TimeoutPolicy; timeouts != nil && timeouts.Idle != \"\" {\n\t\tvalidCondition.AddWarningf(\"SpecError\", \"IgnoredField\",\n\t\t\t\"ignoring field %q; idle timeouts are not supported for ExtensionClusters\",\n\t\t\t\".Spec.TimeoutPolicy.Idle\")\n\t}\n\n\t// API server validation ensures that the protocol is \"h2\" or \"h2c\".\n\tif ext.Spec.Protocol != nil {\n\t\textension.Protocol = stringOrDefault(*ext.Spec.Protocol, extension.Protocol)\n\t}\n\n\tif v := ext.Spec.UpstreamValidation; v != nil {\n\t\tif uv, err := cache.LookupUpstreamValidation(v, ext.GetNamespace()); err != nil {\n\t\t\tvalidCondition.AddErrorf(contour_api_v1.ConditionTypeSpecError, \"TLSUpstreamValidation\",\n\t\t\t\t\"TLS upstream validation policy error: %s\", err.Error())\n\t\t} else {\n\t\t\textension.UpstreamValidation = uv\n\n\t\t\t// Default the SNI server name to the name\n\t\t\t// we need to validate. It is a bit onerous\n\t\t\t// to also have to provide a CA bundle here,\n\t\t\t// but maybe we can make that optional in the\n\t\t\t// future.\n\t\t\t//\n\t\t\t// TODO(jpeach): expose SNI in the API, https://github.com/projectcontour/contour/issues/2893.\n\t\t\textension.SNI = uv.SubjectName\n\t\t}\n\n\t\tif extension.Protocol != \"h2\" {\n\t\t\tvalidCondition.AddErrorf(contour_api_v1.ConditionTypeSpecError, \"InconsistentProtocol\",\n\t\t\t\t\"upstream TLS validation not supported for %q protocol\", extension.Protocol)\n\t\t}\n\t}\n\n\tfor _, target := range ext.Spec.Services {\n\t\t// Note that ExtensionServices only expose Kubernetes\n\t\t// Service resources that are in the same namespace.\n\t\t// This prevent using a cross-namespace reference to\n\t\t// subvert the Contour installation.\n\t\tsvcName := types.NamespacedName{\n\t\t\tNamespace: ext.GetNamespace(),\n\t\t\tName:      target.Name,\n\t\t}\n\n\t\tsvc, port, err := cache.LookupService(svcName, intstr.FromInt(target.Port))\n\t\tif err != nil {\n\t\t\tvalidCondition.AddErrorf(contour_api_v1.ConditionTypeServiceError, \"ServiceUnresolvedReference\",\n\t\t\t\t\"unresolved service %q: %s\", svcName, err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// TODO(jpeach): Add ExternalName support in https://github.com/projectcontour/contour/issues/2875.\n\t\t// TODO(youngnick): If ExternalName support is added, we must pass down the EnableExternalNameService bool\n\t\t// and check it first.\n\t\tif svc.Spec.ExternalName != \"\" {\n\t\t\tvalidCondition.AddErrorf(contour_api_v1.ConditionTypeServiceError, \"UnsupportedServiceType\",\n\t\t\t\t\"Service %q is of unsupported type %q.\", svcName, corev1.ServiceTypeExternalName)\n\t\t\tcontinue\n\t\t}\n\n\t\textension.Upstream.AddWeightedService(target.Weight, svcName, port)\n\t}\n\n\treturn &extension\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dag\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/projectcontour/contour/internal/errors\"\n\t\"github.com/projectcontour/contour/internal/k8s\"\n\t\"github.com/projectcontour/contour/internal/status\"\n\n\t\"github.com/sirupsen/logrus\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/labels\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n\t\"k8s.io/apimachinery/pkg/util/validation\"\n\t\"k8s.io/apimachinery/pkg/util/validation/field\"\n\t\"k8s.io/utils/pointer\"\n\tgatewayapi_v1alpha1 \"sigs.k8s.io/gateway-api/apis/v1alpha1\"\n)\n\nconst (\n\tKindHTTPRoute = \"HTTPRoute\"\n\tKindTLSRoute  = \"TLSRoute\"\n)\n\n// GatewayAPIProcessor translates Gateway API types into DAG\n// objects and adds them to the DAG.\ntype GatewayAPIProcessor struct {\n\tlogrus.FieldLogger\n\n\tdag    *DAG\n\tsource *KubernetesCache\n\n\t// EnableExternalNameService allows processing of ExternalNameServices\n\t// This is normally disabled for security reasons.\n\t// See https://github.com/projectcontour/contour/security/advisories/GHSA-5ph6-qq5x-7jwc for details.\n\tEnableExternalNameService bool\n}\n\n// matchConditions holds match rules.\ntype matchConditions struct {\n\tpathMatchConditions  []MatchCondition\n\theaderMatchCondition []HeaderMatchCondition\n}\n\n// Run translates Service APIs into DAG objects and\n// adds them to the DAG.\nfunc (p *GatewayAPIProcessor) Run(dag *DAG, source *KubernetesCache) {\n\tvar errs field.ErrorList\n\tpath := field.NewPath(\"spec\")\n\n\tp.dag = dag\n\tp.source = source\n\n\t// reset the processor when we're done\n\tdefer func() {\n\t\tp.dag = nil\n\t\tp.source = nil\n\t}()\n\n\t// Gateway and GatewayClass must be defined for resources to be processed.\n\tif p.source.gateway == nil {\n\t\tp.Info(\"Gateway not found in cache.\")\n\t\treturn\n\t}\n\tif p.source.gatewayclass == nil {\n\t\tp.Info(\"Gatewayclass not found in cache.\")\n\t\treturn\n\t}\n\n\tif len(p.source.gateway.Spec.Addresses) > 0 {\n\t\tp.Error(\"Spec.Addresses is unsupported\")\n\t\terrs = append(errs, field.NotSupported(path, p.source.gateway.Spec.Addresses, []string{}))\n\t}\n\n\tfor _, listener := range p.source.gateway.Spec.Listeners {\n\n\t\tvar matchingHTTPRoutes []*gatewayapi_v1alpha1.HTTPRoute\n\t\tvar matchingTLSRoutes []*gatewayapi_v1alpha1.TLSRoute\n\t\tvar listenerSecret *Secret\n\n\t\t// Validate the Protocol on the selector is a supported type.\n\t\tswitch listener.Protocol {\n\t\tcase gatewayapi_v1alpha1.HTTPSProtocolType:\n\t\t\t// Validate that if protocol is type HTTPS, that TLS is defined.\n\t\t\tif listener.TLS == nil {\n\t\t\t\tp.Errorf(\"Listener.TLS is required when protocol is %q.\", listener.Protocol)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Check for TLS on the Gateway.\n\t\t\tif listenerSecret = p.validGatewayTLS(listener); listenerSecret == nil {\n\t\t\t\t// If TLS was configured on the Listener, but it's invalid, don't allow any\n\t\t\t\t// routes to be bound to this listener since it can't serve TLS traffic.\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase gatewayapi_v1alpha1.TLSProtocolType:\n\n\t\t\t// TLS is required for the type TLS.\n\t\t\tif listener.TLS == nil {\n\t\t\t\tp.Errorf(\"Listener.TLS is required when protocol is %q.\", listener.Protocol)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif listener.TLS.Mode != nil {\n\t\t\t\tswitch *listener.TLS.Mode {\n\t\t\t\tcase gatewayapi_v1alpha1.TLSModeTerminate:\n\t\t\t\t\t// Check for TLS on the Gateway.\n\t\t\t\t\tif listenerSecret = p.validGatewayTLS(listener); listenerSecret == nil {\n\t\t\t\t\t\t// If TLS was configured on the Listener, but it's invalid, don't allow any\n\t\t\t\t\t\t// routes to be bound to this listener since it can't serve TLS traffic.\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\tcase gatewayapi_v1alpha1.TLSModePassthrough:\n\t\t\t\t\tif listener.TLS.CertificateRef != nil {\n\t\t\t\t\t\tp.Errorf(\"Listener.TLS.CertificateRef cannot be defined when TLS Mode is %q.\", *listener.TLS.Mode)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tcase gatewayapi_v1alpha1.HTTPProtocolType:\n\t\t\tbreak\n\t\tdefault:\n\t\t\tp.Errorf(\"Listener.Protocol %q is not supported.\", listener.Protocol)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Validate the Group on the selector is a supported type.\n\t\tif listener.Routes.Group != nil {\n\t\t\tif *listener.Routes.Group != gatewayapi_v1alpha1.GroupName {\n\t\t\t\tp.Errorf(\"Listener.Routes.Group %q is not supported.\", listener.Routes.Group)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// Validate the Kind on the selector is a supported type.\n\t\tif listener.Routes.Kind != KindHTTPRoute && listener.Routes.Kind != KindTLSRoute {\n\t\t\tp.Errorf(\"Listener.Routes.Kind %q is not supported.\", listener.Routes.Kind)\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch listener.Routes.Kind {\n\t\tcase KindHTTPRoute:\n\t\t\tfor _, route := range p.source.httproutes {\n\n\t\t\t\t// Filter the HTTPRoutes that match the gateway which Contour is configured to watch.\n\t\t\t\t// RouteBindingSelector defines a schema for associating routes with the Gateway.\n\t\t\t\t// If Namespaces and Selector are defined, only routes matching both selectors are associated with the Gateway.\n\n\t\t\t\t// ## RouteBindingSelector ##\n\t\t\t\t//\n\t\t\t\t// Selector specifies a set of route labels used for selecting routes to associate\n\t\t\t\t// with the Gateway. If this Selector is defined, only routes matching the Selector\n\t\t\t\t// are associated with the Gateway. An empty Selector matches all routes.\n\n\t\t\t\tnsMatches, err := p.namespaceMatches(listener.Routes.Namespaces, route.Namespace)\n\t\t\t\tif err != nil {\n\t\t\t\t\tp.Errorf(\"error validating namespaces against Listener.Routes.Namespaces: %s\", err)\n\t\t\t\t}\n\n\t\t\t\tselMatches, err := selectorMatches(listener.Routes.Selector, route.Labels)\n\t\t\t\tif err != nil {\n\t\t\t\t\tp.Errorf(\"error validating routes against Listener.Routes.Selector: %s\", err)\n\t\t\t\t}\n\n\t\t\t\t// If all the match criteria for this HTTPRoute match the Gateway, then add\n\t\t\t\t// the route to the set of matchingRoutes.\n\t\t\t\tif selMatches && nsMatches {\n\n\t\t\t\t\tif !p.gatewayMatches(route.Spec.Gateways, route.Namespace) {\n\n\t\t\t\t\t\t// If a label selector or namespace selector matches, but the gateway Allow doesn't\n\t\t\t\t\t\t// then set the \"Admitted: false\" for the route.\n\t\t\t\t\t\trouteAccessor, commit := p.dag.StatusCache.RouteConditionsAccessor(k8s.NamespacedNameOf(route), route.Generation, status.ResourceHTTPRoute, route.Status.Gateways)\n\t\t\t\t\t\trouteAccessor.AddCondition(gatewayapi_v1alpha1.ConditionRouteAdmitted, metav1.ConditionFalse, status.ReasonGatewayAllowMismatch, \"Gateway RouteSelector matches, but GatewayAllow has mismatch.\")\n\t\t\t\t\t\tcommit()\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\t// Empty Selector matches all routes.\n\t\t\t\t\tmatchingHTTPRoutes = append(matchingHTTPRoutes, route)\n\t\t\t\t}\n\t\t\t}\n\t\tcase KindTLSRoute:\n\n\t\t\t// Validate the listener protocol is type=TLS.\n\t\t\tif listener.Protocol != gatewayapi_v1alpha1.TLSProtocolType {\n\t\t\t\tp.Errorf(\"invalid listener protocol %q for Kind: TLSRoute\", listener.Protocol)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor _, route := range p.source.tlsroutes {\n\t\t\t\t// Filter the TLSRoutes that match the gateway which Contour is configured to watch.\n\t\t\t\t// RouteBindingSelector defines a schema for associating routes with the Gateway.\n\t\t\t\t// If Namespaces and Selector are defined, only routes matching both selectors are associated with the Gateway.\n\n\t\t\t\t// ## RouteBindingSelector ##\n\t\t\t\t//\n\t\t\t\t// Selector specifies a set of route labels used for selecting routes to associate\n\t\t\t\t// with the Gateway. If this Selector is defined, only routes matching the Selector\n\t\t\t\t// are associated with the Gateway. An empty Selector matches all routes.\n\n\t\t\t\tnsMatches, err := p.namespaceMatches(listener.Routes.Namespaces, route.Namespace)\n\t\t\t\tif err != nil {\n\t\t\t\t\tp.Errorf(\"error validating namespaces against Listener.Routes.Namespaces: %s\", err)\n\t\t\t\t}\n\n\t\t\t\tselMatches, err := selectorMatches(listener.Routes.Selector, route.Labels)\n\t\t\t\tif err != nil {\n\t\t\t\t\tp.Errorf(\"error validating routes against Listener.Routes.Selector: %s\", err)\n\t\t\t\t}\n\n\t\t\t\tif selMatches && nsMatches {\n\n\t\t\t\t\tif !p.gatewayMatches(route.Spec.Gateways, route.Namespace) {\n\n\t\t\t\t\t\t// If a label selector or namespace selector matches, but the gateway Allow doesn't\n\t\t\t\t\t\t// then set the \"Admitted: false\" for the route.\n\t\t\t\t\t\trouteAccessor, commit := p.dag.StatusCache.RouteConditionsAccessor(k8s.NamespacedNameOf(route), route.Generation, status.ResourceTLSRoute, route.Status.Gateways)\n\t\t\t\t\t\trouteAccessor.AddCondition(gatewayapi_v1alpha1.ConditionRouteAdmitted, metav1.ConditionFalse, status.ReasonGatewayAllowMismatch, \"Gateway RouteSelector matches, but GatewayAllow has mismatch.\")\n\t\t\t\t\t\tcommit()\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\t// Empty Selector matches all routes.\n\t\t\t\t\tmatchingTLSRoutes = append(matchingTLSRoutes, route)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvalidGateway := len(errs) == 0\n\n\t\t// Process all the HTTPRoutes that match this Gateway.\n\t\tfor _, matchingRoute := range matchingHTTPRoutes {\n\t\t\tp.computeHTTPRoute(matchingRoute, listenerSecret, listener.Hostname, validGateway)\n\t\t}\n\n\t\t// Process all the routes that match this Gateway.\n\t\tfor _, matchingRoute := range matchingTLSRoutes {\n\t\t\tp.computeTLSRoute(matchingRoute, validGateway, listenerSecret)\n\t\t}\n\t}\n\n\tp.computeGateway(p.source.gateway, errs)\n}\n\nfunc (p *GatewayAPIProcessor) validGatewayTLS(listener gatewayapi_v1alpha1.Listener) *Secret {\n\n\t// Validate the CertificateRef is configured.\n\tif listener.TLS == nil || listener.TLS.CertificateRef == nil {\n\t\tp.Errorf(\"Spec.VirtualHost.TLS.CertificateRef is not configured.\")\n\t\treturn nil\n\t}\n\n\t// Validate a v1.Secret is referenced which can be kind: secret & group: core.\n\t// ref: https://github.com/kubernetes-sigs/gateway-api/pull/562\n\tif !isSecretRef(listener.TLS.CertificateRef) {\n\t\tp.Error(\"Spec.VirtualHost.TLS Secret must be type core.Secret\")\n\t\treturn nil\n\t}\n\n\tlistenerSecret, err := p.source.LookupSecret(types.NamespacedName{Name: listener.TLS.CertificateRef.Name, Namespace: p.source.gateway.Namespace}, validSecret)\n\tif err != nil {\n\t\tp.Errorf(\"Spec.VirtualHost.TLS Secret %q is invalid: %s\", listener.TLS.CertificateRef.Name, err)\n\t\treturn nil\n\t}\n\treturn listenerSecret\n}\n\nfunc isSecretRef(certificateRef *gatewayapi_v1alpha1.LocalObjectReference) bool {\n\treturn strings.ToLower(certificateRef.Kind) == \"secret\" && strings.ToLower(certificateRef.Group) == \"core\"\n}\n\n// computeHosts validates the hostnames for a HTTPRoute as well as validating\n// that the hostname on the HTTPRoute matches what is optionally defined on the\n// listener.hostname.\nfunc (p *GatewayAPIProcessor) computeHosts(hostnames []gatewayapi_v1alpha1.Hostname, listenerHostname *gatewayapi_v1alpha1.Hostname) (map[string]struct{}, []error) {\n\n\thosts := make(map[string]struct{})\n\tvar errors []error\n\n\t// Determine the hosts on the hostnames, if no hosts\n\t// are defined, then set to \"*\". If the listenerHostname is defined,\n\t// then the route must match the Gateway hostname.\n\tif len(hostnames) == 0 && listenerHostname == nil {\n\t\thosts[\"*\"] = struct{}{}\n\t\treturn hosts, nil\n\t}\n\n\tif listenerHostname != nil {\n\t\tif string(*listenerHostname) != \"*\" {\n\n\t\t\t// Validate listener hostname.\n\t\t\tif err := validHostName(string(*listenerHostname)); err != nil {\n\t\t\t\treturn hosts, []error{err}\n\t\t\t}\n\n\t\t\tif len(hostnames) == 0 {\n\t\t\t\thosts[string(*listenerHostname)] = struct{}{}\n\t\t\t\treturn hosts, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, host := range hostnames {\n\n\t\thostname := string(host)\n\n\t\t// Validate the hostname.\n\t\tif err := validHostName(hostname); err != nil {\n\t\t\terrors = append(errors, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif listenerHostname != nil {\n\t\t\tlhn := string(*listenerHostname)\n\n\t\t\t// A \"*\" hostname matches anything.\n\t\t\tif lhn == \"*\" {\n\t\t\t\thosts[hostname] = struct{}{}\n\t\t\t\tcontinue\n\t\t\t} else if lhn == hostname {\n\t\t\t\t// If the listener.hostname matches then no need to\n\t\t\t\t// do any other validation.\n\t\t\t\thosts[hostname] = struct{}{}\n\t\t\t\tcontinue\n\t\t\t} else if strings.Contains(lhn, \"*\") {\n\n\t\t\t\tif removeFirstDNSLabel(lhn) != removeFirstDNSLabel(hostname) {\n\t\t\t\t\terrors = append(errors, fmt.Errorf(\"gateway hostname %q does not match route hostname %q\", lhn, hostname))\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Validate the gateway listener hostname matches the hostnames hostname.\n\t\t\t\terrors = append(errors, fmt.Errorf(\"gateway hostname %q does not match route hostname %q\", lhn, hostname))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\thosts[hostname] = struct{}{}\n\t}\n\treturn hosts, errors\n}\n\nfunc removeFirstDNSLabel(input string) string {\n\tif strings.Contains(input, \".\") {\n\t\treturn input[strings.IndexAny(input, \".\"):]\n\t}\n\treturn input\n}\n\nfunc validHostName(hostname string) error {\n\tif isIP := net.ParseIP(hostname) != nil; isIP {\n\t\treturn fmt.Errorf(\"hostname %q must be a DNS name, not an IP address\", hostname)\n\t}\n\tif strings.Contains(hostname, \"*\") {\n\t\tif errs := validation.IsWildcardDNS1123Subdomain(hostname); errs != nil {\n\t\t\treturn fmt.Errorf(\"invalid hostname %q: %v\", hostname, errs)\n\t\t}\n\t} else {\n\t\tif errs := validation.IsDNS1123Subdomain(hostname); errs != nil {\n\t\t\treturn fmt.Errorf(\"invalid hostname %q: %v\", hostname, errs)\n\t\t}\n\t}\n\treturn nil\n}\n\n// namespaceMatches returns true if the namespaces selector matches\n// the HTTPRoute that is being processed.\nfunc (p *GatewayAPIProcessor) namespaceMatches(namespaces *gatewayapi_v1alpha1.RouteNamespaces, namespace string) (bool, error) {\n\t// From indicates where Routes will be selected for this Gateway.\n\t// Possible values are:\n\t//   * All: Routes in all namespaces may be used by this Gateway.\n\t//   * Selector: Routes in namespaces selected by the selector may be used by\n\t//     this Gateway.\n\t//   * Same: Only Routes in the same namespace may be used by this Gateway.\n\n\tif namespaces == nil {\n\t\treturn true, nil\n\t}\n\n\tif namespaces.From == nil {\n\t\treturn true, nil\n\t}\n\n\tswitch *namespaces.From {\n\tcase gatewayapi_v1alpha1.RouteSelectAll:\n\t\treturn true, nil\n\tcase gatewayapi_v1alpha1.RouteSelectSame:\n\t\treturn p.source.ConfiguredGateway.Namespace == namespace, nil\n\tcase gatewayapi_v1alpha1.RouteSelectSelector:\n\t\tif len(namespaces.Selector.MatchLabels) == 0 && len(namespaces.Selector.MatchExpressions) == 0 {\n\t\t\treturn false, fmt.Errorf(\"RouteNamespaces selector must be specified when `RouteSelectType=Selector`\")\n\t\t}\n\n\t\t// Look up the HTTPRoute's namespace in the list of cached namespaces.\n\t\tif ns := p.source.namespaces[namespace]; ns != nil {\n\n\t\t\t// Check that the route's namespace is included in the Gateway's\n\t\t\t// namespace selector/expression.\n\t\t\tl, err := metav1.LabelSelectorAsSelector(namespaces.Selector)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\t// Look for matching labels on Selector.\n\t\t\treturn l.Matches(labels.Set(ns.Labels)), nil\n\t\t}\n\t}\n\treturn true, nil\n}\n\n// gatewayMatches returns true if \"AllowAll\" is set, the \"SameNamespace\" is set and the HTTPRoute\n// matches the Gateway's namespace, or the \"FromList\" is set and the gateway Contour is watching\n// matches one from the list.\nfunc (p *GatewayAPIProcessor) gatewayMatches(routeGateways *gatewayapi_v1alpha1.RouteGateways, namespace string) bool {\n\n\tif routeGateways == nil || routeGateways.Allow == nil {\n\t\treturn true\n\t}\n\n\tswitch *routeGateways.Allow {\n\tcase gatewayapi_v1alpha1.GatewayAllowAll:\n\t\treturn true\n\tcase gatewayapi_v1alpha1.GatewayAllowFromList:\n\t\tfor _, gateway := range routeGateways.GatewayRefs {\n\t\t\tif gateway.Name == p.source.ConfiguredGateway.Name && gateway.Namespace == p.source.ConfiguredGateway.Namespace {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\tcase gatewayapi_v1alpha1.GatewayAllowSameNamespace:\n\t\treturn p.source.ConfiguredGateway.Namespace == namespace\n\t}\n\treturn false\n}\n\n// selectorMatches returns true if the selector matches the labels on the object or is not defined.\nfunc selectorMatches(selector *metav1.LabelSelector, objLabels map[string]string) (bool, error) {\n\n\tif selector == nil {\n\t\treturn true, nil\n\t}\n\n\t// If a selector is defined then check that it matches the labels on the object.\n\tif len(selector.MatchLabels) > 0 || len(selector.MatchExpressions) > 0 {\n\t\tl, err := metav1.LabelSelectorAsSelector(selector)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\t// Look for matching labels on Selector.\n\t\treturn l.Matches(labels.Set(objLabels)), nil\n\t}\n\t// If no selector is defined then it matches by default.\n\treturn true, nil\n}\n\nfunc (p *GatewayAPIProcessor) computeGateway(gateway *gatewayapi_v1alpha1.Gateway, fieldErrs field.ErrorList) {\n\n\tgwAccessor, commit := p.dag.StatusCache.GatewayConditionsAccessor(k8s.NamespacedNameOf(gateway), gateway.Generation, status.ResourceGateway, &gateway.Status)\n\tdefer commit()\n\n\t// Determine the gateway status based on fieldErrs.\n\tswitch len(fieldErrs) {\n\tcase 0:\n\t\tgwAccessor.AddCondition(gatewayapi_v1alpha1.GatewayConditionReady, metav1.ConditionTrue, status.ReasonValidGateway, \"Valid Gateway\")\n\tdefault:\n\t\tgwAccessor.AddCondition(gatewayapi_v1alpha1.GatewayConditionReady, metav1.ConditionFalse, status.ReasonInvalidGateway, errors.ParseFieldErrors(fieldErrs))\n\t}\n}\n\nfunc (p *GatewayAPIProcessor) computeTLSRoute(route *gatewayapi_v1alpha1.TLSRoute, validGateway bool, listenerSecret *Secret) {\n\n\trouteAccessor, commit := p.dag.StatusCache.RouteConditionsAccessor(k8s.NamespacedNameOf(route), route.Generation, status.ResourceTLSRoute, route.Status.Gateways)\n\tdefer commit()\n\n\t// If the Gateway is invalid, set status on the route.\n\tif !validGateway {\n\t\trouteAccessor.AddCondition(gatewayapi_v1alpha1.ConditionRouteAdmitted, metav1.ConditionFalse, status.ReasonInvalidGateway, \"Invalid Gateway\")\n\t\treturn\n\t}\n\n\tfor _, rule := range route.Spec.Rules {\n\t\tvar hosts []string\n\t\tvar matchErrors []error\n\t\ttotalSnis := 0\n\n\t\t// Build the set of SNIs that are applied to this TLSRoute.\n\t\tfor _, match := range rule.Matches {\n\t\t\tfor _, snis := range match.SNIs {\n\t\t\t\ttotalSnis++\n\t\t\t\tif err := validHostName(string(snis)); err != nil {\n\t\t\t\t\tmatchErrors = append(matchErrors, err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\thosts = append(hosts, string(snis))\n\t\t\t}\n\t\t}\n\n\t\t// If there are any errors with the supplied hostnames, then\n\t\t// add a condition to the route.\n\t\tfor _, err := range matchErrors {\n\t\t\trouteAccessor.AddCondition(status.ConditionResolvedRefs, metav1.ConditionFalse, status.ReasonDegraded, err.Error())\n\t\t}\n\n\t\t// If all the supplied SNIs are invalid, then this route is invalid\n\t\t// and should be dropped.\n\t\tif len(matchErrors) != 0 && len(matchErrors) == totalSnis {\n\t\t\tcontinue\n\t\t}\n\n\t\t// If SNIs is unspecified, then all\n\t\t// requests associated with the gateway TLS listener will match.\n\t\t// This can be used to define a default backend for a TLS listener.\n\t\tif len(hosts) == 0 {\n\t\t\thosts = []string{\"*\"}\n\t\t}\n\n\t\tif len(rule.ForwardTo) == 0 {\n\t\t\trouteAccessor.AddCondition(status.ConditionResolvedRefs, metav1.ConditionFalse, status.ReasonDegraded, \"At least one Spec.Rules.ForwardTo must be specified.\")\n\t\t\tcontinue\n\t\t}\n\n\t\tvar proxy TCPProxy\n\t\tfor _, forward := range rule.ForwardTo {\n\n\t\t\tservice, err := p.validateForwardTo(forward.ServiceName, forward.Port, route.Namespace)\n\t\t\tif err != nil {\n\t\t\t\trouteAccessor.AddCondition(status.ConditionResolvedRefs, metav1.ConditionFalse, status.ReasonDegraded, err.Error())\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tproxy.Clusters = append(proxy.Clusters, &Cluster{\n\t\t\t\tUpstream: service,\n\t\t\t\tSNI:      service.ExternalName,\n\t\t\t})\n\t\t}\n\n\t\tif len(proxy.Clusters) == 0 {\n\t\t\t// No valid clusters so the route should get rejected.\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, host := range hosts {\n\t\t\tsecure := p.dag.EnsureSecureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_https\"})\n\n\t\t\tif listenerSecret != nil {\n\t\t\t\tsecure.Secret = listenerSecret\n\t\t\t}\n\n\t\t\tsecure.TCPProxy = &proxy\n\t\t}\n\n\t}\n\n\t// Determine if any errors exist in conditions and set the \"Admitted\"\n\t// condition accordingly.\n\tswitch len(routeAccessor.Conditions) {\n\tcase 0:\n\t\trouteAccessor.AddCondition(gatewayapi_v1alpha1.ConditionRouteAdmitted, metav1.ConditionTrue, status.ReasonValid, \"Valid TLSRoute\")\n\tdefault:\n\t\trouteAccessor.AddCondition(gatewayapi_v1alpha1.ConditionRouteAdmitted, metav1.ConditionFalse, status.ReasonErrorsExist, \"Errors found, check other Conditions for details.\")\n\t}\n}\n\nfunc (p *GatewayAPIProcessor) computeHTTPRoute(route *gatewayapi_v1alpha1.HTTPRoute, listenerSecret *Secret, listenerHostname *gatewayapi_v1alpha1.Hostname, validGateway bool) {\n\trouteAccessor, commit := p.dag.StatusCache.RouteConditionsAccessor(k8s.NamespacedNameOf(route), route.Generation, status.ResourceHTTPRoute, route.Status.Gateways)\n\tdefer commit()\n\n\t// If the Gateway is invalid, set status on the route.\n\tif !validGateway {\n\t\trouteAccessor.AddCondition(gatewayapi_v1alpha1.ConditionRouteAdmitted, metav1.ConditionFalse, status.ReasonInvalidGateway, \"Invalid Gateway\")\n\t\treturn\n\t}\n\n\thosts, errs := p.computeHosts(route.Spec.Hostnames, listenerHostname)\n\tfor _, err := range errs {\n\t\trouteAccessor.AddCondition(status.ConditionResolvedRefs, metav1.ConditionFalse, status.ReasonDegraded, err.Error())\n\t}\n\n\t// Check if all the hostnames are invalid.\n\tif len(hosts) == 0 {\n\t\trouteAccessor.AddCondition(gatewayapi_v1alpha1.ConditionRouteAdmitted, metav1.ConditionFalse, status.ReasonErrorsExist, \"Errors found, check other Conditions for details.\")\n\t\treturn\n\t}\n\n\t// Validate TLS Configuration\n\tif route.Spec.TLS != nil {\n\t\trouteAccessor.AddCondition(status.ConditionNotImplemented, metav1.ConditionTrue, status.ReasonNotImplemented, \"HTTPRoute.Spec.TLS: Not yet implemented.\")\n\t}\n\n\tfor _, rule := range route.Spec.Rules {\n\n\t\tvar matchconditions []*matchConditions\n\n\t\tfor _, match := range rule.Matches {\n\t\t\tmc := &matchConditions{}\n\t\t\tif err := pathMatchCondition(mc, match.Path); err != nil {\n\t\t\t\trouteAccessor.AddCondition(status.ConditionNotImplemented, metav1.ConditionTrue, status.ReasonPathMatchType, \"HTTPRoute.Spec.Rules.PathMatch: Only Prefix match type and Exact match type are supported.\")\n\t\t\t}\n\n\t\t\tif err := headerMatchCondition(mc, match.Headers); err != nil {\n\t\t\t\trouteAccessor.AddCondition(status.ConditionNotImplemented, metav1.ConditionTrue, status.ReasonHeaderMatchType, \"HTTPRoute.Spec.Rules.HeaderMatch: Only Exact match type is supported.\")\n\t\t\t}\n\t\t\tmatchconditions = append(matchconditions, mc)\n\t\t}\n\n\t\tif len(rule.ForwardTo) == 0 {\n\t\t\trouteAccessor.AddCondition(status.ConditionResolvedRefs, metav1.ConditionFalse, status.ReasonDegraded, \"At least one Spec.Rules.ForwardTo must be specified.\")\n\t\t\tcontinue\n\t\t}\n\n\t\tvar clusters []*Cluster\n\n\t\t// Validate the ForwardTos.\n\t\ttotalWeight := uint32(0)\n\t\tfor _, forward := range rule.ForwardTo {\n\n\t\t\tservice, err := p.validateForwardTo(forward.ServiceName, forward.Port, route.Namespace)\n\t\t\tif err != nil {\n\t\t\t\trouteAccessor.AddCondition(status.ConditionResolvedRefs, metav1.ConditionFalse, status.ReasonDegraded, err.Error())\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvar headerPolicy *HeadersPolicy\n\t\t\tfor _, filter := range forward.Filters {\n\t\t\t\tswitch filter.Type {\n\t\t\t\tcase gatewayapi_v1alpha1.HTTPRouteFilterRequestHeaderModifier:\n\t\t\t\t\tvar err error\n\t\t\t\t\theaderPolicy, err = headersPolicyGatewayAPI(filter.RequestHeaderModifier)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\trouteAccessor.AddCondition(status.ConditionResolvedRefs, metav1.ConditionFalse, status.ReasonDegraded, fmt.Sprintf(\"%s on request headers\", err))\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\trouteAccessor.AddCondition(status.ConditionNotImplemented, metav1.ConditionTrue, status.ReasonHTTPRouteFilterType, \"HTTPRoute.Spec.Rules.ForwardTo.Filters: Only RequestHeaderModifier type is supported.\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Route defaults to a weight of \"1\" unless otherwise specified.\n\t\t\trouteWeight := uint32(1)\n\t\t\tif forward.Weight != nil {\n\t\t\t\trouteWeight = uint32(*forward.Weight)\n\t\t\t}\n\n\t\t\t// Keep track of all the weights for this set of forwardTos. This will be\n\t\t\t// used later to understand if all the weights are set to zero.\n\t\t\ttotalWeight += routeWeight\n\n\t\t\t// https://github.com/projectcontour/contour/issues/3593\n\t\t\tservice.Weighted.Weight = routeWeight\n\t\t\tclusters = append(clusters, p.cluster(headerPolicy, service, routeWeight))\n\t\t}\n\n\t\tvar headerPolicy *HeadersPolicy\n\t\tfor _, filter := range rule.Filters {\n\t\t\tswitch filter.Type {\n\t\t\tcase gatewayapi_v1alpha1.HTTPRouteFilterRequestHeaderModifier:\n\t\t\t\tvar err error\n\t\t\t\theaderPolicy, err = headersPolicyGatewayAPI(filter.RequestHeaderModifier)\n\t\t\t\tif err != nil {\n\t\t\t\t\trouteAccessor.AddCondition(status.ConditionResolvedRefs, metav1.ConditionFalse, status.ReasonDegraded, fmt.Sprintf(\"%s on request headers\", err))\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\trouteAccessor.AddCondition(status.ConditionNotImplemented, metav1.ConditionTrue, status.ReasonHTTPRouteFilterType, \"HTTPRoute.Spec.Rules.Filters: Only RequestHeaderModifier type is supported.\")\n\t\t\t}\n\t\t}\n\n\t\troutes := p.routes(matchconditions, headerPolicy, clusters)\n\t\tfor host := range hosts {\n\t\t\tfor _, route := range routes {\n\t\t\t\t// If there aren't any valid services, or the total weight of all of\n\t\t\t\t// them equal zero, then return 503 responses to the caller.\n\t\t\t\tif len(clusters) == 0 || totalWeight == 0 {\n\t\t\t\t\t// Configure a direct response HTTP status code of 503 so the\n\t\t\t\t\t// route still matches the configured conditions since the\n\t\t\t\t\t// service is missing or invalid.\n\t\t\t\t\troute.DirectResponse = &DirectResponse{\n\t\t\t\t\t\tStatusCode: http.StatusServiceUnavailable,\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If we have a wildcard match, add a header match regex rule to match the\n\t\t\t\t// hostname so we can be sure to only match one DNS label. This is required\n\t\t\t\t// as Envoy's virtualhost hostname wildcard matching can match multiple\n\t\t\t\t// labels. This match ignores a port in the hostname in case it is present.\n\t\t\t\tif strings.HasPrefix(host, \"*.\") {\n\t\t\t\t\troute.HeaderMatchConditions = append(route.HeaderMatchConditions, HeaderMatchCondition{\n\t\t\t\t\t\t// Internally Envoy uses the HTTP/2 \":authority\" header in\n\t\t\t\t\t\t// place of the HTTP/1 \"host\" header.\n\t\t\t\t\t\t// See: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#config-route-v3-headermatcher\n\t\t\t\t\t\tName:      \":authority\",\n\t\t\t\t\t\tMatchType: HeaderMatchTypeRegex,\n\t\t\t\t\t\tValue:     singleDNSLabelWildcardRegex + regexp.QuoteMeta(host[1:]),\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tswitch {\n\t\t\t\tcase listenerSecret != nil:\n\t\t\t\t\tsvhost := p.dag.EnsureSecureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_https\"})\n\t\t\t\t\tsvhost.Secret = listenerSecret\n\t\t\t\t\tsvhost.addRoute(route)\n\t\t\t\tdefault:\n\t\t\t\t\tvhost := p.dag.EnsureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_http\"})\n\t\t\t\t\tvhost.addRoute(route)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Determine if any errors exist in conditions and set the \"Admitted\"\n\t// condition accordingly.\n\tswitch len(routeAccessor.Conditions) {\n\tcase 0:\n\t\trouteAccessor.AddCondition(gatewayapi_v1alpha1.ConditionRouteAdmitted, metav1.ConditionTrue, status.ReasonValid, \"Valid HTTPRoute\")\n\tdefault:\n\t\trouteAccessor.AddCondition(gatewayapi_v1alpha1.ConditionRouteAdmitted, metav1.ConditionFalse, status.ReasonErrorsExist, \"Errors found, check other Conditions for details.\")\n\t}\n}\n\n// validateForwardTo verifies that the specified forwardTo is valid.\n// Returns an error if not or the service found in the cache.\nfunc (p *GatewayAPIProcessor) validateForwardTo(serviceName *string, port *gatewayapi_v1alpha1.PortNumber, namespace string) (*Service, error) {\n\t// Verify the service is valid\n\tif serviceName == nil {\n\t\treturn nil, fmt.Errorf(\"Spec.Rules.ForwardTo.ServiceName must be specified\")\n\t}\n\n\t// TODO: Do not require port to be present (#3352).\n\tif port == nil {\n\t\treturn nil, fmt.Errorf(\"Spec.Rules.ForwardTo.ServicePort must be specified\")\n\t}\n\n\tmeta := types.NamespacedName{Name: *serviceName, Namespace: namespace}\n\n\t// TODO: Refactor EnsureService to take an int32 so conversion to intstr is not needed.\n\tservice, err := p.dag.EnsureService(meta, intstr.FromInt(int(*port)), p.source, p.EnableExternalNameService)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"service %q is invalid: %s\", meta.Name, err)\n\t}\n\n\treturn service, nil\n}\n\nfunc pathMatchCondition(mc *matchConditions, match *gatewayapi_v1alpha1.HTTPPathMatch) error {\n\n\tif match == nil {\n\t\tmc.pathMatchConditions = append(mc.pathMatchConditions, &PrefixMatchCondition{Prefix: \"/\"})\n\t\treturn nil\n\t}\n\n\tpath := pointer.StringDeref(match.Value, \"/\")\n\n\tif match.Type == nil {\n\t\t// If path match type is not defined, default to 'PrefixMatch'.\n\t\tmc.pathMatchConditions = append(mc.pathMatchConditions, &PrefixMatchCondition{Prefix: path})\n\t} else {\n\t\tswitch *match.Type {\n\t\tcase gatewayapi_v1alpha1.PathMatchPrefix:\n\t\t\tmc.pathMatchConditions = append(mc.pathMatchConditions, &PrefixMatchCondition{Prefix: path})\n\t\tcase gatewayapi_v1alpha1.PathMatchExact:\n\t\t\tmc.pathMatchConditions = append(mc.pathMatchConditions, &ExactMatchCondition{Path: path})\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"HTTPRoute.Spec.Rules.PathMatch: Only Prefix match type and Exact match type are supported\")\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc headerMatchCondition(mc *matchConditions, match *gatewayapi_v1alpha1.HTTPHeaderMatch) error {\n\tif match == nil {\n\t\treturn nil\n\t}\n\n\t// HeaderMatchTypeExact is the default if not defined in the object.\n\theaderMatchType := HeaderMatchTypeExact\n\tif match.Type != nil {\n\t\tswitch *match.Type {\n\t\tcase gatewayapi_v1alpha1.HeaderMatchExact:\n\t\t\theaderMatchType = HeaderMatchTypeExact\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"HTTPRoute.Spec.Rules.HeaderMatch: Only Exact match type is supported\")\n\t\t}\n\t}\n\n\tfor k, v := range match.Values {\n\t\tmc.headerMatchCondition = append(mc.headerMatchCondition, HeaderMatchCondition{MatchType: headerMatchType, Name: k, Value: v})\n\t}\n\n\treturn nil\n}\n\n// routes builds a []*dag.Route for the supplied set of matchConditions, headerPolicy and clusters.\nfunc (p *GatewayAPIProcessor) routes(matchConditions []*matchConditions, headerPolicy *HeadersPolicy, clusters []*Cluster) []*Route {\n\tvar routes []*Route\n\n\tfor _, mc := range matchConditions {\n\t\tfor _, pathMatch := range mc.pathMatchConditions {\n\t\t\tr := &Route{\n\t\t\t\tClusters: clusters,\n\t\t\t}\n\t\t\tr.PathMatchCondition = pathMatch\n\t\t\tr.HeaderMatchConditions = mc.headerMatchCondition\n\t\t\tr.RequestHeadersPolicy = headerPolicy\n\t\t\troutes = append(routes, r)\n\t\t}\n\t}\n\n\treturn routes\n}\n\n// cluster builds a *dag.Cluster for the supplied set of headerPolicy and service.\nfunc (p *GatewayAPIProcessor) cluster(headerPolicy *HeadersPolicy, service *Service, weight uint32) *Cluster {\n\treturn &Cluster{\n\t\tUpstream:             service,\n\t\tWeight:               weight,\n\t\tProtocol:             service.Protocol,\n\t\tRequestHeadersPolicy: headerPolicy,\n\t}\n}\n\nfunc pathMatchTypePtr(pmt gatewayapi_v1alpha1.PathMatchType) *gatewayapi_v1alpha1.PathMatchType {\n\treturn &pmt\n}\n\nfunc headerMatchTypePtr(hmt gatewayapi_v1alpha1.HeaderMatchType) *gatewayapi_v1alpha1.HeaderMatchType {\n\treturn &hmt\n}\n\nfunc gatewayAllowTypePtr(gwType gatewayapi_v1alpha1.GatewayAllowType) *gatewayapi_v1alpha1.GatewayAllowType {\n\treturn &gwType\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dag\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\n\tcontour_api_v1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"\n\tcontour_api_v1alpha1 \"github.com/projectcontour/contour/apis/projectcontour/v1alpha1\"\n\t\"github.com/projectcontour/contour/internal/annotation\"\n\t\"github.com/projectcontour/contour/internal/k8s\"\n\t\"github.com/projectcontour/contour/internal/status\"\n\t\"github.com/projectcontour/contour/internal/timeout\"\n\t\"github.com/projectcontour/contour/pkg/config\"\n\t\"k8s.io/apimachinery/pkg/api/equality\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n)\n\n// defaultExtensionRef populates the unset fields in ref with default values.\nfunc defaultExtensionRef(ref contour_api_v1.ExtensionServiceReference) contour_api_v1.ExtensionServiceReference {\n\tif ref.APIVersion == \"\" {\n\t\tref.APIVersion = contour_api_v1alpha1.GroupVersion.String()\n\n\t}\n\n\treturn ref\n}\n\n// HTTPProxyProcessor translates HTTPProxies into DAG\n// objects and adds them to the DAG.\ntype HTTPProxyProcessor struct {\n\tdag      *DAG\n\tsource   *KubernetesCache\n\torphaned map[types.NamespacedName]bool\n\n\t// DisablePermitInsecure disables the use of the\n\t// permitInsecure field in HTTPProxy.\n\tDisablePermitInsecure bool\n\n\t// FallbackCertificate is the optional identifier of the\n\t// TLS secret to use by default when SNI is not set on a\n\t// request.\n\tFallbackCertificate *types.NamespacedName\n\n\t// EnableExternalNameService allows processing of ExternalNameServices\n\t// This is normally disabled for security reasons.\n\t// See https://github.com/projectcontour/contour/security/advisories/GHSA-5ph6-qq5x-7jwc for details.\n\tEnableExternalNameService bool\n\n\t// DNSLookupFamily defines how external names are looked up\n\t// When configured as V4, the DNS resolver will only perform a lookup\n\t// for addresses in the IPv4 family. If V6 is configured, the DNS resolver\n\t// will only perform a lookup for addresses in the IPv6 family.\n\t// If AUTO is configured, the DNS resolver will first perform a lookup\n\t// for addresses in the IPv6 family and fallback to a lookup for addresses\n\t// in the IPv4 family.\n\t// Note: This only applies to externalName clusters.\n\tDNSLookupFamily config.ClusterDNSFamilyType\n\n\t// ClientCertificate is the optional identifier of the TLS secret containing client certificate and\n\t// private key to be used when establishing TLS connection to upstream cluster.\n\tClientCertificate *types.NamespacedName\n\n\t// Request headers that will be set on all routes (optional).\n\tRequestHeadersPolicy *HeadersPolicy\n\n\t// Response headers that will be set on all routes (optional).\n\tResponseHeadersPolicy *HeadersPolicy\n}\n\n// Run translates HTTPProxies into DAG objects and\n// adds them to the DAG.\nfunc (p *HTTPProxyProcessor) Run(dag *DAG, source *KubernetesCache) {\n\tp.dag = dag\n\tp.source = source\n\tp.orphaned = make(map[types.NamespacedName]bool, len(p.orphaned))\n\n\t// reset the processor when we're done\n\tdefer func() {\n\t\tp.dag = nil\n\t\tp.source = nil\n\t\tp.orphaned = nil\n\t}()\n\n\tfor _, proxy := range p.validHTTPProxies() {\n\t\tp.computeHTTPProxy(proxy)\n\t}\n\n\tfor meta := range p.orphaned {\n\t\tproxy, ok := p.source.httpproxies[meta]\n\t\tif ok {\n\t\t\tpa, commit := p.dag.StatusCache.ProxyAccessor(proxy)\n\t\t\tpa.ConditionFor(status.ValidCondition).AddError(contour_api_v1.ConditionTypeOrphanedError,\n\t\t\t\t\"Orphaned\",\n\t\t\t\t\"this HTTPProxy is not part of a delegation chain from a root HTTPProxy\")\n\t\t\tcommit()\n\t\t}\n\t}\n}\n\nfunc (p *HTTPProxyProcessor) computeHTTPProxy(proxy *contour_api_v1.HTTPProxy) {\n\tpa, commit := p.dag.StatusCache.ProxyAccessor(proxy)\n\tvalidCond := pa.ConditionFor(status.ValidCondition)\n\n\tdefer commit()\n\n\tif proxy.Spec.VirtualHost == nil {\n\t\t// mark HTTPProxy as orphaned.\n\t\tp.orphaned[k8s.NamespacedNameOf(proxy)] = true\n\t\treturn\n\t}\n\n\thost := proxy.Spec.VirtualHost.Fqdn\n\tif isBlank(host) {\n\t\tvalidCond.AddError(contour_api_v1.ConditionTypeVirtualHostError, \"FQDNNotSpecified\",\n\t\t\t\"Spec.VirtualHost.Fqdn must be specified\")\n\t\treturn\n\t}\n\tpa.Vhost = host\n\n\t// Ensure root httpproxy lives in allowed namespace.\n\t// This check must be after we can determine the vhost in order to be able to calculate metrics correctly.\n\tif !p.rootAllowed(proxy.Namespace) {\n\t\tvalidCond.AddError(contour_api_v1.ConditionTypeRootNamespaceError, \"RootProxyNotAllowedInNamespace\",\n\t\t\t\"root HTTPProxy cannot be defined in this namespace\")\n\t\treturn\n\t}\n\n\tif strings.Contains(host, \"*\") {\n\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeVirtualHostError, \"WildCardNotAllowed\",\n\t\t\t\"Spec.VirtualHost.Fqdn %q cannot use wildcards\", host)\n\t\treturn\n\t}\n\n\tif len(proxy.Spec.Routes) == 0 && len(proxy.Spec.Includes) == 0 && proxy.Spec.TCPProxy == nil {\n\t\tvalidCond.AddError(contour_api_v1.ConditionTypeSpecError, \"NothingDefined\",\n\t\t\t\"HTTPProxy.Spec must have at least one Route, Include, or a TCPProxy\")\n\t\treturn\n\t}\n\n\tvar tlsEnabled bool\n\tif tls := proxy.Spec.VirtualHost.TLS; tls != nil {\n\t\tif tls.Passthrough && tls.EnableFallbackCertificate {\n\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTLSError, \"TLSIncompatibleFeatures\",\n\t\t\t\t\"Spec.VirtualHost.TLS: both Passthrough and enableFallbackCertificate were specified\")\n\t\t}\n\t\tif !isBlank(tls.SecretName) && tls.Passthrough {\n\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTLSError, \"TLSConfigNotValid\",\n\t\t\t\t\"Spec.VirtualHost.TLS: both Passthrough and SecretName were specified\")\n\t\t\treturn\n\t\t}\n\n\t\tif isBlank(tls.SecretName) && !tls.Passthrough {\n\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTLSError, \"TLSConfigNotValid\",\n\t\t\t\t\"Spec.VirtualHost.TLS: neither Passthrough nor SecretName were specified\")\n\t\t\treturn\n\t\t}\n\n\t\tif tls.Passthrough && tls.ClientValidation != nil {\n\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTLSError, \"TLSIncompatibleFeatures\",\n\t\t\t\t\"Spec.VirtualHost.TLS passthrough cannot be combined with tls.clientValidation\")\n\t\t\treturn\n\t\t}\n\n\t\ttlsEnabled = true\n\n\t\t// Attach secrets to TLS enabled vhosts.\n\t\tif !tls.Passthrough {\n\t\t\tsecretName := k8s.NamespacedNameFrom(tls.SecretName, k8s.DefaultNamespace(proxy.Namespace))\n\t\t\tsec, err := p.source.LookupSecret(secretName, validSecret)\n\t\t\tif err != nil {\n\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTLSError, \"SecretNotValid\",\n\t\t\t\t\t\"Spec.VirtualHost.TLS Secret %q is invalid: %s\", tls.SecretName, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !p.source.DelegationPermitted(secretName, proxy.Namespace) {\n\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTLSError, \"DelegationNotPermitted\",\n\t\t\t\t\t\"Spec.VirtualHost.TLS Secret %q certificate delegation not permitted\", tls.SecretName)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tsvhost := p.dag.EnsureSecureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_https\"})\n\t\t\tsvhost.Secret = sec\n\t\t\t// default to a minimum TLS version of 1.2 if it's not specified\n\t\t\tsvhost.MinTLSVersion = annotation.MinTLSVersion(tls.MinimumProtocolVersion, \"1.2\")\n\n\t\t\t// Check if FallbackCertificate && ClientValidation are both enabled in the same vhost\n\t\t\tif tls.EnableFallbackCertificate && tls.ClientValidation != nil {\n\t\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTLSError, \"TLSIncompatibleFeatures\",\n\t\t\t\t\t\"Spec.Virtualhost.TLS fallback & client validation are incompatible\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Fallback certificates and authorization are\n\t\t\t// incompatible because fallback installs the routes on\n\t\t\t// a separate HTTPConnectionManager. We can't have the\n\t\t\t// same routes installed on multiple managers with\n\t\t\t// inconsistent authorization settings.\n\t\t\tif tls.EnableFallbackCertificate && proxy.Spec.VirtualHost.AuthorizationConfigured() {\n\t\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTLSError, \"TLSIncompatibleFeatures\",\n\t\t\t\t\t\"Spec.Virtualhost.TLS fallback & client authorization are incompatible\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// If FallbackCertificate is enabled, but no cert passed, set error\n\t\t\tif tls.EnableFallbackCertificate {\n\t\t\t\tif p.FallbackCertificate == nil {\n\t\t\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTLSError, \"FallbackNotPresent\",\n\t\t\t\t\t\t\"Spec.Virtualhost.TLS enabled fallback but the fallback Certificate Secret is not configured in Contour configuration file\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tsec, err = p.source.LookupSecret(*p.FallbackCertificate, validSecret)\n\t\t\t\tif err != nil {\n\t\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTLSError, \"FallbackNotValid\",\n\t\t\t\t\t\t\"Spec.Virtualhost.TLS Secret %q fallback certificate is invalid: %s\", p.FallbackCertificate, err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif !p.source.DelegationPermitted(*p.FallbackCertificate, proxy.Namespace) {\n\t\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTLSError, \"FallbackNotDelegated\",\n\t\t\t\t\t\t\"Spec.VirtualHost.TLS fallback Secret %q is not configured for certificate delegation\", p.FallbackCertificate)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tsvhost.FallbackCertificate = sec\n\t\t\t}\n\n\t\t\t// Fill in DownstreamValidation when external client validation is enabled.\n\t\t\tif tls.ClientValidation != nil {\n\t\t\t\tdv := &PeerValidationContext{\n\t\t\t\t\tSkipClientCertValidation: tls.ClientValidation.SkipClientCertValidation,\n\t\t\t\t}\n\t\t\t\tif tls.ClientValidation.CACertificate != \"\" {\n\t\t\t\t\tsecretName := k8s.NamespacedNameFrom(tls.ClientValidation.CACertificate, k8s.DefaultNamespace(proxy.Namespace))\n\t\t\t\t\tcacert, err := p.source.LookupSecret(secretName, validCA)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t// PeerValidationContext is requested, but cert is missing or not configured.\n\t\t\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTLSError, \"ClientValidationInvalid\",\n\t\t\t\t\t\t\t\"Spec.VirtualHost.TLS client validation is invalid: invalid CA Secret %q: %s\", secretName, err)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tdv.CACertificate = cacert\n\t\t\t\t} else if !tls.ClientValidation.SkipClientCertValidation {\n\t\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTLSError, \"ClientValidationInvalid\",\n\t\t\t\t\t\t\"Spec.VirtualHost.TLS client validation is invalid: CA Secret must be specified\")\n\t\t\t\t}\n\t\t\t\tsvhost.DownstreamValidation = dv\n\t\t\t}\n\n\t\t\tif proxy.Spec.VirtualHost.AuthorizationConfigured() {\n\t\t\t\tauth := proxy.Spec.VirtualHost.Authorization\n\t\t\t\tref := defaultExtensionRef(auth.ExtensionServiceRef)\n\n\t\t\t\tif ref.APIVersion != contour_api_v1alpha1.GroupVersion.String() {\n\t\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeAuthError, \"AuthBadResourceVersion\",\n\t\t\t\t\t\t\"Spec.Virtualhost.Authorization.extensionRef specifies an unsupported resource version %q\", auth.ExtensionServiceRef.APIVersion)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// Lookup the extension service reference.\n\t\t\t\textensionName := types.NamespacedName{\n\t\t\t\t\tName:      ref.Name,\n\t\t\t\t\tNamespace: stringOrDefault(ref.Namespace, proxy.Namespace),\n\t\t\t\t}\n\n\t\t\t\text := p.dag.GetExtensionCluster(ExtensionClusterName(extensionName))\n\t\t\t\tif ext == nil {\n\t\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeAuthError, \"ExtensionServiceNotFound\",\n\t\t\t\t\t\t\"Spec.Virtualhost.Authorization.ServiceRef extension service %q not found\", extensionName)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tsvhost.AuthorizationService = ext\n\t\t\t\tsvhost.AuthorizationFailOpen = auth.FailOpen\n\n\t\t\t\ttimeout, err := timeout.Parse(auth.ResponseTimeout)\n\t\t\t\tif err != nil {\n\t\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeAuthError, \"AuthResponseTimeoutInvalid\",\n\t\t\t\t\t\t\"Spec.Virtualhost.Authorization.ResponseTimeout is invalid: %s\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif timeout.UseDefault() {\n\t\t\t\t\tsvhost.AuthorizationResponseTimeout = ext.TimeoutPolicy.ResponseTimeout\n\t\t\t\t} else {\n\t\t\t\t\tsvhost.AuthorizationResponseTimeout = timeout\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif proxy.Spec.TCPProxy != nil {\n\t\tif !tlsEnabled {\n\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTCPProxyError, \"TLSMustBeConfigured\",\n\t\t\t\t\"Spec.TCPProxy requires that either Spec.TLS.Passthrough or Spec.TLS.SecretName be set\")\n\t\t\treturn\n\t\t}\n\t\tif !p.processHTTPProxyTCPProxy(validCond, proxy, nil, host) {\n\t\t\treturn\n\t\t}\n\t}\n\n\troutes := p.computeRoutes(validCond, proxy, proxy, nil, nil, tlsEnabled)\n\tinsecure := p.dag.EnsureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_http\"})\n\tcp, err := toCORSPolicy(proxy.Spec.VirtualHost.CORSPolicy)\n\tif err != nil {\n\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeCORSError, \"PolicyDidNotParse\",\n\t\t\t\"Spec.VirtualHost.CORSPolicy: %s\", err)\n\t\treturn\n\t}\n\tinsecure.CORSPolicy = cp\n\n\trlp, err := rateLimitPolicy(proxy.Spec.VirtualHost.RateLimitPolicy)\n\tif err != nil {\n\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeRouteError, \"RateLimitPolicyNotValid\",\n\t\t\t\"Spec.VirtualHost.RateLimitPolicy is invalid: %s\", err)\n\t\treturn\n\t}\n\tinsecure.RateLimitPolicy = rlp\n\n\taddRoutes(insecure, routes)\n\n\t// if TLS is enabled for this virtual host and there is no tcp proxy defined,\n\t// then add routes to the secure virtualhost definition.\n\tif tlsEnabled && proxy.Spec.TCPProxy == nil {\n\t\tsecure := p.dag.EnsureSecureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_https\"})\n\t\tsecure.CORSPolicy = cp\n\n\t\trlp, err := rateLimitPolicy(proxy.Spec.VirtualHost.RateLimitPolicy)\n\t\tif err != nil {\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeRouteError, \"RateLimitPolicyNotValid\",\n\t\t\t\t\"Spec.VirtualHost.RateLimitPolicy is invalid: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tsecure.RateLimitPolicy = rlp\n\n\t\taddRoutes(secure, routes)\n\t}\n}\n\ntype vhost interface {\n\taddRoute(*Route)\n}\n\n// addRoutes adds all routes to the vhost supplied.\nfunc addRoutes(vhost vhost, routes []*Route) {\n\tfor _, route := range routes {\n\t\tvhost.addRoute(route)\n\t}\n}\n\nfunc (p *HTTPProxyProcessor) computeRoutes(\n\tvalidCond *contour_api_v1.DetailedCondition,\n\trootProxy *contour_api_v1.HTTPProxy,\n\tproxy *contour_api_v1.HTTPProxy,\n\tconditions []contour_api_v1.MatchCondition,\n\tvisited []*contour_api_v1.HTTPProxy,\n\tenforceTLS bool,\n) []*Route {\n\tfor _, v := range visited {\n\t\t// ensure we are not following an edge that produces a cycle\n\t\tvar path []string\n\t\tfor _, vir := range visited {\n\t\t\tpath = append(path, fmt.Sprintf(\"%s/%s\", vir.Namespace, vir.Name))\n\t\t}\n\t\tif v.Name == proxy.Name && v.Namespace == proxy.Namespace {\n\t\t\tpath = append(path, fmt.Sprintf(\"%s/%s\", proxy.Namespace, proxy.Name))\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeIncludeError, \"IncludeCreatesCycle\",\n\t\t\t\t\"include creates an include cycle: %s\", strings.Join(path, \" -> \"))\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tvisited = append(visited, proxy)\n\tvar routes []*Route\n\n\t// Check for duplicate conditions on the includes\n\tif includeMatchConditionsIdentical(proxy.Spec.Includes) {\n\t\tvalidCond.AddError(contour_api_v1.ConditionTypeIncludeError, \"DuplicateMatchConditions\",\n\t\t\t\"duplicate conditions defined on an include\")\n\t\treturn nil\n\t}\n\n\t// Loop over and process all includes\n\tfor _, include := range proxy.Spec.Includes {\n\t\tnamespace := include.Namespace\n\t\tif namespace == \"\" {\n\t\t\tnamespace = proxy.Namespace\n\t\t}\n\n\t\tincludedProxy, ok := p.source.httpproxies[types.NamespacedName{Name: include.Name, Namespace: namespace}]\n\t\tif !ok {\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeIncludeError, \"IncludeNotFound\",\n\t\t\t\t\"include %s/%s not found\", namespace, include.Name)\n\t\t\treturn nil\n\t\t}\n\t\tif includedProxy.Spec.VirtualHost != nil {\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeIncludeError, \"RootIncludesRoot\",\n\t\t\t\t\"root httpproxy cannot include another root httpproxy\")\n\t\t\treturn nil\n\t\t}\n\n\t\tif err := pathMatchConditionsValid(include.Conditions); err != nil {\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeIncludeError, \"PathMatchConditionsNotValid\",\n\t\t\t\t\"include: %s\", err)\n\t\t\treturn nil\n\t\t}\n\n\t\tinc, incCommit := p.dag.StatusCache.ProxyAccessor(includedProxy)\n\t\tincValidCond := inc.ConditionFor(status.ValidCondition)\n\t\troutes = append(routes, p.computeRoutes(incValidCond, rootProxy, includedProxy, append(conditions, include.Conditions...), visited, enforceTLS)...)\n\t\tincCommit()\n\n\t\t// dest is not an orphaned httpproxy, as there is an httpproxy that points to it\n\t\tdelete(p.orphaned, types.NamespacedName{Name: includedProxy.Name, Namespace: includedProxy.Namespace})\n\t}\n\n\tdynamicHeaders := map[string]string{\n\t\t\"CONTOUR_NAMESPACE\": proxy.Namespace,\n\t}\n\n\tfor _, route := range proxy.Spec.Routes {\n\t\tif err := pathMatchConditionsValid(route.Conditions); err != nil {\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeRouteError, \"PathMatchConditionsNotValid\",\n\t\t\t\t\"route: %s\", err)\n\t\t\treturn nil\n\t\t}\n\n\t\tconds := append(conditions, route.Conditions...)\n\n\t\t// Look for invalid header conditions on this route\n\t\tif err := headerMatchConditionsValid(conds); err != nil {\n\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeRouteError, \"HeaderMatchConditionsNotValid\",\n\t\t\t\terr.Error())\n\t\t\treturn nil\n\t\t}\n\n\t\treqHP, err := headersPolicyRoute(route.RequestHeadersPolicy, true /* allow Host */, dynamicHeaders)\n\t\tif err != nil {\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeRouteError, \"RequestHeadersPolicyInvalid\",\n\t\t\t\t\"%s on request headers\", err)\n\t\t\treturn nil\n\t\t}\n\n\t\trespHP, err := headersPolicyRoute(route.ResponseHeadersPolicy, false /* disallow Host */, dynamicHeaders)\n\t\tif err != nil {\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeRouteError, \"ResponseHeaderPolicyInvalid\",\n\t\t\t\t\"%s on response headers\", err)\n\t\t\treturn nil\n\t\t}\n\n\t\tif len(route.Services) < 1 {\n\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeRouteError, \"NoServicesPresent\",\n\t\t\t\t\"route.services must have at least one entry\")\n\t\t\treturn nil\n\t\t}\n\n\t\ttp, err := timeoutPolicy(route.TimeoutPolicy)\n\t\tif err != nil {\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeRouteError, \"TimeoutPolicyNotValid\",\n\t\t\t\t\"route.timeoutPolicy failed to parse: %s\", err)\n\t\t\treturn nil\n\t\t}\n\n\t\trlp, err := rateLimitPolicy(route.RateLimitPolicy)\n\t\tif err != nil {\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeRouteError, \"RateLimitPolicyNotValid\",\n\t\t\t\t\"route.rateLimitPolicy is invalid: %s\", err)\n\t\t\treturn nil\n\t\t}\n\n\t\trequestHashPolicies, lbPolicy := loadBalancerRequestHashPolicies(route.LoadBalancerPolicy, validCond)\n\n\t\tr := &Route{\n\t\t\tPathMatchCondition:    mergePathMatchConditions(conds),\n\t\t\tHeaderMatchConditions: mergeHeaderMatchConditions(conds),\n\t\t\tWebsocket:             route.EnableWebsockets,\n\t\t\tHTTPSUpgrade:          routeEnforceTLS(enforceTLS, route.PermitInsecure && !p.DisablePermitInsecure),\n\t\t\tTimeoutPolicy:         tp,\n\t\t\tRetryPolicy:           retryPolicy(route.RetryPolicy),\n\t\t\tRequestHeadersPolicy:  reqHP,\n\t\t\tResponseHeadersPolicy: respHP,\n\t\t\tRateLimitPolicy:       rlp,\n\t\t\tRequestHashPolicies:   requestHashPolicies,\n\t\t}\n\n\t\t// If the enclosing root proxy enabled authorization,\n\t\t// enable it on the route and propagate defaults\n\t\t// downwards.\n\t\tif rootProxy.Spec.VirtualHost.AuthorizationConfigured() {\n\t\t\t// When the ext_authz filter is added to a\n\t\t\t// vhost, it is in enabled state, but we can\n\t\t\t// disable it per route. We emulate disabling\n\t\t\t// it at the vhost layer by defaulting the state\n\t\t\t// from the root proxy.\n\t\t\tdisabled := rootProxy.Spec.VirtualHost.DisableAuthorization()\n\n\t\t\t// Take the default for enabling authorization\n\t\t\t// from the virtual host. If this route has a\n\t\t\t// policy, let that override.\n\t\t\tif route.AuthPolicy != nil {\n\t\t\t\tdisabled = route.AuthPolicy.Disabled\n\t\t\t}\n\n\t\t\tr.AuthDisabled = disabled\n\t\t\tr.AuthContext = route.AuthorizationContext(rootProxy.Spec.VirtualHost.AuthorizationContext())\n\t\t}\n\n\t\tif len(route.GetPrefixReplacements()) > 0 {\n\t\t\tif !r.HasPathPrefix() {\n\t\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypePrefixReplaceError, \"MustHavePrefix\",\n\t\t\t\t\t\"cannot specify prefix replacements without a prefix condition\")\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tif reason, err := prefixReplacementsAreValid(route.GetPrefixReplacements()); err != nil {\n\t\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypePrefixReplaceError, reason, err.Error())\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Note that we are guaranteed to always have a prefix\n\t\t\t// condition. Even if the CRD user didn't specify a\n\t\t\t// prefix condition, mergePathConditions() guarantees\n\t\t\t// a prefix of '/'.\n\t\t\troutingPrefix := r.PathMatchCondition.(*PrefixMatchCondition).Prefix\n\n\t\t\t// First, try to apply an exact prefix match.\n\t\t\tfor _, prefix := range route.GetPrefixReplacements() {\n\t\t\t\tif len(prefix.Prefix) > 0 && routingPrefix == prefix.Prefix {\n\t\t\t\t\tr.PrefixRewrite = prefix.Replacement\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there wasn't a match, we can apply the default replacement.\n\t\t\tif len(r.PrefixRewrite) == 0 {\n\t\t\t\tfor _, prefix := range route.GetPrefixReplacements() {\n\t\t\t\t\tif len(prefix.Prefix) == 0 {\n\t\t\t\t\t\tr.PrefixRewrite = prefix.Replacement\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tfor _, service := range route.Services {\n\t\t\tif service.Port < 1 || service.Port > 65535 {\n\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeServiceError, \"ServicePortInvalid\",\n\t\t\t\t\t\"service %q: port must be in the range 1-65535\", service.Name)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tm := types.NamespacedName{Name: service.Name, Namespace: proxy.Namespace}\n\t\t\ts, err := p.dag.EnsureService(m, intstr.FromInt(service.Port), p.source, p.EnableExternalNameService)\n\t\t\tif err != nil {\n\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeServiceError, \"ServiceUnresolvedReference\",\n\t\t\t\t\t\"Spec.Routes unresolved service reference: %s\", err)\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Determine the protocol to use to speak to this Cluster.\n\t\t\tprotocol, err := getProtocol(service, s)\n\t\t\tif err != nil {\n\t\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeServiceError, \"UnsupportedProtocol\", err.Error())\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tvar uv *PeerValidationContext\n\t\t\tif protocol == \"tls\" || protocol == \"h2\" {\n\t\t\t\t// we can only validate TLS connections to services that talk TLS\n\t\t\t\tuv, err = p.source.LookupUpstreamValidation(service.UpstreamValidation, proxy.Namespace)\n\t\t\t\tif err != nil {\n\t\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeServiceError, \"TLSUpstreamValidation\",\n\t\t\t\t\t\t\"Service [%s:%d] TLS upstream validation policy error: %s\", service.Name, service.Port, err)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdynamicHeaders[\"CONTOUR_SERVICE_NAME\"] = service.Name\n\t\t\tdynamicHeaders[\"CONTOUR_SERVICE_PORT\"] = strconv.Itoa(service.Port)\n\n\t\t\treqHP, err := headersPolicyService(p.RequestHeadersPolicy, service.RequestHeadersPolicy, dynamicHeaders)\n\t\t\tif err != nil {\n\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeServiceError, \"RequestHeadersPolicyInvalid\",\n\t\t\t\t\t\"%s on request headers\", err)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\trespHP, err := headersPolicyService(p.ResponseHeadersPolicy, service.ResponseHeadersPolicy, dynamicHeaders)\n\t\t\tif err != nil {\n\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeServiceError, \"ResponseHeadersPolicyInvalid\",\n\t\t\t\t\t\"%s on response headers\", err)\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tvar clientCertSecret *Secret\n\t\t\tif p.ClientCertificate != nil {\n\t\t\t\tclientCertSecret, err = p.source.LookupSecret(*p.ClientCertificate, validSecret)\n\t\t\t\tif err != nil {\n\t\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTLSError, \"SecretNotValid\",\n\t\t\t\t\t\t\"tls.envoy-client-certificate Secret %q is invalid: %s\", p.ClientCertificate, err)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc := &Cluster{\n\t\t\t\tUpstream:              s,\n\t\t\t\tLoadBalancerPolicy:    lbPolicy,\n\t\t\t\tWeight:                uint32(service.Weight),\n\t\t\t\tHTTPHealthCheckPolicy: httpHealthCheckPolicy(route.HealthCheckPolicy),\n\t\t\t\tUpstreamValidation:    uv,\n\t\t\t\tRequestHeadersPolicy:  reqHP,\n\t\t\t\tResponseHeadersPolicy: respHP,\n\t\t\t\tProtocol:              protocol,\n\t\t\t\tSNI:                   determineSNI(r.RequestHeadersPolicy, reqHP, s),\n\t\t\t\tDNSLookupFamily:       string(p.DNSLookupFamily),\n\t\t\t\tClientCertificate:     clientCertSecret,\n\t\t\t}\n\t\t\tif service.Mirror && r.MirrorPolicy != nil {\n\t\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeServiceError, \"OnlyOneMirror\",\n\t\t\t\t\t\"only one service per route may be nominated as mirror\")\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif service.Mirror {\n\t\t\t\tr.MirrorPolicy = &MirrorPolicy{\n\t\t\t\t\tCluster: c,\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr.Clusters = append(r.Clusters, c)\n\t\t\t}\n\t\t}\n\t\troutes = append(routes, r)\n\t}\n\n\troutes = expandPrefixMatches(routes)\n\n\treturn routes\n}\n\n// processHTTPProxyTCPProxy processes the spec.tcpproxy stanza in a HTTPProxy document\n// following the chain of spec.tcpproxy.include references. It returns true if processing\n// was successful, otherwise false if an error was encountered. The details of the error\n// will be recorded on the status of the relevant HTTPProxy object,\nfunc (p *HTTPProxyProcessor) processHTTPProxyTCPProxy(validCond *contour_api_v1.DetailedCondition, httpproxy *contour_api_v1.HTTPProxy, visited []*contour_api_v1.HTTPProxy, host string) bool {\n\ttcpproxy := httpproxy.Spec.TCPProxy\n\tif tcpproxy == nil {\n\t\t// nothing to do\n\t\treturn true\n\t}\n\n\tvisited = append(visited, httpproxy)\n\n\t// #2218 Allow support for both plural and singular \"Include\" for TCPProxy for the v1 API Spec\n\t// Prefer configurations for singular over the plural version\n\ttcpProxyInclude := tcpproxy.Include\n\tif tcpproxy.Include == nil {\n\t\ttcpProxyInclude = tcpproxy.IncludesDeprecated\n\t}\n\n\tif len(tcpproxy.Services) > 0 && tcpProxyInclude != nil {\n\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTCPProxyError, \"NoServicesAndInclude\",\n\t\t\t\"cannot specify services and include in the same httpproxy\")\n\t\treturn false\n\t}\n\n\tlbPolicy := loadBalancerPolicy(tcpproxy.LoadBalancerPolicy)\n\tswitch lbPolicy {\n\tcase LoadBalancerPolicyCookie, LoadBalancerPolicyRequestHash:\n\t\tvalidCond.AddWarningf(contour_api_v1.ConditionTypeTCPProxyError, \"IgnoredField\",\n\t\t\t\"ignoring field %q; %s load balancer policy is not supported for TCPProxies\",\n\t\t\t\"Spec.TCPProxy.LoadBalancerPolicy\", lbPolicy)\n\t\t// Reset load balancer policy to ensure the default.\n\t\tlbPolicy = \"\"\n\t}\n\n\tif len(tcpproxy.Services) > 0 {\n\t\tvar proxy TCPProxy\n\t\tfor _, service := range httpproxy.Spec.TCPProxy.Services {\n\t\t\tm := types.NamespacedName{Name: service.Name, Namespace: httpproxy.Namespace}\n\t\t\ts, err := p.dag.EnsureService(m, intstr.FromInt(service.Port), p.source, p.EnableExternalNameService)\n\t\t\tif err != nil {\n\t\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTCPProxyError, \"ServiceUnresolvedReference\",\n\t\t\t\t\t\"Spec.TCPProxy unresolved service reference: %s\", err)\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\t// Determine the protocol to use to speak to this Cluster.\n\t\t\tprotocol, err := getProtocol(service, s)\n\t\t\tif err != nil {\n\t\t\t\tvalidCond.AddError(contour_api_v1.ConditionTypeServiceError, \"UnsupportedProtocol\", err.Error())\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tproxy.Clusters = append(proxy.Clusters, &Cluster{\n\t\t\t\tUpstream:             s,\n\t\t\t\tProtocol:             protocol,\n\t\t\t\tLoadBalancerPolicy:   lbPolicy,\n\t\t\t\tTCPHealthCheckPolicy: tcpHealthCheckPolicy(tcpproxy.HealthCheckPolicy),\n\t\t\t\tSNI:                  s.ExternalName,\n\t\t\t})\n\t\t}\n\t\tsecure := p.dag.EnsureSecureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_https\"})\n\t\tsecure.TCPProxy = &proxy\n\n\t\treturn true\n\t}\n\n\tif tcpProxyInclude == nil {\n\t\t// We don't allow an empty TCPProxy object.\n\t\tvalidCond.AddError(contour_api_v1.ConditionTypeTCPProxyError, \"NothingDefined\",\n\t\t\t\"either services or inclusion must be specified\")\n\t\treturn false\n\t}\n\n\tnamespace := tcpProxyInclude.Namespace\n\tif namespace == \"\" {\n\t\t// we are delegating to another HTTPProxy in the same namespace\n\t\tnamespace = httpproxy.Namespace\n\t}\n\n\tm := types.NamespacedName{Name: tcpProxyInclude.Name, Namespace: namespace}\n\tdest, ok := p.source.httpproxies[m]\n\tif !ok {\n\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTCPProxyIncludeError, \"IncludeNotFound\",\n\t\t\t\"include %s/%s not found\", m.Namespace, m.Name)\n\t\treturn false\n\t}\n\n\tif dest.Spec.VirtualHost != nil {\n\n\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTCPProxyIncludeError, \"RootIncludesRoot\",\n\t\t\t\"root httpproxy cannot include another root httpproxy\")\n\t\treturn false\n\t}\n\n\t// dest is no longer an orphan\n\tdelete(p.orphaned, k8s.NamespacedNameOf(dest))\n\n\t// ensure we are not following an edge that produces a cycle\n\tvar path []string\n\tfor _, hp := range visited {\n\t\tpath = append(path, fmt.Sprintf(\"%s/%s\", hp.Namespace, hp.Name))\n\t}\n\tfor _, hp := range visited {\n\t\tif dest.Name == hp.Name && dest.Namespace == hp.Namespace {\n\t\t\tpath = append(path, fmt.Sprintf(\"%s/%s\", dest.Namespace, dest.Name))\n\t\t\tvalidCond.AddErrorf(contour_api_v1.ConditionTypeTCPProxyIncludeError, \"IncludeCreatesCycle\",\n\t\t\t\t\"include creates a cycle: %s\", strings.Join(path, \" -> \"))\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// follow the link and process the target tcpproxy\n\tinc, commit := p.dag.StatusCache.ProxyAccessor(dest)\n\tincValidCond := inc.ConditionFor(status.ValidCondition)\n\tdefer commit()\n\tok = p.processHTTPProxyTCPProxy(incValidCond, dest, visited, host)\n\treturn ok\n}\n\n// validHTTPProxies returns a slice of *contour_api_v1.HTTPProxy objects.\n// invalid HTTPProxy objects are excluded from the slice and their status\n// updated accordingly.\nfunc (p *HTTPProxyProcessor) validHTTPProxies() []*contour_api_v1.HTTPProxy {\n\t// ensure that a given fqdn is only referenced in a single HTTPProxy resource\n\tvar valid []*contour_api_v1.HTTPProxy\n\tfqdnHTTPProxies := make(map[string][]*contour_api_v1.HTTPProxy)\n\tfor _, proxy := range p.source.httpproxies {\n\t\tif proxy.Spec.VirtualHost == nil {\n\t\t\tvalid = append(valid, proxy)\n\t\t\tcontinue\n\t\t}\n\t\tfqdn := strings.ToLower(proxy.Spec.VirtualHost.Fqdn)\n\t\tfqdnHTTPProxies[fqdn] = append(fqdnHTTPProxies[fqdn], proxy)\n\t}\n\n\tfor fqdn, proxies := range fqdnHTTPProxies {\n\t\tswitch len(proxies) {\n\t\tcase 1:\n\t\t\tvalid = append(valid, proxies[0])\n\t\tdefault:\n\t\t\t// multiple proxies use the same fqdn. mark them as invalid.\n\t\t\tvar conflicting []string\n\t\t\tfor _, proxy := range proxies {\n\t\t\t\tconflicting = append(conflicting, proxy.Namespace+\"/\"+proxy.Name)\n\t\t\t}\n\t\t\tsort.Strings(conflicting) // sort for test stability\n\t\t\tmsg := fmt.Sprintf(\"fqdn %q is used in multiple HTTPProxies: %s\", fqdn, strings.Join(conflicting, \", \"))\n\t\t\tfor _, proxy := range proxies {\n\t\t\t\tpa, commit := p.dag.StatusCache.ProxyAccessor(proxy)\n\t\t\t\tpa.Vhost = fqdn\n\t\t\t\tpa.ConditionFor(status.ValidCondition).AddError(contour_api_v1.ConditionTypeVirtualHostError,\n\t\t\t\t\t\"DuplicateVhost\",\n\t\t\t\t\tmsg)\n\t\t\t\tcommit()\n\t\t\t}\n\t\t}\n\t}\n\treturn valid\n}\n\n// rootAllowed returns true if the HTTPProxy lives in a permitted root namespace.\nfunc (p *HTTPProxyProcessor) rootAllowed(namespace string) bool {\n\tif len(p.source.RootNamespaces) == 0 {\n\t\treturn true\n\t}\n\tfor _, ns := range p.source.RootNamespaces {\n\t\tif ns == namespace {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// expandPrefixMatches adds new Routes to account for the difference\n// between prefix replacement when matching on '/foo' and '/foo/'.\n//\n// The table below shows the behavior of Envoy prefix rewrite. If we\n// match on only `/foo` or `/foo/`, then the unwanted rewrites marked\n// with X can result. This means that we need to generate separate\n// prefix matches (and replacements) for these cases.\n//\n// | Matching Prefix | Replacement | Client Path | Rewritten Path |\n// |-----------------|-------------|-------------|----------------|\n// | `/foo`          | `/bar`      | `/foosball` |   `/barsball`  |\n// | `/foo`          | `/`         | `/foo/v1`   | X `//v1`       |\n// | `/foo/`         | `/bar`      | `/foo/type` | X `/bartype`   |\n// | `/foo`          | `/bar/`     | `/foosball` | X `/bar/sball` |\n// | `/foo/`         | `/bar/`     | `/foo/type` |   `/bar/type`  |\nfunc expandPrefixMatches(routes []*Route) []*Route {\n\tprefixedRoutes := map[string][]*Route{}\n\n\texpandedRoutes := []*Route{}\n\n\t// First, we group the Routes by their slash-consistent prefix match condition.\n\tfor _, r := range routes {\n\t\t// If there is no path prefix, we won't do any expansion, so skip it.\n\t\tif !r.HasPathPrefix() {\n\t\t\texpandedRoutes = append(expandedRoutes, r)\n\t\t}\n\n\t\troutingPrefix := r.PathMatchCondition.(*PrefixMatchCondition).Prefix\n\n\t\tif routingPrefix != \"/\" {\n\t\t\troutingPrefix = strings.TrimRight(routingPrefix, \"/\")\n\t\t}\n\n\t\tprefixedRoutes[routingPrefix] = append(prefixedRoutes[routingPrefix], r)\n\t}\n\n\tfor prefix, routes := range prefixedRoutes {\n\t\t// Propagate the Routes into the expanded set. Since\n\t\t// we have a slice of pointers, we can propagate here\n\t\t// prior to any Route modifications.\n\t\texpandedRoutes = append(expandedRoutes, routes...)\n\n\t\tswitch len(routes) {\n\t\tcase 1:\n\t\t\t// Don't modify if we are not doing a replacement.\n\t\t\tif len(routes[0].PrefixRewrite) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\troutingPrefix := routes[0].PathMatchCondition.(*PrefixMatchCondition).Prefix\n\n\t\t\t// There's no alternate forms for '/' :)\n\t\t\tif routingPrefix == \"/\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Shallow copy the Route. TODO(jpeach) deep copying would be more robust.\n\t\t\tnewRoute := *routes[0]\n\n\t\t\t// Now, make the original route handle '/foo' and the new route handle '/foo'.\n\t\t\troutes[0].PrefixRewrite = strings.TrimRight(routes[0].PrefixRewrite, \"/\")\n\t\t\troutes[0].PathMatchCondition = &PrefixMatchCondition{Prefix: prefix}\n\n\t\t\tnewRoute.PrefixRewrite = routes[0].PrefixRewrite + \"/\"\n\t\t\tnewRoute.PathMatchCondition = &PrefixMatchCondition{Prefix: prefix + \"/\"}\n\n\t\t\t// Since we trimmed trailing '/', it's possible that\n\t\t\t// we made the replacement empty. There's no such\n\t\t\t// thing as an empty rewrite; it's the same as\n\t\t\t// rewriting to '/'.\n\t\t\tif len(routes[0].PrefixRewrite) == 0 {\n\t\t\t\troutes[0].PrefixRewrite = \"/\"\n\t\t\t}\n\n\t\t\texpandedRoutes = append(expandedRoutes, &newRoute)\n\t\tcase 2:\n\t\t\t// This group routes on both '/foo' and\n\t\t\t// '/foo/' so we can't add any implicit prefix\n\t\t\t// matches. This is why we didn't filter out\n\t\t\t// routes that don't have replacements earlier.\n\t\t\tcontinue\n\t\tdefault:\n\t\t\t// This can't happen unless there are routes\n\t\t\t// with duplicate prefix paths.\n\t\t}\n\n\t}\n\n\treturn expandedRoutes\n}\n\nfunc getProtocol(service contour_api_v1.Service, s *Service) (string, error) {\n\t// Determine the protocol to use to speak to this Cluster.\n\tvar protocol string\n\tif service.Protocol != nil {\n\t\tprotocol = *service.Protocol\n\t\tswitch protocol {\n\t\tcase \"h2c\", \"h2\", \"tls\":\n\t\tdefault:\n\t\t\treturn \"\", fmt.Errorf(\"unsupported protocol: %v\", protocol)\n\t\t}\n\t} else {\n\t\tprotocol = s.Protocol\n\t}\n\n\treturn protocol, nil\n}\n\n// determineSNI decides what the SNI should be on the request. It is configured via RequestHeadersPolicy.Host key.\n// Policies set on service are used before policies set on a route. Otherwise the value of the externalService\n// is used if the route is configured to proxy to an externalService type.\nfunc determineSNI(routeRequestHeaders *HeadersPolicy, clusterRequestHeaders *HeadersPolicy, service *Service) string {\n\n\t// Service RequestHeadersPolicy take precedence\n\tif clusterRequestHeaders != nil {\n\t\tif clusterRequestHeaders.HostRewrite != \"\" {\n\t\t\treturn clusterRequestHeaders.HostRewrite\n\t\t}\n\t}\n\n\t// Route RequestHeadersPolicy take precedence after service\n\tif routeRequestHeaders != nil {\n\t\tif routeRequestHeaders.HostRewrite != \"\" {\n\t\t\treturn routeRequestHeaders.HostRewrite\n\t\t}\n\t}\n\n\treturn service.ExternalName\n}\n\nfunc toCORSPolicy(policy *contour_api_v1.CORSPolicy) (*CORSPolicy, error) {\n\tif policy == nil {\n\t\treturn nil, nil\n\t}\n\tmaxAge, err := timeout.ParseMaxAge(policy.MaxAge)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif maxAge.Duration().Seconds() < 0 {\n\t\treturn nil, fmt.Errorf(\"invalid max age value %q\", policy.MaxAge)\n\t}\n\treturn &CORSPolicy{\n\t\tAllowCredentials: policy.AllowCredentials,\n\t\tAllowHeaders:     toStringSlice(policy.AllowHeaders),\n\t\tAllowMethods:     toStringSlice(policy.AllowMethods),\n\t\tAllowOrigin:      policy.AllowOrigin,\n\t\tExposeHeaders:    toStringSlice(policy.ExposeHeaders),\n\t\tMaxAge:           maxAge,\n\t}, nil\n}\n\nfunc toStringSlice(hvs []contour_api_v1.CORSHeaderValue) []string {\n\ts := make([]string, len(hvs))\n\tfor i, v := range hvs {\n\t\ts[i] = string(v)\n\t}\n\treturn s\n}\n\nfunc includeMatchConditionsIdentical(includes []contour_api_v1.Include) bool {\n\tj := 0\n\tfor i := 1; i < len(includes); i++ {\n\t\t// Now compare each include's set of conditions\n\t\tfor _, cA := range includes[i].Conditions {\n\t\t\tfor _, cB := range includes[j].Conditions {\n\t\t\t\tif (cA.Prefix == cB.Prefix) && equality.Semantic.DeepEqual(cA.Header, cB.Header) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tj++\n\t}\n\treturn false\n}\n\n// isBlank indicates if a string contains nothing but blank characters.\nfunc isBlank(s string) bool {\n\treturn len(strings.TrimSpace(s)) == 0\n}\n\n// routeEnforceTLS determines if the route should redirect the user to a secure TLS listener\nfunc routeEnforceTLS(enforceTLS, permitInsecure bool) bool {\n\treturn enforceTLS && !permitInsecure\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dag\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n\n\t\"github.com/projectcontour/contour/internal/annotation\"\n\t\"github.com/projectcontour/contour/internal/k8s\"\n\t\"github.com/sirupsen/logrus\"\n\tnetworking_v1 \"k8s.io/api/networking/v1\"\n\t\"k8s.io/apimachinery/pkg/types\"\n)\n\n// IngressProcessor translates Ingresses into DAG\n// objects and adds them to the DAG.\ntype IngressProcessor struct {\n\tlogrus.FieldLogger\n\n\tdag    *DAG\n\tsource *KubernetesCache\n\n\t// ClientCertificate is the optional identifier of the TLS secret containing client certificate and\n\t// private key to be used when establishing TLS connection to upstream cluster.\n\tClientCertificate *types.NamespacedName\n\n\t// EnableExternalNameService allows processing of ExternalNameServices\n\t// This is normally disabled for security reasons.\n\t// See https://github.com/projectcontour/contour/security/advisories/GHSA-5ph6-qq5x-7jwc for details.\n\tEnableExternalNameService bool\n}\n\n// Run translates Ingresses into DAG objects and\n// adds them to the DAG.\nfunc (p *IngressProcessor) Run(dag *DAG, source *KubernetesCache) {\n\tp.dag = dag\n\tp.source = source\n\n\t// reset the processor when we're done\n\tdefer func() {\n\t\tp.dag = nil\n\t\tp.source = nil\n\t}()\n\n\t// setup secure vhosts if there is a matching secret\n\t// we do this first so that the set of active secure vhosts is stable\n\t// during computeIngresses.\n\tp.computeSecureVirtualhosts()\n\tp.computeIngresses()\n}\n\n// computeSecureVirtualhosts populates tls parameters of\n// secure virtual hosts.\nfunc (p *IngressProcessor) computeSecureVirtualhosts() {\n\tfor _, ing := range p.source.ingresses {\n\t\tfor _, tls := range ing.Spec.TLS {\n\t\t\tsecretName := k8s.NamespacedNameFrom(tls.SecretName, k8s.DefaultNamespace(ing.GetNamespace()))\n\t\t\tsec, err := p.source.LookupSecret(secretName, validSecret)\n\t\t\tif err != nil {\n\t\t\t\tp.WithError(err).\n\t\t\t\t\tWithField(\"name\", ing.GetName()).\n\t\t\t\t\tWithField(\"namespace\", ing.GetNamespace()).\n\t\t\t\t\tWithField(\"secret\", secretName).\n\t\t\t\t\tError(\"unresolved secret reference\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !p.source.DelegationPermitted(secretName, ing.GetNamespace()) {\n\t\t\t\tp.WithError(err).\n\t\t\t\t\tWithField(\"name\", ing.GetName()).\n\t\t\t\t\tWithField(\"namespace\", ing.GetNamespace()).\n\t\t\t\t\tWithField(\"secret\", secretName).\n\t\t\t\t\tError(\"certificate delegation not permitted\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// We have validated the TLS secrets, so we can go\n\t\t\t// ahead and create the SecureVirtualHost for this\n\t\t\t// Ingress.\n\t\t\tfor _, host := range tls.Hosts {\n\t\t\t\tsvhost := p.dag.EnsureSecureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_https\"})\n\t\t\t\tsvhost.Secret = sec\n\t\t\t\t// default to a minimum TLS version of 1.2 if it's not specified\n\t\t\t\tsvhost.MinTLSVersion = annotation.MinTLSVersion(annotation.ContourAnnotation(ing, \"tls-minimum-protocol-version\"), \"1.2\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *IngressProcessor) computeIngresses() {\n\t// deconstruct each ingress into routes and virtualhost entries\n\tfor _, ing := range p.source.ingresses {\n\n\t\t// rewrite the default ingress to a stock ingress rule.\n\t\trules := rulesFromSpec(ing.Spec)\n\t\tfor _, rule := range rules {\n\t\t\tp.computeIngressRule(ing, rule)\n\t\t}\n\t}\n}\n\nfunc (p *IngressProcessor) computeIngressRule(ing *networking_v1.Ingress, rule networking_v1.IngressRule) {\n\thost := rule.Host\n\n\t// If host name is blank, rewrite to Envoy's * default host.\n\tif host == \"\" {\n\t\thost = \"*\"\n\t}\n\n\tvar clientCertSecret *Secret\n\tvar err error\n\tif p.ClientCertificate != nil {\n\t\tclientCertSecret, err = p.source.LookupSecret(*p.ClientCertificate, validSecret)\n\t\tif err != nil {\n\t\t\tp.WithError(err).\n\t\t\t\tWithField(\"name\", ing.GetName()).\n\t\t\t\tWithField(\"namespace\", ing.GetNamespace()).\n\t\t\t\tWithField(\"secret\", p.ClientCertificate).\n\t\t\t\tError(\"tls.envoy-client-certificate contains unresolved secret reference\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tfor _, httppath := range httppaths(rule) {\n\t\tpath := stringOrDefault(httppath.Path, \"/\")\n\t\t// Default to implementation specific path matching if not set.\n\t\tpathType := derefPathTypeOr(httppath.PathType, networking_v1.PathTypeImplementationSpecific)\n\t\tbe := httppath.Backend\n\t\tm := types.NamespacedName{Name: be.Service.Name, Namespace: ing.Namespace}\n\n\t\tvar port intstr.IntOrString\n\t\tif len(be.Service.Port.Name) > 0 {\n\t\t\tport = intstr.FromString(be.Service.Port.Name)\n\t\t} else {\n\t\t\tport = intstr.FromInt(int(be.Service.Port.Number))\n\t\t}\n\n\t\ts, err := p.dag.EnsureService(m, port, p.source, p.EnableExternalNameService)\n\t\tif err != nil {\n\t\t\tp.WithError(err).\n\t\t\t\tWithField(\"name\", ing.GetName()).\n\t\t\t\tWithField(\"namespace\", ing.GetNamespace()).\n\t\t\t\tWithField(\"service\", be.Service.Name).\n\t\t\t\tError(\"unresolved service reference\")\n\t\t\tcontinue\n\t\t}\n\n\t\tr, err := route(ing, rule.Host, path, pathType, s, clientCertSecret, p.FieldLogger)\n\t\tif err != nil {\n\t\t\tp.WithError(err).\n\t\t\t\tWithField(\"name\", ing.GetName()).\n\t\t\t\tWithField(\"namespace\", ing.GetNamespace()).\n\t\t\t\tWithField(\"regex\", path).\n\t\t\t\tErrorf(\"path regex is not valid\")\n\t\t\treturn\n\t\t}\n\n\t\t// should we create port 80 routes for this ingress\n\t\tif annotation.TLSRequired(ing) || annotation.HTTPAllowed(ing) {\n\t\t\tvhost := p.dag.EnsureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_http\"})\n\t\t\tvhost.addRoute(r)\n\t\t}\n\n\t\t// computeSecureVirtualhosts will have populated b.securevirtualhosts\n\t\t// with the names of tls enabled ingress objects. If host exists then\n\t\t// it is correctly configured for TLS.\n\t\tif svh := p.dag.GetSecureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_https\"}); svh != nil && host != \"*\" {\n\t\t\tsvh.addRoute(r)\n\t\t}\n\t}\n}\n\nconst singleDNSLabelWildcardRegex = \"^[a-z0-9]([-a-z0-9]*[a-z0-9])?\"\n\nvar _ = regexp.MustCompile(singleDNSLabelWildcardRegex)\n\n// route builds a dag.Route for the supplied Ingress.\nfunc route(ingress *networking_v1.Ingress, host string, path string, pathType networking_v1.PathType, service *Service, clientCertSecret *Secret, log logrus.FieldLogger) (*Route, error) {\n\tlog = log.WithFields(logrus.Fields{\n\t\t\"name\":      ingress.Name,\n\t\t\"namespace\": ingress.Namespace,\n\t})\n\n\tr := &Route{\n\t\tHTTPSUpgrade:  annotation.TLSRequired(ingress),\n\t\tWebsocket:     annotation.WebsocketRoutes(ingress)[path],\n\t\tTimeoutPolicy: ingressTimeoutPolicy(ingress, log),\n\t\tRetryPolicy:   ingressRetryPolicy(ingress, log),\n\t\tClusters: []*Cluster{{\n\t\t\tUpstream:          service,\n\t\t\tProtocol:          service.Protocol,\n\t\t\tClientCertificate: clientCertSecret,\n\t\t}},\n\t}\n\n\tswitch pathType {\n\tcase networking_v1.PathTypePrefix:\n\t\tprefixMatchType := PrefixMatchSegment\n\t\t// An \"all paths\" prefix should be treated as a generic string prefix\n\t\t// match.\n\t\tif path == \"/\" {\n\t\t\tprefixMatchType = PrefixMatchString\n\t\t} else {\n\t\t\t// Strip trailing slashes. Ensures /foo matches prefix /foo/\n\t\t\tpath = strings.TrimRight(path, \"/\")\n\t\t}\n\t\tr.PathMatchCondition = &PrefixMatchCondition{Prefix: path, PrefixMatchType: prefixMatchType}\n\tcase networking_v1.PathTypeExact:\n\t\tr.PathMatchCondition = &ExactMatchCondition{Path: path}\n\tcase networking_v1.PathTypeImplementationSpecific:\n\t\t// If a path \"looks like\" a regex we give a regex path match.\n\t\t// Otherwise you get a string prefix match.\n\t\tif strings.ContainsAny(path, \"^+*[]%\") {\n\t\t\t// validate the regex\n\t\t\tif err := ValidateRegex(path); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tr.PathMatchCondition = &RegexMatchCondition{Regex: path}\n\t\t} else {\n\t\t\tr.PathMatchCondition = &PrefixMatchCondition{Prefix: path, PrefixMatchType: PrefixMatchString}\n\t\t}\n\t}\n\n\t// If we have a wildcard match, add a header match regex rule to match the\n\t// hostname so we can be sure to only match one DNS label. This is required\n\t// as Envoy's virtualhost hostname wildcard matching can match multiple\n\t// labels. This match ignores a port in the hostname in case it is present.\n\tif strings.HasPrefix(host, \"*.\") {\n\t\tr.HeaderMatchConditions = []HeaderMatchCondition{\n\t\t\t{\n\t\t\t\t// Internally Envoy uses the HTTP/2 \":authority\" header in\n\t\t\t\t// place of the HTTP/1 \"host\" header.\n\t\t\t\t// See: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#config-route-v3-headermatcher\n\t\t\t\tName:      \":authority\",\n\t\t\t\tMatchType: HeaderMatchTypeRegex,\n\t\t\t\tValue:     singleDNSLabelWildcardRegex + regexp.QuoteMeta(host[1:]),\n\t\t\t},\n\t\t}\n\t}\n\n\treturn r, nil\n}\n\n// rulesFromSpec merges the IngressSpec's Rules with a synthetic\n// rule representing the default backend.\n// Prepend the default backend so it can be overridden by later rules.\nfunc rulesFromSpec(spec networking_v1.IngressSpec) []networking_v1.IngressRule {\n\trules := spec.Rules\n\tif backend := spec.DefaultBackend; backend != nil {\n\t\trule := defaultBackendRule(backend)\n\t\trules = append([]networking_v1.IngressRule{rule}, rules...)\n\t}\n\treturn rules\n}\n\n// defaultBackendRule returns an IngressRule that represents the IngressBackend.\nfunc defaultBackendRule(be *networking_v1.IngressBackend) networking_v1.IngressRule {\n\treturn networking_v1.IngressRule{\n\t\tIngressRuleValue: networking_v1.IngressRuleValue{\n\t\t\tHTTP: &networking_v1.HTTPIngressRuleValue{\n\t\t\t\tPaths: []networking_v1.HTTPIngressPath{{\n\t\t\t\t\tBackend: networking_v1.IngressBackend{\n\t\t\t\t\t\tService: &networking_v1.IngressServiceBackend{\n\t\t\t\t\t\t\tName: be.Service.Name,\n\t\t\t\t\t\t\tPort: be.Service.Port,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc stringOrDefault(s, def string) string {\n\tif s == \"\" {\n\t\treturn def\n\t}\n\treturn s\n}\n\nfunc derefPathTypeOr(ptr *networking_v1.PathType, def networking_v1.PathType) networking_v1.PathType {\n\tif ptr != nil {\n\t\treturn *ptr\n\t}\n\treturn def\n}\n\n// httppaths returns a slice of HTTPIngressPath values for a given IngressRule.\n// In the case that the IngressRule contains no valid HTTPIngressPaths, a\n// nil slice is returned.\nfunc httppaths(rule networking_v1.IngressRule) []networking_v1.HTTPIngressPath {\n\tif rule.IngressRuleValue.HTTP == nil {\n\t\t// rule.IngressRuleValue.HTTP value is optional.\n\t\treturn nil\n\t}\n\treturn rule.IngressRuleValue.HTTP.Paths\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dag\n\nimport (\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-cmp/cmp/cmpopts\"\n\tcontour_api_v1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"\n\t\"github.com/projectcontour/contour/internal/fixture\"\n\t\"github.com/projectcontour/contour/internal/status\"\n\t\"github.com/stretchr/testify/assert\"\n\tv1 \"k8s.io/api/core/v1\"\n\tnetworking_v1 \"k8s.io/api/networking/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n\t\"k8s.io/utils/pointer\"\n\tgatewayapi_v1alpha1 \"sigs.k8s.io/gateway-api/apis/v1alpha1\"\n)\n\nfunc TestDAGStatus(t *testing.T) {\n\n\ttype testcase struct {\n\t\tobjs                []interface{}\n\t\tfallbackCertificate *types.NamespacedName\n\t\twant                map[types.NamespacedName]contour_api_v1.DetailedCondition\n\t}\n\n\trun := func(t *testing.T, desc string, tc testcase) {\n\t\tt.Helper()\n\t\tt.Run(desc, func(t *testing.T) {\n\t\t\tt.Helper()\n\t\t\tbuilder := Builder{\n\t\t\t\tSource: KubernetesCache{\n\t\t\t\t\tRootNamespaces: []string{\"roots\", \"marketing\"},\n\t\t\t\t\tFieldLogger:    fixture.NewTestLogger(t),\n\t\t\t\t},\n\t\t\t\tProcessors: []Processor{\n\t\t\t\t\t&IngressProcessor{\n\t\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t\t},\n\t\t\t\t\t&HTTPProxyProcessor{\n\t\t\t\t\t\tFallbackCertificate: tc.fallbackCertificate,\n\t\t\t\t\t},\n\t\t\t\t\t&GatewayAPIProcessor{\n\t\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t\t},\n\t\t\t\t\t&ListenerProcessor{},\n\t\t\t\t},\n\t\t\t}\n\t\t\tfor _, o := range tc.objs {\n\t\t\t\tbuilder.Source.Insert(o)\n\t\t\t}\n\t\t\tdag := builder.Build()\n\t\t\tt.Logf(\"%#v\\n\", dag.StatusCache)\n\n\t\t\tgot := make(map[types.NamespacedName]contour_api_v1.DetailedCondition)\n\t\t\tfor _, pu := range dag.StatusCache.GetProxyUpdates() {\n\t\t\t\tgot[pu.Fullname] = *pu.Conditions[status.ValidCondition]\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.want, got)\n\t\t})\n\t}\n\n\t// proxyNoFQDN is invalid because it does not specify and FQDN\n\tproxyNoFQDN := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace:  \"roots\",\n\t\t\tName:       \"parent\",\n\t\t\tGeneration: 23,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"foo\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// Tests using common fixtures\n\trun(t, \"root proxy does not specify FQDN\", testcase{\n\t\tobjs: []interface{}{proxyNoFQDN},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyNoFQDN.Name, Namespace: proxyNoFQDN.Namespace}: fixture.NewValidCondition().WithGeneration(proxyNoFQDN.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"FQDNNotSpecified\", \"Spec.VirtualHost.Fqdn must be specified\"),\n\t\t},\n\t})\n\n\t// Simple Valid HTTPProxy\n\tproxyValidHomeService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace:  \"roots\",\n\t\t\tName:       \"example\",\n\t\t\tGeneration: 24,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"valid proxy\", testcase{\n\t\tobjs: []interface{}{proxyValidHomeService, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyValidHomeService.Name, Namespace: proxyValidHomeService.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyValidHomeService.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n\n\t// Multiple Includes, one invalid\n\tproxyMultiIncludeOneInvalid := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace:  \"roots\",\n\t\t\tName:       \"parent\",\n\t\t\tGeneration: 45,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName: \"validChild\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tName: \"invalidChild\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/bar\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyIncludeValidChild := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"parentvalidchild\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName: \"validChild\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyChildValidFoo2 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace:  \"roots\",\n\t\t\tName:       \"validChild\",\n\t\t\tGeneration: 1,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"foo2\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyChildInvalidBadPort := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"invalidChild\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"foo3\",\n\t\t\t\t\tPort: 12345678,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy has multiple includes, one is invalid\", testcase{\n\t\tobjs: []interface{}{proxyMultiIncludeOneInvalid, proxyChildValidFoo2, proxyChildInvalidBadPort, fixture.ServiceRootsFoo2, fixture.ServiceRootsFoo3InvalidPort},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyChildValidFoo2.Name, Namespace: proxyChildValidFoo2.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyChildValidFoo2.Generation).\n\t\t\t\tValid(),\n\t\t\t{Name: proxyChildInvalidBadPort.Name, Namespace: proxyChildInvalidBadPort.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyChildInvalidBadPort.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeServiceError, \"ServicePortInvalid\", `service \"foo3\": port must be in the range 1-65535`),\n\t\t\t{Name: proxyMultiIncludeOneInvalid.Name, Namespace: proxyMultiIncludeOneInvalid.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyMultiIncludeOneInvalid.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n\n\trun(t, \"multi-parent child is not orphaned when one of the parents is invalid\", testcase{\n\t\tobjs: []interface{}{proxyNoFQDN, proxyChildValidFoo2, proxyIncludeValidChild, fixture.ServiceRootsKuard, fixture.ServiceRootsFoo2},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyNoFQDN.Name, Namespace: proxyNoFQDN.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyNoFQDN.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"FQDNNotSpecified\", \"Spec.VirtualHost.Fqdn must be specified\"),\n\t\t\t{Name: proxyChildValidFoo2.Name, Namespace: proxyChildValidFoo2.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyChildValidFoo2.Generation).\n\t\t\t\tValid(),\n\t\t\t{Name: proxyIncludeValidChild.Name, Namespace: proxyIncludeValidChild.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyIncludeValidChild.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n\n\tingressSharedService := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"nginx\",\n\t\t\tNamespace: fixture.ServiceRootsNginx.Namespace,\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tTLS: []networking_v1.IngressTLS{{\n\t\t\t\tHosts:      []string{\"example.com\"},\n\t\t\t\tSecretName: fixture.SecretRootsCert.Name,\n\t\t\t}},\n\t\t\tRules: []networking_v1.IngressRule{{\n\t\t\t\tHost:             \"example.com\",\n\t\t\t\tIngressRuleValue: ingressrulev1value(backendv1(fixture.ServiceRootsNginx.Name, intstr.FromInt(80))),\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyTCPSharedService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"nginx\",\n\t\t\tNamespace: fixture.ServiceRootsNginx.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: fixture.SecretRootsCert.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsNginx.Name,\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t// issue 1399\n\trun(t, \"service shared across ingress and httpproxy tcpproxy\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tfixture.SecretRootsCert, fixture.ServiceRootsNginx, ingressSharedService, proxyTCPSharedService,\n\t\t},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPSharedService.Name, Namespace: proxyTCPSharedService.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyTCPSharedService.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n\n\tproxyDelegatedTCPTLS := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"app-with-tls-delegation\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"app-with-tls-delegation.127.0.0.1.nip.io\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: fixture.SecretProjectContourCert.Namespace + \"/\" + fixture.SecretProjectContourCert.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"sample-app\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t// issue 1347\n\trun(t, \"tcpproxy with tls delegation failure\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tfixture.SecretProjectContourCert,\n\t\t\tproxyDelegatedTCPTLS,\n\t\t},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyDelegatedTCPTLS.Name, Namespace: proxyDelegatedTCPTLS.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyDelegatedTCPTLS.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"DelegationNotPermitted\", `Spec.VirtualHost.TLS Secret \"projectcontour/default-ssl-cert\" certificate delegation not permitted`),\n\t\t},\n\t})\n\n\tproxyDelegatedTLS := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"app-with-tls-delegation\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"app-with-tls-delegation.127.0.0.1.nip.io\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: fixture.SecretProjectContourCert.Namespace + \"/\" + fixture.SecretProjectContourCert.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"sample-app\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// issue 1348\n\trun(t, \"routes with tls delegation failure\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tfixture.SecretProjectContourCert,\n\t\t\tproxyDelegatedTLS,\n\t\t},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyDelegatedTLS.Name, Namespace: proxyDelegatedTLS.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyDelegatedTCPTLS.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"DelegationNotPermitted\", `Spec.VirtualHost.TLS Secret \"projectcontour/default-ssl-cert\" certificate delegation not permitted`),\n\t\t},\n\t})\n\n\tserviceTLSPassthrough := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"tls-passthrough\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"https\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       443,\n\t\t\t\tTargetPort: intstr.FromInt(443),\n\t\t\t}, {\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       80,\n\t\t\t\tTargetPort: intstr.FromInt(80),\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyPassthroughProxyNonSecure := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard-tcp\",\n\t\t\tNamespace: serviceTLSPassthrough.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"kuard.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: serviceTLSPassthrough.Name,\n\t\t\t\t\tPort: 80, // proxy non secure traffic to port 80\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: serviceTLSPassthrough.Name,\n\t\t\t\t\tPort: 443, // ssl passthrough to secure port\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\t// issue 910\n\trun(t, \"non tls routes can be combined with tcp proxy\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tserviceTLSPassthrough,\n\t\t\tproxyPassthroughProxyNonSecure,\n\t\t},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyPassthroughProxyNonSecure.Name, Namespace: proxyPassthroughProxyNonSecure.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyPassthroughProxyNonSecure.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n\n\tproxyMultipleIncludersSite1 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"site1\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"site1.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"www\",\n\t\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyMultipleIncludersSite2 := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"site2\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"site2.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"www\",\n\t\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyMultiIncludeChild := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"www\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"two root httpproxies with different hostnames delegated to the same object are valid\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tfixture.ServiceRootsKuard, proxyMultipleIncludersSite1, proxyMultipleIncludersSite2, proxyMultiIncludeChild,\n\t\t},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyMultipleIncludersSite1.Name, Namespace: proxyMultipleIncludersSite1.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyMultipleIncludersSite1.Generation).\n\t\t\t\tValid(),\n\t\t\t{Name: proxyMultipleIncludersSite2.Name, Namespace: proxyMultipleIncludersSite2.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyMultipleIncludersSite2.Generation).\n\t\t\t\tValid(),\n\t\t\t{Name: proxyMultiIncludeChild.Name, Namespace: proxyMultiIncludeChild.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyMultiIncludeChild.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n\n\t// proxyInvalidNegativePortHomeService is invalid because it contains a service with negative port\n\tproxyInvalidNegativePortHomeService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: -80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"invalid port in service\", testcase{\n\t\tobjs: []interface{}{proxyInvalidNegativePortHomeService},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidNegativePortHomeService.Name, Namespace: proxyInvalidNegativePortHomeService.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidNegativePortHomeService.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeServiceError, \"ServicePortInvalid\", `service \"home\": port must be in the range 1-65535`),\n\t\t},\n\t})\n\n\t// proxyInvalidOutsideRootNamespace is invalid because it lives outside the roots namespace\n\tproxyInvalidOutsideRootNamespace := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"finance\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foobar\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"root proxy outside of roots namespace\", testcase{\n\t\tobjs: []interface{}{proxyInvalidOutsideRootNamespace},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidOutsideRootNamespace.Name, Namespace: proxyInvalidOutsideRootNamespace.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidNegativePortHomeService.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeRootNamespaceError, \"RootProxyNotAllowedInNamespace\", \"root HTTPProxy cannot be defined in this namespace\"),\n\t\t},\n\t})\n\n\t// proxyInvalidIncludeCycle is invalid because it delegates to itself, producing a cycle\n\tproxyInvalidIncludeCycle := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"self\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"self\",\n\t\t\t\tNamespace: \"roots\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"green\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy self-edge produces a cycle\", testcase{\n\t\tobjs: []interface{}{proxyInvalidIncludeCycle, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidIncludeCycle.Name, Namespace: proxyInvalidIncludeCycle.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidIncludeCycle.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeIncludeError, \"RootIncludesRoot\", \"root httpproxy cannot include another root httpproxy\"),\n\t\t},\n\t})\n\n\t// proxyIncludesProxyWithIncludeCycle delegates to proxy8, which is invalid because proxy8 delegates back to proxy8\n\tproxyIncludesProxyWithIncludeCycle := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"parent\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"child\",\n\t\t\t\tNamespace: \"roots\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyIncludedChildInvalidIncludeCycle := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"child\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"child\",\n\t\t\t\tNamespace: \"roots\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy child delegates to itself, producing a cycle\", testcase{\n\t\tobjs: []interface{}{proxyIncludesProxyWithIncludeCycle, proxyIncludedChildInvalidIncludeCycle},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyIncludesProxyWithIncludeCycle.Name, Namespace: proxyIncludesProxyWithIncludeCycle.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyIncludesProxyWithIncludeCycle.Generation).Valid(),\n\t\t\t{Name: proxyIncludedChildInvalidIncludeCycle.Name, Namespace: proxyIncludedChildInvalidIncludeCycle.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyIncludedChildInvalidIncludeCycle.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeIncludeError, \"IncludeCreatesCycle\", \"include creates an include cycle: roots/parent -> roots/child -> roots/child\"),\n\t\t},\n\t})\n\n\trun(t, \"proxy orphaned route\", testcase{\n\t\tobjs: []interface{}{proxyIncludedChildInvalidIncludeCycle},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyIncludedChildInvalidIncludeCycle.Name, Namespace: proxyIncludedChildInvalidIncludeCycle.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyIncludedChildInvalidIncludeCycle.Generation).\n\t\t\t\tOrphaned(),\n\t\t},\n\t})\n\n\tproxyIncludedChildValid := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"validChild\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"foo2\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\t// proxyNotRootIncludeRootProxy delegates to proxyWildCardFQDN but it is invalid because it is missing fqdn\n\tproxyNotRootIncludeRootProxy := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"invalidParent\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"validChild\",\n\t\t\t\tNamespace: \"roots\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy invalid parent orphans child\", testcase{\n\t\tobjs: []interface{}{proxyNotRootIncludeRootProxy, proxyIncludedChildValid},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyNotRootIncludeRootProxy.Name, Namespace: proxyNotRootIncludeRootProxy.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyNotRootIncludeRootProxy.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"FQDNNotSpecified\", \"Spec.VirtualHost.Fqdn must be specified\"),\n\t\t\t{Name: proxyIncludedChildValid.Name, Namespace: proxyIncludedChildValid.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyIncludedChildValid.Generation).\n\t\t\t\tOrphaned(),\n\t\t},\n\t})\n\n\t// proxyWildCardFQDN is invalid because it contains a wildcarded fqdn\n\tproxyWildCardFQDN := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.*.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy invalid FQDN contains wildcard\", testcase{\n\t\tobjs: []interface{}{proxyWildCardFQDN},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyWildCardFQDN.Name, Namespace: proxyWildCardFQDN.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyWildCardFQDN.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"WildCardNotAllowed\", `Spec.VirtualHost.Fqdn \"example.*.com\" cannot use wildcards`),\n\t\t},\n\t})\n\n\t// proxyInvalidServiceInvalid is invalid because it references an invalid service\n\tproxyInvalidServiceInvalid := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"invalidir\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"invalid\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy missing service is invalid\", testcase{\n\t\tobjs: []interface{}{proxyInvalidServiceInvalid},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidServiceInvalid.Name, Namespace: proxyInvalidServiceInvalid.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidServiceInvalid.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeServiceError, \"ServiceUnresolvedReference\", `Spec.Routes unresolved service reference: service \"roots/invalid\" not found`),\n\t\t},\n\t})\n\n\t// proxyInvalidServicePortInvalid is invalid because it references an invalid port on a service\n\tproxyInvalidServicePortInvalid := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"invalidir\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 9999,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy with service missing port is invalid\", testcase{\n\t\tobjs: []interface{}{proxyInvalidServicePortInvalid, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidServicePortInvalid.Name, Namespace: proxyInvalidServicePortInvalid.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidServiceInvalid.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeServiceError, \"ServiceUnresolvedReference\", `Spec.Routes unresolved service reference: port \"9999\" on service \"roots/home\" not matched`),\n\t\t},\n\t})\n\n\tproxyValidExampleCom := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"example-com\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyValidReuseExampleCom := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"other-example\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyValidReuseCaseExampleCom := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"case-example\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"EXAMPLE.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"kuard\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"conflicting proxies due to fqdn reuse\", testcase{\n\t\tobjs: []interface{}{proxyValidExampleCom, proxyValidReuseExampleCom},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyValidExampleCom.Name, Namespace: proxyValidExampleCom.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyValidExampleCom.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"DuplicateVhost\", `fqdn \"example.com\" is used in multiple HTTPProxies: roots/example-com, roots/other-example`),\n\t\t\t{Name: proxyValidReuseExampleCom.Name, Namespace: proxyValidReuseExampleCom.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyValidReuseExampleCom.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"DuplicateVhost\", `fqdn \"example.com\" is used in multiple HTTPProxies: roots/example-com, roots/other-example`),\n\t\t},\n\t})\n\n\trun(t, \"conflicting proxies due to fqdn reuse with uppercase/lowercase\", testcase{\n\t\tobjs: []interface{}{proxyValidExampleCom, proxyValidReuseCaseExampleCom},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyValidExampleCom.Name, Namespace: proxyValidExampleCom.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyValidExampleCom.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"DuplicateVhost\", `fqdn \"example.com\" is used in multiple HTTPProxies: roots/case-example, roots/example-com`),\n\t\t\t{Name: proxyValidReuseCaseExampleCom.Name, Namespace: proxyValidReuseCaseExampleCom.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyValidReuseCaseExampleCom.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"DuplicateVhost\", `fqdn \"example.com\" is used in multiple HTTPProxies: roots/case-example, roots/example-com`),\n\t\t},\n\t})\n\n\tproxyRootIncludesRoot := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"root-blog\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"blog.containersteve.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: \"blog-containersteve-com\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"blog\",\n\t\t\t\tNamespace: \"marketing\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyRootIncludedByRoot := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"blog\",\n\t\t\tNamespace: fixture.ServiceMarketingGreen.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"blog.containersteve.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: \"blog-containersteve-com\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceMarketingGreen.Name,\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"root proxy including another root\", testcase{\n\t\tobjs: []interface{}{proxyRootIncludesRoot, proxyRootIncludedByRoot},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyRootIncludesRoot.Name, Namespace: proxyRootIncludesRoot.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyRootIncludesRoot.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"DuplicateVhost\", `fqdn \"blog.containersteve.com\" is used in multiple HTTPProxies: marketing/blog, roots/root-blog`),\n\t\t\t{Name: proxyRootIncludedByRoot.Name, Namespace: proxyRootIncludedByRoot.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyRootIncludedByRoot.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeVirtualHostError, \"DuplicateVhost\", `fqdn \"blog.containersteve.com\" is used in multiple HTTPProxies: marketing/blog, roots/root-blog`),\n\t\t},\n\t})\n\n\tproxyIncludesRootDifferentFQDN := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"root-blog\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"blog.containersteve.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"blog\",\n\t\t\t\tNamespace: \"marketing\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyRootIncludedByRootDiffFQDN := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"blog\",\n\t\t\tNamespace: fixture.ServiceMarketingGreen.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"www.containersteve.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceMarketingGreen.Name,\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"root proxy including another root w/ different hostname\", testcase{\n\t\tobjs: []interface{}{proxyIncludesRootDifferentFQDN, proxyRootIncludedByRootDiffFQDN, fixture.ServiceMarketingGreen},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyIncludesRootDifferentFQDN.Name, Namespace: proxyIncludesRootDifferentFQDN.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyIncludesRootDifferentFQDN.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeIncludeError, \"RootIncludesRoot\", \"root httpproxy cannot include another root httpproxy\"),\n\t\t\t{Name: proxyRootIncludedByRootDiffFQDN.Name, Namespace: proxyRootIncludedByRootDiffFQDN.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyRootIncludedByRootDiffFQDN.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n\n\tproxyValidIncludeBlogMarketing := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"blog\",\n\t\t\tNamespace: fixture.ServiceMarketingGreen.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceMarketingGreen.Name,\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyRootValidIncludesBlogMarketing := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"root-blog\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      proxyValidIncludeBlogMarketing.Name,\n\t\t\t\tNamespace: proxyValidIncludeBlogMarketing.Namespace,\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy includes another\", testcase{\n\t\tobjs: []interface{}{proxyValidIncludeBlogMarketing, proxyRootValidIncludesBlogMarketing, fixture.ServiceRootsKuard, fixture.ServiceMarketingGreen},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyValidIncludeBlogMarketing.Name, Namespace: proxyValidIncludeBlogMarketing.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyValidIncludeBlogMarketing.Generation).\n\t\t\t\tValid(),\n\t\t\t{Name: proxyRootValidIncludesBlogMarketing.Name, Namespace: proxyRootValidIncludesBlogMarketing.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyRootValidIncludesBlogMarketing.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n\n\tproxyValidWithMirror := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"www\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}, {\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}, {\n\t\t\t\t\tName:   fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tMirror: true,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy with mirror\", testcase{\n\t\tobjs: []interface{}{proxyValidWithMirror, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyValidWithMirror.Name, Namespace: proxyValidWithMirror.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyValidWithMirror.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n\n\tproxyInvalidTwoMirrors := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"www\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}, {\n\t\t\t\t\tName:   fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tMirror: true,\n\t\t\t\t}, {\n\t\t\t\t\tName:   fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort:   8080,\n\t\t\t\t\tMirror: true,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy with two mirrors\", testcase{\n\t\tobjs: []interface{}{proxyInvalidTwoMirrors, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidTwoMirrors.Name, Namespace: proxyInvalidTwoMirrors.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidTwoMirrors.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeServiceError, \"OnlyOneMirror\", \"only one service per route may be nominated as mirror\"),\n\t\t},\n\t})\n\n\tproxyInvalidDuplicateMatchConditionHeaders := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:  \"x-header\",\n\t\t\t\t\t\tExact: \"abc\",\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:  \"x-header\",\n\t\t\t\t\t\tExact: \"1234\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"duplicate route condition headers\", testcase{\n\t\tobjs: []interface{}{proxyInvalidDuplicateMatchConditionHeaders, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidDuplicateMatchConditionHeaders.Name, Namespace: proxyInvalidDuplicateMatchConditionHeaders.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidDuplicateMatchConditionHeaders.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeRouteError, \"HeaderMatchConditionsNotValid\", \"cannot specify duplicate header 'exact match' conditions in the same route\"),\n\t\t},\n\t})\n\n\tproxyInvalidDuplicateIncludeCondtionHeaders := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"delegated\",\n\t\t\t\tNamespace: \"roots\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:  \"x-header\",\n\t\t\t\t\t\tExact: \"abc\",\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:  \"x-header\",\n\t\t\t\t\t\tExact: \"1234\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\tproxyValidDelegatedRoots := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"delegated\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"duplicate include condition headers\", testcase{\n\t\tobjs: []interface{}{proxyInvalidDuplicateIncludeCondtionHeaders, proxyValidDelegatedRoots, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidDuplicateIncludeCondtionHeaders.Name,\n\t\t\t\tNamespace: proxyInvalidDuplicateIncludeCondtionHeaders.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidDuplicateIncludeCondtionHeaders.Generation).Valid(),\n\t\t\t{Name: proxyValidDelegatedRoots.Name,\n\t\t\t\tNamespace: proxyValidDelegatedRoots.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyValidDelegatedRoots.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeRouteError, \"HeaderMatchConditionsNotValid\", \"cannot specify duplicate header 'exact match' conditions in the same route\"),\n\t\t},\n\t})\n\n\tproxyInvalidRouteConditionHeaders := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"x-header\",\n\t\t\t\t\t\tNotExact: \"abc\",\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"x-header\",\n\t\t\t\t\t\tNotExact: \"1234\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"duplicate valid route condition headers\", testcase{\n\t\tobjs: []interface{}{proxyInvalidRouteConditionHeaders, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidRouteConditionHeaders.Name, Namespace: proxyInvalidRouteConditionHeaders.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidRouteConditionHeaders.Generation).Valid(),\n\t\t},\n\t})\n\n\tproxyInvalidMultiplePrefixes := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"www\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{\n\t\t\t\t\t{\n\t\t\t\t\t\tPrefix: \"/api\",\n\t\t\t\t\t}, {\n\t\t\t\t\t\tPrefix: \"/v1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy with two prefix conditions on route\", testcase{\n\t\tobjs: []interface{}{proxyInvalidMultiplePrefixes, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidMultiplePrefixes.Name, Namespace: proxyInvalidMultiplePrefixes.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidMultiplePrefixes.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeRouteError, \"PathMatchConditionsNotValid\", \"route: more than one prefix is not allowed in a condition block\"),\n\t\t},\n\t})\n\n\tproxyInvalidTwoPrefixesWithInclude := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"www\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"child\",\n\t\t\t\tNamespace: \"teama\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{\n\t\t\t\t\t{\n\t\t\t\t\t\tPrefix: \"/api\",\n\t\t\t\t\t}, {\n\t\t\t\t\t\tPrefix: \"/v1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyValidChildTeamA := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"child\",\n\t\t\tNamespace: \"teama\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy with two prefix conditions orphans include\", testcase{\n\t\tobjs: []interface{}{proxyInvalidTwoPrefixesWithInclude, proxyValidChildTeamA, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidTwoPrefixesWithInclude.Name, Namespace: proxyInvalidTwoPrefixesWithInclude.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidTwoPrefixesWithInclude.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeIncludeError, \"PathMatchConditionsNotValid\", \"include: more than one prefix is not allowed in a condition block\"),\n\t\t\t{Name: proxyValidChildTeamA.Name, Namespace: proxyValidChildTeamA.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyValidChildTeamA.Generation).\n\t\t\t\tOrphaned(),\n\t\t},\n\t})\n\n\tproxyInvalidPrefixNoSlash := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"www\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{\n\t\t\t\t\t{\n\t\t\t\t\t\tPrefix: \"api\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy with prefix conditions on route that does not start with slash\", testcase{\n\t\tobjs: []interface{}{proxyInvalidPrefixNoSlash, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidPrefixNoSlash.Name, Namespace: proxyInvalidPrefixNoSlash.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(proxyInvalidPrefixNoSlash.Generation).\n\t\t\t\tWithError(contour_api_v1.ConditionTypeRouteError, \"PathMatchConditionsNotValid\", \"route: prefix conditions must start with /, api was supplied\"),\n\t\t},\n\t})\n\n\tproxyInvalidIncludePrefixNoSlash := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"www\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"child\",\n\t\t\t\tNamespace: \"teama\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{\n\t\t\t\t\t{\n\t\t\t\t\t\tPrefix: \"api\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"proxy with include prefix that does not start with slash\", testcase{\n\t\tobjs: []interface{}{proxyInvalidIncludePrefixNoSlash, proxyValidChildTeamA, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidIncludePrefixNoSlash.Name, Namespace: proxyInvalidIncludePrefixNoSlash.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeIncludeError, \"PathMatchConditionsNotValid\", \"include: prefix conditions must start with /, api was supplied\"),\n\t\t\t{Name: proxyValidChildTeamA.Name, Namespace: proxyValidChildTeamA.Namespace}: fixture.NewValidCondition().\n\t\t\t\tOrphaned(),\n\t\t},\n\t})\n\n\tproxyInvalidTCPProxyIncludeAndService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"simple\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"passthrough.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tInclude: &contour_api_v1.TCPProxyInclude{\n\t\t\t\t\tName:      \"foo\",\n\t\t\t\t\tNamespace: \"roots\",\n\t\t\t\t},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"tcpproxy cannot specify services and include\", testcase{\n\t\tobjs: []interface{}{proxyInvalidTCPProxyIncludeAndService, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidTCPProxyIncludeAndService.Name, Namespace: proxyInvalidTCPProxyIncludeAndService.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTCPProxyError, \"NoServicesAndInclude\", \"cannot specify services and include in the same httpproxy\"),\n\t\t},\n\t})\n\n\tproxyTCPNoServiceOrInclusion := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"simple\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"passthrough.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{},\n\t\t},\n\t}\n\n\trun(t, \"tcpproxy empty\", testcase{\n\t\tobjs: []interface{}{proxyTCPNoServiceOrInclusion, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPNoServiceOrInclusion.Name, Namespace: proxyTCPNoServiceOrInclusion.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTCPProxyError, \"NothingDefined\", \"either services or inclusion must be specified\"),\n\t\t},\n\t})\n\n\tproxyTCPIncludesFoo := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"simple\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"passthrough.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tInclude: &contour_api_v1.TCPProxyInclude{\n\t\t\t\t\tName:      \"foo\",\n\t\t\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"tcpproxy w/ missing include\", testcase{\n\t\tobjs: []interface{}{proxyTCPIncludesFoo, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPIncludesFoo.Name, Namespace: proxyTCPIncludesFoo.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTCPProxyIncludeError, \"IncludeNotFound\", \"include roots/foo not found\"),\n\t\t},\n\t})\n\n\tproxyValidTCPRoot := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"foo\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"www.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"tcpproxy includes another root\", testcase{\n\t\tobjs: []interface{}{proxyTCPIncludesFoo, proxyValidTCPRoot, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPIncludesFoo.Name, Namespace: proxyTCPIncludesFoo.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTCPProxyIncludeError, \"RootIncludesRoot\", \"root httpproxy cannot include another root httpproxy\"),\n\t\t\t{Name: proxyValidTCPRoot.Name, Namespace: proxyValidTCPRoot.Namespace}: fixture.NewValidCondition().Valid(),\n\t\t},\n\t})\n\n\tproxyTCPValidChildFoo := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"foo\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"tcpproxy includes valid child\", testcase{\n\t\tobjs: []interface{}{proxyTCPIncludesFoo, proxyTCPValidChildFoo, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPIncludesFoo.Name, Namespace: proxyTCPIncludesFoo.Namespace}:     fixture.NewValidCondition().Valid(),\n\t\t\t{Name: proxyTCPValidChildFoo.Name, Namespace: proxyTCPValidChildFoo.Namespace}: fixture.NewValidCondition().Valid(),\n\t\t},\n\t})\n\n\tproxyInvalidConflictingIncludeConditions := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"blogteama\",\n\t\t\t\tNamespace: \"teama\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tName:      \"blogteamb\",\n\t\t\t\tNamespace: \"teamb\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyValidBlogTeamA := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"blogteama\",\n\t\t\tName:      \"teama\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceTeamAKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\tproxyValidBlogTeamB := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"blogteamb\",\n\t\t\tName:      \"teamb\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceTeamBKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"duplicate path conditions on an include\", testcase{\n\t\tobjs: []interface{}{proxyInvalidConflictingIncludeConditions, proxyValidBlogTeamA, proxyValidBlogTeamB, fixture.ServiceRootsHome, fixture.ServiceTeamAKuard, fixture.ServiceTeamBKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidConflictingIncludeConditions.Name,\n\t\t\t\tNamespace: proxyInvalidConflictingIncludeConditions.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeIncludeError, \"DuplicateMatchConditions\", \"duplicate conditions defined on an include\"),\n\t\t\t{Name: proxyValidBlogTeamA.Name, Namespace: proxyValidBlogTeamA.Namespace}: fixture.NewValidCondition().\n\t\t\t\tOrphaned(),\n\t\t\t{Name: proxyValidBlogTeamB.Name, Namespace: proxyValidBlogTeamB.Namespace}: fixture.NewValidCondition().\n\t\t\t\tOrphaned(),\n\t\t},\n\t})\n\n\tproxyInvalidConflictHeaderConditions := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"blogteama\",\n\t\t\t\tNamespace: \"teama\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"x-header\",\n\t\t\t\t\t\tContains: \"abc\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tName:      \"blogteamb\",\n\t\t\t\tNamespace: \"teamb\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"x-header\",\n\t\t\t\t\t\tContains: \"abc\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"duplicate header conditions on an include\", testcase{\n\t\tobjs: []interface{}{proxyInvalidConflictHeaderConditions, proxyValidBlogTeamA, proxyValidBlogTeamB, fixture.ServiceRootsHome, fixture.ServiceTeamAKuard, fixture.ServiceTeamBKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidConflictHeaderConditions.Name,\n\t\t\t\tNamespace: proxyInvalidConflictHeaderConditions.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeIncludeError, \"DuplicateMatchConditions\", \"duplicate conditions defined on an include\"),\n\t\t\t{Name: proxyValidBlogTeamA.Name,\n\t\t\t\tNamespace: proxyValidBlogTeamA.Namespace}: fixture.NewValidCondition().Orphaned(),\n\t\t\t{Name: proxyValidBlogTeamB.Name,\n\t\t\t\tNamespace: proxyValidBlogTeamB.Namespace}: fixture.NewValidCondition().Orphaned(),\n\t\t},\n\t})\n\n\tproxyInvalidDuplicateHeaderAndPathConditions := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName:      \"blogteama\",\n\t\t\t\tNamespace: \"teama\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"x-header\",\n\t\t\t\t\t\tContains: \"abc\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tName:      \"blogteamb\",\n\t\t\t\tNamespace: \"teamb\",\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/blog\",\n\t\t\t\t\tHeader: &contour_api_v1.HeaderMatchCondition{\n\t\t\t\t\t\tName:     \"x-header\",\n\t\t\t\t\t\tContains: \"abc\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"duplicate header+path conditions on an include\", testcase{\n\t\tobjs: []interface{}{proxyInvalidDuplicateHeaderAndPathConditions, proxyValidBlogTeamA, proxyValidBlogTeamB, fixture.ServiceRootsHome, fixture.ServiceTeamAKuard, fixture.ServiceTeamBKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidDuplicateHeaderAndPathConditions.Name,\n\t\t\t\tNamespace: proxyInvalidDuplicateHeaderAndPathConditions.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeIncludeError, \"DuplicateMatchConditions\", \"duplicate conditions defined on an include\"),\n\t\t\t{Name: proxyValidBlogTeamA.Name,\n\t\t\t\tNamespace: proxyValidBlogTeamA.Namespace}: fixture.NewValidCondition().\n\t\t\t\tOrphaned(),\n\t\t\t{Name: proxyValidBlogTeamB.Name,\n\t\t\t\tNamespace: proxyValidBlogTeamB.Namespace}: fixture.NewValidCondition().\n\t\t\t\tOrphaned(),\n\t\t},\n\t})\n\n\tproxyInvalidMissingInclude := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tIncludes: []contour_api_v1.Include{{\n\t\t\t\tName: \"child\",\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"httpproxy w/ missing include\", testcase{\n\t\tobjs: []interface{}{proxyInvalidMissingInclude, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidMissingInclude.Name, Namespace: proxyInvalidMissingInclude.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeIncludeError, \"IncludeNotFound\", \"include roots/child not found\"),\n\t\t},\n\t})\n\n\tproxyTCPInvalidMissingService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"missing-tcp-proxy-service\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"not-found\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"httpproxy w/ tcpproxy w/ missing service\", testcase{\n\t\tobjs: []interface{}{proxyTCPInvalidMissingService},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPInvalidMissingService.Name, Namespace: proxyTCPInvalidMissingService.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTCPProxyError, \"ServiceUnresolvedReference\", `Spec.TCPProxy unresolved service reference: service \"roots/not-found\" not found`),\n\t\t},\n\t})\n\n\tproxyTCPInvalidPortNotMatched := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"tcp-proxy-service-missing-port\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 9999,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"httpproxy w/ tcpproxy w/ service missing port\", testcase{\n\t\tobjs: []interface{}{proxyTCPInvalidPortNotMatched, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPInvalidPortNotMatched.Name, Namespace: proxyTCPInvalidPortNotMatched.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTCPProxyError, \"ServiceUnresolvedReference\", `Spec.TCPProxy unresolved service reference: port \"9999\" on service \"roots/kuard\" not matched`),\n\t\t},\n\t})\n\n\tproxyTCPInvalidMissingTLS := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"missing-tls\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"httpproxy w/ tcpproxy missing tls\", testcase{\n\t\tobjs: []interface{}{proxyTCPInvalidMissingTLS},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPInvalidMissingTLS.Name, Namespace: proxyTCPInvalidMissingTLS.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTCPProxyError, \"TLSMustBeConfigured\", \"Spec.TCPProxy requires that either Spec.TLS.Passthrough or Spec.TLS.SecretName be set\"),\n\t\t},\n\t})\n\n\tproxyInvalidMissingServiceWithTCPProxy := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"missing-route-service\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: fixture.SecretRootsCert.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{\n\t\t\t\t\t{Name: \"missing\", Port: 9000},\n\t\t\t\t},\n\t\t\t}},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"httpproxy w/ tcpproxy missing service\", testcase{\n\t\tobjs: []interface{}{fixture.SecretRootsCert, fixture.ServiceRootsKuard, proxyInvalidMissingServiceWithTCPProxy},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidMissingServiceWithTCPProxy.Name, Namespace: proxyInvalidMissingServiceWithTCPProxy.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeServiceError, \"ServiceUnresolvedReference\", `Spec.Routes unresolved service reference: service \"roots/missing\" not found`),\n\t\t},\n\t})\n\n\tproxyRoutePortNotMatchedWithTCP := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"missing-route-service-port\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: fixture.SecretRootsCert.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{\n\t\t\t\t\t{Name: fixture.ServiceRootsKuard.Name, Port: 9999},\n\t\t\t\t},\n\t\t\t}},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"tcpproxy route unmatched service port\", testcase{\n\t\tobjs: []interface{}{fixture.SecretRootsCert, fixture.ServiceRootsKuard, proxyRoutePortNotMatchedWithTCP},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyRoutePortNotMatchedWithTCP.Name, Namespace: proxyRoutePortNotMatchedWithTCP.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeServiceError, \"ServiceUnresolvedReference\", `Spec.Routes unresolved service reference: port \"9999\" on service \"roots/kuard\" not matched`),\n\t\t},\n\t})\n\n\tproxyTCPValidIncludeChild := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"validtcpproxy\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: fixture.SecretRootsCert.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tInclude: &contour_api_v1.TCPProxyInclude{\n\t\t\t\t\tName:      \"child\",\n\t\t\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tproxyTCPValidIncludesChild := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"validtcpproxy\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName: fixture.SecretRootsCert.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tIncludesDeprecated: &contour_api_v1.TCPProxyInclude{\n\t\t\t\t\tName:      \"child\",\n\t\t\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tproxyTCPValidChild := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"child\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"valid HTTPProxy.TCPProxy - plural\", testcase{\n\t\tobjs: []interface{}{proxyTCPValidIncludesChild, proxyTCPValidChild, fixture.ServiceRootsKuard, fixture.SecretRootsCert},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPValidIncludesChild.Name,\n\t\t\t\tNamespace: proxyTCPValidIncludesChild.Namespace}: fixture.NewValidCondition().Valid(),\n\t\t\t{Name: proxyTCPValidChild.Name,\n\t\t\t\tNamespace: proxyTCPValidChild.Namespace}: fixture.NewValidCondition().Valid(),\n\t\t},\n\t})\n\n\trun(t, \"valid HTTPProxy.TCPProxy\", testcase{\n\t\tobjs: []interface{}{proxyTCPValidIncludeChild, proxyTCPValidChild, fixture.ServiceRootsKuard, fixture.SecretRootsCert},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyTCPValidIncludeChild.Name,\n\t\t\t\tNamespace: proxyTCPValidIncludeChild.Namespace}: fixture.NewValidCondition().Valid(),\n\t\t\t{Name: proxyTCPValidChild.Name,\n\t\t\t\tNamespace: proxyTCPValidChild.Namespace}: fixture.NewValidCondition().Valid(),\n\t\t},\n\t})\n\n\t// issue 2309\n\tproxyInvalidNoServices := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"missing-service\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"missing-service.example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/\",\n\t\t\t\t}},\n\t\t\t\tServices: nil, // missing\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"invalid HTTPProxy due to empty route.service\", testcase{\n\t\tobjs: []interface{}{proxyInvalidNoServices, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyInvalidNoServices.Name, Namespace: proxyInvalidNoServices.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeRouteError, \"NoServicesPresent\", \"route.services must have at least one entry\"),\n\t\t},\n\t})\n\n\tfallbackCertificate := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName:                \"ssl-cert\",\n\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"invalid fallback certificate passed to contour\", testcase{\n\t\tfallbackCertificate: &types.NamespacedName{\n\t\t\tName:      \"invalid\",\n\t\t\tNamespace: \"invalid\",\n\t\t},\n\t\tobjs: []interface{}{fallbackCertificate, fixture.SecretRootsFallback, fixture.SecretRootsCert, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: fallbackCertificate.Name,\n\t\t\t\tNamespace: fallbackCertificate.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"FallbackNotValid\", `Spec.Virtualhost.TLS Secret \"invalid/invalid\" fallback certificate is invalid: Secret not found`),\n\t\t},\n\t})\n\n\trun(t, \"fallback certificate requested but cert not configured in contour\", testcase{\n\t\tobjs: []interface{}{fallbackCertificate, fixture.SecretRootsFallback, fixture.SecretRootsCert, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: fallbackCertificate.Name,\n\t\t\t\tNamespace: fallbackCertificate.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"FallbackNotPresent\", \"Spec.Virtualhost.TLS enabled fallback but the fallback Certificate Secret is not configured in Contour configuration file\"),\n\t\t},\n\t})\n\n\tfallbackCertificateWithClientValidationNoCA := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName:       \"ssl-cert\",\n\t\t\t\t\tClientValidation: &contour_api_v1.DownstreamValidation{},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"clientValidation missing CA\", testcase{\n\t\tobjs: []interface{}{fallbackCertificateWithClientValidationNoCA, fixture.SecretRootsFallback, fixture.SecretRootsCert, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: fallbackCertificateWithClientValidationNoCA.Name,\n\t\t\t\tNamespace: fallbackCertificateWithClientValidationNoCA.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"ClientValidationInvalid\", \"Spec.VirtualHost.TLS client validation is invalid: CA Secret must be specified\"),\n\t\t},\n\t})\n\n\tfallbackCertificateWithClientValidation := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"roots\",\n\t\t\tName:      \"example\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName:                \"ssl-cert\",\n\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t\tClientValidation: &contour_api_v1.DownstreamValidation{\n\t\t\t\t\t\tCACertificate: \"something\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"fallback certificate requested and clientValidation also configured\", testcase{\n\t\tobjs: []interface{}{fallbackCertificateWithClientValidation, fixture.SecretRootsFallback, fixture.SecretRootsCert, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: fallbackCertificateWithClientValidation.Name,\n\t\t\t\tNamespace: fallbackCertificateWithClientValidation.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"TLSIncompatibleFeatures\", \"Spec.Virtualhost.TLS fallback & client validation are incompatible\"),\n\t\t},\n\t})\n\n\ttlsPassthroughAndValidation := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"invalid\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t\tClientValidation: &contour_api_v1.DownstreamValidation{\n\t\t\t\t\t\tCACertificate: \"aCAcert\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{},\n\t\t},\n\t}\n\n\trun(t, \"passthrough and client auth are incompatible tlsPassthroughAndValidation\", testcase{\n\t\tobjs: []interface{}{fixture.SecretRootsCert, tlsPassthroughAndValidation},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: tlsPassthroughAndValidation.Name, Namespace: tlsPassthroughAndValidation.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"TLSIncompatibleFeatures\", \"Spec.VirtualHost.TLS passthrough cannot be combined with tls.clientValidation\"),\n\t\t},\n\t})\n\n\ttlsPassthroughAndSecretName := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"invalid\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: true,\n\t\t\t\t\tSecretName:  fixture.SecretRootsCert.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{},\n\t\t},\n\t}\n\n\trun(t, \"tcpproxy with TLS passthrough and secret name both specified\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tfixture.SecretRootsCert,\n\t\t\ttlsPassthroughAndSecretName,\n\t\t},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: \"invalid\", Namespace: fixture.ServiceRootsKuard.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"TLSConfigNotValid\", \"Spec.VirtualHost.TLS: both Passthrough and SecretName were specified\"),\n\t\t},\n\t})\n\n\ttlsNoPassthroughOrSecretName := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"invalid\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"tcpproxy.example.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough: false,\n\t\t\t\t\tSecretName:  \"\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{},\n\t\t},\n\t}\n\n\trun(t, \"httpproxy w/ tcpproxy with neither TLS passthrough nor secret name specified\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tfixture.SecretRootsCert,\n\t\t\ttlsNoPassthroughOrSecretName,\n\t\t},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: \"invalid\", Namespace: fixture.ServiceRootsKuard.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"TLSConfigNotValid\", \"Spec.VirtualHost.TLS: neither Passthrough nor SecretName were specified\"),\n\t\t},\n\t})\n\n\temptyProxy := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"empty\",\n\t\t\tNamespace: \"roots\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"proxy with no routes, includes, or tcpproxy is invalid\", testcase{\n\t\tobjs: []interface{}{emptyProxy},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: emptyProxy.Name, Namespace: emptyProxy.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeSpecError, \"NothingDefined\", \"HTTPProxy.Spec must have at least one Route, Include, or a TCPProxy\"),\n\t\t},\n\t})\n\n\tinvalidRequestHeadersPolicyService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"invalidRHPService\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\t\tPort: 8080,\n\t\t\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\t\t\tValue: \"external.com\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"requestHeadersPolicy, Host header invalid on Service\", testcase{\n\t\tobjs: []interface{}{invalidRequestHeadersPolicyService, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: invalidRequestHeadersPolicyService.Name, Namespace: invalidRequestHeadersPolicyService.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeServiceError, \"RequestHeadersPolicyInvalid\", `rewriting \"Host\" header is not supported on request headers`),\n\t\t},\n\t})\n\n\tinvalidResponseHeadersPolicyService := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"invalidRHPService\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\t\tPort: 8080,\n\t\t\t\t\t\tResponseHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\t\t\tValue: \"external.com\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"responseHeadersPolicy, Host header invalid on Service\", testcase{\n\t\tobjs: []interface{}{invalidResponseHeadersPolicyService, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: invalidResponseHeadersPolicyService.Name, Namespace: invalidResponseHeadersPolicyService.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeServiceError, \"ResponseHeadersPolicyInvalid\", `rewriting \"Host\" header is not supported on response headers`),\n\t\t},\n\t})\n\n\tinvalidResponseHeadersPolicyRoute := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"invalidRHPRoute\",\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\t\tPort: 8080,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tResponseHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\tValue: \"external.com\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"responseHeadersPolicy, Host header invalid on Route\", testcase{\n\t\tobjs: []interface{}{invalidResponseHeadersPolicyRoute, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: invalidResponseHeadersPolicyRoute.Name, Namespace: invalidResponseHeadersPolicyRoute.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeRouteError, \"ResponseHeaderPolicyInvalid\", `rewriting \"Host\" header is not supported on response headers`),\n\t\t},\n\t})\n\n\tproxyAuthFallback := fixture.NewProxy(\"roots/fallback-incompat\").\n\t\tWithSpec(contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"invalid.com\",\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tSecretName:                \"ssl-cert\",\n\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t},\n\t\t\t\tAuthorization: &contour_api_v1.AuthorizationServer{\n\t\t\t\t\tExtensionServiceRef: contour_api_v1.ExtensionServiceReference{\n\t\t\t\t\t\tNamespace: \"auth\",\n\t\t\t\t\t\tName:      \"extension\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{Name: \"app-server\", Port: 80}},\n\t\t\t}},\n\t\t})\n\n\trun(t, \"fallback and client auth is invalid\", testcase{\n\t\tobjs: []interface{}{fixture.SecretRootsCert, proxyAuthFallback},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: proxyAuthFallback.Name, Namespace: proxyAuthFallback.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithError(contour_api_v1.ConditionTypeTLSError, \"TLSIncompatibleFeatures\", \"Spec.Virtualhost.TLS fallback & client authorization are incompatible\"),\n\t\t},\n\t})\n\n\tinvalidResponseTimeout := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t\tName:      \"invalid-timeouts\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{\n\t\t\t\t{\n\t\t\t\t\tServices: []contour_api_v1.Service{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tTimeoutPolicy: &contour_api_v1.TimeoutPolicy{\n\t\t\t\t\t\tResponse: \"invalid-val\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"proxy with invalid response timeout value is invalid\", testcase{\n\t\tobjs: []interface{}{invalidResponseTimeout, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{\n\t\t\t\tName:      invalidResponseTimeout.Name,\n\t\t\t\tNamespace: invalidResponseTimeout.Namespace,\n\t\t\t}: fixture.NewValidCondition().WithError(contour_api_v1.ConditionTypeRouteError, \"TimeoutPolicyNotValid\",\n\t\t\t\t`route.timeoutPolicy failed to parse: error parsing response timeout: unable to parse timeout string \"invalid-val\": time: invalid duration \"invalid-val\"`),\n\t\t},\n\t})\n\n\tinvalidIdleTimeout := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: fixture.ServiceRootsKuard.Namespace,\n\t\t\tName:      \"invalid-timeouts\",\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{\n\t\t\t\t{\n\t\t\t\t\tServices: []contour_api_v1.Service{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName: fixture.ServiceRootsKuard.Name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tTimeoutPolicy: &contour_api_v1.TimeoutPolicy{\n\t\t\t\t\t\tIdle: \"invalid-val\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\trun(t, \"proxy with invalid idle timeout value is invalid\", testcase{\n\t\tobjs: []interface{}{invalidIdleTimeout, fixture.ServiceRootsKuard},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{\n\t\t\t\tName:      invalidIdleTimeout.Name,\n\t\t\t\tNamespace: invalidIdleTimeout.Namespace,\n\t\t\t}: fixture.NewValidCondition().WithError(contour_api_v1.ConditionTypeRouteError, \"TimeoutPolicyNotValid\",\n\t\t\t\t`route.timeoutPolicy failed to parse: error parsing idle timeout: unable to parse timeout string \"invalid-val\": time: invalid duration \"invalid-val\"`),\n\t\t},\n\t})\n\n\t// issue 3197: Fallback and passthrough HTTPProxy directive should emit a config error\n\ttlsPassthroughAndFallback := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace:  \"roots\",\n\t\t\tName:       \"example\",\n\t\t\tGeneration: 24,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough:               true,\n\t\t\t\t\tEnableFallbackCertificate: true,\n\t\t\t\t},\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"TLS with passthrough and fallback cert enabled is invalid\", testcase{\n\t\tobjs: []interface{}{tlsPassthroughAndFallback, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: tlsPassthroughAndFallback.Name, Namespace: tlsPassthroughAndFallback.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(tlsPassthroughAndFallback.Generation).WithError(\n\t\t\t\tcontour_api_v1.ConditionTypeTLSError, \"TLSIncompatibleFeatures\",\n\t\t\t\t`Spec.VirtualHost.TLS: both Passthrough and enableFallbackCertificate were specified`,\n\t\t\t),\n\t\t},\n\t})\n\ttlsPassthrough := &contour_api_v1.HTTPProxy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace:  \"roots\",\n\t\t\tName:       \"example\",\n\t\t\tGeneration: 24,\n\t\t},\n\t\tSpec: contour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tTLS: &contour_api_v1.TLS{\n\t\t\t\t\tPassthrough:               true,\n\t\t\t\t\tEnableFallbackCertificate: false,\n\t\t\t\t},\n\t\t\t\tFqdn: \"example.com\",\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tConditions: []contour_api_v1.MatchCondition{{\n\t\t\t\t\tPrefix: \"/foo\",\n\t\t\t\t}},\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"home\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"valid TLS passthrough\", testcase{\n\t\tobjs: []interface{}{tlsPassthrough, fixture.ServiceRootsHome},\n\t\twant: map[types.NamespacedName]contour_api_v1.DetailedCondition{\n\t\t\t{Name: tlsPassthrough.Name, Namespace: tlsPassthrough.Namespace}: fixture.NewValidCondition().\n\t\t\t\tWithGeneration(tlsPassthrough.Generation).\n\t\t\t\tValid(),\n\t\t},\n\t})\n}\n\nfunc TestGatewayAPIHTTPRouteDAGStatus(t *testing.T) {\n\n\ttype testcase struct {\n\t\tobjs []interface{}\n\t\twant []*status.RouteConditionsUpdate\n\t}\n\n\trun := func(t *testing.T, desc string, tc testcase) {\n\t\tt.Helper()\n\t\tt.Run(desc, func(t *testing.T) {\n\t\t\tt.Helper()\n\t\t\tbuilder := Builder{\n\t\t\t\tSource: KubernetesCache{\n\t\t\t\t\tRootNamespaces: []string{\"roots\", \"marketing\"},\n\t\t\t\t\tFieldLogger:    fixture.NewTestLogger(t),\n\t\t\t\t\tConfiguredGateway: types.NamespacedName{\n\t\t\t\t\t\tNamespace: \"contour\",\n\t\t\t\t\t\tName:      \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tgatewayclass: &gatewayapi_v1alpha1.GatewayClass{\n\t\t\t\t\t\tTypeMeta: metav1.TypeMeta{},\n\t\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\t\tName: \"test-gc\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tSpec: gatewayapi_v1alpha1.GatewayClassSpec{\n\t\t\t\t\t\t\tController: \"projectcontour.io/contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tStatus: gatewayapi_v1alpha1.GatewayClassStatus{\n\t\t\t\t\t\t\tConditions: []metav1.Condition{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tType:   string(gatewayapi_v1alpha1.GatewayClassConditionStatusAdmitted),\n\t\t\t\t\t\t\t\t\tStatus: metav1.ConditionTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tgateway: &gatewayapi_v1alpha1.Gateway{\n\t\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\t\tName:      \"contour\",\n\t\t\t\t\t\t\tNamespace: \"projectcontour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\t\t\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\t\t\t\t\tPort:     80,\n\t\t\t\t\t\t\t\tProtocol: gatewayapi_v1alpha1.HTTPProtocolType,\n\t\t\t\t\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tKind: KindHTTPRoute,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tProcessors: []Processor{\n\t\t\t\t\t&IngressProcessor{\n\t\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t\t},\n\t\t\t\t\t&HTTPProxyProcessor{},\n\t\t\t\t\t&GatewayAPIProcessor{\n\t\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t\t},\n\t\t\t\t\t&ListenerProcessor{},\n\t\t\t\t},\n\t\t\t}\n\t\t\tfor _, o := range tc.objs {\n\t\t\t\tbuilder.Source.Insert(o)\n\t\t\t}\n\t\t\tdag := builder.Build()\n\t\t\tgotUpdates := dag.StatusCache.GetRouteUpdates()\n\n\t\t\tops := []cmp.Option{\n\t\t\t\tcmpopts.IgnoreFields(metav1.Condition{}, \"LastTransitionTime\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"ExistingConditions\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"GatewayRef\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"Generation\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"TransitionTime\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"Resource\"),\n\t\t\t\tcmpopts.SortSlices(func(i, j metav1.Condition) bool {\n\t\t\t\t\treturn i.Message < j.Message\n\t\t\t\t}),\n\t\t\t}\n\n\t\t\tif diff := cmp.Diff(tc.want, gotUpdates, ops...); diff != \"\" {\n\t\t\t\tt.Fatalf(\"expected: %v, got %v\", tc.want, diff)\n\t\t\t}\n\n\t\t})\n\t}\n\n\tkuardService := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\trun(t, \"simple httproute\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionTrue,\n\t\t\t\t\tReason:  string(status.ValidCondition),\n\t\t\t\t\tMessage: \"Valid HTTPRoute\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"invalid prefix match for httproute\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.HTTPRouteMatch{{\n\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(\"UNKNOWN\"), // <---- unknown type to break the test\n\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t\tstatus.ConditionNotImplemented: {\n\t\t\t\t\tType:    string(status.ConditionNotImplemented),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionTrue,\n\t\t\t\t\tReason:  string(status.ReasonPathMatchType),\n\t\t\t\t\tMessage: \"HTTPRoute.Spec.Rules.PathMatch: Only Prefix match type and Exact match type are supported.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"regular expression match not yet supported for httproute\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchRegularExpression, \"/\"),\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t\tstatus.ConditionNotImplemented: {\n\t\t\t\t\tType:    string(status.ConditionNotImplemented),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionTrue,\n\t\t\t\t\tReason:  string(status.ReasonPathMatchType),\n\t\t\t\t\tMessage: \"HTTPRoute.Spec.Rules.PathMatch: Only Prefix match type and Exact match type are supported.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"RegularExpression header match not yet supported for httproute\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.HTTPRouteMatch{{\n\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(gatewayapi_v1alpha1.PathMatchPrefix),\n\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tHeaders: &gatewayapi_v1alpha1.HTTPHeaderMatch{\n\t\t\t\t\t\t\t\tType:   headerMatchTypePtr(gatewayapi_v1alpha1.HeaderMatchRegularExpression), // <---- RegularExpression type not yet supported\n\t\t\t\t\t\t\t\tValues: map[string]string{\"foo\": \"bar\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t\tstatus.ConditionNotImplemented: {\n\t\t\t\t\tType:    string(status.ConditionNotImplemented),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionTrue,\n\t\t\t\t\tReason:  string(status.ReasonHeaderMatchType),\n\t\t\t\t\tMessage: \"HTTPRoute.Spec.Rules.HeaderMatch: Only Exact match type is supported.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"spec.tls not yet supported for httproute\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tTLS: &gatewayapi_v1alpha1.RouteTLSConfig{\n\t\t\t\t\t\tCertificateRef: gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\t\tKind:  \"secret\",\n\t\t\t\t\t\t\tName:  \"someSecret\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t\tstatus.ConditionNotImplemented: {\n\t\t\t\t\tType:    string(status.ConditionNotImplemented),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionTrue,\n\t\t\t\t\tReason:  string(status.ReasonNotImplemented),\n\t\t\t\t\tMessage: \"HTTPRoute.Spec.TLS: Not yet implemented.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"spec.rules.forwardTo.serviceName not specified\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: nil,\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\tMessage: \"Spec.Rules.ForwardTo.ServiceName must be specified\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"spec.rules.forwardTo.serviceName invalid on two matches\", testcase{\n\t\tobjs: []interface{}{\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.HTTPRouteMatch{{\n\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(gatewayapi_v1alpha1.PathMatchPrefix),\n\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"invalid-one\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t}, {\n\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.HTTPRouteMatch{{\n\t\t\t\t\t\t\tPath: &gatewayapi_v1alpha1.HTTPPathMatch{\n\t\t\t\t\t\t\t\tType:  pathMatchTypePtr(gatewayapi_v1alpha1.PathMatchPrefix),\n\t\t\t\t\t\t\t\tValue: pointer.StringPtr(\"/blog\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"invalid-two\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\tMessage: \"service \\\"invalid-one\\\" is invalid: service \\\"default/invalid-one\\\" not found, service \\\"invalid-two\\\" is invalid: service \\\"default/invalid-two\\\" not found\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"spec.rules.forwardTo.servicePort not specified\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        nil,\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\tMessage: \"Spec.Rules.ForwardTo.ServicePort must be specified\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"spec.rules.forwardTo not specified\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\tMessage: \"At least one Spec.Rules.ForwardTo must be specified.\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"spec.rules.hostname: invalid wildcard\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"*.*.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\tMessage: \"invalid hostname \\\"*.*.projectcontour.io\\\": [a wildcard DNS-1123 subdomain must start with '*.', followed by a valid DNS subdomain, which must consist of lower case alphanumeric characters, '-' or '.' and end with an alphanumeric character (e.g. '*.example.com', regex used for validation is '\\\\*\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*')]\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"spec.rules.hostname: invalid hostname\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"#projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\tMessage: \"invalid hostname \\\"#projectcontour.io\\\": [a lowercase RFC 1123 subdomain must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character (e.g. 'example.com', regex used for validation is '[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*')]\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"spec.rules.hostname: invalid hostname, ip address\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"1.2.3.4\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\tMessage: \"hostname \\\"1.2.3.4\\\" must be a DNS name, not an IP address\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"HTTPRouteFilterRequestMirror not yet supported for httproute rule\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tFilters: []gatewayapi_v1alpha1.HTTPRouteFilter{{\n\t\t\t\t\t\t\tType: gatewayapi_v1alpha1.HTTPRouteFilterRequestMirror, // HTTPRouteFilterRequestMirror is not supported yet.\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionNotImplemented: {\n\t\t\t\t\tType:    string(status.ConditionNotImplemented),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionTrue,\n\t\t\t\t\tReason:  string(status.ReasonHTTPRouteFilterType),\n\t\t\t\t\tMessage: \"HTTPRoute.Spec.Rules.Filters: Only RequestHeaderModifier type is supported.\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"HTTPRouteFilterRequestMirror not yet supported for httproute forwardto\", testcase{\n\t\tobjs: []interface{}{\n\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\tFilters: []gatewayapi_v1alpha1.HTTPRouteFilter{{\n\t\t\t\t\t\t\t\tType: gatewayapi_v1alpha1.HTTPRouteFilterRequestMirror, // HTTPRouteFilterRequestMirror is not supported yet.\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionNotImplemented: {\n\t\t\t\t\tType:    string(status.ConditionNotImplemented),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionTrue,\n\t\t\t\t\tReason:  string(status.ReasonHTTPRouteFilterType),\n\t\t\t\t\tMessage: \"HTTPRoute.Spec.Rules.ForwardTo.Filters: Only RequestHeaderModifier type is supported.\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"Invalid RequestHeaderModifier due to duplicated headers\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tFilters: []gatewayapi_v1alpha1.HTTPRouteFilter{{\n\t\t\t\t\t\t\tType: gatewayapi_v1alpha1.HTTPRouteFilterRequestHeaderModifier,\n\t\t\t\t\t\t\tRequestHeaderModifier: &gatewayapi_v1alpha1.HTTPRequestHeaderFilter{\n\t\t\t\t\t\t\t\tSet: map[string]string{\"custom\": \"duplicated\", \"Custom\": \"duplicated\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\tMessage: \"duplicate header addition: \\\"Custom\\\" on request headers\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"Invalid RequestHeaderModifier after forward due to invalid headers\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"test.projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{\n\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\tFilters: []gatewayapi_v1alpha1.HTTPRouteFilter{{\n\t\t\t\t\t\t\t\tType: gatewayapi_v1alpha1.HTTPRouteFilterRequestHeaderModifier,\n\t\t\t\t\t\t\t\tRequestHeaderModifier: &gatewayapi_v1alpha1.HTTPRequestHeaderFilter{\n\t\t\t\t\t\t\t\t\tSet: map[string]string{\"!invalid-header\": \"foo\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\tMessage: \"invalid set header \\\"!invalid-Header\\\": [a valid HTTP header must consist of alphanumeric characters or '-' (e.g. 'X-Header-Name', regex used for validation is '[-A-Za-z0-9]+')] on request headers\",\n\t\t\t\t},\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonErrorsExist),\n\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n\n\trun(t, \"gateway selectors match but spec.gateways.allowtype doesn't\", testcase{\n\t\tobjs: []interface{}{\n\t\t\tkuardService,\n\t\t\t&gatewayapi_v1alpha1.HTTPRoute{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSpec: gatewayapi_v1alpha1.HTTPRouteSpec{\n\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowSameNamespace),\n\t\t\t\t\t},\n\t\t\t\t\tHostnames: []gatewayapi_v1alpha1.Hostname{\n\t\t\t\t\t\t\"projectcontour.io\",\n\t\t\t\t\t},\n\t\t\t\t\tRules: []gatewayapi_v1alpha1.HTTPRouteRule{{\n\t\t\t\t\t\tMatches: httpRouteMatch(gatewayapi_v1alpha1.PathMatchPrefix, \"/\"),\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\tReason:  string(status.ReasonGatewayAllowMismatch),\n\t\t\t\t\tMessage: \"Gateway RouteSelector matches, but GatewayAllow has mismatch.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t})\n}\n\nfunc TestGatewayAPITLSRouteDAGStatus(t *testing.T) {\n\n\ttype testcase struct {\n\t\tobjs    []interface{}\n\t\tgateway *gatewayapi_v1alpha1.Gateway\n\t\twant    []*status.RouteConditionsUpdate\n\t}\n\n\trun := func(t *testing.T, desc string, tc testcase) {\n\t\tt.Helper()\n\t\tt.Run(desc, func(t *testing.T) {\n\t\t\tt.Helper()\n\t\t\tbuilder := Builder{\n\t\t\t\tSource: KubernetesCache{\n\t\t\t\t\tRootNamespaces: []string{\"roots\", \"marketing\"},\n\t\t\t\t\tFieldLogger:    fixture.NewTestLogger(t),\n\t\t\t\t\tConfiguredGateway: types.NamespacedName{\n\t\t\t\t\t\tNamespace: \"contour\",\n\t\t\t\t\t\tName:      \"projectcontour\",\n\t\t\t\t\t},\n\t\t\t\t\tgateway: tc.gateway,\n\t\t\t\t\tgatewayclass: &gatewayapi_v1alpha1.GatewayClass{\n\t\t\t\t\t\tTypeMeta: metav1.TypeMeta{},\n\t\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\t\tName: \"test-gc\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tSpec: gatewayapi_v1alpha1.GatewayClassSpec{\n\t\t\t\t\t\t\tController: \"projectcontour.io/contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tStatus: gatewayapi_v1alpha1.GatewayClassStatus{\n\t\t\t\t\t\t\tConditions: []metav1.Condition{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tType:   string(gatewayapi_v1alpha1.GatewayClassConditionStatusAdmitted),\n\t\t\t\t\t\t\t\t\tStatus: metav1.ConditionTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tProcessors: []Processor{\n\t\t\t\t\t&IngressProcessor{\n\t\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t\t},\n\t\t\t\t\t&HTTPProxyProcessor{},\n\t\t\t\t\t&GatewayAPIProcessor{\n\t\t\t\t\t\tFieldLogger: fixture.NewTestLogger(t),\n\t\t\t\t\t},\n\t\t\t\t\t&ListenerProcessor{},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\t// Add a default cert to be used in tests with TLS.\n\t\t\tbuilder.Source.Insert(fixture.SecretProjectContourCert)\n\n\t\t\tfor _, o := range tc.objs {\n\t\t\t\tbuilder.Source.Insert(o)\n\t\t\t}\n\t\t\tdag := builder.Build()\n\t\t\tgotUpdates := dag.StatusCache.GetRouteUpdates()\n\n\t\t\tops := []cmp.Option{\n\t\t\t\tcmpopts.IgnoreFields(metav1.Condition{}, \"LastTransitionTime\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"ExistingConditions\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"GatewayRef\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"Generation\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"TransitionTime\"),\n\t\t\t\tcmpopts.IgnoreFields(status.RouteConditionsUpdate{}, \"Resource\"),\n\t\t\t\tcmpopts.SortSlices(func(i, j metav1.Condition) bool {\n\t\t\t\t\treturn i.Message < j.Message\n\t\t\t\t}),\n\t\t\t}\n\n\t\t\tif diff := cmp.Diff(tc.want, gotUpdates, ops...); diff != \"\" {\n\t\t\t\tt.Fatalf(\"expected: %v, got %v\", tc.want, diff)\n\t\t\t}\n\n\t\t})\n\t}\n\n\tgateways := []*gatewayapi_v1alpha1.Gateway{{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     443,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.TLSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\t// Mode is not defined and should default to \"Terminate\".\n\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\tKind:  \"Secret\",\n\t\t\t\t\t\tName:  fixture.SecretProjectContourCert.Name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tKind: KindTLSRoute,\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}, {\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     443,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.TLSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\tMode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModeTerminate),\n\t\t\t\t\tCertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{\n\t\t\t\t\t\tGroup: \"core\",\n\t\t\t\t\t\tKind:  \"Secret\",\n\t\t\t\t\t\tName:  fixture.SecretProjectContourCert.Name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tKind: KindTLSRoute,\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}, {\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"contour\",\n\t\t\tNamespace: \"projectcontour\",\n\t\t},\n\t\tSpec: gatewayapi_v1alpha1.GatewaySpec{\n\t\t\tListeners: []gatewayapi_v1alpha1.Listener{{\n\t\t\t\tPort:     443,\n\t\t\t\tProtocol: gatewayapi_v1alpha1.TLSProtocolType,\n\t\t\t\tTLS: &gatewayapi_v1alpha1.GatewayTLSConfig{\n\t\t\t\t\tMode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModePassthrough),\n\t\t\t\t},\n\t\t\t\tRoutes: gatewayapi_v1alpha1.RouteBindingSelector{\n\t\t\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tKind: KindTLSRoute,\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}}\n\n\tkuardService := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tName:       \"http\",\n\t\t\t\tProtocol:   \"TCP\",\n\t\t\t\tPort:       8080,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t},\n\t}\n\n\t// Both a \"mode: terminate\" & a \"mode: passthrough\" should return the same\n\t// valid status. This loops through all three types (Not Defined, Terminate, Passthrough)\n\t// and validates the proper status is set. Note when not defined, the default is \"terminate\".\n\tfor _, gw := range gateways {\n\n\t\trun(t, \"TLSRoute: spec.rules.forwardTo.serviceName not specified\", testcase{\n\t\t\tgateway: gw,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\"test.projectcontour.io\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{\n\t\t\t\t\t\t\t\tServiceName: nil,\n\t\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\t\tMessage: \"Spec.Rules.ForwardTo.ServiceName must be specified\",\n\t\t\t\t\t},\n\t\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  \"ErrorsExist\",\n\t\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t})\n\n\t\trun(t, \"TLSRoute: spec.rules.forwardTo.serviceName invalid on two matches\", testcase{\n\t\t\tgateway: gw,\n\t\t\tobjs: []interface{}{\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\"test.projectcontour.io\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{\n\t\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"invalid-one\"),\n\t\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\"another.projectcontour.io\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{\n\t\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"invalid-two\"),\n\t\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\t\tMessage: \"service \\\"invalid-one\\\" is invalid: service \\\"default/invalid-one\\\" not found, service \\\"invalid-two\\\" is invalid: service \\\"default/invalid-two\\\" not found\",\n\t\t\t\t\t},\n\t\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  \"ErrorsExist\",\n\t\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t})\n\n\t\trun(t, \"TLSRoute: spec.rules.forwardTo.servicePort not specified\", testcase{\n\t\t\tgateway: gw,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\"test.projectcontour.io\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{\n\t\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\t\tPort:        nil,\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\t\tMessage: \"Spec.Rules.ForwardTo.ServicePort must be specified\",\n\t\t\t\t\t},\n\t\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  \"ErrorsExist\",\n\t\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t})\n\n\t\trun(t, \"TLSRoute: spec.rules.forwardTo not specified\", testcase{\n\t\t\tgateway: gw,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\"test.projectcontour.io\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\t\tMessage: \"At least one Spec.Rules.ForwardTo must be specified.\",\n\t\t\t\t\t},\n\t\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  \"ErrorsExist\",\n\t\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t})\n\n\t\trun(t, \"TLSRoute: spec.rules.hostname: invalid wildcard\", testcase{\n\t\t\tgateway: gw,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\"*.*.projectcontour.io\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{\n\t\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\t\tMessage: \"invalid hostname \\\"*.*.projectcontour.io\\\": [a wildcard DNS-1123 subdomain must start with '*.', followed by a valid DNS subdomain, which must consist of lower case alphanumeric characters, '-' or '.' and end with an alphanumeric character (e.g. '*.example.com', regex used for validation is '\\\\*\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*')]\",\n\t\t\t\t\t},\n\t\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  \"ErrorsExist\",\n\t\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t})\n\n\t\trun(t, \"TLSRoute: spec.rules.hostname: invalid hostname\", testcase{\n\t\t\tgateway: gw,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\"#projectcontour.io\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{\n\t\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\t\tMessage: \"invalid hostname \\\"#projectcontour.io\\\": [a lowercase RFC 1123 subdomain must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character (e.g. 'example.com', regex used for validation is '[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*')]\",\n\t\t\t\t\t},\n\t\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  \"ErrorsExist\",\n\t\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t})\n\n\t\trun(t, \"TLSRoute: spec.rules.hostname: invalid hostname, ip address\", testcase{\n\t\t\tgateway: gw,\n\t\t\tobjs: []interface{}{\n\t\t\t\tkuardService,\n\t\t\t\t&gatewayapi_v1alpha1.TLSRoute{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tName:      \"basic\",\n\t\t\t\t\t\tNamespace: \"default\",\n\t\t\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\t\t\"app\": \"contour\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tSpec: gatewayapi_v1alpha1.TLSRouteSpec{\n\t\t\t\t\t\tGateways: &gatewayapi_v1alpha1.RouteGateways{\n\t\t\t\t\t\t\tAllow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRules: []gatewayapi_v1alpha1.TLSRouteRule{{\n\t\t\t\t\t\t\tMatches: []gatewayapi_v1alpha1.TLSRouteMatch{{\n\t\t\t\t\t\t\t\tSNIs: []gatewayapi_v1alpha1.Hostname{\"1.2.3.4\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\tForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{\n\t\t\t\t\t\t\t\tServiceName: pointer.StringPtr(\"kuard\"),\n\t\t\t\t\t\t\t\tPort:        gatewayPort(8080),\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\twant: []*status.RouteConditionsUpdate{{\n\t\t\t\tFullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},\n\t\t\t\tConditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{\n\t\t\t\t\tstatus.ConditionResolvedRefs: {\n\t\t\t\t\t\tType:    string(status.ConditionResolvedRefs),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  string(status.ReasonDegraded),\n\t\t\t\t\t\tMessage: \"hostname \\\"1.2.3.4\\\" must be a DNS name, not an IP address\",\n\t\t\t\t\t},\n\t\t\t\t\tgatewayapi_v1alpha1.ConditionRouteAdmitted: {\n\t\t\t\t\t\tType:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),\n\t\t\t\t\t\tStatus:  contour_api_v1.ConditionFalse,\n\t\t\t\t\t\tReason:  \"ErrorsExist\",\n\t\t\t\t\t\tMessage: \"Errors found, check other Conditions for details.\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t})\n\t}\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage v3\n\nimport (\n\t\"testing\"\n\n\t\"github.com/projectcontour/contour/internal/contour\"\n\t\"github.com/projectcontour/contour/internal/dag\"\n\t\"github.com/projectcontour/contour/internal/featuretests\"\n\t\"github.com/sirupsen/logrus\"\n\n\tenvoy_cluster_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3\"\n\tenvoy_route_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/route/v3\"\n\tenvoy_extensions_upstream_http_v3 \"github.com/envoyproxy/go-control-plane/envoy/extensions/upstreams/http/v3\"\n\tenvoy_discovery_v3 \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"\n\t\"github.com/golang/protobuf/ptypes/any\"\n\tcontour_api_v1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"\n\tenvoy_v3 \"github.com/projectcontour/contour/internal/envoy/v3\"\n\t\"github.com/projectcontour/contour/internal/fixture\"\n\t\"github.com/projectcontour/contour/internal/protobuf\"\n\tv1 \"k8s.io/api/core/v1\"\n\tnetworking_v1 \"k8s.io/api/networking/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n\t\"k8s.io/utils/pointer\"\n)\n\n// Assert that services of type v1.ServiceTypeExternalName can be\n// referenced by an Ingress, or HTTPProxy document.\nfunc TestExternalNameService(t *testing.T) {\n\trh, c, done := setup(t, enableExternalNameService(t))\n\tdefer done()\n\n\ts1 := fixture.NewService(\"kuard\").\n\t\tWithSpec(v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tPort:       80,\n\t\t\t\tTargetPort: intstr.FromInt(8080),\n\t\t\t}},\n\t\t\tExternalName: \"foo.io\",\n\t\t\tType:         v1.ServiceTypeExternalName,\n\t\t})\n\n\ti1 := &networking_v1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"kuard\",\n\t\t\tNamespace: s1.Namespace,\n\t\t},\n\t\tSpec: networking_v1.IngressSpec{\n\t\t\tDefaultBackend: featuretests.IngressBackend(s1),\n\t\t},\n\t}\n\trh.OnAdd(s1)\n\trh.OnAdd(i1)\n\n\tc.Request(routeType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tResources: resources(t,\n\t\t\tenvoy_v3.RouteConfiguration(\"ingress_http\",\n\t\t\t\tenvoy_v3.VirtualHost(\"*\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch:  routePrefix(\"/\"),\n\t\t\t\t\t\tAction: routeCluster(\"default/kuard/80/da39a3ee5e\"),\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t\tTypeUrl: routeType,\n\t})\n\n\tc.Request(clusterType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tResources: resources(t,\n\t\t\texternalNameCluster(\"default/kuard/80/da39a3ee5e\", \"default/kuard\", \"default_kuard_80\", \"foo.io\", 80),\n\t\t),\n\t\tTypeUrl: clusterType,\n\t})\n\n\trh.OnDelete(i1)\n\n\trh.OnAdd(fixture.NewProxy(\"kuard\").\n\t\tWithFQDN(\"kuard.projectcontour.io\").\n\t\tWithSpec(contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t}},\n\t\t}),\n\t)\n\n\tc.Request(routeType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tResources: resources(t,\n\t\t\tenvoy_v3.RouteConfiguration(\"ingress_http\",\n\t\t\t\tenvoy_v3.VirtualHost(\"kuard.projectcontour.io\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch:  routePrefix(\"/\"),\n\t\t\t\t\t\tAction: routeCluster(\"default/kuard/80/da39a3ee5e\"),\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t\tTypeUrl: routeType,\n\t})\n\n\tc.Request(clusterType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tResources: resources(t,\n\t\t\texternalNameCluster(\"default/kuard/80/da39a3ee5e\", \"default/kuard\", \"default_kuard_80\", \"foo.io\", 80),\n\t\t),\n\t\tTypeUrl: clusterType,\n\t})\n\n\t// After we set the Host header, the cluster should remain\n\t// the same, but the Route should do update the Host header.\n\trh.OnDelete(fixture.NewProxy(\"kuard\").WithSpec(contour_api_v1.HTTPProxySpec{}))\n\trh.OnAdd(fixture.NewProxy(\"kuard\").\n\t\tWithFQDN(\"kuard.projectcontour.io\").\n\t\tWithSpec(contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: s1.Name,\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\tValue: \"external.address\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t}),\n\t)\n\n\tc.Request(routeType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tTypeUrl: routeType,\n\t\tResources: resources(t,\n\t\t\tenvoy_v3.RouteConfiguration(\"ingress_http\",\n\t\t\t\tenvoy_v3.VirtualHost(\"kuard.projectcontour.io\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch:  routePrefix(\"/\"),\n\t\t\t\t\t\tAction: routeHostRewrite(\"default/kuard/80/da39a3ee5e\", \"external.address\"),\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t})\n\n\tc.Request(clusterType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tTypeUrl: clusterType,\n\t\tResources: resources(t,\n\t\t\texternalNameCluster(\"default/kuard/80/da39a3ee5e\", \"default/kuard\", \"default_kuard_80\", \"foo.io\", 80),\n\t\t),\n\t})\n\n\t// Now try the same configuration, but enable HTTP/2. We\n\t// should still find that the same configuration applies, but\n\t// TLS is enabled and the SNI server name is overwritten from\n\t// the Host header.\n\trh.OnDelete(fixture.NewProxy(\"kuard\").WithSpec(contour_api_v1.HTTPProxySpec{}))\n\trh.OnAdd(fixture.NewProxy(\"kuard\").\n\t\tWithFQDN(\"kuard.projectcontour.io\").\n\t\tWithSpec(contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tProtocol: pointer.StringPtr(\"h2\"),\n\t\t\t\t\tName:     s1.Name,\n\t\t\t\t\tPort:     80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\tValue: \"external.address\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t}),\n\t)\n\n\tc.Request(routeType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tTypeUrl: routeType,\n\t\tResources: resources(t,\n\t\t\tenvoy_v3.RouteConfiguration(\"ingress_http\",\n\t\t\t\tenvoy_v3.VirtualHost(\"kuard.projectcontour.io\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch:  routePrefix(\"/\"),\n\t\t\t\t\t\tAction: routeHostRewrite(\"default/kuard/80/da39a3ee5e\", \"external.address\"),\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t})\n\n\tc.Request(clusterType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tTypeUrl: clusterType,\n\t\tResources: resources(t,\n\t\t\tDefaultCluster(\n\t\t\t\texternalNameCluster(\"default/kuard/80/da39a3ee5e\", \"default/kuard\", \"default_kuard_80\", \"foo.io\", 80),\n\t\t\t\t&envoy_cluster_v3.Cluster{\n\t\t\t\t\tTypedExtensionProtocolOptions: map[string]*any.Any{\n\t\t\t\t\t\t\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\": protobuf.MustMarshalAny(\n\t\t\t\t\t\t\t&envoy_extensions_upstream_http_v3.HttpProtocolOptions{\n\t\t\t\t\t\t\t\tUpstreamProtocolOptions: &envoy_extensions_upstream_http_v3.HttpProtocolOptions_ExplicitHttpConfig_{\n\t\t\t\t\t\t\t\t\tExplicitHttpConfig: &envoy_extensions_upstream_http_v3.HttpProtocolOptions_ExplicitHttpConfig{\n\t\t\t\t\t\t\t\t\t\tProtocolConfig: &envoy_extensions_upstream_http_v3.HttpProtocolOptions_ExplicitHttpConfig_Http2ProtocolOptions{},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t&envoy_cluster_v3.Cluster{\n\t\t\t\t\tTransportSocket: envoy_v3.UpstreamTLSTransportSocket(\n\t\t\t\t\t\tenvoy_v3.UpstreamTLSContext(nil, \"external.address\", nil, \"h2\"),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t),\n\t})\n\n\t// Now try the same configuration, but enable TLS (which\n\t// means HTTP/1.1 over TLS) rather than HTTP/2. We should get\n\t// TLS enabled with the overridden SNI name. but no HTTP/2\n\t// protocol config.\n\trh.OnDelete(fixture.NewProxy(\"kuard\").WithSpec(contour_api_v1.HTTPProxySpec{}))\n\trh.OnAdd(fixture.NewProxy(\"kuard\").\n\t\tWithFQDN(\"kuard.projectcontour.io\").\n\t\tWithSpec(contour_api_v1.HTTPProxySpec{\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tProtocol: pointer.StringPtr(\"tls\"),\n\t\t\t\t\tName:     s1.Name,\n\t\t\t\t\tPort:     80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\tValue: \"external.address\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t}),\n\t)\n\n\tc.Request(routeType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tTypeUrl: routeType,\n\t\tResources: resources(t,\n\t\t\tenvoy_v3.RouteConfiguration(\"ingress_http\",\n\t\t\t\tenvoy_v3.VirtualHost(\"kuard.projectcontour.io\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch:  routePrefix(\"/\"),\n\t\t\t\t\t\tAction: routeHostRewrite(\"default/kuard/80/da39a3ee5e\", \"external.address\"),\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t})\n\n\tc.Request(clusterType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tTypeUrl: clusterType,\n\t\tResources: resources(t,\n\t\t\tDefaultCluster(\n\t\t\t\texternalNameCluster(\"default/kuard/80/da39a3ee5e\", \"default/kuard\", \"default_kuard_80\", \"foo.io\", 80),\n\t\t\t\t&envoy_cluster_v3.Cluster{\n\t\t\t\t\tTransportSocket: envoy_v3.UpstreamTLSTransportSocket(\n\t\t\t\t\t\tenvoy_v3.UpstreamTLSContext(nil, \"external.address\", nil),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t),\n\t})\n\n\tsec1 := &v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"secret\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tType: \"kubernetes.io/tls\",\n\t\tData: featuretests.Secretdata(featuretests.CERTIFICATE, featuretests.RSA_PRIVATE_KEY),\n\t}\n\n\t// Create TCPProxy with upstream protocol 'tls' to an externalName type service\n\t// and verify that the SNI on the upstream request matches the externalName value.\n\trh.OnDelete(fixture.NewProxy(\"kuard\").WithSpec(contour_api_v1.HTTPProxySpec{}))\n\trh.OnAdd(sec1)\n\trh.OnAdd(fixture.NewProxy(\"kuard\").\n\t\tWithFQDN(\"kuard.projectcontour.io\").\n\t\tWithCertificate(sec1.Name).\n\t\tWithSpec(contour_api_v1.HTTPProxySpec{\n\t\t\tTCPProxy: &contour_api_v1.TCPProxy{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tProtocol: pointer.StringPtr(\"tls\"),\n\t\t\t\t\tName:     s1.Name,\n\t\t\t\t\tPort:     80,\n\t\t\t\t}},\n\t\t\t},\n\t\t}),\n\t)\n\n\tc.Request(clusterType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tTypeUrl: clusterType,\n\t\tResources: resources(t,\n\t\t\tDefaultCluster(\n\t\t\t\texternalNameCluster(\"default/kuard/80/da39a3ee5e\", \"default/kuard\", \"default_kuard_80\", \"foo.io\", 80),\n\t\t\t\t&envoy_cluster_v3.Cluster{\n\t\t\t\t\tTransportSocket: envoy_v3.UpstreamTLSTransportSocket(\n\t\t\t\t\t\tenvoy_v3.UpstreamTLSContext(nil, \"foo.io\", nil),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t),\n\t\t),\n\t})\n}\n\nfunc enableExternalNameService(t *testing.T) func(eh *contour.EventHandler) {\n\treturn func(eh *contour.EventHandler) {\n\n\t\tlog := fixture.NewTestLogger(t)\n\t\tlog.SetLevel(logrus.DebugLevel)\n\n\t\teh.Builder.Processors = []dag.Processor{\n\t\t\t&dag.IngressProcessor{\n\t\t\t\tEnableExternalNameService: true,\n\t\t\t\tFieldLogger:               log.WithField(\"context\", \"IngressProcessor\"),\n\t\t\t},\n\t\t\t&dag.HTTPProxyProcessor{\n\t\t\t\tEnableExternalNameService: true,\n\t\t\t},\n\t\t\t&dag.ExtensionServiceProcessor{\n\t\t\t\tFieldLogger: log.WithField(\"context\", \"ExtensionServiceProcessor\"),\n\t\t\t},\n\t\t\t&dag.ListenerProcessor{},\n\t\t}\n\t}\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage v3\n\nimport (\n\t\"testing\"\n\n\tenvoy_core_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/core/v3\"\n\tenvoy_route_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/route/v3\"\n\tenvoy_discovery_v3 \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"\n\t\"github.com/golang/protobuf/ptypes/wrappers\"\n\tcontour_api_v1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"\n\tenvoy_v3 \"github.com/projectcontour/contour/internal/envoy/v3\"\n\t\"github.com/projectcontour/contour/internal/featuretests\"\n\t\"github.com/projectcontour/contour/internal/fixture\"\n\tv1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n)\n\nfunc TestHeaderPolicy_ReplaceHeader_HTTProxy(t *testing.T) {\n\t// Enable ExternalName processing here because\n\t// we need to check that host rewrites work in combination\n\t// with ExternalName.\n\trh, c, done := setup(t, enableExternalNameService(t))\n\tdefer done()\n\n\trh.OnAdd(fixture.NewService(\"svc1\").\n\t\tWithPorts(v1.ServicePort{Port: 80, TargetPort: intstr.FromInt(8080)}),\n\t)\n\n\trh.OnAdd(fixture.NewProxy(\"simple\").WithSpec(\n\t\tcontour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{Fqdn: \"hello.world\"},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"svc1\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\tValue: \"goodbye.planet\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t}),\n\t)\n\n\tc.Request(routeType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tResources: resources(t,\n\t\t\tenvoy_v3.RouteConfiguration(\"ingress_http\",\n\t\t\t\tenvoy_v3.VirtualHost(\"hello.world\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch:  routePrefix(\"/\"),\n\t\t\t\t\t\tAction: routeHostRewrite(\"default/svc1/80/da39a3ee5e\", \"goodbye.planet\"),\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t\tTypeUrl: routeType,\n\t})\n\n\t// Non-Host header\n\trh.OnAdd(fixture.NewProxy(\"simple\").WithSpec(\n\t\tcontour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{Fqdn: \"hello.world\"},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"svc1\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"x-header\",\n\t\t\t\t\t\tValue: \"goodbye.planet\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t}),\n\t)\n\n\tc.Request(routeType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tResources: resources(t,\n\t\t\tenvoy_v3.RouteConfiguration(\"ingress_http\",\n\t\t\t\tenvoy_v3.VirtualHost(\"hello.world\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch:  routePrefix(\"/\"),\n\t\t\t\t\t\tAction: routeCluster(\"default/svc1/80/da39a3ee5e\"),\n\t\t\t\t\t\tRequestHeadersToAdd: []*envoy_core_v3.HeaderValueOption{{\n\t\t\t\t\t\t\tHeader: &envoy_core_v3.HeaderValue{\n\t\t\t\t\t\t\t\tKey:   \"X-Header\",\n\t\t\t\t\t\t\t\tValue: \"goodbye.planet\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tAppend: &wrappers.BoolValue{\n\t\t\t\t\t\t\t\tValue: false,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t\tTypeUrl: routeType,\n\t})\n\n\t// Empty value for replaceHeader in HeadersPolicy\n\trh.OnAdd(fixture.NewProxy(\"simple\").WithSpec(\n\t\tcontour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{Fqdn: \"hello.world\"},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"svc1\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName: \"Host\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t}),\n\t)\n\n\tc.Request(routeType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tResources: resources(t,\n\t\t\tenvoy_v3.RouteConfiguration(\"ingress_http\",\n\t\t\t\tenvoy_v3.VirtualHost(\"hello.world\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch:  routePrefix(\"/\"),\n\t\t\t\t\t\tAction: routeCluster(\"default/svc1/80/da39a3ee5e\"),\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t\tTypeUrl: routeType,\n\t})\n\n\trh.OnAdd(fixture.NewService(\"externalname\").\n\t\tAnnotate(\"projectcontour.io/upstream-protocol.tls\", \"https,443\").\n\t\tWithSpec(v1.ServiceSpec{\n\t\t\tExternalName: \"goodbye.planet\",\n\t\t\tType:         v1.ServiceTypeExternalName,\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tPort: 443,\n\t\t\t\tName: \"https\",\n\t\t\t}},\n\t\t}),\n\t)\n\n\trh.OnAdd(&v1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"foo\",\n\t\t\tNamespace: \"default\",\n\t\t},\n\t\tType: \"kubernetes.io/tls\",\n\t\tData: featuretests.Secretdata(featuretests.CERTIFICATE, featuretests.RSA_PRIVATE_KEY),\n\t})\n\n\t// Proxy with SNI\n\trh.OnAdd(fixture.NewProxy(\"simple\").WithSpec(\n\t\tcontour_api_v1.HTTPProxySpec{\n\t\t\tVirtualHost: &contour_api_v1.VirtualHost{\n\t\t\t\tFqdn: \"hello.world\",\n\t\t\t\tTLS:  &contour_api_v1.TLS{SecretName: \"foo\"},\n\t\t\t},\n\t\t\tRoutes: []contour_api_v1.Route{{\n\t\t\t\tServices: []contour_api_v1.Service{{\n\t\t\t\t\tName: \"externalname\",\n\t\t\t\t\tPort: 443,\n\t\t\t\t}},\n\t\t\t\tRequestHeadersPolicy: &contour_api_v1.HeadersPolicy{\n\t\t\t\t\tSet: []contour_api_v1.HeaderValue{{\n\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\tValue: \"goodbye.planet\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}},\n\t\t}),\n\t)\n\n\tc.Request(routeType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tResources: routeResources(t,\n\t\t\tenvoy_v3.RouteConfiguration(\"ingress_http\",\n\t\t\t\tenvoy_v3.VirtualHost(\"hello.world\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch: routePrefix(\"/\"),\n\t\t\t\t\t\tAction: &envoy_route_v3.Route_Redirect{\n\t\t\t\t\t\t\tRedirect: &envoy_route_v3.RedirectAction{\n\t\t\t\t\t\t\t\tSchemeRewriteSpecifier: &envoy_route_v3.RedirectAction_HttpsRedirect{\n\t\t\t\t\t\t\t\t\tHttpsRedirect: true,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t),\n\t\t\tenvoy_v3.RouteConfiguration(\"https/hello.world\",\n\t\t\t\tenvoy_v3.VirtualHost(\"hello.world\",\n\t\t\t\t\t&envoy_route_v3.Route{\n\t\t\t\t\t\tMatch:  routePrefix(\"/\"),\n\t\t\t\t\t\tAction: routeHostRewrite(\"default/externalname/443/da39a3ee5e\", \"goodbye.planet\"),\n\t\t\t\t\t},\n\t\t\t\t)),\n\t\t),\n\t\tTypeUrl: routeType,\n\t})\n\n\tc.Request(clusterType).Equals(&envoy_discovery_v3.DiscoveryResponse{\n\t\tResources: resources(t,\n\t\t\ttlsCluster(externalNameCluster(\"default/externalname/443/da39a3ee5e\", \"default/externalname/https\", \"default_externalname_443\", \"goodbye.planet\", 443), nil, \"goodbye.planet\", \"goodbye.planet\", nil),\n\t\t),\n\t\tTypeUrl: clusterType,\n\t})\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage config\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gopkg.in/yaml.v2\"\n\t\"k8s.io/apimachinery/pkg/util/validation\"\n)\n\n// ServerType is the name of a xDS server implementation.\ntype ServerType string\n\nconst ContourServerType ServerType = \"contour\"\nconst EnvoyServerType ServerType = \"envoy\"\n\n// Validate the xDS server type.\nfunc (s ServerType) Validate() error {\n\tswitch s {\n\tcase ContourServerType, EnvoyServerType:\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid xDS server type %q\", s)\n\t}\n}\n\n// Validate the GatewayConfig.\nfunc (g *GatewayParameters) Validate() error {\n\n\tvar errorString string\n\tif g == nil {\n\t\treturn nil\n\t}\n\n\tif len(g.Name) == 0 && len(g.Namespace) == 0 && len(g.ControllerName) == 0 {\n\t\treturn nil\n\t}\n\n\tif len(g.Name) == 0 {\n\t\terrorString = \"name required\"\n\t}\n\tif len(g.Namespace) == 0 {\n\t\tif len(errorString) > 0 {\n\t\t\terrorString += \",\"\n\t\t}\n\t\terrorString = strings.TrimSpace(fmt.Sprintf(\"%s namespace required\", errorString))\n\t}\n\tif len(g.ControllerName) == 0 {\n\t\tif len(errorString) > 0 {\n\t\t\terrorString += \",\"\n\t\t}\n\t\terrorString = strings.TrimSpace(fmt.Sprintf(\"%s controllerName required\", errorString))\n\t}\n\n\tif len(errorString) > 0 {\n\t\treturn fmt.Errorf(\"invalid Gateway parameters specified: %s\", errorString)\n\t}\n\treturn nil\n}\n\n// ResourceVersion is a version of an xDS server.\ntype ResourceVersion string\n\nconst XDSv3 ResourceVersion = \"v3\"\n\n// Validate the xDS server versions.\nfunc (s ResourceVersion) Validate() error {\n\tswitch s {\n\tcase XDSv3:\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid xDS version %q\", s)\n\t}\n}\n\n// ClusterDNSFamilyType is the Ip family to use for resolving DNS\n// names in an Envoy cluster configuration.\ntype ClusterDNSFamilyType string\n\nfunc (c ClusterDNSFamilyType) Validate() error {\n\tswitch c {\n\tcase AutoClusterDNSFamily, IPv4ClusterDNSFamily, IPv6ClusterDNSFamily:\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid cluster DNS lookup family %q\", c)\n\t}\n}\n\nconst AutoClusterDNSFamily ClusterDNSFamilyType = \"auto\"\nconst IPv4ClusterDNSFamily ClusterDNSFamilyType = \"v4\"\nconst IPv6ClusterDNSFamily ClusterDNSFamilyType = \"v6\"\n\n// AccessLogType is the name of a supported access logging mechanism.\ntype AccessLogType string\n\nfunc (a AccessLogType) Validate() error {\n\tswitch a {\n\tcase EnvoyAccessLog, JSONAccessLog:\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid access log format %q\", a)\n\t}\n}\n\nconst EnvoyAccessLog AccessLogType = \"envoy\"\nconst JSONAccessLog AccessLogType = \"json\"\n\ntype AccessLogFields []string\n\nfunc (a AccessLogFields) Validate() error {\n\t// Capture Groups:\n\t// Given string \"the start time is %START_TIME(%s):3% wow!\"\n\t//\n\t//   0. Whole match \"%START_TIME(%s):3%\"\n\t//   1. Full operator: \"START_TIME(%s):3%\"\n\t//   2. Operator Name: \"START_TIME\"\n\t//   3. Arguments: \"(%s)\"\n\t//   4. Truncation length: \":3\"\n\tre := regexp.MustCompile(`%(([A-Z_]+)(\\([^)]+\\)(:[0-9]+)?)?%)?`)\n\n\tfor key, val := range a.AsFieldMap() {\n\t\tif val == \"\" {\n\t\t\treturn fmt.Errorf(\"invalid JSON log field name %s\", key)\n\t\t}\n\n\t\tif jsonFields[key] == val {\n\t\t\tcontinue\n\t\t}\n\n\t\t// FindAllStringSubmatch will always return a slice with matches where every slice is a slice\n\t\t// of submatches with length of 5 (number of capture groups + 1).\n\t\ttokens := re.FindAllStringSubmatch(val, -1)\n\t\tif len(tokens) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, f := range tokens {\n\t\t\top := f[2]\n\t\t\tif op == \"\" {\n\t\t\t\treturn fmt.Errorf(\"invalid JSON field: %s, invalid Envoy format: %s\", val, f)\n\t\t\t}\n\n\t\t\t_, okSimple := envoySimpleOperators[op]\n\t\t\t_, okComplex := envoyComplexOperators[op]\n\t\t\tif !okSimple && !okComplex {\n\t\t\t\treturn fmt.Errorf(\"invalid JSON field: %s, invalid Envoy format: %s, invalid Envoy operator: %s\", val, f, op)\n\t\t\t}\n\n\t\t\tif (op == \"REQ\" || op == \"RESP\" || op == \"TRAILER\") && f[3] == \"\" {\n\t\t\t\treturn fmt.Errorf(\"invalid JSON field: %s, invalid Envoy format: %s, arguments required for operator: %s\", val, f, op)\n\t\t\t}\n\n\t\t\t// START_TIME cannot not have truncation length.\n\t\t\tif op == \"START_TIME\" && f[4] != \"\" {\n\t\t\t\treturn fmt.Errorf(\"invalid JSON field: %s, invalid Envoy format: %s, operator %s cannot have truncation length\", val, f, op)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (a AccessLogFields) AsFieldMap() map[string]string {\n\tfieldMap := map[string]string{}\n\n\tfor _, val := range a {\n\t\tparts := strings.SplitN(val, \"=\", 2)\n\n\t\tif len(parts) == 1 {\n\t\t\toperator, foundInFieldMapping := jsonFields[val]\n\t\t\t_, isSimpleOperator := envoySimpleOperators[strings.ToUpper(val)]\n\n\t\t\tif isSimpleOperator && !foundInFieldMapping {\n\t\t\t\t// Operator name is known to be simple, upcase and wrap it in percents.\n\t\t\t\tfieldMap[val] = fmt.Sprintf(\"%%%s%%\", strings.ToUpper(val))\n\t\t\t} else if foundInFieldMapping {\n\t\t\t\t// Operator name has a known mapping, store the result of the mapping.\n\t\t\t\tfieldMap[val] = operator\n\t\t\t} else {\n\t\t\t\t// Operator name not found, save as emptystring and let validation catch it later.\n\t\t\t\tfieldMap[val] = \"\"\n\t\t\t}\n\t\t} else {\n\t\t\t// Value is a full key:value pair, store it as is.\n\t\t\tfieldMap[parts[0]] = parts[1]\n\t\t}\n\t}\n\n\treturn fieldMap\n}\n\n// HTTPVersionType is the name of a supported HTTP version.\ntype HTTPVersionType string\n\nfunc (h HTTPVersionType) Validate() error {\n\tswitch h {\n\tcase HTTPVersion1, HTTPVersion2:\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid HTTP version %q\", h)\n\t}\n}\n\nconst HTTPVersion1 HTTPVersionType = \"http/1.1\"\nconst HTTPVersion2 HTTPVersionType = \"http/2\"\n\n// NamespacedName defines the namespace/name of the Kubernetes resource referred from the configuration file.\n// Used for Contour configuration YAML file parsing, otherwise we could use K8s types.NamespacedName.\ntype NamespacedName struct {\n\tName      string `yaml:\"name\"`\n\tNamespace string `yaml:\"namespace\"`\n}\n\n// Validate that both name fields are present, or neither are.\nfunc (n NamespacedName) Validate() error {\n\tif len(strings.TrimSpace(n.Name)) == 0 && len(strings.TrimSpace(n.Namespace)) == 0 {\n\t\treturn nil\n\t}\n\n\tif len(strings.TrimSpace(n.Namespace)) == 0 {\n\t\treturn errors.New(\"namespace must be defined\")\n\t}\n\n\tif len(strings.TrimSpace(n.Name)) == 0 {\n\t\treturn errors.New(\"name must be defined\")\n\t}\n\n\treturn nil\n}\n\n// TLSParameters holds configuration file TLS configuration details.\ntype TLSParameters struct {\n\tMinimumProtocolVersion string `yaml:\"minimum-protocol-version\"`\n\n\t// FallbackCertificate defines the namespace/name of the Kubernetes secret to\n\t// use as fallback when a non-SNI request is received.\n\tFallbackCertificate NamespacedName `yaml:\"fallback-certificate,omitempty\"`\n\n\t// ClientCertificate defines the namespace/name of the Kubernetes\n\t// secret containing the client certificate and private key\n\t// to be used when establishing TLS connection to upstream\n\t// cluster.\n\tClientCertificate NamespacedName `yaml:\"envoy-client-certificate,omitempty\"`\n\n\t// CipherSuites defines the TLS ciphers to be supported by Envoy TLS\n\t// listeners when negotiating TLS 1.2. Ciphers are validated against the\n\t// set that Envoy supports by default. This parameter should only be used\n\t// by advanced users. Note that these will be ignored when TLS 1.3 is in\n\t// use.\n\tCipherSuites TLSCiphers `yaml:\"cipher-suites,omitempty\"`\n}\n\n// Validate TLS fallback certificate, client certificate, and cipher suites\nfunc (t TLSParameters) Validate() error {\n\t// Check TLS secret names.\n\tif err := t.FallbackCertificate.Validate(); err != nil {\n\t\treturn fmt.Errorf(\"invalid TLS fallback certificate: %w\", err)\n\t}\n\n\tif err := t.ClientCertificate.Validate(); err != nil {\n\t\treturn fmt.Errorf(\"invalid TLS client certificate: %w\", err)\n\t}\n\n\tif err := t.CipherSuites.Validate(); err != nil {\n\t\treturn fmt.Errorf(\"invalid TLS cipher suites: %w\", err)\n\t}\n\n\treturn nil\n}\n\n// ServerParameters holds the configuration for the Contour xDS server.\ntype ServerParameters struct {\n\t// Defines the XDSServer to use for `contour serve`.\n\t// Defaults to \"contour\"\n\tXDSServerType ServerType `yaml:\"xds-server-type,omitempty\"`\n}\n\n// GatewayParameters holds the configuration for Gateway API controllers.\ntype GatewayParameters struct {\n\t// ControllerName is used to determine whether Contour should reconcile a\n\t// GatewayClass. The string takes the form of \"projectcontour.io/<namespace>/contour\".\n\t// If unset, the gatewayclass controller will not be started.\n\tControllerName string `yaml:\"controllerName,omitempty\"`\n\t// Name is the Gateway name that Contour should reconcile.\n\t// Deprecated: Name is deprecated and will be removed in Contour v1.18. Configure \"ControllerName\" instead.\n\tName string `yaml:\"name,omitempty\"`\n\t// Namespace is the Gateway namespace that Contour should reconcile.\n\t// Deprecated: Namespace is deprecated will be removed in Contour v1.18. Configure \"ControllerName\" instead.\n\tNamespace string `yaml:\"namespace,omitempty\"`\n}\n\n// LeaderElectionParameters holds the config bits for leader election\n// inside the  configuration file.\ntype LeaderElectionParameters struct {\n\tLeaseDuration time.Duration `yaml:\"lease-duration,omitempty\"`\n\tRenewDeadline time.Duration `yaml:\"renew-deadline,omitempty\"`\n\tRetryPeriod   time.Duration `yaml:\"retry-period,omitempty\"`\n\tNamespace     string        `yaml:\"configmap-namespace,omitempty\"`\n\tName          string        `yaml:\"configmap-name,omitempty\"`\n}\n\n// TimeoutParameters holds various configurable proxy timeout values.\ntype TimeoutParameters struct {\n\t// RequestTimeout sets the client request timeout globally for Contour. Note that\n\t// this is a timeout for the entire request, not an idle timeout. Omit or set to\n\t// \"infinity\" to disable the timeout entirely.\n\t//\n\t// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-request-timeout\n\t// for more information.\n\tRequestTimeout string `yaml:\"request-timeout,omitempty\"`\n\n\t// ConnectionIdleTimeout defines how long the proxy should wait while there are\n\t// no active requests (for HTTP/1.1) or streams (for HTTP/2) before terminating\n\t// an HTTP connection. Set to \"infinity\" to disable the timeout entirely.\n\t//\n\t// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-idle-timeout\n\t// for more information.\n\tConnectionIdleTimeout string `yaml:\"connection-idle-timeout,omitempty\"`\n\n\t// StreamIdleTimeout defines how long the proxy should wait while there is no\n\t// request activity (for HTTP/1.1) or stream activity (for HTTP/2) before\n\t// terminating the HTTP request or stream. Set to \"infinity\" to disable the\n\t// timeout entirely.\n\t//\n\t// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-stream-idle-timeout\n\t// for more information.\n\tStreamIdleTimeout string `yaml:\"stream-idle-timeout,omitempty\"`\n\n\t// MaxConnectionDuration defines the maximum period of time after an HTTP connection\n\t// has been established from the client to the proxy before it is closed by the proxy,\n\t// regardless of whether there has been activity or not. Omit or set to \"infinity\" for\n\t// no max duration.\n\t//\n\t// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-max-connection-duration\n\t// for more information.\n\tMaxConnectionDuration string `yaml:\"max-connection-duration,omitempty\"`\n\n\t// DelayedCloseTimeout defines how long envoy will wait, once connection\n\t// close processing has been initiated, for the downstream peer to close\n\t// the connection before Envoy closes the socket associated with the connection.\n\t//\n\t// Setting this timeout to 'infinity' will disable it, equivalent to setting it to '0'\n\t// in Envoy. Leaving it unset will result in the Envoy default value being used.\n\t//\n\t// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-delayed-close-timeout\n\t// for more information.\n\tDelayedCloseTimeout string `yaml:\"delayed-close-timeout,omitempty\"`\n\n\t// ConnectionShutdownGracePeriod defines how long the proxy will wait between sending an\n\t// initial GOAWAY frame and a second, final GOAWAY frame when terminating an HTTP/2 connection.\n\t// During this grace period, the proxy will continue to respond to new streams. After the final\n\t// GOAWAY frame has been sent, the proxy will refuse new streams.\n\t//\n\t// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-drain-timeout\n\t// for more information.\n\tConnectionShutdownGracePeriod string `yaml:\"connection-shutdown-grace-period,omitempty\"`\n}\n\n// Validate the timeout parameters.\nfunc (t TimeoutParameters) Validate() error {\n\t// We can't use `timeout.Parse` for validation here because\n\t// that would make an exported package depend on an internal\n\t// package.\n\tv := func(str string) error {\n\t\tswitch str {\n\t\tcase \"\", \"infinity\", \"infinite\":\n\t\t\treturn nil\n\t\tdefault:\n\t\t\t_, err := time.ParseDuration(str)\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := v(t.RequestTimeout); err != nil {\n\t\treturn fmt.Errorf(\"invalid request timeout %q: %w\", t.RequestTimeout, err)\n\t}\n\n\tif err := v(t.ConnectionIdleTimeout); err != nil {\n\t\treturn fmt.Errorf(\"connection idle timeout %q: %w\", t.ConnectionIdleTimeout, err)\n\t}\n\n\tif err := v(t.StreamIdleTimeout); err != nil {\n\t\treturn fmt.Errorf(\"stream idle timeout %q: %w\", t.StreamIdleTimeout, err)\n\t}\n\n\tif err := v(t.MaxConnectionDuration); err != nil {\n\t\treturn fmt.Errorf(\"max connection duration %q: %w\", t.MaxConnectionDuration, err)\n\t}\n\n\tif err := v(t.DelayedCloseTimeout); err != nil {\n\t\treturn fmt.Errorf(\"delayed close timeout %q: %w\", t.DelayedCloseTimeout, err)\n\t}\n\n\tif err := v(t.ConnectionShutdownGracePeriod); err != nil {\n\t\treturn fmt.Errorf(\"connection shutdown grace period %q: %w\", t.ConnectionShutdownGracePeriod, err)\n\t}\n\n\treturn nil\n}\n\ntype HeadersPolicy struct {\n\tSet    map[string]string `yaml:\"set,omitempty\"`\n\tRemove []string          `yaml:\"remove,omitempty\"`\n}\n\nfunc (h HeadersPolicy) Validate() error {\n\tfor key := range h.Set {\n\t\tif msgs := validation.IsHTTPHeaderName(key); len(msgs) != 0 {\n\t\t\treturn fmt.Errorf(\"invalid header name %q: %v\", key, msgs)\n\t\t}\n\t}\n\tfor _, val := range h.Remove {\n\t\tif msgs := validation.IsHTTPHeaderName(val); len(msgs) != 0 {\n\t\t\treturn fmt.Errorf(\"invalid header name %q: %v\", val, msgs)\n\t\t}\n\t}\n\treturn nil\n}\n\n// PolicyParameters holds default policy used if not explicitly set by the user\ntype PolicyParameters struct {\n\t// RequestHeadersPolicy defines the request headers set/removed on all routes\n\tRequestHeadersPolicy HeadersPolicy `yaml:\"request-headers,omitempty\"`\n\n\t// ResponseHeadersPolicy defines the response headers set/removed on all routes\n\tResponseHeadersPolicy HeadersPolicy `yaml:\"response-headers,omitempty\"`\n}\n\n// Validate the header parameters.\nfunc (h PolicyParameters) Validate() error {\n\tif err := h.RequestHeadersPolicy.Validate(); err != nil {\n\t\treturn err\n\t}\n\tif err := h.ResponseHeadersPolicy.Validate(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// ClusterParameters holds various configurable cluster values.\ntype ClusterParameters struct {\n\t// DNSLookupFamily defines how external names are looked up\n\t// When configured as V4, the DNS resolver will only perform a lookup\n\t// for addresses in the IPv4 family. If V6 is configured, the DNS resolver\n\t// will only perform a lookup for addresses in the IPv6 family.\n\t// If AUTO is configured, the DNS resolver will first perform a lookup\n\t// for addresses in the IPv6 family and fallback to a lookup for addresses\n\t// in the IPv4 family.\n\t// Note: This only applies to externalName clusters.\n\t//\n\t// See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-enum-config-cluster-v3-cluster-dnslookupfamily\n\t// for more information.\n\tDNSLookupFamily ClusterDNSFamilyType `yaml:\"dns-lookup-family\"`\n}\n\n// NetworkParameters hold various configurable network values.\ntype NetworkParameters struct {\n\t// XffNumTrustedHops defines the number of additional ingress proxy hops from the\n\t// right side of the x-forwarded-for HTTP header to trust when determining the origin\n\t// client\u2019s IP address.\n\t//\n\t// See https://www.envoyproxy.io/docs/envoy/v1.17.0/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto?highlight=xff_num_trusted_hops\n\t// for more information.\n\tXffNumTrustedHops uint32 `yaml:\"num-trusted-hops\"`\n}\n\n// ListenerParameters hold various configurable listener values.\ntype ListenerParameters struct {\n\t// ConnectionBalancer. If the value is exact, the listener will use the exact connection balancer\n\t// See https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/listener.proto#envoy-api-msg-listener-connectionbalanceconfig\n\t// for more information.\n\tConnectionBalancer string `yaml:\"connection-balancer\"`\n}\n\n// Parameters contains the configuration file parameters for the\n// Contour ingress controller.\ntype Parameters struct {\n\t// Enable debug logging\n\tDebug bool\n\n\t// Kubernetes client parameters.\n\tInCluster  bool   `yaml:\"incluster,omitempty\"`\n\tKubeconfig string `yaml:\"kubeconfig,omitempty\"`\n\n\t// Server contains parameters for the xDS server.\n\tServer ServerParameters `yaml:\"server,omitempty\"`\n\n\t// GatewayConfig contains parameters for the gateway-api Gateway that Contour\n\t// is configured to serve traffic.\n\tGatewayConfig *GatewayParameters `yaml:\"gateway,omitempty\"`\n\n\t// Address to be placed in status.loadbalancer field of Ingress objects.\n\t// May be either a literal IP address or a host name.\n\t// The value will be placed directly into the relevant field inside the status.loadBalancer struct.\n\tIngressStatusAddress string `yaml:\"ingress-status-address,omitempty\"`\n\n\t// AccessLogFormat sets the global access log format.\n\t// Valid options are 'envoy' or 'json'\n\tAccessLogFormat AccessLogType `yaml:\"accesslog-format,omitempty\"`\n\n\t// AccessLogFields sets the fields that JSON logging will\n\t// output when AccessLogFormat is json.\n\tAccessLogFields AccessLogFields `yaml:\"json-fields,omitempty\"`\n\n\t// TLS contains TLS policy parameters.\n\tTLS TLSParameters `yaml:\"tls,omitempty\"`\n\n\t// DisablePermitInsecure disables the use of the\n\t// permitInsecure field in HTTPProxy.\n\tDisablePermitInsecure bool `yaml:\"disablePermitInsecure,omitempty\"`\n\n\t// DisableAllowChunkedLength disables the RFC-compliant Envoy behavior to\n\t// strip the \"Content-Length\" header if \"Transfer-Encoding: chunked\" is\n\t// also set. This is an emergency off-switch to revert back to Envoy's\n\t// default behavior in case of failures. Please file an issue if failures\n\t// are encountered.\n\t// See: https://github.com/projectcontour/contour/issues/3221\n\tDisableAllowChunkedLength bool `yaml:\"disableAllowChunkedLength,omitempty\"`\n\n\t// EnableExternalNameService allows processing of ExternalNameServices\n\t// Defaults to disabled for security reasons.\n\t// TODO(youngnick): put a link to the issue and CVE here.\n\tEnableExternalNameService bool `yaml:\"enableExternalNameService,omitempty\"`\n\n\t// LeaderElection contains leader election parameters.\n\tLeaderElection LeaderElectionParameters `yaml:\"leaderelection,omitempty\"`\n\n\t// Timeouts holds various configurable timeouts that can\n\t// be set in the config file.\n\tTimeouts TimeoutParameters `yaml:\"timeouts,omitempty\"`\n\n\t// Policy specifies default policy applied if not overridden by the user\n\tPolicy PolicyParameters `yaml:\"policy,omitempty\"`\n\n\t// Namespace of the envoy service to inspect for Ingress status details.\n\tEnvoyServiceNamespace string `yaml:\"envoy-service-namespace,omitempty\"`\n\n\t// Name of the envoy service to inspect for Ingress status details.\n\tEnvoyServiceName string `yaml:\"envoy-service-name,omitempty\"`\n\n\t// DefaultHTTPVersions defines the default set of HTTPS\n\t// versions the proxy should accept. HTTP versions are\n\t// strings of the form \"HTTP/xx\". Supported versions are\n\t// \"HTTP/1.1\" and \"HTTP/2\".\n\t//\n\t// If this field not specified, all supported versions are accepted.\n\tDefaultHTTPVersions []HTTPVersionType `yaml:\"default-http-versions\"`\n\n\t// Cluster holds various configurable Envoy cluster values that can\n\t// be set in the config file.\n\tCluster ClusterParameters `yaml:\"cluster,omitempty\"`\n\n\t// Network holds various configurable Envoy network values.\n\tNetwork NetworkParameters `yaml:\"network,omitempty\"`\n\n\t// Listener holds various configurable Envoy Listener values.\n\tListener ListenerParameters `yaml:\"listener,omitempty\"`\n\t// RateLimitService optionally holds properties of the Rate Limit Service\n\t// to be used for global rate limiting.\n\tRateLimitService RateLimitService `yaml:\"rateLimitService,omitempty\"`\n}\n\n// RateLimitService defines properties of a global Rate Limit Service.\ntype RateLimitService struct {\n\t// ExtensionService identifies the extension service defining the RLS,\n\t// formatted as <namespace>/<name>.\n\tExtensionService string `yaml:\"extensionService,omitempty\"`\n\n\t// Domain is passed to the Rate Limit Service.\n\tDomain string `yaml:\"domain,omitempty\"`\n\n\t// FailOpen defines whether to allow requests to proceed when the\n\t// Rate Limit Service fails to respond with a valid rate limit\n\t// decision within the timeout defined on the extension service.\n\tFailOpen bool `yaml:\"failOpen,omitempty\"`\n\n\t// EnableXRateLimitHeaders defines whether to include the X-RateLimit\n\t// headers X-RateLimit-Limit, X-RateLimit-Remaining, and X-RateLimit-Reset\n\t// (as defined by the IETF Internet-Draft linked below), on responses\n\t// to clients when the Rate Limit Service is consulted for a request.\n\t//\n\t// ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html\n\tEnableXRateLimitHeaders bool `yaml:\"enableXRateLimitHeaders,omitempty\"`\n}\n\n// Validate verifies that the parameter values do not have any syntax errors.\nfunc (p *Parameters) Validate() error {\n\tif err := p.Cluster.DNSLookupFamily.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := p.Server.XDSServerType.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := p.GatewayConfig.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := p.AccessLogFormat.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := p.AccessLogFields.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := p.TLS.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := p.Timeouts.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := p.Policy.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, v := range p.DefaultHTTPVersions {\n\t\tif err := v.Validate(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Defaults returns the default set of parameters.\nfunc Defaults() Parameters {\n\tcontourNamespace := GetenvOr(\"CONTOUR_NAMESPACE\", \"projectcontour\")\n\n\treturn Parameters{\n\t\tDebug:      false,\n\t\tInCluster:  false,\n\t\tKubeconfig: filepath.Join(os.Getenv(\"HOME\"), \".kube\", \"config\"),\n\t\tServer: ServerParameters{\n\t\t\tXDSServerType: ContourServerType,\n\t\t},\n\t\tIngressStatusAddress:      \"\",\n\t\tAccessLogFormat:           DEFAULT_ACCESS_LOG_TYPE,\n\t\tAccessLogFields:           DefaultFields,\n\t\tTLS:                       TLSParameters{},\n\t\tDisablePermitInsecure:     false,\n\t\tDisableAllowChunkedLength: false,\n\t\tLeaderElection: LeaderElectionParameters{\n\t\t\tLeaseDuration: time.Second * 15,\n\t\t\tRenewDeadline: time.Second * 10,\n\t\t\tRetryPeriod:   time.Second * 2,\n\t\t\tName:          \"leader-elect\",\n\t\t\tNamespace:     contourNamespace,\n\t\t},\n\t\tTimeouts: TimeoutParameters{\n\t\t\t// This is chosen as a rough default to stop idle connections wasting resources,\n\t\t\t// without stopping slow connections from being terminated too quickly.\n\t\t\tConnectionIdleTimeout: \"60s\",\n\t\t},\n\t\tPolicy: PolicyParameters{\n\t\t\tRequestHeadersPolicy:  HeadersPolicy{},\n\t\t\tResponseHeadersPolicy: HeadersPolicy{},\n\t\t},\n\t\tEnvoyServiceName:      \"envoy\",\n\t\tEnvoyServiceNamespace: contourNamespace,\n\t\tDefaultHTTPVersions:   []HTTPVersionType{},\n\t\tCluster: ClusterParameters{\n\t\t\tDNSLookupFamily: AutoClusterDNSFamily,\n\t\t},\n\t\tNetwork: NetworkParameters{\n\t\t\tXffNumTrustedHops: 0,\n\t\t},\n\t\tListener: ListenerParameters{\n\t\t\tConnectionBalancer: \"\",\n\t\t},\n\t}\n}\n\n// Parse reads parameters from a YAML input stream. Any parameters\n// not specified by the input are according to Defaults().\nfunc Parse(in io.Reader) (*Parameters, error) {\n\tconf := Defaults()\n\tdecoder := yaml.NewDecoder(in)\n\n\tdecoder.SetStrict(true)\n\n\tif err := decoder.Decode(&conf); err != nil {\n\t\t// The YAML decoder will return EOF if there are\n\t\t// no YAML nodes in the results. In this case, we just\n\t\t// want to succeed and return the defaults.\n\t\tif err != io.EOF {\n\t\t\treturn nil, fmt.Errorf(\"failed to parse configuration: %w\", err)\n\t\t}\n\t}\n\n\t// Force the version string to match the lowercase version\n\t// constants (assuming that it will match).\n\tfor i, v := range conf.DefaultHTTPVersions {\n\t\tconf.DefaultHTTPVersions[i] = HTTPVersionType(strings.ToLower(string(v)))\n\t}\n\n\treturn &conf, nil\n}\n\n// GetenvOr reads an environment or return a default value\nfunc GetenvOr(key string, defaultVal string) string {\n\tif value, exists := os.LookupEnv(key); exists {\n\t\treturn value\n\t}\n\n\treturn defaultVal\n}\n", "# Contour Configuration Reference\n\n- [Serve Flags](#serve-flags)\n- [Configuration File](#configuration-file)\n- [Environment Variables](#environment-variables)\n- [Bootstrap Config File](#bootstrap-config-file)\n\n## Overview\n\nThere are various ways to configure Contour, flags, the configuration file, as well as environment variables.\nContour has a precedence of configuration for contour serve, meaning anything configured in the config file is overridden by environment vars which are overridden by cli flags.\n\n## Serve Flags\n\nThe `contour serve` command is the main command which is used to watch for Kubernetes resource and process them into Envoy configuration which is then streamed to any Envoy via its xDS gRPC connection.\nThere are a number of flags that can be passed to this command which further configures how Contour operates. \nMany of these flags are mirrored in the [Contour Configuration File](#configuration-file).\n\n| Flag Name         | Description        |\n|-------------------|--------------------|\n| `--config-path`       | Path to base configuration |\n| `--incluster`         | Use in cluster configuration |\n| `--kubeconfig=</path/to/file>` |    Path to kubeconfig (if not in running inside a cluster) |\n| `--xds-address=<ipaddr>` | xDS gRPC API address |\n| `--xds-port=<port>`       | xDS gRPC API port |\n| `--stats-address=<ipaddr>` | Envoy /stats interface address |\n| `--stats-port=<port>`  |  Envoy /stats interface port |\n| `--debug-http-address=<address>` | Address the debug http endpoint will bind to. |\n| `--debug-http-port=<port>`  | Port the debug http endpoint will bind to |\n| `--http-address=<ipaddr>`  | Address the metrics HTTP endpoint will bind to |\n| `--http-port=<port>`  |    Port the metrics HTTP endpoint will bind to. |\n| `--health-address=<ipaddr>` |   Address the health HTTP endpoint will bind to |\n| `--health-port=<port>` | Port the health HTTP endpoint will bind to |\n| `--contour-cafile=</path/to/file\\|CONTOUR_CERT_FILE>` | CA bundle file name for serving gRPC with TLS |\n| `--contour-cert-file=</path/to/file\\|CONTOUR_CERT_FILE>`  | Contour certificate file name for serving gRPC over TLS |\n| `--contour-key-file=</path/to/file\\|CONTOUR_KEY_FILE>` | Contour key file name for serving gRPC over TLS |\n| `--insecure`  |               Allow serving without TLS secured gRPC |\n| `--root-namespaces=<ns,ns>` | Restrict contour to searching these namespaces for root ingress routes |\n| `--ingress-class-name=<name>` | Contour IngressClass name |\n| `--ingress-status-address=<address>`  | Address to set in Ingress object status |\n| `--envoy-http-access-log=</path/to/file>`  | Envoy HTTP access log |\n| `--envoy-https-access-log=</path/to/file>`  | Envoy HTTPS access log |\n| `--envoy-service-http-address=<ipaddr>`  | Kubernetes Service address for HTTP requests |\n| `--envoy-service-https-address=<ipaddr>` | Kubernetes Service address for HTTPS requests |\n| `--envoy-service-http-port=<port>` | Kubernetes Service port for HTTP requests |\n| `--envoy-service-https-port=<port>` |  Kubernetes Service port for HTTPS requests |\n| `--envoy-service-name=<name>` | Name of the Envoy service to inspect for Ingress status details. |\n| `--envoy-service-namespace=<namespace>` | Envoy Service Namespace  |\n| `--use-proxy-protocol`  |     Use PROXY protocol for all listeners |\n| `--accesslog-format=<envoy\\|json>` | Format for Envoy access logs |\n| `--disable-leader-election` | Disable leader election mechanism |\n| `-d, --debug`   |                  Enable debug logging |\n| `--kubernetes-debug=<log level>`  | Enable Kubernetes client debug logging |\n\n## Configuration File\n\nA configuration file can be passed to the `--config-path` argument of the `contour serve` command to specify additional configuration to Contour.\nIn most deployments, this file is passed to Contour via a ConfigMap which is mounted as a volume to the Contour pod.\n\nThe Contour configuration file is optional.\nIn its absence, Contour will operate with reasonable defaults.\nWhere Contour settings can also be specified with command-line flags, the command-line value takes precedence over the configuration file.\n\n| Field Name | Type | Default | Description |\n|------------|------|---------|-------------|\n| accesslog-format | string | `envoy` | This key sets the global [access log format][2] for Envoy. Valid options are `envoy` or `json`. |\n| debug | boolean | `false` | Enables debug logging. |\n| default-http-versions | string array | <code style=\"white-space:nowrap\">HTTP/1.1</code> <br> <code style=\"white-space:nowrap\">HTTP/2</code> | This array specifies the HTTP versions that Contour should program Envoy to serve. HTTP versions are specified as strings of the form \"HTTP/x\", where \"x\" represents the version number. |\n| disableAllowChunkedLength | boolean | `false` | If this field is true, Contour will disable the RFC-compliant Envoy behavior to strip the `Content-Length` header if `Transfer-Encoding: chunked` is also set. This is an emergency off-switch to revert back to Envoy's default behavior in case of failures. |\n| disablePermitInsecure | boolean | `false` | If this field is true, Contour will ignore `PermitInsecure` field in HTTPProxy documents. |\n| envoy-service-name | string | `envoy` | This sets the service name that will be inspected for address details to be applied to Ingress objects. |\n| envoy-service-namespace | string | `projectcontour` | This sets the namespace of the service that will be inspected for address details to be applied to Ingress objects. If the `CONTOUR_NAMESPACE` environment variable is present, Contour will populate this field with its value. |\n| ingress-status-address | string | None | If present, this specifies the address that will be copied into the Ingress status for each Ingress that Contour manages. It is exclusive with `envoy-service-name` and `envoy-service-namespace`.|\n| incluster | boolean | `false` | This field specifies that Contour is running in a Kubernetes cluster and should use the in-cluster client access configuration.  |\n| json-fields | string array | [fields][5]| This is the list the field names to include in the JSON [access log format][2]. |\n| kubeconfig | string | `$HOME/.kube/config` | Path to a Kubernetes [kubeconfig file][3] for when Contour is executed outside a cluster. |\n| leaderelection | leaderelection | | The [leader election configuration](#leader-election-configuration). |\n| policy | PolicyConfig | | The default [policy configuration](#policy-configuration). |\n| tls | TLS | | The default [TLS configuration](#tls-configuration). |\n| timeouts | TimeoutConfig | | The [timeout configuration](#timeout-configuration). |\n| cluster | ClusterConfig | | The [cluster configuration](#cluster-configuration). |\n| network | NetworkConfig | | The [network configuration](#network-configuration). |\n| listener | ListenerConfig | | The [listener configuration](#listener-configuration). |\n| server | ServerConfig |  | The [server configuration](#server-configuration) for `contour serve` command. |\n| gateway | GatewayConfig |  | The [gateway-api Gateway configuration](#gateway-configuration). |\n| rateLimitService | RateLimitServiceConfig | | The [rate limit service configuration](#rate-limit-service-configuration). |\n| enableExternalNameService | boolean | `false` | Enable ExternalName Service processing. Enabling this has security implications. Please see the [advisory](https://github.com/projectcontour/contour/security/advisories/GHSA-5ph6-qq5x-7jwc) for more details. |\n\n### TLS Configuration\n\nThe TLS configuration block can be used to configure default values for how\nContour should provision TLS hosts.\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| minimum-protocol-version| string | `1.2` | This field specifies the minimum TLS protocol version that is allowed. Valid options are `1.2` (default) and `1.3`. Any other value defaults to TLS 1.2. |\n| fallback-certificate | | | [Fallback certificate configuration](#fallback-certificate). |\n| envoy-client-certificate | | | [Client certificate configuration for Envoy](#envoy-client-certificate). |\n| cipher-suites | []string | See [config package documentation](https://pkg.go.dev/github.com/projectcontour/contour/pkg/config#pkg-variables) | This field specifies the TLS ciphers to be supported by TLS listeners when negotiating TLS 1.2. This parameter should only be used by advanced users. Note that this is ignored when TLS 1.3 is in use. The set of ciphers that are allowed is a superset of those supported by default in stock, non-FIPS Envoy builds and FIPS builds as specified [here](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto#envoy-v3-api-field-extensions-transport-sockets-tls-v3-tlsparameters-cipher-suites). Custom ciphers not accepted by Envoy in a standard build are not supported. |\n\n### Fallback Certificate\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| name       | string | `\"\"` | This field specifies the name of the Kubernetes secret to use as the fallback certificate.      |\n| namespace  | string | `\"\"` | This field specifies the namespace of the Kubernetes secret to use as the fallback certificate. |\n\n\n### Envoy Client Certificate\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| name       | string | `\"\"` | This field specifies the name of the Kubernetes secret to use as the client certificate and private key when establishing TLS connections to the backend service. |\n| namespace  | string | `\"\"` | This field specifies the namespace of the Kubernetes secret to use as the client certificate and private key when establishing TLS connections to the backend service. |\n\n### Leader Election Configuration\n\nThe leader election configuration block configures how a deployment with more than one Contour pod elects a leader.\nThe Contour leader is responsible for updating the status field on Ingress and HTTPProxy documents.\nIn the vast majority of deployments, only the `configmap-name` and `configmap-namespace` fields should require any configuration.\n\n| Field Name | Type | Default | Description |\n|------------|------|---------|-------------|\n| configmap-name | string | `leader-elect` | The name of the ConfigMap that Contour leader election will lease. |\n| configmap-namespace | string | `projectcontour` | The namespace of the ConfigMap that Contour leader election will lease. If the `CONTOUR_NAMESPACE` environment variable is present, Contour will populate this field with its value. |\n| lease-duration | [duration][4] | `15s` | The duration of the leadership lease. |\n| renew-deadline | [duration][4] | `10s` | The length of time that the leader will retry refreshing leadership before giving up. |\n| retry-period | [duration][4] | `2s` | The interval at which Contour will attempt to the acquire leadership lease. |\n\n### Timeout Configuration\n\nThe timeout configuration block can be used to configure various timeouts for the proxies. All fields are optional; Contour/Envoy defaults apply if a field is not specified.\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| request-timeout | string | none* | This field specifies the default request timeout. Note that this is a timeout for the entire request, not an idle timeout. Must be a [valid Go duration string][4], or omitted or set to `infinity` to disable the timeout entirely. See [the Envoy documentation][12] for more information.<br /><br />_Note: A value of `0s` previously disabled this timeout entirely. This is no longer the case. Use `infinity` or omit this field to disable the timeout._  |\n| connection-idle-timeout| string | `60s` | This field defines how long the proxy should wait while there are no active requests (for HTTP/1.1) or streams (for HTTP/2) before terminating an HTTP connection. Must be a [valid Go duration string][4], or `infinity` to disable the timeout entirely. See [the Envoy documentation][8] for more information. |\n| stream-idle-timeout| string | `5m`* |This field defines how long the proxy should wait while there is no request activity (for HTTP/1.1) or stream activity (for HTTP/2) before terminating the HTTP request or stream. Must be a [valid Go duration string][4], or `infinity` to disable the timeout entirely. See [the Envoy documentation][9] for more information. |\n| max-connection-duration | string | none* | This field defines the maximum period of time after an HTTP connection has been established from the client to the proxy before it is closed by the proxy, regardless of whether there has been activity or not. Must be a [valid Go duration string][4], or omitted or set to `infinity` for no max duration. See [the Envoy documentation][10] for more information. |\n| delayed-close-timeout | string | `1s`* | *Note: this is an advanced setting that should not normally need to be tuned.* <br /><br /> This field defines how long envoy will wait, once connection close processing has been initiated, for the downstream peer to close the connection before Envoy closes the socket associated with the connection. Setting this timeout to 'infinity' will disable it.  See [the Envoy documentation][13] for more information. |\n| connection-shutdown-grace-period | string | `5s`* | This field defines how long the proxy will wait between sending an initial GOAWAY frame and a second, final GOAWAY frame when terminating an HTTP/2 connection. During this grace period, the proxy will continue to respond to new streams. After the final GOAWAY frame has been sent, the proxy will refuse new streams. Must be a [valid Go duration string][4]. See [the Envoy documentation][11] for more information. |\n\n_This is Envoy's default setting value and is not explicitly configured by Contour._\n\n### Cluster Configuration\n\nThe cluster configuration block can be used to configure various parameters for Envoy clusters.\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| dns-lookup-family | string | auto | This field specifies the dns-lookup-family to use for upstream requests to externalName type Kubernetes services from an HTTPProxy route. Values are: `auto`, `v4, `v6` |\n\n### Network Configuration\n\nThe network configuration block can be used to configure various parameters network connections.\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| num-trusted-hops | int | 0 | Configures the number of additional ingress proxy hops from the right side of the x-forwarded-for HTTP header to trust. |\n\n### Listener Configuration\n\nThe listener configuration block can be used to configure various parameters for Envoy listener.\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| connection-balancer | string | `\"\"` | This field specifies the listener connection balancer. If the value is `exact`, the listener will use the exact connection balancer to balance connections between threads in a single Envoy process. See [the Envoy documentation][14] for more information. |\n\n### Server Configuration\n\nThe server configuration block can be used to configure various settings for the `contour serve` command.\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| xds-server-type | string | contour | This field specifies the xDS Server to use. Options are `contour` or `envoy`.  |\n\n### Gateway Configuration\n\nThe gateway configuration block is used to configure which gateway-api Gateway Contour should configure:\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| controllerName | string |  | Gateway Class controller name (i.e. projectcontour.io/projectcontour/contour).  |\n| name (Deprecated) | string | contour | DEPRECATED: This field specifies the name of a Gateway.  |\n| namespace (Deprecated) | string | projectcontour | DEPRECATED: This field specifies the namespace of a Gateway.  |\n\n_NOTE: The fields `name` and `namespace` have been deprecated and will be removed in Contour v1.18.\nPlease use the `controllerName` field going forward to configure which Gateway Contour should process._\n\n### Policy Configuration\n\nThe Policy configuration block can be used to configure default policy values\nthat are set if not overridden by the user.\n\nThe `request-headers` field is used to rewrite headers on a HTTP request, and\nthe `response-headers` field is used to rewrite headers on a HTTP response.\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| request-headers | HeaderPolicy | none | The default request headers set or removed on all service routes if not overridden in the object |\n| response-headers | HeaderPolicy | none | The default response headers set or removed on all service routes if not overridden in the object |\n\n#### HeaderPolicy\n\nThe `set` field sets an HTTP header value, creating it if it doesn't already exist but not overwriting it if it does.\nThe `remove` field removes an HTTP header.\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| set | map[string]string | none | Map of headers to set on all service routes if not overridden in the object |\n| remove | []string | none | List of headers to remove on all service routes if not overridden in the object |\n\nNote: the values of entries in the `set` and `remove` fields can be overridden in HTTPProxy objects but it it not possible to remove these entries.\n\n### Rate Limit Service Configuration\n\nThe rate limit service configuration block is used to configure an optional global rate limit service:\n\n| Field Name | Type| Default  | Description |\n|------------|-----|----------|-------------|\n| extensionService | string | <none> | This field identifies the extension service defining the rate limit service, formatted as <namespace>/<name>.  |\n| domain | string | contour | This field defines the rate limit domain value to pass to the rate limit service. Acts as a container for a set of rate limit definitions within the RLS.  |\n| failOpen | bool | false | This field defines whether to allow requests to proceed when the rate limit service fails to respond with a valid rate limit decision within the timeout defined on the extension service.  |\n| enableXRateLimitHeaders | bool | false | This field defines whether to include the X-RateLimit headers X-RateLimit-Limit, X-RateLimit-Remaining, and X-RateLimit-Reset (as defined by the IETF Internet-Draft https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html), on responses to clients when the Rate Limit Service is consulted for a request. |\n\n### Configuration Example\n\nThe following is an example ConfigMap with configuration file included:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: contour\n  namespace: projectcontour\ndata:\n  contour.yaml: |\n    #\n    # server:\n    #   determine which XDS Server implementation to utilize in Contour.\n    #   xds-server-type: contour\n    #\n    # specify the gateway-api Gateway Contour should configure\n    # gateway:\n    #   controllerName: projectcontour.io/projectcontour/contour\n    #   name: contour\n    #   namespace: projectcontour\n    #\n    # should contour expect to be running inside a k8s cluster\n    # incluster: true\n    #\n    # path to kubeconfig (if not running inside a k8s cluster)\n    # kubeconfig: /path/to/.kube/config\n    #\n    # Disable RFC-compliant behavior to strip \"Content-Length\" header if\n    # \"Tranfer-Encoding: chunked\" is also set.\n    # disableAllowChunkedLength: false\n    # Disable HTTPProxy permitInsecure field\n    disablePermitInsecure: false\n    tls:\n    # minimum TLS version that Contour will negotiate\n    # minimum-protocol-version: \"1.2\"\n    # TLS ciphers to be supported by Envoy TLS listeners when negotiating\n    # TLS 1.2.\n    # cipher-suites:\n    # - '[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]'\n    # - '[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]'\n    # - 'ECDHE-ECDSA-AES256-GCM-SHA384'\n    # - 'ECDHE-RSA-AES256-GCM-SHA384'\n    # Defines the Kubernetes name/namespace matching a secret to use\n    # as the fallback certificate when requests which don't match the\n    # SNI defined for a vhost.\n      fallback-certificate:\n    #   name: fallback-secret-name\n    #   namespace: projectcontour\n      envoy-client-certificate:\n    #   name: envoy-client-cert-secret-name\n    #   namespace: projectcontour\n    # The following config shows the defaults for the leader election.\n    # leaderelection:\n    #   configmap-name: leader-elect\n    #   configmap-namespace: projectcontour\n    ### Logging options\n    # Default setting\n    accesslog-format: envoy\n    # To enable JSON logging in Envoy\n    # accesslog-format: json\n    # The default fields that will be logged are specified below.\n    # To customise this list, just add or remove entries.\n    # The canonical list is available at\n    # https://godoc.org/github.com/projectcontour/contour/internal/envoy#JSONFields\n    # json-fields:\n    #   - \"@timestamp\"\n    #   - \"authority\"\n    #   - \"bytes_received\"\n    #   - \"bytes_sent\"\n    #   - \"downstream_local_address\"\n    #   - \"downstream_remote_address\"\n    #   - \"duration\"\n    #   - \"method\"\n    #   - \"path\"\n    #   - \"protocol\"\n    #   - \"request_id\"\n    #   - \"requested_server_name\"\n    #   - \"response_code\"\n    #   - \"response_flags\"\n    #   - \"uber_trace_id\"\n    #   - \"upstream_cluster\"\n    #   - \"upstream_host\"\n    #   - \"upstream_local_address\"\n    #   - \"upstream_service_time\"\n    #   - \"user_agent\"\n    #   - \"x_forwarded_for\"\n    #\n    # default-http-versions:\n    # - \"HTTP/2\"\n    # - \"HTTP/1.1\"\n    #\n    # The following shows the default proxy timeout settings.\n    # timeouts:\n    #   request-timeout: infinity\n    #   connection-idle-timeout: 60s\n    #   stream-idle-timeout: 5m\n    #   max-connection-duration: infinity\n    #   connection-shutdown-grace-period: 5s\n    #\n    # Envoy cluster settings.\n    # cluster:\n    #   configure the cluster dns lookup family\n    #   valid options are: auto (default), v4, v6\n    #   dns-lookup-family: auto   \n    #\n    # network:\n    #   Configure the number of additional ingress proxy hops from the\n    #   right side of the x-forwarded-for HTTP header to trust.\n    #   num-trusted-hops: 0\n    #\n    # Configure an optional global rate limit service.\n    # rateLimitService:\n    #   Identifies the extension service defining the rate limit service,\n    #   formatted as <namespace>/<name>.\n    #   extensionService: projectcontour/ratelimit\n    #   Defines the rate limit domain to pass to the rate limit service.\n    #   Acts as a container for a set of rate limit definitions within\n    #   the RLS.\n    #   domain: contour\n    #   Defines whether to allow requests to proceed when the rate limit\n    #   service fails to respond with a valid rate limit decision within\n    #   the timeout defined on the extension service.\n    #   failOpen: false\n    # Defines whether to include the X-RateLimit headers X-RateLimit-Limit,\n    # X-RateLimit-Remaining, and X-RateLimit-Reset (as defined by the IETF\n    # Internet-Draft linked below), on responses to clients when the Rate\n    # Limit Service is consulted for a request.\n    # ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html\n    #   enableXRateLimitHeaders: false\n    #\n    # Global Policy settings.\n    # policy:\n    #   # Default headers to set on all requests (unless set/removed on the HTTPProxy object itself)\n    #   request-headers:\n    #     set:\n    #       # example: the hostname of the Envoy instance that proxied the request\n    #       X-Envoy-Hostname: %HOSTNAME%\n    #       # example: add a l5d-dst-override header to instruct Linkerd what service the request is destined for\n    #       l5d-dst-override: %CONTOUR_SERVICE_NAME%.%CONTOUR_NAMESPACE%.svc.cluster.local:%CONTOUR_SERVICE_PORT%\n    #   # default headers to set on all responses (unless set/removed on the HTTPProxy object itself)\n    #   response-headers:\n    #     set:\n    #       # example: Envoy flags that provide additional details about the response or connection\n    #       X-Envoy-Response-Flags: %RESPONSE_FLAGS%\n    #\n```\n\n_Note:_ The default example `contour` includes this [file][1] for easy deployment of Contour.\n\n## Environment Variables\n\n### CONTOUR_NAMESPACE\n\nIf present, the value of the `CONTOUR_NAMESPACE` environment variable is used as:\n\n1. The value for the `contour bootstrap --namespace` flag unless otherwise specified.\n1. The value for the `contour certgen --namespace` flag unless otherwise specified.\n1. The value for the `contour serve --envoy-service-namespace` flag unless otherwise specified.\n1. The value for the `leaderelection.configmap-namespace` config file setting for `contour serve` unless otherwise specified.\n\nThe `CONTOUR_NAMESPACE` environment variable is set via the [Downward API][6] in the Contour [example manifests][7].\n\n## Bootstrap Config File\n\nThe bootstrap configuration file is generated by an initContainer in the Envoy daemonset which runs the `contour bootstrap` command to generate the file.\nThis configuration file configures the Envoy container to connect to Contour and receive configuration via xDS.\n\nThe next section outlines all the available flags that can be passed to the `contour bootstrap` command which are used to customize\nthe configuration file to match the environment in which Envoy is deployed. \n\n### Flags\n\nThere are flags that can be passed to `contour bootstrap` that help configure how Envoy\nconnects to Contour:\n\n| Flag | Default  | Description |\n|------------|----------|-------------|\n| <nobr>--resources-dir</nobr> | \"\" | Directory where resource files will be written.  |\n| <nobr>--admin-address</nobr> | 127.0.0.1 | Address the Envoy admin webpage will listen on.  |\n| <nobr>--admin-port</nobr> | 9001 | Port the Envoy admin webpage will listen on.  |\n| <nobr>--xds-address</nobr> | 127.0.0.1 | Address to connect to Contour xDS server on.  |\n| <nobr>--xds-port</nobr> | 8001 | Port to connect to Contour xDS server on. |\n| <nobr>--envoy-cafile</nobr> | \"\" | CA filename for Envoy secure xDS gRPC communication.  |\n| <nobr>--envoy-cert-file</nobr> | \"\" | Client certificate filename for Envoy secure xDS gRPC communication.  |\n| <nobr>--envoy-key-file</nobr> | \"\" | Client key filename for Envoy secure xDS gRPC communication.  |\n| <nobr>--namespace</nobr> | projectcontour | Namespace the Envoy container will run, also configured via ENV variable \"CONTOUR_NAMESPACE\". Namespace is used as part of the metric names on static resources defined in the bootstrap configuration file.    |\n| <nobr>--xds-resource-version</nobr> | v3 | Currently, the only valid xDS API resource version is `v3`.  |\n| <nobr>--dns-lookup-family</nobr> | auto | Defines what DNS Resolution Policy to use for Envoy -> Contour cluster name lookup. Either v4, v6 or auto.  |\n\n\n[1]: {{< param github_url>}}/tree/{{< param version >}}/examples/contour/01-contour-config.yaml\n[2]: /guides/structured-logs\n[3]: https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/\n[4]: https://golang.org/pkg/time/#ParseDuration\n[5]: https://godoc.org/github.com/projectcontour/contour/internal/envoy#DefaultFields\n[6]: https://kubernetes.io/docs/tasks/inject-data-application/environment-variable-expose-pod-information/\n[7]: {{< param github_url>}}/tree/{{< param version >}}/examples/contour\n[8]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-idle-timeout\n[9]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-stream-idle-timeout\n[10]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-max-connection-duration\n[11]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-drain-timeout\n[12]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-request-timeout\n[13]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-delayed-close-timeout\n[14]: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/listener/v3/listener.proto#config-listener-v3-listener-connectionbalanceconfig\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// +build e2e\n\npackage httpproxy\n\nimport (\n\t\"context\"\n\n\t. \"github.com/onsi/ginkgo\"\n\tcontourv1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"\n\t\"github.com/projectcontour/contour/test/e2e\"\n\t\"github.com/stretchr/testify/require\"\n\tcorev1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n\nfunc testExternalNameServiceInsecure(namespace string) {\n\tSpecify(\"external name services work over http\", func() {\n\t\tt := f.T()\n\n\t\tf.Fixtures.Echo.Deploy(namespace, \"ingress-conformance-echo\")\n\n\t\texternalNameService := &corev1.Service{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tNamespace: namespace,\n\t\t\t\tName:      \"external-name-service\",\n\t\t\t},\n\t\t\tSpec: corev1.ServiceSpec{\n\t\t\t\tType:         corev1.ServiceTypeExternalName,\n\t\t\t\tExternalName: \"ingress-conformance-echo.\" + namespace,\n\t\t\t\tPorts: []corev1.ServicePort{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"http\",\n\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\trequire.NoError(t, f.Client.Create(context.TODO(), externalNameService))\n\n\t\tp := &contourv1.HTTPProxy{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tNamespace: namespace,\n\t\t\t\tName:      \"external-name-proxy\",\n\t\t\t},\n\t\t\tSpec: contourv1.HTTPProxySpec{\n\t\t\t\tVirtualHost: &contourv1.VirtualHost{\n\t\t\t\t\tFqdn: \"externalnameservice.projectcontour.io\",\n\t\t\t\t},\n\t\t\t\tRoutes: []contourv1.Route{\n\t\t\t\t\t{\n\t\t\t\t\t\tServices: []contourv1.Service{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName: externalNameService.Name,\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRequestHeadersPolicy: &contourv1.HeadersPolicy{\n\t\t\t\t\t\t\tSet: []contourv1.HeaderValue{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\t\t\t\tValue: externalNameService.Spec.ExternalName,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tproxy, ok := f.CreateHTTPProxyAndWaitFor(p, httpProxyValid)\n\t\tif !ok {\n\t\t\tt.Fatalf(\"The HTTPProxy did not become valid, here are the Valid condition's Errors: %s\", httpProxyErrors(proxy))\n\t\t}\n\n\t\tres, ok := f.HTTP.RequestUntil(&e2e.HTTPRequestOpts{\n\t\t\tHost:      p.Spec.VirtualHost.Fqdn,\n\t\t\tCondition: e2e.HasStatusCode(200),\n\t\t})\n\t\trequire.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)\n\t})\n}\n\nfunc testExternalNameServiceTLS(namespace string) {\n\tSpecify(\"external name services work over https\", func() {\n\t\tt := f.T()\n\n\t\tf.Certs.CreateSelfSignedCert(namespace, \"backend-server-cert\", \"backend-server-cert\", \"echo\")\n\n\t\tf.Fixtures.EchoSecure.Deploy(namespace, \"echo-tls\")\n\n\t\texternalNameService := &corev1.Service{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tNamespace: namespace,\n\t\t\t\tName:      \"external-name-service-tls\",\n\t\t\t},\n\t\t\tSpec: corev1.ServiceSpec{\n\t\t\t\tType:         corev1.ServiceTypeExternalName,\n\t\t\t\tExternalName: \"echo-tls.\" + namespace,\n\t\t\t\tPorts: []corev1.ServicePort{\n\t\t\t\t\t{\n\t\t\t\t\t\tName:     \"https\",\n\t\t\t\t\t\tPort:     443,\n\t\t\t\t\t\tProtocol: corev1.ProtocolTCP,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\trequire.NoError(t, f.Client.Create(context.TODO(), externalNameService))\n\n\t\tp := &contourv1.HTTPProxy{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tNamespace: namespace,\n\t\t\t\tName:      \"external-name-proxy-tls\",\n\t\t\t},\n\t\t\tSpec: contourv1.HTTPProxySpec{\n\t\t\t\tVirtualHost: &contourv1.VirtualHost{\n\t\t\t\t\tFqdn: \"tls.externalnameservice.projectcontour.io\",\n\t\t\t\t},\n\t\t\t\tRoutes: []contourv1.Route{\n\t\t\t\t\t{\n\t\t\t\t\t\tServices: []contourv1.Service{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName:     externalNameService.Name,\n\t\t\t\t\t\t\t\tPort:     443,\n\t\t\t\t\t\t\t\tProtocol: stringPtr(\"tls\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRequestHeadersPolicy: &contourv1.HeadersPolicy{\n\t\t\t\t\t\t\tSet: []contourv1.HeaderValue{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\t\t\t\tValue: externalNameService.Spec.ExternalName,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tproxy, ok := f.CreateHTTPProxyAndWaitFor(p, httpProxyValid)\n\t\tif !ok {\n\t\t\tt.Fatalf(\"The HTTPProxy did not become valid, here are the Valid condition's Errors: %s\", httpProxyErrors(proxy))\n\t\t}\n\n\t\tres, ok := f.HTTP.RequestUntil(&e2e.HTTPRequestOpts{\n\t\t\tHost:      p.Spec.VirtualHost.Fqdn,\n\t\t\tCondition: e2e.HasStatusCode(200),\n\t\t})\n\t\trequire.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)\n\t})\n}\n\nfunc stringPtr(s string) *string {\n\treturn &s\n}\n\nfunc testExternalNameServiceLocalhostInvalid(namespace string) {\n\tSpecify(\"external name services with localhost are rejected\", func() {\n\t\tt := f.T()\n\n\t\tf.Fixtures.Echo.Deploy(namespace, \"ingress-conformance-echo\")\n\n\t\texternalNameService := &corev1.Service{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tNamespace: namespace,\n\t\t\t\tName:      \"external-name-service-localhost\",\n\t\t\t},\n\t\t\tSpec: corev1.ServiceSpec{\n\t\t\t\tType: corev1.ServiceTypeExternalName,\n\t\t\t\t// The unit tests test just `localhost`, so test another item from that\n\t\t\t\t// list.\n\t\t\t\tExternalName: \"localhost.localdomain\",\n\t\t\t\tPorts: []corev1.ServicePort{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"http\",\n\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\trequire.NoError(t, f.Client.Create(context.TODO(), externalNameService))\n\n\t\tp := &contourv1.HTTPProxy{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tNamespace: namespace,\n\t\t\t\tName:      \"external-name-proxy\",\n\t\t\t},\n\t\t\tSpec: contourv1.HTTPProxySpec{\n\t\t\t\tVirtualHost: &contourv1.VirtualHost{\n\t\t\t\t\tFqdn: \"externalnameservice.projectcontour.io\",\n\t\t\t\t},\n\t\t\t\tRoutes: []contourv1.Route{\n\t\t\t\t\t{\n\t\t\t\t\t\tServices: []contourv1.Service{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName: externalNameService.Name,\n\t\t\t\t\t\t\t\tPort: 80,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRequestHeadersPolicy: &contourv1.HeadersPolicy{\n\t\t\t\t\t\t\tSet: []contourv1.HeaderValue{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tName:  \"Host\",\n\t\t\t\t\t\t\t\t\tValue: externalNameService.Spec.ExternalName,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\t_, ok := f.CreateHTTPProxyAndWaitFor(p, httpProxyValid)\n\t\trequire.Falsef(t, ok, \"ExternalName with hostname %s was accepted by Contour.\", externalNameService.Spec.ExternalName)\n\t})\n}\n", "// Copyright Project Contour Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// +build e2e\n\npackage httpproxy\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/davecgh/go-spew/spew\"\n\tcertmanagerv1 \"github.com/jetstack/cert-manager/pkg/apis/certmanager/v1\"\n\tcertmanagermetav1 \"github.com/jetstack/cert-manager/pkg/apis/meta/v1\"\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\t\"github.com/onsi/gomega/gexec\"\n\tcontourv1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"\n\t\"github.com/projectcontour/contour/pkg/config\"\n\t\"github.com/projectcontour/contour/test/e2e\"\n\t\"github.com/stretchr/testify/require\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n\nvar f = e2e.NewFramework(false)\n\nfunc TestHTTPProxy(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"HTTPProxy tests\")\n}\n\nvar _ = BeforeSuite(func() {\n\trequire.NoError(f.T(), f.Deployment.EnsureResourcesForLocalContour())\n})\n\nvar _ = AfterSuite(func() {\n\tf.DeleteNamespace(f.Deployment.Namespace.Name, true)\n\tgexec.CleanupBuildArtifacts()\n})\n\nvar _ = Describe(\"HTTPProxy\", func() {\n\tvar (\n\t\tcontourCmd            *gexec.Session\n\t\tcontourConfig         *config.Parameters\n\t\tcontourConfigFile     string\n\t\tadditionalContourArgs []string\n\t)\n\n\tBeforeEach(func() {\n\t\t// Contour config file contents, can be modified in nested\n\t\t// BeforeEach.\n\t\tcontourConfig = &config.Parameters{}\n\n\t\t// Default contour serve command line arguments can be appended to in\n\t\t// nested BeforeEach.\n\t\tadditionalContourArgs = []string{}\n\t})\n\n\t// JustBeforeEach is called after each of the nested BeforeEach are\n\t// called, so it is a final setup step before running a test.\n\t// A nested BeforeEach may have modified Contour config, so we wait\n\t// until here to start Contour.\n\tJustBeforeEach(func() {\n\t\tvar err error\n\t\tcontourCmd, contourConfigFile, err = f.Deployment.StartLocalContour(contourConfig, additionalContourArgs...)\n\t\trequire.NoError(f.T(), err)\n\n\t\t// Wait for Envoy to be healthy.\n\t\trequire.NoError(f.T(), f.Deployment.WaitForEnvoyDaemonSetUpdated())\n\t})\n\n\tAfterEach(func() {\n\t\trequire.NoError(f.T(), f.Deployment.StopLocalContour(contourCmd, contourConfigFile))\n\t})\n\n\tf.NamespacedTest(\"001-required-field-validation\", testRequiredFieldValidation)\n\n\tf.NamespacedTest(\"002-header-condition-match\", testHeaderConditionMatch)\n\n\tf.NamespacedTest(\"003-path-condition-match\", testPathConditionMatch)\n\n\tf.NamespacedTest(\"004-https-sni-enforcement\", testHTTPSSNIEnforcement)\n\n\tf.NamespacedTest(\"005-pod-restart\", testPodRestart)\n\n\tf.NamespacedTest(\"006-merge-slash\", testMergeSlash)\n\n\tf.NamespacedTest(\"007-client-cert-auth\", testClientCertAuth)\n\n\tf.NamespacedTest(\"008-tcproute-https-termination\", testTCPRouteHTTPSTermination)\n\n\tf.NamespacedTest(\"009-https-misdirected-request\", testHTTPSMisdirectedRequest)\n\n\tf.NamespacedTest(\"010-include-prefix-condition\", testIncludePrefixCondition)\n\n\tf.NamespacedTest(\"011-retry-policy-validation\", testRetryPolicyValidation)\n\n\tf.NamespacedTest(\"012-https-fallback-certificate\", func(namespace string) {\n\t\tContext(\"with fallback certificate\", func() {\n\t\t\tBeforeEach(func() {\n\t\t\t\tcontourConfig.TLS = config.TLSParameters{\n\t\t\t\t\tFallbackCertificate: config.NamespacedName{\n\t\t\t\t\t\tName:      \"fallback-cert\",\n\t\t\t\t\t\tNamespace: namespace,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\tf.Certs.CreateSelfSignedCert(namespace, \"fallback-cert\", \"fallback-cert\", \"fallback.projectcontour.io\")\n\t\t\t})\n\n\t\t\ttestHTTPSFallbackCertificate(namespace)\n\t\t})\n\t})\n\n\tf.NamespacedTest(\"backend-tls\", func(namespace string) {\n\t\tContext(\"with backend tls\", func() {\n\t\t\tBeforeEach(func() {\n\t\t\t\t// Top level issuer.\n\t\t\t\tselfSignedIssuer := &certmanagerv1.Issuer{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tNamespace: namespace,\n\t\t\t\t\t\tName:      \"selfsigned\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: certmanagerv1.IssuerSpec{\n\t\t\t\t\t\tIssuerConfig: certmanagerv1.IssuerConfig{\n\t\t\t\t\t\t\tSelfSigned: &certmanagerv1.SelfSignedIssuer{},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\trequire.NoError(f.T(), f.Client.Create(context.TODO(), selfSignedIssuer))\n\n\t\t\t\t// CA to sign backend certs with.\n\t\t\t\tcaCertificate := &certmanagerv1.Certificate{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tNamespace: namespace,\n\t\t\t\t\t\tName:      \"ca-cert\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: certmanagerv1.CertificateSpec{\n\t\t\t\t\t\tIsCA: true,\n\t\t\t\t\t\tUsages: []certmanagerv1.KeyUsage{\n\t\t\t\t\t\t\tcertmanagerv1.UsageSigning,\n\t\t\t\t\t\t\tcertmanagerv1.UsageCertSign,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tCommonName: \"ca-cert\",\n\t\t\t\t\t\tSecretName: \"ca-cert\",\n\t\t\t\t\t\tIssuerRef: certmanagermetav1.ObjectReference{\n\t\t\t\t\t\t\tName: \"selfsigned\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\trequire.NoError(f.T(), f.Client.Create(context.TODO(), caCertificate))\n\n\t\t\t\t// Issuer based on CA to generate new certs with.\n\t\t\t\tbasedOnCAIssuer := &certmanagerv1.Issuer{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tNamespace: namespace,\n\t\t\t\t\t\tName:      \"ca-issuer\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: certmanagerv1.IssuerSpec{\n\t\t\t\t\t\tIssuerConfig: certmanagerv1.IssuerConfig{\n\t\t\t\t\t\t\tCA: &certmanagerv1.CAIssuer{\n\t\t\t\t\t\t\t\tSecretName: \"ca-cert\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\trequire.NoError(f.T(), f.Client.Create(context.TODO(), basedOnCAIssuer))\n\n\t\t\t\t// Backend client cert, can use for upstream validation as well.\n\t\t\t\tbackendClientCert := &certmanagerv1.Certificate{\n\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\t\tNamespace: namespace,\n\t\t\t\t\t\tName:      \"backend-client-cert\",\n\t\t\t\t\t},\n\t\t\t\t\tSpec: certmanagerv1.CertificateSpec{\n\t\t\t\t\t\tUsages: []certmanagerv1.KeyUsage{\n\t\t\t\t\t\t\tcertmanagerv1.UsageClientAuth,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tCommonName: \"client\",\n\t\t\t\t\t\tSecretName: \"backend-client-cert\",\n\t\t\t\t\t\tIssuerRef: certmanagermetav1.ObjectReference{\n\t\t\t\t\t\t\tName: \"ca-issuer\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\trequire.NoError(f.T(), f.Client.Create(context.TODO(), backendClientCert))\n\n\t\t\t\tcontourConfig.TLS = config.TLSParameters{\n\t\t\t\t\tClientCertificate: config.NamespacedName{\n\t\t\t\t\t\tNamespace: namespace,\n\t\t\t\t\t\tName:      \"backend-client-cert\",\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t})\n\n\t\t\ttestBackendTLS(namespace)\n\t\t})\n\t})\n\n\tf.NamespacedTest(\"014-external-auth\", testExternalAuth)\n\n\tf.NamespacedTest(\"015-http-health-checks\", testHTTPHealthChecks)\n\n\tf.NamespacedTest(\"016-dynamic-headers\", testDynamicHeaders)\n\n\tf.NamespacedTest(\"017-host-header-rewrite\", testHostHeaderRewrite)\n\n\tf.NamespacedTest(\"018-external-name-service-insecure\", func(namespace string) {\n\t\tContext(\"with ExternalName Services enabled\", func() {\n\t\t\tBeforeEach(func() {\n\t\t\t\tcontourConfig.EnableExternalNameService = true\n\t\t\t})\n\t\t\ttestExternalNameServiceInsecure(namespace)\n\t\t})\n\t})\n\n\tf.NamespacedTest(\"018-external-name-service-tls\", func(namespace string) {\n\t\tContext(\"with ExternalName Services enabled\", func() {\n\t\t\tBeforeEach(func() {\n\t\t\t\tcontourConfig.EnableExternalNameService = true\n\t\t\t})\n\t\t\ttestExternalNameServiceTLS(namespace)\n\t\t})\n\t})\n\n\tf.NamespacedTest(\"018-external-name-service-localhost\", func(namespace string) {\n\t\tContext(\"with ExternalName Services enabled\", func() {\n\t\t\tBeforeEach(func() {\n\t\t\t\tcontourConfig.EnableExternalNameService = true\n\t\t\t})\n\t\t\ttestExternalNameServiceLocalhostInvalid(namespace)\n\t\t})\n\t})\n\tf.NamespacedTest(\"019-local-rate-limiting-vhost\", testLocalRateLimitingVirtualHost)\n\n\tf.NamespacedTest(\"019-local-rate-limiting-route\", testLocalRateLimitingRoute)\n\n\tContext(\"global rate limiting\", func() {\n\t\twithRateLimitService := func(body e2e.NamespacedTestBody) e2e.NamespacedTestBody {\n\t\t\treturn func(namespace string) {\n\t\t\t\tContext(\"with rate limit service\", func() {\n\t\t\t\t\tBeforeEach(func() {\n\t\t\t\t\t\tcontourConfig.RateLimitService = config.RateLimitService{\n\t\t\t\t\t\t\tExtensionService: fmt.Sprintf(\"%s/%s\", namespace, f.Deployment.RateLimitExtensionService.Name),\n\t\t\t\t\t\t\tDomain:           \"contour\",\n\t\t\t\t\t\t\tFailOpen:         false,\n\t\t\t\t\t\t}\n\t\t\t\t\t\trequire.NoError(f.T(),\n\t\t\t\t\t\t\tf.Deployment.EnsureRateLimitResources(\n\t\t\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\t\t\t`\ndomain: contour\ndescriptors:\n  - key: generic_key\n    value: vhostlimit\n    rate_limit:\n      unit: hour\n      requests_per_unit: 1\n  - key: route_limit_key\n    value: routelimit\n    rate_limit:\n      unit: hour\n      requests_per_unit: 1\n  - key: generic_key\n    value: tlsvhostlimit\n    rate_limit:\n      unit: hour\n      requests_per_unit: 1\n  - key: generic_key\n    value: tlsroutelimit\n    rate_limit:\n      unit: hour\n      requests_per_unit: 1`))\n\t\t\t\t\t})\n\n\t\t\t\t\tbody(namespace)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tf.NamespacedTest(\"020-global-rate-limiting-vhost-non-tls\", withRateLimitService(testGlobalRateLimitingVirtualHostNonTLS))\n\n\t\tf.NamespacedTest(\"020-global-rate-limiting-route-non-tls\", withRateLimitService(testGlobalRateLimitingRouteNonTLS))\n\n\t\tf.NamespacedTest(\"020-global-rate-limiting-vhost-tls\", withRateLimitService(testGlobalRateLimitingVirtualHostTLS))\n\n\t\tf.NamespacedTest(\"020-global-rate-limiting-route-tls\", withRateLimitService(testGlobalRateLimitingRouteTLS))\n\t})\n})\n\n// httpProxyValid returns true if the proxy has a .status.currentStatus\n// of \"valid\".\nfunc httpProxyValid(proxy *contourv1.HTTPProxy) bool {\n\n\tif proxy == nil {\n\t\treturn false\n\t}\n\n\tif len(proxy.Status.Conditions) == 0 {\n\t\treturn false\n\t}\n\n\tcond := proxy.Status.GetConditionFor(\"Valid\")\n\treturn cond.Status == \"True\"\n\n}\n\n// httpProxyErrors provides a pretty summary of any Errors on the HTTPProxy Valid condition.\n// If there are no errors, the return value will be empty.\nfunc httpProxyErrors(proxy *contourv1.HTTPProxy) string {\n\tcond := proxy.Status.GetConditionFor(\"Valid\")\n\terrors := cond.Errors\n\tif len(errors) > 0 {\n\t\treturn spew.Sdump(errors)\n\t}\n\n\treturn \"\"\n}\n"], "filenames": ["cmd/contour/serve.go", "examples/contour/01-contour-config.yaml", "examples/render/contour-gateway.yaml", "examples/render/contour.yaml", "go.mod", "internal/dag/accessors.go", "internal/dag/accessors_test.go", "internal/dag/builder_test.go", "internal/dag/extension_processor.go", "internal/dag/gatewayapi_processor.go", "internal/dag/httpproxy_processor.go", "internal/dag/ingress_processor.go", "internal/dag/status_test.go", "internal/featuretests/v3/externalname_test.go", "internal/featuretests/v3/headerpolicy_test.go", "pkg/config/parameters.go", "site/content/docs/main/configuration.md", "test/e2e/httpproxy/018_external_name_test.go", "test/e2e/httpproxy/httpproxy_test.go"], "buggy_code_start_loc": [716, 53, 90, 87, 7, 54, 42, 6538, 179, 49, 58, 39, 1761, 18, 33, 537, 86, 82, 22], "buggy_code_end_loc": [740, 53, 90, 87, 7, 80, 97, 9761, 179, 750, 694, 148, 3665, 319, 34, 537, 86, 161, 282], "fixing_code_start_loc": [717, 54, 91, 88, 8, 54, 43, 6539, 180, 50, 59, 40, 1761, 19, 33, 538, 87, 82, 23], "fixing_code_end_loc": [746, 61, 98, 95, 9, 118, 165, 9823, 182, 755, 699, 153, 3665, 345, 37, 543, 88, 228, 329], "type": "CWE-610", "message": "Contour is a Kubernetes ingress controller using Envoy proxy. In Contour before version 1.17.1 a specially crafted ExternalName type Service may be used to access Envoy's admin interface, which Contour normally prevents from access outside the Envoy container. This can be used to shut down Envoy remotely (a denial of service), or to expose the existence of any Secret that Envoy is using for its configuration, including most notably TLS Keypairs. However, it *cannot* be used to get the *content* of those secrets. Since this attack allows access to the administration interface, a variety of administration options are available, such as shutting down the Envoy or draining traffic. In general, the Envoy admin interface cannot easily be used for making changes to the cluster, in-flight requests, or backend services, but it could be used to shut down or drain Envoy, change traffic routing, or to retrieve secret metadata, as mentioned above. The issue will be addressed in Contour v1.18.0 and a cherry-picked patch release, v1.17.1, has been released to cover users who cannot upgrade at this time. For more details refer to the linked GitHub Security Advisory.", "other": {"cve": {"id": "CVE-2021-32783", "sourceIdentifier": "security-advisories@github.com", "published": "2021-07-23T22:15:08.480", "lastModified": "2021-08-05T16:56:23.153", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Contour is a Kubernetes ingress controller using Envoy proxy. In Contour before version 1.17.1 a specially crafted ExternalName type Service may be used to access Envoy's admin interface, which Contour normally prevents from access outside the Envoy container. This can be used to shut down Envoy remotely (a denial of service), or to expose the existence of any Secret that Envoy is using for its configuration, including most notably TLS Keypairs. However, it *cannot* be used to get the *content* of those secrets. Since this attack allows access to the administration interface, a variety of administration options are available, such as shutting down the Envoy or draining traffic. In general, the Envoy admin interface cannot easily be used for making changes to the cluster, in-flight requests, or backend services, but it could be used to shut down or drain Envoy, change traffic routing, or to retrieve secret metadata, as mentioned above. The issue will be addressed in Contour v1.18.0 and a cherry-picked patch release, v1.17.1, has been released to cover users who cannot upgrade at this time. For more details refer to the linked GitHub Security Advisory."}, {"lang": "es", "value": "Contour es un controlador de entrada de Kubernetes usando el proxy Envoy. En Contour versiones anteriores a 1.17.1 se puede usar un servicio de tipo ExternalName especialmente dise\u00f1ado para acceder a la interfaz de administraci\u00f3n de Envoy, que Contour normalmente impide el acceso fuera del contenedor Envoy. Esto puede ser usado para cerrar Envoy de forma remota (una denegaci\u00f3n de servicio), o para exponer la existencia de cualquier secreto que Envoy est\u00e9 usando para su configuraci\u00f3n, incluyendo especialmente los pares de claves TLS. Sin embargo, *no* puede ser usado para obtener el *contenido* de esos secretos. Dado que este ataque permite el acceso a la interfaz de administraci\u00f3n, se presentan diversas opciones de administraci\u00f3n, como apagar el Envoy o drenar el tr\u00e1fico. En general, la interfaz de administraci\u00f3n de Envoy no puede ser usada f\u00e1cilmente para realizar cambios en el cluster, las peticiones en vuelo o los servicios backend, pero podr\u00eda ser usado para apagar o drenar Envoy, cambiar el enrutamiento del tr\u00e1fico o recuperar metadatos secretos, como se ha mencionado anteriormente. El problema se abordar\u00e1 en Contour versi\u00f3n v1.18.0 y ha sido lanzado una versi\u00f3n de parche, versi\u00f3n v1.17.1, para cubrir a usuarios que no pueden actualizar en este momento. Para m\u00e1s detalles, consulte el aviso de seguridad de GitHub"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-610"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-441"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:projectcontour:contour:*:*:*:*:*:kubernetes:*:*", "versionEndExcluding": "1.17.1", "matchCriteriaId": "C1D1AE1D-573C-4C57-8117-914E6FB9C7AF"}]}]}], "references": [{"url": "https://github.com/projectcontour/contour/commit/b53a5c4fd927f4ea2c6cf02f1359d8e28bef852e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/projectcontour/contour/releases/tag/v1.17.1", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/projectcontour/contour/security/advisories/GHSA-5ph6-qq5x-7jwc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/projectcontour/contour/commit/b53a5c4fd927f4ea2c6cf02f1359d8e28bef852e"}}